<html>
<head>
<title>Making Python Programs Blazingly Fast</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让Python程序快得惊人</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/making-python-programs-blazingly-fast-c1cd79bd1b32?source=collection_archive---------0-----------------------#2020-01-01">https://towardsdatascience.com/making-python-programs-blazingly-fast-c1cd79bd1b32?source=collection_archive---------0-----------------------#2020-01-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0f5f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们看看我们的Python程序的性能，看看如何使它们的速度提高30%！</h2></div><p id="0663" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">讨厌Python的人总是说，他们不想使用它的原因之一是它太慢了。不管使用何种编程语言，特定程序的速度是快还是慢在很大程度上取决于编写该程序的开发人员以及他们编写<em class="le">优化</em>和<em class="le">快速</em>程序的技能和能力。</p><p id="c70e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，让我们证明一些人是错的，让我们看看如何提高我们的<em class="le"> Python </em>程序的性能，让它们变得非常快！</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/e3e80cc0a51ed8433fa43107ae728cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RwPxbojXh4PMTkCgPeVMhw.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">由unsplash上的<a class="ae lv" href="https://unsplash.com/@veri_ivanova" rel="noopener ugc nofollow" target="_blank"> @veri_ivanova </a></p></figure><h1 id="4b22" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">计时和分析</h1><p id="92b5" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在我们开始优化任何东西之前，我们首先需要找出我们的代码的哪些部分实际上减慢了整个程序。有时程序的瓶颈可能很明显，但如果您不知道它在哪里，那么您可以通过以下方法找到它:</p><p id="420f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">注意:这是我将用于演示目的的程序，它计算</em><code class="fe mt mu mv mw b"><em class="le">e</em></code><em class="le"/><code class="fe mt mu mv mw b"><em class="le">X</em></code><em class="le">(取自Python文档):</em></p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="bfe7" class="mz lx it bd ly na nb dn mc nc nd dp mg kr ne nf mi kv ng nh mk kz ni nj mm nk bi translated">最懒的“侧写”</h2><p id="8158" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">首先，最简单也是非常懒惰的解决方案——Unix<code class="fe mt mu mv mw b">time</code>命令:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a7bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你只是想为你的整个程序计时，这是可行的，但通常是不够的…</p><h2 id="d307" class="mz lx it bd ly na nb dn mc nc nd dp mg kr ne nf mi kv ng nh mk kz ni nj mm nk bi translated">最详细的剖析</h2><p id="762d" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">光谱的另一端是<code class="fe mt mu mv mw b">cProfile</code>，它会给你<em class="le">太多的</em>信息:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="18fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我们使用<code class="fe mt mu mv mw b">cProfile</code>模块和<code class="fe mt mu mv mw b">time</code>参数运行测试脚本，这样代码行按照内部时间(<code class="fe mt mu mv mw b">cumtime</code>)排序。这给了我们很多信息，你在上面看到的线大约是实际输出的10%。由此，我们可以看到<code class="fe mt mu mv mw b">exp</code>函数是罪魁祸首(<em class="le">意外，意外</em>)，现在我们可以得到更多关于计时和分析的细节...</p><h2 id="c857" class="mz lx it bd ly na nb dn mc nc nd dp mg kr ne nf mi kv ng nh mk kz ni nj mm nk bi translated">定时特定功能</h2><p id="134d" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">既然我们知道了应该把注意力放在哪里，我们可能想要对慢速函数计时，而不需要测量代码的其余部分。为此，我们可以使用简单的装饰器:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9282" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，可以将这个装饰器应用于测试中的函数，如下所示:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6530" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这给了我们这样的输出:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1108" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要考虑的一件事是我们实际(想要)测量的是什么样的时间。时间包提供<code class="fe mt mu mv mw b">time.perf_counter</code>和<code class="fe mt mu mv mw b">time.process_time</code>。这里的区别是<code class="fe mt mu mv mw b">perf_counter</code>返回绝对值，其中包括Python程序进程不运行的时间，因此可能会受到机器负载的影响。另一方面，<code class="fe mt mu mv mw b">process_time</code>只返回<em class="le">用户时间</em>(不包括<em class="le">系统时间</em>)，这只是你的进程的时间。</p><h1 id="06af" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">让它更快</h1><p id="c3d7" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">现在，有趣的是。让我们让你的Python程序运行得更快。我(大部分)不会向您展示一些能够神奇地解决您的性能问题的技巧、诀窍和代码片段。这更多的是关于一般的想法和策略，当使用时，可以对性能产生巨大的影响，在某些情况下可以提高30%。</p><h2 id="e494" class="mz lx it bd ly na nb dn mc nc nd dp mg kr ne nf mi kv ng nh mk kz ni nj mm nk bi translated">使用内置数据类型</h2><p id="dce1" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这个很明显。内置数据类型非常快，尤其是与我们的自定义类型如树或链表相比。那主要是因为内置是用<em class="le"> C </em>实现的，用Python编码的时候我们在速度上确实比不上。</p><h2 id="9b61" class="mz lx it bd ly na nb dn mc nc nd dp mg kr ne nf mi kv ng nh mk kz ni nj mm nk bi translated">使用lru_cache进行缓存/记忆</h2><p id="2697" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我已经在之前的博客文章<a class="ae lv" href="https://martinheinz.dev/blog/4" rel="noopener ugc nofollow" target="_blank">中展示过这一点，但是我认为有必要用一个简单的例子来重复一下:</a></p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9e9f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的函数使用<code class="fe mt mu mv mw b">time.sleep</code>模拟繁重的计算。当用参数<code class="fe mt mu mv mw b">1</code>第一次调用时，它等待2秒，然后才返回结果。再次调用时，结果已经被缓存，所以它跳过函数体并立即返回结果。更多现实生活中的例子请看之前的博文<a class="ae lv" href="https://martinheinz.dev/blog/4" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="be4a" class="mz lx it bd ly na nb dn mc nc nd dp mg kr ne nf mi kv ng nh mk kz ni nj mm nk bi translated">使用局部变量</h2><p id="54f3" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这与在每个作用域中查找变量的速度有关。我正在编写每个作用域的<em class="le">，因为这不仅仅是关于使用局部变量还是全局变量。实际上，查找速度甚至在函数中的局部变量(最快)、类级属性(例如<code class="fe mt mu mv mw b">self.name</code> -较慢)和全局变量(例如像<code class="fe mt mu mv mw b">time.time</code>(最慢)之间也有差异。</em></p><p id="9271" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过使用看似不必要的(直接无用的)赋值来提高性能，如下所示:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="e289" class="mz lx it bd ly na nb dn mc nc nd dp mg kr ne nf mi kv ng nh mk kz ni nj mm nk bi translated">使用功能</h2><p id="f4ac" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这可能看起来与直觉相反，因为调用函数会将更多的东西放入堆栈，并从函数返回中产生开销，但这与前一点有关。如果你只是把你的整个代码放在一个文件中，而没有把它放入函数中，那么会因为全局变量而慢很多。因此，您可以通过将整个代码包装在<code class="fe mt mu mv mw b">main</code>函数中并调用一次来加速您的代码，就像这样:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="5416" class="mz lx it bd ly na nb dn mc nc nd dp mg kr ne nf mi kv ng nh mk kz ni nj mm nk bi translated">不要访问属性</h2><p id="b75f" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">另一个可能降低程序速度的是<em class="le">点运算符</em> ( <code class="fe mt mu mv mw b">.</code>)，它在访问对象属性时使用。该操作符使用<code class="fe mt mu mv mw b">__getattribute__</code>触发字典查找，这会在代码中产生额外的开销。那么，如何才能真正避免(限制)使用它呢？</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="dc29" class="mz lx it bd ly na nb dn mc nc nd dp mg kr ne nf mi kv ng nh mk kz ni nj mm nk bi translated">当心绳子</h2><p id="d437" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">当使用例如<em class="le">模数</em> ( <code class="fe mt mu mv mw b">%s</code>)或<code class="fe mt mu mv mw b">.format()</code>在循环中运行时，字符串上的操作会变得相当慢。我们还有什么更好的选择？根据Raymond Hettinger 最近的<a class="ae lv" href="https://twitter.com/raymondh/status/1205969258800275456" rel="noopener ugc nofollow" target="_blank">推文，我们唯一应该使用的是<em class="le"> f-string </em>，这是最易读、最简洁和最快的方法。所以，根据那条微博，这是你可以使用的方法列表——从最快到最慢:</a></p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c75c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成器并不是天生就更快，因为它们是为惰性计算而设计的，惰性计算节省了内存而不是时间。然而，节省下来的内存可能会导致程序实际上运行得更快。怎么会？嗯，如果你有一个大的数据集，并且你没有使用生成器(迭代器)，那么数据可能会溢出CPU<em class="le">L1缓存</em>，这将大大降低在内存中查找值的速度。</p><p id="5a53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就性能而言，非常重要的一点是，CPU可以尽可能接近地保存它正在处理的所有数据，这些数据位于缓存中。你可以观看Raymond Hettingers的演讲，他在演讲中提到了这些问题。</p><h1 id="cac9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="f5b9" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">优化的第一条规则是<em class="le">不做</em>。但是，如果你真的不得不这样做，那么我希望这几条建议能帮到你。然而，在优化你的代码时要小心，因为它可能最终使你的代码难以阅读，从而难以维护，这可能超过优化的好处。</p><p id="fbcd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">注:此文最初发布于</em><a class="ae lv" href="https://martinheinz.dev/blog/13" rel="noopener ugc nofollow" target="_blank"><em class="le">martinheinz . dev</em></a></p></div></div>    
</body>
</html>