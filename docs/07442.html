<html>
<head>
<title>Geometric Interpretation of Logistic Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑回归的几何解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/geometric-interpretation-of-logistic-regression-4f85047a5860?source=collection_archive---------27-----------------------#2020-06-05">https://towardsdatascience.com/geometric-interpretation-of-logistic-regression-4f85047a5860?source=collection_archive---------27-----------------------#2020-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d8f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解如何使用几何解释导出逻辑回归的成本函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eca9d713e857fb60555340622406e15a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4JU9417TsJAvl24j"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae ky" href="https://unsplash.com/@thisisengineering?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a></p></figure><p id="d943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">逻辑回归是一种统计模型，它使用逻辑函数来模拟二元因变量。在几何解释术语中，逻辑回归试图找到一条线或一个平面来最好地区分这两类。逻辑回归处理几乎或完全线性可分的数据集。</p><blockquote class="lv lw lx"><p id="f8b5" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">术语线性可分是什么意思？</strong></p></blockquote><p id="9671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于二元分类数据集，如果一条直线或一个平面可以几乎或完全分隔两个类，那么这样的数据集称为线性可分数据集。否则，如果这两个类不能被线或平面分开，则数据集不是线性可分的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/2066086535eac6790ecdfc3774c7f45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i-xfThS4fxywMzp-C4_NJw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">左图:线性分离，右图:非线性分离</p></figure><p id="4c41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的二维样本数据集中，左边的样本数据集几乎可以用一条线线性分离，而对于右边的样本数据集，没有一条线可以将这两类点分开。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/9bfc96b4b8327e453d27e488884e09a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*13F9om4JUUio1Cbw6pZVxQ.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片 2</p></figure><p id="0808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在(图 2)中，该线最好地分隔了两类点，错误分类了 3 个点(红色圆圈)。</p><blockquote class="lv lw lx"><p id="01cd" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">深入推导算法的几何解释:</strong></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi me"><img src="../Images/d5002c99370c391c739738c0123b73f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*rMUBWr-6RF04TajdS0P32A.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 3: Xi 和 Xj 是正确分类的点</p></figure><p id="66d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于上面的样本数据集，假设我们需要找到一个平面‘P’来分隔这两个类。</p><p id="af91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">平面的一般方程由下式给出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/ddcf1f2951527111324d6a86befacc66.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*KPR-PUsXGp4rKeK8bRqb7w.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/c56d89a8d1aaa7a245b44acb350dff6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*nJW8hM53abqGx9N9PEMnVA.png"/></div></figure><p id="86a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以最后我们需要找到一个平面 P。设这两类点为 y_i = {1，-1}。对于任意两个随机点 x_i 和 x_j。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/27bd78bcee333faab0e3c5a40323ccf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*qq4Y72f2GxVDFbnfO9NSmg.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/260ba6b6430ac302df92c18d910c94df.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/1*cnqhZA5VmpzMEFpZxaRZyg.png"/></div></div></figure><p id="5c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">d_i =平面和 x_i 之间的距离</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/4db6cfa56d98577c95f85fb86fe27d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*TOk2BzAUPQ0SxZR8D9rcQA.png"/></div></figure><p id="8869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">d_j =平面和 x_j 之间的距离</p><p id="2d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里 W 垂直于平面。当一个点的方向垂直于平面时，那么距离为正，否则为负。</p><p id="20ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于正确分类的点(图 3):</p><p id="5cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> d_i &gt; 0 </strong>和<strong class="lb iu"> d_j &lt; 0 </strong></p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="8f15" class="mp mq it ml b gy mr ms l mt mu">Now for a positive class point: <strong class="ml iu">y_i = +1</strong><br/><strong class="ml iu">(d_i * y_i) &gt; 0</strong>, since <strong class="ml iu">d_i &gt; 0 </strong>and <strong class="ml iu">y_i &gt; 0</strong></span><span id="6077" class="mp mq it ml b gy mv ms l mt mu">For a negative class point: <strong class="ml iu">y_i = -1</strong><br/><strong class="ml iu">(d_i * y_i) &gt; 0, </strong>since <strong class="ml iu">d_i &lt; 0 </strong>and <strong class="ml iu">y_i &lt; 0</strong></span></pre><p id="28ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以对于正确分类的点，<strong class="lb iu"> (y_i * d_i)总是正的</strong></p><p id="f29f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于错误分类的点(图 4):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/09661b36f03a1349f661f1bb04b6ccd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*C_9o-V8HXabrzb9Z3IbR6w.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 4: Xi 和 Xj 是错误分类的点</p></figure><p id="f6bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> d_i &lt; 0 </strong>和<strong class="lb iu"> d_j &gt; 0 </strong></p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="4cd6" class="mp mq it ml b gy mr ms l mt mu">For a positive class point: <strong class="ml iu">y_i = +1</strong><br/><strong class="ml iu">(d_i * y_i) &lt; 0</strong>, since <strong class="ml iu">y_i &gt; 0 and d_i &lt; 0 (because on wrong side)</strong></span><span id="bc31" class="mp mq it ml b gy mv ms l mt mu">For a negative class point: <strong class="ml iu">y_i = -1</strong><br/><strong class="ml iu">(d_i * y_i) &lt; 0, </strong>since <strong class="ml iu">d_i &gt; 0 </strong>and <strong class="ml iu">y_i &lt; 0 (because on wrong side)</strong></span></pre><p id="6a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于错误分类的点，<strong class="lb iu"> (y_i * d_i)总是负的</strong></p><p id="75ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了得到最优解，我们需要最大化<strong class="lb iu"> (y_i * d_i)。</strong>我们需要找到最优的 W，w0，它使下面的等式最大化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/1635a83ade695869223c8b03dfa2733e.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*n1HfNBfX6q0agvEN1wSK7A.png"/></div></figure><blockquote class="lv lw lx"><p id="a83e" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">乙状结肠挤压:</strong></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/f9831fa4dc83028b6e50346f0380bd27.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*1YmHqnQvz4OibS2i9lkODg.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 4</p></figure><p id="1960" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于存在负类的离群点，因此上面获得的成本函数将获得平面“P2”作为最佳平面，但这不是真的。平面“P1”最好地分隔了这两类点。</p><p id="509f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异常值或极值点的存在会在很大程度上影响平面。为了避免这种情况，我们需要找到一个函数，使<strong class="lb iu"> (y_i * d_i) </strong>值变小，如果它太大，id <strong class="lb iu"> (y_i * d_i) </strong>值变小，它应该保持小。</p><p id="6999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要这样一个函数</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/08d300744ab8e8e48dbcf472b39149b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*mZNwsKGa9s04tOFHSxsENA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 5</p></figure><p id="3ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果 x 的值很大，那么 f(x)逐渐变小，如果 x 的值很小，那么它仍然很小。</p><blockquote class="lv lw lx"><p id="54fd" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">乙状结肠功能:</strong></p></blockquote><p id="f940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">sigmoid 函数的图形清楚地定义了它满足我们的条件。sigmoid 函数的数学方程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/c69a046274d75963a9541d85dc9ca0ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*8mf30vONKYOc_1BuKmP6cQ.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/eb92ad4d54b507e8605ad375cf54942b.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*G3TTxOEMIqUqgd4wKXeqkQ.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Google Plots，图片 6，sigmoid 函数的绘图</p></figure><p id="6618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们的方程式可以归结为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/45abbfdaa4accc84f55ee2e43e121ce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*FVkGLxrTCncq60SiHahXmQ.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/97ff21a8c525389388483a61aa05f85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*G2hHSN8QFIQSLBOs116IPg.png"/></div></figure><blockquote class="lv lw lx"><p id="e51b" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">最小化方程式:</strong></p></blockquote><p id="fc55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果 G(x)是单调递增函数，那么 G(F(x))也是单调递增函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/6c6d1eedfc8335fda15c8a5e63e57117.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*g54MsPy8OIf9pGVCLIfYeQ.png"/></div></figure><p id="3997" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把 F(x)作为上面推导的方程，G(x)作为 log(x)作为 log(x)是一个单调递增的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/02bba419ed61b42df77c40fa4398ff87.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*8qG1fFjBpvXt7xwuSUckFQ.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Google Plots，图 7，log_e(x)的绘图</p></figure><blockquote class="lv lw lx"><p id="74f7" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">方程式归结为:</strong></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/234f7b8b2e7622391bd4692edfa882f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*Jn_dO8oc4y78TPRKxjdEtw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/18ffb741f9cc0f93b1838e75b0bf5c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*KhFL6ulydgfgQog550CfdQ.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/70ce600fbca856461ae637ecaa713189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*Y-aHMeLDCwuPHalSRq_t8g.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/67091558a94693ddcb1512c5ddbc5bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*_7ou84zBbfVahPg2gDLuWA.png"/></div></figure><blockquote class="lv lw lx"><p id="f804" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">正规化:</strong></p></blockquote><p id="0458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为 log_e(z)的最小值是 0。因此，优化器将尝试将上述等式的值最小化为 0，这使得 log_e(z)的‘z’= 1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a9d4ae2f99fa4c569942ed2c403c4c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*lb76a8Rdy-U_GwGmd8OqaA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d4acdef1e4dd148e87fac2363db123ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*eSOzCBHM0Ad7EqWjn2ysrw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/690b88a99ae07d0044ac71353aa283a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*hwxOxDRw-iqo_bcGGR2FmQ.png"/></div></figure><p id="d31d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以 W，w0 趋向于无穷大来满足方程，这就趋向于进行逻辑回归。</p><blockquote class="lv lw lx"><p id="676a" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">添加 L2 正则化:</strong></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/2fa6b43e137188951141a636623cdd74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K2ouvMNocm_x19R61eKaVA.png"/></div></div></figure><p id="f744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面导出的等式是逻辑回归算法的成本函数。我们使用优化器来计算使上述成本函数最小化的最佳值<strong class="lb iu"> W，w0</strong>。<em class="ly">【lambda】</em>上式中的‘lambda’是超参数。</p><blockquote class="lv lw lx"><p id="c884" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">偏差方差权衡:</strong></p></blockquote><p id="0064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果λ= 0，则上述方程将不包含任何会使模型过拟合的正则化项。</p><p id="ff35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果 lambda -&gt; infinite(大值)，则正则化项的权重非常高，并且它将遮蔽该项的其余部分，这导致欠拟合模型。</p><blockquote class="lv lw lx"><p id="4634" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">预测查询点的目标类别:</strong></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/629ebc507a74446c06d0d29c4ac0ac41.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*5unXOb4c_qRX7MWh_g9-fw.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 7:查询</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e802311cd6c0aab6de43531b304b2705.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*aMA9fq-1DWZSN8d2QUJ9pQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">w，w0 通过最小化成本函数来计算</p></figure><p id="2d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于查询' q1 '，<strong class="lb iu">y _ pred&gt;0</strong>(W 方向的 q1)</p><p id="ad03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于查询' q2 '，<strong class="lb iu"> y_pred &lt; 0 </strong>(与 W 方向相反的 q2)</p><blockquote class="nq"><p id="7854" class="nr ns it bd nt nu nv nw nx ny nz lu dk translated">感谢您的阅读！</p></blockquote></div></div>    
</body>
</html>