<html>
<head>
<title>mlmachine - Clean ML Experiments, Elegant EDA &amp; Pandas Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">mlmachine -干净的 ML 实验，优雅的 EDA 和 Pandas 管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mlmachine-clean-ml-experiments-elegant-eda-pandas-pipelines-daba951dde0a?source=collection_archive---------23-----------------------#2020-04-03">https://towardsdatascience.com/mlmachine-clean-ml-experiments-elegant-eda-pandas-pipelines-daba951dde0a?source=collection_archive---------23-----------------------#2020-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/490722b36e9acc37a934b7ebe5d9f904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqjQ6XHJkzch4HuCtTv9LQ.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自<a class="ae jd" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=242558" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jd" href="https://pixabay.com/users/PixelAnarchy-555/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=242558" rel="noopener ugc nofollow" target="_blank">像素体系</a>的图像</p></figure><h2 id="f743" class="je jf jg bd b dl jh ji jj jk jl jm dk jn translated" aria-label="kicker paragraph">多层机器</h2><div class=""/><div class=""><h2 id="9920" class="pw-subtitle-paragraph km jp jg bd b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dk translated">这个新的 Python 包加速了基于笔记本的机器学习实验</h2></div><h2 id="1bda" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated"><strong class="ak">TL；博士</strong></h2><p id="25bc" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">mlmachine 是一个 Python 库，用于组织和加速基于笔记本的机器学习实验。</p><p id="3934" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">在本文中，我们使用 mlmachine 来完成原本需要大量编码和工作的操作，包括:</p><ul class=""><li id="513c" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr nc nd ne nf bi translated">数据输入和特征类型识别</li><li id="3649" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">简单、优雅的探索性数据分析</li><li id="37f9" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">熊猫进出管道</li></ul><p id="3bd9" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">查看这篇文章的<a class="ae jd" href="https://github.com/petersontylerd/mlmachine/blob/master/notebooks/mlmachine_part_1.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>。</p><p id="62a5" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">在 GitHub 上查看<a class="ae jd" href="https://github.com/petersontylerd/mlmachine" rel="noopener ugc nofollow" target="_blank">项目</a>。</p><p id="19af" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">查看 mlmachine 系列的其他条目:</p><div class="ip iq gp gr ir nl"><a rel="noopener follow" target="_blank" href="/mlmachine-groupbyimputer-kfoldencoder-and-skew-correction-357f202d2212"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd jq gy z fp nq fr fs nr fu fw jp bi translated">ml machine-group by inputr、KFoldEncoder 和倾斜校正</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">这个新的 Python 包加速了基于笔记本的机器学习实验</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ix nl"/></div></div></a></div><div class="ip iq gp gr ir nl"><a rel="noopener follow" target="_blank" href="/mlmachine-crowd-sourced-feature-selection-50cd2bbda1b7"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd jq gy z fp nq fr fs nr fu fw jp bi translated">mlmachine -众包特征选择</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">这个新的 Python 包加速了基于笔记本的机器学习实验</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz ix nl"/></div></div></a></div></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="7e69" class="oi lf jg bd lg oj ok ol lj om on oo lm kv op kw lq ky oq kz lu lb or lc ly os bi translated"><strong class="ak">什么是 mlmachine？</strong></h1><p id="c516" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">笔记本通常充当数据科学家的草稿纸。机器学习实验往往会变成一系列杂乱无序的硬编码块。即使花时间编写通用功能，这些功能也是孤立的，无用地与新项目隔离开来。</p><p id="345f" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">mlmachine 是一个 Python 包，它有助于进行整洁有序的基于笔记本的机器学习实验，并完成实验生命周期的许多关键方面。</p><p id="4312" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">mlmachine 的中枢是<code class="fe ot ou ov ow b"><strong class="mb jq">Machine()</strong></code>级。<code class="fe ot ou ov ow b"><strong class="mb jq">Machine()</strong></code>对象保留数据集、目标数据和特征元数据。更重要的是，<code class="fe ot ou ov ow b"><strong class="mb jq">Machine()</strong></code>对象有许多内置方法，用于快速执行机器学习实验工作流的关键部分。</p><p id="f132" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">以下是我们将详细探讨的 mlmachine 功能的几个核心领域:</p><ol class=""><li id="d01a" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr ox nd ne nf bi translated"><strong class="mb jq">数据摄取&amp; </strong> <code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtype</strong></code> <strong class="mb jq">识别</strong></li><li id="6519" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr ox nd ne nf bi translated"><strong class="mb jq">探索性数据分析</strong> -下面是一个例子，展示了为一个特性创建一个可视化和数据汇总面板是多么容易:</li></ol><figure class="oy oz pa pb gt is"><div class="bz fp l di"><div class="pc pd l"/></div></figure><figure class="oy oz pa pb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pe"><img src="../Images/beb9b8fa6e434d03d6d82a3e46fca1df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWGhtpbTjFuwu8sY21HeEQ.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">彻底的 EDA，简单的执行</p></figure><p id="77be" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">3.<strong class="mb jq">熊猫友好的变压器和管道</strong>——看看简单地将 mlmachine 实用程序<code class="fe ot ou ov ow b"><strong class="mb jq">PandasTransformer()</strong></code>包裹在<code class="fe ot ou ov ow b"><strong class="mb jq">OneHotEncoder()</strong></code> <strong class="mb jq"> </strong>周围是如何维护我们的<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>:</p><figure class="oy oz pa pb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pf"><img src="../Images/3b35571ff8305d595589e2fad1864e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CxCe-sTt8yAU5t5db77P3A.jpeg"/></div></div></figure><p id="10e4" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">mlmachine 包含大量旨在节省时间和提高模型性能的功能，同时保持我们的工作流程整洁有序。</p><p id="af6a" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">让我们开始吧。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="a9f9" class="oi lf jg bd lg oj ok ol lj om on oo lm kv op kw lq ky oq kz lu lb or lc ly os bi translated">机器类-有许多辐条的轮毂</h1><h2 id="7bc7" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated"><strong class="ak">数据摄取</strong></h2><p id="b1cc" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">我们首先实例化一个<code class="fe ot ou ov ow b"><strong class="mb jq">Machine()</strong></code> <strong class="mb jq"> </strong>对象:</p><figure class="oy oz pa pb gt is"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="794b" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">让我们打开刚才做的东西。使用规范的 Titanic 数据集，我们通过以下方式实例化一个名为<code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_titanic</strong></code>的<code class="fe ot ou ov ow b"><strong class="mb jq">Machine()</strong></code> <strong class="mb jq"> </strong>对象:</p><ul class=""><li id="4df1" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr nc nd ne nf bi translated">将整个数据集作为一个<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>传入</li><li id="5216" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">指定包含目标变量的列</li><li id="8a94" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">将监督学习任务指定为分类任务</li></ul><p id="4f52" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_titanic</strong></code> <strong class="mb jq"> </strong>最基本的目的是维护我们的观察数据集和我们的目标值。我们的数据集存储为<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code> <strong class="mb jq"> </strong>，可以通过调用<code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_titanic.data</strong></code>来访问:</p><figure class="oy oz pa pb gt is"><div class="bz fp l di"><div class="pc pd l"/></div></figure><figure class="oy oz pa pb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pg"><img src="../Images/da4df39fb5c187ee5c8d8c617ab2d915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTSk_ub6sPgMzdkp8YAkIg.png"/></div></div></figure><p id="f9a0" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">我们的目标变量存储为一个名为 Pandas <code class="fe ot ou ov ow b"><strong class="mb jq">Series</strong></code>的变量，可以通过调用<code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_titanic.target</strong></code>轻松访问:</p><figure class="oy oz pa pb gt is"><div class="bz fp l di"><div class="pc pd l"/></div></figure><figure class="oy oz pa pb gt is gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/76939d2be86aa4dedd9536c933667348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*MN3NZ-jiGCM9ort4iIjSXw.png"/></div></figure><p id="6a94" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">如果需要，目标值将被自动标记编码。</p><p id="be8e" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">我们还将几个包含特性名称的列表传递给参数，如<code class="fe ot ou ov ow b"><strong class="mb jq">identify_as_continuous</strong></code> <strong class="mb jq"> </strong>和<code class="fe ot ou ov ow b"><strong class="mb jq">identify_as_nominal</strong></code>。让我们来看看这些参数的用途。</p><h2 id="431f" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated">传销数据类型:为熊猫数据类型添加功能含义</h2><p id="d429" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">Pandas dtypes 描述了包含在一个列中的值，但是不考虑这些值的实际含义<em class="pi"/>。名词性范畴、序数范畴、连续数字、计数……通常不可能单独从熊猫数据类型中做出这些区分。</p><p id="2606" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">在 mlmachine 生态系统中，这些区别被称为<code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>。mlmachine 编目，最重要的是，<em class="pi">随着数据集在特征工程中的发展而更新</em> <code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>。</p><p id="0268" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">我们的数据集存储为<code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_titanic.data</strong></code>，有一个名为<code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>的元数据属性:</p><figure class="oy oz pa pb gt is"><div class="bz fp l di"><div class="pc pd l"/></div></figure><figure class="oy oz pa pb gt is gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/3941d3e33aa466bf9d028a4b9acb5af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*TGadLSuvT4a8a_f_AXlgzw.png"/></div></figure><p id="f9b9" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">这个字典是 mlmachine 工作流的基石，渗透到了包的所有功能中。注意字典的键。根据我们在实例化<code class="fe ot ou ov ow b"><strong class="mb jq">Machine()</strong></code>对象时提供的指导，<code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>存储每个特性的 mlm dtype。</p><p id="f2c4" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">字典键使得引用某种类型的所有特性变得特别容易，而不必键入特性名称。这样做的实际好处是显而易见的，尤其是当我们考虑的数据集比这个巨大的数据集还要大的时候。</p><p id="9d20" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">在本文中，我们将在两个关键领域利用这种效率:</p><ul class=""><li id="2d84" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr nc nd ne nf bi translated">探索性数据分析</li><li id="6200" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">转换和管道</li></ul><p id="71e2" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">让我们在介绍 mlmachine 的探索性数据分析功能时使用<code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="e791" class="oi lf jg bd lg oj ok ol lj om on oo lm kv op kw lq ky oq kz lu lb or lc ly os bi translated">因为 EDA 很繁琐，而且永远都用不完</h1><p id="f951" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">我们都为执行粗略的 EDA 而感到内疚，如果有的话(“让我们开始模型训练吧！”).即使有了所有优秀的 Python 可视化库，EDA 也需要进行大量的设置。我们都在做的事情是，第一百次编写那些相同的、稍加修改的函数。记住哪种可视化类型最适合哪种特征类型以及特征/目标类型的组合并不容易。</p><p id="65c8" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">跳过 EDA 绝对是一个错误，因此 mlmachine 的一部分功能致力于快速制作既有益又好看的面板。</p><h2 id="101e" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated">分类特征面板</h2><p id="a30b" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">我们在介绍中看到了一个名为“apolloed”的分类特性的 EDA 面板。让我们超越这个例子，使用我们的<code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>字典为我们在<code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_titanic.data</strong></code>中的所有分类特征快速生成面板:</p><figure class="oy oz pa pb gt is"><div class="bz fp l di"><div class="pc pd l"/></div></figure><figure class="oy oz pa pb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pk"><img src="../Images/715ee9479b3875fc77d4a7ba94119268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KRCaTNizHkSzvUPDfC0JEw.gif"/></div></div></figure><p id="3d9d" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><code class="fe ot ou ov ow b"><strong class="mb jq">eda_cat_target_cat_feat()</strong></code>为分类目标环境中的分类或计数特征生成 EDA 面板。顶部有三个汇总表:</p><ol class=""><li id="946c" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr ox nd ne nf bi translated">特性摘要——类别中每个级别的简单计数，以及每个级别在特性中所占的百分比。</li><li id="718c" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr ox nd ne nf bi translated">功能与目标摘要-类别中每个级别的计数，按目标中的类分组</li><li id="d69c" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr ox nd ne nf bi translated">目标比例-特定特征级别值的百分比，按目标中的类分组。</li></ol><p id="1d94" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">该面板包括三个可视化。从左至右:</p><ol class=""><li id="0e86" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr ox nd ne nf bi translated">分类特征的树形图。</li><li id="4a71" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr ox nd ne nf bi translated">分类特征的条形图，按目标分面。</li><li id="6911" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr ox nd ne nf bi translated">按目标分面的 100%水平堆积条形图。</li></ol><p id="6038" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><strong class="mb jq">轻松扩展到多类问题</strong></p><p id="248e" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">现在让我们使用<code class="fe ot ou ov ow b"><strong class="mb jq">eda_cat_target_cat_feat()</strong></code>为一个多类示例生成一个面板。我们将使用 Scikit-learn wine 数据集来可视化一个名为“alcalinity_of_ash”的数字特征，该数字特征已被分成 5 个箱，实际上使其成为一个分类列:</p><figure class="oy oz pa pb gt is"><div class="bz fp l di"><div class="pc pd l"/></div></figure><figure class="oy oz pa pb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pl"><img src="../Images/0d070ab6fee71b06fc432e195d5e701f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kNfX1K9o0KcxE7thzrRycQ.png"/></div></div></figure><p id="09de" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">面板的每个组件都相应地适应该数据集中的多类问题。</p><h2 id="14af" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated">连续特征面板</h2><p id="4327" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">现在让我们看看 mlmachine 可以对数字特征做些什么:</p><figure class="oy oz pa pb gt is"><div class="bz fp l di"><div class="pc pd l"/></div></figure><figure class="oy oz pa pb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pm"><img src="../Images/27081d21439996658b5a78fe97b22035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3rWXJjQLQ3mwcIu8D3lKsg.png"/></div></div></figure><p id="bd81" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><code class="fe ot ou ov ow b"><strong class="mb jq">eda_cat_target_num_feat()</strong></code> <strong class="mb jq"> </strong>是一个<strong class="mb jq"> </strong>方法，在分类目标的上下文中为数字特征生成一个面板。在顶部，我们展示了三只熊猫<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrames</strong></code>:</p><ol class=""><li id="937d" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr ox nd ne nf bi translated">特性概要——我们通过执行标准的<code class="fe ot ou ov ow b"><strong class="mb jq">df.describe()</strong></code>命令得到的所有概要统计数据，加上“缺失百分比”、“偏斜”和“峰度”。</li><li id="3d9e" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr ox nd ne nf bi translated">特征与目标摘要-数字特征的计数、比例、平均值和标准差，按目标中的不同类别分组。</li><li id="3537" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr ox nd ne nf bi translated">统计测试——如果目标列只有两个类，则报告 z 测试(或 t 测试，在小样本的情况下)的结果和相关的 p 值。</li></ol><p id="ea65" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">汇总表下面是一个包含四种可视化效果的面板。从左上角开始，从左到右:</p><ol class=""><li id="865c" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr ox nd ne nf bi translated">数字特征的单变量分布图。</li><li id="ccd4" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr ox nd ne nf bi translated">数字特征的 QQ 图。</li><li id="9e9c" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr ox nd ne nf bi translated">由目标分面的数值特征的二元分布图。</li><li id="7a4a" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr ox nd ne nf bi translated">由目标分面的水平方框图。</li></ol><p id="9779" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><strong class="mb jq">对多类问题的另一种毫不费力的扩展</strong></p><p id="a9c2" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><code class="fe ot ou ov ow b"><strong class="mb jq">eda_cat_target_num_feat()</strong></code>还能轻松适应多类问题。让我们看另一个简单的例子:</p><figure class="oy oz pa pb gt is"><div class="bz fp l di"><div class="pc pd l"/></div></figure><figure class="oy oz pa pb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pn"><img src="../Images/eb4fc228cdc600e2aac03489b7fff80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vm5o7p8tVR8flNy2b1pOmw.png"/></div></div></figure><p id="6b4c" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">我们再次使用 Scikit-learn wine 数据集用同样的最少代码创建这个面板。请注意变化:</p><ol class=""><li id="ceb5" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr ox nd ne nf bi translated">“功能与目标概要”表展开以反映所有三个类别。</li><li id="8e20" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr ox nd ne nf bi translated">分面图扩展以可视化所有三个类。</li><li id="e7e8" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr ox nd ne nf bi translated">x 轴和 y 轴刻度标签是小数，而不是整数。这种修改是基于被可视化的数据的规模而动态发生的。更少的格式化时间，更多的探索时间。</li></ol><p id="e084" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">mlmachine 为 EDA 引入了大量的简单性和动态性。现在让我们看看 mlmachine 是如何促进熊猫友好的 ML 实验工作流程的。</p><h1 id="0cdb" class="oi lf jg bd lg oj po ol lj om pp oo lm kv pq kw lq ky pr kz lu lb ps lc ly os bi translated">熊猫进出管道</h1><h2 id="8414" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated"><strong class="ak"> Scikit-learn 拆卸熊猫数据帧</strong></h2><p id="bd55" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">将<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>放入 Scikit-learn 转换器的一个主要缺点是底层 NumPy 数组周围的<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>包装器的丢失。这个问题在像<code class="fe ot ou ov ow b"><strong class="mb jq">PolynomialFeatures()</strong></code>这样的变形金刚身上尤为突出:</p><figure class="oy oz pa pb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pt"><img src="../Images/ec1b2633cbc46b34a667f728cca2c8e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TzgCdeN6twYDGR6xI63n_Q.jpeg"/></div></div></figure><p id="bf49" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">如果我们认为我们已经通过访问<code class="fe ot ou ov ow b"><strong class="mb jq">poly.get_feature_names()</strong></code>属性战胜了这个 transformer，那么当我们看到输出时，我们会非常失望:</p><figure class="oy oz pa pb gt is gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/0f3d97df55c0e4c6bb336b04ff038f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*ilotvmWsKnS3Wf7pwvTZlA.jpeg"/></div></figure><p id="570a" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">没什么帮助。</p><p id="8c9b" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">因此，我们失去了以下能力:</p><ul class=""><li id="b88f" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr nc nd ne nf bi translated">轻松对转换后的数据集执行 EDA</li><li id="89aa" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">训练模型后评估特征重要性</li><li id="859a" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">使用模型可解释性方法，如 SHAP 或莱姆</li><li id="ca69" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">仅仅识别哪些列是哪些列</li></ul><p id="7b17" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">当然，我们可以将 NumPy 数组反馈到一个<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>，并做任何需要的事情来使列匹配，但是……这是一件多么麻烦的事情。</p><h2 id="781a" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated">变形金刚，现在有了数据框架</h2><p id="8201" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">mlmachine 利用一个名为<code class="fe ot ou ov ow b"><strong class="mb jq">PandasTransformer()</strong></code>的类来确保如果一个<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>传入一个变压器，另一端会出现一个<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>。</p><p id="92f3" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">我们所要做的就是用<code class="fe ot ou ov ow b"><strong class="mb jq">PandasTransformer()</strong></code>包装<code class="fe ot ou ov ow b"><strong class="mb jq">PolynomialFeatures()</strong></code>,然后我们得到一个<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>,在另一边有有意义的列名:</p><figure class="oy oz pa pb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pf"><img src="../Images/6b98cf40cf64e03f350392b25a638e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Go95RTEs63xfb4R4oZggiQ.jpeg"/></div></div></figure><p id="64a2" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">就这么简单。</p><p id="c7d4" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">既然我们已经看到了如何在执行单个转换时保留我们的<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>,那么让我们在此基础上使用 Scikit-learn 的<code class="fe ot ou ov ow b"><strong class="mb jq">Pipeline()</strong></code>和<code class="fe ot ou ov ow b"><strong class="mb jq">FeatureUnion()</strong></code>功能来一次对多组特征执行多个操作。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="84fd" class="oi lf jg bd lg oj ok ol lj om on oo lm kv op kw lq ky oq kz lu lb or lc ly os bi translated">PandasFeatureUnion &amp; data frame selector-直观、熟悉、灵活</h1><h2 id="446f" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated">香草特色联盟</h2><p id="8ad4" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">Scikit-learn 包含一个名为<code class="fe ot ou ov ow b"><strong class="mb jq">FeatureUnion()</strong></code>的类。引用文档中的话，<code class="fe ot ou ov ow b"><strong class="mb jq">FeatureUnion()</strong></code>“连接多个 transformer 对象的结果…这对于将几个特征提取机制合并到一个 transformer 中很有用。”</p><p id="ca6a" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">对于将不同的数据处理操作应用于不同的要素，这是一个非常好的工具。例如，我们可能希望表示估算连续特征和模式估算分类特征:</p><figure class="oy oz pa pb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pv"><img src="../Images/658f285de820dd837e899666618f6f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sgau7eow8pSPiPJvbm3UwQ.jpeg"/></div></div></figure><p id="0dc9" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">不幸的是，<code class="fe ot ou ov ow b"><strong class="mb jq">FeatureUnion()</strong></code>也遭受了和其他变形金刚一样的缺点——它返回一个 NumPy 数组。这就是<code class="fe ot ou ov ow b"><strong class="mb jq">PandasFeatureUnion()</strong></code>前来救援的地方。</p><h2 id="fe48" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated">PandasFeatureUnion &amp; data frame selector</h2><p id="81a6" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">就像我们需要<code class="fe ot ou ov ow b"><strong class="mb jq">PandasTransformer()</strong></code>来保留<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame()</strong></code>后变换一样，我们需要<code class="fe ot ou ov ow b"><strong class="mb jq">PandasFeatureUnion()</strong></code>来维护最终的<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>后拼接。</p><p id="638a" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><strong class="mb jq">基本示例</strong></p><figure class="oy oz pa pb gt is"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="aff9" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">我们从这里重新开始，再次实例化一个名为<code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_titanic</strong></code>的<code class="fe ot ou ov ow b"><strong class="mb jq">Machine()</strong></code>对象。然后我们使用 mlmachine 的<code class="fe ot ou ov ow b"><strong class="mb jq">PandasFeatureUnion()</strong></code>类创建一个<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>友好的、<code class="fe ot ou ov ow b"><strong class="mb jq">FeatureUnion</strong></code>风格的管道，称为<code class="fe ot ou ov ow b"><strong class="mb jq">impute_pipe</strong></code>。这里是输出，仍然在一个<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>:</p><figure class="oy oz pa pb gt is gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/120acad75bdd80e6e5d34b69b4a3653e.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*mrgAXDl-pK9HXQUSV6BxKw.jpeg"/></div></figure><p id="5974" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">具体来说，我们对有空值的三个不同列执行三种不同类型的插补:</p><ul class=""><li id="a020" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr nc nd ne nf bi translated">用平均值估算“年龄”</li><li id="c9bd" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">用模式估算“已装船”</li><li id="5af7" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">用常数值(X)输入“客舱”。</li></ul><p id="9ebe" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">敏锐的观察者会注意到每条管道中存在另一个类别。这个类是<code class="fe ot ou ov ow b"><strong class="mb jq">PandasFeatureUnion()</strong></code>工作流的一个基本元素，根据它的使用方式有不同的用途。在第 30、34 和 38 行，<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrameSelector()</strong></code>用于选择 union 的特定分支的列。使用<code class="fe ot ou ov ow b"><strong class="mb jq">include_columns</strong></code> <strong class="mb jq"> </strong>参数按名称选择列。</p><p id="ba08" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">在第 42 行，我们做了一些不同的事情。由于按照设计，<code class="fe ot ou ov ow b"><strong class="mb jq">FeatureUnion()</strong></code>操作作用于特定的列并连接结果，我们将只剩下<em class="pi">和</em>转换后的列，无需进一步干预。</p><p id="eb0e" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">这就是为什么<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrameSelector()</strong></code>可以灵活选择所有列<em class="pi">，除了那些指定的列</em>。通过<code class="fe ot ou ov ow b"><strong class="mb jq">exclude_columns</strong></code>参数，我们选择除我们估算的特征之外的所有特征。这确保了我们保留完整的数据集。</p><p id="dd4d" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">现在我们已经填充了空值，让我们使用<code class="fe ot ou ov ow b"><strong class="mb jq">PandasFeatureUnion()</strong></code>工作流前进到稍微复杂一点的预处理步骤。如果对<code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>的目的有任何疑问，现在将变得更加清楚。</p><p id="f7f1" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><strong class="mb jq">不太基本的例子</strong></p><figure class="oy oz pa pb gt is"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="91f1" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">我们现在有了一个带有编码列的<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>，它们都被明确命名为:</p><figure class="oy oz pa pb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pf"><img src="../Images/65d12fb4ce7194d935053b8f0a8df664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbR-ojGt7E7RbEge3pJ4vw.jpeg"/></div></div></figure><p id="9d3b" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">让我们把这个<code class="fe ot ou ov ow b"><strong class="mb jq">PandasFeatureUnion</strong></code>一个分支一个分支:</p><ul class=""><li id="c65d" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr nc nd ne nf bi translated">“名义”管道——这里我们看到了<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrameSelector()</strong></code>的灵活性。首先，我们通过将<code class="fe ot ou ov ow b"><strong class="mb jq">[“nominal”]</strong></code>传递给<code class="fe ot ou ov ow b"><strong class="mb jq">include_mlm_dtypes</strong></code> <strong class="mb jq"> </strong>参数来选择所有名义列。<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrameSelector()</strong></code>直接引用<code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>进行栏目选择。其次，我们通过将特征名称传递给<code class="fe ot ou ov ow b"><strong class="mb jq">exclude_columns</strong></code>参数来排除“Cabin”(也是一个名义特征)。<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrameSelector()</strong></code>通过选择除“客舱”之外的所有标称列<em class="pi">来协调我们的包含/排除规格。最后，我们将选择的列传递给<code class="fe ot ou ov ow b"><strong class="mb jq">OneHotEncoder()</strong></code>，包装在<code class="fe ot ou ov ow b"><strong class="mb jq">PandasTransformer()</strong></code>中。</em></li><li id="e11f" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">“序数”管道——我们再次使用了<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrameSelector()</strong></code>参数<code class="fe ot ou ov ow b"><strong class="mb jq">include_mlm_dtypes</strong></code>，这次是为了选择所有序数列。然后我们将结果传递给<code class="fe ot ou ov ow b"><strong class="mb jq">OrdinalEncoder()</strong></code>，用<code class="fe ot ou ov ow b"><strong class="mb jq">PandasTransformer()</strong></code>包装。我们还提供编码说明。当我们实例化我们的<code class="fe ot ou ov ow b"><strong class="mb jq">Machine()</strong></code>对象时，我们传入了一个名为<code class="fe ot ou ov ow b"><strong class="mb jq">ordinal_encodings</strong></code>的字典，<code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_titanic</strong></code>将它存储为一个属性。我们将这个字典的值包装在一个列表中，并将其传递给<code class="fe ot ou ov ow b"><strong class="mb jq">OrdinalEncoder()</strong></code>参数<code class="fe ot ou ov ow b"><strong class="mb jq">categories</strong></code>。这将确保在编码过程中执行所需的层次结构。</li><li id="3d6b" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">“bin”管道-我们再次使用<code class="fe ot ou ov ow b"><strong class="mb jq">include_mlm_dtypes</strong></code>选择所有连续特征，并将结果传递给<code class="fe ot ou ov ow b"><strong class="mb jq">KBinsDiscretizer()</strong></code>，包装在<code class="fe ot ou ov ow b"><strong class="mb jq">PandasTransformer()</strong></code>中。</li><li id="8ff5" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">“diff”管道——最后一步是重新组合任何在联合操作中会丢失的特性，并删除任何我们不再需要的特性。我们对<code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>属性执行列表理解以删除“Cabin ”,并将<code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_titanic.ordinal_encodings</strong></code>的键附加到结果中。这将确保原始的标称和序数特征在转换的数据集中是<em class="pi">而不是</em>，但是我们保留“小屋”。注意，我们没有排除连续列，尽管我们用<code class="fe ot ou ov ow b"><strong class="mb jq">KBinsDiscretizer()</strong></code>转换了这些特性。原因很简单——我们希望在数据集中保留原始的连续列。</li></ul><p id="4131" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">我们用熟悉的<code class="fe ot ou ov ow b"><strong class="mb jq">fit_transform()</strong></code>方法来称呼<code class="fe ot ou ov ow b"><strong class="mb jq">encode_pipe</strong></code>。</p><p id="c799" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><strong class="mb jq">更新 mlm_dtypes </strong></p><p id="7e2b" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">因为数据集中有了新的特性，所以最好的做法是在<code class="fe ot ou ov ow b"><strong class="mb jq">fit_transform()</strong></code>之后加上<code class="fe ot ou ov ow b"><strong class="mb jq">update_mlm_dtypes()</strong></code>。</p><figure class="oy oz pa pb gt is"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="05e7" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">正如本文前面提到的，我们可以更新<code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>来反映<code class="fe ot ou ov ow b"><strong class="mb jq">data</strong></code>属性的当前状态。让我们来看一个前后对比，清楚地看到<code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>字典是如何变化的:</p><figure class="oy oz pa pb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi px"><img src="../Images/b10bec465f1bd7e824c3c4ce60f0dafa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vBu5hKoCTpMMSDhDf3q_Ew.jpeg"/></div></div></figure><p id="cf40" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">我们更新的<code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>字典在右边。我们看到没有标称列“apollowed”和“Sex ”,取而代之的是虚拟列的名称，如“apollowed _ C”和“Sex_male ”,由<code class="fe ot ou ov ow b"><strong class="mb jq">PandasTransformer(OneHotEncoder())</strong></code>产生。还要注意,“nominal”键仍然包含“Cabin”特性，我们选择在这里不处理它。</p><p id="b7f0" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">“ordinal”键包含我们的 binned 版本的“Age”和“Fare ”,以及“Pclass ”,它的命名方式清楚地表明了所应用的编码类型。</p><p id="bc84" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">每当我们修改<code class="fe ot ou ov ow b"><strong class="mb jq">data</strong></code>时，我们简单地调用<code class="fe ot ou ov ow b"><strong class="mb jq">update_mlm_dtypes()</strong></code>，而<code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>会自动更新以反映数据集的当前状态。唯一真正的工作是从一开始就确定每个特性的 mlm dtype，这是我们每次都应该做的事情。</p><p id="510e" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">让我们通过利用<code class="fe ot ou ov ow b"><strong class="mb jq">mlm_dtypes</strong></code>字典来对我们的新特性快速执行一点 EDA，从而得出结论。这一次，我们将遍历所有的顺序功能:</p><figure class="oy oz pa pb gt is"><div class="bz fp l di"><div class="pc pd l"/></div></figure><figure class="oy oz pa pb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi py"><img src="../Images/139e8b52498e28766a2901326c013c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*y8cb48Gf9iKi-WcOo2ZIhg.gif"/></div></div></figure><p id="ffca" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">我们覆盖了很多领域，但我们才刚刚开始探索 mlmachine 的功能。</p><p id="12f6" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">查看<a class="ae jd" href="https://github.com/petersontylerd/mlmachine" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>，并继续关注其他专栏条目。</p></div></div>    
</body>
</html>