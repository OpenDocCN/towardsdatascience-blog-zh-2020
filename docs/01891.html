<html>
<head>
<title>Understanding Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解递归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-recursion-a56b2eb0b12c?source=collection_archive---------12-----------------------#2020-02-22">https://towardsdatascience.com/understanding-recursion-a56b2eb0b12c?source=collection_archive---------12-----------------------#2020-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/40201648516282963c3ac1cfeef2bdab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ephye3YujhXImLQi"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">安德里亚·费拉里奥在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="d6f9" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">了解如何利用这一基本但令人困惑的编程概念</h2></div><p id="df14" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">每次我有一段时间不用它的时候，我发现自己都要重新学习这个概念。我大体上记得它是什么，以及我们为什么需要它，但是在长期搁置之后，递归编程总是一场斗争。</p><p id="65c5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在它又一次让我记忆犹新，让我来记录一下我们为什么以及如何使用递归。如果你想下载这篇文章中用到的代码，你可以在我的GitHub上找到它。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="a146" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">学过递归的人可能都记得计算斐波那契数的经典例子:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="dbc1" class="mt mu jj mp b gy mv mw l mx my"># Function that returns the nth number in the Fibonacci sequence<br/># For example, if n=3 the 3rd number in the sequence is returned</span><span id="59e4" class="mt mu jj mp b gy mz mw l mx my">def fib(n):<br/>    if n==0:<br/>        return 1<br/>    elif n==1:<br/>        return 1<br/>    else:<br/>        return fib(n-1) + fib(n-2)</span></pre><p id="a45d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们进入一个更实际的例子之前，让我们用它来理解递归是如何工作的。</p><p id="af8e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">递归是函数调用自身。我把递归比作do-while循环，遗憾的是这在Python中并不存在。与for循环不同，do-while循环会在满足终止条件之前一直运行，而for循环会预先指定要运行的次数。do-while循环的美妙之处在于<strong class="la jk">它会一直运行到任务完成</strong>——您不需要提前知道需要运行多少次。</strong></p><p id="e5f4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">递归很棒，因为它是do-while循环的有价值的替代品。它还会一直运行，直到任务完成。但是递归不是一个循环，而是像电影《盗梦空间》。在《盗梦空间》中，莱昂纳多·迪卡普里奥和他那群快乐的盗梦贼冒险进入了一个人的梦的更复杂的层面——每一层都是梦中的梦。只要他们能找到回去的路，他们能走多深是没有限制的。</strong></p><p id="f314" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每次我们的递归函数调用自己时，它实际上是更深入一层(当前梦中的另一个梦)。但就像《盗梦空间》中的角色一样，深入是达到目的的一种手段。让我们看看我们的斐波纳契代码，特别是最后一行:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="1ea7" class="mt mu jj mp b gy mv mw l mx my">return <strong class="mp jk">fib(n-1) + fib(n-2)</strong></span></pre><p id="7b64" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，该函数调用自身两次，并将结果相加，但是，尽管最初的函数是用<strong class="la jk"> n </strong>作为输入调用的，但这两次调用是用修改后的输入进行的:<strong class="la jk"> n-1 </strong>和<strong class="la jk"> n-2 </strong>。所以基本上梦里的每一个梦都从最初的输入<strong class="la jk"> n </strong>(通过从中减去)逐渐减少，直到它到达终点。让我们展开<strong class="la jk"> fib(5) </strong>来看看这是如何工作的:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="315f" class="mt mu jj mp b gy mv mw l mx my">  fib(5)</span><span id="8786" class="mt mu jj mp b gy mz mw l mx my">= fib(4) + fib(3)</span><span id="96b7" class="mt mu jj mp b gy mz mw l mx my">= fib(3) + fib(2) + fib(2) + fib(1)</span><span id="b270" class="mt mu jj mp b gy mz mw l mx my">= fib(2) + fib(1) + fib(1) + fib(0) + fib(1) + fib(0) + 1</span><span id="43bb" class="mt mu jj mp b gy mz mw l mx my">= fib(1) + fib(0) + 1 + 1 + 1 + 1 + 1 + 1</span><span id="70bd" class="mt mu jj mp b gy mz mw l mx my">= 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1</span><span id="6e86" class="mt mu jj mp b gy mz mw l mx my">= <strong class="mp jk">8</strong></span></pre><p id="ceff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，该函数一直持续到到达<strong class="la jk"> fib(1) </strong>或<strong class="la jk"> fib(0) </strong>为止，这些都是终止情况。比如<strong class="la jk"> fib(3) </strong>变成<strong class="la jk"> fib(2) + fib(1) </strong>，就变成<strong class="la jk"> fib(1) + fib(0) + fib(1) </strong>。这种自我传播，直到达到一个终止的情况，这就是函数如何越来越深(进入梦中的梦)，直到它到达一个出口点。</p><p id="3097" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过对照我们的函数来验证8是否是正确答案:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="e08e" class="mt mu jj mp b gy mv mw l mx my">In:  fib(5)</span><span id="64a7" class="mt mu jj mp b gy mz mw l mx my">Out: 8</span><span id="0b0f" class="mt mu jj mp b gy mz mw l mx my">In:</span><span id="1033" class="mt mu jj mp b gy mz mw l mx my"># For fun, print first 10 values of the Fibonacci Sequence<br/>for i in range(10):<br/>    print(fib(i))</span><span id="81e5" class="mt mu jj mp b gy mz mw l mx my">Out:</span><span id="8544" class="mt mu jj mp b gy mz mw l mx my">1<br/>1<br/>2<br/>3<br/>5<br/>8<br/>13<br/>21<br/>34<br/>55</span></pre><h2 id="2c5f" class="mt mu jj bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">结束</h2><p id="c5c7" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">让我们花点时间来谈谈终止案例。<strong class="la jk">这些都很关键，因为如果没有这些情况，函数就会无限期地调用自己，陷入死循环。</strong>所以编写任何递归函数的第一步是指定它可以退出(终止)的条件。</p><p id="4fce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在斐波那契数列的例子中，我们知道序列中的前两个值是1和1。即<strong class="la jk"> fib(0) = 1 </strong>和<strong class="la jk"> fib(1) = 1 </strong>。所以任何时候我们得到一个0或1的输入，我们就可以返回一个1，然后就结束了。如果我们的输入大于1，那么我们需要像上面那样，通过一系列递归函数调用，朝着终止情况(0或1)前进。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="71ae" class="nw mu jj bd na nx ny nz nd oa ob oc ng kp od kq nj ks oe kt nm kv of kw np og bi translated">更实际的用例</h1><p id="a1e0" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">打印斐波那契数列是一个巧妙的聚会把戏，但是现在让我们来看一个更实际的用例——遍历树。树木的问题在于我们不知道它们有多深。你可以有一个这样的:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="1bcf" class="mt mu jj mp b gy mv mw l mx my">root<br/>|  \<br/>|   \<br/>b1   b2</span></pre><p id="d917" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者像这样稍微深一点的:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="87e7" class="mt mu jj mp b gy mv mw l mx my">root ____________<br/>|           \     \<br/>|            \     \<br/>b1 ____       b2    b3<br/>|  \   \      |  \<br/>l1  l2  l3    l1  l2</span></pre><p id="c714" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们编写一个足够通用的函数，它可以处理这两种树(甚至更复杂的树)。首先，让我们使用Python字典构建上面描述的两棵树:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="ba5d" class="mt mu jj mp b gy mv mw l mx my">my_dict0 = {'root': {'b1': [1],<br/>                     'b2': [2]}<br/>           }</span><span id="9f13" class="mt mu jj mp b gy mz mw l mx my">my_dict1 = {'root': {'b1': {'leaf1': [1,2,3],<br/>                            'leaf2': [4],<br/>                            'leaf3': [5,6]<br/>                           },<br/>                     'b2': {'leaf1': [7,8],<br/>                            'leaf2': [9,10,11]<br/>                           },<br/>                     'b3': 12<br/>                    }<br/>           }</span></pre><p id="2d20" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们考虑如何通过递归来遍历这些树。首先让我们定义终止的情况。由于我们构造字典的方式，<strong class="la jk">终止的情况非常简单:如果我们看到一个列表(或单个值),我们可以只追加内容并继续前进</strong>。注意，我将结果存储在一个名为<strong class="la jk"> result </strong>的扩展列表中(<strong class="la jk"> result </strong>是函数运行完成后返回的结果)。另外，请注意，虽然我称之为终止案例，但我们还没有返回任何内容。相反，我们只是将结束节点的值附加到<strong class="la jk">结果</strong>中，并继续我们的for循环，因为我们知道我们已经完成了树的当前子部分。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="4701" class="mt mu jj mp b gy mv mw l mx my">def parse_dict(my_dict, result):<br/>    for key, val in my_dict.items():<br/>        <strong class="mp jk">if type(val) == list:<br/>            for i in val:<br/>                result.append(i)</strong></span></pre><p id="0820" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们看不到名单呢？然后，我们需要通过递归(Inception)更深入地研究。我们这样做的方法是通过再次调用我们的函数，但是在修改的输入上(如果我们每次调用都不改变我们的输入，我们将陷入无限循环)。因此，我们现在只给函数当前正在检查的树的一部分(<strong class="la jk"> my_dict </strong>)，而不是给函数原始输入。例如，一个对<strong class="la jk"> parse_dict </strong>的递归调用可能只处理<strong class="la jk"> b1 </strong>分支(它有3个叶子:<strong class="la jk"> leaf1 </strong>、<strong class="la jk"> leaf2 </strong>和<strong class="la jk"> leaf3 </strong>)，而另一个调用可能只处理<strong class="la jk"> b3 </strong>分支(它只有值<strong class="la jk"> 12 </strong>)。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="8893" class="mt mu jj mp b gy mv mw l mx my">def parse_dict(my_dict, result):<br/>    for key, val in my_dict.items():<br/>        if type(val) == list:<br/>            for i in val:<br/>                result.append(i)<br/>        <strong class="mp jk">elif type(val) == dict:<br/>            parse_dict(val, result)</strong></span></pre><p id="93cf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后要添加的是一个终止案例，它检查分支何时没有叶子或列表，并且只包含一个数值(比如<strong class="la jk"> b3 </strong>)。在这种情况下，我们可以直接将<strong class="la jk"> val </strong>中的值追加到<strong class="la jk">结果</strong>中:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="2a35" class="mt mu jj mp b gy mv mw l mx my">def parse_dict(my_dict, result):<br/>    for key, val in my_dict.items():<br/>        if type(val) == list:<br/>            for i in val:<br/>                result.append(i)<br/>        elif type(val) == dict:<br/>            parse_dict(val, result)<br/>        <strong class="mp jk">else:<br/>            result.append(val)</strong><br/>    return result</span></pre><p id="2664" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们在简单的树上运行函数，<strong class="la jk"> my_dict0 </strong>，我们得到:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="3fd8" class="mt mu jj mp b gy mv mw l mx my">In:  parse_dict(my_dict0, [])</span><span id="608b" class="mt mu jj mp b gy mz mw l mx my">Out: [1, 2]</span></pre><p id="7e5a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们在<strong class="la jk"> my_dict1 </strong>上运行它，我们会得到:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="1227" class="mt mu jj mp b gy mv mw l mx my">In:  parse_dict(my_dict1, [])</span><span id="26f8" class="mt mu jj mp b gy mz mw l mx my">Out: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></pre><p id="344f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">酷，我们已经遍历了我们的树，挖掘了存储在每个端节点中的值。不管树是简单的还是更复杂、更深入的，我们的函数都能工作。</p><p id="e8b9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">需要记住的一点是，如果你有一棵非常复杂的树，有很多层和很多分支，那么递归遍历它可能需要很长时间。如果您正在处理非常复杂的树结构，那么投入一些时间和思想来构建一个更加优化的解决方案是有意义的。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="44ee" class="nw mu jj bd na nx ny nz nd oa ob oc ng kp od kq nj ks oe kt nm kv of kw np og bi translated">额外收获:获得每个值的路径</h1><p id="1b4f" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">我们可能还想知道到达每个最终值所经过的路径(或者到达特定最终值的路径)。下面的函数产生一个包含每个结束值的路径的列表(与<strong class="la jk"> parse_dict的</strong>输出共享相同的顺序)。它的工作方式与<strong class="la jk"> parse_dict </strong>类似，所以我就不赘述了(但是代码中有一些注释)。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="f322" class="mt mu jj mp b gy mv mw l mx my">def get_path(my_dict, result, path):<br/>    for key, val in my_dict.items():<br/>        # If it's a dict, go one level deeper and update path<br/>        # to include the current key (node name)<br/>        if type(val) == dict:<br/>            get_path(val, result, path+[key])<br/>        <br/>        # If it's not a dict, then append the key and don't<br/>        # go down another level (since no need to)<br/>        elif type(val) == list:<br/>            for i in val:<br/>                result.append(path+[key])<br/>        else:<br/>            result.append(path+[key])<br/>    return result</span></pre><p id="4f39" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一些输出示例。注意，我们需要提供两个输入——返回的<strong class="la jk">结果</strong>和<strong class="la jk">路径</strong>，后者是附加到<strong class="la jk">结果</strong>的中间输出(但在函数结束时不返回)。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="233a" class="mt mu jj mp b gy mv mw l mx my">In:  get_path(my_dict1, [], [])</span><span id="a6f8" class="mt mu jj mp b gy mz mw l mx my">Out: </span><span id="bc22" class="mt mu jj mp b gy mz mw l mx my">[['root', 'b1', 'leaf1'],<br/> ['root', 'b1', 'leaf1'],<br/> ['root', 'b1', 'leaf1'],<br/> ['root', 'b1', 'leaf2'],<br/> ['root', 'b1', 'leaf3'],<br/> ['root', 'b1', 'leaf3'],<br/> ['root', 'b2', 'leaf1'],<br/> ['root', 'b2', 'leaf1'],<br/> ['root', 'b2', 'leaf2'],<br/> ['root', 'b2', 'leaf2'],<br/> ['root', 'b2', 'leaf2'],<br/> ['root', 'b3']]</span></pre><p id="71b3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望这对你有帮助。干杯！</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="00d4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="oh">更多数据科学相关帖子由我:</em> </strong></p><p id="9f8c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/understanding-cross-validation-419dbd47e9bd"> <em class="oh">理解交叉验证</em> </a></p><p id="67b7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/what-in-the-world-are-qq-plots-20d0e41dece1"><em class="oh">QQ剧情到底是什么？</em>T3】</a></p><p id="c76b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/understanding-the-normal-distribution-with-python-e70bb855b027"> <em class="oh">了解正态分布</em> </a></p><p id="097c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/pandas-join-vs-merge-c365fd4fbf49"> <em class="oh">熊猫加入vs合并</em> </a></p><p id="e4bc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/understanding-bayes-theorem-7e31b8434d4b"> <em class="oh">理解贝叶斯定理</em> </a></p></div></div>    
</body>
</html>