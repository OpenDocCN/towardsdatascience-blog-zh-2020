# 像 1970 年一样编程！

> 原文：<https://towardsdatascience.com/program-like-its-1970-6708df2ed101?source=collection_archive---------49----------------------->

## 有点回到人工智能过去的样子

![](img/beafd1e770ba35fcf706d4e3d7c040a0.png)

洛伦佐·埃雷拉在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

机器学习现在风靡一时！CNN、GANs 和 LSTMs 是所有酷孩子现在都在做的事情。很多人忘记了人工智能！= Machnine learning，在 2010 年深度学习热潮之前，人工智能已经存在了很长时间。我想带你回去，用一个简单的例子来说明过去的人工智能方法。

# 地图着色

“地图着色”是制图学中一个著名的玩具问题，我们希望以两个相邻国家总是有不同颜色的方式给地图着色(图 1)。

![](img/939620d38653836d38946e915046f709.png)

图 1:解决地图着色问题

为了便于说明，我们将在下面的部分中尝试给澳大利亚的州着色(因为只有八个州)。

有趣的是，在很长一段时间里，人们“知道”解决这个问题至少需要四种颜色。但是直到 90 年代末，还没有一个关于 T4 的数学证明。

# 约束满足问题

地图着色问题属于一类特殊的问题，简称为“约束满足问题”。这些类型的问题由三个不同的部分组成:

1.  变量:我们要查找其值的占位符。在我们的案例中，这些是澳大利亚的州和地区:新南威尔士州、昆士兰州、维多利亚州、西澳大利亚州、南澳大利亚州、北部地区、澳大利亚首都直辖区和塔斯马尼亚州
2.  域:这些是变量的可能值。在这种情况下，所有变量的定义域都是相同的。每种状态都可以用红、绿、蓝、黄四种颜色中的一种来着色。
3.  约束:变量不能违反这些约束。例如，维多利亚和新南威尔士的颜色必须不同，因为这是两个相邻的州。

一般来说，解决 CSP 有两种不同的策略:

1.  推理
2.  搜索

重要的是，CSP 通常只能通过推理部分解决，因此需要搜索。简而言之，如果我们不需要进行某种随机猜测来寻找答案，那么 CSP 就是完全可以通过推理来求解的。一个典型的例子是数独游戏。我们有自己的变量(空字段)、域(1 到 9 之间的数字)和几个不能违反的约束(在一行、一列或一个正方形中不能有相同的数字)。在这里，我们不必随机选择一些数字，但我们可以通过以正确的顺序应用约束来解决整个难题。不幸的是，对于我们的地图着色问题，我们没有那么幸运:为了找到一个合适的解决方案，我们不可避免地要做一些猜测。

# 通常的方法:回溯

解决类似 CSP 的常见方法是使用回溯算法。这是用 Python 实现的算法:

回溯算法

我们现在将逐行检查代码，以确保我们理解这里发生了什么:

如上所述，我们的 CSP 由变量、域值和约束组成。重要的是要注意，如果可能的话，约束通常被转换成二元约束，以使事情变得更容易。二元约束描述了两个变量之间的关系。在我们的 Python 实现中，它们的形式是[('NSW '，' V ')，(' NSW '，' Q ')，(' NSW '，' SA ')，…，(' T '，' V')]。

如果我们有和变量一样多的赋值，那就意味着我们已经给每个变量赋值了，从而解决了问题！

我们现在必须选择一个仍然未赋值的变量，我们现在想找到它的值。如何选择这个值将在下面进一步讨论。

在选择了一个未赋值的变量后，我们还必须选择一个顺序来测试这个变量的值。

如果我们为变量选择的值与我们的二元约束一致，我们就把它添加到我们所有赋值的列表中。现在真正酷的部分是:我们再次调用回溯函数，所以这是一个递归函数。我们找到了一个变量的有效赋值，所以现在是时候为下一个变量找到一个值了。

可能发生的情况是，递归调用的结果是‘None’。这意味着我们赋给变量的值在这个时候是局部一致的，但是不可能用这个值找到一个整体一致的解。所以我们把这个值从赋值列表中去掉了。如果我们不能找到一个单一的一致的解决方案，我们返回 None 给上面的递归函数。如果所有的递归调用都没有返回 None，这意味着问题是不可解决的。

哦，这个理论说够了。让我们看看这个算法如何执行，如果我们让它运行在我们的地图着色问题:

![](img/2773860172d1a6cc60d42eda80d3bdd0.png)

图 2:天真的回溯

嗯…我们的算法似乎没有任何进展。剧透:它最终会找到一个解决方案，但这需要很长时间，这在上面的 gif 中没有显示。这是为什么呢？因为我们仍然没有回答上面的一个重要问题:我们如何选择下一个变量来赋值？在上图中，算法只是随机选择一个未赋值的值。显然这不是最好的方法。要选择一个变量，我们应该选择一个更好的启发式。我们实现了**最小剩余值**试探法或者 **MRV** 试探法。这一点是不言自明的:我们选择的下一个变量总是剩下最少有效值的变量。这在直觉上也是有道理的。例如，如果我们只能将新南威尔士州涂成红色，但我们仍然可以将西澳大利亚州涂成红、绿和蓝色，那么我们应该首先将新南威尔士州涂成红色，因为如果我们将另一个州涂成红色，可能就不会再有任何有效的颜色留给新南威尔士州了。所以让我们用这个启发法再试一次:

![](img/9d04953be99180329a8b6963285adb62.png)

图 3:MRV 的原路返回

哇，这个好用多了！

比较随机选择和 MRV 启发式(图 3 ),我们可以看到后者通常更省时。

![](img/5c4100ea2c858b6ea8d8c0dfbe9dc445.png)

图 4: MRV(左)与随机(右)选择下一个变量

但是说实话，给澳大利亚涂色并不有趣，因为澳大利亚只有 8 块领土。所以，为了好玩，让我们试着给德国涂上颜色，这个国家有两倍多的州:

![](img/c6263562efee0df8abf32d517ee4771d.png)

图 5:给德国上色

这个也很管用！

# 捷径:序言

因此，到目前为止，整个过程都相当繁琐:我们需要编写所有这些回溯代码(递归函数有时会很棘手！)甚至想出一个好的启发式。没有更好的解决办法吗？介绍:序言。

很可能，作为一个普通的程序员(就像我一样)，你已经接触过相当多的编程语言:Java、Python、C、C#、JavaScript 等等。它们可能完全不同，但它们都属于同一类编程语言:命令式编程。然而，Prolog 属于声明性编程语言，或者更确切地说，属于逻辑编程语言。那么有什么区别呢？在“普通”编程语言中，你指定**事情应该如何**完成。在 Prolog 中，你指定**应该做什么**。看看下面的例子:

简单的序言示例

Prolog 中最重要的两个构造是**事实**和**规则**。在节目的开始，我们陈述了一些事实，例如，亨利是男性，玛丽是迈克尔的父母。再往下我们有一些规则。例如，我们声明，如果 Y 是男性，Y 是 X 的父，重要的是:所有变量都必须以大写字母开头。小写名称是固定的常数。

当我们进入 Prolog 控制台时，我们可以问我们的 Prolog 程序一些问题。我们可以找出迈克尔的母亲是谁:

```
?- mother(michael, X).
X = mary.
```

或者谁是迈克尔的祖父:

```
?- grandfather(michael, X).
X = henry ;
```

现在让我们写一个程序给澳大利亚上色:

这真是直截了当！首先，我们定义哪些状态应该用不同的颜色。Diffx 只是一个帮助函数，它帮助我们定义如果颜色 A 不同于 B，那么 B 也不同于 A。最后，我们只是声明所有的颜色都彼此不同(显然)。就是这样！15 行代码，我们只需要陈述规则和事实，不需要算法。

让我们加载这个程序，要求变量赋值:

```
?- map_coloring(WA, NT, SA, NSW, V, Q, T, ACT).
WA = NSW, NSW = T, T = blue,
NT = V, V = ACT, ACT = red,
SA = green,
Q = yellow
```

将这些值放入地图如下所示:

![](img/7f62f3f68610f5acbd5689b467fe8b5d.png)

图 6:由 Prolog 程序确定的颜色

的确，我们得到了一个有效的解！

# 结论

当我通常处理人工智能时，它必须用神经网络做一些事情，所以对我来说，看看几十年前人们对“人工智能”这个术语的理解是非常有趣的。尤其是用 Prolog 编程对我来说非常独特。解决 CSP 和类似的问题显然是非常容易的。我对这种语言的主要问题是，我从来不知道到底发生了什么。我只是陈述一些事实和规则，但从不明确告诉程序该做什么。因此，如果任务失败，跟踪错误和调试问题几乎是不可能的。