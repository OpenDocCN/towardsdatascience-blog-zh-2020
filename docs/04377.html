<html>
<head>
<title>Pandas Groupby: a simple but detailed tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫小组:一个简单而详细的教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-groupby-a-simple-but-detailed-tutorial-314b8f37005d?source=collection_archive---------15-----------------------#2020-04-20">https://towardsdatascience.com/pandas-groupby-a-simple-but-detailed-tutorial-314b8f37005d?source=collection_archive---------15-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4d7e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Groupby 是一个很好的生成分析的工具，但是为了充分利用它并正确使用它，这里有一些众所周知的技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/922d0feea72c8e46825b606a71ec65e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OXzlIDB29nyEFSmOIzqrUQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@dvlw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">德克·冯·隆-瓦格纳</a>在<a class="ae ky" href="https://unsplash.com/s/photos/lake?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="aec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas <strong class="lb iu"> groupby </strong>是一个相当强大的数据分析工具。但是对于初学者来说使用起来并不是很直观，因为<strong class="lb iu"> groupby </strong>的输出并不是 Pandas <strong class="lb iu"> Dataframe </strong>对象，而是 Pandas<strong class="lb iu">data frame group by</strong>对象。DataFrame 对象可以很容易地被可视化，但对于 Pandas DataFrameGroupBy 对象来说却不是这样。如果一个物体不能被可视化，那么它就更难被操纵。</p><p id="3a4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在网上找到的一些教程要么包含了太多对用户来说不必要的信息，要么没有足够的信息让用户知道它是如何工作的。我认为包含数据科学家日常工作中经常使用的关键工具的指南肯定会有所帮助，这就是为什么我写这篇文章来帮助读者更好地了解 pandas groupby。</p><p id="d6e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">重要注意事项</strong>。<br/> 1。我假设读者在开始之前，已经知道了在 R、SQL、Excel(或其他工具)中<strong class="lb iu"> group by </strong>计算是如何工作的。<br/> 2。所有代码都经过测试，它们适用于熊猫 1.0.3 。旧的熊猫版本可能会有错误。</p><p id="aec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每一节都将提供示例—可能有不同的方法来生成相同的结果，我会选择我经常使用的方法。</p><p id="e09c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大纲如下:</p><ol class=""><li id="a2d1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用创建分析。<strong class="lb iu"> groupby() </strong>和<strong class="lb iu">。agg() </strong>:内置函数</li><li id="3317" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用创建分析。<strong class="lb iu"> groupby() </strong>和<strong class="lb iu">。agg() </strong>:用户定义的函数和 lambda 函数</li><li id="cd37" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用<strong class="lb iu">。transform() </strong>将组统计数据连接到原始数据帧</li><li id="791f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">分组处理时间序列</li></ol><h2 id="5d6e" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">使用创建分析。<strong class="ak"> groupby() </strong>和<strong class="ak">。agg() </strong>:内置函数</h2><p id="d16f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">为了生成数据集中每个组的统计数据，我们需要根据一个或多个列将数据分类成组。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="36d2" class="mj mk it ni b gy nm nn l no np"># group by a single column<br/>df.groupby('column1')</span><span id="6dd2" class="mj mk it ni b gy nq nn l no np"># group by multiple columns<br/>df.groupby(['column1','column2'])</span></pre><p id="d272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们决定想要创建什么样的统计数据。这可以用<code class="fe nr ns nt ni b">.agg()</code>来完成。使用<code class="fe nr ns nt ni b">.agg()</code>有几种不同的方式:</p><p id="bcc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">A.使用字典作为<code class="fe nr ns nt ni b">.agg()</code>的输入。<br/> B .使用单个聚合函数或聚合函数列表作为输入。<br/> C .使用命名聚合(Pandas 0.25.0 中的新功能)作为输入。</p><p id="6037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将用下面的例子来演示这些不同的解决方案是如何工作的。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2336" class="mj mk it ni b gy nm nn l no np">import pandas as pd<br/>import numpy as np <br/>df = pd.DataFrame(dict(Gender=['M', 'F', 'M', 'F',<br/>                               'F', 'M', 'M', np.nan],<br/>                       State=['NY','IL', 'NY', 'CA',<br/>                              'IL', 'CA', 'CA', 'IL'],<br/>                       col_1=[10,20,30,np.nan,40,50,60,70],<br/>                       col_2=[1,6,2,4,6,9,np.nan,3]))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/81fbdd4b46a3f9327ac3c05983d8ac6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*fxoFtz7CLbnWNModQxEX9Q.png"/></div></div></figure><p id="3036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> A .字典<br/> </strong> <em class="nv">什么时候用？— </em>当我们需要在不同的列上运行不同的聚合，并且我们不关心聚合列的名称是什么样子时。</p><p id="3778" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于字典中的每个键-值对，键是我们想要运行聚合的变量，值是聚合函数。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b1bf" class="mj mk it ni b gy nm nn l no np">tbl = df.groupby(['Gender','State'])\<br/>        .agg({'col_1': ['mean', 'std'],<br/>              'col_2': [sum, 'size' ,'count']})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0ae534292bd039c60d8cf9c481545492.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*8E6reRucuJEI9CFWuAr6MQ.png"/></div></figure><p id="8c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对于每一列，只使用一个聚合函数，那么我们就不必将聚合函数放在一个列表中。在这种情况下，<code class="fe nr ns nt ni b">tbl</code>将是单索引的，而不是多索引的。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9b80" class="mj mk it ni b gy nm nn l no np">tbl = df.groupby(['Gender','State'])\<br/>        .agg({'col_1': 'mean',<br/>              'col_2': sum})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/e396fca70eaca3b0796144dca2dddafc.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*ms0ZZvvHv0VyPuke7DFolw.png"/></div></figure><p id="9d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> B .单个聚合函数或者列表聚合函数<br/> </strong> <em class="nv">什么时候使用？— </em>当我们需要对所有列运行相同的聚合，并且我们不关心聚合列的名称是什么样子时。</p><p id="4482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想对每一列应用相同的集合函数，我们只需要在<code class="fe nr ns nt ni b">.agg()</code>中包含一个函数或一列函数。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="8db8" class="mj mk it ni b gy nm nn l no np">tbl = df.groupby(['Gender','State'])\<br/>        .agg([min, max])    # a list of aggregation functions</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/6dea5ca309f195c2be53989bc6adab2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*js5PUGuGbeuA9W1XrZneRQ.png"/></div></figure><p id="b4fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只想查看选定列的结果，我们可以在代码中应用过滤器:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="c759" class="mj mk it ni b gy nm nn l no np"># filter by a single column<br/>tbl = df.groupby(['Gender','State'])\<br/>        ['col_1'].agg([min, max])    </span><span id="6e36" class="mj mk it ni b gy nq nn l no np">tbl = df.groupby(['Gender','State'])\<br/>        [['col_1']].agg([min, max])</span><span id="fb10" class="mj mk it ni b gy nq nn l no np"># filter by a multiple columns<br/>tbl = df.groupby(['Gender','State'])\<br/>        ['col_1', 'col_2'].agg([min, max])</span><span id="7770" class="mj mk it ni b gy nq nn l no np">tbl = df.groupby(['Gender','State'])\<br/>        [['col_1', 'col_2']].agg([min, max])</span></pre><p id="9ba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注。</strong>如果我们按多列过滤，那么无论使用哪种方法,<code class="fe nr ns nt ni b">tbl.columns</code>都是多索引的。如果我们按单列过滤，那么<code class="fe nr ns nt ni b">[['col_1']]</code>使<code class="fe nr ns nt ni b">tbl.columns</code>成为多索引，而<code class="fe nr ns nt ni b">['col_1']</code>使<code class="fe nr ns nt ni b">tbl.columns</code>成为单索引。</p><p id="4275" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> C .命名聚合(熊猫≥ 0.25) <br/> </strong> <em class="nv">什么时候用？— </em>当我们需要在不同的列上运行不同的聚合时，我们希望在运行<code class="fe nr ns nt ni b">.agg()</code>后能够完全控制列名</p><p id="ee31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每个元组中，第一个元素是列名，第二个元素是聚合函数。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="e3de" class="mj mk it ni b gy nm nn l no np">tbl = df.groupby(['Gender','State'])\<br/>        .agg(col_1_mean=('col_1','mean'),<br/>             col_1_max=('col_1',max),<br/>             col_2_sum=('col_2',sum))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/a8ae1617a2e89cf147421f6eee8c7433.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*Sl1JAcXiIlC8GeLeXx_-SQ.png"/></div></figure><p id="ed52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关于</strong> <code class="fe nr ns nt ni b">.agg()</code>的几点说明。</p><ol class=""><li id="16b7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">数据按列 A 和列 B 分组，但列 A 中有缺失值。在任一列中有缺失值的行将从使用<code class="fe nr ns nt ni b">.agg()</code>生成的统计数据中排除。</li><li id="6588" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对于使用<strong class="lb iu"> sum、max、min、【中值】、【均值】、【计数】</strong>(非空元素的计数)、<strong class="lb iu">、【标准】、<strong class="lb iu">、【唯一】、</strong>(不同元素的计数)创建的组统计，数据中缺失的值将从计算中排除。但是<strong class="lb iu">‘size’</strong>(所有元素的计数)仍然包括缺失值。</strong></li><li id="f22f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">可以做<code class="fe nr ns nt ni b"> tbl.columns =["_".join(i) for i in tbl.columns.ravel()]</code>将多索引列转换成单索引列。</li><li id="ef64" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">可以使用<code class="fe nr ns nt ni b">tbl = tbl.reset_index()</code>将索引转换为表<br/>的列。</li><li id="4c4a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在使用<code class="fe nr ns nt ni b">.agg()</code>创建的表格中，组可能没有按照首选顺序排列。一个人可以</li></ol><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="3665" class="mj mk it ni b gy nm nn l no np">df['Gender'] = pd.Categorical(df['Gender'], [<!-- -->'F', 'M'<!-- -->])<br/>df['State']  = pd.Categorical(df['State'],  [<!-- -->'NY', 'CA', 'IL'<!-- -->])</span></pre><p id="c018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行<code class="fe nr ns nt ni b">.agg()</code>之前，将列转换为用户指定级别的分类系列。(注。<code class="fe nr ns nt ni b">pd.Categorical</code>可能不适用于较老的熊猫版本)</p><h2 id="3931" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">使用创建分析。<strong class="ak"> groupby() </strong>和<strong class="ak">。agg() </strong>:用户定义的函数和 lambda 函数</h2><p id="59dc" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">让我们看另一个例子，看看我们如何在<code class="fe nr ns nt ni b">.agg()</code>中使用用户定义的函数或 lambda 函数来计算统计数据。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="de06" class="mj mk it ni b gy nm nn l no np">df = pd.DataFrame(dict(StoreID=[1,1,1,1,2,2,2,2,2,2],<br/>                       ProductID=['A01', 'A02', 'B01','C01',  <br/>                                  'B01', 'B02', 'B03', 'C01', <br/>                                  'C02', 'C03'],<br/>                       price=[10,20,50,100,50,60,70,100,150,200]))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/6649c9ff98fd8e3a2ef57d58d7950514.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*i6yQYqDp09TZ6JcRBl6gMg.png"/></div></figure><p id="e789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望计算每个商店的以下统计数据:<br/> A .以“A”开头的产品数量<br/> B .所有产品的列表<br/> C .最高产品价格和最低产品价格的差异<br/> D .产品价格的第一个分位数(第 25 个百分位数)</p><p id="4bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们定义一个函数来计算一个序列中以“A”开头的元素的数量。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="6688" class="mj mk it ni b gy nm nn l no np">def cnt_A(x):<br/>    ctr = 0<br/>    for item in x:<br/>        if item[0] == 'A':<br/>            ctr += 1<br/>    return ctr</span><span id="1218" class="mj mk it ni b gy nq nn l no np"># If you prefer a Pythonic approach:  <br/>def cnt_A(x):<br/>    return (x.str[0] == 'A').sum()</span></pre><p id="f790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用命名聚合+用户定义函数+ lambda 函数来优雅地完成所有计算。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9441" class="mj mk it ni b gy nm nn l no np">df.groupby(['StoreID'])\<br/>  .agg(number_of_product_A =('ProductID', cnt_A),<br/>       product_list=('ProductID', lambda x: ', '.join(x)),<br/>       price_Q1    =('price', lambda x: np.percentile(x, 25)),<br/>       price_gap   =('price', lambda x: x.max()-x.min())<br/>      )</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/29b7d42151b9aa769a407ac1aa1e05ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YH_3bSaH1TvW4eVMf4yfrw.png"/></div></div></figure><p id="fbee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当函数不复杂时，使用 lambda 函数会使您的生活更轻松。<code class="fe nr ns nt ni b">lambda x: x.max()-x.min()</code>和</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="94c0" class="mj mk it ni b gy nm nn l no np">def gap(x):<br/>    return <!-- -->x.max()-x.min()</span></pre><p id="7f0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成相同的输出。</p><p id="d332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注</strong>。如果在有重复的时候你需要一个唯一的列表，你可以用<code class="fe nr ns nt ni b">lambda x: ', '.join(x.unique())</code>代替<code class="fe nr ns nt ni b">lambda x: ', '.join(x)</code>。</p><h2 id="76ac" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">使用<strong class="ak">。transform() </strong>将组统计信息附加到原始数据中</h2><p id="6eab" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">让我们使用上一节中的数据来看看如何使用<code class="fe nr ns nt ni b">.transform()</code>将组统计信息添加到原始数据中。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="360a" class="mj mk it ni b gy nm nn l no np">df = pd.DataFrame(dict(StoreID=[1,1,1,1,2,2,2,2,2,2],<br/>                       ProductID=['A01', 'A02', 'B01','C01',  <br/>                                  'B01', 'B02', 'B03', 'C01', <br/>                                  'C02', 'C03'],<br/>                       price=[10,20,50,100,50,60,70,100,150,200]))</span><span id="189d" class="mj mk it ni b gy nq nn l no np">df['cnt A in each store'] = df.groupby('StoreID')['ProductID']\<br/>                              .transform(cnt_A)</span></pre><p id="d25d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nr ns nt ni b">.transform()</code>，我们可以轻松地将统计数据添加到原始数据集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/7cc34e2b79ec7785041a89a4fec12bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*c88RQE2cvDbBxfMNEyMNkg.png"/></div></figure><p id="f2ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注 1。</strong>与<code class="fe nr ns nt ni b">.agg()</code>不同，<code class="fe nr ns nt ni b">.transform()</code>不以字典为输入。<br/> <strong class="lb iu">注二。</strong>为了正确地追加数据，我们需要确保<code class="fe nr ns nt ni b">.groupby()</code>中使用的列中没有缺失值。(根据 Pandas 用户指南，<code class="fe nr ns nt ni b">.transform()</code>返回与被分组的对象索引相同(大小相同)的对象。)</p><p id="8ecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例—百分比计数</strong>:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="dffd" class="mj mk it ni b gy nm nn l no np">df = pd.DataFrame(dict(bank_ID=[1,1,1,1,<br/>                                2,2,2,2,2],<br/>                       acct_type=['checking','checking', <br/>                                  'checking','credit',<br/>                                  'checking','credit', <br/>                                  'credit','credit', <br/>                                  'checking']))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/bdaec2a5da395f7e103160dbf03ff5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*p612ik9ISBAvGAVFAfMD3g.png"/></div></figure><p id="5e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">问题</strong>:如何计算各银行账户类型的百分比？首先，我们计算每个 bank_ID + acct_type 组合的组总数:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0e7c" class="mj mk it ni b gy nm nn l no np">tbl = df.groupby(['bank_ID', 'acct_type'])\<br/>        .agg(group_total=('acct_type','count'))\<br/>        .reset_index()</span></pre><p id="ae8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后计算每个银行的总数，并使用<code class="fe nr ns nt ni b">.transform()</code>添加信息。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="70b1" class="mj mk it ni b gy nm nn l no np">tbl['total count in each bank'] = tbl.groupby('bank_ID')\<br/>                                     ['group_total']\<br/>                                     .transform(sum)<br/>tbl['% in each bank'] = (tbl['group_total'] * 100.0 <br/>                       / tbl['total count in each bank'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/08eeb712716cbb7f9373a714f0be04ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JeoRvNtLoGFIPCLnvbVEBw.png"/></div></div></figure><p id="4c39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个没有<code class="fe nr ns nt ni b">.transform()</code>的解决方案:只按 bank_ID 分组，用<code class="fe nr ns nt ni b">pd.merge()</code>把结果联接回<code class="fe nr ns nt ni b">tbl</code>。</p><h2 id="69b1" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">分组处理时间序列</h2><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="d059" class="mj mk it ni b gy nm nn l no np">import datetime<br/>df = pd.DataFrame(dict(acct_ID=['A102','A102','A102','A102',<br/>                                'A102','A102','D276','D276',<br/>                                'D276','D276','D276'],<br/>           transaction_time=[datetime.datetime(2016, 3, 1, 11, 0),<br/>                             datetime.datetime(2016, 4, 12, 9, 0),<br/>                             datetime.datetime(2016, 4, 14, 12, 0),<br/>                             datetime.datetime(2016, 4, 14, 17, 0),<br/>                             datetime.datetime(2016, 4, 20, 13, 0),<br/>                             datetime.datetime(2016, 6, 11, 20, 0),<br/>                             datetime.datetime(2018, 7, 11, 10, 0),<br/>                             datetime.datetime(2018, 7, 12, 10, 0),<br/>                             datetime.datetime(2018, 9, 24, 9, 0),<br/>                             datetime.datetime(2018, 9, 24, 12, 0),<br/>                             datetime.datetime(2018, 12, 20, 15, 0)<br/>                            ],<br/>           transaction_amount=[20, 100, 120, 100, 40, <br/>                               60, 80, 200, 200, 80, 50]))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/513ae301683f7e71b0e172ad7bc9bb6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*fNvKO3lJasYYcPajJ_vdgw.png"/></div></figure><p id="9b2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于上面的交易数据，我们希望将以下各列添加到每个交易记录中:</p><ol class=""><li id="7fe6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">交易行号(按交易时间排序)</li><li id="d6f3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">前一笔交易的交易金额</li><li id="4b5e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">前一笔交易与当前交易的交易金额差额</li><li id="4304" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">前一个交易与当前交易之间的时间间隔(以天为单位，向下舍入)</li><li id="38f5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">截至当前交易的所有交易的累计总额</li><li id="6b24" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">截至当前交易的所有交易的累计最大值</li><li id="2f28" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">截至上一笔交易的所有交易的累计总额</li><li id="1b6e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">截至前一笔交易的所有交易的累计最大值</li></ol><p id="be53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注。在进行以下计算之前，请确保先对数据进行排序。该表已经排序，但如果没有排序，您可以执行<code class="fe nr ns nt ni b">df.sort_values(by=['acct_ID','transaction_time'], inplace=True)</code>。</strong></p><p id="13e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于 1。，我们能做什么</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a5ab" class="mj mk it ni b gy nm nn l no np">df['rowID'] = df.groupby('acct_ID')['transaction_time']\<br/>                .rank(method='first', ascending=True)\<br/>                .astype(int)</span></pre><p id="9eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个人的。-6.，可以通过以下代码轻松完成:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4c95" class="mj mk it ni b gy nm nn l no np">df['prev_trans']  =df.groupby('acct_ID')['transaction_amount']\<br/>                     .shift(1)<br/>df['trans_diff']  =df.groupby('acct_ID')['transaction_amount']\<br/>                     .diff(1)<br/>df['time_diff']   =df.groupby('acct_ID')['transaction_time']\<br/>                     .diff(1).dt.days<br/>df['trans_cumsum']=df.groupby('acct_ID')['transaction_amount']\<br/>                     .cumsum()<br/>df['trans_cummax']=df.groupby('acct_ID')['transaction_amount']\<br/>                     .cummax()</span></pre><p id="8dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了得到 7。和 8。，我们简单的把<code class="fe nr ns nt ni b">.shift(1)</code>加到 5。和 6。我们计算出:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="c161" class="mj mk it ni b gy nm nn l no np">df['trans_cumsum_prev']  = df.groupby('acct_ID')['trans_cumsum']\<br/>                             .shift(1)<br/>df['trans_cummax_prev']  = df.groupby('acct_ID')['trans_cummax']\<br/>                             .shift(1) </span></pre><p id="cc9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些计算的关键思想是，像<br/> <code class="fe nr ns nt ni b">.rank()</code>、<code class="fe nr ns nt ni b">.shift()</code>、<code class="fe nr ns nt ni b">.diff()</code>、<code class="fe nr ns nt ni b">.cummax()</code>、<code class="fe nr ns nt ni b">.cumsum()</code>这样的窗口函数不仅适用于熊猫数据帧，也适用于熊猫分组对象。</p><p id="b19f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看运行上面的计算后会得到什么。结果被分成两个表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/08d337d01706e93879f253faeb1edc94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZSCSuQT4qAWEveS6L_Tfg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/5913c3c6bffa94c6eae37683bdcd3075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iWEFRKrskTGPgle6O3xi0Q.png"/></div></div></figure><p id="d180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">读者可以使用不同的参数来使用这些窗口函数，看看会发生什么(比如说，试试<code class="fe nr ns nt ni b">.diff(2)</code>或<code class="fe nr ns nt ni b">.shift(-1)</code>？).</p><p id="da94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">读者提问</strong> : <br/> 1。我们如何计算不同窗口大小的交易金额的移动平均值？(提示:组合<code class="fe nr ns nt ni b">.shift(1)</code>、<code class="fe nr ns nt ni b">.shift(2)</code>、…) <br/> 2。我们如何按照降序来计算事务行号？(提示:使用<code class="fe nr ns nt ni b">.rank()</code>中的<code class="fe nr ns nt ni b">ascending</code>参数——参见此<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rank.html" rel="noopener ugc nofollow" target="_blank">链接</a>。)</p><p id="2e38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">*</p><p id="0356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">教程到此结束，感谢阅读。欢迎提出建议——欢迎在评论中发表新想法/更好的解决方案，这样其他人也可以看到它们。</p></div></div>    
</body>
</html>