<html>
<head>
<title>Google Maps Feature Extraction with Selenium</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 Selenium 的谷歌地图特征提取</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/google-maps-feature-extraction-with-selenium-faa2b97b29af?source=collection_archive---------24-----------------------#2020-05-04">https://towardsdatascience.com/google-maps-feature-extraction-with-selenium-faa2b97b29af?source=collection_archive---------24-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9c44" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Python + Pillow + Matplotlib</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c66cb92aae99e56c33b73e932fbbdbde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*o3rgY1QgRgi_EdQbmxbxKQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">绿地密度提取(扫描谷歌地图图像)</p></figure><p id="7a96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我计划这是关于提取谷歌地图数据和做一些有趣的路径和基于时间的研究的系列文章的第一部分。一些例子是观察一段时间内的交通流量，并计算给定路线的“美丽分数”。这个旅程的第一步是从 Google Maps 自动加载图像数据，并从这些图像中提取特征。让我们开始吧。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="37fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至于我的工具包，我们使用 Python 做任何事情，并利用 Selenium(用于自动化的 web 浏览器模拟器)、Pillow(图像处理库)和 Matplotlib(绘制数据值)的包。</p><p id="bce3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的工作环境是 Kaggle，这是一个在线数据和笔记本网站，非常有用。首先，我必须安装所需的软件，以允许我们模拟一个浏览器，以便从谷歌地图提取图像数据(除了一些其他数据)。</p><h2 id="ffd6" class="mb mc it bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">软件包的安装</h2><p id="e74d" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">第一步是下载并解压 Firefox 发行版，这将是我们的自动化浏览器。这是我用过的一个:</p><p id="4ba2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae mz" href="http://ftp.mozilla.org/pub/firefox/releases/63.0.3/linux-x86_64/en-US/firefox-63.0.3.tar.bz2" rel="noopener ugc nofollow" target="_blank">http://FTP . Mozilla . org/pub/Firefox/releases/63 . 0 . 3/Linux-x86 _ 64/en-US/Firefox-63 . 0 . 3 . tar . bz2</a></p><p id="eca4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">提取后，记下目录的位置。为了保持整洁，我为这个项目创建了一个新的工作目录:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0ee1" class="mb mc it nb b gy nf ng l nh ni">mkdir ~/working/firefox</span></pre><p id="2139" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在将提取的文件复制到这个新目录中，并设置允许所有人执行的权限。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5551" class="mb mc it nb b gy nf ng l nh ni">cp -a firefox-63.0.3.tar.bz2/. ~/working/firefox<br/>chmod -R 777 ~/working/firefox</span></pre><p id="7c53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我需要安装一个驱动程序来允许 python 和 firefox 之间的通信。与此同时，我还加载了 Selenium 包。</p><p id="53cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用画中画:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6e26" class="mb mc it nb b gy nf ng l nh ni">pip install webdriverdownloader<br/>pip install selenium</span></pre><p id="e952" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我得到了我的 python 代码。在 Kaggle 笔记本中，我运行了以下代码来实际安装驱动程序。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9216" class="mb mc it nb b gy nf ng l nh ni">from webdriverdownloader import GeckoDriverDownloader<br/>gdd = GeckoDriverDownloader()<br/>gdd.download_and_install("v0.23.0")</span></pre><p id="f7e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后但同样重要的是，安装运行代码所需的一些额外的包</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="bca0" class="mb mc it nb b gy nf ng l nh ni">apt-get install -y libgtk-3-0 libdbus-glib-1-2 xvfb</span><span id="2ef3" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># Setting up the virtual display for Firefox</strong><br/>export DISPLAY=:99</span></pre><h2 id="f5fc" class="mb mc it bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">启动浏览器</h2><p id="60a9" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">请记住，我将在后台运行一个 web 浏览器，并使用它来加载 Google Maps 和提取一些数据。要在 Python 中做到这一点，首先从 Selenium 加载包，并实例化一个 Firefox 会话。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d9df" class="mb mc it nb b gy nf ng l nh ni"><strong class="nb iu"># Import the libraries for selenium</strong><br/>from selenium import webdriver as selenium_webdriver</span><span id="cc6b" class="mb mc it nb b gy nj ng l nh ni">from selenium.webdriver.firefox.options import Options as<br/>    selenium_options</span><span id="68e0" class="mb mc it nb b gy nj ng l nh ni">from selenium.webdriver.common.desired_capabilities import<br/>    DesiredCapabilities as selenium_DesiredCapabilities</span></pre><p id="477e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我设置了浏览器选项。我不希望 Firefox 生成一个真正的窗口，所以我用“无头”模式启动它。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="730f" class="mb mc it nb b gy nf ng l nh ni">browser_options = selenium_options()<br/>browser_options.add_argument("--headless")</span></pre><p id="4123" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我添加了浏览器的功能和实例。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7769" class="mb mc it nb b gy nf ng l nh ni"><strong class="nb iu"># Even more setup!</strong><br/>capabilities_argument = selenium_DesiredCapabilities().FIREFOX<br/>capabilities_argument["marionette"] = True</span><span id="7e34" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># This is the money.  We now have the browser object ready</strong><br/>browser = selenium_webdriver.Firefox(<br/>    options=browser_options,<br/>    firefox_binary="~/working/firefox/firefox",<br/>    capabilities=capabilities_argument<br/>)</span></pre><p id="83c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我可以开始抓取一些谷歌地图数据。</p><h2 id="5f29" class="mb mc it bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">提取谷歌地图图像</h2><p id="5ff5" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">下一步是找出我需要使用的 Google Maps URL，这样我就可以在 Selenium 中导航到它。格式如下:</p><blockquote class="nk"><p id="b24d" class="nl nm it bd nn no np nq nr ns nt lt dk translated">【https://www.google.com/maps/@】T2{ LAT }，{LNG}，{Z}z</p></blockquote><p id="dba5" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">其中:</p><ul class=""><li id="da5a" class="nz oa it la b lb lc le lf lh ob ll oc lp od lt oe of og oh bi translated">LAT:我们希望看到的位置的纬度</li><li id="2e1e" class="nz oa it la b lb oi le oj lh ok ll ol lp om lt oe of og oh bi translated">LNG:位置的经度</li><li id="9b1e" class="nz oa it la b lb oi le oj lh ok ll ol lp om lt oe of og oh bi translated">z:地图上的缩放级别(越大意味着越近)</li></ul><p id="ae5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我决定选择多伦多滨水区附近的某个地方，这样我就可以获得该地区的一些公园数据。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="41a1" class="mb mc it nb b gy nf ng l nh ni"><strong class="nb iu"># Toronto Waterfront Coordinates</strong><br/>lat = 43.640722<br/>lng = -79.3811892<br/>z = 17</span></pre><p id="d468" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我用它来生成一个 URL 并用我的浏览器导航:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d951" class="mb mc it nb b gy nf ng l nh ni"><strong class="nb iu"># Build the URL</strong><br/>url = '<a class="ae mz" href="https://www.google.com/maps/@'" rel="noopener ugc nofollow" target="_blank">https://www.google.com/maps/@'</a> + str(lat) + ',' + str(lng) +<br/>    ',' + str(z) + 'z'</span><span id="a255" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># Setting up the browser window size</strong><br/>browser.set_window_size(1024,512)<br/>browser.get(url)</span></pre><p id="184f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此时，浏览器保存了网站的所有信息，就像我手动完成的一样(在浏览器中检查)。我想看看这个网站，所以我在 Selenium 中使用了<strong class="la iu"> save_screenshot </strong>方法。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="8b11" class="mb mc it nb b gy nf ng l nh ni">browser.save_screenshot("before.png")</span></pre><p id="46ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是它看到的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/128164e79398f4ab95b7237a5a7397a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czJpdho-alDDapGYNfweBw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">谷歌地图的原始图像捕捉(多伦多滨水区)</p></figure><p id="682a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于硒的一个很酷的事情是你可以:</p><blockquote class="nk"><p id="0f56" class="nl nm it bd nn no np nq nr ns nt lt dk translated">a)解析 HTML 以提取任何页面数据</p><p id="88f1" class="nl nm it bd nn no np nq nr ns nt lt dk translated">b)在页面上执行 javascript</p></blockquote><p id="50ac" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">我想做的一件额外的事情是得到图像的适当缩放。例如，我想知道给定地图中公园的实际面积。不错的是，谷歌地图在其渲染中包括了一个比例尺。这意味着我可以选择这些元素来获得英尺数(实际页面上显示的内容)以及比例尺的宽度(以像素为单位)。因此，我有图像中每个像素的英尺数！</p><p id="de96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我是加拿大人，所以我把它转换成米:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a6ad" class="mb mc it nb b gy nf ng l nh ni"><strong class="nb iu"># Conversion factor from foot to meter</strong><br/>foot2meter = 0.3048</span><span id="47f6" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># Doing some light cleanup of the string and converting to float</strong><br/>scale_in_feet = float(browser.find_element_by_id('widget-scale<br/>    label').text.replace(' ft',''))</span><span id="e246" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># Now we have the scale in meters</strong><br/>scale_in_meters = scale_in_feet*foot2meter</span><span id="1c7f" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># Get the number of pixels the scale is drawn on, again cleaning</strong><br/>pixel_length = float(browser.find_element_by_class_name('widget<br/>    scale-ruler').value_of_css_property("width").replace('px',''))</span><span id="88c3" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># Taadaa we have the final scaling </strong><br/>MetersPerPixel = scale_in_meters/pixel_length</span></pre><p id="00dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我必须清理图像。正如你所看到的，图像上有一些重叠的元素(搜索栏等)。如果我想从原始地图中提取特征，那么我必须去掉它们。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="fc98" class="mb mc it nb b gy nf ng l nh ni"><strong class="nb iu"># Remove omnibox</strong><br/>js_string = "var element = document.getElementById(\"omnibox<br/>    container\");<br/>    element.remove();"<br/>browser.execute_script(js_string)</span><span id="461d" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># Remove username and icons</strong><br/>js_string = "var element =<br/>    document.getElementById(\"vasquette\");<br/>    element.remove();"<br/>browser.execute_script(js_string)</span><span id="f20e" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># Remove bottom scaling bar</strong><br/>js_string = "var element = document.getElementsByClassName(\"app<br/>    viewcard-strip\");<br/>    element[0].remove();"<br/>browser.execute_script(js_string)</span><span id="25c7" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># Remove attributions at the bottom</strong><br/>js_string = "var element = document.getElementsByClassName(\"scene<br/>    footer-container\");<br/>    element[0].remove();"<br/>browser.execute_script(js_string)ow I take another screenshot</span><span id="2344" class="mb mc it nb b gy nj ng l nh ni">browser.save_screenshot("waterfront.png")</span></pre><p id="5be2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我有一个干净的形象</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4a92968a16a84e82219c6320f0e84f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOqw3ZM1jnqn9kJ7MKJZuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个很好的干净的图像准备进行特征提取</p></figure><h2 id="3be0" class="mb mc it bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">地图特征提取+动画</h2><p id="0907" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">现在我有了我的图像，我想从中提取一些信息。对于这个具体的例子，我想知道绿色公园的<em class="on">面积的百分比和绝对值</em>(这就是为什么我需要上面的缩放)。除此之外，我想<em class="on">制作一个漂亮的动画</em>，展示图像是如何被扫描并提取绿色的。</p><p id="e72f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我在制作动画，所以我想把图片保存在单独的文件夹里，以保持整洁。我这样做是为了扫描和绘制线图:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f043" class="mb mc it nb b gy nf ng l nh ni">mkdir ~/working/frames<br/>mkdir ~/working/matplotlib</span></pre><p id="ecdb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我做编码的主要工作。我定义了一个函数，它能够扫描图像的像素，并确定它们是否在某个 RGB 范围内(有一些松弛)。我还传入了一个 image 对象，以允许在提取过程中拍摄快照。我基本上将所有像素覆盖为白色，只有当像素落在范围内时，我才保留原来的颜色:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9617" class="mb mc it nb b gy nf ng l nh ni"><strong class="nb iu"># The most important part!</strong><br/>def find_pixels(img,pixels,colour_set,slack, size):<br/>    num_px = [] <strong class="nb iu"># List to hold the amount of pixels that match</strong></span><span id="f418" class="mb mc it nb b gy nj ng l nh ni">    <strong class="nb iu"># Set the value you want for these variables</strong><br/>    r_min = colour_set[0]-slack<br/>    r_max = colour_set[0]+slack<br/>    g_min = colour_set[1]-slack<br/>    g_max = colour_set[1]+slack<br/>    b_min = colour_set[2]-slack<br/>    b_max = colour_set[2]+slack</span><span id="70af" class="mb mc it nb b gy nj ng l nh ni">    <strong class="nb iu"># Loop over the pixel array</strong><br/>    for x in range(size[0][0]):<br/>        num_px_col_count = 0<br/>        for y in range(size[0][1]):</span><span id="ef5d" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu">            # Extract the pixel colour data</strong><br/>            r, g, b,a = pixels[x,y]</span><span id="a289" class="mb mc it nb b gy nj ng l nh ni">            <strong class="nb iu"># Set the pixel to be white by default</strong><br/>            pixels[x,y]=(int(255), int(255), int(255),int(0))</span><span id="9e92" class="mb mc it nb b gy nj ng l nh ni">            <strong class="nb iu"># Check the see if there is a match!</strong><br/>            if r &gt;= r_min and r &lt;= r_max and b &gt;= b_min and <br/>                b &lt;= b_max and g &gt;= g_min and g &lt;= g_max:</span><span id="aa33" class="mb mc it nb b gy nj ng l nh ni">                <strong class="nb iu"># If there is a match add one to count<br/>                </strong>num_px_col_count = num_px_col_count + 1;</span><span id="ec1c" class="mb mc it nb b gy nj ng l nh ni">                <strong class="nb iu"># Colour the pixel back to the original</strong><br/>                pixels[x,y]=(colour_set[0], colour_set[1],<br/>                   colour_set[2],int(255))</span><span id="621a" class="mb mc it nb b gy nj ng l nh ni">        <strong class="nb iu"># Append the count to the list</strong><br/>        num_px.append(num_px_col_count)</span><span id="f05f" class="mb mc it nb b gy nj ng l nh ni">        <strong class="nb iu"># Save the image every 10 frames for animation</strong>      <br/>        if x % 10 == 0:<br/>            img.save('~/working/frames/' + str(x)+ '.png')</span><span id="3c80" class="mb mc it nb b gy nj ng l nh ni">return num_px</span></pre><p id="df24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然函数已经定义好了，我就可以实际使用它了。从导入我们的图像和动画库开始</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1b15" class="mb mc it nb b gy nf ng l nh ni">from PIL import Image,ImageDraw,ImageFont<br/>import matplotlib.pyplot as plt</span></pre><p id="01db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打开图像，转换为 RGBA，并将像素载入数组</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ff54" class="mb mc it nb b gy nf ng l nh ni">img = Image.open('~/working/waterfront.png')<br/>img = img.convert('RGBA')<br/>pixels = img.load()</span></pre><p id="7438" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我必须手动做的一件事是确定谷歌地图中给出的公园的颜色。我只是用一个工具选择屏幕上的像素来提取这个。现在我把它立起来，放松一下。在一些像素具有小的颜色可变性的情况下，松弛被用作缓冲器。我把它传递给我们上面定义的函数</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ac11" class="mb mc it nb b gy nf ng l nh ni">park_colour = [197,232,197];park_slack = 2;<br/>num_park = find_pixels(img,pixels,park_colour,park_slack,[img.size])</span></pre><p id="f30f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此时，我实际上已经拥有了我需要的一切！干得好！该看动画了。还记得<strong class="la iu"> num_park </strong>是如何包含每列匹配的像素数的吗？这意味着我可以绘制这个并创建另一个动画。使用图像大小，我创建了一个 matplotlib 图形，并将所有背景、轴和元素设置为白色，以获得一个空白的石板。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="994f" class="mb mc it nb b gy nf ng l nh ni"><strong class="nb iu"># All this is to make a totally blank matplotlib image</strong><br/>fig=plt.figure(figsize=(1024/100,438/100))<br/>ax = fig.add_subplot(111)<br/>ax.set_facecolor("white")<br/>fig.patch.set_facecolor("white")<br/>fig.patch.set_alpha(0.0)<br/>for spine in ax.spines.values():<br/>    spine.set_edgecolor('white')<br/>plt.grid(False)<br/>plt.axis('off')</span></pre><p id="fcfe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于图像处理，我希望图像的比例相同，所以我继续在图中设置缩放比例</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3595" class="mb mc it nb b gy nf ng l nh ni">ax.set_xlim([-10,1024])<br/>ax.set_ylim([-10,438])</span></pre><p id="20af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，每隔 10 个元素循环一次，创建一个线图。一旦创建，只需保存它！</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9c52" class="mb mc it nb b gy nf ng l nh ni">for i in range(0,1024,10):<br/>    ax.plot(num_park[:i],color='#377e4d',linewidth=3,<br/>        antialiased=True)<br/>    plt.savefig('~/working/matplot/'+str(i)+'.png',<br/>        transparent=True,dpi=130)</span></pre><p id="f3d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我有做出最终结果所需的所有图像和数据。</p><p id="cfa7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我从提取中得到总面积。使用米像素和图像大小，我可以得到以千米为单位的总面积</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2d25" class="mb mc it nb b gy nf ng l nh ni">total_area = img.size[0]*img.size[1]*MetersPerPixel/(1000*1000)</span></pre><blockquote class="oo op oq"><p id="2d07" class="ky kz on la b lb lc ju ld le lf jx lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated">0.432 公里~图像的 20%</p></blockquote><p id="832b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，使用 PIL 创建一个动画 GIF。在下面的例子中，我每隔 10 帧循环一次，从上面捕捉加载预先生成的图像，并将它们添加到一个帧列表中。这个帧列表将被传递给动画函数来生成最终的文件。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="964c" class="mb mc it nb b gy nf ng l nh ni"><strong class="nb iu"># Loop over every 10 frames</strong><br/>frames = []<br/>for i in range(0,1024,10):</span><span id="e1bf" class="mb mc it nb b gy nj ng l nh ni">    <strong class="nb iu"># Load the other images we will overlay</strong><br/>    googlemap = Image.open('/kaggle/working/frames/'+ str(i)+".png")</span><span id="4fdf" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu">    # Do resampling to get the smoothing effect</strong><br/>    googlemap = googlemap.resize(googlemap.size,<br/>        resample=Image.ANTIALIAS)</span><span id="417b" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># Append the frames</strong><br/>frames.append(googlemap)</span><span id="6e15" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># Save the final .gif<br/></strong>frames[0].save('googlemap.gif', format='GIF',<br/>    append_images=frames[1::], save_all=True, duration=1, loop=0)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4981bafa3bdee15dc45e10db07d5840c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OMdaR5TiDDnS6Y2hl_udig.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扫描公园的动画</p></figure><p id="2fd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为最后的措施，我还覆盖了动画 matplotlib 图。唯一的区别是我们将使用。<strong class="la iu">粘贴</strong>PIL 的方法来叠加图像。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f59b" class="mb mc it nb b gy nf ng l nh ni"><strong class="nb iu"># Loop over every 10 frames</strong><br/>frames = []<br/>for i in range(0,1024,10):</span><span id="fdc7" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu">    # Load the other images we will overlay</strong><br/>    googlemap = Image.open('/kaggle/working/frames/'+ str(i)+".png")<br/>    matplot = Image.open('/kaggle/working/matplot/'+str(i)+'.png')</span><span id="7de9" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu">   # Overlay the matplotlib plot animation frames (NB we include<br/>   offsets for the image here has well (-175,-52) for alignment<br/>   </strong>googlemap.paste(matplot, (-175, -52),matplot)</span><span id="a34d" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu">    # Do resampling to get the smoothing effect</strong><br/>    googlemap = googlemap.resize(googlemap.size,<br/>        resample=Image.ANTIALIAS)</span><span id="7176" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># Append the frames</strong><br/>frames.append(googlemap)</span><span id="1eaa" class="mb mc it nb b gy nj ng l nh ni"><strong class="nb iu"># Save the final .gif<br/></strong>frames[0].save('FINAL.gif', format='GIF',<br/>    append_images=frames[1::], save_all=True, duration=1, loop=0)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c66cb92aae99e56c33b73e932fbbdbde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*o3rgY1QgRgi_EdQbmxbxKQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">绿地密度提取(扫描谷歌地图图像)</p></figure><p id="524e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你知道了！现在，我们可以做一些真正有趣的事情，如纵向交通扫描，甚至查看跑步路线，看看周围地区有多酷！</p><h2 id="4e3b" class="mb mc it bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">参考</h2><div class="ou ov gp gr ow ox"><a href="https://www.kaggle.com/kapastor/google-maps-feature-extraction-selenium-pil" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">谷歌地图特征提取- Selenium+Pil</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">使用 Kaggle 笔记本探索和运行机器学习代码|使用来自多个数据源的数据</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">www.kaggle.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div></div></div>    
</body>
</html>