<html>
<head>
<title>Learning Python 10 minutes a day #23</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每天 10 分钟学习 Python # 23</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learning-python-10-minutes-a-day-23-8fd7e119da8d?source=collection_archive---------54-----------------------#2020-09-02">https://towardsdatascience.com/learning-python-10-minutes-a-day-23-8fd7e119da8d?source=collection_archive---------54-----------------------#2020-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/861a215f083567059b0616591c415d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kjLLayjOlfsSupnd.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@jeremy_justin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰瑞米·拉帕克</a>在<a class="ae jg" href="/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原始照片。</p></figure><h2 id="83a4" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/10minutespython" rel="noopener" target="_blank">每天 10 分钟 Python 速成班</a></h2><div class=""/><div class=""><h2 id="b1be" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">一种全新的程序设计</h2></div><p id="8b06" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是一个<a class="ae jg" href="https://python-10-minutes-a-day.rocks" rel="noopener ugc nofollow" target="_blank">系列</a>10 分钟的简短 Python 文章，帮助您提高 Python 知识。我试着每天发一篇文章(没有承诺)，从最基础的开始，到更复杂的习惯用法。如果您对 Python 的特定主题有任何问题或要求，请随时通过 LinkedIn 联系我。</p><p id="d47b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当深入了解编程时，你会遇到两大范例:函数式编程和面向对象编程(OOP)。到目前为止，我们主要做的被称为函数式编程。我还没有为这两个术语找到一个令人满意的全面定义。然而，关键的区别是，函数式编程，顾名思义，是以函数为中心的，程序结构就像一步一步的食谱，而 OOP 是以数据为中心的，数据是以对象为结构的。这主要是处理问题的不同方式。这两种范式之间没有真正的好与坏，因为人们更喜欢网球而不是足球。有时，一种方法似乎更容易解决问题，但我相信你可以用两种方法获得相同的结果。OOP 和函数式方法都与 Python 兼容。</p><p id="afec" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">OOP 的核心思想是将程序抽象成对象。对象是将数据和与特定数据相关的代码结合在一起的结构。OOP 的鼓吹者声称这减少了重复的次数，使代码更具可读性。我必须承认，这个想法非常好，确实有一些好处。作为一个很好的入门例子，让我们为一个动物创建一个对象，看看 OOP 在 Python 中是如何工作的。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="0a82" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个结构看起来并不困难，但是有一些新的概念。要开始一个类定义，首先要有 class 关键字，然后是一个名称。按照惯例，类名以大写字母开头，但是从 Python 的角度来看，任何名称都可以(但是请务必大写)。类似于函数定义，我们有一个分号，所有缩进的代码都属于这个定义。提供一个 DocString 来描述该类是一个很好的做法。在定义本身中，我们现在可以创建变量和方法。方法是类定义中函数的名字。</p><p id="009b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">了解<em class="mj">类定义</em>和<em class="mj">类实例</em>之间的区别很重要。我们在前面的例子中创建的代码从类定义开始，为我们的对象创建一个蓝图。当我们想要使用特定类型的对象时，我们需要创建一个实例。在定义了我们的<em class="mj">动物</em>类之后，我们创建了该类的两个实例:<em class="mj"> animal1 </em>和<em class="mj"> animal2 </em>。虽然蓝图定义了哪些数据和方法是可用的，但它并不包含数据本身。当创建类的实例时，我们创建包含实际数据的对象。在我们的示例中，<em class="mj"> animal1 </em>和<em class="mj"> animal2 </em>都属于类型<em class="mj"> Animal </em>，但是它们包含不同的数据:青蛙代表<em class="mj"> animal1 </em>，犀牛代表<em class="mj"> animal2 </em>。您可以为以前定义的类创建任意多个实例。</p><p id="ed50" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当创建一个类的实例时，我们调用 Python 的一个特殊方法:构造函数。我们可以看到它的特别之处，因为它的名字被<em class="mj">双下划线</em>所包围。这些所谓的<em class="mj"> dunder-methods </em>在 Python 中被给予了特殊处理。init <em class="mj"> dunder-method </em>表示构造函数，一个在创建类实例时调用的方法。方法可以像常规函数一样接受参数，但是类有一个强制的第一个参数:<em class="mj"> self </em>。Python 中的任何类方法都需要这个参数，原因是这个特定的对象包含实例的数据。当我们在 Python 中定义一个类时，我们有一个对该类的引用。这个定义对每个物体都是一样的。为了让每个实例拥有自己的数据集，比如我们有一只青蛙和一只犀牛，每个类都有一个保存实际数据的<em class="mj"> self </em>对象。在构造函数中，我们定义了创建的变量并将数据添加到这个<em class="mj"> self </em>对象中。该对象在实例之间共享，但不在不同的实例之间共享。现在，我们可以在类中定义的其他方法中使用该实例数据，比如在<em class="mj"> description() </em>方法中。这是 Python 开发人员想出的在实例级别存储数据的解决方案。虽然您可以在类级别定义变量(其他编程语言会这样做)，但这可能会导致不希望的结果:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="2adf" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这不是一个 bug，而是 Python 的工作方式。该列表是在定义类时定义的。每个实例都获得一个对该列表的引用，因此所有实例共享该列表。这只适用于可变对象。不可变对象通常会在再次更改时获得一个新的引用，因此会覆盖以前的引用。请注意，不要使用默认方法在构造函数中定义所有参数(通常应该使用这种方法)。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7a42" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们添加到<em class="mj"> self </em>对象的所有变量都可以使用点符号来访问。一般来说，对象中的所有变量都称为属性，而所有函数都称为方法。两者都应该有唯一的名称，并且可以使用<code class="fe mk ml mm mn b">&lt;object name&gt;.&lt;attribute name&gt;</code>或<code class="fe mk ml mm mn b">&lt;object name&gt;.&lt;method name&gt;()</code>来访问。这与 Python 中任何对象的符号相同。字符串和整数都是具有相同方法论的对象。然而，这些类定义了更多的方法。如果对象被加在一起，或者如果对象被相乘，有一些特殊的方法来处理对象的打印。我们还可以定义这些，并根据这些定义制定我们自己的规则:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="e149" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该类还有两个 dunder-方法。第一个负责类的表示。如果我们简单地输入代表类实例的变量名，即 number1，它将调用<em class="mj"> repr dunder-method </em>并返回它的表示。这个方法必须返回一个字符串，但是这个字符串是什么，我们可以自由定义。第二个<em class="mj"> dunder-method </em>定义了如何添加两个对象。它期望作为一个参数，紧挨着强制的<em class="mj"> self </em>对象，也就是另一个对象。从技术上来说，这可能是任何对象，我们必须在做加法之前测试它是哪种类型。现在，我们假设它将是相同的类型。这可以是任何定义，甚至是我们在这个例子中所做的其他东西。这是非常强大的，因为你可以定义对象，例如联系卡，并使用添加功能，合并两个联系人。当我们使用 Pathlib 模块中的 Path 时，我们看到了一个有趣的例子。路径定义了 divide dunder-method，它将路径:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="241d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于每个数学运算，都有一个可以定义或重载的<em class="mj"> dunder-method </em>。重载意味着你用一个新的定义覆盖一个现有的方法，这个方法可以是一个常规的方法或者是一个<em class="mj"> dunder-methods </em>中的一个。还有几个其他的<em class="mj"> dunder-methods </em>，例如迭代相关的主题。不需要很努力地去了解他们，但是知道他们的存在确实很好。</p><h1 id="663d" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">今天的练习:</h1><p id="4dc9" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">作为一种抽象形式，类是很棒的，特别适合于表示我们在现实生活中知道的对象。许多游戏都需要骰子来玩，有各种各样的骰子可供选择。有些人只有四张脸，而有些人可能有 100 张脸。</p><p id="1324" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">赋值:</strong> <br/>创建一个骰子类，输入面的数量作为参数。它应该有一个 throw()函数来掷骰子，当然是使用正确的骰子，即一个四面骰子只能掷出 1、2、3 或 4 个骰子。它还应该包含一个 history()方法来显示过去的骰子点数()和一个漂亮的 repr dunder 函数来告诉我们是哪个骰子。</p><p id="cbd2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">提示:<br/> 1。作为 randint(a，b)函数的随机模块在(a，b)之间(包括两个边界)生成随机数。可能对掷骰子有用；-).<br/> 2。你可以使用一个列表来跟踪所有以前的滚动。</p><p id="b34c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我的 Github 上发布了一个解决方案。</p><p id="a81e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如有任何问题，欢迎通过<a class="ae jg" href="https://www.linkedin.com/in/dennisbakhuis/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div></div>    
</body>
</html>