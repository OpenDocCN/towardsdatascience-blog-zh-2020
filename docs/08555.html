<html>
<head>
<title>Decorators in Python: Fundamentals for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的装饰者:数据科学家的基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/decorators-in-python-fundamentals-for-data-scientists-eada7f4eba85?source=collection_archive---------33-----------------------#2020-06-21">https://towardsdatascience.com/decorators-in-python-fundamentals-for-data-scientists-eada7f4eba85?source=collection_archive---------33-----------------------#2020-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="69d5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用一个具体的例子来理解基础！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bf37cfc7f628a2f019977a8145ec2e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5-f4VZ_qPxaDN4wO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">戈兰·艾沃斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中的Decorators用于扩展可调用对象的功能，而无需修改其结构。基本上，装饰函数包装另一个函数来增强或修改它的行为。</p><p id="6ede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将向你介绍Python中装饰者的基础知识。</p><p id="eb10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们编写一个包含装饰器实现示例的Python3代码:</p><h1 id="8ce0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">装饰定义</strong></h1><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="6679" class="ms lw it mo b gy mt mu l mv mw">def <strong class="mo iu">decorator_func_logger</strong>(<strong class="mo iu">target_func</strong>):<br/> def <strong class="mo iu">wrapper_func</strong>():<br/>   print("Before calling", <strong class="mo iu">target_func</strong>.__name__)<br/>   target_func()<br/>   print("After calling", <strong class="mo iu">target_func</strong>.__name__)<br/> <br/> return <strong class="mo iu">wrapper_func</strong></span><span id="6511" class="ms lw it mo b gy mx mu l mv mw"><br/>def <strong class="mo iu">target()</strong>:<br/> print('Python is in the decorated target function')</span><span id="1541" class="ms lw it mo b gy mx mu l mv mw"><strong class="mo iu">dec_func</strong> = <strong class="mo iu">decorator_func_logger</strong>(<strong class="mo iu">target</strong>)<br/><strong class="mo iu">dec_func()</strong></span><span id="5a82" class="ms lw it mo b gy mx mu l mv mw"><strong class="mo iu"><em class="my">Output:</em></strong><em class="my"><br/></em>air-MacBook-Air:$ <strong class="mo iu">python DecoratorsExample.py</strong><br/>('Before calling', 'target')<br/>Python is in the decorated target function<br/>('After calling', 'target')</span></pre><p id="eddc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的装饰结构帮助我们在调用目标函数之前和之后在控制台上显示一些注释。</p><p id="9010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是定义装饰器的简单步骤；</p><ul class=""><li id="3209" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">首先，我们应该定义一个可调用的对象，比如一个<strong class="lb iu">装饰函数</strong>，其中也包含一个包装函数。</li><li id="bef9" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">装饰函数应该将一个<strong class="lb iu">目标函数</strong>作为参数。</li><li id="488b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">它应该返回<strong class="lb iu">包装函数</strong>，该函数扩展了作为参数传递的目标函数。</li><li id="2a67" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">包装函数</strong>应包含一个<strong class="lb iu">目标函数调用</strong>以及扩展目标函数行为的代码。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/fac3774ae728ccf78e566c940a1ea93f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l77wMyQll8BRgURv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多鲁克·耶梅尼西在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="386c" class="ms lw it mo b gy mt mu l mv mw">def <strong class="mo iu">decorator_func_logger</strong>(<strong class="mo iu">target_func</strong>):<br/> def <strong class="mo iu">wrapper_func</strong>():<br/>   print("Before calling", <strong class="mo iu">target_func</strong>.__name__)<br/>   target_func()<br/>   print("After calling", <strong class="mo iu">target_func</strong>.__name__)<br/> <br/> return <strong class="mo iu">wrapper_func</strong></span><span id="f134" class="ms lw it mo b gy mx mu l mv mw">@<strong class="mo iu">decorator_func_logger</strong><br/>def <strong class="mo iu">target()</strong>:<br/> print('Python is in the decorated target function')</span><span id="ae44" class="ms lw it mo b gy mx mu l mv mw"><strong class="mo iu">target()</strong></span><span id="c028" class="ms lw it mo b gy mx mu l mv mw"><strong class="mo iu"><em class="my">Output:</em></strong><em class="my"><br/></em>air-MacBook-Air:$ <strong class="mo iu">python DecoratorsExample.py</strong><br/>('Before calling', 'target')<br/>Python is in the decorated target function<br/>('After calling', 'target')</span></pre><p id="1e09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python提供的语法糖的帮助下，我们可以简化decorator定义，如上所示。</p><p id="4850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意@<strong class="lb iu">decorator _ func _ logger</strong>被添加在我们想要修饰的<strong class="lb iu"> target </strong>函数之前。然后我们可以直接调用目标函数。不需要像我们在第一个例子中所做的那样，显式地分配装饰器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/94426fa03a5acb026b75cdf857cc3284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y5lGECqFCeryOEdS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多鲁克·耶梅尼奇在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="4399" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">用参数定义多个装饰器和装饰函数</strong></h1><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="6ea5" class="ms lw it mo b gy mt mu l mv mw"><strong class="mo iu">import time</strong></span><span id="3297" class="ms lw it mo b gy mx mu l mv mw"><em class="my">def</em> <strong class="mo iu">decorator_func_logger(<em class="my">target_func</em>):</strong><br/> <em class="my">def</em> <strong class="mo iu">wrapper_func(</strong><strong class="mo iu">*args, **kwargs</strong><strong class="mo iu">):</strong><br/>  print("Before calling", target_func.__name__)<br/>  <strong class="mo iu">target_func(</strong><strong class="mo iu">*args, **kwargs</strong><strong class="mo iu">)</strong><br/>  print("After calling", target_func.__name__)<br/> return <strong class="mo iu">wrapper_func</strong></span><span id="979c" class="ms lw it mo b gy mx mu l mv mw"><em class="my">def</em> <strong class="mo iu">decorator_func_timeit(<em class="my">target_func</em>):</strong><br/> <em class="my">def</em> <strong class="mo iu">wrapper_func(</strong><strong class="mo iu">*args, **kwargs</strong><strong class="mo iu">):</strong><br/>  ts = time.time()<br/>  <strong class="mo iu">target_func(</strong><strong class="mo iu">*args, **kwargs</strong><strong class="mo iu">)</strong><br/>  te = time.time()<br/>  print (target_func.__name__, (te - ts) * 1000)<br/> return <strong class="mo iu">wrapper_func</strong></span><span id="1067" class="ms lw it mo b gy mx mu l mv mw"><strong class="mo iu">@decorator_func_logger<br/>@decorator_func_timeit</strong><br/><em class="my">def</em> <strong class="mo iu">target(<em class="my">loop</em>):</strong><br/> count = 0<br/> print('Python is in the decorated target function')<br/> for number in range(loop):<br/>  count += number</span><span id="67de" class="ms lw it mo b gy mx mu l mv mw"><strong class="mo iu">target(100)<br/>target(3000)</strong></span><span id="018f" class="ms lw it mo b gy mx mu l mv mw"><strong class="mo iu"><em class="my">Output:</em></strong><em class="my"><br/></em>air-MacBook-Air:$ <strong class="mo iu">python DecoratorsExample.py</strong></span><span id="f518" class="ms lw it mo b gy mx mu l mv mw">('Before calling', 'wrapper_func')<br/>Python is in the decorated target function<br/>('target', 0.015974044799804688)<br/>('After calling', 'wrapper_func')</span><span id="e568" class="ms lw it mo b gy mx mu l mv mw">('Before calling', 'wrapper_func')<br/>Python is in the decorated target function<br/>('target', 0.47397613525390625)<br/>('After calling', 'wrapper_func')</span></pre><p id="b036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用' @ '语法在目标函数之前添加几个装饰器，可以很容易地用多个装饰器来装饰目标函数。装饰器的执行顺序将与它们在目标函数之前的排列顺序相同。</p><p id="f5de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在我们的目标函数中有一个参数<strong class="lb iu"> loop </strong>。只要包装函数使用相同的参数，这就没有问题。为了确保装饰器可以灵活地接受任意数量的参数，包装器函数使用了<strong class="lb iu"> (*args，**kwargs) </strong>参数。</p><h1 id="1e93" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关键要点</h1><ul class=""><li id="6abc" class="mz na it lb b lc np lf nq li nr lm ns lq nt lu ne nf ng nh bi translated">Decorators定义了可重用的代码块，您可以将这些代码块应用到可调用的对象(函数、方法、类、对象)来修改或扩展其行为，而无需修改对象本身。</li><li id="c645" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">考虑到你的脚本中有许多函数执行许多不同的任务，你需要给所有的函数添加特定的行为。在这种情况下，将相同的代码块复制到函数中以获得所需的功能并不是一个好的解决方案。你可以简单地修饰你的函数。</li></ul><h1 id="0360" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="3791" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在这篇文章中，我解释了Python中decorators的基础知识。</p><p id="f976" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章中的代码可以在<a class="ae ky" href="https://github.com/eisbilen/DecoratorsExample" rel="noopener ugc nofollow" target="_blank">我的GitHub库中找到。</a></p><p id="fcbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用。</p><p id="e702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>