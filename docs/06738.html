<html>
<head>
<title>End-to-End Machine Learning Project: Part-2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">端到端机器学习项目:第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/end-to-end-machine-learning-project-627ed48f8109?source=collection_archive---------55-----------------------#2020-05-26">https://towardsdatascience.com/end-to-end-machine-learning-project-627ed48f8109?source=collection_archive---------55-----------------------#2020-05-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/d4c8107dc1a696d2504bed85577761a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TNgmyLb7396ZFTyi"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">杰克·安斯蒂在<a class="ae jh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><p id="4dbb" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在<a class="ae jh" rel="noopener" target="_blank" href="/end-to-end-machine-learning-project-part-1-806d04da8deb">之前的帖子</a>中，我们看到了我如何训练一个图像分类模型，从数据准备开始到训练模型的不同迭代，都使用了<em class="lf">卷积神经网络</em>和<em class="lf">转移学习</em>来获得一个对美钞进行分类的最终模型。如果你还没有，我建议你先浏览一下那篇文章，然后再来看这篇文章。</p><blockquote class="lg lh li"><p id="c11a" class="kh ki lf kj b kk kl km kn ko kp kq kr lj kt ku kv lk kx ky kz ll lb lc ld le in bi translated"><a class="ae jh" rel="noopener" target="_blank" href="/end-to-end-machine-learning-project-part-1-806d04da8deb"> <em class="jk"> Part-1(前一篇)</em> </a> <em class="jk">:准备数据并训练图像分类模型<br/> Part-2(后一篇):使用Flask和Docker部署模型</em></p></blockquote><p id="24ae" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">训练完模型后，下一个挑战就是展示它。我不想在云资源托管上花费太多，所以我尝试了许多不同的选项，但找不到一个看起来足够容易快速启动和运行的选项。相信我，当我说<em class="lf">有大量的资源和教程讨论如何创建和训练你的深度学习模型，但只有少数资源谈论部署这些模型</em>。</p><h1 id="96c2" class="lm ln jk bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">用什么“工具”？</h1><p id="f59e" class="pw-post-body-paragraph kh ki jk kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le in bi translated">当我接近完成这个模型的时候，这个问题在我的脑海里打转。我知道我想部署这种模式，但不确定平台——它应该是一个本地移动应用程序还是一个web应用程序。在进一步讨论之后，我选择了一个快捷的web应用程序，这样就可以通过浏览器从任何设备访问它。</p><p id="8d30" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我选择了用<a class="ae jh" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank"><em class="lf">Flask</em></a><em class="lf">—</em>一个轻量级的<a class="ae jh" href="https://wsgi.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> WSGI </a> web应用框架。它是可用的最流行的Python web应用程序框架之一，以其简单易用以及能够扩展以构建更复杂的应用程序而闻名。</p><p id="10ad" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">对于这个部署，我选择使用我现有的云服务器— <a class="ae jh" href="https://www.linode.com/products/nanodes/" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> a Nanode </em> </a>，以避免投资额外的云资源，并决定采用基于容器的方法。</p><blockquote class="lg lh li"><p id="c675" class="kh ki lf kj b kk kl km kn ko kp kq kr lj kt ku kv lk kx ky kz ll lb lc ld le in bi translated">容器是一个标准的软件单元，它将代码及其所有依赖项打包，以便应用程序能够快速可靠地从一个计算环境运行到另一个计算环境。(<a class="ae jh" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></blockquote><p id="ab05" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我决定使用<a class="ae jh" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> Docker、</em> </a> <em class="lf">，它提供了一种使用公共运行时在同一台机器上运行多个容器的方法，即</em> <a class="ae jh" href="https://www.docker.com/products/container-runtime" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> Docker引擎</em> </a> <em class="lf">。</em></p><figure class="mq mr ms mt gu iw gi gj paragraph-image"><div class="gi gj mp"><img src="../Images/9daf5d38997677ea1176e1389e2754aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*_-TtbkslhfDInzm9hTzorg.jpeg"/></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图1:使用Docker的容器化应用程序</p></figure><p id="a733" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">对于托管应用程序，我选择了Nginx，它提供了一个代理服务器来托管您的web应用程序。</p><blockquote class="lg lh li"><p id="ec6d" class="kh ki lf kj b kk kl km kn ko kp kq kr lj kt ku kv lk kx ky kz ll lb lc ld le in bi translated">NGINX是一个免费、开源、高性能的HTTP服务器和反向代理，以及一个IMAP/POP3代理服务器。NGINX以其高性能、稳定性、丰富的特性集、简单的配置和低资源消耗而闻名。(<a class="ae jh" href="https://www.nginx.com/resources/wiki/" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></blockquote><h1 id="593c" class="lm ln jk bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">构建基于Flask的web应用程序</h1><p id="b13a" class="pw-post-body-paragraph kh ki jk kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le in bi translated">我发现这个非常有用的<a class="ae jh" href="https://github.com/mtobeiyf/keras-flask-deploy-webapp" rel="noopener ugc nofollow" target="_blank"> GitHub项目</a> [1],它提供了一个简单的模板来使用<em class="lf"> Flask </em>将你训练好的图像分类模型部署为一个web应用。我对[1]中的代码做了一些修改，通过加载我训练过的模型(我正在使用一个<em class="lf">)使它特定于我的模型的目标。tf </em>模型而不是使用<em class="lf"> .h5 </em>文件)、设置输出类名、设置成功预测的概率阈值等。所有这些更改都是对作为flask web应用程序主要后端的<em class="lf"> app.py </em>文件进行的。</p><p id="2569" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我还对这个项目的<em class="lf"> CSS(网页样式)和JavaScript文件</em>做了一些小的改动。</p><p id="6151" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">你可以参考这个项目的<a class="ae jh" href="https://github.com/impiyush/Projects/tree/master/Recognize_US_Bills" rel="noopener ugc nofollow" target="_blank">我的GitHub库的所有这些变化。</a></p><h1 id="5407" class="lm ln jk bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">设置服务器(正确…)</h1><p id="9b3e" class="pw-post-body-paragraph kh ki jk kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le in bi translated">这是这个部署难题中最重要的一块，我可能花了最多的时间来研究、完成和设置它，甚至比构建模型本身还多。 </p><p id="c395" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">第一步是根据操作系统(OS)在您的服务器上安装最新版本的Docker。我有一个Ubuntu盒子作为我的服务器，所以我按照这个快速<a class="ae jh" href="https://www.linode.com/docs/applications/containers/how-to-install-docker-and-pull-images-for-container-deployment/" rel="noopener ugc nofollow" target="_blank">指南</a> [2]安装Docker，这是一帆风顺的。</p><p id="92ee" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">下一步是找到一种方法，使用多个docker容器在同一服务器上部署不同的应用程序。经过大量的谷歌搜索，我偶然发现了这篇令人惊叹的<a class="ae jh" href="https://olex.biz/2019/09/hosting-with-docker-nginx-reverse-proxy-letsencrypt" rel="noopener ugc nofollow" target="_blank">文章</a>【3】，它与我试图实现的目标相似，作者用非常好和简单的方式解释了这一切。</p><figure class="mq mr ms mt gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj mu"><img src="../Images/7ac3419789c746c79ddccfa8eab3c335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_CsmB_4QZl0X1xBZk2L9Q.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图2:使用Nginx反向代理和Docker的部署</p></figure><p id="8c64" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这里，nginx反向代理充当这个设置的<em class="lf">主</em>容器，监听外部端口80 (HTTP)和443 (HTTPS)，充当世界和<em class="lf">从</em>容器之间的通信媒介。<em class="lf">从</em>容器本身的内部工作是隐藏的，用户在访问这些应用程序时看不到任何区别。</p><p id="0181" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">按照[3]中的<a class="ae jh" href="https://olex.biz/2019/09/hosting-with-docker-nginx-reverse-proxy-letsencrypt/#nginx-reverse-proxy-and-ssl" rel="noopener ugc nofollow" target="_blank">示例docker-compose.yml </a>，我为充当<em class="lf">主容器的服务器设置了我的nginx反向代理和SSL版本，同时按照docker-compose中的定义设置了网络。</em></p><p id="3d1a" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">下一步是创建一个<em class="lf">从属容器</em>，它将托管我的web应用程序。为此，我基于[3]和这个<a class="ae jh" href="https://dev.to/ishankhare07/nginx-as-reverse-proxy-for-a-flask-app-using-docker-3ajg" rel="noopener ugc nofollow" target="_blank"> post </a> [4】的组合创建了一个容器应用程序，它使用docker文件来设置承载项目的容器。基于我的项目需求，我修改了docker-compose和Dockerfile。</p><figure class="mq mr ms mt gu iw gi gj paragraph-image"><div class="gi gj mv"><img src="../Images/11e591bc0772933a0f8cb6ae4128cbe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*vV6chcsTBp_u8rs17-MQOw.jpeg"/></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图片-3: Dockerfile(作者提供图片)</p></figure><p id="5a69" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">项目容器基于docker hub的<em class="lf">tensor flow-2 . 0 . 0-py3 docker image</em>，使用python3和tensorflow-2.0。点击这里查看你可以在项目中使用的其他tensorflow图片列表。下载完基础映像后，我将项目的flask应用程序和模型复制到这个容器中，并使用pip安装运行项目的需求。</p><figure class="mq mr ms mt gu iw gi gj paragraph-image"><div class="gi gj mw"><img src="../Images/46e906b8a3825c20ddeaab1000cf944f.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*X5YKztoFCEr_wCh6UaMDtA.jpeg"/></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图4: Docker撰写(作者提供照片)</p></figure><p id="a482" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">最终的docker-compose文件使用上述docker文件来创建一个名为<em class="lf"> usbills </em>的容器，该容器托管模型和web应用程序。它还创建了一个nginx服务，这个服务<em class="lf">依赖</em> <em class="lf">依赖</em><em class="lf">usbills</em>容器，也就是说，如果构建us bills容器时出现问题，nginx容器将不会被创建。</p><p id="af8e" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这个nginx容器的environment部分设置了一个VIRTUAL_HOST，它是这个web应用程序的DNS名称，一旦部署了这个容器，就可以访问它。<em class="lf">这个nginx容器充当从容器，并根据从服务器主容器接收的请求工作。</em></p><p id="9769" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一旦创建了这两个文件，并且我确保了<em class="lf">主容器</em>正常工作，那么只需编写一行命令就可以托管这个应用程序了。</p><pre class="mq mr ms mt gu mx my mz na aw nb bi"><span id="87ff" class="nc ln jk my b gz nd ne l nf ng">$ docker-compose up -d</span></pre><h1 id="faed" class="lm ln jk bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="33c9" class="pw-post-body-paragraph kh ki jk kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le in bi translated">如上面的docker-compose所示，通过访问这个<a class="ae jh" href="https://projects.impiyush.com/" rel="noopener ugc nofollow" target="_blank">链接</a>，可以从任何设备和浏览器访问这个web应用程序。在我最终建立和部署这个模型之前，我花了很多时间<em class="lf">搜索、阅读、理解、尝试和失败。这种多容器部署方法还为将来在同一台服务器上使用类似的docker-compose设置轻松部署任何其他应用程序奠定了基础。</em></p><p id="2ab7" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">希望您喜欢这个两部分的系列。我知道这种方法可能不适合每个人，但希望它能帮助那些和我处境相同的人，他们正在寻找部署我训练有素的模型的方法，而不必花费大量的云资源。请随意使用这种方法来共享您的模型部署的链接，或者如果您有任何其他比这种方法更好的方法。</p><p id="9c04" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><em class="lf">不断学习，打造酷炫模型。下次见… </em></p><h1 id="c636" class="lm ln jk bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">参考</h1><p id="d742" class="pw-post-body-paragraph kh ki jk kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le in bi translated">[1] <a class="ae jh" href="https://github.com/mtobeiyf/keras-flask-deploy-webapp" rel="noopener ugc nofollow" target="_blank">用flask作为web app在10分钟内部署Keras模型</a><br/>【2】<a class="ae jh" href="https://www.linode.com/docs/applications/containers/how-to-install-docker-and-pull-images-for-container-deployment/" rel="noopener ugc nofollow" target="_blank">如何安装Docker并拉取映像进行容器部署</a><br/>【3】<a class="ae jh" href="https://olex.biz/2019/09/hosting-with-docker-nginx-reverse-proxy-letsencrypt/" rel="noopener ugc nofollow" target="_blank">托管多个站点使用Docker和NGINX反向代理使用SSL</a><br/>【4】<a class="ae jh" href="https://dev.to/ishankhare07/nginx-as-reverse-proxy-for-a-flask-app-using-docker-3ajg" rel="noopener ugc nofollow" target="_blank">NGINX作为flask app的反向代理使用Docker</a><br/>【5】<a class="ae jh" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">什么是容器？</a></p></div></div>    
</body>
</html>