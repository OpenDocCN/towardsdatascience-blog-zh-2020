<html>
<head>
<title>Beginner’s guide to deploying H2o models as APIs using FLASK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用FLASK将H2o模型部署为API的初学者指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploying-h2o-models-as-apis-using-flask-42065a4fa567?source=collection_archive---------24-----------------------#2020-06-21">https://towardsdatascience.com/deploying-h2o-models-as-apis-using-flask-42065a4fa567?source=collection_archive---------24-----------------------#2020-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="85a1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">模型训练、调优和创建简单API的端到端示例(没有技术术语)。</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/4c825501f9b8cdc7c165bc5d1e5841ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*HEQVquBY3MHdHzNA.jpg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">我保证，如果你一直关注这篇文章，它将会是(来源:<a class="ae ku" href="https://media.makeameme.org/created/Make-an-API.jpg" rel="noopener ugc nofollow" target="_blank">makeameme.org</a>)</p></figure><p id="6da7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">作为一名数据科学家，我们大部分时间都花在数据预处理(或者说数据角力)、模型训练、超参数调优、模型验证等方面。然而，数据科学家戴的帽子越来越多，因此，许多行业现在开始寻找能够<em class="lr">将他们的ML模型转化为API </em>的人。</p><p id="6485" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这到底是什么意思？意思是:</p><ul class=""><li id="bcfb" class="ls lt it kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">你建立了一个非常精确的ML模型。</li><li id="3f0f" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">您现在希望其他人能够利用您的模型进行预测(因为您很好，或者因为它有利可图，或者两者兼而有之)，而不需要他们看到您的整个代码。这就是API的用武之地..</li></ul><h2 id="4ba7" class="mg mh it bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">什么是API？</h2><blockquote class="mz na nb"><p id="57e1" class="kv kw lr kx b ky kz ju la lb lc jx ld nc lf lg lh nd lj lk ll ne ln lo lp lq im bi translated">API允许我们建立一个连接，以便外部人员可以从服务器请求数据，向服务器发送新信息，更改服务器上的现有数据以及删除服务器上的现有数据。</p></blockquote><p id="d79a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">用更简单的术语来解释(为了本文的目的)，API是一个接口，当用户从前端请求数据时，它允许您在后端访问和操作数据(来自数据库或其他数据源)。Flask是在后端编写数据科学API的最流行的python框架之一。</p><p id="22b3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了测试您的API，您可以在本地运行后端服务器，默认情况下它运行在localhost URL <code class="fe nf ng nh ni b">(http://127.0.0.1)</code>上。这个URL后跟一个端口，比如说5000，这样整个URL看起来就像<code class="fe nf ng nh ni b">http://127.0.0.1:5000</code>。端口可以在Flask设置中更改，这样如果你想运行多个本地服务器，你可以在<code class="fe nf ng nh ni b">http://127.0.0.1:5000</code>、<code class="fe nf ng nh ni b">http://127.0.0.1:5001</code>等等上运行它们。</p><h1 id="033d" class="nj mh it bd mi nk nl nm ml nn no np mo jz nq ka mr kc nr kd mu kf ns kg mx nt bi translated">在本文中…</h1><p id="11cc" class="pw-post-body-paragraph kv kw it kx b ky nu ju la lb nv jx ld le nw lg lh li nx lk ll lm ny lo lp lq im bi translated">我们将使用H2o AutoML建立一个机器学习模型(使用非常少的代码行，但生成高性能的模型)。我们的模型将能够根据某些特征来预测贷款申请是被批准还是被拒绝。接下来，我们将创建我们的第一个API，我们将向它发送一个关于客户年龄、汽车类型、贷款金额等的查询，它将返回申请的状态——批准或拒绝。</p><p id="3908" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注:我将使用<strong class="kx iu"> Jupyter笔记本</strong>构建和测试H2o模型，使用<strong class="kx iu"> Spyder </strong>编写烧瓶代码。最后，我也将从Jupyter内部访问我的API。</p><h1 id="0d6a" class="nj mh it bd mi nk nl nm ml nn no np mo jz nq ka mr kc nr kd mu kf ns kg mx nt bi translated">一步步走向APIs</h1><p id="4025" class="pw-post-body-paragraph kv kw it kx b ky nu ju la lb nv jx ld le nw lg lh li nx lk ll lm ny lo lp lq im bi translated">在我们开始为模型编写简单的API之前，我想简单地体验一下编写更简单的API(不需要用户输入)的感觉。让我们开始驾驶<strong class="kx iu"> Spyder </strong> …</p><p id="da19" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是我们将要使用的一些样板代码(稍后会对其进行修改):</p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="4328" class="mg mh it ni b gy od oe l of og">from flask import Flask<br/>from flask_restful import Resource, Api</span><span id="58c8" class="mg mh it ni b gy oh oe l of og">app = Flask(__name__)<br/>api = Api(app)</span><span id="a4c9" class="mg mh it ni b gy oh oe l of og">class HelloWorld(Resource):<br/>    def get(self):<br/>        return {'hello': 'world'}</span><span id="5df3" class="mg mh it ni b gy oh oe l of og">api.add_resource(HelloWorld, '/')</span><span id="8171" class="mg mh it ni b gy oh oe l of og">if __name__ == '__main__':<br/>    app.run(debug=True, port = 12345)</span></pre><p id="675a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">需要注意的几件事:</p><ul class=""><li id="446b" class="ls lt it kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">这里的返回属于类型<code class="fe nf ng nh ni b">dict</code>，即一个键-值对(键是<code class="fe nf ng nh ni b">hello</code>；值为<code class="fe nf ng nh ni b">world</code>。</li><li id="3145" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><code class="fe nf ng nh ni b">debug = True</code>支持代码重载和更好的错误消息。切勿在生产环境中使用调试模式！</li><li id="cbaa" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">重要的是使用<code class="fe nf ng nh ni b">api.add_resource</code>将您创建的任何资源(比如<code class="fe nf ng nh ni b">HelloWorld</code>)添加到API中。</li><li id="19f6" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">端口被显式指定为<code class="fe nf ng nh ni b">port = 12345</code>，因为有时默认端口可能被其他应用程序使用，并可能抛出错误。</li></ul><p id="af2b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，将文件保存为<em class="lr"> medium_tut.py </em>，并使用顶部的绿色运行按钮(或Mac上的F5)运行它。右侧控制台窗格中的输出应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/35ac4dcc657c290b490f1482e7a1ae7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*W7IznLEDR-TujiZ4-xuFaw.png"/></div></figure><p id="b8b9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如您所见，API正在本地服务器<code class="fe nf ng nh ni b"><a class="ae ku" href="http://127.0.0.1:12345/." rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:12345/</a></code>上运行。现在打开<strong class="kx iu"> Jupyter Notebook </strong>并键入以下代码来访问我们刚刚编写的API。</p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="25d4" class="mg mh it ni b gy od oe l of og">from requests import get<br/>import requests</span><span id="9869" class="mg mh it ni b gy oh oe l of og">url = '<a class="ae ku" href="http://127.0.0.1:12345/'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:12345/'</a><br/>get(url).json()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/82ab8d3d602401db27d231ae6708bd4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*ugoMcV6jLm6BObnit-IRlg.png"/></div></figure><p id="481a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">写你的第一个API值得称赞。:-)</p><p id="6ced" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您仔细注意，我们在<code class="fe nf ng nh ni b">HelloWorld</code>中的get函数的返回类型是<code class="fe nf ng nh ni b">dict</code>，因此我们在上面的代码中使用<code class="fe nf ng nh ni b">.json()</code>来解析该字典的输出。</p><h2 id="cea2" class="mg mh it bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">编写接受一个输入参数的API</h2><p id="7f75" class="pw-post-body-paragraph kv kw it kx b ky nu ju la lb nv jx ld le nw lg lh li nx lk ll lm ny lo lp lq im bi translated">我们将修改我们之前在<code class="fe nf ng nh ni b">medium_tut.py</code>文件中的代码，从用户端接受一个参数(更具体地说是一个数字),并将它的平方返回给用户。</p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="1fe1" class="mg mh it ni b gy od oe l of og">from flask import Flask<br/>from flask_restful import Resource, Api, <strong class="ni iu">reqparse</strong></span><span id="df7f" class="mg mh it ni b gy oh oe l of og">app = Flask(__name__)<br/>api = Api(app)</span><span id="7ee1" class="mg mh it ni b gy oh oe l of og"><strong class="ni iu"><em class="lr"># argument parsing</em><br/>parser = reqparse.RequestParser()<br/>parser.add_argument('num1')</strong></span><span id="491d" class="mg mh it ni b gy oh oe l of og">class HelloWorld(Resource):<br/>    def get(self):<br/>        return {'hello': 'world'}</span><span id="9977" class="mg mh it ni b gy oh oe l of og"><strong class="ni iu">class PrintSquare(Resource):<br/>    def get(self):<br/>        <em class="lr"># use parser and find the user's input</em><br/>        args = parser.parse_args()<br/>        <br/>        user_query = float(args['num1'])<br/>        return {'ans': user_query * user_query}</strong></span><span id="4c83" class="mg mh it ni b gy oh oe l of og">api.add_resource(HelloWorld, <strong class="ni iu">'/hello'</strong>)<br/><strong class="ni iu">api.add_resource(PrintSquare, '/sq')</strong></span><span id="ea38" class="mg mh it ni b gy oh oe l of og">if __name__ == '__main__':<br/>    app.run(debug=True, port = 12345)</span></pre><p id="d264" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">评估我们所做的修改:</p><ul class=""><li id="1036" class="ls lt it kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">我们已经使用<code class="fe nf ng nh ni b">parser.add_argument()</code>将用户输入(在我们的例子中是一个数字)添加到解析器中。</li><li id="84d7" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">我们现在有了一个新的类<code class="fe nf ng nh ni b">PrintSquare</code>来返回数字的平方。</li><li id="1ecb" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">由于我们现在有多个类，并且我们不希望在用户发出请求时混淆API应该运行哪个函数，我们必须通过添加<code class="fe nf ng nh ni b">'/hello'</code>作为端点来更新<code class="fe nf ng nh ni b">HelloWorld</code>的<code class="fe nf ng nh ni b">add_resource</code>。所以现在，<code class="fe nf ng nh ni b">HelloWorld</code>将运行在<code class="fe nf ng nh ni b"><a class="ae ku" href="http://127.0.0.1:12345/." rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:12345/</a>hello</code>而不是<code class="fe nf ng nh ni b"><a class="ae ku" href="http://127.0.0.1:12345/." rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:12345/</a></code>上</li></ul><p id="7d95" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们看看是否可以访问我们的API，回到<strong class="kx iu"> Jupyter笔记本</strong>:</p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="cdab" class="mg mh it ni b gy od oe l of og"><em class="lr"># note the URL has been updates, i.e. the 'sq' endpoint has been added to it</em><br/>url = '<a class="ae ku" href="http://127.0.0.1:12345/sq'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:12345/sq'</a></span><span id="eb9b" class="mg mh it ni b gy oh oe l of og"><em class="lr"># we have one input parameter 'num1'</em><br/>params = {'num1': '2'}</span><span id="2788" class="mg mh it ni b gy oh oe l of og"><em class="lr"># outputting the response from API</em><br/>response = requests.get(url, params)<br/>response.json()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/48cc56b66fb05de9103daa996deff510.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*Qv0uCKALksqdK-F95rxN2g.png"/></div></figure><h2 id="f0b2" class="mg mh it bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">编写采用多个输入参数的API</h2><p id="996a" class="pw-post-body-paragraph kv kw it kx b ky nu ju la lb nv jx ld le nw lg lh li nx lk ll lm ny lo lp lq im bi translated">更新<strong class="kx iu"> Spyder </strong>上的<code class="fe nf ng nh ni b">medium_tut.py</code>文件，以接受来自用户的两个数字作为输入，并返回其总和。</p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="aa29" class="mg mh it ni b gy od oe l of og">from flask import Flask<br/>from flask_restful import Resource, Api, reqparse</span><span id="314d" class="mg mh it ni b gy oh oe l of og">app = Flask(__name__)<br/>api = Api(app)</span><span id="1a58" class="mg mh it ni b gy oh oe l of og"><em class="lr"># argument parsing</em><br/>parser = reqparse.RequestParser()<br/>parser.add_argument('num1')<br/><strong class="ni iu">parser.add_argument('num2')</strong></span><span id="2728" class="mg mh it ni b gy oh oe l of og">class HelloWorld(Resource):<br/>    def get(self):<br/>        return {'hello': 'world'}</span><span id="c0bd" class="mg mh it ni b gy oh oe l of og">class PrintSquare(Resource):<br/>    def get(self):<br/>        <em class="lr"># use parser and find the user's input</em><br/>        args = parser.parse_args()<br/>        <br/>        user_query = float(args['num1'])<br/>        return {'ans': user_query * user_query}</span><span id="3e92" class="mg mh it ni b gy oh oe l of og"><strong class="ni iu">class PrintSum(Resource):<br/>    def get(self):<br/>        # use parser and find the user's inputs<br/>        args = parser.parse_args()<br/>        num1 = float(args['num1'])<br/>        num2 = float(args['num2'])<br/>        return {'ans': num1 + num2}</strong></span><span id="cd3a" class="mg mh it ni b gy oh oe l of og">api.add_resource(HelloWorld, '/hello')<br/>api.add_resource(PrintSquare, '/sq')<br/><strong class="ni iu">api.add_resource(PrintSum, '/sum')</strong></span><span id="7142" class="mg mh it ni b gy oh oe l of og">if __name__ == '__main__':<br/>    app.run(debug=True, port = 12345)</span></pre><p id="b50b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后检查API是否在<strong class="kx iu"> Jupyter Notebook </strong>中工作:</p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="9707" class="mg mh it ni b gy od oe l of og">url = '<a class="ae ku" href="http://127.0.0.1:12345/sum'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:12345/sum'</a></span><span id="ab20" class="mg mh it ni b gy oh oe l of og"><em class="lr"># we have two input parameters - 'num1' &amp; 'num2</em><br/>params = {'num1': '2', 'num2': '5'}</span><span id="5101" class="mg mh it ni b gy oh oe l of og">response = requests.get(url, params)<br/>response.json()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/070a602b1048c0b23ce1ed31be927092.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*Ipxta1erfDk0NPgT_NF2KA.png"/></div></figure><p id="c7de" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">瞧，你已经准备好为自己的ML模型创建API了。</p><p id="4d85" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">提示:继续在桌面上(或其他地方)创建一个新目录，命名为<code class="fe nf ng nh ni b">H2o_API</code>。这是我们将保存Jupyter笔记本的地方，该笔记本包含训练我们的模型的代码。稍后，当我们创建API脚本(在Spyder中)时，它也将保存在同一个目录中。这样做的全部逻辑是，当我们在本地创建和下载模型时，我们的Flask脚本可以访问它。</p><h1 id="b951" class="nj mh it bd mi nk nl nm ml nn no np mo jz nq ka mr kc nr kd mu kf ns kg mx nt bi translated">让我们深入研究数据</h1><p id="563c" class="pw-post-body-paragraph kv kw it kx b ky nu ju la lb nv jx ld le nw lg lh li nx lk ll lm ny lo lp lq im bi translated">我们的数据集有5个预测特征:</p><ul class=""><li id="2140" class="ls lt it kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated"><em class="lr">年龄组</em>:(老年、青年、中年)</li><li id="9e6c" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><em class="lr">汽车类型</em>:分类(敞篷车、轿车、SUV)</li><li id="34bf" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><em class="lr">贷款金额</em>:浮动</li><li id="ae94" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><em class="lr">存款</em>:浮动</li><li id="823f" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><em class="lr">地区</em>:分类(农村、城市)</li></ul><p id="6fb4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以及一个结果变量，即<em class="lr">应用_结果</em>，它可以取两个值:批准或拒绝。</p><p id="de3a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们的数据看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><div class="gh gi om"><img src="../Images/d93c68afa9cb42c0e2bdbae4256ce98e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2aaZfMeqH8zhJgoA8b9w7g.png"/></div></div></figure><h2 id="7472" class="mg mh it bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">将训练集和测试集转换为H2o框架</h2><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="2291" class="mg mh it ni b gy od oe l of og">#Categorical Columns - enum<br/>#Numerical Columns - real<br/>col_dict = {'age_group' : 'enum', <br/>            'car_type' : 'enum', <br/>            'loanamount' : 'real', <br/>            'deposit' : 'real', <br/>            'area' : 'enum',<br/>           'application_outcome': 'enum'}</span><span id="d635" class="mg mh it ni b gy oh oe l of og">train_h2o = h2o.H2OFrame(train, column_types = col_dict)<br/>test_h2o = h2o.H2OFrame(test, column_types = col_dict)</span></pre><h2 id="7a63" class="mg mh it bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">使用H2o AutoML进行培训</h2><p id="dbe1" class="pw-post-body-paragraph kv kw it kx b ky nu ju la lb nv jx ld le nw lg lh li nx lk ll lm ny lo lp lq im bi translated">自动机器学习(AutoML)是将机器学习应用于现实世界问题的端到端过程自动化的过程。使用<a class="ae ku" href="https://docs.h2o.ai/h2o/latest-stable/h2o-docs/automl.html" rel="noopener ugc nofollow" target="_blank"> H2o的AutoML接口</a>可以很容易地执行(我将在下一篇文章中深入讨论)。简而言之，它提供了一个由许多模型的自动训练和调整获得的顶级模型组成的排行榜。</p><p id="2f73" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，让我们把它载入我们的Jupyter笔记本:</p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="7e00" class="mg mh it ni b gy od oe l of og">from h2o.automl import H2OAutoML<br/>aml = H2OAutoML(max_models = 5, max_runtime_secs=100, seed = 1)</span></pre><p id="9445" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">设置预测值和响应特征:</p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="f25d" class="mg mh it ni b gy od oe l of og"><em class="lr"># setting predictor and response features</em><br/>x = ['age_group', 'car_type', 'loanamount', 'deposit', 'area']<br/>y = 'application_outcome'</span></pre><p id="6569" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">训练过程可以简单地使用H2o中的一行代码来实现。</p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="bf38" class="mg mh it ni b gy od oe l of og"><em class="lr"># Training</em><br/>aml.train(x=x, y='application_outcome', training_frame=train_h2o, validation_frame=test_h2o)</span></pre><p id="f90e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最佳模型(基于默认指标AUC)存储在<code class="fe nf ng nh ni b">aml.leader</code>中:</p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="fbaa" class="mg mh it ni b gy od oe l of og">aml.leader</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/aece1929bb029a004fa1f2583ee68279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*HQI8XUOVhv2Eunnjt4cwYQ.png"/></div></figure><p id="ceb5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如你所看到的，即使没有太多的修改，我们已经在验证集上获得了AUC = 0.87的模型(一点也不差)！还有，注意这个模型的名字是<code class="fe nf ng nh ni b">StackedEnsemble_AllModels_AutoML_20200619_172405</code>。您的模型的名称将类似于此，减去最后一个下划线后的部分，即<code class="fe nf ng nh ni b">172405</code>。</p><h2 id="1262" class="mg mh it bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">将最佳模型保存到本地机器上</h2><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="bc7d" class="mg mh it ni b gy od oe l of og"><em class="lr"># download the model built above to your local machine</em><br/>my_local_model = h2o.download_model(aml.leader, path="/Users/UserName/Desktop/H2o_API")</span></pre><p id="a668" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您在您的目录中检查这个保存的模型的名称，它将看起来像<code class="fe nf ng nh ni b">StackedEnsemble_AllModels_AutoML_20200619_******</code>。</p><h1 id="abdc" class="nj mh it bd mi nk nl nm ml nn no np mo jz nq ka mr kc nr kd mu kf ns kg mx nt bi translated">为您的模型创建API</h1><p id="8b74" class="pw-post-body-paragraph kv kw it kx b ky nu ju la lb nv jx ld le nw lg lh li nx lk ll lm ny lo lp lq im bi translated">创建新的python脚本<code class="fe nf ng nh ni b">pred_API.py</code>来编写我们的Flask脚本。</p><h2 id="ec30" class="mg mh it bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">导入库和加载模型</h2><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="521b" class="mg mh it ni b gy od oe l of og">from flask import Flask<br/>from flask_restful import Resource, Api, reqparse</span><span id="a31a" class="mg mh it ni b gy oh oe l of og">app = Flask(__name__)<br/>api = Api(app)</span><span id="c4f2" class="mg mh it ni b gy oh oe l of og">import h2o<br/>import pandas as pd<br/>h2o.init()</span><span id="4530" class="mg mh it ni b gy oh oe l of og"><em class="lr">## load trained model</em><br/>model_path = 'StackedEnsemble_AllModels_AutoML_20200619_******'<br/>uploaded_model = h2o.load_model(model_path)</span></pre><h2 id="654a" class="mg mh it bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">解析输入参数</h2><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="ffac" class="mg mh it ni b gy od oe l of og"><em class="lr"># argument parsing</em><br/>parser = reqparse.RequestParser(bundle_errors=True) <em class="lr"># if there are 2 errors, both of their msgs will be printed</em></span><span id="e2ae" class="mg mh it ni b gy oh oe l of og">parser.add_argument('age_group', choices = ('Young', 'Older', 'Middle-Aged'), help = 'Bad Choice: {error_msg}. Valid choices are Young, Older, Middle-Aged')</span><span id="292e" class="mg mh it ni b gy oh oe l of og">parser.add_argument('car_type', choices = ('SUV', 'Saloon', 'Convertible'), help = 'Bad Choice: {error_msg}. Valid choices are SUV, Saloon, Convertible')</span><span id="c1a6" class="mg mh it ni b gy oh oe l of og">parser.add_argument('loanamount')</span><span id="4d3c" class="mg mh it ni b gy oh oe l of og">parser.add_argument('deposit')</span><span id="ea06" class="mg mh it ni b gy oh oe l of og">parser.add_argument('area', choices = ('urban', 'rural'), help = 'Bad Choice: {error_msg}. Valid choices are urban, rural')</span></pre><p id="d1f6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在将分类特征的值添加到解析器中时(比如<code class="fe nf ng nh ni b">age_group</code>和<code class="fe nf ng nh ni b">car_type</code>，我们将<code class="fe nf ng nh ni b">choices</code>设置为一个元组，其中包含该特征可以采用的所有可能值。如果遇到选项中未提及的值，它将抛出<code class="fe nf ng nh ni b">help</code>中指定的错误消息。</p><p id="4b30" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，我们设置<code class="fe nf ng nh ni b">bundle_errors = True</code>，这样在两个错误的情况下，两个错误消息都被打印出来。例如，在下面的示例中，我们故意将<code class="fe nf ng nh ni b">age_group</code>的值设置为‘older ’,将<code class="fe nf ng nh ni b">car_type</code>的值设置为‘SUVv ’:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><div class="gh gi os"><img src="../Images/f787f27768683204e03e328ca03171f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*glNvHSQD5xyW9jap9jT2bA.png"/></div></div></figure><h2 id="53df" class="mg mh it bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">定义预测类</h2><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="efb1" class="mg mh it ni b gy od oe l of og"><em class="lr">#Categorical Columns - enum<br/>#Numerical Columns - real</em><br/>col_dict = {'age_group' : 'enum', <br/>            'car_type' : 'enum', <br/>            'loanamount' : 'real', <br/>            'deposit' : 'real', <br/>            'area' : 'enum',<br/>           'application_outcome': 'enum'}</span><span id="43a0" class="mg mh it ni b gy oh oe l of og"><em class="lr"># prepare empty test data frame to be fed to the model</em><br/>data = {}</span><span id="a93e" class="mg mh it ni b gy oh oe l of og"><em class="lr"># results dict</em><br/>item_dict = {}</span><span id="712b" class="mg mh it ni b gy oh oe l of og">class LoanPred(Resource):<br/>    def get(self):<br/>         args = parser.parse_args()<br/>         age = args['age_group']<br/>         car_type = args['car_type']<br/>         loanamount = float(args['loanamount'])<br/>         deposit = float(args['deposit'])<br/>         area = args['area']<br/>         application_outcome = 'declined' <em class="lr">#setting as default to declined (can set it as 'approved' as well, doesn't matter)</em><br/>         <br/>         <em class="lr"># put key:value pairs in empty dict called data</em><br/>         data['age_group'] = age<br/>         data['car_type'] = car_type<br/>         data['loanamount'] = [loanamount]<br/>         data['deposit'] = [deposit]<br/>         data['area'] = area<br/>         data['application_outcome'] = application_outcome<br/>         <br/>         <em class="lr"># creating dataframe from dict</em><br/>         testing = pd.DataFrame(data)<br/>         <br/>         <em class="lr"># converting pandas to h2o dataframe</em><br/>         test = h2o.H2OFrame(testing, column_types = col_dict)<br/>        <br/>         <em class="lr"># making predictions</em><br/>         pred_ans = uploaded_model.predict(test).as_data_frame()<br/>         <br/>         <em class="lr"># put key:value pairs in empty dict called item_dict</em><br/>         item_dict['Prediction'] = pred_ans.predict.values[0]<br/>         item_dict['Approved'] = pred_ans.approved.values[0]<br/>         item_dict['Declined'] = pred_ans.declined.values[0]<br/>         <br/>         return{'ans': item_dict}<br/>         <br/>api.add_resource(LoanPred, '/')</span><span id="d0d7" class="mg mh it ni b gy oh oe l of og">if __name__ == '__main__':<br/>    app.run(debug=True, port= 1234)</span></pre><p id="f48c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们首先获取所有输入参数，并使用它们创建一个名为<code class="fe nf ng nh ni b">testing</code>的pandas数据帧。该数据帧必须转换成名为<code class="fe nf ng nh ni b">test</code>的H2o帧，然后才能提供给H2o模型进行预测。</p><p id="7ef3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">需要注意的一点是，<code class="fe nf ng nh ni b">model.predict()</code>的输出是一个h2o帧，目前，Spyder ipython控制台无法正确显示H2o数据帧(您可以在Github上的这里跟踪问题<a class="ae ku" href="https://github.com/spyder-ide/spyder/issues/4714" rel="noopener ugc nofollow" target="_blank">)。因此，我们需要使用<code class="fe nf ng nh ni b">as_data_frame()</code>将<code class="fe nf ng nh ni b">model.predict()</code>的输出显式转换为pandas数据帧。输出<code class="fe nf ng nh ni b">pred_ans</code>是包含三列的数据帧—</a></p><ul class=""><li id="4492" class="ls lt it kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">最终预测(批准或拒绝)，</li><li id="a418" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">申请被批准的概率，</li><li id="bc12" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">申请被拒绝的概率。</li></ul><p id="f0e9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将这三个值作为键值对存储在<code class="fe nf ng nh ni b">item_dict</code>中。</p><p id="5216" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">最后将</strong> <code class="fe nf ng nh ni b">pred_API.py</code> <strong class="kx iu">中的所有代码放在一个地方:</strong></p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="e7c7" class="mg mh it ni b gy od oe l of og">from flask import Flask<br/>from flask_restful import Resource, Api, reqparse</span><span id="1018" class="mg mh it ni b gy oh oe l of og">app = Flask(__name__)<br/>api = Api(app)</span><span id="1580" class="mg mh it ni b gy oh oe l of og">import h2o<br/>import pandas as pd<br/>h2o.init()</span><span id="4e87" class="mg mh it ni b gy oh oe l of og">## load saved model<br/>model_path = 'StackedEnsemble_AllModels_AutoML_20200619_******'<br/>uploaded_model = h2o.load_model(model_path)</span><span id="6bff" class="mg mh it ni b gy oh oe l of og"># argument parsing<br/>parser = reqparse.RequestParser(bundle_errors=True) #if there are 2 errors, both's msg will be printed<br/>parser.add_argument('age_group', choices = ('Young', 'Older', 'Middle-Aged'), help = 'Bad Choice: {error_msg}. Valid choices are Young, Older, Middle-Aged')<br/>parser.add_argument('car_type', choices = ('SUV', 'Saloon', 'Convertible'), help = 'Bad Choice: {error_msg}. Valid choices are SUV, Saloon, Convertible')<br/>parser.add_argument('loanamount')<br/>parser.add_argument('deposit')<br/>parser.add_argument('area', choices = ('urban', 'rural'), help = 'Bad Choice: {error_msg}. Valid choices are urban, rural')</span><span id="7826" class="mg mh it ni b gy oh oe l of og">#Categorical Columns - enum<br/>#Numerical Columns - real<br/>col_dict = {'age_group' : 'enum', <br/>            'car_type' : 'enum', <br/>            'loanamount' : 'real', <br/>            'deposit' : 'real', <br/>            'area' : 'enum',<br/>           'application_outcome': 'enum'}</span><span id="2494" class="mg mh it ni b gy oh oe l of og">#prepare empty test data frame to be fed to the model<br/>data = {}</span><span id="7f35" class="mg mh it ni b gy oh oe l of og"># results dict<br/>item_dict = {}</span><span id="22d3" class="mg mh it ni b gy oh oe l of og">class LoanPred(Resource):<br/>    def get(self):<br/>         args = parser.parse_args()<br/>         age = args['age_group']<br/>         car_type = args['car_type']<br/>         loanamount = float(args['loanamount'])<br/>         deposit = float(args['deposit'])<br/>         area = args['area']<br/>         application_outcome = 'declined' <br/>         <br/>         # put key:value pairs in empty dict called data<br/>         data['age_group'] = age<br/>         data['car_type'] = car_type<br/>         data['loanamount'] = [loanamount]<br/>         data['deposit'] = [deposit]<br/>         data['area'] = area<br/>         data['application_outcome'] = application_outcome<br/>         <br/>         # creating dataframe from dict<br/>         testing = pd.DataFrame(data)<br/>         <br/>         # converting pandas to h2o dataframe<br/>         test = h2o.H2OFrame(testing, column_types = col_dict)<br/>        <br/>         # making predictions<br/>         pred_ans = uploaded_model.predict(test).as_data_frame()<br/>         <br/>         # put key:value pairs in empty dict called item_dict<br/>         item_dict['Prediction'] = pred_ans.predict.values[0]<br/>         item_dict['Approved'] = pred_ans.approved.values[0]<br/>         item_dict['Declined'] = pred_ans.declined.values[0]<br/>         <br/>         return{'ans': item_dict}<br/>         <br/>api.add_resource(LoanPred, '/')</span><span id="f209" class="mg mh it ni b gy oh oe l of og">if __name__ == '__main__':<br/>    app.run(debug=True, port= 1234)</span></pre><h1 id="9f38" class="nj mh it bd mi nk nl nm ml nn no np mo jz nq ka mr kc nr kd mu kf ns kg mx nt bi translated">访问API以获得预测</h1><p id="ada6" class="pw-post-body-paragraph kv kw it kx b ky nu ju la lb nv jx ld le nw lg lh li nx lk ll lm ny lo lp lq im bi translated">在朱庇特的笔记本上:</p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="4e13" class="mg mh it ni b gy od oe l of og"><em class="lr"># Normal API call with all inputs in correct format</em></span><span id="0c06" class="mg mh it ni b gy oh oe l of og">url = '<a class="ae ku" href="http://127.0.0.1:1234/'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:1234/'</a></span><span id="f8ad" class="mg mh it ni b gy oh oe l of og">params = {'age_group': 'Young', 'car_type': 'SUV', 'loanamount': '12342', 'deposit': '2360', 'area': 'rural' }</span><span id="56f8" class="mg mh it ni b gy oh oe l of og">response = requests.get(url, params)<br/>response.json()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/f53864282bb2be58ed1478791864b0a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*I9y-T2DKl5Cn3hcSU2NgWw.png"/></div></figure><p id="5e0a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们走吧..我们已经成功地进行了API调用，并从H2o中训练的模型中检索预测。现在你所要做的就是找到一个朋友，他能把这个API输出变成一些漂亮的网络应用程序。</p></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><h1 id="6513" class="nj mh it bd mi nk pb nm ml nn pc np mo jz pd ka mr kc pe kd mu kf pf kg mx nt bi translated">结论</h1><p id="714a" class="pw-post-body-paragraph kv kw it kx b ky nu ju la lb nv jx ld le nw lg lh li nx lk ll lm ny lo lp lq im bi translated">这是对为ML模型创建API的概念的热情介绍。希望这不会太可怕，并且描述足够详细，可以帮助您理解相关的本质。所有代码都可以在<a class="ae ku" href="https://github.com/V-Sher/H2oModels_API_Flask" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><p id="5c0b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在下一部分中，我们将学习如何使用Flask和Bigquery APIs根据用户查询参数从Bigquery数据集中提取数据。</p><p id="0c5b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">直到下一次:-)</p></div></div>    
</body>
</html>