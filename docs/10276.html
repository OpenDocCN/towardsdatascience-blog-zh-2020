<html>
<head>
<title>A journey to Airflow on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库伯内特斯的气流之旅</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-journey-to-airflow-on-kubernetes-472df467f556?source=collection_archive---------4-----------------------#2020-07-20">https://towardsdatascience.com/a-journey-to-airflow-on-kubernetes-472df467f556?source=collection_archive---------4-----------------------#2020-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ff1f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">…或者我是如何让它一点一点地、合乎逻辑地运转起来的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/83f853b761ef7a775c27603fabc65380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EOffaocf9HUojOHrvB2wqw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当阿帕奇气流任务着陆图看起来更像波洛克的画(来源:作者)</p></figure><h1 id="6f98" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">简介</h1><p id="dfb2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我对 Apache Airflow 的拙见:基本上，如果您有多个自动化任务要调度，并且您正在摆弄<em class="mj"> cron 任务</em>,即使它们的一些依赖项失败了，您也应该尝试一下。但是如果你不愿意接受我的话，请随意查看这些帖子。<a class="ae mk" href="https://medium.com/analytics-and-data/10-benefits-to-using-airflow-33d312537bae" rel="noopener"> </a> <a class="ae mk" href="https://www.solita.fi/en/blogs/why-we-switched-to-apache-airflow/" rel="noopener ugc nofollow" target="_blank"> </a> <a class="ae mk" href="https://robinhood.engineering/why-robinhood-uses-airflow-aed13a9a90c8" rel="noopener ugc nofollow" target="_blank"> </a>深入研究气流概念及其工作原理超出了本文的范围。就此而言，请检查这些其他职位。<a class="ae mk" rel="noopener" target="_blank" href="/airflow-how-and-when-to-use-it-2e07108ac9f5">⁴</a>t11】⁵</p><p id="a7d9" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">长话短说，它的任务定义是基于<em class="mj">代码的</em>，这意味着它们可以如你所愿的那样<em class="mj">动态</em>。您可以创建任务，并根据变量或条件定义任务相关性。它有大量的本地<em class="mj">操作符</em>(任务类型的定义)<a class="ae mk" href="https://airflow.apache.org/docs/stable/_api/airflow/operators/index.html" rel="noopener ugc nofollow" target="_blank"> ⁶ </a>将您的工作流与许多其他工具集成在一起，并允许您使用 Apache Spark 运行从最基本的 shell 脚本到并行数据处理，以及大量其他选项。贡献者操作员<a class="ae mk" href="https://airflow.apache.org/docs/stable/_api/airflow/contrib/operators/index.html" rel="noopener ugc nofollow" target="_blank"/>⁷也可以用于大量的商业工具，而且这个列表每天都在增长。这些操作符是<em class="mj"> python 类</em>，因此它们是可扩展的，并且可以根据您的需要进行修改。您甚至可以从零开始创建自己的操作符，从<code class="fe mq mr ms mt b">BaseOperator</code>类继承。此外，使用它的分布式执行器(如 Celery 或 Kubernetes ),它使您的工作流可以轻松扩展到数百甚至数千个任务。</p><p id="2103" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">我们从 2018 年开始在<a class="ae mk" href="https://institucional.ifood.com.br/" rel="noopener ugc nofollow" target="_blank"> iFood </a>使用气流。我们的第一个实现非常好，基于 docker 容器在一个隔离的环境中运行每个任务。从那时起，它经历了很多变化，从一个服务于我们团队工作负载的简单工具到一个服务于 200 多人的<em class="mj">任务调度平台</em>，上面有很多抽象。最后，不管您是有多年经验的软件工程师还是 SQL 知识很少的业务分析师，您都可以使用我们的平台编写一个<em class="mj"> yaml </em>文件来调度您的任务，该文件包含三个简单的字段:您的任务的 ID、包含您的查询的文件的路径及其表依赖项的名称(即，要运行我的任务，我依赖于表<code class="fe mq mr ms mt b">orders</code>和<code class="fe mq mr ms mt b">users</code>)，瞧，您已经将您的任务调度为每天运行。<em class="mj">但不幸的是，这是未来文章的主题</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/a26998c7724977490841a7bc940f28a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOU-PnjBdWosZoA0PUwPcQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">拥有超过 1000 个任务的巨型 DAG 的一部分。其中大部分是由业务分析师或数据分析师安排的 Apache Spark / Hive 作业(来源:作者)</p></figure><h1 id="a504" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">为什么是 Kubernetes？</h1><p id="b3fb" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">很明显，我们需要将我们的应用程序从 AWS <code class="fe mq mr ms mt b">t2.medium</code> EC2 实例扩展到更强大的东西。我们最初的方法是垂直扩展到一个<code class="fe mq mr ms mt b">r4.large</code>实例，然后扩展到一个<code class="fe mq mr ms mt b">r4.xlarge</code>，但是内存使用量一直在增加。</p><p id="edb4" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">我们公司发展很快。每天都有几十个任务被创建，突然间我们将运行在一个<code class="fe mq mr ms mt b">r4.16xlarge</code>实例上。我们需要一种方法来横向扩展应用程序，更重要的是，考虑到高峰时间来扩展应用程序，并在黎明时缩减应用程序，以最大限度地减少不必要的成本。当时，我们正在将所有平台迁移到 Kubernetes 集群上运行，那么为什么不迁移 Airflow 呢？</p><p id="45dd" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">我在互联网上搜索，从官方的 Apache Airflow 文档到 Medium 文章，寻找如何在 Kubernetes 上使用<code class="fe mq mr ms mt b">KubernetesExecutor</code>运行 Airflow 的简单实现的信息(我知道<code class="fe mq mr ms mt b">CeleryExecutor</code>的存在，但它不符合我们的需求，考虑到您需要预先安排您的工作人员，没有本机自动伸缩)。我发现很多人都在谈论在 Kubernetes 上运行 Airflow 的好处，它背后的架构和一堆掌舵图，但很少有信息告诉我如何以一种符合逻辑的方式一点一点地为 Kubernetes 初学者部署它。这是本文的主要观点。假设您知道 Apache Airflow，以及它的组件如何协同工作，这个想法是向您展示如何利用<code class="fe mq mr ms mt b">KubernetesExecutor</code>的优势部署它在 Kubernetes 上运行，并提供一些有关 Kubernetes 资源的额外信息(<em class="mj"> yaml </em>文件)。这些例子将是基于 AWS 的，但我确信，只需很少的研究，您就可以将信息移植到任何您想要的云服务，甚至可以在本地运行代码。</p><h1 id="2de7" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">考虑</h1><p id="bd3f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">为了完全理解下面的部分并让事情运转起来，我假设您已经:</p><ol class=""><li id="131a" class="mv mw iq lp b lq ml lt mm lw mx ma my me mz mi na nb nc nd bi translated">一个可用的 AWS EKS 集群，或另一种类型的 Kubernetes 集群，在本地或在云环境中。</li><li id="47a3" class="mv mw iq lp b lq ne lt nf lw ng ma nh me ni mi na nb nc nd bi translated">Kubernetes 和<code class="fe mq mr ms mt b">kubectl</code>工具的基本“实践”知识。至少在如何部署资源以及检查它们的描述和日志方面。</li><li id="2406" class="mv mw iq lp b lq ne lt nf lw ng ma nh me ni mi na nb nc nd bi translated">关于 Apache Airflow 及其单元(配置、调度程序、web 服务器、数据库、Dag 和任务)的扎实知识</li></ol><p id="986e" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">如果你没有，我建议你在当地玩一会儿 Kubernetes 和 Airflow。你可以在网上找到很棒的教程，甚至在官方网站上。对于 Kubernetes，您可以从 Katacoda 教程开始。关于阿帕奇气流，这是我尝试的第一个教程。<a class="ae mk" href="https://github.com/hgrif/airflow-tutorial" rel="noopener ugc nofollow" target="_blank"> ⁹ </a></p><h1 id="a991" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">起点</h1><p id="2905" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">首先，我找到了一种方法，可以从 Airflow git 存储库中的官方舵图中获取 Kubernetes 资源<em class="mj"> yaml </em>文件。<a class="ae mk" href="https://github.com/apache/airflow/tree/master/chart" rel="noopener ugc nofollow" target="_blank"> ⁰ </a>给我带来了很多资源，其中一些是空的(可能是因为我使用了 base <code class="fe mq mr ms mt b">values.yaml</code>来填充 Helm 使用的模板)，还有一些对于<code class="fe mq mr ms mt b">KubernetesExecutor</code>方法是无用的(也就是说，我不需要 Redis 集群，或者 Flower 资源，或者结果后端，因为这些是芹菜特有的)。除去那些无用的资源，我最终得到了大约 15 个资源文件，其中一些我当时甚至都不知道。有点势不可挡！我还删除了与 PostgreSQL 实例相关的所有资源(即 pgbouncer)，因为我知道我将使用一个在 Kubernetes 集群外部的 AWS RDS 实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">如何从 Apache Airflow 舵图导出 Kubernetes 资源 yaml 文件</p></figure><p id="aed9" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">Obs:我在本地有这些图表，所以当我执行<code class="fe mq mr ms mt b">helm template</code>命令时，<code class="fe mq mr ms mt b">helm</code>抱怨找不到 PostgreSQL 图表(如果您使用 Helm 存储库，这不会发生)。如果是这种情况，只需在包含你的舵轮图的文件夹中创建路径<code class="fe mq mr ms mt b">charts/</code>，并将<code class="fe mq mr ms mt b">postgresql/</code>舵轮图文件夹放入其中(可从官方舵轮图 github 库获得)。同样重要的是要注意，与我使用的图表相比，在 https://github.com/helm/charts<a class="ae mk" href="https://github.com/helm/charts" rel="noopener ugc nofollow" target="_blank">提供的阿帕奇气流舵图表将带给你一组不同的资源。</a><a class="ae mk" href="https://github.com/apache/airflow/tree/master/chart" rel="noopener ugc nofollow" target="_blank"> ⁰ </a></p><p id="a768" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">经过所有的清理，我得到了这 12 种资源:</p><pre class="kg kh ki kj gt nl mt nm nn aw no bi"><span id="f626" class="np kw iq mt b gy nq nr l ns nt">resources<br/>├── configmap.yaml<br/>├── dags-persistent-volume-claim.yaml<br/>├── rbac<br/>│   ├── pod-launcher-rolebinding.yaml<br/>│   └── pod-launcher-role.yaml<br/>├── scheduler<br/>│   ├── scheduler-deployment.yaml<br/>│   └── scheduler-serviceaccount.yaml<br/>├── secrets<br/>│   └── metadata-connection-secret.yaml<br/>├── statsd<br/>│   ├── statsd-deployment.yaml<br/>│   └── statsd-service.yaml<br/>├── webserver<br/>│   ├── webserver-deployment.yaml<br/>│   └── webserver-service.yaml<br/>└── workers<br/>    └── worker-serviceaccount.yaml</span></pre><h1 id="0bbf" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">思考体积</h1><p id="e5e4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我找到的大多数文章都描述了两种存储 DAG 信息的方法:将 DAG 存储在可从多个 AWS 可用性区域访问的持久卷上，例如 AWS 弹性文件系统(EFS ),或者将它们从 git 存储库同步到集群中挂载的临时卷。如果该 pod 终止，当创建另一个 pod 时，它将再次与存储库同步以获得最后的修改。</p><p id="2339" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">由于我们目前的工作流，我们需要从许多写在<em class="mj"> yaml </em>文件中的任务动态构建我们的 Dag，这意味着当文件在 git 存储库上被版本化时，我们的 Dag 还没有准备好。一个简单的 git-sync 带来的信息对我们来说是不可行的，但它可能是一个起点。考虑到我们还需要日志的某种持久性，我们决定也采用 EFS 方法，使用我们在网上找到的某种混合方法:将我们的<em class="mj"> yaml </em>文件 git-sync 到安装在 EFS 顶部的<code class="fe mq mr ms mt b">PersistentVolume</code>中，并让另一个 pod 处理它，并将新构建的 Dag 扔进调度程序和 web 服务器不断查看以填充<code class="fe mq mr ms mt b">DagBag</code>的文件夹中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于存储 Apache Airflow DAG 文件的持久卷配置</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于存储 Apache Airflow DAG 文件的 PersistentVolumeClaim 配置</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基于 AWS EFS 的存储的存储类配置</p></figure><p id="110c" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">如上所示，为了在 EKS 集群中挂载 EFS，我使用了官方的 AWS CSI 驱动程序，<a class="ae mk" href="https://github.com/kubernetes-sigs/aws-efs-csi-driver" rel="noopener ugc nofollow" target="_blank"> </a>，它必须安装在集群中。除了驱动因素之外，这种方法还占用了五种 Kubernetes 资源:</p><ul class=""><li id="c888" class="mv mw iq lp b lq ml lt mm lw mx ma my me mz mi nu nb nc nd bi translated">2 个持久卷:Dag、日志</li><li id="e596" class="mv mw iq lp b lq ne lt nf lw ng ma nh me ni mi nu nb nc nd bi translated">2 个 PersistentVolumeClaim:Dag、日志(类似于前面的那些)</li><li id="7fcd" class="mv mw iq lp b lq ne lt nf lw ng ma nh me ni mi nu nb nc nd bi translated">1 节储物课</li></ul><p id="d3ff" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">这些资源不在初始列表中，因为最初的部署使用了<code class="fe mq mr ms mt b">emptyDir</code>卷。</p><h1 id="7e78" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">我应该在哪里存储我的 airflow.cfg 文件？</h1><p id="6985" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">任何使用过 Apache Airflow 一段时间的人都知道<code class="fe mq mr ms mt b">airflow.cfg</code>文件(也许还有<code class="fe mq mr ms mt b">webserver_config.py</code>文件)对于设置这些东西非常重要。但是将它放入 EFS 卷似乎并不明智，因为它包含敏感信息(数据库密码、fernet 密钥)。然后，我发现 Kubernetes 存储配置文件的方式是使用<code class="fe mq mr ms mt b">ConfigMap</code>，这是一种“卷”,您可以将其安装在 pod 中，以便为它们公开配置文件。还有 Kubernetes <code class="fe mq mr ms mt b">Secret</code>来存储敏感数据。它们一起工作，所以我可以在一个<code class="fe mq mr ms mt b">ConfigMap</code>中引用一个<code class="fe mq mr ms mt b">Secret</code>，或者甚至将一个<code class="fe mq mr ms mt b">Secret</code>传递给一个环境变量。任务完成！</p><p id="03ee" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">随着您对 Kubernetes 了解得越来越多，您会注意到在存储库中发布“普通”秘密有些不安全。它们包含 base64 字符串，可以在您的终端中使用<code class="fe mq mr ms mt b">base64 -d</code>命令轻松“解密”。看看这个 ExternalSecrets API，<a class="ae mk" href="https://github.com/godaddy/kubernetes-external-secrets" rel="noopener ugc nofollow" target="_blank"> </a>将您的秘密存储在 AWS 参数存储中，并从那里检索它们。</p><p id="66a4" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">如果您检查上面的文件列表，您会注意到<code class="fe mq mr ms mt b">ConfigMap</code>已经存在，您只需定制它。</p><h1 id="b099" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">好的，但是<em class="nv">部署</em>呢？</h1><p id="e1b4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我在 Kubernetes 上的一点点经验足以让我认为我至少需要两个部署:一个用于<em class="mj">调度器</em>，一个用于<em class="mj">web 服务器</em>。它们就在那里，躺在舵轮图爆炸产生的<code class="fe mq mr ms mt b">scheduler</code>和<code class="fe mq mr ms mt b">webserver</code>文件夹里。还有第三个部署，是一个<code class="fe mq mr ms mt b">statsd</code>应用程序，我后来发现它与应用程序内部的指标收集有关。酷，少了一件事要担心！<em class="mj">普罗米修斯</em>会乐意刮的。</p><p id="26be" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">我打开文件，注意到它们有一些熟悉的环境变量，与 fernet 键和数据库连接字符串相关。我用库本内特公司的秘密获取的数据填充了它们。我需要稍微调整一下音量部分，以匹配我的 EFS <code class="fe mq mr ms mt b">PersistentVolume</code>和<code class="fe mq mr ms mt b">PersistentVolumeClaim</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">气流调度程序的部署配置</p></figure><p id="511c" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">很容易注意到这些 shell 脚本是作为<em class="mj"> init 容器</em>执行的。它们与气流开始时发生的数据库迁移相关。scheduler 窗格一启动就运行迁移，webserver 窗格在启动 webserver 容器之前一直等待迁移完成。webserver 部署具有非常相似的结构，所以我冒昧地省略了它。</p><h1 id="10fd" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">Webserver 是一个…服务器！应该有与之相关的服务！</h1><p id="fd0b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">有过。公开容器端口 8080 的 Kubernetes 服务资源。后来我加入了一个<code class="fe mq mr ms mt b">Ingress</code>资源，给它一个 AWS Route53 友好的 DNS。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Airflow 服务器的服务配置</p></figure><p id="07da" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated"><code class="fe mq mr ms mt b">statsd</code>应用程序也在一个端点监听，并有一个与之相关联的服务。这两个服务都包含在由<code class="fe mq mr ms mt b">helm template</code>命令导出的文件中。</p><h1 id="2aa2" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">嗯，应该可以的，对吧？</h1><p id="639d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我尝试将这些配置应用到集群中。Scheduler 和 webserver 都启动了，它们都连接到我的外部 RDS PostgreSQL 数据库。我想:“如果我把一些 DAGs 扔进<code class="fe mq mr ms mt b">dags</code>文件夹，那么它应该可以工作，对吗？”的确如此。我创建了一个简单的 DAG，其中有一个基于<code class="fe mq mr ms mt b">KubernetesPodOperator</code>的任务，使用了存储在 AWS 弹性容器注册表中的容器映像。我仔细检查了我的 pod 是否被允许访问 ECR 存储库。</p><p id="f6db" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">然后，我触发了 DAG，但是失败了(你真的没想到会那么容易吧？).检查日志时，我注意到它是由于某种权限问题而发生的。我的调度程序没有权限生成新的 pod。然后我明白了分散在文件夹中的<code class="fe mq mr ms mt b">ServiceAccount</code>资源以及<code class="fe mq mr ms mt b">ClusterRole</code>和<code class="fe mq mr ms mt b">ClusterRoleBinding</code>的需求。这些人允许你的资源产生新的资源。完成所有配置后，我可以让我的任务成功运行。<code class="fe mq mr ms mt b">KubernetesPodOperator</code>也有<code class="fe mq mr ms mt b">service_account_name</code>参数，应该用能够生成 pod 的<code class="fe mq mr ms mt b">ServiceAccount</code>资源名来填充，因为这就是它要做的:用您作为参数传递给<code class="fe mq mr ms mt b">image</code>参数的图像生成另一个 pod。那个舱将负责运行你的任务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">气流调度程序的 ServiceAccount 配置</p></figure><p id="ef6b" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">如果你想直接从你的网络服务器上运行任务，点击任务菜单中的“运行”按钮，你必须给你的网络服务器<code class="fe mq mr ms mt b">ServiceAccount</code>权限来观察和产生 pod。如果您忘记了这一点，您的任务将被触发，但它们永远不会运行。</p><h1 id="9808" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">作为可信实体的服务帐户</h1><p id="8d09" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如果你在 AWS 上运行你的东西，你需要确保你的 pods 能够访问所有的 AWS 资源，比如 S3、DynamoDB 表、EMR 等等。为此，您需要将您的<code class="fe mq mr ms mt b">ServiceAccount</code>资源绑定到一个附加了 IAM 策略的 AWS IAM 角色，以授予您所需的所有访问权限。只需为您的 IAM 角色提供一个假定角色策略:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">允许 Kubernetes ServiceAccounts 承担具有所需权限的 IAM 角色的策略</p></figure><p id="3879" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">您的员工和任务的<code class="fe mq mr ms mt b">ServiceAccount</code>应与上述政策所附的 IAM 角色相关联。您可以使用注释来完成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">注释 AWS IAM 角色的 ServiceAccount 资源示例</p></figure><h1 id="93d9" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">现在，让那里有光！</h1><p id="8068" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如果您是作为一个教程来跟随这个旅程的，那么在所有的调整之后，您可以在您的集群中创建所有上述资源:</p><pre class="kg kh ki kj gt nl mt nm nn aw no bi"><span id="130d" class="np kw iq mt b gy nq nr l ns nt">kubectl apply -f resources/ --recursive</span></pre><p id="937a" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated"><em class="mj">但是，等等！暂时不要应用它们！</em>如果你是一个细心的读者，你会注意到上面的大多数资源都引用了<code class="fe mq mr ms mt b">airflow-on-k8s</code>名称空间。<code class="fe mq mr ms mt b">Namespace</code>是一种告诉 Kubernetes 同一个名称空间中的所有资源多少有些关联(即它们是同一个项目的一部分)的方式，也是一种在集群内部组织事物的好方法。您应该在<code class="fe mq mr ms mt b">resources/</code>文件夹中声明您的<code class="fe mq mr ms mt b">Namespace</code>资源，并在应用其他所有资源之前应用它，否则您将得到一个错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">声明 airflow-on-k8s 命名空间。小菜一碟，不是吗？</p></figure><p id="7f27" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">仅供参考，并不是 Kubernetes 上的每个资源都有名称空间(即<code class="fe mq mr ms mt b">PersistentVolume</code>、<code class="fe mq mr ms mt b">StorageClass</code>和其他低级资源)，这就是为什么其中一些资源没有对名称空间的任何引用。</p><h1 id="d2b9" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">体系结构</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/80e9336b4298e08285a4cfa719d036cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gnaYB9TUtOFkajKCTXs_Mw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这种方法如何工作的一个极简主义的表现(来源:作者)</p></figure><h1 id="53fb" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">收场白</h1><p id="9b61" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这是我在 Kubernetes 上展开气流之旅的一个快进。我试图涵盖舵图导出生成的各种资源，但如果您认为我遗漏了什么，请在评论部分随意提问。</p><p id="0bcd" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">上面这些<em class="mj"> yaml </em>资源来自我做的一个功能部署。其中一些是我从头开始构建的，另一些是我从导出的版本中改编的。我建议你花时间去理解它们，并为更好的组织和表现做出改变。</p><p id="6fa1" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">要充分利用这种实现，您还可以做更多的事情。您可以为部署中的容器设置<code class="fe mq mr ms mt b">limits</code>和<code class="fe mq mr ms mt b">requests</code>字段，以确保它们拥有正常工作所需的资源。进一步了解 Kubernetes 的优势，您将会看到<code class="fe mq mr ms mt b">KubernetesPodOperator</code>允许您标记您的 pod 并向其传递许多 Kubernetes 配置，例如<em class="mj">亲和力</em>、<em class="mj">耐受性</em>和一堆其他东西。如果你有被感染的节点，你可以保证只有一些特定的 pods 会在上面运行，把最强大的节点留给最关键的任务。</p><p id="1ce1" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">如果你尝试过这个设置，并且有什么要补充的，有什么有用的或者是一个糟糕的选择，请在评论中告诉我们。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/3eb1fc25492a7fe112348c04353919b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I0jSwUBbyrsRQvTXzyj9GQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Kubernetes 上的气流(来源:基于官方徽标的作者组合)</p></figure><p id="b322" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">[1]: <strong class="lp ir">使用气流的十大好处</strong>:<a class="ae mk" href="https://medium.com/analytics-and-data/10-benefits-to-using-airflow-33d312537bae" rel="noopener">https://medium . com/analytics-and-data/10-Benefits-to-use-air flow-33d 312537 BAE</a></p><p id="7695" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">[2]: <strong class="lp ir">我们为什么改用阿帕奇气流</strong>:<a class="ae mk" href="https://www.solita.fi/en/blogs/why-we-switched-to-apache-airflow/" rel="noopener ugc nofollow" target="_blank">https://www . solita . fi/en/blogs/Why-we-switched-to-Apache-air flow/</a></p><p id="d678" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">[3]: <strong class="lp ir">罗宾汉为什么使用气流</strong>:<a class="ae mk" href="https://robinhood.engineering/why-robinhood-uses-airflow-aed13a9a90c8" rel="noopener ugc nofollow" target="_blank">https://robin hood . engineering/Why-robin hood-uses-air flow-aed 13 a9 a90 c 8</a></p><p id="6935" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">【4】:<strong class="lp ir">气流:如何及何时使用</strong>:<a class="ae mk" rel="noopener" target="_blank" href="/airflow-how-and-when-to-use-it-2e07108ac9f5">https://towardsdatascience . com/air flow-How-and-when-to-use-it-2e 07108 ac9f 5</a></p><p id="5801" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">[5]:<strong class="lp ir">Apache air flow 入门</strong>:<a class="ae mk" rel="noopener" target="_blank" href="/getting-started-with-apache-airflow-df1aa77d7b1b">https://towards data science . com/Getting-started-with-Apache-air flow-df 1a 77d 7 B1 b</a></p><p id="e717" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">[6]: <strong class="lp ir"> Airflow 原生操作符</strong>:<a class="ae mk" href="https://airflow.apache.org/docs/stable/_api/airflow/operators/index.html" rel="noopener ugc nofollow" target="_blank">https://air flow . Apache . org/docs/stable/_ API/air flow/operators/index . html</a></p><p id="c8a6" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">[7]:<strong class="lp ir">air flow contrib operators</strong>:<a class="ae mk" href="https://airflow.apache.org/docs/stable/_api/airflow/contrib/operators/index.html" rel="noopener ugc nofollow" target="_blank">https://air flow . Apache . org/docs/stable/_ API/air flow/contrib/operators/index . html</a></p><p id="73fa" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">[8]: <strong class="lp ir">卡塔科达的库伯内特斯</strong>:<a class="ae mk" href="https://www.katacoda.com/courses/kubernetes" rel="noopener ugc nofollow" target="_blank">https://www.katacoda.com/courses/kubernetes</a></p><p id="a1de" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">[9]: <strong class="lp ir"> <em class="mj"> hgrif </em>气流教程</strong>:<a class="ae mk" href="https://github.com/hgrif/airflow-tutorial" rel="noopener ugc nofollow" target="_blank">https://github.com/hgrif/airflow-tutorial</a></p><p id="fbd4" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">[10]: <strong class="lp ir">气流舵图表</strong>:<a class="ae mk" href="https://github.com/apache/airflow/tree/master/chart" rel="noopener ugc nofollow" target="_blank">https://github.com/apache/airflow/tree/master/chart</a></p><p id="e644" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">[11]: <strong class="lp ir">亚马逊 EFS CSI 司机</strong>:<a class="ae mk" href="https://github.com/kubernetes-sigs/aws-efs-csi-driver" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes-sigs/aws-efs-csi-driver</a></p><p id="2470" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated">【12】:【https://github.com/godaddy/kubernetes-external-secrets】Go-daddy Kubernetes:<a class="ae mk" href="https://github.com/godaddy/kubernetes-external-secrets" rel="noopener ugc nofollow" target="_blank">外部秘密</a></p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="77bb" class="pw-post-body-paragraph ln lo iq lp b lq ml jr ls lt mm ju lv lw mn ly lz ma mo mc md me mp mg mh mi ij bi translated"><em class="mj"> Apache Airflow 徽标</em>是 Apache 软件基金会在美国和/或其他国家的注册商标或商标。使用这些标志并不意味着 Apache 软件基金会的认可。<em class="mj"> Kubernetes logo </em>文件在 Apache-2.0 或 CC-BY-4.0(知识共享署名 4.0 国际版)的选择下获得许可。</p></div></div>    
</body>
</html>