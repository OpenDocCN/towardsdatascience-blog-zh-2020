<html>
<head>
<title>How to Use n-gram Models to Detect Format Errors in Datasets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用n元模型检测数据集中的格式错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-n-gram-models-to-detect-format-errors-in-datasets-bb2171842499?source=collection_archive---------48-----------------------#2020-03-16">https://towardsdatascience.com/how-to-use-n-gram-models-to-detect-format-errors-in-datasets-bb2171842499?source=collection_archive---------48-----------------------#2020-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f4a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于语言模型如何扩展和用于不同目的的代码优先方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/13f5c4577e8c4c97df90fcacdaff750b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZhBXt4Xy7Ri4RnPGUUfTw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/Ronile-126846/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=359950" rel="noopener ugc nofollow" target="_blank"> Ronile </a>从<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=359950" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="10f7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">格式错误，在最好的情况下，会破坏自动数据处理管道。在最坏的情况下，它们会在难以调试的下游分析任务中引入逻辑错误。发现这样的错误是一项单调而低效的工作，会降低工作效率。此外，这种手动过程可能引入不同类型的错误。<strong class="li iu">那么，我们能自动检测损坏的值吗？</strong></p><p id="0495" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">例如，考虑一个数据集<code class="fe mc md me mf b">D</code>，它有数百万行，包含一个<code class="fe mc md me mf b">Date</code>列。让我们假设这个列中的值符合一个特定的模式:<code class="fe mc md me mf b">mm.dd.yyyy</code>。假设某处存在一个无效的单元格，由于输入错误，日期遵循不同的格式:<code class="fe mc md me mf b">01.15–2019</code>。在自动化管道中，解析器将尝试读取该特性，并可能抛出异常。试图在管道执行之前找到错误几乎是不可能的。但是如果我们能让计算机检测到它呢？</p><p id="dd12" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu">在这个故事中，我们使用n-grams，一种语言模型，来自动化错误检测。</strong>我们简要讨论n元语法以及NLP工程师如何使用它们来生成语言，并研究我们如何利用它们的属性来识别数据集中可能损坏的值。</p><blockquote class="mg mh mi"><p id="ab4a" class="lg lh mj li b lj lk ju ll lm ln jx lo mk lq lr ls ml lu lv lw mm ly lz ma mb im bi translated"><a class="ae ky" href="https://mailchi.mp/d2d2d4a109b5/learning-rate-newsletter" rel="noopener ugc nofollow" target="_blank">学习率</a>是为那些对AI和MLOps的世界感到好奇的人准备的时事通讯。你会在每周五收到我关于最新人工智能新闻和文章的更新和想法。在这里订阅<a class="ae ky" href="https://mailchi.mp/d2d2d4a109b5/learning-rate-newsletter" rel="noopener ugc nofollow" target="_blank"/>！</p></blockquote><h1 id="c933" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">关于n-grams</h1><p id="29b8" class="pw-post-body-paragraph lg lh it li b lj nf ju ll lm ng jx lo lp nh lr ls lt ni lv lw lx nj lz ma mb im bi translated">n-gram是一个概率模型，简单来说，它试图预测序列中的下一个单词。像n-grams这样的概率模型总是通过例子来更好地理解。因此，请考虑下面这段摘自艾米莉·狄金森的诗:</p><blockquote class="mg mh mi"><p id="d268" class="lg lh mj li b lj lk ju ll lm ln jx lo mk lq lr ls ml lu lv lw mm ly lz ma mb im bi translated">在巨大的痛苦之后，一种正式的感觉来了——<br/>神经像坟墓一样隆重地坐着——<br/>僵硬的心会问‘是他吗，令人厌烦的’，<br/>和‘昨天，还是几个世纪以前’？</p></blockquote><p id="c0d2" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">首先，我们想知道每个句子从哪里开始，什么时候结束。为此，让我们用特殊字符<code class="fe mc md me mf b">&lt;s&gt;</code>表示起点，用<code class="fe mc md me mf b">&lt;/s&gt;</code>指出终点位置。</p><blockquote class="mg mh mi"><p id="d9a3" class="lg lh mj li b lj lk ju ll lm ln jx lo mk lq lr ls ml lu lv lw mm ly lz ma mb im bi translated"><s>巨大的痛苦之后，一种正式的感觉来了——</s><br/>&lt;s&gt;神经顿然，如同坟墓——&lt;/s&gt;<br/>s&lt;s&gt;那颗僵硬的心质问‘是他，那个生了，&lt; /s &gt; <br/> &lt; s &gt;和‘昨天，还是几个世纪以前’？&lt; /s &gt;</p></blockquote><p id="c5f5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">要创建一个n元模型，首先我们必须为<code class="fe mc md me mf b">n</code>超参数设置一个特定的数字。因此，让<code class="fe mc md me mf b">n = 2</code>，在这种情况下，n-gram模型转换为双-gram模型。现在，我们可以计算两个连续单词的概率。例如，这段摘录中的句子通常以<code class="fe mc md me mf b">the</code>一词开头。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/22ab53cbb8f342c59e3117c81d4222af.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*iVZn84tmhHoomsDh7xWQvg.png"/></div></figure><p id="87a9" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">使用这些概率，并给定一个新单词作为<em class="mj">种子</em>，我们可以预测序列中的下一个单词。显然，数据集越大，结果越好。同样，根据问题的不同，3-grams可能更好，但是 <code class="fe mc md me mf b"><strong class="li iu">n</strong></code> <strong class="li iu">的值越大，引入的稀疏性就越多。</strong></p><h1 id="1fe9" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">泛化树和泛化语言</h1><p id="07db" class="pw-post-body-paragraph lg lh it li b lj nf ju ll lm ng jx lo lp nh lr ls lt ni lv lw lx nj lz ma mb im bi translated">为了使用n-grams来检测表中的格式错误，我们需要一种方法来将原始值归纳为模式。我们也可以用原始值训练一个n元模型，但是这种方法的复杂性引入了太多的自由度，导致高度稀疏。</p><p id="862e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">例如，假设<code class="fe mc md me mf b">v₁</code>是一个表示邮政编码的原始数字序列:<code class="fe mc md me mf b">15122</code>。然后，让<code class="fe mc md me mf b">v₂,v₃</code>表示两种不同的代码:<code class="fe mc md me mf b">345a7</code>、<code class="fe mc md me mf b">47592</code>。显然，<code class="fe mc md me mf b">v₂</code>是错误的，但是如果我们在n元模型中传递原始值，我们将不会得到有价值的信息；看那个<code class="fe mc md me mf b">p(a|5) = p(1|5)</code>，这样我们要么漏掉错误，要么产生假阳性。但是如果我们能把一个原始值归纳成一个模式，我们就能得到更有意义的表示。</p><p id="4480" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为此，我们使用了<em class="mj">泛化树</em>和<em class="mj">泛化语言</em>的概念。<strong class="li iu">泛化树是一个类似下图的层次结构，将原始值映射到不同的表示形式。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/7c26076d54c20e20e7e332337d6229b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ccW90VHfn1D0_mhf.png"/></div></div></figure><p id="b04b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">从那棵树上，我们可以派生出许多语言。下面给出一个例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/607a59514f36270e83f4cde7dcce8065.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*CfqI8Ky-emf4TQOKTYqUdg.png"/></div></figure><p id="bb3e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">使用<code class="fe mc md me mf b">L₁</code>，我们可以将<code class="fe mc md me mf b">v₁,v₂,v₃</code>转换成<code class="fe mc md me mf b">DDDDD,DDDLD,DDDDD</code>。我们也可以将模式压缩为<code class="fe mc md me mf b">v₁ = D(5), v₂ = D(3)L(1),D(1), v₃ = D(5)</code>。有了这个表示和足够大的数据集来训练一个n元模型，我们可以得到邮政编码格式的字母<code class="fe mc md me mf b">L</code>出现的概率非常低。简而言之，这就是泛化树和语言的思想。如果需要更详细的介绍，请看下面的故事。</p><div class="nn no gp gr np nq"><a rel="noopener follow" target="_blank" href="/how-to-auto-detect-format-errors-in-a-dataset-6609a9e9aacc"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">如何自动检测数据集中的错误</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">引入泛化树和泛化语言来自动检测结构化数据集中的损坏值。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">towardsdatascience.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div><h1 id="b5a3" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">实施和评估</h1><p id="e3c8" class="pw-post-body-paragraph lg lh it li b lj nf ju ll lm ng jx lo lp nh lr ls lt ni lv lw lx nj lz ma mb im bi translated">现在是我们动手的时候了。对于这个例子，我们使用一个包含100行三个特征的合成数据集:<em class="mj">电子邮件、日期、邮政编码</em>。因此，让我们使用<code class="fe mc md me mf b">pandas</code>加载数据，看看是什么样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/291654d888c2ba6d4ba74478446dabb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*gu9kMilH5oEcPjea6waD6A.png"/></div></figure><p id="16c3" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这一次，我们使用了<code class="fe mc md me mf b">zip_code</code>列，其中我们引入了一些错误。因此，我们指定我们将使用的泛化语言。它严格遵循<code class="fe mc md me mf b">L₁</code>中定义的规则。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0d2a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">例如，<code class="fe mc md me mf b">2899.8</code>的图案是<code class="fe mc md me mf b">d(4)s(1)d(1)</code>，而<code class="fe mc md me mf b">03754</code>的图案是<code class="fe mc md me mf b">d(5)</code>。现在，让我们将每个邮政编码转换成它的模式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="39a0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们使用流行的python库<code class="fe mc md me mf b">nltk</code>，创建3-grams并构建最大似然估计模型(MLE)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="1a52" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">首先，我们填充序列，正如我们在这个故事的第一部分看到的。接下来，我们为每个填充序列(即，每个填充的邮政编码模式)构建一组3-gram。最后，我们使用3-grams来拟合MLE模型。</p><p id="3a74" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为了评估一个邮政编码并检测任何错误，我们需要一个score函数。因此，下面我们定义这样一个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="6933" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这个函数获取一个原始值，相应地将其归纳为一个模式，填充它并计算每个3-gram的分数。最后，它返回最不可能的计算值。<strong class="li iu">这是因为我们只需要一个3-gram就可以确信我们有错误。这是对这个玩具例子的一个简单的解释，但是如果你想了解如何聚合许多泛化语言的结果，请阅读下面的故事。</strong></p><div class="nn no gp gr np nq"><a rel="noopener follow" target="_blank" href="/how-to-auto-detect-errors-in-a-dataset-part-ii-683b114865be"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">如何使用泛化语言自动检测数据集中的错误</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">使用远程监督和汇总预测结果生成验证数据，就像大海捞针一样。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">towardsdatascience.com</p></div></div><div class="nz l"><div class="oi l ob oc od nz oe ks nq"/></div></div></a></div><p id="038e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在，如果我们将一个有效的邮政编码值传递给<code class="fe mc md me mf b">score</code>方法，得到的概率很高:<code class="fe mc md me mf b">score('15378') = 0.951</code>。另一方面，如果有任何包含字母、符号或五个以上数字的值，概率就会下降。例如，第一个邮政编码<code class="fe mc md me mf b">243x2</code>的得分为<code class="fe mc md me mf b">0.0098</code>。</p><h1 id="ec00" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="1c73" class="pw-post-body-paragraph lg lh it li b lj nf ju ll lm ng jx lo lp nh lr ls lt ni lv lw lx nj lz ma mb im bi translated">在这个故事中，我们使用一个玩具示例来展示语言模型(n-grams)如何用于表格数据集中的格式错误检测。我们简要解释了什么是n元语法，以及如何使用泛化树和语言来解决稀疏性问题。最后，我们实现了一个简单的解决方案，利用n-grams的能力结合泛化语言来检测合成数据集中的错误。</p><blockquote class="mg mh mi"><p id="5a33" class="lg lh mj li b lj lk ju ll lm ln jx lo mk lq lr ls ml lu lv lw mm ly lz ma mb im bi translated"><strong class="li iu">我叫Dimitris Poulopoulos，是希腊比雷埃夫斯大学<em class="it"/></strong><a class="ae ky" href="https://bigdatastack.eu/" rel="noopener ugc nofollow" target="_blank"><strong class="li iu">BigDataStack</strong></a><strong class="li iu"><em class="it"/>的机器学习研究员和博士(c)。我曾为欧洲委员会、欧盟统计局、国际货币基金组织、欧洲中央银行、经合组织和宜家等主要客户设计和实施人工智能和软件解决方案。如果你有兴趣阅读更多关于机器学习、深度学习和数据科学的帖子，请在twitter上关注我的</strong><a class="ae ky" href="https://medium.com/@dpoulopoulos" rel="noopener"><strong class="li iu"/></a><strong class="li iu"/><a class="ae ky" href="https://www.linkedin.com/in/dpoulopoulos/" rel="noopener ugc nofollow" target="_blank"><strong class="li iu">LinkedIn</strong></a><strong class="li iu">或</strong><a class="ae ky" href="https://twitter.com/james2pl" rel="noopener ugc nofollow" target="_blank"><strong class="li iu">@ james2pl</strong></a><strong class="li iu">。</strong></p></blockquote></div></div>    
</body>
</html>