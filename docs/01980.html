<html>
<head>
<title>A table detection, cell recognition and text extraction algorithm to convert tables in images to excel files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种表格检测、单元格识别和文本提取算法，用于将图像中的表格转换为excel文件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-table-detection-cell-recognition-and-text-extraction-algorithm-to-convert-tables-to-excel-files-902edcf289ec?source=collection_archive---------0-----------------------#2020-02-25">https://towardsdatascience.com/a-table-detection-cell-recognition-and-text-extraction-algorithm-to-convert-tables-to-excel-files-902edcf289ec?source=collection_archive---------0-----------------------#2020-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b4fc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用OpenCV和pytesseract将表格截图转换成可编辑的数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/64b625f490b69de728a0b4b47194a30b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gEVytsXesPRd2YUfpz0sZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:pixabay</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="6236" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">假设您在文章、pdf或图像中有一个表格，并希望将其转换为excel表格或数据框架，以便能够对其进行编辑。特别是在机器学习的预处理领域，这种算法将非常有助于将许多图像和表格转换为可编辑的数据。如果您的数据存在于<strong class="lh iu">基于文本的pdf文件</strong>中，已经有一些免费的解决方案。最受欢迎的是<em class="mb">表格式，卡梅洛特/神剑</em>，你可以在<a class="ae mc" href="https://tabula.technology" rel="noopener ugc nofollow" target="_blank">https://tabula.technology/</a>，<a class="ae mc" href="https://camelot-py.readthedocs.io/en/master/" rel="noopener ugc nofollow" target="_blank">https://camelot-py.readthedocs.io/en/master/</a>，<a class="ae mc" href="https://excalibur-py.readthedocs.io/en/master/" rel="noopener ugc nofollow" target="_blank">https://excalibur-py.readthedocs.io/en/master/</a>下找到。</p><p id="9545" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">但是，如果您的PDF是基于图像的，或者您在网上找到一篇带有表格的文章，该怎么办？为什么不直接截图转换成excel表呢？因为基于图像的数据(jpg、png、基于图像的pdf等)似乎没有免费或开源软件。)的想法是开发一个通用的解决方案，将表格转换成可编辑的excel文件。</p><p id="0b49" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">但是现在已经足够了，让我们看看它是如何工作的。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="3e0f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">入门指南</h1><p id="655d" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated"><strong class="lh iu">该算法由三部分组成:</strong>第一部分是使用<em class="mb">打开CV </em>的表格检测和单元格识别，第二部分是将单元格彻底分配到适当的行和列，第三部分是使用<em class="mb"> pytesseract </em>通过光学字符识别(OCR)提取每个分配的单元格。</p><p id="e90b" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">和大多数表格识别算法一样，这种算法是基于表格的行结构的。清晰和可检测的线条对于正确识别细胞是必要的。具有虚线、间隙和孔洞的表格导致较差的识别，并且没有检测到仅部分被线包围的单元。如果您的某些文档出现断行，请务必阅读本文并修复断行:<a class="ae mc" href="https://link.medium.com/JuV77oma08" rel="noopener">单击此处</a>。</p><p id="31b9" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">首先，我们需要输入数据，在我的例子中是png格式的截图。目标是拥有一个具有相同表格结构的数据框架和excel文件，其中每个单元格都可以编辑并用于进一步分析。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/d12b4bbe71a2d72a27d91aa7ef5ae471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rkxQhLMUal1xwm9rUCkuUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于进一步表格识别和提取的输入数据。</p></figure><p id="5d20" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们导入必要的库。</p><p id="0baa" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">关于图书馆的更多信息:<br/>cv2—<a class="ae mc" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank">https://opencv.org/</a>T3】宇宙魔方—<a class="ae mc" href="https://pypi.org/project/pytesseract/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/pytesseract/</a></p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="29e4" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu">import</strong> cv2<br/><strong class="nc iu">import</strong> numpy as np<br/><strong class="nc iu">import</strong> pandas as pd<br/><strong class="nc iu">import</strong> matplotlib.pyplot as plt<br/><strong class="nc iu">import</strong> csv</span><span id="85f4" class="ng me it nc b gy nl ni l nj nk">try:<br/>    <strong class="nc iu">from</strong> PIL <strong class="nc iu">import</strong> Image<br/>except ImportError:<br/>    <strong class="nc iu">import</strong> Image<br/><strong class="nc iu">import</strong> pytesseract</span></pre><p id="ceec" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">第一步是从正确的路径读入文件，使用阈值将输入图像转换为二进制图像，并将其反转以获得黑色背景、白色线条和字体。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="1115" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu">#read your file<br/></strong>file=r'/Users/YOURPATH/testcv.png'<br/>img = cv2.imread(file,0)<br/>img.shape</span><span id="3450" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">#thresholding the image to a binary image<br/></strong>thresh,img_bin = cv2.threshold(img,128,255,cv2.THRESH_BINARY |cv2.THRESH_OTSU)</span><span id="82df" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">#inverting the image <br/></strong>img_bin = 255-img_bin<br/>cv2.imwrite('/Users/YOURPATH/cv_inverted.png',img_bin)</span><span id="7e8b" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">#Plotting the image to see the output</strong><br/>plotting = plt.imshow(img_bin,cmap='gray')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/4adcefdec685c91932907490962f906d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AysdJuz4xwRm_aZf9crZeQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二进制反转图像。</p></figure><div class="nn no gp gr np nq"><a href="https://medium.com/subscribe/@hucker.marius" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">请继续关注马里乌斯·哈克的新文章</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">请继续关注Marius Hucker的新文章。如果您还没有注册，您将创建一个中型帐户…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div><p id="ad62" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">下一步是定义一个内核来检测矩形框，然后是表格结构。首先，我们定义核的长度，然后沿着垂直和水平核检测所有的垂直线和水平线。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="7865" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu"># Length(width) of kernel as 100th of total width</strong><br/>kernel_len = np.array(img).shape[1]//100</span><span id="3c9d" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu"># Defining a vertical kernel to detect all vertical lines of image <br/></strong>ver_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, kernel_len))</span><span id="ea01" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu"># Defining a horizontal kernel to detect all horizontal lines of image<br/></strong>hor_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (kernel_len, 1))</span><span id="7077" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu"># A kernel of 2x2<br/></strong>kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 2))</span></pre><p id="8fa8" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">下一步是垂直线的检测。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="30d8" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu">#Use vertical kernel to detect and save the vertical lines in a jpg</strong><br/>image_1 = cv2.erode(img_bin, ver_kernel, iterations=3)<br/>vertical_lines = cv2.dilate(image_1, ver_kernel, iterations=3)<br/>cv2.imwrite("/Users/YOURPATH/vertical.jpg",vertical_lines)</span><span id="2f87" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">#Plot the generated image</strong><br/>plotting = plt.imshow(image_1,cmap='gray')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/753c6ccfd3e14b4243dadd7232136552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5nSq32DdOdtt9gMRG79Xw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提取的垂直线。</p></figure><p id="f400" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在所有的水平线都一样。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="24b7" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu">#Use horizontal kernel to detect and save the horizontal lines in a jpg</strong><br/>image_2 = cv2.erode(img_bin, hor_kernel, iterations=3)<br/>horizontal_lines = cv2.dilate(image_2, hor_kernel, iterations=3)<br/>cv2.imwrite("/Users/YOURPATH/horizontal.jpg",horizontal_lines)</span><span id="12a3" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">#Plot the generated image</strong><br/>plotting = plt.imshow(image_2,cmap='gray')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/39728d7bd2bd5f7eba756faa25c3a49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S82xAnJ7W4Z7rOHRk_03Jg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提取的水平线。</p></figure><p id="e6fb" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们通过用0.5对水平线和垂直线进行加权，将它们组合成第三幅图像。目的是得到一个清晰的表格结构来检测每个细胞。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="b914" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu"># Combine horizontal and vertical lines in a new third image, with both having same weight.<br/></strong>img_vh = cv2.addWeighted(vertical_lines, 0.5, horizontal_lines, 0.5, 0.0)</span><span id="692e" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">#Eroding and thesholding the image</strong><br/>img_vh = cv2.erode(~img_vh, kernel, iterations=2)<br/>thresh, img_vh = cv2.threshold(img_vh,128,255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)<br/>cv2.imwrite("/Users/YOURPATH/img_vh.jpg", img_vh)</span><span id="bdcd" class="ng me it nc b gy nl ni l nj nk">bitxor = cv2.bitwise_xor(img,img_vh)<br/>bitnot = cv2.bitwise_not(bitxor)</span><span id="ebfc" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">#Plotting the generated image</strong><br/>plotting = plt.imshow(bitnot,cmap='gray')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/58d5e015219b2a3340ef85c02c0527c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZEdpjx1Ht1Oj7hYnfisKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提取的不包含文本的表格结构。</p></figure><p id="2880" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">有了表格结构后，我们使用findContours函数来检测轮廓。这有助于我们检索每个盒子的准确坐标。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="4f29" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu"># Detect contours for following box detection<br/></strong>contours, hierarchy = cv2.findContours(img_vh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span></pre><p id="4680" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">以下函数是获取轮廓序列并从上到下对其进行排序所必需的(<a class="ae mc" href="https://www.pyimagesearch.com/2015/04/20/sorting-contours-using-python-and-opencv/" rel="noopener ugc nofollow" target="_blank">https://www . pyimagesearch . com/2015/04/20/sorting-contours-using-python-and-opencv/</a>)。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="ab01" class="ng me it nc b gy nh ni l nj nk">def sort_contours(cnts, method="left-to-right"):</span><span id="7254" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">    # initialize the reverse flag and sort index<br/>    </strong>reverse = False<br/>    i = 0</span><span id="c979" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">    # handle if we need to sort in reverse</strong><br/>    if method == "right-to-left" or method == "bottom-to-top":<br/>    reverse = True</span><span id="1622" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">    # handle if we are sorting against the y-coordinate rather than<br/>    # the x-coordinate of the bounding box<br/>    </strong>if method == "top-to-bottom" or method == "bottom-to-top":<br/>    i = 1</span><span id="adc0" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">    # construct the list of bounding boxes and sort them from top to<br/>    # bottom<br/>    </strong>boundingBoxes = [cv2.boundingRect(c) for c in cnts]<br/>    (cnts, boundingBoxes) = zip(*sorted(zip(cnts, boundingBoxes),<br/>    key=lambda b:b[1][i], reverse=reverse))</span><span id="bf89" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">    # return the list of sorted contours and bounding boxe</strong>s<br/>    return (cnts, boundingBoxes)</span><span id="4ca2" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu"><br/># Sort all the contours by top to bottom.<br/></strong>contours, boundingBoxes = sort_contours(contours, method=”top-to-bottom”)</span></pre><h1 id="c048" class="md me it bd mf mg oi mi mj mk oj mm mn jz ok ka mp kc ol kd mr kf om kg mt mu bi translated">如何检索单元格的位置</h1><p id="ad68" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">需要进一步的步骤来定义每个单元的正确位置，这意味着正确的列和行。首先，我们需要检索每个单元格的高度，并将其存储在列表heights中。然后我们从高处取平均值。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="610b" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu">#Creating a list of heights for all detected boxes</strong><br/>heights = [boundingBoxes[i][3] for i in range(len(boundingBoxes))]</span><span id="4143" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">#Get mean of heights</strong><br/>mean = np.mean(heights)</span></pre><p id="e3c3" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">接下来，我们检索每个轮廓的位置、宽度和高度，并将其存储在盒子列表中。然后我们在所有的盒子周围画出矩形，并绘制图像。在我的例子中，我只对宽度小于1000像素、高度小于500像素的盒子这样做，以忽略可能没有单元格的矩形，例如整个表格。这两个值取决于你的图像大小，所以如果你的图像变小或变大，你需要调整两者。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="c778" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu">#Create list box to store all boxes in  </strong><br/>box = []</span><span id="1663" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu"># Get position (x,y), width and height for every contour and show the contour on image</strong><br/>for c in contours:<br/>    x, y, w, h = cv2.boundingRect(c)</span><span id="1178" class="ng me it nc b gy nl ni l nj nk">    if (w&lt;1000 and h&lt;500):<br/>        image = cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2)<br/>        box.append([x,y,w,h])</span><span id="54e6" class="ng me it nc b gy nl ni l nj nk">plotting = plt.imshow(image,cmap=’gray’)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/81776e5eb9cdefdf76c14996c76e1d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTI2wYgMrNu6Q5wBa4SfWA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由检测到的轮廓/方框包围的每个单元。</p></figure><p id="ee2b" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在我们有了每个单元格，它的位置、高度和宽度，我们需要在表格中得到正确的位置。因此，我们需要知道它位于哪一行哪一列。只要一个盒子的差异不超过它自己的(高度+平均值/2 ),这个盒子就在同一行。一旦高度差高于当前值(高度+平均值/2)，我们就知道新的一行开始了。列在逻辑上从左到右排列。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="a01f" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu">#Creating two lists to define row and column in which cell is located<br/></strong>row=[]<br/>column=[]<br/>j=0</span><span id="3943" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">#Sorting the boxes to their respective row and column</strong></span><span id="4522" class="ng me it nc b gy nl ni l nj nk">for i in range(len(box)):</span><span id="1c97" class="ng me it nc b gy nl ni l nj nk">    if(i==0):<br/>        column.append(box[i])<br/>        previous=box[i]</span><span id="0c08" class="ng me it nc b gy nl ni l nj nk">    else:<br/>        if(box[i][1]&lt;=previous[1]+mean/2):<br/>            column.append(box[i])<br/>            previous=box[i]</span><span id="d012" class="ng me it nc b gy nl ni l nj nk">            if(i==len(box)-1):<br/>                row.append(column)</span><span id="e96c" class="ng me it nc b gy nl ni l nj nk">        else:<br/>            row.append(column)<br/>            column=[]<br/>            previous = box[i]<br/>            column.append(box[i])</span><span id="4b85" class="ng me it nc b gy nl ni l nj nk">print(column)<br/>print(row)</span></pre><p id="1e10" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">接下来，我们计算最大列数(意味着单元格),以了解我们最终的数据框架/表格将有多少列。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="84be" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu">#calculating maximum number of cells</strong></span><span id="f873" class="ng me it nc b gy nl ni l nj nk">countcol = 0<br/>for i in range(len(row)):<br/>    countcol = len(row[i])<br/>    if countcol &gt; countcol:<br/>        countcol = countcol</span></pre><p id="3d8a" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">拥有最大数量的单元格后，我们将每列的中点存储在一个列表中，创建一个数组并对值进行排序。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="a202" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu">#Retrieving the center of each column</strong></span><span id="ffd5" class="ng me it nc b gy nl ni l nj nk">center = [int(row[i][j][0]+row[i][j][2]/2) for j in range(len(row[i])) if row[0]]</span><span id="58bb" class="ng me it nc b gy nl ni l nj nk">center=np.array(center)<br/>center.sort()</span></pre><p id="c5f7" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">此时，我们有了所有的框和它们的值，但是正如您可能在您的行列表的输出中看到的，这些值并不总是按照正确的顺序排序。这就是我们下一步要做的，关于到列中心的距离。我们存储在列表最终框中的正确顺序。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="6267" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu">#Regarding the distance to the columns center, the boxes are arranged in respective order</strong></span><span id="8ce1" class="ng me it nc b gy nl ni l nj nk">finalboxes = []</span><span id="3653" class="ng me it nc b gy nl ni l nj nk">for i in range(len(row)):<br/>    lis=[]<br/>    for k in range(countcol):<br/>        lis.append([])<br/>    for j in range(len(row[i])):<br/>        diff = abs(center-(row[i][j][0]+row[i][j][2]/4))<br/>        minimum = min(diff)<br/>        indexing = list(diff).index(minimum)<br/>        lis[indexing].append(row[i][j])<br/>    finalboxes.append(lis)</span></pre><h1 id="9a8c" class="md me it bd mf mg oi mi mj mk oj mm mn jz ok ka mp kc ol kd mr kf om kg mt mu bi translated">让我们提取值</h1><p id="2a4d" class="pw-post-body-paragraph lf lg it lh b li mv ju lk ll mw jx ln lo mx lq lr ls my lu lv lw mz ly lz ma im bi translated">在下一步中，我们将使用我们的列表终结框。我们取每一个基于图像的盒子，通过扩张和腐蚀来为光学字符识别做准备，并让pytesseract识别包含的字符串。循环遍历每个单元格，并将值存储在外部列表中。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="c93e" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu">#from every single image-based cell/box the strings are extracted via pytesseract and stored in a list</strong></span><span id="ae0d" class="ng me it nc b gy nl ni l nj nk">outer=[]<br/>for i in range(len(finalboxes)):<br/>    for j in range(len(finalboxes[i])):<br/>        inner=’’<br/>        if(len(finalboxes[i][j])==0):<br/>            outer.append(' ')</span><span id="a331" class="ng me it nc b gy nl ni l nj nk">        else:<br/>            for k in range(len(finalboxes[i][j])):<br/>                y,x,w,h = finalboxes[i][j][k][0],finalboxes[i][j][k][1], finalboxes[i][j][k][2],finalboxes[i][j][k][3]<br/>                finalimg = bitnot[x:x+h, y:y+w]<br/>                kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 1))<br/>                border = cv2.copyMakeBorder(finalimg,2,2,2,2,   cv2.BORDER_CONSTANT,value=[255,255])<br/>                resizing = cv2.resize(border, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)<br/>                dilation = cv2.dilate(resizing, kernel,iterations=1)<br/>                erosion = cv2.erode(dilation, kernel,iterations=1)<br/><br/>                <br/>                out = pytesseract.image_to_string(erosion)<br/>                if(len(out)==0):<br/>                    out = pytesseract.image_to_string(erosion, config='--psm 3')<br/>                inner = inner +" "+ out</span><span id="f9a3" class="ng me it nc b gy nl ni l nj nk">            outer.append(inner)</span></pre><p id="458d" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">最后一步是将列表转换成数据帧，并将其存储到excel文件中。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="3c1b" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu">#Creating a dataframe of the generated OCR list<br/></strong>arr = np.array(outer)<br/>dataframe = pd.DataFrame(arr.reshape(len(row),countcol))<br/>print(dataframe)<br/>data = dataframe.style.set_properties(align="left")</span><span id="5843" class="ng me it nc b gy nl ni l nj nk"><strong class="nc iu">#Converting it in a excel-file<br/></strong>data.to_excel(“/Users/YOURPATH/output.xlsx”)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/a1953738c8face1e2e47f2d6920c1afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpg5wDnZL3d0_VAZ7L2IVw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">终端中的最终数据帧。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/3db2fd1c6aa4c88633e64529c906d7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7QqHZhBO1P0yfGzJIjIGg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包含所有单元格的最终excel文件。</p></figure><p id="94e2" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh iu">就是这样！</strong>您的表格现在应该存储在数据帧和excel文件中，可用于自然语言处理、通过统计进行进一步分析或仅用于编辑。这适用于结构清晰简单的表格。如果你的表格有一个非常特殊的结构，在某种意义上说，许多单元格被组合在一起，单元格的大小变化很大，或者使用了许多颜色，那么这个算法可能必须被采用。此外，OCR在识别计算机字体方面近乎完美。但是，如果您有包含手写输入的表格，结果可能会有所不同。</p><p id="16cd" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果你把它用在你自己的桌子上，让我知道它是如何工作的。</p><div class="nn no gp gr np nq"><a href="https://medium.com/subscribe/@hucker.marius" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">请继续关注马里乌斯·哈克的新文章</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">请继续关注Marius Hucker的新文章。如果您还没有注册，您将创建一个中型帐户…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div><h1 id="c81f" class="md me it bd mf mg oi mi mj mk oj mm mn jz ok ka mp kc ol kd mr kf om kg mt mu bi translated">你喜欢这个故事？</h1><h2 id="15d2" class="ng me it bd mf oq or dn mj os ot dp mn lo ou ov mp ls ow ox mr lw oy oz mt pa bi translated"><a class="ae mc" href="https://medium.com/@hucker.marius/membership" rel="noopener">支持我和我在这里的工作</a></h2></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="a9b4" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh iu"> <em class="mb">亦读:</em> </strong></p><p id="d4b1" class="pw-post-body-paragraph lf lg it lh b li lj ju lk ll lm jx ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><a class="ae mc" rel="noopener" target="_blank" href="/how-to-recognize-and-fix-broken-lines-in-table-recognition-1a19f22d59f2">如何修复表格识别中的断线</a></p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure></div></div>    
</body>
</html>