<html>
<head>
<title>Implementation of Naive Bayes Classifier with the use of Scikit-learn and ML.NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Scikit-learn和ML实现朴素贝叶斯分类器。网</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementation-of-naive-bayes-classifier-with-the-use-of-scikit-learn-and-ml-net-d1012e105fbc?source=collection_archive---------28-----------------------#2020-02-05">https://towardsdatascience.com/implementation-of-naive-bayes-classifier-with-the-use-of-scikit-learn-and-ml-net-d1012e105fbc?source=collection_archive---------28-----------------------#2020-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f68cc83dd8636aa04c85a2b29ffa2621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIRlz9LEBIWJqXOquFQYRg.jpeg"/></div></div></figure><p id="afc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们想到机器学习时，首先想到的语言是Python或r，这是可以理解的，因为它们为我们提供了实现这些算法的许多可能性。</p><p id="30de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，我每天都在C#中工作，我的注意力被一个非常新鲜的库所吸引，这个库就是<a class="ae kz" href="https://docs.microsoft.com/en-gb/dotnet/machine-learning/" rel="noopener ugc nofollow" target="_blank">ML.NET</a>。在本文中，我将展示如何使用Scikit-learn在Python语言中实现朴素贝叶斯分类器，以及如何使用前面提到的ML.NET在C#中实现朴素贝叶斯分类器。</p><p id="4d0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">朴素贝叶斯分类器</strong></p><p id="f663" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">朴素贝叶斯分类器是一个简单的概率分类器，它假设独立变量相互独立。它基于贝叶斯定理，其数学表达如下:</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi la"><img src="../Images/7e865ccb85d25051c32ca786ee177aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*RyWZ2qQPafT_Ull8oJ7rgA.png"/></div></figure><p id="f716" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">数据集</strong></p><p id="8d2b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我使用了来自UCI机器学习知识库的<a class="ae kz" href="https://archive.ics.uci.edu/ml/datasets/Wine+Quality" rel="noopener ugc nofollow" target="_blank">葡萄酒质量数据集</a>进行实验。所分析的数据集具有11个特征和11个类别。等级决定了葡萄酒的质量，数值范围为0-10。</p><p id="af5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">ML.NET</strong></p><p id="c066" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一步是创建一个控制台应用程序项目。然后你必须从NuGet包中下载NuGet库。现在，您可以创建与数据集中的属性相对应的类。清单中显示了创建的类:</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="761f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，您可以继续加载数据集，并将其分为训练集和测试集。我在这里采用了标准结构，即80%的数据是训练集，而其余的是测试集。</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="a498" class="lm ln it li b gy lo lp l lq lr">var dataPath = "../../../winequality-red.csv";</span><span id="1b44" class="lm ln it li b gy ls lp l lq lr">var ml = new MLContext();</span><span id="5cae" class="lm ln it li b gy ls lp l lq lr">var DataView = ml.Data.LoadFromTextFile&lt;Features&gt;(dataPath, hasHeader: true, separatorChar: ';');</span></pre><p id="3cae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在有必要使模型结构适应model图书馆采用的标准。这意味着指定类的属性必须称为Label。其余的属性必须压缩在名称Features下。</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="2f24" class="lm ln it li b gy lo lp l lq lr">var partitions = ml.Data.TrainTestSplit( DataView, <br/>testFraction: 0.3);</span><span id="ca86" class="lm ln it li b gy ls lp l lq lr">var pipeline = ml.Transforms.Conversion.MapValueToKey(<br/>inputColumnName: "Quality", outputColumnName: "Label")<br/>.Append(ml.Transforms.Concatenate("Features", "FixedAcidity", "VolatileAcidity","CitricAcid", "ResidualSugar", "Chlorides", "FreeSulfurDioxide", "TotalSulfurDioxide","Density", "Ph", "Sulphates", "Alcohol")).AppendCacheCheckpoint(ml);</span></pre><p id="3e1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完成上述步骤后，您可以继续创建培训渠道。在这里，您可以选择朴素贝叶斯分类器形式的分类器，并在参数中为其指定标注和要素的列名。您还指示了表示预测标签的属性。</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="0257" class="lm ln it li b gy lo lp l lq lr">var trainingPipeline = pipeline.Append(ml.MulticlassClassification.Trainers.<br/>NaiveBayes("Label","Features"))<br/>.Append(ml.Transforms.Conversion.MapKeyToValue("PredictedLabel"));</span></pre><p id="c6ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，您可以继续训练和测试模型。一切都在两行代码中结束。</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="6672" class="lm ln it li b gy lo lp l lq lr">var trainedModel = trainingPipeline.Fit(partitions.TrainSet);</span><span id="af79" class="lm ln it li b gy ls lp l lq lr">var testMetrics = ml.MulticlassClassification.<br/>Evaluate(trainedModel.Transform(partitions.TestSet));</span></pre><p id="ccb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> Scikit-learn </strong></p><p id="249e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Python实现的情况下，我们也从数据集文件的处理开始。为此，我们使用numpy和pandas库。在清单中，您可以看到用于从文件中检索数据并从中创建ndarray的函数，这些函数将用于算法。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="lf lg l"/></div></figure><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="5335" class="lm ln it li b gy lo lp l lq lr">from sklearn.naive_bayes import GaussianNB<br/>from common.import_data import ImportData<br/>from sklearn.model_selection import train_test_split</span><span id="85eb" class="lm ln it li b gy ls lp l lq lr">if __name__ == "__main__":<br/>data_set = ImportData()<br/>x = data_set.import_all_data()<br/>y = data_set.import_columns(np.array(['quality']))</span></pre><p id="3bef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一步是创建一个训练和测试集。在这种情况下，我们还对测试集使用20%的划分，对训练集使用80%的划分。我使用了train_test_split函数，它来自库sklearn。</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="9001" class="lm ln it li b gy lo lp l lq lr">X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.2)</span></pre><p id="d325" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您可以继续使用朴素贝叶斯分类器了。在这种情况下，训练和测试也在几行代码中完成。</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="191f" class="lm ln it li b gy lo lp l lq lr">NB = GaussianNB()<br/>NB.fit(X_train, y_train.ravel())<br/>predictions = NB.predict(X_test)<br/>print('Scores from each Iteration: ', NB.score(X_test, y_test))</span></pre><p id="e9cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">结果和总结</strong></p><p id="736d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Scikit-learn实现的朴素贝叶斯分类器的准确率为56.5%，而ML.NET的准确率为41.5%。这种差异可能是由于算法实现的其他方式，但仅基于精度，我们不能说哪个更好。然而，我们可以说，机器学习算法的实现的一个有前途的替代方案正在开始出现，这就是C#和ML.NET的使用。</p></div></div>    
</body>
</html>