<html>
<head>
<title>AUC and its implementation in CatBoost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AUC及其在CatBoost中的实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/auc-and-its-implementation-in-catboost-6bc740c01f98?source=collection_archive---------33-----------------------#2020-05-12">https://towardsdatascience.com/auc-and-its-implementation-in-catboost-6bc740c01f98?source=collection_archive---------33-----------------------#2020-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ba32" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">本教程是关于受试者工作特征(ROC)曲线下的区域(AUC)及其在CatBoost中的实现，用于二元分类、多类分类和排序问题。</h2></div><h1 id="9b10" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">关于AUC</h1><p id="ee3d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> ROC曲线</strong>显示了<em class="lw">模型区分等级</em>的能力。</p><p id="eddf" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">将类别随机分配给对象的模型是“坏的”分类器，并且具有对角ROC曲线。分类器越好，ROC曲线越高。绘制ROC曲线，y轴为TPR、<a class="ae mc" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Basic_concept" rel="noopener ugc nofollow" target="_blank">真阳性率</a>，x轴为FPR、<a class="ae mc" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Basic_concept" rel="noopener ugc nofollow" target="_blank">假阳性率</a>。该曲线也可以根据模型的<a class="ae mc" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity" rel="noopener ugc nofollow" target="_blank">敏感性和特异性</a>进行解释，y轴为敏感性，x轴为(1-特异性)。</p><p id="d47b" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">构建和可视化ROC曲线可用于<em class="lw">测量具有不同概率边界的分类算法性能</em>和<em class="lw">选择实现指定假阳性或假阴性率所需的概率边界</em>。</p><p id="2259" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated"><strong class="lc iu"> AUC </strong>是ROC曲线下的面积。对所有对象进行正确排序的模型的最佳AUC = 1(所有具有类别1的对象被分配比类别0的对象更高的概率)。作为随机猜测的“坏”分类器的AUC等于0.5。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/68d11710bc70769a4cb17619cd09faa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XG6kb-HUJRLf52zKKng8uw.jpeg"/></div></div></figure><p id="dfb1" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">AUC用于二元分类、多类分类和排序问题。<em class="lw"> AUC测量正确排序对象的比例和模型区分类别的能力</em>。</p><p id="e869" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">AUC具有一个重要的统计特性:分类器的<em class="lw"> AUC相当于分类器将随机选择的阳性实例排列得高于随机选择的阴性实例的概率</em>。</p><h1 id="e913" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">CatBoost实现</h1><p id="9954" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于<a class="ae mc" href="https://catboost.ai/docs/concepts/loss-functions-classification.html" rel="noopener ugc nofollow" target="_blank">二分类</a>、<a class="ae mc" href="https://catboost.ai/docs/concepts/loss-functions-multiclassification.html" rel="noopener ugc nofollow" target="_blank">多分类</a>、<a class="ae mc" href="https://catboost.ai/docs/concepts/loss-functions-ranking.html" rel="noopener ugc nofollow" target="_blank">排序</a>问题，在CatBoost中有AUC的实现。您可以在过度拟合检测和自动最佳模型选择的训练期间计算AUC，使用<a class="ae mc" href="https://catboost.ai/docs/concepts/python-reference_catboost_eval-metrics.html" rel="noopener ugc nofollow" target="_blank"> model.eval_metric </a>评估新数据上的模型，并将AUC用作预测评估和与<a class="ae mc" href="https://https//catboost.ai/docs/concepts/python-reference_utils_eval_metric.html" rel="noopener ugc nofollow" target="_blank"> utils.eval_metric </a>比较的指标。请参阅如何在真实数据集上使用Catboost中的AUC一节中使用CatBoost进行模型拟合和AUC计算的示例。</p><h1 id="d89d" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">有用的链接</h1><ul class=""><li id="a677" class="mp mq it lc b ld le lg lh lj mr ln ms lr mt lv mu mv mw mx bi translated">在维基百科上阅读更多关于ROC的内容。</li><li id="44d0" class="mp mq it lc b ld my lg mz lj na ln nb lr nc lv mu mv mw mx bi translated">要从头开始了解ROC曲线的构建，请参见文章。</li><li id="ff11" class="mp mq it lc b ld my lg mz lj na ln nb lr nc lv mu mv mw mx bi translated">要了解多类分类的AUCμ，请参见文章。</li></ul><h1 id="082e" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">二元分类</h1><h2 id="d613" class="nd kj it bd kk ne nf dn ko ng nh dp ks lj ni nj ku ln nk nl kw lr nm nn ky no bi translated">二元分类的计算规则</h2><p id="3f39" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">二元分类的AUC根据以下公式计算:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi np"><img src="../Images/261a5ade68aff6a20c631eefb58622fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSeGWsxqbwvdNuUsgLgH7w.png"/></div></div></figure><p id="83d1" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">其中<em class="lw"> aᵢ,aⱼ </em> —算法给出的物体属于类别1的预测(概率)。</p><p id="e2f9" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">对所有对象对<em class="lw"> i，j </em>计算总和，使得:<em class="lw"> tᵢ=0，tⱼ=1 </em>其中<em class="lw"> t </em>是真正的类标签。</p><p id="2881" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">如果对象<em class="lw"> i，j </em>排序正确，则<em class="lw"> I </em>是等于1的指示函数:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nq"><img src="../Images/52082d512b599adb0dbb088df86c6a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bPfAxTBPklOFWF8yKrPqqQ.png"/></div></div></figure><p id="e8c8" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">用户可以为每个对象分配权重，以指定每个对象在度量计算中的重要性。</p><h1 id="6544" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">二元分类AUC计算的一个简单例子</h1><p id="c190" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们看一个简单的ROC曲线构建和AUC计算的例子:</p><p id="2ec3" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">我们有10个对象的样本，4个来自类1，6个来自类0(“类”列)。所有对象同等重要(权重= 1)。假设我们预测了对象来自类别1的概率(“预测”列)。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/39326539168eb4ed9b008e4ee303fea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*MHqAp_h_AEMUrKdiHJFFZQ.png"/></div></figure><p id="4f1b" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">分母等于对象对的数量<em class="lw"> i，j </em>使得真实类<em class="lw"> tᵢ=0,tⱼ=1 </em>。因为有4个来自类1的对象和6个来自类0的对象，所以分母等于24。</p><p id="4691" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">对于来自类1的每个对象，计算来自类0的对象的数量，这些对象在排序的数据集中位于下面(概率较小)。</p><p id="d83b" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">我们添加+1个正确排序的对象(例如，id为0和4的对象)，如果概率相等，则添加+0.5个对象(例如，id为1和7的对象)。</p><p id="26d5" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">例如，ID = 1的对象将+4.5加到AUC分子上，与ID:8，3，6，9的对象正确排序，并且与对象7具有相同的预测:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/9c910a59b5bd5db9f5255d9ef331c911.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*fdhniBgPe3_-8Jx6Ndi6Bw.jpeg"/></div></figure><pre class="me mf mg mh gt nt nu nv nw aw nx bi"><span id="f210" class="nd kj it nu b gy ny nz l oa ob">denominator = sum(toy_example['class'] == 1) * sum(toy_example['class'] == 0)</span><span id="cccb" class="nd kj it nu b gy oc nz l oa ob">numerator = (6 + 5 + 4.5 + 2)</span><span id="3f9a" class="nd kj it nu b gy oc nz l oa ob">manually_calculated_auc = numerator / denominator</span><span id="1334" class="nd kj it nu b gy oc nz l oa ob">manually_calculated_auc = 0.7292</span></pre><p id="df8e" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">让我们用Catboost计算同样的指标，并确保一切都是正确的:</p><pre class="me mf mg mh gt nt nu nv nw aw nx bi"><span id="5c97" class="nd kj it nu b gy ny nz l oa ob">catboost_auc = eval_metric(toy_example['class'], toy_example['prediction'], 'AUC')[0]</span></pre><h1 id="127e" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">受试者工作特征曲线</h1><p id="54eb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要构建ROC曲线，请将类别1 (n1)的对象数量放在正方形中，第1条边沿y轴，类别0 (n0)的对象数量沿x轴。</p><p id="faa2" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">按照由模型预测以降序排列的目标标签列表，将沿着y轴增加1/n1，遇到类别1的对象，并且沿着x轴增加1/n0，遇到类别0的对象。</p><p id="b18b" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">通过“类”列从上到下，如果类是1，我们就在图上向上，如果类是0，我们就在图上向右。当遇到预测相同的对象时，将y轴上的数字1和x轴上的数字0相加，然后沿着矩形的对角线前进。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi od"><img src="../Images/fd1813dc548bb0bd5a6fe4e671431e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*rmqzLszrJp6bf89DP025JA.png"/></div></figure><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/271c7b5152139a540f17039a2a3852e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*oIVNvju9Ek6-HdF3ZwR6AA.jpeg"/></div></figure><h1 id="e4a8" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">AUC:加权计算</h1><p id="97a4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">CatBoost允许我们为数据集中的每个对象分配一个权重，以便根据上面的公式计算AUC。如果没有分配权重，所有权重都等于1，因此AUC与正确排序对的数量成比例。如果分配给此属性的权重被更改。</p><p id="28fe" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">权重对于不平衡的数据集非常有用。如果在训练数据集中存在具有少量样本的一类或一组对象，则增加相应对象的权重可能是合理的。</p><p id="27fb" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">例如，如果我们将权重10分配给一个对象，这可以理解为将9个相同的对象添加到数据集。</p><p id="97b6" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">让我们以权重= 10的一个重要对象的错误和正确分类为例来计算AUC。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi of"><img src="../Images/eb1ed5d4c34264870936502540f5be06.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*ytizSz3yZ28hj9xpFKW0vA.png"/></div></figure><pre class="me mf mg mh gt nt nu nv nw aw nx bi"><span id="752a" class="nd kj it nu b gy ny nz l oa ob">roc_auc = catboost.utils.eval_metric(toy_example[‘class’], toy_example[‘prediction’], ‘AUC’, weight=toy_example[‘weight’])[0]</span></pre><p id="de73" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">AUC = 0.9167。一个重要的对象被正确排序，AUC增加</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi og"><img src="../Images/799bc10865b11add44c3c4497f36d2a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*58ZdAxxSxybr4dtqElbVYQ.png"/></div></figure><pre class="me mf mg mh gt nt nu nv nw aw nx bi"><span id="b957" class="nd kj it nu b gy ny nz l oa ob">roc_auc = catboost.utils.eval_metric(toy_example['class'], toy_example['prediction'], 'AUC', weight=toy_example['weight'])[0]</span></pre><p id="3995" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">AUC = 0.4417。一个重要对象订购错误，AUC下降</p><h1 id="5ad4" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">多类分类的AUC</h1><p id="2295" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Catboost中的多类分类实现了两个AUC指标。</p><p id="3cb0" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">首先是<strong class="lc iu"> OneVsAll </strong>。根据二元分类计算原则，对每个类别分别计算AUC值。</p><p id="55aa" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">第二个是<strong class="lc iu"> AUC </strong> μ，其被设计为满足以下特性:</p><ul class=""><li id="82e0" class="mp mq it lc b ld lx lg ly lj oh ln oi lr oj lv mu mv mw mx bi translated">物业1。如果模型在每个例子中给出正确标签的概率最高，那么AUC = 1</li><li id="c267" class="mp mq it lc b ld my lg mz lj na ln nb lr nc lv mu mv mw mx bi translated">房产2。对实施例的随机猜测产生AUC = 0.5</li><li id="fbce" class="mp mq it lc b ld my lg mz lj na ln nb lr nc lv mu mv mw mx bi translated">房产3。AUC对类别偏差不敏感</li></ul><p id="34dd" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">AUCμ可以解释为类别之间成对AUC的平均值。详情可在<a class="ae mc" href="http://proceedings.mlr.press/v97/kleiman19a/kleiman19a.pdf" rel="noopener ugc nofollow" target="_blank">文章</a>中找到。</p><h1 id="b30c" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">OneVsAll AUC</h1><p id="76b1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Catboost中的OneVsAll AUC返回n-class分类的n个AUC值。根据二进制分类计算规则，为从0到K–1编号的每个类K单独计算该值。类别k的对象被认为是正的，而所有其他的被认为是负的。</p><p id="faa0" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">它的工作方式与二进制分类几乎相同，所以我在这里跳过计算细节(它们在iPython笔记本中)。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ok"><img src="../Images/cbab0f0d7d0f5d33bd450c246e49e450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dnUSBIEKwkIvc5_6kRv0GA.png"/></div></div></figure><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/2525bda94b26d3b588f8aea2e68c6b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*HtA0K0Ft5MYcv5PbMXi_hw.png"/></div></figure><p id="5612" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">OneVsAll AUC衡量分类器区分一类对象与另一类对象的能力。</p><p id="4e31" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">OneVsAll的一个优势是能够分别监控不同类的性能。</p><h1 id="113c" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">AUCμ</h1><p id="1ac0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">AUCμ可用作评估度量以防止过度拟合，而OneVsAll AUC仅可用于包含k值的信息(k是类的数量)。</p><p id="a756" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">让我们来看看AUCμ公式:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi om"><img src="../Images/56e04556d2ad20fe86453f4cc4e80823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eCevqZZAyqpioombq3luTg.png"/></div></div></figure><p id="3536" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated"><em class="lw"> K </em>是班数，<em class="lw"> i &lt; j ≤ K </em>是班数。</p><p id="68e3" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated"><em class="lw"> S(i，j) </em>是类<em class="lw"> i </em>和<em class="lw"> j </em>之间的可分性度量，定义为:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi on"><img src="../Images/49df4679acbdfdf6e3691add97dbf52b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bD3ekGSYdS4bFiLTuc247A.png"/></div></div></figure><p id="7b54" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">在哪里</p><ul class=""><li id="3186" class="mp mq it lc b ld lx lg ly lj oh ln oi lr oj lv mu mv mw mx bi translated"><em class="lw"> I </em>是应用于<em class="lw"> O </em>结果的指示函数，如果O<em class="lw">返回正值则返回1，如果</em>O<em class="lw">返回负值则返回0，如果</em>O<em class="lw">返回0则返回0.5。</em></li><li id="d3b0" class="mp mq it lc b ld my lg mz lj na ln nb lr nc lv mu mv mw mx bi translated"><em class="lw"> O </em>是一个方向函数，指示两个实例的顺序是正确、错误还是相同。如果预测排序正确，则返回正值；如果排序错误，则返回负值；如果排序相同，则返回0。</li><li id="e857" class="mp mq it lc b ld my lg mz lj na ln nb lr nc lv mu mv mw mx bi translated"><em class="lw"> a，b </em>分别是来自类<em class="lw"> i，j </em>的对象，</li><li id="8fb5" class="mp mq it lc b ld my lg mz lj na ln nb lr nc lv mu mv mw mx bi translated"><em class="lw"> p(a)，p(b) </em>是对象属于类别的预测概率的向量，</li><li id="40b8" class="mp mq it lc b ld my lg mz lj na ln nb lr nc lv mu mv mw mx bi translated"><em class="lw"> y(a)，y(b) </em>是对象的真标签<em class="lw"> a，b </em>(一热向量)，</li><li id="2118" class="mp mq it lc b ld my lg mz lj na ln nb lr nc lv mu mv mw mx bi translated"><em class="lw"> vᵢ ⱼ </em>是一个两类决策超平面法向量。</li></ul><p id="867e" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated"><em class="lw"> O </em>计算如下:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oo"><img src="../Images/3be20cad7e4cd44922e00270e2601113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3D1-NRjyyzsknWpEvXVyxA.png"/></div></div></figure><p id="c805" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">向量<em class="lw"> v_i，j </em>来自误分类代价矩阵<em class="lw"> A </em>，该矩阵是在学习任务之后手动定义的。</p><p id="947d" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated"><em class="lw"> vᵢ ⱼ=A ᵢ.—ⱼ.</em></p><p id="7eb2" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">一个<em class="lw"> ᵢ ⱼ </em>是当实例的真实类是<em class="lw"> j </em>时，将实例分类为类<em class="lw"> i </em>的成本。然后，A在<em class="lw">(k1)</em>—单纯形上定义一个划分，并归纳出<em class="lw"> K </em>类之间的决策边界。</p><p id="9724" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">默认的误分类成本矩阵值在任何地方都是1，除了对角线上的值是0。它被称为argmax划分矩阵，因为它以最大概率分配一个类。</p><p id="bc80" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">这是一个具有argmax划分矩阵a的3类分类问题的划分。对于使用定义的划分矩阵，边界(由箭头标记)被移动。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi op"><img src="../Images/184e7ec78abba9880efe65044a085e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*N2GL5MpDPxGb9KIvR70Twg.jpeg"/></div></figure><p id="7c8a" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">请关注文章了解更多详情。</p><p id="8e39" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">CatBoost允许我们设置误分类成本矩阵A和对象的权重来计算AUCμ。</p><p id="5900" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">让我们计算一个非常小的例子的AUCμ，这个例子有3个类和4个对象:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oq"><img src="../Images/dd68e66df301ff00b06576151a791a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTndFZddRauYiYiaZZHSEA.png"/></div></div></figure><p id="bf4d" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">让我们计算每个有序类对的S(i，j ):</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi or"><img src="../Images/f28877dac1be64435579dcd218169bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXethy9ZOaz9XidbhSISBw.png"/></div></div></figure><p id="db3e" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">让我们用Catboost AUCμ计算相同的指标，并确保一切都是正确的:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi os"><img src="../Images/7fb2cbeb536838e7cad491eb79f48691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMcIkyzy0-TZeI3R8NZYXA.png"/></div></div></figure><p id="9a47" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">我们可以看到AUCμ相当高，但实际上，算法性能很差，精度为0.25。因此，在培训期间评估其他重要指标是合理的。</p><p id="b08f" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">AUCμ是评估算法在多分类问题中分类能力的一个很好的概括度量。在文章的<a class="ae mc" href="http://proceedings.mlr.press/v97/kleiman19a/kleiman19a.pdf" rel="noopener ugc nofollow" target="_blank">第4.3节中可以看到更多关于多类AUC计算的不同方法及其特性。</a></p><p id="b414" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">AUCμ可以解释为类别之间成对AUC的平均值。与OneVsAll AUC不同，AUCμ是单个值，因此它可以在用于过拟合检测和树修剪的训练期间用作评估度量。</p><h1 id="8da1" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">排名的AUC</h1><p id="313b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于CatBoost中的排名，有两种不同的AUC。</p><h2 id="dac9" class="nd kj it bd kk ne nf dn ko ng nh dp ks lj ni nj ku ln nk nl kw lr nm nn ky no bi translated">经典AUC</h2><p id="faae" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">用于具有对数损失和交叉熵损失函数的模型。它具有与二元分类的AUC相同的公式:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/264d4ffdf23a639782833b830535ad55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*yBNkYqT-Kmrdc00BmQRvmg.png"/></div></figure><p id="9041" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated"><em class="lw"> aᵢ </em>，<em class="lw"> aⱼ </em> —预测对象的等级<em class="lw"> i，j </em>。</p><p id="b9d0" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">对所有对象对<em class="lw"> i，j </em>计算总和，使得:<em class="lw"> tᵢ=0，tⱼ=1 </em>其中<em class="lw"> t </em>是相关的。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ou"><img src="../Images/88a7c2d4cf8784834f812f6ae5b70159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cij3BZSi5-VkIE1XJ31Emg.png"/></div></div></figure><p id="f0fd" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">上面的公式适用于目标值等于1和0的简单任务。如果我们有更多的目标值呢？</p><p id="2934" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">如果目标类型不是二进制，那么具有目标值<em class="lw"> t </em>和权重<em class="lw"> w </em>的每个对象<em class="lw"> i </em>被替换为两个对象用于度量计算:</p><ul class=""><li id="ff50" class="mp mq it lc b ld lx lg ly lj oh ln oi lr oj lv mu mv mw mx bi translated"><em class="lw">重量<em class="lw"> wt </em>目标值为1的σ₁ </em></li><li id="f319" class="mp mq it lc b ld my lg mz lj na ln nb lr nc lv mu mv mw mx bi translated"><em class="lw">重量为<em class="lw">w(1t)</em>的σ₂ </em>，目标值为0。</li></ul><p id="138b" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">目标值必须在范围<em class="lw">[0；1] </em>。</p><p id="9f4a" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">让我们为一个小例子计算排名的经典AUC。假设我们有2个文档，2个请求，相应的相关性在范围[1，5]内，预测相关性在范围[0，1]内:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/1da73fe8c6e9bfedcf8afc9090534c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*gq0ZUz65UJRmAqetLaYkjQ.png"/></div></figure><p id="cf5c" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">数据预处理后(详见笔记本),我们得到:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ow"><img src="../Images/444563ecc3a47f2f8eb33cace169a3d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_mUNb2AKlUgrMcPeymPyw.png"/></div></div></figure><p id="1f88" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">让我们计算AUC:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ox"><img src="../Images/f1f81ab3d6232856ec80176d2bf56418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OiM8oqYEgdT0mIZ4Uv02EQ.png"/></div></div></figure><h1 id="d84a" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">排名AUC</h1><p id="7471" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">AUC排名用于损失函数排名。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/462d26d7fdc63a6b877a4054c96ce9e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*cRuHvX3jLCuTA7Hd6vK-qw.png"/></div></figure><p id="c3ac" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated"><em class="lw"> aᵢ，</em>是预测对象的等级<em class="lw"> i，j </em>。</p><p id="212a" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">对所有对象对<em class="lw"> i，j </em>计算总和，使得:<em class="lw"> tᵢ &lt; tⱼ </em>其中<em class="lw"> t </em>是相关的。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oz"><img src="../Images/c67cc557dff6a7657150834c05eeeb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wbeS4VzP4zLHUyYaRXMxw.png"/></div></div></figure><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi pa"><img src="../Images/98749b4aa7a59f7c8977d927b5b829fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qFg9HW8hbbR9kLABLuNBg.png"/></div></div></figure><p id="3d98" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">排名AUC直接衡量正确排名对的数量。问题是指标的计算不考虑组。在我们的例子中，我们有组(请求),并且我们可能想要测量组内的质量，但是目前，AUC是在数据集上计算的，并且如果例如一个请求的前一个文档的排名低于另一个文档的前一个文档，而真实排名相反(但是仍然是每个文档的前一个),则AUC惩罚我们。</p><p id="4bd2" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">AUC用于排序的另一个问题是，它没有将顶部对象与其他对象区分开来。如果我们有许多不相关的文档，这些文档被模型排序为不相关，但排名在前10位，AUC可能仍然很高，因为不相关对象的“尾巴”比相关对象的排名低。</p><h1 id="69bb" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">概观</h1><p id="6692" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">AUC是一种广泛使用的度量标准，用于衡量模型区分类别和正确排序来自不同类别/具有不同相关性的对象的能力。AUC是不可微的，因此不能用作损失函数，但作为一种度量，它提供了很多信息，非常有用。</p><p id="ecd7" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">我们研究了以下AUC类型:</p><ul class=""><li id="5002" class="mp mq it lc b ld lx lg ly lj oh ln oi lr oj lv mu mv mw mx bi translated">二元分类的AUC。这是一个经典的度量标准，用来衡量模型的质量。ROC曲线允许选择概率阈值以满足所需的假阳性或假阴性率。</li><li id="3e77" class="mp mq it lc b ld my lg mz lj na ln nb lr nc lv mu mv mw mx bi translated">多类分类的AUC:OneVsAll和AUCμ。OneVsAll AUC有助于控制每个类的算法性能，但不能用作防止过度拟合的度量。相反，AUCμ是一个很好的概括指标，但是不能检测一个类的问题。</li><li id="e18a" class="mp mq it lc b ld my lg mz lj na ln nb lr nc lv mu mv mw mx bi translated">排名的AUC:经典AUC和排名AUC。AUC适合于排序任务，因为它被设计成测量算法如何区分类别，并且它简单地转移到区分相关和不相关的对象。但是AUC没有考虑到在排序问题中，前n个位置非常重要，并且平等地对待每个正确排序的文档对。</li></ul><p id="2f27" class="pw-post-body-paragraph la lb it lc b ld lx ju lf lg ly jx li lj lz ll lm ln ma lp lq lr mb lt lu lv im bi translated">要更深入地了解数据处理、计算细节以及在CatBoost中使用AUC的示例，请参见iPython笔记本，代码见<a class="ae mc" href="https://github.com/catboost/catboost/blob/master/catboost/tutorials/metrics/AUC_tutorial.ipynb" rel="noopener ugc nofollow" target="_blank"> CatBoost教程</a>。</p></div></div>    
</body>
</html>