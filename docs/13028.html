<html>
<head>
<title>The Upgraded “Top N” Analysis You Haven’t Seen Yet with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">升级后的“前 N 名”分析你还没见过熊猫</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-upgraded-top-n-analysis-you-havent-seen-yet-with-pandas-47e6fdc67130?source=collection_archive---------39-----------------------#2020-09-07">https://towardsdatascience.com/the-upgraded-top-n-analysis-you-havent-seen-yet-with-pandas-47e6fdc67130?source=collection_archive---------39-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1450" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">thePYTHON</h2><div class=""/><div class=""><h2 id="86d6" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">这是一个巧妙的技巧，可以添加到你的熊猫技能中，从数据中获取新的见解</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/b1ab4dbb87e67213b47bbf50bd35820d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJqjm_baPhVjn7fetBRV1g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://www.instagram.com/softie__arts/" rel="noopener ugc nofollow" target="_blank"> softie__arts </a></p></figure><p id="ab62" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您知道在 Pandas 中可以基于多个列进行前 N 名分析吗？</p><p id="be52" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">前 N 名分析有助于选择符合特定条件的数据子集。例如，如果你拥有一家餐馆，想看看哪些顾客对你的总销售额贡献最大，那该怎么办？最简单的方法是查看所有客户的总销售额，然后从高到低对列表进行排序。</p><p id="a112" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一个值得关注的子集可能是利润贡献最低(或为负)的客户。然后，您可以用类似的方式完成这项工作，根据利润贡献获得所有客户的列表，然后只选取最低的成员。</p><p id="2b63" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，如果您想找出是否有客户同时出现在两个列表中，该怎么办呢？</p><p id="36f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可以帮助你确定哪些领域你实际上在赔钱，即使看起来总销售额非常高。例如，如果你有一道菜的利润率非常低，那么单单重复点这道菜可能对你的底线没有好处。</p><p id="8250" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们来看看你如何结合内置的熊猫函数来做这种分析！</p><p id="c783" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这篇文章中使用的数据来自雅虎财经。我们将使用特斯拉股票价格数据的子集。如果您想继续，请运行下面的代码。(如果你对我用来获取数据的函数感到好奇，请滚动到最底部，点击第一个链接。)</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="d9e9" class="mj mk it mf b gy ml mm l mn mo">import pandas as pd</span><span id="af56" class="mj mk it mf b gy mp mm l mn mo">df = pd.read_html("<a class="ae lh" href="https://finance.yahoo.com/quote/TSLA/history?period1=1546300800&amp;period2=1550275200&amp;interval=1d&amp;filter=history&amp;frequency=1d" rel="noopener ugc nofollow" target="_blank">https://finance.yahoo.com/quote/TSLA/history?period1=1546300800&amp;period2=1550275200&amp;interval=1d&amp;filter=history&amp;frequency=1d</a>")[0]<br/>df = df.head(30)<br/>df = df.astype({"Open":'float',<br/>                "High":'float',<br/>                "Low":'float',<br/>                "Close*":'float',<br/>                "Adj Close**":'float',<br/>                "Volume":'float'})</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/c1d9f30172cf6c077006003e85cd03d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*qJnU92aG8tMLKVPjB52I8Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来自<a class="ae lh" href="https://finance.yahoo.com/quote/TSLA/history?period1=1546300800&amp;period2=1550275200&amp;interval=1d&amp;filter=history&amp;frequency=1d" rel="noopener ugc nofollow" target="_blank">雅虎财经</a>的特斯拉股价样本</p></figure><h1 id="d9de" class="mr mk it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">组合顶部 N 和底部 N 与熊猫</h1><p id="25e8" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">为了演示如何将前 N 名和后 N 名分析结合起来，我们将回答以下问题:</p><blockquote class="nn no np"><p id="224c" class="li lj nq lk b ll lm kd ln lo lp kg lq nr ls lt lu ns lw lx ly nt ma mb mc md im bi translated">《T4 》:在数据集中，哪几天的股价涨幅最高，同时开盘价最低？</p></blockquote><p id="d124" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们需要计算股票价格在一天之内变化了多少。这可以通过简单的计算来实现:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="a442" class="mj mk it mf b gy ml mm l mn mo">df['Gain'] = df['Close*'] - df['Open']</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c7b1590d9696d711702a4f3c73273f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*l7G860ZGIHr_Wr4LlLSIWg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">具有新“增益”栏的数据</p></figure><p id="8f95" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们已经将“Close*”和“Open”列之间的差异存储到一个名为“Gain”的新列中。正如您在上表中看到的，并不是所有的列值都是正的，因为有些日子股票价格下降了。</p><p id="8f9f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们将创建两个新的数据帧:一个包含前 10 个最高“增益”值，另一个包含前 10 个最低“开放”值。</p><h2 id="761e" class="mj mk it bd ms nv nw dn mw nx ny dp na lr nz oa nc lv ob oc ne lz od oe ng iz bi translated">条件 1:增益的顶部 N</h2><p id="8a05" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">在这里，我们将在熊猫身上使用<code class="fe of og oh mf b">nlargest</code>方法。该方法接受要保留的元素数量、要对数据帧进行排序的列，以及输出的数据帧中应该出现哪些重复值(如果有)。默认情况下，<code class="fe of og oh mf b">nlargest</code>将只保留第一个副本，其余的将从返回的数据帧中排除。</p><p id="f6ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个方法将返回与<code class="fe of og oh mf b">df.sort_values(columns, ascending=false).head(n)</code>相同的结果。这段代码非常容易理解，也可以工作，但是根据文档显示，<code class="fe of og oh mf b">nlargest</code>方法更具性能。</p><p id="f873" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">获取具有最高“增益”值的 10 行的代码如下:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="c0cd" class="mj mk it mf b gy ml mm l mn mo">df_top = df.nlargest(10, 'Gain')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/f8e5721e08d67affd52c030626b76fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*U-aVxQiP2hkZvL_34_bubg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">按“增益”排名前 N</p></figure><p id="790b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">返回的数据帧现在只给出原始数据帧中具有最高 10 个“增益”值的值。这个新的数据帧也已经按降序排序。</p><h2 id="8c31" class="mj mk it bd ms nv nw dn mw nx ny dp na lr nz oa nc lv ob oc ne lz od oe ng iz bi translated">条件 2:底部开口</h2><p id="71a2" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">接下来，我们将在数据帧上使用<code class="fe of og oh mf b">nsmallest</code>方法来获取具有最低“打开”值的行。这种方法的工作方式与前一种方法完全一样，只是它将按升序对值进行排序和切片。</p><p id="728c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实现这一点的代码如下:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="c855" class="mj mk it mf b gy ml mm l mn mo">df_bottom = df.nsmallest(10, 'Open')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/2f43444ce846f2bf7c034aa0f6cbcfbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*iSqdsIgIjxrKzwOf41TvEQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">底部 N 由“打开”</p></figure><h2 id="55ac" class="mj mk it bd ms nv nw dn mw nx ny dp na lr nz oa nc lv ob oc ne lz od oe ng iz bi translated">创建顶部和底部 N 个值的“组合集”</h2><p id="a4c8" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">我们现在准备组合这两个数据帧来创建一个<strong class="lk jd">组合集</strong>。我从一个内置的 Tableau 函数中借用了这个术语，但它所指的只是基于两个或更多列匹配多个条件的数据子集。在这种情况下，我们寻找只存在于“增益”前 10 名和“开放”后 10 名的数据。</p><p id="a947" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要获得我们的组合集，有两个主要步骤:</p><ol class=""><li id="92d2" class="ok ol it lk b ll lm lo lp lr om lv on lz oo md op oq or os bi translated">连接顶部 N 个和底部 N 个数据帧</li><li id="70ba" class="ok ol it lk b ll ot lo ou lr ov lv ow lz ox md op oq or os bi translated">删除除重复行之外的所有行。</li></ol><p id="7d39" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实现这一点的代码如下:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="53e5" class="mj mk it mf b gy ml mm l mn mo">df_combined = pd.concat([df_top, df_bottom])<br/>df_combined['Duplicate'] = df_combined.duplicated(subset=['Date'])<br/>df_combined = df_combined.loc[df_combined['Duplicate']==True]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/3504282068c1cdb61180ceada1bf91dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*9tYK_XLMPd1rReQ66WPuFQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">组合顶部 N 和底部 N v1</p></figure><p id="1c39" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们简单地调用<code class="fe of og oh mf b">pd.concat</code>并将两个数据帧粘在一起。由于顶部的 N 个和底部的 N 个数据帧来自完全相同的源，我们不需要担心重命名任何列或指定索引。</p><p id="6718" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，为了创建“Duplicate”列，我们使用了<code class="fe of og oh mf b">duplicated</code>方法。该函数返回一个布尔序列，如果一行是重复的，则将该行标记为“真”，否则标记为“假”。您可以在 DataFrame 上调用这个函数，并通过将列名写成一个参数来指定在哪个列中搜索重复项(在本例中为<code class="fe of og oh mf b">subset=['Date']</code>)。为了进行演示，我创建了一个新列“Duplicate”来存储新的布尔值。</p><p id="1bb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我不会深入讨论<code class="fe of og oh mf b">loc[]</code>函数是如何工作的，但是如果你以前没有使用过它，快速浏览一下<a class="ae lh" rel="noopener" target="_blank" href="/you-dont-always-have-to-loop-through-rows-in-pandas-22a970b347ac">这个介绍</a>，这样你就能理解如何使用它以各种方式过滤你的数据帧。我们在这里所做的只是取“重复”列中为真的值，因为这些值出现在两个数据帧中。</p><p id="1226" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们甚至不需要创建一个新的列来标记重复的值。上面代码的一个稍微精简(和等效)的版本如下所示:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="8986" class="mj mk it mf b gy ml mm l mn mo">combined = pd.concat([df_top, df_bottom])<br/>combined = combined.loc[combined.duplicated()==True]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/944034c93828dce7ba1ae1d3d27ed092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*_EF7pk_K1Pmh8PayQC0Kzw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">组合顶部 N 和底部 N v2</p></figure><p id="1b6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">瞧啊。现在，我们可以看到在整个数据集中“开放”程度最低的一天中有高“收益”的行。</p></div><div class="ab cl pa pb hx pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="im in io ip iq"><p id="80ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">仅此而已！</p><p id="dd05" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这种快速查看前 N 名(和后 N 名)的分析对您有所帮助。组合多个条件可以让您以新的方式过滤和处理数据，这有助于您从数据集中提取有价值的信息。</p><p id="3a92" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">祝你的熊猫工作好运！</p></div><div class="ab cl pa pb hx pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="im in io ip iq"><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="5936" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf jd">More Pandas stuff by me:<br/></strong>- <a class="ae lh" rel="noopener" target="_blank" href="/2-easy-ways-to-get-tables-from-a-website-with-pandas-b92fc835e741?source=friends_link&amp;sk=9981ddaf0785a79be893b5a1dd3e03dd">2 Easy Ways to Get Tables From a Website with Pandas</a><br/>- <a class="ae lh" rel="noopener" target="_blank" href="/how-to-quickly-create-and-unpack-lists-with-pandas-d0e78e487c75?source=friends_link&amp;sk=32ea67b35fe90382dc719c1c78c5900c">How to Quickly Create and Unpack Lists with Pandas</a><br/>- <a class="ae lh" rel="noopener" target="_blank" href="/top-4-repositories-on-github-to-learn-pandas-1008cb769f77?source=friends_link&amp;sk=d3acc38062490a86ecb46875342224e6">Top 4 Repositories on GitHub to Learn Pandas</a><br/>- <a class="ae lh" rel="noopener" target="_blank" href="/a-quick-way-to-reformat-columns-in-a-pandas-dataframe-80d0b70de026?source=friends_link&amp;sk=e54f86ec079fb17d5824bac6d1e93919">A Quick Way to Reformat Columns in a Pandas DataFrame</a></span></pre></div></div>    
</body>
</html>