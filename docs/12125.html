<html>
<head>
<title>Input Pipeline for Images using Keras and TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Keras 和 TensorFlow 的图像输入管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/input-pipeline-for-images-using-keras-and-tensorflow-c5e107b6d7b9?source=collection_archive---------16-----------------------#2020-08-21">https://towardsdatascience.com/input-pipeline-for-images-using-keras-and-tensorflow-c5e107b6d7b9?source=collection_archive---------16-----------------------#2020-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fddd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Keras 和 TensorFlow 为深度学习模型的自定义图像数据集创建输入管道的指南</h2></div><p id="4bc4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">其次，在本系列的</em> </strong> <a class="ae lf" rel="noopener" target="_blank" href="/loading-custom-image-dataset-for-deep-learning-models-part-1-d64fa7aaeca6"> <strong class="kk iu"> <em class="le">中，学习如何使用 Kera 预处理、Tensorflow 和 tf.data 从自定义数据</em> </strong> </a> <strong class="kk iu"> <em class="le">创建输入管道来加载和创建图像序列和测试数据集。</em> </strong></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/21e97aa1b37c822ef48c599c6d14a841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFOBLAcGigR3jD9gRU0drQ.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">照片由<a class="ae lf" href="https://unsplash.com/@mbenna?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迈克·本纳</a>在<a class="ae lf" href="https://unsplash.com/s/photos/image-pipeline?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f381" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里使用的数据集是来自 Kaggle 的<a class="ae lf" href="https://www.kaggle.com/puneet6060/intel-image-classification/version/2" rel="noopener ugc nofollow" target="_blank"> Intel 图像分类</a>，文章中的所有代码都在 Tensorflow 2.0 中工作。</p><p id="9da4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">英特尔图像分类数据集分为训练数据集、测试数据集和验证数据集。我们将仅使用训练数据集来学习如何使用不同的库加载数据集。</p><h1 id="1214" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">使用 Keras 预处理创建深度学习的输入管道</h1><p id="d21f" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated"><strong class="kk iu"><em class="le">imagedata generator</em></strong>类为图像数据生成批量张量，并将像素值从 0 到 255 缩小到 0 到 1 之间的值。</p><p id="aed0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以对训练图像数据集应用不同的实时数据增强，如旋转图像、缩放图像、水平翻转或垂直翻转等。<em class="le">数据扩充不适用于验证或测试数据集</em>。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="f67e" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">import pandas as pd<br/>import numpy as np<br/>import os<br/>from tensorflow.keras.preprocessing.image import ImageDataGenerator, img_to_array, load_img, array_to_img<br/>import tensorflow as tf</strong></span><span id="423b" class="my lx it mu b gy nd na l nb nc"><strong class="mu iu">IMG_WIDTH=200<br/>IMG_HEIGHT=200<br/>batch_size=4</strong></span><span id="9db8" class="my lx it mu b gy nd na l nb nc"><strong class="mu iu">train_dir = r'\CV\Intel_Images\seg_train\seg_train'<br/>test_dir  = r'\CV\Intel_Images\seg_pred\seg_pred'<br/>val_dir   = r'\CV\Intel_Images\seg_test\seg_test'</strong></span><span id="fe5e" class="my lx it mu b gy nd na l nb nc"><strong class="mu iu">image_gen_train = ImageDataGenerator(rescale=1./255, <br/>                                     zoom_range=0.2, <br/>                                     rotation_range=65,<br/>                                     shear_range=0.09,<br/>                                     horizontal_flip=True,<br/>                                     vertical_flip=True)</strong></span><span id="6060" class="my lx it mu b gy nd na l nb nc"><strong class="mu iu">image_gen_val = ImageDataGenerator(rescale=1./255)</strong></span></pre><p id="76f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦<strong class="kk iu"><em class="le">imagedata generator</em></strong>的实例被创建，使用<strong class="kk iu"><em class="le">flow _ from _ directory()</em></strong>从目录<strong class="kk iu"> <em class="le">中读取图像文件。</em> </strong></p><p id="0472" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"><em class="le">【flow _ from _ directory()</em></strong>期望图像数据具有如下所示的特定结构，其中每个类具有一个文件夹，并且该类的图像包含在该类文件夹中。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/87c88de7ac41d1615455fa6dacfc0bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*9AwLsVWEA1rTJmd2fE2_Nw.png"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">文件夹结构为<strong class="bd nf"><em class="ng">flow _ from _ directory()imagedata generator</em>方法</strong></p></figure><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="c864" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">train_data_gen = image_gen_train.flow_from_directory(batch_size=batch_size,directory=train_dir,<br/>shuffle=True,                                                     target_size=(IMG_HEIGHT, IMG_WIDTH,3),                                                     class_mode='sparse')</strong></span><span id="bf96" class="my lx it mu b gy nd na l nb nc"><strong class="mu iu">val_data_gen = image_gen_val.flow_from_directory(batch_size=batch_size,<br/>directory=val_dir,                                                 target_size=(IMG_HEIGHT, IMG_WIDTH,3),                                                 class_mode='sparse')</strong></span></pre><p id="09e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"><em class="le">class _ indexes . keys()</em></strong>将从字典中的数据集中提取类名</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="1507" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">train_data_gen.class_indices.keys()</strong></span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nh"><img src="../Images/ea653fe94ab5eaaff3f280775cb9b0c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bPoQJthBp6AlgCC3VwWsqg.png"/></div></div></figure><p id="9bea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">创建一个简单的深度学习模型，编译它，并使用 Keras 预处理生成的数据集训练模型</strong></p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="1699" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">model=tf.keras.Sequential(<br/>        [<br/>            tf.keras.layers.InputLayer(input_shape=(200, 200, 3)),<br/>            tf.keras.layers.Conv2D(filters=32, kernel_size=3, strides=(2, 2), activation='relu'),<br/>            tf.keras.layers.Conv2D(filters=64, kernel_size=3, strides=(2, 2), activation='relu'),<br/>            tf.keras.layers.Flatten(),<br/>            tf.keras.layers.Dense(6)<br/>         ])</strong></span><span id="60ce" class="my lx it mu b gy nd na l nb nc">#Compile the model<br/><strong class="mu iu">model.compile(optimizer='rmsprop', loss='sparse_categorical_crossentropy',<br/>metrics=['accuracy'])</strong></span><span id="20ab" class="my lx it mu b gy nd na l nb nc">#Fitting the model<br/><strong class="mu iu">history = model.fit(train_data_gen,steps_per_epoch=len(train_data_gen)//batch_size, validation_data=val_data_gen, epochs=2)</strong></span></pre><h1 id="20cf" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">使用 TensorFlow 为深度学习创建输入管道</h1><p id="bbb4" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">使用 Tensorflow 的输入管道将创建张量作为模型的输入。</p><ol class=""><li id="f704" class="ni nj it kk b kl km ko kp kr nk kv nl kz nm ld nn no np nq bi translated"><strong class="kk iu">使用<strong class="kk iu">打开图像文件</strong>T3】tensor flow . io . read _ file()T5】</strong></li><li id="2ecc" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><strong class="kk iu">解码文件的格式</strong>。这里我们有一个 JPEG 文件，所以我们用三个颜色通道的<strong class="kk iu"> <em class="le"> decode_jpeg() </em> </strong>。</li><li id="08bc" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><strong class="kk iu">调整图像尺寸</strong>以匹配深度学习模型的输入层的输入尺寸。</li><li id="534e" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><strong class="kk iu">使用 TensorFlow </strong>将图像转换为 float 数据类型，然后<strong class="kk iu">将 0 到 1 之间的值</strong>归一化为 0 到 255。</li><li id="34a6" class="ni nj it kk b kl nr ko ns kr nt kv nu kz nv ld nn no np nq bi translated"><strong class="kk iu"> <em class="le"> tf.stack() </em> </strong>创建一个堆叠的张量作为行数据</li></ol><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="62a0" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">def create_dataset_tf(img_folder):<br/>    class_name=[]<br/>    tf_img_data_array=[]   <br/>    <br/>    for dir1 in os.listdir(img_folder):<br/>        for file in os.listdir(os.path.join(img_folder, dir1)):<br/>            image= os.path.join(img_folder,dir1, file)<br/>            image = tf.io.read_file(image)<br/>            image = tf.io.decode_jpeg(image, channels=3)<br/>            image = tf.image.resize(image, (200,200))<br/>            image = tf.cast(image / 255., tf.float32)<br/>            tf_img_data_array.append(image)<br/>            class_name.append(dir1)                   <br/>    return tf.stack(tf_img_data_array, axis=0),class_name</strong></span><span id="be34" class="my lx it mu b gy nd na l nb nc"><strong class="mu iu"><em class="le">img_folder=r'CV\Intel_Images\seg_train\seg_train'</em></strong></span><span id="2dce" class="my lx it mu b gy nd na l nb nc"><strong class="mu iu"><em class="le">tf_img_data, class_name=create_dataset_tf(img_folder)</em></strong></span></pre><p id="1e89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">将文本标签转换成数字代码</strong></p><p id="120f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为类的所有唯一值创建一个字典</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="6109" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">target_dict={k: v for v, k in enumerate(np.unique(class_name))}<br/>target_dict</strong></span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/d5af704cfeff074b57ec6e258ebfb4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/0*p5FO2Zrl930-KJje.png"/></div></figure><p id="d1a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据字典将 class_names 转换成它们各自的数值</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="371a" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">target_val=  [target_dict[class_name[i]] for i in range(len(class_name))]</strong></span></pre><p id="c845" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">创建一个简单的深度学习模型，编译它，训练模型。</strong></p><p id="cff7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它与我们之前在起诉<strong class="kk iu"> <em class="le"> Keras.preprocessing()时创建的模型相同。</em> </strong>这里唯一的变化是输入图像数据和类名，这是一个张量值的列表来拟合模型。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="1e10" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">model=tf.keras.Sequential(<br/>        [<br/>            tf.keras.layers.InputLayer(input_shape=(200, 200, 3)),<br/>            tf.keras.layers.Conv2D(filters=32, kernel_size=3, strides=(2, 2), activation='relu'),<br/>            tf.keras.layers.Conv2D(filters=64, kernel_size=3, strides=(2, 2), activation='relu'),<br/>            tf.keras.layers.Flatten(),<br/>            tf.keras.layers.Dense(6)<br/>         ])</strong></span><span id="4cc0" class="my lx it mu b gy nd na l nb nc">#Compile the model<br/><strong class="mu iu">model.compile(optimizer='rmsprop', loss='sparse_categorical_crossentropy',<br/>metrics=['accuracy'])</strong></span><span id="59e4" class="my lx it mu b gy nd na l nb nc">#Fitting the model</span><span id="bf84" class="my lx it mu b gy nd na l nb nc"><strong class="mu iu">history = model.fit(x=tf_img_data, y=tf.cast(list(map(int,target_val)),tf.int32), epochs=2)</strong></span></pre><h1 id="ca22" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">使用 tf.data 创建深度学习的输入管道</h1><p id="706f" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated"><strong class="kk iu"> tf.data </strong> API 允许我们构建复杂的输入管道，同时读取不同格式的大量数据，然后应用转换。</p><p id="3289" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 TF . data for image processing pipeline 中，元素是单个训练示例，具有一对张量来表示图像及其对应的标签。</p><p id="4f73" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">导入库和设置基本参数</strong></p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="a3c4" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">import numpy as np<br/>import os<br/>import tensorflow as tf</strong></span><span id="13a2" class="my lx it mu b gy nd na l nb nc"><strong class="mu iu">data_dir=r'\CV\Intel_Images\seg_train\seg_train'<br/>batch_size = 32<br/>img_height = 200<br/>img_width = 200</strong></span></pre><p id="c8f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"><em class="le">TF . data . dataset . list _ files()</em></strong>使用匹配模式从文件的目录列表创建数据集。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="164f" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">list_ds = tf.data.Dataset.list_files(str(data_dir + '\\*\\*'), shuffle=False)</strong></span><span id="f8d2" class="my lx it mu b gy nd na l nb nc"># get the count of image files in the train directory<br/><strong class="mu iu">image_count=0<br/>for dir1 in os.listdir(data_dir):<br/>    for files in os.listdir(os.path.join(data_dir, dir1)):<br/>        image_count+=1</strong></span><span id="58b3" class="my lx it mu b gy nd na l nb nc"><strong class="mu iu">list_ds = list_ds.shuffle(image_count, reshuffle_each_iteration=False)</strong></span></pre><p id="83c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">从目录名创建类别标签</strong></p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="7cdd" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">class_names = np.array(sorted([dir1 for dir1 in os.listdir(data_dir)]))</strong></span></pre><p id="a66b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">将数据集拆分为 train 和 Val。</strong></p><p id="6718" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">验证数据集占总数据集的 20%，训练数据集占整个数据集的 80%。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="be07" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">val_size = int(image_count * 0.2)<br/>train_ds = list_ds.skip(val_size)<br/>val_ds = list_ds.take(val_size)</strong></span></pre><p id="8fa2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为表示一对张量的单个训练/确认示例创建输入管道组件，以表示图像及其对应的标签。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="2df5" class="my lx it mu b gy mz na l nb nc">#To process the label<strong class="mu iu"><br/>def get_label(file_path):<br/> </strong> # convert the path to a list of path components separated by sep<strong class="mu iu"><br/>  parts = tf.strings.split(file_path, os.path.sep)<br/>  <br/> </strong> # The second to last is the class-directory<strong class="mu iu"><br/>  one_hot = parts[-2] == class_names</strong></span><span id="2815" class="my lx it mu b gy nd na l nb nc"># Integer encode the label<strong class="mu iu"><br/>  return tf.argmax(tf.cast(one_hot, tf.int32))</strong></span><span id="b0a7" class="my lx it mu b gy nd na l nb nc"># To process the image<br/><strong class="mu iu">def decode_img(img):<br/>  </strong># convert the compressed string to a 3D uint8 tensor<strong class="mu iu"><br/>  img = tf.image.decode_jpeg(img, channels=3)<br/>  <br/>  </strong># resize the image to the desired size<strong class="mu iu"><br/>  return tf.image.resize(img, [img_height, img_width])</strong></span><span id="9213" class="my lx it mu b gy nd na l nb nc"># To create the single training of validation example with image and its corresponding label<strong class="mu iu"><br/>def process_path(file_path):<br/>  label = get_label(file_path)</strong></span><span id="c5cb" class="my lx it mu b gy nd na l nb nc"># load the raw data from the file as a string<strong class="mu iu"><br/>  img = tf.io.read_file(file_path)<br/>  img = decode_img(img)<br/>  return img, label</strong></span></pre><p id="77de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设置自动调谐；这将有助于在运行时将并行性级别的决策委托给<strong class="kk iu"> <em class="le"> tf.data </em> </strong>，以优化 CPU/GPU 利用率。</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="ee0f" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">AUTOTUNE = tf.data.experimental.AUTOTUNE</strong><br/># Set `num_parallel_calls` so multiple images are loaded/processed in parallel.<br/><strong class="mu iu">train_ds = train_ds.map(process_path, num_parallel_calls=AUTOTUNE)<br/>val_ds = val_ds.map(process_path, num_parallel_calls=AUTOTUNE)</strong></span></pre><p id="85b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">为性能配置数据源</strong></p><p id="6cb9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了配置数据源的性能，使用<strong class="kk iu">预取</strong>。</p><p id="f1a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">TF . data 中的预取允许数据的预处理和训练步骤的模型执行重叠</strong>。</p><p id="ceb8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当模型正在执行训练步骤 100 时，输入管道正在读取步骤 101 的数据。T3】</p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="23f3" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">def configure_for_performance(ds):<br/>  ds = ds.cache()<br/>  ds = ds.shuffle(buffer_size=1000)<br/>  ds = ds.batch(batch_size)<br/>  ds = ds.prefetch(buffer_size=AUTOTUNE)<br/>  return ds</strong></span><span id="0b57" class="my lx it mu b gy nd na l nb nc"><strong class="mu iu">train_ds = configure_for_performance(train_ds)<br/>val_ds = configure_for_performance(val_ds)</strong></span></pre><p id="997b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">创建一个简单的深度学习模型</strong></p><p id="b98b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模型的输入是<strong class="kk iu"> <em class="le"> tf.data.Dataset </em> </strong></p><pre class="lh li lj lk gt mt mu mv mw aw mx bi"><span id="bd53" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">model=tf.keras.Sequential(<br/>        [<br/>            tf.keras.layers.InputLayer(input_shape=(200, 200, 3)),<br/>            tf.keras.layers.Conv2D(filters=32, kernel_size=3, strides=(2, 2), activation='relu'),<br/>            tf.keras.layers.Conv2D(filters=64, kernel_size=3, strides=(2, 2), activation='relu'),<br/>            tf.keras.layers.Flatten(),<br/>            tf.keras.layers.Dense(6)<br/>         ])</strong></span><span id="8a29" class="my lx it mu b gy nd na l nb nc">#Compile the model<br/><strong class="mu iu">model.compile(optimizer='rmsprop', loss='sparse_categorical_crossentropy',<br/>metrics=['accuracy'])</strong></span><span id="76b8" class="my lx it mu b gy nd na l nb nc">#Fitting the model<br/><strong class="mu iu">history = model.fit(train_ds,validation_data=val_ds,epochs=3)</strong></span></pre><h2 id="c52a" class="my lx it bd ly nx ny dn mc nz oa dp mg kr ob oc mi kv od oe mk kz of og mm oh bi translated">结论:</h2><p id="7965" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我得到的最好的训练时间是使用 tf.data，因为有预取，这是使用 AUTOTUNE 在并行级别上委托决策。</p><h2 id="412c" class="my lx it bd ly nx ny dn mc nz oa dp mg kr ob oc mi kv od oe mk kz of og mm oh bi translated">参考资料:</h2><div class="oi oj gp gr ok ol"><a href="https://keras.io/api/preprocessing/image/" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">Keras 文档:图像数据预处理</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">从目录中的图像文件生成 tf.data.Dataset。如果您的目录结构是:然后调用…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">keras.io</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz lq ol"/></div></div></a></div><p id="6bb1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae lf" href="https://www.tensorflow.org/tutorials/load_data/images#using_tfdata_for_finer_control" rel="noopener ugc nofollow" target="_blank">https://www . tensor flow . org/tutorials/load _ data/images # using _ TF data _ for _ finer _ control</a></p></div></div>    
</body>
</html>