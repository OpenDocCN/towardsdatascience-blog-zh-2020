<html>
<head>
<title>Density-based algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于密度的算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/density-based-algorithms-49237773c73b?source=collection_archive---------15-----------------------#2020-04-05">https://towardsdatascience.com/density-based-algorithms-49237773c73b?source=collection_archive---------15-----------------------#2020-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dea0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对两种基于密度的算法的理解:DBSCAN和OPTICS</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2f04f13ec3ff53207b8d4cb05f8f5f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5EbbSHNpl5v8nocFbSQ1g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.flickr.com/photos/jazbinsek/48210846062/in/photolist-2gsebTQ-Z1AeZb-achwEC-9DbiXJ-2dmPUKa-2hRg3M5-2isjxgr-23E1tgg-2inhm8f-Ud2Fm1-4f7rvy-YpqBcQ-achwHy-aceG9p-achwFw-7PtMsu-R96duY-52TjtK-AFBsDQ-ijcvEj-9D8ppg-jcxVE-bPh5X-f3wQDt-zhgrdk-HqMjmf-8y7Eu3-dYpukQ-dLbsc-r2VXcd-6DrCMN-DwBJZm-2h1D9Nc-2caRE4J-251idpH-n9nFXx-37XZkJ-37TRNV-35c6Xc-35kQjp-TWTT9Q-2iG8Mbi-YSgTwo-VT89xZ-6jH7VX-JYjFs-6jMiL9-aFwCRn-YSgTvm-YSgTxL" rel="noopener ugc nofollow" target="_blank">图片来源:Fabrice Jazbinsek </a></p></figure><p id="b798" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像划分方法或层次聚类这样的聚类方法在寻找任意形状的聚类时是无效的。基于密度的聚类方法在发现任意形状的聚类方面是有效的，并且防止了离群值和噪声。</p><p id="95cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用基于密度的方法时，对象聚类简单地基于密度的概念。并且根据密度，使用该方法创建不同类型的算法，例如，如果通过使用邻域对象的密度创建聚类，则使用DBSAN算法，或者如果根据密度函数创建聚类，则使用DENCLUE。而光学是基于密度的，这产生了数据收集结构的增强顺序。</p><h1 id="6f77" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基于密度的噪声应用空间聚类</h1><p id="71ca" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">DBSCAN通过计算固定半径邻域或<strong class="lb iu"> ɛ </strong>中的点的数量来估计密度，并认为只有当两个点位于彼此的邻域内时它们才是连通的。因此，该算法使用两个参数，如ɛ和MinPts。ɛ表示一个点的Eps邻域，MinPts表示Eps邻域中的最小点。所以ɛ和MinPts是由用户指定的参数</p><p id="5a8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个要点需要记住:</p><p id="4dde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ms">核心点:</em> </strong>作为核心点的是Eps邻域中的某个特定点，该点的值大于MinPts的精确点数。</p><p id="cd20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"/></p><p id="7b70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">噪声点:</strong>不属于核心或边界的点称为噪声点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/b6c67a3806e7df8a816fad8ce02295cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9CAzryuxjxS3VjJp1r_YQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">密度点</p></figure><h2 id="0b78" class="mu lw it bd lx mv mw dn mb mx my dp mf li mz na mh lm nb nc mj lq nd ne ml nf bi translated">算法</h2><p id="a21b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">输入:n个待聚类对象和全局参数<strong class="lb iu"> ɛ </strong>和<strong class="lb iu"> MinPts </strong>。<br/>输出:物体的集群</p><p id="0581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.任意选择一个点P. <br/> 2。检索从P wrt ɛ和MinPts可到达的所有点密度。<br/> 3。如果P是一个核心点，则形成一个簇。<br/> 4。如果P是边界点，那么不存在密度可达的点，DBSCAN移动到下一个点。<br/> 5。这个过程一直持续到所有的点都被处理完。</p><p id="0c52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，使用DBSAN有一些优点和缺点，例如:</p><p id="4fa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">优点<br/> </strong> - DBSCAN可以使用MinPts参数找到任意形状的聚类<br/> -数据库中的点的顺序不敏感<br/> -处理噪声和异常值<br/> <strong class="lb iu">缺点</strong> <br/> -在密度差异较大的情况下不能很好地执行<br/> -不适合涉及各种密度的情况</p><h2 id="d4db" class="mu lw it bd lx mv mw dn mb mx my dp mf li mz na mh lm nb nc mj lq nd ne ml nf bi translated">光学</h2><p id="3b61" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">光学系统的工作原理类似于DBSCAN的扩展。唯一的区别是它不分配聚类成员，而是存储处理点的顺序。所以对于每个对象商店:<em class="ms">核心距离</em>和可达性距离。订单种子被称为构成输出订单的记录。</p><p id="c466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ms">核心距离:</em></strong>p的ɛ-neighborhood中出现的ɛ的最小值就是核心距离。当然，它需要保存最少的MinPts对象。</p><p id="b8b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ms">可达距离:</em></strong>p与q之间的可达距离定义为从q到p密度的最小半径值。</p><h2 id="5660" class="mu lw it bd lx mv mw dn mb mx my dp mf li mz na mh lm nb nc mj lq nd ne ml nf bi translated">算法</h2><p id="e476" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">1.随机选择一个未访问的点P <br/> 2。选择从P . w . r . t . Eps，MinPts可达的所有点的密度。<br/> 3。分配核心距离&amp;可达性距离=空值<br/> 4。如果P不是核心点<br/> 5。移动订单种子列表中的下一点<br/> 6。如果P是核心点<br/> 7。对于每个物体q，在P <br/> 8的ɛ邻域中。从P <br/> 9更新可达性距离。如果q未被访问，将q插入订单种子<br/> 10。直到没有不被访问的对象</p><p id="d18d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">注:</em>以上算法摘自《基于密度的大数据聚类算法综述》。</p><p id="f3fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">优点<br/> - </strong>它不需要密度参数。<br/> <strong class="lb iu"> - </strong>聚类顺序对于提取基本的聚类信息很有用。<br/> <strong class="lb iu">缺点</strong><br/><strong class="lb iu">——</strong>它只产生一个集群排序。<br/> <strong class="lb iu"> - </strong>它不能处理高维数据。</p><p id="6cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ms">注:</em> </strong>认为只存在上面解释的这两种基于密度的算法是不好的。还有其他这类算法在这里没有提到，例如DENCLUE，但最流行的是DBSCAN，因为它被认为是最简单的基于密度的方法。</p><h1 id="2b13" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="29cf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">本文旨在简要解释基于密度的方法。因此，总而言之，基于密度的方法满足这些要求:<br/>——产生实际上只发生在空间数据上的非球形聚类。术语空间数据用于表示点、线和多边形。在空间数据簇中形成的簇可以具有任意形状。<br/>-大型数据库对后续全效率的需求。<br/>-检测和减少噪音和离群值的能力。</p><p id="955e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">光学和DBSCAN不是实现基于密度的方法的唯一算法。尽管我提到了它们，但这并不意味着只需要使用这些算法。然而，这些算法是最受欢迎的，每种基于密度的算法都有其优点和缺点，因此在使用它之前，您需要查看数据集，首先了解数据集，看看该类型的算法是否符合您的需求。</p><h2 id="6f6e" class="mu lw it bd lx mv mw dn mb mx my dp mf li mz na mh lm nb nc mj lq nd ne ml nf bi translated">参考</h2><p id="7252" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">T.米兰达·拉克什米、约瑟芬·萨哈纳、普拉桑娜·文卡特桑。基于密度的大数据聚类算法综述</p><p id="40ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据聚类:算法和应用(查普曼和霍尔/CRC数据挖掘和知识发现系列，第113-117页</p></div></div>    
</body>
</html>