<html>
<head>
<title>Make Your Python Code Fluent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你的 Python 代码流畅</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/make-your-python-code-fluent-7ee2dd7c9ae3?source=collection_archive---------32-----------------------#2020-07-23">https://towardsdatascience.com/make-your-python-code-fluent-7ee2dd7c9ae3?source=collection_archive---------32-----------------------#2020-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c8d5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">函数和运算符重载</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4972d94be57c463c7d2ed9b40faebd6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OWzz9mS6O7mxUxJs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">诺兰·马尔克蒂在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3e05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">Python 中的重载</strong>允许我们定义函数和操作符，它们根据所使用的参数或操作数以不同的方式运行。</p><h1 id="13f4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">运算符重载</h1><p id="fb7d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">作为一个例子，我们可以使用<strong class="lb iu"> "+"操作符</strong>对<strong class="lb iu">数值</strong>进行算术计算，而当使用<strong class="lb iu">字符串</strong>操作数时，同一个<strong class="lb iu"> "+"操作符</strong>连接两个字符串。这被称为<strong class="lb iu">操作符重载</strong>，它允许我们在不同的对象类型上使用相同的操作符来执行类似的任务。</p><p id="1ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如下所示，我们可以重载<strong class="lb iu"> "+"操作符</strong>来使用我们定制的对象类型。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2b3b" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu"># No overloading, task is performed by 'add' method</strong><br/>cost1 = Cost(10)<br/>cost2 = Cost(24)<br/>cost_total = cost1.add(cost2)</span><span id="f9c5" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu"># '+' operator is overloaded to work with 'Cost' type of objects</strong><br/>cost1 = Cost(10)<br/>cost2 = Cost(24)<br/>cost_total = cost1 + cost2</span></pre><p id="674b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与第一个代码块相比，上面的第二个代码块更容易阅读和理解。这就是重载如何使我们的代码流畅和干净。</p><h1 id="e3e5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">函数重载</h1><p id="603f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">虽然 Python 默认情况下不支持函数重载，但是有一些技巧可以实现它。</p><p id="96c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想创建一个函数来计算三角形的面积。用户可以提供；</p><ul class=""><li id="60f0" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">三角形的底和高，</li><li id="2a2b" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">三角形三条边的长度</li></ul><p id="ea57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不考虑重载，我们需要定义两个不同的函数来处理这个任务。</p><p id="f3b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以只编写一个函数并重载它来增加代码的一致性和可读性，而不是为同一个任务定义不同的函数。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="44f3" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">#---------------------<br/># No overloading, task is performed by two similar functions<br/>#---------------------<br/></strong>def <strong class="mt iu">triangle_area_base_height(base, height)</strong>:<br/> ....<br/>def <strong class="mt iu">triangle_area_three_sides(a_side, b_side, c_side):</strong><br/> ....</span><span id="98e8" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">area1 = triangle_area_base_height (10,14)<br/>area2 = triangle_area_three_sides (10, 12,8)</strong></span><span id="d5cb" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">#---------------------<br/># Function overloading<br/>#---------------------<br/></strong><strong class="mt iu">from</strong> <!-- -->multipledispatch <strong class="mt iu">import</strong> <!-- -->dispatch</span><span id="209f" class="mx lw it mt b gy nc mz l na nb">@dispatch(int,int)<br/>def<!-- --> <strong class="mt iu">triangle_area</strong><strong class="mt iu">(base, heigth):</strong><br/> .....</span><span id="29b4" class="mx lw it mt b gy nc mz l na nb">@dispatch(int,int,int)<br/>def<!-- --> <strong class="mt iu">triangle_area</strong><strong class="mt iu">(</strong><strong class="mt iu">a_side, b_side, c_side</strong><strong class="mt iu">):</strong><br/> .....</span><span id="78b9" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">area1 = triangle_area (10,14)<br/>area2 = triangle_area (10,12,8)</strong></span></pre><h1 id="9f8e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">重载运算符</h1><p id="8a36" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我们使用一个操作符时，会调用一个与该操作符相关的特殊函数。举个例子，当我们使用<strong class="lb iu"> +操作符</strong>时，会调用<strong class="lb iu"> __add__ </strong>的特殊方法。要重载+ operator，我们需要在一个类结构中扩展<strong class="lb iu"> __add__ </strong>方法的功能。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="90b4" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu"># Addition of 2D point coordinates with<br/># + operator overloading</strong></span><span id="88c3" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">class</strong> P<!-- -->oint2D:<br/> <strong class="mt iu">def</strong> <!-- -->__init__(self, x, y):<br/>  self.x <strong class="mt iu">=</strong> <!-- -->x<br/>  self.y <strong class="mt iu">=</strong> <!-- -->y</span><span id="b752" class="mx lw it mt b gy nc mz l na nb"># adding two points<br/> <strong class="mt iu">def</strong><strong class="mt iu"> </strong><strong class="mt iu">__add__(self, other):</strong><br/>  <strong class="mt iu">return</strong> <!-- -->self.x <strong class="mt iu">+</strong> <!-- -->other.x, self.y <strong class="mt iu">+</strong> <!-- -->other.y</span><span id="f2e0" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">def</strong> <!-- -->__str__(self):<br/>  <strong class="mt iu">return</strong> <!-- -->self.x, self.y</span><span id="848e" class="mx lw it mt b gy nc mz l na nb">point1 <strong class="mt iu">=</strong> P<!-- -->oint2D(5, 4)<br/>point2 <strong class="mt iu">=</strong> P<!-- -->oint2D(6, 1)<br/>point3 <strong class="mt iu">=</strong> <!-- -->point1 <strong class="mt iu">+</strong> <!-- -->point2</span><span id="df91" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">print</strong>(point3)</span><span id="337d" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>(11, 5)</span></pre><p id="531e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以重载<strong class="lb iu"> + operator </strong>来拥有更加流畅和易读的代码，而不是定义一个额外的函数来添加<strong class="lb iu"> Point2d objects </strong>。</p><p id="a661" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过修改类结构中相关的特殊方法，可以重载所有操作符，包括赋值、比较和二元操作符。</p><h1 id="ac5f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">重载内置函数</h1><p id="57fc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们还可以重载内置的 Python 函数来修改它们的默认动作。考虑<strong class="lb iu"> len() </strong>内置函数，它返回序列或集合中对象的数量。为了将它与我们定制的对象类型一起使用，我们需要实现重载。</p><p id="0756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了重载<strong class="lb iu"> len() </strong>，我们需要在一个类结构中扩展<strong class="lb iu"> __len__ </strong>方法的功能。</p><p id="713c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面让我们看看如何用 Python 来实现:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ac68" class="mx lw it mt b gy my mz l na nb">class <strong class="mt iu">Names</strong>:</span><span id="92f4" class="mx lw it mt b gy nc mz l na nb">def <strong class="mt iu">__init__</strong>(self, name, country):<br/>  self.name = list(name)<br/>  self.country = country</span><span id="639b" class="mx lw it mt b gy nc mz l na nb">def <strong class="mt iu">__len__</strong>(self):<br/>  return len(self.name)</span><span id="bf1f" class="mx lw it mt b gy nc mz l na nb">obj1 = Names(['Amy', 'Harper', 'James'], 'UK')<br/>print(len(obj1))</span><span id="fd35" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>3</span></pre><p id="c891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，您可以重载所有内置函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/8b1b3ed00427dbabf2da9899af7b9ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CcvkWo3SEDLh5Snp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@chundy_tanz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">春迪·坦茨</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="4d2a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">重载用户定义的函数</h1><p id="2fbd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python 默认不支持函数重载。但是我们可以使用多个分派库来处理重载。</p><p id="dc70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导入<strong class="lb iu"> multipledispatch，</strong>我们需要做的就是用<strong class="lb iu"> @dispatch() </strong> decorator 来修饰我们的函数。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9bb8" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">import math<br/>from multipledispatch import dispatch</strong></span><span id="8b5d" class="mx lw it mt b gy nc mz l na nb">@dispatch(int,int)<br/>def <strong class="mt iu">triangle_area(base, height)</strong>:<br/> return (base*height)/2</span><span id="2095" class="mx lw it mt b gy nc mz l na nb">@dispatch(int,int,int)<br/>def <strong class="mt iu">triangle_area(a_side, b_side, c_side)</strong>:<br/> s = (a_side + b_side + c_side) / 2<br/> return math.sqrt(s * (s-a_side) * (s-b_side) * (s-c_side))</span><span id="6f4e" class="mx lw it mt b gy nc mz l na nb">area1 = triangle_area (10,14)<br/>area2 = triangle_area (5,5,5)</span><span id="b125" class="mx lw it mt b gy nc mz l na nb">print("Area1: {}".format(area1))<br/>print("Area2: {}".format(area2))</span><span id="c238" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:</strong><br/>Area1: 70.0 <br/>Area2: 10.825317547305483</span></pre><h1 id="fbf9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关键要点</h1><ul class=""><li id="f9a5" class="nd ne it lb b lc mn lf mo li ns lm nt lq nu lu ni nj nk nl bi translated"><strong class="lb iu">Python 中的重载</strong>允许我们根据所使用的参数或操作数来定义行为不同的函数和操作符。</li><li id="a665" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">操作符重载</strong>允许我们在不同的对象类型上使用相同的操作符来执行相似的任务。</li><li id="ddba" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">我们可以只编写一个函数并重载它来增加代码的一致性和可读性，而不是为同一个任务定义不同的函数。</li></ul><h1 id="5036" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="04ee" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这篇文章中，我解释了 Python 中重载的基础知识。</p><p id="0596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章中的代码可以在<a class="ae ky" href="https://github.com/eisbilen/Overloading" rel="noopener ugc nofollow" target="_blank">我的 GitHub 库中找到。</a></p><p id="c312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用。</p><p id="895a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>