<html>
<head>
<title>Hangar Tutorial (2/2): Training a Model with Versioned data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机库教程(2/2):使用版本化数据训练模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hangar-tutorial-2-2-training-a-model-with-the-versioned-data-78460404c55?source=collection_archive---------51-----------------------#2020-09-09">https://towardsdatascience.com/hangar-tutorial-2-2-training-a-model-with-the-versioned-data-78460404c55?source=collection_archive---------51-----------------------#2020-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b7b0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何从机库获取数据并训练 PyTorch 模型？</h2></div><p id="e284" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上一篇教程中，我们介绍了<a class="ae lb" href="https://hangar-py.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">hanger</a>，这是一个 python 库，可以帮助你对数据进行版本控制。数据是新的石油，正确管理和传输数据流对您的公司至关重要。Hangar 是您工具箱中的一个很好的工具，它带来了从软件开发到 ML 工程的版本控制等最佳实践，从而帮助您为客户提供强大的 ML 服务。如果你还没看过<a class="ae lb" rel="noopener" target="_blank" href="/hangar-tutorial-1-2-adding-your-data-to-hangar-d7f039265455">之前的博客</a>，那就去看看吧。我讨论了机库的核心概念，以及如何在那里创建自己的机库回购。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lh li l"/></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">ML 工作流程变得越来越复杂，我认为 Hangar 是你工具箱中非常重要的工具(via <a class="ae lb" href="https://giphy.com/gifs/HUplkVCPY7jTW" rel="noopener ugc nofollow" target="_blank"> <em class="ln"> Giphy </em> </a>)</p></figure><p id="d101" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="lo">注:</em> </strong> <em class="lo">随附的 GitHub repo 中有一些详细的笔记本，解释了所有讨论的概念。您可以在本教程中尝试一下。【</em> <a class="ae lb" href="https://github.com/jjmachan/hangar_tutorials" rel="noopener ugc nofollow" target="_blank"> <em class="lo">链接</em></a><em class="lo">】</em></p><h1 id="efd6" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">我们说到哪了..？</h1><p id="74bf" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">因此，我们已经学习了机库的核心概念，我们将玩具数据集(MNIST)添加到了机库中。今天，我们将从我们停止的地方继续，并根据我们添加到 Hangar 的数据训练一个模型。首先我们来连线机库回购。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mm li l"/></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">将所有制表符转换为空格 vim</p></figure><p id="b09a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们快速浏览一下摘要，了解一下我们回购中的数据。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mm li l"/></div></figure><pre class="lc ld le lf gt mn mo mp mq aw mr bi"><span id="184d" class="ms lq iq mo b gy mt mu l mv mw">Summary of Contents Contained in Data Repository <br/> <br/>================== <br/>| Repository Info <br/>|----------------- <br/>|  Base Directory: /home/jjmachan/jjmachan/hangar_tutorial <br/>|  Disk Usage: 105.88 MB <br/> <br/>=================== <br/>| Commit Details <br/>------------------- <br/>|  Commit: a=39a36c4fa931e82172f03edd8ccae56bf086129b <br/>|  Created: Fri May  1 18:23:19 2020 <br/>|  By: jjmachan <br/>|  Email: jjmachan@g.com <br/>|  Message: added all the mnist datasets <br/> <br/>================== <br/>| DataSets <br/>|----------------- <br/>|  Number of Named Columns: 6 <br/>|<br/>|  * Column Name: ColumnSchemaKey(column="mnist_test_images", layout="flat") <br/>|    Num Data Pieces: 10000 <br/>|    Details: <br/>|    - column_layout: flat <br/>|    - column_type: ndarray <br/>|    - schema_hasher_tcode: 1 <br/>|    - data_hasher_tcode: 0 <br/>|    - schema_type: fixed_shape <br/>|    - shape: (784,) <br/>|    - dtype: float32 <br/>|    - backend: 00 <br/>|    - backend_options: {'complib': 'blosc:lz4hc', 'complevel': 5, 'shuffle': 'byte'} <br/>|<br/>|  * Column Name: ColumnSchemaKey(column="mnist_test_labels", layout="flat") <br/>|    Num Data Pieces: 10000 <br/>|    Details: <br/>|    - column_layout: flat <br/>|    - column_type: ndarray <br/>|    - schema_hasher_tcode: 1 <br/>|    - data_hasher_tcode: 0 <br/>|    - schema_type: fixed_shape <br/>|    - shape: (1,) <br/>|    - dtype: int64 <br/>|    - backend: 10 <br/>|    - backend_options: {} <br/>|<br/>|  * Column Name: ColumnSchemaKey(column="mnist_training_images", layout="flat") <br/>|    Num Data Pieces: 50000 <br/>|    Details: <br/>|    - column_layout: flat <br/>|    - column_type: ndarray <br/>|    - schema_hasher_tcode: 1 <br/>|    - data_hasher_tcode: 0 <br/>|    - schema_type: fixed_shape <br/>|    - shape: (784,) <br/>|    - dtype: float32 <br/>|    - backend: 00 <br/>|    - backend_options: {'complib': 'blosc:lz4hc', 'complevel': 5, 'shuffle': 'byte'} <br/>|<br/>|  * Column Name: ColumnSchemaKey(column="mnist_training_labels", layout="flat") <br/>|    Num Data Pieces: 50000 <br/>|    Details: <br/>|    - column_layout: flat <br/>|    - column_type: ndarray <br/>|    - schema_hasher_tcode: 1 <br/>|    - data_hasher_tcode: 0 <br/>|    - schema_type: fixed_shape <br/>|    - shape: (1,) <br/>|    - dtype: int64 <br/>|    - backend: 10 <br/>|    - backend_options: {} <br/>|<br/>|  * Column Name: ColumnSchemaKey(column="mnist_validation_images", layout="flat") <br/>|    Num Data Pieces: 10000 <br/>|    Details: <br/>|    - column_layout: flat <br/>|    - column_type: ndarray <br/>|    - schema_hasher_tcode: 1 <br/>|    - data_hasher_tcode: 0 <br/>|    - schema_type: fixed_shape <br/>|    - shape: (784,) <br/>|    - dtype: float32 <br/>|    - backend: 00 <br/>|    - backend_options: {'complib': 'blosc:lz4hc', 'complevel': 5, 'shuffle': 'byte'} <br/>|<br/>|  * Column Name: ColumnSchemaKey(column="mnist_validation_labels", layout="flat") <br/>|    Num Data Pieces: 10000 <br/>|    Details: <br/>|    - column_layout: flat <br/>|    - column_type: ndarray <br/>|    - schema_hasher_tcode: 1 <br/>|    - data_hasher_tcode: 0 <br/>|    - schema_type: fixed_shape <br/>|    - shape: (1,) <br/>|    - dtype: int64 <br/>|    - backend: 10 <br/>|    - backend_options: {}</span></pre><p id="f496" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，数据存储在 6 个 ndarray 列中。2 列各存储 3 个数据分割、训练、测试和验证的图像和目标对。现在让我们从主分支创建一个只读签出来访问列。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mm li l"/></div></figure><pre class="lc ld le lf gt mn mo mp mq aw mr bi"><span id="4884" class="ms lq iq mo b gy mt mu l mv mw">* Checking out BRANCH: master with current HEAD: a=39a36c4fa931e82172f03edd8ccae56bf086129b</span></pre><h1 id="88ff" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">数据加载器</h1><p id="dbe4" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">现在，让我们从 Hangar 加载数据，将其输入我们的神经网络进行训练。尽管您可以使用 checkout 直接访问数据，但推荐的方法是使用 make_torch_dataset。它提供了更多可配置的选项，并使其更有效、更容易地加载到 PyTorch 中。</p><p id="2cdc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"><em class="lo">make _ torch _ dataset</em>(列</strong>，<em class="lo">key:Sequence[str]= None</em>，<em class="lo"> index_range: slice = None </em>，<em class="lo">field _ names:Sequence[str]= None</em><strong class="kh ir">)</strong></p><p id="7466" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lo"> make_torch_dataset </em>创建一个 PyTorch 数据集，将列传递给它。在我们的示例中，如果我们要传递“mnist_training_images”列和“mnist_training_labels”列。现在，make_torch_dataset 将为每个索引返回一个元组，其中包含与该索引对应的图像和标签。</p><p id="6a0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为它返回一个 PyTorch 数据集，所以我们可以将它传递给 PyTorch 数据加载器来执行混洗、批处理等操作。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mm li l"/></div></figure><p id="6462" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，遍历 trainDataloader 将为我们提供成批的数据，并作为张量准备用于训练。</p><h1 id="0b2a" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">培养</h1><p id="67cb" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">我们不会深入模型是如何定义和训练的细节。如果你觉得下面的代码很难跟上，我强烈建议你看看<a class="ae lb" href="https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html" rel="noopener ugc nofollow" target="_blank"> Pytorch 教程</a></p><p id="f6f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将为 MNIST 定义一个简单的 3 层全连接神经网络。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mm li l"/></div></figure><p id="f408" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，使用 dataloader，我们通过批处理进行迭代，进行正向传播，计算损耗，通过反向传播找到梯度，并调整模型参数，这就是您所熟悉的标准神经网络训练。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mm li l"/></div></figure><pre class="lc ld le lf gt mn mo mp mq aw mr bi"><span id="14db" class="ms lq iq mo b gy mt mu l mv mw">[EPOCH 0/10] Train Loss: 1.2083537247954312<br/>Test Loss: 0.47797256113050846 Accuracy: 0.865814696485623<br/>[EPOCH 1/10] Train Loss: 0.3944594695549208<br/>Test Loss: 0.3467818654228609 Accuracy: 0.897064696485623<br/>[EPOCH 2/10] Train Loss: 0.31767420198765994<br/>Test Loss: 0.2960374093682954 Accuracy: 0.9107428115015974<br/>[EPOCH 3/10] Train Loss: 0.27709063706813486<br/>Test Loss: 0.2613061714274719 Accuracy: 0.9223242811501597<br/>[EPOCH 4/10] Train Loss: 0.24662601495887404<br/>Test Loss: 0.234231408689909 Accuracy: 0.9306110223642172<br/>[EPOCH 5/10] Train Loss: 0.22161395768786918<br/>Test Loss: 0.21181030162928488 Accuracy: 0.9365015974440895<br/>[EPOCH 6/10] Train Loss: 0.20021527176466666<br/>Test Loss: 0.19286749035137862 Accuracy: 0.9421924920127795<br/>[EPOCH 7/10] Train Loss: 0.18172580767267993<br/>Test Loss: 0.1767021114335428 Accuracy: 0.946685303514377<br/>[EPOCH 8/10] Train Loss: 0.16573666792806246<br/>Test Loss: 0.16299303889887545 Accuracy: 0.9507787539936102<br/>[EPOCH 9/10] Train Loss: 0.1518441192202165<br/>Test Loss: 0.15127997121999795 Accuracy: 0.954073482428115</span></pre><p id="0591" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">瞧！</p><p id="7df8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经成功地使用来自机库的数据训练了我们的模型。</p><h1 id="ec64" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">结论</h1><p id="4493" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">到目前为止，您应该已经学习了 Hangar 的基础知识，如何根据您的数据集定义列，向这些列添加数据，并从中加载数据以在 PyTorch 中训练模型。hangle 还有其他一些很酷的功能，比如<a class="ae lb" href="https://hangar-py.readthedocs.io/en/stable/Tutorial-003.html" rel="noopener ugc nofollow" target="_blank">远程仓库</a>、<a class="ae lb" href="https://hangar-py.readthedocs.io/en/stable/Tutorial-003.html#Partial-Fetching-and-Clones" rel="noopener ugc nofollow" target="_blank">从这些远程仓库部分下载</a>数据、<a class="ae lb" href="https://hangar-py.readthedocs.io/en/stable/externals.html" rel="noopener ugc nofollow" target="_blank">hangle 外部</a>是 hangle 的一个高级接口，当你将 hangle 与现有数据流集成时可以使用。我已经链接了相关的文档，并且我建议你去看看这些文档，了解一下 Hangar 提供的所有功能。</p><p id="932a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着越来越多的公司正在寻找新的方法将机器学习的力量融入他们的产品，我们将一些最佳实践融入其中以避免积累技术债务是很重要的。这仍然是一个不断发展的领域，每个人都仍然在弄清楚这些“最佳实践”是什么，以及哪些工作流可能最适合他们。对您的数据进行版本控制就是这样一种实践，可以添加它来确保可再现性、协作和更好的管理。像 Hangar 和 DVC 这样的工具是最好的选择，尽管还有很多工作要做。Hangar 非常容易添加到你现有的 ML 工作流程中，希望这篇教程能让你更好的理解它。</p><p id="d6cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯</p><h1 id="ae8d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated"><em class="ln">辅助</em></h1><p id="178a" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">这是一个比较两方面机库的辅助部分</p><ol class=""><li id="7ff0" class="mx my iq kh b ki kj kl km ko mz ks na kw nb la nc nd ne nf bi translated">存储在机库之前和之后数据集的大小</li><li id="e501" class="mx my iq kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated">使用 Hangar 和一个简单数据加载器的数据加载器的速度，该数据加载器采用我们定义的 mnist_dataset。</li></ol><p id="d5fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，这些是我个人的实验和基准，所以你可以自己尝试一下，看看我下面讨论的结果是否相同。如果现在你能把它分享给每个人，我会很高兴的！该代码可在<a class="ae lb" href="https://github.com/jjmachan/hangar_tutorials" rel="noopener ugc nofollow" target="_blank"> GitHub repo 上获得。</a></p><p id="c0b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们谈谈数据集的大小。现在，内部机库在将数据保存到磁盘时，在处理数据方面做得非常好。在我们的例子中，原来的 MNIST 文件是 210 兆，但在机库它只占 105 兆。但我说的是未压缩版的 MNIST。压缩版只有 17Mb，这是一个很大的容量。这是我见过的 Hangar 最大的问题之一。它在压缩数字数据方面做得很好，但最有可能的是，有其他格式的数据可能会提供显著的大小缩减。这在把 jpeg 文件保存在机库时变得非常明显，它们占据了大量的空间。</p><p id="90d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在有办法通过手动调整库选择保存数据的后端来提高效率。但是这是以更高的读取时间为代价的。据开发商称，这是出于好意。存储很便宜，但时间不便宜。</p><p id="ad68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二是从磁盘加载用于训练。差不多要多花 7 倍的时间，很多！同样在这个例子中，我在将数据加载到内存之前执行解压缩，仍然只需要大约 1 秒。</p><p id="7b42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我系统的输出。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/ece8f6bc49b8f6fecbdb1dae159d067e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*IXl0EFD-XGI1IrTDl1T4gQ.png"/></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">显示结果的屏幕截图</p></figure><p id="de0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这又回到了后端选择。所有这些结果都是默认设置，但可以调整。所以问题是我们如何调整这些。一份官方指南正在制作中。当它出来的时候，我会更多的评论后端选择。</p><p id="e714" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同时，你检查一下，告诉我你的结果。很想听听！</p></div></div>    
</body>
</html>