<html>
<head>
<title>Design Pattern for Machine Learning training work flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习培训工作流程的设计模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/design-pattern-for-machine-learning-training-work-flow-1945da4d3b05?source=collection_archive---------40-----------------------#2020-06-29">https://towardsdatascience.com/design-pattern-for-machine-learning-training-work-flow-1945da4d3b05?source=collection_archive---------40-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="59b4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">作为一名数据科学家，我做很多快速实验。在这篇文章中，我解释了如何使用高阶函数和装饰器来管理我的 Python 实验。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4e86057085cc4e2211a87e63c6cfe131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXylSLgFZh1q1sY30ExJOQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://burst.shopify.com/laptop?utm_campaign=photo_credit&amp;utm_content=Free+Programmers+Reviewing+Code+On+Computer+Image%3A+Stunning+Photography&amp;utm_medium=referral&amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">爆发</a>的<a class="ae kv" href="https://burst.shopify.com/@sarahpflugphoto?utm_campaign=photo_credit&amp;utm_content=Free+Programmers+Reviewing+Code+On+Computer+Image%3A+Stunning+Photography&amp;utm_medium=referral&amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">莎拉·普弗卢格</a>的照片</p></figure><p id="7692" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我相信我所有的读者都会在他们的数据集上尝试多种训练算法，以找到性能最佳的模型。我已经多次这样做了，在整个练习结束时，我的工作空间会是这样的—</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/0dc157a6858ba959824f08038fe01a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*UB7qwyiT6LJj3U6z1B2zTw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">经过几轮实验后，我的工作区</p></figure><p id="d4e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终，我会忘记我在每个文件中做了什么，甚至为了记住最佳型号，我将不得不浏览每个笔记本文件来检查性能。当我邀请合作者参与这个项目时，系统变得更加复杂。我和我的合作者将有我们自己的训练代码，我们每个人都将用他们自己的代码创建一个 Python 文件/笔记本。这整个设置变成了一个令人头疼的维护问题。</p><p id="b981" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经学会了通过实现一个叫做“<a class="ae kv" href="https://www.tutorialspoint.com/python_design_patterns/python_design_patterns_strategy.htm" rel="noopener ugc nofollow" target="_blank">策略</a>”的设计模式来降低复杂性。我一启动项目就设置了这种模式，并提高了项目代码的可维护性和可重用性。</p><p id="7ea5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在阐述策略之前，我需要引入高阶函数和装饰器的概念。如果您已经了解了这一点，请跳过接下来的两个部分。</p><h1 id="d6c6" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">高阶函数</h1><p id="333a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Python 将函数视为一级对象。这个想法很深刻，很细致。在这篇文章中，我无法公正地对待这个复杂的话题。相反，我将敦促你们所有人向那些写了多篇关于“一流”文章的大师们学习。相反，我将展示两个将函数视为一级对象的例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/b6e83f16cefddeab80a3c0435525e987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OpdK8O4icxXWbnq-"/></div></div></figure><p id="51ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们创建了一个函数来计算阶乘，Python 解释器在<code class="fe mr ms mt mu b">0x103d6b430</code>注册了这个函数。第一类自然允许我-</p><ol class=""><li id="88f0" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">将阶乘赋值给一个名为<code class="fe mr ms mt mu b">fact</code>的新变量，并使用该变量计算阶乘。而且，</li><li id="c74a" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">将<code class="fe mr ms mt mu b">factorial</code>作为参数传递给函数<code class="fe mr ms mt mu b">accumulate</code>。</li></ol><p id="97fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<code class="fe mr ms mt mu b">accumulate</code>是一个<strong class="ky ir">高阶函数</strong>，因为它将一个函数作为输入。高阶函数在数据科学(以及整个 Python)中很流行。我确信所有的数据科学家都使用过像<code class="fe mr ms mt mu b">df.apply(np.mean)</code>这样的模式来构建他们的熊猫数据框架。<code class="fe mr ms mt mu b">np.mean</code>是一个函数，由于<code class="fe mr ms mt mu b">apply</code>将其作为输入，<code class="fe mr ms mt mu b">apply</code>是一个高阶函数。</p><h1 id="ba97" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">装修工</h1><p id="873a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">装饰器也是高阶函数，它接受另一个函数(称为装饰函数)作为参数，并返回或替换该函数。我将集中讨论一个最简单的装潢师的例子。</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="e12b" class="nn lu iq mu b gy no np l nq nr">def decorator(func):<br/>	'''do something'''<br/>	return func</span><span id="500a" class="nn lu iq mu b gy ns np l nq nr">@decorate<br/>def my_function():<br/>	'''Interesting code'''</span><span id="6ca1" class="nn lu iq mu b gy ns np l nq nr"># The above is equivalent to - <br/>decorate(my_function)</span></pre><p id="d336" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">装饰者利用 Python 中函数的<strong class="ky ir">一级性质。</strong></p><h1 id="16ce" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">战略设计模式</h1><p id="7eb6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">设计模式描述了一个具有<strong class="ky ir">模式</strong>的问题，然后提出了该问题的解决方案。在我的情况下，问题是在合作进行机器学习的快速实验时减少混乱。</p><p id="9248" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">引用维基百科-</p><blockquote class="nt nu nv"><p id="ec58" class="kw kx nw ky b kz la jr lb lc ld ju le nx lg lh li ny lk ll lm nz lo lp lq lr ij bi translated">在<a class="ae kv" href="https://en.wikipedia.org/wiki/Computer_programming" rel="noopener ugc nofollow" target="_blank">计算机编程</a>中，<strong class="ky ir">策略模式</strong>(也称为<strong class="ky ir">策略模式</strong>)是一种<a class="ae kv" href="https://en.wikipedia.org/wiki/Behavioral_design_pattern" rel="noopener ugc nofollow" target="_blank">行为</a> <a class="ae kv" href="https://en.wikipedia.org/wiki/Design_pattern_(computer_science)" rel="noopener ugc nofollow" target="_blank">软件设计模式</a>，能够在运行时选择<a class="ae kv" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank">算法</a>。代码不是直接实现单个算法，而是接收运行时指令，以决定使用哪一组算法。<a class="ae kv" href="https://en.wikipedia.org/wiki/Strategy_pattern#cite_note-1" rel="noopener ugc nofollow" target="_blank">【1】</a></p></blockquote><p id="c2b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用的策略模式包括使用装饰器来跟踪和获取模型。实现如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/3dec4d120e30cd5baec6a3f52f966ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WGrSsiV0Xo9xn_cAQ5z5Aw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模型训练代码的脚手架</p></figure><ol class=""><li id="0e63" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">我已经初始化了一个空列表来存储我感兴趣的所有模型。</li><li id="9a5b" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">我创建了一个<code class="fe mr ms mt mu b">register</code>装饰函数来注册我的模型。装饰器接受任何函数，并将该函数添加到列表中<code class="fe mr ms mt mu b">models</code></li><li id="74aa" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">我使用<code class="fe mr ms mt mu b">@register</code>关键字来注册我的模型</li><li id="17ef" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">我将每个模型训练代码作为一个独立的函数来编写。但是它们都实现了标准的返回类型。在这个例子中是 F1 分数和训练模型。</li><li id="5696" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">现在<code class="fe mr ms mt mu b">best_model(data)</code>获取所有注册的模型，并返回性能最好的模型。</li></ol><p id="2ca6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我的合作者添加一个新的模型训练函数时，她都会用关键字<code class="fe mr ms mt mu b">@register</code>来修饰这个函数，新的模型就会被集成到我的训练运行中。</p><p id="1e80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式允许我们以灵活和简单的方式开发 ML 模型。该模式在运行时选择最佳模型。我可以添加一个新的模型训练代码，并且可以运行模型训练功能的全部或特定子集。要移除任何函数(模型训练代码),我可以只注释掉<code class="fe mr ms mt mu b">@register</code>装饰器。</p><h1 id="3f9c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="4a3b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">随着许多人尝试不同的技巧，协作机器学习变得复杂和混乱，您的开发环境变成了陈旧代码和笔记本文件的复杂混乱。我推荐的模式可以帮助开发人员灵活地设计新代码，并允许维护人员保持代码库的整洁。该策略在开发人员中强制执行纪律，以编写标准的可重用代码。这个策略帮助我和我的团队缩短了代码开发时间，减少了代码中的错误。</p></div></div>    
</body>
</html>