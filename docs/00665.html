<html>
<head>
<title>In Praise of the Coin Flip</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为了赞美抛硬币</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/in-praise-of-the-coin-flip-238ddfb02cb9?source=collection_archive---------17-----------------------#2020-01-19">https://towardsdatascience.com/in-praise-of-the-coin-flip-238ddfb02cb9?source=collection_archive---------17-----------------------#2020-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d8d6" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">统计数字</h2><div class=""/><div class=""><h2 id="bf16" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">不起眼的抛硬币如何帮助解决数据科学中的问题</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/92f5206d33bd3b26216a109c55377584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nr5Aed2joe36gYSRVsI0GA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来源:<a class="ae lh" href="https://www.pexels.com/photo/close-up-of-coins-on-table-332304/" rel="noopener ugc nofollow" target="_blank">像素</a></p></figure><p id="a2d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di">1953年</span>，卡尔·巴克斯创作的一部名为<a class="ae lh" href="https://scrooge-mcduck.fandom.com/wiki/Flip_Decision" rel="noopener ugc nofollow" target="_blank">《翻转决定》</a>的唐老鸭漫画，提出了一种伪哲学，叫做<em class="mn">翻转主义。前提很简单:对于人生中每个需要做出决定的十字路口，选择一张硬币的正面(正面或反面)，投掷硬币，然后根据掷硬币的结果做出决定。作为哲学的发明者，巴蒂教授宣称:</em></p><blockquote class="mo mp mq"><p id="4b24" class="li lj mn lk b ll lm kd ln lo lp kg lq mr ls lt lu ms lw lx ly mt ma mb mc md im bi translated">“人生不过是一场赌博！让flipism图表你的漫谈！”</p></blockquote><p id="3ad1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，不幸的是，在漫画中，对唐纳德来说，flipism并不奏效。每个决定都要掷硬币，这给可怜的唐纳德带来了一连串的不幸。然而具有讽刺意味的是，为了得到应有的惩罚，唐纳德通过抛硬币找到了正确的门背后的欺诈行为，成功地追捕到了骗子教授巴蒂，所以也许这种哲学确实有一些价值(或者更有可能，只是证明了作者的力量)。</p><p id="7bc0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然我不一定主张过基于抛硬币的生活，但事实证明，抛硬币和管理抛硬币的基本统计原则在应用于数据中经常面临的一些问题时特别有效。</p><p id="2020" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们来看三个例子。</p><h2 id="4441" class="mu mv it bd mw mx my dn mz na nb dp nc lr nd ne nf lv ng nh ni lz nj nk nl iz bi translated">基准模型</h2><p id="bbc5" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">想象一下，现在你已经训练了你的机器学习模型，比方说，在给定一些用户上下文信息的情况下，预测网页上广告的点击率。你使用一些关于你的用户的信息，例如，他们来自哪个国家，他们的人口统计信息，他们来自的登陆页面和一系列其他功能。如果他们在你的平台上工作，你可以使用基于他们在使用平台时所做的特性来提高你的模型的性能。</p><p id="ef8e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后你训练你的模型。现在，</p><blockquote class="mo mp mq"><p id="7c17" class="li lj mn lk b ll lm kd ln lo lp kg lq mr ls lt lu ms lw lx ly mt ma mb mc md im bi translated">您可以使用什么样的最简单的基准来了解您的模型是否是高性能的？</p></blockquote><p id="6037" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">值得注意的是，在这种情况下，任何训练有素的模型都必须以简单的抛硬币为基准。</p><p id="4b31" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们以50%的概率为广告的点击和非点击分别指定正面和反面，然后通过投掷硬币随机指定正面和反面来预测广告点击，我们得到一个<em class="mn">随机分类器</em>。现在，任何经过训练的模型的目标都很简单:<strong class="lk jd">它必须至少击败随机预测器</strong>。这就是为什么测量模型的准确性很重要，然后将其与随机预测值的准确性进行比较(平均而言，准确性为50%)。</p><p id="e7f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们甚至可以更进一步:假设我们知道广告的历史基础点击率是30%。然后，使用上面的硬币方法，我们现在模拟一个有偏向的硬币，正面有30%的概率，反面没有。任何预测模型都必须击败这个新的随机预测基准。请注意，准确性不是衡量性能的唯一标准；其他如<a class="ae lh" href="https://en.wikipedia.org/wiki/False_positive_rate" rel="noopener ugc nofollow" target="_blank">假阳性率</a>，以及<a class="ae lh" href="https://en.wikipedia.org/wiki/Precision_and_recall" rel="noopener ugc nofollow" target="_blank">精度和召回率</a>也可以使用。</p><p id="bd77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以看到这如何应用于任何类型的二元类预测场景，随机预测器作为一个简单的健全性检查:<strong class="lk jd">如果一个模型不能击败基准，那么是时候回到绘图板</strong>。相反，如果它确实超过了基准，那么我们想量化多少。通过这个简单的比较，我们可以很容易地做到这一点，确信我们的模型不是出于随机的机会，而是比那更好。</p><h2 id="9b09" class="mu mv it bd mw mx my dn mz na nb dp nc lr nd ne nf lv ng nh ni lz nj nk nl iz bi translated">计算大数</h2><p id="bcc9" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">自计算的早期以来，计数一直是计算机科学的一个标准焦点。一个值得注意且重要的问题是大数的计数，以及确定大量项目的大小(基数)的相关问题，这是每个现代数据库系统都面临的问题。</p><p id="c143" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设你有一个有限的内存空间，但是必须计算非常大的数字。更具体地说，考虑这样一个场景，您受限于一个32位寄存器，并且需要计数到大于2 -1= 65，535的数。这种情况在高速网络路由器中很普遍，其中计数需要在非常短的时间窗口内在快速但昂贵的<a class="ae lh" href="https://en.wikipedia.org/wiki/Static_random-access_memory" rel="noopener ugc nofollow" target="_blank">静态随机存取存储器</a>上执行。</p><p id="d2b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个技巧是近似地计数<em class="mn"/>，即放松<strong class="lk jd">必须精确计数的要求，而不是以一些小的误差幅度计数</strong>。这里的基本原理是，一旦您处理大数字，与1亿的值相比，相差几百的小误差对某些应用程序来说并不是什么大问题，尤其是那些大致的数字已经足够可行的应用程序。</p><p id="8fa9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">计算大数的简单算法如下:</p><blockquote class="mo mp mq"><p id="497d" class="li lj mn lk b ll lm kd ln lo lp kg lq mr ls lt lu ms lw lx ly mt ma mb mc md im bi translated">要增加计数器，掷一枚等于计数器当前值乘以数字的公平硬币。如果硬币每次都正面朝上，计数器加1，否则什么都不做。</p></blockquote><p id="1ace" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是众所周知的<em class="mn">莫里斯算法</em>，它是由贝尔实验室的罗伯特·莫里斯于1977年发明的。</p><p id="5dcd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看起来很简单，但是它是如何工作的呢？</p><p id="9717" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设计数器当前处于数字2。现在，为了增加，我们连续两次投掷一枚公平的、无偏见的硬币，所以我们可以得到的排列是</p><blockquote class="mo mp mq"><p id="c1ec" class="li lj mn lk b ll lm kd ln lo lp kg lq mr ls lt lu ms lw lx ly mt ma mb mc md im bi translated">HH，HT，TH，TT</p></blockquote><p id="a318" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其中<em class="mn"> H </em>代表正面，<em class="mn"> T </em>代表反面。按照上面的说明，我们只在<em class="mn"> HH </em>上递增，实际上只以0.25的概率递增。因为下一个计数器状态将是3，所以由计数器表示的数字范围在4和8之间(包括8)。</p><p id="3fa4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随着计数器值变大，我们可以看到算法只是存储数字范围的以2为底的对数，<em class="mn">即</em> 1，2，4，8，…无限。由于任何数字<em class="mn"> N </em>都可以用对数来表示，即<em class="mn"> log </em> ₂ <em class="mn"> N，</em>那么莫里斯计数器所做的就是只<strong class="lk jd">保留<em class="mn"> log </em> ₂ <em class="mn"> N，</em> </strong>的第一个数字，换句话说就是数字<em class="mn"> N </em> 的<strong class="lk jd">指数。</strong></p><p id="20a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Phillipe Flajolet对Morris算法进行了更彻底的分析，通过将其增量建模为离散时间生灭过程(他还在论文中创造了术语<em class="mn">近似计数</em>)。我们可以进一步扩展Morris算法(如果我们愿意的话),为更大的数字保留指数的指数<strong class="lk jd">!</strong></p><p id="bff5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一个有趣的花絮来自信息论分析。如果我们想要一个数字<em class="mn"> N </em>的精确计数，我们将需要<em class="mn">对数</em> ₂ <em class="mn"> N </em>位。莫里斯提出了一种计数器，它使用<em class="mn">对数</em> ₂ <em class="mn">对数</em> ₂ <em class="mn"> N </em>位，因此只保留数字的指数。我们现在可以看到，内存增长的规模将比我们想要一个确切的数字要慢得多。</p><p id="7dd0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如今，Morris算法已经被改进的算法所取代，例如现代数据库系统中使用的<a class="ae lh" href="https://en.wikipedia.org/wiki/HyperLogLog" rel="noopener ugc nofollow" target="_blank"><em class="mn">hyperlog log</em></a><em class="mn"/>算法，以及SQL方言中的近似不同计数函数，例如<a class="ae lh" href="https://prestodb.io/docs/current/functions/hyperloglog.html" rel="noopener ugc nofollow" target="_blank"> Presto </a>和<a class="ae lh" href="https://docs.snowflake.net/manuals/user-guide/querying-approximate-cardinality.html" rel="noopener ugc nofollow" target="_blank">雪花</a>。然而，Morris算法仍然是现代概率计数算法的先驱，并且是最容易实际实现的算法之一。</p><h2 id="072b" class="mu mv it bd mw mx my dn mz na nb dp nc lr nd ne nf lv ng nh ni lz nj nk nl iz bi translated">伯努利多臂强盗</h2><p id="e051" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">多臂土匪问题涉及在一组竞争选项中最大化期望回报的问题，其中每个选项的回报最初是未知的，但随着时间的推移是可发现的。这个术语暗指赌场中的一排排老虎机，也称为<em class="mn">独臂强盗</em>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/24605a7763aab5f10caabd069a735217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ToACctqqBeI4Eocfv9Zgrw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一排独臂土匪。(来源:<a class="ae lh" href="https://www.pexels.com/photo/slot-machines-3021120/" rel="noopener ugc nofollow" target="_blank">派克斯</a>)</p></figure><p id="5826" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在多臂土匪的情况下，一个赌徒必须玩一套吃角子老虎机，以找出随着时间的推移哪台机器将提供最高的预期奖励。当游戏者第一次开始时，游戏者不知道随着时间的推移哪台机器将提供最高的预期回报；如果游戏者这么做了，那么问题就变成了<strong class="lk jd">通过独自在上面玩来利用</strong>正确的吃角子老虎机。由于游戏者没有预先的知识，那么游戏者将不得不<strong class="lk jd">探索</strong>一组机器，随着时间的推移，确定产生最高预期回报的机器。</p><p id="6b5f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，在回报最初未知的环境中，我们有一个<em class="mn">探索对开发</em>的常见案例。你应该采取什么样的策略，你需要做多少探索和开发？开发得太快，你就有陷入局部最大值的风险；探索太多，你将永远无法最大化你的预期回报，因为你会从一个选项跳到另一个选项。</p><p id="e4e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现实世界中的许多问题都会出现这种情况:投资组合分配、推荐系统、优化显示给用户的广告、搜索结果排名和约会。虽然有人可能会在最后一次申请时生气。</p><p id="a4c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有趣的是，许多这样的问题都符合抛硬币的框架。让我们考虑我们想要向用户展示的广告的两种变体，目标是最大化点击率。我们在我们的平台上部署广告的两种变体，50%的用户群看到变体A，而其余的看到变体b。然后，随着时间的推移，我们希望分配更多比例的用户来查看表现最佳的变体。</p><p id="cc5e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以对这个场景建模如下:当每个用户看到一个广告时，一次点击，比如说<em class="mn">头</em>头，就是一个奖励。广告A和B都可以被建模为具有不同翻转概率的硬币。然后，我们的任务是推断每个广告的点击率，这实质上是推断广告A和B的掷硬币概率。我们还想知道基于这些概率哪个是表现最好的变体(这可以用作<a class="ae lh" href="https://medium.com/convoy-tech/the-power-of-bayesian-a-b-testing-f859d2219d5" rel="noopener">贝叶斯A/B测试</a>的基础)。</p><p id="ec6b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦我们做到了这一点，我们就可以计算出如何将用户比例分配给表现最好的广告。分配策略的主题仍然是一个活跃的研究领域，有一些著名的解决方案，如置信上限算法和Thompson抽样。点击这里，查看Lilian Weng对这些算法<a class="ae lh" href="https://github.com/lilianweng/multi-armed-bandit" rel="noopener ugc nofollow" target="_blank">的实现。</a></p><p id="7d57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以将这个框架扩展到多种广告。多臂bandit公式已被各公司用作经典A/B测试的替代品，如<a class="ae lh" href="https://netflixtechblog.com/artwork-personalization-c589f074ad76" rel="noopener ugc nofollow" target="_blank">网飞</a>。</p><p id="9457" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最好的部分是，它可以应用于广告以外的其他东西！您当然可以将它扩展到推荐商品和对一组搜索结果进行排名；对这两种情况的警告是，在UI中向用户显示项目时，您必须考虑位置偏差。其中一个版本用于在<a class="ae lh" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>对图片搜索结果进行排名，它已经投入生产有一段时间了。此后，它被更强大的算法所取代，但却是一个令人惊讶的难以推翻的基准！</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="8b2e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然唐老鸭可能在抛硬币决定其人生道路方面运气不佳，但抛硬币解决数据科学中的问题确实非常有用。</p><p id="1609" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不起眼的抛硬币是这样一个通用的框架，它可以作为二元选择情况下的一个有用的心理模型。下次你遇到问题的时候，想想你可以如何使用抛硬币！只是…不要做唐纳德做过的事。</p><h2 id="5ea6" class="mu mv it bd mw mx my dn mz na nb dp nc lr nd ne nf lv ng nh ni lz nj nk nl iz bi translated">参考</h2><p id="4fe8" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">[1]菲利普·弗莱约莱。“近似计数:详细分析”。<a class="ae lh" href="http://algo.inria.fr/flajolet/Publications/Flajolet85c.pdf" rel="noopener ugc nofollow" target="_blank">http://algo.inria.fr/flajolet/Publications/Flajolet85c.pdf</a></p><p id="7e5a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[2]彼得·奥尔。“使用置信界限进行开发-探索权衡”，《机器学习研究杂志》第3期，2002年，第397–422页。<a class="ae lh" href="http://www.jmlr.org/papers/volume3/auer02a/auer02a.pdf" rel="noopener ugc nofollow" target="_blank">http://www.jmlr.org/papers/volume3/auer02a/auer02a.pdf</a></p><p id="0054" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[3]威廉·r·汤普森。“根据两个样本的证据，一个未知概率超过另一个未知概率的可能性”。《生物计量学》, 25(3–4)，1933年，第285–294页。<a class="ae lh" href="https://www.dropbox.com/s/yhn9prnr5bz0156/1933-thompson.pdf" rel="noopener ugc nofollow" target="_blank">https://www.dropbox.com/s/yhn9prnr5bz0156/1933-thompson.pdf</a></p></div></div>    
</body>
</html>