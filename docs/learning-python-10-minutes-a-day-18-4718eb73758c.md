# 每天 10 分钟学习 Python 10

> 原文：<https://towardsdatascience.com/learning-python-10-minutes-a-day-18-4718eb73758c?source=collection_archive---------51----------------------->

![](img/861a215f083567059b0616591c415d2f.png)

[杰瑞米·拉帕克](https://unsplash.com/@jeremy_justin?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的原始照片。

## [每天 10 分钟 Python 速成班](https://towardsdatascience.com/tagged/10minutespython)

## 关于生成器以及如何创建它们的更多信息

这是一个[系列](https://python-10-minutes-a-day.rocks)10 分钟的简短 Python 文章，帮助您提高 Python 知识。我试着每天发一篇文章(没有承诺)，从最基础的开始，到更复杂的习惯用法。如果您对 Python 的特定主题有任何问题或要求，请随时通过 LinkedIn 联系我。

我们已经遇到了生成器，它是一个 iterable，可以在需要的时候缓慢地计算值。这在速度上有好处，但最大的好处是减少了内存。常规列表需要一次性分配，一百万个值的列表可能会占用大量内存。当我们一次处理一个(或几个)值时，使用生成器要聪明得多。我们已经看到了 *range()* 函数，然而这并不是一个正式的生成器(但还是有点类似)。关于生成器，有一点是它只能在 iterable 上迭代一次。范围()可以重复完整迭代。当然，这只是一个细微的差别，但是要牢记在心。在上节课中，我们讨论了理解，但我们没有提到一种特殊类型:生成理解(或生成表达)。这种类型的理解看起来与列表理解相同，但是使用圆括号而不是方括号，并且顾名思义，返回一个生成器。

发电机没有长度，因此不能使用 *length()* 功能。在这个例子中，我们知道长度，因为我们已经定义了它( *range(10)* )。然而，如果我们使用生成器来一行一行地遍历一个大文件，根据定义，生成器没有长度。实际上，要获得长度，即要读取的行数，您需要读取整个文件并计算' \n '个字符。这已经花费了一个完整的迭代周期。

从生成器获取下一个值的另一种方法是使用 *next()* 函数。你必须记住，如果生成器是空的，即完整的迭代已经完成， *next()* 函数将引发一个 *StopIteration* 异常。这可能会让您想知道 for 循环是如何工作的，因为您无法检查是否还有剩余的项。原来 for-loop 抓到了 *StopIteration* 异常:[*先请求原谅再请求许可*](/learning-python-10-minutes-a-day-12-44806ea44852) 。

我们了解到，生成器对于减少 Python 程序的内存占用非常有用，甚至可以读取 100GB 的文件。为了完成这些专门的任务，您需要定义自己的生成器函数。生成器函数看起来像一个常规函数，它计算当前值。然后返回这个值，但是我们不使用 *return* 关键字，而是使用 *yield* 。通常，当使用 *return* 时，函数的状态是垃圾收集。这意味着函数中的所有变量都被删除了。使用*产量*，功能的状态被保持，保持所有变量完整。当 for-loop 或 next()调用请求下一个值时，生成器函数将继续生成下一个值。让我们创建一个简单的生成器:

从生成器函数本身来看，已经很清楚为什么生成器在一次完整的迭代后是空的了。到达 *max_number* 后，该功能结束，不能产生新的值。为了再次迭代生成器，我们需要再次重新启动生成器。

函数本身可以是任何东西。我们已经提到的例子是一个大于内存的文件的逐行迭代，但是还有许多其他的用法。生成器可以组合一个或多个数据库调用，可以从互联网下载信息，并且可以被定义为可以无限期运行。

生成器是 Python 中的一个高级特性，在某些情况下非常有用。正如我已经提到的，当内存是一个问题时，生成器是一个可能的解决方案。值是动态计算的。如果你只需要几个值(比如 100 个值中的前 10 个)，你可以省略不需要的计算，这样可以提高速度。你可以用发电机做更高级的事情，例如堆叠发电机。组合生成器可以模仿管道，这是一种高效的技术，例如在 Unix 世界中。

# 今天的练习:

当讨论更高级的话题时，作业也会变得更有趣。因为我喜欢数字，今天我们要产生[斐波纳契数](https://en.wikipedia.org/wiki/Fibonacci_number)。斐波那契数列(或斐波那契数列)非常神奇，因为它们在自然界中经常出现。该序列定义了当前的斐波那契数列是前两个数列的和:

```
F = [0, 1, 1, 2, 3, 5, 8, 13, ....... ]
```

**赋值:** 创建一个*无限*生成器来生成斐波那契数。使用 while 循环(和 break)测试您的函数。由于生成器是无限的，您可以继续第二个循环。

**提示** :
a)无限循环可以用永远为真的 while 循环来创建。
b)生成器函数需要跟踪最后两个值并得出总和。

我已经在我的 Github 上发布了[解决方案](https://gist.github.com/dennisbakhuis/ad7ceab8238e1eac2df6e98d06c859d2)。

如有任何问题，欢迎通过 [LinkedIn](https://www.linkedin.com/in/dennisbakhuis/) 联系我。