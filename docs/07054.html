<html>
<head>
<title>Optimal performance with Bigtable: changing the key of your table with Apache Beam</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Bigtable优化性能:使用Apache Beam更改表的键</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimal-performance-with-bigtable-changing-the-key-of-your-table-with-apache-beam-9139542a445e?source=collection_archive---------39-----------------------#2020-05-30">https://towardsdatascience.com/optimal-performance-with-bigtable-changing-the-key-of-your-table-with-apache-beam-9139542a445e?source=collection_archive---------39-----------------------#2020-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/881c9b5d708babee4e03de09bcf8009a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*30uxtIUy-FyW1NGP"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">克里斯蒂安·恩格梅尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3043" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://cloud.google.com/bigtable" rel="noopener ugc nofollow" target="_blank"> Cloud Bigtable </a>是一个高性能的分布式NoSQL数据库，可以存储数Pb的数据，并以低于10毫秒的延迟响应查询。然而，为了达到这一性能水平，<a class="ae kc" href="https://cloud.google.com/bigtable/docs/schema-design" rel="noopener ugc nofollow" target="_blank">为您的表选择正确的键</a>非常重要。此外，您能够进行的查询类型取决于您为表选择的键。</p><p id="9bf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Bigtable附带了<a class="ae kc" href="https://cloud.google.com/bigtable/docs/keyvis-overview" rel="noopener ugc nofollow" target="_blank"> Key Visualizer </a>工具，用于诊断我们的键是如何执行的。为了开始产生结果，Key Visualizer至少需要30 GB的数据和一些工作负载。您拥有的数据越多越好，因为结果会越接近您在生产环境中部署时的结果。</p><p id="4baf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以当你在Bigtable中存储了很多数据之后，<strong class="kf ir">如果你发现你的键性能不好怎么办？如何更新密钥？需要再从头开始吗？</strong></p><p id="22a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不，您可以使用Apache Beam管道来更新密钥。</p><p id="bbad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们描述了如何使用Apache Beam管道来更改表的键，只需编写几行代码来定义新的键。我们将使用演示数据在本地运行所有内容(Apache Beam使用DirectRunner，Bigtable使用模拟器)，因此没有必要为了跟进这篇文章而使用Google Cloud项目。但是你需要安装<a class="ae kc" href="https://cloud.google.com/sdk/docs/quickstarts" rel="noopener ugc nofollow" target="_blank">Google Cloud SDK</a>。</p><p id="8e95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于有大量数据的真实情况，建议在<a class="ae kc" href="https://cloud.google.com/dataflow" rel="noopener ugc nofollow" target="_blank">数据流</a>中运行这个管道，但是对于演示来说，DirectRunner就足够了。</p><p id="31b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Google Cloud专业服务团队的Github repo中提供了管道:</p><div class="lb lc gp gr ld le"><a href="https://github.com/GoogleCloudPlatform/professional-services/tree/master/examples/bigtable-change-key" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">Google cloud platform/professional-services/examples/bigtable-change-</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">更改Bigtable中表的键的数据流管道</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">github.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls jw le"/></div></div></a></div><p id="8e7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">克隆repo并转到此管道的目录。您可以在本地或在云外壳中克隆回购。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="916f" class="mc md iq ly b gy me mf l mg mh">git clone <a class="ae kc" href="https://github.com/GoogleCloudPlatform/professional-services" rel="noopener ugc nofollow" target="_blank">https://github.com/GoogleCloudPlatform/professional-services</a></span><span id="0e02" class="mc md iq ly b gy mi mf l mg mh">cd professional-services/examples/bigtable-change-key</span></pre></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="0938" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您已经有了一个Bigtable实例，可以转到下一节。在这里，我们将展示如何启动Google Cloud SDK附带的<a class="ae kc" href="https://cloud.google.com/bigtable/docs/emulator" rel="noopener ugc nofollow" target="_blank"> Bigtable模拟器</a>,因此您不需要为Bigtable实例付费来试用这篇博客文章。</p><p id="2d56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了启动模拟器，我们在终端中运行以下命令:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="603a" class="mc md iq ly b gy me mf l mg mh">gcloud beta emulators bigtable start</span></pre><p id="6569" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它通常会在端口8086启动一个服务器。但是不要担心这些细节，因为我们稍后将使用<code class="fe mq mr ms ly b">gcloud</code>实用程序来设置它们。</p><p id="deca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在不同的shell会话中(例如，新的终端窗口或新的终端标签)，我们将设置一些环境变量来使用模拟器。我们将不得不使用该会话来运行管道，因此请确保在新的终端中继续运行命令。现在，通过运行以下命令来设置环境变量:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="f216" class="mc md iq ly b gy me mf l mg mh">$(gcloud beta emulators bigtable env-init)</span></pre><p id="a710" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以检查一下，现在有一些变量指向我们的本地Bigtable服务器:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7a1e" class="mc md iq ly b gy me mf l mg mh">echo $BIGTABLE_EMULATOR_HOST</span></pre><p id="7d1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该会看到类似于<code class="fe mq mr ms ly b">localhost:8086</code>的输出</p><p id="2bf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您得到一个空的输出，那么一定是出了问题(也许您不是在同一个shell会话中运行？).</p><p id="fd8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在需要配置<code class="fe mq mr ms ly b">cbt</code>来使用这个模拟器作为Bigtable实例。为此，我们需要在<code class="fe mq mr ms ly b">~/.cbtrc</code>处编辑文件，并设置以下内容(我们必须在管道配置中使用相同的<em class="mt">项目</em>和<em class="mt">实例</em>名称):</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="4d84" class="mc md iq ly b gy me mf l mg mh">project = my-fake-project<br/>instance = my-fake-instance</span></pre></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="5162" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您已经有了一个正在运行的Bigtable实例，让我们用数据填充它。为此，我们可以在管道中使用Github中包含的一个脚本。在管道的主目录中(在我们的repo克隆中)，我们运行以下脚本，创建一个名为<code class="fe mq mr ms ly b">taxis</code>的表:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="0e98" class="mc md iq ly b gy me mf l mg mh">./scripts/create_sandbox_table.sh taxis</span></pre><p id="582b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以检查表是否已经创建。记住，您需要配置<code class="fe mq mr ms ly b">cbt</code>来访问您的实例。在上一节中，我们已经为Bigtable模拟器完成了这项工作。如果您跳过了前一部分，请<a class="ae kc" href="https://cloud.google.com/bigtable/docs/quickstart-cbt" rel="noopener ugc nofollow" target="_blank">检查如何配置cbt </a>。</p><p id="eaeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们运行这个命令</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="4ee3" class="mc md iq ly b gy me mf l mg mh">cbt ls taxis</span></pre><p id="d824" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该得到这样的输出</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="a7db" class="mc md iq ly b gy me mf l mg mh">Family Name      GC Policy<br/>-----------      ---------<br/>id               &lt;never&gt;<br/>loc              &lt;never&gt;</span></pre><p id="9044" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以通过运行以下命令来检查该表中有3行</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b3bf" class="mc md iq ly b gy me mf l mg mh">cbt count taxis</span></pre><p id="23ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Bigtable模拟器将这些数据保存在内存中。也就是说，它是短暂的。如果停止模拟器，数据将会丢失。因此，您需要再次填充它才能使用它。<strong class="kf ir">不要在仿真器中存储任何有价值的数据，它不会被保存</strong>。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="9398" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们在一个表中有了一些数据，我们可以编写代码来更改表的键。我们将对密钥做一个简单的更改:我们将反转它。对于自动递增的值，比如时间戳，这是一个常见的<em class="mt">技巧</em>来尝试改善表中数据的分布。有更多的考虑和可能的改变，但是对于这篇文章，我们将只做这些改变。</p><p id="9a36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，要更改现有表的键，在我们的管道中，我们将使用以下两个元素来决定新键:当前(旧)键和完整记录(包含所有列)。</p><p id="a982" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该能够根据这些信息决定新的密钥。因为我们只是反转旧密钥，所以在本例中，我们将忽略该记录来生成新密钥。</p><p id="22de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现这种密钥更改，我们需要更新管道的代码。你需要改变<a class="ae kc" href="https://github.com/GoogleCloudPlatform/professional-services/blob/433da74fa5665dff9bb368133b46c384731eb0e2/examples/bigtable-change-key/src/main/java/com/google/cloud/pso/pipeline/BigtableChangeKey.java#L41-L50" rel="noopener ugc nofollow" target="_blank">类</a> <code class="fe mq mr ms ly b"><a class="ae kc" href="https://github.com/GoogleCloudPlatform/professional-services/blob/433da74fa5665dff9bb368133b46c384731eb0e2/examples/bigtable-change-key/src/main/java/com/google/cloud/pso/pipeline/BigtableChangeKey.java#L41-L50" rel="noopener ugc nofollow" target="_blank">com.google.cloud.pso.pipeline.BigtableChangeKey</a></code>中的 <code class="fe mq mr ms ly b"><a class="ae kc" href="https://github.com/GoogleCloudPlatform/professional-services/blob/433da74fa5665dff9bb368133b46c384731eb0e2/examples/bigtable-change-key/src/main/java/com/google/cloud/pso/pipeline/BigtableChangeKey.java#L41-L50" rel="noopener ugc nofollow" target="_blank">transformKey</a></code> <a class="ae kc" href="https://github.com/GoogleCloudPlatform/professional-services/blob/433da74fa5665dff9bb368133b46c384731eb0e2/examples/bigtable-change-key/src/main/java/com/google/cloud/pso/pipeline/BigtableChangeKey.java#L41-L50" rel="noopener ugc nofollow" target="_blank">函数。代码如下面的代码片段所示:</a></p><figure class="lt lu lv lw gt jr"><div class="bz fp l di"><div class="mu mv l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">函数来更新记录的键</p></figure><p id="d6b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数需要返回一个带有新密钥的<code class="fe mq mr ms ly b">String</code>。输入参数是当前键(作为一个<code class="fe mq mr ms ly b">String</code>)，以及包含所有列的完整记录(作为一个<code class="fe mq mr ms ly b">Row</code>)。记录的类型是<code class="fe mq mr ms ly b">Row</code>，可以在Google Bigtable库中找到<a class="ae kc" href="http://googleapis.github.io/googleapis/java/all/latest/apidocs/com/google/bigtable/v2/Row.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1ebe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何恢复该记录中的列和所有数据？参见<a class="ae kc" href="https://github.com/GoogleCloudPlatform/professional-services/blob/433da74fa5665dff9bb368133b46c384731eb0e2/examples/bigtable-change-key/src/main/java/com/google/cloud/pso/dofns/UpdateKey.java#L52-L69" rel="noopener ugc nofollow" target="_blank">管道中的一个例子，它遍历记录以创建它的副本</a>(这就是为什么它创建一个突变列表，在Bigtable的隐语中更改一行)。但是总的来说，只需遍历列族、列和单元格值，就可以恢复该记录中包含的所有元素(请记住，一个单元格可能有一个以上的单元格版本，这就是为什么会有多个单元格)。这段代码片段展示了如何遍历一个<code class="fe mq mr ms ly b">Row</code></p><figure class="lt lu lv lw gt jr"><div class="bz fp l di"><div class="mu mv l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">显示如何在Java中遍历Bigtable行的代码片段</p></figure><p id="1a10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">管道中包含的默认代码反转密钥，因此不需要实际做任何更改来反转它。但是请随意更改代码，尝试不同的密钥更新功能。请记住，每个记录的键应该是唯一的；具有相同键的记录将被管道覆盖。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="1548" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经编写了更新密钥的代码，让我们运行管道。在这个例子中，我们将使用Apache Beam的<code class="fe mq mr ms ly b">DirectRunner</code>(而不是，例如，<code class="fe mq mr ms ly b">DataflowRunner</code>)，因为我们正在处理一个只有3条记录存储在Bigtable模拟器中的表。</p><p id="4892" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在运行管道之前，我们必须确保目标表存在，并且它与我们从中复制的表具有相同的列族。为此，我们运行以下脚本。该脚本使用的是<code class="fe mq mr ms ly b">cbt</code>，我们已经将其配置为指向我们的Bigtable实例。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="13f5" class="mc md iq ly b gy me mf l mg mh">./scripts/copy_schema_to_new_table.sh taxis taxis_newkey</span></pre><p id="3d47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这应该会生成一个额外的表。如果我们执行<code class="fe mq mr ms ly b">cbt ls</code>，我们应该得到这个输出:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="026b" class="mc md iq ly b gy me mf l mg mh">taxis<br/>taxis_newkey</span></pre><p id="44cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新表应该有两个柱族。<code class="fe mq mr ms ly b">cbt ls taxis_newkey</code>的输出应该返回类似如下的内容:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="42da" class="mc md iq ly b gy me mf l mg mh">Family    Name GC Policy<br/>------    --------------<br/>id        &lt;never&gt;<br/>loc       &lt;never&gt;</span></pre><p id="5026" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以检查一下桌子是不是空的。命令<code class="fe mq mr ms ly b">cbt count taxis_newkey</code>应该返回0。</p><p id="e693" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们编译并构建这个包。为此，我们跑</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="dfc5" class="mc md iq ly b gy me mf l mg mh">mvn package</span></pre><p id="89ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构建应该成功，并在<em class="mt">target/bigtable-change-key-bundled-0.1-snapshot . jar</em>中创建一个包</p><p id="d430" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以使用本地运行器运行管道:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7dc1" class="mc md iq ly b gy me mf l mg mh">JAR_LOC=target/bigtable-change-key-bundled-0.1-SNAPSHOT.jar<br/><br/>INPUT_TABLE=taxis<br/>OUTPUT_TABLE=taxis_newkey<br/><br/>RUNNER=DirectRunner<br/><br/>java -cp ${JAR_LOC} com.google.cloud.pso.pipeline.BigtableChangeKey \<br/>        --runner=${RUNNER} \<br/>        --project=my-fake-project \<br/>        --bigtableInstance=my-fake-instance \<br/>        --inputTable=${INPUT_TABLE} \<br/>        --outputTable=${OUTPUT_TABLE}</span></pre><p id="9f50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行管道后，我们可以检查命令<code class="fe mq mr ms ly b">cbt count taxis_newkey</code>现在返回3。让我们比较输入表<code class="fe mq mr ms ly b">taxis</code>和输出表<code class="fe mq mr ms ly b">taxis_newkey</code>中的元素。</p><p id="5016" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们执行<code class="fe mq mr ms ly b">cbt read taxis</code>,我们将获得三条记录，为了简洁起见，我在这里只包括一条:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5d08" class="mc md iq ly b gy me mf l mg mh">----------------------------------------<br/><strong class="ly ir">33cb2a42-d9f5–4b64–9e8a-b5aa1d6e142f#132</strong><br/><strong class="ly ir"> id:point_idx</strong>                        @ 2020/05/31–01:35:26.865000<br/> “132”<br/><strong class="ly ir"> id:ride_id</strong>                          @ 2020/05/31–01:35:25.198000<br/> “33cb2a42-d9f5–4b64–9e8a-b5aa1d6e142f”<br/> <strong class="ly ir">loc:latitude</strong>                        @ 2020/05/31–01:35:28.591000<br/> “41.7854”</span></pre><p id="a171" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以你可以看到，这个键实际上是由<code class="fe mq mr ms ly b">ride_id</code>和<code class="fe mq mr ms ly b">point_idx</code>串联而成，由<code class="fe mq mr ms ly b">#</code>分隔。</p><p id="8ede" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在执行<code class="fe mq mr ms ly b">cbt read taxis_newkey</code>并尝试找到具有相同<code class="fe mq mr ms ly b">ride_id</code>和相同<code class="fe mq mr ms ly b">point_idx</code>的记录:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="d6dd" class="mc md iq ly b gy me mf l mg mh">----------------------------------------<br/><strong class="ly ir">231#f241e6d1aa5b-a8e9–46b4–5f9d-24a2bc33</strong><br/><strong class="ly ir"> id:point_idx</strong>                          @ 2020/05/31–01:35:26.865000<br/> “132”<br/><strong class="ly ir"> id:ride_id</strong>                            @ 2020/05/31–01:35:25.198000<br/> “33cb2a42-d9f5–4b64–9e8a-b5aa1d6e142f”<br/><strong class="ly ir"> loc:latitude</strong>                          @ 2020/05/31–01:35:28.591000<br/> “41.7854”</span></pre><p id="4334" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你注意到什么了吗？该行的键现在是原始表中键的反转:<code class="fe mq mr ms ly b">33cb2....132</code>是原始键，<code class="fe mq mr ms ly b">231....2bc33</code>是新键。如果你检查其他记录，你会注意到钥匙被颠倒了。</p><p id="472f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在回到<code class="fe mq mr ms ly b">transformKey</code>函数的代码，尝试编写不同的键。使用相同的模式创建一个新的输出表，重新编译并再次运行本地管道，以查看代码的效果。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="64fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">那么如果你需要改变一个有GBs或者TBs数据的表的键呢？</strong>在<a class="ae kc" href="https://cloud.google.com/dataflow" rel="noopener ugc nofollow" target="_blank">数据流</a>中运行此管道，创建一个副本表，但使用一个新的键。只是不要浪费云资源来检查新的transform key函数是否按预期工作。首先利用Bigtable模拟器和Apache Beam Direct Runner在本地运行管道，并确保在激发数据流中的数百个工人之前生成正确的密钥。</p></div></div>    
</body>
</html>