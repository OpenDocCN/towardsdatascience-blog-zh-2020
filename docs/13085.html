<html>
<head>
<title>Classifying Parkinson’s disease through image analysis: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过图像分析对帕金森病进行分类:第一部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/classifying-parkinsons-disease-through-image-analysis-2e7a152fafc9?source=collection_archive---------39-----------------------#2020-09-08">https://towardsdatascience.com/classifying-parkinsons-disease-through-image-analysis-2e7a152fafc9?source=collection_archive---------39-----------------------#2020-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="7b30" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">应用计算机视觉</h2><div class=""/><div class=""><h2 id="37f6" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">预处理和探索性数据分析</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/934fd23289dcbf6ad7815c96b394fc4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fVniO2FZsuP4wwfJXdpf5g.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">在<a class="ae le" href="https://unsplash.com/s/photos/science?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae le" href="https://unsplash.com/@halacious?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">halance</a>拍摄的照片</p></figure><h2 id="5702" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated"><span class="l ma mb mc bm md me mf mg mh di">我</span>简介</h2><p id="43ca" class="pw-post-body-paragraph mi mj iq mk b ml mm ka mn mo mp kd mq lo mr ms mt ls mu mv mw lw mx my mz na ij bi nb translated">阿金森氏病通常伴有震颤和僵硬等运动障碍症状。这些会对患有早期疾病的人的书写和素描产生明显的影响[1]。缩微图是一个人的笔迹中异常小的波动，然而，由于一个人发展的笔迹、语言、熟练程度和教育等的可变性，已经声称难以解释[1]。因此，2017 年进行的一项研究旨在通过使用螺旋和波浪的标准化分析来改善诊断。在这一系列的帖子中，我们将分析该研究中收集的原始图像，看看我们是否可以为一名帕金森患者创建一个分类器，并在此过程中得出一些结论。我们将使用的数据托管在 Kaggle [2]上，特别感谢 Kevin Mader 分享数据集上传。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/a30ecafdab8947c01c69a8115ad50735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YC2vnqxzxmOZjG1JI98bdw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自作者。我们将使用的数据的样本图像。</p></figure><p id="76cb" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">在第 1 部分中，我们将进行一些探索性的数据分析，并对图像进行预处理，以创建一些有望有助于分类的特征。我选择不使用卷积神经网络(CNN)来简单地对图像进行分类，因为这将是一个黑盒——没有任何衡量曲线/草图之间潜在差异的指标。相反，我们不是简单地执行分类任务，而是试图使用图像处理来理解和量化差异。在随后的帖子中，我将与 CNN 进行比较。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ni nj l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">来自吉菲</p></figure><blockquote class="nk nl nm"><p id="e565" class="mi mj nn mk b ml nd ka mn mo ne kd mq no nf ms mt np ng mv mw nq nh my mz na ij bi translated">在我们开始之前，声明这并不意味着任何形式的医学研究或测试。请参考<a class="ae le" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5592741/" rel="noopener ugc nofollow" target="_blank">原始论文</a>了解实际实验的细节，我并没有参与其中。<br/> Zham P，Kumar DK，Dabnichki P，Poosapadi Arjunan S，Raghav S. <em class="iq">利用画螺旋的速度和笔压综合指数区分帕金森病的不同阶段</em>。前神经元。2017;8:435.发布于 2017 年 9 月 6 日。doi:10.3389/fneur.2017.00435</p></blockquote></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="04b9" class="ny lg iq bd lh nz oa ob lk oc od oe ln kf of kg lr ki og kj lv kl oh km lz oi bi translated">探索性数据分析</h1><p id="d277" class="pw-post-body-paragraph mi mj iq mk b ml mm ka mn mo mp kd mq lo mr ms mt ls mu mv mw lw mx my mz na ij bi nb translated">首先，让我们看一下图像，执行一些基本的分割，并开始探索一些感兴趣的潜在特征。我们将全程使用熊猫来存储图像和信息。对于那些质疑你是否会阅读这一部分的人，这里是我们将要进入的内容:<br/> -阈值处理和清理<br/> -通过最近邻的厚度量化<br/> -骨架化<br/> -交叉点和边缘点</p><h2 id="a71d" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">阈值处理和清洗</h2><p id="0aa9" class="pw-post-body-paragraph mi mj iq mk b ml mm ka mn mo mp kd mq lo mr ms mt ls mu mv mw lw mx my mz na ij bi translated">我们使用一个修改的读取和阈值函数，主要是从 Kevin Mader 在 Kaggle 上的原始笔记本中获得的[2]。在这里，当我们想要查看蒙太奇风格的图像时，可以选择调整大小，如上图和下图所示。我们首先读入并反转图像，使图形在黑色背景上是白色的，如果需要还可以调整大小。我们还应用了一个小的中值滤波器。</p><blockquote class="nk nl nm"><p id="21c5" class="mi mj nn mk b ml nd ka mn mo ne kd mq no nf ms mt np ng mv mw nq nh my mz na ij bi translated">这个项目有相当多的代码，我不会把它们都放在这里，所以如果你想查看笔记本或 python 脚本以了解更多细节，请查看 github 链接。</p></blockquote><pre class="kp kq kr ks gt oj ok ol om aw on bi"><span id="b3a5" class="lf lg iq ok b gy oo op l oq or">from skimage.io import imread<br/>from skimage.util import montage as montage2d<br/>from skimage.filters import threshold_yen as thresh_func<br/>from skimage.filters import median<br/>from skimage.morphology import disk<br/>import numpy as np</span><span id="ced4" class="lf lg iq ok b gy os op l oq or">def process_imread(in_path, resize=True):<br/>    """read images, invert and scale them"""<br/>    c_img = 1.0-imread(in_path, as_gray=True)<br/>    max_dim = np.max(c_img.shape)<br/>    if not resize:<br/>        return c_img<br/>    if c_img.shape==(256, 256):<br/>        return c_img<br/>    if max_dim&gt;256:<br/>        big_dim = 512<br/>    else:<br/>        big_dim = 256<br/>    """ pad with zeros and center image, sizing to either 256 or 512"""   <br/>    out_img = np.zeros((big_dim, big_dim), dtype='float32')<br/>    c_offset = (big_dim-c_img.shape[0])//2<br/>    d_offset = c_img.shape[0]+c_offset<br/>    <br/>    e_offset = (big_dim-c_img.shape[1])//2<br/>    f_offset = c_img.shape[1]+e_offset<br/>    out_img[c_offset:d_offset, e_offset:f_offset] = c_img[:(d_offset-c_offset), :(f_offset-e_offset)]<br/>    return out_img</span><span id="f376" class="lf lg iq ok b gy os op l oq or">def read_and_thresh(in_path, resize=True):<br/>    c_img = process_imread(in_path, resize=resize)<br/>    c_img = (255*c_img).clip(0, 255).astype('uint8')<br/>    c_img = median(c_img, disk(1))<br/>    c_thresh = thresh_func(c_img)<br/>    return c_img&gt;c_thresh</span></pre><p id="6c78" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">最后，对于读入的内容，我们还通过移除任何与主草图无关的小对象来清理图像。</p><pre class="kp kq kr ks gt oj ok ol om aw on bi"><span id="854d" class="lf lg iq ok b gy oo op l oq or">from skimage.morphology import label as sk_label</span><span id="824a" class="lf lg iq ok b gy os op l oq or">def label_sort(in_img, cutoff=0.01):<br/>    total_cnt = np.sum(in_img&gt;0)<br/>    lab_img = sk_label(in_img)<br/>    new_image = np.zeros_like(lab_img)<br/>    remap_index = []<br/>    for k in np.unique(lab_img[lab_img&gt;0]):<br/>        cnt = np.sum(lab_img==k) # get area of labelled object<br/>        if cnt&gt;total_cnt*cutoff:<br/>            remap_index+=[(k, cnt)]<br/>    sorted_index = sorted(remap_index, key=lambda x: -x[1]) # reverse sort - largest is first<br/>    for new_idx, (old_idx, idx_count) in enumerate(sorted_index, 1): #enumerate starting at id 1<br/>        new_image[lab_img==old_idx] = new_idx<br/>    return new_image</span></pre><p id="a658" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">这是通过仅保留大于 1%的激活像素的足够大的分量来实现的；由截止值定义。首先标记图像中的每个单独的对象，并将每个标记的面积相加(不是 0)。如果计数超过总数的 1%,则保留索引。执行负排序，使最大的对象具有标签 1。用新的订购 id 替换旧的标签号。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/e6badbf1bf3bc445e45c153a56c9ab3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WqL_mx-7HIpnOOM-yH0_7Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自作者。阈值处理和清理后的数据样本图像。</p></figure><p id="62d6" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">作为绘图差异的初始视图，我们可以创建一个骨架图像并形成一个新的数据框，其中每一行都是每个图像中非零像素的单个像素坐标。然后，我们可以将这些曲线中的每一条绘制在一个图表上——在归一化位置之后。我们不会使用这种格式的数据框，这只是为了可视化。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ot"><img src="../Images/9a61b59a5085b66ec6aa0b7f7a9cb0d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tAJV-fY3rwd9rg_AL7bL1w.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自作者。一个地块上的所有图纸。</p></figure><p id="75d5" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">正如我们所看到的，健康的草图之间有很强的一致性。考虑到帕金森症状可能导致的随机运动，这是有意义的。</p><h2 id="5363" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">厚度量化</h2><p id="9857" class="pw-post-body-paragraph mi mj iq mk b ml mm ka mn mo mp kd mq lo mr ms mt ls mu mv mw lw mx my mz na ij bi nb translated"><span class="l ma mb mc bm md me mf mg mh di"> N </span> ext，我们将尝试量化厚度。为此，我们将使用距离图来给出图纸宽度的近似值。中轴也返回一个距离图，但是骨骼化更干净，因为它做了一些修剪。</p><pre class="kp kq kr ks gt oj ok ol om aw on bi"><span id="57d9" class="lf lg iq ok b gy oo op l oq or">from skimage.morphology import medial_axis<br/>from skimage.morphology import skeletonize</span><span id="803a" class="lf lg iq ok b gy os op l oq or">def stroke_thickness_img(in_img):<br/>    skel, distance = medial_axis(in_img, return_distance=True)<br/>    skeleton = skeletonize(in_img)<br/>    # Distance to the background for pixels of the skeleton<br/>    return distance * skeleton</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/93b9bf72cfa15416904d1e664801764c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*2-YgWDOSravjSwhOYTJxRg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自作者。线条粗细计算。</p></figure><p id="b431" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">通过绘制平均值和标准偏差，我们看到了这些图之间的一些相关性。主要是在标准差中，考虑到随机影响，这也是有意义的，事实上它是巨大的，并不小于健康也是有意义的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/d43434db50b3357bd639cb7593b4b769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JjSzvYno6_jxBGKdj1AcXQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自作者。图纸的厚度。</p></figure><h2 id="370e" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">交叉点和边缘点</h2><p id="0b29" class="pw-post-body-paragraph mi mj iq mk b ml mm ka mn mo mp kd mq lo mr ms mt ls mu mv mw lw mx my mz na ij bi nb translated"><span class="l ma mb mc bm md me mf mg mh di"> D </span>由于图像骨架化的工作方式，根据线条的“平滑度”,更多起伏的曲线会有更多的端点。因此，与平滑线相比，这些是随机运动的一些度量。另外，我们可以计算交点的数量；完美的曲线没有交点，只有两个端点。这些在其他图像处理应用中也是有用的，例如道路绘图。</p><p id="fc42" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">我不会在这里过多地讨论代码，因为需要进行相当多的清理，但是，我会尝试使用一些图像来解释我所做的事情。首先，我们计算曲线骨架的最近邻图像。除了在边缘点的值为 1 和在交叉点的值为 3 之外，这给了我们在任何地方的值为 2；这是在使用连通性 2(8 个最近的邻居)时。这是放大后的结果图像。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ov"><img src="../Images/10fb7fb6da4436c571fb39eff94b7258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDD2yN2-xrCR_jKwh1JTeQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自作者。交点和边缘点。</p></figure><p id="d018" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">正如你所看到的，这和预期的一样，除了我们遇到了一些问题，如果我们想得到一个像素交叉点来正确量化交叉点的数量。右边的图像有三个值为 3 的像素，尽管这只是一个交集。当这些交点的总和大于“正确的”交点时，我们可以通过隔离这些区域，用下面的伪算法来清理这个问题。我们可以将最近邻(NN)图像和阈值相加来隔离它们。连通性 1 有直接邻居，连通 2 包括对角线。</p><ul class=""><li id="2284" class="ow ox iq mk b ml nd mo ne lo oy ls oz lw pa na pb pc pd pe bi translated">从原始神经网络，分别使用连接 1 和 2 求和。</li><li id="dbd6" class="ow ox iq mk b ml pf mo pg lo ph ls pi lw pj na pb pc pd pe bi translated">隔离连通性 2 中值≥ 8 的交叉点。</li><li id="3a4b" class="ow ox iq mk b ml pf mo pg lo ph ls pi lw pj na pb pc pd pe bi translated">标记连接到交叉点像素的每条边。</li><li id="0090" class="ow ox iq mk b ml pf mo pg lo ph ls pi lw pj na pb pc pd pe bi translated">对于连通性 1 图像，隔离总和在 3 和 5 之间的交叉点像素。这些是我们不想要的。</li><li id="d760" class="ow ox iq mk b ml pf mo pg lo ph ls pi lw pj na pb pc pd pe bi translated">覆盖不正确的交叉点像素。</li></ul><p id="291d" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">结果如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ov"><img src="../Images/b77b9208aa21a714a003bb6b4e58d012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rodndQfUA2icxLDhAthyHA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自作者。交叉点和边缘点，已更正。</p></figure><p id="a87a" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">如你所见，我们现在在交叉点位置有一个值为 3 的像素。我们现在可以简单地将这些位置相加，以量化交点的数量。如果我们把这些画在一条曲线上，我们可以看到结果，黄色下面是交叉点，绿色是边缘点。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ov"><img src="../Images/2b61c480d2a3fb7e9957b53cc1502e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDFnZW9hU_zeLJKpJ00UFA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自作者。绘制了交点和边缘点的骨架曲线。</p></figure><p id="fba5" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">如果我们画出每种绘画类型的数量，我们可以看到相当强的相关性:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/75f513196fe45fc0324b0d77863befd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4G3vdnxZ716Oe8A_ygjdjA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自作者。平均边缘点数。</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/77658bda12a6eaa55d2b712135110b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0qDcgf7Pdc9khZ9Q7kcUIw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自作者。平均相交数。</p></figure><p id="c856" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">我们还可以看到，我们对具有大约 2 个边缘点的健康曲线的初始估计也是正确的。帕金森波图有非常多的边缘点，因为这些通常非常“尖锐”而不是平滑地弯曲，这在这些波的尖端产生了大量的边缘点。</p><p id="038c" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">最后，我们还可以检查骨架图像中像素总数的相关性。这与图纸的“间接”性质有关。这种量化非常简单，我们只需对骨架图像中大于零的像素求和。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/8057bb25bf19f039c72b8ae875af139d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4z0Tkx0TzXoV0lQeScqBQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自作者。平均像素数。</p></figure><p id="cb7e" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">没有一段感情那么牢固，但还是有意义的。</p><h2 id="5924" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">摘要</h2><p id="1741" class="pw-post-body-paragraph mi mj iq mk b ml mm ka mn mo mp kd mq lo mr ms mt ls mu mv mw lw mx my mz na ij bi nb translated"><span class="l ma mb mc bm md me mf mg mh di">因此</span>到目前为止，我们已经读入、清理并获得了一些潜在有用的指标，这些指标不仅有助于我们了解缩微程度，还可以用作分类器(如逻辑回归或随机森林)的输入。在本系列的第 2 部分中，我们将使用这些度量标准进行分类，并与一个更强大的黑盒神经网络进行比较。使用随机森林的优势在于，我们还可以看到哪些功能对模型的影响最大。根据以上观察，你是否已经有了直觉，知道哪些特性可能是最重要的？</p><p id="8910" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">如果你觉得这篇文章的任何部分提供了一些有用的信息或一点灵感，请关注我。</p><p id="1071" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">你可以在我的<a class="ae le" href="https://github.com/robintwhite" rel="noopener ugc nofollow" target="_blank"> github </a>上找到源代码。<em class="nn">该项目目前仍在建设中。</em></p><p id="667c" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">链接到我的其他帖子:</p><ul class=""><li id="495d" class="ow ox iq mk b ml nd mo ne lo oy ls oz lw pa na pb pc pd pe bi translated"><a class="ae le" rel="noopener" target="_blank" href="/computer-vision-and-the-ultimate-pong-ai-e6d70153fc45">计算机视觉和终极 Pong AI</a>——使用 Python 和 OpenCV 在线玩 Pong</li><li id="e489" class="ow ox iq mk b ml pf mo pg lo ph ls pi lw pj na pb pc pd pe bi translated"><a class="ae le" href="https://medium.com/analytics-vidhya/minecraft-mapper-ab4478e98297" rel="noopener">《我的世界》测绘仪</a> —计算机视觉和光学字符识别从截图和绘图中抓取位置</li></ul><h2 id="23fd" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">奖金</h2><p id="d64c" class="pw-post-body-paragraph mi mj iq mk b ml mm ka mn mo mp kd mq lo mr ms mt ls mu mv mw lw mx my mz na ij bi translated">这里不使用，但为了好玩，我们也可以创建一个图形来表示每个图像，因为我们有节点和边，其中节点是交叉点或边点，边是连接这些点的绘图部分。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ov"><img src="../Images/6ad14a0e5e99c029effcccb3de7fab1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4A-AeppbcN7H5w5tU8GqjA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自作者。网络图的绘制。</p></figure><p id="b4cd" class="pw-post-body-paragraph mi mj iq mk b ml nd ka mn mo ne kd mq lo nf ms mt ls ng mv mw lw nh my mz na ij bi translated">我们为此使用了 Networkx 库，其中每个数字要么是一个节点，要么是交叉点，其颜色对应于连接节点的绘图部分的长度。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h2 id="2187" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">参考</h2><p id="7deb" class="pw-post-body-paragraph mi mj iq mk b ml mm ka mn mo mp kd mq lo mr ms mt ls mu mv mw lw mx my mz na ij bi translated">[1] Zham P，Kumar DK，Dabnichki P，Poosapadi Arjunan S，Raghav S. <em class="nn">利用画螺旋的速度和笔压综合指数区分帕金森病的不同阶段</em>。前神经元。2017;8:435.发布于 2017 年 9 月 6 日。doi:10.3389/fneur . 2017.00435<br/>【2】Mader，K. <em class="nn">帕金森素描概述。</em><a class="ae le" href="https://www.kaggle.com/kmader/parkinsons-drawings" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/kmader/parkinsons-drawings</a>。获取日期:2020 年 7 月 9 日</p></div></div>    
</body>
</html>