<html>
<head>
<title>Understanding Crossword Puzzles with OpenCV, OCR, and DNNs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 OpenCV、OCR 和 DNNs 理解纵横字谜</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-crossword-puzzles-with-opencv-ocr-and-dnns-f7dd759650b2?source=collection_archive---------49-----------------------#2020-06-06">https://towardsdatascience.com/understanding-crossword-puzzles-with-opencv-ocr-and-dnns-f7dd759650b2?source=collection_archive---------49-----------------------#2020-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b769" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你能教机器如何阅读填字游戏吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/062998f8f5b117eeba31c575a80e3335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LSm21YfOF41fxgnVehsV_g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/zlbB-anyO3I" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/zlbB-anyO3I</a></p></figure><p id="0a33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">简介</strong></p><p id="7e04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我被分配了一个任务，创建一个算法，从纵横字谜照片中提取所有可能的元数据。这对我来说似乎是个有趣的任务，所以我决定试一试。以下是这篇博客将要涉及的话题:</p><ul class=""><li id="053a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">基于 OpenCV 的纵横细胞检测与提取</li><li id="3de4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Pytorch CNN 纵横字谜细胞分类</li><li id="dcaf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">单元元数据提取</li></ul><p id="3f24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="http://artkulakov.com" rel="noopener ugc nofollow" target="_blank">我的网站</a>和我的<a class="ae ky" href="https://github.com/artkulak/crossword-data-extraction" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到完整的代码实现。</p><p id="3d4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">纵横字谜细胞检测</strong></p><p id="6b04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，要提取元数据，您必须了解它的位置。为此，我使用简单的 OpenCV 试探法来识别纵横字谜上的线条，并用这些线条形成一个单元格网格。输入图像需要足够大，以便可以容易地检测到所有的线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/1e48f0d24bfc57a9b8b4e8b76f66e7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIL5uUYcTqISIjtlwAjplQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">同一图像上的输入图像和输出行</p></figure><p id="9a6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，对于细胞检测，我找到了线之间的交叉点，并根据交叉点形成了细胞。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/034bbfbcb6bd726d26604c499733593a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_QU8i7rKdlYT4ZvgYvUWyQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像线交点</p></figure><p id="aaf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在这一阶段，每个细胞都从图像中切下，并保存为一个单独的文件，以供进一步操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/8ebdcbe65e8f9589a0ddecfa444acc99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oab-hqz7uDbGmxrg0NH8Kg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从单个图像中提取的细胞</p></figure><p id="63fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">用 PyTorch CNN 进行纵横字谜细胞分类</strong></p><p id="f3d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于细胞分类，一切都很简单。该问题被建模为具有以下目标的多类分类问题:</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="8a8c" class="mq mr it mm b gy ms mt l mu mv">{0: 'both', 1: 'double_text', 2: 'down', 3: 'inverse_arrow', 4: 'other', 5: 'right', 6: 'single_text'}</span></pre><p id="3943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个目标类，我为每个类手工标记了大约 100 个单元格。之后，我用以下架构安装了一个简单的 PyTorch CNN 模型:</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="f3ce" class="mq mr it mm b gy ms mt l mu mv">class Net(nn.Module):<br/>    # Pytorch CNN model class<br/>    def __init__(self):<br/>        super(Net, self).__init__()<br/>        self.conv1 = nn.Conv2d(3, 6, 3)<br/>        self.pool = nn.MaxPool2d(2, 2)<br/>        self.conv2 = nn.Conv2d(6, 16, 3)<br/>        <br/>        self.conv3 = nn.Conv2d(16, 32, 5)<br/>        self.conv4 = nn.Conv2d(32, 64, 5)<br/>        <br/>        <br/>        self.dropout = nn.Dropout(0.3)<br/>        <br/>        self.fc1 = nn.Linear(64*11*11, 512)<br/>        self.bnorm1 = nn.BatchNorm1d(512)<br/>        <br/>        self.fc2 = nn.Linear(512, 128)<br/>        self.bnorm2 = nn.BatchNorm1d(128)<br/>        <br/>        self.fc3 = nn.Linear(128, 64)<br/>        self.bnorm3 = nn.BatchNorm1d(64)<br/>        <br/>        self.fc4 = nn.Linear(64, 7)<br/>    def forward(self, x):<br/>        x = F.relu(self.conv1(x))<br/>        x = self.pool(F.relu(self.conv2(x)))<br/>        <br/>        x = F.relu(self.conv3(x))<br/>        x = self.pool(F.relu(self.conv4(x)))<br/>        <br/>        x = x.view(-1, 64*11*11)<br/>        x = self.dropout(x)<br/>        x = F.relu(self.bnorm1(self.fc1(x)))<br/>        x = F.relu(self.bnorm2(self.fc2(x)))<br/>        x = F.relu(self.bnorm3(self.fc3(x)))<br/>        x = self.fc4(x)<br/>        return x</span></pre><p id="9ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的模型预测几乎是下降的，甚至在不同格式的填字游戏中也能很好地概括。</p><p id="e080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">单元元数据提取</strong></p><p id="3192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的最后一步是从标记的单元格中提取所有元数据。为此，我首先以 Pandas DataFrame 格式创建了每个图像单元的分类表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/49548b12ff9f2f28419a3ba4184719cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-ulHUWplXkCnR9VHjsWYw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像单元文本表示</p></figure><p id="7949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，基于 cell 类，我或者使用 Pytesseract 从图像中提取文本，或者如果单元格被归类为箭头单元格之一，则提取箭头坐标和方向。</p><p id="3cc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该脚本的结果输出以 JSON 格式显示如下:</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="bab1" class="mq mr it mm b gy ms mt l mu mv">{“definitions”: <br/>[{“label”: “F Faitune |”, “position”: [0, 2], “solution”:{“startPosition”: [0, 3], “direction”: “down”}}, <br/>{“label”: “anceur”, “position”: [0, 4], “solution”: {“startPosition”: [1, 4], “direction”: “down”}}]<br/>}</span></pre><p id="73e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结论</strong></p><p id="b24b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这项工作对我来说是一次很好的经历，并提供了一个很好的机会来深入研究一项混合了简单的 OpenCV 试探法以及使用更前沿的概念(如 OCR 和 DNNs)进行图像分类的任务。谢谢你的阅读！</p><p id="522e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在我的 <a class="ae ky" href="http://artkulakov.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">网站</strong> </a>上查看其他帖子</p></div></div>    
</body>
</html>