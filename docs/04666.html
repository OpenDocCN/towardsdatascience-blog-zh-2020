<html>
<head>
<title>How to simply make an operation on pandas DataFrame faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何简单快捷地对熊猫数据帧进行操作</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-simply-make-an-operation-on-pandas-dataframe-faster-adaea5e41e96?source=collection_archive---------17-----------------------#2020-04-25">https://towardsdatascience.com/how-to-simply-make-an-operation-on-pandas-dataframe-faster-adaea5e41e96?source=collection_archive---------17-----------------------#2020-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9274" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在这篇文章中，我将介绍并评估不同的 python 方法，以便在 pandas 中运行相同的函数并创建新的列。这些方法将在数值和非数值运算中进行检查。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/449534390ef6826012e08b30a4aa8626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h9mA9-RWk9XiRNS2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Marc Sendra Martorell 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="78f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你以前有过足够大的数据集，你就会知道有时一个简单的操作需要很多时间。有很多方法可以使熊猫数据帧上的操作更快。你可以使用像 multiprocessing，modin[ray]，cuDF，Dask，Spark 这样的库来完成这项工作。此外，您可以修改您的算法，以更快地执行任务。但是在寻求一个困难的解决方案之前，让我们看看有没有简单的方法来获得更高的速度和节省一些时间！</p><p id="c26f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于我的数据集，我用的是<a class="ae ky" href="https://www.kaggle.com/snap/amazon-fine-food-reviews" rel="noopener ugc nofollow" target="_blank">T5 这个 T7 的一部分。它有两个数字列和一个文本列，由“HelpfulnessNumerator”列中的 0 和“ProfileName”列中的 NaN 组成。(数据集和所有笔记本都已经上传到了</a><a class="ae ky" href="https://github.com/MINIMALaq/FasterPandasOperation" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">这个 Github </strong> </a>资源库中。)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/51f6d0f2bb53e13a71c6cb2d6ac58808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JWcIc85Sis5LcBuh0Jbdqw.png"/></div></div></figure><h1 id="89d4" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">数值运算</h1><p id="754c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我想在不改变主函数的情况下简单地检查不同的方法。数字部分的函数是一个除法函数。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9fa0" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">def</strong> divide(t,h):<br/>    <strong class="mu iu">if</strong> h == 0:<br/>        <strong class="mu iu">return</strong> np.nan<br/>    <strong class="mu iu">return</strong> t/h</span></pre><p id="d2f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在处理熊猫数据帧时学到的第一件事是 df.iterrows()</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ee38" class="my lx it mu b gy mz na l nb nc">%%timeit<br/>iterrows_divide = []<br/><strong class="mu iu">for</strong> index,row <strong class="mu iu">in</strong> df.iterrows():<br/>    Time = row['Time']<br/>    HelpfulnessNumerator = row['HelpfulnessNumerator']<br/>    iterrows_divide.append(divide(Time,HelpfulnessNumerator))<br/>5min 12s ± 31.1 s per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="32d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">apply()方法是另一个选项:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c8ee" class="my lx it mu b gy mz na l nb nc">%timeit df.apply(<strong class="mu iu">lambda</strong> row: divide(row['Time'],row['HelpfulnessNumerator']),axis = 1)</span><span id="cd12" class="my lx it mu b gy nd na l nb nc">1min 25s ± 4.88 s per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="9cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pandas 行操作中最好的选择是 itertuples()方法:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5107" class="my lx it mu b gy mz na l nb nc">%%timeit<br/>itertuples_divide = []<br/><strong class="mu iu">for</strong> _ <strong class="mu iu">in</strong> df.itertuples():<br/>    Time = getattr(_,'Time')<br/>    HelpfulnessNumerator = getattr(_,'HelpfulnessNumerator')<br/>    itertuples_divide.append(divide(Time,HelpfulnessNumerator))</span><span id="ba55" class="my lx it mu b gy nd na l nb nc">4 s ± 238 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="65f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数情况下，我们并不强制使用按行操作。但如果对你来说是必须的，df.itertuples()是最快的方法。</p><p id="c3f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试 map()方法:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="76a5" class="my lx it mu b gy mz na l nb nc">%timeit list(map(divide,df['Time'],df['HelpfulnessNumerator']))</span><span id="1915" class="my lx it mu b gy nd na l nb nc">861 ms ± 22.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="39e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们做一些(假的)numpy 矢量器()方法:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9dbd" class="my lx it mu b gy mz na l nb nc">%timeit np.vectorize(divide)(df['Time'],df['HelpfulnessNumerator'])</span><span id="b10e" class="my lx it mu b gy nd na l nb nc"><br/>636 ms ± 24.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="1fda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以对(实)numpy 矢量器使用 numpy where()方法:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8823" class="my lx it mu b gy mz na l nb nc">%timeit np.where(df['HelpfulnessNumerator'] == 0 , 0 , df['Time']/df['HelpfulnessNumerator'])</span><span id="682d" class="my lx it mu b gy nd na l nb nc">21.6 ms ± 329 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><p id="824c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们不能在任何地方使用 np.where()方法。但是真的很快。让我们稍微改变一下函数:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="59ad" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">def</strong> modified_divide(t,h):<br/>    <strong class="mu iu">return</strong> t/h</span></pre><p id="e625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在 np.where()中使用这个函数:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ba0f" class="my lx it mu b gy mz na l nb nc">%timeit np.where(df['HelpfulnessNumerator'] == 0 , 0 , modified_divide(df['Time'],df['HelpfulnessNumerator']))</span><span id="5b20" class="my lx it mu b gy nd na l nb nc">21.4 ms ± 200 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><p id="6163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以直接用 pandas 操作这个函数:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="48ae" class="my lx it mu b gy mz na l nb nc">%timeit modified_divide(df['Time'],df['HelpfulnessNumerator'])</span><span id="774f" class="my lx it mu b gy nd na l nb nc">8.75 ms ± 114 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="91f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他选择吗？绝对是的。如果你能用 Python 写代码，你就能用 Fortran 写代码。我在 Jupyter 笔记本里为 Fortran magic 做了一个<a class="ae ky" href="https://github.com/MINIMALaq/FasterPandasOperation/blob/master/FortranMagic.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">笔记本</strong> </a>。举个例子，看看这个:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1dc6" class="my lx it mu b gy mz na l nb nc">%%fortran<br/><br/>subroutine fortran_divide(x, y, z)<br/>    real, intent(<strong class="mu iu">in</strong>) :: x,y<br/>    real, intent(out) :: z<br/>    <br/>    z = x/y<br/>    IF ( 0 .EQ. Y ) THEN <br/>         Z = 0<br/>    END IF<br/>    <br/>    <br/>end subroutine fortran_divide</span><span id="cdbe" class="my lx it mu b gy nd na l nb nc">%timeit np.vectorize(fortran_divide)(df['Time'],df['HelpfulnessNumerator'])</span><span id="70bb" class="my lx it mu b gy nd na l nb nc">669 ms ± 22.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="c9b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用 numba。Numba 是一个 python 库，我们可以非常直接地使用它。它比 np.where()快 2 倍，而且这里没有 np.where()的一些限制:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8a70" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">from</strong> <strong class="mu iu">numba</strong> <strong class="mu iu">import</strong> njit<br/><br/>@njit()<br/><strong class="mu iu">def</strong> divide(t, h):<br/>    res = np.empty(t.shape)<br/>    <strong class="mu iu">for</strong> i <strong class="mu iu">in</strong> range(len(t)):<br/>        <strong class="mu iu">if</strong> h[i] != 0:<br/>            res[i] = t[i] / h[i]<br/>        <strong class="mu iu">else</strong>:<br/>            res[i] = 0<br/>    <strong class="mu iu">return</strong> res<br/><br/>%timeit divide(df['Time'].values, df['HelpfulnessNumerator'].value</span><span id="51ef" class="my lx it mu b gy nd na l nb nc">9.99 ms ± 133 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="a41f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">numba 和 Fortran 都可以选择使用多处理的能力。这取决于数据帧的大小和操作。有时候我们可以使用多重处理来获得更快的速度，而有时候 numba 和 Fortran 中的多重处理对我们没有太大帮助。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/bd5271a2b83870ff6ff4dc809f4f4695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cAr0NQlccFlDXEOIce3r3Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每种方法的对数时间。</p></figure><blockquote class="nf"><p id="4f78" class="ng nh it bd ni nj nk nl nm nn no lu dk translated">总之，不要在 pandas 数据帧上使用逐行操作。如果是必须的，可以使用 df.itertuples()。永远不要使用 df.iterrows()和 df.apply(…，axis=1)。</p><p id="e46a" class="ng nh it bd ni nj np nq nr ns nt lu dk translated"><strong class="ak">大部分时候可以用 np.where()搭配一些小技巧。这是最好的选择。但是如果不能使用，可以在进行数值运算的同时使用 np.vectorize()。</strong></p><p id="dc2e" class="ng nh it bd ni nj np nq nr ns nt lu dk translated"><strong class="ak">如果我们有一个很大的数据集，有一些其他的选项可以帮助我们，比如 numba 和 Fortran magics，值得花一些时间去学习和使用它们。</strong></p><p id="cb2a" class="ng nh it bd ni nj np nq nr ns nt lu dk translated">另外，有时候熊猫本身也支持我们想要的。先查熊猫比较好。:)</p></blockquote><h1 id="3f00" class="lw lx it bd ly lz ma mb mc md me mf mg jz nu ka mi kc nv kd mk kf nw kg mm mn bi translated"><strong class="ak">非数值运算</strong></h1><p id="dc86" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我将定义一个简单的函数来评估不同的方法。该函数将在每条记录的开头添加一个短语。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f1ec" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">def</strong> edit_name(profileName):<br/>    <strong class="mu iu">if</strong> profileName != profileName:<br/>        <strong class="mu iu">return</strong> np.nan<br/>    <strong class="mu iu">return</strong> 'Name is <strong class="mu iu">{}</strong>'.format(profileName)</span></pre><p id="eb45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用 df.iterrows()很简单。但是它太慢了:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="19c0" class="my lx it mu b gy mz na l nb nc">%%timeit<br/>iterrows_name=[]<br/><strong class="mu iu">for</strong> index,row <strong class="mu iu">in</strong> df.iterrows():<br/>    name = edit_name(row['ProfileName'])<br/>    iterrows_name.append(name)</span><span id="2617" class="my lx it mu b gy nd na l nb nc">4min 15s ± 2.45 s per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="91fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用逐行应用方法():</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8a27" class="my lx it mu b gy mz na l nb nc">%timeit df.apply(<strong class="mu iu">lambda</strong> row: edit_name(row['ProfileName']),axis = 1)</span><span id="ef60" class="my lx it mu b gy nd na l nb nc">43.2 s ± 687 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="606e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用 itertuples()方法:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="765e" class="my lx it mu b gy mz na l nb nc">%%timeit<br/>itertuples_name=[]<br/><strong class="mu iu">for</strong> _ <strong class="mu iu">in</strong> df.itertuples():<br/>    name = edit_name(getattr(_,'ProfileName'))<br/>    itertuples_name.append(name)</span><span id="4cb6" class="my lx it mu b gy nd na l nb nc">3.78 s ± 128 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="802d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种使用 apply()的方法:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3d8b" class="my lx it mu b gy mz na l nb nc">%timeit df['ProfileName'].apply(<strong class="mu iu">lambda</strong> x: edit_name(x))</span><span id="0108" class="my lx it mu b gy nd na l nb nc">1.58 s ± 86.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="5778" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用 map()方法:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3344" class="my lx it mu b gy mz na l nb nc">%timeit list(map(edit_name,df['ProfileName']))</span><span id="8758" class="my lx it mu b gy nd na l nb nc">1.41 s ± 65.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="8ebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哎呀，np.vectorizer 没有我们预期的那么快。是的，因为运算不是数值的。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="73fd" class="my lx it mu b gy mz na l nb nc">%timeit np.vectorize(edit_name)(df['ProfileName'])</span><span id="6dff" class="my lx it mu b gy nd na l nb nc">2.16 s ± 155 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="ebd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一只<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.map.html" rel="noopener ugc nofollow" target="_blank">熊猫。可以非常快速地完成有限任务的 Series.map </a>。它可以自己处理 NaN 值。例如，让我们更改函数并查看结果:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e4bc" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">def</strong> modified_edit_name(profileName):<br/>    <strong class="mu iu">return</strong> 'Name is <strong class="mu iu">{}</strong>'.format(profileName)</span></pre><p id="99fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在 np.where()中轻松处理 NaN 值:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="84c5" class="my lx it mu b gy mz na l nb nc">%timeit np.where(df['ProfileName'] == np.nan,np.nan, modified_edit_name(df['ProfileName']))</span><span id="caa3" class="my lx it mu b gy nd na l nb nc">2.69 s ± 98.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="ba63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫系列地图方法:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f7e0" class="my lx it mu b gy mz na l nb nc">%timeit df['ProfileName'].map('Name is <strong class="mu iu">{}</strong>'.format, na_action='ignore')</span><span id="5ac4" class="my lx it mu b gy nd na l nb nc">1.16 s ± 50.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/560a91bc42336591445eda7b21e0226b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVVt7Vo5LzP794uOrN2cTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每种方法的对数时间。</p></figure><blockquote class="nf"><p id="e385" class="ng nh it bd ni nj nk nl nm nn no lu dk translated"><strong class="ak">说到文字，我更喜欢用 map()，因为它速度快。如果我必须进行行操作，我将使用 df.itertuples()。</strong></p></blockquote><p id="2664" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">正如我所说的，在这个简单的优化之后，我们可以在应用多重处理和使用其他库之后对 pandas DataFrame 进行更快的操作。</p><p id="559f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于 numba 和 Fortran magic 的更多信息，请看这里:</p><div class="od oe gp gr of og"><a href="http://numba.pydata.org/numba-doc/0.15.1/examples.html" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">示例- numba 0.15.1 文档</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">假设我们想用 Python 写一个图像处理函数。下面是它可能的样子。Numba 实际上产生了两个…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">numba.pydata.org</p></div></div></div></a></div><div class="od oe gp gr of og"><a href="https://github.com/mgaitan/fortran_magic" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">mgaitan/fortran_magic</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">使用 f2py，用 Fortran 代码编译和导入单元格中的符号。单元格的内容被写入 a .f90…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="http://arogozhnikov.github.io/2015/11/29/using-fortran-from-python.html" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">从 python 使用 fortran</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">我喜欢 numpy(python 中数值计算的核心库)，但在一些非常罕见的情况下，我需要实现…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">arogozhnikov.github.io</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div></div></div>    
</body>
</html>