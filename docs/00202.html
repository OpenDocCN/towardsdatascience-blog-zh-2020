<html>
<head>
<title>Mathematical Analysis of Reinforcement Learning — Bellman Optimality Equation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强化学习的数学分析——贝尔曼最优方程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mathematical-analysis-of-reinforcement-learning-bellman-equation-ac9f0954e19f?source=collection_archive---------2-----------------------#2020-01-07">https://towardsdatascience.com/mathematical-analysis-of-reinforcement-learning-bellman-equation-ac9f0954e19f?source=collection_archive---------2-----------------------#2020-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9a8e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">度量空间，柯西序列，压缩映射和Banach不动点定理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/307626a3e5709359db89a93505cdb654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ZsAUGZWWJVxdCY9ih28OA.jpeg"/></div></div></figure><p id="ec44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">强化学习在玩星际争霸(AlphaStar)和围棋(AlphaGO)这样的游戏中取得了显著的效果。所有这些成功项目的核心在于——马尔可夫决策过程(MDPs)的贝尔曼最优<em class="ln"> </em>方程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/78e37766c271e01664e960b826504a30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*T0Qjv2C12xIUe3Dp"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">贝尔曼最优方程</p></figure><p id="ea0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">贝尔曼最优<em class="ln"> </em>方程是一个递归方程，可以使用动态规划(DP)算法来求解，以找到最优值函数和最优策略。在本文中，我将尝试解释为什么贝尔曼最优方程可以通过提供最优策略来解决每个MDP，并对其进行简单(希望如此)的数学分析。</p><h1 id="529a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">记号</h1><ul class=""><li id="ae56" class="ml mm iq kt b ku mn kx mo la mp le mq li mr lm ms mt mu mv bi translated"><code class="fe mw mx my mz b">S</code>是状态空间。</li><li id="98e4" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated"><code class="fe mw mx my mz b">V</code>是价值函数。</li><li id="d3da" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated"><code class="fe mw mx my mz b">V*</code>是最优值函数。</li><li id="cc45" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated"><code class="fe mw mx my mz b">V(s)</code>是状态<code class="fe mw mx my mz b">s</code>的值。</li><li id="b7e8" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated"><code class="fe mw mx my mz b">π</code>是政策。</li><li id="1fd8" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated"><code class="fe mw mx my mz b">π*</code>是上策。</li><li id="4b82" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated"><code class="fe mw mx my mz b">π(s)</code>返回策略<code class="fe mw mx my mz b">π</code>下状态<code class="fe mw mx my mz b">s</code>的动作。</li><li id="57a1" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated"><code class="fe mw mx my mz b">P</code>是转移概率矩阵。</li><li id="6d67" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated"><code class="fe mw mx my mz b">A</code>是动作空间。</li></ul><h1 id="16a0" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">先决条件</h1><p id="56f7" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">尽管我尽了最大努力，但分析还是相当严谨的，我认为读者应该熟悉以下附加条件:</p><ol class=""><li id="0bd6" class="ml mm iq kt b ku kv kx ky la ni le nj li nk lm nl mt mu mv bi translated">马尔可夫决策过程(MDP)</li><li id="92e4" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm nl mt mu mv bi translated">贝尔曼方程及其如何使用迭代法求解。</li><li id="242e" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm nl mt mu mv bi translated">RL基础——价值函数、奖励、政策、折扣系数等。</li><li id="deda" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm nl mt mu mv bi translated">线性代数</li><li id="1002" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm nl mt mu mv bi translated">向量演算</li></ol><h1 id="2cb6" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">概观</h1><p id="3e87" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">如果您研究过RL和MDP，您一定遇到过这样的说法:<strong class="kt ir"> <em class="ln">“对于每个MDP，总有至少一个策略优于或等于所有其他策略。”这既出现在萨顿和巴尔托的书中，也出现在大卫·西尔弗的系列讲座中。阅读/听到这些使这种说法变得非常直观，然而，我不得不更深入地挖掘并以更具体的方式理解这一点。因此，在本文中，我将从数学上证明以下定理:</em></strong></p><blockquote class="nm nn no"><p id="d1bf" class="kr ks ln kt b ku kv jr kw kx ky ju kz np lb lc ld nq lf lg lh nr lj lk ll lm ij bi translated"><strong class="kt ir">定理:</strong>对于任何有限的MDP，都存在一个最优策略π*，使得它优于或等于其他所有可能的策略π。</p></blockquote><p id="844a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在找到最佳策略之前，我们需要了解策略的排序。什么时候一种政策(<code class="fe mw mx my mz b">π1</code>)被认为比另一种(<code class="fe mw mx my mz b">π2</code>)更好？</p><p id="0add" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果对于环境中的每个状态，使用<code class="fe mw mx my mz b">π1</code>导出的状态的值好于或等于使用<code class="fe mw mx my mz b">π2</code>导出的状态的值，则称策略π1优于策略<code class="fe mw mx my mz b">π2</code>。从数学上讲，这可以写成如下形式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/27521f31b4247134605b856ce4ccd49d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/0*kuZ2WWfnE04GNjta"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">政策比较</p></figure><p id="bd7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然我们知道如何比较政策，我们需要证明总有一个政策比所有其他政策更好。</p><p id="4d86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用<strong class="kt ir"> Banach不动点定理</strong>来证明这一点，通过表明<strong class="kt ir"> Bellman最优算子</strong>是具有度量<strong class="kt ir">L-无穷范数</strong>的实数的<strong class="kt ir">完全度量空间</strong>上的<strong class="kt ir">收缩</strong>。为此，我们将首先讨论关于<strong class="kt ir">柯西序列</strong>的<strong class="kt ir">不动点问题</strong>和<strong class="kt ir">完备度量空间</strong>。</p><p id="4f07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的段落听起来很吓人，但是一旦我们掌握了基本的术语，它实际上会变得非常简单和直观。我们将讨论以上段落中用粗体字表示的所有内容。让我们遵循自下而上的方法，学习每个概念并克服我们的恐惧:</p><h2 id="60b3" class="nt lu iq bd lv nu nv dn lz nw nx dp md la ny nz mf le oa ob mh li oc od mj oe bi translated">1.不动点问题</h2><p id="15b8" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">我相信我们大多数人都熟悉求方程根的问题。我们求解<code class="fe mw mx my mz b">x</code>使得函数<code class="fe mw mx my mz b">f(x) = 0</code>。然而，在定点问题中，我们对<code class="fe mw mx my mz b">x</code>进行求解，使得<code class="fe mw mx my mz b">f(x) = x</code>。顾名思义，<code class="fe mw mx my mz b">x</code>是一个固定点，它即使在函数的应用上也不会改变。一个不动点问题可以通过形成另一个函数<code class="fe mw mx my mz b">g(x) = f(x)-x = 0</code>转化为一个求根问题。事实上，即使是求根问题也可以转换回不动点问题。然而，解决不动点问题真的很容易(对于特殊情况)，这就是为什么它们非常有趣和有用(没有计算开销)。</p><blockquote class="nm nn no"><p id="a4d4" class="kr ks ln kt b ku kv jr kw kx ky ju kz np lb lc ld nq lf lg lh nr lj lk ll lm ij bi translated">解决一个不动点问题，选择一个随机的起始值x，重复应用f(x)无限次。如果<strong class="kt ir">函数收敛</strong>并且你很幸运，你会找到解决方案。</p></blockquote><p id="7193" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从数学上讲，这很简单，让我们首先描述一个符号:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/f7eb5c28e9d94effb430aabd59971fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bfM0gLp4qLTdEeBe"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">f^n(x)符号</p></figure><p id="3ce4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果函数是收敛的，那么它一定会收敛到某个值，比如说，<code class="fe mw mx my mz b">x*</code>。这个值，<code class="fe mw mx my mz b">x*</code>确实是不动点问题的解，如下所示:</p><p id="f7c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们选择任意值<code class="fe mw mx my mz b">x0</code>并对<code class="fe mw mx my mz b">x0</code>应用函数<code class="fe mw mx my mz b">f(.)</code>无限次以得到<code class="fe mw mx my mz b">x*</code>，然后用它来解决不动点问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/960134eb1cbe109039e7a3721ad6b12d.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/0*nrYAj4LAtRMN9xnl"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">解决不动点问题</p></figure><p id="7799" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这背后的直觉很简单，如果一个函数在某个点收敛，那么这个函数在这个点的值就是这个点本身。所以，收敛点就是不动点本身。</p><p id="6f64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这也可以从下面的笔记本中观察到:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="153f" class="nt lu iq bd lv nu nv dn lz nw nx dp md la ny nz mf le oa ob mh li oc od mj oe bi translated">2.度量空间</h2><p id="8342" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">度量空间就是一个集合，其中定义了度量来度量该集合中任意两个元素之间的距离。例如，欧几里得空间是一个度量空间，其距离被定义为实数集合中的欧几里得距离。因此，度量空间<code class="fe mw mx my mz b">M</code>被表示为<code class="fe mw mx my mz b">(X, d)</code>，其中<code class="fe mw mx my mz b">X</code>是集合而<code class="fe mw mx my mz b">d</code>是某种度量。度量标准<code class="fe mw mx my mz b">d</code>必须满足以下特性:</p><ol class=""><li id="a5d5" class="ml mm iq kt b ku kv kx ky la ni le nj li nk lm nl mt mu mv bi translated"><strong class="kt ir">识别</strong> <code class="fe mw mx my mz b">d(x,x) = 0</code></li><li id="f8cd" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm nl mt mu mv bi translated"><strong class="kt ir">非否定性</strong>T10】</li><li id="cf50" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm nl mt mu mv bi translated"><strong class="kt ir">对称性</strong> : <code class="fe mw mx my mz b">d(x,y) = d(y,x)</code></li><li id="a12b" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm nl mt mu mv bi translated"><strong class="kt ir">三角形不等式</strong> : <code class="fe mw mx my mz b">d(x,z) ≤ d(x,y)+d(y,z)</code></li></ol><h2 id="4678" class="nt lu iq bd lv nu nv dn lz nw nx dp md la ny nz mf le oa ob mh li oc od mj oe bi translated"><strong class="ak"> 3。柯西序列</strong></h2><p id="8391" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">对于度量空间<code class="fe mw mx my mz b">(X, d)</code>，集合<code class="fe mw mx my mz b">X</code>，<code class="fe mw mx my mz b">(x1, x2, x3…. xn)</code>的元素序列是柯西序列，如果对于每个正实数<code class="fe mw mx my mz b"><em class="ln">ε</em></code>，<em class="ln">，</em>存在一个整数<code class="fe mw mx my mz b">N</code>，使得以下等式成立:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/8dc7c1d938f37f758568262265370aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/0*FTtwhA_tCzlAhGTi"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">柯西序列</p></figure><p id="9e2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里的数学解释不是很直观，也没有必要复杂。简而言之，度量空间的元素序列是柯西的，如果这个序列收敛于某点(它们之间的距离变成常数)。关于这一点，另一个很好的解释是由本网站给出的，内容如下:<em class="ln">“对于任何小的距离，都有一个特定的指数，超过这个指数，任何两个术语都在彼此的距离之内，这抓住了术语变得接近的直观想法。”</em>“项变得接近”的思想是级数收敛或极限背后的基本直觉。</p><h2 id="3b8d" class="nt lu iq bd lv nu nv dn lz nw nx dp md la ny nz mf le oa ob mh li oc od mj oe bi translated">4.完全度量空间</h2><p id="cfb2" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">如果集合<code class="fe mw mx my mz b">X</code>中元素的每个可能的柯西序列收敛到也属于集合<code class="fe mw mx my mz b">X</code>的元素，则度量空间<code class="fe mw mx my mz b">(X, d)</code>是完备的。也就是说，集合的元素的每一个柯西序列的收敛极限都在于集合本身。这就是为什么它被称为“完整”。</p><h2 id="ea95" class="nt lu iq bd lv nu nv dn lz nw nx dp md la ny nz mf le oa ob mh li oc od mj oe bi translated">5.收缩</h2><p id="e639" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">如果存在某个常数<code class="fe mw mx my mz b">γ∈[0,1)</code>使得对于度量空间<code class="fe mw mx my mz b">x1</code>和<code class="fe mw mx my mz b">x2</code>的任意两个元素，以下条件成立，则定义在度量空间<code class="fe mw mx my mz b">(X, d)</code>的元素上的函数(或算子或映射)是收缩函数(或收缩函数):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/01c01a7fb9e5cc56dc1e18dea2b23ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/0*7IOymgHqqiNSWZRw"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">收缩映射</p></figure><p id="ff5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着在元素<code class="fe mw mx my mz b">x1</code>和<code class="fe mw mx my mz b">x2</code>上应用了映射<code class="fe mw mx my mz b">f(.)</code>之后，它们至少通过因子<code class="fe mw mx my mz b">γ</code>和<em class="ln">彼此更加接近。</em>还有，这样一个常数<code class="fe mw mx my mz b"><em class="ln">γ</em></code> <em class="ln"> </em>的最小值叫做Lipschitz常数(这是一个对于生成式对抗性网络很重要的常数)。同样，如果<code class="fe mw mx my mz b"><em class="ln">γ=</em>1</code>，映射不再是收缩而是短映射。直观地，可以观察到在应用收缩映射之后，元素的顺序值越来越接近。</p><h2 id="bfcb" class="nt lu iq bd lv nu nv dn lz nw nx dp md la ny nz mf le oa ob mh li oc od mj oe bi translated">6.Banach不动点定理</h2><p id="a8e0" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">这是我们证据的核心。非正式地，这个定理说，对于一个完全的度量空间，在集合的元素上一次又一次地应用收缩符，将最终使我们得到一个最优的、唯一的值。我们知道:</p><ol class=""><li id="1049" class="ml mm iq kt b ku kv kx ky la ni le nj li nk lm nl mt mu mv bi translated">承包商将布景的元素组合在一起。</li><li id="37d8" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm nl mt mu mv bi translated">一次又一次地使用这个承包商，会得到一个序列。(柯西？)</li><li id="4559" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm nl mt mu mv bi translated">完备度量空间中的柯西序列总是收敛于度量空间中的一个值。</li></ol><p id="e481" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">形式上，这个定理可以表述为:</p><blockquote class="nm nn no"><p id="e24b" class="kr ks ln kt b ku kv jr kw kx ky ju kz np lb lc ld nq lf lg lh nr lj lk ll lm ij bi translated">定理:设(X，d)是完备度量空间且函数f: X-&gt;X是收缩子那么，f有一个<strong class="kt ir">唯一的</strong>不动点x*∈ X(即f(x*)=x*)使得序列f(f(f(…f(x)))) <strong class="kt ir">收敛</strong>到x*。</p></blockquote><p id="9e22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，为了从数学上证明这一点，我们需要证明<code class="fe mw mx my mz b">x*</code>的唯一性和存在性。</p><ol class=""><li id="c55d" class="ml mm iq kt b ku kv kx ky la ni le nj li nk lm nl mt mu mv bi translated"><strong class="kt ir">唯一性</strong>:我们用矛盾来证明这一点。假设收敛值不是唯一的，并且<code class="fe mw mx my mz b">x1*</code>和<code class="fe mw mx my mz b">x2*</code>是承包商序列收敛的两个值，那么我们将有:</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/6f126ce957db22202c577fc90d00c6be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/0*ruVGcasQPJe6z2va"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">x1*和x2*是最佳值，承包商已收敛于此，距离不再改变</p></figure><p id="8be4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，请注意<code class="fe mw mx my mz b">f</code>是一个承包商，因此它必须持有以下财产:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/7df99517d5a794ae8707db93b13043ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/0*ugqPWZxboWHHFHhf"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">承包商财产</p></figure><p id="32a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在由于<code class="fe mw mx my mz b">γ∈[0,1)</code>，不可能同时满足等式1和2。因此，我们的假设一定是错误的。因此，通过矛盾，<code class="fe mw mx my mz b">x*</code>一定是独特的。</p><p id="2788" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.存在:现在我们已经证明了<code class="fe mw mx my mz b">x*</code>是唯一的，我们需要证明<code class="fe mw mx my mz b">x*</code>存在。设<code class="fe mw mx my mz b">(x1, x2, x3, …. xn)</code>为重复申请承包人形成的序列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/daa7da95e0aa7e3d814075437199772b.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/0*f4sXaskJH3a8xp_J"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">我们度量空间的一个元素</p></figure><p id="11c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们<strong class="kt ir">假设</strong>序列<code class="fe mw mx my mz b">(x1, x2, x3, …. xn)</code>是柯西，我们肯定知道这个序列会收敛到某个点，比如说<code class="fe mw mx my mz b">x*</code>。同样，由于度量空间是完整的，这个收敛点<code class="fe mw mx my mz b">x*</code>将属于度量空间<code class="fe mw mx my mz b">(X,d)</code>。现在，我们只需要证明这个序列是柯西序列。我们将这样做:取集合中的两个元素<code class="fe mw mx my mz b">xn</code>和<code class="fe mw mx my mz b">xm</code>，使得<code class="fe mw mx my mz b">m&gt;&gt;n </code>和<code class="fe mw mx my mz b">m</code>非常大，然后通过重复应用度量<code class="fe mw mx my mz b">d</code>的三角不等式属性，我们得到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/fcf9d7281a3de98cc637ea1e38512ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vCjHiFblQDMpUuyM"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">度量d的三角不等式的推广</p></figure><p id="80f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，由于f是承包商，我们知道:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/20e5b53628d36cb4a05fed0773d23d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WcB3YP3RxQ-ZLdTF"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">重复的承包商不等式</p></figure><p id="ba80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以进一步简化<code class="fe mw mx my mz b">d(xm, xn)</code>如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/6f5c8e06a8eee6d5eeae94505d13489d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1Bnvnq4OXBqFkrMz"/></div></div></figure><p id="0be9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，通过选择足够大的<code class="fe mw mx my mz b">n</code>，我们可以使上述等式的RHS小于任何正实数<code class="fe mw mx my mz b"><em class="ln">ε</em></code> <em class="ln">。因此，序列<code class="fe mw mx my mz b">(x1, x2, x3, …. xn)</code>是柯西的，并且存在一个最优的<code class="fe mw mx my mz b">x*∈X</code>。这就结束了Banach不动点定理的证明。</em></p><h1 id="82cb" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">回到贝尔曼最优方程</h1><p id="fa55" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">对于价值函数，<code class="fe mw mx my mz b">V(s)</code>我们定义了一个新的算子，最优贝尔曼算子，<code class="fe mw mx my mz b">B</code>，它接受一个价值函数并返回另一个价值函数。我们将该运算符定义如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/52bf8f448fe0f31cc11c23443d2263f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KCZ0j11Rra4OSsvq"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">行李员接线员</p></figure><p id="b285" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很容易观察到，<code class="fe mw mx my mz b">B</code>是一个递归运算符。因此，这将产生一系列的价值函数。如果我们可以证明<code class="fe mw mx my mz b">B</code>确实是某个度量空间<code class="fe mw mx my mz b">(X,d)</code>的收缩者，那么通过Banach不动点定理，我们可以得出结论:最优Bellman算子的重复应用将最终给出唯一的最优值函数，使用该函数可以导出最优(最佳)策略。因此，我们现在所有的工作都归结为证明<code class="fe mw mx my mz b">B</code>是一个承包商。首先，让我们如下定义度量空间:</p><p id="2b59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">度量空间</strong> <code class="fe mw mx my mz b">(X,d)</code>:集合<code class="fe mw mx my mz b">X</code>是实数的集合，定义如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/efbb3184e994357e592290e66441fe78.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/0*GYp-qWRybn_2CCSc"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">价值函数属于实数集。底部的X表示完整值函数的集合，而顶部的X表示单一状态的值集合。</p></figure><p id="3360" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于度量，我们使用定义如下的<a class="ae ok" href="https://en.wikipedia.org/wiki/L-infinity" rel="noopener ugc nofollow" target="_blank">L-无穷大</a>范数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/c5aaedae5ed1c7857b79104a2cee6cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/0*4vuuN5qmjx1OKZNc"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">l-无穷范数</p></figure><p id="0289" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据这个度量，两个值函数之间的距离将等于两者之间的最高元素绝对差。此外，对于具有有限回报的有限MDP，价值函数将总是停留在实空间中。价值函数不可能不在实空间，因此，这个有限空间永远是完备的。</p><blockquote class="nm nn no"><p id="5ce4" class="kr ks ln kt b ku kv jr kw kx ky ju kz np lb lc ld nq lf lg lh nr lj lk ll lm ij bi translated"><strong class="kt ir">定理</strong> : Bellman算子<code class="fe mw mx my mz b">B</code>是有限空间中的压缩映射<code class="fe mw mx my mz b">(R, L-infinity)</code></p></blockquote><p id="6f40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">证明:设<code class="fe mw mx my mz b">V1</code>和<code class="fe mw mx my mz b">V2</code>是两个值函数。然后:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/46b49a0f047f0afd9f256f0b315c5fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lEtVgLe1CSJ8z3vs"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">B是收缩的证明</p></figure><ul class=""><li id="7ee7" class="ml mm iq kt b ku kv kx ky la ni le nj li nk lm ms mt mu mv bi translated">在上面的第二步中，我们通过将第二个值函数的<code class="fe mw mx my mz b">a’</code>替换为<code class="fe mw mx my mz b">a</code>来引入不等式。这是因为通过用一些其他动作<code class="fe mw mx my mz b">a</code>替换它的最优动作<code class="fe mw mx my mz b">a’</code>，我们减少了它的总价值，从而引入了一个不等式。</li><li id="cb09" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated">在第四步中，我们通过在<code class="fe mw mx my mz b">s’</code>上取最大值来移除L-无穷范数(回想一下我们设置中关于值函数的L-无穷的定义)</li><li id="4925" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated">在最后一步，我们删除了sigma，因为概率之和总是<code class="fe mw mx my mz b">1</code>。</li></ul><p id="b0f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，对于贝尔曼最优方程，由于<code class="fe mw mx my mz b">γ∈[0,1)</code>(让我们暂时忽略<code class="fe mw mx my mz b">γ=1</code>的可能性)，因此，贝尔曼算子是一个承包商。</p><p id="9e7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们知道:</p><ol class=""><li id="aa4d" class="ml mm iq kt b ku kv kx ky la ni le nj li nk lm nl mt mu mv bi translated"><code class="fe mw mx my mz b">(R, L-infinity)</code>是一个完备的度量空间</li><li id="8c7c" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm nl mt mu mv bi translated">行李员操作员<code class="fe mw mx my mz b">B</code>是承包商</li></ol><p id="6288" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，通过Banach不动点定理，我们得出结论，对于每个MDP，存在唯一的最优值函数<code class="fe mw mx my mz b">V*</code>。利用这个<code class="fe mw mx my mz b">V*</code>，我们可以得出最优策略<code class="fe mw mx my mz b">π*</code>。</p><p id="aa38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此证明了，对于任何有限的MDP，存在一个最优策略<code class="fe mw mx my mz b">π*</code>，使得它优于或等于所有其他可能的策略<code class="fe mw mx my mz b">π</code>。</p><p id="1557" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如何找到这个最优政策和价值函数？一种方法是将Bellman算子反复应用于随机初始值函数，以获得最优函数。但是，这在计算上非常昂贵，并且通常完全不可行。因此，我们使用迭代方法，如值和策略迭代，或时间差分方法，如Q-Learning或SARSA。有关这方面的更多信息，请参考我的博客<a class="ae ok" rel="noopener" target="_blank" href="/reinforcement-learning-temporal-difference-sarsa-q-learning-expected-sarsa-on-python-9fecfda7467e#eccc">强化学习:时态差异，SARSA，Q-Learning &amp;预期的python中的SARSA</a>或者只是在我的Github上查看这些算法:<a class="ae ok" href="https://github.com/TimeTraveller-San/RL_from_scratch" rel="noopener ugc nofollow" target="_blank"> RL_from_scratch </a>。</p><h1 id="e288" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="1127" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">我们学习了一些基本的数学工具，如度量空间，完全度量空间，柯西序列，压缩映射和Banach不动点定理。在所有这些的基础上，我们从数学上证明了每个MDP的贝尔曼最优方程的唯一最优性。</p><h1 id="8120" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">参考文献和致谢</h1><ul class=""><li id="2c52" class="ml mm iq kt b ku mn kx mo la mp le mq li mr lm ms mt mu mv bi translated">我使用<a class="ae ok" href="https://latex.codecogs.com/eqneditor/editor.php" rel="noopener ugc nofollow" target="_blank">https://latex.codecogs.com/eqneditor/editor.php</a>为LaTeX生成图像。(但愿介质允许乳胶)</li><li id="303e" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated">维基百科提供了所有的正式定义和定理。</li><li id="b03c" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated">CMU 15–781号<a class="ae ok" href="https://www.cs.cmu.edu/~ninamf/courses/401sp18/prev.shtml" rel="noopener ugc nofollow" target="_blank">赛道</a></li><li id="5783" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated">丹尼尔·默菲特博士的<a class="ae ok" href="http://therisingsea.org/notes/mast30026/lecture14.pdf" rel="noopener ugc nofollow" target="_blank">笔记</a>和<a class="ae ok" href="https://www.youtube.com/watch?v=gsM7PPBx16k" rel="noopener ugc nofollow" target="_blank">视频</a></li><li id="f5e2" class="ml mm iq kt b ku na kx nb la nc le nd li ne lm ms mt mu mv bi translated">巴拉拉曼·拉温德兰博士和IIT·马德拉斯教授的免费网络电话课程</li></ul><h1 id="f6bc" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">尾注</h1><p id="0ab5" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">我试图用尽可能简单的语言解释一切。如果我不清楚或者我犯了一些错误，请在回复中告诉我。此外，在乳胶方程中可能会有一些错误。如果你找到他们，请让我知道。最后但同样重要的是，感谢阅读！</p></div></div>    
</body>
</html>