<html>
<head>
<title>Neural Implanting With AutoEncoders and TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用自动编码器和张量流的神经植入</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/neural-implanting-with-autoencoders-and-tensorflow-9c2c7b532198?source=collection_archive---------41-----------------------#2020-08-10">https://towardsdatascience.com/neural-implanting-with-autoencoders-and-tensorflow-9c2c7b532198?source=collection_archive---------41-----------------------#2020-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f674" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">🤖<a class="ae ep" href="https://equipintelligence.medium.com/list/deep-learning-techniques-methods-and-how-tos-01015cf5f917" rel="noopener">深度学习</a></h2><div class=""/><div class=""><h2 id="b7ee" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用自动编码器的图像重建(使用跳跃连接)</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/2113fd1003a37c72b6dea55424759839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vWkfYzq3QH5x-mIl"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@kalenemsley?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡伦·艾姆斯利</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="47ed" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">直觉</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ma"><img src="../Images/ac3d18a8963015c2859915e6ee751f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5FL1xui72lTHE5__"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">马库斯·温克勒在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3c92" class="pw-post-body-paragraph mb mc it md b me mf kd mg mh mi kg mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">想象你正在解决一个拼图游戏。你已经完成了大部分。假设你需要在一张图片的中间固定一块(这张图片快完成了)。你需要从盒子里选择一件适合这个空间的物品，并完成整幅画。</p><p id="d382" class="pw-post-body-paragraph mb mc it md b me mf kd mg mh mi kg mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">我相信你能很快做到这一点。但是你的大脑是怎么做到的呢？</p><p id="29ac" class="pw-post-body-paragraph mb mc it md b me mf kd mg mh mi kg mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">首先，它分析空槽周围的图片(在那里你需要固定一块拼图)。如果图片中有一棵树，你会寻找一个绿色的块(这是显而易见的！).因此，简而言之，我们的大脑能够通过了解图像的<em class="mx">周围环境</em>来预测作品(将适合该槽)。</p><blockquote class="my mz na"><p id="7c60" class="mb mc mx md b me mf kd mg mh mi kg mj nb ml mm mn nc mp mq mr nd mt mu mv mw im bi translated">在本教程中，我们的模型将执行类似的任务。它将学习图像的上下文，然后使用这个学习的上下文预测图像的一部分(丢失的)。</p></blockquote><h2 id="7f5d" class="ne lj it bd lk nf ng dn lo nh ni dp ls mk nj nk lu mo nl nm lw ms nn no ly iz bi translated">代码实现</h2><p id="bb93" class="pw-post-body-paragraph mb mc it md b me np kd mg mh nq kg mj mk nr mm mn mo ns mq mr ms nt mu mv mw im bi translated">我建议你应该在另一个标签中打开这个笔记本(TF 实现),这样你就能对正在发生的事情有一个直觉。</p><div class="nu nv gp gr nw nx"><a href="https://colab.research.google.com/drive/1zFe9TmMCK2ldUOsVXenvpbNY2FLrLh5k#scrollTo=UXjElGKzyiey&amp;forceEdit=true&amp;sandboxMode=true" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd jd gy z fp oc fr fs od fu fw jc bi translated">谷歌联合实验室</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">编辑描述</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">colab.research.google.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol lb nx"/></div></div></a></div><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om on l"/></div></figure><h1 id="94bb" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">问题陈述</h1><p id="ac73" class="pw-post-body-paragraph mb mc it md b me np kd mg mh nq kg mj mk nr mm mn mo ns mq mr ms nt mu mv mw im bi translated">我们希望我们的模型能够预测图像的一部分。给定一个有洞的图像(图像数组的一部分，只包含零)，我们的模型将预测完整的原始图像。</p><p id="4136" class="pw-post-body-paragraph mb mc it md b me mf kd mg mh mi kg mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">因此，我们的模型将使用它在训练期间学习的上下文来重建图像的丢失部分。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/f59862b863942ac84d0b340b6d6102a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cA4-fmuhc3Ecxt_yBPVclQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><h1 id="9ada" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">数据</h1><p id="8153" class="pw-post-body-paragraph mb mc it md b me np kd mg mh nq kg mj mk nr mm mn mo ns mq mr ms nt mu mv mw im bi translated">我们将为我们的任务选择一个域。我们在<a class="ae lh" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上选择了一些山脉图像，它们是<a class="ae lh" href="https://www.kaggle.com/puneet6060/intel-image-classification" rel="noopener ugc nofollow" target="_blank">英特尔图像分类</a>数据集的一部分。</p><blockquote class="my mz na"><p id="ca8a" class="mb mc mx md b me mf kd mg mh mi kg mj nb ml mm mn nc mp mq mr nd mt mu mv mw im bi translated">为什么只有山脉的图像？</p><p id="6163" class="mb mc mx md b me mf kd mg mh mi kg mj nb ml mm mn nc mp mq mr nd mt mu mv mw im bi translated">这里，我们选择属于特定领域的图像。如果我们选择一个在野生的图像中有<em class="it">的数据集，我们的模型将不能很好地执行。因此，我们将其限制在单个域中。</em></p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/09482ab5904243bb85cf263c5702fa13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ed5rw3UX0gEFHZfx_ouukg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数据集中的一些图像。作者图片</p></figure><p id="9a69" class="pw-post-body-paragraph mb mc it md b me mf kd mg mh mi kg mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">使用<code class="fe oq or os ot b">wget</code>下载我在 GitHub 上托管的数据</p><pre class="ks kt ku kv gt ou ot ov ow aw ox bi"><span id="52d8" class="ne lj it ot b gy oy oz l pa pb">!wget <a class="ae lh" href="https://github.com/shubham0204/Dataset_Archives/blob/master/mountain_images.zip?raw=true" rel="noopener ugc nofollow" target="_blank">https://github.com/shubham0204/Dataset_Archives/blob/master/mountain_images.zip?raw=true</a> -O images.zip</span><span id="a8a4" class="ne lj it ot b gy pc oz l pa pb">!unzip images.zip</span></pre><p id="753b" class="pw-post-body-paragraph mb mc it md b me mf kd mg mh mi kg mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">为了生成训练数据，我们将遍历数据集中的每个图像，并对其执行以下任务。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/a45a118dd261f5bd21349352a378ee8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tiLaI638QOe5xKu7CnWkw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><ol class=""><li id="659b" class="pd pe it md b me mf mh mi mk pf mo pg ms ph mw pi pj pk pl bi translated">首先，我们将使用<code class="fe oq or os ot b">PIL.Image.open()</code>读取我们的图像文件。使用<code class="fe oq or os ot b">np.asarray()</code>将这个<code class="fe oq or os ot b">Image</code>对象转换成一个 NumPy 数组。</li><li id="7e8b" class="pd pe it md b me pm mh pn mk po mo pp ms pq mw pi pj pk pl bi translated">确定窗口大小。这将是我们要从原始图像中提取的正方形的边长。</li><li id="0fae" class="pd pe it md b me pm mh pn mk po mo pp ms pq mw pi pj pk pl bi translated">在<code class="fe oq or os ot b">[ 0 , image_dim — window_size ]</code>范围内产生 2 个随机数。其中<code class="fe oq or os ot b">image_dim</code>是我们的正方形输入图像的大小。</li><li id="94e9" class="pd pe it md b me pm mh pn mk po mo pp ms pq mw pi pj pk pl bi translated">这两个数字(称为<code class="fe oq or os ot b">px</code>和<code class="fe oq or os ot b">py</code>)是原始图像将被裁剪的位置。选择图像数组的一部分，并用零数组替换它。</li></ol><p id="7699" class="pw-post-body-paragraph mb mc it md b me mf kd mg mh mi kg mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">代码看起来像这样，</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om on l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">1.准备培训数据。</p></figure><h1 id="733d" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">带跳跃连接的自动编码器型号</h1><p id="e729" class="pw-post-body-paragraph mb mc it md b me np kd mg mh nq kg mj mk nr mm mn mo ns mq mr ms nt mu mv mw im bi translated">我们将跳过连接添加到我们的自动编码器模型中。这些跳跃连接提供了更好的上采样。通过使用最大池层，许多空间信息在进入编码器时会丢失。为了从图像的潜在表示(由编码器产生)中重建图像，我们添加了跳过连接，将信息从编码器带到解码器。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om on l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">2.自动编码器模型。</p></figure><p id="d780" class="pw-post-body-paragraph mb mc it md b me mf kd mg mh mi kg mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">最后，我们用跳过连接来训练我们的自动编码器模型，</p><pre class="ks kt ku kv gt ou ot ov ow aw ox bi"><span id="1878" class="ne lj it ot b gy oy oz l pa pb">model.fit( x_train , y_train , epochs=150 , batch_size=25 , validation_data=( x_test , y_test ) )</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/86912969e11fc84335b327d910f3b3ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0b_nbmznOqqbufU92wvFfA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="34cd" class="pw-post-body-paragraph mb mc it md b me mf kd mg mh mi kg mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">上述结果是在一些测试图像上获得的。我们观察到模型几乎已经学会了如何填充黑盒！但我们仍能辨认出盒子在原始图像中的位置。这样，我们可以构建一个模型来预测图像中缺失的部分。</p><h1 id="07fd" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">进一步阅读</h1><p id="625f" class="pw-post-body-paragraph mb mc it md b me np kd mg mh nq kg mj mk nr mm mn mo ns mq mr ms nt mu mv mw im bi translated">如果你喜欢这个博客，请确保你在媒体上读到更多我的故事。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om on l"/></div></figure><h1 id="60af" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">仅此而已！</h1><p id="9b30" class="pw-post-body-paragraph mb mc it md b me np kd mg mh nq kg mj mk nr mm mn mo ns mq mr ms nt mu mv mw im bi translated">这只是自动编码器的一个很酷的应用。我从<a class="ae lh" href="https://youtu.be/9zKuYvjFFS8?t=317" rel="noopener ugc nofollow" target="_blank">这里</a>得到了这个视频的灵感。感谢阅读！</p></div></div>    
</body>
</html>