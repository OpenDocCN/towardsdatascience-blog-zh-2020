<html>
<head>
<title>Julia’s Most Awesome Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朱莉娅最令人敬畏的特征</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/julias-most-awesome-features-be51f798f140?source=collection_archive---------20-----------------------#2020-05-23">https://towardsdatascience.com/julias-most-awesome-features-be51f798f140?source=collection_archive---------20-----------------------#2020-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="047a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Julia编程语言中我最喜欢的五个特性。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bc3cb9fee405bc38bd567d3d9f4bf8e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erbJbE_Jf8KH8u8c2Th0Yw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(茱莉亚logo src =<a class="ae ky" href="http://julialang.org" rel="noopener ugc nofollow" target="_blank">http://julialang.org</a>，茱莉亚格普logo src =<a class="ae ky" href="https://github.com/JuliaGPU" rel="noopener ugc nofollow" target="_blank">https://github.com/JuliaGPU</a>)</p></figure><p id="11af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编程语言的范围包括编程概念和范例。许多语言利用它们的范例以及有趣的泛型编程概念来创建特性，以区别于其他语言。然而，这些特性通常范围有限，有时使用频率不够高，甚至没有存在的理由。</p><p id="e831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Julia编程语言是一个有趣的例子，因为与大多数语言不同，Julia有一些致命的定义特性，这些特性使它能够做各种你可能想不到的事情。虽然Julia语言使用了一大堆奇妙的特性，但这是我认为最有用和最吸引人的五个特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1cd1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">№1:宏</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/42a3e5faebeefce2d453c460e184a3b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*e1ggYxQlGwtUu7uC5o9olw.png"/></div></figure><p id="02ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管宏对于编程来说肯定不是一个新概念，但它们在Julia中的实现是相当独特的，而且在我看来做得相当好。宏是可以用来快速有效地访问函数的“快捷方式”，在处理Julia语言的函数应用程序时非常有用。在Julia中，只需使用“macro”就可以定义一个宏。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="5015" class="na md it mw b gy nb nc l nd ne">macro add(num1,num2)<br/>   num1 + num2 <br/>end</span></pre><p id="c8de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过在宏名前添加@符号来使用宏。参数可以添加空格，不需要括号或逗号！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/844c458adf53064f17295c9a6cfc0d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*LZCdsjFaZy2nRygO55WXzQ.png"/></div></figure><h1 id="e816" class="mc md it bd me mf ng mh mi mj nh ml mm jz ni ka mo kc nj kd mq kf nk kg ms mt bi translated">№2:调度</h1><p id="a5b4" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">如果您熟悉Julia语言，并且相对地使用过它，那么您很可能熟悉Julia的高性能调度。使用Julia中的语法表达式，我们可以创建不同的函数，这些函数使用参数多态以相同的方法处理不同的类型。为此，我们只需使用等号运算符。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="0f4a" class="na md it mw b gy nb nc l nd ne">exampledispatch(x::Int64) = _int(x)<br/>exampledispatch(x::Float64) = _float(x)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/65fedb9834294ea9620caa0baae826d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*3Kn1Z3AMkU8umFU15JuPgA.png"/></div></figure><p id="5e97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于Julia的调度，你可能没有注意到一个惊人的副作用，那就是所有的Julia函数都可以在任何类型上通用。考虑这个例子:</p><blockquote class="nr ns nt"><p id="f1d1" class="kz la nu lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated">我想创建一个类型，它使用push函数将数据添加到包含在结构中的数组中。</p></blockquote><p id="87c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用力！()函数是Julia基础的一部分，而在大多数其他语言中，为了避免冲突，我们需要为我们的模块编写一个全新的标识符。使用该语言附带的标准库时尤其如此。但是，在Julia中，我们可以只发送push！()处理我们的类型:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="ecc8" class="na md it mw b gy nb nc l nd ne">push!(data,x::Type{ihavedatainme}) = _pushdata(data,x)</span></pre><h1 id="4e16" class="mc md it bd me mf ng mh mi mj nh ml mm jz ni ka mo kc nj kd mq kf nk kg ms mt bi translated">№3:语法表达</h1><p id="e2f2" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">甚至一些Julia程序员可能没有意识到这一点，但是语法表达式负责我们如何编写Julia代码背后的整个方法。本质上，使用语法表达式，我们可以设置任何表达式或变量等于任何表达式或变量。这也是dispatch的工作方式，因为我们所做的只是将一个方法的特定参数类型设置为对应的方法。</p><p id="4e9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，除了分派之外，我们还可以通过多种方式使用语法表达式。例如，我们可以将一个方法设置为一个表达式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/b4fefaa00d7bd927fca51421a24b40d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*QjWTG9J-lBF-WQoWTzzusA.png"/></div></figure><p id="2051" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想学习更多关于语法表达式的知识，并学习一些很酷的方法，我这里有一篇关于它们的文章:</p><div class="nz oa gp gr ob oc"><a rel="noopener follow" target="_blank" href="/syntactical-expressions-are-awesome-dc9ba5f25911"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">语法表达超赞！</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">利用朱莉娅语法的力量来断言任何事情。</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div><h1 id="4884" class="mc md it bd me mf ng mh mi mj nh ml mm jz ni ka mo kc nj kd mq kf nk kg ms mt bi translated">№4:元编程</h1><p id="7bf0" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">Julia以一种非常有趣的方式处理像元编程这样的概念。元编程和类似概念的包通常是分段的，但仍然包含在Julia的库中。这使得Julia的base在预编译时花费的时间少得多，同时仍然加载了令人敬畏的特性。为了在Julia中进行元编程，您应该从Meta.parse()和eval()这两个函数开始。Eval包含在Julia核心中，不需要导入，而Meta是包含在Base中的一个模块。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="288c" class="na md it mw b gy nb nc l nd ne">using Base.Meta</span></pre><p id="f37b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">评估元表达式的第一步是解析它。这将把一个常规字符串转换成eval()能够处理的表达式类型。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="c5b0" class="na md it mw b gy nb nc l nd ne">meta_code = "1 + 1"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/2fb5869a33b3de84bb6c2af603e62d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*PDEvp9Zob0JT2awEJqko3g.png"/></div></figure><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="018b" class="na md it mw b gy nb nc l nd ne">expression = Meta.parse(meta_code)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/bf64dadc10466f65debfb08ba1d878e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*JJyRoS-uqHj7Rso0h-GIZA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/ba3f56be6e3ec6aa5f9b067a28444eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*5nqugP4v32fVfRFeCrr0tQ.png"/></div></figure><h1 id="1f4a" class="mc md it bd me mf ng mh mi mj nh ml mm jz ni ka mo kc nj kd mq kf nk kg ms mt bi translated">№5:并行计算</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/d3520e186a779881620d2766614dd67e.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*FtSYHqkyF7ffnnrdiuKaZg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://github.com/JuliaGPU" rel="noopener ugc nofollow" target="_blank">https://github.com/JuliaGPU</a></p></figure><p id="2c4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，我明白了…并行计算本身并不一定是一个“特性”，但是Julia的并行计算令人印象深刻的是Julia Computing在这方面做了多么了不起的工作。与许多其他语言不同，Julia自带了大量的GPU支持。核心的Julia语言支持图形数组和处理，这是你在其他地方无法得到的。将并行计算紧密集成到Julia中，并使用专门设计的类型和函数来处理它，比在大多数语言中(这是事后才想到的)要强大得多。此外，Julia拥有各种用于并行计算的优秀包，以及CUDA和OpenCL等行业标准。</p><h1 id="d675" class="mc md it bd me mf ng mh mi mj nh ml mm jz ni ka mo kc nj kd mq kf nk kg ms mt bi translated">结论</h1><p id="c305" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">Julia编程语言有一大堆令人难以置信的特性，这些特性绝对让使用这种语言物有所值。有了所有独特的解决问题的方法，很少有时候你不能用这种语言创造性地完成一些事情。除此之外，Julia还拥有它通常所拥有的所有优势。这些是我最喜欢的，但是我也想知道其他程序员喜欢这种语言的什么。(想分享就留言评论吧！)</p></div></div>    
</body>
</html>