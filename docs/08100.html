<html>
<head>
<title>10 Techniques to Speed Up Python Runtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速 Python 运行时的 10 种技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-techniques-to-speed-up-python-runtime-95e213e925dc?source=collection_archive---------9-----------------------#2020-06-15">https://towardsdatascience.com/10-techniques-to-speed-up-python-runtime-95e213e925dc?source=collection_archive---------9-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a2fe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用代码<strong class="ak">运行时</strong>比较好的写法和不好的写法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1d109177a63c45b7a12092e41fff9113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PffPsm3w5aNzttd6Unf_g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">哈雷戴维森在 Unsplash 上拍摄的照片</p></figure><p id="8d65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python 是一种脚本语言。与 C/C++这样的编译语言相比，Python 在效率和性能上有一定的劣势。然而，我们可以使用一些技术来提高 Python 代码的效率。在本文中，我将向您展示我在工作中通常使用的加速技术。</p><p id="a761" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">测试环境是 Python 3.7，macOS 10.14.6，2.3 GHz 英特尔酷睿 i5。</p><h1 id="d3ed" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">0.优化原则</h1><p id="7d03" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在深入代码优化的细节之前，我们需要了解一些代码优化的基本原则。</p><ol class=""><li id="d371" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated"><strong class="la iu">先确认代码能正常工作。</strong>因为让正确的程序更快比让快程序正确容易得多。</li><li id="a1bf" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><strong class="la iu">权衡优化成本</strong>。优化是有代价的。例如，较少的运行时间通常需要更多的空间使用，或者较少的空间使用通常需要更多的运行时间。</li><li id="7bde" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><strong class="la iu">优化不能牺牲代码可读性。</strong></li></ol><h1 id="8bb4" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">1.Python 中正确的数据类型用法</h1><h2 id="e38c" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">1.1 用 set 替换 list 以检查元素是否在序列中</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6ec2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据 Python 的<a class="ae nt" href="https://wiki.python.org/moin/TimeComplexity" rel="noopener ugc nofollow" target="_blank"> TimeComplexity </a>可知<code class="fe nu nv nw nx b">list</code>的<code class="fe nu nv nw nx b">x in s</code>操作的平均情况为 O(n)。另一方面，<code class="fe nu nv nw nx b">set</code>的<code class="fe nu nv nw nx b">x in s</code>运算的平均情况是 O(1)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="16aa" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">1.2 用 defaultdict 初始化字典</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b1a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该使用<code class="fe nu nv nw nx b">defaultdict</code>进行初始化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="9701" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">2.用生成器表达式替换列表理解</h1><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="c21a" class="nf lv it nx b gy oc od l oe of"># Bad: 447ms<br/>nums_sum_list_comprehension = sum([num**2 for num in range(1000000)])</span><span id="9a5f" class="nf lv it nx b gy og od l oe of"># Good: 300ms<br/>nums_sum_generator_expression = sum((num**2 for num in range(1000000)))</span></pre><p id="041b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成器表达式的另一个好处是，我们可以在迭代之前获得结果，而无需在内存中构建和保存整个列表对象。换句话说，生成器表达式节省了内存使用。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="3cd8" class="nf lv it nx b gy oc od l oe of">import sys</span><span id="80b9" class="nf lv it nx b gy og od l oe of"># Bad<br/>nums_squared_list = [num**2 for num in range(1000000)]<br/>print(sys.getsizeof(nums_squared_list))  # 87632</span><span id="2ea7" class="nf lv it nx b gy og od l oe of"># Good<br/>nums_squared_generator = (num**2 for num in range(1000000))<br/>print(sys.getsizeof(nums_squared_generator))  # 128</span></pre><h1 id="2a63" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">3.用局部变量替换全局变量</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="40a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该把全局变量放入函数中。局部变量比全局变量快。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="2d50" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">4.避免点操作</h1><h2 id="76ce" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">4.1 避免功能访问</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="693b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每次我们用<code class="fe nu nv nw nx b">.</code>访问函数，都会触发特定的方法，像<code class="fe nu nv nw nx b">__getattribute__()</code>和<code class="fe nu nv nw nx b">__getattr__()</code>。这些方法将使用字典操作，这将导致时间成本。我们可以用<code class="fe nu nv nw nx b">from xx import xx</code>去掉这样的成本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="dbc2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据技术 3，我们也可以将全局函数分配给局部函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6469" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我们可以将<code class="fe nu nv nw nx b">list.append()</code>方法分配给一个局部函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="5617" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">4.2 避免类属性访问</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a8ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">访问<code class="fe nu nv nw nx b">self._value</code>的速度比访问局部变量慢。我们可以将 class 属性赋给一个局部变量来加快运行速度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="4df3" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">5.避免不必要的抽象</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b8a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当使用额外的处理层(如 decorators、property access、descriptors)来包装代码时，会使代码变慢。在大多数情况下，需要重新考虑是否有必要使用这些层。一些 C/C++程序员可能会遵循使用 getter/setter 函数来访问属性的编码风格。但是我们可以使用更简单的写作风格。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="8f31" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">6.避免数据重复</h1><h2 id="334c" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">6.1 避免无意义的数据复制</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0d2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">value_list</code>没有意义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="8724" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">6.2 更改值时避免使用 temp 变量</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5574" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">temp</code>是没有必要的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="2a11" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">6.3 连接字符串时，将<code class="fe nu nv nw nx b">+</code>替换为<code class="fe nu nv nw nx b">join()</code></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6ad6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe nu nv nw nx b">a + b</code>串接字符串时，Python 会申请内存空间，将 a 和 b 分别复制到新申请的内存空间。这是因为 Python 中的字符串数据类型是不可变的对象。如果连接<code class="fe nu nv nw nx b">n</code>字符串，将生成<code class="fe nu nv nw nx b">n-1</code>中间结果，每个中间结果将申请内存空间并复制新字符串。</p><p id="ffde" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，<code class="fe nu nv nw nx b"> join()</code>会节省时间。它会先计算出需要申请的总内存空间，然后一次性申请所需内存，将每个字符串元素复制到内存中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="801c" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">7.利用<code class="fe nu nv nw nx b">if</code>语句的短路评估</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="46ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python 使用<a class="ae nt" href="https://www.pythoninformer.com/python-language/intermediate-python/short-circuit-evaluation/" rel="noopener ugc nofollow" target="_blank">短路技术</a>来加速真值评估。如果第一个语句是假的，那么整个事情一定是假的，所以它返回那个值。否则，如果第一个值为真，它将检查第二个值并返回该值。</p><p id="a5ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，为了节省运行时间，我们可以遵循以下规则:</p><ul class=""><li id="8844" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt oh mx my mz bi translated"><code class="fe nu nv nw nx b">if a and b</code>:变量<code class="fe nu nv nw nx b">a</code>应该有很大概率为假，所以 Python 不会计算 b。</li><li id="c003" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt oh mx my mz bi translated"><code class="fe nu nv nw nx b">if a or b</code>:变量<code class="fe nu nv nw nx b">a</code>应该有更高的概率为真，所以 Python 不会计算 b。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="9590" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">8.循环优化</h1><h2 id="60e1" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">8.1 将<code class="fe nu nv nw nx b">while</code>替换为<code class="fe nu nv nw nx b">for</code></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4477" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">for</code>循环比<code class="fe nu nv nw nx b">while</code>循环快。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="f15e" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">8.2 用隐式 for 循环替换显式 for 循环</h2><p id="7311" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们用上面的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="42d9" class="nf lv it bd lw ng nh dn ma ni nj dp me lh nk nl mg ll nm nn mi lp no np mk nq bi translated">8.3 减少内部 for 循环的计算</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5e84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将<code class="fe nu nv nw nx b">sqrt(x)</code>从内部 for 循环移动到外部 for 循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="9311" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">9.使用 numba.jit</h1><p id="03e6" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Numba 可以将 Python 函数 JIT 编译成机器码执行，大大提高了代码的速度。想了解更多关于 numba 的信息，请看<a class="ae nt" href="http://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank">主页</a>。</p><p id="0079" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们用上面的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3a31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将<code class="fe nu nv nw nx b">sqrt(x)</code>从内部 for 循环移动到外部 for 循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="74a3" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">10.使用 cProfile 定位时间成本函数</h1><p id="9ea1" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">“cProfile”将输出每个功能的时间使用情况。所以我们可以找到时间成本函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><blockquote class="oi oj ok"><p id="6c0c" class="ky kz ol la b lb lc ju ld le lf jx lg om li lj lk on lm ln lo oo lq lr ls lt im bi translated"><strong class="la iu"> <em class="it">查看我的其他帖子</em> </strong> <a class="ae nt" href="https://medium.com/@bramblexu" rel="noopener"> <strong class="la iu"> <em class="it">中等</em> </strong> </a> <strong class="la iu"> <em class="it">同</em> </strong> <a class="ae nt" href="https://bramblexu.com/posts/eb7bd472/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> <em class="it">一分类查看</em> </strong> </a> <strong class="la iu"> <em class="it">！<br/>GitHub:</em></strong><a class="ae nt" href="https://github.com/BrambleXu" rel="noopener ugc nofollow" target="_blank"><strong class="la iu"><em class="it">bramble Xu</em></strong></a><strong class="la iu"><em class="it"><br/>LinkedIn:</em></strong><a class="ae nt" href="https://www.linkedin.com/in/xu-liang-99356891/" rel="noopener ugc nofollow" target="_blank"><strong class="la iu"><em class="it">徐亮</em> </strong> </a> <strong class="la iu"> <em class="it"> <br/>博客:</em></strong><a class="ae nt" href="https://bramblexu.com/" rel="noopener ugc nofollow" target="_blank"><strong class="la iu"><em class="it">bramble Xu</em></strong></a></p></blockquote><h1 id="ced9" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">参考</h1><ul class=""><li id="b3f1" class="mr ms it la b lb mm le mn lh op ll oq lp or lt oh mx my mz bi translated"><a class="ae nt" href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips" rel="noopener ugc nofollow" target="_blank">https://wiki.python.org/moin/PythonSpeed/PerformanceTips</a></li><li id="fdd1" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt oh mx my mz bi translated"><a class="ae nt" href="https://realpython.com/introduction-to-python-generators/#building-generators-with-generator-expressions" rel="noopener ugc nofollow" target="_blank">https://real python . com/introduction-to-python-generators/# building-generators-with-generator-expressions</a></li><li id="36dd" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt oh mx my mz bi translated">编写可靠的 Python 代码 91 建议</li><li id="9d04" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt oh mx my mz bi translated">Python 食谱，第三版</li><li id="fc73" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt oh mx my mz bi translated"><a class="ae nt" href="https://zhuanlan.zhihu.com/p/143052860" rel="noopener ugc nofollow" target="_blank">https://zhuanlan.zhihu.com/p/143052860</a></li><li id="ebad" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt oh mx my mz bi translated"><a class="ae nt" href="https://pybit.es/faster-python.html" rel="noopener ugc nofollow" target="_blank">https://pybit.es/faster-python.html</a></li></ul></div></div>    
</body>
</html>