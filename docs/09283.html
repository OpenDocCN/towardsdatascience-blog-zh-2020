<html>
<head>
<title>Five Python Features You (Probably) Didn’t Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你(可能)不知道的五个 Python 特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/five-python-features-you-probably-didnt-know-d48faa0b892e?source=collection_archive---------3-----------------------#2020-07-03">https://towardsdatascience.com/five-python-features-you-probably-didnt-know-d48faa0b892e?source=collection_archive---------3-----------------------#2020-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4850" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写更优雅、更高效代码的简单步骤</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6c6d764073a9d11d39c64e6e02b2500a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NymatKQCivniWp60"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@donramxn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉蒙·萨利内罗</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0c52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 大有可为。每周，我都会看到以我认为不可能的方式编写的代码。其中一些功能非常出色，我无法理解没有它们我是如何生活的——其他的功能知道了就好了。</p><p id="3406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将介绍其中一些不常用但仍然非常有用的功能，包括:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="91c2" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">Variable Assignments</strong> - with *args and **kwargs (incl. dictionary merging)<br/><strong class="lw iu">Frozensets</strong> - what they are and why they're useful<br/><strong class="lw iu">Multiple Conditionals</strong> - cleaner logic<br/><strong class="lw iu">Check if a Variable Exists</strong> - in both local and global scopes<br/><strong class="lw iu">Better than Lambdas</strong> - writing Pythonic and functional one liners</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4d2e" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">变量赋值</h1><p id="cc44" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">就像 function *args 和**kwargs 一样，我们可以在变量赋值中使用相同的语法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/922000e734544c2a613cb51d35be9d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*12vBaWIdiadjZQE2MGXPhA.png"/></div></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="2fdf" class="ma mb it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">合并两本词典</h2><p id="0a8c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">合并字典时，使用 iterable 变量赋值方法特别有用，我们可以使用**kwargs 语法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/6ed9b567669ad3ea8daad6d89f32307b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llOAGbWATVGlfnkKMDXysA.png"/></div></div></figure><p id="158e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们需要谨慎。如果两个字典之间有任何公共键，后面的键-值对(来自<code class="fe nv nw nx lw b">y</code>)将替换前面的。</p><p id="2589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着最新的<a class="ae ky" rel="noopener" target="_blank" href="/new-features-in-python39-2529765429fe">Python(3.9)</a>即将发布的版本，我们将获得一个全新的语法来解决这个问题——字典合并和更新操作符:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dc5a" class="ma mb it lw b gy mc md l me mf">z = <strong class="lw iu">x | y</strong>  # merge - same behavior as above<br/><strong class="lw iu">x |= y</strong>  # update - in-place dictionary merge</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="f2bd" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">冰冻集</h1><p id="cda6" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在 Python 中，我们可以使用集合，集合是不同对象的无序集合。这些集合是可变的，这意味着我们可以用<code class="fe nv nw nx lw b">add()</code>和<code class="fe nv nw nx lw b">remove()</code>来改变它们——这也意味着集合是不可改变的(稍后会详细介绍)。</p><p id="0043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可以使用不可变的<code class="fe nv nw nx lw b">frozenset()</code>——我们不能改变它的值。但是，因为它是不可变的，所以它是可散列的——当我们试图同时使用<code class="fe nv nw nx lw b">set</code>和<code class="fe nv nw nx lw b">frozenset</code>作为字典键时，就会显示这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/412f7d2bec77d1a09cfe40ab131d3127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JVpPhQlYmsn-jlyz2CsqwA.png"/></div></div></figure><p id="c289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，所以使用一个<code class="fe nv nw nx lw b">frozenset</code>作为字典键并没有那么有用(如果有人有这样做的理由，请告诉我！).但是<code class="fe nv nw nx lw b">frozenset</code>给我们的是更明确的、有意的代码。它警告未来的代码读者—</p><blockquote class="nz"><p id="5760" class="oa ob it bd oc od oe of og oh oi lu dk translated">改变我，一切都会破碎</p></blockquote><p id="9de1" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated"><em class="oo">有读者指出不止一个，而是两个</em><a class="ae ky" href="https://twitter.com/luke_binwalker/status/1279368482572943366" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="oo"/></strong><em class="oo">为此在推特上</em></a><em class="oo">——感谢！</em></p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="5a6c" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">多重条件句</h1><p id="8998" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">清理那些凌乱的<strong class="lb iu"> if 语句</strong>。而不是:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fe25" class="ma mb it lw b gy mc md l me mf">if 0 &lt;= x and x &lt;= 1:<br/>     print('value is %')</span></pre><p id="a0e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e13a" class="ma mb it lw b gy mc md l me mf">if (0 &lt;= x &lt;= 1):<br/>    print('value is %')</span></pre><p id="a75c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更进一步，我们可以添加更多的条件语句，并用按位运算符将它们连接在一起，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5652" class="ma mb it lw b gy mc md l me mf">if (0 &lt;= x &lt; 1) | (7 &lt;= x &lt; 8) | (x == 10):<br/>    print('passed')</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="74dd" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">检查变量是否存在</h1><p id="184e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">需要检查变量是否存在？</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6d93" class="ma mb it lw b gy mc md l me mf">if "var_name" in globals():<br/>    print("var_name exists!")</span><span id="2586" class="ma mb it lw b gy op md l me mf">elif "var_name" in locals():<br/>    print("var_name exists locally!")</span><span id="a663" class="ma mb it lw b gy op md l me mf">else:<br/>    print("var_name does not exist.")</span></pre><p id="1b69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以分别使用<code class="fe nv nw nx lw b">globals()</code>和<code class="fe nv nw nx lw b">locals()</code>来检查全局和局部范围内的变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/4b629f13140a661ab2931b56bb3c544d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSchX1YQvHI_m34Gd060Cw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查变量<strong class="bd or"> test1 </strong>和<strong class="bd or"> test2 </strong>是否存在于全局或局部范围内。</p></figure><p id="f0e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个作用域函数<code class="fe nv nw nx lw b">globals</code>和<code class="fe nv nw nx lw b">locals</code>都返回字典——所以我们也实现了上面的字典合并语法<code class="fe nv nw nx lw b">{**x, **y}</code>。然后我们的代码在这个合并的范围字典中检查<code class="fe nv nw nx lw b">test1</code>和<code class="fe nv nw nx lw b">test2</code>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="18f7" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">比兰姆达斯好</h1><p id="3edb" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">将 lambdas 用于快速简单的一行程序非常常见，但我很少看到它用于构建多参数函数。我们通常看到的是这样的:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a4c8" class="ma mb it lw b gy mc md l me mf">do_something = lambda x: x**2 / (1 - x)</span></pre><p id="c73c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是它们可以用来创建优雅的一行程序函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/fdac875909e55639cbad3db292c2933d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xb_y_lPKubWb0G8eZIfx4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 lambda 函数创建一个包含 Cochran 公式的单行样本量计算器。</p></figure><p id="a226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始到处编写 lambdas 之前，请注意这可能是 Python 中最讨厌的语法用法之一——所以让我们快速回顾一下。</p><p id="feac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.python.org/dev/peps/pep-0008/#programming-recommendations" rel="noopener ugc nofollow" target="_blank">PEP 8</a>—Python 的风格指南—<strong class="lb iu"/>强烈反对使用 lambda 作为<strong class="lb iu">命名函数</strong>。</p><p id="d56f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与此同时，单行函数，尤其是数学公式，可能看起来很神奇。</p><p id="a6c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们不使用<code class="fe nv nw nx lw b">lambda</code>，而是编写一行<code class="fe nv nw nx lw b">def</code>语句，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/b472d129f975cbc03daf0f297b71f8e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ssp-5K9mao0idS2pgPYWOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用单行 def 语句创建带有 Cochran 公式的样本大小计算器。</p></figure><p id="af47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你用哪种方法由你决定。如果你想让愤怒的暴徒拿着干草叉呼喊你的名字，使用<code class="fe nv nw nx lw b">lambda</code>——否则，使用<code class="fe nv nw nx lw b">def</code>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="b52a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们五个非常有用的 Python 特性—</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="97cf" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">Variable Assignments</strong><br/><strong class="lw iu">Frozensets</strong><br/><strong class="lw iu">Multiple Conditionals</strong><br/><strong class="lw iu">Check if a Variable Exists</strong><br/><strong class="lw iu">Better than Lambdas</strong></span></pre><p id="984d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望其中一些对你来说是新的，对你和对我一样有帮助。如果你想了解更多内容，我在<a class="ae ky" href="https://www.youtube.com/channel/UCv83tO5cePwHMt1952IVVHw" rel="noopener ugc nofollow" target="_blank"> YouTube 上发布了 Python 视频</a>！或者，如果你有任何问题，请随时通过<a class="ae ky" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或在下面的评论中联系我们。</p><p id="39b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="b9fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有兴趣了解更多关于 Python 的知识吗？</p><p id="b345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于 Python 中的 API，你需要知道的一切，或者 Python 中的<a class="ae ky" rel="noopener" target="_blank" href="/step-up-your-regex-game-in-python-1ec20c5d65f">高级正则表达式，怎么样？</a></p><div class="os ot gp gr ou ov"><a rel="noopener follow" target="_blank" href="/step-up-your-regex-game-in-python-1ec20c5d65f"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">用 Python 升级你的正则表达式游戏</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">Python 中使用正则表达式的高级文本操作</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">towardsdatascience.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div></div></div>    
</body>
</html>