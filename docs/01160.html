<html>
<head>
<title>Pool Limited Queue Processing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的池限制队列处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pool-limited-queue-processing-in-python-2d02555b57dc?source=collection_archive---------6-----------------------#2020-02-02">https://towardsdatascience.com/pool-limited-queue-processing-in-python-2d02555b57dc?source=collection_archive---------6-----------------------#2020-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4b9f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用预定义数量的线程并行处理数据</h2></div><p id="30a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最近遇到了一个问题:我需要构建大量(大约100个)Docker容器，然后将它们推送到注册中心。Docker SDK for Python提供了一个很好的处理方法，再加上“多重处理”库，可以非常有效地并行处理任务。然而，经过一些初步测试后，我发现将多个图像推送到注册表可能由于同时上传的过载而停止。在我的测试中，我只能同时运行2-3个<code class="fe lb lc ld le b">docker push</code>命令，直到我添加的所有新命令都停止。在这一点上，我决定将同步上传限制在少量的并行线程上，同时仍然利用大量的线程来促进映像构建。将工作从构建线程传递到推进线程的队列(<code class="fe lb lc ld le b">multiprocessing.Queue</code>)和线程池(<code class="fe lb lc ld le b">multiprocessing.Pool</code>)的组合看起来是一个最佳选择。然而，文档中有一些细微差别和空白，这让我花了一些时间去理解(尤其是在Windows上使用<code class="fe lb lc ld le b">multiprocessing</code>的时候)。下面，我提供了一个关于如何使用这些数据结构和对象的小教程。</p><p id="8fdd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">问题公式化</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/538313716b20e49be7ae05ed31958058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m-Fw9RrdxrrwluBwD8Au9w.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">算法设计</p></figure><p id="b1fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个玩具问题中，我们有大量并行进程将结果写入队列。除了它们之外，还有一个单线程读取器进程检查队列中的新项目，并将它们分配给池中的新进程，这样，只有一小部分固定数量的进程同时运行。让我们看一下下面的所有元素。</p><h1 id="4151" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><code class="fe lb lc ld le b">Process</code></h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mn"><img src="../Images/59293c7033a7fe06f18f536dffd200af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P1dZsZ1AyUwwU_dT"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">弗兰克·麦肯纳在<a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="cb4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于左侧的大量并行线程，我们将使用<code class="fe lb lc ld le b">multithreading.Process()</code>。来自官方<a class="ae mo" href="https://docs.python.org/3.7/library/multiprocessing.html#multiprocessing.Process" rel="noopener ugc nofollow" target="_blank">参考</a>:</p><blockquote class="mp mq mr"><p id="8c7d" class="kf kg ms kh b ki kj jr kk kl km ju kn mt kp kq kr mu kt ku kv mv kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Process</code>对象表示在独立进程中运行的活动。</p></blockquote><p id="1a6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">启动一个进程需要两件事:调用<strong class="kh ir">目标函数</strong>和<code class="fe lb lc ld le b"><strong class="kh ir">Process</strong></code> <strong class="kh ir">调用</strong>本身。让我们来看看:</p><pre class="lg lh li lj gt mw le mx my aw mz bi"><span id="10ed" class="na lw iq le b gy nb nc l nd ne">from multiprocessing import Process</span><span id="6df5" class="na lw iq le b gy nf nc l nd ne">def proc(i):<br/>    print(f'I am Process {i}')</span><span id="8a37" class="na lw iq le b gy nf nc l nd ne">if __name__ ==  '__main__':<br/>    for i in range(10):<br/>        Process(target=proc, args=(i,)).start()</span></pre><p id="de27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们创建了10个<code class="fe lb lc ld le b">Process</code> es并同时启动它们。每个进程都运行一个<code class="fe lb lc ld le b">proc()</code>函数的实例，其参数来自<code class="fe lb lc ld le b">arg</code>。因为执行的顺序没有得到保证，所以当我们运行它时，我们会得到类似这样的结果:</p><pre class="lg lh li lj gt mw le mx my aw mz bi"><span id="4a8d" class="na lw iq le b gy nb nc l nd ne">I am Process 6<br/>I am Process 2<br/>I am Process 0<br/>I am Process 3<br/>I am Process 7<br/>I am Process 4<br/>I am Process 8<br/>I am Process 1<br/>I am Process 5<br/>I am Process 9</span></pre><p id="d12d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还要注意<code class="fe lb lc ld le b">args=(i,)</code>有趣的语法。<code class="fe lb lc ld le b">Process</code>要求<code class="fe lb lc ld le b">args</code>是可迭代的，所以把它改成<code class="fe lb lc ld le b">args=(i)</code>或者<code class="fe lb lc ld le b">args=i</code>就会产生一个<code class="fe lb lc ld le b">TypeError</code>。</p><h1 id="f75f" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">长队</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ng"><img src="../Images/51d749b703327dc540683a2e4522c003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*afEJODLZGAOVPeHO"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae mo" href="https://unsplash.com/@halgatewood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈尔·盖特伍德</a>在<a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a608" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，是时候介绍一个<code class="fe lb lc ld le b">multithreading.Queue()</code>了。根据<a class="ae mo" href="https://docs.python.org/3.7/library/multiprocessing.html#multiprocessing.Queue" rel="noopener ugc nofollow" target="_blank">参考</a>:</p><blockquote class="mp mq mr"><p id="0882" class="kf kg ms kh b ki kj jr kk kl km ju kn mt kp kq kr mu kt ku kv mv kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Queue()</code>返回一个使用管道和一些锁/信号量实现的进程共享队列。</p></blockquote><p id="9abf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">队列允许我们将对象放入队列，并在别处异步处理它们。重要的是，队列是线程和进程安全的。让我们修改前面的例子，添加<code class="fe lb lc ld le b">Queue</code>对象，并将其传递给我们的并行<code class="fe lb lc ld le b">Process</code> es:</p><pre class="lg lh li lj gt mw le mx my aw mz bi"><span id="d530" class="na lw iq le b gy nb nc l nd ne">from multiprocessing import Process, Queue</span><span id="cef3" class="na lw iq le b gy nf nc l nd ne">def writer(i,q):<br/>    message = f'I am Process {i}'<br/>    q.put(message)</span><span id="c4e7" class="na lw iq le b gy nf nc l nd ne">if __name__ ==  '__main__':<br/>    # Create multiprocessing queue<br/>    q = Queue()<br/>    <br/>    # Create a group of parallel writers and start them<br/>    for i in range(10):<br/>        Process(target=writer, args=(i,q,)).start()</span><span id="dc59" class="na lw iq le b gy nf nc l nd ne">    # Read the queue sequentially<br/>    for i in range(10):<br/>        message = q.get()<br/>        print(message)</span></pre><p id="fd88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住<code class="fe lb lc ld le b">Queue.get()</code>是一个阻塞方法，所以我们不会错过队列中的任何消息。</p><p id="c448" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决我们问题的下一步是切换到从队列中并行读取。我们可以像产生写进程一样产生读进程，但是这将允许10个线程并行运行。如果像原问题描述中那样受限于较小的读者数量，该怎么办？</p><h1 id="d292" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">泳池</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nh"><img src="../Images/4e4bfb0f26723b3f749f8f9bb1167f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X334OFEde5qK8dXF"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated"><a class="ae mo" href="https://unsplash.com/@picsbyjameslee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">李中清</a>在<a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7cdc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输入<code class="fe lb lc ld le b"><a class="ae mo" href="https://docs.python.org/3.7/library/multiprocessing.html#multiprocessing.pool.Pool" rel="noopener ugc nofollow" target="_blank">multithreading.Pool()</a></code>:</p><blockquote class="mp mq mr"><p id="943d" class="kf kg ms kh b ki kj jr kk kl km ju kn mt kp kq kr mu kt ku kv mv kx ky kz la ij bi translated">"一个进程池对象，它控制一个可以提交作业的工作进程池。它支持带有超时和回调的异步结果，并具有并行映射实现”。</p></blockquote><p id="f511" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lb lc ld le b">Pool</code>,我们可以分配尽可能多的并行进程，但是在任何给定的时刻，只有“进程”数量的线程是活动的。</p><p id="3aaf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看，如果我们把所有的读者都扔到“池子”里，情况会怎样:</p><pre class="lg lh li lj gt mw le mx my aw mz bi"><span id="45ec" class="na lw iq le b gy nb nc l nd ne">from multiprocessing import Process, Queue, Pool</span><span id="f63f" class="na lw iq le b gy nf nc l nd ne">def writer(i,q):<br/>    message = f’I am Process {i}’<br/>    q.put(message)</span><span id="2760" class="na lw iq le b gy nf nc l nd ne">def reader(i,q):<br/>    message = q.get()<br/>    print(message)</span><span id="47e9" class="na lw iq le b gy nf nc l nd ne">if __name__ == ‘__main__’:<br/>    # Create multiprocessing queue<br/>    q = Queue()</span><span id="2e68" class="na lw iq le b gy nf nc l nd ne">    # Create a group of parallel writers and start them<br/>    for i in range(10):<br/>        Process(target=writer, args=(i,q,)).start()</span><span id="18e4" class="na lw iq le b gy nf nc l nd ne">    # Create multiprocessing pool<br/>    p = Pool(10)</span><span id="065d" class="na lw iq le b gy nf nc l nd ne">    # Create a group of parallel readers and start them<br/>    # Number of readers is matching the number of writers<br/>    # However, the number of simultaneously running<br/>    # readers is constrained to the pool size<br/>    <br/>    for i in range(10):<br/>        p.apply_async(reader, (i,q,))</span></pre><p id="2027" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果我们运行上面的代码，我们将不会得到任何输出。发生了什么事？当我们调用<code class="fe lb lc ld le b">apply_async</code>时，代码执行立即继续，因为主函数中没有留下任何东西，所以退出。谢天谢地，<code class="fe lb lc ld le b">multiprocessing</code>提供了一种等待执行结果的参考方式:</p><pre class="lg lh li lj gt mw le mx my aw mz bi"><span id="0e55" class="na lw iq le b gy nb nc l nd ne">from multiprocessing import Process, Queue, Pool</span><span id="0e9e" class="na lw iq le b gy nf nc l nd ne">def writer(i,q):<br/>    message = f’I am Process {i}’<br/>    q.put(message)</span><span id="b607" class="na lw iq le b gy nf nc l nd ne">def reader(i,q):<br/>    message = q.get()<br/>    print(message)</span><span id="936c" class="na lw iq le b gy nf nc l nd ne">if __name__ == ‘__main__’:<br/>    # Create multiprocessing queue<br/>    q = Queue()</span><span id="6f5f" class="na lw iq le b gy nf nc l nd ne">    # Create a group of parallel writers and start them<br/>    for i in range(10):<br/>        Process(target=writer, args=(i,q,)).start()</span><span id="8bc3" class="na lw iq le b gy nf nc l nd ne">    # Create multiprocessing pool<br/>    p = Pool(10)</span><span id="c317" class="na lw iq le b gy nf nc l nd ne">    # Create a group of parallel readers and start them<br/>    # Number of readers is matching the number of writers<br/>    # However, the number of simultaneously running<br/>    # readers is constrained to the pool size</span><span id="4ba2" class="na lw iq le b gy nf nc l nd ne">    readers = []<br/>    for i in range(10):<br/>        readers.append(p.apply_async(reader, (i,q,)))</span><span id="66a8" class="na lw iq le b gy nf nc l nd ne">    # Wait for the asynchrounous reader threads to finish<br/>    [r.get() for r in readers]</span></pre><p id="fcb7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次，如果我们运行代码，我们将得到下面的错误:<code class="fe lb lc ld le b">RuntimeError: Queue objects should only be shared between processes through inheritance</code>。<code class="fe lb lc ld le b">multiprocessing.Manager</code>将使我们能够管理队列，并使不同的工作人员也可以访问它:</p><pre class="lg lh li lj gt mw le mx my aw mz bi"><span id="a877" class="na lw iq le b gy nb nc l nd ne">from multiprocessing import Process, Queue, Pool, Manager</span><span id="1dfe" class="na lw iq le b gy nf nc l nd ne">def writer(i,q):<br/>    message = f’I am Process {i}’<br/>    q.put(message)</span><span id="3047" class="na lw iq le b gy nf nc l nd ne">def reader(i,q):<br/>    message = q.get()<br/>    print(message)</span><span id="f50a" class="na lw iq le b gy nf nc l nd ne">if __name__ == ‘__main__’:<br/>    # Create manager<br/>    m = Manager()</span><span id="a182" class="na lw iq le b gy nf nc l nd ne">    # Create multiprocessing queue<br/>    q = m.Queue()</span><span id="86f9" class="na lw iq le b gy nf nc l nd ne">    # Create a group of parallel writers and start them<br/>    for i in range(10):<br/>        Process(target=writer, args=(i,q,)).start()</span><span id="93b6" class="na lw iq le b gy nf nc l nd ne">    # Create multiprocessing pool<br/>    p = Pool(10)</span><span id="ec82" class="na lw iq le b gy nf nc l nd ne">    # Create a group of parallel readers and start them<br/>    # Number of readers is matching the number of writers<br/>    # However, the number of simultaneously running<br/>    # readers is constrained to the pool size</span><span id="112e" class="na lw iq le b gy nf nc l nd ne">    readers = []<br/>    for i in range(10):<br/>        readers.append(p.apply_async(reader, (i,q,)))</span><span id="ba86" class="na lw iq le b gy nf nc l nd ne">    # Wait for the asynchrounous reader threads to finish<br/>    [r.get() for r in readers]</span></pre><p id="58bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们能够得到我们期望的结果:</p><pre class="lg lh li lj gt mw le mx my aw mz bi"><span id="3888" class="na lw iq le b gy nb nc l nd ne">&gt; python pl.py</span><span id="0257" class="na lw iq le b gy nf nc l nd ne">I am Process 1<br/>I am Process 4<br/>I am Process 9<br/>I am Process 8<br/>I am Process 0<br/>I am Process 5<br/>I am Process 7<br/>I am Process 2<br/>I am Process 6<br/>I am Process 3</span></pre><h1 id="6770" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">与Windows相关的怪癖</h1><p id="4b42" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">我最初在基于Linux的机器上着手解决这个问题，但后来在Windows上继续。不幸的是，许多事情并没有立即见效。以下是你需要知道的事情:</p><p id="b88e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.对于上面的代码，中断程序执行(Ctrl+C)不会立即生效。<a class="ae mo" href="https://stackoverflow.com/a/6191991" rel="noopener ugc nofollow" target="_blank">解决方法</a>是添加初始化器工人:</p><pre class="lg lh li lj gt mw le mx my aw mz bi"><span id="a94c" class="na lw iq le b gy nb nc l nd ne">def init_worker():<br/>    """<br/>    Pool worker initializer for keyboard interrupt on Windows<br/>    """</span><span id="6be7" class="na lw iq le b gy nf nc l nd ne">    signal.signal(signal.SIGINT, signal.SIG_IGN)</span><span id="e858" class="na lw iq le b gy nf nc l nd ne">p = Pool(num_readers, init_worker)</span></pre><p id="2e4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.我无法在Windows上运行Jupyter笔记本中的代码，除非我将工人函数移动到单独的<code class="fe lb lc ld le b">.py</code>文件中，并将它们导入我的笔记本。与此相关，如果不将主代码打包到<code class="fe lb lc ld le b">if __name__ == ‘main':</code>中，您将无法运行上面的脚本。</p><h1 id="f01e" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">决赛成绩</h1><p id="0bbe" class="pw-post-body-paragraph kf kg iq kh b ki ni jr kk kl nj ju kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">作为收尾工作，让我们添加以下内容:<br/>延迟以模拟读取器和写入器上CPU受限的工作<br/>等待读取线程完成时的异常处理<br/>可配置的写入器和读取线程数量<br/>一些函数文档</p><p id="f4d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是最终结果:</p><pre class="lg lh li lj gt mw le mx my aw mz bi"><span id="e8ea" class="na lw iq le b gy nb nc l nd ne">from multiprocessing import Pool, Queue, Process, Manager<br/>import random<br/>import signal<br/>import time</span><span id="880b" class="na lw iq le b gy nf nc l nd ne">num_writers = 10<br/>num_readers = 3</span><span id="f4e2" class="na lw iq le b gy nf nc l nd ne">def writer(i,q):<br/>    # Imitate CPU-bound work happening in writer<br/>    delay = random.randint(1,10)<br/>    time.sleep(delay)<br/>    <br/>    # Put the result into the queue<br/>    t = time.time()<br/>    print(f’I am writer {i}: {t}’)<br/>    q.put(t)</span><span id="cb07" class="na lw iq le b gy nf nc l nd ne">def init_worker():<br/>    """<br/>    Pool worker initializer for keyboard interrupt on Windows<br/>    """<br/>    signal.signal(signal.SIGINT, signal.SIG_IGN)</span><span id="b78f" class="na lw iq le b gy nf nc l nd ne">def reader(i, q):<br/>    """<br/>    Queue reader worker<br/>    """<br/>    <br/>    # Read the top message from the queue<br/>    message = q.get()<br/>    <br/>    # Imitate CPU-bound work happening in reader<br/>    time.sleep(3)<br/>    print(f’I am reader {i}: {message}’)</span><span id="8bb5" class="na lw iq le b gy nf nc l nd ne">if __name__ == ‘__main__’:<br/>    # Create manager<br/>    m = Manager()<br/>    <br/>    # Create multiprocessing queue<br/>    q = m.Queue()</span><span id="3173" class="na lw iq le b gy nf nc l nd ne">    # Create a group of parallel writers and start them<br/>    for i in range(num_writers):<br/>        Process(target=writer, args=(i,q,)).start()<br/>    <br/>    # Create multiprocessing pool<br/>    p = Pool(num_readers, init_worker)</span><span id="c693" class="na lw iq le b gy nf nc l nd ne">    # Create a group of parallel readers and start them<br/>    # Number of readers is matching the number of writers<br/>    # However, the number of simultaneously running<br/>    # readers is constrained to the pool size<br/>    readers = []<br/>    for i in range(10):<br/>        readers.append(p.apply_async(reader, (i,q,)))<br/>    <br/>    # Wait for the asynchrounous reader threads to finish<br/>    try:<br/>        [r.get() for r in readers]<br/>    except:<br/>        print(‘Interrupted’)<br/>        p.terminate()<br/>        p.join()</span></pre><p id="cb5a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您运行它，您将得到类似如下的结果:</p><p id="352f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">```</p><pre class="lg lh li lj gt mw le mx my aw mz bi"><span id="3530" class="na lw iq le b gy nb nc l nd ne">&gt; python final.py</span><span id="abb7" class="na lw iq le b gy nf nc l nd ne">I am writer 8: 1580659076.783544<br/>I am writer 3: 1580659076.783544<br/>I am reader 0: 1580659076.783544<br/>I am reader 1: 1580659076.783544<br/>I am writer 7: 1580659079.7990372<br/>I am writer 2: 1580659080.7971141<br/>I am writer 1: 1580659081.785277<br/>I am writer 4: 1580659082.7955923<br/>I am reader 2: 1580659079.7990372<br/>I am reader 3: 1580659080.7971141<br/>I am writer 6: 1580659083.800029<br/>I am writer 0: 1580659084.7862694<br/>I am reader 4: 1580659081.785277<br/>I am writer 9: 1580659085.7819643<br/>I am writer 5: 1580659085.7919443<br/>I am reader 5: 1580659082.7955923<br/>I am reader 6: 1580659083.800029<br/>I am reader 7: 1580659084.7862694<br/>I am reader 8: 1580659085.7819643<br/>I am reader 9: 1580659085.7919443</span></pre></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="8622" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章最初发表在<a class="ae mo" href="https://taletskiy.com/posts/python-pool-limited-queue-processing/" rel="noopener ugc nofollow" target="_blank">我的博客</a>上。</p></div></div>    
</body>
</html>