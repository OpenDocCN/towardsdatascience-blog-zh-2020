<html>
<head>
<title>Pandas read_csv() tricks you should know to speed up your data analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫 read_csv()加快数据分析速度你应该知道的小技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/all-the-pandas-read-csv-you-should-know-to-speed-up-your-data-analysis-1e16fe1039f3?source=collection_archive---------1-----------------------#2020-08-21">https://towardsdatascience.com/all-the-pandas-read-csv-you-should-know-to-speed-up-your-data-analysis-1e16fe1039f3?source=collection_archive---------1-----------------------#2020-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b67d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一些最有帮助的熊猫技巧来加速你的数据分析</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29f02a4f68e89d60f967f4b6b5fae351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wVRiOKtW1KR9OTxXpAVSHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自 https://www.flaticon.com/search?word=csv%20file<a class="ae ky" href="https://www.flaticon.com/search?word=csv%20file" rel="noopener ugc nofollow" target="_blank">的搜索结果</a></p></figure><p id="55b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导入数据是任何数据科学项目的第一步。通常，您会处理 CSV 文件中的数据，并在一开始就遇到问题。在本文中，您将看到如何使用 Pandas <code class="fe lv lw lx ly b">read_csv()</code>函数来处理以下常见问题。</p><ol class=""><li id="6376" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">处理不同的字符编码</li><li id="da16" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">处理标题</li><li id="3d6e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">处理列</li><li id="3322" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">解析日期列</li><li id="3a34" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">设置列的数据类型</li><li id="4fcb" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">查找和定位无效值</li><li id="3859" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">向现有 CSV 文件追加数据</li><li id="9965" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">用<code class="fe lv lw lx ly b">chunksize</code>加载一个巨大的 CSV 文件</li></ol><p id="8c78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请查看我的<a class="ae ky" href="https://github.com/BindiChen/machine-learning/blob/master/data-analysis/006-pandas-read_csv/read_csv-tricks.ipynb" rel="noopener ugc nofollow" target="_blank"> Github repo </a>获取源代码。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2742" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">1.处理不同的字符编码</h1><p id="7d4a" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><strong class="lb iu">字符编码</strong>是从原始二进制字节串映射到组成人类可读文本的字符的特定规则集[1]。Python 内置了对标准编码列表的支持。</p><p id="f3e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符编码不匹配现在不太常见，因为 UTF-8 是包括 Python 在内的大多数编程语言中的标准文本编码。然而，如果你试图读取一个不同于原始编码的文件，这肯定还是一个问题。当这种情况发生时，您很可能会以类似下面的内容或<strong class="lb iu"> DecodeError </strong>结束:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/8ba892cd133a02e53702f8ae666bf6eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*4bze0bzMr9nGUvJyy7whsA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源于<a class="ae ky" href="https://www.kaggle.com/alexisbcook/character-encodings" rel="noopener ugc nofollow" target="_blank"> Kaggle 字符编码</a></p></figure><p id="afa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫<code class="fe lv lw lx ly b">read_csv()</code>函数有一个名为<code class="fe lv lw lx ly b">encoding</code>的参数，允许您指定读取文件时使用的编码。</p><p id="a327" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的一个例子:</p><p id="83f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们用一些汉字创建一个数据框架，并用<code class="fe lv lw lx ly b">encoding='gb2312'</code>保存。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="95ea" class="nw mv it ly b gy nx ny l nz oa">df = pd.DataFrame({'name': '一 二 三 四'.split(), 'n': [2, 0, 2, 3]})</span><span id="bcc3" class="nw mv it ly b gy ob ny l nz oa">df.to_csv('data/data_1.csv', <strong class="ly iu">encoding='gb2312'</strong>, index=False)</span></pre><p id="9314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当试图用默认的 utf8 编码读取文件时，您应该得到一个<strong class="lb iu"> UnicodeDecodeError </strong>。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="6e88" class="nw mv it ly b gy nx ny l nz oa"># Read it with default encoding='utf8'<br/># You should get an error <br/>pd.read_csv('data/data_1.csv')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/84914ef6e60bdc2dfbba8342560c6662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PP7n13qTWe-t6Zd1wOfk7A.png"/></div></div></figure><p id="2d93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了正确地读取它，您应该传递文件编写的编码。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="84bb" class="nw mv it ly b gy nx ny l nz oa">pd.read_csv('data/data_1.csv', <strong class="ly iu">encoding='gb2312'</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/91816bd26811c0236acc53d653bcf486.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*HgaK3NQ8uMPxYcl6d5a-dg.png"/></div></figure><h1 id="90f2" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">2.处理标题</h1><p id="fc8b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">标题是指列名。对于某些数据集，标题可能完全缺失，或者您可能希望将不同的行视为标题。<code class="fe lv lw lx ly b">read_csv()</code>函数有一个名为<code class="fe lv lw lx ly b">header</code>的参数，允许您指定要使用的头。</p><h2 id="e3e8" class="nw mv it bd mw oj ok dn na ol om dp ne li on oo ng lm op oq ni lq or os nk ot bi translated">没有标题</h2><p id="b319" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果您的 CSV 文件没有头，那么您需要将参数<code class="fe lv lw lx ly b">header</code>设置为<code class="fe lv lw lx ly b">None</code>，熊猫将生成一些整数值作为头</p><p id="bc22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如导入<strong class="lb iu"> data_2_no_headers.csv </strong></p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="dd48" class="nw mv it ly b gy nx ny l nz oa">pd.read_csv('data/data_2_no_headers.csv', <strong class="ly iu">header=None</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/ee4954940af2c60b020874a94403ff9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*pG5dyjSQ2NgFVV5Lwg3c9Q.png"/></div></figure><h2 id="f261" class="nw mv it bd mw oj ok dn na ol om dp ne li on oo ng lm op oq ni lq or os nk ot bi translated">将不同行视为标题</h2><p id="55fe" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们来看看<strong class="lb iu"> <em class="ov"> data_2.csv </em> </strong></p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="171c" class="nw mv it ly b gy nx ny l nz oa">x1,       x2,      x3,     x4<br/><strong class="ly iu">product,  price,   cost,   profit</strong><br/>a,        10,      5,      1<br/>b,        20,      12,     2<br/>c,        30,      20,     3<br/>d,        40,      30,     4</span></pre><p id="bdc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来更合理的列名应该是<code class="fe lv lw lx ly b">product</code>、<code class="fe lv lw lx ly b">price</code>、… <code class="fe lv lw lx ly b">profit</code>，但是它们不在第一行。参数<code class="fe lv lw lx ly b">header</code>还允许您指定用作列名和数据开始的行号。在这种情况下，我们希望跳过第一行，使用第二行作为标题:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="b50d" class="nw mv it ly b gy nx ny l nz oa">pd.read_csv('data/data_2.csv', <strong class="ly iu">header=1</strong>)</span></pre><h1 id="a631" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">3.处理列</h1><p id="edb6" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">当您的输入数据集包含大量列，并且您想要将这些列的子集加载到 DataFrame 中时，那么<code class="fe lv lw lx ly b">usecols</code>将非常有用。</p><p id="adea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就性能而言，这样做更好，因为不必将整个数据帧加载到内存中，然后删除备用列，我们可以在加载数据集时选择我们需要的列。</p><p id="67da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用同一个数据集<strong class="lb iu"> <em class="ov"> data_2.csv </em> </strong>并选择<strong class="lb iu"> <em class="ov">产品</em> </strong>和<strong class="lb iu"> <em class="ov">成本</em> </strong>列。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="5043" class="nw mv it ly b gy nx ny l nz oa">pd.read_csv('data/data_2.csv',<br/>            header=1,<br/>            <strong class="ly iu">usecols=['product', 'cost']</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/dfa288a99a9e7117b4dd7215a65385b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*rJ5c3_WsRlQVbo7UfKltHw.png"/></div></figure><p id="c1e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以将列索引传递给<code class="fe lv lw lx ly b">usecols</code>:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="24e8" class="nw mv it ly b gy nx ny l nz oa">pd.read_csv('data/data_2.csv',<br/>            header=1,<br/>            <strong class="ly iu">usecols=[0, 1]</strong>)</span></pre><h1 id="9f94" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">4.解析日期列</h1><p id="bdbb" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">从 CSV 文件加载数据时，默认情况下日期列表示为<strong class="lb iu">对象</strong>。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="a12c" class="nw mv it ly b gy nx ny l nz oa">df = pd.read_csv('data/data_3.csv')<br/>df.info()</span><span id="7780" class="nw mv it ly b gy ob ny l nz oa">RangeIndex: 4 entries, 0 to 3<br/>Data columns (total 5 columns):<br/> #   Column   Non-Null Count  Dtype <br/>---  ------   --------------  ----- <br/> <strong class="ly iu">0   date     4 non-null      object</strong><br/> 1   product  4 non-null      object<br/> 2   price    4 non-null      int64 <br/> 3   cost     4 non-null      int64 <br/> 4   profit   4 non-null      int64 <br/>dtypes: int64(3), object(2)<br/>memory usage: 288.0+ bytes</span></pre><p id="05dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了正确读取<strong class="lb iu"> <em class="ov">日期</em> </strong>列，我们可以使用参数<code class="fe lv lw lx ly b">parse_dates</code>来指定日期列的列表。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="bd83" class="nw mv it ly b gy nx ny l nz oa">df = pd.read_csv('data/data_3.csv', <strong class="ly iu">parse_dates=['date']</strong>)<br/>df.info()</span><span id="4ae5" class="nw mv it ly b gy ob ny l nz oa">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 4 entries, 0 to 3<br/>Data columns (total 5 columns):<br/> #   Column   Non-Null Count  Dtype         <br/>---  ------   --------------  -----         <br/> <strong class="ly iu">0   date     4 non-null      datetime64[ns]</strong><br/> 1   product  4 non-null      object        <br/> 2   price    4 non-null      int64         <br/> 3   cost     4 non-null      int64         <br/> 4   profit   4 non-null      int64         <br/>dtypes: datetime64[ns](1), int64(3), object(1)<br/>memory usage: 288.0+ bytes</span></pre><p id="5eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时日期被拆分成多个列，例如，<strong class="lb iu"> <em class="ov">年</em> </strong>，<strong class="lb iu"> <em class="ov">月</em> </strong>，<strong class="lb iu"> <em class="ov">日</em> </strong> <em class="ov">。为了将它们组合成一个日期时间，我们可以将一个嵌套列表传递给<code class="fe lv lw lx ly b">parse_dates</code>。</em></p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="496f" class="nw mv it ly b gy nx ny l nz oa">df = pd.read_csv('data/data_4.csv',<br/>                 <strong class="ly iu">parse_dates=[['year', 'month', 'day']]</strong>)<br/>df.info()</span><span id="0ca4" class="nw mv it ly b gy ob ny l nz oa">RangeIndex: 4 entries, 0 to 3<br/>Data columns (total 5 columns):<br/> #   Column          Non-Null Count  Dtype         <br/>---  ------          --------------  -----         <br/> <strong class="ly iu">0   year_month_day  4 non-null      datetime64[ns]</strong><br/> 1   product         4 non-null      object        <br/> 2   price           4 non-null      int64         <br/> 3   cost            4 non-null      int64         <br/> 4   profit          4 non-null      int64         <br/>dtypes: datetime64[ns](1), int64(3), object(1)<br/>memory usage: 288.0+ bytes</span></pre><p id="cce7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要指定一个自定义的列名来代替自动生成的<strong class="lb iu"><em class="ov">year _ month _ day</em></strong>，我们可以通过一个字典来代替。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="ea8d" class="nw mv it ly b gy nx ny l nz oa">df = pd.read_csv('data/data_4.csv',<br/>                 <strong class="ly iu">parse_dates={ 'date': ['year', 'month', 'day'] }</strong>)<br/>df.info()</span></pre><p id="fa18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的日期列是不同的格式，那么您可以定制一个日期解析器并将其传递给参数<code class="fe lv lw lx ly b">date_parser</code>:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="ec3d" class="nw mv it ly b gy nx ny l nz oa">from datetime import datetime<br/><strong class="ly iu">custom_date_parser = lambda x: datetime.strptime(x, "%Y %m %d %H:%M:%S")</strong></span><span id="08b0" class="nw mv it ly b gy ob ny l nz oa">pd.read_csv('data/data_6.csv',<br/>             parse_dates=['date'],<br/>             <strong class="ly iu">date_parser=custom_date_parser</strong>)</span></pre><p id="186b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关解析日期列的更多信息，请查看本文</p><div class="ox oy gp gr oz pa"><a rel="noopener follow" target="_blank" href="/4-tricks-you-should-know-to-parse-date-columns-with-pandas-read-csv-27355bb2ad0e"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd iu gy z fp pf fr fs pg fu fw is bi translated">您应该知道的用 Pandas read_csv()解析日期列的 4 个技巧</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">一些最有用的熊猫把戏</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">towardsdatascience.com</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po ks pa"/></div></div></a></div><h1 id="b244" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">5.设置数据类型</h1><p id="482b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果要设置 DataFrame 列的数据类型，可以使用参数<code class="fe lv lw lx ly b">dtype</code>，例如</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="34aa" class="nw mv it ly b gy nx ny l nz oa">pd.read_csv('data/data_7.csv',<br/>                 <strong class="ly iu">dtype={<br/>                     'Name': str,<br/>                     'Grade': int<br/>                 }</strong>)</span></pre><h1 id="ae2e" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">6.查找和定位无效值</h1><p id="3ff1" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">当使用参数<code class="fe lv lw lx ly b">dtype</code>设置数据类型时，您可能会得到<strong class="lb iu">类型错误</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/e33377e86d3cb28a9c891e3c4eadcac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhBqYS0IC_87s52Rtlh6Fg.png"/></div></div></figure><p id="39b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生这种错误时，查找并定位无效值总是有用的。以下是找到它们的方法:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="dd6f" class="nw mv it ly b gy nx ny l nz oa">df = pd.read_csv('data/data_8.csv')</span><span id="893b" class="nw mv it ly b gy ob ny l nz oa"><strong class="ly iu">is_error = pd.to_numeric(df['Grade'], errors='coerce').isna()</strong></span><span id="5530" class="nw mv it ly b gy ob ny l nz oa">df[is_error]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/327db12d905d763ab4ed5fc00a396e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*DAF3euhIwYtszuH2_K11gQ.png"/></div></div></figure><h1 id="ffbb" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">7.向现有 CSV 文件追加数据</h1><p id="1bf0" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">你可以在熊猫<code class="fe lv lw lx ly b">to_csv()</code>函数中指定一个 Python 写模式。为了将数据添加到现有的 CSV 文件中，我们可以使用<code class="fe lv lw lx ly b">mode='a'</code>:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="5708" class="nw mv it ly b gy nx ny l nz oa">new_record = pd.DataFrame([['New name', pd.to_datetime('today')]],<br/>                      columns=['Name', 'Date'])</span><span id="c4af" class="nw mv it ly b gy ob ny l nz oa">new_record.to_csv('data/existing_data.csv',<br/>              <strong class="ly iu">mode='a',</strong><br/>              <strong class="ly iu">header=None,</strong><br/>              <strong class="ly iu">index=False</strong>)</span></pre><h1 id="a476" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">8.用<code class="fe lv lw lx ly b">chunksize</code>加载一个巨大的 CSV 文件</h1><p id="d1ba" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">默认情况下，Pandas <code class="fe lv lw lx ly b">read_csv()</code>函数会将整个数据集加载到内存中，当导入一个巨大的 CSV 文件时，这可能是一个内存和性能问题。</p><p id="f7ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">read_csv()</code>有一个名为<code class="fe lv lw lx ly b">chunksize</code>的参数，它允许您以相同大小的块来检索数据。这在作为数据科学项目的一部分读取大型数据集时尤其有用。</p><p id="db5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的一个例子:</p><p id="4c96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个 400，000 行的大型数据集，并将其保存到<strong class="lb iu"> big_file.csv </strong></p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="0cec" class="nw mv it ly b gy nx ny l nz oa"># Make up a huge dataset</span><span id="9f1b" class="nw mv it ly b gy ob ny l nz oa">nums = 100_000</span><span id="04b6" class="nw mv it ly b gy ob ny l nz oa">for name in 'a b c d'.split():<br/>    df = pd.DataFrame({<br/>        'col_1': [1]*nums,<br/>        'col_2': np.random.randint(100, 2000, size=nums)<br/>    })</span><span id="b2a7" class="nw mv it ly b gy ob ny l nz oa">    df['name'] = name<br/>    df.to_csv('data/big_file.csv',<br/>              mode='a',<br/>              index=False,<br/>              header= name=='a')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/33881dbd46cae51c27ec4fdd6cee04a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JrsZ7MOC4NyhQ5EVTG7oOA.png"/></div></div></figure><p id="c1dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们在用<code class="fe lv lw lx ly b">read_csv()</code>加载数据时指定一个 50，000 的<code class="fe lv lw lx ly b">chucksize</code></p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="6d76" class="nw mv it ly b gy nx ny l nz oa">dfs = pd.read_csv('data/big_file.csv',<br/>                  <strong class="ly iu">chunksize=50_000,</strong><br/>                  dtype={<br/>                      'col_1': int,<br/>                      'col_2': int,<br/>                      'name': str<br/>                  })</span></pre><p id="67ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们对每个块执行一些聚合，然后将结果连接成一个数据帧。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="f227" class="nw mv it ly b gy nx ny l nz oa">res_dfs = []<br/><strong class="ly iu">for chunk in dfs:</strong><br/>    res = chunk.groupby('name').col_2.agg(['count', 'sum'])<br/>    res_dfs.append(res)</span><span id="4109" class="nw mv it ly b gy ob ny l nz oa"><strong class="ly iu">pd.concat(res_dfs).groupby(level=0).sum()</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/46d49f8d54e2a056c33968d1263fd3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*Z8wDUUFlSKZk61WyvwnMOg.png"/></div></figure><p id="2e86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们对照没有<code class="fe lv lw lx ly b">chunksize</code>的解决方案来验证结果</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="6a9c" class="nw mv it ly b gy nx ny l nz oa">pd.read_csv('data/big_file.csv',<br/>              dtype={<br/>                  'col_1': int,<br/>                  'col_2': int,<br/>                  'name': str<br/>              }).groupby('name').col_2.agg(['count', 'sum'])</span></pre><p id="ad76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该得到相同的输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/46d49f8d54e2a056c33968d1263fd3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*Z8wDUUFlSKZk61WyvwnMOg.png"/></div></figure><h1 id="e3a2" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">好了</h1><p id="9a1a" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">感谢阅读。</p><p id="dd38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请在我的 Github 笔记本上查看源代码。</p><p id="c671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对机器学习的实用方面感兴趣，请继续关注。</p><p id="9f48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一些相关的文章</p><ul class=""><li id="cb90" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu pt mf mg mh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/4-tricks-you-should-know-to-parse-date-columns-with-pandas-read-csv-27355bb2ad0e">用 Pandas read_csv()解析日期列应该知道的 4 个技巧</a></li><li id="7b2c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu pt mf mg mh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/6-pandas-tricks-you-should-know-to-speed-up-your-data-analysis-d3dec7c29e5">你应该知道的 6 个熊猫技巧，以加速你的数据分析</a></li><li id="1d3e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu pt mf mg mh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/7-setups-you-should-include-at-the-beginning-of-a-data-science-project-8232ab10a1ec">数据科学项目开始时你应该包括的 7 个设置。</a></li></ul><h1 id="865f" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">参考</h1><ul class=""><li id="ca77" class="lz ma it lb b lc nm lf nn li pu lm pv lq pw lu pt mf mg mh bi translated">[1] Kaggle 数据清理:<a class="ae ky" href="https://www.kaggle.com/alexisbcook/character-encodings" rel="noopener ugc nofollow" target="_blank">字符编码</a></li></ul></div></div>    
</body>
</html>