<html>
<head>
<title>Graphical Functions made from an effortless sketch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轻松绘制的图形功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graphical-functions-made-from-an-effortless-sketch-266ccf95c46d?source=collection_archive---------48-----------------------#2020-07-09">https://towardsdatascience.com/graphical-functions-made-from-an-effortless-sketch-266ccf95c46d?source=collection_archive---------48-----------------------#2020-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4433" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">"返回方程式的 MS Paint "</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5c4ae98c3c4692ec685a0f510e533545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MogVumuH7uR0A5dUjE0VAQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://pixabay.com/users/Wokandapix-614097/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=988017" rel="noopener ugc nofollow" target="_blank"> Wokandapix </a>来自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=988017" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="77a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大家好！几天前，我在研究一个机器学习模型，我需要输入一个与 X 和 Y 相关的函数。唯一的约束是函数必须连续，X 和 Y 的界限必须是[0，1]。</p><p id="cf87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">脑子里有了几十条不同的曲线，我开始在纸上画出它们的草图。重点是之后把它们放在绘图计算器上。这是一项单调乏味的任务，我向姐姐寻求帮助。</p><p id="2761" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“你为什么不为它写个程序呢？”，她回答道。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5128" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">目的</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/d49cfada16085a1c68fad208e156cf2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lJO98_U0WLf4gpzGrCtaag.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个已有的应用:<a class="ae kv" href="https://mycurvefit.com/" rel="noopener ugc nofollow" target="_blank"> MyCurveFit </a></p></figure><p id="54f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现有的应用程序采用 X 和 Y 坐标来返回精确的方程。然而，曲线越复杂，用户输入的坐标就越多。此外，用户必须手动选择函数来拟合这些点(例如:线性对指数)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/cc3974018db9664107f8a07bc066c01f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nbM7xRMviP_OuEiCnkIQEA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这个计划</p></figure><p id="4f5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想要一个“返回方程式的 MS Paint”。</p><p id="e033" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然手绘意味着坐标不能精确，但当近似方程足够时，它是一个方便的工具，微调可以留待下次进行。通过比较均方误差，程序也自动选择最佳函数。</p><h1 id="d86f" class="lz ma iq bd mb mc mt me mf mg mu mi mj jw mv jx ml jz mw ka mn kc mx kd mp mq bi translated">应用程序管道</h1><p id="5d23" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这是整体架构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/8ab26e75de908b8efcf1d607ac323fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UIL4IVS7yN8LfHGIA23Bcw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我的应用程序管道</p></figure><p id="2b7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户在提供的画布上绘制时，提取曲线上的点的 X 和 Y 坐标。它们被输入到不同的模型中，这些模型符合如上所示的相应方程。最后，显示具有最小均方误差的方程。</p><p id="04c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于多项式方程最容易过度拟合，因此用户可以选择限制次数。</p><h2 id="6d1d" class="ne ma iq bd mb nf ng dn mf nh ni dp mj lf nj nk ml lj nl nm mn ln nn no mp np bi translated">输入加工</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/672a08df8a7dbfc96f637b29f6046688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FBV3JmkPFBe29wKGciU-aA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从用户界面到 3D 阵列的绘制</p></figure><p id="536a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户界面包含来自<a class="ae kv" href="https://github.com/Leimi/drawingboard.js/" rel="noopener ugc nofollow" target="_blank"> drawingboard.js </a>资源库的绘图画布。当用户与它交互时，鼠标的移动会被跟踪并保存为 PNG 格式。然后图像被处理成如上所示的三维阵列。<em class="nr">(宽 x 高 x 通道)</em></p><p id="fc67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据图像的数组表示，计算 X 和 Y 坐标，并分别存储在 X 和 Y 数组中。</p><h2 id="a18d" class="ne ma iq bd mb nf ng dn mf nh ni dp mj lf nj nk ml lj nl nm mn ln nn no mp np bi translated">模型拟合</h2><p id="b091" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Scipy 库提供了给定 X 和 Y 数组来拟合方程的方法。我主要使用了其中的两种。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/097fca8b386fabdb51f4ed298449d14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IP7cNFEJdse7anKLSEGHwA.png"/></div></div></figure><h2 id="6de9" class="ne ma iq bd mb nf ng dn mf nh ni dp mj lf nj nk ml lj nl nm mn ln nn no mp np bi translated"><strong class="ak"> Polyfit </strong></h2><p id="a922" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这个方法返回给定次数的多项式的系数。下面是一个例子。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="bb43" class="ne ma iq nu b gy ny nz l oa ob"><strong class="nu ir">from</strong> numpy.polynomial.polynomial <strong class="nu ir">import</strong> polyfit</span><span id="03d1" class="ne ma iq nu b gy oc nz l oa ob">x_array = [0, 1, 2, 3]<br/>y_array = [1, 3, 4, 6]<br/>coef = polyfit(x_array, y_array, deg=2) # Polynomial of Degree 2</span><span id="8af6" class="ne ma iq nu b gy oc nz l oa ob"><strong class="nu ir">print(</strong>coef<strong class="nu ir">)</strong><br/># [ 1.  2.  0. ]<br/># Function: y = 1 + 2*x + 0*x^2</span></pre><p id="f8bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所见，这可以很容易地扩展到其他功能，如多对数。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="1f43" class="ne ma iq nu b gy ny nz l oa ob"><strong class="nu ir">from</strong> math <strong class="nu ir">import</strong> e</span><span id="5a44" class="ne ma iq nu b gy oc nz l oa ob">x_array = [e, e**2, e**3]<br/>y_array = [2, 4, 6]<br/>coef = polyfit(np.log(x_array), y_array, deg=2)</span><span id="4dfc" class="ne ma iq nu b gy oc nz l oa ob"><strong class="nu ir">print(</strong>coef<strong class="nu ir">)</strong><br/># [ 0.  2.  0. ]<br/># Function: y = 0 + 2*(log x) + 0*(log x)^2</span></pre><h2 id="545b" class="ne ma iq bd mb nf ng dn mf nh ni dp mj lf nj nk ml lj nl nm mn ln nn no mp np bi translated">曲线拟合</h2><p id="cfec" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这种方法更加灵活，因为它采用了用户定义的函数和要拟合的自定义系数。</p><p id="229b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正弦函数就是一个例子:<em class="nr"> y = a * sin(b * x) + c </em></p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="6e7c" class="ne ma iq nu b gy ny nz l oa ob"><strong class="nu ir">from</strong> scipy.optimize <strong class="nu ir">import</strong> curve_fit<br/><strong class="nu ir">from</strong> math <strong class="nu ir">import</strong> pi</span><span id="b3ec" class="ne ma iq nu b gy oc nz l oa ob">x_array = [0, pi/2, pi, 3*pi/2]<br/>y_array = [0, 1, 0]</span><span id="9b61" class="ne ma iq nu b gy oc nz l oa ob"># User-defined function with custom a, b, c, d<br/>sine_function = <strong class="nu ir">lambda</strong> x, a, b, c, d: a * np.sin(b*x + c) + d</span><span id="d8ab" class="ne ma iq nu b gy oc nz l oa ob">coef, cov = curve_fit(sine_function, x_array, y_array)</span><span id="6c11" class="ne ma iq nu b gy oc nz l oa ob"><strong class="nu ir">print(</strong>coef<strong class="nu ir">)</strong><br/># [ 1.  1.  0.  0. ]<br/># Function: y = 1*sin(1*x + 0) + 0</span></pre><p id="2d80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这同样适用于指数函数和双曲正弦函数等其他函数。</p><p id="5a97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后每个拟合的函数预测 Y 坐标。从输入 Y 中选择具有最小均方误差的一个用于显示。</p><h2 id="f162" class="ne ma iq bd mb nf ng dn mf nh ni dp mj lf nj nk ml lj nl nm mn ln nn no mp np bi translated">输出</h2><p id="2522" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">使用<a class="ae kv" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>库，用不同的颜色绘制预测的 Y 与 X。之后，绘图图形被转换回 PNG 图像用于显示。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="826d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">样本案例</h1><p id="d6be" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">1.三次多项式、三次多元对数函数和其他函数之间的最佳拟合</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/95094eb8d9d9e0158aeee7475a8bc83e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ROG0WUysdEqmESOZZRfSw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">正弦函数在这里表现最佳</p></figure><p id="85e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.5 次多项式、5 次多对数函数和其他函数之间的最佳拟合</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/c4cfd92031e87397dfc8cff3d51a8015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oZzxgZ8vLomtB04esqKg2g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">5 次多项式性能最佳</p></figure><p id="2b60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.不同次数多项式函数的比较</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/35d94ea6958c3b6a0aa6d0b5f1e364e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gzln9WtnHmI-a1CPRG-ZDQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从 1 到 3 的多项式次数</p></figure><p id="d50c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果看起来不错！</p><h2 id="7334" class="ne ma iq bd mb nf ng dn mf nh ni dp mj lf nj nk ml lj nl nm mn ln nn no mp np bi translated"><strong class="ak">未来的改进</strong></h2><p id="8e76" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">首先，可以添加更多的模型。这很容易做到，因为它们已经从应用程序的其余部分中抽象出来了。欢迎建议！</p><p id="dd6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二，输入的范围可以变得更鲁棒，因为它当前仅接受[-1，1]。绘图画布可以是动态的，以适应其他范围。</p><p id="d1c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p><h2 id="c80d" class="ne ma iq bd mb nf ng dn mf nh ni dp mj lf nj nk ml lj nl nm mn ln nn no mp np bi translated">密码</h2><div class="og oh gp gr oi oj"><a href="https://github.com/yarkhinephyo/sketch_a_function" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">yarkhinephyo/sketch_a_function</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">在 GitHub 上创建一个帐户，为 yarkhinephyo/sketch_a_function 开发做贡献。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox kp oj"/></div></div></a></div></div></div>    
</body>
</html>