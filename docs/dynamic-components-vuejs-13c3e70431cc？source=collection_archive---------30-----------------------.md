# 如何在 Vuejs 上实现动态组件

> 原文：<https://towardsdatascience.com/dynamic-components-vuejs-13c3e70431cc?source=collection_archive---------30----------------------->

## 了解轻松创建模块化应用程序的解决方案

单页应用程序现在是大多数情况下的标准。从表现中分离业务逻辑在效率和质量方面带来了巨大的优势。事实上，大多数框架构建了一组静态文件，这是降低托管或部署复杂性的一个额外好处。这些特征对于企业应用程序来说是很好的，但是当我开始开发 RawCMS 的前端时，我发现这些特征非常有限。事实上，我需要一个模块化的系统，贡献者可以在没有任何限制或构建任何东西的情况下向界面添加功能。在这篇文章中，我将回顾我提出最终解决方案的步骤。

**剧透:**我用 Vuex 和普通 javascript 结束了 VueJs。结果是一个从任何公共 URL 加载组件的动态引擎，如果我可以从头开始，我会再次做出同样的决定😆

![](img/5c434430863cd948e834a71fdf055b9b.png)

foto di[piro 4d](https://pixabay.com/it/users/PIRO4D-2707530/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=3127504)da[pix abay](https://pixabay.com/it/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=3127504)

# 我需要的

在像 headless cms 这样的产品上工作，你想让人们扩展平台开发他们自己的模块是一个挑战。在前端部分，我被说服使用水疗方法，我习惯了玩角，但有一个挑战。构建完成后，动态加载组件、扩展 UI(如添加菜单项或路由)并不容易。

这就是为什么当我和莱昂纳多·马库奇开始着手这项工作时，我们记录了一些市场提供的技术机会。

我们发现了三种主要的解决方案，每一种都有利弊。

## 使用 Iframes

此解决方案包括部署多个 SPA，并使用一个中央 SPA 来管理外壳。因此它可以根据模块的数量(SPA 部署)加载菜单项。我放弃了这个解决方案，因为我害怕 iframe 的局限性和模块之间的交互。我担心像这样的解决方案只不过是一个链表。

## Web 组件

我发现了一些关于 web 组件的好观点。对于我所寻找的，web 组件是一个很好的解决方案，但我会使用易于使用的技术解决方案，并广泛用于防止来自社区的拒绝，在我做出这个选择的时候，像 StencilJs 这样的解决方案还很年轻。

## 利用我们所拥有的来玩

最终的解决方案是使用广泛使用的库，让我不用构建就可以开发一个 SPA，并且可以动态加载新的插件。这非常简单，只需要使用 VueJs 天生给我们的东西。不信？只看下一章。

# 我们如何制作 VueJs 水疗模块

最后的决定是使用普通 VueJs，因为它允许我们在没有构建过程的情况下做伟大的事情。限制一点浏览器兼容性，我们可以使用 ES6，利用许多强大的功能，如承诺、阵列自动化等。在我们的例子中，该产品是为开发人员设计的，所以我们认为强迫他们使用 Chrome、Firefox 或 Edge 等现代浏览器并不是一个很大的限制。此外，如果一个开发者想继续使用 IE6，我们可能有一个比安装一个使用这个无头 cms 的浏览器更大的问题要解决。

所以，VueJs 是被选中的框架，然后我们有一系列的挑战来使它工作。在这一章中，我试图重新回顾所有将我们带到最终版本的步骤。

## 第一块砖:动态文件加载

我们首先使用的是动态加载 javascript 模块的机会。基本上，以下选项是等效的:

```
import {MyDefaultComponent} from '/MyDefaultComponentFile.js'//orconst filePath='/MyDefaultComponentFile.js';
import(filePath).then(x => x.default());
```

其中, **MyDefaultComponent** 是这样声明的:

```
import { XanderCage} from '/xxx.js'; 
const _myComponentInstance = function(){
//Declare your component here
};export default _myComponentInstance;
```

import 语句也可以以编程方式调用，使整个解决方案动态化，如下所示:

上面的代码片段是 RawCMS 引导模块调用 API 返回注册模块列表的地方。在这个特定的例子中，我将它们都添加到一个列表中，然后我一起解析所有的承诺，以确保在 init 阶段之前加载所有的承诺。可以对他的原始代码进行改进或优化，但这是我稍后将讲述的所有内容的基础。

## 组件集成

正如您在上一段中看到的，导入仅限于名为“config.js”的文件。这个文件必须放在插件文件夹的根目录下，并且将包含一个带有模块配置的 json 对象。为此，我使用了 Vuex，VueJs 的状态管理框架。这使得事情很容易管理。在主机应用程序上集成所有动态组件的代码只有几行代码:

在上面的例子中，我们通过解析承诺加载了所有模块(第一个模块是宿主应用程序，单独处理)。其他模块通过初始化(使用标准方法)和获取路线集成到应用程序中。

在这一步之后，我们的模块是主应用程序的一部分，可以使用了。

## 路线

通过将来自模块的单个路由添加到 Vue 路由引擎中，可以自动管理路由。我们只需要一个额外的步骤来管理国际化。这需要根据我们正在访问的路由来加载翻译，因此我们在路由管道上添加了一个链。

这段代码加载所有来自模块的翻译，并将其合并。c 核心标签用作故障转移。

## 菜单整合

基于模块的定义添加菜单项是一件非常简单的事情，只是一个渲染问题。组件的 js 端只是将来自插件的信息放在一个属性中，以便在模板端进行简单的管理。

在模板上，我们只需要使用材料设计组件来呈现元素。

## 模块间的通信

两种基本机制允许模块之间的通信

1.  事件
2.  Vuex 状态

通过事件，我们可以通知所有模块有事情发生。因为事件系统是中心的，所有的事件名称都是按名称引用的，所以不存在物理依赖性。所有想要列出给定事件的模块都可以基于它来做和反应，即使它们在模块之外。基于这一原则，当用户登录时，登录组件会通知显示用户徽章的组件，但是您也可以附加您的组件。剩下的由 Vuex 库完成。在下一个代码片段中，登录的例子被翻译成了代码。

什么是 *RawCMS.eventBus* ？只不过是一个 Vue 组件。看看 RawCMS 的定义就知道了。

最后一点是关于 Vuex 的用法。我将定义 Vuex 模块以及如何从 Vuex 存储器读取/写入数据的代码段添加到代码片段中。

# 带什么回家

创建模块化 SPA 应用程序是可能的，并且在某些情况下是必需的。我的用例是一个开源的可扩展产品，并不常见，但是你可能会遇到类似的情况。试想一个应用程序太大，无法由一个团队或公司开发。使用事件总线和强大的约定将应用程序分解成模块，使之成为可能。我提出的解决方案是可行的，并且易于实现。使用几个月后，我对它的看法。

## **亲**

*   易于设置
*   易于管理
*   容易理解
*   可以与后端代码集成
*   易于包装和移动

## 面向连接的网络服务(Connection Oriented Network Service)

*   不容易防止 js 错误(没有构建过程)
*   难以优化(没有构建，谁能负责压缩或最小化 javascript)？
*   不要在旧的浏览器上工作，因为没有任何填充或传输。

在 RawCMS 案例中，一个对开发人员进行评估的产品，UI 只是用来让技术人员建立一个无头 CMS，与采用智能解决方案的好处相比，它的局限性是微不足道的。在企业案例或具有不同类型用户的其他产品中，您可能需要一些额外的工作(可能在 DevOps 方面)来克服实际解决方案的限制。

# 参考

*   [raw CMS 项目(Git Hub 源代码)](https://github.com/arduosoft/RawCMS/)
*   (电子书)[来自 Andrea Koutifaris 的 Vuex 快速入门指南](https://www.amazon.com/Vuex-Quick-Start-Guide-applications/dp/1788999932)
*   [VueJs](https://vuejs.org/) 主页
*   RawCMS UI 的主要撰稿人 Leonardo Marcucci