<html>
<head>
<title>Data Scientists, Start Using Profilers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家，开始使用分析器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-scientists-start-using-profilers-4d2e08e7aec0?source=collection_archive---------32-----------------------#2020-08-07">https://towardsdatascience.com/data-scientists-start-using-profilers-4d2e08e7aec0?source=collection_archive---------32-----------------------#2020-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="80cd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">找到算法中真正让你慢下来的部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5790f4209f638c9b17d5bdea6c4f62f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C6xQk9PpujP-7mM4"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@jantined?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jantine Doornbos </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="0bd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据科学家通常需要编写大量复杂、缓慢、CPU 和 I/O 繁重的代码，无论您是处理大型矩阵、数百万行数据、读取数据文件还是浏览网页。</p><p id="0b29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当对另一部分进行一些简单的修改就能使代码速度提高 10 倍时，难道你不想浪费时间重构代码的一部分，试图榨干最后一丝性能吗？</p><p id="b6b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您正在寻找一种加快代码速度的方法，一个分析器可以准确地显示哪些部分花费的时间最多，让您看到哪些部分将从优化中受益最多。</p><p id="3325" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分析器测量程序的时间或空间复杂度。对算法的大 O 复杂度进行理论化肯定是有价值的，但是检验算法的真实复杂度也同样有价值。</p><p id="4e3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">你的代码最大的减速在哪里？你的代码</em> <a class="ae kv" href="https://stackoverflow.com/questions/868568/what-do-the-terms-cpu-bound-and-i-o-bound-mean" rel="noopener ugc nofollow" target="_blank"> <em class="ls">是 I/O 绑定还是 CPU 绑定</em> </a> <em class="ls">？哪些具体线路导致了速度变慢？</em></p><p id="2a2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你回答了这些问题，你将 A)对你的代码有更好的理解，B)知道你的优化工作的目标是什么，以便用最少的努力获得最大的收益。</p><p id="72ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们深入一些使用 Python 的快速示例。</p><h1 id="a0f2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">基础知识</h1><p id="1523" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">您可能已经熟悉了一些为代码计时的方法。您可以检查一行执行前后的时间，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7a1c" class="mv lu iq mr b gy mw mx l my mz">In [1]: start_time = time.time()<br/>   ...: a_function() # Function you want to measure<br/>   ...: end_time = time.time()<br/>   ...: time_to_complete = end_time - start_time<br/>   ...: time_to_complete<br/>Out[1]: 1.0110783576965332</span></pre><p id="b241" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，如果您在 Jupyter 笔记本中，您可以使用神奇的<code class="fe na nb nc mr b">%time</code>命令来计时语句的执行，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b710" class="mv lu iq mr b gy mw mx l my mz">In [2]: %time a_function()<br/>CPU times: user 14.2 ms, sys: 41 µs, total: 14.2 ms<br/>Wall time: 1.01 s</span></pre><p id="dfcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，您可以使用<em class="ls"> other </em>魔法命令<code class="fe na nb nc mr b">%timeit</code>，它通过多次运行该命令获得更精确的测量，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8b90" class="mv lu iq mr b gy mw mx l my mz">In [3]: %timeit a_function()<br/>1.01 s ± 1.45 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="bcc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，如果您想为整个脚本计时，您可以使用 bash 命令<code class="fe na nb nc mr b">time</code>，就像这样…</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="29ba" class="mv lu iq mr b gy mw mx l my mz">$ time python my_script.py<br/><br/>real    0m1.041s<br/>user    0m0.040s<br/>sys     0m0.000s</span></pre><p id="8111" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想快速了解一个脚本或一段代码运行需要多长时间，这些技术非常有用，但是当您想要更全面的了解时，这些技术就没那么有用了。如果你不得不在<code class="fe na nb nc mr b">time.time()</code>支票中换行，那将是一场噩梦。在下一节中，我们将看看如何使用 Python 的内置分析器。</p><h1 id="bdac" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用 cProfile 深入探索</h1><p id="d121" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当你试图更好地理解你的代码是如何运行的，首先要从 Python 的内置分析器<a class="ae kv" href="https://docs.python.org/3/library/profile.html#module-cProfile" rel="noopener ugc nofollow" target="_blank"> cProfile </a>开始。cProfile 将记录你的程序的各个部分被执行的频率和时间。</p><p id="de38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，cProfile 不应该用于测试您的代码。它是用 C 写的，这使得它很快，但它仍然引入了一些开销，可能会影响您的时间。</p><p id="8367" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有多种方法可以使用 cProfile，但是一种简单的方法是从命令行使用。</p><p id="65cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在演示 cProfile 之前，让我们先来看一个基本的示例程序，它将下载一些文本文件，计算每个文件中的单词数，然后将每个文件中的前 10 个单词保存到一个文件中。话虽如此，代码做什么并不太重要，只是我们将使用它来展示分析器是如何工作的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试我们的分析器的演示代码</p></figure><p id="ed11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，使用下面的命令，我们将分析我们的脚本。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7e47" class="mv lu iq mr b gy mw mx l my mz">$ python -m cProfile -o profile.stat script.py</span></pre><p id="52dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc mr b">-o</code>标志为 cProfile 指定一个输出文件，以保存分析统计数据。</p><p id="1d1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可以使用<a class="ae kv" href="https://docs.python.org/3/library/profile.html#module-pstats" rel="noopener ugc nofollow" target="_blank"> pstats </a>模块(也是标准库的一部分)启动 python 来检查结果。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="620e" class="mv lu iq mr b gy mw mx l my mz">In [1]: import pstats<br/>   ...: p = pstats.Stats("profile.stat")<br/>   ...: p.sort_stats(<br/>   ...:   "cumulative"   # sort by cumulative time spent<br/>   ...: ).print_stats(<br/>   ...:   "script.py"    # only show fn calls in script.py<br/>   ...: )</span><span id="8773" class="mv lu iq mr b gy nf mx l my mz">Fri Aug 07 08:12:06 2020    profile.stat</span><span id="b980" class="mv lu iq mr b gy nf mx l my mz">46338 function calls (45576 primitive calls) in 6.548 seconds</span><span id="bb71" class="mv lu iq mr b gy nf mx l my mz">Ordered by: cumulative time<br/>List reduced from 793 to 6 due to restriction &lt;'script.py'&gt;</span><span id="9838" class="mv lu iq mr b gy nf mx l my mz">ncalls tottime percall cumtime percall filename:lineno(function)<br/>     1   0.008   0.008   5.521   5.521 script.py:1(&lt;module&gt;)<br/>     1   0.012   0.012   5.468   5.468 script.py:19(read_books)<br/>     5   0.000   0.000   4.848   0.970 script.py:5(get_book)<br/>     5   0.000   0.000   0.460   0.092 script.py:11(split_words)<br/>     5   0.000   0.000   0.112   0.022 script.py:15(count_words)<br/>     1   0.000   0.000   0.000   0.000 script.py:32(save_results)</span></pre><p id="4beb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇！看看那些有用的信息！</p><p id="cddf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每个被调用的函数，我们看到以下信息:</p><ul class=""><li id="ec1a" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated"><code class="fe na nb nc mr b">ncalls</code>:函数被调用的次数</li><li id="ced6" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe na nb nc mr b">tottime</code>:给定函数花费的总时间(不包括调用子函数)</li><li id="0c60" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe na nb nc mr b">percall</code> : <code class="fe na nb nc mr b">tottime</code>除以<code class="fe na nb nc mr b">ncalls</code></li><li id="869e" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe na nb nc mr b">cumtime</code>:该功能和所有子功能花费的总时间</li><li id="0801" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe na nb nc mr b">percall</code>:(再次)<code class="fe na nb nc mr b">cumtime</code>除以<code class="fe na nb nc mr b">ncalls</code></li><li id="cb91" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe na nb nc mr b">filename:lineo(function)</code>:文件名、行号、函数名</li></ul><p id="ba0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当读取这个输出时，请注意我们隐藏了大量数据——事实上，我们只看到了 793 行中的 6 行。那些隐藏的行都是从像<code class="fe na nb nc mr b">urllib.request.urlopen</code>或<code class="fe na nb nc mr b">re.split</code>这样的函数中调用的子函数。另外，注意<code class="fe na nb nc mr b">&lt;module&gt;</code>行对应于<code class="fe na nb nc mr b">script.py</code>中不在函数内部的代码。</p><p id="faff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们回头看看结果，按累计持续时间排序。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1286" class="mv lu iq mr b gy mw mx l my mz">ncalls tottime percall cumtime percall filename:lineno(function)<br/>     1   0.008   0.008   5.521   5.521 script.py:1(&lt;module&gt;)<br/>     1   0.012   0.012   5.468   5.468 script.py:19(read_books)<br/>     5   0.000   0.000   4.848   0.970 script.py:5(get_book)<br/>     5   0.000   0.000   0.460   0.092 script.py:11(split_words)<br/>     5   0.000   0.000   0.112   0.022 script.py:15(count_words)<br/>     1   0.000   0.000   0.000   0.000 script.py:32(save_results)</span></pre><p id="b2e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住函数调用的层次结构。顶层<code class="fe na nb nc mr b">&lt;module&gt;</code>调用<code class="fe na nb nc mr b">read_books</code>，<code class="fe na nb nc mr b">save_results.</code>调用<code class="fe na nb nc mr b">get_book</code>，<code class="fe na nb nc mr b">split_words</code>和<code class="fe na nb nc mr b">count_words</code>。通过比较累积时间，我们看到<code class="fe na nb nc mr b">&lt;module&gt;</code>的大部分时间花在了<code class="fe na nb nc mr b">read_books</code>上，而<code class="fe na nb nc mr b">read_books</code>的大部分时间花在了<code class="fe na nb nc mr b">get_book</code>上，在这里我们发出 HTTP 请求，使得这个脚本(<em class="ls">不出所料</em>)受到 I/O 的限制。</p><p id="959c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们看看如何通过逐行剖析我们的代码来更加细化。</p><h1 id="8002" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">逐行剖析</h1><p id="c1c3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一旦我们使用 cProfile 了解了哪些函数调用花费了最多的时间，我们就可以逐行检查这些函数，从而更清楚地了解我们的时间都花在了哪里。</p><p id="aa00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们需要用以下命令安装<code class="fe na nb nc mr b">line-profiler</code>库:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="67c5" class="mv lu iq mr b gy mw mx l my mz">$ pip install line-profiler</span></pre><p id="f70e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦安装完毕，我们只需要将<code class="fe na nb nc mr b">@profile</code>装饰器添加到我们想要分析的函数中。以下是我们脚本的更新片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="25ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们不需要导入<code class="fe na nb nc mr b">profile</code>装饰函数——它将由<code class="fe na nb nc mr b">line-profiler</code>注入。</p><p id="7227" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，为了分析我们的函数，我们可以运行以下代码:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a5be" class="mv lu iq mr b gy mw mx l my mz">$ kernprof -l -v script-prof.py</span></pre><p id="e076" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc mr b">kernprof</code>随<code class="fe na nb nc mr b">line-profiler</code>一起安装。<code class="fe na nb nc mr b">-l</code>标志告诉<code class="fe na nb nc mr b">line-profiler</code>逐行进行，而<code class="fe na nb nc mr b">-v</code>标志告诉它将结果打印到终端，而不是保存到文件中。</p><p id="6a50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们脚本的结果看起来会像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里重点关注的关键栏目是<code class="fe na nb nc mr b">% Time</code>。正如你所看到的，我们解析每本书的 89.5%的时间都花在了<code class="fe na nb nc mr b">get_book</code>函数上——发出 HTTP 请求——进一步验证了我们的程序是 I/O 受限的，而不是 CPU 受限的。</p><p id="62a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，有了这个新的信息，如果我们想加速我们的代码，我们就不会浪费时间试图让我们的单词计数器更有效。与 HTTP 请求相比，它只需要很少的时间。相反，我们会专注于加速我们的请求——可能是通过异步方式。</p><p id="2670" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，结果并不令人惊讶，但是在一个更大更复杂的程序中，<code class="fe na nb nc mr b">line-profiler</code>是我们编程工具带中一个无价的工具，它允许我们窥视我们程序的内部并找到计算瓶颈。</p><h1 id="5831" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">轮廓记忆</h1><p id="5cfe" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">除了分析我们程序的时间复杂度，我们还可以分析它的内存复杂度。</p><p id="6e2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了进行逐行内存分析，我们需要安装<code class="fe na nb nc mr b">memory-profiler</code>库，它也使用相同的<code class="fe na nb nc mr b">@profile</code>装饰器来确定要分析哪个函数。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="cb0b" class="mv lu iq mr b gy mw mx l my mz">$ pip install memory-profiler</span><span id="8cf0" class="mv lu iq mr b gy nf mx l my mz">$ python -m memory_profiler script.py</span></pre><p id="d070" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在同一个脚本上运行<code class="fe na nb nc mr b">memory-profiler</code>的结果应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4ec1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前有一些关于“增量”准确性的<a class="ae kv" href="https://github.com/pythonprofilers/memory_profiler/issues/236" rel="noopener ugc nofollow" target="_blank">问题</a>，所以现在只关注“内存使用”栏。</p><p id="b119" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们把书分成单词时，我们的脚本在第 28 行内存使用达到峰值。</p><h1 id="db23" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="1e18" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">希望现在您的编程工具箱中有一些新工具来帮助您编写更高效的代码，并快速确定如何最好地利用您的优化时间。</p><p id="858f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里阅读更多关于 cProfile <a class="ae kv" href="https://docs.python.org/3/library/profile.html" rel="noopener ugc nofollow" target="_blank">的内容，在这里</a>阅读线分析器<a class="ae kv" href="https://github.com/pyutils/line_profiler" rel="noopener ugc nofollow" target="_blank">的内容，在这里</a>阅读内存分析器<a class="ae kv" href="https://github.com/pythonprofilers/memory_profiler" rel="noopener ugc nofollow" target="_blank">的内容。我也强烈推荐 Micha Gorelick 和 Ian Ozsvald [1]写的书<em class="ls">高性能 Python </em>。</a></p><p id="cc71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">感谢阅读！我很想听听你对分析器、数据科学或其他任何东西的看法。下面评论或者伸手上</em><a class="ae kv" href="https://www.linkedin.com/in/austinpoor" rel="noopener ugc nofollow" target="_blank"><em class="ls">LinkedIn</em></a><em class="ls">或者</em><a class="ae kv" href="https://twitter.com/austin_poor" rel="noopener ugc nofollow" target="_blank"><em class="ls">Twitter</em></a><em class="ls">！</em></p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="6556" class="lt lu iq bd lv lw ob ly lz ma oc mc md jw od jx mf jz oe ka mh kc of kd mj mk bi translated">参考</h1><p id="ab2f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">[1] M. Gorelick 和 I. Ozsvald，<a class="ae kv" href="https://www.oreilly.com/library/view/high-performance-python/9781492055013/" rel="noopener ugc nofollow" target="_blank">高性能 Python 第二版</a> (2020)，奥赖利媒体公司。</p></div></div>    
</body>
</html>