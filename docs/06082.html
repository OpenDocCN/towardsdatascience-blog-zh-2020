<html>
<head>
<title>Mechanics of the ROC Curve</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ROC曲线的力学</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mechanics-of-the-roc-curve-83b10ce3887f?source=collection_archive---------52-----------------------#2020-05-17">https://towardsdatascience.com/mechanics-of-the-roc-curve-83b10ce3887f?source=collection_archive---------52-----------------------#2020-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="56df" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">研究ROC曲线如何工作的直观仪表板</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/897188580ddabea30b4e958d29bfc643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VfAPEnrrcFQBWmsi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">里奇·卡拉瓦拉在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f3be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于手头的任务，预测模型可以分为两类，即分类器和回归器。回归模型旨在预测连续结果，而分类器旨在预测离散结果。</p><p id="ba28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在回归模型中，如果结果的分布是偏斜的，它会抛弃一些模型。例如，使用线性回归来预测<a class="ae ky" href="https://stats.stackexchange.com/questions/267078/why-is-skewed-data-not-preferred-for-modelling" rel="noopener ugc nofollow" target="_blank">偏态分布</a>会降低模型的性能。在线性回归的情况下，这种情况会发生，因为它违反了我们关于正态分布噪声的假设(您也可以考虑受一些“异常值”结果影响并阻碍学习过程的潜在损失函数；为了应对这种情况,<a class="ae ky" href="https://en.wikipedia.org/wiki/Huber_loss" rel="noopener ugc nofollow" target="_blank"> Huber回归</a>可能会有所帮助，因为潜在损失不会受到偏斜度的太大影响。).处理这种现象的一种方法是使用不同的模型，如<a class="ae ky" href="https://en.wikipedia.org/wiki/Random_forest" rel="noopener ugc nofollow" target="_blank">决策树</a>，g <a class="ae ky" href="https://en.wikipedia.org/wiki/Generalized_linear_model" rel="noopener ugc nofollow" target="_blank">一般化线性模型</a>等。本质上，结果分布在数据建模中起着重要的作用。</p><p id="d5c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与连续结果情况类似，离散结果(分类)也有类似的不平衡结果计数问题。例如，假设我们试图对一个数据集建模，其结果是1/0的形式。例如，1可能表示信用卡欺诈。大多数人不会犯欺诈罪，所以在这种情况下，计数会向0的方向倾斜。在<a class="ae ky" href="https://www.sciencedirect.com/science/article/abs/pii/S016786550500303X" rel="noopener ugc nofollow" target="_blank">这篇</a>论文中，他们引入了ROC曲线，作为一种工具，用于比较不同分类器的相对性能。这个工具正是受处理不平衡数据集问题的启发。这篇论文是深入理解ROC曲线概念的有趣读物。</p><p id="8ba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将尝试进一步解构ROC曲线的概念，并希望给你一个关于这些东西如何工作的直觉。我将使用<a class="ae ky" href="https://www.kaggle.com/uciml/pima-indians-diabetes-database" rel="noopener ugc nofollow" target="_blank"> PIMA糖尿病数据集</a>来研究ROC曲线。我将从描述问题开始，说明为什么使用简单的准确性度量是一个糟糕的选择，最后，介绍一个仪表板来查看运行中的ROC曲线。</p><h1 id="8390" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题是</h1><p id="b12c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">该数据集包含以下预测因子:妊娠次数，血糖浓度。、血压、皮褶厚度、血清胰岛素、身体质量指数、糖尿病谱系函数值、年龄。这些是诊断测量，目的是建立一个预测模型，对患者是否患有(1)糖尿病(0)进行分类。在数据收集过程中，设置了几个约束条件。例如，数据集中的所有患者都是至少21岁的女性。由于这种限制，并基于各种预测值(就其物理意义而言)，我们可能需要在将该数据集用于某些模型(如线性回归)之前进行一些预处理。此外，数据集也有一些缺失值。为了保持本文简洁，避免偏离讨论的主题，我不讨论数据预处理步骤。你可以在这里找到更多<a class="ae ky" href="https://medium.com/@sahilgupta_86549/pima-diabetes-dataset-77ee2aa67ce7" rel="noopener">的信息。</a></p><p id="3fe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们进行了适当的预处理，让我们看看结果变量的计数。我们可以在图1中观察到，计数偏向于标签0，即与糖尿病患者相比，没有糖尿病的患者数量要多得多。</p><div class="kj kk kl km gt ab cb"><figure class="ms kn mt mu mv mw mx paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/bf489b5726c1b440f8589cf9f0ad0584.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*aILvvLtRqzSeo4UU2HTIKQ.png"/></div></figure><figure class="ms kn my mu mv mw mx paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/47d70128f736db5c89eae19063522f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*_a2TpEMAdpeuDHtCLZIICQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk mz di na nb translated">图。1(左)。响应变量直方图。患者总数为768人；500名患者没有糖尿病(0)，268名患者有糖尿病(1)。图。2(右)一个表格，描述了我们的预测模型中的分类可以达到的级别。</p></figure></div><p id="14c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分类器的准确度被定义为它执行的所有分类中正确分类的数量。用技术术语来说，每当一个分类者进行分类时，它可以落在图2中四个框中的任何一个中。例如，这是我们如何读取单元格“FP”的表格:对于特定的分类，我们看到标签为0，但分类器将其预测为1，即预测模型预测一个没有糖尿病的人患有糖尿病，这解释了为什么它被称为假阳性(FP)。精确度定义为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/7504a6c069da30bb34b22e21aa858031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kw_w75CBqUOhACmYeblSTw.png"/></div></div></figure><p id="2238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建一个相当准确但完全无用的分类器非常容易。例如，我们可以使用数据集中的类频率构建一个随机分类器。真阴性(非糖尿病)的比例为768分之500。在预测时，该随机分类器以500/768或0.651的概率预测一个人没有糖尿病。所以，这个分类器的准确率是65.1%！但是，我们知道这在实际应用中完全没有用。显然，在我们对预测模型的准确性评估中，有一些缺失。直观地说，准确性关注的是模型能够捕捉的实际真值(即TP和TN)。然而，在图1中，我们看到计数是偏斜的。因此，考虑到模型做出的错误预测(即FP和FN)也是有意义的，因为错过更罕见事件的实际成本可能会高得多(随着计数偏斜度的增加，这可能会进一步增加)。</p><p id="0056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经说服自己，评估预测分类模型的常用方法(即基于准确性)似乎不适用于不平衡的数据集。ROC曲线是帮助我们做到这一点的一个工具。</p><h1 id="41c5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">ROC曲线</h1><p id="5efb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">ROC曲线，顾名思义，是真阳性率(TPR)和假阳性率(FPR)之间的图形。这些被定义为，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/512fa3510a59f635a57c7da4b21a7194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJcsjgAd4YWB6KNdzV-RZA.png"/></div></div></figure><p id="c8c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着理解这些术语，然后看看为什么ROC曲线可能是一个好的选择。让我们从分母开始。注意，TPR和FPR中的分母分别是实际正和实际负(正指标签1，负指标签0，类似于图2)。例如，根据图2(见上图),我们知道糖尿病患者可以通过模型预测为糖尿病患者(TP)或非糖尿病患者(FN)。因此，TPR表示所有阳性<strong class="lb iu">标签</strong>中真正阳性(由模型预测)的比例。类似地，FPR指出了假阳性(由模型预测)在所有阴性<strong class="lb iu">标签</strong>中的比例。这里要注意的关键点是，这两个量是在更细粒度的水平上看分类器的预测。我们也可以用类似的方式解释这两个量的补数。TPR的补充将是FNR(假阴性率)，对于FPR，它将是TNR(真阴性率)。TPR也叫灵敏度，1-FPR叫选择性。所以，我们也可以说ROC曲线是灵敏度v/S1-选择性的曲线图。</p><p id="39bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便提一下，灵敏度(TPR)和选择性(1-FPR)也可以解释为条件概率。例如，敏感度是将数据点(在PIMA数据集中带有正标签)分类为正的概率(请注意，分母TP+FN是真正标签为1的数据点，TP是数据集中实际的正标签)。用数学术语来说，这就是灵敏度和选择性的定义，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/7bc7a6b5fc6a0260be7452566751b59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XHHX4mes43-rx9QmaEJV1Q.png"/></div></div></figure><p id="4a8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正是一个条件概率描述。这里，sₒ是一个阈值，其使用如下:如果我们的分类器的分数高于阈值(sₒ)，那么它被分类为正标签(1)，否则为负标签(0)。敏感性和特异性这两个术语在医学中被广泛使用，从疾病的角度思考这些定义会使它们更加直观:通过PIMA糖尿病数据集，我们的目标是建立分类模型，可以识别糖尿病患者和非糖尿病患者。因此，敏感度定义了我们的模型(/test)正确识别糖尿病患者的能力。类似地，特异性定义了我们的模型(/test)在检测非糖尿病患者方面的特异性(通常，在疾病的情况下，未患病的患者数量比患病的患者数量多得多)。</p><p id="36e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们观察ROC曲线所在的平面，获得一些直觉。虚线表示随机分类器，其中TPR = FPR。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/c9607c9398d366c85a12321f1aba016c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*cMSH0rxXGZYzmmrt-SOYEQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3。ROC曲线所在的平面。注意，根据FPR的定义，TPR ∈ [0，1]。</p></figure><p id="a008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是基于先前(来自训练集)类别频率的随机分类器将在<strong class="lb iu">平均</strong>时获得相似的条件频率，因此等于TPR和FPR。假设正标签和负标签的先验类别比例分别为α和1- α。基于此的随机分类器将平均预测样本的α分数为糖尿病。这也意味着在<strong class="lb iu">所有</strong>糖尿病患者的样本中，它将平均预测α部分患者为糖尿病，这表示敏感性为α。使用类似的论证，我们可以说选择性是1-α，这意味着FPR是α。因此，线TPR=FPR实际上代表一个随机分类器。</p><p id="61f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过观察曲线中的极值点，我们可以获得一些进一步的直觉。左下方的绿点(FPR=0且TPR=0)表示具有0灵敏度和1选择性的分类器，即它在识别非糖尿病患者方面非常好，而在识别糖尿病患者方面非常差。另一方面，右上角(FPR=1和TPR=1)表示分类器确实擅长识别糖尿病患者，但不擅长识别非糖尿病患者。换句话说，分类器是超级敏感的，代价是没有选择性。最后，左上角(FPR=0和TPR=1)代表一个理想的分类器:它具有完美的灵敏度(=1)和完美的选择性(=1)。</p><p id="960c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用类似的方法，我们可以比较标记为红叉的两个分类器。与右侧相比，左侧具有更好的选择性和更差的灵敏度。一般来说，我们的目标是建立一个尽可能靠近左上角的分类器。</p><h1 id="3757" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">ROC曲线仪表板</h1><p id="71c5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，我们可以看到真正的ROC曲线了。为了澄清我在敏感度和选择性的定义中提到的关于分数的任何混淆，在我们给预测分配标签之前，这些可以被认为是值。例如，在<a class="ae ky" href="https://en.wikipedia.org/wiki/Logistic_regression#Examples" rel="noopener ugc nofollow" target="_blank">逻辑回归模型</a>中，它是数据点的对数优势值。通常，使用0.5(概率)的隐含阈值(在我们的头脑中，或在纸上)。在对数赔率的上下文中，这基本上意味着我们正在选择可能性更大的事件(记住，<a class="ae ky" href="https://en.wikipedia.org/wiki/Logit" rel="noopener ugc nofollow" target="_blank">对数赔率</a>是事件赔率的对数比)。就像我们之前看到的，有时候这个阈值0.5不是一个好主意(准确性)，我们需要一个更好的阈值。ROC曲线正好帮助我们做到了这一点。事不宜迟，这里有一个仪表板，您可以使用它，让这些事情变得更加直观。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/c643a361f15e909f6257d756d1ada74d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PYThKeHDg8jWJGPm16TpCw.gif"/></div></div></figure><p id="46e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里找到这个仪表盘<a class="ae ky" href="https://github.com/sahilgupta2105/Medium-Articles/blob/master/MechanicsOfTheRocCurve.ipynb" rel="noopener ugc nofollow" target="_blank">的Jupyter笔记本。运行笔记本中的所有单元格后，仪表板会弹出。dashboard使用Plotly和Python小部件，这使得将它直接嵌入到medium上有点棘手。</a></p><p id="37e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在离开仪表板之前，让我说几句如何解释仪表板。在顶部，您可以找到两个阈值滑块，用于控制逻辑回归和随机森林的阈值(在灵敏度和选择性定义中定义)。左上角的图是使用逻辑回归模型生成的分数的逻辑分布。我已经将它包含在仪表板中，以使事情更加清晰。但是，在随机森林的情况下，分布的函数形式是未知的，这就是为什么省略随机森林情况下的分布。接下来，在它的右边，我们有一个模型和标记的ROC曲线图，显示了阈值的当前值。随着滑块的移动，标记在各自的ROC曲线上移动。</p><p id="1ea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，我们有两个模型的条件概率分布，即以分类器知道预测的标签为条件。例如，假设分类器预测一个人是糖尿病患者，以Pred=1为条件的概率定义了一个人是糖尿病患者(TP)还是非糖尿病患者(FP)的概率。换句话说，底部的两个图给了我们一个互补的视角，当阈值变化时会发生什么。请注意，敏感度(和选择性)是条件概率，条件是知道数据点的真实标签是C=1(或C=0)。</p><p id="e63e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里您可以注意到的一个有趣的事情是，对于一个特定的模型(和超参数值)，ROC曲线是固定的，改变阈值有助于我们进一步调整模型，以更好地与手头的业务目标保持一致(考虑灵敏度和选择性)。通常，使用交叉验证来选择阈值。</p></div></div>    
</body>
</html>