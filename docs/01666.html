<html>
<head>
<title>Building an Incremental Recommender System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个增量推荐系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-an-incremental-recommender-system-8836e30afaef?source=collection_archive---------11-----------------------#2020-02-15">https://towardsdatascience.com/building-an-incremental-recommender-system-8836e30afaef?source=collection_archive---------11-----------------------#2020-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="99b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理想情况下，推荐系统应该能够适应发生的变化。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0b28d9743e47a230f3bc633b1ccd5807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sf1x5qSVfTpu8QU6VQ4oPg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Nathália Rosa 在<a class="ae ky" href="https://unsplash.com/s/photos/products?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><blockquote class="kz la lb"><p id="b23f" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae ky" href="https://mailchi.mp/d2d2d4a109b5/learning-rate-newsletter" rel="noopener ugc nofollow" target="_blank"> Learning Rate </a>是一份时事通讯，面向那些对AI和MLOps世界感到好奇的人。你会在每周五收到我关于最新人工智能新闻和文章的更新和想法。订阅<a class="ae ky" href="https://mailchi.mp/d2d2d4a109b5/learning-rate-newsletter" rel="noopener ugc nofollow" target="_blank">这里</a>！</p></blockquote></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="6d69" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">这个故事的第二部分现在通过下面的《走向数据科学》发表。</p><div class="mj mk gp gr ml mm"><a rel="noopener follow" target="_blank" href="/building-an-incremental-recommender-system-part-ii-2d0e782b2cf6"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">构建增量推荐系统:第二部分</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">自信地超越最先进的技术！</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">towardsdatascience.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na ks mm"/></div></div></a></div><h1 id="3f3a" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">要求或先决条件</h1><p id="2101" class="pw-post-body-paragraph lc ld it lf b lg nt ju li lj nu jx ll mg nv lo lp mh nw ls lt mi nx lw lx ly im bi translated">虽然我会尽量减少数学术语，但这个故事希望读者熟悉用户-项目交互矩阵、矩阵分解、嵌入空间等概念，以及基本的机器学习术语。这个故事不是对推荐系统的介绍。这是对它们的增量变体的介绍。无论如何，这个故事是写给你可能称之为机器学习和推荐系统世界的初学者的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/7adae15d1bc838ddff39ec047d8092a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMP7saNWD28N9NcWS4wkFg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">推荐系统的矩阵分解</p></figure><h1 id="65fa" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">介绍</h1><p id="6bc7" class="pw-post-body-paragraph lc ld it lf b lg nt ju li lj nu jx ll mg nv lo lp mh nw ls lt mi nx lw lx ly im bi translated">开始一个机器学习项目，数据科学家收集数据，处理数据，训练模型，并将其部署到生产中。当模型的性能开始恶化时，数据科学家通常会从头开始重复这个循环。只是这一次，他们有了新的数据示例来更新模型并提高其性能。然而，这通常是一种适得其反且效率低下的做法，尤其是对于那些对当前数据做出决策至关重要的业务领域。</p><p id="2f14" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">现在，进入推荐系统的世界，用户的偏好会根据季节、预算、流行趋势等频繁变化。此外，到来的客户和新库存会产生所谓的冷启动问题，即系统没有足够的信息来将消费者与产品或服务相匹配。理想情况下，推荐系统应该在这些变化发生时适应这些变化，修改其模型以始终代表当前状态，同时要求数据只经过一次。这就是增量学习的思想。</p><p id="24b6" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">这个故事是一个系列的第一部分，在这个系列中，我们通过实践的方法来探索如何将增量学习的思想应用于推荐系统。在第一部分中，我们使用基于Pytorch构建的python库，名为<a class="ae ky" href="https://pypi.org/project/cf-step/" rel="noopener ugc nofollow" target="_blank"> CF Step </a>，重现了joo Vinagre等人在<em class="le">“快速增量矩阵因式分解，用于仅含正反馈的推荐”</em>出版物中给出的结果。接下来，我们将通过应用几个技巧来达到更高的目标。</p><h1 id="bcf6" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">快速增量矩阵分解</h1><p id="56cf" class="pw-post-body-paragraph lc ld it lf b lg nt ju li lj nu jx ll mg nv lo lp mh nw ls lt mi nx lw lx ly im bi translated">我们将要实现的算法使用隐式的、仅肯定的反馈。让我们试着揭开这两个关键词的神秘面纱。<em class="le">隐性反馈</em>是指用户从来没有对自己互动过的项目表达过直接的意见，比如评分。隐式反馈的一个例子是，客户购买了多少次产品，或者他们看了多少分钟的电影。客户购买产品或使用服务越多，我们就越有信心认为这是偏好的表现。<em class="le">仅正面反馈</em>是一个通常与隐性反馈联系在一起的术语。这是因为，在隐性反馈的情况下，我们很少知道什么构成了负面互动。一个用户不与一个项目交互并不意味着什么。想象一个超市里的消费者。如果客户还没有购买特定产品，我们无法确定原因。</p><p id="7254" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">回到我们的实现，仅正意味着用户-项目交互矩阵<code class="fe nz oa ob oc b"><em class="le">R</em></code> <em class="le"> </em>仅包含布尔值，其中<code class="fe nz oa ob oc b">true</code>值指示偏好，<code class="fe nz oa ob oc b">false</code>值被视为缺失。这个假设有两个主要含义:保持了<code class="fe nz oa ob oc b"><em class="le">R</em></code>的稀疏性，因为在训练期间仅使用正反馈，并且<code class="fe nz oa ob oc b">false</code>值对于任何用户-项目交互都是完全有效的推荐候选。</p><h1 id="9a11" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">算法和方法</h1><p id="5b4b" class="pw-post-body-paragraph lc ld it lf b lg nt ju li lj nu jx ll mg nv lo lp mh nw ls lt mi nx lw lx ly im bi translated">现在让我们更仔细地看看本文中提出的增量随机梯度下降(ISGD)算法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/0a75050c83ee2c2438c0e03189fe35dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVOQLif6UdKWoq-UhAoiGQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ISGD —增量新币</p></figure><p id="5ace" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">我们拥有的数据是元组或用户-项目交互。记住，这些都是积极的互动。算法的输入是三个数字；<code class="fe nz oa ob oc b">feat</code>，用户或项目嵌入空间的维度，<code class="fe nz oa ob oc b">λ</code>，正则化系数，<code class="fe nz oa ob oc b">η</code>，学习率。该算法的输出是两个嵌入矩阵:用户的<code class="fe nz oa ob oc b"><em class="le">A</em></code>和项目的<code class="fe nz oa ob oc b"><em class="le">B</em></code>。这些矩阵的维数分别是<code class="fe nz oa ob oc b">number_of_users x feat</code>代表<code class="fe nz oa ob oc b"><em class="le">A</em></code>和<em class="le"> </em> <code class="fe nz oa ob oc b"><em class="le">number_of_items x feat</em></code> <em class="le"> </em>代表<code class="fe nz oa ob oc b"><em class="le">B</em></code> <em class="le">。然后我们有几个不同的步骤:</em></p><ul class=""><li id="465d" class="oe of it lf b lg lh lj lk mg og mh oh mi oi ly oj ok ol om bi translated">检查活动用户是否已知。如果没有，创建一个具有随机潜在特征的新用户，从具有平均值<code class="fe nz oa ob oc b">0</code>和标准偏差<code class="fe nz oa ob oc b">1</code>的正态分布中抽取。对活动项目执行相同的操作。</li><li id="216f" class="oe of it lf b lg on lj oo mg op mh oq mi or ly oj ok ol om bi translated">计算损失。因为我们只需要处理正反馈，目标永远是<code class="fe nz oa ob oc b">1</code>。因此，我们只需从<code class="fe nz oa ob oc b">1</code>中减去我们的预测。</li><li id="4489" class="oe of it lf b lg on lj oo mg op mh oq mi or ly oj ok ol om bi translated">使用通用更新规则更新活跃用户的潜在特征(用户嵌入矩阵中的参数)。对活动项目执行相同的操作。</li><li id="1a81" class="oe of it lf b lg on lj oo mg op mh oq mi or ly oj ok ol om bi translated">转到下一个数据点。这样，我们可以处理任意长度的流数据。</li></ul><h1 id="b254" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">实施和评估</h1><p id="13ca" class="pw-post-body-paragraph lc ld it lf b lg nt ju li lj nu jx ll mg nv lo lp mh nw ls lt mi nx lw lx ly im bi translated">对于这个实现，我们将使用<a class="ae ky" href="https://pypi.org/project/cf-step/" rel="noopener ugc nofollow" target="_blank"> CF Step </a> Python库和众所周知的<a class="ae ky" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank"> Movielens </a>数据集。CF Step是一个开源库，用python编写，构建于Pytorch之上，支持增量学习推荐系统的快速实现。这个图书馆是欧洲研究项目“云应用”的副产品。您可以通过运行以下命令轻松安装该库:</p><pre class="kj kk kl km gt os oc ot ou aw ov bi"><span id="0dfc" class="ow nc it oc b gy ox oy l oz pa">pip install cf-step</span></pre><p id="78b0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">接下来，下载movielens 1m数据集并在方便的位置提取<code class="fe nz oa ob oc b">ratings.dat</code> <em class="le"> </em>文件，例如Linux中的<code class="fe nz oa ob oc b">tmp</code>文件夹。对于这个实现，我们只需要这个文件。其余的文件(<code class="fe nz oa ob oc b">users.dat</code>和<code class="fe nz oa ob oc b">movies.dat</code>)包含关于用户和电影的元数据。我们将使用pandas加载内存中的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/5d250f843c6a7185e1f367bf58c9ab07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*V17yhscfV0m1Mt90C33xQg.png"/></div></figure><p id="2bff" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">如您所见，我们将用户和电影id转换为类别，以便提取类别代码。现在，我们不必为嵌入矩阵生成创建单独的词汇表。我们只需要处理用户和电影代码，而不是id。最后，我们总是通过这个数据帧在代码和id之间建立联系，以找到原始用户和电影。现在，让我们看看我们正在处理的独特用户和电影的数量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="d08c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">如果我们打印这些数字，我们会看到我们正在与6040个独特的用户和3706个独特的电影。接下来，我们将按<em class="le">时间戳对数据进行排序，以</em>模拟流事件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="729a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">正如我们所讨论的，该算法只支持正反馈。因此，我们将把<code class="fe nz oa ob oc b">5 </code>的评分视为正面反馈，并放弃任何其他评分。我们希望用<code class="fe nz oa ob oc b">1 </code>来标识喜欢的东西，用<code class="fe nz oa ob oc b">0</code>来标识不喜欢的东西，并创建一个名为<code class="fe nz oa ob oc b">preference</code>的新列来保存它们。然后，我们可以只过滤<code class="fe nz oa ob oc b">preference == 1</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/4b783257445ff5a9934c89950a63a0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*Sgi9SU2onlb87MHkqNbZkQ.png"/></div></figure><p id="7cd5" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">下面，让我们初始化我们的模型。为此，我们需要一个模型架构、一个目标函数(即损失函数)和一个优化器。我们将使用<code class="fe nz oa ob oc b">SimpleCF</code>网络作为模型架构，这是CF Step提供的内置神经网络架构。对于目标函数，我们将使用一个简单的<code class="fe nz oa ob oc b">lambda</code>函数，它接受一个预测和一个目标，并从目标中减去预测。在我们的例子中，目标总是<code class="fe nz oa ob oc b">1</code>。对于优化器，我们将使用Pytorch的SGD实现。我们选择的因子数是<code class="fe nz oa ob oc b">128</code>，学习率是<code class="fe nz oa ob oc b">0.06</code>。现在我们准备初始化<code class="fe nz oa ob oc b">Step</code>模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="5050" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">评估方法如下:</p><ul class=""><li id="452a" class="oe of it lf b lg lh lj lk mg og mh oh mi oi ly oj ok ol om bi translated">通过对前20%的数据进行训练来引导模型。</li><li id="1f2c" class="oe of it lf b lg on lj oo mg op mh oq mi or ly oj ok ol om bi translated">使用<code class="fe nz oa ob oc b">recall@k</code>作为度量，模拟数据流并评估模型的性能。</li><li id="87e9" class="oe of it lf b lg on lj oo mg op mh oq mi or ly oj ok ol om bi translated">如果用户是已知的，则进行预测并为该预测计算<code class="fe nz oa ob oc b">recall@k</code>。然后，使用这种用户-项目交互，递增地训练算法。</li><li id="7757" class="oe of it lf b lg on lj oo mg op mh oq mi or ly oj ok ol om bi translated">如果用户是未知的，只需使用这种用户-项目交互来递增地训练算法。</li></ul><p id="9860" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">为此，让我们获取前20%的数据，创建数据加载器并批量拟合模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="f881" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">然后，我们获取剩余的数据并创建一个不同的数据集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="03a9" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">最后，使用<code class="fe nz oa ob oc b">recall@10</code>模拟流并评估模型。这一步在GPU上需要五到六分钟。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="5d0e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">我们可以使用下面的代码来可视化我们的训练结果。为此，我们将使用<code class="fe nz oa ob oc b">5k</code>滑动窗口的移动平均值，就像他们在出版物中所做的那样。我们可以看到，该图遵循了论文中针对movielens数据集给出的结果。要保存模型，使用<code class="fe nz oa ob oc b">model.save()</code>内置方法并传递一个有效路径。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/5d47ec5d06322650f7ae2c23da3d042a.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*B6XqgZA0PiR6s35U0KUJwA.png"/></div></figure><h1 id="4544" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">结论</h1><p id="b7c3" class="pw-post-body-paragraph lc ld it lf b lg nt ju li lj nu jx ll mg nv lo lp mh nw ls lt mi nx lw lx ly im bi translated">在这个故事中，我们展示了增量学习在推荐系统中的重要性，并复制了由joo Vinagre等人发表的<em class="le">“快速增量矩阵分解用于仅正面反馈的推荐”</em>的结果。我们介绍了<a class="ae ky" href="https://pypi.org/project/cf-step/" rel="noopener ugc nofollow" target="_blank"> CF Step </a> python库，这是一个开源库，可以快速实现增量学习推荐系统。在下一章中，我们将更进一步，尝试提高算法的精确度。</p><blockquote class="kz la lb"><p id="6355" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf iu">我叫Dimitris Poulopoulos，是希腊比雷埃夫斯大学<em class="it"/></strong><a class="ae ky" href="https://bigdatastack.eu/" rel="noopener ugc nofollow" target="_blank"><strong class="lf iu">BigDataStack</strong></a><strong class="lf iu"><em class="it"/>的机器学习研究员和博士(c)。我曾为欧洲委员会、欧盟统计局、国际货币基金组织、欧洲中央银行、经合组织和宜家等主要客户设计和实施人工智能和软件解决方案。如果你有兴趣阅读更多关于机器学习、深度学习和数据科学的帖子，请在twitter上关注我的</strong><a class="ae ky" href="https://medium.com/@dpoulopoulos" rel="noopener"><strong class="lf iu"/></a><strong class="lf iu"/><a class="ae ky" href="https://www.linkedin.com/in/dpoulopoulos/" rel="noopener ugc nofollow" target="_blank"><strong class="lf iu">LinkedIn</strong></a><strong class="lf iu">或</strong><a class="ae ky" href="https://twitter.com/james2pl" rel="noopener ugc nofollow" target="_blank"><strong class="lf iu">@ james2pl</strong></a><strong class="lf iu">。</strong></p></blockquote></div></div>    
</body>
</html>