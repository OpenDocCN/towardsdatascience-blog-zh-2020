<html>
<head>
<title>Five Cool Python Looping Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">五个很酷的Python循环技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/five-cool-python-looping-tips-14f6f44bcfc7?source=collection_archive---------4-----------------------#2020-04-04">https://towardsdatascience.com/five-cool-python-looping-tips-14f6f44bcfc7?source=collection_archive---------4-----------------------#2020-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="188b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">帮助你掌握Python迭代循环技巧的5个技巧。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/adb76c5d448e7376d7091f9eeb854df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0K1rGYGvimZ3AnCPZdW8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(python标识由<a class="ae ky" href="http://python.org)" rel="noopener ugc nofollow" target="_blank">http://python.org提供)</a></p></figure><p id="86e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">或者循环很可能是一个新的Python程序员最先学会的概念之一。这是有充分理由的，因为for循环可以对数据做很多事情，而不会变得狡猾。然而，经常很容易让您的思想停留在简单迭代的世界中，而没有利用一些更有效和简洁的迭代方法和技巧来应用于for循环。使用这些技巧不仅可以使for循环更快，还可以使代码更简洁，为Python中潜在的循环机会打开一扇新的大门。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="46ba" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">Zip:一次遍历两个列表</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/bd4cdca9887a37c572f5de97df8b0ce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6PmywoJrriIVV0-tPlUtVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(python徽标由http://python.org提供)</p></figure><p id="ef51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的经验中，我发现一个真正有价值的工具是一次遍历两个数组的能力。这在其他语言中显然要困难得多，而在Python中我非常欣赏这种简单性。为了一次遍历两个数组，我们只需使用zip()方法。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="9e1f" class="nj mm it nf b gy nk nl l nm nn">for first,second in zip(array1,array2):<br/>    print(first)<br/>    print(second)</span></pre><p id="13c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">演示这一点的一个很好的例子是用一组偶数和一组奇数进行计数:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="5af0" class="nj mm it nf b gy nk nl l nm nn">odds = [1,3,5,7,9]<br/>evens = [2,4,6,8,10]<br/>for oddnum, evennum in zip(odds,evens):<br/>    print(oddnum)<br/>    print(evennum)</span></pre><p id="97fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的输出会是:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="d444" class="nj mm it nf b gy nk nl l nm nn">1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9<br/>10</span></pre><h1 id="abfa" class="ml mm it bd mn mo no mq mr ms np mu mv jz nq ka mx kc nr kd mz kf ns kg nb nc bi translated">在范围内:编写一个C风格的循环</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/ffc2c8424de3c482992f6b1cc8dd20ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F0cPzaBQn6Tp1DZ1v7LPlg.png"/></div></div></figure><p id="e039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这看起来很基本，但是你可以用经典的C风格的循环做很多有趣的事情。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="464b" class="nj mm it nf b gy nk nl l nm nn">for i in range(10):<br/>    print(i)<br/>    if i == 3:<br/>        i.update(7)</span></pre><p id="a430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们中的C爱好者可能认为这不一定是C风格的for循环，但这是不用编写自己的迭代方法就能得到的最接近的方法。幸运的是，我喜欢浪费时间，所以我决定写一个新的迭代器来尽可能接近经典的C循环:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3bf4" class="nj mm it nf b gy nk nl l nm nn">class forrange:<br/><br/>    def __init__(self, startOrStop, stop=None, step=1):<br/>        if step == 0:<br/>            raise ValueError('forrange step argument must not be zero')<br/>        if not isinstance(startOrStop, int):<br/>            raise TypeError('forrange startOrStop argument must be an int')<br/>        if stop is not None and not isinstance(stop, int):<br/>            raise TypeError('forrange stop argument must be an int')<br/><br/>        if stop is None:<br/>            self.start = 0<br/>            self.stop = startOrStop<br/>            self.step = step<br/>        else:<br/>            self.start = startOrStop<br/>            self.stop = stop<br/>            self.step = step<br/><br/>    def __iter__(self):<br/>        return self.foriterator(self.start, self.stop, self.step)<br/><br/>    class foriterator:<br/><br/>        def __init__(self, start, stop, step):<br/>            self.currentValue = None<br/>            self.nextValue = start<br/>            self.stop = stop<br/>            self.step = step<br/><br/>        def __iter__(self): return self<br/><br/>        def next(self):<br/>            if self.step &gt; 0 and self.nextValue &gt;= self.stop:<br/>                raise StopIteration<br/>            if self.step &lt; 0 and self.nextValue &lt;= self.stop:<br/>                raise StopIteration<br/>            self.currentValue = forrange.forvalue(self.nextValue, self)<br/>            self.nextValue += self.step<br/>            return self.currentValue<br/><br/>    class forvalue(int):<br/>        def __new__(cls, value, iterator):<br/>            value = super(forrange.forvalue, cls).__new__(cls, value)<br/>            value.iterator = iterator<br/>            return value<br/><br/>        def update(self, value):<br/>            if not isinstance(self, int):<br/>                raise TypeError('forvalue.update value must be an int')<br/>            if self == self.iterator.currentValue:<br/>                self.iterator.nextValue = value + self.iterator.step</span></pre><h1 id="c697" class="ml mm it bd mn mo no mq mr ms np mu mv jz nq ka mx kc nr kd mz kf ns kg nb nc bi translated">Enumerate():索引您的dim</h1><p id="b2d8" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">Python中的enumerate方法允许Python对从数组中出来的列表索引进行编号。为了证明这一点，我将列出一个包含三个元素的列表:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="521d" class="nj mm it nf b gy nk nl l nm nn">l = [5,10,15]</span></pre><p id="87e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以像这样访问数组索引:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="b1cf" class="nj mm it nf b gy nk nl l nm nn">l[1]<br/>10<br/>l[0]<br/>5<br/>l[2]<br/>15</span></pre><p id="5941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在枚举这些列表的时候，我们会把dim的索引位置，连同dim，一起砸进一个新的变量里。注意新变量的类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/eec6b533e4f3d5d89557a7e7e4c88fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*o8pYOpaUE48UV8TPabbu_A.png"/></div></figure><p id="2ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python会自动把这些索引放到一个元组里，我觉得很奇怪。我当然更喜欢用一个元素的Python字典来接收结果。幸运的是，我们总是可以用Python的将我们的枚举转换成Python字典</p><blockquote class="oa"><p id="c850" class="ob oc it bd od oe of og oh oi oj lu dk translated">“非常简单”</p></blockquote><p id="a2fe" class="pw-post-body-paragraph kz la it lb b lc ok ju le lf ol jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">类型断言！</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="f9f9" class="nj mm it nf b gy nk nl l nm nn">data = dict(enumerate(l))</span></pre><p id="b15e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将给我们:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="dc9a" class="nj mm it nf b gy nk nl l nm nn">&gt;&gt;&gt; data<br/>{0: 5, 1: 10, 2: 15}</span></pre><h1 id="42a2" class="ml mm it bd mn mo no mq mr ms np mu mv jz nq ka mx kc nr kd mz kf ns kg nb nc bi translated">Sorted():在期间而不是之前对数据进行排序。</h1><p id="a3bb" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">对于任何处理大量数据的人来说，排序方法都是一种基本方法，数据科学家通常都应该这样做。排序是按照预期的方式工作的，字符串按照从字母A到字母B的字母顺序排序，整数和双精度从- <strong class="lb iu"> ∞ </strong>升序排序。关于这个函数需要注意的一点是，它不能处理包含字符串、整数或浮点数的列表。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="8252" class="nj mm it nf b gy nk nl l nm nn">l = [15,6,1,8]<br/>for i in sorted(l):<br/>    print(i)<br/>1<br/>6<br/>8<br/>15</span></pre><p id="5702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以通过将reverse参数设置为False来执行相反的操作:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="c840" class="nj mm it nf b gy nk nl l nm nn">for i in sorted(l,reverse = True):<br/>    print(i)<br/>15<br/>8<br/>6<br/>1</span></pre><p id="f1df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们可用的最后一个参数，我们可以使用一个键。密钥是应用于给定循环内每个dim的函数。为此，我喜欢使用lambda，它将创建一个匿名但仍可调用的函数。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3d9a" class="nj mm it nf b gy nk nl l nm nn">l.sort(key=lambda s: s[::-1])</span></pre><h1 id="c5ce" class="ml mm it bd mn mo no mq mr ms np mu mv jz nq ka mx kc nr kd mz kf ns kg nb nc bi translated">Filter():只循环你想要的数据。</h1><p id="18a5" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在处理大量数据时，一个绝对有助于提高性能的函数是filter函数。filter函数完全按照您的预期工作，在迭代之前过滤掉数据。当您只想对特定范围内的数据产生影响，而不必对其应用条件时，这可能会很有用。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="1e81" class="nj mm it nf b gy nk nl l nm nn">people = [{"name": "John", "id": 1}, {"name": "Mike", "id": 4}, {"name": "Sandra", "id": 2}, {"name": "Jennifer", "id": 3}]</span><span id="b638" class="nj mm it nf b gy op nl l nm nn">for person in filter(lambda i: i["id"] % 2 == 0, people):<br/>...     print(person)<br/>... <br/>{'name': 'Mike', 'id': 4}<br/>{'name': 'Sandra', 'id': 2}</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="706d" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">结论</h1><p id="9621" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">理想情况下，将这些方法应用到Python代码中不仅会使代码更简洁，而且很可能会更快。利用这些方法将会给你迭代的超能力，并使通过迭代处理大量数据变得容易得多，这有时是不可避免的。</p></div></div>    
</body>
</html>