<html>
<head>
<title>Turn Your Excel Workbook Into a SQLite Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Excel工作簿转换为SQLite数据库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/turn-your-excel-workbook-into-a-sqlite-database-bc6d4fd206aa?source=collection_archive---------3-----------------------#2020-05-18">https://towardsdatascience.com/turn-your-excel-workbook-into-a-sqlite-database-bc6d4fd206aa?source=collection_archive---------3-----------------------#2020-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/4378dc6cc7672782617be762092e5848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8pUcIVteZSETt3af"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片来自<a class="ae jd" href="https://unsplash.com/@jankolar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">推特:@jankolario </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><div class=""/><div class=""><h2 id="f032" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">将电子表格转换成可查询的数据库表格</h2></div><h1 id="fe66" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">介绍</h1><p id="bdef" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Relational_database" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh">关系数据库</strong> </a> <strong class="lp jh"> </strong>是数据表的集合——存储单个数据的行和列的集合——它们可以相互连接。这样，关系数据库与Excel工作簿并不完全不同，Excel工作簿中的相关数据集存储在多个工作表中。考虑到这一点，本文通过一个例子，使用Python将Excel电子表格转换成可以使用<strong class="lp jh">结构化查询语言(SQL) </strong>查询的数据库。</p><h1 id="7b69" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">数据</h1><p id="58c0" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这篇文章中的例子使用了来自<em class="mj">超市销售</em>数据集的数据，可以在<a class="ae jd" href="https://data.world/scottadams26/superstoresalesexample" rel="noopener ugc nofollow" target="_blank">这里</a>找到。该数据集存储为Excel工作簿，包含存储在以下四个表中的示例销售交易数据:<em class="mj">销售</em>、<em class="mj">订单</em>、<em class="mj">客户</em>和<em class="mj">产品。</em></p><h2 id="cc4c" class="mk kw jg bd kx ml mm dn lb mn mo dp lf lw mp mq lh ma mr ms lj me mt mu ll mv bi translated">用Python读取数据</h2><p id="04e0" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">首先，如果您没有使用<code class="fe mw mx my mz b">conda</code>或<code class="fe mw mx my mz b">pip</code>安装<code class="fe mw mx my mz b">xlrd</code>包，请在启动Python会话之前安装，否则当您试图读取Excel文件时会遇到以下错误(即使安装了<em class="mj"> pandas </em>)。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi na"><img src="../Images/aeeedbd2d42ae62bfa6d8f6e96b2b150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJY3WXanICEVd0Sv_UuqNw.png"/></div></div></figure><p id="338f" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">现在让我们启动一个Python会话，并使用<code class="fe mw mx my mz b">import pandas</code>和<code class="fe mw mx my mz b">import sqlite3</code>导入<em class="mj">熊猫</em>和<em class="mj"> sqlite3 </em>。我们将使用<code class="fe mw mx my mz b">read_excel</code>将每个Excel电子表格中的数据读入一个单独的<em class="mj"> pandas </em>数据框，如下面的代码所示。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bdc9" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">在每个代码块中，<code class="fe mw mx my mz b">read_excel</code>中的第一个参数标识要处理的文件的名称。如有必要，包括文件所在的路径。例如，当我运行这段代码时，我的数据存储在<code class="fe mw mx my mz b">data</code>目录中，但是我的工作目录在上面一个目录中。第二个参数<code class="fe mw mx my mz b">sheet_name =</code>，指定工作簿中要处理的电子表格的名称。最后一个参数<code class="fe mw mx my mz b">header=0</code>告诉Python正在读取的电子表格中的第一行包含列标题。记住Python是零索引的，这就是为什么我们使用<code class="fe mw mx my mz b">0</code>而不是<code class="fe mw mx my mz b">1</code>来标识第一行。通过明确标识标题行，每个电子表格第一行中的值将被视为其各自数据框的列名。</p><p id="3fdb" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">让我们看一下每个数据框的前几行，以确保一切看起来都是正确的。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/d85a30cf2017552d17ef923a0dc997df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKiAvbV0J5KALx9bI-9-Ag.png"/></div></div></figure><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nn"><img src="../Images/eccdca090c48c5c537c5c3a633f62e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ubf1HsPNHaxMPN4q6kfcQ.png"/></div></div></figure><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/9ebf6d364471af3a88adf5623dd13f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EVcz5epZb4jxDSgMxBycIg.png"/></div></div></figure><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi np"><img src="../Images/e9bb05f1110003658615af2e5533507e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WY_xYyDX9C2pEqdWVkqwEw.png"/></div></div></figure><p id="2445" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">太好了！现在让我们创建数据库。</p><h1 id="75d5" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">创建SQLite数据库</h1><p id="a854" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">有多种关系数据库产品可用，这里我们将使用的具体产品是<a class="ae jd" href="https://www.sqlite.org/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh"> SQLite </strong> </a>。这是一个轻量级的SQL数据库引擎，可用于在个人计算机上创建存储为文件的数据库。我们可以启动一个新的SQLite数据库连接对象，并将该对象赋给一个变量。下面，我把这个变量命名为<code class="fe mw mx my mz b">db_conn</code>。</p><pre class="nb nc nd ne gt nq mz nr ns aw nt bi"><span id="5743" class="mk kw jg mz b gy nu nv l nw nx">db_conn = sqlite3.connect("data/superstore.db")</span></pre><p id="b6cb" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">当执行上述代码时，将在<em class="mj">数据</em>目录中创建一个名为<em class="mj"> superstore.db </em>的新文件(假设<em class="mj"> superstore.db </em>在该目录中尚不存在)。新创建的<em class="mj"> superstore.db </em>文件此时是一个空的SQLite数据库(即，它没有表)。<code class="fe mw mx my mz b">db_conn</code>也指向<em class="mj"> superstore.db </em>数据库，可以认为是使用这个数据库的接口。酷！但是等等…我们实际上如何运行创建数据表的SQL代码呢？很高兴你问了。我们现在需要建立一个<a class="ae jd" href="https://docs.python.org/2/library/sqlite3.html#cursor-objects" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh">游标</strong> </a> <strong class="lp jh"> </strong>对象，它是一个针对感兴趣的数据库执行SQL代码的工具。这里，光标被分配给一个名为<code class="fe mw mx my mz b">c</code>的变量。</p><pre class="nb nc nd ne gt nq mz nr ns aw nt bi"><span id="3132" class="mk kw jg mz b gy nu nv l nw nx">c = db_conn.cursor()</span></pre><p id="e1fd" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">下一步是创建将包含在数据库中的表，尽管需要强调的是，创建表的下一步将导致空表。稍后，我们将用之前创建的四个数据框中的数据填充我们的表。然而，在我们继续之前，让我们看一下将用于创建<em class="mj">销售</em>表的实际SQL代码，以便更好地理解表的创建过程。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f14f" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">上面代码中的第1行提供了创建名为<em class="mj"> sales </em>的表的命令，第2–8行在<em class="mj"> sales </em>中创建了7个新列:salesID、OrderID、ProductID、Sales、Quantity、Discount和Profit。每列的数据类型在相应列名的右侧指定。关于SQLite数据类型的更多信息可以在<a class="ae jd" href="https://www.sqlite.org/datatype3.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。请注意，列的顺序与关联数据框中列的顺序相匹配。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/1d289da4b3baf1085e62c9ae0bd1d812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXDRqJTHlBMBLwbzmCV_TQ.png"/></div></div></figure><p id="3082" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated"><code class="fe mw mx my mz b">CREATE TABLE</code>语句中的列顺序是有意安排的，因为这确保了数据框中的适当值进入数据库表中的预期列。例如，如果我将OrderID作为第一列，将SalesID作为第二列，那么SalesID值将被写入到<em class="mj"> sales </em>表中的OrderID列，并且该表中的SalesID列将包含OrderID值。</p><p id="38c0" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">第9行建立了表的<strong class="lp jh">主键</strong>，这是一个包含唯一标识每行的值的列。在<em class="mj">销售</em>表中，SalesID满足主键的要求，因为没有两行具有相同的SalesID值。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/576290711ea3237e7c8d7b564daba0f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_Mk5_2dyBGzMhQltl_vTg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">“销售”表的快照</p></figure><p id="214e" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">上一组代码中的第10行为<em class="mj">销售</em>建立了两个<strong class="lp jh">外键</strong>中的第一个。外键是一个表中的列，它是另一个表中的主键。例如，请注意，在<em class="mj">销售</em>表中，不同的行可以共享相同的OrderID值，这使得OrderID不再是该表<em class="mj">中的主键。然而，</em><em class="mj"/><em class="mj">订单</em>表中的每一行确实包含一个唯一的OrderID <em class="mj"> </em>值。因此，OrderID可以作为<em class="mj">订单</em>的主键。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/c0e8d7dce3e85c1f9db2e2c9ea2d93a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtXGwP2g5mOSvsu7HkQPKA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">“订单”表的快照</p></figure><p id="f0cd" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">让我们回到前面的<code class="fe mw mx my mz b">CREATE TABLE</code>语句中第10行的实际代码。代码的第一部分<code class="fe mw mx my mz b">FOREIGN KEY(OrderID)</code>确定<em class="mj"> sales </em>中的OrderID列是一个外键。第二部分，<code class="fe mw mx my mz b">REFERENCE orders(OrderID)</code>指定OrderID引用的表和主键。<code class="fe mw mx my mz b">CREATE TABLE</code>语句的第11行遵循相同的ProductID列逻辑。</p><p id="ea41" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">通过指定主键和外键，我们能够创建一个“映射”,显示数据库中的表是如何相互关联的。例如，熟悉SQL概念但不熟悉该特定数据的人可以查看创建<em class="mj">销售</em>表的<code class="fe mw mx my mz b">CREATE TABLE</code>语句，并认识到通过匹配两个表的OrderID列中的值，可以将<em class="mj">销售</em>和<em class="mj">订单</em>表中的数据放在一起，或者将<a class="ae jd" href="https://www.w3schools.com/sql/sql_join.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh">连接到</strong> </a>。为了简要说明联接是如何工作的，考虑我们如何通过在OrderID上“联接”来将OrderDate添加到<em class="mj"> sales </em>表中，如下所示。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ob"><img src="../Images/6e1b5902dd4ccedf1e3b4e6877158eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHBGQ9yCZzfkyinLcfXAuA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">联接如何工作的基本视觉演示</p></figure><h2 id="4c06" class="mk kw jg bd kx ml mm dn lb mn mo dp lf lw mp mq lh ma mr ms lj me mt mu ll mv bi translated">正在完成数据库</h2><p id="4df7" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">建立了表创建过程的基本概述后，让我们创建所有的数据库表。这是我们放置光标的地方，<code class="fe mw mx my mz b">c</code>开始工作。我们可以运行<code class="fe mw mx my mz b">c.execute()</code>并将所需的SQL代码作为字符串包含在括号中，以针对我们当前连接的数据库运行所述SQL代码(即<code class="fe mw mx my mz b">data/superstore.db</code>)。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="fa95" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">现在是时候用我们之前创建的四个数据框中的相关数据填充数据库中的表了。幸运的是，在每个数据帧上使用<em class="mj">pandas</em>’<code class="fe mw mx my mz b">to_sql</code>可以轻松完成这一步(更多细节见<code class="fe mw mx my mz b">to_sql</code> <a class="ae jd" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_sql.html" rel="noopener ugc nofollow" target="_blank">这里</a>)。下面块中的代码将数据从四个数据框中的每一个传输到数据库中适当的表中。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5456" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">上面每一行代码中的第一个参数标识数据框中的值将被写入的数据库表的名称，后面的参数指定实际的数据库连接。接下来，<code class="fe mw mx my mz b">if_exists='append'</code>告诉<code class="fe mw mx my mz b">to_sql</code>如果表已经存在(在本例中确实如此)，那么应该将数据框中的值插入到表中。最后，通过<code class="fe mw mx my mz b">index=False</code>,我们告诉<code class="fe mw mx my mz b">to_sql</code>不要将索引作为附加列包含在表中。</p><h1 id="f725" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">结论</h1><p id="71d8" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">现在，我们已经有了一个准备就绪的SQLite数据库！可以用<a class="ae jd" href="https://sqlite.org/cli.html" rel="noopener ugc nofollow" target="_blank"> SQLite命令行shell </a>或者其他支持SQLite的数据库软件，比如<a class="ae jd" href="https://www.dbvis.com/" rel="noopener ugc nofollow" target="_blank"> DbVisualizer </a>来查询<em class="mj"> superstore.db </em>数据库文件。您还可以使用<em class="mj"> pandas </em>中的<code class="fe mw mx my mz b">read_sql</code>在数据库上运行查询(参见更多信息<a class="ae jd" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_sql.html" rel="noopener ugc nofollow" target="_blank">此处</a>)。例如，如果我们希望看到来自<em class="mj"> sales </em>的前五行，我们可以在我们的Python shell或笔记本中运行如下所示的代码。</p><pre class="nb nc nd ne gt nq mz nr ns aw nt bi"><span id="d626" class="mk kw jg mz b gy nu nv l nw nx">pd.read_sql("SELECT * FROM sales LIMIT 5", db_conn)</span></pre><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oc"><img src="../Images/59cb2ca0fc35c974dbd810e2758d6872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ApEM3JbMFwfcL2JU5c_XQ.png"/></div></div></figure><p id="9df9" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">当您用Python处理完这个数据库后，您可以通过运行<code class="fe mw mx my mz b">db_conn.close()</code>来关闭连接。如果您想在关闭后再次使用该数据库，只需重新建立数据库连接</p><pre class="nb nc nd ne gt nq mz nr ns aw nt bi"><span id="5504" class="mk kw jg mz b gy nu nv l nw nx">db_conn = sqlite3.connect("data/superstore.db")</span></pre><p id="e2e6" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">并使用<code class="fe mw mx my mz b">read_sql</code>运行查询。如果不将数据写入数据库，则不需要建立新的游标。</p><p id="b779" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">在我们结束之前，有一句话需要澄清。在这篇文章的开始，我提到了Excel工作簿的结构类似于SQL数据库，因为两者都可以由多个相关的表组成。为此，本练习旨在演示如何将Excel工作簿轻松转换为SQLite数据库文件。尽管如此，我们只是触及了数据库设计的表面，我想强调的是，一个设计良好的数据库不仅仅是表的集合。的确，<a class="ae jd" href="https://en.wikipedia.org/wiki/Database_normalization" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh">规范化</strong></a><strong class="lp jh"/>的过程在关系数据库设计中非常重要，其目的是消除数据冗余，促进数据完整性。请注意，我们创建的数据库可以进一步规范化。如果您有兴趣了解更多关于关系数据库和跨多个表存储数据背后的基本原理，我推荐您阅读更多关于规范化的内容。</p><p id="1220" class="pw-post-body-paragraph ln lo jg lp b lq nf kh ls lt ng kk lv lw nh ly lz ma ni mc md me nj mg mh mi ij bi translated">好吧，这将是这个职位。感谢您的阅读，如果您有任何问题和/或建设性反馈，请联系我们。</p></div></div>    
</body>
</html>