<html>
<head>
<title>Basic Algorithms — Heapsort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本算法—堆排序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/basic-algorithms-heapsort-31d64d6919a1?source=collection_archive---------14-----------------------#2020-02-18">https://towardsdatascience.com/basic-algorithms-heapsort-31d64d6919a1?source=collection_archive---------14-----------------------#2020-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0a6b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用“堆”数据结构对数组排序</h2></div><p id="4706" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在以前的帖子中，我们看到了不同的排序算法，如<a class="ae le" rel="noopener" target="_blank" href="/basic-algorithms-finding-the-closest-pair-5fbef41e9d55">合并排序</a>和<a class="ae le" rel="noopener" target="_blank" href="/basic-algorithms-quicksort-b549ea9ef27">快速排序</a>，这次讨论的是另一种排序算法 Heapsort。Heapsort，顾名思义，使用“堆”数据结构。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/75b5f82f178050d014bd0efdb8ee6c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P5Z3_QTlxVh19bAq"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">苏珊·霍尔特·辛普森在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h2 id="5d87" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">许多</h2><p id="d2d5" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">堆是一种数据结构，堆是二叉树的数组。二叉树的每个节点对应于数组的一个元素。由于一个节点有零个、一个或两个子节点，对于数组的第<em class="mt"> i- </em>个元素，第<em class="mt"> 2i- </em>个和第(<em class="mt"> 2i+1 </em>)个元素分别是其左右子节点。</p><p id="fca3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图描述了一个示例堆，其中节点数等于 12 元素数组中的顺序数。根是数组中的第一个元素，它的左右子元素分别是第二个和第三个元素。第六个元素只有一个左子，第七个没有。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/44d1937a383935e93ec1a5790a3e4d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*txNuhCG1LO-Ao5s4pJetxQ.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">最小堆示例</p></figure><p id="00c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有两种堆:最小堆和最大堆。在最小堆中，父节点比子节点小(根节点最小)，而在最大堆中则相反(根节点最大)。在本文中，我们将使用 max-heap 属性进行堆排序。</p><h2 id="57fa" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">堆排序</h2><p id="e11c" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">策略如下:I)将数组转换成最大堆；ii)挑选根，这是最大数；iii)将剩余的数组保持为最大堆；iv)递归 ii)和 iii)。</p><p id="b6f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是步骤 iii)的代码，它也用于步骤 I)。这个“Max-Heapify”函数有两个输入:一个数组和一个整数。该函数将给定顺序的节点(输入整数)与其两个子节点进行比较。如果节点比任何一个子节点都小，它将与两个子节点中最大的一个交换。</p><pre class="lg lh li lj gt mv mw mx my aw mz bi"><span id="17d8" class="lv lw it mw b gy na nb l nc nd">def <strong class="mw iu">max_heapify</strong>(array, i):<br/>    l = (i+1) * 2 - 1<br/>    r = (i+1) * 2<br/>    length = len(array)</span><span id="adc5" class="lv lw it mw b gy ne nb l nc nd">    if l &lt; length and array[l] &gt; array[i]:<br/>        largest = l<br/>    else: <br/>        largest = i<br/>    <br/>    if r &lt; length and array[r] &gt; array[largest]:<br/>        largest = r<br/>        <br/>    if largest != i:<br/>        largest_value = array[largest]<br/>        array[largest] = array[i]<br/>        array[i] = largest_value<br/>        <strong class="mw iu">max_heapify</strong>(array, largest)<br/>        <br/>    return array</span></pre><p id="77a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然 Max-Heapify 不会耗尽整个堆，但是通过对除了叶子(堆的末端节点)之外的所有节点操作该函数，我们可以将任何数组转换为 max-heap。</p><pre class="lg lh li lj gt mv mw mx my aw mz bi"><span id="a8ad" class="lv lw it mw b gy na nb l nc nd">def <strong class="mw iu">build_max_heap</strong>(array):<br/>    length = len(array)<br/>    for i in range(length//2, -1, -1):<br/>        <strong class="mw iu">max_heapify</strong>(array, i)</span><span id="e389" class="lv lw it mw b gy ne nb l nc nd">    return array</span></pre><p id="5fe4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们准备实现 Heapsort。</p><pre class="lg lh li lj gt mv mw mx my aw mz bi"><span id="0a95" class="lv lw it mw b gy na nb l nc nd">def <strong class="mw iu">heap_sort</strong>(array):<br/>    length = len(array)<br/>    array = <strong class="mw iu">build_max_heap</strong>(array)<br/>    for i in range(length-1, 0, -1):<br/>        largest = array[0]<br/>        array[0] = array[i]<br/>        array[i] = largest<br/>        <strong class="mw iu">max_heapify</strong>(array[:i], 0)<br/>        <br/>    return array</span></pre><p id="fa8b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图解释了 Heapsort 如何处理一个 12 元素数组；I)首先，我们将数组转换为最大堆；ii)取根 12，用最后一个元素 3 代替；iii)在剩余的 11 元素数组的根上处理 Max-Heapify，受影响的节点以深蓝色显示；iii)递归 ii)和 iii)。最后我们将得到一个按升序排序的数组。堆排序就地操作，在输入数组之外只存储恒定数量的数据。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nf"><img src="../Images/1df81327c207db0864de37b42842bdbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XciUbJuvdbWW0onAgtnOQw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">示例堆排序过程</p></figure><h2 id="4629" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">堆集成本</h2><p id="1871" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们可以通过检查 Max-Heapify 和 Build-Max-Heap 的子函数来分析 Heapsort 的开销。</p><p id="7339" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Max-Heapify 的代价是<em class="mt"> O(lgn) </em>。比较一个节点和它的两个子节点的成本<em class="mt">θ(1)</em>，在最坏的情况下，我们递归<em class="mt"> ⌊log </em> ₂ <em class="mt"> n⌋ </em>次到底部。或者，Max-Heapify 的成本可以用堆的高度<em class="mt">h</em>O(h)来表示。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/91a2bd5ff9ce9eba66026aeb0fb18dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*nGEcVyAi86uctGcIQtMrJQ.png"/></div></figure><p id="10a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Build-Max-Heap 的开销是<em class="mt"> O(n) </em>。由于一个<em class="mt"> n </em>元素堆的深度为<em class="mt"> ⌊lgn⌋ </em>，并且在任意高度，除了叶子之外还有<em class="mt"> ⌈n/2ʰ⁺ ⌉ </em>节点，我们可以将成本导出为 Max-Heapify 成本的总和<em class="mt"> O(h) </em>，如左图所示。</p><p id="b344" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Heapsort 的总开销是<em class="mt"> O(nlgn) </em>，因为它调用 Build-Max-Heap ( <em class="mt"> O(n) </em>)和 Max-Heapify ( <em class="mt"> O(lgn) </em>)超过<em class="mt"> (n-1) </em>次。</p><h2 id="3dce" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">性能检查</h2><p id="981b" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">下图描述了不同的排序算法。正如预期的那样，Heapsort 遵循其他的<em class="mt"> O(nlgn) </em> -cost 算法，尽管它不如隐藏在<em class="mt"> O </em>符号中的常数更高的 Quicksort 便宜。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nh"><img src="../Images/49208771101d9e2b615b909ceb4478bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgajyUKYNojj76grRxdL2A.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">来源:作者的计算</p></figure><p id="bc2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管 Heapsort 在排序算法上不如 Quicksort，但是 Heap 作为数据结构提供了许多不同的用途，其中最值得注意的是在优先级队列中。作为对堆的介绍，我们将在后面看到堆是如何应用于一个有效的优先级队列算法的。</p></div></div>    
</body>
</html>