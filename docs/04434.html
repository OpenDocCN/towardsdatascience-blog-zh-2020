<html>
<head>
<title>Extra 4 SQL Tricks Every Data Scientist Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个数据科学家都应该知道的额外4个SQL技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/extra-4-sql-tricks-every-data-scientist-should-know-d3ed7cd7bc6c?source=collection_archive---------3-----------------------#2020-04-21">https://towardsdatascience.com/extra-4-sql-tricks-every-data-scientist-should-know-d3ed7cd7bc6c?source=collection_archive---------3-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d116" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">充分利用SQL加快分析工作的第2部分</h2></div><p id="6644" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我之前的博客<a class="ae le" rel="noopener" target="_blank" href="/6-sql-tricks-every-data-scientist-should-know-f84be499aea5">每个数据科学家都应该知道的6个SQL技巧</a>中，我讨论了在我作为数据科学家的日常工作中最有用的SQL功能。这个博客是这个迷你系列的第2部分，我将继续分享我的SQL技巧来帮助你提高你的分析/报告效率。</p><p id="9ce9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天，我们将使用一个新的玩具表，如下所示，包含多种数据类型，出于演示目的，该练习将在MS SQL server 2017中实现。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/7b7a15aa1e2edec4de1361ea2afe31f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*13Bujw-gvXtYxE4jLsUAzA.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">玩具数据表(带有变量定义)</p></figure><ol class=""><li id="fb53" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld lw lx ly lz bi translated"><strong class="kk iu"> ROW_NUMBER()返回行的子集</strong></li></ol><p id="9e70" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SQL中的ROW_NUMBER()函数为结果的每一行创建一个唯一的递增整数值。这一列值被认为是一个<strong class="kk iu">伪</strong> - <strong class="kk iu">列</strong>，因为<strong class="kk iu"> </strong>它本身并不存在于我们的数据表中，因此，结果是按照ORDER BY子句中分析师确定的顺序返回的。</p><p id="bc52" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这个伪列，我们可以使用一个简单的查询来解决“前N名”的问题，下面演示了如何为每个ID选择Num_Var值最高的前3条记录，</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="804b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是返回的子集(当然，您可以从输出中删除列RowNumber)，</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/307fcc07daf1bbf770505c5ce48dfe62.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*rQJbZqFTWpdYcv9_9CL0Yw.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">输出:Num_Var值最高的前3条记录</p></figure><p id="b1ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我注意到，尽管只有一行，ID 0180和其他ID(多于3行)一样被正确返回。因此，不需要额外注意原始数据是否有足够的行数用于指定的数量N。直白！</p><p id="5182" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="md"> ***更新2022:你也可以在这里看这篇文章的视频版，</em> </strong></p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="me mb l"/></div></figure><p id="4cd9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 2。用ROW_NUMBER()(高级)</strong>计算连续天数</p><p id="0c26" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">知道了ROW_NUMBER()的概念，您一定在想时间序列中的另一个可能的应用，在这里我们计算感兴趣的事件持续的连续时间。</p><p id="519b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我什么意思？好吧，让我们把玩具数据看作是登录我们网站的顾客。客户ID 0155在06/01、06/02和06/03(即连续3天)登录，然后分别在09/29和09/30连续登录了2次。从视觉上看，如果日期没有排序，我们进行计算就没那么简单了。SQL查询有什么帮助？</p><p id="d873" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一种直观的方法是首先使用ROW_NUMBER()在每个客户ID中分配按日期排序的行号。因为整数行号恰好也是递增1，所以连续天数就是最后一个日期和第一个日期之间的差！不幸的是，它不会工作，因为它会给我们一个5，而不是3和2(对于客户0155)。</p><p id="4a37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就引出了关于ROW_NUMBER()函数的一个重要注意事项:<strong class="kk iu">它没有间隙！</strong>它为每个分区创建一个始终从1开始递增的值，而我们的数据有间隙(例如，06/03和09/29不是连续的)。因此，简单地应用ROW_NUMBER()并不能得到我们想要的输出。我们需要一些调整，以下是方法，</p><p id="4584" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="md">步骤1: </em> </strong>创建RowNumber (order by date ASC)</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="86e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这为我们提供了这个临时输出，为了便于参考，我们将其标记为<strong class="kk iu"><em class="md">output _ table _ with _ row number</em></strong>，</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/2d96422f088d8fd037201560029811b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*OcKsXiQuHpE5En8EjFDItA.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">临时输出:按日期排列的行号</p></figure><p id="de2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="md">第二步</em></strong>:Date _ Var row number对连续的天数(即具有相同计数起点的日期)进行分组</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="b2a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而这里的返回，标注为<strong class="kk iu"><em class="md">output _ table _ with _ grouping _ var</em></strong>，</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/1620b6024c5a18b6c97d2852e3912c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*VituVC6tsgubpNIR28hk4g.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">临时输出:创建分组变量</p></figure><p id="a250" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，不要纠结于这个派生变量<strong class="kk iu"> <em class="md">的值，因为它毫无意义。它只是一个分组变量，基本上是告诉SQL这些行是连续的(即递增1)。</em></strong></p><p id="dbb0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="md">第三步</em> </strong>:计算按Starting_Count_DT分组的长度(连续天数)</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="da89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们的最终输出！</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/8e7dbc149d9f0d760507c48403f9046b.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*MTgF-JmXJUWtzZRSGA_7Fw.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">输出:连续天数</p></figure><p id="391d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">把所有东西放在一起，</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="5d0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唷，问题解决了！如果您第一次没有得到它，不要担心，您可以将它放入您的数据科学代码片段库，并在需要时随时引用。当你在下一次大型科技公司的数据科学家职位面试中遇到这个问题时，不要惊讶😄</p><p id="2e93" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 3。用声明保持干燥</strong></p><p id="2e17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们刚刚看到的，前面的查询是一个相当复杂的查询，包含两个嵌套的子查询。这些子查询增加了读取和调试代码的复杂性，如果我们将代码传递给其他队友，他们很可能不知道这个查询在做什么。</p><p id="9f33" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，WITH子句(也称为子查询分解)可以解决问题了！让我们看看如何重写上面的查询，使它更容易理解，</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="3760" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，(1)通过利用WITH子句，我们将嵌套查询分解成两个单独的临时视图，以提高代码可读性；(2)对多个查询之间的关系没有要求，这意味着它们可以是独立的或相关的(如在我们的例子中)。</p><p id="808e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">WITH子句的另一个有用场景是当WITH查询被多次引用时。不需要一次又一次地重复编写相同的子查询(即<a class="ae le" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">the DRY/not Repeat Yourself principle</a>)，我们可以在前面引入，在后面重用。</p><p id="ba83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 4。串联以重新格式化您的数据结构</strong></p><p id="7ad1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们的下一个任务是为我们的内部利益相关者创建一个汇总报告，显示每个客户登录的日期。这将是多对多信息的聚合。还观察到ID_Var和Gen_Var都包含跨行的重复值，因此为了使其适合人类阅读，我们立即想到MS SQL 2017中的STRING_AGG()函数，</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="15e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码片段产生了，</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/d36d708498c800803e4de80d46ea9993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*JojQU-ahDMOjV27VpK6bDw.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">输出:日期串联</p></figure><p id="72d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，(1)通过简单地指定ORDER BY语句(例如，ID 0155)，可以对级联列表中的元素进行排序；(2)尽管STRING_AGG()函数更常用于字符串连接，但它也适用于其他数据类型(例如，我们示例中的日期和数字变量)。</p><p id="51d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，关于这个聚合功能的几个<strong class="kk iu"> <em class="md">标注</em> </strong>:</p><p id="6a0f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(1)虽然在各大SQL数据库中都有，但具体的函数名称各不相同。在Oracle/PLSQL (11g)中是<strong class="kk iu"> LISTAGG() </strong>，在MySQL和IBM Netezza中是<strong class="kk iu"> GROUP_CONCAT() </strong>，在MS SQL server 2017和PostgresSQL中是<strong class="kk iu"> STRING_AGG() </strong>。</p><p id="7412" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(2)除了使数据视图更简单之外，我发现它在我们需要将数据提取到R或Python中进行深入分析的场景中也很有用(顺便说一下，如果您还没有这样做，请查看我以前的文章<a class="ae le" rel="noopener" target="_blank" href="/6-sql-tricks-every-data-scientist-should-know-f84be499aea5">中关于将数据从SQL数据库提取到Python的技巧</a>)。我们可以先将具有不同值的字段连接到每个ID的一行中，以减少数据大小，然后用R或Python解析这个字段，而不是像大多数列那样传输整个原始数据表。在这种连接中，空值将被排除，因此，我们不必担心在这一点上丢失值的处理。</p><p id="0d17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是你要的——4个额外的数据分析SQL技巧！我希望你觉得这个迷你系列鼓舞人心，并喜欢阅读它像我写它一样。和往常一样，所有的代码片段和玩具数据都可以在我的Github 中找到<a class="ae le" href="https://github.com/YiLi225/SQL_Python_R" rel="noopener ugc nofollow" target="_blank">😀</a></p><p id="e5c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="md">想要更多数据科学和编程技巧？使用</em> </strong> <a class="ae le" href="https://yilistats.medium.com/membership" rel="noopener"> <strong class="kk iu"> <em class="md">我的链接</em> </strong> </a> <strong class="kk iu"> <em class="md">注册Medium，获得我所有内容的全部访问权限。</em>T29】</strong></p><p id="2d2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="md">还订阅我新创建的YouTube频道</em> </strong> <a class="ae le" href="https://www.youtube.com/channel/UCbGx9Om38Ywlqi0x8RljNdw" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="md">【数据谈吉】</em></strong></a><strong class="kk iu"><em class="md"/></strong></p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="me mb l"/></div></figure><p id="f7f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">这个迷你系列的第一部，</strong></p><div class="mj mk gp gr ml mm"><a rel="noopener follow" target="_blank" href="/6-sql-tricks-every-data-scientist-should-know-f84be499aea5"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">每个数据科学家都应该知道的6个SQL技巧</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">提高分析效率的SQL技巧</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">towardsdatascience.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na ll mm"/></div></div></a></div></div></div>    
</body>
</html>