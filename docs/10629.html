<html>
<head>
<title>How to Create a GraphQL API using AWS AppSync</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 AWS AppSync 创建 GraphQL API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-create-a-graphql-api-using-aws-appsync-49fed1171780?source=collection_archive---------13-----------------------#2020-07-25">https://towardsdatascience.com/how-to-create-a-graphql-api-using-aws-appsync-49fed1171780?source=collection_archive---------13-----------------------#2020-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6fb6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是 GraphQL 以及如何使用 AWS AppSync 创建我们自己的 GraphQL API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2a7a787a2388891ea1ef3771c782856f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BxCB5Mo5vgIGzbVS5aD1Jw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/bsdrouin-5016447/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2402637" rel="noopener ugc nofollow" target="_blank">贝瑟尼·德鲁因</a>从<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2402637" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</p></figure><h1 id="7e33" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是 GraphQL</h1><p id="238f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">如今，每当我们谈论或考虑创建/设计一个 API 时，首先浮现在脑海中的是<strong class="lt iu"> REST </strong>。REST(<strong class="lt iu">RE</strong>presentational<strong class="lt iu">S</strong>state<strong class="lt iu">T</strong>transfer)一直是开发 API 平台的首选标准。即使 REST 成为了标准，它也有自己的缺点。一个主要的缺点是对于将要消费它们的客户来说缺乏灵活性。因此，即使在开始时，我们根据客户需求创建 REST API，当客户需求快速变化时，该 API 的选项也很少。为了支持这些快速的变化，客户需要发送多个调用，并获得多个不必要的数据。</span></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/5876461436bfb5b10a1a63f56b3d901a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*RHWi_Erl7eAzfsiDf3sanQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>提供</p></figure><p id="816c" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated"><strong class="lt iu"> GraphQL </strong>的开发主要着眼于为客户提供这种灵活性。它最初是脸书内部的一个项目，但是后来他们把它变成了开源项目。主要概念是让客户端能够选择要查询的数据和需要返回的数据，而无需进行多次 API 调用。是的，正如你在 GraphQL 中读到的，它没有多个端点，而是只有一个端点。为了说明 GraphQL 是如何工作的，让我们尝试使用 node.js 和 express framework 实现一个简单的 GraphQL API。我们的 GraphQL 的数据模型将是一个用户。</p><p id="5afd" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">下面的 npm 包将在我们的代码中使用。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="4128" class="nh la it nd b gy ni nj l nk nl">express, express-graphql, graphql</span></pre><p id="939c" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">一个 GraphQL API 主要由四个组件组成。</p><ul class=""><li id="af53" class="nm nn it lt b lu mx lx my ma no me np mi nq mm nr ns nt nu bi translated">(计划或理论的)纲要</li><li id="20e3" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated">问题</li><li id="36ec" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated">突变</li><li id="16a2" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated">下决心者</li></ul><h2 id="b6d4" class="nh la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">(计划或理论的)纲要</h2><p id="2e42" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">GraphQL 模式是我们定义客户端连接到 API 后可以执行的功能的核心元素。模式上的主要构建块是<em class="ol">类型</em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="93e0" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">如上图所示，使用积木<em class="ol">类型</em>，我们创建了三个积木。<em class="ol">类型</em>类型<strong class="lt iu">查询</strong>、<em class="ol">类型</em>、<strong class="lt iu">突变、</strong>类型<strong class="lt iu">用户</strong>。下面将描述查询和突变。对于<em class="ol">类型</em>用户，如您所见，我们已经定义了属性字段，当查询用户时，这些字段将对客户端可用。</p><h2 id="789c" class="nh la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">询问</h2><p id="af00" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">查询<em class="ol">类型</em>用于定义什么类型的查询将可用于要被访问的客户端。用 REST 术语查询类型可以映射到<strong class="lt iu"> GET </strong>请求。在上面的模式中，我们定义了三个查询，它们接受的参数以及返回值的类型。(!代表必需的)</p><h2 id="15fe" class="nh la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">变化</h2><p id="4ede" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">任何导致数据变化的函数都应该作为 GraphQL 的变种来完成。对 REST 的<strong class="lt iu"> POST </strong>、<strong class="lt iu"> PUT、</strong>和<strong class="lt iu"> DELETE </strong>请求可以映射为 GraphQL 上的突变。正如我们定义查询一样，变异也是用参数和返回值类型定义的。</p><h2 id="93a9" class="nh la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">下决心者</h2><p id="098b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在解析器中，我们定义了我们在模式中定义的<em class="ol">查询</em>和<em class="ol">突变</em>的功能。解析器将模式定义的方法映射到我们正在执行的功能方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="0d96" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">在上面你可以看到，对于我们定义的每个<em class="ol">查询</em>和<em class="ol">变异</em>，我们已经映射了一个 Javascript 函数来执行功能逻辑。(getUser、getUserByName、getUserByStatus 和 updateUser 是 Javascript 函数)</p><p id="96f5" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">好了，现在我们已经介绍了代码中的主要概念，下面是简单的 GraphQL API 的完整代码。如上所述，您需要安装提到的 npm 包，以便运行应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ceee" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">现在，您可以启动 node.js 服务器，并向我们的 API 发出查询，我们可以使用 graphql 工具，它将在<a class="ae ky" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graph QL</a>上运行</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/006f73ff8ae0eb43a772efaf13619a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9CyeOteJ1C8KRr6aLYOjwA.png"/></div></div></figure><p id="83c1" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">现在，如上所示，我们可以为我们创建的 API 执行查询。上面我们得到了 id 为 1 的用户，我们只请求返回姓名和年龄字段。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/f23e6fe773eba04fbef24a6185d0fccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gpdcSghZeYNTeZ-YZtUG0Q.png"/></div></div></figure><p id="b61f" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">与查询一样，我们也可以发送变异来更新用户。上面我们已经将用户的年龄改为 25 岁。</p><h1 id="691f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">AWS AppSync</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/57e89107a53804546ec13648a616209e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AU4PDrperLmLjlGCThPF6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源<a class="ae ky" href="https://aws.amazon.com/appsync/" rel="noopener ugc nofollow" target="_blank"> AWS AppSync </a></p></figure><p id="20e0" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi mn translated">WS AppSync 是由 Amazon Web Services 提供的一项服务，它通过让开发人员在其基础设施上创建安全、灵活的 GraphQL API 来简化 API 应用程序开发。使用 AWS AppSync 的好处是，它还提供了额外的功能，如 Cognito、IAM permissions、API key 和许多其他 AWS 服务，以便与我们的 API 集成。</p><p id="4d7e" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">对于 AppSync，GraphQL 的主要概念基本保持不变，只是增加了一个<em class="ol">类型</em>、<strong class="lt iu">订阅</strong>。订阅被调用到一个通过 API 完成的变异，因此它可以用来创建实时的 GrapgQL APIs。此外，在我们开始在 AWS AppSync 中创建自己的 GraphQL 之前，我们需要讨论 AWS AppSync 中的另外两个组件。</p><ul class=""><li id="fa46" class="nm nn it lt b lu mx lx my ma no me np mi nq mm nr ns nt nu bi translated"><strong class="lt iu">数据源</strong> —数据源可以是持久存储(关系数据库或 NoSQL 数据库)或触发器(AWS Lambda 函数或其他 HTTP API)</li><li id="2d37" class="nm nn it lt b lu nv lx nw ma nx me ny mi nz mm nr ns nt nu bi translated"><strong class="lt iu">解析器</strong> —与 GrapQL 中的解析器有相同的概念，但是这里我们将请求负载映射到我们的数据源或触发器。这些解析器主要与包含执行逻辑的映射模板妥协。</li></ul><h2 id="ba0e" class="nh la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">在 AppSync 上创建 GraphQL API</h2><p id="c944" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们开始实现我们的 API。首先转到 AppSync 服务，如果您还没有创建 API，您将看到下面的屏幕。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/73063523697c1c678e2a1c18ca6f3c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*flI53AndTL5QPQo5jnOiBw.png"/></div></div></figure><p id="fecf" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">点击<strong class="lt iu">创建 API </strong>，这将把我们带到 API 创建页面。这里 AWS 将为我们提供几种选择。我们可以从已经创建的模板中选择一个，也可以从头开始。对于这篇文章，让我们选择<strong class="lt iu">从头开始构建</strong>，这样我们将能够了解场景背后的一切是如何连接的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/368a11a601204297b88036d0ebc3e43a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kzY9P6yD1h2ncShHV41WUg.png"/></div></div></figure><p id="1cec" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">接下来，提供一个名称并创建我们的 API。然后，我们将转到一个屏幕，在这里我们可以选择编辑我们的模式并根据我们的 API 运行查询。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/a3fbf7b886a0f1209cb01fe8a2caa809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i6L0w84LByfjSD5TE4Md-w.png"/></div></div></figure><p id="8411" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">因为我们的 API 上还没有任何东西，所以让我们首先定义我们的模式。在本文中，我将讨论 AppSync 支持的两种类型的数据源。一个是<strong class="lt iu"> DynamoDB </strong>另一个将是<strong class="lt iu"> AWS Lambda functions </strong>。由于上面创建了简单的 GraphQL API，让我们假设我们的用户数据模型。</p><h2 id="09ba" class="nh la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">DynamoDB 作为数据源</h2><p id="d0d8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设我们需要将用户保存在 DynamoDB 表中。因此，对<em class="ol">类型</em>用户进行的所有查询和变更都将直接发生在我们的 DynamoDB 表上。所以首先让我们在模式中定义我们的用户类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/4b7b7134bf474d09b569efabb4a838af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGj1jm6yUlqtl17z3LdVEA.png"/></div></div></figure><p id="401f" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">在模式页面上，单击<strong class="lt iu">创建资源</strong>，我们将在其中定义我们的用户模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/5873dd8d394cea3bcfb95605ccb56807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MehuowSO366wmiIJnVu6Xw.png"/></div></div></figure><p id="9036" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我们定义了<strong class="lt iu">用户</strong>的新<em class="ol">类型</em>，然后它将要求 DynamoDB 表的详细信息。在这里，我们可以提供表的名称，还可以配置我们需要创建的不同类型的索引。最后，它将显示为我们的<em class="ol">类型</em> <strong class="lt iu">用户</strong>自动生成的模式块，这些模式块将被合并到我们的模式中。点击<strong class="lt iu">创建</strong>，它将创建 DynamoDB 表以及解析器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/dcd529f2eab6e1449cb54c01c5ee778d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmjCYIsgkZqIdUv22r2A3w.png"/></div></div></figure><p id="fc88" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">现在让我们更深入地看看我们的模式。我们可以看到 AppSync 已经为我们自动生成了<strong class="lt iu">查询</strong>类型和<strong class="lt iu">突变</strong>，并且已经将这些查询和突变映射到<strong class="lt iu">解析器</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/4d48c25517be909d75dcb07c355b9ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TaLxYPj7V497iSdeguKehA.png"/></div></div></figure><p id="a450" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">让我们看一个解析器，以确定解析器如何在 AppSync 上工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/127c7bb4ebea7a752451f965539f61cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*mUx7b3RwYbHLW49TOaTo_Q.png"/></div></figure><p id="333c" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">点击<em class="ol">创建用户</em>突变。在这里，我们可以看到 AppSync 用于此突变的模板。在请求映射模板中，我们可以看到它将 id 作为我们的<em class="ol">用户表</em>的键，并在表中创建一个用户集合。<em class="ol"> $ctx.args.input </em>是我们将传递给变异的参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/5c2fb891e9302f5881fc38273786760d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-H1EmOJTKpP0oa9hVAGKbg.png"/></div></div></figure><p id="c375" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">响应映射定义了我们将发送回客户端的响应。在这里，它将直接发送来自 DynamoDb 的输出，这将是新创建的用户。</p><p id="e4ce" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我们可以使用提供的查询工具测试我们的 API。让我们首先添加一个用户，并尝试使用 id 查询该用户。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/9c77aac731b3cbb101dfaefb62a3e596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PicSEQ3YdkoX9LLxs2uRg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/233e4afec5df3354f4ad3e662dc18e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D1tSrswOssVUXnorPS2oxA.png"/></div></div></figure><h2 id="6e4e" class="nh la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">AWS Lambda 用作数据源</h2><p id="9c71" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">到目前为止，我们创建的 API 可以直接在 DynamoDB 数据库上执行所有 CRUD 操作。但是 API 不仅仅包含 CRUD 操作。可以有不同种类的功能逻辑，如通过向队列发送消息来启动流程，或者我们可能需要使用不同的 AWS 资源，如 ElasticSearch，而不是在数据库上进行 CRUD 操作。为了迎合这种情况，我们可以使用 AWS lambda 函数作为数据源。</p><p id="0a0a" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">对于本文，让我们假设我们想从 AWS lambda 函数获取用户数据，而不是从 DynamoDb 获取。首先，让我们创建 lambda 函数。我们要映射为解析器的查询是</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="7ebe" class="nh la it nd b gy ni nj l nk nl">getUser(id: Int!): User</span></pre><p id="bdb6" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">创建一个新的 lambda 函数，并为该函数添加以下代码。在这里，我们检查将通过解析器发送的<strong class="lt iu"> event.field </strong>参数。因此，如果字段参数是<em class="ol"> getUsers </em>，那么我们将返回过滤后的用户。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5964" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">现在让我们为这个函数配置一个解析器。在此之前，我们需要在我们的 API 中将这个函数注册为一个<strong class="lt iu">数据源</strong>。为此，转到<em class="ol">数据源</em>选项卡，点击<strong class="lt iu">创建数据源</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/c2d2288ed7a264671558b002065b30ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vKeW-dTk6GnMsPxCvMf2rg.png"/></div></div></figure><p id="f9e8" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">接下来，为数据源提供一个名称，选择<em class="ol"> DataStorageType </em>作为<strong class="lt iu"> Lambda </strong>，然后选择<em class="ol"> region </em>，最后选择我们创建的 Lambda 函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/07e14786ad5bcb31f15018b269c2cbe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YKBFM_CnS5ZmOYC7m0au0A.png"/></div></div></figure><p id="f003" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">下一步是在我们的模式中分配这个数据源。首先，当我们将模式映射到 DynamoDB 表时，删除已经映射到 getUser()解析器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/01c7b64c2ca5e463f286f6b31ee13744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*pTROEiBNq6K3NiSIaBJ6sA.png"/></div></figure><p id="7ff6" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">删除后，点击<strong class="lt iu">连接</strong>。然后选择数据源作为我们为 lambda 函数创建的数据源。接下来将为<strong class="lt iu">请求映射</strong>和<strong class="lt iu">响应映射</strong>添加模板。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="c0a8" class="nh la it nd b gy ni nj l nk nl">{<br/>    "version": "2017-02-28",<br/>    "operation": "Invoke",<br/>    "payload": {<br/>        "field": "getUser",<br/>        "arguments":  $utils.toJson($context.arguments)<br/>    }<br/>}</span></pre><p id="ca07" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">将上述内容添加为请求映射模板。这里我们将字段指定为<strong class="lt iu"> getUser </strong>，我们在 lambda 函数中使用它作为<strong class="lt iu">事件。对于响应映射，我们可以让它保持原样。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/cb65673204ab0c877cdd31c7ecc5cea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPc_qZ4MfibX7jWXuGTNMA.png"/></div></div></figure><p id="6b95" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">现在让我们试着从我们的 GraphQL API 中查询这个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/3bcf9ecb95de6b0603fa30fa22672c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcFsMtuJP6hjNCRgMg2q8A.png"/></div></div></figure><p id="491d" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">就是这样。尽管这里 lambda 函数只是用来返回一个用户，但我想你可能会发现 lambda 函数能做的任何事情都可以映射到我们的 GraphQL，这确实创建了一个无服务器 API。</p><p id="7af4" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">我想你已经了解了更多关于什么是 GraphQL 以及如何使用 AWS AppSync 为我们创建一个 GraphQL。还有许多概念没有在本文中介绍。因此，如果你热衷于此，请确保遵循官方文档以及其他可用的精彩文章。谢谢你。</p><div class="pf pg gp gr ph pi"><a href="https://graphql.org/learn/" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">GraphQL:一种 API 查询语言。</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">在本系列文章中了解 GraphQL，它是如何工作的，以及如何使用它。寻找关于如何…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">graphql.org</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw ks pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a href="https://docs.aws.amazon.com/appsync/latest/devguide/welcome.html" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">欢迎</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">欢迎使用 AWS AppSync 开发人员指南。AWS AppSync 是一个企业级的完全托管的 GraphQL 服务，具有…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">docs.aws.amazon.com</p></div></div></div></a></div></div></div>    
</body>
</html>