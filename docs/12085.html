<html>
<head>
<title>Optimization in Python — Interning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的优化—实习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimization-in-python-interning-805be5e9fd3e?source=collection_archive---------24-----------------------#2020-08-20">https://towardsdatascience.com/optimization-in-python-interning-805be5e9fd3e?source=collection_archive---------24-----------------------#2020-08-20</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="2c42" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">编程，PYTHON</h2><div class=""/><div class=""><h2 id="1fa6" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">了解 Python 的优化技术——实习</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/ce956666be14253ea2e070765aabee87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TVH3cYeJ4s6F-4F3"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">乔治·斯图尔特在<a class="ae li" href="https://unsplash.com/photos/D8gtlT7j1v4" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lj lk hy ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="in io ip iq ir"><p id="2cac" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">有不同的 Python 实现，比如<em class="mm"> CPython </em>、<em class="mm"> Jython </em>、<em class="mm"> IronPython </em>等等。本文中我们将要讨论的优化技术与标准 Python 实现<em class="mm"> CPython </em>相关。</p><h1 id="a380" class="mn mo iu bd mp mq mr ms mt mu mv mw mx kj my kk mz km na kn nb kp nc kq nd ne bi translated">实习生</h1><p id="757b" class="pw-post-body-paragraph lq lr iu ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml in bi translated"><em class="mm">实习是按需重用对象</em>而不是创建新对象。这是什么意思？让我们试着用例子来理解整数和字符串的实习。</p><blockquote class="nk nl nm"><p id="b508" class="lq lr mm ls b lt lu ke lv lw lx kh ly nn ma mb mc no me mf mg np mi mj mk ml in bi translated"><strong class="ls je">是</strong> —这个用来比较两个 python 对象的内存位置。<br/> <strong class="ls je"> id </strong> —返回以 10 为基数的内存位置。</p></blockquote><h2 id="d874" class="nq mo iu bd mp nr ns dn mt nt nu dp mx lz nv nw mz md nx ny nb mh nz oa nd ja bi translated">整数实习</h2><p id="bbb9" class="pw-post-body-paragraph lq lr iu ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml in bi translated">启动时，Python 将一个整数列表预加载/缓存到内存中。这些都在<code class="fe ob oc od oe b">-5 to +256</code>范围内。每当我们试图在这个范围内创建一个整数对象时，Python 会自动引用内存中的这些对象，而不是创建新的整数对象。</p><p id="478d" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">这种优化策略背后的原因很简单，即<code class="fe ob oc od oe b">-5 to 256</code>中的整数使用频率更高。因此将它们存储在主内存中是有意义的。因此，Python 在启动时将它们预加载到内存中，以便优化速度和内存。</p><p id="f295" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated"><strong class="ls je"> <em class="mm">例 1: </em> </strong></p><p id="df5c" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">在这个例子中，<code class="fe ob oc od oe b">a</code>和<code class="fe ob oc od oe b">b</code>都被赋值为 100。由于在范围<code class="fe ob oc od oe b">-5 to +256</code>内，Python 使用了 interning，因此<code class="fe ob oc od oe b">b</code>也将引用相同的内存位置，而不是创建另一个值为 100 的整数对象。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj of"><img src="../Images/a91c73b81b8d26c94955efd40fd1ff13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*2bCl5cSdmLdcdcu4SJ7yZA.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</p></figure><p id="b325" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">从下面的代码中我们可以看到，<code class="fe ob oc od oe b">a</code>和<code class="fe ob oc od oe b">b</code>都引用了内存中的同一个对象。Python 不会创建新的对象，而是引用<code class="fe ob oc od oe b">a</code>的内存位置。这都是因为整数实习。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj og"><img src="../Images/7570d88a0c697bfe4675d7402e48bd0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*KXOVe2gvDFXx-yEbYwWoiA.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</p></figure><p id="3cc5" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated"><strong class="ls je"> <em class="mm">例二:</em> </strong></p><p id="1b4c" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">在本例中，<code class="fe ob oc od oe b">a</code>和<code class="fe ob oc od oe b">b</code>都被赋予了值 1000。由于超出了-5 到+256 的范围，Python 将创建两个整数对象。所以 a 和 b 将被存储在内存的不同位置。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oh"><img src="../Images/832b12f98ce356b7dfe83bc6f7e77807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*1xhLqtk8pxzLbzJESmv9MQ.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</p></figure><p id="1c8e" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">从下面的代码中我们可以看到，<code class="fe ob oc od oe b">a</code>和<code class="fe ob oc od oe b">b</code>都存储在内存的不同位置。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oi"><img src="../Images/428117b2a50d91cdea8069cd8100ab72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*qzdvHUE2Bl6sjegrGX_pJg.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</p></figure><h2 id="dde3" class="nq mo iu bd mp nr ns dn mt nt nu dp mx lz nv nw mz md nx ny nb mh nz oa nd ja bi translated">字符串实习</h2><p id="894e" class="pw-post-body-paragraph lq lr iu ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml in bi translated">像整数一样，一些字符串也会被保留。通常，任何满足标识符命名约定的字符串都会被保留。有时候会有例外。所以，不要依赖它。</p><p id="c687" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated"><strong class="ls je">例 1: </strong></p><p id="cd2a" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">字符串“Data”是一个有效的标识符，Python 对该字符串进行了整形，因此这两个变量将指向相同的内存位置。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oj"><img src="../Images/6f26d7f34341a85829b7e9af7239fae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*TwabGuCDNvtJZF4Z--hxfQ.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</p></figure><p id="82cb" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated"><strong class="ls je"> <em class="mm">例 2 </em> : </strong></p><p id="7c46" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">字符串“数据科学”不是有效的标识符。因此，这里没有应用字符串滞留，所以 a 和 b 都指向两个不同的内存位置。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj ok"><img src="../Images/ef36b45a0a3253e2c299a6d8ff2d2ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*75_mJbYlq-pIEpRtzyxVXQ.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</p></figure><blockquote class="nk nl nm"><p id="611e" class="lq lr mm ls b lt lu ke lv lw lx kh ly nn ma mb mc no me mf mg np mi mj mk ml in bi translated">上面所有的例子都来自 Google Colab，它有 Python 3 . 6 . 9 版本</p><p id="ff3b" class="lq lr mm ls b lt lu ke lv lw lx kh ly nn ma mb mc no me mf mg np mi mj mk ml in bi translated">在 Python 3.6 中，任何长度≤ 20 的有效字符串都将被保留。但是在 Python 3.7 中，这个已经改成了 4096。正如我之前提到的，这些东西会随着不同的 Python 版本而不断变化。</p></blockquote><p id="053f" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">由于不是所有的字符串都被保留，Python 提供了使用<code class="fe ob oc od oe b">sys.intern()</code>强制保留字符串的选项。除非有必要，否则不应该使用这种方法。请参考下面的示例代码。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ol"><img src="../Images/f7c8b5be6363d900a91efa33740d5228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XlY1DoTzGDFaLSdYa1MaIw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</p></figure><h1 id="79c0" class="mn mo iu bd mp mq mr ms mt mu mv mw mx kj my kk mz km na kn nb kp nc kq nd ne bi translated">为什么字符串实习很重要？</h1><p id="923a" class="pw-post-body-paragraph lq lr iu ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml in bi translated">让我们假设您有一个应用程序，其中有许多字符串操作正在发生。如果我们使用<code class="fe ob oc od oe b">equality operator ==</code>来比较长的字符串，Python 会尝试一个字符一个字符地比较，显然这需要一些时间。但是如果这些长字符串可以被保留，那么我们知道它们指向同一个内存位置。在这种情况下，我们可以使用<code class="fe ob oc od oe b">is</code>关键字来比较内存位置，因为这样会快得多。</p><h1 id="7e9c" class="mn mo iu bd mp mq mr ms mt mu mv mw mx kj my kk mz km na kn nb kp nc kq nd ne bi translated">结论</h1><p id="60af" class="pw-post-body-paragraph lq lr iu ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml in bi translated">希望你已经理解了 Python 中优化的<em class="mm"> interning </em>的概念。</p><p id="5648" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">如果你有兴趣学习更多关于优化的知识，请浏览<a class="ae li" rel="noopener" target="_blank" href="/optimization-in-python-peephole-e9dc84cc184d"> <strong class="ls je">窥视孔优化</strong> </a>。</p><div class="om on gq gs oo op"><a rel="noopener follow" target="_blank" href="/optimization-in-python-peephole-e9dc84cc184d"><div class="oq ab fp"><div class="or ab os cl cj ot"><h2 class="bd je gz z fq ou fs ft ov fv fx jd bi translated">Python 中的优化—窥视孔</h2><div class="ow l"><h3 class="bd b gz z fq ou fs ft ov fv fx dk translated">Python 的窥视孔优化技术简介</h3></div><div class="ox l"><p class="bd b dl z fq ou fs ft ov fv fx dk translated">towardsdatascience.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd lc op"/></div></div></a></div><p id="8b14" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated">要了解 M <em class="mm">的不变性和 Python </em>的不变性，请<a class="ae li" rel="noopener" target="_blank" href="/mutability-immutability-in-python-b698bc592cbc"> <strong class="ls je">点击这里</strong> </a>阅读文章。</p><p id="6e63" class="pw-post-body-paragraph lq lr iu ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml in bi translated"><em class="mm">阅读更多关于 Python 和数据科学的此类有趣文章，</em> <a class="ae li" href="https://pythonsimplified.com/home/" rel="noopener ugc nofollow" target="_blank"> <strong class="ls je"> <em class="mm">订阅</em> </strong> </a> <em class="mm">到我的博客</em><a class="ae li" href="http://www.pythonsimplified.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ls je"><em class="mm">【www.pythonsimplified.com】</em></strong></a><strong class="ls je"><em class="mm">。</em> </strong>你也可以通过<a class="ae li" href="https://www.linkedin.com/in/chetanambi/" rel="noopener ugc nofollow" target="_blank"><strong class="ls je">LinkedIn</strong></a><strong class="ls je">联系我。</strong></p></div></div>    
</body>
</html>