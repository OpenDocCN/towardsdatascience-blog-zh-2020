<html>
<head>
<title>Everything about Fasterrcnn in PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTorch 关于 Fasterrcnn 的一切</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/everything-about-fasterrcnn-6d758f5a6d79?source=collection_archive---------9-----------------------#2020-07-05">https://towardsdatascience.com/everything-about-fasterrcnn-6d758f5a6d79?source=collection_archive---------9-----------------------#2020-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d92e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何在 PyTorch 中实现 Fasterrcnn 并提取每幅图像的特征图</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b4e53df28f3b095d4d338ce81d6ef8fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MopAvnV3vnX-jqArVWRKMQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@r3dmax?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">乔纳森派</a>在<a class="ae kv" href="https://unsplash.com/s/photos/scenery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h2 id="4dcb" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍</h2><p id="723b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">目标检测是计算机视觉中的一项任务，我们试图对图像中存在的目标进行分类，而不是对图像进行分类。它有各种各样的应用，如检测空闲的停车位，跟踪闭路电视镜头中的物体，以及监控作物，这就是我们将要讨论的内容。</p><p id="3dc0" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">有许多方法来执行对象检测；Fasterrcnn 只是其中之一。许多其他技术，如 YOLO 和 SSD，同样工作良好。你应该了解 Fasterrcnn 的原因是，它在许多比赛中给出了最先进的结果，并在 Pinterest 应用程序等实际应用中使用。</p><p id="3f5d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">本文简要介绍了 Fasterrcnn、与之相关的概念及其在 PyTorch 中的实现。</p><h2 id="8f38" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">建筑:</h2><p id="f573" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">Fasterrcnn 的架构如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/b9cab2e4de282f8bb994525fc3ff0ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7g_bSngK8vSmizdPgHIGkA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:https://arxiv.org/abs/1506.01497<a class="ae kv" href="https://arxiv.org/abs/1506.01497" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="52cd" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">该网络首先从图像中提取特征。体系结构的这一部分被称为网络的主干。可以使用任何标准的图像分类架构。我们将使用带有<a class="ae kv" href="https://arxiv.org/abs/1612.03144" rel="noopener ugc nofollow" target="_blank">特征金字塔网络</a>的 ResNet50 作为我们的主干。</p><p id="164e" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在第二步中，<strong class="lu ir"> <em class="mr">区域提议网络</em> </strong>用于生成可能包含对象的区域。与过去的方法相比，这个网络是一个真正的提升，比如在整个图像上滑动一个窗口来寻找潜在的区域，正如你可以想象的那样，这是一个非常缓慢和计算昂贵的过程。</p><p id="e7ff" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在这个网络中，相对于过去的方法的另一个改进是使用锚盒来检测各种比例和纵横比的图像。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/9a3400aa1ce42157f4692e6bde1ff679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EM1hkSxZUSzDqhCSkY_KhA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://arxiv.org/abs/1506.01497" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1506.01497</a></p></figure><p id="efe1" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">最后，从体系结构中可以看出，相同的特征图用于检测区域和分类。重用特征地图的想法非常聪明，你会看到很多架构都在这么做。采取的功能图，并附上多个头部，它的多项任务。</p><p id="46ad" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">现在让我们用 PyTorch 实现一个 Fasterrcnn，并在此过程中理解更多的术语。</p><h2 id="81da" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">在 PyTorch 中实现 Fasterrcnn</h2><p id="b61e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">Kaggle 最近举办了一场识别麦穗的比赛。我用这次比赛的数据训练了一个模型。</p><p id="db1b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">数据以 csv 及其相应图像的形式提供。我们有左下角的坐标，也有每个盒子的宽度和高度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/cc105033d04fd06b9c8bf204ad535338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NcKVPnVNIwd9jt4Ua6D5SA.png"/></div></div></figure><p id="482f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">如果我们打印边界框的类型，我们会看到它们是字符串类型，而不是我们所期望的列表。<a class="ae kv" href="https://www.linkedin.com/posts/dvasani_python-oneabrssabrpython-activity-6673000959301455872-R0Ny" rel="noopener ugc nofollow" target="_blank">这个错误很常见，可以使用</a>来解决。为了方便使用，我们还将边界框分成了四列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/41776d2a59810a22f2b76c55120ad12e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r7Q9_LW_jh7uOjYGerCJRw.png"/></div></div></figure><p id="c5d6" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我们现在创建一个定制的<strong class="lu ir">小麦数据集。</strong>faster CNN 期望我们的数据以图像和与之对应的字典的形式出现。字典至少应该包括边界框和标签。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/9d3f375fba152120b2eebac9546c41d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jM77KU-NwyOSKChZGba4Q.png"/></div></div></figure><p id="a7f6" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我们用数据框和存放图像的文件夹初始化数据集。我们在 __getitem__()函数中完成剩余的计算。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/409896ab6e4f44867de4af4be15321d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYfqn76AhxX89F9PMbvadw.png"/></div></div></figure><p id="a3eb" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我们将盒子从(x0，y0，w，h)格式转换为(x0，y0，x1，y1)格式。我们把我们的标签分配给所有的 1，因为在这个问题中我们只有一个类(我们用 1 作为我们的标签，因为在 PyTorch 中，0 代表背景。).最后，我们把所有东西都转换成 PyTorch 张量。</p><p id="3d28" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我们还定义了 __len__()函数，因为 PyTorch 数据加载器使用它来迭代我们的数据集。</p><blockquote class="nb nc nd"><p id="2636" class="ls lt mr lu b lv ml jr lx ly mm ju ma ne mn mc md nf mo mf mg ng mp mi mj mk ij bi translated">Pro 提示:如果你的数据在云上，不用下载到本地，可以直接拉图进行训练(考虑到这个过程不是超级慢)。这样，当您在线更新数据集(添加更多条目或对现有条目进行更改)时，您就不必更新本地副本。您只需要运行一个训练脚本，您的模型将根据新数据进行训练。</p></blockquote><p id="34ac" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">现在，我们可以从数据加载器中检索一个批处理，并可视化其中一个输入图像。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/24a4360bcf6037516fa535e481ae1040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ezOOu1uSxn6ZohLhrhSPyw.png"/></div></div></figure><p id="e0f8" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">接下来，让我们定义我们的模型。我们正在为我们的 Fasterrcnn 使用带有功能金字塔网络的 ResNet50 主干网。主干很容易定制。我们需要传递的唯一参数是数据集中的类的数量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/24f9ab2dccb5dab87f786f38361d982d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IC17zpcw0i5JrSF-kUCY7w.png"/></div></div></figure><p id="3170" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在训练模式中，该模型将图像和目标字典作为输入，并产生 loss_dict 作为输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/8cbdef92c534a070080d5361896c1e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFsBZW79ar3yfZVNIqiKgw.png"/></div></div></figure><p id="1bc1" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我们为 5 个时期训练我们的模型。然后，我们通过传递我们的图像来评估它，并获得一个边界框、标签及其各自分数的字典。然而，这不是最终的结果。如果我们看其中一个输出，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/21a581464431baa156333a200f50e43f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Epc11jTyBtoLxjGn_KGHkA.png"/></div></div></figure><p id="9067" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我们看到我们的模型为同一个对象生成了许多盒子。过滤掉不需要的盒子是我们的责任。这样做的一种技术叫做非最大抑制。</p><h2 id="28db" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">非最大抑制(NMS)</h2><p id="4486" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">要在 PyTorch 中使用 NMS，我们可以简单地做</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/7d491b78cae7efdcd890f7e2929bd871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6carblwUM9XI9Rimj6gaw.png"/></div></div></figure><p id="061f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这一行代码给出了我们应该保留的所有边界框的索引。让我们来看看应用 NMS 后的相同图像。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/58352670b3b7a8b4f53896d3a2300316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_79Us5ngSZJwXnvY7NWwA.png"/></div></div></figure><p id="4e5c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">看起来好多了，对吧？那么 NMS 是如何运作的呢？</p><p id="9472" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">要理解 NMS，我们首先需要理解 IoU(并集上的交集)。IoU 是衡量两个盒子相似程度的指标。IoU 越接近 1，方框越相似。记住这一点，让我们来看看 NMS 算法:</p><ol class=""><li id="085d" class="nn no iq lu b lv ml ly mm lf np lj nq ln nr mk ns nt nu nv bi translated">根据分数(置信度)对所有边界框进行排序。</li><li id="b0e6" class="nn no iq lu b lv nw ly nx lf ny lj nz ln oa mk ns nt nu nv bi translated">选择可信度最高的框。该框将是输出的一部分。</li><li id="187d" class="nn no iq lu b lv nw ly nx lf ny lj nz ln oa mk ns nt nu nv bi translated">和其他箱子一起算欠条。</li><li id="de00" class="nn no iq lu b lv nw ly nx lf ny lj nz ln oa mk ns nt nu nv bi translated">将 IoU 超过阈值(本例中为 0.3)的框与所选框一起移除。这将删除包含相同对象或仅包含其一部分的所有重叠框。</li><li id="7ad4" class="nn no iq lu b lv nw ly nx lf ny lj nz ln oa mk ns nt nu nv bi translated">从左边的框中，选择下一个框(第二高的分数)并重复该过程。</li></ol><p id="e219" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这样做给了我们一个非常好的输出。我们可以尝试各种阈值，但 0.3 效果很好。</p><p id="d42b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">如果你也想提取特征图，你可以使用钩子来完成。查看内核中的相同内容。</p><p id="7a8d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这就是本文的全部内容。如果你想了解更多关于深度学习的知识，可以看看我在这方面的系列文章。</p><div class="ob oc gp gr od oe"><a href="https://medium.com/@dipam44/deep-learning-series-30ad108fbe2b" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">深度学习系列</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">我所有关于深度学习的文章的系统列表</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">medium.com</p></div></div><div class="on l"><div class="oo l op oq or on os kp oe"/></div></div></a></div><h2 id="050e" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">参考资料:</h2><p id="d179" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated"><a class="ae kv" href="https://arxiv.org/abs/1506.01497" rel="noopener ugc nofollow" target="_blank">faster CNN 论文</a></p><p id="cd42" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><a class="ae kv" href="https://arxiv.org/abs/1612.03144" rel="noopener ugc nofollow" target="_blank">特色金字塔网论文</a></p><p id="8793" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><a class="ae kv" href="https://www.kaggle.com/pestipeti/pytorch-starter-fasterrcnn-train" rel="noopener ugc nofollow" target="_blank"> PyTorch 启动器—快速启动</a></p><p id="0d55" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/non-maximum-suppression-nms-93ce178e177c">非最大抑制</a></p></div></div>    
</body>
</html>