<html>
<head>
<title>SQL vs. Pandas — Which one to choose in 2020? Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL vs 熊猫——2020 年选哪个？第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-vs-pandas-which-one-to-choose-in-2020-part-2-9268d4a69984?source=collection_archive---------35-----------------------#2020-08-21">https://towardsdatascience.com/sql-vs-pandas-which-one-to-choose-in-2020-part-2-9268d4a69984?source=collection_archive---------35-----------------------#2020-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="89ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最流行的数据分析选项之间的详细比较—第 2/2 部分</h2></div><p id="daea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SQL 和熊猫并不是新技术。尽管如此，为这两种技术找到对应的功能并不是一件容易的事情。这就是这篇文章和上一篇文章发挥作用的地方——为你提供两者之间的详细比较。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/2c67a557fefb2c39b3b8365432c163fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vOAsKwdVv736kLL2"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">本杰明·沃罗斯在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2bef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">几天前，我已经讨论了这个由两部分组成的系列的第一部分，讨论了这两种技术之间更简单的比较:</p><div class="lw lx gp gr ly lz"><a rel="noopener follow" target="_blank" href="/sql-vs-pandas-which-one-to-choose-in-2020-a98f236829ef"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">SQL vs 熊猫——2020 年选哪个？</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">最流行的数据分析选项之间的详细比较—第 1/2 部分</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn lq lz"/></div></div></a></div><p id="60b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先阅读那篇文章不是先决条件，但肯定会帮助你更好地理解这两者。这些技术不是为同样的工作设计的，但是很高兴看到两者之间对应的功能。如前所述，今天我们将讨论更高级的主题:</p><ul class=""><li id="3797" class="mo mp it kk b kl km ko kp kr mq kv mr kz ms ld mt mu mv mw bi translated">连接</li><li id="7c98" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">联合</li><li id="982c" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">分组</li></ul><p id="de7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们这样做之前，让我们从简单的删除语句开始。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="b59c" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">删除</h1><p id="144f" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated"><code class="fe og oh oi oj b">DELETE</code>语句在<em class="le"> SQL </em>中用于从表中删除或移除一行。在<em class="le"> SQL </em>中删除行的语法如下:</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="2578" class="oo nk it oj b gy op oq l or os">DELETE FROM table_name<br/>WHERE condition;</span></pre><p id="cd35" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<em class="le">熊猫</em>中删除一行略有不同。在<em class="le"> Pandas </em>中，我们不删除一行，我们只是选择我们需要的部分，然后丢弃其余的部分。如果你觉得这是个谜，不要担心，这个例子会进一步说明它。</p><p id="041a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们想删除亚洲地区的所有记录。</p><h2 id="57e4" class="oo nk it bd nl ot ou dn np ov ow dp nt kr ox oy nv kv oz pa nx kz pb pc nz pd bi translated">结构化查询语言</h2><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="2367" class="oo nk it oj b gy op oq l or os">DELETE FROM fert_data<br/>WHERE region = ‘Asia’;</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/ec386ee741f9ab27785bceade6e79697.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*vyZurz-9bw3MwLQ_I8FWWQ.png"/></div></figure><p id="59f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">已成功删除行。现在让我们看看如何在<em class="le">熊猫</em>中执行这个任务。</p><h2 id="1f89" class="oo nk it bd nl ot ou dn np ov ow dp nt kr ox oy nv kv oz pa nx kz pb pc nz pd bi translated">熊猫</h2><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="eb4a" class="oo nk it oj b gy op oq l or os">df = df.loc[df[‘region’] != ‘Asia’]</span></pre><p id="4627" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我们选择了区域不是“亚洲”的所有行，然后将结果集分配给我们当前的数据框。这意味着我们已经排除了区域为“亚洲”的所有行。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="d82a" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">连接</h1><p id="0a60" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated"><code class="fe og oh oi oj b">JOINS</code>用于<em class="le"> SQL </em>中，根据特定条件将两个或多个表连接或合并在一起。在<em class="le"> SQL 中主要有四种类型的连接:</em> <code class="fe og oh oi oj b">LEFT</code>、<code class="fe og oh oi oj b">RIGHT</code>、<code class="fe og oh oi oj b">INNER</code>、<code class="fe og oh oi oj b">FULL</code>。以下是 JOIN 的语法:</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="ef11" class="oo nk it oj b gy op oq l or os">SELECT *<br/>FROM table_name_1 as t1 JOIN table_name_2 as t2<br/>ON t1.column_name_1 = t2.column_name_2;</span></pre><p id="38fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<em class="le"> Pandas </em>中，我们可以使用<code class="fe og oh oi oj b">merge()</code> <strong class="kk iu">来连接两个或多个数据帧。</strong>默认情况下，它会执行内部连接。但是您可以使用<code class="fe og oh oi oj b">how</code>参数定制它来执行其他连接。<code class="fe og oh oi oj b">pd.merge()</code>的基本语法如下:</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="f325" class="oo nk it oj b gy op oq l or os">merge(left_df, right_df, how=’inner’, on=condition)</span></pre><p id="ee08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个例子来说明连接。</p><h2 id="2d1a" class="oo nk it bd nl ot ou dn np ov ow dp nt kr ox oy nv kv oz pa nx kz pb pc nz pd bi translated">结构化查询语言</h2><p id="a642" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">下面给出了一个名为<em class="le"> country_sub_region </em>的表格。我们必须使用内部连接将这个表与<em class="le"> fert_data </em>连接起来。</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="d65f" class="oo nk it oj b gy op oq l or os">SELECT country, sub_region<br/>FROM country_sub_region;</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/b19fad4542248730532eef021e55bb83.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*6HssACeGU-RN34mtiZxNew.png"/></div></figure><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="3b8d" class="oo nk it oj b gy op oq l or os">SELECT * FROM<br/>fert_data as f INNER JOIN country_sub_region as c<br/>ON f.country = c.country;</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/e084e751e80e2a272f6c4a66a2d59a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*-2Auf1lO3gju_6q_O_dMZg.png"/></div></figure><p id="d245" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些表已成功联接。让我们看看如何在<em class="le">熊猫</em>中加入他们。</p><h2 id="c39a" class="oo nk it bd nl ot ou dn np ov ow dp nt kr ox oy nv kv oz pa nx kz pb pc nz pd bi translated">熊猫</h2><p id="d4c6" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">这里，我们创建了一个类似于<em class="le"> country_sub_region </em>表的数据框:</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="d1c7" class="oo nk it oj b gy op oq l or os">country_sub_reg = data = [<br/>    [‘country’, ’subregion’],<br/>    [‘Kenya’, ’East Africa’],<br/>    [‘Liberia’, ’West Africa’],<br/>    [‘Mali’, ’West Africa’]<br/>]</span><span id="3b22" class="oo nk it oj b gy ph oq l or os">df_sr = pd.DataFrame(country_sub_reg[1:],columns=country_sub_reg[0])</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/d3987890cb4f4e2c152d1b5383b17b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*WuPptJJVMaTvjq0VevxzjA.png"/></div></figure><p id="ec0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用内部连接将<code class="fe og oh oi oj b">df_sr</code>与<em class="le">国家</em>字段上的<code class="fe og oh oi oj b">df</code>合并:</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="a44b" class="oo nk it oj b gy op oq l or os">pd.merge(df, df_sr, on=’country’, how=’inner’)</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/38d5de019e0e91bf96971c46ec5e873b.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*Wxqb_H7dso46p0U4Gf17rA.png"/></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="cd86" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">联盟</h1><p id="2327" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated"><code class="fe og oh oi oj b">UNION</code>运算符用于将<em class="le"> SQL </em>中两个或多个<code class="fe og oh oi oj b">SELECT</code>语句的结果组合在一起。有一个同志给工会操作员叫<code class="fe og oh oi oj b">UNION ALL</code>。它们的区别在于前者从组合结果中删除了重复值。</p><p id="4e9f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<em class="le">熊猫</em>中<code class="fe og oh oi oj b">UNION ALL</code>操作员的任务可以使用<code class="fe og oh oi oj b">pd.concat()</code>来执行。而<code class="fe og oh oi oj b">UNION</code>操作符的功能可以通过首先使用<code class="fe og oh oi oj b">pd.concat()</code>连接数据帧，然后对其应用<code class="fe og oh oi oj b">pd.drop_duplicates()</code> <strong class="kk iu"> </strong>来执行。</p><h2 id="51bc" class="oo nk it bd nl ot ou dn np ov ow dp nt kr ox oy nv kv oz pa nx kz pb pc nz pd bi translated">结构化查询语言</h2><p id="2ed8" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">为了说明<em class="le"> SQL </em>中的<code class="fe og oh oi oj b">UNION/UNION ALL</code>操作符，我们创建了一个名为<em class="le"> fert_data_1 </em>的附加表。该表中的数据如下所示:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/141642b14d678035b7a4277982f16555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*po8F3gHYb8wZbihaDEYeCQ.png"/></div></figure><p id="073e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的任务如下—从<em class="le"> fert_data </em>和<em class="le"> fert_data_1 </em>表中找到行的并集:</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="c6c1" class="oo nk it oj b gy op oq l or os">SELECT * FROM fert_data_1<br/>UNION ALL<br/>SELECT * FROM fert_data<br/>ORDER BY country;</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi pl"><img src="../Images/eb905807c81101c2a4b4d281570104b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eI0YIEqdxvmK50prPJd3eA.png"/></div></div></figure><p id="33c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您会发现有一些重复的值。是的，你猜对了。您可以使用<code class="fe og oh oi oj b">UNION</code>操作器来移除它们。你自己试试。</p><h2 id="d272" class="oo nk it bd nl ot ou dn np ov ow dp nt kr ox oy nv kv oz pa nx kz pb pc nz pd bi translated">熊猫</h2><p id="78d9" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">在 Pandas 中，我们创建了一个类似于<em class="le"> SQL </em>中的<em class="le"> fert_data_1 </em>表的数据帧。</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="8654" class="oo nk it oj b gy op oq l or os">data = [<br/>    [‘country’, ’region’, ’tfr’, ’contraceptors’],    <br/>    [‘USA’, ’North.Amer’, 1.77, 20],<br/>    [‘UK’, ’Europe’, 1.79, 23],<br/>    [‘Bangladesh’, ’Asia’, 5.5, 40],<br/>    [‘Thailand’, ’Asia’, 2.3, 68]<br/>]</span><span id="e885" class="oo nk it oj b gy ph oq l or os">df1 = pd.DataFrame(data[1:], columns=data[0])</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/1c0dc619e98a1e0c675c751bf8df31d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*TwTWi-obvPBSL3N4BL1COg.png"/></div></figure><p id="99a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe og oh oi oj b">df</code>和<code class="fe og oh oi oj b">df1</code>的联合:</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="cf70" class="oo nk it oj b gy op oq l or os">df_dupli = pd.concat([df1, df])</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi pn"><img src="../Images/dce9eca78e59d3b516cb65f18dd3f743.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*grVH3gZtGWtvlp_VhJzoQA.png"/></div></div></figure><p id="cde2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来自数据框的数据已被合并。但是，在这种情况下，我们也会得到重复的行。例如，我们的目标是让“孟加拉国”只出现一次:</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="eb2f" class="oo nk it oj b gy op oq l or os">df_dupli[df_dupli[‘country’] == ’Bangladesh’]</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi po"><img src="../Images/c9f49a0e362df7da28dfc8191e057f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*quiZSMAGp93E1BMRTDUdnA.png"/></div></figure><p id="a275" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe og oh oi oj b">drop_duplicates()</code>删除重复记录，如下所示:</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="0496" class="oo nk it oj b gy op oq l or os">df_wo_dupli = pd.concat([df1, df]).drop_duplicates()</span></pre><p id="420a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们运行同样的查询，看看我们是否仍然得到两行。</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="5850" class="oo nk it oj b gy op oq l or os">df_wo_dupli[df_wo_dupli[‘country’] == ‘Bangladesh’]</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/15a39b1b58708fc9ebca88e900beccee.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*TG5uq-KI-NT3w2LCdACNKg.png"/></div></figure><p id="b267" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">问题解决了。不再有重复的行。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="3e4d" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">分组依据</h1><p id="efb2" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated"><em class="le"> SQL </em>中的<code class="fe og oh oi oj b">GROUP BY</code>子句用于通过将记录分组在一起来准备汇总行。子句通常与 AVG、SUM、COUNT、MIN、MAX 等集合函数连用。下面是<code class="fe og oh oi oj b">GROUP BY</code>子句的基本语法:</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="d0f1" class="oo nk it oj b gy op oq l or os">SELECT column_name_1, agg_func(column_name_2)<br/>FROM table_name<br/>GROUP BY column_name_1;</span></pre><p id="a832" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<em class="le"> Pandas </em>中，我们有一个<code class="fe og oh oi oj b">groupby()</code>函数，帮助我们汇总特定列的数据。通用语法如下:</p><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="37f6" class="oo nk it oj b gy op oq l or os">df.groupby([‘column_name_1’]).agg_function()</span></pre><p id="1992" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们尝试一个例子来更好地理解它—找到每个区域的平均<em class="le"> tfr </em>和计数<em class="le">逆变</em>场。</p><h2 id="a75c" class="oo nk it bd nl ot ou dn np ov ow dp nt kr ox oy nv kv oz pa nx kz pb pc nz pd bi translated">结构化查询语言</h2><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="58f2" class="oo nk it oj b gy op oq l or os">SELECT region, round(avg(tfr),2), count(contraceptors)<br/>FROM fert_data<br/>GROUP BY region;</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/a124f83ad0533d283db2ad61bfc70053.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*O34-4F3_VWKfieUKp5q0ug.png"/></div></figure><h2 id="30c3" class="oo nk it bd nl ot ou dn np ov ow dp nt kr ox oy nv kv oz pa nx kz pb pc nz pd bi translated">熊猫</h2><pre class="lh li lj lk gt ok oj ol om aw on bi"><span id="5142" class="oo nk it oj b gy op oq l or os">df.groupby(‘region’).agg({‘tfr’: np.mean, ‘contraceptors’: np.size}).round(2)</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi pr"><img src="../Images/cbd10367fd7a30b8887620ccb861a933.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*kFjp6kw06wi3sbehypxOcg.png"/></div></div></figure><p id="6dd1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从两个查询中得到相同的结果。你一定想知道熊猫的那个<code class="fe og oh oi oj b">agg()</code>是干什么用的。它用于聚合指定轴上的一个或多个操作。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="9808" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">在你走之前</h1><p id="68eb" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">这就做到了——你现在应该对这两种技术有了一个很好的了解，至少在数据分析方面。很难推荐哪一个，因为这取决于你以前的经验、偏见和你工作的公司的选择。</p><p id="646b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好的一面是——在<em class="le"> SQL </em>中完成的所有事情都可以在<em class="le"> Pandas </em>中完成——至少在这个层面上。随便选一个你更喜欢的，不会出错的。</p><p id="be71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="67f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">喜欢这篇文章吗？成为</em> <a class="ae lf" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="le">中等会员</em> </a> <em class="le">继续无限制的学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="lw lx gp gr ly lz"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">通过我的推荐链接加入 Medium-Dario rade ci</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com</p></div></div><div class="mi l"><div class="ps l mk ml mm mi mn lq lz"/></div></div></a></div></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="f1fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">加入我的私人邮件列表，获得更多有用的见解。 </p></div></div>    
</body>
</html>