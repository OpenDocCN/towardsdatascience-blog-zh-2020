<html>
<head>
<title>The One PyTorch Trick Which You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的一个PyTorch把戏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-one-pytorch-trick-which-you-should-know-2d5e9c1da2ca?source=collection_archive---------9-----------------------#2020-04-29">https://towardsdatascience.com/the-one-pytorch-trick-which-you-should-know-2d5e9c1da2ca?source=collection_archive---------9-----------------------#2020-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/fde1a9de2ccf3bbaa787da36b5f64b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6ihDliAWA5XWXlh0Nb-TA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://www.pexels.com/@willianwas" rel="noopener ugc nofollow" target="_blank">威利安来自<a class="ae jg" href="https://www.pexels.com/photo/man-in-black-tank-top-skateboarding-wearing-helmet-700953/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的</a></p></figure><div class=""/><div class=""><h2 id="bc73" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">钩子如何显著改善你的工作流程</h2></div><p id="b6ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你以前使用过深度学习，你就会知道调试模型有时真的很难。张量形状不匹配、爆炸梯度和无数其他问题可能会让你大吃一惊。解决这些问题需要在显微镜下观察模型。最基本的方法包括使用print语句或引入断点来丢弃<code class="fe lu lv lw lx b">forward()</code>方法。这些当然不太具有可扩展性，因为它们需要猜测哪里出了问题，而且总体来说非常繁琐。</p><p id="1645" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，有一个解决方案:钩子。这些是特定的函数，可以附加到每一层，并在每次使用该层时调用。它们基本上允许您冻结特定模块的向前或向后传递的执行，并处理其输入和输出。</p><p id="2720" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看他们的行动吧！</p><h1 id="7927" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">钩子速成班</h1><p id="09e6" class="pw-post-body-paragraph ky kz jj la b lb mq kk ld le mr kn lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">因此，钩子只是一个带有预定义签名的可调用对象，它可以注册到任何<code class="fe lu lv lw lx b">nn.Module</code>对象。当在模块上使用触发方法时(即<code class="fe lu lv lw lx b">forward()</code>或<code class="fe lu lv lw lx b">backward()</code>，模块本身及其输入和可能的输出被传递给钩子，在计算进行到下一个模块之前执行。</p><p id="9cfb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在PyTorch中，您可以将一个钩子注册为</p><ul class=""><li id="bb3f" class="mv mw jj la b lb lc le lf lh mx ll my lp mz lt na nb nc nd bi translated">向前预瞄(在向前传球之前执行)，</li><li id="1b4f" class="mv mw jj la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">向前钩住(在向前传球之后执行)，</li><li id="d74a" class="mv mw jj la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">向后挂钩(在向后传递后执行)。</li></ul><p id="e754" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一开始听起来可能很复杂，所以让我们来看一个具体的例子！</p><h2 id="bc93" class="nj lz jj bd ma nk nl dn me nm nn dp mi lh no np mk ll nq nr mm lp ns nt mo nu bi translated">示例:保存每个卷积层的输出</h2><p id="7bb5" class="pw-post-body-paragraph ky kz jj la b lb mq kk ld le mr kn lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">假设我们想要检查ResNet34架构中每个卷积层的输出。这个任务非常适合钩子。在下一部分中，我将向您展示如何实现这一点。如果你想互动地跟随它，你可以在https://github.com/cosmic-cortex/pytorch-hooks-tutorial<a class="ae jg" href="https://github.com/cosmic-cortex/pytorch-hooks-tutorial" rel="noopener ugc nofollow" target="_blank"/>找到附带的Jupyter笔记本。</p><p id="b7ea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的模型定义如下。</p><figure class="nv nw nx ny gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d44b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建一个钩子来保存输出非常简单，一个基本的可调用对象就足够了。</p><figure class="nv nw nx ny gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b220" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">SaveOutput</code>的一个实例将简单地记录向前传递的输出张量，并将其存储在一个列表中。</p><p id="7410" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以用<code class="fe lu lv lw lx b">register_forward_hook(hook)</code>方法注册一个向前的钩子。(对于其他类型的挂钩，我们有<code class="fe lu lv lw lx b">register_backward_hook</code>和<code class="fe lu lv lw lx b">register_forward_pre_hook</code>。)这些方法的返回值是钩子句柄，可以用来从模块中移除钩子。</p><p id="b6ec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们将钩子注册到每个卷积层。</p><figure class="nv nw nx ny gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="33b7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当这样做时，钩子将在每个卷积层的每个前向传递之后被调用。为了测试它，我们将使用下面的图像。</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/52d5967e3645a6e59fc14b64d9a6b734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_alfzTepyrmx-faL"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@madhatterzone?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">曼加·维托里奇</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="80a0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">向前传球:</p><figure class="nv nw nx ny gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1d76" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如预期的那样，输出被正确存储。</p><pre class="nv nw nx ny gt oc lx od oe aw of bi"><span id="1c19" class="nj lz jj lx b gy og oh l oi oj">&gt;&gt;&gt; len(save_output.outputs)<br/>36</span></pre><p id="ad1d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过检查这个列表中的张量，我们可以可视化网络所看到的。</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/4acde6c03b7772409b83f177c2005ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*oYiR6DS_V3e8JxeN7ps-IQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">ResNet34第一层的输出。</p></figure><p id="631e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于好奇，我们可以检查一下之后会发生什么。如果我们在网络中走得更深，学习到的特征会变得越来越高。例如，有一个似乎负责检测眼睛的过滤器。</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/a91e75705c3c5b073c038d45bf793d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*8ccQX1EG_kKN0b64cXtotg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">ResNet34的第16卷积层的输出。</p></figure><h1 id="4902" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">超越</h1><p id="37b8" class="pw-post-body-paragraph ky kz jj la b lb mq kk ld le mr kn lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">当然，这只是冰山一角。钩子能做的不仅仅是简单地存储中间层的输出。例如，神经网络修剪，这是一种减少参数数量的技术，<a class="ae jg" href="https://pytorch.org/tutorials/intermediate/pruning_tutorial.html" rel="noopener ugc nofollow" target="_blank">也可以用钩子</a>来执行。</p><p id="f257" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总而言之，如果你想增强你的工作流，应用钩子是一个非常有用的学习技巧。有了这些，你就能做更多更有效的事情。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="7f78" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://www.tivadardanka.com/blog" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> <em class="os">如果你喜欢把机器学习概念拆开，理解是什么让它们运转，我们有很多共同点。看看我的博客，我经常在那里发表这样的技术文章！</em> </strong> </a></p></div></div>    
</body>
</html>