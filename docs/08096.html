<html>
<head>
<title>Tree algorithms explained: Ball Tree Algorithm vs. KD Tree vs. Brute Force</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">树算法讲解:球树算法vs. KD树vs .蛮力</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tree-algorithms-explained-ball-tree-algorithm-vs-kd-tree-vs-brute-force-9746debcd940?source=collection_archive---------5-----------------------#2020-06-15">https://towardsdatascience.com/tree-algorithms-explained-ball-tree-algorithm-vs-kd-tree-vs-brute-force-9746debcd940?source=collection_archive---------5-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4802" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解最近邻搜索的结构化数据算法背后的内容</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/034ee9b7cc5edd00e77a8c35a31d8b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOmEnJ6PxUhxrrOhIgqBSw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://www.pexels.com/photo/flight-landscape-nature-sky-36717/" rel="noopener ugc nofollow" target="_blank"> pixabay </a>。</p></figure><p id="aeb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三种算法都用于最近邻搜索。球树和KD树算法是用于数据点的空间划分和它们到特定区域的分配的树算法。换句话说，它们用于在多维空间中构建数据。</p><p id="06c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">不过先从底层说起:</strong> <em class="lv">为什么叫树算法？什么是树？— </em>跳过，如果你已经知道了！</p><p id="291f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一棵<strong class="lb iu">树</strong>是一种结构化数据的分层方式。由于存在诸如队列的线性数据结构，其中数据被一个接一个地分配，所以树是一种常见的数据结构。树被应用于计算机科学的许多不同领域，从图形、数据库到操作系统。它们不仅与自然界中的植物学朋友有共同的名称，而且还有一些特征。作为植物树，计算机科学中的树有根、叶和分支。然而，与普通树相比，这些部分的分配是自底向上的。根在树顶，叶在下端。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/5f72483e479a32d848b09f2ea64b1459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MfDwumgWRHfHJjOoY0BsNg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">树的结构。</p></figure><p id="4ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">父节点= </strong>是另一个节点之上的节点，例如，根节点是其下内部节点的父节点</p><p id="1384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">子节点</strong> =顾名思义，父节点的子节点，以及父节点下的子节点。子节点可以再次成为下面节点的父节点。</p><p id="fe5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">根节点</strong> =最上面的节点，树的原点</p><p id="0330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">叶节点</strong> =也称为外部节点，可以看作是一个“死胡同”，它是最后一个节点，下面没有子节点</p><p id="691f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">内部节点</strong> =也称为内部节点或分支节点。它是一个上下都有连接的节点(子节点和父节点)</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="433b" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">你还没上媒体？每月仅需4.16美元。</h1><h1 id="9459" class="me mf it bd mg mh mw mj mk ml mx mn mo jz my ka mq kc mz kd ms kf na kg mu mv bi translated"><a class="ae ky" href="https://medium.com/@hucker.marius/membership" rel="noopener">开始使用</a></h1></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="6ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解这在计算机科学话题中的表现，你可以在下面找到一段HTML代码。树有助于构建网站，网站通常可以用树来描述。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="ede3" class="ng mf it nc b gy nh ni l nj nk"><strong class="nc iu">&lt;html&gt;<br/>&lt;head&gt;</strong><br/>    <strong class="nc iu">&lt;meta charset=utf-8" /&gt;</strong><br/>    <strong class="nc iu">&lt;title&gt;</strong>Ball Tree vs. KD Tree<strong class="nc iu">&lt;/title&gt;</strong><br/>    <strong class="nc iu">&lt;nav&gt;</strong><br/>    <strong class="nc iu">&lt;a href="/r/"&gt;</strong>R<strong class="nc iu">&lt;/a&gt;</strong><br/>    <strong class="nc iu">&lt;a href="/js/"&gt;</strong>JavaScript<strong class="nc iu">&lt;/a&gt;</strong><br/>    <strong class="nc iu">&lt;a href="/python/"&gt;</strong>Python<strong class="nc iu">&lt;/a&gt;</strong><br/>    <strong class="nc iu">&lt;/nav&gt;</strong><br/><strong class="nc iu">&lt;/head&gt;</strong></span><span id="1290" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">&lt;body&gt;</strong><br/>    <strong class="nc iu">&lt;h1&gt;</strong>What is a tree?<strong class="nc iu">&lt;/h1&gt;</strong><br/>    <strong class="nc iu">&lt;ul&gt;</strong><br/>        <strong class="nc iu">&lt;li&gt;</strong>List item one<strong class="nc iu">&lt;/li&gt;</strong><br/>        <strong class="nc iu">&lt;li&gt;</strong>List item two<strong class="nc iu">&lt;/li&gt;</strong><br/>    <strong class="nc iu">&lt;/ul&gt;</strong><br/>    <strong class="nc iu">&lt;h2&gt;</strong>How does a tree look like?<strong class="nc iu">&lt;/h2&gt;</strong><br/><strong class="nc iu">&lt;/body&gt;</strong><br/><strong class="nc iu">&lt;/html&gt;</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/78f351e44251af0dce57a97181104d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XpEW11ku2O7PBzekbRWcvg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">html代码的树形可视化。</p></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="5830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">KD-Tree算法和Ball算法都是构建这种树的二进制算法。在这个上下文中，二进制意味着每个父节点只有两个子节点。典型地，该算法应用于最近邻搜索。</p><h2 id="91cc" class="ng mf it bd mg nn no dn mk np nq dp mo li nr ns mq lm nt nu ms lq nv nw mu nx bi translated">球树算法</h2><p id="5ecd" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">球树算法可以被视为一个<em class="lv">度量树</em>。度量树考虑数据点所在的度量空间来组织和构造数据点。使用度量标准，点不必是有限维的或在向量中(Kumar，Zhang &amp; Nayar，2008)。</p><p id="87e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法将数据点分成两个聚类。每个集群被一个圆(2D)或一个球(3D)包围。这个球通常被称为超球。</p><blockquote class="od oe of"><p id="1a52" class="kz la lv lb b lc ld ju le lf lg jx lh og lj lk ll oh ln lo lp oi lr ls lt lu im bi translated">“一个<strong class="lb iu">超球</strong>是距离称为其中心的给定点恒定距离的点集。”— <a class="ae ky" href="https://en.wikipedia.org/wiki/Hypersphere" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="4824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从簇的球体形式，衍生出名称<strong class="lb iu"> <em class="lv">球树算法</em> </strong>。每个簇代表树的一个节点。让我们看看算法是如何执行的。</p><p id="1092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择的子节点之间的距离最大，通常在树的每一层使用以下结构。</p><p id="9399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，设置整个数据点云的质心。与质心距离最大的点被选为第一个群集和子节点的中心。离第一聚类中心最远的点被选为第二聚类的中心点。然后，将所有其他数据点分配给距离中心最近的节点和聚类，可以是聚类1或聚类2。任何点只能是一个集群的成员。球体线可以彼此相交，但是这些点必须明确地分配给一个簇。如果一个点正好在两个中心的中间，并且随后到两边的距离相同，则该点必须被分配到一个聚类中。集群可能不平衡。这基本上是球树算法背后的概念。将数据点分成两个群/球的过程在每个群内重复，直到达到定义的深度。这导致嵌套集群包含越来越多的圆。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/efc58c0ee142f35b3fb8fe1a79a2ba31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bdt854gdCrd_kKQECAELPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">球树算法的可视化。</p></figure><p id="5968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图所示，树的深度为2。质心1是算法的开始。一个球体(2D)被放置在所有数据点(灰色)周围。从中心开始，选择聚类的最远点，这里是数字3或数字9。这是星团1的新中心，这里是紫色星团的3号。离第三个点最远的点是聚类2的中心。这是橙色星团的9号。然后，包括紫色球体的所有数据点被考虑用于新质心2的计算。对位于橙色球体中的所有数据点进行同样的操作，得到质心3。最远的点再次成为新群的中心。数据点编号3是距离质心2和新簇中心最远的点。</p><p id="72bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在质心2的另一侧，它和数据点1之间的最大距离ist。它是第二个集群的中心。然后对橙色侧也执行该步骤，再次产生两个集群。然而，橙色的一面是不平衡的。<br/>生成的树如下所示(M是质心为1的球体和包含所有数据点的起始球体)。从那里，集群被划分为深度为2:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/f9e834f676d9ce2f0cf9c93c1f970383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*InmEnPbjsqWp0hbUuJ64Dw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">产生的球树。</p></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="af9e" class="ng mf it bd mg nn no dn mk np nq dp mo li nr ns mq lm nt nu ms lq nv nw mu nx bi translated">KD树算法</h2><p id="d645" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">KD树算法是最常用的最近邻算法之一。数据点在每个节点被分成两组。像前面的算法一样，KD树也是一个二叉树算法，总是以最多两个节点结束。选择的分割标准通常是中间值。在下图的右侧，您可以看到数据点的确切位置，左侧是它们的空间位置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/d4fe92cd3a350d830a7cecfdf085ef0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f0CNdguQEiQJgL0Rhl3S8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据点及其在坐标系中的位置。</p></figure><p id="91b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">KD树算法首先使用第一轴的中值，然后在第二层中使用第二轴的中值。我们从x轴开始，<br/>按升序排序的x值是:1，2，3，4，4，6，7，8，9，9。接下来，中位数是6。</p><p id="f849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据点然后被分成较小的和较大的，等于6。这导致(1，2) (2，3) (3，4) (4，5) (4，6)在左侧，而(6，5) (7，9) (8，7) (9，6) (9，1)在另一侧的簇上。在坐标系中画出6的中值，就可以看到这两个可视化的集群。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/65ba6b34fb2712d6fafd4b695c5c6400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJKI5vOJoWQLTy4AzV2OLA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将6的x中值绘制到坐标系中。</p></figure><p id="ea50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们要用Y轴。我们已经有了两个集群，所以我们需要分别查看它们。在左边，我们得到了排序后的y值:2，3，4，5，6。中位数是4。这会在值4处产生一条分隔线，坐标系如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/521f8f3d9ee5716efcd3df2783aee3d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jtRJZ-wppZwomKkKLRBgw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">中间值4分隔X中间值(=6)左侧的数据点。</p></figure><p id="1524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些值以4分隔，第一个分类包含(2，3) (1，2)。第二组包含点(4，6) (3，4) (4，5)。<br/>在x-median的另一边，4是目前的5个点(包括点(5，6))。按照排序顺序，y值为6，7，8，9，9。这导致中值为8，并且第一个聚类包含(9，1)和(6，5)。第二个聚类包含(8，7)(7，9)(9，6)。<br/>最终的坐标系如下所示。数据点被分成深度为2 (X和Y)的4个聚类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/49e9d185f5e6d420eaedf1a2ba5caaad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJQ2izgF8WXOZeC56eJtjQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最终的空间分离。</p></figure><p id="55e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这棵树看起来像什么？让我们看看结果树是如何划分的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/5859a21d09b0316fca36d2bd992f32f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*6LuJXjGifBSm7lEEO5sftQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">KD树。</p></figure><h2 id="21ef" class="ng mf it bd mg nn no dn mk np nq dp mo li nr ns mq lm nt nu ms lq nv nw mu nx bi translated">比较和总结</h2><p id="d4bc" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">由于考虑了所有数据点，暴力可能是最准确的方法。因此，没有数据点被分配给错误的聚类。对于小数据集，蛮力是合理的，然而，对于增加的数据，KD或球树是更好的选择，因为它们的速度和效率。</p><blockquote class="od oe of"><p id="8b09" class="kz la lv lb b lc ld ju le lf lg jx lh og lj lk ll oh ln lo lp oi lr ls lt lu im bi translated">KD树及其变体可以被称为“投影树”，这意味着它们基于点在一些低维空间中的投影来对点进行分类。(库马尔、张和纳亚尔，2008年)</p></blockquote><p id="b1a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于低维数据，KD树算法可能是最好的解决方案。如上所述，KD树的节点划分是轴对齐的，不能采取不同的形状。所以分布可能没有正确映射，导致性能下降。</p><p id="8b5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于高维空间，球树算法可能是最好的解决方案。它的性能取决于训练数据的数量、维度和数据的结构。由于没有清晰的结构，具有许多噪声数据点也可能导致糟糕的性能。</p><p id="4500" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，希望您喜欢！</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><div class="kj kk kl km gt oq"><a href="https://medium.com/subscribe/@hucker.marius" rel="noopener follow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">请继续关注马里乌斯·哈克的新文章</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">请继续关注Marius Hucker的新文章。如果您还没有注册，您将创建一个中型帐户…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">medium.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="9085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">参考文献</em> </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pf pg l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pf pg l"/></div></figure><div class="ph pi gp gr pj oq"><a href="https://github.com/JKnighten/k-nearest-neighbors/wiki/KNN-and-BallTree-Overview" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">JKnighten/k-最近邻</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">k近邻(KNN)是一个简单的机器学习算法，可用于分类和…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">github.com</p></div></div><div class="oz l"><div class="pk l pb pc pd oz pe ks oq"/></div></div></a></div><div class="ph pi gp gr pj oq"><a href="https://ashokharnal.wordpress.com/tag/ball-tree-explained-in-simple-manner/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">球树深入浅出的解释——Linux大叔</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">2015年1月20日在这篇博客和接下来的几篇博客中，我将讨论k-近邻(k-NN)算法的实现…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">ashokharnal.wordpress.com</p></div></div><div class="oz l"><div class="pl l pb pc pd oz pe ks oq"/></div></div></a></div><div class="ph pi gp gr pj oq"><a href="https://jakevdp.github.io/blog/2013/04/29/benchmarking-nearest-neighbor-searches-in-python/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">Python中最近邻搜索的基准测试</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">我最近提交了一个scikit-learn pull请求，其中包含一个全新的球树和快速最近邻的kd树…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">jakevdp.github.io</p></div></div></div></a></div></div></div>    
</body>
</html>