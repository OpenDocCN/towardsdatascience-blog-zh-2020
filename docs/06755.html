<html>
<head>
<title>Financial Independence — Simulating ODEs With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">财务独立——用 Python 模拟 ODEs</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/financial-independence-simulating-odes-with-python-c9b5468dbe74?source=collection_archive---------72-----------------------#2020-05-26">https://towardsdatascience.com/financial-independence-simulating-odes-with-python-c9b5468dbe74?source=collection_archive---------72-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/30acf0c6fd98451c5d4bf227bf77b923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2hgAno-VRzcqTWgOT6nHkg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者试图战胜地心引力。波兰 2015。</p></figure><div class=""/><div class=""><h2 id="9d63" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">使用 Python 来设置你的路径。</h2></div><h1 id="65f1" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">介绍</h1><p id="c4bf" class="pw-post-body-paragraph lp lq ji lr b ls lt kj lu lv lw km lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">想象一下，有一天你醒来，你知道你可以在余生中自由地做任何你想做的事情…而且…钱不再是问题。你变得真正经济独立<em class="ml"/>并且你不再需要工作来保证来年的收入。听起来有吸引力吗？</p><p id="d1a0" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">虽然听起来可能如此，但实现这一目标的道路肯定不容易(不像 Youtube 广告所说的那样)。在处理你的财务问题时，有许多因素需要考虑，而推理往往被复杂性所掩盖。</p><p id="8062" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">在本文中，我们将从数学和程序上解决这个问题。</p><p id="c5ee" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">我们将使用一组<em class="ml">常微分方程</em> (ODEs)来为你的钱包建模，稍后我们将使用<code class="fe mr ms mt mu b">scipy</code>库和 Python 来<em class="ml">求解</em>。在每个阶段，我们将尝试<strong class="lr jj">将数学公式与 python 代码</strong>联系起来，并解释其背后的推理。</p><p id="a5c0" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">目标是使模型具有可解释性和可扩展性。我们将一步一步地创建它，希望这能让我们对底层数学和代码有更直观的理解。作为参考，请看看下面的笔记本:<a class="ae mv" href="https://github.com/OlegZero13/Data-Science-Algorithm-Gallery/blob/master/Personal_Financial_Simulator_with_ODE.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="d7e9" class="mw ky ji bd kz mx my dn ld mz na dp lh ly nb nc lj mc nd ne ll mg nf ng ln nh bi translated">放弃</h2><p id="ba75" class="pw-post-body-paragraph lp lq ji lr b ls lt kj lu lv lw km lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">在我们进入等式之前，我们想强调的是，这篇文章在任何情况下都不应该被视为财务建议。这篇文章的作者有物理学而不是金融的背景，所以也请原谅使用的词汇中任何可能的不一致。</p><h1 id="66f4" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">问题陈述</h1><p id="ee5a" class="pw-post-body-paragraph lp lq ji lr b ls lt kj lu lv lw km lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">看钱包有两种方法。</p><p id="7ae4" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">一种方法是看看在任何给定的时间点<em class="ml"> t </em>你<strong class="lr jj">有</strong> <em class="ml"> x(t) </em>多少钱。另一种方法是看它<strong class="lr jj">如何随时间变化</strong>。知道初始量<em class="ml"> x₀ = x(0) </em>以及一阶导数<em class="ml"> dx/dt </em>，你就可以预测未来的情况。</p><p id="5d51" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">因为在我们看来，为导数制定方程是一个简单得多的过程，我们将倾向于这种方法，而不是直接寻找<em class="ml"> x(t) </em>。毕竟，一旦我们有了<em class="ml"> dx/dt </em>的完整表达式，<em class="ml"> x(t) </em>就可以通过数值积分<em class="ml"> dx/dt </em>得到:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/16844843640639aff1b82aedb3e57b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*v4ZpXaSAhaQYVsQ7kha-pA.png"/></div></figure><p id="56e6" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">前提是我们知道 x₀。</p><h1 id="8685" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">简单模型</h1><h2 id="0657" class="mw ky ji bd kz mx my dn ld mz na dp lh ly nb nc lj mc nd ne ll mg nf ng ln nh bi translated">你朝九晚五地工作…</h2><p id="116b" class="pw-post-body-paragraph lp lq ji lr b ls lt kj lu lv lw km lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">让我们从一个简单的例子开始，你有一份工作。您现在还没有投资，您的年度余额由以下三个因素决定:</p><ul class=""><li id="0182" class="nn no ji lr b ls mm lv mn ly np mc nq mg nr mk ns nt nu nv bi translated">你的年收入是多少？</li><li id="61ed" class="nn no ji lr b ls nw lv nx ly ny mc nz mg oa mk ns nt nu nv bi translated">你所有的花费……一切:食物、房租、汽车、饮料，无论什么，</li><li id="23b7" class="nn no ji lr b ls nw lv nx ly ny mc nz mg oa mk ns nt nu nv bi translated">你为你的收入缴纳的税。</li></ul><p id="7917" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">如果没有其他因素起作用，你的<em class="ml">收益</em>(或<em class="ml">损失</em> ) —你变富或变穷的比率是:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/a6aac7ca9b01c9b52af66d3fa54d47a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*8ABY9-fZVaOVVkwBlzOoIg.png"/></div></figure><p id="1e4d" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">因此，我们可以设定</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/e0f692588d2f8e1baef9f5dd173aa9e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:186/format:webp/1*l9Uu-GRmfGPYN049UAGysg.png"/></div></figure><p id="c9d3" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">如果<em class="ml"> a，s </em>和<em class="ml"> T </em>是常数，那么这个等式实际上非常简单，我们可以解析地求解它:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/4577ab8d1b4cdb2840fe4a26b0a1aeed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*Xy8Y0On3ZPxxM16bLHYjYA.png"/></div></figure><p id="bec7" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">这是一条直线，但是因为我们只是设置了逐渐增加复杂性的路径，所以让我们用 python 来做。</p><pre class="nj nk nl nm gt oe mu of og aw oh bi"><span id="2406" class="mw ky ji mu b gy oi oj l ok ol">import numpy as np<br/>import pandas as pd<br/>from scipy.integrate import odeint<br/><br/><br/>class Life:<br/>    def __init__(self):<br/>        self.income = 10000  # gold pcs. per month<br/>        self.spending = 5000 # gold pcs. per month<br/>        self.tax_rate = 0.19 # example<br/>    <br/>    def earn(self, t):<br/>        return 12 * self.income<br/><br/>    def spend(self, t):<br/>        return 12 * self.spending<br/><br/>    def pay_taxes(self, t):<br/>        return self.earn(t) * self.tax_rate<br/><br/><br/>def live_without_investing(x, t, you):<br/>    return you.earn(t) - you.spend(t) - you.pay_taxes(t)</span></pre><p id="e8b7" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">这里，<code class="fe mr ms mt mu b">Life</code>是类，我们将使用它的方法来定义分数贡献。虽然其形式纯粹是为了方便起见，但将贡献的定义分开是有意义的，因为它们本身会变得复杂(例如累进税)。</p><p id="67fd" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated"><code class="fe mr ms mt mu b">live_without_investing(...)</code>函数是我们的衍生物，因此，它有一个精确定义的接口<code class="fe mr ms mt mu b">func(x, t, **args)</code>。</p><p id="8344" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">为了执行集成，我们可以使用来自<a class="ae mv" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html" rel="noopener ugc nofollow" target="_blank"> scipy </a>的<code class="fe mr ms mt mu b">odeint</code>。</p><pre class="nj nk nl nm gt oe mu of og aw oh bi"><span id="e521" class="mw ky ji mu b gy oi oj l ok ol">def simulate(you):<br/>    t = np.linspace(0, 100, num=101)<br/>    x = odeint(live_without_investing, 0, t, args=(you,))<br/>    return pd.DataFrame({'time': t, 'wallet (non-investor)': x})<br/><br/><br/>you = Life()<br/>df = simulate(you)</span></pre><p id="f151" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">这里，我们定义了 100 年的时间线，粒度为 1，并将其作为第三个参数传递给<code class="fe mr ms mt mu b">odeint</code>。作为第二个参数传递的零代表<em class="ml"> x₀ = 0 </em>这是我们的初始条件。第四个(可选的)参数允许我们向函数传递额外的参数，我们刚刚通过传递<code class="fe mr ms mt mu b">you</code> object 做到了这一点。</p><h1 id="163a" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">生活的不连续性</h1><p id="4ab2" class="pw-post-body-paragraph lp lq ji lr b ls lt kj lu lv lw km lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">很难想象你五岁的时候就已经在交税了。同样，过了某个年龄，你可能会想收获你工作的成果。</p><p id="a79c" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">为了将这些关键变化融入你的生活，我们将把它分成三个阶段:</p><ul class=""><li id="5915" class="nn no ji lr b ls mm lv mn ly np mc nq mg nr mk ns nt nu nv bi translated"><em class="ml">童年</em>——你完全依赖父母，因此<em class="ml"> x(t) = 0 </em>。</li><li id="8580" class="nn no ji lr b ls nw lv nx ly ny mc nz mg oa mk ns nt nu nv bi translated">积极的生活——你挣钱，你消费，你纳税。</li><li id="36c7" class="nn no ji lr b ls nw lv nx ly ny mc nz mg oa mk ns nt nu nv bi translated"><em class="ml">退休</em> —你的收入被低于收入的养老金取代，你的支出故意保持在同一水平，但税收被认为已经缴纳。</li></ul><p id="ca21" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">同时，我们引入了另外两个参数:<code class="fe mr ms mt mu b">you.starting_age</code>和<code class="fe mr ms mt mu b">you.retirement_age</code>作为你在上述阶段之间转换的年龄。</p><p id="8438" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">对于我们的数学模型，这种转变意味着存在两个点<em class="ml"> t₁ </em>和<em class="ml"> t₂ </em>，在这两个点<em class="ml"> dx/dt </em>是不连续的。为了正确计算<em class="ml"> x(t) </em>，我们需要<em class="ml">对你一生中的<em class="ml"> dx/dt </em>进行分段积分，从摇篮到坟墓。</em></p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/14bff80d3b8232d19573f403aa1d14a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*WUiA1upsDkyZMPuuFlMbIA.png"/></div></figure><p id="4a3f" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">对于我们的代码，我们以下列方式修改模型:</p><pre class="nj nk nl nm gt oe mu of og aw oh bi"><span id="3eb0" class="mw ky ji mu b gy oi oj l ok ol">class Life:<br/>    def __init__(self):<br/>        ...  # as before<br/>        self.pension = 1000<br/>        self.starting_age = 18<br/>        self.retirement_age = 67<br/><br/>    def earn(self, t):<br/>        if t &lt; self.starting_age:<br/>            return 0<br/>        elif self.starting_age &lt;= t &lt; self.retirement_age:<br/>            return 12 * self.income<br/>        else:<br/>            return 12 * pension<br/><br/>    def spend(self, t):<br/>        ...  # as before<br/><br/>    def pay_taxes(self, t):<br/>        ...  # as before<br/><br/><br/>def life_without_investing(x, y, you):<br/>    ...  # as before</span></pre><p id="7280" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">然后，模拟变成:</p><pre class="nj nk nl nm gt oe mu of og aw oh bi"><span id="9418" class="mw ky ji mu b gy oi oj l ok ol">def simulate(you):<br/>    t0 = np.linespace(0, you.starting_age - 1, num=you.starting_age)<br/>    t1 = np.linespace(you.starting_age, you.retirement_age - 1, num=(you.retirement_age - you.starting_age))<br/>    t2 = np.linespace(you.retirement_age, 100, num=(100 - you.retirement_age))<br/><br/>    x0 = np.zeros((t0.shape[0], 1))<br/>    x1 = odeint(live_without_investing, 0, t1, args=(you,))<br/>    x2 = odeint(live_without_investing, x1[-1], t2, args=(you,))<br/><br/>    df0 = pd.DataFrame({'time': t0, 'wallet (non-investor)': x0})<br/>    df1 = pd.DataFrame({'time': t1, 'wallet (non-investor)': x1})<br/>    df2 = pd.DataFrame({'time': t2, 'wallet (non-investor)': x2})<br/>    return pd.concat([df0, df1, df2])</span></pre><p id="6e84" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">注意，我们还将<em class="ml"> x(tₙ) </em>作为初始条件输入到下一个积分中。虽然<em class="ml"> dx/dt </em>是不连续的，但是<em class="ml"> x(t) </em>就不能这么说了！</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/f5fab078f635cc34f570c80d00abca38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JtImTEvQcfwaddJv.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图一。示例“使用起始年龄=18 岁”，“退休年龄= 67 岁”，收入= 1000，成本= 650，税率= 19%。注意到一旦过了退休年龄，养老金就不能补偿支出，从而导致债务。</p></figure><h1 id="49fd" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">添加非线性</h1><p id="ec09" class="pw-post-body-paragraph lp lq ji lr b ls lt kj lu lv lw km lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">到目前为止，我们假设钱包每年的增长是一个常数函数<em class="ml">δ= a—s—T(a)</em>，<em class="ml">δ≠δ(T)</em>。你可能会获得一些年度加薪或增加你的支出。也有可能你想把税率本身建模成一个依赖于时间的函数。</p><p id="a666" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">假设你的收入现在是时间的线性函数 a(t)=α₀+α₁t(T25)，这里是你的预期基本收入(平均值)，是额外的“黄金个人电脑”数量你每年都会收到。类似地，支出也可以用 s(t)=σ₀+σ₁t(t27)的形式表示，σ₀是平均每月支出，是你未来将要支出的额外金额——一种“生活水平的通胀”。</p><p id="bacd" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">现在，我们的导数与时间成正比<em class="ml"> dx/dt ∝ t </em>，因此我们可以期望是二次的<em class="ml"> x(t) ∝ t </em>。</p><p id="cb63" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">同样，以编程方式:</p><pre class="nj nk nl nm gt oe mu of og aw oh bi"><span id="0c10" class="mw ky ji mu b gy oi oj l ok ol">class Life:<br/>    def __init__(self):<br/>        ...  # as before<br/>        self.pay_raise = 100<br/>        self.life_inflation = 50<br/><br/>    def earn(self, t):<br/>            ...  # as before<br/>        elif self.starting_age &lt;= t &lt; self.retirement_age:<br/>            return 12 * (self.income + self.pay_raise \<br/>                      * (t - self.starting_age))<br/>        else:<br/>            ...  # as before<br/><br/>    def spend(self, t):<br/>        ...  # as before<br/>        return 12 * (self.costs + self.life_inflation \<br/>                  * (t - self.starting_age))</span></pre><p id="eade" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">集成保持不变，但它带来了一个新的结果。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/309b9eea6b45e3a93821b6e1fcb0b714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gitxdA9fHfhItnL8.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图二。使用附加参数的示例:` pay _ raise = 100 `,` life _ inflation = 50`。观察两条曲线的抛物线形状。</p></figure><h1 id="6510" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">投资</h1><p id="a441" class="pw-post-body-paragraph lp lq ji lr b ls lt kj lu lv lw km lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">如果你按照计算，你可能已经试图根据与你更相关的数字来预测你的财务状况。你可能已经注意到，即使你选择不提高自己的生活水平，平均工资的高增长也不能保证提前或安全退休。</p><p id="fd7a" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">从数学上来说，你可以自由构建任何你想要的“加薪”条款(例如<em class="ml"> a(t) ∝ t </em>或<em class="ml"> a(t) ∝ t </em>)，但你可能很难证明它们的实际来源。况且这样的条款只能给你的钱包<em class="ml">多项式</em>的增长，说实话，还没有它能得到的那么快。</p><p id="f791" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">在这个阶段，你们中的一些人可能已经回忆起了<em class="ml">复利</em>的公式:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/2720b19c706af813665e4ca83e18bae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*NTttRazmSBWsOH1uq8ionA.png"/></div></figure><p id="5fa9" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">其中 FV 代表<em class="ml">未来值</em>，PV 为<em class="ml">现值</em>(通常称为<em class="ml">本金</em>)，<em class="ml"> R </em>为<em class="ml">利率</em>，<em class="ml"> t </em>为时间步长(年)<em class="ml"> n </em>为每年利息资本化的次数。在我们的例子中，为了简单起见，FV <em class="ml"> ≡ x(t) </em>、PV <em class="ml"> ≡ x₀ </em>和<em class="ml"> n = 1 </em>。</p><p id="8788" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">公式本身可以有两种不同的理解方式。一种方式是理解它作为随后应用某个函数<em class="ml"> f: x → x ⋅ (1 + R) </em>的结果，该函数将输入乘以某个因子<em class="ml"> (1 + R) </em>:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi op"><img src="../Images/efc1a55bea57b5e9ecf1b8876da1bd5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*0WicxgPogOab8El612331w.png"/></div></figure><p id="0bac" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">另一种方法是把它想成下面导数的一个主要函数:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/bcb78dc0748e6f65544542fc62724b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*QLvMbXuM_wn5A65mwdV1yg.png"/></div></figure><p id="c52f" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">上面的等式不是别的，只是一个例子，其中一个函数<strong class="lr jj">与其自身的增长</strong>成比例，我们可以通过重新排列各项并积分来确认这一点:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/b260866e83db835359dac6c2e6ec3994.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*OLy76spDNtM1hesj3Ed6qg.png"/></div></figure><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi os"><img src="../Images/25ab80c607fc8375898e818a1329858e.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*e3uAb8A7PCHgrqcUAXINZg.png"/></div></figure><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi os"><img src="../Images/8a8aea973a73419d8137d5f0024ca9aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*BkLNf_d-V5Qy8i8C0XKm6A.png"/></div></figure><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/fca783abb9746f9768efab1ff5cd06a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*6ORYvbwvPPaY-lvsr8MgQw.png"/></div></figure><h1 id="ef2f" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">包括对模型的投资</h1><p id="87da" class="pw-post-body-paragraph lp lq ji lr b ls lt kj lu lv lw km lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这就是有趣的地方。在实践中，我们更感兴趣的是为投资持续提供资金，而不是投资一些 x₀作为一次性机会。此外，要了解整体情况，重要的是我们仍然要考虑本文前面提到的影响因素。</p><p id="30c0" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">由于表达式可能会很快变得错综复杂，导数方法似乎是一种更简单、更优雅的表述问题的方式。我们要做的就是不断增加不同的贡献，然后积分方程。</p><p id="b72d" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">为了更直观，现在让我们定义两个<em class="ml"> x </em>。让<em class="ml"> x₁ </em>做原钱包，而<em class="ml"> x₂ </em>做投资桶。换句话说，你可以将<em class="ml"> x₁ </em>视为你的主要银行账户，在那里你领取工资、支付账单和纳税，但现在你也可以选择将剩余的部分<em class="ml"> β ∈ [0，1] </em>转移到<em class="ml"> x₂ </em>。然后，你用这些钱购买股票、债券、商品、房地产等。无论你做什么，你都在继续<strong class="lr jj">(再)投资</strong><em class="ml"/>x₂，假设一些预期利率<em class="ml"> R </em>并倍增你的钱。</p><p id="2d90" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">在这种情况下，初始方程变成两个<em class="ml">耦合的常微分方程</em>的系统:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/7467e75d3aad28c3245f7cd5fdaff0ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*deTR-bkw8mGeikhVqjhq9g.png"/></div></figure><p id="ca8d" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">为了说明新的情况，让我们更新代码:</p><pre class="nj nk nl nm gt oe mu of og aw oh bi"><span id="97b3" class="mw ky ji mu b gy oi oj l ok ol">class Life:<br/>    def __init__(self):<br/>        ...  # as before<br/>        self.investment_fraction = 0.75  # beta<br/>        self.interest_rate = 5  # 5%<br/><br/>    ...  # as before<br/><br/><br/>def live_with_investing(x, t, you):<br/>    balance = you.earn(t) - you.spend(t) - you.pay_taxes(t)<br/>    if t &lt; self.retirement_age:<br/>        x1 = balance * (1 - you.investment_fraction)<br/>        x2 = np.log(1 + 0.01 * you.interest_rate) * x[1] \<br/>           + balance * you.investment_fraction<br/>    else:<br/>        x1 = balance<br/>        x2 = 0<br/>    return [x1, x2]</span></pre><p id="7b2e" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">这个实现与我们刚刚讨论的方程组有一点不同。在这里，为了清楚起见，我们假设你退休的决定相当于从<em class="ml"> x₂ </em>取出你所有的钱，并把它提供给<em class="ml"> x₁ </em>。换句话说，在我们的模拟中，我们想要检查你可以用所有积累和产生的资本支持自己多久。</p><p id="bf1f" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">因此，<code class="fe mr ms mt mu b">simulate</code>函数也得到更新:</p><pre class="nj nk nl nm gt oe mu of og aw oh bi"><span id="1243" class="mw ky ji mu b gy oi oj l ok ol">def simulate(you):<br/>    ...  # t0, t1, t2 - as before<br/><br/>    # non-investor<br/>    x1_0 = np.zeros((t0.shape[0], 1))<br/>    x1_1 = odeint(live_without_investing, 0, t1, args=(you,))<br/>    x1_2 = odeint(live_without_investing, x1_1[-1], t2, args=(you,))<br/><br/>    # investor<br/>    x2_0 = np.zeros((t0.shape[0], 2))<br/>    x2_1 = odeint(live_with_investing, [0, 0], t1, args=(you,))<br/>    x2_2 = odeint(live_with_investing, [x2_1[-1].sum(), 0], t2, args=(you,))<br/><br/>    df0 = pd.DataFrame({'time': t0, 'wallet (non-investor)': x1_0[:, 0], 'wallet (investor)': x2_0[:, 0], 'investment bucket (investor)': x2_0[:, 1]})<br/>    df1 = pd.DataFrame({'time': t1, 'wallet (non-investor)': x1_1[:, 0], 'wallet (investor)': x2_1[:, 0], 'investment bucket (investor)': x2_1[:, 1]})<br/>    df2 = pd.DataFrame({'time': t2, 'wallet (non-investor)': x1_2[:, 0], 'wallet (investor)': x2_2[:, 0], 'investment bucket (investor)': x2_2[:, 1]})<br/>    return pd.concat([df0, df1, df2])</span></pre><p id="1596" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">观察第 12 行。这就是我们为第三个积分<em class="ml"> x₁(t₂) + x₂(t₂) → x₁(t₂) </em>设置新的初始条件的地方。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/780f32bf122606dfd34bcbb6300a8828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rVsyCnTUObgJMOE6.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图 3。“投资分数= 0.8”和“利率= 3.3%”的示例。观察一下，即使利率如此之低，你也能为自己争取近十年的时间，或者相反，你的提前退休变得更容易实现。</p></figure><h1 id="8cde" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">通货膨胀——你的敌人</h1><p id="ef73" class="pw-post-body-paragraph lp lq ji lr b ls lt kj lu lv lw km lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我们刚刚看到了指数增长的威力。不幸的是，不管你是否选择投资，有一个因素几乎肯定存在，它也具有指数性质，但对你不利。这是<strong class="lr jj">通货膨胀</strong>。</p><p id="f504" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">简单来说，通货膨胀不是物价的整体上涨，而是货币随着时间的推移而贬值。比方说，50%的通货膨胀率将导致同样的钞票只有其早期购买力的 2/3。因此，为了在我们的模型中考虑通货膨胀，而不是保持货币的名义价值，而是以某种方式想象价格上涨，我们宁愿将 is 建模为负利率——一种吞噬你的钱的复利。</p><p id="d01c" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">利用我们以前的知识，并把通货膨胀率表示为ξ，我们只需要稍微修改一下方程组:</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/82f859ece9c4a22112a7d1894d0b63b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*WZMTC29n6Dlm98WVEm6rcw.png"/></div></figure><p id="be8a" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">现在，注意乘以<em class="ml"> x₂ </em>的项。利用对数的性质，我们可以只用一个常数来表示这两个值，</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/fea6fa02f7c619f91f6f7ca74c7154e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*5FWjzst8waNTTWnypp8AMA.png"/></div></figure><p id="12fe" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">现在很容易发现，只有当我们战胜通货膨胀时，我们才能从投资中获利。自然，对于“钱包”，我们的数字永远是<em class="ml"> λ &lt; 0 </em>，因为没有<em class="ml"> R </em>来“拉起来”。这又是一个原因，为什么“努力工作，努力储蓄”是一个完全没有希望的想法。</p><p id="bba4" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">“代码方式”:</p><pre class="nj nk nl nm gt oe mu of og aw oh bi"><span id="d509" class="mw ky ji mu b gy oi oj l ok ol">def live_without_investing(x, t, you):<br/>    balance = you.earn(t) - you.spend(t) - you.pay_taxes(t)<br/>    return balance - np.log(1 + 0.01*you.inflation_proc) * x<br/><br/><br/>def live_with_investing(x, t, you):<br/>    balance = you.earn(t) - you.spend(t) - you.pay_taxes(t)<br/>    if t &lt; you.retirement_age:<br/>        x1 = balance * (1 - you.investment_fraction)<br/>        x2 = np.log(1 + 0.01*you.interest_rate_proc) * x[1] \<br/>           + you.investment_fraction * balance<br/>        <br/>        x1 -= np.log(1 + 0.01*you.inflation_proc) * x[0]<br/>        x2 -= x2 - np.log(1 + 0.01*you.inflation_proc) * x[1]<br/>    else:<br/>        x0 = balance<br/>        x1 -= np.log(1 + 0.01*you.inflation_proc) * x[0]<br/>        x2 = 0<br/>    return [x0, x1]</span></pre><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/ad8879401f7e26e3f285ccc423ba075f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fc5Qndi4CQI7EqmT.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图 4。前面的例子中，“通货膨胀率”设置为 3.0%，而“利率”设置为 3.3%。</p></figure><h1 id="54ce" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">结论</h1><p id="3972" class="pw-post-body-paragraph lp lq ji lr b ls lt kj lu lv lw km lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">在本文中，我们展示了如何使用常微分方程对财务状况建模，以及如何使用 python 将它们转化为模拟器。</p><p id="d3da" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">这里讨论的案例没有考虑很多因素。一些因素，如你所在国家的税法，突然的遗产继承，或者由于意外的金融危机导致的通货膨胀，无疑增加了复杂性。此外，我们在这里没有提到贷款或债务，尽管使用刚才介绍的方法，我们确信您能够将它们包含在您的模型中——而这正是本文的目标。</p><p id="01e4" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">最后，关键在于，特别是对于那些对编码不感兴趣的人，记住那些增长与其价值成正比的函数正是你想要使用并为你所用的机器。</p><p id="bd06" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">也可以在 Google Colab: <a class="ae mv" href="https://github.com/OlegZero13/Data-Science-Algorithm-Gallery/blob/master/Personal_Financial_Simulator_with_ODE.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到可以运行的笔记本。您可以随意克隆它、修改它，并随意使用它。让我知道你的想法。</p><h1 id="48e0" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">还会有更多…</h1><p id="f1b4" class="pw-post-body-paragraph lp lq ji lr b ls lt kj lu lv lw km lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我计划把文章带到下一个层次，并提供简短的视频教程。</p><p id="b613" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated">如果您想了解关于视频和未来文章的更新，<strong class="lr jj">订阅我的</strong> <a class="ae mv" href="https://landing.mailerlite.com/webforms/landing/j5y2q1" rel="noopener ugc nofollow" target="_blank"> <strong class="lr jj">简讯</strong> </a> <strong class="lr jj">。你也可以通过填写<a class="ae mv" href="https://forms.gle/bNpf9aqZJGLgaU589" rel="noopener ugc nofollow" target="_blank">表格</a>让我知道你的期望。回头见！</strong></p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><p id="da6d" class="pw-post-body-paragraph lp lq ji lr b ls mm kj lu lv mn km lx ly mo ma mb mc mp me mf mg mq mi mj mk im bi translated"><em class="ml">原载于</em><a class="ae mv" href="https://zerowithdot.com/financial-independence-ode-python/" rel="noopener ugc nofollow" target="_blank"><em class="ml">https://zerowithdot.com</em></a><em class="ml">。</em></p></div></div>    
</body>
</html>