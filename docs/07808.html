<html>
<head>
<title>Understanding Generator Expressions In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Python中的生成器表达式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-generator-expressions-in-python-fe0c4534619?source=collection_archive---------31-----------------------#2020-06-10">https://towardsdatascience.com/understanding-generator-expressions-in-python-fe0c4534619?source=collection_archive---------31-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="986a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">技术的</h2><div class=""/><div class=""><h2 id="57b8" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过利用一个优雅且内存高效的解决方案在python中生成序列类型，提高您的python编程语言技能。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f5b883e33e7a9d0ae84861770929c2ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Y_uEBu4KwkPlI6-GVrbJA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">制造者在<a class="ae lh" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae lh" href="https://unsplash.com/@nesabymakers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> NESA的照片</a></p></figure><h1 id="4d40" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">介绍</h1><p id="a488" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">本文是对Python编程语言中的<a class="ae lh" href="https://www.python.org/dev/peps/pep-0289/" rel="noopener ugc nofollow" target="_blank">生成器表达式(gene XP)</a>的介绍。</p><p id="0e3b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">本文面向所有级别的开发人员。如果你是初学者，你可以学习一些新概念，比如生成器表达式、列表理解(listcomps)和序列类型生成。中级开发人员可以学习一两件关于可伸缩性和内存效率的事情，或者只是将本文作为复习。</p><p id="e8bf" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在本文中，您会发现以下内容:</p><ul class=""><li id="58a3" class="nb nc it mc b md mw mg mx mj nd mn ne mr nf mv ng nh ni nj bi translated"><strong class="mc jd">生成器表达式描述</strong></li><li id="c359" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated"><strong class="mc jd">如何利用生成器表达式(代码)</strong></li><li id="fac8" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated"><strong class="mc jd">生成器表达式相对于其他类似解决方案的优势</strong></li><li id="cc67" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated"><strong class="mc jd">gene XP和listcomps的内存和时间测量</strong></li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="02ec" class="li lj it bd lk ll nw ln lo lp nx lr ls ki ny kj lu kl nz km lw ko oa kp ly lz bi translated">生成器表达式</h1><blockquote class="ob oc od"><p id="bec8" class="ma mb oe mc b md mw kd mf mg mx kg mi of my ml mm og mz mp mq oh na mt mu mv im bi translated">enexps是在python中生成序列类型(如数组、元组、集合)的优雅且节省内存的解决方案。</p></blockquote><p id="968a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">生成器表达式类似于<a class="ae lh" rel="noopener" target="_blank" href="/basics-of-list-comprehensions-in-python-e8b75da50b30">list comprehensions(list comps)</a>——在python中构造列表序列类型的另一种方法。Genexps和listcomps在实现方式上有相似之处。</p><p id="65af" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">下面的短代码片段描述了它们的语法相似性:</p><p id="671d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在下面的代码中，生成器表达式用于计算按整数递增的一系列值的总和。</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="3c05" class="on lj it oj b gy oo op l oq or">#Generator Expression<br/>accumulated_gexp = sum((1 + x for x in range(2000000)))<br/>print(accumulated_gexp)<br/>&gt;&gt; 2000001000000</span><span id="65d5" class="on lj it oj b gy os op l oq or">#List Comprehension<br/>accumulated_listcomp = sum([1 + x for x in range(2000000)])<br/>print(accumulated_listcomp)<br/>&gt;&gt;2000001000000</span></pre><p id="0704" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">虽然很微妙，但上面的genexp和listcomp示例之间的主要区别是genexp以方括号开始和结束，而listcomp以方括号开始和结束——更好的术语应该是'<em class="oe">括号</em>'。</p><p id="9e54" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">下面是另一个使用生成器表达式创建元组的例子。</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="4f79" class="on lj it oj b gy oo op l oq or">beginning_topic = ['Machine', 'Deep', 'Reinforcement']<br/>ending_topic = 'Learning'</span><span id="f5e3" class="on lj it oj b gy os op l oq or">tuple(print(beginning + " " + ending_topic) for beginning in beginning_topic)</span><span id="7608" class="on lj it oj b gy os op l oq or">&gt;&gt; Machine Learning<br/>&gt;&gt; Deep Learning<br/>&gt;&gt; Reinforcement Learning</span></pre></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="47c5" class="li lj it bd lk ll nw ln lo lp nx lr ls ki ny kj lu kl nz km lw ko oa kp ly lz bi translated">优势:内存效率</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/e679db099bc8756ac95e0a6e09269885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPhrodAAPnTBhjVyURsb4g.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@franckinjapan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Franck V. </a>在<a class="ae lh" href="https://unsplash.com/s/photos/compute-memory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4a97" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">与listcomps相比，生成表达式更节省内存。Genexps内存效率是利用python迭代器协议“<em class="oe">产生</em>或返回迭代器中的项目的结果。相比之下，列表理解为生成的列表及其内容利用内存。</p><p id="013b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">一个生成器只会在需要的时候产生迭代器中的条目，因此给了genexps内存高效的特性。</p><p id="4a77" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果上面写的还不够清楚，下面的代码片段会让它更加清楚。下面的代码片段显示了genexps和listcomps示例的内存大小要求(以字节为单位)。</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="2ae2" class="on lj it oj b gy oo op l oq or">from sys import getsizeof</span><span id="d7bd" class="on lj it oj b gy os op l oq or">accumulated_gexp = (1 + x for x in range(2000000))print(type(accumulated_gexp))<br/>print(getsizeof(accumulated_gexp))<br/>&gt;&gt; &lt;class 'generator'&gt;<br/>&gt;&gt; 112</span><span id="8caa" class="on lj it oj b gy os op l oq or">accumulated_listcomp = [1 + x for x in range(2000000)]<br/>print(type(accumulated_listcomp))<br/>print(getsizeof(accumulated_listcomp))<br/>&gt;&gt; &lt;class 'list'&gt;<br/>&gt;&gt; 17632624</span></pre><p id="5893" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在上面的代码片段中，我们可以观察到list comprehension使用了17632624字节；而生成器表达式只使用了少得可怜的112字节内存。</p><p id="05f6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">还可以通过使用迭代器的next函数来访问序列的内容，用于生成器表达式和列表索引来理解列表。</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="260b" class="on lj it oj b gy oo op l oq or">print(next(accumulated_gexp))<br/>&gt;&gt; 1</span><span id="e703" class="on lj it oj b gy os op l oq or">print(accumulated_listcomp[0])<br/>&gt;&gt; 1</span></pre></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="3c01" class="li lj it bd lk ll nw ln lo lp nx lr ls ki ny kj lu kl nz km lw ko oa kp ly lz bi translated">优势:时间效率</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/84b150e2826bc6ebaf0e80ea6e34419d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffIRhYEsKPDpMcmqQBXK4w.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@gaellemarcel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">盖尔·马塞尔</a>在<a class="ae lh" href="https://unsplash.com/s/photos/time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3878" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">与列表理解相比，生成器表达式的另一个优点是它们的时间效率特性。</p><p id="1fba" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">对于许多开发人员来说，尤其是初学者，您更熟悉并接触到列表理解的使用。</p><p id="8aee" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">但是在大多数情况下，使用生成器表达式的好处不是那么容易被忽略的，尤其是当程序执行的速度非常重要的时候。</p><p id="ab68" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在实际场景中，当你在一个序列上迭代一次时，你很可能会更好地利用genexps。为了更大的灵活性和序列的多次迭代，您可能会使用listcomps。</p><p id="9f5a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">下面的代码片段演示了listcomps和genexps之间的执行时间差异。</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="7d7c" class="on lj it oj b gy oo op l oq or">import timeit</span><span id="b9d3" class="on lj it oj b gy os op l oq or">generator_exp_time = timeit.timeit('''accumulated_gexp = (1 + x for x in range(200))''', number=1000000)<br/>print(generator_exp_time)<br/>&gt;&gt; 1.5132575110037578</span><span id="8f9d" class="on lj it oj b gy os op l oq or">list_comp_time = timeit.timeit('''accumulated_listcomp = [1 + x for x in range(200)]''', number=1000000)<br/>print(list_comp_time)<br/>&gt;&gt; 29.604462443996454</span></pre><p id="8981" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">使用<a class="ae lh" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank"> timeit </a> python模块，我们可以测量代码行的执行时间，如上所示。</p><p id="257b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">正如我们所观察到的，生成器表达式用时不到两秒(generator_exp_time: 1.51…)，而列表理解执行时间几乎多了20倍。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="2079" class="li lj it bd lk ll nw ln lo lp nx lr ls ki ny kj lu kl nz km lw ko oa kp ly lz bi translated">优势</h1><p id="5cba" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">下面总结了python中生成表达式的优点:</p><ul class=""><li id="f99f" class="nb nc it mc b md mw mg mx mj nd mn ne mr nf mv ng nh ni nj bi translated">python中生成序列类型的高效内存方法。</li><li id="a7bc" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">为编写的代码增加了进一步的简洁性和可读性。生成器表达式被<a class="ae lh" href="https://wiki.python.org/moin/Generators" rel="noopener ugc nofollow" target="_blank">生成器函数</a>缩短。</li><li id="209e" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">与列表比较相比，时间效率高。</li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="643f" class="li lj it bd lk ll nw ln lo lp nx lr ls ki ny kj lu kl nz km lw ko oa kp ly lz bi translated">结论</h1><p id="2b96" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">生成器表达式一点也不复杂，它们使得python编写的代码高效且可伸缩。</p><p id="224c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">对于初学者来说，学习何时使用列表理解和生成器表达式是在职业生涯早期掌握的一个极好的概念。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="7b8c" class="li lj it bd lk ll nw ln lo lp nx lr ls ki ny kj lu kl nz km lw ko oa kp ly lz bi translated">我希望这篇文章对你有用。</h1><p id="1d2f" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">要联系我或找到更多类似本文的内容，请执行以下操作:</p><ol class=""><li id="ee50" class="nb nc it mc b md mw mg mx mj nd mn ne mr nf mv ov nh ni nj bi translated">订阅我的<a class="ae lh" href="https://www.youtube.com/channel/UCNNYpuGCrihz_YsEpZjo8TA" rel="noopener ugc nofollow" target="_blank"> <strong class="mc jd"> YouTube频道</strong> </a>即将上线的视频内容<a class="ae lh" href="https://www.youtube.com/channel/UCNNYpuGCrihz_YsEpZjo8TA" rel="noopener ugc nofollow" target="_blank"> <strong class="mc jd">这里</strong> </a></li><li id="7a70" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ov nh ni nj bi translated">跟我上<a class="ae lh" href="https://medium.com/@richmond.alake" rel="noopener"> <strong class="mc jd">中</strong> </a></li><li id="a1d1" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ov nh ni nj bi translated">通过<a class="ae lh" href="https://www.linkedin.com/in/richmondalake/" rel="noopener ugc nofollow" target="_blank"> <strong class="mc jd"> LinkedIn </strong> </a>联系我</li></ol></div></div>    
</body>
</html>