<html>
<head>
<title>8 Python Iteration Skills That Data Scientists Shouldn’t Miss Out</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家不应错过的 8 个 Python 迭代技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/8-python-iteration-skills-that-data-scientists-shouldnt-miss-out-6b57fb35e00f?source=collection_archive---------19-----------------------#2020-08-25">https://towardsdatascience.com/8-python-iteration-skills-that-data-scientists-shouldnt-miss-out-6b57fb35e00f?source=collection_archive---------19-----------------------#2020-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e39c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您想知道的常见有用迭代技巧的回顾</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8854e3b9b1cc2e07918a396ef8eeefbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fcH_vVJOZRFXIBmn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@vladshap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗拉德·沙波奇尼科夫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="18ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的程序做的一个主要的自动操作是为我们重复特定的任务。这通常使用 for 循环来实现，其最基本的形式如下:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6298" class="ma mb it lw b gy mc md l me mf">for item in iterable:<br/>    # Your tasks go here</span></pre><p id="6491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论上，我们可以利用基本形式来解决所有与迭代相关的需求，但是在许多情况下，如果我们利用 Python 提供的现有功能，我们的代码会变得更加简洁。在本文中，我想回顾一下我们在进行数据科学项目时应该考虑的 8 种有用的技术。</p><p id="acc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明这些技术的有用性，我将它们与只使用最基本形式的代码进行对比。从这些比较中，您可以看到代码可读性的显著提高。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="0426" class="ma mb it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">1.使用 enumerate()跟踪迭代</h2><p id="e099" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">假设我们需要跟踪迭代的计数。换句话说，我们想知道我们已经迭代了多少次循环。在这种情况下，我们应该考虑<code class="fe nj nk nl lw b">enumerate()</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用枚举()</p></figure><ul class=""><li id="9c46" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">要获得序列中项目的索引，基本方法包括创建一个<em class="nx"> range </em>对象，因为典型方法(即<code class="fe nj nk nl lw b">for item in iterable</code>)没有与索引相关的信息。尽管我们可以使用带有列表的<code class="fe nj nk nl lw b">index()</code>方法来查找索引，但默认情况下，它会返回第一个找到的元素的索引。因此，当有重复的项目时，它会给出非预期的信息。</li><li id="f7a9" class="no np it lb b lc ny lf nz li oa lm ob lq oc lu nt nu nv nw bi translated"><code class="fe nj nk nl lw b">enumerate()</code>函数创建一个<em class="nx">枚举</em>对象作为迭代器。它可以带一个可选参数<code class="fe nj nk nl lw b">start</code>，指定计数器的开始。默认情况下，它从 0 开始计数。在我们的例子中，我们从 1 开始计算第一个渲染元素。如你所见，<code class="fe nj nk nl lw b">enumerate()</code>函数直接给出了计数器和元素。</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="8c9d" class="ma mb it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">2.将 Iterables 与 zip()配对</h2><p id="aa3c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当我们有几个可重复项，并且需要从这些可重复项的相同位置检索项目时，我们应该考虑<code class="fe nj nk nl lw b">zip()</code>函数，如本例所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 zip()</p></figure><ul class=""><li id="8afe" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">为了获得相同索引处的元素，我们使用<code class="fe nj nk nl lw b">range()</code>函数创建索引，就像我们在上一节中所做的那样。使用索引从每个 iterable 中检索元素有点乏味。</li><li id="626d" class="no np it lb b lc ny lf nz li oa lm ob lq oc lu nt nu nv nw bi translated"><code class="fe nj nk nl lw b">zip()</code>函数可以连接多个 iterable，并且在每个循环中，它产生一个 tuple 对象，该对象包含来自相同索引处的每个 iterable 的元素。我们可以解包元组对象来非常方便地检索元素。代码看起来干净多了，不是吗？</li><li id="53ab" class="no np it lb b lc ny lf nz li oa lm ob lq oc lu nt nu nv nw bi translated">另一件需要注意的事情是，<code class="fe nj nk nl lw b">zip()</code>函数将压缩匹配其中最短可迭代对象的可迭代对象。如果你想让压缩匹配最长的可重复项，你应该使用<em class="nx"> itertools </em>库中的<code class="fe nj nk nl lw b">zip_longest()</code>函数。</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="0615" class="ma mb it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">3.使用 reversed()进行反向迭代</h2><p id="5051" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当需要以逆序迭代一系列元素时，最好使用<code class="fe nj nk nl lw b">reversed()</code>函数。假设学生在稍微不同的时间到达教室，您想使用相反的顺序检查他们的作业，即第一个到达的学生最后被检查。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用反转()</p></figure><ul class=""><li id="4c32" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">如果您坚持使用<code class="fe nj nk nl lw b">range()</code>函数，您将使用序列的反向索引。换句话说，我们用-1 来表示列表的最后一项，依此类推。</li><li id="5354" class="no np it lb b lc ny lf nz li oa lm ob lq oc lu nt nu nv nw bi translated">或者，我们可以使用<code class="fe nj nk nl lw b">[::-1]</code>反转列表，然后迭代新创建的列表对象。</li><li id="e94c" class="no np it lb b lc ny lf nz li oa lm ob lq oc lu nt nu nv nw bi translated">最好的方法就是简单地使用<code class="fe nj nk nl lw b">reversed()</code>函数。这是一个非常灵活的函数，因为它可以接受其他序列数据，如元组和字符串。</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="7b78" class="ma mb it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">4.带过滤器的过滤器元件()</h2><p id="5511" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">您不需要总是使用 iterable 中的所有项目。在这些情况下，我们通常可以在应用所需的操作之前检查项目是否满足特定的标准。这样的条件评估和所需迭代器的创建可以很容易地集成到一个函数调用中— <code class="fe nj nk nl lw b"> filter()</code>。让我们来看看它是如何与典型的方式进行比较的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用过滤器()</p></figure><ul class=""><li id="bad9" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">典型的方法包括评估每个元素。</li><li id="bcca" class="no np it lb b lc ny lf nz li oa lm ob lq oc lu nt nu nv nw bi translated"><code class="fe nj nk nl lw b">filter()</code>函数将计算元素，同时将元素呈现为迭代器。换句话说，该函数返回一个迭代器，这样就可以在 for 循环中使用它。</li><li id="8aff" class="no np it lb b lc ny lf nz li oa lm ob lq oc lu nt nu nv nw bi translated">根据您的需要，您可以考虑其他过滤函数，例如 itertools 库中的<code class="fe nj nk nl lw b">filterfalse()</code>，它执行相反的操作(即保留那些评估<code class="fe nj nk nl lw b">False</code>的函数)。</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="7113" class="ma mb it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">5.Chain Iterables 与 Chain()</h2><p id="c608" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在上一节中，我们已经讨论了如何使用<code class="fe nj nk nl lw b">zip()</code>函数处理多个可重复项，对于这一点，您可以认为我们在垂直方向上连接了可重复项。如果想首尾相连，应该使用 itertools 库中的<code class="fe nj nk nl lw b">chain()</code>函数。具体来说，假设您有多个可迭代对象，您想要依次迭代它们中的每一个，这是<code class="fe nj nk nl lw b">chain()</code>函数的最佳用例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用链条()</p></figure><ul class=""><li id="ef31" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">典型的方法是手动连接 iterables，比如使用一个中间列表。如果你使用其他的可重复项，比如字典和集合，你需要知道如何连接它们。</li><li id="cae6" class="no np it lb b lc ny lf nz li oa lm ob lq oc lu nt nu nv nw bi translated"><code class="fe nj nk nl lw b">chain()</code>函数可以链接任意数量的可迭代对象，并生成另一个迭代器，从每个可迭代对象中顺序产生元素。您不需要管理保存这些元素的另一个临时对象。</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="34f9" class="ma mb it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">6.迭代字典</h2><p id="6626" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">字典是一种非常常见的数据类型，它以键值对的形式存储数据。因为使用散列实现，所以从字典中查找和检索条目非常快，因此它们是许多开发人员最喜欢的数据结构。键值对的存储为我们迭代字典提供了不同的选择。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迭代字典</p></figure><ul class=""><li id="8eb6" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">要迭代这些键，我们只需在 dictionary 对象上使用<code class="fe nj nk nl lw b">keys()</code>方法。或者，我们可以只使用 dictionary 对象本身作为 iterable，这只是由<code class="fe nj nk nl lw b">keys()</code>方法创建的 view 对象的语法糖。</li><li id="f2f8" class="no np it lb b lc ny lf nz li oa lm ob lq oc lu nt nu nv nw bi translated">为了迭代这些值，我们将只使用<code class="fe nj nk nl lw b">values()</code>方法。</li><li id="4792" class="no np it lb b lc ny lf nz li oa lm ob lq oc lu nt nu nv nw bi translated">为了以键值对的形式迭代条目，我们将使用<code class="fe nj nk nl lw b">items()</code>方法。</li><li id="5c59" class="no np it lb b lc ny lf nz li oa lm ob lq oc lu nt nu nv nw bi translated">值得注意的是，这些方法创建的对象是字典视图对象，这与 SQL 视图非常相似。换句话说，当<em class="nx"> dict </em>对象被更新时，这些视图对象也会被更新，下面显示了一个简单的例子。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">字典视图对象</p></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="608c" class="ma mb it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">7.将理解视为选择</h2><p id="5c0b" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">如果迭代的目的是从 iterable 中创建一个新的<em class="nx"> list </em>、<em class="nx"> dictionary </em>或<em class="nx"> set </em> object，我们应该考虑理解技术，它更具性能，也更简洁。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">（听力或阅读）理解测试</p></figure><ul class=""><li id="b513" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">列表理解具有以下格式:<code class="fe nj nk nl lw b">[expr for item in iterable]</code>，与 for 循环相比，这是创建<em class="nx">列表</em>对象的首选方式。</li><li id="851c" class="no np it lb b lc ny lf nz li oa lm ob lq oc lu nt nu nv nw bi translated">字典理解有以下格式:<code class="fe nj nk nl lw b">{key_expr: value_expr for item in iterable}</code>。类似地，这是从可迭代对象创建一个<em class="nx">字典</em>对象的首选方式。</li><li id="0205" class="no np it lb b lc ny lf nz li oa lm ob lq oc lu nt nu nv nw bi translated">集合理解具有以下格式:<code class="fe nj nk nl lw b">{expr for item in iterable}</code>，这是从 iterable 创建集合对象的首选方式，与 for 循环相比。</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="1014" class="ma mb it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">8.考虑 else 子句</h2><p id="b2e3" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">最后但同样重要的是，要考虑在 for 循环中使用<em class="nx"> else </em>子句。应该注意的是，这并不是最直观的技术，因为许多人甚至不知道 for 循环中的<em class="nx"> else </em>子句的存在。下面的案例向您展示了一个微不足道的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">For 循环中的 Else 子句</p></figure><p id="7cd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与一些人的错误想法不同，在常规情况下，<em class="nx"> else </em>子句中的代码将遵循 for 循环运行。但是，如果执行中遇到任何<code class="fe nj nk nl lw b">break</code>语句，将会跳过<em class="nx"> else </em>子句中的代码。如第一个函数调用所示，没有执行<em class="nx"> else </em>子句。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="fa8d" class="ma mb it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">结论</h2><p id="5851" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在本文中，我们回顾了除了 for 循环的基本形式之外，我们可以考虑在 for 循环中使用的八种技术。应用这些技术可以让你的代码更加简洁，性能更好。</p><p id="586a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇文章。</p></div></div>    
</body>
</html>