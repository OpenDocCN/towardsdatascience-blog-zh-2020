<html>
<head>
<title>Raster Data Scatter Plot Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 绘制栅格数据散点图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/raster-data-scatter-plot-using-python-4bcdc8286769?source=collection_archive---------17-----------------------#2020-07-11">https://towardsdatascience.com/raster-data-scatter-plot-using-python-4bcdc8286769?source=collection_archive---------17-----------------------#2020-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="401d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">地理信息系统</h2><div class=""/><div class=""><h2 id="71f7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在某些情况下，您可能需要查看两个栅格数据集之间的关系。在 GUI 应用程序中这样做可能会令人恼火，因为存在滞后、不一致等问题。处理大分辨率栅格时甚至更糟。使用 Python 编写脚本可能是一种替代解决方案，可以为您提供可靠、快速、自动化和一致的结果。本文将指导您使用基本和流行的 Python 库来显示两个栅格数据集的散点图。</h2></div><h1 id="aee9" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">介绍</h1><p id="6264" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">栅格数据基本上是一种图像或矩阵。作为图像或矩阵，它由数组组成，可以形成数据框或电子表格。甚至可以在 Adobe Photoshop 或者<a class="ae mf" href="https://excelcharts.com/" rel="noopener ugc nofollow" target="_blank"> Ms. Excel </a>中可视化光栅数据！每个栅格像元包含一个数值，该数值可以表示任何内容，具体取决于上下文。该值可以是高程、土地覆盖指数、NDVI(归一化植被指数)，具体取决于具体环境。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/480920813f78878e0a880157e3b77776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZbQvU9J2LEHm3YjATn48Fw.jpeg"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">栅格数据(来源:作者，2020 年)</p></figure><p id="a926" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">在某些情况下，我们可能想要查看栅格之间的关系。比如坡度对绿化有影响吗？NDVI 和 NDBI 是什么关系？与交通设施的距离是否与二氧化氮或其他污染气体相关？</p><p id="0780" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">虽然一些软件提供了显示两个栅格数据之间散点图的方法，但我总是觉得这很令人恼火。显示绘图需要大量的 ram 和 CPU 资源，因此经常会导致延迟。窗格需要时间来加载，更改内容或绘图属性也需要时间来加载。此外，有时，我们需要自动化我们的工作，而不必做繁琐的任务，如布局和美化我们的图表一次又一次。当我们处理需要更多 RAM 或 CPU 的高分辨率栅格时，情况会变得更糟！</p><p id="9deb" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">幸运的是，Python 有一种方法来完成这样的任务，而不必做那些繁琐的事情。使用 Python，在显示散点图时也可以减少对 RAM 和 CPU 容量的需求，因为不需要 GUI，并且可以最小化显示。<strong class="ll jd"> </strong>我想分享这个过程，因此，<strong class="ll jd">本文的主要目的是向您展示如何预处理栅格数据</strong>(使用 GIS) <strong class="ll jd">并使用 Python 将它们显示在散点图中。</strong></p><h1 id="e16e" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">逻辑过程</h1><p id="94a3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">散点图需要 2 个输入，并且<strong class="ll jd">两个输入都需要是一维的。</strong>栅格数据，就其本质而言，是二维数据，所以我们需要将数据重塑为一维。这种整形是通过拆纱完成<a class="ae mf" href="https://www.w3resource.com/numpy/manipulation/ravel.php" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="bd77" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">在拆纱之前，在我们开始拆纱过程之前，必须满足一些标准。必须确保栅格的每个像元在空间上对齐。这确保了一维松散的数据是合乎逻辑的，并且类似于对应关系。如果两个栅格数据之间存在空间不匹配，则生成的散点图将绘制错误的绘图。此外，关于标准将在<strong class="ll jd">数据标准</strong>部分中解释。</p><p id="e26b" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">总之，raveling 产生一个长度为列乘以行的一维数组。确保两个栅格数据具有相同的列和行意味着确保行进数据的长度精确。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/8ef2146a4571ac4dbf217cc7668b8539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6L49J3nTo5QU3S-0ruWfA.jpeg"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">栅格数据散点图的思维过程(来源:作者，2020)</p></figure><h1 id="a47d" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">先验知识和要求</h1><p id="6c41" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果你想继续，建议你理解</p><ul class=""><li id="0ceb" class="nb nc it ll b lm mw lp mx ls nd lw ne ma nf me ng nh ni nj bi translated"><strong class="ll jd">GIS 分析的基础</strong>，做一些栅格掩蔽/提取</li><li id="aa95" class="nb nc it ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><strong class="ll jd">地理空间数据类型</strong>(栅格数据)，了解栅格数据的属性</li><li id="82d3" class="nb nc it ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><strong class="ll jd">投影系统</strong>，转换栅格数据的空间度量。</li><li id="49aa" class="nb nc it ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><strong class="ll jd"> Python </strong>。库:<strong class="ll jd"> NumPy </strong>(处理数组)<strong class="ll jd"> matplotlib </strong>(绘图和数据可视化)，图像分析(使用<strong class="ll jd"> PIL(枕头)</strong>)。嗯，我们只需要图像分析部分来读取光栅数据并将其转换为 NumPy 数组，因此只要您可以读取图像光栅数据，它就会进行检查。我推荐 PIL，因为 OpenCV 或 Matplotlib Imread 不能直接完成这项工作，因为我们将处理单波段图像。</li></ul><h1 id="7138" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">数据标准</h1><p id="4ade" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果我们要将两个栅格绘制成散点图，则必须满足一些标准:</p><ul class=""><li id="9356" class="nb nc it ll b lm mw lp mx ls nd lw ne ma nf me ng nh ni nj bi translated"><strong class="ll jd">这两个栅格必须具有相同的维度。</strong>这意味着两个栅格必须具有相同数量的<strong class="ll jd">列和行，以及相同的像素大小</strong>。这个标准很重要，因为阵列之间的对应关系必须一致，这样每个单元都有一个到另一个单元的连接。绘图时，对于一个 X 输入会返回一个 Y 值，在只有 1 个 X 输入的情况下，如果返回 2 个 Y 值，会比较混乱；函数不是这样工作的，散点图就是一个函数。</li><li id="4e4a" class="nb nc it ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><strong class="ll jd">这两个栅格必须在空间上对齐并重叠。</strong>一个<strong class="ll jd"> </strong>散点图并不表示空间对齐和重叠，因此这一标准必须使用 GIS 进行独立评估。</li><li id="eae9" class="nb nc it ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><strong class="ll jd">这两个栅格必须具有相同的坐标参考。我不认为这很关键，只要列数和行数相同。应该首先满足这个标准，因为我们必须匹配像素大小和空间相邻性。</strong></li><li id="187a" class="nb nc it ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><strong class="ll jd">如果一个栅格中的像元为空值，则另一个栅格的对应像元应改为空值。</strong>还是那句话，标绘这样的数据不符合逻辑。例如，一个 X 输入返回一个空值…我们应该如何绘制？Null 不是 0，所以最好直接删除这个值。</li></ul><h1 id="b1a5" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">利用地理信息系统进行数据预处理:符合标准</h1><p id="dde2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果您的栅格数据不符合标准(通常不符合)，则必须进行一些地理空间预处理。我将解释如何使用 ArcGIS 工具集，对于其他软件，如 QGis，甚至是 Python 包，如 RasterIO 或 Geopandas，应该有等效的工具。请原谅我…</p><p id="9d57" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated"><strong class="ll jd">假设我们有 2 个栅格:X 轴栅格和 Y 轴栅格。这两个栅格彼此重叠</strong>，我们想要概述这种关系。<strong class="ll jd"> </strong>我们可以把 x 轴栅格想象成 NDVI 栅格，把 Y 轴栅格想象成高程数据 aster。由于来源和采集方法不同，这两种栅格具有不同的属性。因此，需要进行一些预处理。</p><h2 id="c912" class="np ks it bd kt nq nr dn kx ns nt dp lb ls nu nv ld lw nw nx lf ma ny nz lh iz bi translated"><strong class="ak">预处理步骤 1/3:决定一个光栅数据参考(例如 X 轴光栅)</strong></h2><p id="eaf3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">选择一个参考栅格。我更喜欢最低比例的栅格(最低分辨率；最小数量的列和行)。您可以在 GIS 软件中查看属性，并找到栅格的列、行和像素大小。在本例中，我的栅格参考(我将其命名为 X 轴栅格)有 203 列、210 列和 158(米)像素大小。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oa"><img src="../Images/8c7ec1d0ea848c543847c34dce38a750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjPUGI_7Mdsjd82ZoBd1SA.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">x 轴栅格属性(来源:作者)</p></figure><h2 id="ee13" class="np ks it bd kt nq nr dn kx ns nt dp lb ls nu nv ld lw nw nx lf ma ny nz lh iz bi translated"><strong class="ak">预处理步骤 2/3Y 轴光栅概述</strong></h2><p id="a6c9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">例如，Y 轴栅格具有不同的属性，如下图所示。我们必须对此 Y 轴栅格进行更改，使其具有与 X 轴栅格参考相同的属性。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oa"><img src="../Images/5f5c52b8b85ac3ee9ed8d25c7a2c5420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCPY1sp_p3Me4TyTS3ZSdg.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">预处理前的 y 轴(来源:作者)</p></figure><h2 id="3cff" class="np ks it bd kt nq nr dn kx ns nt dp lb ls nu nv ld lw nw nx lf ma ny nz lh iz bi translated"><strong class="ak">预处理步骤 3/3:使用 GIS 对 Y 轴和 X 轴栅格进行空间处理</strong></h2><p id="99f8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">有 3 个主要过程。</p><ul class=""><li id="5dbe" class="nb nc it ll b lm mw lp mx ls nd lw ne ma nf me ng nh ni nj bi translated"><a class="ae mf" href="https://pro.arcgis.com/en/PRO-APP/TOOL-REFERENCE/DATA-MANAGEMENT/project.htm" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">将</strong></a><strong class="ll jd">Y 轴光栅投影到与 X 轴光栅相同的坐标系中。</strong>如果 Y 轴光栅具有相同的坐标参考，则不需要该步骤。<strong class="ll jd"> </strong>这保证了像素大小有相同的单位。在这种情况下，我的 Y 轴栅格具有非常小的像元大小，这是因为 Y 轴具有不同的投影参考。</li><li id="59dc" class="nb nc it ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><a class="ae mf" href="https://pro.arcgis.com/en/pro-app/tool-reference/data-management/resample.htm" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">重采样</strong> </a> <strong class="ll jd">投影后的 Y 轴:</strong>投影后，Y 轴光栅的像元大小应该与 X 轴光栅具有相同的度量，但它们可能大小不同。重采样聚合或插值 Y 轴值以调整 Y 轴分辨率，使其与 X 轴分辨率相同。所以…将 Y 轴栅格重采样到 X 轴栅格的分辨率。</li><li id="0ffa" class="nb nc it ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><strong class="ll jd">双重</strong> <a class="ae mf" href="https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/extract-by-mask.htm" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">通过相互屏蔽</strong> </a> <strong class="ll jd">提取栅格:</strong>双重屏蔽确保消除与非空值重叠的空值。所以，首先用 X 轴屏蔽 Y 轴(返回屏蔽的 Y 轴)，然后用屏蔽的 Y 轴提取 X 轴。<strong class="ll jd">现在您应该有 2 个符合条件的预处理栅格了！屏蔽的 Y 轴栅格和屏蔽的 X 轴栅格。</strong></li><li id="9802" class="nb nc it ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated">最后，<strong class="ll jd">将这些栅格导出为 TIFF 格式</strong>，32 位浮点像素类型，无数据值为-10(或任何其他数字！你必须注意这个没有数据值！)</li></ul><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/0e8b745aef61d529775840271c820f30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*NxVpsadeG910eWo4GFSSMA.png"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">导出栅格(来源:作者)</p></figure><h1 id="1a12" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">使用 Python 散点图绘制栅格</h1><p id="5fd1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，资料都准备好了，该做饭了。步骤真的很简单！</p><ul class=""><li id="db0e" class="nb nc it ll b lm mw lp mx ls nd lw ne ma nf me ng nh ni nj bi translated"><strong class="ll jd">定义拆纱功能。</strong>读取光栅、清理光栅和移动光栅。函数声明缩短了脚本。</li><li id="7cf7" class="nb nc it ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><a class="ae mf" href="https://www.w3resource.com/w3r_images/numpy-manipulation-ravel-function-image-1.png" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">将</strong> </a> <strong class="ll jd">每个光栅数据分解成一维数组</strong>(使用分解功能)</li><li id="9972" class="nb nc it ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated">绘制每个散开的栅格！</li></ul><p id="bff4" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">我们将需要这些库:</p><ul class=""><li id="efb8" class="nb nc it ll b lm mw lp mx ls nd lw ne ma nf me ng nh ni nj bi translated">Numpy 负责整理和管理数组</li><li id="3ebc" class="nb nc it ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><a class="ae mf" href="https://pypi.org/project/Pillow/2.2.1/" rel="noopener ugc nofollow" target="_blank">枕</a>读取光栅</li><li id="1e8b" class="nb nc it ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><a class="ae mf" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>可视化散点图</li></ul><h2 id="7d6f" class="np ks it bd kt nq nr dn kx ns nt dp lb ls nu nv ld lw nw nx lf ma ny nz lh iz bi translated">绘图，步骤 1/3:定义松散函数</h2><p id="4b60" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">正如我在逻辑部分解释的，我们必须遍历每个栅格。我们将使用下面的<strong class="ll jd"> fetch_data </strong>函数遍历栅格。<strong class="ll jd"> fetch_data </strong>函数读取并清理光栅数据。清理很重要，因为 TIF 图像包含应该为空的值，但还不为空。清理会将这些值转换为空值，以便以后删除。<strong class="ll jd"> fetch_data </strong>返回松散的、干净的、准备绘制的光栅。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="38fc" class="np ks it bd kt nq nr dn kx ns nt dp lb ls nu nv ld lw nw nx lf ma ny nz lh iz bi translated">绘图，步骤 2/3:分析数据</h2><p id="4e34" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">定义函数后，我们使用 fetch_data 函数移动 X 轴栅格和 Y 轴栅格。现在我们有了 x_data 和 y_data。</p><pre class="mh mi mj mk gt oe of og oh aw oi bi"><span id="4950" class="np ks it of b gy oj ok l ol om">#path to each raster data<br/>x_data_path = "folder/x_raster.tif"<br/>y_data_path = "folder/y_raster.tif"</span><span id="aedf" class="np ks it of b gy on ok l ol om">#raveling the data<br/>y_data = fetch_data(y_data_path)<br/>X_data = fetch_data(x_data_path)</span></pre><h2 id="6474" class="np ks it bd kt nq nr dn kx ns nt dp lb ls nu nv ld lw nw nx lf ma ny nz lh iz bi translated">绘制，步骤 3/3:绘制数据</h2><p id="00df" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这部分只是 matplotlib 可视化基础。您可以使用简单的分散代码，如下所示。</p><pre class="mh mi mj mk gt oe of og oh aw oi bi"><span id="3742" class="np ks it of b gy oj ok l ol om">import matplotlib.pyplot as plt<br/>plt.rcParams["font.family"] = "Times New Roman"</span><span id="5dcb" class="np ks it of b gy on ok l ol om">#Declaring the figure, and hiding the ticks' labels<br/>fig, ax = plt.subplots(figsize=(15,8))<br/>ax.set_yticklabels([])<br/>ax.set_xticklabels([])</span><span id="30db" class="np ks it of b gy on ok l ol om">#Actually Plotting the data<br/>plt.scatter(x_data,y_data, s=0.1, c='black')</span><span id="4482" class="np ks it of b gy on ok l ol om">#Making the graph pretty and informative!<br/>plt.title("Raster Data Scatter Plot", fontsize=28)<br/>plt.xlabel("X-Axis Raster", fontsize=22)<br/>plt.ylabel("Y-Axis Raster", fontsize=22)<br/>plt.show()</span></pre><h1 id="229a" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">结果呢</h1><p id="a9d2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">使用上面的代码，我们应该有这个绘图结果。你有它！两个栅格的散点图！</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oo"><img src="../Images/34636941569ed12233b26c9fc113700a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7hA-Qoz-1udxiNTB9TAlsw.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">绘制栅格(来源:作者，2020 年)</p></figure></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><h1 id="ffe3" class="kr ks it bd kt ku ow kw kx ky ox la lb ki oy kj ld kl oz km lf ko pa kp lh li bi translated">结束语</h1><p id="6c3f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">绘图过程相当直接，但使用 GIS 的预处理是棘手的。在这种情况下，GIS 预处理需要人工监督，因此您必须充分了解并小心谨慎。</p><p id="6f22" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">仅当栅格输入在空间上对齐时，松散才有效。这种空间排列可能是应该彻底检查的最重要的方面。这一步至关重要，因为只要维度相同，对数据进行分析和绘图总是会产生散点图。这种虚幻的散点图会产生误导，因为它没有任何空间对齐的指示，但本质上，它显示的是空间未对齐的信息。</p><p id="b677" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated">例如，从技术上讲，34x78 维 10m 分辨率栅格可以用 78x34 维 10m 分辨率栅格进行绘制。拆开时，它们产生相同的一维长度，34x78=2652。您也可以从技术上绘制这些栅格，但它们没有任何意义。如果两个栅格不重叠，情况会更糟。</p><p id="0b66" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls my lu lv lw mz ly lz ma na mc md me im bi translated"><strong class="ll jd">因此，请始终仔细检查栅格数据是否在相同的维度上，并且在空间上对齐。祝你好运！</strong></p></div></div>    
</body>
</html>