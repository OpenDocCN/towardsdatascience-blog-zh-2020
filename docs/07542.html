<html>
<head>
<title>How to Find Closed and Maximal Frequent Itemsets from FP-Growth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从FP-Growth中发现闭和最大频繁项集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-find-closed-and-maximal-frequent-itemsets-from-fp-growth-861a1ef13e21?source=collection_archive---------11-----------------------#2020-06-07">https://towardsdatascience.com/how-to-find-closed-and-maximal-frequent-itemsets-from-fp-growth-861a1ef13e21?source=collection_archive---------11-----------------------#2020-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7fd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python优化寻找闭和最大频繁项集</p><p id="690d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上一篇文章中，我已经详细讨论了什么是FP-growth，以及它是如何发现频繁项集的。此外，我从头开始演示了python实现。在这篇文章中，我将介绍关联规则挖掘中的两个重要概念，闭项集和最大频繁项集。为了理解这个概念，你需要对什么是FPtree和什么是频繁项集有一些基本的了解。我的上一篇文章涵盖了所有的基础知识。</p><p id="43ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" rel="noopener" target="_blank" href="/understand-and-build-fp-growth-algorithm-in-python-d8b989bab342">理解并构建Python中的FP-Growth算法</a></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/88ccac696578966f62d610f77addfd9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CcPj5heh3PqByRhc"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">由<a class="ae ko" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="94c2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是闭频繁项集和最大频繁项集</h1><p id="362b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这里我们快速回顾一下频繁项集的概念。项目集的支持度大于或等于minsup(最小支持度)阈值。支持度是项目集出现的频率。例如，给定一组事务T，我们希望找到在所有事务中出现2次以上的所有项集。这可以看作是寻找所有minsup ≥2的频繁项集。</p><p id="799e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">那么什么是闭和最大频繁项集呢？</strong></p><p id="c587" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据定义，如果一个项目集的直接超集都不是频繁的，那么这个项目集就是最大频繁项目集。如果一个项集的直接超集都不具有与该项集相同的支持度，则该项集是封闭的。让我们用一个例子和图表来更好地理解这个概念。</p><p id="190a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们有5个事务的事务T，让我们用一个树形图表示所有的项集层次结构，并用红色写下项集出现在顶部的事务。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mi"><img src="../Images/a63363fc16891440bbc07bb316b4c76a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWWhF_ipw6CD8EuByWCbtQ.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">示例演示。</p></figure><p id="9f87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们将minsup设置为2，那么任何出现两次以上的项集都将是频繁项集。在这些频繁项集中，我们可以通过比较它们的支持度(出现频率)和它们的超集来发现闭的和最大的频繁项集。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mj"><img src="../Images/ebea578401540e794d2814390fc23585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXKwhN32RuLoNsnPXz3TlQ.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">突出显示所有封闭和最大频繁项目集</p></figure><p id="075f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到最大项集是闭项集的子集。同样，最大项目集作为一个边界，任何低于最大项目集的都不是频繁项目集(任何最大项目集的超集都不是频繁的)。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mk"><img src="../Images/7fc22bb2cf0ce8dffea66ee76aea2c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbsXcmecUU_SfE4td248sQ.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">频繁、闭和最大项目集之间的关系</p></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="88d0" class="lf lg it bd lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly mw ma mb mc bi translated">Python实现</h1><p id="185a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">有许多不同的方法试图有效地找到最大和最接近的频繁项目集。这仍然是数据挖掘领域的一个热门研究问题。有兴趣的话可以找很多不同算法的研究文章来解决这个问题。我将演示一种相对简单的方法，通过比较每个项目的支持度和它们的超集来发现基于频繁项目集的闭和最大频繁项目集。然而，考虑到O(n)的运行时间复杂度，这种方法可能相当耗时。为了在处理大型数据库时优化算法，我们需要利用python字典。通过将具有相同支持计数的所有项目集存储到一个字典中，使用支持作为关键字，我们可以将复杂度降低到O(n)。因为我们不需要比较每一项，因为所有超集都有来自其父代的≤支持。并且我们在寻找封闭项集时只需要比较具有相同支持计数的项。同样的事情也适用于寻找最大项目集。</p><p id="b471" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了实现，我首先使用MLXtend库和fpgrowth函数来计算频繁项集，并编写自己的函数来从第一步的结果中挖掘封闭和最大频繁项集。</p><pre class="kq kr ks kt gt mx my mz na aw nb bi"><span id="a877" class="nc lg it my b gy nd ne l nf ng">#Import all basic libray<br/>import pandas as pd<br/>from mlxtend.preprocessing import TransactionEncoder<br/>import time<br/>from mlxtend.frequent_patterns import fpgrowth</span><span id="11e4" class="nc lg it my b gy nh ne l nf ng">#Task1 : Compute Frequent Item Set using  mlxtend.frequent_patterns<br/>te = TransactionEncoder()<br/>te_ary = te.fit(dataset).transform(dataset)<br/>df = pd.DataFrame(te_ary, columns=te.columns_)</span><span id="2285" class="nc lg it my b gy nh ne l nf ng">start_time = time.time()<br/>frequent = fpgrowth(df, min_support=0.001, use_colnames=True)<br/>print('Time to find frequent itemset')<br/>print("--- %s seconds ---" % (time.time() - start_time))</span><span id="7545" class="nc lg it my b gy nh ne l nf ng"># Task 2&amp;3: Find closed/max frequent itemset using frequent itemset found in task1</span><span id="d979" class="nc lg it my b gy nh ne l nf ng">su = frequent.support.unique()#all unique support count</span><span id="f1e1" class="nc lg it my b gy nh ne l nf ng">#Dictionay storing itemset with same support count key<br/>fredic = {}<br/>for i in range(len(su)):<br/>    inset = list(frequent.loc[frequent.support ==su[i]]['itemsets'])<br/>    fredic[su[i]] = inset</span><span id="59ca" class="nc lg it my b gy nh ne l nf ng">#Dictionay storing itemset with  support count &lt;= key<br/>fredic2 = {}<br/>for i in range(len(su)):<br/>    inset2 = list(frequent.loc[frequent.support&lt;=su[i]]['itemsets'])<br/>    fredic2[su[i]] = inset2</span><span id="eac2" class="nc lg it my b gy nh ne l nf ng">#Find Closed frequent itemset<br/>start_time = time.time()</span><span id="1708" class="nc lg it my b gy nh ne l nf ng">cl = []<br/>for index, row in frequent.iterrows():<br/>    isclose = True<br/>    cli = row['itemsets']<br/>    cls = row['support']<br/>    checkset = fredic[cls]<br/>    for i in checkset:<br/>        if (cli!=i):<br/>            if(frozenset.issubset(cli,i)):<br/>                isclose = False<br/>                break<br/>    <br/>    if(isclose):<br/>        cl.append(row['itemsets'])</span><span id="09d1" class="nc lg it my b gy nh ne l nf ng">print('Time to find Close frequent itemset')<br/>print("--- %s seconds ---" % (time.time() - start_time))  <br/>    <br/>#Find Max frequent itemset<br/>start_time = time.time()</span><span id="8090" class="nc lg it my b gy nh ne l nf ng">ml = []<br/>for index, row in frequent.iterrows():<br/>    isclose = True<br/>    cli = row['itemsets']<br/>    cls = row['support']<br/>    checkset = fredic2[cls]<br/>    for i in checkset:<br/>        if (cli!=i):<br/>            if(frozenset.issubset(cli,i)):<br/>                isclose = False<br/>                break<br/>    <br/>    if(isclose):<br/>        ml.append(row['itemsets'])</span><span id="70a6" class="nc lg it my b gy nh ne l nf ng">print('Time to find Max frequent itemset')<br/>print("--- %s seconds ---" % (time.time() - start_time))</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="ebe5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您的阅读，我期待听到您的问题和想法。如果你想了解更多关于数据科学和云计算的知识，可以在 <a class="ae ko" href="https://www.linkedin.com/in/andrewngai9255/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Linkedin </strong> </a> <strong class="js iu">上找我。</strong></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ni"><img src="../Images/9de52c4fe6ce5a05cb22f4a65fc36924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v_FIIWAETSWkrU2q"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">照片由<a class="ae ko" href="https://unsplash.com/@alfonsmc10?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿尔方斯·莫拉莱斯</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="560b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nj">参考文献</em></p><p id="ba76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="http://rasbt.github.io/mlxtend/user_guide/frequent_patterns/fpgrowth/" rel="noopener ugc nofollow" target="_blank"><em class="nj">http://rasbt . github . io/mlx tend/user _ guide/frequent _ patterns/FP growth/</em></a></p></div></div>    
</body>
</html>