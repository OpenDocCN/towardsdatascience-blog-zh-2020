<html>
<head>
<title>Asyncio Is Not Parallelism</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不对称不是平行</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/asyncio-is-not-parallelism-70bfed470489?source=collection_archive---------14-----------------------#2020-06-13">https://towardsdatascience.com/asyncio-is-not-parallelism-70bfed470489?source=collection_archive---------14-----------------------#2020-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de3b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你可能听说过 Python <a class="ae ki" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> asyncio </a>是并发的，但不是并行编程。但是怎么做呢？我用简单的例子解释一下。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/27c745ad63e6ca0e9bea7514142282af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*PPIp7twJJUknfohZqtL8pQ.png"/></div></figure><p id="1c7c" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们从一个完美的并发例子#1 开始。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="5d7e" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">异步函数 say_after 是 Python 官方文档中的一个例子。它在休眠“延迟”秒后打印出“什么”。</p><p id="ffe4" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在 main 函数中，我们创建了 say_after 的两个任务，一个在 1 秒后说‘hello’，另一个在 2 秒后说‘world’。运行它，我们看到它总共用了 2 秒钟，因为两个任务同时运行。完美！</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/73e0e2b0238ba613e68706267851eaeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*mfP6X8BJfvrpg_Bb4EoGdg.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">主功能没有延迟</p></figure><p id="de24" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但是它们平行吗？让我们用更多的例子来理解并发性和并行性之间的区别。</p><p id="8c11" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">示例 2:</p><p id="5bd3" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将主函数替换如下。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="55af" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如您所见，我们在创建任务后添加了一个 print 来检查任务是否在创建后立即启动，并在 main 函数中添加了一个 0.5 秒后的异步 sleep。注意 main 本身就是一个任务(<a class="ae ki" href="https://docs.python.org/3/library/asyncio-task.html#coroutine" rel="noopener ugc nofollow" target="_blank">协程</a>确切地说)。</p><p id="8e3c" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">以下是输出:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/053182f99c287e5180422448bd1b6c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*SEMFb1PFlqiKoMhCvXv4Og.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">主模式下异步睡眠 0.5s</p></figure><p id="e3ca" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">第一，总共还是 2 秒，没有变化。它同时运行主任务和另外两个 say_after 任务。主服务器中的异步睡眠没有阻塞。</p><p id="0f3a" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">第二，“延迟前—创建任务后”在开始 say_after 任务前打印。是啊！创建的任务在创建后并不立即开始，而是由<strong class="kt iu">安排</strong>在所谓的<a class="ae ki" href="https://docs.python.org/3/library/asyncio-eventloop.html" rel="noopener ugc nofollow" target="_blank">事件循环</a>中运行。它们仅在主任务等待时启动，即本例中的<code class="fe lv lw lx ly b">await asyncio.sleep(0.5)</code>。根据我的理解，你不能控制任务的执行顺序，即优先级。</p><p id="4c7e" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例 3:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ln lo l"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">主模式下阻止睡眠 0.5</p></figure><p id="938c" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这个例子中，我们用 time.sleep 替换了 asyncio.sleep，time . sleep 等待 main 中的阻塞，并查看 say_after 任务何时开始。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/d61eb787c54dbf63864974c775c2f28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*V3qbQjcGS2NCMV1Fm9u4dQ.png"/></div></figure><p id="f485" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">看到总数现在是 2.5 秒。task1 在创建后 0.5 秒开始。很明显，任务不是并行的，即同时执行。</p><p id="11fc" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">实施例 4:</p><p id="7f55" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">你可能会争论应该用 asyncio.sleep 代替 time.sleep 用 asyncio 编程。主要任务正在做某事并导致延迟，这是怎么回事？</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ln lo l"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">干线环路延迟 1 秒</p></figure><p id="5149" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这个例子中，我们用一个循环替换 time.sleep，在主任务中增加大约 1 秒的延迟。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/6b3eb89028a00f15f5cdda60a544f379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*wCCgUBvml77EgXUvJzYO7g.png"/></div></figure><p id="8565" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">你可以看到我们得到了相似的结果。say_after 任务延迟开始，总时间变为 3 秒。</p><p id="2fa8" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例 5:</p><p id="de8c" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果一项任务开始了，它能保证在预期的时间内结束吗？不要！<br/>下面我们来看看这个例子。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ln lo l"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">time.sleep 主模式 3s</p></figure><p id="8d79" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们在第 7 行中使用 asyncio.sleep(0.1)来允许 task1 和 task2 启动，但是在第 8 行中添加 time.sleep(3)来阻止 3 秒钟。<br/>以下是输出:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/bd5a8750b9ddb1a4fac02fa48b936cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*hzKe4XO-wvhs6OAwM6uF6w.png"/></div></figure><p id="518b" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您可以在第 3 行和第 4 行看到两个任务都立即开始，但不是在预期的 1 秒或 2 秒后“说”，而是在 3 秒后“说”(结束)。</p><p id="bdaf" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">原因是当 say_after 等待 1 / 2 秒时，事件循环返回到主任务并在那里阻塞 3 秒钟，然后才能返回到 say_after 任务继续。</p><p id="4679" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">你可以在这里找到完整的演示文件<a class="ae ki" href="https://gist.github.com/b201298268727826d39db2710e8d2e5e" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="109e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="71f4" class="pw-post-body-paragraph kr ks it kt b ku mu ju kw kx mv jx kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">Asynicio 尽最大努力做到并发，但它不是并行的。</p><p id="1e0e" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您无法控制任务的开始和结束。</p><p id="cff7" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果您在任务创建后立即等待任务，您可以控制启动，如下所示，但是它变成了同步编程，这对于异步目的没有意义。请注意，即使这不是 100%的保证，并认为自己。</p><pre class="kk kl km kn gt mz ly na nb aw nc bi"><span id="2fd9" class="nd md it ly b gy ne nf l ng nh">task1 = asyncio.create_task(say_after(1, ‘hello’))<br/>await task1</span></pre><p id="b2e5" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因此，如果你正在开发一个对时间敏感的应用程序，避免使用 asyncio(广义上的协程事件循环)。这种限制的原因是事件循环只使用一个线程来调度多个任务。</p><h1 id="a715" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">供选择的</h1><p id="3232" class="pw-post-body-paragraph kr ks it kt b ku mu ju kw kx mv jx kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">那么并行的解决方案是什么呢？<a class="ae ki" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank">穿线</a>。</p><p id="3bec" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这是示例 5 的等效代码，它在主函数中有 3 秒钟的睡眠阻塞。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="7e5a" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">输出如下所示。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/0e133f796e4672da1786ab51a6706765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*zQEUcp3NrMWp_ckrfH4t9g.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">3 秒延迟的线程输出</p></figure><p id="3c5a" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">看到 task1 和 task2 都立即开始，并在预期的 1 秒和 2 秒内结束。</p><p id="e31a" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您也可以使用<a class="ae ki" href="https://docs.python.org/3.7/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">多处理</a>来利用多个 CPU 内核。</p><p id="5428" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，我并不是说您不应该使用事件循环，它在处理网络流量时非常有用。但这取决于你的需要。</p><p id="c9f6" class="pw-post-body-paragraph kr ks it kt b ku kv ju kw kx ky jx kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae ki" href="https://www.linkedin.com/in/xiejiping/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a></p></div></div>    
</body>
</html>