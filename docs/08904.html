<html>
<head>
<title>PyTorch Tidbits: Measuring Streams and Times</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTorch 花絮:测量溪流和时间</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pytorch-tidbits-measuring-streams-and-times-de0c7bae85da?source=collection_archive---------45-----------------------#2020-06-26">https://towardsdatascience.com/pytorch-tidbits-measuring-streams-and-times-de0c7bae85da?source=collection_archive---------45-----------------------#2020-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="13ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">统计数据收集的简单实用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/47a9a30aeee692437ef64a2621482c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ncFDBgF0B1OlmqFtdFnmZg.png"/></div></figure><p id="81a8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">典型的 PyTorch 训练循环包含跟踪训练和测试指标的代码；他们帮助我们监控进度并绘制学习曲线。</p><p id="6668" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">假设对于一个分类任务，我们使用二元交叉熵作为训练损失，我们也对准确性感兴趣。在每一个时期之后，我们在一个持续的验证数据集上测量相同的值。我们希望将定期进度信息写入控制台以及 Tensorboard(或任何其他您喜欢的仪表板工具)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="0c5d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">请注意记录大量连续值，然后对其进行统计的模式。虽然这个片段足够简单，但是有一些重复，并且日志开始模糊主要的算法核心。我们想要跟踪的度量和统计数据(比如，除了平均值之外的标准偏差)就越多。</p><p id="b676" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这已经在<a class="ae lo" href="https://github.com/pytorch/examples/blob/master/imagenet/main.py#L359" rel="noopener ugc nofollow" target="_blank"> ImageNet 演示代码</a>中得到认可，它包含了一个用于此目的的辅助类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="715b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用起来非常简单:我们创建一个<code class="fe lp lq lr ls b">AverageMeter</code>实例<code class="fe lp lq lr ls b">m</code>，反复调用<code class="fe lp lq lr ls b">m.update(loss)</code>，并在一个时期结束时检索平均值为<code class="fe lp lq lr ls b">m.avg</code>。</p><p id="f650" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">诚然，这是一个相当谦虚的班级；然而，在用 Python 编写机器学习应用程序时，像这样跟踪统计数据是普遍存在的。因此，仔细研究一下这个概念可能是值得的，因为它有助于多种扩展。</p><h2 id="9fb7" class="lt lu it bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated">聚合函数</h2><p id="76fb" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">您肯定已经注意到，在第一个清单中，存储每个损失值有点天真；相反，我们只需要递增地更新元素的总数和数量。大多数数据处理语言，如<em class="mr"> SQL </em>或<em class="mr"> PigLatin </em>通常称之为<a class="ae lo" href="https://en.wikipedia.org/wiki/Aggregate_function" rel="noopener ugc nofollow" target="_blank">可分解聚合函数</a>；它只记录恒定数量的足够的统计数据，并以交换和关联的方式更新。常见的聚合函数有最小值、最大值和标准差(为此我们需要平方和)。很容易得出其他有用的度量:最近的值、零或非常小的值的百分比、绝对最小值和最大值。我们的更新功能变成了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="0ebc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">平均值和标准偏差可通过以下简单属性提取:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="cf47" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果我们不局限于恒定的空间和时间要求，我们当然可以实现更复杂的聚合函数，或者作为精确的或者许多已知的近似算法<a class="ae lo" href="https://en.wikipedia.org/wiki/Streaming_algorithm" rel="noopener ugc nofollow" target="_blank">之一</a>，用于 k-最频繁、k-最小和唯一的元素。</p><h2 id="618b" class="lt lu it bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated">句法糖</h2><p id="8881" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">作为一种快捷方式，增量添加操作符<code class="fe lp lq lr ls b">+=</code>可以作为 update 的别名。添加意味着更新副本。标准的<code class="fe lp lq lr ls b">__len__</code>函数默认为计数。以字典的形式检索值并拥有合适的字符串表示很方便。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><h2 id="77a7" class="lt lu it bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated">与其他电表、NumPy 阵列和 PyTorch 张量聚合</h2><p id="49b5" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">两个<code class="fe lp lq lr ls b">Meters</code>可以在两个并发线程中聚合指标，我们希望将它们汇总在一起。更新功能的扩展很简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="59f0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">到目前为止，我们假设我们的值是本地 Python 数字。但是有时我们想要查看 PyTorch <code class="fe lp lq lr ls b">Tensors</code>上的统计数据(比如模型激活、权重和它们的梯度)。我们将用数组更新<code class="fe lp lq lr ls b">Meter</code>的语义定义为用每个单独的元素更新它。</p><p id="ec9a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">回想一下，PyTorch <code class="fe lp lq lr ls b">Tensors</code>可以通过共享底层内存转换成<em class="mr"/>NumPy<code class="fe lp lq lr ls b">ndarrays</code>；所以当我们两个都想要的时候，一个可以简化为另一个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="76ea" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们希望为用户提供一个<code class="fe lp lq lr ls b">update</code>函数，而不必记住选择<code class="fe lp lq lr ls b">update_scalar,</code> <code class="fe lp lq lr ls b">update_tensor,</code>或<code class="fe lp lq lr ls b">update_meter. </code>不幸的是，与 C++等强类型语言不同，Python 不允许参数重载，但我们可以将通用功能移到抽象基类并创建一个分派:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="0d78" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">仪表词典</strong></p><p id="0ec3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当跟踪多个指标时，可以通过使用字典来简化代码，字典的键和值分别是指标的名称和聚合器。聚合两个<code class="fe lp lq lr ls b">MeterDicts</code>或一个<code class="fe lp lq lr ls b">MeterDict</code>和一个<code class="fe lp lq lr ls b">Meter</code>的操作非常简单。</p><p id="19a3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我们作为软件工程师成长时，对全局变量的恐惧已经被灌输到我们的头脑中。但有时这让我们忘记了全局变量在少数情况下确实是有用的；它们可以让我们避免在函数中传递相同或不重要的参数，或者避免重复拼写长的类引用链。Python 中现有的例子有日志和随机数生成器。在训练循环的实现中，我们开始使用我们的<code class="fe lp lq lr ls b">Engine</code>类的成员变量来跟踪统计数据，但是结果证明这太麻烦了——例如，<em class="mr"> </em> PyTorch <code class="fe lp lq lr ls b">DataLoader</code>中的工作线程不能直接访问引擎，那么我们如何才能轻松地共享度量呢？我们认为，共享一个单一的、全局的<code class="fe lp lq lr ls b">MeterDict</code>对于跨应用程序的度量跟踪是有用的。</p><h2 id="43d8" class="lt lu it bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated"><strong class="ak">格式化</strong></h2><p id="20a7" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">对于人类可读的输出，数字应该总是被适当地格式化，例如，通过舍入到有效数字。此外，日志文件可以包含大量输出；我们可以使用 grep 之类的工具搜索我们感兴趣的东西，但对于这项工作来说，使用统一的格式并将相关信息放在同一行也很有帮助。我们定义一个 formatter 类，它注册一个或几个仪表，其字符串表示是所需的日志记录输出。</p><p id="5217" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">将所有内容放在一起，我们最初的、简单的训练循环现在可以写成如下形式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="707f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">定时</strong></p><p id="db88" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">出于诊断和监控目的，默认情况下，将执行时间记录到 Tensorboard 是很有用的。通常，这样的度量是在多次调用中平均的，这意味着使用一个<code class="fe lp lq lr ls b">Meter</code>进行聚合。查看挂钟时间和 CPU 时间可能会有所帮助，因此我们的计时函数将同时提供这两种时间(通过后缀来区分)。有时我们想对代码段计时，这需要一个上下文管理器(类<code class="fe lp lq lr ls b">Timing</code>)；对于完整的函数调用，我们更喜欢装饰器，<code class="fe lp lq lr ls b">@timed</code>。所有这些函数都允许一个可选的<code class="fe lp lq lr ls b">MeterDict</code>参数，但是它们默认为全局的<code class="fe lp lq lr ls b">MeterDict</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><h2 id="a316" class="lt lu it bd lv lw lx dn ly lz ma dp mb kz mc md me ld mf mg mh lh mi mj mk ml bi translated"><strong class="ak">代码</strong></h2><p id="1cec" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">本文的完整代码可在<a class="ae lo" href="https://github.com/stefan-schroedl/pymeter" rel="noopener ugc nofollow" target="_blank">这里</a>获得；我希望它对你的下一个 python ML 项目有用！</p></div></div>    
</body>
</html>