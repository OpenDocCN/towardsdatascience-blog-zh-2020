<html>
<head>
<title>Adding Julia’s Polymorphic Dispatch To My Plotting Library (Part 4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Julia的多态分派添加到我的绘图库中(第4部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/adding-julias-polymorphic-dispatch-to-my-plotting-library-part-4-1446e924774f?source=collection_archive---------62-----------------------#2020-04-27">https://towardsdatascience.com/adding-julias-polymorphic-dispatch-to-my-plotting-library-part-4-1446e924774f?source=collection_archive---------62-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b3ad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">方法论之争！</h2></div><blockquote class="ki kj kk"><p id="8c1f" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">第一部分</p><p id="540d" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><a class="ae li" rel="noopener" target="_blank" href="/metaprogramming-a-graph-class-in-julia-90a90e8ab45b">第二部</a></p><p id="0f7b" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><a class="ae li" rel="noopener" target="_blank" href="/introducing-hone-a-modular-object-oriented-graphing-library-for-julia-823b028b462a">第三部</a></p></blockquote><blockquote class="lj"><p id="bfb7" class="lk ll it bd lm ln lo lp lq lr ls lh dk translated"><a class="ae li" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Adding%20polymorphism%20to%20Hone.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><p id="9815" class="pw-post-body-paragraph kl km it ko b kp lt ju kr ks lu jx ku lv lw kx ky lx ly lb lc lz ma lf lg lh im bi mb translated">在之前的文章中，我创建了一个坐标解析器和一个功能上面向对象的(我意识到这听起来有多疯狂)系统，用于将元数据从对象传输到最终的对象，看起来有点像这样:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mk"><img src="../Images/f6da3e3e67ee75a6ca0863942c78a60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjrGAzS6AHYcqBoQbivnpg.png"/></div></div></figure><p id="dc2e" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">从那时起，我只改变了模块整体的一个方面。该模块现在导出函数，而不是包含来自其他模块的函数。因此，现在使用模块的方式与在笔记本中使用代码的方式相同，例如:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mw"><img src="../Images/13316fcc3eec11a6a8f2a2ea86e8dbd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djDPcRXEJXTpyMvc17ok4g.png"/></div></div></figure><p id="11b7" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">相对于:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/19ed0fc009c4d1ab78f4a9c0a26cc773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*_LHtT3665I0hQAg_cm1MkQ.png"/></div></figure><p id="faaf" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">但做完这些出口后，一个想法闪过我的脑海。显然我们可以画出一个X和一个Y，但是对比数据呢？毕竟，大多数情况下，您需要散点图来比较多个X的一些数据，而不仅仅是可视化单个X的位置。为了改变这一点，我计划利用DataFrames，因为Lathe已经作为一个依赖项添加到Project.toml而且Lathe有DataFrames.jl作为依赖项，这意味着任何使用Hone的人很可能已经在他们的计算机上安装了DataFrames。</p><p id="3f15" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">有两种主要的方法可以解决这个问题。一种方法对最终用户来说不是最佳的，但却容易得多。然而，另一种方法会更困难一点，但从长远来看会使方案更好。我决定选择第一种。</p><blockquote class="lj"><p id="d702" class="lk ll it bd lm ln my mz na nb nc lh dk translated">我开玩笑的…</p></blockquote><p id="357e" class="pw-post-body-paragraph kl km it ko b kp lt ju kr ks lu jx ku lv lw kx ky lx ly lb lc lz ma lf lg lh im bi translated">通常，在类似的编程语言(如R或Python)中，我们必须用条件来检查进入函数的类型，例如:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nd"><img src="../Images/38ca3cdbe32ec935283b179f8e9a2394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYunk98lMUJTh6ptBtUBfQ.png"/></div></div></figure><p id="7dec" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">这没什么大不了的，这让我想起了主循环事件编程，在那里你必须不断地检查标志的条件来执行任何事情，否则，它将在处理器的每个时钟周期执行，这有点滑稽。幸运的是，既然我们是用Julia编程，我们可以做得更好。我们可以通过使用Julia的多重分派来做到这一点，我们可以从编写两个需要处理两种不同类型的函数开始。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/13b860775f923ed4c4360dd46a8ee569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*jDvYsZ-rz9b-NlsTa-XUfw.png"/></div></figure><p id="53f1" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">现在我们只添加这两行简单的代码，将这些方法作为结构的属性来应用:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nf"><img src="../Images/8da409828e0c93e2f2a26055d0645171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RK5Lq7m0arCu5d7CvLGLQ.png"/></div></div></figure><p id="a4e9" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">现在我们用两种类型来称呼它:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a1cd423e55daa79ec7d8595fa5cf18d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*zh5M-AnWdLbAlb_wX29BUQ.png"/></div></figure><blockquote class="lj"><p id="3f0b" class="lk ll it bd lm ln lo lp lq lr ls lh dk translated">这些函数根据类型相应地运行。</p></blockquote><p id="7528" class="pw-post-body-paragraph kl km it ko b kp lt ju kr ks lu jx ku lv lw kx ky lx ly lb lc lz ma lf lg lh im bi translated">我们可以将这个想法应用到Hone中，制作一个新的分散函数来处理数据帧而不是数组。我把我们旧的Scatter函数重命名为_arrayscatter，我们的新函数将是_dfscatter。出于个人偏好，我使用这种带有下划线的命名方案，因为它有助于区分最终用户功能和用户永远看不到的后端功能，尽管这不是必需的，但我认为保持一致很重要。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nh"><img src="../Images/69f29ec5bc0fd7e5038e228e68fcb2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXNCMO2VKiyec1GS8jfhrA.png"/></div></div></figure><p id="8a1a" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">现在我们只需添加我们的调度行:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ni"><img src="../Images/88c066ce79c6f4859e1474100e245417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFmsSwU6JgKEZo1pj9uYIQ.png"/></div></div></figure><p id="15bd" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">注意，我必须首先将DataFrames.jl加载到会话中，才能使用DataFrame类型。另一件要注意的事情是，Y的类型断言是Symbol，而不是您可能期望的Array，这是因为我们假设我们要用作Y的数组在数据帧内部，所以我们可以这样调用它:</p><pre class="ml mm mn mo gt nj nk nl nm aw nn bi"><span id="4e8b" class="no np it nk b gy nq nr l ns nt">x[y]</span></pre><blockquote class="lj"><p id="69df" class="lk ll it bd lm ln lo lp lq lr ls lh dk translated">奇怪的是。</p></blockquote><p id="9a5c" class="pw-post-body-paragraph kl km it ko b kp lt ju kr ks lu jx ku lv lw kx ky lx ly lb lc lz ma lf lg lh im bi translated">现在我们可以构建一个数据框架来证明一切都在正常运行:</p><pre class="ml mm mn mo gt nj nk nl nm aw nn bi"><span id="b3b2" class="no np it nk b gy nq nr l ns nt">df = DataFrame(:one =&gt; [1,5,2,3], :two =&gt; [8,4,5,3], :y =&gt; [5,6,2,3])</span></pre><p id="f1c4" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">当我们通过函数传递它时:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nu"><img src="../Images/3e8f689663474959f45823229fc18276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djddAhWmonIRM2Ml8_ZUPA.png"/></div></div></figure><p id="2e49" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">因此调度是有效的，但是我们仍然需要为数据框函数的绘制添加逻辑。为此，我将首先从常规的scatter函数中提取代码，然后复制坐标解析器，以便它分别解析两个X。我们要寻找的结果应该是散点图上的另外四个点，总共八个点。因此，首先我将向您展示结果，然后深入分析我必须进行的重构:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nv"><img src="../Images/39d333c3d9a82d7931e42451129100a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ODQTq690t0dQulKIvjVrw.png"/></div></div></figure><p id="84ee" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">对于解释，我将逐行进行，因为这里有很多。首先，在获得最大值和最小值的分散函数中；我不得不将X的最大值的计算转移到迭代循环中，因为这一次我们循环通过具有不同最大值的不同数组。然而，我确实保留了Y的原始位置:</p><pre class="ml mm mn mo gt nj nk nl nm aw nn bi"><span id="f343" class="no np it nk b gy nq nr l ns nt">function _dfscatter(x,y,shape,debug=false)<br/>    topy = maximum(x[y])</span></pre><p id="c234" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">接下来，需要移动的循环将原始函数中的所有坐标转换为百分比，并将其放入循环中(应该如此。)</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nw"><img src="../Images/2f641bf76e40d1ecf693f6166db01e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oFWzbHNcDcOWKSazSJxJeQ.png"/></div></div></figure><p id="bd51" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">除此之外，实际的解析被移到遍历列的循环内部。一个很明显的缺陷是，没有办法在坐标平面上区分两个X，</p><blockquote class="lj"><p id="10eb" class="lk ll it bd lm ln my mz na nb nc lh dk translated">所以让我们改变这一点。</p></blockquote><p id="e23b" class="pw-post-body-paragraph kl km it ko b kp lt ju kr ks lu jx ku lv lw kx ky lx ly lb lc lz ma lf lg lh im bi translated">这个过程的第一步是将我们的“shape”参数作为多态分派的类型断言中的一个数组，如下所示:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nx"><img src="../Images/1c3b989ea7beebe8adf4d48d49ee9460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQrdHCbWy1Q468JaEdmnow.png"/></div></div></figure><p id="d5fd" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">现在，我们将简单地在循环中添加一个计数器，从零开始，直到循环完成。这将有助于确定我们在数据框架中的位置，尽管我将来可能会更改这一点，以使用列的索引来代替。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ny"><img src="../Images/3105adf7572157409e7c0cb1180675ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5XB-3ITT2psDpmG3dHlI5A.png"/></div></div></figure><p id="7f2b" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">现在你可能会认为，如果我们试图对单个形状使用我们的函数，它将不再工作，但这根本不是真的，它仍然可以正常工作——Julia会假装它是一个单个的dim数组，这让我感到惊讶。这揭示了一个新的问题，然而，这是我甚至没有想到的上下文的问题，因为填充颜色只能在每个上下文中声明一次，但我肯定会在下一篇文章中详细阐述这一点，因为在这篇文章中我还想得到一些其他的东西！</p><blockquote class="lj"><p id="7d0a" class="lk ll it bd lm ln my mz na nb nc lh dk translated">添加新形状。</p></blockquote><p id="f2ed" class="pw-post-body-paragraph kl km it ko b kp lt ju kr ks lu jx ku lv lw kx ky lx ly lb lc lz ma lf lg lh im bi translated">幸运的是，我为未来的自己做了非常简单的事情，我们可以通过简单地撕掉我们的圆形函数开始创建我们的新形状，我将把它重命名为矩形。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nz"><img src="../Images/8a7afbd2d88da72a05e824a798686abc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygZIbGPg1MOnQEjSN15ZYw.png"/></div></div></figure><p id="851d" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">正如我假设的那样，我是正确的，所有这一切都需要为矩形添加参数并重命名函数，没有任何复杂的事情。最棒的是现在我们可以吃饱了</p><blockquote class="lj"><p id="6191" class="lk ll it bd lm ln my mz na nb nc lh dk translated">圆形。</p></blockquote><p id="cc41" class="pw-post-body-paragraph kl km it ko b kp lt ju kr ks lu jx ku lv lw kx ky lx ly lb lc lz ma lf lg lh im bi translated">明白了吗？不管怎样，我们可以用形状而不是颜色来区分这两列。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi oa"><img src="../Images/c04bcbd726477dfcf8810bc19d65c13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyHDKkVa56P1YRndu3x2rw.png"/></div></div></figure><blockquote class="lj"><p id="4fa8" class="lk ll it bd lm ln lo lp lq lr ls lh dk translated">往好的方面想，至少那不是很多文字什么的。</p></blockquote><p id="ec30" class="pw-post-body-paragraph kl km it ko b kp lt ju kr ks lu jx ku lv lw kx ky lx ly lb lc lz ma lf lg lh im bi translated">现在让我们通过_dfscatter函数传递这些形状！</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ob"><img src="../Images/1302114c6cff6cf7f192b63acb3beec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFrYEJdIa_OMCy5gIwvStA.png"/></div></div></figure><p id="8077" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">我会让海绵宝宝解释这种感觉:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi oc"><img src="../Images/d22dc8c58eb07628fd20a4ee6aa75b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKmJBs4r5RrMNpGgsf-dyA.jpeg"/></div></div><p class="od oe gj gh gi of og bd b be z dk translated">(海绵宝宝是Nickelodeon的财产，我不拥有海绵宝宝)</p></figure></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="136b" class="oo np it bd op oq or os ot ou ov ow ox jz oy ka oz kc pa kd pb kf pc kg pd pe bi translated">结论</h1><p id="bea6" class="pw-post-body-paragraph kl km it ko b kp pf ju kr ks pg jx ku lv ph kx ky lx pi lb lc lz pj lf lg lh im bi translated">到目前为止，关于Hone的令人兴奋的事情是，在它完成后，基础将是多么容易建造，就像我们在正方形中看到的那样。很容易添加形状，甚至自定义形状到等式中，这肯定会使事情变得有趣。在未来，你还将有能力阅读图像，并相应地绘制它们，我认为这非常棒。</p><p id="2c87" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lv kw kx ky lx la lb lc lz le lf lg lh im bi translated">至于数据框标绘，当然还有一些事情要做，一般来说还有一些事情要做。不管怎样，我觉得我们已经非常接近于让Hone成为一个相当不错的绘图库了！如果你想了解Hone，请访问Github:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi pk"><img src="../Images/d4dcb14fa1a0c48420072d740e176871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oA6_H1YOgl96ujKHhsRoEw.gif"/></div></div></figure><div class="pl pm gp gr pn po"><a href="https://github.com/emmettgb/Hone.jl" rel="noopener  ugc nofollow" target="_blank"><div class="pp ab fo"><div class="pq ab pr cl cj ps"><h2 class="bd iu gy z fp pt fr fs pu fu fw is bi translated">emmettgb/Hone.jl</h2><div class="pv l"><h3 class="bd b gy z fp pt fr fs pu fu fw dk translated">模块化的形状，网格和线条容易预制快速绘图简单和轻型车床集成(即将推出)…</h3></div><div class="pw l"><p class="bd b dl z fp pt fr fs pu fu fw dk translated">github.com</p></div></div><div class="px l"><div class="py l pz qa qb px qc mu po"/></div></div></a></div><blockquote class="lj"><p id="6595" class="lk ll it bd lm ln lo lp lq lr ls lh dk translated">感谢阅读！</p></blockquote></div></div>    
</body>
</html>