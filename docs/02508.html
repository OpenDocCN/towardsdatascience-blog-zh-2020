<html>
<head>
<title>Navigating The Random Forest Algorithm in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 R 中导航随机森林算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/navigating-the-random-forest-algorithm-in-r-5ccbc0ef70e?source=collection_archive---------10-----------------------#2020-03-10">https://towardsdatascience.com/navigating-the-random-forest-algorithm-in-r-5ccbc0ef70e?source=collection_archive---------10-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/db4b9e127ca42d975951d4cd098e44e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*5BmMfp4LB2clpRB4NnK-QA.jpeg"/></div><p class="jx jy gj gh gi jz ka bd b be z dk translated">图片来自<a class="ae kb" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4773016" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kb" href="https://pixabay.com/users/501stCommanderMax-14065499/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4773016" rel="noopener ugc nofollow" target="_blank"> 501stCommanderMax </a></p></figure><h1 id="e6d8" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">袋装树和随机森林有什么相似之处？</h1><p id="97ec" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">随机森林与袋装树的相似之处在于，随机森林或袋装树模型中的每棵树都根据数据的随机子集进行训练。事实上，这种对不同数据组进行采样以训练独立模型的过程是一种称为 bagging 的集成方法；因此得名袋装树。(见此处袋装树课:<a class="ae kb" href="https://datasciencelessons.com/2019/08/05/learn-bagged-trees-for-classification-in-r/" rel="noopener ugc nofollow" target="_blank">https://datasciencelessons . com/2019/08/05/learn-bagged-trees-for-class ification-in-r/</a>)</p><h1 id="b345" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">它们有什么不同？</h1><p id="92ab" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">随机森林与袋装树的不同之处在于，袋装树可以访问任何给定树上的所有变量，因此袋装树的主要区别仅在于数据的采样。对于随机森林，用于训练模型的变量是在每棵树上随机选择的。这个过程被称为特性打包，因为它在概念上非常类似于引导聚合，只是针对变量。</p><p id="e7cb" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">许多人想知道为什么这个特征打包过程会导致更好的性能，原因是因为每个决策树有更大的不同可能性，因此每个树对因变量的变化给出不同的解释。</p><p id="126e" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">由于随机森林是对袋装树的改进，它们通常更有性能，在许多情况下也更容易调整。</p><p id="78d6" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">现在使用我在打包文章中使用的相同数据集；我将在这里使用相同的数据集。</p><h1 id="fe23" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">让我们开始吧</h1><p id="7cc2" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我们将使用<code class="fe md me mf mg b">randomForest</code>包。需要记住的一点是，当调整<code class="fe md me mf mg b">ntree</code>超参数时，更多的树几乎总是意味着更好的模型性能，您只需权衡计算时间和您可能获得的任何性能增益。(默认为 500 棵树)。</p><p id="bf4e" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">使用与决策树和袋装树教程中相同的数据集，我在每个模型中运行相同的公式。</p><p id="f68e" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">正如我在其他教程中所说的，下面的<code class="fe md me mf mg b">formula</code>部分是你告诉函数你想要理解什么的地方。<code class="fe md me mf mg b">~</code>之前的变量是你的因变量或者你想了解的东西。<code class="fe md me mf mg b">~</code>符号表示，<em class="mh">由</em>表示，或者<em class="mh">由</em>表示，接下来的一切就是你用来解释因变量的变化。</p><p id="b748" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">在这里，我们试图了解是否有人有可能在泰坦尼克号上幸存，给定他们的性别，年龄，兄弟姐妹数，票价，等等。</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="0c0e" class="mq kd it mg b gy mr ms l mt mu">set.seed(14)<br/>model &lt;- randomForest(formula = as.factor(Survived) ~ Pclass + Sex + Age + SibSp + Parch + Fare + Embarked,<br/>data = train)<br/>print(model)</span></pre><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/46e8eb5cc0f65f6a1824ea0ac47368d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BSOdnrXtlY_k7dqF.png"/></div></div></figure><p id="5012" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">这里你可以看到打印出来的模型。包括了我们模型本身的一些解释，比如类型、树计数、变量计数等等。最有趣的是<code class="fe md me mf mg b">OOB estimate of error rate</code>。<code class="fe md me mf mg b">OOB</code>代表出袋错误；与袋装树相似，这意味着当你采集数据样本来训练模型的每个版本时，你会遗漏一些数据。对于遗漏的数据，或者我们称之为袋外数据，模型会对其进行预测，并将其与实际数据进行比较，从而得出您在上面看到的错误率。上面计算误差的方法是通过错误分类计数并确定它占总分类的比例。比如我们预测 87 + 193 为 1 或者有可能存活。31%的错误率是通过将我们得到的错误数 87 除以预测值 87 + 193 计算出来的。</p><p id="e608" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">够了！让我们开始预测吧！</p><p id="de34" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">这里，我们使用刚刚训练的模型来预测测试中每个记录的类别。</p><h1 id="d9a5" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">性能赋值</h1><h1 id="54a1" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">混淆矩阵</h1><p id="bf99" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">从那里，我们实际上必须声明它是一个因子。如果两个字段不是同一个类，则<code class="fe md me mf mg b">Caret</code>的<code class="fe md me mf mg b">confusionMatrix</code>功能将不起作用。</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="ed21" class="mq kd it mg b gy mr ms l mt mu">test$pred &lt;- predict(model, test)<br/>test$pred &lt;- as.factor(test$pred)<br/>confusionMatrix(test$pred, test$Survived)</span></pre><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi na"><img src="../Images/872ae9b997f51e5559f827e44f6225de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/0*-QRGwmGbtqyBh2p-.png"/></div></figure><p id="55be" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">正如您在上面看到的，这是<code class="fe md me mf mg b">confusionMatrix</code>函数的输出。</p><p id="04da" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">该函数向您显示了预测值和实际值如何匹配的表格。所以预测值和参考值相同的对角线单元格代表我们得到的正确值。</p><p id="110d" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">我将给你上一堂课，教你如何解读下面的困惑矩阵:</p><p id="fd57" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">True positive:象限中引用和预测都为 1 的单元格。这表明你预测了存活，而他们确实存活了下来。</p><p id="5666" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">假阳性:这里你预测为阳性，但你错了。</p><p id="2509" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">真阴性:当你预测为阴性，并且你是正确的。</p><p id="b621" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">假阴性:当你预测为阴性，而你是不正确的。</p><p id="281c" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">需要记住的几个关键指标是灵敏度和特异性。敏感度是您正确预测的真实记录的百分比。</p><p id="9943" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">另一方面，特异性是衡量实际错误记录中你正确预测的部分。</p><p id="5cc0" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">在不平衡数据集上进行预测时，要记住特异性。一个非常常见的例子就是对垃圾邮件进行分类。99%的情况下它不是垃圾邮件，所以如果你预测没有垃圾邮件，你有 99%的准确率，但你的特异性是 0，导致所有的垃圾邮件都被接受。</p><h1 id="77d9" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">ROC 曲线和 AUC</h1><p id="9a4b" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">ROC 曲线或受试者工作特征曲线是一种可视化二元分类模型正确诊断或预测能力的方法。ROC 曲线绘出了不同阈值下的真阳性率与假阳性率的关系。</p><p id="2fda" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">我们对于 ROC 曲线的目标是真阳性率 100%，假阳性率 0%。那条曲线会落在图的左上角。</p><p id="c8f9" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">AUC 旨在确定可分性的程度，或正确预测类别的能力。AUC 越高越好。1 是完美的，0.5 是随机的。</p><pre class="mi mj mk ml gt mm mg mn mo aw mp bi"><span id="7233" class="mq kd it mg b gy mr ms l mt mu">pred &lt;- predict(object = model,<br/>            newdata = test,<br/>            type = "prob")library(Metrics)<br/>auc(actual = test$Survived, <br/>    predicted = pred[,"yes"])</span></pre><h1 id="5536" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="8afe" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">那就是我对 R 中随机森林进行分类的介绍！希望对你有帮助！如果你愿意跟随我写关于数据科学、机器学习之类的东西，来 datasciencelessons.com 找我吧。</p><p id="30e8" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">祝数据科学快乐！</p><p id="3303" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">如果你有兴趣了解这个主题的更多信息，请务必订阅！我目前正在写一本书，更详细地探讨这一原则和其他原则。</p></div></div>    
</body>
</html>