<html>
<head>
<title>Auditing vs. Testing in Data Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据开发中的审计与测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/auditing-vs-testing-in-data-development-2c3feda3a1e4?source=collection_archive---------24-----------------------#2020-02-01">https://towardsdatascience.com/auditing-vs-testing-in-data-development-2c3feda3a1e4?source=collection_archive---------24-----------------------#2020-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c296" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">“你如何测试数据？”</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/02cbb3ba208eac6b4c08248f6114a597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xGVyk3W26GuCQQJO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@scienceinhd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科学高清</a>拍摄的照片</p></figure><blockquote class="kz"><p id="f8e3" class="la lb it bd lc ld le lf lg lh li lj dk translated">“你如何测试数据？”</p></blockquote><p id="b681" class="pw-post-body-paragraph lk ll it lm b ln lo ju lp lq lr jx ls lt lu lv lw lx ly lz ma mb mc md me lj im bi translated">每当有人想讨论数据堆栈的现代化时，这个问题总是排在列表的首位。最常见的情况是，软件工程师负责解开 SQL 脚本和存储过程的网络，当他们发现“dev”和“prod”只是数据开发人员的 SQL 编辑器中不同的连接设置时，他们感到很苦恼。数据开发的发展非常缓慢，可以说缺乏自动化测试/测试驱动的开发是这种懒惰的一个重要原因。TDD 和 CI/CD 已经成为快速可靠的软件开发领域的爆炸性催化剂，一旦被采用，它们将对数据开发产生同样的影响。问题是<strong class="lm iu"> <em class="mf">如何</em> </strong>进行数据转换/模型测试并不十分直观。数据给软件设计增加了一层活动部件，可以感觉几乎不可能测试；但是和任何类型的开发一样，如果事情感觉太复杂，你可能需要考虑的更小。那么<em class="mf">如何</em>测试数据呢？容易；你不知道。你<strong class="lm iu"> <em class="mf">测试</em> </strong>软件，你<strong class="lm iu"> <em class="mf">审核</em> </strong>数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/2eabe2b1f9e1a42333924e6078740613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihZabOoHrLFtkxw8TNosiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">非结构化开发和 TDD 在技术上都是编程的方式，就像它们在技术上都是电话一样。图片来自美国国会图书馆印刷品和照片部吉尔伯特·h·格罗夫纳收藏。</p></figure><h1 id="cc11" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">数据不是软件，但数据软件是软件</h1><p id="69fe" class="pw-post-body-paragraph lk ll it lm b ln mz ju lp lq na jx ls lt nb lv lw lx nc lz ma mb nd md me lj im bi translated">《剑桥词典》将软件定义为控制计算机工作的指令。在 ELT 入库流程的情况下，软件是 SQL(或 python，或 R 等。)来决定如何更改或处理数据。数据是这个软件处理的东西。这种区别看起来很明显，但明确地说出来仍然很重要，因为它是如此多混乱的根源。当我们编写软件测试时，关键是我们只测试软件。</p><h1 id="2e58" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">事情在哪里变糟？</h1><p id="bb34" class="pw-post-body-paragraph lk ll it lm b ln mz ju lp lq na jx ls lt nb lv lw lx nc lz ma mb nd md me lj im bi translated">想象你拥有一家冰淇淋工厂(我们都可以做梦)。你的价值链大概是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/17e951d2b88eea653cfa143e12cd9512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9mtaOoOa6HhmAKNeR8ScQ.png"/></div></div></figure><p id="8d6c" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">假设你决定测试你的产品，所以你去商店买了一加仑的石头路。令你惊恐的是，你发现冰淇淋酸得要命！从这个测试中，我们知道有几个不同的地方可能会出错:</p><ul class=""><li id="a8cc" class="nk nl it lm b ln nf lq ng lt nm lx nn mb no lj np nq nr ns bi translated">这个牛奶场可能一开始就生产了劣质牛奶</li><li id="8f0c" class="nk nl it lm b ln nt lq nu lt nv lx nw mb nx lj np nq nr ns bi translated">罐车可能污染了牛奶(不良 EL 工艺)</li><li id="a885" class="nk nl it lm b ln nt lq nu lt nv lx nw mb nx lj np nq nr ns bi translated">工厂可能会让牛奶变质(转化软件错误)</li></ul><p id="a941" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">如果一个测试告诉你出了问题，但是不能帮助你确定它发生在价值链的什么地方，那么这个测试就是没有价值的。<a class="ae ky" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>告诉我们任何一点软件都应该只做一件事，并且把那件事做好。我们的测试也不例外！</p><p id="a899" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">如果不只是去商店测试，而是设立测试点，会怎么样？</p><ul class=""><li id="48e6" class="nk nl it lm b ln nf lq ng lt nm lx nn mb no lj np nq nr ns bi translated">在对牛奶做任何处理之前，在牛奶场检查牛奶</li><li id="0748" class="nk nl it lm b ln nt lq nu lt nv lx nw mb nx lj np nq nr ns bi translated">从罐车上接受牛奶之前，先检查一下</li><li id="f835" class="nk nl it lm b ln nt lq nu lt nv lx nw mb nx lj np nq nr ns bi translated">就在装运前，检查工厂生产线末端的冰淇淋</li><li id="4af0" class="nk nl it lm b ln nt lq nu lt nv lx nw mb nx lj np nq nr ns bi translated">检查店面的冰淇淋</li></ul><p id="1f43" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">现在如果你在奶牛场发现一批酸奶，就没必要再往前走了。如果你在工厂生产线的末端收到一盒变质的冰淇淋，你知道它在加工过程中变酸了。</p><p id="7fae" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated"><strong class="lm iu"> <em class="mf">审计</em> </strong>你的数据是在对牛奶做任何事情之前检查它。审计所做的唯一一件事(<a class="ae ky" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank"> SRP </a>)就是确保我们的源数据按照我们的预期到达。</p><p id="3e7d" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated"><strong class="lm iu"> <em class="mf">测试</em> </strong>您的转换/模型逻辑是在冰淇淋被处理后检查它。测试所做的唯一一件事(<a class="ae ky" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank"> SRP </a>)就是确保给定一个预期的数据输入，你的代码会像预期的那样运行。</p><h1 id="9d28" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">事情变得混乱</h1><p id="3737" class="pw-post-body-paragraph lk ll it lm b ln mz ju lp lq na jx ls lt nb lv lw lx nc lz ma mb nd md me lj im bi translated">审核和测试之间的界限最初可能很难看出，原因如下:</p><ul class=""><li id="a2b3" class="nk nl it lm b ln nf lq ng lt nm lx nn mb no lj np nq nr ns bi translated"><strong class="lm iu">代码看起来一样，一定是重复工作。开发人员对我们代码库中相同的文本段落有一种精心策划的恐惧。干编程告诉我们，任何两个看起来几乎相同的东西都应该被参数化/注入/粉碎成某种形式的单一的、可调用的执行。当我们的测试和审计提出类似的问题时，很容易尝试多任务处理。不要这样做！审计和测试可能会问同样的问题，但它们是在非常不同的环境中进行的。例如，在<code class="fe ny nz oa ob b">user_id</code>中发现一个<code class="fe ny nz oa ob b">NULL</code>值的审计告诉您有一个源数据问题或变更。转换测试中相同的<code class="fe ny nz oa ob b">NULL</code>值告诉您您的 SQL 是不正确的。审计<code class="fe ny nz oa ob b">NULL</code>只能<em class="mf"/>意味着源数据有问题，因为您的转换还没有触及它。一个测试<code class="fe ny nz oa ob b">NULL</code>只能<em class="mf">意味着你的 SQL 代码有 bug，因为源数据通过了审计。</em></strong></li><li id="41b4" class="nk nl it lm b ln nt lq nu lt nv lx nw mb nx lj np nq nr ns bi translated"><strong class="lm iu">测试是工具，不是数据。测试的唯一目的是促进发展。给定一个不可变的输入，我们应该期待一个不可变的输出(否则我们会有更大的问题)。因此，测试是确定我们在输入和输出之间精心制作的逻辑何时“完成”的一种方式为了让测试有用，它们需要足够快，能够在我们开发的过程中一遍又一遍地运行，并且足够全面，以至于我们“目测”来验证我们工作的任何东西都有一个等价的自动化测试。有效测试的一个核心要求是，我们可以相信所提供的源数据与我们得到的承诺完全一致。</strong></li><li id="5d16" class="nk nl it lm b ln nt lq nu lt nv lx nw mb nx lj np nq nr ns bi translated"><strong class="lm iu">审计是实质性的(和大量的元数据)</strong>。为了让我们的测试信任源数据，我们的审计不能信任源数据。审计对源数据有期望(即<code class="fe ny nz oa ob b">user_id</code>永远不会是<code class="fe ny nz oa ob b">NULL</code>)，并检查以确保这些期望得到满足(<code class="fe ny nz oa ob b">SELECT * FROM products WHERE user_id IS NULL</code>)。当源数据没有通过这项检查时，审计人员并没有生气，他们只是感到失望——他们通过停止 ELT 过程来表达这种失望。</li></ul><h1 id="a1a6" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">实践中的理论</h1><p id="ca3c" class="pw-post-body-paragraph lk ll it lm b ln mz ju lp lq na jx ls lt nb lv lw lx nc lz ma mb nd md me lj im bi translated">理解审计-测试模型最简单的方法是浏览一个例子。</p><p id="8a44" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">这里我们有来自一个电子商务网站的源数据，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/f0060f4aa63d9a6a51d1f00d7dd3f217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cio54nKK_haZ7XQKd3QqqA.png"/></div></div></figure><p id="0e2e" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">我们相信:<br/> -所有记录<em class="mf">必须</em>有一个<code class="fe ny nz oa ob b">user_id</code>值<br/> - ip_region 只能是<code class="fe ny nz oa ob b">east</code>、<code class="fe ny nz oa ob b">west</code>、<code class="fe ny nz oa ob b">north</code>或<code class="fe ny nz oa ob b">south</code></p><p id="0e6a" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">因此，我们编写了在每次从源系统批量加载后运行的审计:</p><pre class="kj kk kl km gt od ob oe of aw og bi"><span id="9cb1" class="oh mi it ob b gy oi oj l ok ol">## audit_users_user_id_is_not_null<br/>SELECT * FROM "DATA_LAKE"."USERS" WHERE user_id IS NULL;</span><span id="a4a7" class="oh mi it ob b gy om oj l ok ol">## audit_users_region_in_set<br/>SELECT * FROM "DATA_LAKE"."USERS" WHERE ip_region NOT IN ('west','east','south')</span></pre><p id="78d4" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">如何运行审计可以有多种方式(从实现的角度来看)。重要的是:<br/> -审计在任何转换之前首先运行。<br/> -当所有审核通过时，ELT 正常进行。<br/> -当审核失败时，会详细记录失败情况，ELT 会暂停并发出警报。</p><p id="d329" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated"><strong class="lm iu"> <em class="mf">注意:</em></strong><em class="mf"/><a class="ae ky" href="https://www.kimballgroup.com/2014/03/design-tip-164-built-your-audit-dimension/" rel="noopener ugc nofollow" target="_blank"><em class="mf">Kimball</em></a><em class="mf">围绕审计级别和记录模式做了大量的工作，这些不在本文的范围之内。</em></p><p id="9404" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">从事聚合转换的开发人员也可以编写一个测试，在<code class="fe ny nz oa ob b">user_id</code>中寻找<code class="fe ny nz oa ob b">NULL</code>值:</p><pre class="kj kk kl km gt od ob oe of aw og bi"><span id="c2d4" class="oh mi it ob b gy oi oj l ok ol">## test_user_id_never_null<br/>SELECT * FROM "DATA_WAREHOUSE"."DIM_USER" WHERE user_id IS NULL;</span></pre><p id="2db2" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">但是关键的区别在于:<strong class="lm iu">开发人员的测试只是为了告诉他们代码是否正确</strong>。审计层承诺所有记录都有<code class="fe ny nz oa ob b">user_id</code>值，所以开发过程中的任何<code class="fe ny nz oa ob b">NULL</code>值都意味着代码有 bug。开发人员可以根据承诺的输入安全地编写测试来检查预期的输出，当所有测试都通过时，代码就可以发布了。</p><p id="fd79" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">如果没有<code class="fe ny nz oa ob b">user_id</code>的记录进来，ELT 停止。所有记录都有一个<code class="fe ny nz oa ob b">user_id</code>的信念不再被认为是正确的。通过审计记录调查缺失行的<code class="fe ny nz oa ob b">user_id</code>,发现所有有问题的行都正好来自 2020–03–02t 11:10:53，是由一个应用程序错误引起的，该错误已被修补。还要注意的是，在那个时间戳没有创建有效的行。新的承诺是所有行都将有一个<code class="fe ny nz oa ob b">user_id</code>，除了在 2020–03–02t 11:10:53 创建的记录。审计代码被调整以反映我们现在认为是真实的，应用程序代码被调整以<em class="mf">处理数据的新现实</em>。</p><p id="3a20" class="pw-post-body-paragraph lk ll it lm b ln nf ju lp lq ng jx ls lt nh lv lw lx ni lz ma mb nj md me lj im bi translated">审计记录可以(并且经常)被注释，以便为所有这些复杂性创建上下文。其结果是丰富的数据演变历史记录和高性能的开发工作流程，优化您最有价值的资产—数据开发人员带宽。</p></div></div>    
</body>
</html>