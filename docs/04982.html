<html>
<head>
<title>Essential Python Concepts &amp; Structures Any Serious Programmer Needs to Know, Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">任何认真的程序员都需要知道的基本 Python 概念和结构，解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/essential-python-concepts-any-serious-programmer-needs-to-know-explained-429aad86b92e?source=collection_archive---------14-----------------------#2020-04-30">https://towardsdatascience.com/essential-python-concepts-any-serious-programmer-needs-to-know-explained-429aad86b92e?source=collection_archive---------14-----------------------#2020-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2971049bb2402e73cd1912b064e66124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*teuuwMyTnK3AOat2.jpg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://pixabay.com/photos/architecture-skyscraper-urban-city-768432/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="8927" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">生成器、面向对象编程、闭包、装饰器等等</h2></div><p id="7f12" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将概述一些重要的 Python 概念，任何认真的程序员都应该知道并理解这些概念才能实现。这些概念形成了高级 Python 编程的框架，以智能地处理和实现问题。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8856" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">发电机</h1><p id="edf5" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">用 Python 构建一个迭代器，一个可以迭代的对象，需要做大量的工作。一个类(面向对象的编程)必须用一个<code class="fe my mz na nb b">__iter__()</code>和<code class="fe my mz na nb b">__next__()</code>方法构建，内部状态必须被存储和更新，当没有值要返回时，必须产生一个<code class="fe my mz na nb b">StopIteration</code>错误。</p><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nc"><img src="../Images/87cb60be53c7a5b034e19521aa4f8bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyHqMH9FFq74dNQYAtU_BQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Python 中的迭代。作者创建的图像。</p></figure><p id="0082" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了避免这个冗长的过程，Python 生成可以自动创建迭代器。上面描述的创建迭代器的所有过程都是由 Python 和生成器自动完成的。生成器是一个函数，它返回一个可以迭代的对象(迭代器)(一次覆盖一个值)。</p><p id="8398" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成器函数被定义为一个函数，但是使用了关键字<code class="fe my mz na nb b">yield</code>而不是传统的<code class="fe my mz na nb b">return</code>。如果函数体包含<code class="fe my mz na nb b">yield</code>，那么它将自动成为一个生成器函数。</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="7052" class="nl mc jj nb b gy nm nn l no np">def simple_generator():<br/>     yield 1<br/>     yield 2<br/>     yield 3</span><span id="f107" class="nl mc jj nb b gy nq nn l no np">for value in simple_generator():<br/>     print(value)</span></pre><p id="ad59" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前四行代码定义了生成器，它将迭代返回<code class="fe my mz na nb b">1</code>、<code class="fe my mz na nb b">2</code>和<code class="fe my mz na nb b">3</code>。最后两行通过迭代打印输出值来演示迭代，输出:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="fceb" class="nl mc jj nb b gy nm nn l no np">1<br/>2<br/>3</span></pre><p id="84e8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个生成器对象仍然需要一个函数来描述对象，但是需要设置为等于一个变量，在本例中为<code class="fe my mz na nb b">x</code>。</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="2497" class="nl mc jj nb b gy nm nn l no np">x = simple_generator()<br/>print(next(x))<br/>print(next(x))<br/>print(next(x))</span></pre><p id="65b4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，下面的代码创建一个斐波那契数列生成器，其中每一项都是前面两项(0、1、1、2、3、5、8、13、…)的和。</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="e17b" class="nl mc jj nb b gy nm nn l no np">def fibonacci(limit):<br/>     a, b = 0, 1<br/>     <br/>     while a &lt; limit:<br/>          yield a<br/>          a, b = b, a+b</span></pre><p id="cb67" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用于跟踪序列的两个数字是<code class="fe my mz na nb b">a</code>和<code class="fe my mz na nb b">b</code>，它们分别被初始化为 0 和 1。当<code class="fe my mz na nb b">a</code>低于限值(函数中指定为参数的数字)时，程序产生(返回)a 的值。然后，<code class="fe my mz na nb b">a</code>和<code class="fe my mz na nb b">b</code>同时更新，其中<code class="fe my mz na nb b">a</code>设置为<code class="fe my mz na nb b">b</code>，而<code class="fe my mz na nb b">b</code>设置为自身加上<code class="fe my mz na nb b">a</code>。这将序列 1 向右移动，同时保留用于生成下一个序列值(前两个数字)的相关信息。</p><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nr"><img src="../Images/70d90d27329360f1efc44e20a07adaff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q51JufkbiDaZUkozvUzObg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">斐波那契序列发生器逻辑。作者创建的图像。</p></figure><p id="e0c7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后可以迭代生成器，在这种情况下使用 for 循环:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="5e92" class="nl mc jj nb b gy nm nn l no np">for i in fibonacci(8):<br/>     print(i)</span></pre><p id="bef3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，输出将遍历 Fibonacci 序列中值为 8 的所有元素:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="9d28" class="nl mc jj nb b gy nm nn l no np">0<br/>1<br/>1<br/>2<br/>3<br/>5</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="9330" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">面向对象编程</h1><p id="1f7e" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">面向对象编程是 Python 的一个特性，它允许对方法和变量进行干净和有组织的存储。Python 中的面向对象编程(OOP)由<code class="fe my mz na nb b">class</code>对象组成，其中包含关于该对象的信息。</p><p id="ab3b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，假设我们想用 Python 创建一只虚拟狗。一个类的个人属性存储在一个<code class="fe my mz na nb b">__init__</code>函数中。必须包括<code class="fe my mz na nb b">self</code>参数，以及创建时需要定义的该对象的任何其他属性，例如狗的<code class="fe my mz na nb b">species</code>和<code class="fe my mz na nb b">age</code>。</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="fe73" class="nl mc jj nb b gy nm nn l no np">class dog:<br/>     def __init__(self, species, age):<br/>          self.species = species<br/>          self.age = age</span></pre><p id="4d14" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以用<code class="fe my mz na nb b">.</code>在<code class="fe my mz na nb b">class</code>对象内部调用对象的变量和函数，前面的元素引用对象，句号后面的项目引用被调用的对象。<code class="fe my mz na nb b">self.species = species</code>将内部变量设置为输入参数<code class="fe my mz na nb b">species</code>的值。</p><p id="ac2b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还可以在类中创建函数:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="17ad" class="nl mc jj nb b gy nm nn l no np">class dog:<br/>     def __init__(self, species, age):<br/>          self.species = species<br/>          self.age = age</span><span id="ca1a" class="nl mc jj nb b gy nq nn l no np">     def bark(self, call='Woof!'):<br/>          print(call)</span><span id="823f" class="nl mc jj nb b gy nq nn l no np">     def reveal_information(self):<br/>          print('I am a', self.species)<br/>          print('I am', self.age, 'years old')</span></pre><p id="466f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两个内部函数<code class="fe my mz na nb b">bark</code>和<code class="fe my mz na nb b">reveal_information</code>是由类执行和附加的方法。然后，我们可以为 dog 类设置一个变量<code class="fe my mz na nb b">pepper</code>。我们必须指定初始化参数，<code class="fe my mz na nb b">species</code>和<code class="fe my mz na nb b">age</code>。</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="9cb7" class="nl mc jj nb b gy nm nn l no np">pepper = dog(species='German Shepard', age=3)</span></pre><p id="04d4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以调用<code class="fe my mz na nb b">pepper</code>的属性:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="419e" class="nl mc jj nb b gy nm nn l no np">pepper.reveal_information()</span></pre><p id="e8f3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将输出:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="a9b9" class="nl mc jj nb b gy nm nn l no np">I am a German Shepard<br/>I am 3 years old</span></pre><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/f78bba4498e4b54ad9095e9ff3449c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFbQbkcQkntZKD_iSPkepg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">面向对象的可视化类。作者创建的图像。</p></figure><p id="a636" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python 中的面向对象编程适用于许多目的。尽管它可能需要更多的输入来设置，但它允许更多的可读代码。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="32cb" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">关闭</h1><p id="934d" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">闭包可以避免使用全局值，并提供了一种数据隐藏形式，为问题提供了一种面向对象的解决方案。当一个类中要实现的方法很少时，闭包可以提供一种替代的、更优雅的解决方案。当属性和方法的数量增加时，一个类就更合适了。以下标准演示了当嵌套函数引用其封闭范围内的值时 Python 中的闭包:</p><ul class=""><li id="e72c" class="nt nu jj la b lb lc le lf lh nv ll nw lp nx lt ny nz oa ob bi translated">存在嵌套函数(函数中的函数)</li><li id="86bc" class="nt nu jj la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">嵌套函数引用封闭函数中声明的值</li><li id="a785" class="nt nu jj la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">封闭函数返回嵌套函数</li></ul><figure class="nd ne nf ng gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/08d31140fedb1f4edfca132f9df4687b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LaS2KCHQgTb2uqkKt9iHRg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">闭合图。作者创建的图像。</p></figure><p id="81a5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用一个示例函数<code class="fe my mz na nb b">make_multiplier</code>来演示闭包，它接受一个参数<code class="fe my mz na nb b"><em class="oi">n</em></code>并返回一个带有该参数的函数。</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="b738" class="nl mc jj nb b gy nm nn l no np">def make_multiplier(n):<br/>    def multiplier(x):<br/>        return x * n<br/>    return multiplier</span></pre><p id="d37d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建一个将某物乘以 3 的函数的过程如下:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="a293" class="nl mc jj nb b gy nm nn l no np">times3 = make_multiplier(3)</span></pre><p id="2370" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为函数<code class="fe my mz na nb b">make_multiplier</code>返回一个函数，<code class="fe my mz na nb b">times3</code>是一个函数。</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="bcea" class="nl mc jj nb b gy nm nn l no np">print(times3(9))</span></pre><p id="2621" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">…返回…</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="7372" class="nl mc jj nb b gy nm nn l no np">27</span></pre><p id="e44a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">…因为 3 乘以 9 等于 27。闭包可能是用 Python 完成这项任务的最佳方式。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="fdda" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">内置枚举</h1><p id="7116" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Python 内置枚举<em class="oi">牛逼</em>。也许开发人员面临的最常见的任务是在跟踪索引的同时遍历列表中的一项。在许多没有枚举的其他语言中，程序员需要手动完成这项工作，例如在 Python 中:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="cd68" class="nl mc jj nb b gy nm nn l no np">counter = 0<br/>for item in a_list:<br/>     do_something_with(item)<br/>     do_something_else_with(counter)<br/>     counter += 1</span></pre><p id="24f4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，Python 的<code class="fe my mz na nb b">enumerate()</code>函数通过返回一个不可打包的元组来自动跟踪每次迭代的计数器:</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="43b7" class="nl mc jj nb b gy nm nn l no np">for index, item in enumerate(a_list):<br/>     do_something_with(item)<br/>     do_something_with(index)</span></pre><p id="9288" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为演示，下面的代码…</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="3cba" class="nl mc jj nb b gy nm nn l no np">for index, item in enumerate(['a','b','c']):<br/>     print(index,item)</span></pre><p id="c238" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">…会输出…</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="0098" class="nl mc jj nb b gy nm nn l no np">0 a<br/>1 b<br/>2 c</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="77af" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">装修工</h1><p id="6556" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">装饰者接受一个函数，向该函数添加一些功能，然后返回它。这在需要父函数的小变化的情况下非常有用，因为可以用装饰器来改变函数，而不是为需要的函数的每个变化重写函数。</p><p id="f14b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有一个函数<code class="fe my mz na nb b">ordinary()</code>，它的唯一目的是打印出一个字符串<code class="fe my mz na nb b">“I am an ordinary function.”</code></p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="d555" class="nl mc jj nb b gy nm nn l no np">def ordinary():<br/>    print("I am an ordinary function.")</span></pre><p id="a120" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们还想添加另一条消息，<code class="fe my mz na nb b">“I was decorated!”</code>我们可以创建一个函数<code class="fe my mz na nb b">decorate()</code>，它接收一个函数，打印添加的消息，然后调用原始函数，其对象作为参数输入到函数<code class="fe my mz na nb b">decorate()</code>中。添加额外字符串和调用原始函数的过程可以存储在一个内部函数中，其对象用<code class="fe my mz na nb b">decorate()</code>返回。</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="6029" class="nl mc jj nb b gy nm nn l no np">def decorate(function):<br/>    def inner_function():<br/>        print("I was decorated!")<br/>        function()<br/>    return inner_function</span></pre><p id="5e53" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了修饰原始函数<code class="fe my mz na nb b">ordinary()</code>，我们将在原始函数上调用函数<code class="fe my mz na nb b">decorate()</code>。我们存储<code class="fe my mz na nb b">decorate()</code>输出到<code class="fe my mz na nb b">decorated</code>的变量是一个函数(函数<code class="fe my mz na nb b">decorate()</code>中的<code class="fe my mz na nb b">inner_function</code>)。</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="33d7" class="nl mc jj nb b gy nm nn l no np">decorated = decorate(ordinary)<br/>decorated()</span></pre><p id="16ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">调用<code class="fe my mz na nb b">decorated()</code>产生输出…</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="b5cd" class="nl mc jj nb b gy nm nn l no np">I was decorated!<br/>I am an ordinary function.</span></pre><p id="3307" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">装饰者使用<code class="fe my mz na nb b">@</code>符号来自动装饰一个功能。</p><pre class="nd ne nf ng gt nh nb ni nj aw nk bi"><span id="e233" class="nl mc jj nb b gy nm nn l no np">@decorate<br/>def ordinary():<br/>    print("I am an ordinary function.")</span></pre><p id="3715" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在函数定义前使用<code class="fe my mz na nb b">@</code>符号会自动修饰函数。它的计算方式与前面概述的修饰函数的方法相同。</p><p id="f7ae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过在一个函数前添加几行<code class="fe my mz na nb b">@decorate</code>，多个 decorators 可以相互链接。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8c07" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">感谢阅读！</h1><p id="773c" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">如果您对代码示例或概念有任何疑问，请在下面的回复中提问。</p></div></div>    
</body>
</html>