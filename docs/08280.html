<html>
<head>
<title>Graph Theory | Center of a Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图论|树的中心</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-theory-center-of-a-tree-a64b63f9415d?source=collection_archive---------28-----------------------#2020-06-17">https://towardsdatascience.com/graph-theory-center-of-a-tree-a64b63f9415d?source=collection_archive---------28-----------------------#2020-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="bbef" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/tag/graph-theory-simplified" rel="noopener">图论简化版</a></h2><div class=""/><blockquote class="jz ka kb"><p id="9644" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">欢迎大家回来。我们现在在这个叫做<a class="ae lb" href="https://medium.com/@kelvinjose/graph-theory-go-hero-1b5917da4fc1?source=---------2------------------" rel="noopener"> <strong class="kf jd"> <em class="it">图论:Go Hero </em> </strong> </a>系列的第9个帖子。去看看以前文章的索引页。我尽量每个周末更新。让我们看看如何找到树的中心。</p></blockquote><h2 id="bfc4" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated">介绍</h2><p id="36a8" class="pw-post-body-paragraph kc kd it kf b kg lx ki kj kk ly km kn ll lz kq kr lp ma ku kv lt mb ky kz la im bi translated">寻找树的中心是一个需要了解的简便算法，因为我们经常在其他算法的子例程中看到它，而且当我们<a class="ae lb" rel="noopener" target="_blank" href="/graph-theory-rooting-a-tree-fb2287b09779"> <strong class="kf jd"> <em class="ke">为树</em> </strong> </a>求根时，这也是一个选择根节点的有用方法。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/03b3ea2fada78f08c511aec9534e4828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqDPFnhx_eS1rAV4YuV0fQ.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">作者照片</p></figure><p id="0445" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">要记住的一点是，树可以有一个以上的中心，但不能超过两个。</p><h2 id="1441" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated">计算中心</h2><p id="c9e7" class="pw-post-body-paragraph kc kd it kf b kg lx ki kj kk ly km kn ll lz kq kr lp ma ku kv lt mb ky kz la im bi translated">请注意，中心始终是树中每条最长路径的中间顶点或中间两个顶点。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ms"><img src="../Images/eb3e7ef4a090270db6514cfec3d0a0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxA_xcqhzr1K03y7j5e3bQ.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">作者照片</p></figure><p id="4485" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">例如，上图中橙色的路径是最长的路径，红色节点被认为是其中的中心。如果我们重复这个过程，选择另一条可能的长路径，中心将保持不变。</p><p id="93e2" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">另一种寻找中心的方法是像剥洋葱一样反复挑选每个叶子节点。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/9ddc2f302f61c4f3053a2e30646fdaf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*BEtlbsuS5gstzsn7hTZKcw.jpeg"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@cdrying?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> C在<a class="ae lb" href="/photos/5oMpx91a9ks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上烘干</a></p></figure><p id="03b0" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">所以，我们从郊区开始，逐渐在中心结束。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/36337b43f9f4abfac3703bf67c7a382b.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*kzAmN77S7TGClRsQFNxB1w.png"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">作者照片</p></figure><p id="3a1f" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">在我们的例子中，中间有一条水平线的节点是叶子。如果我们计算这些节点的<strong class="kf jd"> <em class="ke">度</em> </strong>，</p><blockquote class="jz ka kb"><p id="28f4" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">节点的度是它所连接的节点的数量。</p></blockquote><p id="6324" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">肯定会是1。因为所有这些叶节点都恰好连接到一个节点。当我们修剪树叶时，所有其他节点也会受到影响，即节点的度会开始降低。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/a2f26e82333e9ea0fc212745880b2a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*_WK1mpSfTbjVwxQTbuot5A.png"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">作者照片</p></figure><p id="f120" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">正如我们在上面的图像中看到的，我们的图形将开始反复松开它的叶子，直到我们找到它的中心。记住，<strong class="kf jd"> <em class="ke">我们可能会找到一个或多个中心</em> </strong>。</p><h2 id="61d0" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated">伪码</h2><p id="7084" class="pw-post-body-paragraph kc kd it kf b kg lx ki kj kk ly km kn ll lz kq kr lp ma ku kv lt mb ky kz la im bi translated">现在让我们看一些伪代码。</p><pre class="md me mf mg gt mv mw mx my aw mz bi"><span id="2be6" class="lc ld it mw b gy na nb l nc nd">function <strong class="mw jd">treeCenters</strong>(g):<br/>    n = g.numberOfNodes()<br/>    degree = [0] * n<br/>    leaves = []<br/>    for(i=0; i&lt;n; i++):<br/>        if degree[i] == 0 or degree[i] == 1:<br/>            leaves.add(i)<br/>            degree[i] = 0<br/>    count = leaves.size()<br/>    <br/>    while count &lt; n:<br/>        new_leaves = []<br/>        for node in leaves:<br/>            for neighbor in g[node]:<br/>                degree[neighbor] = degree[neighbor] - 1<br/>                if degree[neighbor] == 1:<br/>                    new_leaves.add(neighbor)<br/>        count += new_leaves.size()<br/>        leaves = new_leaves</span></pre><p id="4c87" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">函数<strong class="kf jd"> <em class="ke">的参数<strong class="kf jd"><em class="ke">g</em></strong>tree centers()</em></strong>是一个无向图。变量n表示我们的树中节点的数量。我们定义了两个数组，degree和leaves。前者的大小为<strong class="kf jd"> <em class="ke"> n </em> </strong>并存储树中每个节点的度，后者保留最近一层的叶节点。然后我们进入一个循环，我们计算图中每个节点的度，我们也检查我们是否考虑一个单节点树或者它是一个叶子节点。如果这两个条件中的任何一个为真，我们将条目添加到leaves数组中，并将其在degrees数组中的值标记为0——因为我们不必再次访问该节点。变量count将记录到目前为止我们已经处理的节点数。然后，我们不断地检查树叶并修剪它们。最后，我们会得到树的中心。</p><p id="d6ab" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">这很简单，对吧？</p><p id="deab" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">我们将在下一篇文章中讨论<strong class="kf jd"> <em class="ke">识别同构树</em> </strong>。敬请期待。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ne"><img src="../Images/12a42ea150b669878b350084c16af78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgzROdVHD1jDW91xwO8mVA.png"/></div></div></figure></div></div>    
</body>
</html>