<html>
<head>
<title>Building a Road Sign Classifier in Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Keras 中构建路标分类器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-road-sign-classifier-in-keras-764df99fdd6a?source=collection_archive---------8-----------------------#2020-01-24">https://towardsdatascience.com/building-a-road-sign-classifier-in-keras-764df99fdd6a?source=collection_archive---------8-----------------------#2020-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f2c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写一个 CNN，在 Keras 框架中对超过 43 种类型的路标进行分类</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/713edb532e01ef62e0b1a895506e1f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bnej5JYaGK4aPAFvuY-0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">路标分类过程(<a class="ae ky" href="https://www.mdpi.com/symmetry/symmetry-09-00138/article_deploy/html/images/symmetry-09-00138-g003.png" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="45da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有这么多不同类型的交通标志，每一种都有不同的颜色、形状和大小。有时，有两个标志可能有相似的颜色，形状和大小，但有两个完全不同的含义。我们究竟怎样才能给计算机编程序来正确分类道路上的交通标志呢？我们可以通过创建自己的 CNN 来为我们分类不同的路标。</p><h2 id="b23f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">下载数据</h2><p id="8b89" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在本教程中，我们将使用 GTSRB 数据集，该数据集包含超过 50，000 张德国交通标志的图像。共有 43 个类别(43 种不同类型的标志，我们将对其进行分类)。单击下面的链接下载数据集。</p><div class="mt mu gp gr mv mw"><a href="https://www.kaggle.com/meowmeowmeowmeowmeow/gtsrb-german-traffic-sign" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">GTSRB -德国交通标志识别基准</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">多类别、单图像分类挑战</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">www.kaggle.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ks mw"/></div></div></a></div><p id="83ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你在电脑中打开数据集时，数据集内应该有 6 个路径(3 个文件夹和 3 个电子表格)，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/744abebebf57f80030da97dccd0cc133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvcbSX6ea8Osro-S1n2cgA.jpeg"/></div></div></figure><p id="009d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nm"> meta </em> </strong>文件夹应该有 43 个不同的图像(范围从 0-42)。<strong class="lb iu"> <em class="nm">测试</em> </strong>文件夹就是一堆测试图片。<strong class="lb iu"> <em class="nm"> train </em> </strong>文件夹应该有 43 个文件夹(范围也是从 0 到 42)，每个文件夹包含各自类别的图像。</p><p id="58db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经有了数据集，并且数据集包含了所有需要的数据，让我们开始编码吧！</p><p id="5346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程将分为 3 个部分:<strong class="lb iu"> <em class="nm">加载数据</em> </strong>，<strong class="lb iu"> <em class="nm">建立模型</em> </strong>和<strong class="lb iu"> <em class="nm">训练模型</em> </strong>。</p><p id="2d40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过在开始之前，请确保您的计算机上安装了 Jupiter 笔记本，因为本教程是在 Jupiter 笔记本上完成的(这可以通过安装 Anaconda 来完成。点击下面的链接安装 Anaconda。)</p><div class="mt mu gp gr mv mw"><a href="https://www.anaconda.com/distribution/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">Anaconda Python/R 发行版-免费下载</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">开源的 Anaconda 发行版是在…上执行 Python/R 数据科学和机器学习的最简单的方法</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">www.anaconda.com</p></div></div><div class="nf l"><div class="nn l nh ni nj nf nk ks mw"/></div></div></a></div><h1 id="01b3" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">加载数据</h1><p id="ecce" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">好了，现在我们已经安装了 Jupyter 笔记本，也安装了数据集，我们准备开始编码了(Yesss)！</p><p id="3733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们导入加载数据所需的库和模块。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="df92" class="lv lw it oa b gy oe of l og oh">import pandas as pd<br/>import numpy as np<br/>import os<br/>import cv2<br/>import matplotlib.pyplot as plt<br/>import random</span><span id="9c51" class="lv lw it oa b gy oi of l og oh">import tensorflow as tf<br/>from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import BatchNormalization<br/>from tensorflow.keras.layers import Conv2D<br/>from tensorflow.keras.layers import MaxPooling2D<br/>from tensorflow.keras.layers import Activation<br/>from tensorflow.keras.layers import Flatten<br/>from tensorflow.keras.layers import Dropout<br/>from tensorflow.keras.layers import Dense<br/>from tensorflow.keras.utils import to_categorical<br/>from tensorflow.keras.preprocessing.image import ImageDataGenerator<br/>from tensorflow.keras.optimizers import Adam</span></pre><p id="4e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一束是创建<strong class="lb iu"> <em class="nm"> load_data </em> </strong>函数所需的库。第二组是我们构建模型所需要的东西。如果您愿意，可以在不同的内核中导入每个束，但这真的无关紧要。</p><h2 id="5c79" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">创建 L <em class="oj"> oad_Data </em>函数</h2><p id="3752" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">要开始加载数据，让我们创建一个变量来表示数据集的存储位置。确保你把字母<strong class="lb iu"> <em class="nm"> r </em> </strong>放在你的路径字符串前面，这样你的计算机就知道它应该<strong class="lb iu">读</strong>这个字符串。</p><p id="93a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我的道路将与你的不同。要获得数据集的路径，您应该转到数据集所在的文件夹，单击一次数据集(不要打开它，只要让您单击它)，然后单击屏幕左上角的按钮<strong class="lb iu"> <em class="nm">复制路径</em> </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/3ab206648cf363fd13dd2552db860a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aAKuWOCBtBMZ8t39MFesRw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不要双击数据文件夹，只需单击一次将其高亮显示</p></figure><p id="6441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后把路径粘贴到你的 jupyter 笔记本上(就像我下面做的那样)。确保你在你的字符串前面加了一个<strong class="lb iu"> <em class="nm"> r </em> </strong>，这样 pc 就知道它应该读取这个文件了。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="b4a9" class="lv lw it oa b gy oe of l og oh">data_path = r"D:\users\new owner\Desktop\Christmas Break\gtsrb-german-traffic-sign"</span></pre><p id="6574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义将数据从计算机加载到笔记本中的函数。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="091c" class="lv lw it oa b gy oe of l og oh">def load_data(dataset):<br/>    images = []<br/>    classes = []</span><span id="4a79" class="lv lw it oa b gy oi of l og oh">    rows = pd.read_csv(dataset)<br/>    rows = rows.sample(frac=1).reset_index(drop=True)</span></pre><p id="0519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<strong class="lb iu"><em class="nm">load _ data</em></strong><em class="nm"/>函数取 1 个参数，这是我们数据集的路径。之后，我们定义两个列表，<strong class="lb iu"> <em class="nm">图片</em> </strong>和<strong class="lb iu"> <em class="nm">类</em> </strong>。<strong class="lb iu"> <em class="nm">图像</em> </strong>列表将存储图像数组，而<strong class="lb iu"> <em class="nm">类</em> </strong>列表将存储每个图像的类编号。</p><p id="fb36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一行中，我们将打开 CSV 文件。</p><p id="8bca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一行使我们的数据随机化，这将防止模型过度适应特定的类。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="faf9" class="lv lw it oa b gy oe of l og oh">    for i, row in rows.iterrows():<br/>        img_class = row["ClassId"]<br/>        img_path = row["Path"]</span><span id="e61e" class="lv lw it oa b gy oi of l og oh">        image = os.path.join(data, img_path)</span></pre><p id="973d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">for 循环遍历所有行。<strong class="lb iu"> <em class="nm">。iterrows() </em> </strong>函数为每一行返回一个索引(第一行是 0，然后是 1，2，3，…)。直到最后一行)。</p><p id="b204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<strong class="lb iu"> <em class="nm"> ClassId </em> </strong>列获取图像的类，从<strong class="lb iu"> <em class="nm">路径</em> </strong>列获取图像数据。</p><p id="7fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们从电子表格中获取图像的路径，并将其与数据集的路径相结合，以获得图像的完整路径</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="16fa" class="lv lw it oa b gy oe of l og oh">        image = cv2.imread(image)<br/>        image_rs = cv2.resize(image, (img_size, img_size), 3)</span><span id="722c" class="lv lw it oa b gy oi of l og oh">        R, G, B = cv2.split(image_rs)</span><span id="ab62" class="lv lw it oa b gy oi of l og oh">        img_r = cv2.equalizeHist(R)<br/>        img_g = cv2.equalizeHist(G)<br/>        img_b = cv2.equalizeHist(B)</span><span id="76ad" class="lv lw it oa b gy oi of l og oh">        new_image = cv2.merge((img_r, img_g, img_b))</span></pre><p id="f1cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们读取图像数组(将它从数字数组转换成实际的图片，以便我们可以调整它的大小)。然后，我们将图像尺寸调整为 32 X 32 X 3，(如果所有图像的尺寸都相同，那么训练模型的速度会更快)。</p><p id="b28d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来的 5 行执行直方图均衡，这是一种提高图像对比度的均衡技术。如果您有兴趣了解直方图均衡化的更多信息，请单击此处的<a class="ae ky" href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization" rel="noopener ugc nofollow" target="_blank"/></p><p id="dc8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:这段代码仍然在前面代码块的 for 循环中</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="6e54" class="lv lw it oa b gy oe of l og oh">        if i % 500 == 0:<br/>            print(f"loaded: {i}")</span><span id="7523" class="lv lw it oa b gy oi of l og oh">        images.append(new_image)<br/>        classes.append(img_class)</span><span id="f0d8" class="lv lw it oa b gy oi of l og oh">    X = np.array(images)<br/>    y = np.array(images)<br/>    <br/>    return (X, y)</span></pre><p id="0b77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仍然在 for 循环中，我们将编写一个 if 语句，打印我们已经加载了多少图像。这条语句将每 500 幅图像打印一次，只是为了让我们知道我们的函数实际上在工作。</p><p id="9e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将刚刚从数据集中提取的图像添加到之前定义的列表中。</p><p id="4a5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在 for 循环之外，我们将把<strong class="lb iu"> <em class="nm">图像</em> </strong>和<strong class="lb iu"> <em class="nm">类</em> </strong>列表重新定义为 Numpy 数组。这是为了我们以后可以在阵列上执行操作。</p><p id="2f29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，当我们从数据集中提取完所有图像后，我们将返回元组中的<strong class="lb iu"> <em class="nm">图像</em> </strong>和<strong class="lb iu"> <em class="nm">类</em> </strong>列表。</p><h2 id="adf1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">定义超参数</h2><p id="01f6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">超参数是神经网络无法学习的参数。它们必须由程序员在培训前明确定义</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="30bc" class="lv lw it oa b gy oe of l og oh">epochs = 20<br/>learning_rate = 0.001<br/>batch_size = 64</span></pre><p id="7dda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的第一个超参数(我会用缩写 HYP)，<strong class="lb iu"> <em class="nm"> epochs </em> </strong>，告诉神经网络应该完成多少次完整的训练过程。在这种情况下，神经网络将训练自己 20 次(检查所有 50，000 张图像，并用 12，000 张测试图像验证自己 20 次)！</p><p id="5bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">学习率告诉我们每次会更新多少权重。学习率往往在 0 到 1 之间。</p><p id="0f94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">批量大小告诉我们神经网络将一次循环通过多少图像。计算机不可能一次循环通过所有 50，000 张图像，它会崩溃的。这就是为什么我们有批量大小。</p><h2 id="31ee" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">载入数据</h2><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="6219" class="lv lw it oa b gy oe of l og oh">train_data = r"D:\users\new owner\Desktop\TKS\Christmas Break\gtsrb-german-traffic-sign\Train.csv"<br/>test_data = r"D:\users\new owner\Desktop\TKS\Christmas Break\gtsrb-german-traffic-sign\Test.csv"</span><span id="5083" class="lv lw it oa b gy oi of l og oh">(trainX, trainY) = load_data(train_data)<br/>(testX, testY) = load_data(test_data)</span></pre><p id="5b49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将定义测试和训练数据集的路径，使用我们以前用来定义数据集路径的相同方法</p><p id="6c94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将使用我们的<strong class="lb iu"> <em class="nm"> load_data </em> </strong>函数加载训练和测试数据。</p><p id="9215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把<strong class="lb iu"> <em class="nm">图片</em> </strong>列表存储在变量<strong class="lb iu"><em class="nm"/></strong>中，把<strong class="lb iu"> <em class="nm">类</em> </strong>列表存储在<strong class="lb iu"> <em class="nm"> trainY </em> </strong>变量中，并对<strong class="lb iu"><em class="nm">【testX】</em></strong>和<strong class="lb iu"> <em class="nm"> testY 进行同样的操作。</em>T47】</strong></p><p id="4eed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:这一步可能需要一段时间，取决于你电脑的规格。我的花了 10-15 分钟。</p><h2 id="b2a1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">为培训准备数据</h2><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="93a3" class="lv lw it oa b gy oe of l og oh">print("UPDATE: Normalizing data")<br/>trainX = train_X.astype("float32") / 255.0<br/>testX = test_X.astype("float32") / 255.0</span><span id="b38c" class="lv lw it oa b gy oi of l og oh">print("UPDATE: One-Hot Encoding data")<br/>num_labels = len(np.unique(train_y))<br/>trainY = to_categorical(trainY, num_labels)<br/>testY = to_categorical(testY, num_labels)</span><span id="0b58" class="lv lw it oa b gy oi of l og oh">class_totals = trainY.sum(axis=0)<br/>class_weight = class_totals.max() / class_totals</span></pre><p id="3a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们要对数据进行归一化处理。这使得我们可以将数据中的值缩小到 0 到 1 之间，而之前的值在 0 到 255 之间。</p><p id="4141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将<strong class="lb iu">一次性编码</strong>测试和训练标签。本质上，一键编码是用二进制值(1 和 0)而不是分类值(“红色”或“蓝色”)来表示每个类的一种方式。这是通过创建一个主对角线为 1，其余值为 0 的对角矩阵来实现的。矩阵的维数等于类的数量(如果有 20 个类，则矩阵是 20×20 的矩阵)。在矩阵中，每行代表一个不同的类，因此每个类都有其唯一的代码。如果你想了解更多关于一键编码的知识，<a class="ae ky" href="https://machinelearningmastery.com/why-one-hot-encode-data-in-machine-learning/" rel="noopener ugc nofollow" target="_blank">这里有</a>一个很好的资源</p><p id="00c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将通过给每个等级分配一个权重来说明等级中的不平等。</p><h1 id="c7a3" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">构建模型</h1><p id="bd40" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在是时候构建实际的 CNN 架构了。首先，让我们导入必要的库和模块:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="541d" class="lv lw it oa b gy oe of l og oh">import tensorflow as tf<br/>from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import BatchNormalization<br/>from tensorflow.keras.layers import Conv2D<br/>from tensorflow.keras.layers import MaxPooling2D<br/>from tensorflow.keras.layers import Activation<br/>from tensorflow.keras.layers import Flatten<br/>from tensorflow.keras.layers import Dropout<br/>from tensorflow.keras.layers import Dense</span></pre><p id="9411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们导入 Tensorflow，这是 Python 中的一个框架，允许我们构建 ML 模型，我们从 Tensorflow 导入 Keras，这进一步简化了我们的模型！之后，我们导入一系列不同的图层来构建模型。如果你想了解更多关于这些层的具体功能，请浏览我在 CNN 上的文章。</p><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/a-simple-guide-to-convolutional-neural-networks-751789e7bd88"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">卷积神经网络的简单指南</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">卷积神经网络揭秘没有任何花哨的技术术语！</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="ol l nh ni nj nf nk ks mw"/></div></div></a></div><p id="0052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始构建模型之前，我想指出没有“合适的”方法来构建模型。你的 CNN 没有固定的层数、尺寸或层数类型。你应该试着用它来看看哪一个能给你最好的准确度。我给你一个最准确的。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="03e6" class="lv lw it oa b gy oe of l og oh">class RoadSignClassifier:<br/>    def createCNN(width, height, depth, classes):<br/>        model = Sequential()<br/>        inputShape = (height, width, depth)</span></pre><p id="b943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们要创建一个类，名为<strong class="lb iu"><em class="nm">RoadSignClassifier</em></strong>(任何名字都可以)。在该类中，有一个函数，<strong class="lb iu"> <em class="nm"> createCNN，</em> </strong>接受 4 个参数。我们将使用顺序 API，它允许我们逐层创建模型。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="090c" class="lv lw it oa b gy oe of l og oh">        model.add(Conv2D(8, (5, 5), input_shape=inputShape,      activation="relu"))<br/>        model.add(MaxPooling2D(pool_size=(2, 2)))</span></pre><p id="a0d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的第一个卷积层。我们定义了输出的维度(8 X 8 X 3)，并使用了激活函数“relu”。我们继续使用 Conv2D — MaxPooling2D 序列 2 次以上。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="cb6e" class="lv lw it oa b gy oe of l og oh">        model.add(Conv2D(16, (3, 3), activation="relu"))<br/>        model.add(BatchNormalization())<br/>        model.add(Conv2D(16, (3, 3), activation="relu"))<br/>        model.add(BatchNormalization())<br/>        model.add(MaxPooling2D(pool_size=(2, 2)))<br/> <br/>        model.add(Conv2D(32, (3, 3), padding="same", activation="relu"))<br/>        model.add(BatchNormalization())<br/>        model.add(Conv2D(32, (3, 3), padding="same", activation="relu"))<br/>        model.add(BatchNormalization())</span></pre><p id="3656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和上次一样，除了这次我们包括<strong class="lb iu">批量归一化。</strong>只是加速训练而已。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="13ee" class="lv lw it oa b gy oe of l og oh">        model.add(Flatten())<br/>        model.add(Dropout(0.5))<br/>        model.add(Dense(512, activation="relu"))</span><span id="eada" class="lv lw it oa b gy oi of l og oh">        model.add(Dense(classes, activation="softmax"))<br/>        return model</span></pre><p id="213b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们展平最终卷积层的输出，执行一次丢弃，然后进入最终的密集层。最终密集层的输出等于我们拥有的类的数量。</p><p id="5999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这基本上就是构建模型的全部内容。是时候继续前进了！</p><h1 id="dd3d" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">训练模型</h1><p id="5706" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在是有趣的部分(实际上这是我们必须等待 30 分钟模型训练 lol 的部分)。是时候训练我们的模型识别路标了！</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="caa1" class="lv lw it oa b gy oe of l og oh">data_aug = ImageDataGenerator(<br/>rotation_range=10,<br/>zoom_range=0.15,<br/>width_shift_range=0.1,<br/>height_shift_range=0.1,<br/>shear_range=0.15,<br/>horizontal_flip=False,<br/>vertical_flip=False)</span></pre><p id="0395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们正在执行<strong class="lb iu">数据增强</strong>。数据扩充在我们的数据集中创建图像的修改版本。它允许我们向数据集添加图像，而无需我们收集新的图像。在 Keras 中，我们使用<strong class="lb iu"><em class="nm">imagedata generator</em></strong>模块来执行数据扩充。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="8c54" class="lv lw it oa b gy oe of l og oh">model = RoadSignClassifier.createCNN(width=32, height=32, depth=3, classes=43)<br/>optimizer = Adam(lr=learning_rate, decay=learning_rate / (epochs))</span></pre><p id="3465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一行定义了我们的模型。我们使用类<strong class="lb iu"> <em class="nm"> RoadSignClassifier，</em> </strong>并定义类的宽度、高度、深度和数量。</p><p id="bf9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二行中，我们创建了我们的优化器，在本例中是<strong class="lb iu"> Adam </strong>优化器。我们将学习率初始化为之前设置的值(0.001)，我们还将学习率设置为在每个时期减少(这是<a class="ae ky" href="https://machinelearningmastery.com/how-to-reduce-overfitting-in-deep-learning-with-weight-regularization/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">衰减</strong> </a> <strong class="lb iu"> </strong>参数，它减少了过度拟合)。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="c18b" class="lv lw it oa b gy oe of l og oh">model.compile(optimizer=optimizer, loss="categorical_crossentropy", metrics=["accuracy"])</span><span id="b20a" class="lv lw it oa b gy oi of l og oh">fit = model.fit_generator(<br/>    data_aug.flow(train_X, trainY, batch_size=batch_size), <br/>    epochs=epochs,<br/>    validation_data=(test_X, testY),<br/>    class_weight=class_weight,<br/>    verbose=1)</span></pre><p id="f897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一行编译模型。我们创建模型并定义优化器、损失和时期数。</p><p id="9e02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二行，我们装配模型(这是培训发生的地方)。我们的<strong class="lb iu"><em class="nm">data _ aug . flow</em></strong>方法对我们之前定义的图像应用增强。<strong class="lb iu"> <em class="nm">历元的数量</em> </strong>被设置为 20。对于<strong class="lb iu">验证数据</strong>，我们使用我们的测试数据。<strong class="lb iu"> verbose </strong>被设置为 1，这意味着 Keras 将在您进行训练时显示模型的进度。</p><p id="60a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您已经完成了模型代码的编写。是时候运行它了。运行一段时间后，您应该会得到如下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/13ec67a867f4c8eff0d638d96cbce3bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFA098nDgGltTvaafTYjeQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">前三个时期(在第三个时期，您的准确度应该是 70–80%)</p></figure><p id="bfe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在您完成了所有的 epochs 之后，您应该会得到类似如下的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/0e70d915a3c4111ee7663d17ebe65583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hH9Rp0A8Inn8lisx_7p1Mg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最后三个纪元(你的准确率应该超过 90%)</p></figure><p id="db98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的准确率至少要达到<strong class="lb iu"> 90%。</strong>如果没有，就去玩玩模型架构。最终，您的模型将返回大约 90%或更高的准确率。</p><h1 id="cac2" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">酷！</h1><p id="adf7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在你完成了你的分类器！感觉不错吧！好了，今天就到这里。希望你从这篇文章中学到了一些东西！如果你遇到什么困难，可以发邮件到 nushainef@gmail.com 给我，我会尽力帮助你。祝你的 ML 之旅好运。</p><h1 id="8858" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">其他很好的选择</h1><p id="fad2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果这个教程对你没有吸引力，或者你只是在寻找另一个教程，这里有另一个很棒的教程，我发现它真的很有用！</p><div class="mt mu gp gr mv mw"><a href="https://www.pyimagesearch.com/2019/11/04/traffic-sign-classification-with-keras-and-deep-learning/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">基于 Keras 和深度学习的交通标志分类——PyImageSearch</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">在本教程中，您将学习如何训练自己的交通标志分类器/识别器能够获得 95%以上的…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">www.pyimagesearch.com</p></div></div><div class="nf l"><div class="on l nh ni nj nf nk ks mw"/></div></div></a></div></div></div>    
</body>
</html>