<html>
<head>
<title>Movie Recommender System: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">电影推荐系统(二)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/movie-recommender-system-52e4651f3ae7?source=collection_archive---------14-----------------------#2020-03-28">https://towardsdatascience.com/movie-recommender-system-52e4651f3ae7?source=collection_archive---------14-----------------------#2020-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8eb9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何找到推荐给用户的最佳商品数量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/740386d0aaac4cec1d7ebf9825183fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lAglpYtDQ0d5c1JQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@georgiavagim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔治亚·瓦格姆</a>拍摄</p></figure><h1 id="72ba" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">' k '建议</h1><p id="c72a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当在推荐系统中推荐项目时，我们非常感兴趣的是仅向用户推荐前<strong class="lt iu"> K </strong>个项目，并且发现使用了最佳的数量召回和精确度。</p><h2 id="ac9d" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">K时的召回率和精确度</h2><p id="87d2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu"> Precision: </strong>尝试回答<strong class="lt iu">“从字面上看，模型的肯定识别的比例是多少？”</strong></p><blockquote class="mz"><p id="6abd" class="na nb it bd nc nd ne nf ng nh ni mm dk translated">真阳性/(真阳性+假阳性)。</p></blockquote><p id="9f62" class="pw-post-body-paragraph lr ls it lt b lu nj ju lw lx nk jx lz ma nl mc md me nm mg mh mi nn mk ml mm im bi translated"><strong class="lt iu">回忆:</strong>尝试回答<strong class="lt iu">“模型正确知道实际阳性的比例是多少？”</strong></p><blockquote class="mz"><p id="b32c" class="na nb it bd nc nd ne nf ng nh ni mm dk translated"><em class="no">真阳性/(真阳性+假阴性)</em></p></blockquote><p id="6ae7" class="pw-post-body-paragraph lr ls it lt b lu nj ju lw lx nk jx lz ma nl mc md me nm mg mh mi nn mk ml mm im bi translated">在某些情况下，我们可能会意识到我们需要关注<strong class="lt iu">回忆</strong>或<strong class="lt iu">精确度。</strong>例如，在筛查一个人是否感染了某种疾病时，召回将是可选择的。</p><p id="88df" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">查全率和查准率是经典的评估指标，用于评估二进制指标，因此我们必须将我们的评级(从(1–5)转换为二进制问题，其中0表示与<strong class="lt iu">相关的</strong>，1表示与<strong class="lt iu">无关的</strong> <strong class="lt iu">相关的</strong>项目。</p><p id="8cd7" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated"><strong class="lt iu">转换为二进制</strong></p><p id="c765" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">为了进行转换，我们必须选择一个任意的<strong class="lt iu"/><strong class="lt iu">值</strong>，根据该值，我们可以说上面的任何评级都被认为是相关的。有许多选择该值的方法，但现在，我们将选择<strong class="lt iu"> 3.5 </strong>作为<strong class="lt iu">阈值</strong>，这意味着任何高于3.5的真实评级将被视为相关，低于3.5的将被视为不相关。</p><p id="3f15" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated"><strong class="lt iu">相关和推荐的定义</strong></p><p id="f434" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated"><strong class="lt iu">相关:</strong>真实等级&gt; = 3.5</p><p id="0cdc" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated"><strong class="lt iu">无关:</strong>真实评级&lt; 3.5</p><p id="6a81" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated"><strong class="lt iu">推荐项目:</strong>预测评分&gt; = 3.5</p><p id="7db5" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated"><strong class="lt iu">不推荐项目:</strong>预测等级&gt; = 3.5</p><p id="8dba" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">在我们想要获得两者混合的情况下，我们可以使用<strong class="lt iu"> F1 </strong>分数，它基本上是精确度和召回率的调和平均值。</p><p id="a7e4" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated"><strong class="lt iu"> F1得分= 2 <em class="nu">(精度* </em>召回)/(精度+召回)</strong></p><p id="d4e4" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">下面的函数计算精度和召回和F1分数，如上所述。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="cebf" class="mn la it nw b gy oa ob l oc od"><em class="nu">#Calculate TP,FP,TN,FN at every threshold level (0.0 - 5.0)</em></span><span id="ef82" class="mn la it nw b gy oe ob l oc od">final = []</span><span id="2b13" class="mn la it nw b gy oe ob l oc od"><strong class="nw iu">for</strong> threshold <strong class="nw iu">in</strong> np.arange(0, 5.5, 0.5):<br/>  tp=0<br/>  fn=0<br/>  fp=0<br/>  tn=0<br/>  temp = []</span><span id="f38f" class="mn la it nw b gy oe ob l oc od">  <strong class="nw iu">for</strong> uid, _, true_r, est, _ <strong class="nw iu">in</strong> predictions:<br/>    <strong class="nw iu">if</strong>(true_r&gt;=threshold):<br/>      <strong class="nw iu">if</strong>(est&gt;=threshold):<br/>        tp = tp+1<br/>      <strong class="nw iu">else</strong>:<br/>        fn = fn+1<br/>    <strong class="nw iu">else</strong>:<br/>      <strong class="nw iu">if</strong>(est&gt;=threshold):<br/>        fp = fp+1<br/>      <strong class="nw iu">else</strong>:<br/>        tn = tn+1   </span><span id="8bc0" class="mn la it nw b gy oe ob l oc od">    <strong class="nw iu">if</strong> tp == 0:<br/>      precision = 0<br/>      recall = 0<br/>      f1 = 0<br/>    <strong class="nw iu">else</strong>:<br/>      precision = tp / (tp + fp)<br/>      recall = tp / (tp + fn)<br/>      f1 = 2 * (precision * recall) / (precision + recall)  </span><span id="55aa" class="mn la it nw b gy oe ob l oc od">  temp = [threshold, tp,fp,tn ,fn, precision, recall, f1]<br/>  final.append(temp)</span><span id="4524" class="mn la it nw b gy oe ob l oc od">results = pd.DataFrame(final)<br/>results.rename(columns={0:'threshold', 1:'tp', 2: 'fp', 3: 'tn', 4:'fn', 5: 'Precision', 6:'Recall', 7:'F1'}, inplace=<strong class="nw iu">True</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/e66f46182e1dbe0ba89992ad5089b5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*ZejiXITzwpVG0cSDiWUytA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果表的屏幕截图</p></figure><p id="9ccc" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">根据上述结果，阈值的最佳值为<strong class="lt iu"> 2.5 </strong>。</p><p id="f77a" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated"><strong class="lt iu">决定‘K’</strong></p><p id="d8e8" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">在推荐系统中，我们感兴趣的是向用户显示前N个项目，因此最好是计算前N个值的精确度和召回率，而不是计算所有项目。</p><p id="fd1f" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">下一步是找到最佳K值，为了找到它，我们必须首先计算阈值为2.5的所有K值(2–10)的精度和召回率。</p><p id="58a3" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">下面是计算<strong class="lt iu">精度和召回@ K. </strong>的函数</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="112e" class="mn la it nw b gy oa ob l oc od"><em class="nu">'''Return precision and recall at k metrics for each user.'''</em></span><span id="734f" class="mn la it nw b gy oe ob l oc od">    <em class="nu"># First map the predictions to each user.</em><br/>    user_est_true = defaultdict(list)<br/>    <strong class="nw iu">for</strong> uid, _, true_r, est, _ <strong class="nw iu">in</strong> predictions:<br/>        user_est_true[uid].append((est, true_r))</span><span id="5718" class="mn la it nw b gy oe ob l oc od">    precisions = dict()<br/>    recalls = dict()<br/>    <strong class="nw iu">for</strong> uid, user_ratings <strong class="nw iu">in</strong> user_est_true.items():</span><span id="8877" class="mn la it nw b gy oe ob l oc od">        <em class="nu"># Sort user ratings by estimated value</em><br/>        user_ratings.sort(key=<strong class="nw iu">lambda</strong> x: x[0], reverse=<strong class="nw iu">True</strong>)</span><span id="de61" class="mn la it nw b gy oe ob l oc od">        <em class="nu"># Number of relevant items</em><br/>        n_rel = sum((true_r &gt;= threshold) <strong class="nw iu">for</strong> (_, true_r) <strong class="nw iu">in</strong> user_ratings)</span><span id="90a6" class="mn la it nw b gy oe ob l oc od">        <em class="nu"># Number of recommended items in top k</em><br/>        n_rec_k = sum((est &gt;= threshold) <strong class="nw iu">for</strong> (est, _) <strong class="nw iu">in</strong> user_ratings[:k])</span><span id="6bf7" class="mn la it nw b gy oe ob l oc od">        <em class="nu"># Number of relevant and recommended items in top k</em><br/>        n_rel_and_rec_k = sum(((true_r &gt;= threshold) <strong class="nw iu">and</strong> (est &gt;= threshold))<br/>                              <strong class="nw iu">for</strong> (est, true_r) <strong class="nw iu">in</strong> user_ratings[:k])</span><span id="7f1d" class="mn la it nw b gy oe ob l oc od">        <em class="nu"># Precision@K: Proportion of recommended items that are relevant</em><br/>        precisions[uid] = n_rel_and_rec_k / n_rec_k <strong class="nw iu">if</strong> n_rec_k != 0 <strong class="nw iu">else</strong> 1</span><span id="6fae" class="mn la it nw b gy oe ob l oc od">        <em class="nu"># Recall@K: Proportion of relevant items that are recommended</em><br/>        recalls[uid] = n_rel_and_rec_k / n_rel <strong class="nw iu">if</strong> n_rel != 0 <strong class="nw iu">else</strong> 1</span><span id="ce95" class="mn la it nw b gy oe ob l oc od">    <em class="nu">#tp = n_rel_and_rec_k</em><br/>    <em class="nu">#fn =  n_rel - tp</em><br/>    <em class="nu">#fp = n_rec_k - tp</em><br/>    <strong class="nw iu">return</strong> precisions, recalls</span></pre><p id="d824" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">现在，让我们调用上面定义的函数，并对所有用户进行平均。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="8526" class="mn la it nw b gy oa ob l oc od">results=[] <strong class="nw iu">for</strong> i <strong class="nw iu">in</strong> range(2, 11):  <br/>   precisions, recalls = precision_recall_at_k(predictions, k=i, threshold=2.5)</span><span id="91d8" class="mn la it nw b gy oe ob l oc od"><em class="nu"># Precision and recall can then be averaged over all users</em> <br/>   prec = sum(prec <strong class="nw iu">for</strong> prec <strong class="nw iu">in</strong> precisions.values()) / len(precisions)</span><span id="70a2" class="mn la it nw b gy oe ob l oc od">rec = sum(rec <strong class="nw iu">for</strong> rec <strong class="nw iu">in</strong> recalls.values()) / len(recalls)           <br/>   results.append({'K': i, 'Precision': prec, 'Recall': rec})         <br/>   results</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c8df3a8ec1df07c400a863ff199855b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*5Tsd4sPwnfDHw1llpnqKFA.png"/></div></figure><p id="b37b" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">让我们画出这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/71846c4ac60e487cd6d06b4840939611.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*06mzKuxKLcFAomgXY40hZQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1</p></figure><p id="fddb" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">如图所示，精度在<strong class="lt iu">‘4’，</strong>之后显著下降，因此我们将K的值视为<strong class="lt iu"> 4 </strong>。</p><p id="0fb5" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated"><strong class="lt iu">瞧，完成了！！</strong></p><h1 id="1cf6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">是时候给用户推荐电影了</h1><p id="0680" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们知道了要提供的最佳推荐数量，是时候向用户提供推荐了。为此，我们必须预测用户尚未观看的电影的收视率。</p><p id="7662" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">首先，我们将在电影镜头数据集上训练一个SVD算法。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="19c5" class="mn la it nw b gy oa ob l oc od"><em class="nu">data = Dataset.load_builtin('ml-100k')</em><br/>trainset = data.build_full_trainset()   <em class="nu">#Build on entire data set</em><br/>algo = SVD(n_factors=factors, n_epochs=epochs, lr_all=lr_value, reg_all=reg_value)<br/>algo.fit(trainset)</span></pre><p id="f773" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">然后预测不在训练集中的所有对(u，I)的评级。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="3267" class="mn la it nw b gy oa ob l oc od">testset = trainset.build_anti_testset()</span><span id="2743" class="mn la it nw b gy oe ob l oc od"><em class="nu">#Predicting the ratings for testset</em><br/>predictions = algo.test(testset)</span></pre><p id="4bfe" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">现在让我们对所有评级进行排序</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="2c49" class="mn la it nw b gy oa ob l oc od"><strong class="nw iu">def</strong> get_all_predictions(predictions):<br/>    <br/>    <em class="nu"># First map the predictions to each user.</em><br/>    top_n = defaultdict(list)    <br/>    <strong class="nw iu">for</strong> uid, iid, true_r, est, _ <strong class="nw iu">in</strong> predictions:<br/>        top_n[uid].append((iid, est))</span><span id="84a6" class="mn la it nw b gy oe ob l oc od">    <em class="nu"># Then sort the predictions for each user</em><br/>    <strong class="nw iu">for</strong> uid, user_ratings <strong class="nw iu">in</strong> top_n.items():<br/>        user_ratings.sort(key=<strong class="nw iu">lambda</strong> x: x[1], reverse=<strong class="nw iu">True</strong>)</span><span id="8ebc" class="mn la it nw b gy oe ob l oc od">    <strong class="nw iu">return</strong> top_n</span><span id="22eb" class="mn la it nw b gy oe ob l oc od">all_pred = get_all_predictions(predictions)</span></pre><h2 id="7db0" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">因为我们有所有预测的评级，所以我们将数据集子集化为每个用户的仅前K部电影(K = 4)。</h2><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="6243" class="mn la it nw b gy oa ob l oc od">n = 4<br/><strong class="nw iu">for</strong> uid, user_ratings <strong class="nw iu">in</strong> all_pred.items():<br/>    user_ratings.sort(key=<strong class="nw iu">lambda</strong> x: x[1], reverse=<strong class="nw iu">True</strong>)<br/>    all_pred[uid] = user_ratings[:n]</span><span id="48f1" class="mn la it nw b gy oe ob l oc od">tmp = pd.DataFrame.from_dict(all_pred)<br/>tmp_transpose = tmp.transpose()</span></pre><p id="795a" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">现在我们有了一个数据框，其中包含了推荐给每个用户的前4部电影。</p><p id="525f" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">让我们创建一个为给定用户返回推荐电影的函数:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="8e69" class="mn la it nw b gy oa ob l oc od"><strong class="nw iu">def</strong> get_predictions(user_id):<br/>    results = tmp_transpose.loc[user_id]<br/>    <strong class="nw iu">return</strong> results</span></pre><p id="f2d4" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">让我们尝试一个例子，并为用户<strong class="lt iu"> 67 </strong>找到建议</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="c2d6" class="mn la it nw b gy oa ob l oc od">user_id=67<br/>results = get_predictions(user_id)<br/>results</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/f94acdb7879714b391595d61280082ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*oam-dbTfyTfxl0vMu22nJw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对用户的建议_id-67</p></figure><p id="1217" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">上图显示了用户67的前“4”个推荐，“电影id预测评级”。但是我们只需要电影而不需要收视率，所以让我们从结果中提取电影id，然后从电影表中获取电影细节</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="d1dc" class="mn la it nw b gy oa ob l oc od">recommended_movie_ids=[]<br/><strong class="nw iu">for</strong> x <strong class="nw iu">in</strong> range(0, n):<br/>    recommended_movie_ids.append(results[x][0])</span><span id="9130" class="mn la it nw b gy oe ob l oc od">movies = pd.read_csv('data/movies.csv')<br/>recommended_movies = movies[movies['movieId'].isin(recommended_movie_ids)]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e03257079424989883abb5f6db1fe9f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*GiTBK2EHT7YRS_i0izu9qQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">推荐电影id的电影详情</p></figure><p id="dcc3" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">现在，我们可以将结果与用户历史进行比较，看看这些推荐有多相关。</p><p id="ecc5" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">以下是用户67评价最高的电影</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/537bc5948556a9db8c6028ca9d580186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*-svlQ6bzl4yL8_1utlL4Eg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户评分最高的电影</p></figure><p id="1146" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">由于用户的历史告诉我们，用户大多喜欢剧情电影，而我们正在推荐所有的剧情电影，这意味着我们正在向用户推荐合适的电影。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="a811" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">看起来你很喜欢这篇文章！</p><ul class=""><li id="2435" class="os ot it lt b lu np lx nq ma ou me ov mi ow mm ox oy oz pa bi translated">你刚刚学会了在K计算精度和召回，然后推荐K部电影，推荐给用户多少部电影。</li><li id="d093" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/movie-recommender-system-part-1-7f126d2f90e2?source=friends_link&amp;sk=b28e7ae7f1cf97b0a7a59d0aa8c692ff">在这里</a>你可以阅读如何使用<strong class="lt iu"> Surprise </strong>库在显式数据上构建模型。</li><li id="e21b" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated">完整的代码，你可以在这里找到Jupyter笔记本<a class="ae ky" href="https://github.com/divensambhwani/MovieLens-100K_Recommender-System/blob/master/MovieLens-100K-Recommeder%20System-SVD.ipynb" rel="noopener ugc nofollow" target="_blank"/>。</li></ul><p id="d5c8" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">编码快乐！</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="1253" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">如果你有任何想法或建议，请不吝赐教。你也可以通过<a class="ae ky" href="https://www.linkedin.com/in/divensambhwani/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><h2 id="66af" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">参考资料:</h2><p id="e61e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">[1]<a class="ae ky" href="https://medium.com/@m_n_malaeb/recall-and-precision-at-k-for-recommender-systems-618483226c54" rel="noopener">https://medium . com/@ m _ n _ malaeb/recall-and-precision-at-k-for-recommender-systems-618483226 c54</a></p><p id="8b7a" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">[2]<a class="ae ky" rel="noopener" target="_blank" href="/beyond-accuracy-precision-and-recall-3da06bea9f6c">https://towards data science . com/beyond-accuracy-precision-and-recall-3da 06 bea 9 f6c</a></p><p id="8a71" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated">[3]<a class="ae ky" href="https://developers.google.com/machine-learning/crash-course/classification/precision-and-recall?hl=ru" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/machine-learning/crash-course/classification/precision-and-recall？hl=ru </a></p><p id="5642" class="pw-post-body-paragraph lr ls it lt b lu np ju lw lx nq jx lz ma nr mc md me ns mg mh mi nt mk ml mm im bi translated"><a class="ae ky" href="https://surprise.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">https://surprise.readthedocs.io/en/stable/</a></p></div></div>    
</body>
</html>