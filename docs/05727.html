<html>
<head>
<title>Using TensorFlow Go to serve an object detection model with a web service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 TensorFlow Go 通过 web 服务服务于对象检测模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-tensorflow-go-to-serve-an-object-detection-model-with-a-web-service-7a47a0cc3d7d?source=collection_archive---------45-----------------------#2020-05-12">https://towardsdatascience.com/using-tensorflow-go-to-serve-an-object-detection-model-with-a-web-service-7a47a0cc3d7d?source=collection_archive---------45-----------------------#2020-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4893" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 TensorFlow Go 构建 web 服务来服务 MobileNet 对象检测模型。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cb4fe5a05edbaa5cadb7e04d64db0175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x0wtD-upE3S75kyQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jannisbrandt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">詹尼斯·布兰德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="42d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">张量流这个术语超出了 Python 和神经网络的范畴。在这个时髦的词背后，有一个由几个框架、项目甚至硬件组成的完整生态系统。其中一个项目是<strong class="lb iu"> TensorFlow Go </strong>。这个 TensorFlow API for Go 擅长在 Go 程序中加载和部署模型，这些模型是用 Python 对应物创建的。在本教程中，我们将看到一个这样的例子。这里的目标是在 Go 中创建一个 web 服务器，为 TensorFlow 中训练的对象检测模型提供服务。</p><h1 id="5f67" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">安装 TensorFlow Go</h1><p id="f583" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">安装 TensorFlow Go 需要使用下载软件包</p><p id="5702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">$ go get github.com/tensorflow/tensorflow/tensorflow/go</code></p><p id="25e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您需要安装 TensorFlow C 库。安装起来没那么简单，为了避免侧钻，这里就不讨论了。你可以在 https://www.tensorflow.org/install/lang_c<a class="ae ky" href="https://www.tensorflow.org/install/lang_c" rel="noopener ugc nofollow" target="_blank">找到说明。</a></p><h1 id="0258" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">项目的设计</h1><p id="6819" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于第一次迭代，我只向项目中添加一个对象检测模型。然而，我将这些功能实现为包，以防将来我决定添加额外的模型。如果发生这种情况，我将重用部分代码或将其他部分重构为接口。</p><h1 id="0bbb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模型</h1><p id="a470" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将服务的模型是在从<a class="ae ky" href="http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_coco_2018_01_28.tar.gz" rel="noopener ugc nofollow" target="_blank">http://download . tensor flow . org/models/object _ detection/SSD _ MobileNet _ v1 _ COCO _ 2018 _ 01 _ 28 . tar . gz</a>获得的 COCO 数据集上训练的 SSD MobileNet 对象检测模型。“但是胡安，MobileNet，SSD，还有 COCO。这是什么意思？”很高兴你问了！我将从 MobileNet 开始简要解释这些术语。</p><p id="d049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MobileNet ( <a class="ae ky" href="https://arxiv.org/abs/1704.04861" rel="noopener ugc nofollow" target="_blank"> Howard et al. </a>)是一个轻型机器学习模型家族，以精度换取速度和性能。顾名思义，MobileNet 设计用于移动或嵌入式设备。SSD，代表单次多盒检测器(<a class="ae ky" href="https://arxiv.org/abs/1512.02325" rel="noopener ugc nofollow" target="_blank">刘等</a>)，是指使用单个神经网络来检测对象的方法。与这种“单镜头”方法相对应的是一种架构，它使用一个称为“提议生成器”的额外组件来查找图像的感兴趣区域。最后，我们有 COCO，它是“上下文中常见对象”的缩写(<a class="ae ky" href="https://arxiv.org/pdf/1405.0312.pdf" rel="noopener ugc nofollow" target="_blank">林等人</a>)，用于训练模型的数据集。COCO 数据集是一个超过 200，000 个标记图像的集合，这些图像分布在 90 个类别中，包括“鸟”、“猫”、“人”和“车”。"</p><h1 id="ae37" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">服务</h1><p id="dca9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将构建的服务有一个端点——<code class="fe ms mt mu mv b">predict</code>——它将图像的路径作为参数。它的响应是一个 JSON，包含以下字段:</p><ul class=""><li id="b54c" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">detections</code>:被检测对象的数组，包括以下对象:<code class="fe ms mt mu mv b">score</code>、<code class="fe ms mt mu mv b">box</code>和<code class="fe ms mt mu mv b">label</code>。</li><li id="6299" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">score</code>:检测的置信度得分。</li><li id="3922" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">box</code>:检测对象的边框(<code class="fe ms mt mu mv b">[yMin, xMin, yMax, xMax]</code>)。这个数字不是检测的像素位置。相反，返回值是相对于图像的宽度和长度的位置。例如，在大小为[400，200]的图像中，位于其垂直中心的对象的<code class="fe ms mt mu mv b">yMin</code>值为 0.5(图 1)。</li><li id="d71b" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">label</code>:被检测对象的 COCO 类。</li><li id="96bf" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">numDetections</code>:检测总数。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/b67f4bfebc582978c492ce641071cba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXzYiTPeRYjGJC5nhbLSkw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。检测到的对象的示例。</p></figure><p id="507c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图 2 给出了一个响应示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/2d0c60a0c11b61a8b9069adafa6a4a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvMFV8roAHSiLnGdj83QsA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。服务的输出。</p></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="38d0" class="lv lw it bd lx ly nt ma mb mc nu me mf jz nv ka mh kc nw kd mj kf nx kg ml mm bi translated">构建服务</h1><h2 id="ddea" class="ny lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">下载模型</h2><p id="fa44" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">从这里下载模型开始教程<a class="ae ky" href="http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_coco_2018_01_28.tar.gz" rel="noopener ugc nofollow" target="_blank">http://download . tensor flow . org/models/object _ detection/SSD _ mobilenet _ v1 _ coco _ 2018 _ 01 _ 28 . tar . gz</a>。然后解压缩文件。在该目录中，您填充了几个文件，其中包括关于模型的元数据、训练配置文件(来自 TensorFlow 的对象检测 API)、检查点等。从所有这些中，您只需要 saved_model/目录。所以复制它，并粘贴到您的工作目录。</p><h2 id="7d81" class="ny lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">加载模型</h2><p id="e5f4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下载完模型后，下一步是将其加载到 TensorFlow Go 中。在工作目录中，创建一个新文件夹，并将其命名为 models。在里面，创建一个文件<em class="ok"> coco_ssd_mobilenet.go </em>。然后添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="ba18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最上面，我们有包的名字，imports，和一个 struct Coco，我们将在其中添加模型。结构之后是文件的路径和创建结构的构造函数。很标准的做法。然后就变得有趣了。</p><p id="6416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该结构的第一个方法<code class="fe ms mt mu mv b">Load()</code>加载模型。它的第一行<code class="fe ms mt mu mv b">tf.LoadSavedModel()</code>，使用模型的路径、一系列<strong class="lb iu">标签</strong>和一个我们目前不需要的<code class="fe ms mt mu mv b">SessionOptions</code>对象作为参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="7b11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，<strong class="lb iu">标签</strong>？那是什么？</p><h2 id="14bc" class="ny lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">SavedModel 标记和签名</h2><p id="0869" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">像我们这样的 TensorFlow SavedModel 可以有多个图。因此，为了识别它们，这些图表与标签相关联。因此，当加载模型时，你需要指定你要使用的图。在这个例子中，我们需要标记“serve”，它预测。要查看 SavedModel 的标签，以及我们即将使用的模型的其他信息，您需要 TensorFlow 安装附带的工具<strong class="lb iu"> saved_model_cli </strong>。要使用它，请执行以下命令:</p><p id="2021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">$ saved_model_cli show --dir PATH/TO/MODEL/ssd_mobilenet_v1_coco_2018_01_28 --all</code></p><p id="4217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的图 3 显示了输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/1f2aff174e78506c5ee00b00c21d1f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATxswNo8YDMj1HWir6DFlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 3。模型的“服务”标签。</p></figure><p id="58d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面是标签“serve”的签名。SavedModel 签名定义了模型的输入和输出。这个模型的输入是一个名为“image_tensor”的张量，其<code class="fe ms mt mu mv b">dtype</code>为<code class="fe ms mt mu mv b">UINT8</code>，输入形状(-1，-1，-1，3)(任意大小的一批彩色图像)。至于输出，它们与我们在 JSON 响应中返回的值相同(detection_boxes、detection_classes、detection_scores 和 num_detections)。</p><p id="4369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关 SavedModel 的更多信息，请访问<a class="ae ky" href="https://www.tensorflow.org/guide/saved_model" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/guide/saved_model</a></p><h2 id="87eb" class="ny lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">阅读标签</h2><p id="0a96" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">加载模型后，下一步是读取标签文件。Coco 模型有 91 个类，因此，模型的输出是 1 到 91 之间的一个数字。但是这个值对用户来说没有意义。如果你给我看，我会说，“这是什么数字？我需要实际的标签。”因此，我将数据集的标签收集在一个名为 labels.txt 的文件中，目标是将模型的输出映射到一个标签:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="a896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是功能<code class="fe ms mt mu mv b">readLabels()</code>。这个函数读取标签文件并将它们作为字符串片段返回。要使用该函数，从<code class="fe ms mt mu mv b">Load()</code>添加对它的调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="38d5" class="ny lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">预测</h2><p id="c453" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在最酷的部分来了:预测。总而言之，预测包括获取输入图像，将其转换为张量，然后将其提供给模型。正如我们在模型的签名中看到的，在预测之后，它产生四个张量<code class="fe ms mt mu mv b">detection_boxes</code>、<code class="fe ms mt mu mv b">detection_classes</code>、<code class="fe ms mt mu mv b">detection_scores</code>和<code class="fe ms mt mu mv b">num_detections</code>。这些值是用户将收到的信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="b281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">Predict()</code>有一个参数<code class="fe ms mt mu mv b">[]byte</code>，代表图像。在函数的第一行，我们将使用<code class="fe ms mt mu mv b">[]byte</code>并使用即将到来的函数<code class="fe ms mt mu mv b">makeTensorFromBytes()</code>将其转换为张量。然后，我们使用<code class="fe ms mt mu mv b">Run()</code>方法和刚刚转换的张量作为输入来执行图形。至于输出，使用一个<code class="fe ms mt mu mv b">[]tf.Output</code>切片，包含模型的所有可能输出。接下来是函数<code class="fe ms mt mu mv b">responses.NewObjectDetectionResponse()</code>将输出值封装在一个结构中。在进入细节之前，我们先来看看<code class="fe ms mt mu mv b">makeTensorFromBytes():</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="d5ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<code class="fe ms mt mu mv b">makeTensorFromBytes()</code>取自<a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/go/example_inception_inference_test.go" rel="noopener ugc nofollow" target="_blank">这里的</a>，将<code class="fe ms mt mu mv b">[]byte</code>转换为张量。在它的内部有一个对<code class="fe ms mt mu mv b">makeBatch()</code>的调用，这个函数为一个张量增加了一个额外的维度，并将其转换为大小为 1 的一批(还记得输入形状第 4 维输入形状):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="20b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要一个方法<code class="fe ms mt mu mv b">CloseSession()</code>来结束会话:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="af2a" class="ny lw it bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">准备响应</h2><p id="bb5f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在预测并得到结果后，我们需要提取值，并使它们对用户来说是可显示的。为了实现这一点，我创建了一个名为<code class="fe ms mt mu mv b">responses</code>的新包，并在其中添加了一个由检测列表和检测数量组成的<code class="fe ms mt mu mv b">ObjectDetectionResponse</code>结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="0218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里最重要的部分是<code class="fe ms mt mu mv b">NewObjectDetectionResponse</code>函数，负责创建响应。这个函数有两个参数:输出张量和标签列表。输出张量与几个类型断言语句一起使用，以获取它们的值。然后，在一个循环中，我们迭代<code class="fe ms mt mu mv b">numDetections</code>次，每次都检查检测的置信度是否低于给定的阈值。如果是真的，我们继续。否则，创建一个由乐谱、边界框和标签组成的<code class="fe ms mt mu mv b">detection</code>实例，并将其添加到列表<code class="fe ms mt mu mv b">detection</code>中。在函数结束时，返回<code class="fe ms mt mu mv b">ObjectDetectionResponse</code>对象。</p><h1 id="3e25" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">网络服务</h1><p id="5496" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">因此，我们到达了最后一部分:网络服务。如上面的例子所示，该服务有一个 POST 方法，它接收一个图像并以 JSON 的形式返回<code class="fe ms mt mu mv b">ObjectDetectionResponse</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="596e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个函数中的第一个，<code class="fe ms mt mu mv b">main()</code>加载模型并设置服务。而第二个函数，处理函数<code class="fe ms mt mu mv b">predict()</code>，接收图像并执行预测。</p><p id="3e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行服务器，请执行<code class="fe ms mt mu mv b">$ go run main.go</code>。要进行测试，执行 run a <em class="ok"> curl </em>命令，就像这样<code class="fe ms mt mu mv b">curl -F "data=@PATH/TO/IMAGE" <a class="ae ky" href="http://localhost:8080/predict" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/predict</a></code>。</p><p id="8616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽情享受吧！</p><h1 id="ffcc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">概述</h1><p id="64ed" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">TensorFlow 是一个由多个平台组成的庞大生态系统。其中之一 TensorFlow Go 能够执行由 TensorFlow (Python)和 TensorFlow.js 等同类产品生成的图形。在本教程中，我们构建了一个程序来加载对象检测 MobileNet 模型，并通过 web 服务为其提供服务。</p><p id="daf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该项目可以用作一个库。如果您想使用它，运行<code class="fe ms mt mu mv b">$ go get github.com/juandes/tensorflow-go-models/models</code>。为了进行测试，您可以使用上面给出的 web 服务器代码。将来，我想在项目中添加更多的模型，并将我们使用的一些方法转换成接口。这样，我们可以轻松地扩展项目以支持更多的模型。如果你想尝试并添加一个新的模型，请随时提交您的 PR。</p><p id="51ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的源代码可以在 https://github.com/juandes/tensorflow-go-models<a class="ae ky" href="https://github.com/juandes/tensorflow-go-models" rel="noopener ugc nofollow" target="_blank">获得</a></p></div></div>    
</body>
</html>