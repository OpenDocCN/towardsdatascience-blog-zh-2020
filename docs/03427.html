<html>
<head>
<title>TensorFlow Lite Android Support Library: Simplify ML On Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow Lite Android支持库:简化Android上的ML</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tensorflow-lite-android-support-library-simply-ml-on-android-561402292c80?source=collection_archive---------20-----------------------#2020-04-01">https://towardsdatascience.com/tensorflow-lite-android-support-library-simply-ml-on-android-561402292c80?source=collection_archive---------20-----------------------#2020-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="648a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">介绍新的TF Lite Android支持库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8bf15cb3d6eb7e525eb6d2d195facdc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B0UYNEGgluprRKNJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Benjamin Sow 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个人都喜欢TensorFlow，当你可以直接在Android上运行TF模型时就更喜欢了。我们都在Android上使用TensorFlow Lite，我们也有几个CodeLabs在上面。使用Android上的<code class="fe lv lw lx ly b">Interpreter</code>类，我们目前正在应用程序中运行我们的<code class="fe lv lw lx ly b">.tflite</code>模型。</p><p id="6df5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在那之前我们要做很多事情，对吗？如果我们正在执行图像分类任务，你可能会从相机库中获得一个<code class="fe lv lw lx ly b">Bitmap</code>或<code class="fe lv lw lx ly b">Image</code>对象，然后我们将其转换为<code class="fe lv lw lx ly b">float[][][]</code>或<code class="fe lv lw lx ly b">byte[]</code>。然后我们从<code class="fe lv lw lx ly b">assets</code>文件夹中加载我们的模型作为<code class="fe lv lw lx ly b">MappedByteBuffer</code>。在调用了<code class="fe lv lw lx ly b">interpreter.run()</code>之后，我们获得了类概率，我们对其执行<code class="fe lv lw lx ly b">argmax()</code>操作，然后最终从<code class="fe lv lw lx ly b">labels.txt</code>文件中获得一个标签。</p><p id="6b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们开发人员遵循的传统方法，没有其他方法。</p><h1 id="e635" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">TensorFlow Lite Android支持库简介</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/093446a654a9125bc68382081d7a8d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjsEPItNww_khr8o2me-xg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.tensorflow.org/lite" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="bc95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>团队发布了<a class="ae ky" href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/lite/experimental/support/java" rel="noopener ugc nofollow" target="_blank"> TensorFlow Lite Android支持库</a>来解决预处理的繁琐任务。GitHub页面给出了他们目标的直觉，</p><blockquote class="ms mt mu"><p id="09af" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">移动应用程序开发人员通常与位图等类型化对象或整数等原语进行交互。然而，运行设备上机器学习模型的TensorFlow Lite解释器使用ByteBuffer形式的张量，这可能很难调试和操作。TensorFlow Lite Android支持库旨在帮助处理TensorFlow Lite模型的输入和输出，并使TensorFlow Lite解释器更易于使用。</p></blockquote><p id="e799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要在我们的Android项目中做到这一点。还记得<code class="fe lv lw lx ly b">build.gradle</code>文件吗？对！我们将把这些依赖关系添加到我们的应用程序级<code class="fe lv lw lx ly b">build.gradle</code>文件中，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="2b8b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">1.创建输入和输出数组</h1><p id="46a4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">运行TFLite模型的第一步是创建一些数组对象，它可以存储模型的输入以及模型将产生的输出。为了让我们的生活更轻松，减少与<code class="fe lv lw lx ly b">float[]</code>对象的斗争，TF支持库包含了一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/experimental/support/java/src/java/org/tensorflow/lite/support/tensorbuffer/TensorBuffer.java" rel="noopener ugc nofollow" target="_blank">TensorBuffer</a></code>类，它采用所需数组的形状及其数据类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">片段1</p></figure><blockquote class="ms mt mu"><p id="32b2" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated"><strong class="lb iu">注:截至2020年4月1日，仅支持</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">DataType.FLOAT32</strong></code> <strong class="lb iu">和</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">DataType.UINT8</strong></code> <strong class="lb iu">。</strong></p></blockquote><p id="54a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您甚至可以通过修改现有的<code class="fe lv lw lx ly b">TensorBuffer</code>对象的数据类型来创建一个<code class="fe lv lw lx ly b">TensorBuffer</code>对象，</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="024c" class="nk ma it ly b gy nl nm l nn no"><strong class="ly iu">val </strong>newImage = TensorImage.createFrom( image , DataType.<strong class="ly iu">FLOAT32 </strong>)</span></pre><h1 id="0a49" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">2.图像操作</h1><p id="8e06" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如果您正在处理对象检测、图像分类或其他与图像相关的模型，您需要在<code class="fe lv lw lx ly b">Bitmap</code>上工作，并调整其大小或使其正常化。我们对此有三个操作，即<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/experimental/support/java/src/java/org/tensorflow/lite/support/image/ops/ResizeOp.java" rel="noopener ugc nofollow" target="_blank">ResizeOp</a></code>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/experimental/support/java/src/java/org/tensorflow/lite/support/image/ops/ResizeWithCropOrPadOp.java" rel="noopener ugc nofollow" target="_blank">ResizeWithCropOrPadOp</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/experimental/support/java/src/java/org/tensorflow/lite/support/image/ops/Rot90Op.java" rel="noopener ugc nofollow" target="_blank">Rot900p</a></code>。</p><p id="c3f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/experimental/support/java/src/java/org/tensorflow/lite/support/image/ImageProcessor.java" rel="noopener ugc nofollow" target="_blank">ImageProcessor</a></code>类定义预处理管道。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><blockquote class="ms mt mu"><p id="ae79" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated"><strong class="lb iu">问题:什么是双线性和最近邻法？</strong></p><p id="67f8" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">答:读<a class="ae ky" href="https://support.esri.com/en/technical-article/000005606" rel="noopener ugc nofollow" target="_blank">这个</a>。</p></blockquote><p id="f3b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，创建一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/experimental/support/java/src/java/org/tensorflow/lite/support/image/TensorImage.java" rel="noopener ugc nofollow" target="_blank">TensorImage</a></code>对象并处理图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="47b8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">3.张量运算</h1><p id="f4d1" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">图像阵列的归一化对于几乎所有的模型都是必要的，无论是图像分类模型还是回归模型。对于处理张量，我们有一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/experimental/support/java/src/java/org/tensorflow/lite/support/common/TensorProcessor.java" rel="noopener ugc nofollow" target="_blank">TensorProcessor</a></code>。除了<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/experimental/support/java/src/java/org/tensorflow/lite/support/common/ops/NormalizeOp.java" rel="noopener ugc nofollow" target="_blank">NormalizeOp</a></code>，我们还有<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/experimental/support/java/src/java/org/tensorflow/lite/support/common/ops/CastOp.java" rel="noopener ugc nofollow" target="_blank">CastOp</a></code>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/experimental/support/java/src/java/org/tensorflow/lite/support/common/ops/QuantizeOp.java" rel="noopener ugc nofollow" target="_blank">QuantizeOp</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/experimental/support/java/src/java/org/tensorflow/lite/support/common/ops/DequantizeOp.java" rel="noopener ugc nofollow" target="_blank">DequantizeOp</a></code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><blockquote class="ms mt mu"><p id="a49d" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated"><strong class="lb iu">问题:什么是正常化？</strong></p><p id="edb9" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">答:将实际值范围转换为标准值范围的过程，通常为-1到+1或0到1。例如，假设某个特征的自然范围是800到6000。通过减法和除法，您可以将这些值规范化到-1到+1的范围内。</p></blockquote><p id="69d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以通过实现<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/experimental/support/java/src/java/org/tensorflow/lite/support/common/TensorOperator.java" rel="noopener ugc nofollow" target="_blank">TensorOperator</a></code>类来自由构建定制的ops，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="c637" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">4.加载模型和标签</h1><p id="ba5e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们可以使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/lite/experimental/support/java/src/java/org/tensorflow/lite/support/common/FileUtil.java" rel="noopener ugc nofollow" target="_blank">FileUtil.loadMappedFile()</a></code>方法轻松加载我们的<code class="fe lv lw lx ly b">.tflite</code>模型。类似地，我们可以从<code class="fe lv lw lx ly b">InputStream</code>或资产文件夹中加载标签。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b95b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后使用<code class="fe lv lw lx ly b">Interpreter.run()</code>进行推理，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="07d6" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">关于Android机器学习的更多资源</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="8723" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">仅此而已！</h1><p id="cf7c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我希望你喜欢新的TensorFlow Lite Android支持库。这是一个内部的快速审查，但尝试探索自己。感谢阅读！</p></div></div>    
</body>
</html>