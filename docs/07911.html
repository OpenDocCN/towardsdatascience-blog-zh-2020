<html>
<head>
<title>The Great CSV Showdown: Julia vs Python vs R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">伟大的CSV对决:Julia vs Python vs R</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-great-csv-showdown-julia-vs-python-vs-r-aa77376fb96?source=collection_archive---------5-----------------------#2020-06-12">https://towardsdatascience.com/the-great-csv-showdown-julia-vs-python-vs-r-aa77376fb96?source=collection_archive---------5-----------------------#2020-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0a16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">任何数据分析工作流程中的第一项任务就是简单地读取数据，这绝对必须快速有效地完成，这样才能开始更有趣的工作。在许多行业和领域中，CSV文件格式是存储和共享表格数据的首选。快速而健壮地加载CSV是至关重要的，它必须能够很好地适应各种文件大小、数据类型和形状。这篇文章比较了三个不同csv解析器读取8个不同真实数据集的性能:R的fread、Pandas的read_csv和Julia的CSV.jl。这些解析器分别被选为每个<a class="ae ko" href="https://www.r-project.org" rel="noopener ugc nofollow" target="_blank"> R </a>、<a class="ae ko" href="https://www.python.org" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae ko" href="https://julialang.org" rel="noopener ugc nofollow" target="_blank"> Julia </a>的“同类最佳”CSV解析器。多线程是当今计算机达到最高性能的关键，但只有一种语言(Julia)能够持续有效地使用多核。</p><p id="070c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这三个工具都支持加载各种可能丢失值的数据类型，但只有<a class="ae ko" href="https://www.rdocumentation.org/packages/data.table/versions/1.12.8/topics/fread" rel="noopener ugc nofollow" target="_blank"> fread </a> (R)和<a class="ae ko" href="https://github.com/JuliaData/CSV.jl" rel="noopener ugc nofollow" target="_blank"> CSV.jl </a> (Julia)支持多线程— <a class="ae ko" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>只支持单线程CSV加载。Julia的CSV.jl的另一个独特之处在于，它是唯一一个完全用其高级语言实现的工具，而不是用C实现并从R / Python包装而来的。(Pandas确实有一个稍微强一点的Python原生解析器，它明显慢一些，并且几乎所有read_csv的使用都默认为C引擎。)因此，这里的CSV.jl基准不仅代表了在Julia中加载数据的速度，而且还表明了在分析中使用的后续Julia代码可能的性能。</p><p id="8d63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下基准测试表明，即使在限制单核的情况下，Julia的CSV.jl也比Pandas快1.5到5倍；启用多线程后，速度可以提高20倍以上。r的fread更有竞争力，因为它支持多线程，但在许多数据集上它仍落后Julia 10倍或更多。用于基准测试的工具有:Julia的<a class="ae ko" href="https://github.com/JuliaCI/BenchmarkTools.jl" rel="noopener ugc nofollow" target="_blank"> BenchmarkTools.jl </a>，R的<a class="ae ko" href="https://www.rdocumentation.org/packages/microbenchmark/versions/1.4-7/topics/microbenchmark" rel="noopener ugc nofollow" target="_blank">微基准测试</a>，Python的<a class="ae ko" href="https://docs.python.org/2/library/timeit.html" rel="noopener ugc nofollow" target="_blank"> timeit </a>。</p><h1 id="f7f5" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">同质数据</h1><p id="843b" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">让我们从一些同质数据集开始，即所有列中具有相同类型数据的数据集。本节中的数据集，除了股票价格数据集之外，都是从基准站点的<a class="ae ko" href="https://www.queryverse.org/benchmarks/" rel="noopener ugc nofollow" target="_blank">中获得的。性能指标是线程数量从1增加到20时加载数据集所用的时间。由于Pandas不支持多线程，单线程速度是针对所有内核计数的。</a></p><p id="fe56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">同质数据集上的性能</strong>:</p><p id="9c06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">统一浮点数据集</strong>:第一个数据集包含排列在100万行20列的浮点值。Pandas加载这个文件需要232毫秒。单线程data.table比CSV.jl快1.6倍，有了多线程，CSV.jl处于最佳状态，比data.table快一倍多，CSV.jl比没有多线程的熊猫快1.5倍，有了大约快11倍。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/4a1833e8335aa59af5b2a04b6eb0d7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0nNfDvP2K0kkY5S2"/></div></div></figure><p id="c23f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">统一字符串数据集(I) </strong>:该数据集包含所有列中的字符串值，有一百万行20列。Pandas加载文件需要546毫秒。对于R，添加线程似乎不会带来任何性能提升。单线程CSV.jl比data.table快2.5倍，10线程时比data.table快14倍左右。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/4ab4dabe10abb40eb06b71f170a3fbfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dq_1eTL6LO9y5BoY"/></div></div></figure><p id="8713" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">统一字符串数据集(二)</strong>:该数据集的维度与上一个数据集的维度相同。但是，每一列也有缺失值。熊猫需要300毫秒。没有线程，CSV.jl比R快1.2倍，有了，大概快5倍。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/de29b809d7f8029863bcd1ebc5683ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wmfSLdlHKznqsQJW"/></div></div></figure><p id="b5a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">苹果股票价格</strong>:</p><p id="9d4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该数据集包含5000万行和5列，大小为2.5GB。这些行是AAPL股票的开盘价、最高价、最低价和收盘价。包含价格的四列是浮点值，还有一个日期列。</p><p id="a217" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">单线程的CSV.jl比R的fread from data.table快1.5倍左右，多线程的CSV.jl快22倍左右！熊猫的read_csv需要34s才能读完，这个比R和Julia都慢。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/588e74444365dd32650dc43f2aac9368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AL5DbNri_aLQGM2P"/></div></div></figure><h1 id="86bc" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">异构数据集上的性能</h1><p id="8fda" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated"><strong class="js iu">混合数据集:</strong>这个数据集有10k行，200列。这些列包含字符串、浮点、日期时间和缺失值。Pandas加载这个数据集大约需要400毫秒。没有线程的情况下，CSV.jl比R快2倍，有10个线程的情况下快10倍左右。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/8eb1c257ef169eeadf9f132ab5979565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v2Uu3met9MmHMVYw"/></div></div></figure><p id="6f39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">抵押贷款风险数据集</strong></p><p id="359e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们来看一个更广泛的数据集。来自Kaggle的这个<a class="ae ko" href="https://www.kaggle.com/xiaodaizj/mortgageriskfeaturetools" rel="noopener ugc nofollow" target="_blank">抵押贷款风险数据集</a>是一个混合型数据集，有356k行和2190列。这些列是异构的，并且具有String、Int、Float、Missing类型的值。熊猫在这个数据集中需要119秒来读取。单线程的fread比CSV.jl快大约两倍，然而，如果有更多的线程，Julia要么和r一样快，要么比r稍快。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi gj"><img src="../Images/c51b6023df0bbdfd021632ef7f8525b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oXC_Qo_u5HvMaFZZ"/></div></div></figure><p id="255e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">宽数据集</strong>:这是一个相当宽的数据集，有1000行和20，000列。数据集包含字符串和整型值。熊猫读取数据集需要7.3秒。在这种情况下，单线程data.table比CSV.jl快大约5倍。由于线程较多，CSV.jl与data.table相比具有竞争力。在data.table中，增加线程数量似乎不会带来任何性能提升</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/891b39fa06dda3e4a2f31a1a630940c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gXUiHvbCfGhLyFZQ"/></div></div></figure><p id="4ac9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">房利美收购数据集</strong>:该数据集可从<a class="ae ko" href="https://www.fanniemae.com/portal/funding-the-market/data/loan-performance-data.html" rel="noopener ugc nofollow" target="_blank">房利美网站</a>下载。数据集有400万行和25列，值的类型为Int、String、Float、Missing。</p><p id="cc6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">单线程data.table比CSV.jl快1.25倍，但是，CSV.jl的性能随着线程的增加而不断提高。CSV.jl通过多线程获得了大约4倍的速度。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi gj"><img src="../Images/e5a36d4a728031731b0b702d4d2ba336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dPEdumqow4bW7pof"/></div></div></figure><p id="8f44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">汇总图表:</strong></p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi me"><img src="../Images/b93c665433eb470bb4da331a647ca1a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*vhj1dzmHIsXUhKFkCP52yw.png"/></div></figure><p id="1a30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在所有八个数据集上，Julia的CSV.jl总是比Pandas快，即使人为限制为单核。借助多线程技术，Julia几乎在每一个案例中都独占鳌头，而且常常以10倍或更大的优势胜出。r的fread只在少数情况下能够跟上。</p><p id="e2ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">系统信息:</strong>执行基准测试的系统规格如下</p><blockquote class="mf mg mh"><p id="90a9" class="jq jr mi js b jt ju jv jw jx jy jz ka mj kc kd ke mk kg kh ki ml kk kl km kn im bi translated">$ lsb_release -a <br/>没有lsb模块可用。<br/>发行商ID: Ubuntu <br/>描述:Ubuntu 18.04.4 LTS <br/>发布时间:18.04 <br/>代号:仿生</p><p id="a295" class="jq jr mi js b jt ju jv jw jx jy jz ka mj kc kd ke mk kg kh ki ml kk kl km kn im bi translated">$ uname -a <br/> Linux南极5 . 6 . 0-custom+<em class="it"># 1 SMP Mon Apr 6 00:47:33 EDT 2020 x86 _ 64 x86 _ 64 GNU/Linux</em></p><p id="8046" class="jq jr mi js b jt ju jv jw jx jy jz ka mj kc kd ke mk kg kh ki ml kk kl km kn im bi translated">$ lscpu <br/>架构:x86_64 <br/> CPU op-mode(s): 32位， 64位<br/>字节顺序:小端<br/>CPU:40<br/>在线CPU列表:每核心0–39<br/>线程:每插槽2 <br/>核心:10 <br/>插槽:2 <br/> NUMA节点:2 <br/>厂商ID: GenuineIntel <br/> CPU家族:6 <br/>型号:85 <br/>型号名称:英特尔(R)至强(R) 银4114 CPU @ 2.20GHz <br/>步进:4 <br/> CPU MHz: 800.225 <br/> CPU最大MHz: 3000.0000 <br/> CPU最小MHz:800.0000<br/>BogoMIPS:4400.00<br/>虚拟化:VT-x <br/> L1d缓存:32K <br/> L1i缓存:32K <br/> L2缓存:1024K <br/> L3</p><p id="384b" class="jq jr mi js b jt ju jv jw jx jy jz ka mj kc kd ke mk kg kh ki ml kk kl km kn im bi translated">free -h <br/>总已用空闲共享缓冲区/可用缓存<br/>Mem:62G 3.3G 6.3G 352k 52G 58G<br/>Swap:59G 3.2G 56G</p></blockquote><p id="6246" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JuliaCon今年上线，免费注册。JuliaCon是一年中最大的Julia会议，汇集了来自世界各地的演讲者、开发者和爱好者，为期3天，充满了主题演讲、讲座和研讨会！在此注册！</p></div></div>    
</body>
</html>