<html>
<head>
<title>Python OpenCV: Building Instagram-Like Image Filters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python OpenCV:构建类似 Instagram 的图像过滤器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-opencv-building-instagram-like-image-filters-5c482c1c5079?source=collection_archive---------13-----------------------#2020-03-29">https://towardsdatascience.com/python-opencv-building-instagram-like-image-filters-5c482c1c5079?source=collection_archive---------13-----------------------#2020-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="763f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用图像变换技术构建图像过滤器的 Python OpenCV 教程。</h2></div><p id="b453" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu"> OpenCV </strong>是为解决大量计算机视觉任务而构建的库。它包含了大量的基本和高级特性，非常容易掌握，并且可用于多种编程语言。</p><p id="c93d" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在这篇文章中，我们将应用一些基本的图像变换技术，以获得图像过滤器。对于那些习惯了所有图像编辑软件的人来说，这些滤镜可能对你来说很基本。但是我认为对于第一次接触 OpenCV 的人来说，它们是很棒的，因为它们允许我们在不编写大量代码的情况下学习一些基本原理。😀</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/aac09f25fedd65f2b6d6a11dc639655c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ppG0VNB-GPfrdCt2"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae lv" href="https://unsplash.com/@nordwood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">诺德伍德主题</a>在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e06d" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><em class="lw">本文原载于</em> <a class="ae lv" href="https://programmerbackpack.com/python-opencv-building-instagram-like-image-filters/" rel="noopener ugc nofollow" target="_blank"> <em class="lw">程序员背包博客</em> </a> <em class="lw">。如果你想阅读更多这类的故事，一定要访问这个博客。</em></p><p id="c900" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><em class="lw">更感兴趣？在 Twitter 上关注我，地址是</em><a class="ae lv" href="https://twitter.com/b_dmarius" rel="noopener ugc nofollow" target="_blank"><em class="lw">@ b _ dmarius</em></a><em class="lw">，我会在那里发布每一篇新文章。</em></p><h1 id="c7af" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">介绍</h1><p id="ff0e" class="pw-post-body-paragraph kj kk it kl b km mp ju ko kp mq jx kr ks mr ku kv kw ms ky kz la mt lc ld le im bi translated">在这一节中，我将解释计算机如何存储和处理 RGB 图像背后的逻辑。如果你已经熟悉这些东西，请跳到下一节，我们将跳到更高级的细节。</p><p id="16b8" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">图像中的基本单位数据是<strong class="kl iu">像素</strong>。像素只是图像中的一个点，并存储为范围在[0，256]内的数字。RGB 模型代表<strong class="kl iu">红绿蓝</strong>并告诉我们，对于每个像素，我们存储红、绿、蓝的强度(我们将这些<em class="lw">通道称为</em>)作为一个从 0 到 256 的数字。如果所有 3 个通道都是 256，则像素为白色；如果所有 3 个通道都是 0，则像素为黑色。如果相应的通道是 256 并且所有其他通道是 0，则像素是完全红色/绿色/蓝色的。你明白了，每种颜色都是由这三个通道混合而成的。</p><p id="14c7" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">所以图像是像素的集合。比方说，如果我们的图像是 300x200，那么我们将把它存储为 300 行 200 列的 2D 数组，其中每个单元是一个像素。但是我们从上面知道，对于每个像素，我们将存储所有 3 个通道的信息，所以这实际上给了我们一个 3D 数组。</p><h1 id="6f23" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">OpenCV 卷积和内核</h1><p id="5867" class="pw-post-body-paragraph kj kk it kl b km mp ju ko kp mq jx kr ks mr ku kv kw ms ky kz la mt lc ld le im bi translated">这是完全由理论组成的最后一部分。如果你想直接跳到实用部分，请见下一节。</p><p id="c747" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在我们知道了图像是如何作为像素存储的，我们可以学习对这些像素应用变换。</p><p id="547a" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">卷积</strong>是通过将图像分割成称为<em class="lw">窗口</em>的小部分，并对每个部分应用称为<strong class="kl iu">内核</strong>的操作符来变换图像的操作。</p><p id="ae67" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">内核通常是一个固定的、包含数字的小型 2D 数组。内核中的一个重要部分是中心，称为<strong class="kl iu">锚点</strong>。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/44d4dafcc10a9c8564cbce4cc41b4a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*pmm8-otM24Wxmynp3eTn7w.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">OpenCV 过滤器—内核示例</p></figure><p id="8e33" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">卷积通过以下步骤执行:</p><ol class=""><li id="a1b8" class="mv mw it kl b km kn kp kq ks mx kw my la mz le na nb nc nd bi translated">将内核放置在图像的顶部，内核锚点位于预定像素的顶部。</li><li id="b4c2" class="mv mw it kl b km ne kp nf ks ng kw nh la ni le na nb nc nd bi translated">在内核数和被内核重叠的像素值之间执行乘法，对乘法结果求和，并将结果放在锚点下方的像素上。</li><li id="4ce5" class="mv mw it kl b km ne kp nf ks ng kw nh la ni le na nb nc nd bi translated">重复这个过程，在图像上的每个可能的位置滑动图像顶部的内核。</li></ol><p id="903a" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果你想知道如何选择核的值，请注意最流行的核是图像处理科学家大量研究的结果。你当然可以试着选择你自己的内核，但是对于最基本的转换，我们已经有了很好的内核，可以提供很好的结果。</p><h1 id="b0f0" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">项目设置</h1><p id="3b28" class="pw-post-body-paragraph kj kk it kl b km mp ju ko kp mq jx kr ks mr ku kv kw ms ky kz la mt lc ld le im bi translated">我们需要安装 2 个 python 包，然后就可以开始了。</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="175b" class="no ly it nk b gy np nq l nr ns">pip3 install opencv-python<br/>pip3 install scipy</span></pre><p id="7eb0" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将导入单个图像(这是我亲自拍摄的图像)，并且对于每个转换，我们将制作该图像的副本。然后，我们通过一个单独的方法应用转换，这样我们可以保持代码的整洁。最后，我们将把结果保存为一个单独的图像。下面是基本流程:</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="4e30" class="no ly it nk b gy np nq l nr ns">initialImage = cv2.imread("image1.jpg")<br/>blurredImage = gaussianBlur(copy.deepcopy(initialImage))<br/>cv2.imwrite("blurred.jpg", blurredImage)</span></pre><h1 id="9333" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">OpenCV 内核和卷积变换</h1><p id="57f9" class="pw-post-body-paragraph kj kk it kl b km mp ju ko kp mq jx kr ks mr ku kv kw ms ky kz la mt lc ld le im bi translated">在这一部分，我们将使用一组预定义的内核来应用卷积，以获得漂亮的效果。对于其他类型的转换，请跳到下一节。对于每一个转换，我将向你们展示内核和代码，在这一节的最后，我将展示一个画廊，展示初始图像和结果。</p><h1 id="36f6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">图像锐化</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/18ca157848e85ac146cfb80b103dcd38.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*GPz6A5p4NZLZT5aIYPUzAw.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">Python OpenCV 滤镜-图像锐化</p></figure><p id="6ae1" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这是用来锐化图片细节的内核。我们将使用 OpenCV 库中的<em class="lw"> filter2D </em>方法，它将为我们执行卷积。</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="a243" class="no ly it nk b gy np nq l nr ns">def sharpen(image):<br/>    kernel = np.array([[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]])<br/>    return cv2.filter2D(image, -1, kernel)</span></pre><h1 id="38d5" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">棕褐色效果</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/caaeae68740204b9b09e5020cd41a3bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*X6h45vsjZPKyIojJN_XbzQ.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">Python OpenCV 滤镜—棕褐色</p></figure><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="2321" class="no ly it nk b gy np nq l nr ns">def sepia(image):<br/>    kernel = np.array([[0.272, 0.534, 0.131],<br/>                       [0.349, 0.686, 0.168],<br/>                       [0.393, 0.769, 0.189]])<br/>    return cv2.filter2D(image, -1, kernel)</span></pre><h1 id="b3fc" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">模糊效应</h1><p id="8441" class="pw-post-body-paragraph kj kk it kl b km mp ju ko kp mq jx kr ks mr ku kv kw ms ky kz la mt lc ld le im bi translated">为了达到这个效果，我们可以使用一个基本的内核，就像上面所有的一样，但是结果是相当蹩脚的。幸运的是，OpenCV 实现了高斯模糊，它将为我们完成这项工作。我们需要做的就是:</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="4636" class="no ly it nk b gy np nq l nr ns">def gaussianBlur(image):<br/>    return cv2.GaussianBlur(image, (35, 35), 0)</span></pre><h1 id="bc94" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">浮雕效果</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/6acc966d4d0813cbdf5d3fa3ee94f6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*uCtc4ClHa468D69zzWvbkQ.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">Python OpenCV 滤镜-浮雕</p></figure><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="78e0" class="no ly it nk b gy np nq l nr ns">def emboss(image):<br/>    kernel = np.array([[0,-1,-1],<br/>                            [1,0,-1],<br/>                            [1,1,0]])<br/>    return cv2.filter2D(image, -1, kernel)</span></pre><p id="0c7d" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这是我们内核转换结果的图库。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/54222c5683e19af8105b131bdd587264.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*mmbNNUmJjDehYXq9-0Hwgg.jpeg"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">这是最初的图像</p></figure><div class="lg lh li lj gt ab cb"><figure class="nw lk nx ny nz oa ob paragraph-image"><img src="../Images/65bcb3bebfe6aac8512524eea9812b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*OY24T0Q6YK5bd59XhH0UJw.jpeg"/></figure><figure class="nw lk nx ny nz oa ob paragraph-image"><img src="../Images/59e40cf2934d678d0896e1f650a9a00f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*aopzxXaxkxEVyos785LH5A.jpeg"/></figure></div><div class="ab cb"><figure class="nw lk nx ny nz oa ob paragraph-image"><img src="../Images/3ac77d84c182e640979a20f6906733b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*BlLMS2B7zmYCCwo4rWT5AQ.jpeg"/></figure><figure class="nw lk nx ny nz oa ob paragraph-image"><img src="../Images/a74891061787246ad736bf37556f0eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*zGf5e6wKjA9GpHQ7t7jkQA.jpeg"/><p class="lr ls gj gh gi lt lu bd b be z dk oc di od oe translated">从左到右，从上到下:模糊，浮雕，棕褐色，锐化</p></figure></div><h1 id="5440" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">OpenCV —基于像素值的变换</h1><p id="538a" class="pw-post-body-paragraph kj kk it kl b km mp ju ko kp mq jx kr ks mr ku kv kw ms ky kz la mt lc ld le im bi translated">接下来，我们将增加图像的亮度。为此，我们需要做的就是导航到图像的每个像素，然后导航到特定像素的每个通道。然后，我们将每个通道的值增加一个特定的值。这将给我们一个很好的亮度效果。</p><p id="3f0b" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">为了将我们从所有这些代码中解放出来，OpenCV 框架实现了一个方法，可以完全做到这一点。</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="1181" class="no ly it nk b gy np nq l nr ns">def brightnessControl(image, level):<br/>    return cv2.convertScaleAbs(image, beta=level)</span></pre><p id="aa02" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这是我们亮度控制方法的结果。</p><div class="lg lh li lj gt ab cb"><figure class="nw lk nx ny nz oa ob paragraph-image"><img src="../Images/23c435e48fa0b3ff282b27447ddf0605.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*FG0Rzd-8e4si6-ax-IbNwA.jpeg"/></figure><figure class="nw lk nx ny nz oa ob paragraph-image"><img src="../Images/54222c5683e19af8105b131bdd587264.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*mmbNNUmJjDehYXq9-0Hwgg.jpeg"/><p class="lr ls gj gh gi lt lu bd b be z dk oc di od oe translated">左—明亮的图像，右—原始图像</p></figure></div><h1 id="5ac2" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">OpenCV —查找表转换</h1><p id="0e53" class="pw-post-body-paragraph kj kk it kl b km mp ju ko kp mq jx kr ks mr ku kv kw ms ky kz la mt lc ld le im bi translated">我们将使用这种类型的变换来使图像看起来更温暖和更寒冷，但首先让我们看看我们如何使用查找表。</p><p id="bc3a" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">一个<strong class="kl iu">查找表</strong>只是一个简单的值对集合，如下所示:<em class="lw">【值 1，值 2，…。，valueN]，[modifiedValue1，modifiedValue2，…，modifiedValueN] </em>这背后的逻辑很简单——我们将获取每个像素值，并用查找表中的相应值替换它(意味着用<em class="lw"> modifiedValue1 </em>等替换<em class="lw"> value1 </em>)。</p><p id="470a" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在的问题是，有很多值需要替换(从 0 到 256)，为此创建一个查找表是一个痛苦的过程。但是幸运再次站在我们这边，因为我们有一个工具可以利用它。</p><p id="c6b7" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">来自<strong class="kl iu"> scipy </strong>包的<strong class="kl iu"> <em class="lw">单变量线</em> </strong> <em class="lw"> </em>平滑方法可以帮助我们。这种方法只取几个参考值，并试图找到一种方法来修改我们提供的参考值范围内的所有其他值。</p><p id="6300" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">基本上，我们将定义一个简短的查找表，如下所示</p><p id="23d7" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><em class="lw">【0，64，128，256】，【0，80，160，256】</em></p><p id="3205" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">并应用<em class="lw"> UnivariateSpline </em>变换，该变换将填充[0，256]范围内的其余值。</p><p id="436d" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">构建好查找表后，我们只需将它们应用于特定的通道。为了获得一个<strong class="kl iu">温暖的图像</strong>，我们将为图像中的所有像素增加红色通道的值，减少蓝色通道的值。为了获得<strong class="kl iu">冷图像</strong>，我们要做相反的事情:增加蓝色通道的值，减少红色通道的值。绿色通道在这两种情况下都不会被触及。</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="8c42" class="no ly it nk b gy np nq l nr ns">def spreadLookupTable(x, y):<br/>  spline = UnivariateSpline(x, y)<br/>  return spline(range(256))</span><span id="7033" class="no ly it nk b gy of nq l nr ns">def warmImage(image):<br/>    increaseLookupTable = spreadLookupTable([0, 64, 128, 256], [0, 80, 160, 256])<br/>    decreaseLookupTable = spreadLookupTable([0, 64, 128, 256], [0, 50, 100, 256])<br/>    red_channel, green_channel, blue_channel = cv2.split(image)<br/>    red_channel = cv2.LUT(red_channel, increaseLookupTable).astype(np.uint8)<br/>    blue_channel = cv2.LUT(blue_channel, decreaseLookupTable).astype(np.uint8)<br/>    return cv2.merge((red_channel, green_channel, blue_channel))</span><span id="1c73" class="no ly it nk b gy of nq l nr ns">def coldImage(image):<br/>    increaseLookupTable = spreadLookupTable([0, 64, 128, 256], [0, 80, 160, 256])<br/>    decreaseLookupTable = spreadLookupTable([0, 64, 128, 256], [0, 50, 100, 256])<br/>    red_channel, green_channel, blue_channel = cv2.split(image)<br/>    red_channel = cv2.LUT(red_channel, decreaseLookupTable).astype(np.uint8)<br/>    blue_channel = cv2.LUT(blue_channel, increaseLookupTable).astype(np.uint8)<br/>    return cv2.merge((red_channel, green_channel, blue_channel))</span></pre><p id="d6a8" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这里的结果和预期的一样。</p><div class="lg lh li lj gt ab cb"><figure class="nw lk og ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/e33d150ca1c4b99128714cd850bf71df.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*EKP228LTKiU9OvRh8R6WmQ.jpeg"/></div></figure><figure class="nw lk og ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/99f4b0d2b89866316479e53b554f8573.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*mmbNNUmJjDehYXq9-0Hwgg.jpeg"/></div></figure><figure class="nw lk og ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/c3115dee2f81dc735b82979b20d5bb75.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*7nYcbgZaGnNNt7K96VePgg.jpeg"/></div><p class="lr ls gj gh gi lt lu bd b be z dk oh di oi oe translated">左侧—暖图像，中间—原始图像，右侧—冷图像</p></figure></div><p id="66b4" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这很有趣！我们在这里看到了一点数学，一点代码，学到了很多关于计算机如何存储和处理图像，以及我们如何使用它来获得图像的美丽变换。如果你喜欢这篇文章，并想了解更多，那么请确保你在 Twitter 上关注我，因为不久我将发布另一篇关于使用 OpenCV 构建类似 Instagram 的面具的文章。</p><p id="6d2c" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><em class="lw">本文原载于</em> <a class="ae lv" href="https://programmerbackpack.com/python-opencv-building-instagram-like-image-filters/" rel="noopener ugc nofollow" target="_blank"> <em class="lw">程序员背包博客</em> </a> <em class="lw">。如果你想阅读更多这类的故事，一定要访问这个博客。</em></p><p id="90d5" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><em class="lw">非常感谢您阅读本文！有兴趣了解更多吗？在 Twitter 上关注我，地址是</em><a class="ae lv" href="https://twitter.com/b_dmarius" rel="noopener ugc nofollow" target="_blank"><em class="lw">@ b _ dmarius</em></a><em class="lw">，我会在那里发布每一篇新文章。</em></p></div></div>    
</body>
</html>