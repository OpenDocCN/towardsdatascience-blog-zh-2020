<html>
<head>
<title>Geographic Clustering with HDBSCAN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 HDBSCAN 进行地理聚类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/geographic-clustering-with-hdbscan-ef8cb0ed6051?source=collection_archive---------19-----------------------#2020-07-04">https://towardsdatascience.com/geographic-clustering-with-hdbscan-ef8cb0ed6051?source=collection_archive---------19-----------------------#2020-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7435" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用 HDBSCAN、H3、图论和 OSM 探索地理数据。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9c34fe3797821877fdb4b5fc92da37d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0wrFL9wnGaoyaCvo"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马丁·桑切斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ab07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你的智能手机知道你何时在家或在办公室。至少，我的能，甚至能告诉我什么时候出发，准时到达我的一个共同目的地。我们都接受我们的智能设备收集我们的偏好信息，并将它们发送到云端进行处理。这些反馈回来作为购物、食物、交配以及何时离开办公室回家的建议。</p><p id="5727" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">推断一个通常位置背后的魔力是什么？云计算机是如何找到我们生活的“地方”的？答案包括时间戳地理区域和聚类的集合。</p><p id="fff4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将使用 HDBSCAN [1]算法和<a class="ae kv" href="https://arxiv.org/abs/1905.02081v1" rel="noopener ugc nofollow" target="_blank">车辆能源数据集</a>来说明地理聚类的过程。请参考我的上一篇名为“<a class="ae kv" rel="noopener" target="_blank" href="/the-medium-sized-dataset-632cf0f15bb6"> <em class="ls">中型数据集</em> </a> <em class="ls">，</em>”的文章，在这篇文章中，我展示了数据集以及如何用 SQLite 数据库处理它的细节。本文共享同一个<a class="ae kv" href="https://github.com/joaofig/ved-explore" rel="noopener ugc nofollow" target="_blank"> GitHub 存储库</a>，并在此基础上为地理数据分析提供更多功能。</p><p id="9f28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">聚类方法来自另一篇名为“<a class="ae kv" rel="noopener" target="_blank" href="/mapping-the-uks-traffic-accident-hotspots-632b1129057b"> <em class="ls">绘制英国交通事故热点图</em> </a> <em class="ls">，</em>”的文章，在这篇文章中，我使用 DBSCAN 帮助在英国最常报告的交通事故区域周围创建地理围栏。在这里，我使用著名的基于密度的聚类算法的改进版本来处理城市环境中自然出现的复杂聚类，并使用公开可用的数据以一种非常简单但有效的方式命名它们。</p><h1 id="4cfa" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">车辆能源数据集</h1><p id="3d42" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">2019 年，G. S. Oh、David J. Leblanc 和 Huei Peng 发表了一篇关于车辆能源数据集(VED)的论文，其中包含一年的车辆轨迹和能耗数据。这些数据是从 2017 年 11 月至 2018 年 11 月在安阿伯收集的，参考了 383 辆不同类型和动力源的车辆样本。在这里，我们将只使用数据集中的地理数据，并将能源动力学的分析推迟到以后的文章中。</p><p id="2391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文讨论了一种有趣的个人数据去识别方法，并研究了与燃油经济性和能效相关的使用案例。最重要的是，该调查收集了超过 374，000 英里的 GPS 数据，我们可以将这些数据用于本文的地理聚类目的。</p><p id="339b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这项研究的数据收集过程通过一个相对简单的三步法确保了司机匿名。这个过程变得与本文非常相关，因为它产生了一个副产品，一个关键的信息:个性化的车辆轨迹。为了匿名化驾驶员信息，研究作者应用了<em class="ls">随机模糊</em>、<em class="ls">地理围栏</em>和<em class="ls">主要交叉边界</em>技术。随机雾化会移除行程起点和终点附近的观测位置，而地理围栏会在城市边界周围定义的边界框外裁剪观测值。作者还在第一个和最后一个十字路口附近修剪了行程。除了驾驶员匿名化，这些程序还具有生成易于使用的个人轨迹的好处。</p><p id="2e84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在上一篇文章中给出了如何提取和显示这些轨迹的示例。在这里，我将使用所有轨迹的端点来识别感兴趣的地方，以便将来进行分析。不幸的是，这些将指的是安娜堡最常用的十字路口，而不是司机的最终目的地本身，因为这些都不存在。但这足以说明构建由所有轨迹端点定义的地理聚类的过程。</p><p id="9ffe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始之前，我邀请您克隆本文的<a class="ae kv" href="https://github.com/joaofig/ved-explore" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>，并运行前四个编号的笔记本。下面的每一节都详细介绍了接下来的三个 Jupyter 笔记本，引导您到达端点:集群命名。</p><h1 id="ff99" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用 HDBSCAN 进行聚类</h1><blockquote class="mq mr ms"><p id="43e0" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">遵循笔记本中的这一部分<code class="fe mw mx my mz b"><em class="iq">5-clustering-hdbscan.ipynb</em></code></p></blockquote><p id="89c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行上述四个笔记本将使您准备好开始地理聚类过程。我们寻找的行程终点信息保存在 SQLite 数据库的<code class="fe mw mx my mz b">move</code>表中，我们使用下面的代码通过一个查询读取行程的开始和结束位置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0bf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦数据可用，我们可以将它重新排列成只有两列的数组，一列表示纬度，另一列表示经度，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d740" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以将位置信息提供给 HDBSCAN 算法，该算法的输出是一个集群标识符数组。下面的函数处理所有的工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="11c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意将地理坐标从度转换为米的要求。现在我们可以在端点坐标上调用这个函数，并以相同的顺序收集集群索引。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="215b" class="ng lu iq mz b gy nh ni l nj nk">clusterer = fit_utm_clusterer(locations)</span></pre><p id="efc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">得到的数组在第一维上具有与位置数组相同的大小，并且计算出的聚类标识符位于相应的索引中，使得查询非常容易。下面的函数在给定 id 的情况下在地图中显示一个聚类。这里，点定义感兴趣的区域，而不是地理围栏。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a71b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在第五台笔记本电脑上看到这个功能，它还配有一个交互式小部件来简化集群选择。使用这种设置，您可以快速检查生成的集群质量，并可能调整一些 HDBSCAN 算法参数。</p><p id="8770" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">处理异常值</strong></p><p id="35f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">毫无疑问，突出的问题之一是一些集群的质量差。一些聚集的点出现在离主要聚集非常远的地方，这些应该通过将它们标记为噪声来处理。下一张图展示了这种现象的一个明显例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/8a600891a212d6cfdc1930c89ee43430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qi9Zn8jsHoEkgCeqVZY7aA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">聚类号 2 显示了东北方向的一组独特的边远点。每个点的异常值分数反映在它的颜色上，蓝色点分数低，红色点分数高。</p></figure><p id="2f19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，HDBSCAN 算法为我们提供了一种处理这些点的方法，即<em class="ls">异常值得分</em>。异常值的范围从 0 到 1，其中 0 表示算法非常确定该位置属于该聚类，而接近 1 的值则表示相反。在上图中，计算出的异常值分数被转换成一个颜色条带，从代表零的蓝色到代表一的红色。看着地图，很明显红色的点是噪音，不属于中央集群。</p><p id="e539" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管如此，我们必须想出一个阈值来区分离群值或其他。我的方法非常直观，所以我浏览了所有的聚类点，寻找一个合理的阈值。离群值分数高于该阈值的点将被转换为噪声，而所有其他点将被保留。原来，红色的位置总是在最奇怪的地方，红色意味着高于<em class="ls"> 0.8 </em>的异常值。</p><p id="c821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样一个值的选择似乎是任意的，所以我决定提供一些数字支持。我试图确定这样一个门槛是否会去掉太多的分数。简单看一下整个数据集的异常值分布让我放心了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ce9139e85e3cbee5190d643182df33c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*oNeKSysdw2yWSKi1BVaGNg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通过选择 0.8 的异常值分数阈值，我们保留了超过 97.85%的聚类点。</p></figure><p id="3f6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从数值上看，这种计算非常简单，并且产生了 97.85%的相对高的值。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="d0e5" class="ng lu iq mz b gy nh ni l nj nk">scores = clusterer.outlier_scores_<br/>scores[scores &lt; 0.8].shape[0] / scores.shape[0]</span></pre><p id="40f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想在聚类质量上保守一点，保留少一点，比如 95%的点，该怎么办？这个计算也很容易执行。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="f1ea" class="ng lu iq mz b gy nh ni l nj nk">pd.Series(scores).quantile(0.95)</span></pre><p id="a8b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实证明，如果只考虑 95%的聚类点，可以将离群值阈值设置为 72.7%。让我们保留 0.8 的值，并过滤掉外围位置。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="4527" class="ng lu iq mz b gy nh ni l nj nk">filtered_clusters = np.copy(clusterer.labels_)<br/>filtered_clusters[scores &gt;= 0.8] = -1</span></pre><p id="e904" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，过滤是将所有异常值标记为噪声的简单过程。我们现在可以将它们保存到数据库中。对于每个聚类点，我们存储相应的 id(对于离群值可能是-1)、地理位置和 12 级 H3 指数。正如我们将在下面看到的，这会给我们带来一点麻烦，解决起来会很有趣。</p><p id="63d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">聚类已经有了很大的价值，因为它们让我们能够从地理上了解旅行的起点和终点。然而，我们可以更进一步，设计一种方法，在聚类点周围绘制地理围栏。此地理围栏将作为判别函数来测试某个位置是否属于某个聚类。</p><h1 id="35d4" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">集群地理围栏</h1><blockquote class="mq mr ms"><p id="131b" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">遵循笔记本中的这一部分<code class="fe mw mx my mz b"><em class="iq">6-cluster-geofencing.ipynb</em></code></p></blockquote><p id="0b69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决地理围栏问题，我将再次求助于 H3。正如我在之前的一篇文章中所展示的，我们可以用 H3 来图形化地描述集群。对于每个 H3 索引，我们可以根据地理坐标查询相应的六边形顶点。下面的函数将 H3 六边形索引转换成相应顶点坐标的数组。请注意第一个坐标是如何复制到最后以产生一个闭合的多边形的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="aee0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将一个集群的所有六边形粘贴在一起，我们可以构建一个类似蜂巢的集群表示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/fbe86c6d2e904936a2e6b24225fd3d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJCn-vI2UQasnPRZEHsenw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通过将所有六边形粘贴在一起，我们创建了一个类似蜂巢的集群表示。然而，我们只想保留大纲。</p></figure><p id="dca2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上图有助于理解基于哈希的聚类包含检测算法是如何工作的。这些六边形中的每一个都对应于 12 级的 H3 指数。为了测试一个随机点在聚类中的包含性，我们必须将其坐标转换为 H3 指数，并将其与聚类列表进行比较。这种计算速度很快，并且很容易在数据库索引或内存哈希表的帮助下进行编码。</p><p id="87cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将保留这种基于哈希的搜索功能，但将通过仅保留多边形的整体轮廓来改进表示。我们在 Shapely 包的帮助下合并所有的多边形。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="fe58" class="ng lu iq mz b gy nh ni l nj nk">merged = cascaded_union(polygons)</span></pre><p id="96d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将六边形多边形列表提供给级联联合函数。对于上面的简单情况，它返回单个多边形对象，或者当六边形的放置产生分散的“岛”时，它返回多多边形对象这就是我们想要的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/10ef2ed431bde39c8c35790a5b5b433c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0ottTs1HLEu0E5kdYnKWA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">与上面相同的簇，但是现在所有的六边形合并成一个形状。</p></figure><p id="9e6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但并不是所有的星团都会聚结成一个单一的形状。由于点分散和用于表示的固定 H3 水平，我们可能会看到一些不连续的区域，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/a59ba8b93374914a2d6535f335c9af54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kOK1mnkro-gaqrh4Hq1Yw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由于点分散和用于表示六边形的固定 H3 水平，这些岛逐渐增大。</p></figure><p id="0087" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题的解决方案似乎很简单:我们必须在某个地方放置另一个六边形，并将两个组件连接起来，这让我想起了网络组件。也许我们可以用一些图论来解决这个问题。</p><p id="d926" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过将六边形视为节点，将相邻关系视为边，来构思一个表示我们的集群单元的图。如果两个六边形是邻居，将有一条边连接它们。下面的函数就是这样做的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5427" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数接收六边形索引列表作为输入参数，并扫描所有可能的紧邻对。产生的邻域图不是有向类型，所以该函数只测试所有可能关系的一半。</p><p id="59c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦生成，我们就可以查询该图，以了解它有多少个<a class="ae kv" href="https://en.wikipedia.org/wiki/Component_(graph_theory)" rel="noopener ugc nofollow" target="_blank">连通分量</a>。从视觉上看，结果如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/95192f275e51b0c406d06e3db7b7478d.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*Jn0_GLnhvOHAsOrshvtjZQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上面的集群表示为一个图形。请注意两个明显的组件，以及较大组件中的节点是如何连接的。每条边都是邻居关系。为了将孤立的节点链接到更大的组件，我们必须至少添加另一个节点(六边形)。</p></figure><p id="de12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">NetworkX 包通过一个简单的查询证实了我们的直觉。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="4f46" class="ng lu iq mz b gy nh ni l nj nk">nx.number_connected_components(g)</span></pre><p id="dd44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个查询返回值 2，我们甚至可以查询组件是什么。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="c012" class="ng lu iq mz b gy nh ni l nj nk">list(nx.connected_components(g))</span></pre><p id="7bd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该查询生成一个列表，其中包含每个连接组件的一组节点。在这种情况下，结果如下。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="d4d3" class="ng lu iq mz b gy nh ni l nj nk">[{'8c274994cbb45ff'},<br/> {'8c274994c85a3ff',<br/>  '8c274994c85a7ff',<br/>  '8c274994c85b1ff',<br/>  '8c274994c85b3ff',<br/>  '8c274994c85b5ff',<br/>  '8c274994c85b7ff',<br/>  '8c274994c85bdff',<br/>  '8c274994cbb49ff',<br/>  '8c274994cbb4bff',<br/>  '8c274994cbb51ff',<br/>  '8c274994cbb59ff',<br/>  '8c274994cbb5bff',<br/>  '8c274994cbb5dff'}]</span></pre><p id="af3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以迭代这两个组件，并尝试找到它们之间最短的桥。幸运的是，H3 用一个在两个六边形之间“画线”的功能来拯救我们。下面的函数使用此服务来查找两个不同连接组件的任意两个六边形之间的最短可能直线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b4d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数遍历输入列表中的前两个连接组件，并枚举它们之间所有可能的“桥”。选定的桥要么是枚举中最短的桥，要么是只有三个元素的第一个桥。</p><p id="3ac7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们有了桥，我们就可以在两个组件之间构建它，生成一个新的图，并进行迭代。找到最新的连接组件列表，如果我们有多个组件，重新运行整个列表。</p><p id="b314" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是整个过程。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="09aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们只保留桥中的内部六边形，因为外部六边形已经存在于连接的组件中。上面的代码还会在数据库中插入新的集群点。</p><p id="3eed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们确信所有的集群都已连接并存储在数据库中。那么给它们命名呢？</p><h1 id="69ae" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">集群命名</h1><blockquote class="mq mr ms"><p id="3d75" class="kw kx ls ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">遵循笔记本中的这一部分<code class="fe mw mx my mz b"><em class="iq">7-cluster-names.ipynb</em></code></p></blockquote><p id="7114" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文中的最后一个挑战是在不使用反向地理编码服务的情况下获得聚类名称。我们将使用<a class="ae kv" href="https://wiki.openstreetmap.org/wiki/Overpass_API" rel="noopener ugc nofollow" target="_blank"> OSM 立交桥 API </a>来查询地理数据，并使用它来分配名称。每个查询都需要一个地理边界框，所以我们必须首先从数据库中获取它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ef20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在可以跨线查询了，但是我们需要做额外的准备，以避免通过缓存所有返回的数据来加重公共 API 的负担。这个策略将允许我们在出错的情况下防止发出重复的调用。为此，我们创建了一个特定的目录，将所有收集到的数据存储为 JSON 格式的文件。请注意，如果您决定返回并调整集群定义，您将必须擦除所有缓存文件，因为集群编号可能会发生变化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">该函数在提取文件缓存的同时检索与集群相关的 OSM 数据。</p></figure><p id="49b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以迭代集群集合，并使用下面的代码计算相关的名称。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="cdee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码有两处值得注意的地方。首先，我们使用一个转换 JSON 编码数据的辅助函数来构建每个 OSM 网络对象。第二，聚类名称是定义聚类本身的点集的函数。该函数计算距离每个输入点最近的<em class="ls"> K </em>个位置，并使用简单的投票机制检索前两个最常见的街道名称。最终的集群名称仅仅是这两个名称的串联，因为我们正在命名街道交叉口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/1980dc3357d3d4831df7671fd34b75c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*elT5e5SweUxmKEhHJRkK7w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">位于帕卡德路和卡彭特路交叉口的一个命名集群。</p></figure><h1 id="406a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="41e9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在本文中，我展示了一些处理地理聚类的技术，从聚类过程本身开始，然后是地理围栏过程，最后是一个轻量级地理编码器。</p><p id="07f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于这些数据还有很多需要探索的地方，我打算在以后的文章中这样做。最令人兴奋的模式之一无疑是车辆在两个集群之间行驶时的路线。敬请关注。</p><h1 id="80eb" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">参考</h1><p id="5b43" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">长度麦金尼斯，j .希利，s .阿斯特尔斯，<em class="ls"> hdbscan:基于层次密度的聚类</em>，《开放源码软件杂志》，第 2 卷，第 11 期。2017</p><p id="f8fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Ester，m .，Kriegel，H.P .等人(1996)一种基于密度的算法，用于在带有噪声的大型空间数据库中发现聚类。KDD，226–231</p><p id="0810" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://arxiv.org/abs/1905.02081v1" rel="noopener ugc nofollow" target="_blank">汽车能源数据集(VED)，用于汽车能源消耗研究的大规模数据集</a></p><h1 id="9662" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">相关文章</h1><p id="10da" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/the-medium-sized-dataset-632cf0f15bb6">中型数据集</a></p><p id="24bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/mapping-the-uks-traffic-accident-hotspots-632b1129057b">绘制英国交通事故热点图</a></p><p id="511d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/geospatial-indexing-with-ubers-h3-766399b690c">优步 H3 的地理空间索引</a></p><h1 id="8e26" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">油管（国外视频网站）</h1><p id="1394" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/lightning-talk-clustering-with-hdbscan-d47b83d1b03a">闪电对话:用 HDBSCAN 集群</a></p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt nz"><a href="https://www.linkedin.com/in/joao-paulo-figueira/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">joo Paulo Figueira—数据科学家—TB . LX by Daimler Trucks &amp; bus | LinkedIn</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">查看 joo Paulo Figueira 在全球最大的职业社区 LinkedIn 上的个人资料。圣保罗列出了 1 份工作…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.linkedin.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on kp nz"/></div></div></a></div></div></div>    
</body>
</html>