<html>
<head>
<title>Two Pandas functions you must know for easy data manipulation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为了在 Python 中轻松操作数据，您必须知道两个熊猫函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/two-pandas-functions-you-must-know-for-easy-data-manipulation-in-python-2f6d0a2ef3e5?source=collection_archive---------11-----------------------#2020-03-18">https://towardsdatascience.com/two-pandas-functions-you-must-know-for-easy-data-manipulation-in-python-2f6d0a2ef3e5?source=collection_archive---------11-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e2dd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">掌握这些 pandas 函数(和方法)可以缩短代码，提高性能，避免麻烦。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ebd6daedced23369788beec3ff319fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpGswBvzIzPJWyBIJWldBw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫——其中一只与众不同(右上图由<a class="ae ky" href="https://unsplash.com/@stanyw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">斯坦·w .</a>在<a class="ae ky" href="https://unsplash.com/s/photos/pandas?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><p id="a1da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我做大量的数据工作——一些 it 数据科学，一些 it 数据可视化，一些 it 数据邻近——比如摆弄体育分析。所有这些都是用 Python 完成的，而且几乎所有的数据操作都会用到 Pandas。</p><p id="f710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢认为在这段时间里，我学到了一两件关于使用熊猫的事情。我使用熊猫的方式与几年前我刚开始涉足熊猫时大不相同。我使用 Pandas 越多，我发现自己越少走出它进行数据操作。我的印象是，我的代码变得更加简洁，结果节省了大量时间。</p><p id="73d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在这篇文章中，我想和你们分享一些我现在离不开的功能——我相信你会发现它们和我一样有用。</p><p id="d789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是呆在室内的时候了，所以今天我使用来自<a class="ae ky" href="https://www.kaggle.com" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的<a class="ae ky" href="https://www.kaggle.com/shivamb/netflix-shows" rel="noopener ugc nofollow" target="_blank">网飞电影数据集</a>。如果没有别的，你可能已经发现了一些值得看的东西:)。</p><h1 id="1fa1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在开始之前</h1><h2 id="5abb" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated"><code class="fe mz na nb nc b">Packages</code></h2><p id="daf2" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我假设您熟悉 python。即使你相对较新，这个教程也不应该太难。</p><p id="5b52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要<code class="fe mz na nb nc b">pandas</code>和<code class="fe mz na nb nc b">plotly</code>。用一个简单的<code class="fe mz na nb nc b">pip install [PACKAGE_NAME]</code>安装每一个(在您的虚拟环境中)。</p><h1 id="924f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">内容，内容无处不在</h1><p id="b1a0" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">使用以下命令将网飞<code class="fe mz na nb nc b">csv</code>数据文件加载到熊猫数据帧中:</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="c77b" class="mn lw it nc b gy nm nn l no np">nf_df = pd.read_csv('srcdata/netflix_titles.csv')</span></pre><p id="17e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用<code class="fe mz na nb nc b">.head()</code>方法检查数据帧。</p><p id="adbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，这引出了我的第一个建议。</p><h2 id="540c" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">在熊猫中设定显示选项</h2><p id="a1d4" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">如果你像我一样，不使用 Jupyter notebook 或其变体，你可能会对 Python 外壳中熊猫有限的显示宽度感到沮丧。</p><p id="4241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是运行<code class="fe mz na nb nc b">nf_df.head()</code>时输出的样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这并不能告诉你太多…</p></figure><p id="77ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没那么有用。但是等等！Pandas 有一个<code class="fe mz na nb nc b">.set_option</code>功能，您可以使用它来调整要显示的列数，以及显示的总宽度。将您的参数设置为如下所示:</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="ed7a" class="mn lw it nc b gy nm nn l no np">pd.set_option('display.max_columns', desired_cols)<br/>pd.set_option('display.width', desired_width)</span></pre><p id="ec1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您的 shell 将输出更有用的东西。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更有用的输出</p></figure><p id="6242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他可以通过<code class="fe mz na nb nc b">.set_option</code>功能设置的选项——如果您有兴趣，可以在这里查看<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.set_option.html" rel="noopener ugc nofollow" target="_blank">文档。</a></p><h2 id="637e" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">。分配</h2><p id="2928" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">你曾经看到过这条信息吗？</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="7fad" class="mn lw it nc b gy nm nn l no np">&lt;input&gt;:1: SettingWithCopyWarning: <br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/>Try using .loc[row_indexer,col_indexer] = value instead</span></pre><p id="bb37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这从未发生在你身上，你比我更好——你可能已经通过文件或一本书正确地了解了熊猫。</p><p id="57d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而熊猫官方的解释可以在这里<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#why-does-assignment-fail-when-using-chained-indexing" rel="noopener ugc nofollow" target="_blank">找到</a>；但是 TL；dr 版本是，Pandas 警告您，无法确定您是否正在操作数据帧的<em class="nq">副本</em>(在这种情况下，您可能不会更改任何值)。</p><p id="6a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是使用<code class="fe mz na nb nc b">.assign</code>的原因之一。使用<code class="fe mz na nb nc b">.assign</code>，返回一个<em class="nq">新对象</em>，以避免由于<code class="fe mz na nb nc b">SettingWithCopyWarning</code>而导致的潜在混乱，不管实际问题是否存在，该问题经常被提出。</p><p id="01c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，一个更明显的原因是创建一个新的<em class="nq">数据帧，现有的数据帧由于某种原因被保留。正如我提到的，<code class="fe mz na nb nc b">.assign</code>返回一个新的对象，所以我们可以避免类似这样的问题:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e7a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个例子打印 13，因为我们不小心修改了原始数据帧(<code class="fe mz na nb nc b">nf_df</code>)，而在第二个例子中，原始数据帧保持不变，有 12 列。</p><p id="073a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们继续讨论<code class="fe mz na nb nc b">.apply</code>——这可能是熊猫最被低估的功能之一:)。</p><h2 id="970f" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">。应用</h2><p id="db0f" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">如果你和我一样，你可能尝试过在一个循环中操作熊猫数据——可能会做类似这样的事情:</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="4867" class="mn lw it nc b gy nm nn l no np">for i in range(len(nf_df)):<br/>    nf_df.iloc[i, 1] = ...some function here</span></pre><p id="16d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">停下来。没必要这样。</p><p id="8951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe mz na nb nc b">.apply</code>方法的作用。它沿着数据帧的轴对每个元素应用一个函数。让我们来看一些例子。</p><p id="6e07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例 1 —按发布年份统计的内容数量</strong></p><p id="0d41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的数据框架包括一个发布年份的列(<code class="fe mz na nb nc b">release_year</code>)。分布可以绘制如下，如下所示:</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="711e" class="mn lw it nc b gy nm nn l no np">fig = px.histogram(nf_df, x='release_year')<br/>fig.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/0ac2b935d247bd1cb79e93e0f1798d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZnBqkc76L3k0RVr_drc0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按年份划分的网飞图书发行数据直方图</p></figure><p id="2613" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想看十年的数据呢？简单—创建一个新列<code class="fe mz na nb nc b">‘decade’</code>,如下所示:</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="75da" class="mn lw it nc b gy nm nn l no np">nf_df['decade'] = nf_df.release_year.apply(lambda x: str(x)[:3]+'0s')</span></pre><p id="bfc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们通过<code class="fe mz na nb nc b">nf_df.release_year</code>获取<code class="fe mz na nb nc b">release_year</code>列数据，并应用 lambda 函数<code class="fe mz na nb nc b">lambda x: str(x)[:3]+’0s’</code>。</p><p id="5efe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Lambda 函数看起来令人困惑，但是一旦你习惯了，它就非常简单。在这里，它抓取每个元素(<code class="fe mz na nb nc b">x</code>)，首先应用转换<code class="fe mz na nb nc b">str(x)[:3]</code>获得年份字符串的前 3 个字母，并在末尾添加<code class="fe mz na nb nc b">’0s’</code>。</p><p id="eb54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，看看我们新十年专栏的柱状图:</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="7cf1" class="mn lw it nc b gy nm nn l no np">fig = px.histogram(nf_df, x='decade', category_orders={'decade': np.sort(nf_df.decade.unique())})<br/>fig.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/e5f4dcdcbf4b9c5f4f272d035ae28f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cUkOllaaWxBCMMJRlgsRbQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按十年划分的网飞图书发行数据直方图</p></figure><p id="1bb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到这有多简单了吗？</p><p id="871d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，你可能已经注意到我使用了<code class="fe mz na nb nc b">.unique()</code>方法。这是一个非常有用的方法，它将返回该列中唯一实体的数组——不要错过它！</p><p id="1f68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧。我们再来看一个使用<code class="fe mz na nb nc b">.apply</code>的例子。</p><p id="6455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例 2 —按来源国统计的内容数量</strong></p><p id="6f72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DataFrame 还包括一个列(“<code class="fe mz na nb nc b">country</code>”)，该列(据我所知)包括内容的来源。</p><p id="5542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速看了一下数据(<code class="fe mz na nb nc b">nf_df[‘country’].nunique()</code>)发现有 555 个(！)唯一实体在<code class="fe mz na nb nc b">country</code>列中。这是怎么回事？</p><p id="d6a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，许多列表包含多个国家名称(例如'<code class="fe mz na nb nc b">United States, India, South Korea, China</code> ') —因此，让我们保留前 20 个名称，并将所有剩余的名称更改为“其他”。</p><p id="7908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe mz na nb nc b">.apply</code>很容易做到。为了清楚起见，我将使用两行代码，但也可能只用一行。准备好了吗？</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="715a" class="mn lw it nc b gy nm nn l no np">top_countries = nf_df.groupby('country')['title'].count().sort_values().index<br/>nf_df['country'] = nf_df.country.apply(lambda x: 'Others' if (x not in top_countries[-20:]) else x)</span></pre><p id="a9da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！再次运行<code class="fe mz na nb nc b">nf_df[‘country’].nunique()</code>，我们看到现在只有 21 个“国家”。</p><p id="4488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的 lambda 函数是一个简单的 if… else 语句，根据具有最高计数的列表检查'<code class="fe mz na nb nc b">country</code>'实体。</p><p id="8135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设每个列还包括内容类型列，我们可以通过按内容类型给每个栏着色来可视化内容数据的细分。</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="229e" class="mn lw it nc b gy nm nn l no np">fig = px.histogram(nf_df, x='country', color='type', category_orders={'country': top_countries},<br/>color_discrete_sequence=px.colors.qualitative.Safe, template='plotly_white')<br/>fig.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/2601bb9b499d668712ca2e8840a0562b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PS90bzBkacIfoSPEGLahvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按来源国家和类型划分的网飞标题直方图</p></figure><p id="eb2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那不是很容易吗？想象一下用一些疯狂的循环函数来做这件事——通过<code class="fe mz na nb nc b">.loc</code>或<code class="fe mz na nb nc b">.iloc</code>索引器找到正确的索引器行/列号。不了，谢谢你。</p><p id="0817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整洁，对不对？</p><p id="51be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅通过这两个简短的函数，您就可以完成以前可能需要一行又一行代码才能完成的事情。尝试一下——我敢打赌你会感到惊喜，并提高你的工作效率。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="10a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这个，比如说👋/关注<a class="ae ky" href="https://twitter.com/_jphwang" rel="noopener ugc nofollow" target="_blank"> twitter </a>，或点击此处获取更新。ICYMI:我还写了这篇关于用 Plotly Dash 构建 web 数据仪表板的文章。</p><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/build-a-web-data-dashboard-in-just-minutes-with-python-d722076aee2b"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">使用 Python 在几分钟内构建一个 web 数据仪表板</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">通过将您的数据可视化转换为基于 web 的仪表板，以指数方式提高功能和可访问性…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><p id="d8c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章也是关于将数据可视化来讲故事的:</p><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/effectively-visualize-data-across-time-to-tell-better-stories-2a2c276e031e"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">随着时间的推移有效地可视化数据，以讲述更好的故事</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">使用 Python 和 Plotly 构建清晰易读的时序数据可视化，以支持您的叙述。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div></div></div>    
</body>
</html>