<html>
<head>
<title>What is a survival bias and how to avoid it?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是生存偏差，如何避免？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-is-a-survival-bias-and-how-to-avoid-it-14296d02c0c2?source=collection_archive---------30-----------------------#2020-02-07">https://towardsdatascience.com/what-is-a-survival-bias-and-how-to-avoid-it-14296d02c0c2?source=collection_archive---------30-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4236a18d5d11e7becb5ad069a732b512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xcwk6czPk2qaeE0V.jpg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">斯蒂芬·凯勒在<a class="ae jg" href="https://pixabay.com/photos/fantasy-clouds-woman-castle-sun-3281795/" rel="noopener ugc nofollow" target="_blank">的照片</a></p></figure><div class=""/><div class=""><h2 id="20b7" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">评估不同的交易策略时，你需要考虑的一个简单因素</h2></div><p id="1948" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我以前的一篇文章中，我<a class="ae jg" href="https://medium.com/swlh/build-a-trading-simulator-in-python-ebe046949dd9" rel="noopener">建造了一个交易模拟器</a>，并展示了一些结果。那些结果好得令人难以置信，然而我却欣喜若狂。有人对我说，我是一种叫做<strong class="la jk"><em class="lu"/></strong>的东西的受害者。</p><p id="05c0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，生存偏见是一种逻辑错误，即专注于在某种过程或一段时间内“幸存”的事物，而忽略那些没有幸存的事物。我想介绍一个简单的方法来帮助你避免同样的错误。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="7ea8" class="mc md jj bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">我的经历</h2><p id="b113" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">如前所述，我建立了一个交易模拟器，并在上面测试了一个策略。测试时间从2000年1月1日至2019年12月31日。在此期间，这一策略在交易S&amp;P500指数成份股时本可以产生9438%的利润。</p><p id="f19c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中一条评论后来透露，我用的是目前活跃的股票。这是真的，整个模拟假设在2000年初，我们观察到组成2019年指数的相同符号。那种假设根本就是错误的！</p><p id="abda" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，当遍历时间时，我应该做以下事情:</p><ol class=""><li id="234a" class="na nb jj la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated">列出2000-1-1年构成S&amp;P500指数的符号。</li><li id="3acb" class="na nb jj la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">对于索引中的每次更新(一个符号被添加，另一个被删除)，我也应该更新我的符号列表。</li></ol><p id="c449" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我看来，这是对抗生存偏见的唯一方法，因为你会把失败者和成功者都考虑进去。</p><blockquote class="no"><p id="de33" class="np nq jj bd nr ns nt nu nv nw nx lt dk translated">“历史是由胜利者书写的”——温斯顿·丘吉尔</p></blockquote><h2 id="5cf6" class="mc md jj bd me mf ny dn mh mi nz dp mk lh oa mm mn ll ob mp mq lp oc ms mt mu bi translated">查找相关数据</h2><p id="9995" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">在谷歌搜索了一些相关数据后，我发现我在寻找的解决方案并不简单。根据<a class="ae jg" href="https://en.wikipedia.org/wiki/List_of_S%26P_500_companies" rel="noopener ugc nofollow" target="_blank">维基百科</a>的数据，在1963年1月1日至2014年12月31日期间，S &amp; P500的成分发生了1186次变化，而这里只列出了其中的227次。显然这不能完全相信。</p><p id="c6b6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">谷歌的另一个结果告诉我，我可以花97美元购买S&amp;P500指数的所有变更列表。出于一点小小的好奇，这有点过分了。我有点惊讶，如此琐碎的知识不是免费分享的。</p><p id="6db4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一个结果很有趣:</p><div class="is it gp gr iu od"><a href="https://nemozny.github.io/datasets/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jk gy z fp oi fr fs oj fu fw ji bi translated">S&amp;P 100/500历史组件</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">特定日期(变更)标准普尔500和S&amp;P 100指数中的公司/指数成分列表。这些数据…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">nemozny.github.io</p></div></div></div></a></div><p id="42b8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这位作者花了很长时间提取索引数据，结果他整理出了一个漂亮的<a class="ae jg" href="https://nemozny.github.io/datasets/sp500-historical-components.json" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> JSON文件</strong> </a>。这些条目包含两个名称-值对:一个用于日期，另一个用于组成S &amp; P500指数的符号。由于它很难阅读，我不打算把整个文件粘贴到这里。相反，下图显示了JSON文件中两个条目的内容。你看它有多长就知道了！</p><figure class="on oo op oq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/f88a66b6aa87d0888de9638766a89a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*048imUitihwhOoaMNLK93w.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">JSON文件中的两个条目。你看它有多长就知道了！</p></figure><p id="c713" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经对JSON文件有了一些了解，让我们开始一些编码工作。</p><h2 id="138e" class="mc md jj bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">把它编成密码</h2><p id="212a" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">如果我们仔细观察这个JSON文件，我们可以看到它是一个字典列表——每个条目都用一个python字典表示。我们可以用下面的代码加载数据:</p><pre class="on oo op oq gt or os ot ou aw ov bi"><span id="e966" class="mc md jj os b gy ow ox l oy oz">import json</span><span id="8518" class="mc md jj os b gy pa ox l oy oz">with open('sp500-historical-components.json') as json_file:<br/>    data = json.load(json_file)</span></pre><p id="76a2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，<code class="fe pb pc pd os b">data</code>只是一个包含不同字典的列表。这个列表是无序的，让它有序可能很好。首先，让我们创建一个日期列表:</p><pre class="on oo op oq gt or os ot ou aw ov bi"><span id="fbf2" class="mc md jj os b gy ow ox l oy oz">dates = []<br/>for entry in data:<br/>    dates.append(entry["Date"])</span></pre><p id="7fe7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的代码终端显示<code class="fe pb pc pd os b">dates</code>列表如下:</p><pre class="on oo op oq gt or os ot ou aw ov bi"><span id="e403" class="mc md jj os b gy ow ox l oy oz">['2012/11/30', '2016/10/31', '2017/04/28', '2017/05/03', '2017/03/31', '2016/12/30', '2016/08/31', '2016/09/30', '2017/01/31', '2017/02/28', '2016/07/29', '2016/06/30', '2016/04/29', '2016/05/31', '2015/10/30', '2015/07/31', '2016/01/29', '2016/02/29', '2016/03/31', '2015/12/31', '2015/11/30', '2015/09/30', '2015/08/31', '2015/06/30', '2015/05/29', '2015/04/30', '2014/12/31', '2015/01/30', '2014/10/31', '2014/11/28', '2015/02/27', '2014/09/30', '2015/03/31', '2014/08/29', '2014/05/30', '2014/06/30', '2014/07/31', '2014/03/31', '2014/04/30', '2013/12/31', '2013/11/29', '2014/01/31', '2014/02/28', '2013/10/31', '2013/08/30', '2013/07/31', '2013/09/30', '2012/12/31', '2013/05/31', '2013/06/28', '2012/10/31', '2013/02/28', '2013/03/28', '2013/01/31', '2013/04/30', '2012/08/31', '2016/11/30', '2012/09/28', '2012/04/30', '2012/06/29', '2012/03/30', '2012/07/31', '2012/05/31', '2012/02/29', '2011/10/31', '2012/01/31', '2011/08/31', '2011/05/31', '2011/06/30', '2011/02/28', '2011/03/31', '2010/12/31', '2010/11/30', '2011/12/30', '2011/11/30', '2010/09/30', '2010/10/29', '2011/09/30', '2011/07/29', '2010/06/30', '2011/04/29', '2011/01/31', '2010/02/26', '2010/01/29', '2009/12/31', '2010/08/31', '2010/04/30', '2010/07/30', '2010/03/31', '2010/05/28', '2009/09/30', '2009/08/31', '2009/10/30', '2009/04/30', '2009/11/30', '2009/03/31', '2009/06/30', '2009/07/31', '2009/02/27', '2009/05/29', '2009/01/30', '2008/10/31', '2008/11/28', '2008/12/31', '2008/09/30', '2008/08/29', '2008/07/31', '2008/06/30', '2008/04/30', '2008/05/30', '2008/01/31', '2008/02/29', '2008/03/31']</span></pre><p id="0331" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以肯定地看到我们的数据列表是无序的。此外，日期从2008年到2017年。由于这个列表中的日期不多(大约100个)，我们可以使用一种健壮的方式来调用有序数据:</p><pre class="on oo op oq gt or os ot ou aw ov bi"><span id="42c6" class="mc md jj os b gy ow ox l oy oz">datescopy = dates.copy()<br/>datescopy.sort()</span><span id="8c1f" class="mc md jj os b gy pa ox l oy oz">indices = []<br/>for date in datescopy:<br/>    indices.append(dates.index(date))</span></pre><p id="405d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个方法创建了一个<code class="fe pb pc pd os b">dates</code>的副本，并对其进行排序。一个列表<code class="fe pb pc pd os b">indices</code>帮助我们映射有序和无序数据之间的日期。自己看:</p><pre class="on oo op oq gt or os ot ou aw ov bi"><span id="93bb" class="mc md jj os b gy ow ox l oy oz">for index in indices:<br/>    print(data[index]["Date"])</span></pre><p id="77bb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打印出来的日期是有序的。酷！</p><p id="4268" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设你想回测你的交易策略。您已经创建了您的交易模拟器，并特别希望包括2008年1月31日至2017年5月3日期间S&amp;P500的股票。</p><p id="b956" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你用<code class="fe pb pc pd os b">data[indices[0]]["Symbols"]</code>初始化你的可交易符号，一旦根据<code class="fe pb pc pd os b">data</code>有了更新，你也随着时间的推移更新你的符号列表。</p><p id="c9af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法简单易行，效果很好。不幸的是，这些数据在2017年停止，并且不再定期更新。如果你有更好的免费数据，请在评论中告诉我。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="3188" class="mc md jj bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">摘要</h2><ol class=""><li id="ebfc" class="na nb jj la b lb mv le mw lh pe ll pf lp pg lt nf ng nh ni bi translated">维基百科https://en.wikipedia.org/wiki/List_of_S%26P_500_companies S&amp;P500组件列表:<a class="ae jg" href="https://en.wikipedia.org/wiki/List_of_S%26P_500_companies" rel="noopener ugc nofollow" target="_blank"/></li><li id="6e48" class="na nb jj la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">数据集的链接:<a class="ae jg" href="https://nemozny.github.io/datasets/" rel="noopener ugc nofollow" target="_blank">https://nemozny.github.io/datasets/</a></li></ol><h2 id="6cd1" class="mc md jj bd me mf mg dn mh mi mj dp mk lh ml mm mn ll mo mp mq lp mr ms mt mu bi translated">资源</h2></div></div>    
</body>
</html>