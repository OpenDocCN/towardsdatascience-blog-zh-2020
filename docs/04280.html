<html>
<head>
<title>Preprocess and prepare a face dataset ready for CNN models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预处理和准备面部数据集，为 CNN 模型做好准备</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/preprocess-and-prepare-a-face-dataset-ready-for-cnn-models-885867907eb0?source=collection_archive---------20-----------------------#2020-04-18">https://towardsdatascience.com/preprocess-and-prepare-a-face-dataset-ready-for-cnn-models-885867907eb0?source=collection_archive---------20-----------------------#2020-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="61b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们使用 Google Colab、TensorFlow 和 Dlib 从 IMDB-WIKI 数据集中提取人脸，并以 CNN 友好的格式存储在 Google Drive 中。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/18ad88964c14cff5061a4ab47a11a7b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*iFAPSA-JszAEQEnH5RSflA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来源:IMDB-WIKI 数据集</p></figure><p id="1ade" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你好朋友们。在本文中，我将对 IMDB-WIKI 数据集进行预处理，从这些图像中提取人脸，并将它们与其他有用的信息(如姓名、年龄和性别)一起保存到 Google Drive。数据将作为对象本身存储在。泡菜格式。最棒的是，你不必在你的机器上运行一行代码，而是在 Google Colab 上运行。</p><p id="919c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在深入研究我们的代码之前，我将简要介绍一下 Google Colabs。你是否曾经担心过你的电脑处理能力不够或者你缺少一个 GPU，现在你不必再担心了，因为谷歌已经通过谷歌实验室提供了一个解决方案。通过你的浏览器在谷歌的服务器上使用 GPU 进行令人眼花缭乱的快速执行。<br/> Google Colabs 为用户提供了一个 Jupyter 笔记本，用于交互式编码体验。它与 GitHub 无缝连接。您创建的所有笔记本都存储在您的 google drive 中。</p><p id="cd19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们将使用 Google Colabs，我建议您学习 Jupyter 笔记本的工作原理，因为它会让您对环境感到更加舒适。如果你想了解更多关于 Google Colab 的信息，你可以阅读这篇由<a class="lr ls ep" href="https://medium.com/u/4b0ee587f4d1?source=post_page-----885867907eb0--------------------------------" rel="noopener" target="_blank"> fuat </a>撰写的<a class="ae lq" href="https://medium.com/deep-learning-turkey/google-colab-free-gpu-tutorial-e113627b9f5d" rel="noopener"> Google Colab 免费 GPU 教程</a>。</p><p id="9837" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们开始编码之前，让我简单介绍一下我们将如何从这里开始。</p><ul class=""><li id="ac37" class="lt lu it kw b kx ky la lb ld lv lh lw ll lx lp ly lz ma mb bi translated">我将在 Google Colab 上创建一个笔记本</li><li id="a525" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">我们将把 Google drive 安装到笔记本上。</li><li id="e780" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">我们将使用这个笔记本来提取和处理数据集，并将其保存在我们的 Google Drive 中。</li></ul><p id="f79d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文结束时，您将准备好使用 CNN 模型的数据集。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="9347" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">我们开始吧。</h1><p id="ac5f" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">在本文中，我详细解释了预处理过程中需要的每个步骤。我还解释了每一行代码，这样你就不会感到困惑。</p><h2 id="2f6f" class="nl mp it bd mq nm nn dn mu no np dp my ld nq nr na lh ns nt nc ll nu nv ne nw bi translated">1)创建您的第一个笔记本</h2><p id="12f7" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">访问<a class="ae lq" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Colabs </a>主页。您将看到一个欢迎笔记本。如果您还没有登录您的 Google 帐户，请登录。已经签到的可以跳过这一步。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi nx"><img src="../Images/cf72302922b09c6d521bc15fa12c1fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbxc28tUIJ2AkAHYczIfpg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 1:显示 Colab 笔记本上的登录按钮</p></figure><p id="49f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">登录后，您将看到一个弹出框。点击右下角的“新建笔记本”按钮。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi oc"><img src="../Images/e1dcce8cc6a3b8480cd44931a77a2741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZ19YPD8XXYX0xmlRy1s6Q.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 2:创建新笔记本</p></figure><p id="ac6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将创建一个新笔记本，您将被重定向到该笔记本。它也将被保存在你的硬盘中一个名为 Colab Notebooks 的文件夹中。</p><p id="ceae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在将你的笔记本重命名为“extract _ data _ and _ preprocess . ipynb”。</p><h2 id="93aa" class="nl mp it bd mq nm nn dn mu no np dp my ld nq nr na lh ns nt nc ll nu nv ne nw bi translated">2)开始编码</h2><p id="24e1" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">打开您创建的“extract data _ and _ preprocess . ipynb”笔记本。</p><p id="64ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">将运行时类型改为 GPU: </strong></p><ul class=""><li id="0a32" class="lt lu it kw b kx ky la lb ld lv lh lw ll lx lp ly lz ma mb bi translated">点击运行时选项，然后转到“更改运行时类型”。</li><li id="b33b" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">选择硬件加速器选项，将其从无更改为 GPU 并保存。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/a307756d9aaebc6bb7c5c9cedb8a12cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*veZW3GnCP_yh3_TAT4CmKg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 4:将运行时改为 GPU</p></figure><p id="0d59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将你的谷歌硬盘安装到你的笔记本上。</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="2e09" class="nl mp it of b gy oj ok l ol om"><strong class="of iu">Note:</strong> You will be able to mount your drive only after you have connected to a runtime. To connect to a runtime if not connected already click on the connect button on the top right corner.</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi on"><img src="../Images/884382c4ce2913004706ba19d36bb649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UwY3RbacbZfx6j3l73txSg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 5:安装 Google Drive</p></figure><p id="e38b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们必须导入我们将在整个数据预处理过程中使用的所有包。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块 1:导入所需的包。</p></figure><p id="fed4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Colab 中，可以在不同的单元格中编写代码，并以您喜欢的任何顺序逐一执行它们。现在，执行导入所有包的单元格。</p><p id="bb6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用 dlib 的基于 CNN 的人脸识别模型来从我们的数据集中的图像中检测和提取人脸。基于 CNN 的模型比 dlib 中的 Hog 模型慢，但更精确。要了解更多关于他们的区别，请阅读由<a class="lr ls ep" href="https://medium.com/u/9af1b843339?source=post_page-----885867907eb0--------------------------------" rel="noopener" target="_blank">阿伦·彭努萨米</a>撰写的文章<a class="ae lq" rel="noopener" target="_blank" href="/cnn-based-face-detector-from-dlib-c3696195e01c">基于 CNN 的 dlib </a>人脸检测器。</p><p id="badb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们必须下载 CNN 模型运行所需的权重。因此，在一个新的单元格中，让我们编写代码来下载权重。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块 2:下载 Dlib 的 CNN 人脸识别模型的权重。</p></figure><p id="ec8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我来解释一下代码:</p><p id="5646" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 2 行:</strong>我已经使用 Keras 库中的 get_file 函数下载了权重。下载的文件将存储为“mmod _ human _ face _ detector . dat . bz2”</p><p id="652d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 3 行:</strong>‘cache _ subdir’—此处必须给出下载文件的存储路径。</p><p id="8b8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 4 行:</strong>‘origin’—待下载文件的下载网址</p><p id="aa7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 6–10 行:</strong>在这些行中，使用 bz2 包打开下载的压缩文件，以二进制格式读取内容并存储在“mmod_human_face_detector.dat”文件中。该文件稍后将被 CNN 模型使用。</p><p id="b514" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来让我们下载数据集。IMDB-WIKI 数据集拥有超过 45 万张图片。处理这么多的图像并从中提取数据将花费很多时间，所以我将只使用维基数据集中的那些图像。那些希望使用 IMDB-WIKI 的人可以在下面的代码中替换“dataset_url”，将“data_key”值更改为“IMDB ”,将“mat_file”值更改为“imdb.mat”。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块 3:下载和提取数据集。</p></figure><p id="2814" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 1–2 行:</strong>数据集的下载 URL 和将从文件中提取的文件夹名称。文件夹名称与提取无关，稍后我们的代码中将会用到它。</p><p id="b867" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 4–7 行:</strong>使用与之前相同的功能，并给它一个不同的下载 URL。我们将“extract”参数设置为 True，这样函数将自己提取数据集。之前我们没有使用相同的函数提取，因为 bz2 文件格式不支持提取。</p><p id="8050" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 9 行:</strong>‘wiki’是所有图像元数据存在的密钥。当您加载。mat 文件并查看它。</p><p id="1de6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第十行:</strong>的名字。包含图像元数据的 mat 文件。</p><p id="a2c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在已经下载并提取了数据集。让我们加载。解压缩的文件夹中存在 mat 文件。由于文件是 MatLab 格式，我们必须将其转换为 Python 数据类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块 4:加载。mat 文件和初始化所需变量</p></figure><p id="f60b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第 1 行:我们正在加载。使用 scipy 包处理数据格式转换的 mat 文件。</p><p id="12d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 2 行:</strong>加载的文件为字典格式。它有一个关键的“维基”，其中有其余的数据。为了更好地理解加载文件中的所有数据，您可以打印字典或访问<a class="ae lq" href="https://data.vision.ee.ethz.ch/cvl/rrothe/imdb-wiki/" rel="noopener ugc nofollow" target="_blank"> IMDB_WIKI </a>网站。</p><p id="2c1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 3 行:</strong>我们将所有图像的路径加载到 route 变量中。文件中的数据不是一种非常容易访问的格式，所以不要与我使用的多维数组访问相混淆。</p><p id="2dd7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 4–9 行:</strong>初始化所有基本变量。</p><p id="4008" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">准备数据集的所有要求现在都已完成。在我们开始处理它之前，让我们编写代码来看看我们从数据集得到了什么，我们是如何处理它的，以及我们将要存储什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块 5:查看我们将要存储哪种图像的代码</p></figure><p id="9b00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 1 行:</strong>创建 dlib 的基于 CNN 的人脸检测模型的对象。的。作为参数传递的 dat 文件是我们首先下载并提取的文件。</p><p id="de01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 6 行:</strong>选择一个随机索引，从该路径加载图像并显示。</p><p id="74b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第 7 行:让这一行保持原样，我将在下一步简要解释。</p><p id="39db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 8 行:</strong>从给定路径加载图像</p><p id="79c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 9 行:</strong>由于 OpenCV 使用 BRG 格式，我们正在将图像转换为标准的 RGB 格式。</p><p id="330d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 10 行:</strong>查找给定图像的面部坐标。它将返回图像中人脸的坐标列表。</p><p id="86af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 11–22 行:</strong>使用 dlib 模型提供的人脸坐标，我们在人脸周围画一个方框。然后，我们使用 TensorFlow 提供的 crop_to_bounding_box 函数裁剪出该区域。然后我们显示两幅图像。裁剪后的人脸图像是每幅图像将要拍摄和存储的内容。</p><p id="4d56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您执行上面的单元时，您将看到来自您的数据集中的两个随机图像，这将向您显示图像将如何被处理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/ca3967d77e159493c8e5a0467d68874b.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*M9JWwuRBOIeX8CoG_rXKkA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 6:显示提取的人脸样本。(来源:IMDB-WIKI 数据集)</p></figure><p id="83db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">终于到了处理整个数据集并从中提取我们需要的数据的时候了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块 6:处理图像并提取人脸和其他所需数据。</p></figure><p id="d48d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 4 行:</strong>对数据集中的所有图像运行一个循环，“I”是我们用来从 route 变量中的列表获取第 I 个路径的索引。然后，我们在该路径获取图像。这样，我们可以读取数据集中的所有图像。</p><p id="0fdd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 7 行:</strong>使用 try-except 块，不要让一些错误的图像阻止我们的进程。</p><p id="1f79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 8–9 行:</strong>我正在访问的数据是创建该数据集的人对图像集的面部评分。所以我们忽略了所有没有人脸的图片。这将加快提取速度。我们还检查我们试图访问的图像的性别数据是否也可用。这将有助于我们忽略数据集中存在的所有破损图像。</p><p id="4c5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 10–14 行:</strong>如前所述，读取图像并检测其中的人脸。</p><p id="dcab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 15 行:</strong>我们只考虑一个只有一张脸的图像。</p><p id="fc6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 18 行:</strong>取 CNN 模型返回的人脸坐标。有时，当人脸出现在图像的角落时，模型往往会给出图像外部的坐标，使用 max 函数，我们可以确保坐标在图像内部。</p><p id="9d12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 19–22 行:</strong>获取脸部的高度和宽度。该模型返回“左上”和“右下”坐标。在下一行中，我们确保坐标在图像中。</p><p id="9f06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 24 行:</strong>使用 TensorFlow 的 image 类提供的函数从图像中裁剪人脸。</p><p id="7183" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 28 行:</strong>将图像大小调整为 32x32，因为图像大小对于任何 CNN 模型的训练都无关紧要，所以，我们可以减少图像所消耗的空间。</p><p id="b528" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 31 行:</strong>将提取的、调整大小的面部图像附加到图像列表。</p><p id="1c64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 32 行:</strong>出生日期以序数日期格式给出。因此，使用 datetime 类，我们将序数日期转换为 datetime 类对象，从中我们可以单独提取年份。</p><p id="9443" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 33–35 行:</strong>将各个数据添加到各自的数组中。</p><p id="fc0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 37–51 行:</strong>处理上述过程中发生的异常。所有阵列中数据的一致性非常重要。因此，当错误发生时，我们从列表中弹出图像数据和其他元数据。</p><p id="b323" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经完成了数据集的处理，是时候将数据存储到我们的驱动器中了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块 7:保存包含所有已处理数据的字典。</p></figure><p id="ba67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 1–7 行:</strong>用我们提取的数据创建字典。</p><p id="ba4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 8–9 行:</strong>检查我们将要存储数据的目录是否存在，如果不存在，我们就创建它。</p><p id="111b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">第 10–12 行:</strong>我们在追加二进制模式下创建一个文件，并将我们的字典转储到其中。</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="ee1a" class="nl mp it of b gy oj ok l ol om"><strong class="of iu">Note: </strong>While dumping a huge object to Google Drive, it is advisable to break the data into parts and store it. The session may crash and the runtime will restart if a large file is being stored in the drive.</span></pre><p id="fa38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我附上了我的“extract _ data _ and _ preprocess . ipynb”笔记本的链接供你参考<a class="ae lq" href="https://colab.research.google.com/drive/1U5Or-riULEZTsmO7En_h85_HqgIPEVlN" rel="noopener ugc nofollow" target="_blank">https://colab . research . Google . com/drive/1 u5 or-riuleztsmo 7 en _ h85 _ HqgIPEVlN</a>。</p><p id="aabf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望这篇文章值得你阅读。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="0b35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如有任何疑问，请随时联系我。</p><p id="22c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Instagram: <a class="ae lq" href="https://www.instagram.com/nachijr4/" rel="noopener ugc nofollow" target="_blank"> nachijr4 </a></p><p id="2e3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">电子邮件:nachi2muthu13@gmail.com</p><p id="ec9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">中等:<a class="ae lq" href="https://medium.com/@nachi2muthu13" rel="noopener">纳赤木图</a></p><p id="6d4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">领英:<a class="ae lq" href="https://www.linkedin.com/in/nachi-muthu-4351a5112/" rel="noopener ugc nofollow" target="_blank">纳奇穆图</a></p></div></div>    
</body>
</html>