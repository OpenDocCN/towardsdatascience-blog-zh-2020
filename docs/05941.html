<html>
<head>
<title>Natural Language Processing Pipeline Decoded!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自然语言处理流水线解码！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/natural-language-processing-pipeline-decoded-f97a4da5dbb7?source=collection_archive---------34-----------------------#2020-05-15">https://towardsdatascience.com/natural-language-processing-pipeline-decoded-f97a4da5dbb7?source=collection_archive---------34-----------------------#2020-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/34f7b36b77dd68a91614024977a3a9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jDFUfJs6Kt47osqGR3xaYg.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.shutterstock.com/image-illustration/natural-language-processing-concept-word-cloud-201226490" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="d0f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自然语言是我们书写、说话和理解的语言。世界上几乎所有已知的语言都属于自然语言的范畴。自然语言处理是处理语言的书面形式并使计算机理解它们的任务。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="83be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来谈谈为了让自然语言<strong class="ki iu">机器或深度学习模型做好准备所需的一些非常基本的任务。</strong></p><blockquote class="ll lm ln"><p id="fcb0" class="kg kh lo ki b kj kk kl km kn ko kp kq lp ks kt ku lq kw kx ky lr la lb lc ld im bi translated"><strong class="ki iu">句子分割</strong></p><p id="f0fb" class="kg kh lo ki b kj kk kl km kn ko kp kq lp ks kt ku lq kw kx ky lr la lb lc ld im bi translated"><strong class="ki iu">转换成小写</strong></p><p id="c83b" class="kg kh lo ki b kj kk kl km kn ko kp kq lp ks kt ku lq kw kx ky lr la lb lc ld im bi translated"><strong class="ki iu">词语的标记化</strong></p><p id="3c56" class="kg kh lo ki b kj kk kl km kn ko kp kq lp ks kt ku lq kw kx ky lr la lb lc ld im bi translated"><strong class="ki iu">删除标点符号、特殊字符和停用词</strong></p><p id="03a1" class="kg kh lo ki b kj kk kl km kn ko kp kq lp ks kt ku lq kw kx ky lr la lb lc ld im bi translated"><strong class="ki iu">词汇化/词干化</strong></p><p id="89a3" class="kg kh lo ki b kj kk kl km kn ko kp kq lp ks kt ku lq kw kx ky lr la lb lc ld im bi translated"><strong class="ki iu">创建单词袋模型/ TF-IDF模型</strong></p></blockquote><p id="0634" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面就一个一个说吧。</p><p id="b78f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="lo">句子分割</em> </strong>是一个众所周知的文本分割子任务。文本分割基本上是将给定的文本分成逻辑上可理解的信息单元。一个这样的逻辑单元的例子是句子。因此，将给定文本划分成句子的任务被称为句子分割。这项任务是处理文本的第一步。将包含大量文本的文档分成句子有助于我们逐句处理文档，从而不会丢失它们可能包含的重要信息。</p><p id="9442" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，句子分割取决于文档的性质和文档遵循的句子边界的类型。例如，在一个文档中，文本可以根据“.”分成句子而在另一个文档中，文本可以根据换行符或“\n”来划分。因此，在进行句子分割之前，查看您的文档并在尝试句子分割之前找到合理的句子边界是非常重要的。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ls"><img src="../Images/fdea982b94b87a5f1df99d9b0a73f7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LmP7v0fRyjuFQjg_XSdHDg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">句子分割插图</p></figure><p id="cf25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上图展示了一个例子，说明了<a class="ae kf" href="https://spacy.io/" rel="noopener ugc nofollow" target="_blank"> spacy </a>如何通过使用句号将给定文本分成两个句子来帮助执行句子分割。</p><p id="e588" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个任务通常是<strong class="ki iu"> <em class="lo">将所有句子转换成小写</em> </strong>。在你不想根据大小写来区分单词的问题中，这是很重要的。例如，如果您的任务是分类，那么<em class="lo">“Run”</em>和<em class="lo">“Run”</em>是相同的单词，不应该被您的模型视为两个不同的单词。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lx"><img src="../Images/fe2f05fd346702140f649229d9141871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2FZhzExPMBt5_gKB1Qfsw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">转换成小写插图</p></figure><p id="654e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个很好的反例是命名实体识别问题(NER)，在这种情况下，转换为小写可能会导致重要信息的丢失。如果一个句子中的所有单词都被转换成小写字母，那么对系统来说，识别命名实体就变得更加困难。如果所有单词都转换成小写，即使像spacy等库也无法识别准确的命名实体。因此，在尝试将文档中的所有单词小写之前，理解问题的细微差别是非常重要的。</p><p id="b629" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个要理解的任务是<strong class="ki iu"> <em class="lo">单词标记化</em> </strong>。标记化是把一个句子分成单词的过程。这样做是为了让我们能够理解(语料库的)每个句子中包含的句法和语义信息。因此，我们通过逐字分析来破译句子的相关性，从而确保没有信息丢失。可以基于不同的试探法或单词边界(如空格、制表符等)来执行句子的标记化。一个这样的例子如下所示。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ly"><img src="../Images/630eeb6c246ce9b15ac69e5d57a94139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5alAGsPVOmdpZ23xTHRqMQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">文字插图的符号化</p></figure><p id="88fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，spacy检测单词边界并帮助标记给定的文本。</p><p id="697c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们<strong class="ki iu"> <em class="lo">去掉标点符号</em> </strong>以确保我们没有“，”，”等等在我们的令牌列表中。这在几个问题类型中很重要，因为在使用机器或深度学习算法处理自然语言时，我们通常不关心标点符号。因此，移除它们似乎是明智之举。你可以通过遍历你的标记列表来删除标点符号，也可以从一开始就把它们从每个句子中删除。后者如下所示。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lz"><img src="../Images/ab66e395094dfa99c13317a15d942703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pvPOC_tHMnBSYS1CBNNmwA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">标点符号移除插图</p></figure><p id="0d81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步通常是<strong class="ki iu"> <em class="lo">去掉特殊字符</em> </strong>比如<em class="lo">"！@#$%^&amp;*</em>来自令牌化后接收到的令牌列表。这是根据需要完成的，并且高度依赖于您试图解决的问题类型。例如，你可以尝试在给定的语料库中检测推文，删除像<em class="lo"> '@' </em>这样的特殊字符可能对你的努力没有帮助，因为人们通常在推文中使用<em class="lo"> '@' </em>。下面显示的是一个代码片段，如果您的问题需要，它可以帮助您从句子中删除任何特殊字符(使用python: re的regex库)。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ma"><img src="../Images/5dc2c212f47c84b835f1d7ae95a95539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfaub3eevX-8IDNDICljKw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">特殊字符删除说明</p></figure><p id="5cfd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个重要步骤是<strong class="ki iu"> <em class="lo">去除停用词</em> </strong>。<em class="lo">停用词</em>是任何语言中最常见的词。为了方便起见，让我们假设英语是我们的主要语言。一些最常见的停用词有<em class="lo">、【in】、【and】、【a】、</em>等。这是重要的一步，因为你不希望你的模型在没有任何意义的单词上浪费时间，停用词本身几乎不包含任何意义。它们可以很容易地从一个句子或一列标记中删除，而不会导致太多的信息损失，从而加快模型的训练过程。因此，在尝试训练模型之前删除它们几乎总是一个好主意。</p><p id="a39e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">给出的图像显示了如何使用<a class="ae kf" href="https://www.nltk.org/" rel="noopener ugc nofollow" target="_blank"> nltk </a>来完成这一操作。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mb"><img src="../Images/e51ae40c781a6a705c55f840d5bfdd18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1WA1IkDVvm7GnLO1za8V9w.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">停用字词删除图示</p></figure><p id="abc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个任务通常是<strong class="ki iu"> <em class="lo">词汇化和/或词干化</em> </strong>。这两个过程都涉及到单词的规范化，因此只有单词的基本形式保留下来，从而保持了完整的意思，但删除了所有的屈折词尾。这是一个重要的步骤，因为你不希望你的模型把像<em class="lo">“running”</em>和<em class="lo">“run”</em>这样的单词当作单独的单词。</p><p id="e3dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">词汇化使用形态分析和词汇来识别基本单词形式(或词汇),而词干化通常砍掉词尾，如<em class="lo">、【ing】、【s】、</em>等，希望找到基本单词。下图显示了两者的区别。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/6927da624dec1feedf3339a6c4d37437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iG-YYgjyefuV9E27XYekmA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">词汇化v/s词干插图</p></figure><p id="a79f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，上图中的lemmatizer正确地识别出单词<em class="lo">【语料库】</em>有基础形式<em class="lo">【语料库】</em>，而斯特梅尔没有检测到这一点。但是，词干分析器正确地将<em class="lo">【rock】</em>识别为<em class="lo">【rocking】</em>的基本形式。因此，使用词汇化或词干化，或者两者都用，很大程度上取决于您的问题需求。</p><p id="44d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们已经讨论了处理文本数据所必需的基本思想，那么让我们来谈谈如何将文本转换成机器可学习的形式。一种这样的技术是创建<strong class="ki iu"> <em class="lo">单词袋模型</em> </strong>。单词包只是简单地计算文本中出现的所有单词的数量。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/9c5aa2a205e9c68ef03c8d5e99cac254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GL6hPyG5QFjKJGmR1Ysq5w.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">单词袋模型插图</p></figure><p id="38ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面给出的代码首先获取一个包含4个句子的语料库。然后它使用<a class="ae kf" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html" rel="noopener ugc nofollow" target="_blank"> sklearn的计数矢量器</a>创建一个单词包模型。换句话说，它创建了一个模型，其中包含关于语料库中每个唯一单词在每个句子中出现多少次的信息(我们使用<em class="lo">矢量器. get_feature_names() </em>)。为了方便起见，我增加了一列<em class="lo">【句子】</em>，帮助我们理解哪个计数值对应哪个句子。此外，代码中的最后一行创建了一个<em class="lo"> "bow.csv" </em>文件，该文件包含与所有单词对应的所有上述计数，如下所示。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/b0ede00a01e252e8526c05080309a6b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYt2gduO0KpYPX0ewT4BHA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">单词袋模型插图</p></figure><p id="fd0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个这样的模型叫做<strong class="ki iu"> <em class="lo">词频逆文档频率(TF-IDF)模型。</em> </strong>该模型在词频(TF)和逆文档频率(IDF)之间找到一个折衷。词频是每个词在给定文本语料库或文档中出现的次数(如词袋模型图所示)。逆文档频率是单词在语料库中的文档中出现的次数的倒数。换句话说，术语频率发现一个单词有多常见，逆文档频率发现一个单词有多罕见。</p><p id="d1a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们看看如何在python中实现它。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mf"><img src="../Images/746cd8b95b1c9465805f37e4eb4734e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkThucu2uXu673o4tuZ2hQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">TF-IDF插图</p></figure><p id="0c2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面给出的代码首先获取一个包含4个句子的语料库。然后，它使用<a class="ae kf" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html" rel="noopener ugc nofollow" target="_blank"> sklearn的TF IDF矢量器</a>创建一个包含TF-IDF值的TF-IDF模型。代码还创建了一个文件<em class="lo">“tfi df . CSV”</em>，其中包含了语料库中的唯一单词，作为列，以及它们对应的TF-IDF值，作为行，以帮助理解模型创建背后的思想。它创建的文件类型的一个例子如下所示。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ls"><img src="../Images/3e37d5a195577e56051589fb4e2ada0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFtfjUQ_R6SUyBCKgn7Onw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">TF-IDF模型图</p></figure><p id="376e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您可以使用这些模型中的任何一个作为文本分类、情感分析等问题的训练数据。现在您已经理解了处理文本数据的基础，您已经准备好开始您的第一个项目了！</p><p id="04aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章的全部代码可以在<a class="ae kf" href="https://github.com/AnanyaBanerjee/Medium-Article-Code/blob/master/basics_of_nlp.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> <em class="lo">这里</em> </strong>找到。</a>请注意，jupyter笔记本中的每个单元格都可以独立运行(由于单元格特定的导入语句，为了方便起见),您可能希望将代码顶部的所有内容只导入一次，而不是多次导入！</p><p id="5e37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这篇文章能帮助你理解如何使用自然语言，并有朝一日开始你掌握自然语言处理的旅程！</p><p id="31db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lo">感谢您的阅读！</em></p><p id="09d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">附言:如果你有任何问题，或者你想让我写任何特定的话题，请在下面评论。</p><p id="7a8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">参考文献:</strong></p><ol class=""><li id="fb85" class="mg mh it ki b kj kk kn ko kr mi kv mj kz mk ld ml mm mn mo bi translated">语音和语言处理，第三版，作者<a class="ae kf" href="http://web.stanford.edu/people/jurafsky/" rel="noopener ugc nofollow" target="_blank">丹·茹拉夫斯基</a>和<a class="ae kf" href="http://www.cs.colorado.edu/~martin/" rel="noopener ugc nofollow" target="_blank">詹姆斯·h·马丁</a></li><li id="535f" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld ml mm mn mo bi translated"><em class="lo">sk learn:</em><a class="ae kf" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank">https://scikit-learn.org/stable/</a></li><li id="397b" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld ml mm mn mo bi translated"><em class="lo">空间</em>:<a class="ae kf" href="https://spacy.io/" rel="noopener ugc nofollow" target="_blank">https://spacy.io/</a></li><li id="1130" class="mg mh it ki b kj mp kn mq kr mr kv ms kz mt ld ml mm mn mo bi translated"><em class="lo">NLTK:</em>T18】https://www.nltk.org/</li></ol></div></div>    
</body>
</html>