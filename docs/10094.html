<html>
<head>
<title>A comprehensive ML Metadata walkthrough for Tensorflow Extended</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tensorflow Extended 的全面 ML 元数据演练</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-comprehensive-ml-metadata-walkthrough-for-tensorflow-extended-953230770867?source=collection_archive---------28-----------------------#2020-07-16">https://towardsdatascience.com/a-comprehensive-ml-metadata-walkthrough-for-tensorflow-extended-953230770867?source=collection_archive---------28-----------------------#2020-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="57a0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它存在的原因以及它在 Beam 管道组件中的使用方式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3d8a93d02d2950698892b4ef37a651a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEJLMX1sC6AtbTwNQGnbuA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://www.tensorflow.org/tfx/guide/mlmd" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/tfx/guide/mlmd</a></p></figure><blockquote class="kz"><p id="d0b1" class="la lb it bd lc ld le lf lg lh li lj dk translated"><a class="ae ky" href="https://github.com/google/ml-metadata" rel="noopener ugc nofollow" target="_blank"> <em class="lk"> ML 元数据(MLMD) </em>是一个用于记录和检索与 ML 开发人员和数据科学家工作流相关的元数据的库。</a></p><p id="b84d" class="la lb it bd lc ld ll lm ln lo lp lj dk translated"><a class="ae ky" href="https://www.tensorflow.org/tfx" rel="noopener ugc nofollow" target="_blank"> TensorFlow Extended (TFX)是一个用于部署生产 ML 管道的端到端平台</a></p></blockquote></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="7ad3" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">在本文发布时，ML 元数据的当前版本是 v0.22(tfx 也是 v 0.22)。该 API 已经足够成熟，可以在公共云上进行主流使用和部署。Tensorflow Extended 将其广泛用于组件-组件通信、沿袭跟踪和其他任务。</p><p id="3e46" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">我们将运行一个非常简单的管道，该管道将为著名的芝加哥出租车旅行数据集的样本 csv 生成统计数据和模式。这是一个大约 10mb 的小文件，管道可以在本地运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/8c0a144e27c68826a50fa5c37bb09aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PH38iAmf_vMwUfzTceN-jw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成的工件列表</p></figure><p id="0789" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">运行一次，打开<code class="fe mv mw mx my b">metadata_store.db</code>文件进行检查。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/bebffa6d02c7eef80058754ab225004a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4u4-pFmij2ZFAPUvfG8YJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ML 元数据生成的表</p></figure><p id="2627" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">ML 元数据<a class="ae ky" href="https://www.tensorflow.org/tfx/guide/mlmd" rel="noopener ugc nofollow" target="_blank">存储关于<strong class="lz iu"> 3 </strong>事物的信息:</a></p><ul class=""><li id="6f9d" class="na nb it lz b ma mb md me mg nc mk nd mo ne lj nf ng nh ni bi translated"><strong class="lz iu">关于生成的工件的元数据</strong></li><li id="9a9f" class="na nb it lz b ma nj md nk mg nl mk nm mo nn lj nf ng nh ni bi translated"><strong class="lz iu">关于这些组件执行的元数据—步骤</strong></li><li id="db81" class="na nb it lz b ma nj md nk mg nl mk nm mo nn lj nf ng nh ni bi translated"><strong class="lz iu">关于管道和相关沿袭信息的元数据</strong></li></ul></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="c2d3" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">Apache Beam Pipeline TFX 组件不会将整个二进制工件(由具有多个 io 的<code class="fe mv mw mx my b"><a class="ae ky" href="https://beam.apache.org/releases/javadoc/2.1.0/org/apache/beam/sdk/transforms/ParDo.html" rel="noopener ugc nofollow" target="_blank">ParDo</a></code>处理)传递给下一个节点。相反，URIs 的神器被传来传去。工件通常存储在某种云文件系统上，如<a class="ae ky" href="https://cloud.google.com/storage/docs/json_api/v1/buckets" rel="noopener ugc nofollow" target="_blank">云存储桶</a>。</p><p id="2f9c" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated"><em class="no">甚至</em> <strong class="lz iu"> <em class="no"> TFRecord tf。示例</em> </strong> <em class="no">保存的文件作为中间阶段工件处理。它们被压缩以节省空间。</em></p><p id="e949" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated"><code class="fe mv mw mx my b">&gt; SELECT * FROM `Artifact`;</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/fc4ebce470d683a92f9b7dbf109b5835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2x3XJEXEEiOX69DAPxq-hQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">被储存的藏物</p></figure><p id="f021" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">您可以看到，所有这些生成的工件父目录都被存储了起来，还有一个数字(稍后将详细介绍这个数字)、创建和更新时间。</p><p id="4e6b" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">在<code class="fe mv mw mx my b">CsvExampleGen/examples/1</code>的例子中，我们得到了两个子目录，<code class="fe mv mw mx my b">train</code>和<code class="fe mv mw mx my b">eval</code>，它们被存储为同一个工件。该路径的<strong class="lz iu"> /examples </strong>部分是<code class="fe mv mw mx my b">example_gen</code>产生的工件的名称(查看管道代码)，<code class="fe mv mw mx my b">statistics_gen</code>将其作为输入。</p><p id="877d" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">空值可能是正在进行的工作，因为商店是 v0.xx 版本。你可以在<a class="ae ky" href="https://github.com/google/ml-metadata/blob/b4891cf4f00a6d6d4b6a28a69c5601f1a48cd9f1/ml_metadata/proto/metadata_store.proto" rel="noopener ugc nofollow" target="_blank">源代码协议缓冲区声明中看到</a> n 可以是<code class="fe mv mw mx my b">UNKNOWN — PENDING — LIVE — MARKED_FOR_DELETION — DELETED</code>并且名字很好，这个名字，除了<code class="fe mv mw mx my b">type_id</code>之外。</p><p id="9faf" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated"><code class="fe mv mw mx my b">Types</code>工作台与<code class="fe mv mw mx my b">type_id</code>如预期的一样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/82632b8d2c1d850efb7bbfcbe9edc7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i72Kt9kd0Q6sx4an436iWg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类型</p></figure><p id="0b86" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">工件也支持属性映射。这些总结在<code class="fe mv mw mx my b">ArtifactProperty</code>表中。(例如，保存的 TFRecord 文件的校验和。它们通过 TFX 缓存中间步骤。)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/db570262e3ac2c85abec5de4f4614116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b44t-QgITQaebVvxdHJTvg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工件属性图</p></figure><ul class=""><li id="d0c3" class="na nb it lz b ma mb md me mg nc mk nd mo ne lj nf ng nh ni bi translated">一个<strong class="lz iu">上下文</strong>包含多个工件、执行和事件</li><li id="e31c" class="na nb it lz b ma nj md nk mg nl mk nm mo nn lj nf ng nh ni bi translated">一个<strong class="lz iu">事件</strong>包含工件和执行</li><li id="c131" class="na nb it lz b ma nj md nk mg nl mk nm mo nn lj nf ng nh ni bi translated">一个<strong class="lz iu">执行</strong>通常是一个独立的流水线步骤</li></ul></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="88e9" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">对于工件的执行跟踪和沿袭跟踪功能(例如，告诉哪个模型或统计对应于哪个数据集或管道运行)，我们必须处理<strong class="lz iu">事件、上下文和执行。</strong></p><ul class=""><li id="1398" class="na nb it lz b ma mb md me mg nc mk nd mo ne lj nf ng nh ni bi translated"><strong class="lz iu">事件</strong>关联<code class="fe mv mw mx my b">artifact_ids</code>和<code class="fe mv mw mx my b">execution_ids</code></li><li id="8033" class="na nb it lz b ma nj md nk mg nl mk nm mo nn lj nf ng nh ni bi translated"><strong class="lz iu">执行</strong>只跟踪<code class="fe mv mw mx my b">type_ids</code>和时间戳</li><li id="901b" class="na nb it lz b ma nj md nk mg nl mk nm mo nn lj nf ng nh ni bi translated"><strong class="lz iu">上下文</strong>将<code class="fe mv mw mx my b">type_ids</code>与管道运行和时间戳信息相关联</li></ul><p id="d104" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">表<strong class="lz iu">执行</strong>属性和<strong class="lz iu">上下文</strong>属性包含键值形式的额外数据。</p><ul class=""><li id="b67c" class="na nb it lz b ma mb md me mg nc mk nd mo ne lj nf ng nh ni bi translated"><strong class="lz iu"> ExecutionProperties </strong>包含传递给每个组件的输入和输出配置，以及管道和步骤根目录，以及工件的 IO 位置。</li><li id="597d" class="na nb it lz b ma nj md nk mg nl mk nm mo nn lj nf ng nh ni bi translated"><strong class="lz iu">上下文属性</strong>将<code class="fe mv mw mx my b">context_ids</code>与管道组件名称和时间戳相关联</li></ul><blockquote class="ns nt nu"><p id="283e" class="lx ly no lz b ma mb ju mc md me jx mf nv mh mi mj nw ml mm mn nx mp mq mr lj im bi translated">对于更大的管道的其他步骤，如模型验证和祝福，产生的工件或多或少采用相同的格式。</p></blockquote></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="0894" class="ny nz it bd oa ob oc dn od oe of dp og mg oh oi oj mk ok ol om mo on oo op oq bi translated">访问数据</h2><p id="39a3" class="pw-post-body-paragraph lx ly it lz b ma or ju mc md os jx mf mg ot mi mj mk ou mm mn mo ov mq mr lj im bi translated">有大量的信息可用，仅仅是在本地运行的简单的 3 步管道。例如，这个管道可以在云中的<code class="fe mv mw mx my b">Dataflow</code> runner 上运行，只需对配置进行最小的更改。</p><p id="e39b" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">在这种情况下，使用存储在数据库中的数据要比浏览服务器场上的云存储桶和虚拟机容易得多。</p><p id="1154" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">从这一点开始，您可以通过直接 SQL 连接或 gRPC(通过存根或普通的旧调用)连接到 ML 元数据存储。然后，就是选择您想要手动检查的数据类型的问题。例如，这可以是模式或统计 protobuf。</p><p id="4759" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">通常，您只需要访问资源的资源标识符。如果您在相同的环境中，您应该能够仅通过 URI 访问它们(例如 GCP 项目 VM 内的笔记本)。</p><h2 id="6fd0" class="ny nz it bd oa ob oc dn od oe of dp og mg oh oi oj mk ok ol om mo on oo op oq bi translated">示例使用案例</h2><p id="f39c" class="pw-post-body-paragraph lx ly it lz b ma or ju mc md os jx mf mg ot mi mj mk ou mm mn mo ov mq mr lj im bi translated">假设您有一个管道在某个时间间隔(或基于事件的触发)运行，并且有时您想要查看最新管道运行与前一次运行的数据统计。</p><ul class=""><li id="5642" class="na nb it lz b ma mb md me mg nc mk nd mo ne lj nf ng nh ni bi translated">您需要两个不同管道运行的<strong class="lz iu">statistics gen/statistics</strong>工件(这些是<strong class="lz iu"> ExampleStatistics </strong>类型，带有<code class="fe mv mw mx my b">type_id</code> 8)。这些可以在<code class="fe mv mw mx my b">Artifact</code>的桌子上找到。</li><li id="5fe5" class="na nb it lz b ma nj md nk mg nl mk nm mo nn lj nf ng nh ni bi translated">您还需要从正确的管道运行中访问工件。<code class="fe mv mw mx my b">Attribution</code>表格将<code class="fe mv mw mx my b">context_id</code>与<code class="fe mv mw mx my b">artifact_id</code>相关联。唯一缺少的是精确定位您需要的 2 个<code class="fe mv mw mx my b">context_id</code>,以便进行简单的选择查询。</li><li id="9fbd" class="na nb it lz b ma nj md nk mg nl mk nm mo nn lj nf ng nh ni bi translated"><code class="fe mv mw mx my b">Context</code>表还包含时间戳信息。例如，行<code class="fe mv mw mx my b">Pipeline .2020–07–14T23:45:00.508181.StatisticsGen</code>有一个<code class="fe mv mw mx my b">context_id</code> 5。</li></ul><p id="7d93" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">上下文 Id 5 对应于属性表中的工件 Id 3。工件 Id 3 确实是我们需要的统计工件。</p><p id="acf5" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated"><strong class="lz iu">幸运的是，kubeflow 管道</strong> <a class="ae ky" href="https://www.kubeflow.org/docs/pipelines/sdk/output-viewer/" rel="noopener ugc nofollow" target="_blank"> <strong class="lz iu">已经自动做到了这一点</strong> </a></p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="e472" class="ow nz it bd oa ox oy oz od pa pb pc og jz pd ka oj kc pe kd om kf pf kg op pg bi translated">结论</h1><p id="4501" class="pw-post-body-paragraph lx ly it lz b ma or ju mc md os jx mf mg ot mi mj mk ou mm mn mo ov mq mr lj im bi translated">现在，您应该对 ML 元数据存储确切包含的内容以及为什么它是 TFX 生态系统中如此有用的组件有了一个明确的理解。</p><p id="0b93" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr lj im bi translated">感谢一路读到最后！</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="9119" class="ny nz it bd oa ob oc dn od oe of dp og mg oh oi oj mk ok ol om mo on oo op oq bi translated">定制工件</h2><p id="dc5d" class="pw-post-body-paragraph lx ly it lz b ma or ju mc md os jx mf mg ot mi mj mk ou mm mn mo ov mq mr lj im bi translated"><a class="ae ky" href="https://github.com/google/ml-metadata/blob/master/g3doc/get_started.md" rel="noopener ugc nofollow" target="_blank">支持自定义工件。我们不会在这里深入探讨，因为这主要是针对 TFX 的生态系统。更多信息请看这里。</a></p></div></div>    
</body>
</html>