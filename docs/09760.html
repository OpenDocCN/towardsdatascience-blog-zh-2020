<html>
<head>
<title>Recommending Similar Images Using PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 PyTorch 推荐相似图片</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/recommending-similar-images-using-pytorch-da019282770c?source=collection_archive---------11-----------------------#2020-07-11">https://towardsdatascience.com/recommending-similar-images-using-pytorch-da019282770c?source=collection_archive---------11-----------------------#2020-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="45f5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">resnet 18 的全迁移学习实现</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/78e98a06494214bbd4268934ba61c1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P0BICenJbn67pM5m1SIc-w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用 Resnet18 特性找到了相似的图像(来源:M. D. Korzec)</p></figure><p id="5d77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" rel="noopener" target="_blank" href="/effortlessly-recommending-similar-images-b65aff6aabfb">在我的上一篇文章</a>中，我们介绍了一种简单的逻辑，通过使用迁移学习，根据图像内容在大集合中为相似图像创建推荐。</p><p id="0e1b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们使用 PyTorch 中预训练的 Resnet18 卷积神经网络创建一个 Python 原型实现。它将获取图像文件夹的内容，并创建 k 个与输入最相似的图像的 top-k 列表。</p><p id="3634" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将 Resnet18 网络用于一组固定图像的简单推荐器的基本实现将在以下步骤中导出</p><p id="deef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ls"> 0。理论倒带:图像推荐逻辑</em></p><p id="ac66" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ls"> 1。重新调整数据</em></p><p id="86db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ls"> 2。使用预训练的 Resnet18 网络作为特征向量生成器</em></p><p id="b484" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ls"> 3。通过计算这些向量的余弦，使用特征阵列计算相似性</em></p><p id="823a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ls"> 4。创建 top-k 列表</em></p><p id="7fd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ls"> 5。使用 top-k 列表并可视化建议</em></p><p id="f089" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你已经读过我的前一篇文章，可以跳过第 0 步。</p><p id="ed4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你主要对原型实现感兴趣，你可以在这里找到 Jupyter 笔记本<a class="ae lr" href="https://github.com/MathMagicx/JupyterNotebooks/tree/master/ImageRecommenderResnet18" rel="noopener ugc nofollow" target="_blank"/>。它涵盖了所有步骤，包括一组图像样本和推荐图像的简单可视化</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ca7a" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak"> 0。</strong> <strong class="ak">图像推荐器逻辑</strong></h1><p id="b943" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">我们希望将相似的图像推荐给参考输入，例如在线商店中的推荐者。相似性是基于像素内编码的信息，而不是其元数据。</p><p id="8c82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设您已经在一个包含 jpg 图像的文件夹中收集了数据。然后，我们对图像进行预处理，以符合所选网络的输入要求(例如，Resnet18 的大小调整为 224x224 RGB 图像)，我们使用所选网络计算大小调整后的图像的特征向量，我们基于余弦相似性计算相似性，并存储用于推荐的 top-k 列表。最后，我们使用列表进行推荐。</p><p id="0e5e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下示意图总结了所有步骤</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/1aa346cb2ca0a544d58729d52c774891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0VmeJdUM79AtLWKEQINzXw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">完整的图像推荐系统示意图(来源:M. D. Korzec)</p></figure><p id="39b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">核心步骤将使用 PyTorch 来执行，py torch 是 Python 中的一个开源机器学习框架。它伴随着各种各样的卷积网络和来自对巨大数据集的预训练的权重。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="fcd5" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak"> 1。</strong> <strong class="ak">预处理</strong></h1><p id="69e0" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">图像文件夹应位于工作目录中。为了满足 PyTorch 卷积网络的输入要求，独立于网络，我们从<a class="ae lr" href="https://pytorch.org/docs/stable/torchvision/models.html" rel="noopener ugc nofollow" target="_blank"> PyTorch 主页</a>了解到，对于所有模型，我们需要以相同的方式归一化输入图像，以正确使用预训练的权重。输入需要</p><ul class=""><li id="fa3e" class="my mz iq kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated">至少具有 224x224 分辨率</li><li id="03b1" class="my mz iq kx b ky nh lb ni le nj li nk lm nl lq nd ne nf ng bi translated">是 RGB 图像(即三个颜色通道)</li><li id="d295" class="my mz iq kx b ky nh lb ni le nj li nk lm nl lq nd ne nf ng bi translated">具有在[0，1]范围内的图像值</li><li id="10f0" class="my mz iq kx b ky nh lb ni le nj li nk lm nl lq nd ne nf ng bi translated">考虑具有平均值[0.485，0.456，0.406](每个颜色通道一个值)和标准偏差[0.229，0.224，0.225]的归一化图像。</li></ul><p id="9023" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了重新缩放图像，我们可以如下进行:定义变换，迭代输入目录中的所有图像名称，加载图像，应用变换，将变换后的图像与其方向信息一起存储</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2a98" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">规范化是在 next 后面的转换类的构造函数中执行的。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c173" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak"> 2。使用预训练的 Resnet18 网络作为特征向量生成器</strong></h1><p id="d329" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">为了从重新缩放的图像中生成特征，我们在构造函数中设置了一个包含网络相关信息的类</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><ul class=""><li id="342a" class="my mz iq kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated">ToTensor 变换在每个通道中取值为 0 到 255 之间的 H x W x C 形式的图像，并将其压缩为 C x H x W 形状的 torch 张量，值为[0，1]。</li><li id="2429" class="my mz iq kx b ky nh lb ni le nj li nk lm nl lq nd ne nf ng bi translated">归一化操作采用图像的每个通道，并计算(图像-平均值)/std</li><li id="ed48" class="my mz iq kx b ky nh lb ni le nj li nk lm nl lq nd ne nf ng bi translated">私有方法 getFeatureLayer(self)返回特征层，即平均池层。它是小分类向量之前的最后一个完全连接的层，并且是通过模型获得的。_modules.get('avgpool ')</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="138d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">公共方法 getVec(self，img)从图像输入中创建特征向量。它使用定义的设备(cpu)。一个函数被挂接到网络的转发调用，以从相关层复制数据。因此，最终包含相关信息的嵌入张量需要具有层的格式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c9b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，为所有图像创建特征向量已经万事俱备。它们被收集在 allVectors 集合中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="6296" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak"> 3。使用特征数组通过计算这些向量的余弦来计算相似度</strong></h1><p id="11f3" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">在我们计算完所有的特征向量之后，是时候计算它们之间的余弦值了。因为我们仅通过内积和归一化来计算相似性值，所以这是一个使用基本 NumPy(数字线性代数库)功能的函数调用。矩阵存储为 Pandas DataFrame(二维表格数据结构)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3b77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请记住，存储整个相似性矩阵是大规模使用的瓶颈——需要一些更精细的方法。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="0f5e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak"> 4。使用最佳建议列表</strong></h1><p id="eba7" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">对于前 k 个(k 个最相似的图像)列表，熊猫数据帧从相似性矩阵创建，该矩阵包含与输入相似的名称和相应的相似性值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3d79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">tqdm 用于获得一个进度条，当你想处理许多图像时，这很有用。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="52e6" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak"> 5。</strong> <strong class="ak">使用 top-k 列表并可视化推荐</strong></h1><p id="6d5d" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">在最后一步中，您应该能够看到与请求的输入类似的图像。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6410" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们将它用于存储库中提供的一些图像</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/8b9c59c52676c5684f619b238ae82062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*-bjuvYXNxYmrQz1SxnZq6w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">资料来源 M. D. Korzec</p></figure><h1 id="0c68" class="ma mb iq bd mc md np mf mg mh nq mj mk jw nr jx mm jz ns ka mo kc nt kd mq mr bi translated"><strong class="ak">期末笔记</strong></h1><p id="a4c5" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">有了上面的解释和代码，你应该已经掌握了使用 PyTorch 的预训练卷积网络为相似图像创建推荐系统所需的所有基础知识。完整代码可从<a class="ae lr" href="https://github.com/MathMagicx/JupyterNotebooks/tree/master/ImageRecommenderResnet18" rel="noopener ugc nofollow" target="_blank">下载</a>。</p><p id="aea5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想用不同的型号，在<a class="ae lr" href="https://pytorch.org/docs/stable/torchvision/models.html" rel="noopener ugc nofollow" target="_blank"> PyTorch 网站</a>上有描述。当你想创建更多的实验时，把代码模块化，只把网络及其层当作参数。当创建具有较大集合的实验时，建议存储中间结果，例如作为 pickle 文件。</p><p id="3286" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你问自己如何运营一个包含这种推荐者的网站，你可能想看看我的后续文章。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="7983" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">感谢阅读！喜欢这个话题吗？</h1><p id="490f" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">如果你觉得这篇文章很有趣，你可能想看看我在这个主题上的其他文章:</p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/effortlessly-recommending-similar-images-b65aff6aabfb"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">轻松推荐相似图片</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">使用来自训练的卷积神经网络的特征来产生可比性</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kp nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://medium.com/@maciek.korzec/a-flask-app-for-image-recommendations-a865e1496a0d" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">一个推荐图片的 Flask 应用程序</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">PyTorch 中基于卷积神经网络的相似图像推荐网站原型</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol kp nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/image-recommendations-with-pytorch-flask-postgresql-heroku-deployment-206682d06c6b"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">py torch+Flask+PostgreSQL+Heroku 部署的映像建议</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">用 Flask 封装一个基于 PostgreSQL/ PyTorch 的图像推荐系统，导入数据并在 Heroku 上运行</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol kp nx"/></div></div></a></div></div></div>    
</body>
</html>