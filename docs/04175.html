<html>
<head>
<title>Exploring the Data: Learn from the Food Nutrition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索数据:从食物营养中学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploring-the-data-learn-from-the-food-nutrition-a4ea2110522a?source=collection_archive---------18-----------------------#2020-04-16">https://towardsdatascience.com/exploring-the-data-learn-from-the-food-nutrition-a4ea2110522a?source=collection_archive---------18-----------------------#2020-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dc7b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在没有明确目标的情况下，我们可以尝试从数据中探索什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2a0c7c41f485c5b5b13fc9153ed70c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c0Bfqxf7ejm6HxsD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">布鲁克·拉克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="a303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢探索我的数据，并从中发现意想不到的模式。作为一名数据科学家，在我个人看来，我们需要具备这种好奇心特质，才能在这个领域取得成功。探索数据的方法不仅限于诸如可视化数据和获得统计数字的基本技术，一种方法是实现机器学习。</p><p id="d020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">机器学习也是一种探索数据的技术，而不仅仅是人们经常喜欢宣传的预测目的。这就是为什么我经常专注于理解模型的概念，以了解我的数据是如何处理的；更好地了解我们的数据发生了什么变化。</p><p id="3b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想介绍通过无监督学习来探索数据，我们可以从统计数字和数据挖掘技术中获得什么信息。在这里，因为我的爱好之一是烹饪，我将使用来自Kaggle的关于普通食物和产品的食物营养价值的<a class="ae ky" href="https://www.kaggle.com/trolukovich/nutritional-values-for-common-foods-and-products" rel="noopener ugc nofollow" target="_blank">数据集</a>。我想探究这些数据，既是为了学习，也是为了满足自己的好奇心。这意味着，我在这里的目标只是知道我的数据中发生了什么，以及我可以获得什么样的信息，而没有任何特定的目标。让我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7f2f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">探索数据</h1><h2 id="42d2" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">数据清理</h2><p id="6b9b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">首先，我们需要阅读我们的数据，了解我们的数据如何。这是重要的第一步。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="2e26" class="mu md it nm b gy nq nr l ns nt">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns</span><span id="325b" class="mu md it nm b gy nu nr l ns nt">data = pd.read_csv('nutrition.csv')<br/>data.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/3710b10a84548e11f7a89b0d9fabdd6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q1Vt0TrY1f5QYJRHtUu7EA.png"/></div></div></figure><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="5876" class="mu md it nm b gy nq nr l ns nt">data.info()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/54f0a5fce00d860205004051b1eb60bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*KmB0wADl1XC9mtV_lM3eDA.png"/></div></figure><p id="484f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实际上有76列，我没有在这里全部显示(这将是一个很长的列表)，数据示例如上表所示。</p><p id="65a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的大部分数据是由营养值(卡路里、脂肪、糖、碳水化合物等)组成的。)与美食名。营养值栏有不同的度量单位，如克(克)、毫克(毫克)和微克(微克)。在这种情况下，我们还可以忽略功能serving_size，因为除了所有数据都基于100克食物之外，它不提供任何其他信息。一些列还包含一个NaN值，我相信这个Null值意味着有等于0的值。现在，让我们做一些数据清理。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="085c" class="mu md it nm b gy nq nr l ns nt">#Drop the serving_size column<br/>data.drop('serving_size', axis = 1, inplace = True)</span><span id="df5c" class="mu md it nm b gy nu nr l ns nt">#Fill the NaN value with 0<br/>data.fillna(0, inplace = True)</span></pre><p id="b4bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我希望除了name特性之外的所有特性都变成数字列。这意味着，我们需要删除数据中所有的非数字文本。我还想转换除卡路里以外的所有数字数据，使其具有相同的度量(克)。让我们开始吧。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="c9cc" class="mu md it nm b gy nq nr l ns nt">#I would use Regular Expression Module to help me clean the data<br/>import re</span><span id="ec77" class="mu md it nm b gy nu nr l ns nt">#Looping in each non-numerical features except the name feature <br/>for col in data.drop('name',axis = 1).select_dtypes(exclude = 'number').columns:<br/>    for i in data[col]:<br/>        if i == '0' or i == 0:<br/>            pass<br/>        else:<br/>            point = re.findall('[a-zA-Z]+',i)[0]<br/>            replace = []<br/>            if point == 'mg':<br/>                for j in data[col]:<br/>                    if j == '0' or j == 0:<br/>                        replace.append(float(j))<br/>                    else:<br/>                        replace.append(float(re.sub('[a-zA-Z]','',j))/1000)<br/>            elif point == 'mcg':<br/>                for j in data[col]:<br/>                    if j == '0' or j == 0:<br/>                        replace.append(float(j))<br/>                    else:<br/>                        replace.append(float(re.sub('[a-zA-Z]','',j))/1000000)  <br/>            else:<br/>                 for j in data[col]:<br/>                    if j == '0' or j == 0:<br/>                        replace.append(float(j))<br/>                    else:       <br/>                        replace.append(float(re.sub('[a-zA-Z]','',j)))<br/>                        <br/>            data[col] = replace    <br/>            data.rename({col:col+'(g)'}, axis =1, inplace = True)<br/>            break</span></pre><p id="dc1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我的数据的最终结果，我将进一步探索。请注意，我知道除了卡路里之外，所有数据现在都是以克为单位，但只是为了学习，我将它添加到我的列名中，这样我们就不会忘记它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/83af453e059bb97b3b848867e7f234f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqVGQad2-rwJc2FJtOW5tA.png"/></div></div></figure><p id="e174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还创建了另一个名为food_categories特性，因为当仔细检查这个命名特性时，逗号前面的第一个单词就是food。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="74e5" class="mu md it nm b gy nq nr l ns nt">data['food_categories'] = data['name'].apply(lambda x: x.split(',')[0])</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="fd9d" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">数字统计</h2><p id="d510" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">如果我们试图一个接一个地可视化这些列，这将是巨大的并且有点重复，因为它不会给我们提供太多的信息。如果你愿意，你可以试试。我可以给你下面的代码。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="00f8" class="mu md it nm b gy nq nr l ns nt">for i in data.select_dtypes('number').columns:<br/>    sns.distplot(data[i])<br/>    plt.title(i)<br/>    plt.show()</span></pre><p id="fc4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候，在这种情况下，如果我们真的只是想探索数据，通过数字而不是可视化来看会更直观(毕竟我是一个更注重数字的人，因为我相信有时可视化是有偏见的)。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="ff10" class="mu md it nm b gy nq nr l ns nt">pd.set_option('display.max_columns', None)<br/>data.agg(['mean', 'median', 'std', 'skew', 'kurtosis'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/d91c3c6d8fd3da44d8f797978650e7c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptB2unku69MhkCg4-fbfsg.png"/></div></div></figure><p id="e3b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在这里，我使用。数据帧的agg方法，用于获取关于每列的平均值、中值、标准差、偏斜度和峰度的信息。这就是数字比形象更有说服力的地方。</p><p id="e7a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">众所周知，平均值是数据的平均值。多个要素可能具有相同的平均值，但它们在平均值周围的分布方式不同，这通过标准差(std)来表示。有一个规则叫做经验规则，我们可以通过标准差得到数据扩散的概率。经验法则表明:</p><ul class=""><li id="3cdd" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">68%的数据低于平均值1 *标准差</li><li id="8ba9" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">我们95%的数据低于平均值2 *标准差</li><li id="b32a" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">我们99.7%的数据都低于平均值3 *标准差</li></ul><p id="89ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经验法则或者也有人说68–95–99.7法则经常被用来分析数据异常值。这种统计的主要问题是，它们会受到异常值或极值的影响，并经常导致数据失真。我用一张图片向你展示什么是扭曲的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/bf299aeaf89db99873a34c253eae51fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*4bEvZQxeEAE-76iU8rvABQ.png"/></div></figure><p id="8411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是total_fat(g)特性图。它向右倾斜，因为尾巴在右边。但是，偏斜度有多大呢？这就是不对称统计的目的。我们可以记住关于<strong class="lb iu">偏斜度</strong>的一些规则是:</p><ul class=""><li id="ff2c" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">如果偏斜度在-0.5和0.5之间，数据是相当对称的</li><li id="1ea7" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果偏斜度介于-1和-0.5之间或介于0.5和1之间，则数据是中度偏斜的</li><li id="556b" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果偏斜度小于-1或大于1，则数据是高度偏斜的</li></ul><p id="13b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们可以看到，如果我们上面的数据是高度倾斜的，实际上你会遇到的大多数数据都是这样的。那么峰度呢？这个统计数字告诉我们什么？<strong class="lb iu">峰度</strong>是衡量数据相对于正态分布是重尾还是轻尾的指标。这一分析可总结如下:</p><ul class=""><li id="2b31" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">如果峰度接近于0，那么通常假设正态分布。这些被称为中kurtic分布。</li><li id="b7f5" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果峰度小于0，则该分布是轻尾的，称为宽峰分布。</li><li id="0d27" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果峰度大于0，那么该分布具有较重的尾部，称为细峰分布。</li></ul><p id="9d2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们把它形象化，它看起来会像下面的图片。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/22116c3f7176c2c640f90a549928fbdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*X6jP2L9Yp9jyJxOp3O31vw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">过度峰度取自<a class="ae ky" href="https://www.bogleheads.org/wiki/Excess_kurtosis" rel="noopener ugc nofollow" target="_blank">booglehead.com</a></p></figure><p id="3903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准确地说，我们之前的数据被称为<strong class="lb iu">过度峰度</strong>，其中正态分布以峰度为0来衡量。如果我们只讨论峰度，正态分布将等于3，这就是为什么在过度峰度中，我们将峰度减去3。</p><p id="f5e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的大部分数据都是不准确的。扭曲的数据实际上非常有趣，因为你可以尝试用它来探索。例如，基于卡路里，什么食物被认为是异常值。</p><p id="8547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们的数据是足够偏斜的，我不会依靠平均值来发现异常值；相反，我会应用基于中位数的<strong class="lb iu"> IQR </strong>方法。</p><p id="4730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IQR或四分位距是基于数据位置的。例如，如果我们描述“卡路里”特征，我们将得到下面的描述。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="fdb3" class="mu md it nm b gy nq nr l ns nt">data['calories'].describe()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/a1cca8ef8cfd42fe6c0afc8da3556047.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*B-2M7Z7xI7wazYGsPAt7uw.png"/></div></figure><p id="449d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IQR将基于25%的位置或Q1和75%的位置或第三季度。我们也可以通过用Q1减去Q3得到IQR值(Q3-Q1)。使用IQR方法，我们可以根据上限或下限来决定哪些数据被视为异常值:</p><p id="b9ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">下限</strong>= Q1–1.5 * IQR</p><p id="5be4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">上限= </strong> Q3 + 1.5 * IQR</p><p id="40ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何高于或低于此限值的数据都将被视为异常值。让我们试着实现这个方法，看看什么样的食物被认为是基于卡路里的异常值。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="ad04" class="mu md it nm b gy nq nr l ns nt">#Specifying the limit<br/>cal_Q1 = data.describe()['calories']['25%']<br/>cal_Q3 = data.describe()['calories']['75%']<br/>cal_IQR = cal_Q3 - cal_Q1</span><span id="2283" class="mu md it nm b gy nu nr l ns nt">data[(data['calories'] &lt; 1.5 * (cal_Q1 - cal_IQR)) | (data['calories'] &gt; 1.5 * (cal_Q3 + cal_IQR)) ]['food_categories'].value_counts()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/61ab8ae0189d0235cc8767aae62a2ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*C05AVJHwqTuansEZadAroQ.png"/></div></figure><p id="3a53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，大部分高热量食物是油，这并不奇怪。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="a607" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">无监督学习</h2><p id="138d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">上面我向你展示了一种从数字上探索数据的方法，现在我想向你展示一个机器学习如何帮助我们探索数据的例子。</p><p id="a206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无监督学习是一种机器学习，我们没有任何特定的学习目标。一个例子是聚类分析，我们向模型提供数据，输出是一个数据聚类，其中最接近的数据被视为一个聚类。</p><p id="93f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢做的是，如果我们没有任何探索数据的特定目标，我们可以让机器学习来为我们学习。使用无监督学习，我们可以获得以前没有意识到的新视角。让我们用我最喜欢的聚类分析算法举例说明。</p><p id="0361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最喜欢的聚类算法是<strong class="lb iu">凝聚聚类</strong>分析，你可以在这里详细阅读<a class="ae ky" rel="noopener" target="_blank" href="/breaking-down-the-agglomerative-clustering-process-1c367f74c7c2">。基本上，该分析将每一个数据点分配为一个单独的聚类，并通过合并每个聚类来进行，因此我们只剩下一个聚类。</a></p><p id="81dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在我们进行分析之前，我们需要准备数据。聚类分析取决于数据之间的距离。数据的距离会受到其比例的影响，这就是为什么我们还需要转换所有的要素，使其具有相同的比例。如果你还记得，我们已经在我们的功能中的每一个单独的列都是以克为单位的，但是有一个“卡路里”列不是在同一个刻度上。这就是为什么我们仍然需要转换数据。通常我们会将数据转换为遵循标准分布，这就是我们要做的。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3092" class="mu md it nm b gy nq nr l ns nt">#Importing the transformer<br/>from sklearn.preprocessing import StandardScaler</span><span id="d865" class="mu md it nm b gy nu nr l ns nt">#Transforming the data, I drop the name feature as we only need the numerical column</span><span id="f0ac" class="mu md it nm b gy nu nr l ns nt">scaler = StandardScaler()<br/>training = pd.DataFrame(scaler.fit_transform(data.drop('name', axis =1)), columns = data.drop('name', axis =1).columns)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/78331a30d9fe1bf57039b327cb8a0fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X5gYIxaiADjCOk3q0NJKKg.png"/></div></div></figure><p id="9e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们最终得到的，一个每个要素都具有相同比例的数据集。现在，让我们尝试通过聚集聚类来对数据进行聚类。首先，我们想象集群最终会如何。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3770" class="mu md it nm b gy nq nr l ns nt">from scipy.cluster.hierarchy import linkage, dendrogram</span><span id="6182" class="mu md it nm b gy nu nr l ns nt">#Ward is the most common linkage method<br/>Z = linkage(training,method = 'ward')<br/>dendrogram(Z, truncate_mode = 'lastp')<br/>plt.xticks(rotation = 90, fontsize = 10)<br/>plt.ylabel('Distance')<br/>plt.xlabel('Cluster')<br/>plt.title('Agglomerative Clustering')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/d31318ccac152083108859c13d325dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*0e-SOBqkIqMOJPJFmnc1uA.png"/></div></figure><p id="6861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面是凝聚聚类生成的树。它只显示最后30个合并事件，因为如果我们在这里全部显示，它会被挤满。正如我们所看到的，数据似乎可以分为两类；当然，如果你想更保守一点，它可以分为3个集群，因为在上面的可视化中有证据表明它可能是这样的。尽管如此，我现在会把它保持为两个集群。</p><p id="99bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到之前的数据，将凝聚聚类结果输入到我们的数据中。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="0d7c" class="mu md it nm b gy nq nr l ns nt">from sklearn.cluster import AgglomerativeClustering</span><span id="8eb7" class="mu md it nm b gy nu nr l ns nt">#I specify n_clusters to be 2 based on our previous analysis<br/>ach = AgglomerativeClustering(n_clusters = 2)<br/>ach.fit(training)</span><span id="eab0" class="mu md it nm b gy nu nr l ns nt">#Input the label result to the data<br/>data['label'] = ach.labels_</span></pre><p id="7eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，通过无监督学习，我们实际上可以尝试将多维数据可视化成两个轴。有几种方法可以做到这一点，但我会向你展示一种叫做t-SNE的技术。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="ce62" class="mu md it nm b gy nq nr l ns nt">from sklearn.manifold import TSNE</span><span id="ff96" class="mu md it nm b gy nu nr l ns nt">#t-SNE is based on a stochastic (random) process, that is why I set the random_state so we could repeat the result</span><span id="f166" class="mu md it nm b gy nu nr l ns nt">tsne = TSNE(random_state=0)<br/>tsne_results = tsne.fit_transform(training) <br/>tsne_results=pd.DataFrame(tsne_results, columns=['tsne1', 'tsne2'])</span><span id="2bfa" class="mu md it nm b gy nu nr l ns nt">#Visualize the data<br/>tsne_results['label'] = data['label']<br/>sns.scatterplot(data = tsne_results, x = 'tsne1', y = 'tsne2', hue='label')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/ad4d3aeca0b023d661b7758876fd9439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*ugyRqt8_AYBElfHECDC_4Q.png"/></div></figure><p id="d93e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的多维数据已经被可视化，并且凝聚聚类方法清楚地将我们的数据分成一条清晰的线。好吧，到底是什么让他们分开的？是我们需要分析的。没有简单的方法，除了再次弄脏数字。当然，可视化在这里会有所帮助。我会给出下面每一列的分布代码。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="f44f" class="mu md it nm b gy nq nr l ns nt">for i in data.select_dtypes('number').columns:<br/>    sns.distplot(data[data['label'] == 0][i], label = 'label 0')<br/>    sns.distplot(data[data['label'] == 1][i], label = 'label 1')<br/>    plt.title(i)<br/>    plt.legend()<br/>    plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/5762a3ed70c7774072326dd3043851a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*0-xQj68B__ambO5oND5IMQ.png"/></div></figure><p id="ba23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面是每一列的循环分布图，但是如果你喜欢用像我这样的数字；我们可以使用DataFrame对象中的groupby方法。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="a005" class="mu md it nm b gy nq nr l ns nt">data.groupby('label').agg(['mean', 'median', 'std'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/823d9434e4ac6803b4e884cd3b244ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Stx-seoahxv0Xyu3xQ_ZTA.png"/></div></div></figure><p id="074a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果会是上面的样子。我做了一些分析，使他们分开。以下是我的总结:</p><ul class=""><li id="6b07" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">标签0表示蛋白质少、糖和碳水化合物多、纤维多、脂肪和胆固醇少的食物，热量除了200卡左右都是分散的。</li><li id="1ac3" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">标签1表示蛋白质多、糖和碳水化合物少、纤维少、脂肪和胆固醇多的食物，热量只分摊到200卡左右。</li></ul><p id="ef2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以从上面的标签看到我们有什么样的食物。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="d2f3" class="mu md it nm b gy nq nr l ns nt">#Food label 0<br/>data[data['label'] == 0]['food_categories'].value_counts()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/a48d706fa48f47fa7512a84f41a8b1c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*5RRW6T-ZV4BeVjrKpTIIbw.png"/></div></figure><p id="511b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标签为0的食品前5名是饮料、谷类食品、婴儿食品、汤和小吃，这是一种不含太多蛋白质和脂肪的食品。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="5acd" class="mu md it nm b gy nq nr l ns nt">#Food label 1<br/>data[data['label'] == 1]['food_categories'].value_counts()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/cafe19a4e6b7a79032931ac0b26b2954.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*AdKj_moz3Ta77eG5q8ajgw.png"/></div></figure><p id="b540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在标签1中，排名前5的食物都是肉类。这并不奇怪，因为与标签1相比，这个标签是针对含有更高脂肪和蛋白质的食物的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="99a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="2f5a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在这里，我只是试着摆弄数据，试着从数据中得到我能得到的模式。除了深入了解我的数据能为我提供什么，我没有任何具体的目标。</p><p id="6ade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，与可视化相比，有时数字可以告诉我们更多的信息，机器学习并不总是用于预测，但也可以用于分析。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="636b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如果您喜欢我的内容，并希望获得更多关于数据或数据科学家日常生活的深入知识，请考虑在此订阅我的<a class="ae ky" href="https://cornellius.substack.com/welcome" rel="noopener ugc nofollow" target="_blank">简讯。</a></h1><blockquote class="oy"><p id="98d8" class="oz pa it bd pb pc pd pe pf pg ph lu dk translated">如果您没有订阅为中等会员，请考虑通过<a class="ae ky" href="https://cornelliusyudhawijaya.medium.com/membership" rel="noopener">我的介绍</a>订阅。</p></blockquote></div></div>    
</body>
</html>