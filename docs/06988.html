<html>
<head>
<title>Working with 3D data — fastai2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 3D 数据— fastai2</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/working-with-3d-data-fastai2-5e2baa09037e?source=collection_archive---------50-----------------------#2020-05-29">https://towardsdatascience.com/working-with-3d-data-fastai2-5e2baa09037e?source=collection_archive---------50-----------------------#2020-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f624" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解 fastai 数据块并创建构建块以处理深度学习应用程序的图像序列</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d086868d6cd55339cd714bb2973434c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZIoFbeCO-Ijdy1MeIeixg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">奥拉夫·阿伦斯·罗特内在<a class="ae kv" href="https://unsplash.com/s/photos/rubik-cube?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><h2 id="704a" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍</h2><p id="aaa7" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">处理 3D 数据或图像序列对于许多应用程序都很有用。假设您正在处理 3D 医疗数据、视频数据、卫星图像的时间序列，甚至是一幅更大图像的几个片段。如果你正在处理这样的问题，除了简单的基于图像的问题之外，你还需要一些额外的考虑。如何对 3D 数据进行增强？这些转换应该应用于图像方式还是序列方式，或者两者都应用？如何洗牌训练数据？是否应该保留序列顺序？这些问题的答案取决于问题的类型。然而，拥有一个能够适应所有这些不同可能性的框架是有用的。fastai 是模块化的，非常通用，这使它成为深度学习实践者和研究人员非常有用的工具。</p><p id="a116" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在这个故事中，我将从 fastai <strong class="lu ir">数据块</strong>的一个基本例子开始——创建数据加载器的构建块。然后，我将展示如何编写附加功能，以允许使用数据块创建包含 3D 数据的数据加载器，包括图像序列的扩充。</p><p id="2581" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在<a class="ae kv" href="https://www.kaggle.com/mnpinto/fastai2-working-with-3d-data" rel="noopener ugc nofollow" target="_blank">这个 Kaggle 内核</a>上提供了一个工作示例。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h2 id="66c4" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">fastai 数据块</h2><p id="6218" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">下面的代码显示了一个典型的基于图像的数据集的 fastai <strong class="lu ir"> DataBlock </strong>类的示例。如果你是 fastai 的新手，你可以在 fastai 文档中找到更多的例子。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="d4ad" class="kw kx iq my b gy nc nd l ne nf">dblock <strong class="my ir">=</strong> DataBlock(blocks     <strong class="my ir">=</strong> (ImageBlock, CategoryBlock),<br/>                   get_items  <strong class="my ir">=</strong> get_image_files,<br/>                   get_y      <strong class="my ir">=</strong> label_func,<br/>                   splitter   <strong class="my ir">=</strong> RandomSplitter(),<br/>                   item_tfms  <strong class="my ir">=</strong> Resize(224),<br/>                   batch_tfms <strong class="my ir">= </strong>aug_transforms())</span></pre><ul class=""><li id="8d52" class="ng nh iq lu b lv ml ly mm lf ni lj nj ln nk mk nl nm nn no bi translated"><strong class="lu ir">块</strong> —该参数接收一个元组，该元组定义了<strong class="lu ir">数据块</strong>的输入类型和目标。在这种情况下，我们有<strong class="lu ir"> ImageBlock </strong>和<strong class="lu ir"> CategoryBlock，</strong>因此<strong class="lu ir"> DataBlock </strong>需要图像输入和分类目标——顾名思义。</li><li id="8d3f" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated"><strong class="lu ir"> get_items </strong> —该参数接收一个返回项目列表的函数。在这种情况下，<strong class="lu ir"> get_image_files </strong>简单地返回<strong class="lu ir"> </strong>所有图像文件的路径是一些目录和子目录。</li><li id="99aa" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated"><strong class="lu ir"> get_y </strong> —该参数接收一个定义标签的函数。在这种情况下是相应项目的类别。<strong class="lu ir"> get_x </strong>也可以用在一些情况下，我们稍后会看到。请记住，<strong class="lu ir"> get_x </strong>和<strong class="lu ir"> get_y </strong>接收<strong class="lu ir"> get_items </strong>的输出，并分别定义<strong class="lu ir"> ImageBlock </strong>和<strong class="lu ir"> CategoryBlock </strong>将接收哪些信息。在本例中，不需要<strong class="lu ir"> get_x </strong>，因为<strong class="lu ir"> get_image_files </strong>已经返回了图像的列表路径，这是<strong class="lu ir"> ImageBlock </strong>所需要的。</li><li id="3447" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated"><strong class="lu ir">拆分器</strong> —用于指示如何将数据拆分为训练集和验证集。</li><li id="af3d" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated"><strong class="lu ir"> item_tfms </strong> —用于定义应用于 CPU 上每个图像的变换。</li><li id="f8ca" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated"><strong class="lu ir"> batch_tfms </strong> —用于定义应用于 GPU 上每个批处理的转换。</li></ul><p id="80aa" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">如您所见，这种结构非常灵活，几乎可以处理任何类型的数据，只要相应地定义了每个参数。对于更高级的应用，可能需要定义自定义块类型和函数来创建批处理。处理 3D 数据就是这种情况。然而，正如我将在下面的六个步骤中展示的，一旦你熟悉了<strong class="lu ir">数据块</strong>的结构，这个过程就相当简单了。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h2 id="e101" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">步骤 0。数据源</h2><p id="1b6b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">在这个例子中，我将使用 MNIST 的数据。我将从 0 到 9 的数字序列定义为我们的图像序列——这使得调试更加容易。下表显示了数据帧的组织方式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/21f5b701e5ecc482c985b49c9148692d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*tjmkNH8Z8vugoyiiR-q3Aw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据帧的例子。作者创造的形象。</p></figure><p id="15e1" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">数据框架中的列有:</p><ul class=""><li id="05e7" class="ng nh iq lu b lv ml ly mm lf ni lj nj ln nk mk nl nm nn no bi translated"><strong class="lu ir">文件</strong> : <strong class="lu ir"> </strong>每个图像的路径；</li><li id="c316" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated"><strong class="lu ir"> sequence_id </strong>:每个序列的唯一标识符；</li><li id="737e" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated"><strong class="lu ir"> sequence_order </strong>:序列中元素的顺序——在这种情况下，对应于从 0 到 9 的数字；</li><li id="8693" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated"><strong class="lu ir">标签</strong>:每个序列的目标标签。</li></ul><h2 id="36e6" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第一步。定义<strong class="ak">图像序列块</strong></h2><p id="3bc8" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">为了定义一个<strong class="lu ir">图像序列块</strong>，我使用了以下代码:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="8095" class="kw kx iq my b gy nc nd l ne nf">class <strong class="my ir">ImageSequence</strong>(Tuple):<br/>    <em class="nv">@classmethod</em><br/>    def create(cls, image_files): <br/>        return cls(tuple(PILImage.create(f) for f in image_files))<br/><br/>def <strong class="my ir">ImageSequenceBlock</strong>(): <br/>    return TransformBlock(type_tfms  = ImageSequence.create,<br/>                          batch_tfms = int2float)</span></pre><ul class=""><li id="44df" class="ng nh iq lu b lv ml ly mm lf ni lj nj ln nk mk nl nm nn no bi translated">首先，创建一个<strong class="lu ir">图像序列</strong>。它只是一个元组，包含<strong class="lu ir"> image_files </strong>列表中给出的所有图像。</li><li id="0c58" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated">那么<strong class="lu ir"> ImageSequenceBlock </strong>只是一个使用<strong class="lu ir"> ImageSequence </strong>返回 fastai <strong class="lu ir"> TransformBlock </strong>的函数。这是对<strong class="lu ir">图像块</strong>的 fastai 代码的简单改编。</li></ul><h2 id="82a6" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第二步。定义获取项目功能</h2><p id="bf11" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">请注意，<strong class="lu ir"> ImageSequence </strong>中的 create 函数接收图像文件列表作为参数。我们需要创建将返回这样的列表的函数，并将其交给<strong class="lu ir">数据块中的<strong class="lu ir"> get_items </strong>参数。</strong></p><p id="190d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">基于数据源格式(步骤 0 中的 dataframe ),我定义了以下类来创建序列和标签列表:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="1e56" class="kw kx iq my b gy nc nd l ne nf">class <strong class="my ir">SequenceGetItems</strong>():<br/>    def __init__(self, filename_col, sequence_id_col, label_col):<br/>        self.fn    = filename_col<br/>        self.seq   = sequence_id_col<br/>        self.label = label_col<br/>        <br/>    def __call__(self, df):<br/>        data = []<br/>        for fn in progress_bar(df[self.seq].unique()):<br/>            similar = df[self.seq] == fn<br/>            similar = df.loc[similar]<br/>            fns = similar[self.fn].tolist()<br/>            lbl = similar[self.label].values[0]<br/>            data.append([*fns, lbl])<br/>        return data</span></pre><ul class=""><li id="9ae5" class="ng nh iq lu b lv ml ly mm lf ni lj nj ln nk mk nl nm nn no bi translated">该类所需的属性只是数据帧上对应于文件名、唯一序列标识符和标签的列名。</li><li id="c65c" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated">调用时，__call__ 方法将接收数据帧“df”作为参数，并将返回一个列表列表。每个子列表由序列的图像文件名和子列表最后一个元素中的相应标签组成。</li></ul><p id="1c0f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">现在，请记住上面的<strong class="lu ir">数据块</strong>示例，即<strong class="lu ir"> get_x </strong>和<strong class="lu ir"> get_y </strong>接收来自<strong class="lu ir"> get_items </strong>的输出，并且应该将输入和目标分开。在这种情况下，它们就像这样简单:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="05ab" class="kw kx iq my b gy nc nd l ne nf">get_x = lambda t : t[:-1]<br/>get_y = lambda t : t[-1]</span></pre><ul class=""><li id="467d" class="ng nh iq lu b lv ml ly mm lf ni lj nj ln nk mk nl nm nn no bi translated">如你所见，<strong class="lu ir"> get_x </strong>将选择列表中的所有元素，但最后一个将由<strong class="lu ir"> get_y </strong>选择。<strong class="lu ir"> </strong>这只是前面讨论的序列创建方式的结果——标签只是每个子列表中的最后一个元素。</li></ul><h2 id="5b7c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第三步。把所有东西放在数据块里</h2><p id="4f4f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">有了上面两步定义的代码，为我们的图像序列构建一个<strong class="lu ir">数据块</strong>是一项简单的任务:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="84d2" class="kw kx iq my b gy nc nd l ne nf">dblock = DataBlock(<br/>    blocks    = (ImageSequenceBlock, CategoryBlock),<br/>    get_items = SequenceGetItems('file', 'sequence_id', 'label'), <br/>    get_x     = lambda t : t[:-1],<br/>    get_y     = lambda t : t[-1],<br/>    splitter  = RandomSplitter())</span></pre><ul class=""><li id="caa0" class="ng nh iq lu b lv ml ly mm lf ni lj nj ln nk mk nl nm nn no bi translated">注意，对于<strong class="lu ir">块</strong>参数，我们现在给出步骤 1 中定义的<strong class="lu ir">图像序列块</strong>。</li><li id="02d0" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated">然后对于<strong class="lu ir"> get_items </strong>参数，我们使用在步骤 2 中定义的<strong class="lu ir"> SequenceGetItems </strong>类。</li><li id="cd85" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated"><strong class="lu ir"> get_x </strong>和<strong class="lu ir"> get_y </strong>非常简单，如前一节所述。</li><li id="858a" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated">对于<strong class="lu ir">分离器，</strong>可以使用常用的 fastai 功能。另一个常见的选项是<strong class="lu ir"> IndexSplitter </strong>，它允许精确地指定哪些项在验证集上。</li></ul><p id="f730" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我还没有包含任何<strong class="lu ir"> item_tfms </strong>或<strong class="lu ir"> batch_tfms </strong>，但是我很快就会包含。然而，让我们首先来看一个重要的附加部分——创建数据加载器。</p><h2 id="3d39" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第四步。创建数据加载器</h2><p id="305f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">为了从<strong class="lu ir">数据块</strong>中创建一个数据加载器，我们需要定义一个自定义函数来告诉如何创建批处理。到目前为止，我们只有图像序列。我们想要的是 PyTorch 张量。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="901e" class="kw kx iq my b gy nc nd l ne nf">def <strong class="my ir">create_batch</strong>(data):<br/>    xs, ys = [], []<br/>    for d in data:<br/>        xs.append(d[0])<br/>        ys.append(d[1])<br/>    xs = torch.cat([TensorImage(torch.cat([im[None] for im in x], dim=0))[None] for x in xs], dim=0)<br/>    ys = torch.cat([y[None] for y in ys], dim=0)<br/>    return TensorImage(xs), TensorCategory(ys)</span></pre><ul class=""><li id="a4c4" class="ng nh iq lu b lv ml ly mm lf ni lj nj ln nk mk nl nm nn no bi translated">这段代码将单个图像张量连接成一个具有额外维度的新张量，然后将单个序列成批连接在一起。如果图像是 3 通道，128×128 大小，序列的长度是 10，批量大小是 8，那么张量将具有[8，10，3，128，128]的形状。</li><li id="5375" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated">注意，当我返回张量时，我使用了<strong class="lu ir"> TensorImage </strong>和<strong class="lu ir"> TensorCategory </strong>。这些是 fastai 类型，提供了非常有用的功能。</li></ul><p id="db7a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">现在，要创建数据加载器，下面一行代码可以完成:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="aa95" class="kw kx iq my b gy nc nd l ne nf">dls = dblock.dataloaders(df, bs=8, create_batch=create_batch)</span></pre><ul class=""><li id="e842" class="ng nh iq lu b lv ml ly mm lf ni lj nj ln nk mk nl nm nn no bi translated">请注意，<strong class="lu ir"> df </strong>是我们在步骤 0 中提到的数据帧，<strong class="lu ir"> bs </strong>是批量大小，并且给出了一个自定义的<strong class="lu ir"> create_batch </strong>函数。</li></ul><h2 id="1979" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第五步。可视化数据</h2><p id="bf1b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">这一步对于功能来说并不是最基本的，但是能够显示数据并检查是否一切正常总是好的！</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="28cd" class="kw kx iq my b gy nc nd l ne nf">def <strong class="my ir">show_sequence_batch</strong>(max_n=4):<br/>    xb, yb = dls.one_batch()<br/>    fig, axes = plt.subplots(ncols=10, nrows=max_n, figsize=(12,6), dpi=120)<br/>    for i in range(max_n):<br/>        xs, ys = xb[i], yb[i]<br/>        for j, x in enumerate(xs):<br/>            axes[i,j].imshow(x.permute(1,2,0).cpu().numpy())<br/>            axes[i,j].set_title(ys.item())<br/>            axes[i,j].axis('off')</span></pre><p id="85be" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> show_sequence_batch </strong>函数<strong class="lu ir"/></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/f4e3877f1034d66a4a90d5f190aaf905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3bX_8OEq4jgsoPQb8d8bw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">show_sequence_batch 函数的结果作者创造的形象。</p></figure><p id="803f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">请注意，每个图像上方的数字对应于序列标识符，这就是为什么在本例中它们在每一行都是相同的。</p><h2 id="4da5" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第六步。添加图像和序列增强</h2><p id="699b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">由于我们的批次有一个“额外的”维度—对应于序列长度—我们不能开箱即用地应用 fastai 图像增强。此外，正如在本文的引言中所讨论的，在一些问题中，我们需要按顺序应用变换，以便在我们可能希望提供给 3D 卷积模型的序列元素之间保持空间一致性。</p><p id="471b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">获得想要的结果的最简单的方法——或者至少是我能想到的最简单的方法——是注意到变换被同样地应用到每个图像通道。因此，如果我们使用张量形状——使用 PyTorch <strong class="lu ir"> view </strong>方法——我们可以按顺序或按图像应用基本的图像变换。变换之后，我们可以把张量重塑回原来的形状。</p><p id="8937" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">为此，我定义了两个类:<strong class="lu ir">sequence FMS</strong>和<strong class="lu ir"> BatchTfms </strong>。这两个类被定义为 fastai <strong class="lu ir"> Transform </strong>的子类。关于 fastai <strong class="lu ir">转换</strong>需要注意的一个方面是<strong class="lu ir">编码</strong>方法类似于 PyTorch 模块中的<strong class="lu ir"> forward </strong>方法或者 Python 类中常见的<strong class="lu ir"> __call__ </strong>方法。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="e6c1" class="kw kx iq my b gy nc nd l ne nf">class <strong class="my ir">SequenceTfms</strong>(Transform):<br/>    def __init__(self, tfms): <br/>        self.tfms = tfms<br/>        <br/>    def encodes(self, x:TensorImage): <br/>        bs, seq_len, ch, rs, cs = x.shape<br/>        x = x.view(bs, seq_len*ch, rs, cs)<br/>        x = compose_tfms(x, self.tfms)<br/>        x = x.view(bs, seq_len, ch, rs, cs) <br/>        return x<br/>    <br/>class <strong class="my ir">BatchTfms</strong>(Transform):<br/>    def __init__(self, tfms): <br/>        self.tfms = tfms<br/>        <br/>    def encodes(self, x:TensorImage): <br/>        bs, seq_len, ch, rs, cs = x.shape<br/>        x = x.view(bs*seq_len, ch, rs, cs)<br/>        x = compose_tfms(x, self.tfms)<br/>        x = x.view(bs, seq_len, ch, rs, cs) <br/>        return x</span></pre><ul class=""><li id="97fa" class="ng nh iq lu b lv ml ly mm lf ni lj nj ln nk mk nl nm nn no bi translated">这两个类都用要应用于数据的扩充列表进行初始化。</li><li id="72d0" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated"><strong class="lu ir">sequence FMS</strong>按顺序应用变换(同一序列中所有图像的变换相同)。</li><li id="f639" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated"><strong class="lu ir"> BatchTfms </strong>按图像方式应用变换。</li></ul><p id="117d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">完整的<strong class="lu ir">数据块</strong>现在看起来像这样:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="1d61" class="kw kx iq my b gy nc nd l ne nf">affine_tfms, light_tfms = aug_transforms(flip_vert=True)<br/>brightness = lambda x : x.brightness(p=0.75, max_lighting=0.9)<br/>contrast   = lambda x : x.contrast(p=0.75, max_lighting=0.9)<br/><br/>dblock = DataBlock(<br/>    blocks     = (ImageSequenceBlock, CategoryBlock),<br/>    get_items  = SequenceGetItems('file', 'sequence_id', 'label'), <br/>    get_x      = lambda t : t[:-1],<br/>    get_y      = lambda t : t[-1],<br/>    splitter   = RandomSplitter(valid_pct=0.2, seed=2020),<br/>    item_tfms  = Resize(128),<br/>    batch_tfms = [SequenceTfms([affine_tfms]), <br/>                  BatchTfms([brightness, contrast])])<br/><br/>dls = dblock.dataloaders(df, bs=8, create_batch=create_batch)</span></pre><p id="c907" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">注意:到目前为止，我还不能用这种方法使用由<strong class="lu ir"> aug_transforms </strong>给出的<strong class="lu ir">light _ tfms</strong>——这就是为什么我手动定义了<strong class="lu ir">亮度</strong>和<strong class="lu ir">对比度</strong>转换，它们只是<strong class="lu ir"> ImageTensor </strong> fastai 类型的方法。</p><p id="244b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><strong class="lu ir"> show_sequence_batch </strong>可视化的结果如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/2160fc1963ce92fc014ccfc747e7c681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e4E-boThArytnvKnunI2wQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用图像和序列增强的 show_sequence_batch 函数的结果。作者创造的形象。</p></figure><ul class=""><li id="3df9" class="ng nh iq lu b lv ml ly mm lf ni lj nj ln nk mk nl nm nn no bi translated">请注意，在第一行中，图像是旋转的，但由于仿射变换是按顺序应用的，因此它们在序列中是一致旋转的。</li><li id="076e" class="ng nh iq lu b lv np ly nq lf nr lj ns ln nt mk nl nm nn no bi translated">对于亮度和对比度变换，请注意它们是随机应用于各个图像的。</li></ul><p id="3c1b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">如您所见，该框架可以根据数据/问题的类型轻松定制。</p><h2 id="f22a" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">结论</strong></h2><p id="9c65" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">在这个故事中，我讲述了如何使用 fastai <strong class="lu ir"> DataBlock </strong>为深度学习应用处理 3D 数据。这个代码的一个工作示例在<a class="ae kv" href="https://www.kaggle.com/mnpinto/fastai2-working-with-3d-data" rel="noopener ugc nofollow" target="_blank">这个 Kaggle 内核</a>上提供。</p><p id="9005" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我花了一些时间和几次迭代才得到这里展示的代码，但所有这些学习过程让我对 fastai <strong class="lu ir"> DataBlock </strong>有了更好的理解，以及它是如何如此通用的！</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="561b" class="nx kx iq bd ky ny nz oa lb ob oc od le jw oe jx li jz of ka lm kc og kd lq oh bi translated">关于我</h1><div class="oi oj gp gr ok ol"><a rel="noopener follow" target="_blank" href="/my-3-year-journey-from-zero-python-to-deep-learning-competition-master-6605c188eec7"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">我的 3 年历程:从零 Python 到深度学习竞赛高手</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">自从 2017 年开始学习 Python 以来，我一直遵循的道路是成为一名独自参加 Kaggle 比赛的大师…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz kp ol"/></div></div></a></div><p id="00f4" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><em class="nv">感谢阅读！如果你对这个话题还有其他问题，请随时发表评论。</em></p></div></div>    
</body>
</html>