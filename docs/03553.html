<html>
<head>
<title>Getting Started With Parallel Programming In R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R并行编程入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-parallel-programming-in-r-d5f801d43745?source=collection_archive---------10-----------------------#2020-04-04">https://towardsdatascience.com/getting-started-with-parallel-programming-in-r-d5f801d43745?source=collection_archive---------10-----------------------#2020-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="acf2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在多个CPU内核之间分配工作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/193b3c5a689abee026850dd657bcf1f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-rf1L6aC-ZwcrB_9Vh6ig.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://pixabay.com/photos/highway-night-photograph-lights-393492/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><h1 id="8274" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">我为什么要看这篇文章？</h1><p id="05f9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">尽管R中有许多关于并行计算的好资料，但很少有人以这样一种任何人都可以入门的基本方式解释这些概念。由于R的高级本质和强大的开源开发者社区，并行化基本和更复杂的任务非常简单。如果您熟悉<code class="fe mk ml mm mn b">apply</code>系列函数(在数组或列表的索引上应用函数的函数)，只需增加三行代码就可以完成并行化！在本文中，我们将从“应用”功能的并行版本开始，扩展到更灵活的方法，最后通过一个来自财务优化的真实示例。</p><h1 id="5405" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">并行运行<code class="fe mk ml mm mn b">"apply" </code>功能</h1><p id="443c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们开始吧。假设我们有一个包含四个大向量的列表。对于四个大向量中的每一个，我们都要计算平均值。下面，使用传统的<code class="fe mk ml mm mn b">lapply</code>方法计算平均值:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="2a06" class="ms kx iq mn b gy mt mu l mv mw"># Generate data<br/>data &lt;- 1:1e9<br/>data_list &lt;- list("1" = data,<br/>                  "2" = data,<br/>                  "3" = data,<br/>                  "4" = data)</span><span id="6c61" class="ms kx iq mn b gy mx mu l mv mw"># Single core<br/>time_benchmark &lt;- system.time(<br/>  lapply(data_list, mean)<br/>)</span></pre><p id="32d1" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这个计算用了18.33秒。用18秒来计算四个简单的平均值？我们没有时间了。事实证明，我们不需要这么做。上面执行的四个计算是完全独立的。即它们不相互依赖。第1项的含义绝不取决于第2项的含义。默认情况下，R中的大多数功能都运行在一个处理核心上。随着当今大多数系统采用多核处理器，通过简单地将任务划分到多个内核上来减少运行时间的潜力是非常显著的。图书馆<code class="fe mk ml mm mn b">parallel</code>帮助我们实现这一目标。下面，使用来自<code class="fe mk ml mm mn b">parallel</code>库的<code class="fe mk ml mm mn b">lapply</code> ( <code class="fe mk ml mm mn b">parLapply</code>)的多核等价物来实现相同的计算:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="f0f3" class="ms kx iq mn b gy mt mu l mv mw">library(parallel)</span><span id="1d3d" class="ms kx iq mn b gy mx mu l mv mw"># Detect the number of available cores and create cluster<br/>cl &lt;- parallel::makeCluster(detectCores())</span><span id="73c9" class="ms kx iq mn b gy mx mu l mv mw"># Run parallel computation<br/>time_parallel &lt;- system.time(<br/>  parallel::parLapply(cl,<br/>                      data_list,<br/>                      mean)<br/>)</span><span id="cbf4" class="ms kx iq mn b gy mx mu l mv mw"># Close cluster<br/>parallel::stopCluster(cl)</span></pre><p id="3b76" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这个计算用了4.99秒。通过添加三行代码，计算时间几乎减少了75%！这就是现代多核CPU的好处。我使用四核CPU，在四个核而不是一个核上运行四个计算，速度提高了四倍(嗯，由于计算机科学的原因，我没有足够的智慧来解释这一点)。这是您开始使用r中的并行计算所需要的全部内容。如果您只需要apply函数，那就自己动手吧。否则，请继续阅读，我们将用一种提供更多灵活性的方法进行更深入的研究。</p><h1 id="21cc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">并行运行循环迭代</h1><p id="5b43" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">比起一个<code class="fe mk ml mm mn b">apply </code>函数，你更喜欢并行一个传统的循环吗？那么<code class="fe mk ml mm mn b">foreach</code>库就是你的解决方案。<code class="fe mk ml mm mn b">foreach</code>函数的工作方式很像传统的循环，但是除了索引之外，它还需要关于如何构建输出以及在多核循环中应该可以访问哪些库的信息。因为我们的均值计算是使用基R函数执行的，所以不需要将任何包传递给<code class="fe mk ml mm mn b">foreach</code>。同样，平均值的计算是这样实现的:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="38c6" class="ms kx iq mn b gy mt mu l mv mw">library(doParallel)<br/>library(parallel)<br/>library(foreach)</span><span id="e70d" class="ms kx iq mn b gy mx mu l mv mw"># Detect the number of available cores and create cluster<br/>cl &lt;- parallel::makeCluster(detectCores())</span><span id="f06a" class="ms kx iq mn b gy mx mu l mv mw"># Activate cluster for foreach library<br/>doParallel::registerDoParallel(cl)</span><span id="ee92" class="ms kx iq mn b gy mx mu l mv mw">time_foreach &lt;- system.time({<br/>  r &lt;- foreach::foreach(i = 1:length(data_list),<br/>                        .combine = rbind) %dopar% {<br/>    mean(data_list[[i]])<br/>  }<br/>})<br/>time_foreach[3]</span><span id="771b" class="ms kx iq mn b gy mx mu l mv mw"># Stop cluster to free up resources<br/>parallel::stopCluster(cl)</span></pre><p id="e142" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">在5.03秒时，计算时间与<code class="fe mk ml mm mn b">parLapply</code>实现的时间没有显著不同。这里重要的是使用了同名库中的<code class="fe mk ml mm mn b">foreach</code>函数。它具有与for循环类似的功能，但同时在多个内核上执行迭代。这意味着迭代之间不存在依赖性。这里有两个输入被传递给函数；与常规循环一样的索引，以及如何组合输出。<code class="fe mk ml mm mn b">rbind</code>将输出绑定为行。<code class="fe mk ml mm mn b">foreach</code>提供了很大的灵活性，因为你可以完成几乎与传统循环相同的任务——假设每次迭代的结果之间不存在依赖关系。</p><h1 id="a805" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">并行运行投资组合优化</h1><p id="1b4f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在让我们尝试一个更现实的问题。可能很少有人有一个四个向量的列表，并想计算每个向量的平均值。在这一节中，我想说明你刚刚学到的东西在均值计算之外是有用的。具体来说，在我自己的计算金融领域。在计算金融中，经常需要通过运行10、100或1000次相当大的优化算法来模拟性能。通过适当的简化，这个问题很容易并行处理。</p><p id="e782" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">投资组合优化是在给定最大容许风险量的情况下，寻找具有最大预期回报的投资组合的艺术，反之亦然。预期回报通常以平均历史回报给出，风险以历史回报的标准差(或类似的度量)给出。这是一门有缺陷的艺术，因为它假设未来和过去一样。一位智者(苏伦·克尔凯郭尔)曾经说过，生活只能向后理解，但必须向前生活。不幸的是，在量化金融领域也是如此。</p><p id="0841" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">投资组合优化不能告诉你应该承担多大的风险。如果你还年轻，正在为退休储蓄，你可能应该承担相当大的风险，因为你不打算很快取出这笔钱，从长期来看，风险投资会获得更好的回报。如果你正在攒钱准备明年买房，那么降低风险是明智之举。高风险和低风险的投资组合都有一个共同点，那就是它们应该是最优的权衡。你希望在一定的风险下获得尽可能多的回报。所有这些最优投资组合都可以在一个名为“有效边界”的图表中可视化，这是我们将在第三部分也是最后一部分构建的。</p><p id="fcaa" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">首先，为了并行化和财务优化，有必要加载库:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="1a7e" class="ms kx iq mn b gy mt mu l mv mw"># Load parallelisation libraries<br/>library(doParallel)<br/>library(foreach)<br/>library(parallel)</span><span id="38ca" class="ms kx iq mn b gy mx mu l mv mw"># Load finance and optimization libraries<br/>library(PerformanceAnalytics)<br/>library(PortfolioAnalytics)<br/>require(ROI)<br/>require(ROI.plugin.glpk)<br/>require(ROI.plugin.quadprog)<br/>require(quadprog)</span></pre><p id="2002" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">您已经熟悉了前三个库。剩下的五个是金融数学和优化的专用库:</p><ul class=""><li id="5215" class="nd ne iq lq b lr my lu mz lx nf mb ng mf nh mj ni nj nk nl bi translated"><code class="fe mk ml mm mn b">PerformanceAnalytics</code> —用于计算绩效和风险指标的函数库</li><li id="a99f" class="nd ne iq lq b lr nm lu nn lx no mb np mf nq mj ni nj nk nl bi translated"><code class="fe mk ml mm mn b">PortfolioAnalytics</code> —用于构建和分析金融投资组合的函数库</li><li id="4650" class="nd ne iq lq b lr nm lu nn lx no mb np mf nq mj ni nj nk nl bi translated"><code class="fe mk ml mm mn b">ROI</code>、<code class="fe mk ml mm mn b">ROI.plugin.glpk</code>、<code class="fe mk ml mm mn b">ROI.plugin.quadprog</code>、<code class="fe mk ml mm mn b">quadprog</code> —用于优化的库</li></ul><p id="17dd" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">从<code class="fe mk ml mm mn b">PerformanceAnalytics</code>库中，可以加载包含13种工具的财务回报的样本数据集:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="74f0" class="ms kx iq mn b gy mt mu l mv mw"># Load sample return data from the PerformanceAnalytics library<br/>lookback &lt;- 120 # lookback in months<br/>returns &lt;- tail(PerformanceAnalytics::edhec, lookback)</span></pre><p id="f7c1" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我们选择使用过去十年的回报数据来进行投资组合优化，从而假设不久的将来会像过去十年一样。对于投资组合，我们希望只进行长期投资(投资正金额)，完全投资(投资整个预算)投资组合，以最小化风险。最小化的风险度量是ETL(预期尾部损失/风险条件价值/执行短缺)——一种具有理想财务属性的风险度量。如果你不熟悉这个指标，就假设它相当于收益的标准差。如果投资组合的价值波动很大，风险就大。以下代码创建要优化的投资组合对象:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="a556" class="ms kx iq mn b gy mt mu l mv mw"># Create portfolio object<br/>names_funds &lt;- colnames(returns)<br/>port.obj &lt;- PortfolioAnalytics::portfolio.spec(assets = names_funds)<br/>port.obj &lt;- PortfolioAnalytics::add.constraint(portfolio = port.obj,<br/>                                               type = "full_weight")<br/>port.obj &lt;- PortfolioAnalytics::add.constraint(portfolio = port.obj,<br/>                                               type="long_only")<br/>port.obj &lt;- add.objective(portfolio=port.obj,<br/>                          type='risk',<br/>                          name='ETL',<br/>                          arguments=list(p=0.95))</span></pre><p id="26f8" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">现在，为了计算有效边界，有必要知道从给定的工具领域构建的投资组合可以实现的最大预期回报和最小风险:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="a34f" class="ms kx iq mn b gy mt mu l mv mw"># Define maximum achievable return<br/>ER_assets &lt;- colMeans(returns)<br/>ER_assets_max &lt;- max(ER_assets)</span><span id="6002" class="ms kx iq mn b gy mx mu l mv mw"># Calculation of return of minimum risk portfolio<br/>weights_ES_min &lt;- PortfolioAnalytics::optimize.portfolio(<br/>  R = returns,<br/>  portfolio = port.obj,<br/>  optimize_method = "ROI",<br/>  trace = FALSE)$weights<br/>ER_ES_min &lt;- sum(weights_ES_min * ER_assets)</span><span id="117c" class="ms kx iq mn b gy mx mu l mv mw"># Vector of return targets<br/>n_portfolios &lt;- 500<br/>return_targets &lt;- seq(ER_ES_min,<br/>                      ER_assets_max,<br/>                      length.out = n_portfolios)</span></pre><p id="f1e8" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">最大预期收益很容易找到，它就是回望期内平均收益最大的投资组合。由于分散效应，最小化风险的投资组合稍微复杂一些。我们通过求解优化问题找到投资组合，而无需指定回报目标，并计算该投资组合的预期回报。最后，定义最小值和最大值之间的500个等间距返回目标的向量。</p><p id="e101" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">对于这种多核优化，将再次使用<code class="fe mk ml mm mn b">foreach</code>。然而，计算稍微复杂一些，因此将多核循环中的内容定义为函数是有益的。这使得指定输出等的格式变得简单。该函数定义如下:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="2f52" class="ms kx iq mn b gy mt mu l mv mw"># Write optimization function that returns exactly what we need.<br/>optimise &lt;- function(port.obj,<br/>                     return_target) {<br/>  port.obj &lt;- PortfolioAnalytics::add.constraint(<br/>    portfolio = port.obj,<br/>    type="return",<br/>    return_target = return_target)<br/>  out &lt;- PortfolioAnalytics::optimize.portfolio(<br/>    R = returns,<br/>    portfolio = port.obj,<br/>    optimize_method = "ROI",<br/>    trace = FALSE)<br/>  return(c(out$weights, out$objective_measures$ETL))<br/>}</span></pre><p id="50e8" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">优化功能将目标回报约束添加到我们的投资组合中，确定最佳投资组合，并以向量形式回报工具权重和风险。这是在<code class="fe mk ml mm mn b">foreach</code>循环中实现的，与之前一样:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="f768" class="ms kx iq mn b gy mt mu l mv mw"># Activate cluster for foreach library and pass libraries<br/>cl &lt;- parallel::makeCluster(detectCores())<br/>doParallel::registerDoParallel(cl)</span><span id="2177" class="ms kx iq mn b gy mx mu l mv mw">time_foreach &lt;- system.time({<br/>  data_frontier_par &lt;- foreach::foreach(<br/>    i = 1:n_portfolios,<br/>    .combine = rbind,<br/>    .packages = c("PortfolioAnalytics")) %dopar% {<br/>      optimise(port.obj, return_targets[i])<br/>    }<br/>})</span><span id="c123" class="ms kx iq mn b gy mx mu l mv mw">parallel::stopCluster(cl)</span></pre><p id="caa4" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><code class="fe mk ml mm mn b">foreach</code>函数将循环的索引作为输入，如何组合输出和循环中引用的库。定义这三个输入后，只需插入优化函数，500次优化运行在1.91秒内完成。<code class="fe mk ml mm mn b">foreach</code>的一个有用特性是，通过将<code class="fe mk ml mm mn b">%dopar%</code>改为<code class="fe mk ml mm mn b">%do%</code>，它可以被修改为在单核上运行。如果你有一个咄咄逼人的老板，需要一个借口去喝咖啡(或者如果你想对单核的计算时间进行基准测试)，这是一个很好的功能。在单核上，500次优化运行在5.05秒内完成——这一次，并行化并没有使我们的运行时间减少75%。这是因为将库加载到所有四个核心上需要时间。由此产生的有效边界看起来如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/8123d57c7fc1692b6540e32af706c036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1BhgLCEmoToHIhiKbyKI3A.png"/></div></div></figure><p id="1201" class="pw-post-body-paragraph lo lp iq lq b lr my jr lt lu mz ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">每单位风险的最佳回报可能是3% ETL左右，但选择哪个投资组合取决于你。沿着边界的所有投资组合都给出了其风险量的最优回报，因此可以被理性的投资者选择。</p><h1 id="f663" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="7dfa" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我希望这篇文章能让你并行运行R脚本，从而帮助你加快速度！随着CPU性能向更多内核而不是更高频率发展，不利用并行化将是一种浪费。在R中，只需在正确的位置添加几行代码，您的计算速度就可以提高数倍。</p><h1 id="fbaf" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">评论</h1><p id="d175" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">本文中的代码运行在Windows系统上。对于Linux或Mac，考虑用<code class="fe mk ml mm mn b">mclapply</code>替换<code class="fe mk ml mm mn b">parLapply</code>。可能需要更多的修改。</p><h1 id="e8f0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">参考</h1><ul class=""><li id="b28c" class="nd ne iq lq b lr ls lu lv lx ns mb nt mf nu mj ni nj nk nl bi translated"><a class="ae kv" href="https://cran.r-project.org/web/packages/PortfolioAnalytics/vignettes/portfolio_vignette.pdf" rel="noopener ugc nofollow" target="_blank">portfolio analytics简介</a></li><li id="0698" class="nd ne iq lq b lr nm lu nn lx no mb np mf nq mj ni nj nk nl bi translated"><a class="ae kv" href="https://nceas.github.io/oss-lessons/parallel-computing-in-r/parallel-computing-in-r.html" rel="noopener ugc nofollow" target="_blank">R中并行计算的快速介绍</a></li></ul></div></div>    
</body>
</html>