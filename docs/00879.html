<html>
<head>
<title>A Data Scientist’s Intro to Parallel Computing With Dask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家对Dask并行计算的介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-data-scientists-intro-to-parallel-computing-with-dask-4c1b4a464579?source=collection_archive---------11-----------------------#2020-01-25">https://towardsdatascience.com/a-data-scientists-intro-to-parallel-computing-with-dask-4c1b4a464579?source=collection_archive---------11-----------------------#2020-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1210" class="pw-subtitle-paragraph jr is it bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">利用Dask并行化您的Python代码</h2></div><p id="fe53" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在这篇文章中，我们讨论了利用python 中的<a class="ae lf" href="https://docs.dask.org" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> Dask </em> </a> <em class="lg">的基础知识，使用它来执行一些简单的并行化任务(<em class="lg">令人尴尬的并行</em>)，了解一些最常见的可能用例(<em class="lg">数据管理、数据探索、机器学习</em>)，然后触及一些更复杂的工作流，这些工作流可以通过将不同的ML库与<em class="lg"> Dask </em>相结合来构建。在这篇文章中，我们将重点关注运行一个令人尴尬的与Dask </em>并行的任务。</p><p id="d979" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">什么是并行计算？</strong></p><p id="a277" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你可能听说过这个短语，但是除了所有实际的复杂算法之外，它真正的核心含义是:你执行你想做的工作，这样多个步骤同时发生，而不是总是等待前一个任务完成。难度随着你实际想要完成的事情的性质而增加。</p><p id="668c" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">彼此独立的操作/任务，即除了每个任务的开始和结束之外，不存在任何数据依赖性——通常最容易并行化，并被称为<em class="lg">令人尴尬的并行</em> <strong class="kl iu"> <em class="lg">、</em> </strong>，而在开始和结束之间涉及大量数据传输/通信的任务则难以并行化。</p><blockquote class="lh li lj"><p id="baf4" class="kj kk lg kl b km kn jv ko kp kq jy kr lk kt ku kv ll kx ky kz lm lb lc ld le im bi translated">作为一名数据科学家/分析师，您并不总是有足够的时间或所需的技能来思考如何并行化您的任务，并从头开始用其他语言实施解决方案，例如，花费数周、甚至数月时间来发现最佳的分组方式并不是您所期望的！</p></blockquote><p id="0948" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">什么是<em class="lg"> Dask </em>？</strong></p><blockquote class="ln"><p id="d057" class="lo lp it bd lq lr ls lt lu lv lw le dk translated">Dask:在Python中并行化计算任务的框架</p></blockquote><p id="9327" class="pw-post-body-paragraph kj kk it kl b km lx jv ko kp ly jy kr ks lz ku kv kw ma ky kz la mb lc ld le im bi translated"><code class="fe mc md me mf b">Dask</code>是一个旨在帮助促进:</p><ul class=""><li id="6089" class="mg mh it kl b km kn kp kq ks mi kw mj la mk le ml mm mn mo bi translated">超大型数据集的数据管理，以及</li><li id="798f" class="mg mh it kl b km mp kp mq ks mr kw ms la mt le ml mm mn mo bi translated">跨大量内核(具有多个工作人员的本地集群)或物理计算机(具有多个节点的集群)的计算分布</li></ul><p id="6302" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">它提供的功能类似于Apache Spark的<a class="ae lf" href="https://spark.apache.org" rel="noopener ugc nofollow" target="_blank"><em class="lg"/></a>，但是它被紧密地集成到了<code class="fe mc md me mf b">numpy</code>和<code class="fe mc md me mf b">pandas</code>中，对于那些库的用户来说，它比Spark更容易学习和使用。</p><p id="d499" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">并行化一项任务，如果你是一个从头开始构建框架的人，那么任何任务都是困难的。有python模块(例如<em class="lg">多重处理</em>)可以帮助你跳过这一部分，执行和管理(在某种程度上)不同的线程。但是，从用户的角度来看，即使这样也需要大量的努力和特殊的技能。在这种情况下，监控、日志记录等通常也是次要的。</p><p id="d076" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu"> <em class="lg"> Dask </em> </strong>去掉了所有复杂的<em class="lg">(虽然重要)</em>内部抽象，给你一个干净的api，让你在python中并行化你现有的代码。取决于你如何编写你的代码——你可能甚至不需要修改你现有的函数来使它们与<strong class="kl iu"> <em class="lg"> Dask </em> </strong>一起工作！</p><p id="f642" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们从使用下面的<strong class="kl iu"> <em class="lg"> Dask </em> </strong>和接下来的几篇文章开始。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mu"><img src="../Images/dff3cd5d559c5f5d7092cf567ab70687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6mSsdWECFLn6wJne4VTjg.png"/></div></div></figure><p id="f4cd" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">获取<em class="lg"> Dask </em> : </strong></p><p id="7be5" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我会推荐以下选择之一:</p><ul class=""><li id="54b0" class="mg mh it kl b km kn kp kq ks mi kw mj la mk le ml mm mn mo bi translated">为您的python环境安装<a class="ae lf" href="https://www.anaconda.com/distribution" rel="noopener ugc nofollow" target="_blank"> Anaconda </a>(我的首选，Dask 随基本设置一起安装。你也可以<a class="ae lf" href="https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html" rel="noopener ugc nofollow" target="_blank">创建一个新的环境</a>来保持你的<em class="lg"> Dask </em>环境在你学习、安排工作等的时候是独立的</li></ul><pre class="mv mw mx my gt ng mf nh ni aw nj bi"><span id="0390" class="nk nl it mf b gy nm nn l no np">conda create --name dask python=3.7 anaconda dask</span></pre><ul class=""><li id="1e79" class="mg mh it kl b km kn kp kq ks mi kw mj la mk le ml mm mn mo bi translated">创建一个新的<a class="ae lf" href="https://docs.python-guide.org/dev/virtualenvs" rel="noopener ugc nofollow" target="_blank"> python虚拟环境</a>并在其中安装<em class="lg"> Dask </em></li><li id="6117" class="mg mh it kl b km mp kp mq ks mr kw ms la mt le ml mm mn mo bi translated">在您当前的环境中安装<em class="lg"> Dask </em></li></ul><pre class="mv mw mx my gt ng mf nh ni aw nj bi"><span id="558f" class="nk nl it mf b gy nm nn l no np"># Anaconda environment</span><span id="ab81" class="nk nl it mf b gy nq nn l no np">conda install dask</span><span id="10dd" class="nk nl it mf b gy nq nn l no np"># pip based installation</span><span id="c819" class="nk nl it mf b gy nq nn l no np">pip install "dask[complete]"</span></pre><p id="124a" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">创建你的<em class="lg"> Dask </em>客户端:</strong></p><pre class="mv mw mx my gt ng mf nh ni aw nj bi"><span id="61f7" class="nk nl it mf b gy nm nn l no np">import dask<br/>from dask.distributed import Client, progress</span><span id="d54d" class="nk nl it mf b gy nq nn l no np">try:<br/>    client.close()<br/>    client = Client(threads_per_worker=1, <br/>                    n_workers=5, <br/>                    memory_limit='2GB')<br/>except:<br/>    client = Client(threads_per_worker=1, <br/>                    n_workers=5, <br/>                    memory_limit='2GB')</span><span id="2b06" class="nk nl it mf b gy nq nn l no np">client</span></pre><p id="75be" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在这里，我们已经创建了一个<strong class="kl iu">本地集群</strong>，<strong class="kl iu"> </strong>定义了要运行多少本地工作者以及要为每个工作者分配的资源。<br/>这个客户端一次最多可以运行5个任务(<em class="lg">n _ workers</em>)<em class="lg">Dask</em>处理定义单个线程的所有细节，在一个任务完成时在不同线程之间进行协调，下一个任务开始时，从我们的环境向每个工作线程传输数据，等等</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nr"><img src="../Images/f6ef9c22f155c4f10882ae172d58bfef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hb3RbsLeiedPPNVuTw7Vvw.png"/></div></div></figure><h2 id="849b" class="nk nl it bd ns nt nu dn nv nw nx dp ny ks nz oa ob kw oc od oe la of og oh oi bi translated">您的第一个Dask示例:</h2><p id="b49a" class="pw-post-body-paragraph kj kk it kl b km oj jv ko kp ok jy kr ks ol ku kv kw om ky kz la on lc ld le im bi translated">任务:计算给定数据集中每个类别的平均值和标准偏差</p><p id="1097" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">步骤01:创建一个样本模拟<br/> </strong>在我们的例子中，我模拟了一个包含<strong class="kl iu"> k </strong>操作和<strong class="kl iu"> g </strong>类别的数据集。该模拟的输出是每个模拟的平均值和标准偏差。</p><pre class="mv mw mx my gt ng mf nh ni aw nj bi"><span id="e22a" class="nk nl it mf b gy nm nn l no np">def simulate_dataset(i):<br/>    <br/>    g = 10<br/>    k = 100000<br/>    <br/>    categories = np.random.choice(a = np.arange(g), size= k)<br/>    values = [(j+1)*np.random.random(k//g) for j in range(g) ]<br/>    values = np.concatenate(values)<br/>    <br/>    data     = pd.DataFrame({'category':categories,<br/>                             'values':values})<br/>    data_out = data.groupby('category').apply(lambda df: [<br/>                                         df.loc[:,'values'].mean(),<br/>                                         df.loc[:,'values'].std()<br/>                                         ])</span><span id="beef" class="nk nl it mf b gy nq nn l no np">return(data_out)</span></pre><p id="367d" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">这个</strong>函数可以是你想要的任何东西，任何复杂的分析/模拟任务——只要它是独立的。每次迭代都可以独立运行，不需要与其他线程进行任何通信，只需要在模拟开始时进行输入。</p><p id="5e05" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">步骤02:在for循环中运行n次模拟</strong></p><pre class="mv mw mx my gt ng mf nh ni aw nj bi"><span id="3538" class="nk nl it mf b gy nm nn l no np">%%timeit</span><span id="b570" class="nk nl it mf b gy nq nn l no np">results = {}</span><span id="4a72" class="nk nl it mf b gy nq nn l no np">for i in range(n):<br/>    <br/>    results[i] = simulate_dataset(i)</span></pre><p id="f072" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">步骤03:用<em class="lg"> Dask </em>运行n次</strong>模拟</p><pre class="mv mw mx my gt ng mf nh ni aw nj bi"><span id="bcbc" class="nk nl it mf b gy nm nn l no np">%%timeit</span><span id="a6e0" class="nk nl it mf b gy nq nn l no np">results_interim = {}<br/>for i in range(n):<br/>    results_interim[i] = delayed(simulate_dataset)(i)</span><span id="5bf2" class="nk nl it mf b gy nq nn l no np">results_scheduled = delayed(list)(results_interim)<br/>results = results_scheduled.compute()</span></pre><h1 id="164d" class="oo nl it bd ns op oq or nv os ot ou ny ka ov kb ob kd ow ke oe kg ox kh oh oy bi translated">比较:</h1><p id="c635" class="pw-post-body-paragraph kj kk it kl b km oj jv ko kp ok jy kr ks ol ku kv kw om ky kz la on lc ld le im bi translated">在这个独立的例子中，我们看到了大约3倍的加速。当您增加计算/模拟的重量时，加速会更加明显(增加独特的<strong class="kl iu">类别</strong>或<strong class="kl iu">总样本量</strong>(在我们的例子中为<strong class="kl iu"> ) </strong></p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi oz"><img src="../Images/dd9e640fe2851e7d77a2850407637e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hufvzKOey0lUqiR-PEF5vA.png"/></div></div><p class="pa pb gj gh gi pc pd bd b be z dk translated">For循环vs Dask</p></figure><p id="b28e" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这种增长不是线性的，因为启动和管理不同的员工会产生管理费用。每个工人的计算量越大，这种开销的影响就越小。</p></div><div class="ab cl pe pf hx pg" role="separator"><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj"/></div><div class="im in io ip iq"><p id="1c75" class="pw-post-body-paragraph kj kk it kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu"><em class="lg">Dask仪表板上的进度可视化:</em> </strong></p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi pl"><img src="../Images/857398f31a911bbe9a060c3515d03455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W5YXXC2O_7kWG3Vl1S5yvQ.png"/></div></div><p class="pa pb gj gh gi pc pd bd b be z dk translated">工人利用率</p></figure><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi pm"><img src="../Images/b88ed9f0681bc09a49c5536192eddbd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcvvAYPphVPomvtJFBv2SA.png"/></div></div><p class="pa pb gj gh gi pc pd bd b be z dk translated">任务图</p></figure><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi pm"><img src="../Images/47bc1be5846e077ad39038b45b54332f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSfqnwEO_C6C20H6HyzCmg.png"/></div></div><p class="pa pb gj gh gi pc pd bd b be z dk translated">任务流</p></figure></div></div>    
</body>
</html>