<html>
<head>
<title>Generalizing data load processes with Airflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用气流概括数据加载过程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/generalizing-data-load-processes-with-airflow-a4931788a61f?source=collection_archive---------11-----------------------#2020-01-13">https://towardsdatascience.com/generalizing-data-load-processes-with-airflow-a4931788a61f?source=collection_archive---------11-----------------------#2020-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7953" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener" target="_blank" href="/building-a-data-warehouse-basic-architectural-principles-66bd7059ffd0">构建数据仓库:基本架构原则</a></h2><div class=""/><div class=""><h2 id="3d6a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">数据加载过程不应该写两遍，它们应该是通用的</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/1650aac0f68f0ec85c9d0482ba74f3c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fUhOV1VFReN9C2J-"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@maxcodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克斯·尼尔森</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="be6d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使用Airflow作为我们的数据管道编排器，以便轻松地编排和监控数据流程。特别是，我们一直致力于<a class="ae lh" href="https://en.wikipedia.org/wiki/Extract,_transform,_load" rel="noopener ugc nofollow" target="_blank"> <em class="me">数据加载过程</em> </a> <em class="me"> </em>以便使它们更容易<em class="me">。</em>这些流程允许我们从不同的来源提取数据，并将它们集成到我们的数据湖中——在本例中是AWS S3。</p><p id="6a83" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们体验气流的早期，我们会为应该集成到数据湖中的每个数据源创建一个DAG。然而，过了一段时间，我们最终会得到<strong class="lk jd">许多重复的代码</strong>。基本上，创建用于提取数据的Dag的源代码对于它们中的每一个都是相同的。它们之间唯一的区别是数据库连接和将数据增量装载到数据湖的查询。</p><p id="ac9d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">重复代码的问题是，当必须引入更改时，它们必须在执行数据加载的每个Dag中传播，这既耗时又容易出错。</p><p id="24da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们决定通过推广我们为数据加载过程创建Dag的方式来解决这个问题。为此，我们构建了一个框架，在这个框架中，为编排数据加载过程创建这样的Dag更加容易。因此，在这篇文章中，我们想与你分享框架<em class="me"> </em>是如何构建的，以及它如何帮助我们简化数据加载过程。</p><h1 id="2d61" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">我们如何解决它？</h1><p id="8864" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">我们构建了一个旨在简化数据加载的框架。特别是，编写一个配置文件更容易。基于这样一个文件，框架<a class="ae lh" href="https://www.astronomer.io/guides/dynamically-generating-dags/" rel="noopener ugc nofollow" target="_blank">动态生成DAG </a>，允许从目标源增量提取数据并上传到AWS S3。</p><p id="ea69" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该框架包括三个逻辑层次:<em class="me">配置文件</em>、<em class="me"> DAG工厂</em>和<em class="me">加载器</em>:</p><ul class=""><li id="08aa" class="nc nd it lk b ll lm lo lp lr ne lv nf lz ng md nh ni nj nk bi translated"><strong class="lk jd">配置文件</strong>是YAML文件，其中提供了目标源的配置。这种配置可以包括DAG配置参数、数据库凭证、表规范、数据类型等等。这样，集成一个新的源代码就像编写一个简单的配置文件一样简单。</li><li id="3d63" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated"><strong class="lk jd"> <em class="me"> DAG工厂</em> </strong>基于一种我们称之为<em class="me"> DAG工厂的模式。</em>它们允许封装逻辑<a class="ae lh" href="https://www.astronomer.io/guides/dynamically-generating-dags/" rel="noopener ugc nofollow" target="_blank">动态创建Dag</a>。<em class="me"> DAG工厂模式</em>包括<em class="me"> DAG接口</em>和<em class="me">工厂</em>。<em class="me"> DAG接口</em>的功能是读取配置文件并将配置参数传递给适当的<em class="me">工厂，</em>因此<em class="me">工厂</em>可以创建DAG工作流，允许从目标源提取数据。我们集成了许多<em class="me">工厂</em>，例如数据库引擎类型<em class="me">，例如</em>，我们集成了来自MySQL和MongoDB引擎的数据。所以，在这一点上，我们只实现了<em class="me"> MySQL工厂</em>和<em class="me"> MongoDB工厂</em>。</li><li id="6682" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">一个<strong class="lk jd"> <em class="me">加载器</em> </strong>是一个docker映像，它实现了我们所说的<em class="me">加载器模式</em>。基本上，<em class="me">加载器模式</em>基于在数据加载过程中实现功能数据工程方法的<a class="ae lh" rel="noopener" target="_blank" href="/implementing-the-functional-data-engineering-paradigm-in-data-load-processes-by-using-airflow-61d3bae486b0">。因此，给定一组参数，<em class="me">加载器</em>能够从目标源提取数据并上传到AWS S3。<em class="me">加载器</em>是</a><a class="ae lh" href="https://en.wikipedia.org/wiki/Deterministic_algorithm" rel="noopener ugc nofollow" target="_blank">确定性的</a>和<a class="ae lh" href="https://en.wikipedia.org/wiki/Idempotence" rel="noopener ugc nofollow" target="_blank">幂等的</a>，因此它们每次运行时都会产生相同的结果。</li></ul><p id="f1bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在下一张图中找到我们的框架的逻辑结构的图示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/1dda121602cc4cfe8ca7be1df18cff3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*f7JR_SeDNfX1uJtniKtHhQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">框架逻辑结构</p></figure><h2 id="1a62" class="nr mg it bd mh ns nt dn ml nu nv dp mp lr nw nx mr lv ny nz mt lz oa ob mv iz bi translated">配置文件</h2><p id="e23e" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">接下来，给出一个名为“<em class="me"> databasename </em>”的MySQL数据库的配置文件示例。在配置文件中，指定了一些配置，如DAG名称、默认参数、计划、数据库连接和表及其列数据类型。因此，它们可用于动态生成DAG。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="debc" class="nr mg it bd mh ns nt dn ml nu nv dp mp lr nw nx mr lv ny nz mt lz oa ob mv iz bi translated">DAG接口</h2><p id="6cea" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">在DAG界面中，读取配置文件信息。然后，根据数据库引擎类型，通过调用适当的<em class="me">工厂</em>方法来创建DAG工作流。此外，必要的参数被传递给<em class="me">工厂</em>，以便创建适当的DAG工作流。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">因此，基于上面指定的配置文件，t</p></figure><h2 id="601e" class="nr mg it bd mh ns nt dn ml nu nv dp mp lr nw nx mr lv ny nz mt lz oa ob mv iz bi translated">工厂</h2><p id="99f0" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">一个<em class="me">工厂</em>允许<a class="ae lh" rel="noopener" target="_blank" href="/creating-a-dynamic-dag-using-apache-airflow-a7a6f3c434f3">动态生成一个DAG工作流</a>，允许提取和加载给定目标源的数据。特别是，DAG工作流将具有与配置文件中指定的表一样多的任务。任务基于通过使用<a class="ae lh" href="https://airflow.apache.org/docs/stable/_api/airflow/operators/docker_operator/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="me">气流对接操作符</em> </a> <em class="me">运行适当的<em class="me">加载器</em>对接映像。</em>为此<em class="me">，配置文件中提供的</em>参数应该作为环境变量传递给docker映像。</p><blockquote class="oe of og"><p id="c46b" class="li lj me lk b ll lm kd ln lo lp kg lq oh ls lt lu oi lw lx ly oj ma mb mc md im bi translated">请记住，该框架旨在执行每日增量加载。所以，它就是为此而设计的。为了支持其他用例，应该引入一些更改。</p></blockquote><p id="d81c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在下一段代码中展示了MySQL工厂。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="5727" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，这是由<em class="me"> MySQL工厂生成的DAG工作流的样子。</em>记住<em class="me"> </em>每个任务都是一个运行<a class="ae lh" href="https://github.com/ajhenaor/pyspark-mysql-to-s3-loader" rel="noopener ugc nofollow" target="_blank"> <em class="me"> MySQL loader </em> </a>的airflow docker操作员。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/f5a3664a996db3656b213fc7a69b4d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*6lfYID4my3LXR2ymfw8ysA.png"/></div></figure><h2 id="6181" class="nr mg it bd mh ns nt dn ml nu nv dp mp lr nw nx mr lv ny nz mt lz oa ob mv iz bi translated">装货设备</h2><p id="c68e" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">一个<em class="me">加载器</em>是一个docker镜像，允许从一个特定的数据库引擎提取数据并上传到我们的数据湖——AWS S3。</p><p id="9d84" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下一段代码中，出现了<a class="ae lh" href="https://github.com/ajhenaor/pyspark-mysql-to-s3-loader" rel="noopener ugc nofollow" target="_blank"> <em class="me"> MySQL加载器</em></a><em class="me"/><em class="me">。</em>我们试图遵循<a class="ol om ep" href="https://medium.com/u/9f4d525c99e2?source=post_page-----a4931788a61f--------------------------------" rel="noopener" target="_blank"> Maxime Beauchemin </a>在这篇<a class="ae lh" href="https://medium.com/@maximebeauchemin/functional-data-engineering-a-modern-paradigm-for-batch-data-processing-2327ec32c42a" rel="noopener">文章</a>中提出的功能数据工程方法。相应地，<em class="me">加载器</em>被设计成上下文无关的；它们使用覆盖方法，并且它们的结果是不可变暂存区的一部分。这使得它们易于复制。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="2639" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">结论</h1><p id="3b30" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">我们构建这个框架是基于这样一个信念，即数据加载过程不应该写两次，它们应该是通用的。</p><p id="4360" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的解决方案深受功能数据工程范例的影响，该范例由<a class="ol om ep" href="https://medium.com/u/9f4d525c99e2?source=post_page-----a4931788a61f--------------------------------" rel="noopener" target="_blank"> Maxime Beauchemin </a>在这篇<a class="ae lh" href="https://medium.com/@maximebeauchemin/functional-data-engineering-a-modern-paradigm-for-batch-data-processing-2327ec32c42a" rel="noopener">文章</a>中提出。事实上，你可以在这篇<a class="ae lh" rel="noopener" target="_blank" href="/implementing-the-functional-data-engineering-paradigm-in-data-load-processes-by-using-airflow-61d3bae486b0">帖子</a>中找到更多关于这种范式如何塑造了<em class="me">装载机</em>的设计方式的信息。</p><p id="998e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">希望这些信息对你有用！</p><p id="d9ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢您的阅读！:)</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="c52f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">如果你想随时更新我的作品，</em> <strong class="lk jd"> <em class="me">请加入我的</em> </strong> <a class="ae lh" href="https://metadatacommunity.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> <em class="me">简讯</em> </strong> </a> <strong class="lk jd"> <em class="me">！</em> </strong> <em class="me">我会努力为你提供信息和资源，让你成为更好的数据从业者！</em></p></div></div>    
</body>
</html>