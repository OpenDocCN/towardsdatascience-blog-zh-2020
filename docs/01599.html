<html>
<head>
<title>Getting Familiar with Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熟悉Keras</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-familiar-with-keras-dd17a110652d?source=collection_archive---------20-----------------------#2020-02-13">https://towardsdatascience.com/getting-familiar-with-keras-dd17a110652d?source=collection_archive---------20-----------------------#2020-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e07a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">两个神经网络回归问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/02bacc6b94935325fe8755de13bb63c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sEZr42ujzrJhHWa1Ca-swA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://www.pexels.com/photo/black-female-barista-together-with-colleague-using-laptop-at-work-4350039/" rel="noopener ugc nofollow" target="_blank">像素</a>上的<a class="ae ky" href="https://www.pexels.com/@ketut-subiyanto" rel="noopener ugc nofollow" target="_blank">赖爷子</a>拍摄的照片</p></figure><p id="6dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">神经网络是由大脑连通性松散启发的计算系统。简而言之，神经网络对输入进行一系列转换，其结果在学习过程中被用作特征。Keras是python中的一个开源库，可以轻松地对神经网络进行实验。Keras提供了许多神经网络的构建模块，包括目标函数、优化器、激活函数、各种类型的层和许多附加工具。</p><p id="d24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将使用Keras库构建三个回归神经网络模型。</p><p id="e307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><h1 id="0150" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">预测汽车的价值</h1><p id="bcb4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在第一个例子中，我们将根据客户属性预测汽车销售的潜在价值。这些属性包括年龄、收入和性别等信息。数据可以在<a class="ae ky" href="https://github.com/MGCodesandStats/datasets/blob/master/cars.csv" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="2a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们导入pandas并将数据读入数据框:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9057" class="mx lw it mt b gy my mz l na nb">import pandas as pd <br/>df = pd.read_csv("cars.csv")</span></pre><p id="368a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们打印前五行:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a9b6" class="mx lw it mt b gy my mz l na nb">print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/d05f7cbfbd480ce193d4db4bd03bf397.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*Jo7ThSBDABIzZZKb0gfirQ.png"/></div></figure><p id="209b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将定义输入和输出变量。我们将使用“年龄”、“性别”、“英里数”、“债务”和“收入”来预测“销售额:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9673" class="mx lw it mt b gy my mz l na nb">import numpy as np<br/>X = np.array(df[['age', 'gender', 'miles', 'debt', 'income']])<br/>y = np.array(df['sales'])</span></pre><p id="0c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在需要分割数据用于训练和测试。我们将从“sklearn”中导入“train_test_split”方法:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0c04" class="mx lw it mt b gy my mz l na nb">from sklearn.model_selection import train_test_split</span></pre><p id="eade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将测试集定义为随机样本(20%的数据):</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5cf5" class="mx lw it mt b gy my mz l na nb">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state = 42)</span></pre><p id="c0b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要重塑我们的标签系列:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a157" class="mx lw it mt b gy my mz l na nb">y_train = np.reshape(y_train, (-1,1))</span></pre><p id="63ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以定义我们的模型了。首先，我们需要导入几个包:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7922" class="mx lw it mt b gy my mz l na nb">from tensorflow.python.keras.models import Sequential<br/>from tensorflow.python.keras.layers import Dense</span></pre><p id="9c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们定义一个顺序模型对象:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="39e3" class="mx lw it mt b gy my mz l na nb">model = Sequential()</span></pre><p id="cd57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们建立一个简单的神经网络，它有一个输入层、一个隐藏层和一个输出层。我们还将在输入层和隐藏层使用“ReLu”激活功能。对于输出层，我们将使用线性激活函数。输入层和隐藏层将有32个神经元:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="457a" class="mx lw it mt b gy my mz l na nb">model.add(Dense(32, input_dim=5, kernel_initializer='normal', activation='relu'))<br/>model.add(Dense(32, activation='relu'))<br/>model.add(Dense(1, activation='linear'))</span></pre><p id="3a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们编译模型。我们将使用“adam”优化器和均方误差损失函数:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3ad9" class="mx lw it mt b gy my mz l na nb">model.compile(loss='mse', optimizer='adam', metrics=['mse','mae'])</span></pre><p id="45b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们拟合我们的模型。让我们以100个时期和10:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3efa" class="mx lw it mt b gy my mz l na nb">model.fit(X_train, y_train, epochs=100, batch_size=10)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/c87820c32544444bd65ecde8d10b7068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EYgbefEL8jpa0glWQUBk1Q.png"/></div></div></figure><p id="3ac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，与销售额相比，均方误差和平均绝对误差都非常低，这很好。</p><p id="1f9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们对测试集进行预测:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="b3b1" class="mx lw it mt b gy my mz l na nb">y_pred = model.predict(X_test)</span></pre><p id="df0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以可视化我们的结果。让我们导入matplotlib和seaborn，并显示真实值与预测值的散点图:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="df69" class="mx lw it mt b gy my mz l na nb">import matplotlib.pyplot as plt <br/>plt.scatter(y_test, y_pred)<br/>plt.xlabel('True Values')<br/>plt.ylabel('Predictions')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/d00cbd95da9b9e7513bcae241b19f19e.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*vPHQHVp_s089mtXI03wLJw.png"/></div></figure><p id="b7bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于第一次传球来说，这是一个不错的表现。通过进一步的超参数调整，我们可以做得更好。为了进一步提高性能，我鼓励您尝试一下层数、神经元、时期和批量大小。你也可以尝试一些其他的优化器，而不是“adam”，比如“rmsprop”或“sgd”。您还可以尝试使用规范化、标准化或最小/最大缩放来转换数据。</p><h1 id="2100" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">预测燃油效率</h1><p id="9b0b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，让我们继续讨论另一个问题。在本例中，我们将以每加仑英里数来预测燃油效率。我们将使用马力、重量和气缸数量等信息作为预测模型的输入。数据可以在<a class="ae ky" href="http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="a2c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们导入数据并打印前五行:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ea38" class="mx lw it mt b gy my mz l na nb">df = pd.read_csv("auto-mpg.csv")<br/>print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/864dba83559c1de44389b252a6e4abd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*MOoB3O-q-pnHnTpL2tJB7Q.png"/></div></figure><p id="918a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们将定义我们的输入和输出。我们将使用“气缸”、“排量”、“马力”、“重量”、“加速度”、“车型年”和“来源”来预测每加仑英里数(MPG):</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e9f2" class="mx lw it mt b gy my mz l na nb">X = np.array(df[['Cylinders','Displacement','Horsepower','Weight',<br/>                'Acceleration', 'Model Year', 'Origin']])<br/>y = np.array(df['MPG'])</span></pre><p id="1368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在需要分割数据用于训练和测试。我们将测试集定义为数据的随机样本:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="50e2" class="mx lw it mt b gy my mz l na nb">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state = 42)</span></pre><p id="88dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要重塑我们的标签系列:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="eec6" class="mx lw it mt b gy my mz l na nb">y_train=np.reshape(y_train, (-1,1))</span></pre><p id="4b13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们定义我们的模型。让我们从一个具有64个神经元的输入和隐藏层的神经网络开始。输入维度为7，优化器为“adam”，损失函数为“mse”。我们还将使用1000个历元和10:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="05b1" class="mx lw it mt b gy my mz l na nb">model = Sequential()<br/>model.add(Dense(64, input_dim=7, kernel_initializer='normal', activation='relu'))<br/>model.add(Dense(64, activation='relu'))<br/>model.add(Dense(1, activation='linear'))<br/>model.compile(loss='mse', optimizer='adam', metrics=['mse','mae'], validation_split = 0.2)<br/>model.fit(X_train, y_train, epochs=1000, batch_size=10)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/b39c124fc6b4fd666600a2f5f4ddf87d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*laP0TcTAVTC1XK1xnd5kFg.png"/></div></div></figure><p id="0670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来看看我们的结果:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="513e" class="mx lw it mt b gy my mz l na nb">y_pred = model.predict(X_test)<br/>plt.scatter(y_test, y_pred)<br/>plt.xlabel('True Values')<br/>plt.ylabel('Predictions')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/37ac438c4a329c270c7278e963302952.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*G_819OwdmKHBK6vhTcymHw.png"/></div></figure><p id="ee3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到性能相当不错。我鼓励您尝试提高性能，或者尝试为其他预测问题建立神经网络模型。例如，您可能对使用神经网络来预测野火规模感兴趣，使用<a class="ae ky" href="https://www.kaggle.com/tracy2533/us-wildfire" rel="noopener ugc nofollow" target="_blank">美国野火数据</a>。</p><p id="847d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，在这篇文章中，我们介绍了两个回归问题的建模过程:预测汽车的价值和预测燃油效率。我们讨论了如何初始化顺序模型对象、添加层、添加神经元、指定优化器、指定时期和指定批量大小。我们还使用真实散点图和预测散点图进行了模型验证。我希望这篇文章对你有用。这篇文章的代码可以在<a class="ae ky" href="https://github.com/spierre91/medium_code/blob/master/two_nn_regression_problems.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。感谢阅读，机器学习快乐！</p></div></div>    
</body>
</html>