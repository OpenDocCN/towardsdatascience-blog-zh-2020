<html>
<head>
<title>Loading files into BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将文件加载到BigQuery</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/loading-files-into-bigquery-6de1ff63df35?source=collection_archive---------18-----------------------#2020-06-17">https://towardsdatascience.com/loading-files-into-bigquery-6de1ff63df35?source=collection_archive---------18-----------------------#2020-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b15e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python将拼花和CSV文件导入GCP BigQuery</h2></div><p id="a192" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Google云平台的BigQuery能够将多种文件类型摄取到表格中。在本教程中，我将展示它可以处理什么类型的文件，以及为什么您应该尽可能使用Parquet。</p><blockquote class="le"><p id="6262" class="lf lg it bd lh li lj lk ll lm ln ld dk translated">要获得所有媒体文章的完整访问权限，包括我的文章，请考虑在此订阅<a class="ae lo" href="https://niczky12.medium.com/membership" rel="noopener"/>。</p></blockquote><h1 id="6ea5" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ma ka mb kc mc kd md kf me kg mf mg bi translated">如何加载文件</h1><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mh"><img src="../Images/81d857b2151dda95735eacc76b3696d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQ9TWqRXZUhOHnR_pPRnlA.jpeg"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">肯定比这容易。图片来源:<a class="ae lo" href="https://www.pxfuel.com/en/free-photo-emvlj" rel="noopener ugc nofollow" target="_blank"> pxfuel </a></p></figure><p id="f855" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们需要一个包含这些表的数据集:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="263b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码片段将创建一个名为<code class="fe mz na nb nc b">files</code>的数据集。以下是对所用参数的解释:</p><ul class=""><li id="e06d" class="nd ne it kk b kl km ko kp kr nf kv ng kz nh ld ni nj nk nl bi translated"><code class="fe mz na nb nc b">location</code>设置数据集中表的位置。请注意，不同地点之间可能会收取转让费。最佳实践是尽可能将存储桶和BigQuery表放在同一个区域。这里我用<code class="fe mz na nb nc b">europe-west2</code>(伦敦)表示地区位置。您也可以使用多区域位置，如<code class="fe mz na nb nc b">EU</code>或<code class="fe mz na nb nc b">US</code>。点击查看选项<a class="ae lo" href="https://cloud.google.com/bigquery/docs/locations" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="2c65" class="nd ne it kk b kl nm ko nn kr no kv np kz nq ld ni nj nk nl bi translated"><code class="fe mz na nb nc b">default_table_expiration</code>设置新创建的表格过期的秒数。如果您只想让表存在一段时间，或者您担心会忘记删除它们，这是非常有用的。我把它设置为2小时。</li><li id="5b06" class="nd ne it kk b kl nm ko nn kr no kv np kz nq ld ni nj nk nl bi translated"><code class="fe mz na nb nc b">description</code>是对数据集用途的简短易读的描述。</li></ul><p id="db60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将从<a class="ae lo" href="https://cloud.google.com/shell" rel="noopener ugc nofollow" target="_blank">云外壳</a>运行代码，因为这样最方便——我强烈建议您也从那里尝试一下。</p><p id="a0fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦它运行，我们可以从用户界面确认所有设置都设置正确:</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nr"><img src="../Images/6646786ad4c9dbc2646cccc49028bd49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fn01SO3oewMj6fz-g8eoFg.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">新数据集信息面板的屏幕截图</p></figure><p id="60d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有一个数据集要填充，让我们使用Python ( <code class="fe mz na nb nc b">sklearn</code>)为我们创建一些数据，并将其保存为一个逗号分隔的文件。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1c07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个非常简单的数据集，所以我们实际上可以使用BigQuery的<code class="fe mz na nb nc b">autodetect</code>特性来计算它的模式。下面是如何使用<code class="fe mz na nb nc b">bq</code>从命令行完成这项工作:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="cf84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果由于某种原因无法找到<code class="fe mz na nb nc b">files</code>数据集，您可以将您的项目名称指定为<a class="ae lo" href="https://cloud.google.com/bigquery/docs/loading-data-local#loading_data_from_a_local_data_source" rel="noopener ugc nofollow" target="_blank">表名称</a>的一部分，或者您可以将默认项目设置为您之前使用的项目:</p><p id="0c96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mz na nb nc b">gcloud config set core/project YOUR_PROJECT_NAME</code></p><p id="d824" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看如何通过Python的<code class="fe mz na nb nc b">gcloud</code> SDK实现这一点:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c445" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，在这里，我们将文件直接从本地存储上传到BigQuery，但是建议首先将您的文件复制到GCS (Google Cloud Storage ),然后从那里加载文件。查看<code class="fe mz na nb nc b"><a class="ae lo" href="https://googleapis.dev/python/bigquery/latest/generated/google.cloud.bigquery.client.Client.html#google.cloud.bigquery.client.Client.load_table_from_uri" rel="noopener ugc nofollow" target="_blank">load_table_from_uri</a></code>如何做到这一点。</p><h1 id="3bb8" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ns ka mb kc nt kd md kf nu kg mf mg bi translated">什么样的文件可以加载到BigQuery中？</h1><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nv"><img src="../Images/71aa3fe9cf09c36e3e3926342e2c3c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*udWCnVCdz7sO1x9Y3fluPw.jpeg"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">谈到文件格式，我们确实有选择。图片来源:<a class="ae lo" href="https://www.pxfuel.com/en/free-photo-ocilb" rel="noopener ugc nofollow" target="_blank"> pxfuel </a></p></figure><p id="cead" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谈到文件类型，BigQuery确实支持一些选项:</p><ul class=""><li id="beb4" class="nd ne it kk b kl km ko kp kr nf kv ng kz nh ld ni nj nk nl bi translated">Avro</li><li id="6298" class="nd ne it kk b kl nm ko nn kr no kv np kz nq ld ni nj nk nl bi translated">镶木地板</li><li id="0eea" class="nd ne it kk b kl nm ko nn kr no kv np kz nq ld ni nj nk nl bi translated">光学字符识别</li><li id="f1f5" class="nd ne it kk b kl nm ko nn kr no kv np kz nq ld ni nj nk nl bi translated">战斗支援车</li><li id="c100" class="nd ne it kk b kl nm ko nn kr no kv np kz nq ld ni nj nk nl bi translated">JSON(换行分隔)</li></ul><p id="951f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但他们并非生而平等…</p><p id="47cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，在上面的文件中，所有内容都是数字，这使得BigQuery很容易检测列类型。但是当你开始加载字符串、日期、时间、浮点数、整数和混合字段时，生活就变得复杂了，BigQuery的模式<code class="fe mz na nb nc b">autodetect</code>特性也就消失了。然后，您需要自己指定模式，这很快就会变得繁琐而混乱，因为Numpy数据类型与BigQuery之间没有一对一的映射。在这种情况下，Avro和Parquet格式更有用。它们存储关于列的元数据，BigQuery可以使用这些信息来确定列的类型！</p><p id="d4d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Avro是BigQuery的推荐文件类型，因为它的压缩格式允许快速并行上传，但Python中对Avro的支持有些有限，所以我更喜欢使用Parquet。</p><h2 id="27cb" class="nw lq it bd lr nx ny dn lv nz oa dp lz kr ob oc mb kv od oe md kz of og mf oh bi translated">让我们制作一个更大的数据集</h2><p id="a5e6" class="pw-post-body-paragraph ki kj it kk b kl oi ju kn ko oj jx kq kr ok kt ku kv ol kx ky kz om lb lc ld im bi translated">为了演示<code class="fe mz na nb nc b">autodetect</code>会失败的地方，让我们再添加几行和一个时髦的列，除了最后的2个浮点数，它到处都有缺失值。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mx my l"/></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">这里的upload_csv是一个封装了我们之前所做的步骤的函数。检查<a class="ae lo" href="https://github.com/niczky12/medium/tree/master/tech/bigquery/file_loads" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p></figure><p id="313b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种工作方式没有错误。但是它做了我们想要它做的吗？让我们检查一下数据类型:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d1f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这为我们提供了以下信息:</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi on"><img src="../Images/3dbd70b73ff45c3852c957b01e914a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5awWx1BdCZSaoERxvQWeyA.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">看看最后一排！😱</p></figure><p id="dcdf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们心爱的花车变成了琴弦！</p><h1 id="a571" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ns ka mb kc nt kd md kf nu kg mf mg bi translated">拼花地板拯救世界</h1><p id="cda4" class="pw-post-body-paragraph ki kj it kk b kl oi ju kn ko oj jx kq kr ok kt ku kv ol kx ky kz om lb lc ld im bi translated">CSV格式比较乱。对于应该如何引用字符串，应该使用什么分隔符，是否有标题，没有明确的指导，我们甚至没有触及跨多个文件的数据集。</p><p id="97a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，拼花文件携带关于列的元数据。他们知道每一列应该是什么类型，所以当您将它加载到BigQuery时，不再需要猜测。更好的是，parquet文件通常是按列压缩的，所以你的分类列存储起来会便宜很多！试试吧！</p><p id="18fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看如何将相同的<code class="fe mz na nb nc b">dataframe</code>作为一个parquet文件上传到BigQuery:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a1d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这更简单——注意，我们不再需要跳过标题或猜测模式——最棒的是它带有压缩功能。我们的文件大小从1.8MB变成了59KB(我们必须注意，这主要是因为许多重复的值，但仍然非常令人印象深刻)！</p><p id="7701" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的列类型现在是正确的:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/26d5124c5bbf307845ddf417df6d36c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*duRdnrgaL6RQvjg6ymOCZg.png"/></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">彩车回来了！🎉</p></figure><h1 id="c598" class="lp lq it bd lr ls lt lu lv lw lx ly lz jz ns ka mb kc nt kd md kf nu kg mf mg bi translated">摘要</h1><p id="4225" class="pw-post-body-paragraph ki kj it kk b kl oi ju kn ko oj jx kq kr ok kt ku kv ol kx ky kz om lb lc ld im bi translated">我们展示了BigQuery如何接收CSV和Parquet文件，以及CSV如何导致复杂性。<strong class="kk iu">如果你觉得上面的例子在现实生活中不会发生，那就再想想吧！</strong>当您有数千个列分布在数千个大型文件中时，BigQuery检测到错误列类型的可能性非常高——同样，当您需要为它编写模式时，数千个列也没有用…</p><p id="c555" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以下一次当您希望将一个大文件加载到BigQuery中时，可以请求Parquet！</p></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><p id="5694" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要获得BigQuery的更多乐趣，请查看这篇文章，在这篇文章中，我展示了如何使用UDF找到斐波那契数列。</p><p id="9ad0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面用到的所有代码都可以在<a class="ae lo" href="https://github.com/niczky12/medium/tree/master/tech/bigquery/file_loads" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div></div>    
</body>
</html>