<html>
<head>
<title>2-Min Python: Never use Mutables as Default Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2分钟Python:永远不要使用可变值作为默认值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/2-min-python-mutables-as-default-values-6dccaf019546?source=collection_archive---------63-----------------------#2020-06-23">https://towardsdatascience.com/2-min-python-mutables-as-default-values-6dccaf019546?source=collection_archive---------63-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/732d2778f7b73631d44b789fc85f91d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e_a171rQWQ1NNtxb"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">丹尼尔·陶西斯在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="494d" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">会发生什么，为什么会发生，怎么做才能避免。</h2></div><h1 id="3076" class="ky kz jj bd la lb lc ld le lf lg lh li kp lj kq lk ks ll kt lm kv ln kw lo lp bi translated">可变违约的后果</h1><p id="823d" class="pw-post-body-paragraph lq lr jj ls b lt lu kk lv lw lx kn ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们编写了一个函数，它将学生的姓名和分数作为参数，并根据提供的分数将“通过”或“未通过”添加到字典中。为了方便起见，由用户决定她是否要提供字典。如果她不做，我们想重新开始。我们的第一次尝试是这样的:</p><figure class="mm mn mo mp gt iv"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c09a" class="pw-post-body-paragraph lq lr jj ls b lt ms kk lv lw mt kn ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">这看起来不错，但是让我们在不提供字典的情况下连续使用这个函数两次，看看会发生什么:</p><figure class="mm mn mo mp gt iv"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7a2a" class="pw-post-body-paragraph lq lr jj ls b lt ms kk lv lw mt kn ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">从输出中可以看到，每个函数调用都将<strong class="ls jk">指向同一个对象</strong>。这不是我们想要发生的！</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="5eaf" class="ky kz jj bd la lb ne ld le lf nf lh li kp ng kq lk ks nh kt lm kv ni kw lo lp bi translated">重复使用对象的原因</h1><p id="8257" class="pw-post-body-paragraph lq lr jj ls b lt lu kk lv lw lx kn ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们来搞清楚这种行为。如果我们试图访问函数外部的变量，Python会返回一个<em class="nj"> NameError </em>。这表明变量作用域按预期工作。然而，该值必须在某处可用；否则，Python无法在第二次函数调用期间添加键。</p><p id="559d" class="pw-post-body-paragraph lq lr jj ls b lt ms kk lv lw mt kn ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">让我们再深入一层。下面是同一函数的调整版本，它也返回字典的<strong class="ls jk">内存地址</strong>:</p><figure class="mm mn mo mp gt iv"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="f301" class="pw-post-body-paragraph lq lr jj ls b lt ms kk lv lw mt kn ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">如果我们查看结果，我们可以看到两个调用都引用了内存中的同一个对象。我们也能够直接从内存中提取值。总之，我们不能通过变量访问这个值，但是它在内存中是安全可靠的。那么，<strong class="ls jk">让它活下去的隐藏引用</strong>在哪里呢？</p><p id="80db" class="pw-post-body-paragraph lq lr jj ls b lt ms kk lv lw mt kn ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">答案在于Python加载函数的方式。也就是说，每当Python第一次加载一个函数时，它也会创建对其默认值的<strong class="ls jk">引用。也就是说，对函数的引用隐藏了对字典的引用。</strong></p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="65c5" class="ky kz jj bd la lb ne ld le lf nf lh li kp ng kq lk ks nh kt lm kv ni kw lo lp bi translated">如何防止这种行为</h1><p id="eb6b" class="pw-post-body-paragraph lq lr jj ls b lt lu kk lv lw lx kn ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了防止这种不必要的行为，我们需要将引用的创建转移到函数本身中。这确保了每个函数调用都使用新的引用而不是旧的引用。修改后的函数如下所示:</p><figure class="mm mn mo mp gt iv"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8d65" class="pw-post-body-paragraph lq lr jj ls b lt ms kk lv lw mt kn ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">如您所见，现在每个函数调用都指向另一个内存地址。这些对象不再相互干扰。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="f2bc" class="pw-post-body-paragraph lq lr jj ls b lt ms kk lv lw mt kn ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">这是一个针对较小主题的新“快速修复”格式的实验。让我知道你对它的看法，在评论中或者在推特上。我也很乐意在LinkedIn上联系。感谢您的阅读！</p></div></div>    
</body>
</html>