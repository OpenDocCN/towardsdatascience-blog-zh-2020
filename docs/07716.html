<html>
<head>
<title>Is NumPy really faster than Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NumPy真的比Python快吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/is-numpy-really-faster-than-python-aaa9f8afb5d7?source=collection_archive---------24-----------------------#2020-06-09">https://towardsdatascience.com/is-numpy-really-faster-than-python-aaa9f8afb5d7?source=collection_archive---------24-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/7797131feceeae2ad1d41c8717a04c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EjjL0rY-W_93xfSImXJe2w.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:sl linux命令的截图</p></figure><div class=""/><div class=""><h2 id="ad78" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">是的，但前提是你知道如何使用它。</h2></div><p id="14a0" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Python开发人员都知道NumPy比普通Python快。然而，如果你用错了，它可能会影响你的表现，这也是事实。要知道什么时候使用NumPy是有益的，我们必须了解它是如何工作的。</p><p id="95b1" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在这篇文章中，我们将详细了解一下<em class="lt">为什么</em> NumPy可以更快，以及什么时候使用它是次优的。</p><h1 id="a696" class="lu lv ji bd lw lx ly lz ma mb mc md me ko mf kp mg kr mh ks mi ku mj kv mk ml bi translated">Python中的随机数</h1><p id="e529" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">我们的玩具问题是随机数的产生。假设我们只需要一个随机数。我们应该使用NumPy吗？来测试一下吧！我们将它与内置的随机数生成器进行比较，运行两者一千万次，测量执行时间。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5b00" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">对我来说，结果如下。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mx"><img src="../Images/6f62cf6f4e1cd3f760089ed985d359cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVgLLR57sWE_HQGB6tE6Dw.png"/></div></div></figure><p id="7c62" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">所以，对于单个随机数，NumPy要慢得多。为什么会这样呢？如果我们需要一个数组而不是一个数字呢？会不会也慢一点？</p><p id="3578" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这一次，让我们生成一个包含一千个元素的列表/数组。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b2ce" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">(我不想在lambdas中包装要计时的表达式，因为在Python中函数调用有开销。我希望尽可能精确，所以我将它们作为字符串传递给<code class="fe my mz na nb b">timeit</code>函数。)</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mx"><img src="../Images/994896008c440c3f7de92eaa7ba92a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*006A3kolqyk37uwQzEuUsQ.png"/></div></div></figure><p id="ea4b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在情况大不一样了。当我们生成一个数组或随机数时，NumPy轻松获胜。</p><p id="b649" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这个结果也有一些奇怪的地方。首先，我们生成一个随机数10 000 000次。第二，我们将1000个随机数组成的数组生成10 000次。在这两种情况下，我们最终都有10 00万个随机数。使用内置方法，当我们将它们放入一个列表中时，需要大约2倍的时间。然而，使用NumPy，当使用数组时，我们看到了比它本身快30倍的速度。</p><p id="b69d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了了解幕后发生了什么，我们将对代码进行分析。</p><h1 id="b77d" class="lu lv ji bd lw lx ly lz ma mb mc md me ko mf kp mg kr mh ks mi ku mj kv mk ml bi translated">剖析代码:使用cProfiler进行分析</h1><p id="ef85" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">为了查看脚本在每个函数中花费了多少时间，我们将使用<a class="ae nc" href="https://docs.python.org/3/library/profile.html" rel="noopener ugc nofollow" target="_blank"> cProfiler </a>。</p><h2 id="db5d" class="nd lv ji bd lw ne nf dn ma ng nh dp me lg ni nj mg lk nk nl mi lo nm nn mk no bi translated">1.用于生成单个数字的内置随机数</h2><p id="4f7c" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">我们先来看看内置函数。在下面的脚本中，我们像以前一样创建10，0 00，0 00个随机数。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="88cf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们从命令行使用cProfiler:</p><pre class="mr ms mt mu gt np nb nq nr aw ns bi"><span id="aa2d" class="nd lv ji nb b gy nt nu l nv nw">python -m cProfile -s tottime builtin_random_single.py</span></pre><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b4fb" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">出于我们的目的，这里有两个重要的列。<code class="fe my mz na nb b">ncalls</code>显示一个函数被调用的次数，而<code class="fe my mz na nb b">tottime</code>是花费在一个函数上的总时间，不包括花费在子函数上的时间。</p><p id="740a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">所以内置函数<code class="fe my mz na nb b">random.random()</code>如预期被调用了10 000 000次，在那个函数上花费的总时间是<code class="fe my mz na nb b">0.380</code>秒。</p><p id="35eb" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">NumPy版本呢？</p><h2 id="1063" class="nd lv ji bd lw ne nf dn ma ng nh dp me lg ni nj mg lk nk nl mi lo nm nn mk no bi translated">2.NumPy random用于生成单个数字</h2><p id="8e68" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">这里，这是我们分析的脚本。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2141" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">结果令人惊讶:</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d9bd" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">与之前类似，<code class="fe my mz na nb b">numpy.random.random()</code>函数确实如我们所料被调用了10 000 000次。然而，脚本在这个函数上花费的时间比以前在内置的随机函数上花费的时间要多得多。因此，每次函数调用的成本更高。</p><p id="a847" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">然而，当我们开始使用数组和列表时，事情发生了巨大的变化。</p><h2 id="3190" class="nd lv ji bd lw ne nf dn ma ng nh dp me lg ni nj mg lk nk nl mi lo nm nn mk no bi translated">3.内置的随机数生成一个随机数列表</h2><p id="0dd7" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">像以前一样，让我们生成1000个随机数的列表10 000次。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a3e0" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">侧写的结果并不令人惊讶。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="baba" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">正如我们所看到的，大约60%的时间花在了列表理解上:10 000个电话，总共0.628秒。(回想一下，<code class="fe my mz na nb b">tottime</code>不计算子功能调用，比如这里对<code class="fe my mz na nb b">random.random()</code>的调用。)</p><p id="bbd2" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在我们可以看到为什么NumPy在正确使用的情况下会更快。</p><h2 id="fbab" class="nd lv ji bd lw ne nf dn ma ng nh dp me lg ni nj mg lk nk nl mi lo nm nn mk no bi translated">4.NumPy random用于生成随机数数组</h2><p id="14e2" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">这个剧本和以前一样非常简单。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2703" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这是侧写的结果。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="eee0" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">10 000次呼叫，即使每次呼叫花费的时间更长，您也可以获得10 00个随机数的<code class="fe my mz na nb b">numpy.ndarray</code>。正确使用NumPy的原因是它的数组非常高效。它们就像C数组而不是Python列表。它们之间有两个显著的区别。</p><ul class=""><li id="3a88" class="nx ny ji kz b la lb ld le lg nz lk oa lo ob ls oc od oe of bi translated">Python列表是动态的，因此可以添加和删除元素。NumPy数组的长度是固定的，所以如果不创建一个新的数组，就不能添加或删除。(创建一个数组成本很高。)</li><li id="0bf5" class="nx ny ji kz b la og ld oh lg oi lk oj lo ok ls oc od oe of bi translated">Python列表可以同时保存几种数据类型，而NumPy数组只能包含一种。</li></ul><p id="6da5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">因此，它们不太灵活，但性能明显更高。当不需要这种额外的灵活性时，NumPy优于Python。</p><h1 id="9f85" class="lu lv ji bd lw lx ly lz ma mb mc md me ko mf kp mg kr mh ks mi ku mj kv mk ml bi translated">盈亏平衡点在哪里？</h1><p id="6b37" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">为了确切地了解NumPy在随机数生成方面在多大程度上超过Python，我们可以通过测量不同大小的执行时间来比较这两者。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/82bf22b975263e9cd648f5728b0eeb70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mCeEBNHjvLjL8JQAxAQfDQ.png"/></div></div></figure><p id="76e9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们可以看到20左右，NumPy开始超过Python。当然，对于其他运算，如计算正弦或数字相加，这个数字可能不同，但趋势是相同的。对于较小的输入大小，Python的表现略胜于NumPy，但是随着输入大小的增加，NumPy会大幅度胜出。</p><h1 id="eec1" class="lu lv ji bd lw lx ly lz ma mb mc md me ko mf kp mg kr mh ks mi ku mj kv mk ml bi translated">摘要</h1><p id="6c32" class="pw-post-body-paragraph kx ky ji kz b la mm kj lc ld mn km lf lg mo li lj lk mp lm ln lo mq lq lr ls im bi translated">正确使用NumPy可以显著提高性能。然而，在某些情况下，Python可能是更好的选择。如果你不知道<em class="lt">什么时候</em>使用NumPy，你可能会损害你的表现。</p><p id="afa8" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">一般来说，你最好使用普通的Python，例如</p><ul class=""><li id="6ab1" class="nx ny ji kz b la lb ld le lg nz lk oa lo ob ls oc od oe of bi translated">你处理小列表，</li><li id="fdd5" class="nx ny ji kz b la og ld oh lg oi lk oj lo ok ls oc od oe of bi translated">您想要频繁地添加/删除列表。</li></ul><p id="0f25" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当优化性能时，总是要考虑事物内部是如何工作的。这样，即使是在Python中，您也可以真正增强代码。</p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="804c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><a class="ae nc" href="https://www.tivadardanka.com/blog" rel="noopener ugc nofollow" target="_blank"> <strong class="kz jj"> <em class="lt">如果你喜欢把机器学习概念拆开，理解是什么让它们运转，我们有很多共同点。看看我的博客，我经常在那里发表这样的技术文章！</em> </strong> </a></p></div></div>    
</body>
</html>