<html>
<head>
<title>Detecting real-time and unsupervised anomalies in streaming data: a starting point</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">检测流数据中的实时和无监督异常:一个起点</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/detecting-real-time-and-unsupervised-anomalies-in-streaming-data-a-starting-point-760a4bacbdf8?source=collection_archive---------12-----------------------#2020-01-10">https://towardsdatascience.com/detecting-real-time-and-unsupervised-anomalies-in-streaming-data-a-starting-point-760a4bacbdf8?source=collection_archive---------12-----------------------#2020-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2c46469c319db91b3f92749a594e7318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rMci1vqXHRqqrZ1mkvCMtQ.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图 1:智能设备生成实时数据，这些数据可能会出现异常，如果我们不检测并正确管理它们，就会导致我们做出错误的数据驱动型决策。图片来自 pixabay.com。</p></figure><p id="1702" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传感器通过收集各种系统中的数据来实现物联网(<a class="ae kc" href="https://en.wikipedia.org/wiki/Internet_of_things" rel="noopener ugc nofollow" target="_blank"> <em class="lb">物联网</em> </a>)。数据通常以实时方式产生，然后我们可能会发现自己被迫进行实时处理(<em class="lb">流数据挖掘</em> [1】)。系统的行为并不总是恒定不变的，而是可能表现出一种不寻常的、明显不同于先前正常行为的行为(<strong class="kf ir"> <em class="lb">异常</em></strong>【2】)。异常检测是有价值的，但在实践中，它可能会变成一项难以可靠执行的任务。</p><p id="f332" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文并不声称是方法和解决方案的详尽列表，但是对于那些第一次处理这个问题并且需要简单、可理解和可伸缩的解决方案的从业者来说，它确实是一个简单的切入点。异常可能存在于真实世界的应用中，例如欺诈预防、金融、能源需求或消耗、电子商务、网络安全、医疗诊断、社交媒体、预测性维护或故障检测等。本文分析了一些处理异常的算法。它们是<em class="lb"> Welford 的</em>算法，基于<em class="lb">四分位数</em>的解决方案，基于<em class="lb"> z-score </em>度量的解决方案，以及基于机器学习的解决方案，称为<em class="lb">半空间树(HST)。</em>前 3 个解决方案基于统计指标/度量，而最后一个来自机器学习领域。</p><h2 id="f49b" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">流媒体:游戏规则</h2><p id="6747" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">与<em class="lb">批处理学习</em>相反，批处理学习【】中假设数据是静止的(历史数据是可用的)，并且模型不连续地将新信息集成到已经构建的模型中，<strong class="kf ir"> <em class="lb">流学习</em> </strong>对实时处理施加约束:</p><ul class=""><li id="f1c2" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">流中的实例(数据)在线到达(通常一次一个实例),并且最多可以被读取一次，这构成了处理数据流的最强约束，并且系统必须决定当前实例是应该被丢弃还是存档。</li><li id="5720" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">只有选定的过去实例可以通过将它们存储在内存中来访问，相对于数据流的大小，内存通常较小。当设计流学习算法时，我们必须考虑几个算法和统计因素。例如，我们必须面对这样一个事实，即由于我们不能存储所有的输入，我们不能撤销根据过去的数据做出的决策。</li><li id="a578" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">每个实例的处理时间必须小且恒定。</li><li id="6b28" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">处理算法必须产生一个模型，该模型等同于由<em class="lb">批次</em>处理算法产生的模型。</li></ul><p id="3376" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这组约束是大多数现有的用于<em class="lb"> bacth </em>处理的异常检测算法不适用于<em class="lb">流</em>应用的原因。</p><p id="cd8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在大多数实际情况下，数据由一个连续的单变量数据集组成，其中关于异常的监督信息(有多少，在哪里)是不可用的。</p><h2 id="000c" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">威尔福德算法</h2><p id="96de" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">Welford 的方法是一种可用的单程方法，用于计算运行方差或运行标准差。它可以通过查看 N 个和 N-1 个实例的平方差之和的差来导出。不需要为第二次传递存储数据[3]。为了将 Welford 的方法用于异常检测问题，我建议加入以下简单的修改。</p><blockquote class="mo mp mq"><p id="8306" class="kd ke lb kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated"><em class="iq">我们创建一个上限(UL)和一个下限(LL)。当</em>在线平均消耗<em class="iq">(橙色实线)</em> <em class="iq">克服这些限制中的任何一个(或</em> X <em class="iq">乘以</em>在线标准偏差<em class="iq">，那么我们将该读数(实例)归类为异常。限值(黑色虚线)可计算如下:</em></p><p id="6ae4" class="kd ke lb kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated">UP =在线平均消费+X *在线标准差</p><p id="4d32" class="kd ke lb kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated">LL =在线平均消耗量-X *在线标准偏差</p></blockquote><p id="f0e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> X </em>越高，我们假设的假阴性(FNs)就越多，而<em class="lb"> X </em>越低，我们获得的假阳性(FPs)就越多。因此，<em class="lb"> X </em>的选择不是微不足道的，并且在该参数<em class="lb"> X </em>与 FPs 和 FNs 之间存在权衡。然后，你需要定义<em class="lb"> X=1，2，3，4，… </em>等等。取决于这个决定。如您所见，每次新实例到达时，<em class="lb">在线平均消耗</em>和限制都会在线更新。</p><p id="803f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">代码</strong>:原方法的简单实现可以在<a class="ae kc" href="https://gist.github.com/alexalemi/2151722" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="834b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注释</strong>:读数=0 应视为异常与否。您还注意到，根据读数和<em class="lb"> X. </em>的不同，LL 可能低于 0，如果这对于您的图表是个问题，可以很容易地调整这一事实。请注意，如果您获得许多连续的异常，您可能需要将它们视为唯一的异常，或者甚至视为“异常”周期。最后，我想提一下使用大小为<em class="lb"> w、</em>的滑动窗口的可能性，并计算它上面的所有指标。</p><h2 id="991f" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">基于四分位数的解决方案</h2><p id="168f" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">箱线图是一种基于一组数字汇总来表示数据集分布的流行方法:最小值、第一个四分位数(Q1 <strong class="kf ir"> / </strong>第 25 个百分位数)、中值、第三个四分位数(Q3/75 个百分位数)和最大值。这种表示可以告诉您异常值及其值。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/bca990846359e0b8ab8e3f90ec5260d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*MutyN_nQFwzpYISRm1US5Q.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图 5:箱线图的元素。图片修改自<a class="ae kc" href="https://es.wikipedia.org/wiki/Archivo:Boxplot.svg" rel="noopener ugc nofollow" target="_blank">维基共享</a>。</p></figure><p id="91bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">四分位距(IQR) </strong>从 Q1 到 Q3，我们可以计算最大值和最小值如下:</p><blockquote class="mo mp mq"><p id="cd24" class="kd ke lb kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated">最大值=Q3+1.5*IQR</p><p id="de64" class="kd ke lb kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated">最小值=Q3-1.5*IQR</p></blockquote><p id="6bc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(关于 boxplots 和 quartiles 的更多详细信息，我建议您查看以下文章:<a class="ae kc" rel="noopener" target="_blank" href="/understanding-boxplots-5e2df7bcbd51">https://towardsdatascience . com/understanding-box plots-5e 2 df 7 bcbd 51</a>)</p><p id="c912" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以将所有高于最大值或低于最小值的点视为异常值。我们可以在线计算这些数字汇总。</p><p id="7a18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">代码:</strong>如你所见，这个解决方案很容易实现。对于懒惰的人来说，在已知的存储库或其他网站上有许多这种方法的可用实现。</p><p id="8d0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意</strong>:这里我们也可以使用前面提到的滑动窗口。</p><h2 id="5252" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">基于 z 分数度量的解决方案</h2><p id="2d5a" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">标准分数或 z 分数(<em class="lb"> z </em>)给出了一个数据实例离均值有多远的概念，即原始分数高于或低于总体均值多少个标准差。</p><blockquote class="mo mp mq"><p id="6ebe" class="kd ke lb kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated"><em class="iq">实例</em> x <em class="iq">的 z 值可以计算为:</em>z =(x-μ)/σ</p></blockquote><p id="ad1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">标准分数也可以通过在线方式计算。但这一次，我们使用了滑动窗口，然后被称为运行或移动 z 分数。给定此窗口大小<em class="lb"> w </em>，移动 z 值将是每个实例偏离平均值的标准偏差数，其中平均值和标准偏差仅在之前的<em class="lb"> w </em>实例中计算。</p><p id="41f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">代码:</strong>如你所见，<strong class="kf ir"> </strong>这个解决方案很容易实现。对于懒人来说，这个方法在众所周知的源代码库中有很多可用的实现。</p><h2 id="64cf" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><em class="mz">半空间树</em></h2><p id="4f38" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">半空间树(HST) [4]是一个快速的单类异常检测器，用于进化数据流。它只需要正常的数据进行训练，并且在异常情况及时扩散时工作良好。如果在时间窗口内将异常打包在一起，效果并不好。这种技术是随机 HST 的集合，其中每个树结构都是在没有任何数据的情况下构建的，这使得该技术非常高效，因为它在适应进化的数据流时不需要模型重构。</p><p id="cf7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种技术是增量训练的，并且使用滑动窗口<em class="lb"> w. </em>其他相关参数是集合中的树的数量(<em class="lb"> nt </em>)，以及用于声明异常的阈值(<em class="lb"> th </em>)。任何高于此阈值的实例预测概率都将被声明为异常:分数越低，当前实例越有可能是异常的。要了解更多关于所有参数的信息，请查看下面的代码部分，或这篇<a class="ae kc" href="https://www.ijcai.org/Proceedings/11/Papers/254.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>。</p><p id="f4d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">代码:</strong>这个解决方案可以在<a class="ae kc" href="https://creme-ml.github.io/generated/creme.anomaly.HalfSpaceTrees.html#creme.anomaly.HalfSpaceTrees" rel="noopener ugc nofollow" target="_blank"> Creme </a>或者<a class="ae kc" href="https://scikit-multiflow.github.io/scikit-multiflow/_autosummary/skmultiflow.anomaly_detection.HalfSpaceTrees.html" rel="noopener ugc nofollow" target="_blank"> scikit-multiflow </a>中找到，这两个框架都是用 Python 实现的。</p><h2 id="ff03" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">其他方法</h2><p id="606d" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">它也值得特别注意一些其他已知的方法，其中包括:</p><ul class=""><li id="7e42" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">局部异常因素(LOF，见<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.LocalOutlierFactor.html" rel="noopener ugc nofollow" target="_blank">此处</a>更多细节)，</li><li id="621c" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">单变量参数方法，如<em class="lb"> Grubb </em>检验(平均值可能是离群值的 mak)或<em class="lb"> Tietjen y Moore </em>检验(可能会遭受淹没)，</li><li id="ea86" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">不要忘记检查[5]，在那里已经进行了许多检测器之间的广泛比较。</li></ul><h2 id="c304" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">结论</h2><ul class=""><li id="caee" class="ma mb iq kf b kg lv kk lw ko na ks nb kw nc la mf mg mh mi bi translated">正如您已经意识到的，所有这些技术都需要调整一个或多个参数，这些参数会影响它们在 FPs 和 FNs 方面的性能(参见<a class="ae kc" href="https://en.wikipedia.org/wiki/F1_score" rel="noopener ugc nofollow" target="_blank"> F1-score </a>性能指标)。</li><li id="ff5d" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">由于这是一个无人监管的场景，因此为了评估该技术的性能，以及正确地找到 FPs 和 FNs 之间的平衡，具有该领域的广泛知识是非常重要的。在任何情况下，他们的评价都是主观的，这就是领域知识至关重要的原因。</li><li id="b996" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">每种技术根据不同的标准发现异常，因此它们不一定与其分类相匹配(异常是/否)。但是我们可以找到相似之处，例如在基于度量的解决方案和 T2 的解决方案之间。</li><li id="96d7" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">最后，您应该考虑将这些技术组合在一起的可能性，因为它们可以互补并检测不同类型的异常。</li></ul><h2 id="da37" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">参考</h2><p id="bae4" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">[1] <em class="lb">比费特，a .，霍尔姆斯，g .，柯克比，r .，&amp;普法林格，B. (2010)。Moa:海量在线分析。机器学习研究杂志，11(5 月)，1601–1604。</em></p><p id="4331" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[2]<em class="lb">钱德拉，v .，米塔尔，v .，T15 库马尔，V. (2008 年 12 月)。序列数据异常检测技术的比较评估。2008 年第八届 IEEE 数据挖掘国际会议(第 743-748 页)。IEEE。</em></p><p id="1141" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[3] <em class="lb"> Knuth，D. E. (2014)。计算机编程艺术，第 2 卷:半数值算法。艾迪森-韦斯利专业版。</em></p><p id="34e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[4] <em class="lb"> S.C.Tan，K.M.Ting，和 T.F.Liu，“流数据的快速异常检测”，载于《国际人工智能联合会议论文集》, 2011 年，第 22 卷，第 1 期，第 1511-1516 页。</em></p><p id="6d30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[5] <em class="lb">艾哈迈德，s .，拉文，a .，波弟，&amp;阿迦，Z. (2017)。流数据的无监督实时异常检测。神经计算，262，134–147。</em></p></div></div>    
</body>
</html>