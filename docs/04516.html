<html>
<head>
<title>Deploy Tensorflow Object Detection API on Kubernetes with Python, Flask and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python、Flask和Docker在Kubernetes上部署Tensorflow对象检测API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploy-tensorflow-object-detection-api-on-kubernetes-with-python-flask-and-docker-7a9513dd19e4?source=collection_archive---------21-----------------------#2020-04-22">https://towardsdatascience.com/deploy-tensorflow-object-detection-api-on-kubernetes-with-python-flask-and-docker-7a9513dd19e4?source=collection_archive---------21-----------------------#2020-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a431" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本文中，我们将使用Flask提供Tensorflow对象检测API，对应用程序进行Dockerize，并使用Google Kubernetes引擎将其部署在Kubernetes上。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29f92092f9e9e574d20c3aac6fb3d5f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdL7mioxFRsDd4x6pABycg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1863906" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/Skitterphoto-324082/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1863906" rel="noopener ugc nofollow" target="_blank">鲁迪和</a>彼得·斯皮特林拍摄</p></figure><h1 id="7d4e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="d736" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">TensorFlow对象检测API是一个基于TensorFlow构建的开源框架，可以轻松构建、训练和部署对象检测模型。本文演示了如何使用Flask提供Tensorflow对象检测API，如何使用Google Kubernetes引擎将应用程序Dockerize并部署到Kubernetes上。</p><p id="9374" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">部署后，您可以将API合并到您的自定义应用程序中，无论是移动应用程序还是web应用程序，都可以满足您的需求。</p><h1 id="0df5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">快速大纲</h1><p id="72ee" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这些是我们将要采取的步骤:</p><ul class=""><li id="2935" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">设置Tensorflow对象检测API</li><li id="31e9" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">使用烧瓶供应API</li><li id="39a8" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">使用Docker将应用程序容器化</li><li id="7ce9" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">在Kubernetes上部署容器化应用程序</li></ul><p id="70f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">注意</strong>:我们不会深入讨论Tensorflow对象检测API，因为这不是本文的重点。有兴趣可以去官方<a class="ae ky" href="https://github.com/tensorflow/models/tree/master/research/object_detection" rel="noopener ugc nofollow" target="_blank">回购</a>看看。如果你熟悉它，那会很有帮助。我们也不会经历设置环境的整个过程，因为我们可以使用Docker来简化它。不过，有兴趣可以参考这篇惊艳的<a class="ae ky" href="https://gilberttanner.com/blog/installing-the-tensorflow-object-detection-api" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><h1 id="f21a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">入门指南</h1><p id="a71b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">将我的<a class="ae ky" href="https://github.com/wingedrasengan927/Tensorflow-2-Object-Detection-API-Flask-Application" rel="noopener ugc nofollow" target="_blank">存储库</a>克隆到工作区中。我们将在整篇文章中使用这些代码。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="df6d" class="nl la it nh b gy nm nn l no np">git clone <a class="ae ky" href="https://github.com/wingedrasengan927/Tensorflow-2-Object-Detection-API-Flask-Application.git" rel="noopener ugc nofollow" target="_blank">https://github.com/wingedrasengan927/Tensorflow-2-Object-Detection-API-Flask-Application.git</a></span></pre><h1 id="35ce" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">建立码头工人形象</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9fd6889977b61b764a713f0052bc5524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*e8u6teTHyalPejIBauj4Jw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">码头工人</p></figure><p id="c085" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你还没有安装<a class="ae ky" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> Docker </a>在你的系统中。Docker容器基本上打包了代码及其所有依赖项，因此应用程序可以在任何环境中快速可靠地运行。它包括运行应用程序所需的一切，并将依赖项与主环境隔离开来。</p><p id="e841" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在您克隆的repo中，您会发现一个Dockerfile文件。Dockerfiles描述了构建映像的不同过程，还可以包含一些元数据，描述如何基于该映像运行容器。我们的docker文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="286d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要从Dockerfile文件构建映像，请在repo内部运行以下命令:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="25ea" class="nl la it nh b gy nm nn l no np">docker build -t tf-od-api:latest .</span></pre><p id="80fc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">-t表示您赋予Docker图像的标签。这个建筑需要很多时间。如果你看到这样的东西:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a45e" class="nl la it nh b gy nm nn l no np">Successfully built 64edf7b4c21f<br/>Successfully tagged tf-od-api:latest</span></pre><p id="4699" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这意味着映像已成功构建。现在让我们从图像中运行一个容器。运行以下命令:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ef79" class="nl la it nh b gy nm nn l no np">docker run -d -p 5000:5000 tf-od-api:latest</span></pre><p id="10ff" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这确保了我们与运行中的容器分离，并且容器暴露在端口5000上。</p><p id="f9de" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们测试我们的应用程序。这可以通过运行脚本client.py来完成，该脚本位于repo中，带有必要的参数(您需要在工作区中安装opencv和numpy来运行该脚本):</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="cdae" class="nl la it nh b gy nm nn l no np">python client.py --address <a class="ae ky" href="http://127.0.0.1:5000" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000</a> --image_path images/test_image.jpg --output_dir outputs/</span></pre><p id="21db" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您看到类似这样的输出，那么我们的应用程序正在按预期工作:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="744b" class="nl la it nh b gy nm nn l no np">Detections are: [{‘person’: ‘79%’}, {‘chair’: ‘34%’}]<br/>the image size is: size=1920x1281<br/>the image is being written in outputs/</span></pre><h1 id="3412" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">好吧…刚刚发生了什么！？</h1><p id="146b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当我们从docker文件构建映像时，我们设置运行Tensorflow对象检测API所需的环境，这包括克隆存储库、编译协议缓冲区、设置环境变量、下载模型，当我们准备就绪时，我们克隆存储库，其中包含为Flask应用程序提供服务的代码，我们在端口5000上启动应用程序，并确保在运行容器时公开该端口。</p><p id="d970" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是应用程序代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4ec1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以在此文件中更改参数、预训练模型。确保您的更改反映在docker文件中，您可以使用docker文件中的<em class="nt"> COPY </em>将已更改的repo从您的本地环境复制到docker文件中，而不是克隆它。</p><p id="b096" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在客户端，我们发送到端点的请求包含图像数据。我们可以使用API测试工具如<a class="ae ky" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮差</a>或curl命令来发送数据。我们得到的响应包含图像中的检测、图像大小和带有边界框覆盖的图像数据。我们把这个图像写到<em class="nt">输出目录</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="65ce" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated"><strong class="ak">注</strong>:</h2><ol class=""><li id="c941" class="ms mt it lt b lu lv lx ly ma of me og mi oh mm oi my mz na bi translated">如果您已经设置了包括将所需路径添加到PATH环境变量的环境，则可以在本地系统上运行该应用程序。</li><li id="20b8" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm oi my mz na bi translated">如果Docker容器没有按预期运行，您可以通过运行<em class="nt"> docker logs container_id </em>来检查日志，以检查哪里出错了</li><li id="e172" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm oi my mz na bi translated">这是API的基础版本，您可以根据需要对其进行定制。</li></ol><h1 id="9e80" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">将图像推送到Google容器注册表</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7dc6752c0a940b4c8a2bcdf1abde1470.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*x6ZPGy7StrkjP_8mvfSJSA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">谷歌容器注册</p></figure><p id="a4bb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在继续之前，您需要确保您在<a class="ae ky" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a>上有一个工作帐户，安装了云<a class="ae ky" href="https://cloud.google.com/sdk" rel="noopener ugc nofollow" target="_blank"> SDK </a>，并且创建了一个<a class="ae ky" href="https://cloud.google.com/resource-manager/docs/creating-managing-projects" rel="noopener ugc nofollow" target="_blank">项目</a>。</p><p id="6d34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们在本地环境中有映像，要进行部署，我们需要将它托管在云上。在本节中，我们将把Docker图像推送到<a class="ae ky" href="https://cloud.google.com/container-registry/docs/pushing-and-pulling?hl=en_US" rel="noopener ugc nofollow" target="_blank"> Google容器注册表</a>。</p><h2 id="16b8" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">我们开始吧</h2><p id="ec0b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先我们需要配置Docker来使用gcloud作为凭证助手。为此，请运行命令:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="b566" class="nl la it nh b gy nm nn l no np">gcloud auth configure-docker</span></pre><p id="3636" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要将任何本地图像推送到容器注册中心，我们需要首先用注册中心名称标记它，然后推图像。要进行标记，请运行以下命令:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ef4c" class="nl la it nh b gy nm nn l no np">docker tag tf-od-api gcr.io/${PROJECT_ID}/tf-od-api</span></pre><p id="e77d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="nt"> gcr.io </em>是主机名，它指定了存储映像的位置或存储库。</p><p id="663b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要推送标记的图像，请运行:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="1dca" class="nl la it nh b gy nm nn l no np">docker push gcr.io/${PROJECT_ID}/tf-od-api</span></pre><p id="574d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要检查图像是否已被推送，请列出图像。为此，请运行:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="92bd" class="nl la it nh b gy nm nn l no np">gcloud container images list</span></pre><p id="3a40" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果成功推送，您应该会在输出中看到图像名称。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="479d" class="nl la it nh b gy nm nn l no np">NAME<br/>gcr.io/my-project-21212/tf-od-api</span></pre><h1 id="aae3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">在Kubernetes部署</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/218f5ae39afdfbe1d860525b5846e2e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*T22Li5ZY0HcomtuirDbUrQ.png"/></div></figure><h2 id="3d44" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">介绍</h2><p id="2322" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您肯定听说过Kubernetes，它已经成为部署和管理容器化应用程序的标准。在本节中，我们将使用<a class="ae ky" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> Google Kubernetes引擎</a>在Kubernetes上部署我们的应用。</p><p id="b5c1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Kubernetes是一个容器编排系统。它有助于在集群上部署和管理容器化的应用程序。Kubernetes集群由一个主集群和节点组成，主集群负责管理集群，节点是运行应用程序的工作机。</p><h2 id="a0c4" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">我们开始吧</h2><p id="a2e1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，让我们安装<em class="nt"> kubectl </em>。<em class="nt"> kubectl </em>用于与Kubernetes通信。要安装<em class="nt"> kubectl </em>，运行:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5910" class="nl la it nh b gy nm nn l no np">gcloud components install kubectl</span></pre><h2 id="c8e0" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">创建集群</h2><p id="1d67" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们创建一个名为object-detection的双节点集群。如前所述，在Kubernetes中，节点是一个工作机，它可以是虚拟机，也可以是物理机，这取决于集群。要创建群集，请运行以下命令:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8d2a" class="nl la it nh b gy nm nn l no np">gcloud container clusters create object-detection --num-nodes=2</span><span id="2548" class="nl la it nh b gy ol nn l no np"><strong class="nh iu">OUTPUT</strong><br/>NAME              LOCATION       MASTER_VERSION  MASTER_IP       MACHINE_TYPE   NODE_VERSION    NUM_NODES  STATUS<br/>object-detection  us-central1-a  1.14.10-gke.27  35.193.127.147  n1-standard-1  1.14.10-gke.27  2          RUNNING</span></pre><p id="3791" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">创建集群后，它在G <a class="ae ky" href="https://cloud.google.com/compute" rel="noopener ugc nofollow" target="_blank"> oogle计算引擎</a>上启动两个VM实例，它们是集群的节点工作器。要查看它们，请运行以下命令:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8bef" class="nl la it nh b gy nm nn l no np">gcloud compute instances list</span><span id="6ab5" class="nl la it nh b gy ol nn l no np"><strong class="nh iu">OUTPUT</strong><br/>NAME                                             ZONE           MACHINE_TYPE   PREEMPTIBLE  INTERNAL_IP  EXTERNAL_IP   STATUS<br/>gke-object-detection-default-pool-cd7fa3ff-3zd6  us-central1-a  n1-standard-1               10.128.0.4   34.67.58.20   RUNNING<br/>gke-object-detection-default-pool-cd7fa3ff-z2hw  us-central1-a  n1-standard-1               10.128.0.5   35.222.93.20  RUNNING</span></pre><h2 id="395d" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">部署</h2><p id="c813" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经有了一个集群，让我们部署我们的容器化应用程序。为此，我们必须创建一个<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank"> Kubernetes部署</a>。该部署指导Kubernetes如何创建和更新我们的应用程序实例。当我们创建一个部署时，我们必须为我们的应用程序指定容器映像和部署的名称。运行以下命令创建部署:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4b98" class="nl la it nh b gy nm nn l no np">kubectl create deployment object-detection --image=gcr.io/${PROJECT_ID}/tf-od-api</span></pre><p id="aee1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当我们创建部署时，Kubernetes会创建Pods来托管应用程序实例。一个Pod代表一组一个或多个应用程序容器。一个Pod在一个节点上运行。要查看部署创建的pod，请运行:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ea0f" class="nl la it nh b gy nm nn l no np">kubectl get pods</span><span id="e9e2" class="nl la it nh b gy ol nn l no np"><strong class="nh iu">OUTPUT</strong><br/>NAME                                READY   STATUS    RESTARTS   AGE<br/>object-detection-7c997cbfd8-5nz4j   1/1     Running   0          2m11s</span></pre><h2 id="1475" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">向internet公开应用程序</h2><p id="3753" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们必须允许从互联网到应用程序的流量，这样我们才能访问它。为此，请运行:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="55d2" class="nl la it nh b gy nm nn l no np">kubectl expose deployment object-detection --type=LoadBalancer --port 80 --target-port 5000</span></pre><p id="7865" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="nt">端口</em>标志指定负载均衡器上配置的端口号，<em class="nt">目标端口</em>标志指定<em class="nt"> tf-od-api </em>容器监听的端口号。</p><p id="f84e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要获取外部IP，请运行以下命令:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5432" class="nl la it nh b gy nm nn l no np">kubectl get service</span><span id="d086" class="nl la it nh b gy ol nn l no np"><strong class="nh iu">OUTPUT</strong><br/>NAME               TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)        AGE<br/>kubernetes         ClusterIP      10.51.240.1    &lt;none&gt;          443/TCP        30m<br/>object-detection   LoadBalancer   10.51.245.79   35.193.230.83   80:31667/TCP   4m57s</span></pre><p id="85a3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们检查一下我们的应用程序是否是可访问的。为此，我们将运行相同的<em class="nt"> client.py </em>，但我们必须给出外部IP作为地址参数:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5971" class="nl la it nh b gy nm nn l no np">python client.py --address http://35.193.230.83/(my external IP) --image_path images/input_image.jpg --output_dir outputs/</span><span id="705f" class="nl la it nh b gy ol nn l no np"><strong class="nh iu">OUTPUT</strong><br/>Detections are: [{‘person’: ‘79%’}, {‘chair’: ‘34%’}]<br/>the image size is: size=1920x1281<br/>the image is being written in outputs/</span></pre><p id="d8c3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您看到类似于我们之前运行时的输出，那么恭喜您！您已经在Kubernetes上成功部署了一个容器化的Tensorflow对象检测API应用程序。</p><h2 id="b194" class="nl la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">清理</h2><p id="9167" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">完成后不要忘记删除集群，因为这可能会产生费用。为此，请运行以下命令删除该服务:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="6424" class="nl la it nh b gy nm nn l no np">kubectl delete service object-detection</span></pre><p id="1b93" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要删除群集及其资源，请运行:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4a90" class="nl la it nh b gy nm nn l no np">gcloud container clusters delete object-detection</span><span id="01f9" class="nl la it nh b gy ol nn l no np"><strong class="nh iu">OUTPUT</strong><br/>Deleting cluster object-detection...done.<br/>Deleted [<a class="ae ky" href="https://container.googleapis.com/v1/projects/temp-kubernetes/zones/us-central1-a/clusters/object-detection" rel="noopener ugc nofollow" target="_blank">https://container.googleapis.com/v1/projects/temp-kubernetes/zones/us-central1-a/clusters/object-detection</a>].</span></pre><h1 id="359b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="b494" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们学习了如何使用Flask服务Tensorflow对象检测API，使用Docker封装应用程序，以及在Kubernetes上部署应用程序。希望对你有所帮助。</p><p id="f4e5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您有任何反馈或希望取得联系，请在<em class="nt">ms.neerajkrishna@gmail.com</em>给我留言</p></div></div>    
</body>
</html>