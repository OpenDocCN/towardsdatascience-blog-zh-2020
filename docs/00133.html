<html>
<head>
<title>Using Python &amp; Stan to pick the Superbowl Winner with an Unrealistic Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python &amp; Stan用一个不切实际的模型选出超级碗冠军</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-python-stan-to-pick-the-superbowl-winner-with-an-unrealistic-model-e68c84c3e95a?source=collection_archive---------25-----------------------#2020-01-04">https://towardsdatascience.com/using-python-stan-to-pick-the-superbowl-winner-with-an-unrealistic-model-e68c84c3e95a?source=collection_archive---------25-----------------------#2020-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9f6d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">贝叶斯逻辑回归的一个简单例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/42da90732c8ee993de5afb22d6d06d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_cOPqRX1D0OaP7Qc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">戴夫·阿达姆松在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2ab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将说明一种使用Stan构建简单、不切实际但有用的概率模型的方法，以:</p><ul class=""><li id="eeaa" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">根据球队进攻、对手防守以及球队是否在主场比赛，预测每支NFL球队在一场比赛中的得分。</li><li id="6332" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用该模型模拟一个时间表，其中每支球队与所有31支球队进行100次主客场比赛。</li><li id="e932" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用结果为所有32个团队生成一个实力排名。</li><li id="9507" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用该模型预测季后赛的结果&amp;最终是超级碗。</li></ul><h1 id="9a64" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">原定目标</strong></h1><p id="9c32" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我本来是想找一个小问题，学习如何使用Stan进行贝叶斯建模。NFL权力排名模型似乎是一个有趣的尝试。某一年的数据样本量很小，因此很有吸引力:</p><ul class=""><li id="0584" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">32支队伍</li><li id="ae34" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">16场比赛</li><li id="2c24" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">512种结果——每场比赛每队一种</li><li id="04c9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">随着新分数的出现，该模型可以每周更新。</li></ul><p id="1284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从斯坦的主页——https://mc-stan.org/——可以下载该软件。</p><h1 id="b886" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">关于斯坦</h1><p id="6b27" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">“Stan是用于统计建模和高性能统计计算的一流平台。成千上万的用户依赖Stan进行社会、生物、物理科学、工程和商业领域的统计建模、数据分析和预测。</p><p id="6247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户在Stan的概率编程语言中指定对数密度函数，得到:</p><ul class=""><li id="889e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用MCMC抽样的完全贝叶斯统计推断(NUTS，HMC)</li><li id="3b29" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">带有变分推理的近似贝叶斯推理</li><li id="43a6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">优化的惩罚最大似然估计(L-BFGS)”</li></ul><h1 id="f53b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">数据</strong></h1><p id="4bcf" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">数据很容易从https://www.pro-football-reference.com/years/2019/games.htm获得。只需单击共享箭头选项卡，即可获得要复制的数据的csv布局。</p><p id="986b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了保持模型简单，模型需要的字段是:</p><ul class=""><li id="cb8d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">获胜队</li><li id="42ba" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">失败的队伍</li><li id="ce26" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">获胜团队得分</li><li id="af7c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">失去团队分数</li><li id="8ede" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">主/从指示器—&gt;@</li></ul><h1 id="f270" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">不切实际的分数概率模型</strong></h1><p id="0842" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在实际比赛中，得分事件产生1、2、3或6分，并且是3个以上因素的结果。</p><p id="591c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将被评估的模型将把分数仅仅作为球队进攻、对手防守以及球队是否在主场比赛的函数。</p><p id="ac63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用来预测球队得分的不切实际的模型是:</p><ul class=""><li id="7a06" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一个队可以得0到60分</li><li id="7256" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">团队得分的点数被建模为具有60次试验的二项式分布，并且成功概率p如上所述被估计。</li></ul><p id="84c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将使用Pystan对模型进行估计，并对模型中的特征进行先验分布，如下所述。</p><h1 id="ad92" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">数据处理</strong></h1><p id="0bc0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">抱歉——为读到这篇文章的任何数据科学家争论——我道歉。</p><p id="04b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进口:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="743d" class="nl mk it nh b gy nm nn l no np">import pandas as pd<br/>import numpy as np<br/>import pystan<br/>from   pystan import StanModel</span></pre><p id="cced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(1)读入保存的结果和重命名列的csv文件:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="3fac" class="nl mk it nh b gy nm nn l no np">df         = pd.read_csv("~/ml/Data/NFL2019.csv")</span><span id="daf3" class="nl mk it nh b gy nq nn l no np">df.columns = ['Week', 'Day', 'Date', 'Time', 'Winner',    'away','Loser','Unnamed: 7', 'PtsW', 'PtsL', 'YdsW', 'TOW', 'YdsL', 'TOL']</span></pre><p id="4d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(2)建立将城市队名称映射到队名称和队id的字典。最初，我认为我必须构建一个256 X 65 X的设计矩阵，因此团队id在下面的代码中是col_id。稍后会详细介绍。</p><p id="141f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果col_id没有从1开始，问题可能会在以后出现，因为Stan默认从1而不是0开始。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a684" class="nl mk it nh b gy nm nn l no np">team_dict = {}<br/>col_id    = 1</span><span id="5aa0" class="nl mk it nh b gy nq nn l no np">for i in range(df.shape[0]):<br/>    team_ = df.Winner[i]<br/>    temp  = team_.split()<br/>    temp  = temp[-1]<br/>    if team_ not in team_dict:<br/>        team_dict[team_] = dict(team=temp,k= col_id,)<br/>        col_id += 1</span></pre><p id="dc75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带有k的前几个team_dict条目是team_id:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="e0c5" class="nl mk it nh b gy nm nn l no np">{'Green Bay Packers': {'team': 'Packers', 'k': 1},<br/> 'Minnesota Vikings': {'team': 'Vikings', 'k': 2},<br/> 'Los Angeles Rams': {'team': 'Rams', 'k': 3},<br/> 'Baltimore Ravens': {'team': 'Ravens', 'k': 4},<br/> 'Philadelphia Eagles': {'team': 'Eagles', 'k': 5},</span></pre><p id="f9cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(3)构建反向字典，将列id映射回团队</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f2b0" class="nl mk it nh b gy nm nn l no np">X_dict = {}<br/>for key in team_dict:<br/>    x_key = team_dict[key]['team']<br/>    X_dict[x_key] = team_dict[key]['k']</span></pre><p id="af1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前几个X_dict条目:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="3710" class="nl mk it nh b gy nm nn l no np">{'Packers': 1,<br/> 'Vikings': 2,<br/> 'Rams': 3,<br/> 'Ravens': 4,<br/> 'Eagles': 5,</span></pre><p id="9371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(4)构建X矩阵以馈送给Stan。它将有3列:</p><ul class=""><li id="d623" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们预测其得分的团队的id</li><li id="35e9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它正在玩的队的id(防御)</li><li id="6602" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">基于数据中@符号的home 0/1指示器</li></ul><p id="2214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，存储分数。</p><p id="0651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于数据中的每一行，在X矩阵中创建两行，一行用于获胜的团队，一行用于失败的团队。idx_o &amp; idx_d是team_dict中攻防队的指数。</p><p id="7b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致在3列向量中存储可能非常稀疏的矩阵(在65列的每行中只有3个非零元素)。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="d349" class="nl mk it nh b gy nm nn l no np">X      = np.zeros((2*df.shape[0],3),int)<br/>score  = np.zeros(2*df.shape[0],int)<br/>row    = 0</span><span id="5467" class="nl mk it nh b gy nq nn l no np">for i in range(df.shape[0]):<br/>    idx_o    = team_dict[df.Winner[i]]['k']<br/>    idx_d    = team_dict[df.Loser[i]]['k']<br/>    X[row,0] = idx_o                         <br/>    X[row,1] = idx_d<br/>    score[row]     = df.PtsW.values[i]<br/>    if df.away[i] != '@':<br/>        X[row,2] = 1 <br/>    row += 1<br/>    <br/>    idx_o = team_dict[df.Loser[i]]['k']<br/>    idx_d = team_dict[df.Winner[i]]['k']<br/>    X[row,0] = idx_o<br/>    X[row,1] = idx_d<br/>    score[row]     = df.PtsL.values[i]<br/>    if df.away[i] == '@':<br/>        X[row,2] = 1</span></pre><p id="dc71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">x矩阵的前几行:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f1d2" class="nl mk it nh b gy nm nn l no np">array([[ 1, 20,  0],<br/>       [20,  1,  1],<br/>       [ 2, 21,  1],<br/>       [21,  2,  0],<br/>       [ 3, 25,  0],<br/>       [25,  3,  1],</span></pre><h1 id="0c48" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">使用Stan评估模型</strong></h1><p id="c776" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">(1)Stan的数据字典定义—相当简单，告诉Stan数据是什么以及有多少行(N)。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="597e" class="nl mk it nh b gy nm nn l no np">datadict  = { <br/>    'offense'  : X[:,0] ,<br/>    'defense'  : X[:,1],<br/>    'home'     : X[:,2] ,<br/>    'score'    : score,<br/>    'N'        : X.shape[0]<br/>}</span></pre><p id="0a28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(2)定义Stan模型——Python多行字符串。</p><p id="a40c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组件:</p><ul class=""><li id="8f8a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu"> <em class="nr">数据</em> </strong> —如上面的datadict中所定义。</li><li id="9bef" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"> <em class="nr">参数</em> </strong> —我们希望Stan估计的参数列表。一个用于每个队的进攻和防守，一个用于主场比赛和拦截。主队系数有一个上限。</li><li id="6aa8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"> <em class="nr">转换后的参数</em> </strong> —该模型估计<strong class="lb iu"> p的对数，</strong>我们不切实际的二项式模型中的概率。函数<strong class="lb iu"> <em class="nr"> inv_logit </em> </strong>将登录次数转换成成功的概率(在我们的例子中是60次试验中每一次的分数)。</li><li id="f868" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"> <em class="nr">模型— </em> </strong>在模型部分，先验分布与我们正在估计的概率模型(得分)一起指定。</li></ul><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="2bd3" class="nl mk it nh b gy nm nn l no np">stanCode = """<br/>data {<br/>int N;<br/>int score [N];<br/>int offense [N];<br/>int defense [N];<br/>int home    [N];<br/>}<br/>parameters {<br/>vector      [32]       b_offense;<br/>vector      [32]       b_defense;<br/>real &lt;upper = 0.05&gt;    b_home;<br/>real                   alpha;<br/>}<br/>transformed parameters{<br/>  real mu [N];<br/>  for (n in 1:N){<br/>    mu[n]  &lt;- inv_logit(alpha + b_offense[offense[n]] <br/>                              + b_defense[defense[n]]<br/>                              + b_home * home[n]);<br/>  }<br/>}</span><span id="b032" class="nl mk it nh b gy nq nn l no np">model {<br/>alpha      ~ normal(log(23),1);<br/>b_offense  ~ cauchy(0,0.5);<br/>b_defense  ~ cauchy(0,0.5);<br/>b_home     ~ double_exponential(0,5);<br/>score      ~ binomial(60,mu);</span><span id="f011" class="nl mk it nh b gy nq nn l no np">}<br/>"""</span></pre><p id="9023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(3)编译Stan模型——这需要一些时间。将打印出一条信息消息。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f28b" class="nl mk it nh b gy nm nn l no np">from pystan import StanModel<br/>sm = StanModel(model_code=stanCode)</span></pre><p id="c1dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(4)估计模型系数——op将是一个字典，包含每个队的进攻和防守系数、主客场系数、截距和预测mu。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c9b5" class="nl mk it nh b gy nm nn l no np">op = sm.optimizing(data=datadict)</span></pre><h1 id="8ae3" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">实力排名</strong></h1><p id="aeea" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在这一点上，我们现在已经有了模型权重，它使我们能够通过在游戏中运行sigmoid变换，根据任何两个队的进攻和防守系数以及该队是否在主场，来预测他们在游戏中的得分。</p><p id="b5ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以模拟任何球队和其他球队比赛的结果…不限于实际比赛。那么为什么不去做呢？我们模拟了一个时间表，其中每支球队与其他球队“比赛”100次，50次在主场，50次在客场。我们记录赢、输和平局。</p><p id="69e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要调整索引(team_ids ),因为模拟将在Python中进行，并构建一个团队列表来运行模拟。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="3622" class="nl mk it nh b gy nm nn l no np">team_list = []<br/>for team in X_dict:<br/>    team_list.append(team)<br/>    X_dict[team] = X_dict[team] - 1<br/>    print("{a:&gt;20s}  {b:6.3f}  {c:6.3f}".format(<br/>        a=team, <br/>        b=op['b_offense'][X_dict[team]],<br/>        c=op['b_defense'][X_dict[team]]</span><span id="e26e" class="nl mk it nh b gy nq nn l no np">))</span></pre><p id="7c4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查前几行——乌鸦和酋长队的进攻系数非常正，防守系数为负，而老鹰队接近平均水平。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8138" class="nl mk it nh b gy nm nn l no np">        offense  defense<br/>Packers   0.037   -0.203              <br/>Vikings   0.167   -0.226                 <br/>Rams      0.147   -0.131               <br/>Ravens    0.752   -0.358               <br/>Eagles    0.047    0.018                <br/>Bills    -0.252   -0.450               <br/>Chiefs    0.427   -0.226</span></pre><p id="f2a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模拟所有球队之间的100场比赛赛季:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ca33" class="nl mk it nh b gy nm nn l no np">wins   = np.zeros(len(team_list),int)<br/>losses = np.zeros(len(team_list),int)<br/>ties   = np.zeros(len(team_list),int)<br/>for idx_1 in range(31):<br/>    for idx_2 in range(idx_1+1,32):<br/>        team_1 = team_list[idx_1]<br/>        team_2 = team_list[idx_2]<br/>  <br/>        for game in range(100):<br/>            at_home = game % 2</span><span id="c22e" class="nl mk it nh b gy nq nn l no np">            u      = op['alpha'] <br/>            u     += op['b_offense'][X_dict[team_1]] <br/>            u     += op['b_defense'][X_dict[team_2]] <br/>            u     += op['b_home'] * at_home<br/>            prob   = 1. / (1. + np.exp(-u))<br/>            pts_1  = np.random.binomial(60,prob)</span><span id="3db2" class="nl mk it nh b gy nq nn l no np">            u      = op['alpha'] <br/>            u     += op['b_offense'][X_dict[team_2]] <br/>            u     += op['b_defense'][X_dict[team_1]] <br/>            u     += op['b_home'] * (1 - at_home)<br/>            prob   = 1. / (1. + np.exp(-u))<br/>            pts_2  = np.random.binomial(60,prob)</span><span id="461a" class="nl mk it nh b gy nq nn l no np">            if pts_1 &gt; pts_2:<br/>                wins[idx_1]   += 1<br/>                losses[idx_2] += 1<br/>            elif pts_1 &lt; pts_2:<br/>                wins[idx_2]   += 1<br/>                losses[idx_1] += 1<br/>            else:<br/>                ties[idx_1]   += 1<br/>                ties[idx_2]   += 1</span></pre><p id="24fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果——按获胜百分比排列的实力等级(平局算作1/2的胜负)。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="61fe" class="nl mk it nh b gy nm nn l no np">report = pd.DataFrame(dict(<br/>    team = team_list,<br/>    won  = wins,<br/>    lost = losses,<br/>    ties = ties<br/>))<br/>report['winpct'] = np.round((report.won + 0.5 * report.ties) / (report.won + report.lost + report.ties),3)</span><span id="6f1c" class="nl mk it nh b gy nq nn l no np">report.sort_values('winpct',ascending=False,inplace=True)<br/>report.reset_index(inplace=True)<br/>report = report[['team','won','lost','ties','winpct']]<br/>print(report)</span></pre><p id="dc62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【2019赛季模拟实力排名:</p><p id="3526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些排名通过了一个意义上的检验——强队在顶部，弱队在底部。大部分球队都在中心，公羊队和牛仔队在排名上表现不佳，而海鹰队和老鹰队表现出色，进入了季后赛。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f39b" class="nl mk it nh b gy nm nn l no np">         team    won  lost  ties  winpct<br/>0       Ravens  3025    53    22   0.979<br/>1     Patriots  2823   230    47   0.918<br/>2        49ers  2795   253    52   0.910<br/>3       Chiefs  2653   379    68   0.867<br/>4       Saints  2460   558    82   0.807<br/>5      Cowboys  2269   726   105   0.749<br/>6      Vikings  2270   735    95   0.748<br/>7         Rams  2104   867   129   0.700<br/>8       Titans  2014   942   144   0.673<br/>9      Packers  1997   979   124   0.664<br/>10    Seahawks  1882  1073   145   0.630<br/>11       Bills  1882  1081   137   0.629<br/>12      Texans  1589  1371   140   0.535<br/>13  Buccaneers  1593  1377   130   0.535<br/>14      Eagles  1585  1366   149   0.535<br/>15    Steelers  1545  1391   164   0.525<br/>16     Falcons  1487  1469   144   0.503<br/>17       Bears  1342  1594   164   0.459<br/>18    Chargers  1297  1666   137   0.440<br/>19       Colts  1237  1716   147   0.423<br/>20      Browns  1213  1739   148   0.415<br/>21     Broncos  1212  1754   134   0.413<br/>22   Cardinals  1032  1922   146   0.356<br/>23       Lions   750  2199   151   0.266<br/>24        Jets   603  2369   128   0.215<br/>25     Raiders   586  2403   111   0.207<br/>26     Jaguars   587  2415    98   0.205<br/>27    Panthers   552  2441   107   0.195<br/>28     Bengals   511  2479   110   0.183<br/>29      Giants   473  2529    98   0.168<br/>30    Redskins   209  2826    65   0.078<br/>31    Dolphins   178  2853    69   0.069</span></pre><p id="04c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">模拟季后赛</strong></p><p id="61da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于获取获胜概率的1场比赛的函数:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="e39c" class="nl mk it nh b gy nm nn l no np">def sim_games(team_1,team_2,row_id,report,s_round,add_home=True):<br/>    wins   = np.zeros(2,int)<br/>    losses = np.zeros(2,int)<br/>    ties   = np.zeros(2,int)<br/>    score  = np.zeros((1000,2),int)</span><span id="5dbd" class="nl mk it nh b gy nq nn l no np">    for game in range(1000):        <br/>        u      = op['alpha'] <br/>        u     += op['b_offense'][X_dict[team_1]]   <br/>        u     += op['b_defense'][X_dict[team_2]]  <br/>        u     += op['b_home'] * add_home<br/>        prob   = 1. / (1. + np.exp(-u))<br/>        pts_1  = np.random.binomial(60,prob)<br/>        <br/>        score[game,0] = pts_1</span><span id="e427" class="nl mk it nh b gy nq nn l no np">        u      = op['alpha'] <br/>        u     += op['b_offense'][X_dict[team_2]]   <br/>        u     += op['b_defense'][X_dict[team_1]]  <br/>        u     += op['b_home'] * add_home<br/>        prob   = 1. / (1. + np.exp(-u))<br/>        pts_2  = np.random.binomial(60,prob)<br/>        <br/>        score[game,1] = pts_2</span><span id="5f9c" class="nl mk it nh b gy nq nn l no np">        if pts_1 &gt; pts_2:<br/>            wins[0]   += 1<br/>            losses[1] += 1<br/>        elif pts_1 &lt; pts_2:<br/>            wins[1]   += 1<br/>            losses[0] += 1<br/>        else:<br/>            ties[0]   += 1<br/>            ties[1]   += 1</span><span id="5640" class="nl mk it nh b gy nq nn l no np">new_row = pd.DataFrame(dict(<br/>        Round        = s_round,<br/>        Visitor      = team_1,<br/>        V_Wins       = int(wins[0]+ ties[0]/2),<br/>        V_Score      = np.round(np.mean(score[:,0]),1),<br/>        Home         = team_2,<br/>        H_Wins       = int(wins[1]+ ties[1]/2),<br/>        H_Score      = np.round(np.mean(score[:,1]),1)<br/>),index=[row_id])</span><span id="1ebe" class="nl mk it nh b gy nq nn l no np">report = pd.concat((report,new_row))<br/>return(report)   </span></pre><p id="236c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">模拟季后赛的函数调用:</strong></p><p id="7ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进行第一轮比赛，并将预计的获胜者传送到第二轮比赛。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="74aa" class="nl mk it nh b gy nm nn l no np">report = pd.DataFrame()<br/>row_id = 0<br/>report = sim_games("Bills","Texans",<br/>row_id,report,s_round='Round 1',add_home=True)<br/>row_id = 1<br/>report = sim_games("Titans","Patriots",<br/>row_id,report,s_round='Round 1',add_home=True)<br/>row_id = 2<br/>report = sim_games("Seahawks","Eagles",<br/>row_id,report,s_round='Round 1',add_home=True)<br/>row_id = 4<br/>report = sim_games("Vikings","Saints",<br/>row_id,report,s_round='Round 1',add_home=True)<br/>row_id = 5<br/>report = sim_games("Bills","Ravens",<br/>row_id,report,s_round='Round 2',add_home=True)<br/>row_id = 6<br/>report = sim_games("Patriots","Chiefs",<br/>row_id,report,s_round='Round 2',add_home=True)<br/>row_id = 7<br/>report = sim_games("Seahawks","49ers",<br/>row_id,report,s_round='Round 2',add_home=True)<br/>row_id = 8<br/>report = sim_games("Saints","Packers",<br/>row_id,report,s_round='Round 2',add_home=True)<br/>row_id = 9<br/>report = sim_games("Saints","49ers",<br/>row_id,report,s_round='Round 3',add_home=True)<br/>row_id = 10<br/>report = sim_games("Patriots","Ravens",<br/>row_id,report,s_round='Round 3',add_home=True)<br/>row_id = 11<br/>report = sim_games("49ers","Ravens",<br/>row_id,report,s_round='superbowl',add_home=False)</span></pre><h1 id="9110" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">结果</strong></h1><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f193" class="nl mk it nh b gy nm nn l no np">        Round   Visitor  V_Wins  V_Score      Home  H_Wins  H_Score<br/>0     Round 1     Bills     648     19.9    Texans     352     17.9<br/>1     Round 1    Titans      77     16.6  Patriots     922     23.9<br/>2     Round 1  Seahawks     685     26.3    Eagles     315     23.5<br/>4     Round 1   Vikings     392     22.9    Saints     607     24.3<br/>5     Round 2     Bills       9     15.4    Ravens     990     27.2<br/>6     Round 2  Patriots     665     22.5    Chiefs     335     20.0<br/>7     Round 2  Seahawks      63     21.3     49ers     936     29.5<br/>8     Round 2    Saints     792     25.1   Packers     207     20.9<br/>9     Round 3    Saints     253     23.2     49ers     746     26.6<br/>10    Round 3  Patriots     233     20.5    Ravens     766     24.3<br/>11  superbowl     49ers     166     24.3    Ravens     834     29.6</span></pre><h1 id="0c6d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">总结</strong></h1><p id="4848" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">2019年的NFL结果被用来建立一个使用PyStan预测分数的模型，更重要的是作为一个如何使用Stan估计贝叶斯模型的例子。</p><p id="535e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着数据的可用和赛季的进展，该模型可用于生成每周电力排名。</p><p id="ce4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些观察结果:</p><ul class=""><li id="45ee" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">尽管该模型在权力排名上做得相当好，但预测的分数似乎受到了先验的影响。</li><li id="7eed" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">具有更大分布的先验可能导致更宽的预测得分范围。</li><li id="211d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">模型的弱点包括模型是基于整个赛季到目前为止，没有额外的重量给予最近的分数，关键的伤病或球员回归。</li></ul><p id="5635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">问题&amp;建议</strong></p><p id="6ce3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有任何问题、建议或需要预测模型，请随时发送电子邮件至:</p><p id="baea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">bill.fite@miner3.com。</p></div></div>    
</body>
</html>