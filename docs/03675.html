<html>
<head>
<title>Securing ML Services on the Web</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护网络上的ML服务</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/securing-ml-services-on-the-web-69408e8554d0?source=collection_archive---------36-----------------------#2020-04-06">https://towardsdatascience.com/securing-ml-services-on-the-web-69408e8554d0?source=collection_archive---------36-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/815a83ab088b891c895d29edce8b10ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sM7qgJIEmyhKXgeX.jpg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://pixabay.com/photos/vault-business-bank-vault-bank-1144249/" rel="noopener ugc nofollow" target="_blank">https://pix abay . com/photos/vault-business-bank-vault-bank-1144249/</a></p></figure><div class=""/><div class=""><h2 id="7927" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">HTTPS和访问控制</h2></div><p id="b99c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您希望在web上托管机器学习服务，那么通常有必要锁定端点，以便对服务的调用是安全的，并且只有授权用户才能访问服务。为了确保敏感信息不会暴露在web上，我们可以使用安全的HTTP (HTTPS)来加密客户端和服务之间的通信，并使用访问控制来限制谁可以访问端点。如果你在2020年建立一个机器学习服务，你应该计划为你的端点实现安全HTTP和访问控制。</p><p id="74cb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将展示如何构建一个用Flask实现的安全端点来托管scikit-learn模型。我们将探索以下方法:</p><ul class=""><li id="9360" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">使HTTPS直接在烧瓶中</li><li id="1c2d" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">使用WSGI服务器(Gunicorn)</li><li id="40af" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">使用安全的负载平衡器(GCP)</li></ul><p id="8d72" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在GCP生态系统中使用Docker和Kubernetes托管服务。为了限制授权用户的访问，我们将探索以下服务访问控制方法:</p><ul class=""><li id="ad5f" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">基于令牌的身份验证(Flask)</li><li id="5767" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">OAuth认证(破折号)</li><li id="f39d" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">白名单</li></ul><p id="415a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据您的组织部署服务的方式，这些选项中的一些可能不可用，但获得锁定服务的各种不同方法的经验是很好的，通常使用多种方法锁定端点是个好主意。这篇文章是从托管用Python编写的web服务的角度来写的，并建立在我以前关于模型作为web端点的文章的基础上。</p><div class="is it gp gr iu mi"><a rel="noopener follow" target="_blank" href="/models-as-web-endpoints-162cb928a9e6"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jk gy z fp mn fr fs mo fu fw ji bi translated">作为Web端点的模型</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">《生产中的数据科学》摘录</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">towardsdatascience.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw ja mi"/></div></div></a></div><h1 id="4677" class="mx my jj bd mz na nb nc nd ne nf ng nh kp ni kq nj ks nk kt nl kv nm kw nn no bi translated">烧瓶用HTTPS</h1><p id="fe9b" class="pw-post-body-paragraph ky kz jj la b lb np kk ld le nq kn lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">如果您计划在web上托管一个机器学习模型，那么您应该在项目早期考虑数据和结果的安全传输需求。Chrome在2018年年中开始将HTTP网站标记为不安全，现在有很多工具可以使用HTTPS来保护模型端点。安全HTTP利用安全套接字层(SSL)来确保客户端和服务器之间的通信是加密的，并使用公钥基础设施(PKI)来确保客户端与其预定目标进行通信。本文主要关注第一个方面，客户端和服务器之间发送的流量是加密的。若要完全设置HTTPS，您需要设置一个对应于您的端点IP地址的DNS条目，以便您可以创建一个签名证书，将您的端点标识为受信任的主机。一旦你设置了DNS入口，这一步对于谷歌云平台(GCP)来说是很简单的，但是管理一个网络域和DNS查询不在这篇文章的讨论范围之内。</p><p id="2512" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，最好使用Flask以外的系统来保护端点，因为Flask不应该直接用作web应用程序。相反，最好使用Gunicorn或Nginx等工具在非安全的Flask应用程序上提供一个安全层。然而，有时候Flask应用程序，比如在Flask上用Dash构建的交互式web应用程序，需要提供端到端的安全连接。这就是像<a class="ae jg" href="https://flask-dance.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Flask Dance </a>这样的库有用的地方。</p><p id="cdc5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要安装Python和相关库。对于本教程，我们将安装以下库来设置Flask端点、Dash应用程序和客户端应用程序:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="4758" class="od my jj nz b gy oe of l og oh">pip3 install --user pandas <br/>pip3 install --user scikit-learn<br/>pip3 install --user flask<br/>pip3 install --user Flask-HTTPAuth<br/>pip3 install --user requests<br/>pip3 install --user cryptography<br/>pip3 install --user gunicorn<br/>pip3 install --user dash<br/>pip3 install --user flask_dance<br/>pip3 install --user dash-google-auth</span></pre><p id="a943" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们首先在Flask中构建一个预测建模端点，返回用户购买新游戏的倾向。模型的输入是一个特征向量，它描述了用户以前是否购买过小目录中的游戏。代码在我以前关于模型的帖子中有更详细的描述，名为<a class="ae jg" rel="noopener" target="_blank" href="/models-as-web-endpoints-162cb928a9e6"> web端点</a>。下面的代码片段显示了如何设置Flask端点，该端点首先训练一个scikit-learn模型，在“/”处设置一个端点来服务该模型，然后直接启动应用程序。</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="oi oj l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">基本HTTP Flask应用程序。</p></figure><p id="4812" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在使用<code class="fe ok ol om nz b">python flask_html.py</code>运行应用程序之后，我们现在有了一个运行在端口80上的模型服务器应用程序。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="7cc6" class="od my jj nz b gy oe of l og oh">* Serving Flask app "app" (lazy loading)<br/>* Environment: production<br/>* Debug mode: off<br/>* Running on <a class="ae jg" href="https://0.0.0.0:443/" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:80/</a> (Press CTRL+C to quit)</span></pre><p id="e609" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还可以使用Python测试端点，如下面的代码片段所示:</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="oi oj l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">用于通过HTTP调用模型端点的Python客户端。</p></figure><p id="baf0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行客户端代码的结果是使用<code class="fe ok ol om nz b">requests</code>库通过不安全的HTTP调用模型端点，然后打印结果。我们希望达到同样的结果，但要让通话在HTTPS进行。要设置此协议，我们可以锁定Flask端点，使用web服务在Flask上提供一个安全层，或者使用负载平衡器来提供HTTPS功能，同时仍然在虚拟私有云(VPC)中使用HTTP。</p><p id="6d64" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">直接使用Flask<br/></strong>使用Flask应用程序启用安全HTTP的第一种方法是在Flask中建立安全连接。这不是推荐的方法，因为在生产环境中直接使用Flask不是最佳实践，而是应该使用诸如Gunicorn之类的WSGI服务器来包装Flask应用程序。但是如果您想在开发期间锁定服务，那么这种方法可能是合适的。在Flask端，从HTTP到HTTPS的更改只需要更改一行，这是前面Flask代码片段中的最后一行。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="ec26" class="od my jj nz b gy oe of l og oh">app.run(host='0.0.0.0', port=443, ssl_context='adhoc')</span></pre><p id="b635" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们修改了应用程序，使其运行在端口443上，这是HTTPS的默认端口，而不是HTTP的默认端口80。此外，我们还设置了一个SSL上下文，它告诉Flask使用SSL来提供安全连接。<code class="fe ok ol om nz b">adhoc</code>参数告诉Flask动态生成未签名的凭证，而不是将已签名或未签名的凭证传递给服务器。当您运行更新后的示例时，您会看到服务的端口和协议都发生了变化，如下所示。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="b0c8" class="od my jj nz b gy oe of l og oh">* Serving Flask app "app" (lazy loading)<br/>* Environment: production<br/>* Debug mode: off<br/>* Running on <a class="ae jg" href="https://0.0.0.0:443/" rel="noopener ugc nofollow" target="_blank">https://0.0.0.0:443/</a> (Press CTRL+C to quit)</span></pre><p id="d9f6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该服务现在使用SSL来提供客户端和服务器之间的安全连接，但是使用<code class="fe ok ol om nz b">adhoc</code>设置意味着证书的来源没有经过可信机构的验证。为了创建正确签名的证书，我们需要将模型托管在一个命名的URL上，比如<code class="fe ok ol om nz b"><a class="ae jg" href="https://cat-classifier.ml.com" rel="noopener ugc nofollow" target="_blank">https://cat-classifier.ml.com</a></code>，而不仅仅是一个IP地址，比如<code class="fe ok ol om nz b"><a class="ae jg" href="https://10.0.0.1" rel="noopener ugc nofollow" target="_blank">https://10.0.0.1</a></code>。如果您能够设置一个DNS条目来将您的IP地址映射到一个命名的URL，那么您可以使用一个<a class="ae jg" href="https://en.wikipedia.org/wiki/Certificate_authority" rel="noopener ugc nofollow" target="_blank">认证机构</a>来创建正确的凭证。与此同时，我们将继续使用<code class="fe ok ol om nz b">adhoc</code>方法，这意味着当您试图使用Google Chrome查看模型端点时，会得到以下警告。</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/8e26d2083837fb4693862e583d83c6da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZ3hdSt5fgFA0OEUBEyojw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用临时凭据会导致未签名的证书。</p></figure><p id="d8b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，如果您修改前面的客户端示例，使用HTTPS代替HTTP，您将得到下面的警告。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="180d" class="od my jj nz b gy oe of l og oh">requests.exceptions.SSLError: HTTPSConnectionPool(host='localhost', port=443): Max retries exceeded with url: / (Caused by SSLError(SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: self signed certificate (_ssl.c:1076)')))</span></pre><p id="f27a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在有了作为安全端点运行的模型，但不是可信端点。为了创建受信任的端点，我们需要一个签名证书来验证发送到端点的流量实际上对应于模型端点，并且不能被冒充我们的服务的第三方截获。我们不会在本文中涉及这方面的内容，但是我们将在下一节中展示如何设置自签名证书。</p><p id="0bc0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">使用WSGI服务器<br/> </strong>与其直接运行Flask应用，不如在将模型服务应用部署到生产时，使用可扩展的web服务器框架，如Gunicorn或Nginx。要修改我们的应用程序以使用Gunicorn，我们首先需要创建一个自签名证书，该证书可用于建立安全连接。下面显示的命令显示了如何使用Gunicorn在HTTPS上提供Flask应用程序。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="6ccd" class="od my jj nz b gy oe of l og oh">openssl req -x509 -newkey rsa:4096 -nodes -out cert.pem <br/>            -keyout key.pem -days 365<!-- --> </span><span id="2e75" class="od my jj nz b gy oo of l og oh">gunicorn --certfile cert.pem --keyfile key.pem <br/>         -b 0.0.0.0:443 flask_http:app</span></pre><p id="750d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果与上一节类似，现在我们有了一个受不可信模型保护的端点。这两个例子的主要区别在于Gunicorn方法可以处理更大的流量。</p><p id="faee" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">使用负载均衡器<br/> </strong>还有第三种方法可以用来建立安全的flask应用程序，即构建一个Flask应用程序，它使用HTTP来服务请求，但是将这个服务包装在一个私有集群中。这种方法是安全的，但是不使用端到端加密。一旦流量被路由到私有集群，云内的机器之间就会使用不安全的连接，这些机器通常没有公共IP地址。实现这种设置的一种方法是使用Google Kubernetes引擎(GKE)来托管您的容器化Flask应用程序，并使用节点端口和入口来设置HTTPS安全负载平衡器。结果是，从客户端到服务器的流量将被加密到入口端点，并且从该端点到容器将在内部使用HTTP。同样，这种方法导致了一种安全但不可信的方法。然而，如果您的端点有一个DNS条目，那么使用Google管理的SSL证书创建一个合适的证书是很简单的。</p><p id="29d7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一部分专门针对GCP，但是这种方法应该适用于其他Kubernetes环境。下面是一般的方法:</p><ol class=""><li id="f20f" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt op ma mb mc bi translated">使用Docker将您的应用程序容器化</li><li id="13a0" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt op ma mb mc bi translated">在没有公共IP的Kubernetes集群中托管容器</li><li id="0742" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt op ma mb mc bi translated">使用节点端口服务类型在VPC中公开服务</li><li id="087b" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt op ma mb mc bi translated">使用启用了HTTPS的服务入口启用外部连接</li></ol><p id="c20f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要设置GCP帐户、创建凭证并启用这种方法所需的容器注册和GKE服务，需要遵循许多步骤。在我之前关于在GCP建立模型服务的文章中提供了更多的细节。我将在这篇文章中介绍的主要区别是使用节点端口加入口设置(<em class="oq">第7层</em>)与使用负载平衡器作为TCP端点来直接公开服务(<em class="oq">第4层</em>)。</p><div class="is it gp gr iu mi"><a rel="noopener follow" target="_blank" href="/devops-for-data-science-with-gcp-3e6b5c3dd4f6"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jk gy z fp mn fr fs mo fu fw ji bi translated">与GCP合作开发数据科学</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">为模型服务部署生产级容器</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">towardsdatascience.com</p></div></div><div class="mr l"><div class="or l mt mu mv mr mw ja mi"/></div></div></a></div><p id="b972" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一步是将端点设置为Docker应用程序。为了实现这一结果，我们需要创建一个docker文件来设置Python生态系统，安装所需的库，并定义要运行的应用程序。我们将使用Gunicorn来包装Flask应用程序，并通过HTTP托管这个端点，如下面的<em class="oq"> Dockerfile </em>所示:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="f369" class="od my jj nz b gy oe of l og oh">FROM ubuntu:latest<br/>MAINTAINER Ben Weber</span><span id="0a45" class="od my jj nz b gy oo of l og oh">RUN apt-get update \<br/>  &amp;&amp; apt-get install -y python3-pip python3-dev \<br/>  &amp;&amp; cd /usr/local/bin \<br/>  &amp;&amp; ln -s /usr/bin/python3 python</span><span id="2cc7" class="od my jj nz b gy oo of l og oh">RUN pip3 install flask<br/>RUN pip3 install pandas<br/>RUN pip3 install gunicorn<br/>RUN pip3 install scikit-learn</span><span id="49cd" class="od my jj nz b gy oo of l og oh">COPY app.py app.py</span><span id="c2ca" class="od my jj nz b gy oo of l og oh">ENTRYPOINT ["gunicorn", "--bind", "0.0.0.0:80", "app:app"]</span></pre><p id="d46f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将构建容器，然后在将容器推送到注册中心之前在本地测试容器。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="5384" class="od my jj nz b gy oe of l og oh">sudo docker image build -t "model_service" .<br/>sudo docker images<br/>sudo docker run -it -p 80:80 model_service</span></pre><p id="3507" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要将容器推送到Google Container Registry，我们首先需要在推容器之前执行<code class="fe ok ol om nz b">docker login</code>。关于设置这些证书的细节，请参见我之前在GKE 的<a class="ae jg" rel="noopener" target="_blank" href="/models-as-web-endpoints-162cb928a9e6">模特服务上的帖子。执行完这些步骤后，我们将在GCP上有一个可用的容器，我们可以用它在GKE部署服务。</a></p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="oi oj l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">将图像推送到Google容器注册表。</p></figure><p id="8228" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将容器推送到GCP后，我们将启动一个GKE集群，并将容器部署为一个工作负载。一旦您设置了一组pod并运行服务，您就可以通过首先设置节点端口服务类型来安全地公开服务，如下图所示。</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div class="gh gi os"><img src="../Images/69ba52e4976fa972bded6770c8c151a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*8LinYAMkS8C6HbHqKX8fJw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">在VPC中公开模型服务。</p></figure><p id="d820" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是为服务创建一个入口，将端点暴露给开放的web，而不仅仅是在您的VPC中。要设置入口，请浏览至服务和入口选项卡，选择您刚刚创建的节点端口，然后选择“创建入口”。</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/94960ea8099a845646218462911b4036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xytNz8nIEmUQhq7uDMRrnQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">从节点端口创建入口。</p></figure><p id="418e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这一步开始，我们可以设置一个具有HTTP和HTTPS端点的负载平衡器。如果要禁用模型服务的非安全流量，可设置仅HTTPS端点。如果选择HTTPS选项，则需要指定要使用的证书。您可以暂时假装这一步，选择使用Google管理的证书并选择任何域。结果将是一个无效的证书，但是您将能够测试设置一个支持HTTPS的负载平衡器。</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ou"><img src="../Images/389d7c91e23b1d3e8d26c2554fcbe1df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9OLyf3SuLn7c_WT6nhWjg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用GCP负载平衡设置HTTPS端点。</p></figure><p id="41b4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果将是一个HTTPS端点，您现在可以在“服务和入口”选项卡中查看。模型服务现在在<code class="fe ok ol om nz b"><a class="ae jg" href="https://34.107.189.4" rel="noopener ugc nofollow" target="_blank">https://34.107.189.4</a></code>运行，但是端点不是受信任的URL。</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/64fb18b7ea80f695db05171bf5fa545d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84PlOqyJXFUaHoLnFQbjZw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由此产生的HTTPS端点。</p></figure><p id="094c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在已经探索了将Flask应用程序设置为安全端点的三个选项。虽然使用的方法会根据您的云平台和组织偏好而有所不同，但是使用安全web服务包装Flask应用程序的第二种方法可能是最合适的方法。</p><h1 id="eb16" class="mx my jj bd mz na nb nc nd ne nf ng nh kp ni kq nj ks nk kt nl kv nm kw nn no bi translated">烧瓶的访问控制</h1><p id="02c6" class="pw-post-body-paragraph ky kz jj la b lb np kk ld le nq kn lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">我们已经讨论了锁定模型服务的第一个方面，即确保客户端和服务器之间发送的流量是加密的。下一步是使用访问控制工具来限制谁可以访问该工具。加密可确保第三方无法监听主机之间的流量，而访问控制可确保未授权方无法访问该服务。如果您在公司网络中工作，那么一种可能已经存在的访问控制形式是仅限于VPN的访问。我们不会在这篇文章中讨论这种方法，因为VPN的设置可能非常复杂，并且在不同的组织中差异很大。相反，我们将通过令牌、OAuth和白名单来探索访问控制。</p><p id="5999" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文没有涉及的另一种访问控制方法是使用web服务层，例如Nginx，在将流量转发到Flask应用程序之前进行用户授权。这种方法非常适合数据科学团队，因为它实现了关注点的分离，数据科学团队建立模型服务容器，DevOps团队管理对端点的访问。对于成熟的组织来说，这是一个很好的方法，但对于负责端到端模型部署的数据科学团队来说，这可能不可行。</p><p id="3795" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">基于令牌的认证<br/> </strong>启动并运行锁定端点的最简单方法是拥有一个公共秘密，客户端可以使用该秘密向模型服务进行认证。在最简单的情况下，这意味着拥有单一的共享密码，客户端可以使用该密码来建立对资源的访问。这种方法以及大多数访问控制方法只有在使用安全连接与模型服务进行通信时才有效。一般来说，如果没有安全的通信协议，您就不能拥有有效的访问控制。下一步是为不同的用户提供不同的访问令牌或密码，并为不同的角色提供不同的访问级别。</p><p id="1a55" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用令牌方法开始，因为密码管理是一个庞大的主题，我无法在一篇简短的帖子中对其进行公正的讨论。事实上，我建议不要使用任何直接的密码管理，而应该使用OAuth之类的协议，这将在下一节中讨论。我们将浏览的示例使用单个令牌进行访问，但是可以扩展到使用一组令牌。理想情况下，您应该有一个工具来生成令牌，存储关于用户和角色的元数据，并能够拒绝令牌或使令牌过期。对于这个简单的例子，我们将使用<a class="ae jg" href="https://flask-httpauth.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Flask-HTTPAuth </a>，它提供令牌和摘要认证。</p><p id="dfcb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">向Flask应用程序添加令牌认证只需要几个步骤。我们需要使用<code class="fe ok ol om nz b">@auth.login_required </code>注释来识别哪些路由是安全的，并实现一个<code class="fe ok ol om nz b">verify_token</code>函数来认证客户端。在这种情况下，我们检查来自用户<em class="oq"> (1234567890abcdefg </em>)的已知令牌。对于生产系统，通常将令牌存储在数据库中，并将令牌映射到不同的访问策略。</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="oi oj l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">用固定令牌保护Flask应用程序。</p></figure><p id="69f5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经锁定了端点，当客户端试图在没有令牌的情况下访问端点时，将被拒绝访问，如下所示。</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/cb19d0b0aabff45fb4a74be84f379266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*0djEn2d3DiFmWkno94wdyg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">尝试在没有令牌的情况下访问模型服务。</p></figure><p id="3ca0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要访问模型服务，我们需要更新客户机请求示例，以便在请求头中提供令牌。下面的代码片段显示了如何更新请求，将令牌添加到请求中的<code class="fe ok ol om nz b">headers</code>参数。现在，结果应该与第一个示例相同，但是我们现在已经使用令牌将模型服务锁定到客户端。</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="oi oj l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用用于访问的令牌调用模型端点。</p></figure><p id="3cc2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在与第三方合作时，令牌方法非常有用，因为您可以允许大量用户进行访问。但是，这种方法不如使用OAuth之类的协议安全，OAuth可以用来限制对一组指定用户的访问。</p><p id="34d5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> OAuth认证<br/> </strong>令牌对于模型端点很有用，因为您可能需要提供预测，而不需要客户端通过web UI登录。但是如果你的目标应用是一个交互式应用，而不是模型预测，那么Dash这样的工具会非常有用。我喜欢用Dash来构建web应用程序，因为我可以用Python编写web应用程序，并使用OAuth等安全特性来验证用户。使用OAuth，您可以将身份验证委托给已知的提供者，比如Google来建立用户的身份。您仍然定义可以访问您的应用程序的用户列表，但是您依赖可信的提供者来完成确保身份的复杂工作。</p><p id="b403" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的例子展示了如何使用Google Oauth 2.0来锁定Dash应用程序。Dash是建立在Flask之上的框架，本例中使用的Flask Dance库可以应用于所有Flask应用程序。为了让这个例子工作，您需要在<a class="ae jg" href="https://cloud.google.com/docs/authentication" rel="noopener ugc nofollow" target="_blank"> GCP </a>中配置一个OAuth规则。</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="oi oj l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">用OAuth 2.0保护的Dash应用程序示例。</p></figure><p id="363a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法的结果是，当您试图访问模型服务端点时，您将得到一个登录页面。如果您提供了凭据并且在允许的用户列表中，您将获得以下内容:</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/a1eb67b3df092ef75d678a9614cd865f.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*zyxxrI41KTRfGonmvWSKRw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">该应用程序服务于授权用户。</p></figure><p id="9bca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用OAuth的主要好处是第三方负责建立用户的身份，这是一个标准协议。如果您正在设置一个基于GUI的web服务，这是一个很好的方法。</p><p id="fd9b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第三种实施访问控制的方式是限制哪些机器可以访问服务。这种方法被称为白名单，因为只有授权IP地址列表上的机器才被授权使用该服务。这种方法不验证发出调用的客户端的身份，但是锁定了对少量机器的访问。这种方法对于VPN设置很有用，在VPN设置中，到VPN的连接是安全的，流量通过带有静态地址的VPN传输。这对于需要与已知IP地址的第三方服务交互的模型端点也很有用。</p><p id="becc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您使用GKE服务入口方法来设置负载平衡的HTTPS端点，那么您可以使用GCP云盔甲来设置白名单规则。所有不允许访问服务的传入流量都将返回403响应代码(禁止)。要为负载平衡器设置白名单，请在GCP控制台中浏览到Cloud Armor，然后单击“创建策略”。您可以配置一组阻止的IP和允许的IP。在下面的示例中，默认情况下所有流量都被阻止，优先级更高的第二个规则允许来自IP <code class="fe ok ol om nz b">1.2.3.4</code>的访问。设置好IP规则后，我们可以使用<em class="oq">目标</em>部分将这个新策略应用到模型服务负载平衡器。</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/330a72b85ce3f662480f57bf4bf768ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-4ubsaV4tRQ6rGLf36hTQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">将单个IP(1.2.3.4)加入GCP云防护的白名单</p></figure><p id="28c1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法的结果是，来自指定IP地址的流量将被允许，所有其他流量将得到<em class="oq">禁止</em>响应。这种方法不直接对用户进行身份验证，而是依赖于来自已知静态IP地址的流量。这类似于在AWS上配置EC2安全组时设置入站流量规则。</p><h1 id="05b7" class="mx my jj bd mz na nb nc nd ne nf ng nh kp ni kq nj ks nk kt nl kv nm kw nn no bi translated">结论</h1><p id="0fac" class="pw-post-body-paragraph ky kz jj la b lb np kk ld le nq kn lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">如果您计划建立将在web上提供的机器学习模型，那么您应该从项目一开始就计划安全性和访问控制。虽然通常使用包装数据科学团队建立的服务功能的工具来提供安全措施，但是任何发布服务的团队都应该确保web服务是安全的，并且仅限于授权用户。</p></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="c8d9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本·韦伯是Zynga杰出的数据科学家。我们正在<a class="ae jg" href="https://www.zynga.com/job-listing-category/data-analytics-user-research/" rel="noopener ugc nofollow" target="_blank">招聘</a>！</p></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="f57f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="oq">注来自《走向数据科学》的编辑:</em> </strong> <em class="oq">虽然我们允许独立作者根据我们的</em> <a class="ae jg" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="oq">规则和指导方针</em> </a> <em class="oq">发表文章，但我们不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae jg" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="oq">读者术语</em> </a> <em class="oq">。</em></p></div></div>    
</body>
</html>