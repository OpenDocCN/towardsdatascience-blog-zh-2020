<html>
<head>
<title>How To Make Your Python Code Run Faster — 1st Installment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让您的Python代码运行得更快—第1期</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/did-you-know-how-to-make-your-python-code-run-faster-1st-installment-f317359159a1?source=collection_archive---------20-----------------------#2020-04-04">https://towardsdatascience.com/did-you-know-how-to-make-your-python-code-run-faster-1st-installment-f317359159a1?source=collection_archive---------20-----------------------#2020-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e022" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">优化系统硬件的利用率</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6c6a2a39bc37e90a6fea2f94339b7829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UgJExIZx8KsqjhUo"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">蒂姆·高在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d3d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/d2wap-sud/did-you-know-you-can-measure-the-execution-time-of-python-codes-14c3b422d438" rel="noopener">的上一篇教程</a>中，我们向您介绍了<strong class="ky ir"> line_profiler </strong>，这是一个可以帮助您对代码进行时间分析的包。现在是向前迈出一步的时候了。</p><p id="9e33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们将学习使用Python实现多线程和多处理方法。这些方法指导操作系统优化利用系统硬件，从而提高代码执行效率。</p><p id="653f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始吧…</p><h1 id="83ef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">多线程</h1><blockquote class="mk ml mm"><p id="04d7" class="kw kx mn ky b kz la jr lb lc ld ju le mo lg lh li mp lk ll lm mq lo lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">引用Wiki </strong> </a> —在计算机架构中，<strong class="ky ir">多线程</strong>是中央处理器(CPU)(或多核处理器中的单核)提供<strong class="ky ir">多个线程并发执行</strong>的能力，由操作系统支持。</p></blockquote><p id="7b58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给定并发性，可以启动多个进程的并行执行，并实现更快的运行时。不去探究技术细节(<strong class="ky ir">谷歌和阅读GIL </strong>)，要记住的一件事是<strong class="ky ir">多线程在执行基于I/O的任务(如下载图像和文件)时效率更高。另一方面，多处理更适合基于CPU的计算密集型任务。</strong></p><h2 id="04ef" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">Python中的多线程实现</h2><p id="207b" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">为了实现多线程，我们将使用Python的标准库，<strong class="ky ir">线程</strong>。默认情况下，标准Python安装附带了这个库，因此可以在我们的代码中直接导入。</p><p id="9350" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了演示多线程的有效性，我们将从<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Unsplash </strong> </a>下载5幅图像。让我们观察顺序下载这些图像时的执行时间:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="cc91" class="mr lt iq nj b gy nn no l np nq"><strong class="nj ir">#### Importing requests library</strong><br/>import requests</span><span id="cd27" class="mr lt iq nj b gy nr no l np nq"><strong class="nj ir">#### Defining the function </strong><br/>def down_img(name,link):<br/>    data = requests.get(link).content<br/>    name = f"/home/isud/DidYouKnow/Tutorial 5/{name}.jpg"<br/>    with open(name, "wb") as file:<br/>        file.write(data)</span><span id="61f5" class="mr lt iq nj b gy nr no l np nq"><strong class="nj ir">#### 5 images downloaded sequentially</strong><br/>%%timeit -n1 -r1<br/>images = ['<a class="ae kv" href="https://images.unsplash.com/photo-1531458999205-f31f14fa217b'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1531458999205-f31f14fa217b'</a>,<br/>          '<a class="ae kv" href="https://images.unsplash.com/photo-1488572749058-7f52dd70e0fa'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1488572749058-7f52dd70e0fa'</a>,<br/>          '<a class="ae kv" href="https://images.unsplash.com/photo-1531404610614-68f9e73e35db'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1531404610614-68f9e73e35db'</a>,<br/>          '<a class="ae kv" href="https://images.unsplash.com/photo-1523489405193-3884f5ca475f'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1523489405193-3884f5ca475f'</a>,<br/>          '<a class="ae kv" href="https://images.unsplash.com/photo-1565098735462-5db3412ac4cb'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1565098735462-5db3412ac4cb'</a>]<br/>for i,link in enumerate(images):<br/>    down_img(i,link)</span><span id="9c10" class="mr lt iq nj b gy nr no l np nq"><strong class="nj ir">#### %%timeit results</strong><br/>51.4 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)</span></pre><p id="5fe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以看出，完整下载5个图像花费了51.4秒。此外，只有在前一次下载结束后，新的下载才会开始。现在让我们看看<strong class="ky ir">多线程</strong>如何提高代码性能。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="e1ed" class="mr lt iq nj b gy nn no l np nq"><strong class="nj ir">#### Importing necessary library<br/></strong>import threading<br/>import requests</span><span id="1779" class="mr lt iq nj b gy nr no l np nq"><strong class="nj ir">#### Defining the function<br/></strong>def down_img(name,link):<br/>    data = requests.get(link).content<br/>    name = f"/home/isud/DidYouKnow/Tutorial 5/{name}.jpg"<br/>    with open(name, "wb") as file:<br/>        file.write(data)</span><span id="597c" class="mr lt iq nj b gy nr no l np nq"><strong class="nj ir">#### Images downloaded in parallel threads<br/></strong>%%timeit -n1 -r1<br/>threads = []<br/>images = ['<a class="ae kv" href="https://images.unsplash.com/photo-1531458999205-f31f14fa217b'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1531458999205-f31f14fa217b'</a>,<br/>          '<a class="ae kv" href="https://images.unsplash.com/photo-1488572749058-7f52dd70e0fa'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1488572749058-7f52dd70e0fa'</a>,<br/>          '<a class="ae kv" href="https://images.unsplash.com/photo-1531404610614-68f9e73e35db'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1531404610614-68f9e73e35db'</a>,<br/>          '<a class="ae kv" href="https://images.unsplash.com/photo-1523489405193-3884f5ca475f'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1523489405193-3884f5ca475f'</a>,<br/>          '<a class="ae kv" href="https://images.unsplash.com/photo-1565098735462-5db3412ac4cb'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1565098735462-5db3412ac4cb'</a>]</span><span id="ff1f" class="mr lt iq nj b gy nr no l np nq">for i,link in enumerate(images):<br/>    <strong class="nj ir">t = threading.Thread(target=down_img, args=(i,link))</strong><br/>    <strong class="nj ir">t.start()</strong><br/>    <strong class="nj ir">threads.append(t)</strong></span><span id="34d6" class="mr lt iq nj b gy nr no l np nq"><strong class="nj ir">for thread in threads:<br/>    thread.join()</strong></span><span id="706e" class="mr lt iq nj b gy nr no l np nq"><strong class="nj ir">#### %%timeit results<br/></strong>25.6 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)</span></pre><h2 id="b845" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">代码解释—定义图像下载循环:</h2><ul class=""><li id="5017" class="ns nt iq ky b kz nd lc ne lf nu lj nv ln nw lr nx ny nz oa bi translated"><strong class="ky ir">步骤1(线程初始化)</strong> — Python在单线程中运行完整的代码(姑且称之为<strong class="ky ir">主线程</strong>)。在这个例子中，通过从<strong class="ky ir">线程</strong>库中调用<strong class="ky ir">线程</strong>函数，我们<strong class="ky ir">启动并行线程</strong>并为它们分配一个要执行的目标进程(在这个例子中为<strong class="ky ir"> down_image </strong>)。被调用函数所需的所有参数都应该作为一个序列对象(在本例中为tuple)传递。每次调用<strong class="ky ir">线程</strong>函数都会启动一个新线程(姑且称之为<strong class="ky ir">并行线程</strong>)。</li><li id="6d7a" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated"><strong class="ky ir">步骤2(线程开始)</strong> —调用<strong class="ky ir">线程的</strong> <strong class="ky ir">开始</strong> <strong class="ky ir">方法</strong>将指示Python开始线程执行。假定<strong class="ky ir">for循环的<em class="mn">正在主线程中执行，并且函数调用在并行线程</em></strong>中执行，则在图像下载进行的同时，for循环将继续执行。</li><li id="1436" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated"><strong class="ky ir">步骤3(线程连接)</strong> —每个新线程都被捕获到一个名为<strong class="ky ir"> threads的列表中。</strong>然后通过调用<strong class="ky ir">连接方法</strong>将并行线程连接到主线程。</li></ul><h2 id="8d56" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">为什么加盟是必要的？</h2><p id="0eb7" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">直到第2步，我们所有的线程(<strong class="ky ir">主线程和</strong>并行线程)都处于并行执行状态。在这种情况下，<strong class="ky ir">主线程的执行可以在并行线程</strong>之前完成。为了避免这种情况，将并行线程连接到主线程是不可避免的。这将确保主线程的执行仅在并行线程完成之后完成。下图解释了这两种情况:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/f230a648f552686866a57b234140c454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oEwX_zJlZXcJa7rWobyzTg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">无连接和有连接的螺纹</p></figure><p id="9376" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以看出，下载图像的执行时间缩短了近50%(大约25.6秒)。).上述示例展示了多线程如何有助于I/O操作并提高下载/上传过程的效率。</p><h1 id="07f2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">多重处理</h1><p id="ede6" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">与在单个进程中执行多个线程的多线程不同，<strong class="ky ir">多线程为每个任务</strong>启动一个新的并行进程。如上所述，它为CPU密集型任务(需要大量计算的任务)提供了相当大的运行时间改进。</p><h2 id="ddfc" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">在Python中实现多重处理</h2><p id="88a2" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated"><strong class="ky ir">多重处理</strong>是另一个支持Python多重处理特性的标准库。为了理解它的功能，我们将多次调用一个计算密集型函数。用于演示的<strong class="ky ir">函数计算1到1000万的平方</strong>。该功能并行执行8次。我们来观察一下这个函数在正常情况下的表现。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="8db3" class="mr lt iq nj b gy nn no l np nq"><strong class="nj ir">#### Importing time library</strong><br/>import time</span><span id="ad35" class="mr lt iq nj b gy nr no l np nq"><strong class="nj ir">#### Defining the function </strong><br/>def demo_func(num):<br/>    for i in range(num):<br/>        a = i**2</span><span id="7ee5" class="mr lt iq nj b gy nr no l np nq"><strong class="nj ir">#### Calling demo function sequentially</strong><br/>%%timeit -n1 -r1<br/>for i in range(8):<br/>    demo_func(10000000)</span><span id="4dcb" class="mr lt iq nj b gy nr no l np nq"><strong class="nj ir">#### %%timeit results</strong><br/>21.2 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)</span></pre><p id="5d35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演示函数的顺序执行总共花费了21.2秒。现在，让我们检查一下在多处理设置中完成后的性能提升。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="8efd" class="mr lt iq nj b gy nn no l np nq"><strong class="nj ir">#### Importing time library</strong><br/>import time</span><span id="ec9a" class="mr lt iq nj b gy nr no l np nq"><strong class="nj ir">#### Defining the function </strong><br/>def demo_func(num):<br/>    for i in range(num):<br/>        a = i**2</span><span id="bdd2" class="mr lt iq nj b gy nr no l np nq"><strong class="nj ir">#### Multi-processing demo function </strong><br/>%%timeit -n1 -r1<br/>processes = []<br/>lop_size = [10000000,10000000,10000000,10000000,10000000,10000000,10000000, 10000000]<br/><strong class="nj ir">p = multiprocessing.Pool()</strong><br/><strong class="nj ir">p.map(demo_func,lop_size)</strong><br/><strong class="nj ir">p.close()<br/>p.join()</strong></span><span id="81a6" class="mr lt iq nj b gy nr no l np nq"><strong class="nj ir">#### %%timeit results</strong><br/>11.6 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)</span></pre><p id="af47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在多处理框架下，<strong class="ky ir">的执行时间下降了50%，为11.6秒</strong>。在<strong class="ky ir">顺序处理</strong>中，一次使用一个<strong class="ky ir">单CPU内核</strong>，而在<strong class="ky ir">多处理</strong>中，并行使用所有系统内核。CPU使用情况屏幕截图显示了同样的情况:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/535a5238e5141bc80560808430e6a1dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1L7X3Vgmfarhz7EqbtV5w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">顺序执行与并行执行</p></figure><p id="9a68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上图中的每条线代表一个CPU内核。请注意，在顺序执行中，每个函数调用都会触发一个内核，而在并行执行中，所有内核都会被同时触发。</p><h2 id="d1ad" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">代码解释</h2><ul class=""><li id="147e" class="ns nt iq ky b kz nd lc ne lf nu lj nv ln nw lr nx ny nz oa bi translated"><strong class="ky ir">步骤1(池创建)</strong>—<strong class="ky ir">池方法</strong>创建可以并行利用的进程池。在没有任何参数的情况下，<strong class="ky ir">创建的进程数量等于系统上CPU内核的数量</strong>。我有一个四核系统(4核),这意味着在执行8个函数调用时，前4个调用将并行运行，随后是后4个调用。请注意，<strong class="ky ir">您还可以在池中定义自定义的进程数量</strong>(比内核数量多<strong class="ky ir">)，但是超过这个数量<strong class="ky ir">，它将开始消耗您的系统内存</strong>并可能降低性能</strong></li><li id="66e2" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated"><strong class="ky ir">步骤2(池映射)</strong> —这是指示您的流程执行一个<strong class="ky ir">特定函数(第一个参数)</strong>以及要传递给它的一系列<strong class="ky ir">参数(第二个参数)</strong></li><li id="459b" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated"><strong class="ky ir">步骤3(池关闭)—关闭方法</strong>指示Python解释器，我们已经提交了我们想要提交到池中的所有内容，并且将来不会再有输入提供给池。</li><li id="a77b" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated"><strong class="ky ir">第4步(池连接)——</strong>与线程的情况一样，<strong class="ky ir">连接方法</strong>确保只有当所有并行进程完成时，代码执行才会完成。</li></ul><p id="9c45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的场景中，我们可以看到多线程是如何成为对抗低效代码性能的强大武器的。</p><h1 id="e883" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结束语</h1><p id="a515" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">在本教程中，我们将重点放在通过优化利用系统硬件来提高代码性能上。在下一期文章中，我们将展示提高代码性能的具体编程实践。</p><p id="de18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇教程是有启发性的，并且你学到了一些新的东西。</p><p id="deee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">会在以后的教程中尝试并带来更多有趣的话题。在此之前:</p><p id="825c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快乐学习！！！！</p></div></div>    
</body>
</html>