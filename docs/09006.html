<html>
<head>
<title>Coloring an Image using Crayola Colors (Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用克雷奥拉颜色为图像着色(Python)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/coloring-an-image-using-crayola-colors-python-31ca1c7edb9d?source=collection_archive---------50-----------------------#2020-06-28">https://towardsdatascience.com/coloring-an-image-using-crayola-colors-python-31ca1c7edb9d?source=collection_archive---------50-----------------------#2020-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bf1e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我如何使用 cython 和 OpenCV 编写了一个 python 代码来将图像转换为好像它们是使用 Crayola 颜色着色的。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/05713df25c7a6417c7642fa867475724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SxK7MK8prz1okjkE2XbjsA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="109a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建一个颜色数组。首先，我为一个 120 色蜡笔<a class="ae lr" href="http://www.jennyscrayoncollection.com/2017/10/complete-list-of-current-crayola-crayon.html" rel="noopener ugc nofollow" target="_blank">蜡笔盒</a>选择相应的 RGB 值，并将它们复制到一个列表中。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="fca0" class="lx ly iq lt b gy lz ma l mb mc">colorsFile = open("colors.txt","r")<br/>colors = []</span><span id="bd90" class="lx ly iq lt b gy md ma l mb mc">for line in colorsFile.readlines():<br/>    colorset = line.strip().split(" ")<br/>    rgbFormat = [int(x) for x in colorset[2].split(",")]<br/>    colors.append(rgbFormat)</span></pre><p id="84f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其次，我从挑选一张图片并把它调整到较小的尺寸开始。这主要是为了减少运行时间。此外，我注意到较小的图片似乎更好地带出预期的效果。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="ef95" class="lx ly iq lt b gy lz ma l mb mc">import cv2<br/>import os<br/>for imageFile in os.listdir("TestImages"):<br/>    img_rgb = cv2.imread("TestImages/" + imageFile)<br/>    img_rgb = cv2.resize(img_rgb, (0, 0), fx = 0.7, fy = 0.7)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/4bba7f03961e555518eac41a8035c97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cxluqCLhOvhi6jf9r1QNAw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">原始图像(作者)</p></figure><p id="5353" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我运行了一个<a class="ae lr" href="https://www.geeksforgeeks.org/python-bilateral-filtering/" rel="noopener ugc nofollow" target="_blank">双边滤波器</a>，它平滑了图像，但保留了边缘。边缘是很重要的，因为大多数蜡笔画都有强烈的、非常真实的、轮廓分明的边缘。OpenCV 中的双边滤镜由两个主要因素控制，sigmaColor(值越高，混合的远距离颜色越多)和 sigmaSpace(值越高，混合的远距离像素越多)。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="3eaa" class="lx ly iq lt b gy lz ma l mb mc">#alpha = 6 Repeatedly running the filter with small values brought better results than a single run with a larger filter<br/>for _ in range(alpha):<br/>        img_rgb_smooth = cv2.bilateralFilter(img_rgb, d=9, sigmaColor=9, sigmaSpace=7)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/651986c582e266cf1d0d758244826f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nClluC3WLmZgoLcjLY2E2w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行双边过滤器后</p></figure><p id="0f7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行双边过滤器后，我识别了图像中的边缘。首先，我将图像转换成灰度。主要是因为我们将使用<a class="ae lr" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html" rel="noopener ugc nofollow" target="_blank">自适应阈值</a>方法来识别边缘，这种方法只适用于灰度。我们基本上是在制作一个二进制图像，其中每个像素不是黑就是白。为创建这个二进制图像设置一个单一的阈值会遇到麻烦，比如图像上的光照不均匀。因此，最好是使用局部阈值，这将带来更好的结果。根据图像调整块大小会产生更好的结果。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="14e3" class="lx ly iq lt b gy lz ma l mb mc">img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2GRAY)<br/>img_edge = cv2.adaptiveThreshold(img_gray, 255,<br/>    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,<br/>    cv2.THRESH_BINARY,<br/>    blockSize=11,<br/>    C=2)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/5fea30f49eb1ed491540f3b4d7d56bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q4VxKBBx4a1pMm6fizCgBg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">边缘提取</p></figure><p id="0dea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我把固体边缘放回我们的图像上。我们可以使用逐位 and 算术运算符，对带有边缘的图像和 RGB 图像进行逐像素运算。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="dcef" class="lx ly iq lt b gy lz ma l mb mc">img_edge = cv2.cvtColor(img_edge, cv2.COLOR_GRAY2RGB)<br/>img_rgb_edges = cv2.bitwise_and(img_rgb, img_edge)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/6d172820f8d83b0fd3eba6727b7fcb32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d4uYX5RWNlwLgdCwzs4VuQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">叠加边缘</p></figure><p id="a8f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我用调色板中最接近的颜色替换了每个像素的颜色。我花了很长时间才把它做好，这很容易成为本模块的核心步骤。我首先使用了当前颜色和调色板中每种颜色之间的纯欧几里德距离。输出不像我希望的那样真实。它通常会显示出与预期颜色的显著偏差。使用这里提供的<a class="ae lr" href="https://stackoverflow.com/questions/1847092/given-an-rgb-value-what-would-be-the-best-way-to-find-the-closest-match-in-the-d" rel="noopener ugc nofollow" target="_blank">堆栈溢出解决方案缓解了这个问题</a>,它用我们感知颜色的灵敏度来增强公式。其他的<a class="ae lr" href="https://en.wikipedia.org/wiki/Color_difference" rel="noopener ugc nofollow" target="_blank">建议</a>是基于色调距离，然而，我觉得它并没有比欧几里得更好的表现。所以最初，我用 python 写了一个 for 循环来操作每个像素。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="75ad" class="lx ly iq lt b gy lz ma l mb mc">for x in range(0,width):<br/>    for y in range(0,height):<br/>        channels_xy = img_rgb_edges[y,x]<br/>        colorSwapping(x,y,channels_xy)</span><span id="7755" class="lx ly iq lt b gy md ma l mb mc">def colorSwapping(x,y,rgbArray):<br/>    r1,g1,b1 = rgbArray<br/>    shortestDistance = None<br/>    sol = None<br/>    for color,value in colors.items():<br/>        r2,g2,b2 = value<br/>        d = pow(((r2-r1)*0.30),2) + pow(((g2-g1)*0.59),2) + pow(((b2-b1)*0.11),2)<br/>        if(shortestDistance == None or d &lt; shortestDistance):<br/>            shortestDistance = d<br/>            sol = value<br/>    img_rgb_edges[y,x] = sol</span></pre><p id="6b49" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而这真的很慢，然后我尝试使用线程。那也没多大帮助。Python 有一个叫做<a class="ae lr" href="https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank">的全局解释器锁</a>，它不允许在一个数组上并发运行。经过进一步的搜索，我发现 cython 可以帮助大大加快这个过程。在我的例子中，将像素操作逻辑转移到 cython 有助于将速度提高 20 倍。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="1fd0" class="lx ly iq lt b gy lz ma l mb mc">import cythoncode<br/>img_rgb_edges = cythoncode.coloringImage(img_rgb_edges, colors)<br/>cv2.imwrite("Output/"+imageFile ,img_rgb_edges)</span></pre><p id="63e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">cython 功能，</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="d403" class="lx ly iq lt b gy lz ma l mb mc">#cythoncode.pyx<br/>cpdef coloringImage(img,colors):<br/>    cdef int height = img.shape[0]<br/>    cdef int width = img.shape[1]<br/>    for x in range(0,width):<br/>        for y in range(0,height):<br/>            pixelSwap(img,x,y, colors)<br/>    return img<br/>    <br/>cpdef pixelSwap(img,x,y,colors):<br/>    channels_xy = img[y,x]<br/>    cdef int shortestDistance = -1<br/>    sol = []<br/>    cdef length = len(colors)<br/>    for index in range(0,length):<br/>        d = distanceCalculator(channels_xy,colors[index])<br/>        if(shortestDistance == -1  or d &lt; shortestDistance):<br/>            shortestDistance = d<br/>            sol = colors[index]<br/>    img[y,x] = sol</span><span id="dcdc" class="lx ly iq lt b gy md ma l mb mc">cpdef int distanceCalculator(color1, color2):<br/>    cdef int r2 = color1[0]<br/>    cdef int g2 = color1[1]<br/>    cdef int b2 = color1[2]<br/>    cdef int r1 = color2[0]<br/>    cdef int g1 = color2[1]<br/>    cdef int b1 = color2[2]<br/>    return int(((r2-r1)*0.30)**2 + ((g2-g1)*0.59)**2 + ((b2-b1)*0.11)**2)</span></pre><p id="bf47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Cython 就像 Python 的一个超集，具有来自 c 的函数。由于我对 cython 相对陌生，所以我只将简单的组件(如距离计算器)转移到 cython，这纯粹是计算。将 python 图像对象转换成数组可能有助于进一步提高速度。</p><p id="f9ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Setup.py 构建模块，</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="40b7" class="lx ly iq lt b gy lz ma l mb mc">from setuptools import setup<br/>from Cython.Build import cythonize<br/>setup(<br/>    name='Cython Pixel Manipualtion Code',<br/>    ext_modules=cythonize("cythoncode.pyx"),<br/>    zip_safe=False,<br/>)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/6b6aa3850c205451e40e29eb22d8a760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7xU2C0GgpS9PWo9x4M6jA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">切换到最接近的克雷奥拉颜色</p></figure><p id="7ea7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所见，最合适的颜色并不总是在图像中挑选。但是，仍然产生了相当好的卡通化效果。</p><p id="07aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我运行代码的更多图片，</p><div class="kg kh ki kj gt ab cb"><figure class="mf kk mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/0f4c1e6fbecb4282139683c54b83a408.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*NXyJHkuYr4_5OmAmSsJ_Ww.jpeg"/></div></figure><figure class="mf kk ml mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/5c0f0c785cebf9463bf54c082dfcdbb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*-zHbbKAaX6V28W75fuUV3A.jpeg"/></div></figure><figure class="mf kk mm mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/6cb6d0d458d35bda7166205f4c071d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*Bvan3pypFjTqS3a0fA2WeQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk mn di mo mp translated">在 Pixel 3 上拍摄多张照片，然后使用代码进行转换</p></figure></div><div class="ab cb"><figure class="mf kk mq mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/32c74482c1cf9a684df60eb4991968e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*K9FHvpH4uHesQuv8GiETiQ.jpeg"/></div></figure><figure class="mf kk mr mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/b4f4bb7732941207748b523bbe01f014.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*I_NvlnNZ55MVnmjnzhllfQ.jpeg"/></div></figure></div></div></div>    
</body>
</html>