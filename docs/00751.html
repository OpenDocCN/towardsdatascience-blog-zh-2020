<html>
<head>
<title>How To Manage A Shared Codebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何管理共享代码库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-the-best-development-teams-manage-shared-codebases-2613b5b87185?source=collection_archive---------27-----------------------#2020-01-21">https://towardsdatascience.com/how-the-best-development-teams-manage-shared-codebases-2613b5b87185?source=collection_archive---------27-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ab8a2deb5f41f55f9d4abaae7ba9d59e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzQ5XA_Jy0-XdlocJmcFNw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://unsplash.com/@anniespratt" rel="noopener ugc nofollow" target="_blank">安妮·斯普拉特</a>在<a class="ae jg" href="https://unsplash.com/photos/QckxruozjRg" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h2 id="c234" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">软件工程</h2><div class=""/><div class=""><h2 id="7ecf" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">避免团队开发时面临的常见问题</h2></div><p id="c950" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">恭喜</strong>！你终于想出了完美的新应用创意。你和你的软件工程师团队匆忙编写代码，这将是你名利双收的门票。但是等等。Maria 为这个应用程序的主页编写的代码看起来很棒——但是它如何与 Steven 为访问数据库编写的代码一起工作呢？Hector 设计了一个函数来计算我们正在寻找的值——但是这些值如何在应用程序中从一个页面移动到另一个页面呢？让团队的代码协同工作本身就成了一个项目！</p><p id="49f9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，我将向您展示我们如何使用<strong class="lj jt"> Git </strong>和<strong class="lj jt"> GitHub </strong>来管理将在多个开发人员之间共享的代码库。<strong class="lj jt">版本控制</strong>像<strong class="lj jt"> Git </strong>这样的工具被软件工程师、数据科学家和游戏开发者使用——仅举几个例子。</p><blockquote class="md"><p id="c9ed" class="me mf jj bd mg mh mi mj mk ml mm mc dk translated">先决条件:<a class="ae jg" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank">安装 Git </a>，<a class="ae jg" href="https://github.com/" rel="noopener ugc nofollow" target="_blank">有一个 GitHub 帐号</a>，<a class="ae jg" rel="noopener" target="_blank" href="/getting-started-with-git-github-6235f5ae3a0b">知道如何创建一个库</a></p></blockquote><blockquote class="mn mo mp"><p id="03f8" class="lh li mq lj b lk mr kt lm ln ms kw lp mt mu ls lt mv mw lw lx mx my ma mb mc im bi translated"><strong class="lj jt"> <em class="jj">注意:Salesforce 已经决定移除他们的 Heroku 免费等级。自 2022 年 11 月起，该数据库的部署将不再免费。</em> </strong></p></blockquote></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="9076" class="ng nh jj bd ni nj nk nl nm nn no np nq ky nr kz ns lb nt lc nu le nv lf nw nx bi translated">1.创建存储库和添加协作者</h1><p id="a8ea" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated">一旦你登录到<strong class="lj jt"> GitHub </strong>上，继续创建一个库。我的就叫“<a class="ae jg" href="https://github.com/ClairvoyantCoding/How_To_Manage_A_Shared_Codebase_Article" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt">如何 _ 管理 _ 共享 _ 代码库 _ 文章</strong> </a>”。确保使用 README.md 文件创建存储库，以便在进入第二步之前进行根提交。在您新创建的 GitHub 资源库中，点击<strong class="lj jt">设置</strong>。然后从左侧菜单中选择<strong class="lj jt">合作者</strong>。</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/01918d962b20aca4d808b2eda90d3a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ciJhX8DTTmVF-vXqKgX7wQ.png"/></div></div></figure><p id="566b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你可以通过他们的 GitHub <strong class="lj jt">用户名</strong>或者他们的<strong class="lj jt">电子邮件地址</strong>来添加你的团队成员。然后，他们将通过电子邮件收到加入您项目的邀请。</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/7fc47ebf4b755b81b38ae8baf20c8d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5WeeSPQ3QU_yQwgs.png"/></div></div></figure><p id="a636" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦他们接受，您将能够通过选择以下选项，在协作者页面上编辑他们的权限:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7d4cc69ebb5bfcd18de4531ba0953084.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*2F5K6EnTqUQJku0Jut8B3A.png"/></div></figure><p id="f90b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在您和您的团队可以克隆您的存储库并开始开发了！如果你给你的团队成员“<strong class="lj jt">写</strong>”权限，他们就可以开始投稿了。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="1dfc" class="ng nh jj bd ni nj nk nl nm nn no np nq ky nr kz ns lb nt lc nu le nv lf nw nx bi translated">2.Git 分支</h1><p id="4e7e" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated"><strong class="lj jt"> Git </strong>中的<strong class="lj jt">分支</strong>的行为类似于我们用来组织工作片段的项目的副本。如果我们的项目中有三个任务要完成，我们可以为每个任务创建一个分支，然后在完成每个单独的任务后将每个分支合并到主分支中。</p><p id="a0f0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我们新克隆的存储库中，尝试运行以下命令:</p><pre class="oe of og oh gt ok ol om on aw oo bi"><span id="65df" class="op nh jj ol b gy oq or l os ot"><strong class="ol jt">git branch</strong></span></pre><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/b20b0b61ff029c5f371a791bdd230325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*AE9GtSd0F2iPAFoYdKcIQA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)运行“git branch”命令来查看我们所有的分支</p></figure><p id="19ab" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">git branch 命令列出了我们存储库中的分支。目前，我们只有默认的<em class="mq">主</em>分支，它是在我们创建存储库时自动创建的。我们可以使用<strong class="lj jt"> git branch </strong>命令创建一个新的分支，并添加一个分支名，如下所示:</p><pre class="oe of og oh gt ok ol om on aw oo bi"><span id="64c4" class="op nh jj ol b gy oq or l os ot"><strong class="ol jt">git branch first_branch</strong></span></pre><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi gj"><img src="../Images/910190fefba5c687f2cdd6b4e90938ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DlBax4giQVQHwnrAh0TpSA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)创建一个分支，(2)使用“git branch”命令查看我们所有的分支</p></figure><p id="6104" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们现在有了项目的两个不同的副本。主<em class="mq">分支旁边有一个星号——这意味着这是我们当前正在使用的项目分支。为了在项目的分支之间切换，我们使用了<strong class="lj jt"> git checkout </strong>命令:</em></p><pre class="oe of og oh gt ok ol om on aw oo bi"><span id="ada5" class="op nh jj ol b gy oq or l os ot"><strong class="ol jt">git checkout first_branch</strong></span></pre><p id="79fc" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，如果我们运行<strong class="lj jt"> git branch </strong>命令，我们会看到星星已经从<em class="mq"> main </em>移动到<em class="mq"> first_branch </em>:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/d0132ff39b4a58cdf4e03f2c3a9af693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nx-GQ59Xkxm1oZLZLaPpBQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)切换到我们的新分支，(2)检查我们是否在分支上</p></figure><p id="3444" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我们的新分支上，让我们添加一些变化。我们将创建一个名为<strong class="lj jt"> app.sh </strong>的 shell 脚本，其中包含:</p><pre class="oe of og oh gt ok ol om on aw oo bi"><span id="736e" class="op nh jj ol b gy oq or l os ot"><strong class="ol jt">echo “Hello world”</strong></span></pre><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/95a47f59cde7726ecf20b09f70218b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*r_q7xczxpfisvhGZ4d9B-g.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)创建“Hello world”shell 脚本，(2)查看脚本内容，(3)运行脚本</p></figure><p id="d376" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后我们将添加文件并提交它。之后，我们可以运行 git log 来查看我们的新提交:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/c0d74a48fcc6a40e48a3345df8bcd6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*0SDjomCOxr0X04HjxRUJxA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)使用 git add 选择要提交的 shell 脚本，(2)使用消息提交 shell 脚本，(3)使用“git log”查看新的提交</p></figure><blockquote class="mn mo mp"><p id="d4c4" class="lh li mq lj b lk ll kt lm ln lo kw lp mt lr ls lt mv lv lw lx mx lz ma mb mc im bi translated">注意:请参见第二行，我在 Windows 上使用。/app.sh "。在 Mac 或 Linux 上，您可以使用“sh app.sh”来运行该文件。</p></blockquote><p id="a301" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在让我们使用 git checkout 返回到我们的<em class="mq">主</em>分支，然后使用 git log 查看我们在主分支上的提交:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/c5e59652ac0b43e25554941bcd6f6c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*8qL2Ig9cJVUN_xhzsLTPFg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)使用 git checkout main 返回到主分支，(2)然后使用 git log 查看我们的 shell 脚本没有在这个分支上提交它，文件本身也没有</p></figure><p id="9c6e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如您所见，我们在<em class="mq"> first_branch </em>分支上创建的提交不在这里。让我们假设我们在<em class="mq"> first_branch </em>上所做的工作已经完成，现在我们想把我们的变更转移到<em class="mq"> main </em>分支上。为此，我们将不得不切换回我们的<em class="mq"> first_branch </em>，并将我们的分支推到 GitHub。</p><p id="92fa" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我们的<em class="mq"> first_branch </em>上运行<strong class="lj jt"> git push </strong>将会失败——但是它将提供我们可以用来<strong class="lj jt">设置我们的上游</strong>的命令。因为我们在本地存储库上创建了我们的分支，并且我们直到现在才推送这个分支——我们的新分支不知道推送至何处。我们将上游设置为<strong class="lj jt">原点</strong>，方法是在我们尝试推送时运行错误消息中给出的命令:“<em class="mq">git push-set-upstream origin first _ branch</em>”。</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/87324a5760232cfe33c9dcb0d824e44c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*sYEZvalBJA1qJ0bc7Fj3Ig.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)切换回具有我们的新 shell 脚本的 first_branch，(2)尝试推送并得到一个错误，它不知道将该错误推送到哪里，(3)从错误消息中复制 set-upstream 命令并使用它来推送我们的新代码</p></figure></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="ca9b" class="ng nh jj bd ni nj nk nl nm nn no np nq ky nr kz ns lb nt lc nu le nv lf nw nx bi translated">3.拉取请求</h1><p id="dd9f" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated">我们回 GitHub 看看我们新推的分支吧。我们可以使用下图左下方的“<strong class="lj jt">分支:主</strong>”下拉菜单来更改我们正在查看的分支。由于我们刚刚推送了我们的分支，GitHub 给了我们一条消息，询问我们是否愿意为我们的新分支创建一个<strong class="lj jt">拉取请求</strong>。我们将单击绿色的“<strong class="lj jt">比较&amp;拉动请求</strong>按钮。</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/97aa787a266536dddfd23d5b9ff2195e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*52BYdfG0oJ6ymZLwO0p0fg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">查看 GitHub 上的“比较和拉取请求”按钮，查看我们推送的新 first_branch</p></figure><p id="ab35" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在你可以看到<em class="mq"> first_branch </em>将合并为<em class="mq"> main </em>表示为:<strong class="lj jt">base:main←compare:first _ branch</strong>。旁边有一个绿色的“<strong class="lj jt">能够合并</strong>”信息，告诉你这些分支可以自动合并。点击<strong class="lj jt">创建拉动请求</strong>按钮创建拉动请求。</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/7f8c7e2d297ff897b3740cad19f22856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NsLE7AlOkmUxeMNHBRxvPg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">表单为我们的新 first_branch 创建拉请求，以合并到主分支中</p></figure><p id="b559" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下一页——如下图所示——是新打开的拉请求页面。点击<strong class="lj jt">文件修改</strong>工具栏选项，可以查看<em class="mq"> first_branch </em>上的修改内容。由于我们所做的更改没有导致任何冲突，我们可以单击“<strong class="lj jt">合并拉取请求</strong>”按钮，Git 会自动将我们的代码合并到<em class="mq">主</em>分支中。</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/767ca512bdabaf57233f1fba2ee3c779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1-twhVYxVc_PD40EZiung.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">查看我们创建的拉动式请求</p></figure><p id="1b15" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用拉请求将代码合并到<em class="mq">主</em>分支需要这个漫长的过程，因为我们希望确保被破坏的代码永远不会出现在<em class="mq">主</em>分支上。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="e4bb" class="ng nh jj bd ni nj nk nl nm nn no np nq ky nr kz ns lb nt lc nu le nv lf nw nx bi translated">4.使用 Git Pull 更新本地主分支</h1><p id="e9b2" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated">自从我们将<em class="mq"> first_branch </em>合并到 GitHub 上的<em class="mq"> main </em>分支后，我们的<em class="mq"> main </em>分支现在用来自我们<em class="mq"> first_branch </em>的代码更新。然而，我们本地机器上的存储库不知道我们的主<em class="mq">分支</em>的更新。为了将本地机器上的<em class="mq">主</em>分支与<em class="mq">主</em>分支在线同步，我们将“<strong class="lj jt">git check out main”</strong>切换回我们的<em class="mq">主</em>分支，然后使用“<strong class="lj jt">git pull”</strong>命令获取更新的更改:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/e724ffa7fbe757a5c2b48d0a362c4df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*3N4Eid6TRnJ5k2wbV35uTg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)在合并拉请求之后，从 first_branch 切换回 main，(2)然后在 main 分支上运行“git pull”来拉下合并的变更</p></figure><p id="24bf" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在消息中你可以看到有一个文件发生了变化，这是我们合并到<em class="mq">主</em>的<em class="mq"> first_branch </em>中新添加的 app.sh 文件。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="59d7" class="ng nh jj bd ni nj nk nl nm nn no np nq ky nr kz ns lb nt lc nu le nv lf nw nx bi translated">4.当自动合并不可能时</h1><p id="2d15" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated">这次合并很容易，因为我们没有任何冲突。如果两个开发人员对<em class="mq">主</em>分支做出了冲突的变更，我们将如何解决冲突？</p><p id="1fe7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在下图中，你会看到我首先创建了两个主分支:<em class="mq">第二个分支</em> &amp; <em class="mq">第三个分支</em>。然后，我切换到<em class="mq">第二分支</em>，并将消息从“<strong class="lj jt"> Hello world </strong>”更改为“<strong class="lj jt"> Hello world from second branch！</strong>”。现在我已经做了这个更改，我"<strong class="lj jt"> git add。"</strong>选择所有要提交的更改，然后我"<strong class="lj jt">git commit-m ' update app . sh '</strong>"在<em class="mq"> second_branch </em>上创建提交。然后我尝试"<strong class="lj jt"> git push </strong>"知道它会失败，因为我没有设置上游-但是它会给我设置上游的命令，并第一次将我的<em class="mq"> second_branch </em>推送到 GitHub:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/2b5328915e17b1e43a97027afc0deb3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*wYJouJYSbpXA26ZkywncDg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)创建 second_branch，(2)创建 third_branch，(3)切换到 second_branch，(4)用 vi 编辑 app.sh，(5) git add 选择我更改的要提交的文件，(6)提交 app.sh 文件更改，(7)明知会失败仍尝试推送，(8)复制命令以设置上游并推送 second_branch</p></figure><p id="c2e2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">项目的当前状态是<em class="mq">主</em>分支仍然有<strong class="lj jt"> app.sh </strong>和消息“<strong class="lj jt"> Hello world </strong>”，而<em class="mq">次 _ 分支</em>有来自次分支的更新消息“<strong class="lj jt"> Hello world！</strong>”。我们已经推出了第二个分支。如果我们愿意，我们可以立即将<em class="mq"> second_branch </em>合并到<em class="mq"> main </em>中，而不会像第一次那样发生冲突。然而，我们想要模拟一个冲突的变化。回到我们的终端或 git bash，让我们切换到<em class="mq"> third_branch </em>并添加另一个更改:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/68cc0dc5458113441e33b47084543b30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*uAsDxxX4Ds0x-U8VuRgQJg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)切换到 third_branch，(2)使用 vi 编辑 app.sh，(3)运行 shell 脚本以查看更改，(4) git 添加要提交的文件，(5)将文件提交到 third_branch，(6)明知推送会失败仍尝试推送，(7)从错误消息中获取设置上游的命令，并将我们的新 third_branch 推送到 GitHub</p></figure><p id="4e26" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在上面的图片中，你会看到我切换到<em class="mq"> third_banch </em>并更改了消息“<strong class="lj jt"> Hello World！</strong>【到】<strong class="lj jt">你好来自第三分局！</strong>"在 vi 编辑器中。信息是"<strong class="lj jt">你好，世界！</strong>“因为我们创建了<em class="mq">第三 _ 分支</em>作为<em class="mq">主</em>分支的副本——它不知道我们对<em class="mq">第二 _ 分支</em>所做的更改。在设置我们的上游并将我们的<em class="mq">第三 _ 分支</em>推送到 GitHub 之后，我们的 GitHub 页面将会为我们的两个更新分支中的每一个分支提供一个“<strong class="lj jt">比较&amp;拉取请求</strong>”提示，如下所示:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pg"><img src="../Images/0fbbe4031e8026320501e2d8d208c19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9teR0nmJdNFA0V1ua22_yA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">看到两个分支都成功推送到 GitHub</p></figure><p id="645f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">先合并<em class="mq"> second_branch </em>吧。我们点击相应的“<strong class="lj jt">比较&amp;拉动请求</strong>按钮，然后我们看到绿色的“<strong class="lj jt">能够合并。</strong>"间<em class="mq">主</em> &amp; <em class="mq">次 _ 分支</em>下一页:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/d2533514be8a00f8b81b9c7249c59d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mW49kkfCNrkyCH4xsS9SYw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">注意 second_branch 能够自动合并</p></figure><p id="2d91" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们点击绿色的“<strong class="lj jt">打开拉式请求</strong> t”按钮，然后点击“<strong class="lj jt">合并拉式请求</strong>”按钮，并且<em class="mq">第二 _ 分支</em>自动合并到<em class="mq">主</em>中，因为没有冲突的变更。之后，我们的<em class="mq">主</em>分支<strong class="lj jt"> app.sh </strong>会有“<strong class="lj jt">回音‘来自二分支的你好世界！’</strong>”。</p><p id="65e3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，让我们单击 GitHub 页面上看到的<em class="mq"> third_branch </em>提示符的绿色“<strong class="lj jt">Compare&amp;pull request</strong>”按钮。现在代替绿色的<strong class="lj jt">能够合并。</strong>“我们习以为常的消息—我们会看到红色的“<strong class="lj jt">无法自动合并</strong>”消息:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/a25c8df5936126fa938d896a2832eb4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXCTtXIeAsq63LGNSk-7dQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">无法自动合并，因为我们对 third_branch 所做的更改与我们对已经合并的 second_branch 所做的更改相冲突</p></figure><p id="dd0e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果 GitHub 不能自动合并我们的分支，我们就不应该创建 pull 请求。相反，我们应该在本地存储库中解决<em class="mq"> third_branch </em>中的合并冲突，然后将我们的更改推送到 GitHub。这意味着——我们应该用来自<em class="mq">主</em>分支的最新变化更新我们的<em class="mq">第三分支</em>,然后将结果<em class="mq">第三分支</em>推送到 GitHub。这个更新的<em class="mq"> third_branch </em>将能够自动与<em class="mq"> main 合并。</em></p><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/116bdb7e103f121ed4dac8bf642e7994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*EghaI3I-nKR4ANtx5A6faA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)将主分支的最新更改拉入 third_branch，这样我们可以解决冲突，(2)运行“git status”来查看哪些文件是冲突的</p></figure><p id="9444" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">上面你会看到我从第三个分支开始。从那里我运行"<strong class="lj jt">git pull origin main</strong>"——这意味着在线访问 GitHub 存储库，并将<em class="mq"> main </em>分支上的更改拉入当前分支。如果你看看我的 git bash 中括号内的绿色消息——它从“<strong class="lj jt"> (third_branch) </strong>”变成了“<strong class="lj jt">(third _ branch *+| MERGING)</strong>”，因为我们现在正在本地将<em class="mq"> main </em>合并到<em class="mq"> third_branch </em>中，而不是在 GitHub 上。运行“<strong class="lj jt"> git status </strong>”将向我们显示合并中的冲突文件，但在这种情况下，唯一的冲突文件是<strong class="lj jt"> app.sh </strong>。让我们看看<strong class="lj jt"> app.sh </strong>内部的冲突是什么:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/186e04df32ed25ef854d61874a543f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*CBjbeMcGAoEvzAgVeTIKdw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)使用“cat”命令查看冲突文件 app.sh 的内容</p></figure><p id="d529" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如您在上面看到的，git 自动将所有冲突的更改放到我们的文件中。&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD” and “||||||| fd0f83b” you can see the changes from <em class="mq">第三 _ 分支</em>之间。在“|||||| fd0f83b”和“=======”之间可以看到<em class="mq"> third_branch </em>最初从<em class="mq"> main </em>分支时的原始状态。最后，在“=======”和“&gt;&gt;&gt;&gt;&gt;&gt;&gt;6126…”之间，可以看到<em class="mq">主</em>分支的当前状态。</p><p id="873b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Git 不知道哪个更改是正确的，这就是为什么它不能自动为我们合并代码。Git 向我们展示了所有的变更，因此我们可以自己决定保留哪些变更。因此，我将删除除了来自<em class="mq">第三 _ 分支</em>的最新更改之外的所有内容:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/7e32f2871b105c84b52ab6c1aed1740f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*Iqr-f3VGuS7q-6NlYW8HUA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)使用 vi 来编辑文件以删除除了 third_branch 内容之外的所有内容，(2)使用“cat”来查看更新的文件</p></figure><p id="3a9d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在我们已经解决了合并冲突，我们可以<strong class="lj jt"> git 添加</strong>、<strong class="lj jt"> git 提交</strong>，以及<strong class="lj jt"> git 推送</strong>我们手动合并的代码:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/5ccceca9b8df294f5f5b9f5268cac9e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*1yvuBTCW7huJosbEYkubLA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)使用 git add 选择要提交的更新文件，(2)使用描述变更的消息提交更新文件，(3)将对 third_branch 的变更推送到 GitHub</p></figure><p id="43e9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">将<em class="mq"> third_branch </em>推至 GitHub，会提示我们点击“<strong class="lj jt">比较&amp;拉取请求</strong>按钮:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pl"><img src="../Images/37ac7723d0c0103c1d0ab09b7ec1a8a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMOJoXzcodKn9GdxrN3rxg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">看到在 GitHub 上为我们更新的 third_branch 创建一个拉请求的消息</p></figure><p id="936e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在打开<em class="mq">第三分支</em>和<em class="mq">主</em>之间的新拉动请求后，我们看到绿色的“<strong class="lj jt">能够合并</strong>”消息，因为我们的冲突现已解决:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pm"><img src="../Images/b6087785dc31c07ffed9bf7d8bba51ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oc6l3xUZtd68ZoP8DbUA5A.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">我们现在能够自动合并，因为我们解决了我们的冲突变更</p></figure><p id="f496" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以点击<strong class="lj jt">创建拉式请求</strong>按钮。在“拉取请求”页面上，我们可以单击“<strong class="lj jt">合并拉取请求</strong>”，我们的更改将自动合并到<em class="mq"> main </em>中。现在我们已经合并了我们的 pull 请求，我们可以返回到我们的 terminal/git bash，并将本地存储库的主分支与在线存储库同步:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/079689db21cbfde49366377f68a02b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*Zv017qjKvcCT0EVbWKpUVA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(1)切换主分支，(2)使用“git pull”来更新我们的本地 git 存储库，我们将这些更改合并到 GitHub 上的主分支中</p></figure></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="bd06" class="ng nh jj bd ni nj nk nl nm nn no np nq ky nr kz ns lb nt lc nu le nv lf nw nx bi translated">5.其他需要了解的有用信息</h1><p id="650e" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated">完成前四个步骤后，我们可以返回 GitHub，点击工具栏选项中的<strong class="lj jt">提交</strong>，我们会看到:</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi po"><img src="../Images/3630964ac0863c1f6f8ccdc7fe2a9f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o1Y-CuUPJop88LpzV6fDUg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">查看主分支上的所有提交，并查看我们创建的合并提交</p></figure><p id="ce16" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这里我们可以看到<em class="mq">主</em>分支上的所有提交，并且我们可以切换到其他分支来查看它们的提交。当学习使用 Git 和 GitHub 进行协作时——理解项目的历史如何随时间演变是很重要的。我鼓励你查看每个“<strong class="lj jt">合并拉取请求</strong>”提交，看看合并拉取请求如何改变项目的历史。</p><p id="85f8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">GitHub 上另一个有用的页面是分支页面，你可以从你的 GitHub 库主页点击<a class="ae jg" href="https://github.com/ClairvoyantCoding/How_To_Manage_A_Shared_Codebase_Article/branches" rel="noopener ugc nofollow" target="_blank">工具栏选项<strong class="lj jt">分支</strong>进入。在这里，我们可以看到我们推送到 GitHub 的所有分支——您会注意到，所有分支都已经被合并了。通常在我们合并一个分支后，我们可以通过点击下面的红色垃圾桶图标来删除这个分支。</a></p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pp"><img src="../Images/ca500f5c43de9e0325d5eb869edcb710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvC-VmzJuoSXeEyNh24MGQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">查看 GitHub 上的所有分支</p></figure></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="c529" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">感谢阅读！我很乐意听到你的反馈或回答你的任何问题，所以请在下面评论，我会尽力帮助你。</p></div></div>    
</body>
</html>