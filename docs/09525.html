<html>
<head>
<title>Transformations with OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 OpenCV 进行转换</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/transformations-with-opencv-ff9a7bea7f8b?source=collection_archive---------22-----------------------#2020-07-07">https://towardsdatascience.com/transformations-with-opencv-ff9a7bea7f8b?source=collection_archive---------22-----------------------#2020-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4d62" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何用 Python 的 OpenCV 转换图像的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/ab83a36bac3d73af136bb0a5e20507c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*ygPa5ysYhOj9i4Dn78pvVw.png"/></div></figure><p id="d5a8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你曾经不得不使用一个可以位图化的图像增强器，你可能知道这有多困难。在本文中，我们将了解变换，并探索移动、旋转、裁剪和调整大小等内容。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h2 id="07cc" class="lu lv it bd lw lx ly dn lz ma mb dp mc kz md me mf ld mg mh mi lh mj mk ml mm bi translated">要求</h2><p id="c6a5" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">对于示例，我们将使用 OpenCV、NumPy 和 Matplotlib。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3677" class="lu lv it mt b gy mx my l mz na">import cv2<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span></pre><p id="2624" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lm" rel="noopener" target="_blank" href="/getting-started-with-opencv-249e86bd4293">在这里</a>，我学习了 OpenCV 的一些基础知识，比如读取、显示和修改图像的一些属性。本文中的例子将从那里开始，但我认为你不需要阅读它来跟上这一点。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h2 id="5e54" class="lu lv it bd lw lx ly dn lz ma mb dp mc kz md me mf ld mg mh mi lh mj mk ml mm bi translated">变换矩阵</h2><p id="a226" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">从一些简单的东西开始，我们将读取图像并将颜色序列从 BGR 转换为 RGB。</p><p id="7348" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然后，我们将构建一个包含图像变换信息的变换矩阵。为简单起见，我们可以将该矩阵视为:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="958c" class="lu lv it mt b gy mx my l mz na">[[size, rotation, location], ←x-axis<br/>[rotation, size, location]] ←y-axis</span></pre><p id="3a4b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">默认矩阵或不会改变任何东西的矩阵是:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="dbe0" class="lu lv it mt b gy mx my l mz na">[[1, 0, 0]<br/> [0, 1, 0]]</span></pre><p id="35b5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这意味着，100%的大小，零旋转，位置不变——再一次，我过于简化了。</p><p id="4612" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们算出矩阵后，我们可以用。形状和用途。warpAffine 来转换图像。</p><p id="e639" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们检查一个没有任何转换的例子，以了解这个过程。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3b54" class="lu lv it mt b gy mx my l mz na"># read img and convert color<br/>img = cv2.imread('img3.jpeg')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><span id="b0d1" class="lu lv it mt b gy nb my l mz na"># build a transformation matrix<br/>matrix = [[1, 0, 0], #x <br/>          [0, 1, 0]] #y<br/>t = np.float32(matrix)</span><span id="e61f" class="lu lv it mt b gy nb my l mz na"># get the sizes<br/>h, w = img.shape[:2]</span><span id="5394" class="lu lv it mt b gy nb my l mz na"># transform<br/>img = cv2.warpAffine(img, t, (w, h))</span><span id="294c" class="lu lv it mt b gy nb my l mz na"># plot<br/>fig, ax = plt.subplots(1, figsize=(12,8))<br/>ax.axis('off')   <br/>plt.imshow(img)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/76d63b676ebe51f66839e9198524121f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQkv26y0zo_gKvAORVPBaQ.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated"><a class="ae lm" href="https://pixabay.com/photos/cassettes-tinge-magnetband-hifi-5148602/" rel="noopener ugc nofollow" target="_blank">Bru-nO 拍摄的图片</a></p></figure><p id="74d6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">好吧，我们可以试着移动它。我们会用不同的矩阵重复所有的事情。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="488b" class="lu lv it mt b gy mx my l mz na"># Change location<br/>matrix = [[1, 0, <strong class="mt iu">300</strong>], #x <br/>          [0, 1, <strong class="mt iu">-300</strong>]] #y</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nl"><img src="../Images/67f33153c1bdd9c5633fc563094fcb9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQycXsPMNcYD7okDyawzfw.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">移动图像。</p></figure><p id="c917" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，让我们改变一切，看看它是如何工作的。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="60f8" class="lu lv it mt b gy mx my l mz na"># Change size, rotation, and location<br/>matrix = [[0.5, 0.3, 450], #x <br/>          [-0.3, 0.5, 600]] #y</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nm"><img src="../Images/e092f30cfdb67226397d7c0882735bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eRBAsB53wj2WmiHRdI2z1w.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">移动、旋转和缩放图像。</p></figure><p id="6b16" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有意思。你可能已经注意到我们有两种不同的“尺寸”——让我们来看看它们有什么不同。</p><p id="b390" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以在矩阵中将宽度缩放 0.5。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0222" class="lu lv it mt b gy mx my l mz na">matrix = [[<strong class="mt iu">0.5</strong>, 0, 0], #x <br/>          [0, 1, 0]]   #y</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nn"><img src="../Images/77591cfb41fc220e9fec5403bd2ab9ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ayLAoz6zhyDRhkV3JYfw1Q.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">按 0.5 缩放的宽度。</p></figure><p id="4140" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以把宽度除以 2 英寸。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6e50" class="lu lv it mt b gy mx my l mz na">img = cv2.warpAffine(img, T, (<strong class="mt iu">int(w/2)</strong>, h))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/88d7b12d092a5445675f2f1db5cd44ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*89_Yqh78BfddwOiJZqus2A.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">宽度除以 2。</p></figure><p id="e5a3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我想理解转换矩阵是必要的，但是它有点过于复杂了。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h2 id="32d8" class="lu lv it bd lw lx ly dn lz ma mb dp mc kz md me mf ld mg mh mi lh mj mk ml mm bi translated">旋转</h2><p id="2c66" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">OpenCV 有一些更方便的方法来构建它，比如 getRotationMatrix2D 方法，我们可以在一个方法中设置所需的图像位置、旋转角度和缩放因子。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e960" class="lu lv it mt b gy mx my l mz na">img = cv2.imread('Images/3.jpg')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><span id="670b" class="lu lv it mt b gy nb my l mz na">h, w = img.shape[:2]</span><span id="fa7c" class="lu lv it mt b gy nb my l mz na"># (w/2, h/2) -&gt; center of the image<strong class="mt iu"><br/>T = cv2.getRotationMatrix2D((w/2, h/2), 90, .5)</strong></span><span id="f905" class="lu lv it mt b gy nb my l mz na">img = cv2.warpAffine(img, T, (w, h))</span><span id="34cd" class="lu lv it mt b gy nb my l mz na">fig, ax = plt.subplots(1, figsize=(12,8))<br/>ax.axis('off')   <br/>plt.imshow(img)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nl"><img src="../Images/6b36cf3b2d1f20644e9984bf53c4e743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUhkYOSd13hBBBj9Hb3juA.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">移动、旋转和缩放图像。</p></figure><p id="7c43" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果我们只需要将整个画面旋转 90 度。trasponse 是一种更简便的方法。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c7d4" class="lu lv it mt b gy mx my l mz na">img = cv2.imread('Images/3.jpg')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><span id="a241" class="lu lv it mt b gy nb my l mz na">img = cv2.transpose(img)</span><span id="3019" class="lu lv it mt b gy nb my l mz na">fig, ax = plt.subplots(1, figsize=(12,8))<br/>ax.axis('off')   <br/>plt.imshow(img)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/d6353ebe2a86512bc716410b90b95d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*l8gqgJOgdcfQDiDTYaqAdw.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">转置图像。</p></figure></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h2 id="4630" class="lu lv it bd lw lx ly dn lz ma mb dp mc kz md me mf ld mg mh mi lh mj mk ml mm bi translated">镜子</h2><p id="7f09" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">我们可以创造一种镜像效果，比如倒影。我们只需要。随着图像和我们想要反映的方向翻转。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="41cf" class="lu lv it mt b gy mx my l mz na">img = cv2.imread('Images/2.jpeg')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><span id="22c8" class="lu lv it mt b gy nb my l mz na">fig, ax = plt.subplots(1, figsize=(12,12))</span><span id="354d" class="lu lv it mt b gy nb my l mz na">ax = plt.subplot(221) <br/>plt.imshow(img)</span><span id="594e" class="lu lv it mt b gy nb my l mz na">img2 = cv2.flip(img, 1)<br/>ax = plt.subplot(222) <br/>plt.imshow(img2)</span><span id="3ba4" class="lu lv it mt b gy nb my l mz na">img3 = cv2.flip(img, 0)<br/>ax = plt.subplot(223) <br/>plt.imshow(img3)</span><span id="d843" class="lu lv it mt b gy nb my l mz na">img4 = cv2.flip(img, -1)<br/>ax = plt.subplot(224) <br/>plt.imshow(img4)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nq"><img src="../Images/d0e0ca2efe348bbb88694a767773fc3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NrnZ6HPW9tRctuJZrXvGWA.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">原始图像和镜像图像。图片由<a class="ae lm" href="https://www.pexels.com/photo/happy-young-indian-couple-looking-at-camera-4312847/" rel="noopener ugc nofollow" target="_blank">赖爷 Subiyanto </a></p></figure></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h2 id="50f1" class="lu lv it bd lw lx ly dn lz ma mb dp mc kz md me mf ld mg mh mi lh mj mk ml mm bi translated">种植</h2><p id="03aa" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">很多时候，我们可能需要图像的特定部分，而不是整个图像。如果是这种情况，我们可以通过分割 NumPy 数组轻松地裁剪图片。</p><p id="9ad3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">切片的第一部分与高度有关，所以如果我们把它看作一个表格，它就像行号，第二部分指的是宽度，所以它就像列号。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d6f2" class="lu lv it mt b gy mx my l mz na">img = cv2.imread('Images/2.jpeg')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><span id="a988" class="lu lv it mt b gy nb my l mz na">fig, ax = plt.subplots(1, figsize=(12,8))<br/>ax.axis('off')</span><span id="8fed" class="lu lv it mt b gy nb my l mz na"># [height start: height end, width start: width end]<br/># [first row : last row, first column: last column]<br/>plt.imshow(img<strong class="mt iu">[500:1000, 250:500]</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/d1a135c6879245dddfac7a2cddfab56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*UDYluVkyzijyy3jap4dCHA.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">裁剪的图像。</p></figure><p id="af37" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">猜测我们希望从哪个像素开始和结束裁剪并不是最佳选择，所以让我们构建一个简单的缩放函数来理解我们如何系统地完成这项工作。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9716" class="lu lv it mt b gy mx my l mz na"># scale function<br/><strong class="mt iu">def px(size, proportion):<br/>    return int(size * proportion)</strong></span><span id="8a42" class="lu lv it mt b gy nb my l mz na"># read, convert and get height/ width<br/>img = cv2.imread('Images/2.jpeg')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)<br/>h, w = img.shape[:2]</span><span id="4183" class="lu lv it mt b gy nb my l mz na"># crop<br/>img = img[<strong class="mt iu">px(h, .25):px(h, .40)</strong>, #25% to 40%<br/>          <strong class="mt iu">px(w, .10):px(w, .35)</strong>] #10% to 35%</span><span id="bbf8" class="lu lv it mt b gy nb my l mz na"># plot<br/>fig, ax = plt.subplots(1, figsize=(12,8))<br/>ax.axis('off')   <br/>plt.imshow(img)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/0a72f629401e9f4f64e10ca41269ba45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*SE3fMAy6DnmsUWeWI5cGhw.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">用函数裁剪</p></figure></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h2 id="6756" class="lu lv it bd lw lx ly dn lz ma mb dp mc kz md me mf ld mg mh mi lh mj mk ml mm bi translated">调整大小</h2><p id="6606" class="pw-post-body-paragraph kq kr it ks b kt mn ju kv kw mo jx ky kz mp lb lc ld mq lf lg lh mr lj lk ll im bi translated">默认情况下，调整大小是通过线性插值实现的，但是我们也可以尝试其他方法来看看它们之间的区别。</p><p id="608d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们尝试使用。resize。我们需要图像和所需的大小，在这里我们可以指定我们想要的插值方法。尺寸可以是新照片的尺寸，也可以是 x 和 y 的比例因子。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="217a" class="lu lv it mt b gy mx my l mz na"># read, convert and get height/ width<br/>img = cv2.imread('Images/2.jpeg')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)<br/>h, w = img.shape[:2]</span><span id="9638" class="lu lv it mt b gy nb my l mz na"># crop<br/>img = img[px(h, .33):px(h, .35), <br/>          px(w, .18):px(w, .25)]</span><span id="5759" class="lu lv it mt b gy nb my l mz na"># figure<br/>fig, ax = plt.subplots(1, figsize=(12,16))</span><span id="75ae" class="lu lv it mt b gy nb my l mz na"># resize - nearest<br/>ax = plt.subplot(311)<strong class="mt iu"><br/>img_scaled = cv2.resize(img, None, fx=3, fy=3, interpolation = cv2.INTER_NEAREST)</strong><br/>plt.imshow(img_scaled)<br/>plt.title('nearest')</span><span id="3af9" class="lu lv it mt b gy nb my l mz na"># resize - default/ linear<br/>ax = plt.subplot(312)<br/><strong class="mt iu">img_scaled = cv2.resize(img, None, fx=3, fy=3)<br/></strong>plt.imshow(img_scaled)<br/>plt.title('default/ linear')</span><span id="4bd5" class="lu lv it mt b gy nb my l mz na"># resize - cubic<br/>ax = plt.subplot(313)<br/><strong class="mt iu">img_scaled = cv2.resize(img, None, fx=3, fy=3, interpolation = cv2.INTER_CUBIC)<br/></strong>plt.imshow(img_scaled)<br/>plt.title('cubic')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/f6a475b5a15a80305db3494764bb60dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*JMiaFl44K85Lmvc8u7DASQ.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">不同的插值。</p></figure><p id="1ff3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">另一种调整大小的方法是使用金字塔。让我们快速看一下这是如何工作的。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0545" class="lu lv it mt b gy mx my l mz na"># read and convert<br/>img = cv2.imread('Images/ufo.jpg')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><span id="c4f6" class="lu lv it mt b gy nb my l mz na"># crop<br/>img = img[50:150, 200:400]</span><span id="81ad" class="lu lv it mt b gy nb my l mz na"># figure<br/>fig, ax = plt.subplots(1, figsize=(12,12))</span><span id="222c" class="lu lv it mt b gy nb my l mz na"># img<br/>ax = plt.subplot(311)<br/>plt.imshow(img)<br/>plt.title('regular size')</span><span id="c0f9" class="lu lv it mt b gy nb my l mz na"># downsize<br/><strong class="mt iu">small = cv2.pyrDown(img)</strong></span><span id="ccd4" class="lu lv it mt b gy nb my l mz na">ax = plt.subplot(312)<br/>plt.imshow(small)<br/>plt.title('smaller')</span><span id="9f4e" class="lu lv it mt b gy nb my l mz na"># upsize<br/><strong class="mt iu">regular = cv2.pyrUp(small)</strong></span><span id="5cd9" class="lu lv it mt b gy nb my l mz na">ax = plt.subplot(313)<br/>plt.imshow(regular)<br/>plt.title('regular again')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/fae0881debe4b422b35b786d1a6fb231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*wvuE849SG1fuOZG5H1hemQ.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">金字塔法— <a class="ae lm" href="https://upload.wikimedia.org/wikipedia/commons/d/df/PurportedUFO2.jpg" rel="noopener ugc nofollow" target="_blank">原图来自维基百科</a></p></figure><p id="c0c5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以看到，就像其他方法一样，分辨率有一些损失，但总的来说这是一个很好的方法。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="402f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">好的，在我们结束前再来一个。</p><p id="d9fd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对我们的数组进行切片不仅对裁剪有用，我们还可以用它来操作图像的特定部分，甚至用切片来替换不同的部分。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e7a8" class="lu lv it mt b gy mx my l mz na"># read and convert<br/>img = cv2.imread('Images/ufo.jpg')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><span id="244b" class="lu lv it mt b gy nb my l mz na">img2 = cv2.imread('Images/8.jpg')<br/>img2 = cv2.cvtColor(img2, cv2.COLOR_BGR2RGB)</span><span id="d172" class="lu lv it mt b gy nb my l mz na"># replace<br/>img2[200:250, 1000:1100] = small</span><span id="29a2" class="lu lv it mt b gy nb my l mz na"># plot<br/>fig, ax = plt.subplots(1, figsize=(12,12))<br/>plt.imshow(img2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nm"><img src="../Images/df6fc504ef266c10d1a0fddeb2bc7260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ksm20vsB18HrMXmP-DCxQ.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated"><a class="ae lm" href="https://unsplash.com/photos/Y_7wXiRn_J8" rel="noopener ugc nofollow" target="_blank">图片由马克·阿斯特霍夫</a>(没有飞碟)</p></figure></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="cdd7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">好了，我们看到了如何移动、旋转和调整图像大小。我们还了解了裁剪、镜像以及如何处理图片的切片。</p><p id="0352" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">感谢阅读我的文章。我希望你喜欢它。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="66fd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">参考资料:<br/>T5】OpenCV 几何图像变换；<br/> <a class="ae lm" href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html" rel="noopener ugc nofollow" target="_blank"> OpenCV 对数组的操作</a>；<br/> <a class="ae lm" href="https://docs.opencv.org/4.2.0/js_contour_properties_transpose.html" rel="noopener ugc nofollow" target="_blank"> OpenCV 转置示例</a>；<br/> <a class="ae lm" href="https://docs.opencv.org/2.4/doc/tutorials/imgproc/pyramids/pyramids.html" rel="noopener ugc nofollow" target="_blank"> OpenCV 金字塔</a>；</p></div></div>    
</body>
</html>