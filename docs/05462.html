<html>
<head>
<title>How To Check For Missing Values In Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何检查熊猫中缺失的值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-check-for-missing-values-in-pandas-d2749e45a345?source=collection_archive---------11-----------------------#2020-05-08">https://towardsdatascience.com/how-to-check-for-missing-values-in-pandas-d2749e45a345?source=collection_archive---------11-----------------------#2020-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cba7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何发现和鉴定熊猫缺失值的介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/59ec7da1345285a589dfe7239cadb827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Idfio71gHLWnAKkDRuKTBg.png"/></div></div></figure><p id="7f74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">每一位数据科学家在日常工作中都会遇到问题。有必要弄清楚是否有遗漏，在哪里可以找到遗漏，以及遗漏发生的频率。基于此，数据科学家必须决定如何在进一步分析中处理缺失数据。</p><h2 id="5721" class="lz ma it bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">1)寻找失踪人员</h2><p id="d578" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">寻找缺失通常是数据分析的第一步。在开始时，问题是是否有任何遗漏，如果有，有多少。通常情况下，Pandas 提供了几种方法来确定错过的次数。根据数据帧的大小，性能会有很大的差异。首先，我们简单地期望结果为真或假，以检查是否有任何遗漏:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="264e" class="lz ma it my b gy nc nd l ne nf">df.isna().any().any()<br/>True</span></pre><p id="f686" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这正是我们想要的。现在我们知道有失踪，但执行花了多长时间？</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="8651" class="lz ma it my b gy nc nd l ne nf">%timeit df.isna().any().any()<br/>47.8 ms ± 1.24 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><p id="f3d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们来比较几种方法:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="f301" class="lz ma it my b gy nc nd l ne nf">%timeit df.isnull().any().any()<br/>46.2 ms ± 899 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span><span id="f0b1" class="lz ma it my b gy ng nd l ne nf">%timeit df.isnull().values.any()<br/>44.6 ms ± 731 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span><span id="ebc6" class="lz ma it my b gy ng nd l ne nf">%timeit df.isna().values.any()<br/>41.8 ms ± 229 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span><span id="eefc" class="lz ma it my b gy ng nd l ne nf">%timeit np.isnan(df.values).any()<br/>41.3 ms ± 368 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><blockquote class="nh ni nj"><p id="0993" class="ku kv nk kw b kx ky ju kz la lb jx lc nl le lf lg nm li lj lk nn lm ln lo lp im bi translated">我们试过五种不同的方法，结果都一样。带 Numpy 的版本比最慢的版本快 14 %。</p></blockquote><h2 id="3661" class="lz ma it bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">2)遗漏的频率(绝对)</h2><p id="8477" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我们已经在寻找丢失中看到了性能上的差异。第一步，我们只想知道是否有任何遗漏。现在我们还想知道我们的数据帧中有多少缺失。首先，我们再次看看我们期望的结果:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="0550" class="lz ma it my b gy nc nd l ne nf">df.isna().sum().sum()<br/>4600660</span></pre><p id="f639" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了这样的信息，我们具有 2500 万个单元(5000*5000)的数据帧包含大约 460 万个缺失。</p><p id="2119" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看这里的性能差异是否更大:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="533e" class="lz ma it my b gy nc nd l ne nf">%timeit df.isna().sum().sum()<br/>117 ms ± 2.15 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span><span id="1e3c" class="lz ma it my b gy ng nd l ne nf">%timeit df.isnull().sum().sum()<br/>115 ms ± 1.41 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span><span id="62e9" class="lz ma it my b gy ng nd l ne nf">%timeit np.isnan(df.values).sum()<br/>89 ms ± 706 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><blockquote class="nh ni nj"><p id="6301" class="ku kv nk kw b kx ky ju kz la lb jx lc nl le lf lg nm li lj lk nn lm ln lo lp im bi translated">同样，Numpy 版本是最快的版本。这一次 Numpy 版本大约快了 24 %。</p></blockquote><h2 id="12d3" class="lz ma it bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">3)缺失的频率(相对)</h2><p id="eb35" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">有时，您可能只想确定每列缺失的相对频率，以决定是简单地删除还是替换缺失:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="a874" class="lz ma it my b gy nc nd l ne nf">df.isna().sum()/(len(df))*100</span><span id="ea07" class="lz ma it my b gy ng nd l ne nf"><strong class="my iu">0       17.98<br/>1       18.90<br/>2       18.66<br/>3       18.02<br/>4       18.70<br/>        ...  <br/>4995    18.88<br/>4996    18.72<br/>4997    18.68<br/>4998    17.76<br/>4999    19.32</strong><br/>Length: 5000, dtype: float64</span></pre><p id="733f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了一个熊猫系列，我们可以随心所欲地处理它:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="56f3" class="lz ma it my b gy nc nd l ne nf">temp = df.isna().sum()/(len(df))*100</span><span id="0128" class="lz ma it my b gy ng nd l ne nf">print("Column with lowest amount of missings contains {} % missings.".format(temp.min()))<br/>print("Column with highest amount of missings contains {} % missings.".format(temp.max()))</span><span id="664a" class="lz ma it my b gy ng nd l ne nf"><strong class="my iu">Column with lowest amount of missings contains 16.54 % missings.<br/>Column with highest amount of missings contains 20.64 % missings.</strong></span></pre><blockquote class="nh ni nj"><p id="3e1f" class="ku kv nk kw b kx ky ju kz la lb jx lc nl le lf lg nm li lj lk nn lm ln lo lp im bi translated">Pandas 还可以用于量化和分析大型数据集中的缺失。</p></blockquote><h2 id="301e" class="lz ma it bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">4)确定有缺失的列</h2><p id="b0b2" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在某些情况下，确定缺失的列并将它们与其他列分开处理可能会很有用:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="efe1" class="lz ma it my b gy nc nd l ne nf">&gt;&gt;&gt; df.loc[:, df.isnull().any()].columns</span><span id="a87c" class="lz ma it my b gy ng nd l ne nf">Int64Index(<strong class="my iu">[   0,    1,    2,    3,    4,    5,    6,    7,    8,    9,<br/>            ...<br/>            4990, 4991, 4992, 4993, 4994, 4995, 4996, 4997, 4998, 4999]</strong>,<br/>           dtype='int64', length=5000)</span></pre><p id="3f40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，结果当然不那么令人兴奋—我们在每一列中都有一个缺失。</p><h2 id="f338" class="lz ma it bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">5)显示缺失的行</h2><p id="d438" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在数据分析的最后一步，您可能希望查看单个案例，以了解为什么会有遗漏以及如何处理它们:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="cd11" class="lz ma it my b gy nc nd l ne nf">&gt;&gt;&gt; df.dropna()<br/>Empty DataFrame<br/>Columns: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, ...]<br/>Index: []</span><span id="f5eb" class="lz ma it my b gy ng nd l ne nf"><strong class="my iu">[0 rows x 5000 columns]</strong></span></pre><p id="5c79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，我们的数据集中没有每列都包含缺失的行。在下一步中，我们可以指定要检查缺失的列:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="ce79" class="lz ma it my b gy nc nd l ne nf">&gt;&gt;&gt; df.dropna(subset=[1]).head(5)<br/>     0     1     2     3     4     5     ...  4994  4995  4996  4997  4998  4999<br/>10    NaN   0.0   NaN   NaN   NaN   NaN  ...   NaN   NaN   NaN   NaN   NaN   NaN<br/>136   NaN   0.0   NaN   NaN   NaN   NaN  ...   NaN   NaN   NaN   NaN   NaN   NaN<br/>431   NaN   0.0   NaN   NaN   NaN   NaN  ...   NaN   NaN   NaN   NaN   NaN   NaN<br/>435   NaN   0.0   NaN   NaN   NaN   NaN  ...   NaN   NaN   NaN   0.0   NaN   NaN<br/>474   NaN   0.0   NaN   NaN   NaN   NaN  ...   NaN   NaN   NaN   NaN   NaN   NaN</span><span id="bf99" class="lz ma it my b gy ng nd l ne nf"><strong class="my iu">[5 rows x 5000 columns]</strong></span></pre><blockquote class="nh ni nj"><p id="c45f" class="ku kv nk kw b kx ky ju kz la lb jx lc nl le lf lg nm li lj lk nn lm ln lo lp im bi translated">如果不为 dropna 函数指定列，将得到只包含缺失的行。为了进一步分析，指定一个或多个列作为子集是有意义的。</p></blockquote><h2 id="9052" class="lz ma it bd mb mc md dn me mf mg dp mh ld mi mj mk lh ml mm mn ll mo mp mq mr bi translated">结论</h2><p id="49ad" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我们已经知道如何确定数据帧中是否有缺失，如果有，有多少。Numpy 变体在每种情况下都是最快的，尽管性能差异只有在数据帧非常大的情况下才变得明显。</p><p id="36ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还看到，我们有无数的可能性以其他方式量化和可视化错过的数量。此外，我们还可以检查个别案例，以决定如何进一步进行分析。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="29db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae nv" href="https://medium.com/@droste.benedikt/membership" rel="noopener">如果您喜欢中级和高级数据科学，并且还没有注册，请随时使用我的推荐链接加入社区。</a></p></div></div>    
</body>
</html>