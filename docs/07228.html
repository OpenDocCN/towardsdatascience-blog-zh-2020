<html>
<head>
<title>Datetime2 — Why You Should (Not) Use It?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Datetime2 —为什么应该(不应该)使用它？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/datetime2-why-you-should-not-use-it-70e50ae2bab9?source=collection_archive---------3-----------------------#2020-06-02">https://towardsdatascience.com/datetime2-why-you-should-not-use-it-70e50ae2bab9?source=collection_archive---------3-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1c2b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">选择正确的数据类型并不像您第一眼看到的那样简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/67316582b24d235d164f58ef823aefdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Y-YXXBryiJfMx8XxbhPPw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔恩·泰森在<a class="ae ky" href="https://unsplash.com/s/photos/time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="61b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几周前，我正在处理一个业务请求，为客户调查准备一个数据集成场景。在最初的概念阶段和逻辑数据建模之后，在物理数据建模阶段，我在考虑既能满足业务需求又能确保SQL Server资源得到最佳利用的某些数据类型。</p><p id="1aa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的建议是对所有Datetime列使用<em class="lv"> Datetime2 </em>数据类型，而我的老板坚持使用老式的<em class="lv"> Datetime </em>。我想，他是一个老派的家伙，习惯于使用传统的数据类型，所以我将证明他是错的，并说服他改用更新的(顺便说一下，也是微软推荐的)数据类型。</p><h2 id="2557" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">介绍</h2><p id="3c7b" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在继续之前，我需要简要强调一下<em class="lv"> Datetime </em>和<em class="lv"> Datetime2 </em>数据类型之间的主要特征和差异。</p><p id="d7fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下表给出了这两者的简要概述:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/2bedd36ee2b2ff57905719053b843084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8CUg1pIQWk4qwyD2Xvldw.jpeg"/></div></div></figure><h2 id="6a3b" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">日期时间</h2><p id="a48f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><em class="lv"> Datetime </em>是一种“传统”数据类型，用于存储关于日期和时间的数据。它占用8个字节的内存，4个字节用于日期部分，4个字节用于时间部分。</p><p id="b2c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们来看看幕后发生了什么:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="687c" class="lw lx it mw b gy na nb l nc nd">DECLARE @dt DATETIME = '2020-05-28 12:00:00.000';<br/>SELECT CAST(@dt as varbinary(8));</span></pre><p id="5831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到了以下十六进制值:0x0000ABC900C5C100</p><p id="8418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们取前8个字符(0000ABC9)并将其转换为十进制，我们将得到43977个整数值。该值显示自1900–01–01以来的天数，可以按如下方式进行测试:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d38c" class="lw lx it mw b gy na nb l nc nd">SELECT DATEADD(DD, 43977, '1900-01-01') AS DateTimeTest</span></pre><p id="a322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到我们之前“定义”的日期(2020年5月28日)就在那里。</p><p id="abb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查时间部分，去掉最后8个字符(00C5C100)。把它转换成十进制，得到12960000。这个数字表示从午夜开始的时钟滴答数。而且，由于精度为1/300秒，我们可以进行以下计算，以获得更多人类可读的结果:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="130a" class="lw lx it mw b gy na nb l nc nd">SELECT 12960000/ 300 AS SecFromMidnight<br/>      ,12960000/ ( 300 * 60) AS MinsFromMidnight<br/>      ,12960000/ ( 300 * 60 * 60) as HoursFromMidnight</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/c1b7da0c8b2040840da8a21bb9e9484d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TiPu8xGC-O1X4AixJNqX8g.png"/></div></div></figure><p id="3e98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们将这个时间部分“添加”到前一个日期部分，我们将得到2020–05–28 12:00:00.000，就像第一个声明中一样。</p><h2 id="0b85" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">日期时间2</h2><p id="6a4b" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><em class="lv"> Datetime2 </em>是在SQL Server 2008中引入的，所以它在这里足够长，可以与它的“哥哥”进行一些比较。主要区别在于数据存储的方式:在<em class="lv"> Datetime </em>类型中，先日期后时间，在<em class="lv"> Datetime2 </em>中，3个字节，最后表示日期部分！</p><p id="bfbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用与前面相同的数据进行检查:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="74fc" class="lw lx it mw b gy na nb l nc nd">DECLARE @dt DATETIME2(3) = '2020-05-28 12:00:00.000';<br/>SELECT CAST(@dt as varbinary(8));</span></pre><p id="51c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，十六进制值是:0x03002E930224410B</p><p id="3781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们取日期的最后6个字符(3个字节)，但是最右边的字节在<em class="lv">数据时间2 </em>中是最重要的，所以它先取:0B4124。把它转换成十进制，我们得到737572。当我们将其添加到<em class="lv">日期时间2 </em>数据类型的“0001–01–01”起点时，我们将日期(2020–05–28)恢复为:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="5050" class="lw lx it mw b gy na nb l nc nd">SELECT DATEADD(DD,737572,convert(date,'0001-01-01')) AS DateTimeTest</span></pre><p id="87ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于时间部分，事情变得更加复杂，因为它依赖于定义的精度。在我们的例子中，它是3位精度，但它可以达到7位(这是默认的，以防我们没有定义任何特定的值)。根据精度不同，<em class="lv"> Datetime2 </em>占用6到8个字节的存储空间。</p><p id="8e70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的例子:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="17db" class="lw lx it mw b gy na nb l nc nd">SELECT CAST(0x02932E00 AS INT)/ POWER(10,3) AS SecFromMidnight<br/>      ,CAST(0x02932E00 AS INT)/ (POWER(10,3) * 60) AS MinsFromMidnight<br/>      ,CAST(0x02932E00 AS INT)/ (POWER(10,3) * 60 * 60) as HoursFromMidnight</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/2ee3192c56abf043e4de81876010f4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ClY6J629rWKZk_jKCu7m2Q.png"/></div></div></figure><p id="5192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们得到了预期的结果。</p><h2 id="c2d2" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">回到我们最初的场景…</h2><p id="8053" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">好了，这是两种数据类型的简要概述。创建表时，在许多情况下，人们无法预见特定表中将存储多少数据。有时，你创建了一个表，认为它不会超过某个阈值，但过了一会儿，你意识到你的假设是不正确的。</p><p id="a24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们确信这张桌子会很大！我说的大，是指一两年后可能接近1亿行。回到我们最初创建最优表的请求，我认为将数据存储为2位数精度的<em class="lv"> Datetime2 </em>(需要6个字节)，乘以至少5个Datetime列，可以为我们节省大量空间。</p><p id="b43d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要更少的存储，更高的精度，更大的日期范围，符合SQL标准…</p><h1 id="cd2b" class="ng lx it bd ly nh ni nj mb nk nl nm me jz nn ka mh kc no kd mk kf np kg mn nq bi translated">为什么还有人使用日期时间呢？</h1><p id="8e50" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">但是，我开始深入挖掘。并尝试在网上搜索寻找专家对这个话题的看法。我想，Datetime2 一定有什么(我的意思是，我的老板通常知道他在说什么，呵呵)。所以，我发现<a class="ae ky" href="https://www.sqlservercentral.com/forums/topic/why-do-some-dbas-avoid-datetime2" rel="noopener ugc nofollow" target="_blank">这个讨论</a>有着<em class="lv"> Datetime2 </em>的被充分证明的缺点。</p><p id="d358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要问题是缺乏对日期进行基本数学运算的(简单)可能性，例如计算两个日期之间的天数、小时数、分钟数等。</p><p id="cec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个关于<em class="lv">日期时间</em>类型的基本示例:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="6538" class="lw lx it mw b gy na nb l nc nd">SELECT CONVERT(DATE, GETDATE()+1) AS Tomorrow;</span></pre><p id="8593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您试图对<em class="lv"> Datetime2 </em>做同样的事情，您将得到一个错误:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="0f9a" class="lw lx it mw b gy na nb l nc nd">SELECT CONVERT(DATE,SYSDATETIME()+1) AS Tomorrow;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1eb73b5a4172a7ee7dd2d70bd7066061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*63OmGiRh77c6IjNnPeTr3g.png"/></div></figure><p id="a0a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个非常明显的缺点是，如果您试图计算当月的第一天，这是一种非常常见的情况:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="763c" class="lw lx it mw b gy na nb l nc nd">SELECT  CurrentMonthStart = DATEADD(mm,DATEDIFF(mm,0,SYSDATETIME()),0);</span></pre><p id="c9b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是意料之中的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f62b54009879b204e4fd652330e8a1dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*-MuY0xkbJSSVtkV7Ss7jfQ.png"/></div></figure><p id="620a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，你不会想到它的数据类型是:<em class="lv">日期时间</em>，而不是<em class="lv">日期时间2 </em>！</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="127e" class="lw lx it mw b gy na nb l nc nd">SELECT  SQL_VARIANT_PROPERTY(DATEADD(mm,DATEDIFF(mm,0,SYSDATETIME()),0),'BASETYPE') AS DataTypeTest</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/0510b8cb3a15001cd631e0dc74dab567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGhQQLeRHazO7NJA7od8JQ.png"/></div></div></figure><p id="3f10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着每次使用这些计算进行比较时，您都将完成隐式数据转换！</p><p id="7bc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个真正重要的考虑来自于这样一个事实，即由于数据存储的方式(还记得前面解释过的字节逆序)，SQL Server不能正确地对<em class="lv"> Datetime2 </em>列使用统计信息。关于这些问题的更多信息，请参见亚伦·贝特朗的文章<a class="ae ky" href="https://sqlperformance.com/2016/04/sql-performance/surprises-dateadd" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误的估计会导致非最优的查询计划，从而降低性能，这是一个更大的缺点。</p><p id="976c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，结果是错误的估计和糟糕的查询计划，常见场景中的隐式数据转换，无法使用基本的数学运算进行日期计算…</p><h1 id="660b" class="ng lx it bd ly nh ni nj mb nk nl nm me jz nn ka mh kc no kd mk kf np kg mn nq bi translated">究竟为什么有人想使用Datetime2？</h1></div></div>    
</body>
</html>