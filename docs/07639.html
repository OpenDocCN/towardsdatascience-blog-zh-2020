<html>
<head>
<title>Lord of the Wiki Ring: Importing Wikidata into Neo4j and analyzing family trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">维基指环王:将维基数据导入 Neo4j 并分析家谱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lord-of-the-wiki-ring-importing-wikidata-into-neo4j-and-analyzing-family-trees-da27f64d675e?source=collection_archive---------36-----------------------#2020-06-08">https://towardsdatascience.com/lord-of-the-wiki-ring-importing-wikidata-into-neo4j-and-analyzing-family-trees-da27f64d675e?source=collection_archive---------36-----------------------#2020-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="88d0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何从维基数据中抓取 LOTR 世界，并使用 Neo4j for Graph Data Science 工具箱对其进行分析</h2></div><p id="e772" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我之前关于结合 NLP 技术和图形的<a class="ae lb" rel="noopener" target="_blank" href="/nlp-and-graphs-go-hand-in-hand-with-neo4j-and-apoc-e57f59f46845">的长篇文章取得如此大的成功之后，我准备了另一个详尽的教程。我们将讨论几个话题。我们将通过</a><a class="ae lb" href="https://www.wikidata.org/wiki/Wikidata:Main_Page" rel="noopener ugc nofollow" target="_blank">维基数据 API </a>将数据导入<a class="ae lb" href="https://neo4j.com/" rel="noopener ugc nofollow" target="_blank"> Neo4j </a>开始。当我们完成的时候，我们将会收集维基数据上的大部分 LOTR 信息。在下一步中，我们将准备一个探索性的数据分析，并展示如何根据一些假设填充缺失值。最重要的是，我们将运行一些图形算法，并准备一些漂亮的可视化。</p><p id="f2ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确保你身边有一些爆米花，并准备好一些深入的图表分析。</p><h1 id="62a5" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">议程</h1><ul class=""><li id="95db" class="lu lv iq kh b ki lw kl lx ko ly ks lz kw ma la mb mc md me bi translated">将维基百科数据导入 Neo4j</li><li id="5991" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">基本图形探索</li><li id="0cd0" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">填充缺少的值</li><li id="45dd" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">更多的图形探索</li><li id="55d7" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">弱连通分量</li><li id="2694" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">中间中心性</li><li id="813e" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">用 Bloom 实现图形可视化(很酷的部分！)</li></ul><h1 id="7a7c" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">图表模式</h1><p id="df10" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">您可以通过<code class="fe mn mo mp mq b">db.schema.visualization()</code>程序在 Neo4j 浏览器中可视化图形模式。这是一个方便的过程，可以自动捕获存储图的模式。</p><p id="60fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mr">附注:只有在我们导入图表后才运行它</em></p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="71e6" class="na ld iq mq b gy nb nc l nd ne">CALL db.schema.visualization()</span></pre><p id="8800" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nf"><img src="../Images/d5aa753ca07919be46c4ef63b82001a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sBmuwQoY8eBucRIj.png"/></div></div></figure><p id="64ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用简单的图表模式已经有一段时间了。我很高兴地说，这一次有点复杂。我们有一个有家族关系的角色的社交网络，像<strong class="kh ir">配偶</strong>、<strong class="kh ir">兄弟姐妹</strong>、<strong class="kh ir">有父亲</strong>，甚至没有像<strong class="kh ir">敌人</strong>这样的家族关系。我们知道一些关于角色的附加信息，比如他们的国家、种族和他们所属的任何团体。</p><h1 id="6c15" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">维基数据导入</h1><p id="91bb" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">如前所述，我们将在<code class="fe mn mo mp mq b">apoc.load.json</code>过程的帮助下从 WikiData API 获取数据。如果您还不知道的话，<a class="ae lb" href="https://github.com/neo4j-contrib/neo4j-apoc-procedures" rel="noopener ugc nofollow" target="_blank"> APOC </a>为将数据导入 Neo4j 提供了出色的支持。除了从任何 REST API 获取数据的能力，它还具有通过 JDBC 驱动程序与其他数据库(如 MongoDB 或关系数据库)集成的功能。</p><p id="69a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你经常使用 RDF 数据，你应该去看看这个 <a class="ae lb" href="https://neo4j.com/docs/labs/nsmntx/current/" rel="noopener ugc nofollow" target="_blank"> <em class="mr">新语义库</em> </a> <em class="mr">。</em></p><p id="d642" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从引入 LOTR 世界的所有种族开始。我不得不承认我对 SPARQL 一无所知，所以我不会深入解释语法。如果你需要关于如何查询维基数据的基本介绍，我推荐 Youtube 上的这个<a class="ae lb" href="https://www.youtube.com/watch?v=kJph4q0Im98" rel="noopener ugc nofollow" target="_blank">教程</a>。基本上，LOTR 世界中的所有种族都是 id 为 Q989255 的中土种族实体的一个实例。为了获得特定条目的出现次数，我们使用下面的 SPARQL 子句:</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="591b" class="na ld iq mq b gy nb nc l nd ne">?item wdt:P31 wd:Q989255</span></pre><p id="246c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可以翻译为“我们想要获取一个项目，它是一个 id 为<a class="ae lb" href="https://www.wikidata.org/wiki/Q989255" rel="noopener ugc nofollow" target="_blank"> Q989255 </a>的实体(wdt: <a class="ae lb" href="https://www.wikidata.org/wiki/Property:P31" rel="noopener ugc nofollow" target="_blank"> P31 </a>)的实例”。在我们用 APOC 下载了数据之后，我们将结果存储到 Neo4j 中。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="a4f4" class="na ld iq mq b gy nb nc l nd ne">// Prepare a SPARQL query<br/>WITH 'SELECT ?item ?itemLabel<br/>      WHERE{<br/>      ?item wdt:P31 wd:Q989255 .<br/>      SERVICE wikibase:label { bd:serviceParam wikibase:language<br/>      "[AUTO_LANGUAGE],en" }<br/>      }' AS sparql<br/>// make a request to Wikidata<br/>CALL apoc.load.jsonParams(<br/>        "https://query.wikidata.org/sparql?query=" + <br/>            apoc.text.urlencode(sparql),<br/>        { Accept: "application/sparql-results+json"}, null)<br/>YIELD value<br/>// Unwind results to row<br/>UNWIND value['results']['bindings'] as row<br/>// Prepare data<br/>WITH row['itemLabel']['value'] as race, <br/>     row['item']['value'] as url, <br/>     split(row['item']['value'],'/')[-1] as id<br/>// Store to Neo4j<br/>CREATE (r:Race)<br/>SET r.race = race,<br/>    r.url = url,<br/>    r.id = id</span></pre><p id="180d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那很容易。下一步是获取给定中土世界种族的实例角色。SPARQL 语法与前面的查询几乎相同，只是这一次，我们对每个种族进行迭代，并找到属于它的字符。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="0a1b" class="na ld iq mq b gy nb nc l nd ne">// Iterate over each race in graph<br/>MATCH (r:Race)<br/>// Prepare a SparQL query<br/>WITH 'SELECT ?item ?itemLabel<br/>      WHERE {<br/>        ?item wdt:P31 wd:' + r.id + ' .<br/>        SERVICE wikibase:label { bd:serviceParam wikibase:language<br/>        "[AUTO_LANGUAGE],en" }<br/>      }' AS sparql, r<br/>// make a request to Wikidata<br/>CALL apoc.load.jsonParams(<br/>    "https://query.wikidata.org/sparql?query=" + <br/>      apoc.text.urlencode(sparql),<br/>    { Accept: "application/sparql-results+json"}, null)<br/>YIELD value<br/>UNWIND value['results']['bindings'] as row<br/>WITH row['itemLabel']['value'] as name, <br/>     row['item']['value'] as url, <br/>     split(row['item']['value'],'/')[-1] as id, <br/>     r<br/>// Store to Neo4j<br/>CREATE (c:Character)<br/>SET c.name = name,<br/>    c.url = url,<br/>    c.id = id<br/>CREATE (c)-[:BELONG_TO]-&gt;(r)</span></pre><p id="ae99" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你知道中土世界至少有 700 个角色吗？我从来没有想到会有这么多记录在维基数据上。我们的第一个探索性的密码查询将是按种族统计他们。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="d7f8" class="na ld iq mq b gy nb nc l nd ne">MATCH (r:Race)<br/>RETURN r.race as race, <br/>       size((r)&lt;-[:BELONG_TO]-()) as members<br/>ORDER BY members DESC <br/>LIMIT 10</span></pre><p id="b064" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fdad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">指环组的<a class="ae lb" href="https://lotr.fandom.com/wiki/Fellowship_of_the_Ring_(group)" rel="noopener ugc nofollow" target="_blank">团队是中土世界种族的一个代表样本。大多数角色要么是人类，要么是霍比特人，有几个精灵和矮人漫步走过。不过，这是我第一次听说梵拉和梅尔的比赛。</a></p><p id="8704" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是时候用关于人物性别、国家和死亡方式的信息来丰富图表了。SPARQL 查询将与以前略有不同。这一次，我们将直接通过惟一的 id 选择一个 WikiData 实体，并有选择地获取它的一些属性。我们可以使用下面的 SPARQL 子句按 id 过滤特定的项目:</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="ebf8" class="na ld iq mq b gy nb nc l nd ne">filter (?item = wd:' + r.id + ')</span></pre><p id="7dae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与 cypher 查询语言类似，SPARQL 也区分了<code class="fe mn mo mp mq b">MATCH</code>和<code class="fe mn mo mp mq b">OPTIONAL MATCH</code>。当我们想要返回一个实体的多个属性时，最好将每个属性包装成一个<code class="fe mn mo mp mq b">OPTIONAL MATCH</code>。这样，如果任何属性存在，我们将得到结果。如果没有<code class="fe mn mo mp mq b">OPTIONAL MATCH</code>，我们将只能得到所有三个属性都存在的实体的结果。这是与 cypher 相同的行为。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="b54b" class="na ld iq mq b gy nb nc l nd ne">OPTIONAL{ ?item wdt:P21 [rdfs:label ?gender] . <br/>           filter (lang(?gender)="en") }</span></pre><p id="357b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mn mo mp mq b">wdt:P21</code>表示我们对性别属性感兴趣。我们还指定我们想要获得一个实体的英文标签，而不是它的 WikiData id。搜索所需属性 id 的最简单方法是检查 WikiData 网页上的项目，并将鼠标悬停在属性名称上。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/f0861b8d251891c8d7e5f44bcce63237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SL-dbgdAjTqoo29Q.png"/></div></div></figure><p id="31da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种方法是使用<a class="ae lb" href="https://query.wikidata.org/" rel="noopener ugc nofollow" target="_blank"> WikiData 查询编辑器</a>，它通过使用 CTRL+T 命令具有强大的自动完成功能。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/7043b7aa296c05ba39d23185dfc827d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/0*DHx3OieS-f7YqOsF.png"/></div></figure><p id="773b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将图形存储回 Neo4j，我们将使用<code class="fe mn mo mp mq b">FOREACH</code>技巧。因为我们的一些结果将包含空值，所以我们必须将<code class="fe mn mo mp mq b">MERGE</code>语句包装到支持条件执行的<code class="fe mn mo mp mq b">FOREACH</code>语句中。查看<a class="ae lb" href="https://medium.com/neo4j/5-tips-tricks-for-fast-batched-updates-of-graph-structures-with-neo4j-and-cypher-73c7f693c8cc" rel="noopener">迈克尔·亨格</a><a class="ae lb" href="https://twitter.com/mesirii" rel="noopener ugc nofollow" target="_blank">的博客文章</a>了解更多信息。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="c7a7" class="na ld iq mq b gy nb nc l nd ne">// Iterate over characters<br/>MATCH (r:Character)<br/>// Prepare a SparQL query<br/>WITH 'SELECT *<br/>      WHERE{<br/>        ?item rdfs:label ?name .<br/>        filter (?item = wd:' + r.id + ')<br/>        filter (lang(?name) = "en" ) .<br/>      OPTIONAL{<br/>        ?item wdt:P21 [rdfs:label ?gender] .<br/>        filter (lang(?gender)="en")<br/>      }<br/>      OPTIONAL{<br/>        ?item wdt:P27 [rdfs:label ?country] .<br/>        filter (lang(?country)="en")<br/>      }<br/>      OPTIONAL{<br/>        ?item wdt:P1196 [rdfs:label ?death] .<br/>        filter (lang(?death)="en")<br/>      }}' AS sparql, r<br/>// make a request to Wikidata<br/>CALL apoc.load.jsonParams(<br/>    "https://query.wikidata.org/sparql?query=" + <br/>    apoc.text.urlencode(sparql),<br/>     { Accept: "application/sparql-results+json"}, null)<br/>YIELD value<br/>UNWIND value['results']['bindings'] as row<br/>SET r.gender = row['gender']['value'], <br/>    r.manner_of_death = row['death']['value']<br/>// Execute FOREACH statement<br/>FOREACH(ignoreme in case when row['country'] is not null then [1] else [] end | <br/>        MERGE (c:Country{name:row['country']['value']})<br/>        MERGE (r)-[:IN_COUNTRY]-&gt;(c))</span></pre><p id="fe7f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在一点一点地将额外的信息连接到我们的图表，并慢慢地将它转化为知识图表。我们先来看死亡财产的方式。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="6184" class="na ld iq mq b gy nb nc l nd ne">MATCH (n:Character) <br/>WHERE exists (n.manner_of_death)<br/>RETURN n.manner_of_death as manner_of_death, <br/>       count(*) as count</span></pre><p id="3220" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="63ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没什么有趣的。这显然不是《权力的游戏》系列。我们也来考察一下国家财产的结果。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="10f8" class="na ld iq mq b gy nb nc l nd ne">MATCH (c:Country)<br/>RETURN c.name as country, <br/>       size((c)&lt;-[:IN_COUNTRY]-()) as members<br/>ORDER BY members <br/>DESC LIMIT 10</span></pre><p id="de81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="407c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有 236 个字符的国家信息。我们可以做一些假设，并尝试填充缺失的国家值。让我们假设如果两个人是兄弟姐妹，他们属于同一个国家。这很有道理。为了实现这一点，我们必须从维基数据中导入家族关系。具体来说，我们将获取父亲、母亲、亲戚、兄弟姐妹和配偶关系。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="87bf" class="na ld iq mq b gy nb nc l nd ne">// Iterate over characters<br/>MATCH (r:Character)<br/>WITH 'SELECT *<br/>      WHERE{<br/>        ?item rdfs:label ?name .<br/>        filter (?item = wd:' + r.id + ')<br/>        filter (lang(?name) = "en" ) .<br/>      OPTIONAL{<br/>        ?item wdt:P22 ?father<br/>      }<br/>      OPTIONAL{<br/>         ?item wdt:P25 ?mother<br/>      }<br/>      OPTIONAL{<br/>         ?item wdt:P1038 ?relative<br/>      }<br/>      OPTIONAL{<br/>         ?item wdt:P3373 ?sibling<br/>      }<br/>      OPTIONAL{<br/>         ?item wdt:P26 ?spouse<br/>      }}' AS sparql, r<br/>// make a request to wikidata<br/>CALL apoc.load.jsonParams(<br/>    "https://query.wikidata.org/sparql?query=" + <br/>     apoc.text.urlencode(sparql),<br/>     { Accept: "application/sparql-results+json"}, null)<br/>YIELD value<br/>UNWIND value['results']['bindings'] as row<br/>FOREACH(ignoreme in case when row['mother'] is not null then [1] else [] end | <br/>        MERGE (c:Character{url:row['mother']['value']}) <br/>        MERGE (r)-[:HAS_MOTHER]-&gt;(c))<br/>FOREACH(ignoreme in case when row['father'] is not null then [1] else [] end | <br/>        MERGE (c:Character{url:row['father']['value']}) <br/>        MERGE (r)-[:HAS_FATHER]-&gt;(c))<br/>FOREACH(ignoreme in case when row['relative'] is not null then [1] else [] end | <br/>        MERGE (c:Character{url:row['relative']['value']}) <br/>        MERGE (r)-[:HAS_RELATIVE]-(c))<br/>FOREACH(ignoreme in case when row['sibling'] is not null then [1] else [] end | <br/>        MERGE (c:Character{url:row['sibling']['value']}) <br/>        MERGE (r)-[:SIBLING]-(c))<br/>FOREACH(ignoreme in case when row['spouse'] is not null then [1] else [] end | <br/>        MERGE (c:Character{url:row['spouse']['value']}) <br/>        MERGE (r)-[:SPOUSE]-(c))</span></pre><p id="43ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始填充缺失值之前，让我们检查一下中土世界的滥交情况。第一个查询将搜索有多个配偶的角色。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="e680" class="na ld iq mq b gy nb nc l nd ne">MATCH p=()-[:SPOUSE]-()-[:SPOUSE]-()<br/>RETURN p LIMIT 10</span></pre><p id="f9d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/16db0790dafa8a9433d1445bdcb70fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/0*gbl8rr7BMvFAGVN0.png"/></div></figure><p id="aef3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们实际上发现了一个有两个配偶的角色。是芬威，诺尔多的第一任国王。我们也可以看看某人是否有多个伴侣的孩子</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="0d78" class="na ld iq mq b gy nb nc l nd ne">MATCH (c:Character)&lt;-[:HAS_FATHER|HAS_MOTHER]-()-[:HAS_FATHER|HAS_MOTHER]-&gt;(other)<br/>WITH c, collect(distinct other) as others<br/>WHERE size(others) &gt; 1<br/>MATCH p=(c)&lt;-[:HAS_FATHER|HAS_MOTHER]-()-[:HAS_FATHER|HAS_MOTHER]-&gt;()<br/>RETURN p</span></pre><p id="b027" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ns"><img src="../Images/ec9bedfd3ddfd1bb5d39bbd3c816ee79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4aMAUEwM9ysIpE1r.png"/></div></div></figure><p id="f80f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以看起来芬威和茵迪丝有四个孩子，和米里埃尔有一个孩子。另一方面，贝伦有两个父亲是很奇怪的。我想阿达内尔需要解释一下。我们可能会在 GoT 世界发现更多的死亡和滥交。</p><h1 id="c6e0" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">填充缺少的值</h1><p id="8e8f" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">现在我们知道了中土世界的人物不滥交，让我们填充缺失的国家价值观。记住，我们的假设是:</p><blockquote class="nt nu nv"><p id="040e" class="kf kg mr kh b ki kj jr kk kl km ju kn nw kp kq kr nx kt ku kv ny kx ky kz la ij bi translated">如果两个角色是兄弟姐妹，他们属于同一个国家。</p></blockquote><p id="2b3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们填充国家/地区的缺失值之前，让我们填充兄弟国家/地区的缺失值。我们将假设如果两个角色有相同的母亲或父亲，他们是兄弟姐妹。让我们看看一些同胞候选人。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="16d3" class="na ld iq mq b gy nb nc l nd ne">MATCH p=(a:Character)-[:HAS_FATHER|:HAS_MOTHER]-&gt;()&lt;-[:HAS_FATHER|:HAS_MOTHER]-(b:Character)<br/>WHERE NOT (a)-[:SIBLING]-(b)<br/>RETURN p<br/>LIMIT 5</span></pre><p id="6dd1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nz"><img src="../Images/853173e9cd1b3cb4a7d9ba8206d6452f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kAPrYKzcPm4QhK9R.png"/></div></div></figure><p id="c187" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">阿轧曼塔·丘博至少有六个孩子。其中只有两个被标记为兄弟姐妹。因为根据定义，它们都是兄弟姐妹，所以我们将填充缺失的连接。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="6ab6" class="na ld iq mq b gy nb nc l nd ne">MATCH p=(a:Character)-[:HAS_FATHER|:HAS_MOTHER]-&gt;()&lt;-[:HAS_FATHER|:HAS_MOTHER]-(b:Character)<br/>WHERE NOT (a)-[:SIBLING]-(b)<br/>MERGE (a)-[:SIBLING]-(b)</span></pre><p id="b5a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该查询添加了 118 个缺失的关系。我需要学习如何更新维基数据知识图，并批量添加缺失的连接。现在，我们可以为兄弟姐妹填写缺失的国家值。我们会将所有字符与已填写的国家信息进行匹配，并搜索他们没有国家信息的兄弟姐妹。我喜欢用 cypher 查询语言表达这种模式是如此简单。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="86b2" class="na ld iq mq b gy nb nc l nd ne">MATCH (country)&lt;-[:IN_COUNTRY]-(s:Character)-[:SIBLING]-(t:Character) WHERE NOT (t)-[:IN_COUNTRY]-&gt;()<br/>MERGE (t)-[:IN_COUNTRY]-&gt;(country)</span></pre><p id="f41f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新增了 49 个缺失的国家。我们可以很快提出更多的假设来填补缺失的值。您可以尝试自己添加一些其他缺失的属性。</p><p id="15cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们仍然需要在图表中添加一些信息。在这个查询中，我们将添加关于角色的职业、语言、群体和事件的信息。SPARQL 查询与之前的相同，我们遍历每个字符并获取额外的属性。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="8b5b" class="na ld iq mq b gy nb nc l nd ne">MATCH (r:Character)<br/>WHERE exists (r.id)<br/>WITH 'SELECT *<br/>      WHERE{<br/>         ?item rdfs:label ?name .<br/>         filter (?item = wd:' + r.id + ')<br/>         filter (lang(?name) = "en" ) .<br/>      OPTIONAL {<br/>        ?item wdt:P106 [rdfs:label ?occupation ] .<br/>         filter (lang(?occupation) = "en" ).<br/>       }<br/>      OPTIONAL {<br/>        ?item wdt:P103 [rdfs:label ?language ] .<br/>        filter (lang(?language) = "en" ) .<br/>       }<br/>      OPTIONAL {<br/>        ?item wdt:P463 [rdfs:label ?member_of ] .<br/>        filter (lang(?member_of) = "en" ).<br/>      }<br/>      OPTIONAL {<br/>        ?item wdt:P1344[rdfs:label ?participant ] .<br/>        filter (lang(?participant) = "en") .<br/>      }<br/>     OPTIONAL {<br/>       ?item wdt:P39[rdfs:label ?position ] .<br/>       filter (lang(?position) = "en") .<br/>     }}' AS sparql, r<br/>CALL apoc.load.jsonParams(<br/>    "https://query.wikidata.org/sparql?query=" + <br/>     apoc.text.urlencode(sparql),<br/>    { Accept: "application/sparql-results+json"}, null)<br/>YIELD value<br/>UNWIND value['results']['bindings'] as row<br/>FOREACH(ignoreme in case when row['language'] is not null then [1] else [] end | <br/>    MERGE (c:Language{name:row['language']['value']}) <br/>    MERGE (r)-[:HAS_LANGUAGE]-&gt;(c))<br/>FOREACH(ignoreme in case when row['occupation'] is not null then [1] else [] end | <br/>    MERGE (c:Occupation{name:row['occupation']['value']}) <br/>    MERGE (r)-[:HAS_OCCUPATION]-&gt;(c))<br/>FOREACH(ignoreme in case when row['member_of'] is not null then [1] else [] end | <br/>    MERGE (c:Group{name:row['member_of']['value']}) <br/>    MERGE (r)-[:MEMBER_OF]-&gt;(c))<br/>FOREACH(ignoreme in case when row['participant'] is not null then [1] else [] end | <br/>    MERGE (c:Event{name:row['participant']['value']}) <br/>    MERGE (r)-[:PARTICIPATED]-&gt;(c))<br/>SET r.position = row['position']['value']</span></pre><p id="d6b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们来调查一下各组的成绩和人物的职业。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="6964" class="na ld iq mq b gy nb nc l nd ne">MATCH (n:Group)&lt;-[:MEMBER_OF]-(c)<br/>OPTIONAL MATCH (c)-[:HAS_OCCUPATION]-&gt;(o)<br/>RETURN n.name as group, <br/>       count(*) as size, <br/>       collect(c.name)[..3] as members, <br/>       collect(distinct o.name)[..3] as occupations<br/>ORDER BY size DESC</span></pre><p id="de76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="23bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就在这时，我意识到整个霍比特人系列都包括在内。巴林是索林公司集团的日记作者。出于某种原因，我期待比尔博·巴金斯是日记作者。很明显，环组团契里只能有一个弓箭手，那就是勒苟拉斯。甘道夫似乎参与了几个组织。</p><p id="1934" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将再执行一次 WikiData API 调用。这一次我们将取得敌人和角色拥有的物品。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="e8ce" class="na ld iq mq b gy nb nc l nd ne">MATCH (r:Character)<br/>WHERE exists (r.id)<br/>WITH 'SELECT *<br/>      WHERE<br/>      {<br/>        ?item rdfs:label ?name .<br/>        filter (?item = wd:' + r.id + ')<br/>        filter (lang(?name) = "en" ) .<br/>      OPTIONAL{<br/>        ?item wdt:P1830 [rdfs:label ?owner ] .<br/>        filter (lang(?owner) = "en" ).<br/>      }<br/>      OPTIONAL{<br/>       ?item wdt:P7047 ?enemy <br/>      }}' AS sparql, r<br/>CALL apoc.load.jsonParams(<br/>    "https://query.wikidata.org/sparql?query=" + <br/>     apoc.text.urlencode(sparql),<br/>{ Accept: "application/sparql-results+json"}, null)<br/>YIELD value<br/>WITH value,r<br/>WHERE value['results']['bindings'] &lt;&gt; []<br/>UNWIND value['results']['bindings'] as row<br/>FOREACH(ignoreme in case when row['owner'] is not null then [1] else [] end | <br/>    MERGE (c:Item{name:row['owner']['value']}) <br/>    MERGE (r)-[:OWNS_ITEM]-&gt;(c))<br/>FOREACH(ignoreme in case when row['enemy'] is not null then [1] else [] end | <br/>    MERGE (c:Character{url:row['enemy']['value']}) <br/>    MERGE (r)-[:ENEMY]-&gt;(c))</span></pre><p id="1010" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们已经完成了图表的导入。我们来看看直系亲属之间有多少仇人。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="cb00" class="na ld iq mq b gy nb nc l nd ne">MATCH p=(a)-[:SPOUSE|SIBLING|HAS_FATHER|HAS_MOTHER]-(b)<br/>WHERE (a)-[:ENEMY]-(b)<br/>RETURN p</span></pre><p id="e5e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/4511aceeefa6459b468051fc445de800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/0*PR_vKQOe61-QHjBp.png"/></div></figure><p id="6a23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来 Morgoth 和 Manw 是兄弟也是敌人。这是我第一次听说这两个人，但是<a class="ae lb" href="https://lotr.fandom.com/wiki/Melkor" rel="noopener ugc nofollow" target="_blank"> LOTR 粉丝网站</a>声称 Morgoth 是第一个黑魔王。我们来看看二级亲属内部有多少敌人。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="bf02" class="na ld iq mq b gy nb nc l nd ne">MATCH p=(a)-[:SPOUSE|SIBLING|HAS_FATHER|HAS_MOTHER*..2]-(b) <br/>WHERE (a)-[:ENEMY]-(b) <br/>RETURN p</span></pre><p id="6f15" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/659aff29825b2d1db40b87b39a56581d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/0*Rt9UYHxwb2_2Uwqr.png"/></div></figure><p id="8351" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二代家庭内部的敌人并不多。我们可以观察到，瓦尔达已经采取了她丈夫的立场，也是与摩哥特为敌。这是一个稳定的三角形或三和弦的例子。三角形由一个积极的关系(配偶)和两个消极的关系(敌人)组成。在社会网络分析中，三角形用于衡量网络的凝聚力和结构稳定性。</p><h1 id="173b" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">图形数据科学</h1><p id="f6ec" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">如果你读过我以前的博客文章，你会知道我必须包括一些来自<a class="ae lb" href="https://github.com/neo4j/graph-data-science" rel="noopener ugc nofollow" target="_blank">图形数据科学</a>图书馆的图形算法的用例。如果你需要快速复习一下 GDS 图书馆是如何运作的，幕后发生了什么，我建议你看看我之前的博客文章。</p><p id="9461" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从投影家庭网络开始。我们加载了所有的角色以及他们之间的家庭关系，比如配偶、兄弟姐妹、父母。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="8f6a" class="na ld iq mq b gy nb nc l nd ne">CALL gds.graph.create('family','Character',<br/>    ['SPOUSE','SIBLING','HAS_FATHER','HAS_MOTHER'])</span></pre><h1 id="7ebb" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">弱连通分量</h1><p id="97cb" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated"><a class="ae lb" href="https://neo4j.com/docs/graph-data-science/current/algorithms/wcc/" rel="noopener ugc nofollow" target="_blank">弱连通分量算法</a>用于在我们的网络中寻找孤岛或不连通分量。以下可视化包含两个连接的组件。第一部分由迈克尔、马克和道格组成，而第二部分由爱丽丝、查尔斯和布里奇特组成。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/09d6ade65f20a3d225713f2f10f04062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/0*m2i-G65QpUHVhMkD.png"/></div></figure><p id="8553" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，我们将使用弱连接组件算法来寻找家庭网络中的孤岛。同一家庭成员中的所有成员都以某种方式相互关联。可能是嫂子的祖母的表亲，或者更直接一点的兄弟姐妹。为了大致了解结果，我们将运行算法的<code class="fe mn mo mp mq b">stats</code>模式。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="23a2" class="na ld iq mq b gy nb nc l nd ne">CALL gds.wcc.stats('family')<br/>YIELD componentCount, componentDistribution<br/>RETURN componentCount as components, <br/>       componentDistribution.p75 as p75,<br/>       componentDistribution.p90 as p90,<br/>       apoc.math.round(componentDistribution.mean,2) as mean,<br/>       componentDistribution.max as max</span></pre><p id="4c18" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8563" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的图表中有 145 个岛屿。75%以上的组件只包含一个字符。这意味着大约 110 (75% * 145)个角色没有图中描述的任何家族联系。如果它们只有一个连接，那么组件的大小至少是两个。最大的组成部分有 328 名成员。那一定是一个幸福的家庭。让我们写回结果，进一步分析家庭组成。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="1ed6" class="na ld iq mq b gy nb nc l nd ne">CALL gds.wcc.write('family', {writeProperty:'familyComponent'})</span></pre><p id="2611" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从五个最大的家庭组成部分开始。我们感兴趣的第一件事是哪些种族出现在家谱中。我们还将在结果中添加一些随机成员，以便更好地感受数据。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="20c4" class="na ld iq mq b gy nb nc l nd ne">MATCH (c:Character)<br/>OPTIONAL MATCH (c)-[:BELONG_TO]-&gt;(race)<br/>WITH c.familyComponent as familyComponent, <br/>     count(*) as size, <br/>     collect(c.name) as members,<br/>     collect(distinct race.race) as family_race<br/>     ORDER BY size DESC LIMIT 5 <br/>RETURN familyComponent, <br/>       size, <br/>       members[..3] as random_members,<br/>       family_race</span></pre><p id="4032" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7652" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，最大的家族有 328 名成员，他们来自不同的种族，从精灵到人类，甚至是玛雅人。在中土世界，精灵和人类的生活似乎纠缠在一起。还有他们的腿。半精灵种族的存在是有原因的。其他种族，像霍比特人和矮人，更忠于自己的同类。</p><p id="131b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看最大的社区中的跨种族婚姻。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="60a1" class="na ld iq mq b gy nb nc l nd ne">MATCH (c:Character)<br/>WHERE c.familyComponent = 169 // fix the family component <br/>MATCH p=(race)&lt;-[:BELONG_TO]-(c)-[:SPOUSE]-(other)-[:BELONG_TO]-&gt;(other_race)<br/>WHERE race &lt;&gt; other_race AND id(c) &gt; id(other)<br/>RETURN c.name as spouse_1, <br/>       race.race as race_1, <br/>       other.name as spouse_2, <br/>       other_race.race as race_2</span></pre><p id="aafe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="081b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我不知道埃尔隆德是半精灵。看起来人类和精灵的“联盟”历史悠久。我主要是期待看到阿尔温和阿拉贡，因为我记得从电影中。了解半精灵可以追溯到多远会很有趣。我们来看看谁是拥有最多后代的半精灵。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="6fa4" class="na ld iq mq b gy nb nc l nd ne">MATCH (c:Character)<br/>WHERE (c)-[:BELONG_TO]-&gt;(:Race{race:'half-elven'}) <br/>MATCH p=(c)&lt;-[:HAS_FATHER|HAS_MOTHER*..20]-(end)<br/>WHERE NOT (end)&lt;-[:HAS_FATHER|:HAS_MOTHER]-()<br/>WITH c, max(length(p)) as descendants<br/>ORDER BY descendants DESC<br/>LIMIT 5<br/>RETURN c.name as character, <br/>       descendants</span></pre><p id="48d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="932b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">迪奥·艾鲁奇似乎是记录在案的最古老的半精灵。我在<a class="ae lb" href="https://lotr.fandom.com/wiki/Dior" rel="noopener ugc nofollow" target="_blank"> LOTR 粉丝网站</a>检查了结果，看来我们是对的。迪奥·艾鲁奇尔诞生于公元 470 年的第一个纪元。还有几个半精灵出生在迪奥之后的 50 年内。</p><h1 id="f2c2" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">中间中心性</h1><p id="c6ed" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们还将看一下介数中心算法。它用于查找不同社区之间的桥节点。如果我们看一下下面的可视化，我们可以观察到美国队长具有最高的中间中心性分数。这是因为他是网络中的主要桥梁，连接着图的左边和右边。网络中的第二座桥是野兽。我们可以很容易地看到，图表的中央和右侧之间交换的所有信息都必须通过他才能到达右侧。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi od"><img src="../Images/764b131c57867e3d9cfb668b20ce5e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QlKs-W1QW-sKH6lM.png"/></div></div></figure><p id="3123" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会在最大的家庭网络中寻找桥段人物。我的猜测是，跨种族婚姻中的配偶将会胜出。这是因为所有种族之间的交流都通过他们进行。我们已经看到只有六种不同种族间的婚姻，所以很可能其中一些会胜出。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="684e" class="na ld iq mq b gy nb nc l nd ne">CALL gds.alpha.betweenness.stream({<br/>    nodeQuery:"MATCH (n:Character) WHERE n.familyComponent = 169<br/>               RETURN id(n) as id",<br/>    relationshipQuery:"MATCH (s:Character)-[:HAS_FATHER|HAS_MOTHER|SPOUSE|SIBLING]-(t:Character)<br/>                       RETURN id(s) as source, id(t) as target",<br/>    validateRelationships:false})<br/>YIELD nodeId, centrality<br/>RETURN gds.util.asNode(nodeId).name as character,<br/>       centrality<br/>ORDER BY centrality DESC LIMIT 10</span></pre><p id="41d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="341b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的是阿尔温和阿拉贡获得了冠军。不知道为什么，但我一直认为他们是现代的罗密欧和朱丽叶，他们通过婚姻结成了人类和半精灵之间的联盟。我不知道 JRR 托尔金系统是如何生成名字的，但它似乎有点偏向于以 a 开头的名字。</p><h1 id="d899" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">Neo4j Bloom</h1><p id="3546" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">到目前为止，我们已经完成了数据分析，并获得了一些见解。现在是时候用图表的实际应用来给我们的同事留下深刻印象了。<a class="ae lb" href="https://neo4j.com/bloom/" rel="noopener ugc nofollow" target="_blank"> Neo4j Bloom </a>是图形数据科学生态系统<a class="ae lb" href="https://neo4j.com/blog/announcing-neo4j-for-graph-data-science/" rel="noopener ugc nofollow" target="_blank"> Neo4j 的一部分。它是一个工具，主要用于研究图形，并允许用户在很少或没有密码知识的情况下进行研究。查看由 Lju Lazarevic </a>发布的<a class="ae lb" href="https://medium.com/neo4j/bloom-ing-marvellous-a2be0c3702bb" rel="noopener">绽放精彩</a>的帖子，了解最新功能。</p><p id="1998" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Neo4j Bloom 预装了<a class="ae lb" href="https://neo4j.com/download/" rel="noopener ugc nofollow" target="_blank"> Neo4j 桌面</a>包。我已经写了一篇关于如何开始使用它的博客文章。一旦你打开了 Neo4j Bloom，创建你的第一视角。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/7a7f9333e9c2ffd2969ce67ba8af20c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/0*TYxV53NLD0cd3HS7.png"/></div></figure><p id="ae10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击<strong class="kh ir">生成</strong>按钮，自动生成图形透视图。一旦创建了视图，将鼠标悬停在它上面并单击 Use 透视图。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div class="gh gi of"><img src="../Images/9d4d054d9d0ed6d3a4e6e7f0fbfa384c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/0*0VxsCM5yXeqhzhxJ.png"/></div></figure><h1 id="0d22" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">近自然语言搜索</h1><p id="c630" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">欢迎来到 Neo4j Bloom。没有 cypher 查询知识的用户可以使用<a class="ae lb" href="https://www.youtube.com/watch?v=9rL8O0lsuDc" rel="noopener ugc nofollow" target="_blank">近自然语言搜索</a>来探索图表。我们先在搜索栏输入<strong class="kh ir">敌人</strong>开始。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi og"><img src="../Images/2340248e82b4dc2f64aa0fff9e2fb857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AaPZjzFbtNyRKkwV.png"/></div></div></figure><p id="f47e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Bloom 自动为我们提供了一个可能与我们的搜索查询相关的模式。如果我们点击它，我们将得到以下可视化。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oh"><img src="../Images/bb97c8e06b32b3904c4a445e2cca84f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*id4VEqSUX6Ul9z59.png"/></div></div></figure><p id="d1d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，我知道。网络中的所有节点都是蓝色的。我们一会儿就会谈到这个问题。可视化清楚地显示了两个集群或社区。在图的左边，我们看到好人和索伦在战斗。这是 LOTR 系列的。在右边，我们有好人对抗魔哥特人。我猜这一定是霍比特人系列。</p><p id="8018" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想改变节点的颜色，按照这个图像。首先，点击字符标签，然后选择基于<strong class="kh ir">规则的</strong>选项卡，输入您的颜色规则。在我们的例子中，我们把所有的女性角色都涂成红色。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/27767e92306983eef4fee235a30bec20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/0*O_aecxqZ6KX6nGwy.png"/></div></figure><p id="a1e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过近自然语言搜索，我们还可以定义更精确的图形模式。例如，假设我们想调查佛罗多·巴金斯先生的敌人。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oj"><img src="../Images/dc590ce59b6c941e522b804a29b5b3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gBp6P1Vd5A64mM8_.png"/></div></div></figure><p id="0049" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它会自动完成我们正在寻找的模式。如果我们点击它，我们会得到。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ok"><img src="../Images/5499ef5c6d2fb0cf05a43cbdae036525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CP5XjdxO5mDnb2l0.png"/></div></div></figure><h1 id="40d6" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">搜索短语:最短路径</h1><p id="a900" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">搜索短语机制允许我们向 Neo4j Bloom 添加自定义搜索功能。我们首先定义搜索短语应该是什么样子。我们可以使用<strong class="kh ir"> $ </strong>符号向搜索查询添加参数。对搜索短语参数的自动完成支持是现成的，这真的很可爱。然后，我们输入所需的 cypher 查询，就万事俱备了。我们将使用下面的 cypher 查询来查找任意两个角色之间家族关系的最短路径。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="8fd1" class="na ld iq mq b gy nb nc l nd ne">MATCH (s:Character)<br/>WHERE s.name = $source<br/>MATCH (t:Character)<br/>WHERE t.name = $target<br/>MATCH p=shortestPath((s)-[:HAS_FATHER|HAS_MOTHER|SIBLING|SPOUSE*..25]-(t))<br/>RETURN p</span></pre><p id="88ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">填写好的搜索短语将如下所示:</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ol"><img src="../Images/6d84d8af2b86d0d2aa28103ac8b629d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tdaOIn4qUUtWKEtk.png"/></div></div></figure><p id="fe39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以在搜索框中执行新的搜索短语。如前所述，该应用程序帮助我们自动完成。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi om"><img src="../Images/331f563ede8bbcc12f74497701f2849e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CUXTWJL_oSUgqPXy.png"/></div></div></figure><p id="ba2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于佛罗多·巴金斯和山姆卫斯·詹吉之间的最短家族关系路径，我们得到以下结果。他们有血缘关系，但是只有 9 步之遥。佛罗多的堂兄有一个儿子，是山姆女儿的丈夫的祖父。希望我没有搞砸。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi on"><img src="../Images/a75dfba72a56f6426366f43916cb53f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vgF-0vc6X86TvOon.png"/></div></div></figure><h1 id="fb0a" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">搜索短语:祖先树</h1><p id="e466" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">最后，我们将创建一个搜索短语来分析给定角色的家族祖先树。我为 cypher 查询准备了两种变体。第一个变体只遍历 HAS_FATHER 和 HAS_MOTHER 关系。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="71f0" class="na ld iq mq b gy nb nc l nd ne">MATCH (c:Character)<br/>WHERE c.name = $name<br/>MATCH p=(c)-[:HAS_FATHER|HAS_MOTHER*..20]-&gt;()<br/>RETURN p</span></pre><p id="9d60" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个变体将之前用弱连通分量算法计算的整个家族分量可视化。</p><pre class="ms mt mu mv gt mw mq mx my aw mz bi"><span id="8a81" class="na ld iq mq b gy nb nc l nd ne">MATCH (c:Character)<br/>WHERE c.name = $name<br/>WITH c.familyComponent as family<br/>MATCH p=(c1)--(c2)<br/>WHERE c1.familyComponent = family AND c2.familyComponent = family<br/>RETURN p</span></pre><p id="299e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用第一种变体，因为它为博客文章产生了更漂亮的可视化效果，但是我鼓励您亲自尝试第二种变体。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/494748f2d69351eb6fee13ad79d792a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/0*8cb00ASnBUaSWV4B.png"/></div></figure><p id="f0d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们添加了另一个搜索短语。我们现在可以在搜索栏中使用它。</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi op"><img src="../Images/5616a521d334a11f597f34979be83df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R_smQc3i3tACuZH9.png"/></div></div></figure><p id="4238" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oq"><img src="../Images/4c24155e70e400384f6b1b35a4e50dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nFZYIbn4CBDx-pwQ.png"/></div></div></figure><h1 id="ed60" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">结论</h1><p id="af39" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我真的很喜欢写这篇博客和搜集维基数据知识图表。它包含了丰富的信息，我们可以在 Neo4j 中进行分析。我可以把这篇博文分成两部分甚至三部分。尽管如此，我还是喜欢将所有内容放在一个地方，向您展示完成图形分析的整个循环是多么容易，从导入和丰富图形到基本的数据探索和分析，我们以一些漂亮的图形可视化为基础。立即试用并下载<a class="ae lb" href="https://neo4j.com/download-center/" rel="noopener ugc nofollow" target="_blank"> Neo4j 桌面</a>。如果您有任何反馈或问题，可以在<a class="ae lb" href="http://community.neo4j.com" rel="noopener ugc nofollow" target="_blank"> Neo4j 社区网站</a>上分享。</p><p id="1632" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和往常一样，代码可以在<a class="ae lb" href="https://github.com/tomasonjo/blogs/blob/master/Lord_of_the_wikidata/Part1%20Importing%20Wikidata%20into%20Neo4j%20and%20analyzing%20family%20trees.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>