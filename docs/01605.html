<html>
<head>
<title>Enriching OCR with Akka Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Akka 流丰富 OCR</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/enriching-ocr-with-akka-streams-7e48990be929?source=collection_archive---------26-----------------------#2020-02-13">https://towardsdatascience.com/enriching-ocr-with-akka-streams-7e48990be929?source=collection_archive---------26-----------------------#2020-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fef4ce9a4bd575beadb6c3e81a158ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iYlYLKMUuCz-HcEL"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">马丁·桑切斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a604" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Tesseract 文档<a class="ae kf" href="https://github.com/tesseract-ocr/tesseract/wiki/ImproveQuality" rel="noopener ugc nofollow" target="_blank">列出了一些预处理步骤</a>以获得更好的 OCR 结果。由于我不知道如何执行这些步骤，所以我决定创建一个可插拔的流架构，以便在进行过程中添加它们。在 Akka Streams 世界中，这最终看起来像一个带有 sub <code class="fe le lf lg lh b">Flow[Mat]</code>的<code class="fe le lf lg lh b">Flow[BufferedImage]</code>——其中<a class="ae kf" href="https://docs.opencv.org/2.4/doc/tutorials/core/mat_the_basic_image_container/mat_the_basic_image_container.html" rel="noopener ugc nofollow" target="_blank"> Mat 是一个 OpenCV 构造</a>。然后将<code class="fe le lf lg lh b">BufferedImage</code>传递给宇宙魔方，宇宙魔方返回一个字符串。这就是我们在<a class="ae kf" rel="noopener" target="_blank" href="/ocr-with-akka-tesseract-and-javacv-part-1-702781fc73ca"> OCR 与 Akka、Tesseract 和 JavaCV </a>中讨论的内容。这篇文章着眼于获取 OCR 结果，并通过几个处理阶段来丰富它。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi li"><img src="../Images/d4dcfc03c7f541891d4f497ed3763792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PP9IIoN9mVt4nnvjUUz0FA@2x.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">先前系统的图示</p></figure><blockquote class="ln lo lp"><p id="4c81" class="kg kh lq ki b kj kk kl km kn ko kp kq lr ks kt ku ls kw kx ky lt la lb lc ld im bi translated">如果你想继续的话，所有的代码都已经在 Github Repo 中更新了！</p></blockquote></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><blockquote class="mb"><p id="3c79" class="mc md it bd me mf mg mh mi mj mk ld dk translated">理解这篇文章不需要<a class="ae kf" rel="noopener" target="_blank" href="/ocr-with-akka-tesseract-and-javacv-part-1-702781fc73ca">上一篇文章</a>。它只是用来显示我们是如何得到 OCR 文本结果的。</p></blockquote><h1 id="8824" class="ml mm it bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">快速洞察</h1><p id="a8fd" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">以上给了我一些不错的结果，但如果能看到图像随着每个阶段的变化会更好。计划是连接一个<code class="fe le lf lg lh b">ImageSink</code>将图像写入文件。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/8e150e8d1b4b390c720080df721c1898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3n2bB2sg-mclDhErdD3kg.png"/></div></div></figure><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ffdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们运行应用程序并上传样本文件时，我们可以在项目的根目录中看到预处理的 3 个不同阶段:</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/47426f95cb89cee52b1f8359b36152ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ApMPUr5jX3fJB_YsbMtk-w.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">原始、二进制、增强、消除倾斜</p></figure><p id="0066" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从 Tesseract 的 OCR 过程返回的文本是:</p><pre class="lj lk ll lm gt ns lh nt nu aw nv bi"><span id="0069" class="nw mm it lh b gy nx ny l nz oa">CHAPTER 1 THE COMPOUND EFFECT IN ACTION You know that expression, “Slow and steady wins the race”? Ever heard the story of the tortoise and the hare? Ladies and gentlemen, I’m the tortoise. Give me enough time, and I will beat virtually anybody, anytime, in any competition. Why? Not because I’m the best or the smartest or the fastest. I’ll win because of the positive habits I’ve developed, and because of the consistency J use in applying those habits. I’m the world’s biggest believer in consistency. I'm living proof that it’s the ultimate key to success, yet it’s one of the biggest pitfalls for people struggling to achieve. Most people don’t know how to sustain it. I do. Ihave my father to thank for that. In essence, he was my first coach for igniting the power of the Compound Effect. My parents divorced when I was eighteen months old, and my dad raised me as a single father. He wasn’t exactly</span></pre><p id="5cee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过扫描，我们可以看到两个错误，<code class="fe le lf lg lh b">consistency <strong class="ki iu">J</strong> use in applying</code>和<code class="fe le lf lg lh b"><strong class="ki iu">Ihave</strong> my father to thank</code>。不错的成绩！但是，让我们通过更多的处理阶段来运行 OCR 结果，从而变得更加智能；拼写检查、自然语言处理和日期提取。😎</p><h1 id="4b6b" class="ml mm it bd mn mo mp mq mr ms mt mu mv mw ob my mz na oc nc nd ne od ng nh ni bi translated">OCR 后处理</h1><p id="4c69" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">我们的 OCR 流程将变成:</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/0675e541f82169fa263e8892c6fdbe5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RapNHCIY9E5xVxETcFLRvA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">新的 OCR 后处理阶段</p></figure><h2 id="f60c" class="nw mm it bd mn of og dn mr oh oi dp mv kr oj ok mz kv ol om nd kz on oo nh op bi translated">拼写检查</h2><p id="1e3b" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">首先，我们将添加一个拼写检查器。我在这里买了 100 本英语词典。我们可以将它们添加到我们的资源目录中，并创建这个拼写特征:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dde0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们确保我们的主要对象扩展了这一特性:</p><pre class="lj lk ll lm gt ns lh nt nu aw nv bi"><span id="8900" class="nw mm it lh b gy nx ny l nz oa">object Main extends App with OCR with Spell</span></pre><p id="3416" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以添加一个遵循<code class="fe le lf lg lh b">Flow[String]</code>协议的拼写检查方法。它删除换行符、大部分标点符号，并过滤拼写错误的单词。对于每个拼写错误的单词，我们会添加一个建议列表。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9881" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你运行 OCR 应用程序(<code class="fe le lf lg lh b">sbt run</code>)并上传一张图片，你会看到潜在的拼写错误和建议列表。对于上面的图像，我们得到以下结果:</p><pre class="lj lk ll lm gt ns lh nt nu aw nv bi"><span id="9190" class="nw mm it lh b gy nx ny l nz oa">{ <br/>   <strong class="lh iu">"ocr"</strong>:"...",<br/>   <strong class="lh iu">"suggestions"</strong>:[<br/>      {<br/>         <strong class="lh iu">"Ihave"</strong>:["Have", "Shave", "I have"]<br/>      }<br/>   ]<br/>}</span></pre><h2 id="2e57" class="nw mm it bd mn of og dn mr oh oi dp mv kr oj ok mz kv ol om nd kz on oo nh op bi translated">命名实体识别</h2><p id="78d3" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">接下来，我们将添加一个阶段来尝试和识别命名实体，特别是人。对于 NLP，我们将按字符进行标记，但是让我们也添加一个句子模型。我们使用以下模型创建 NLP 特征:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e0a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的主要对象也扩展了 NLP…</p><pre class="lj lk ll lm gt ns lh nt nu aw nv bi"><span id="356a" class="nw mm it lh b gy nx ny l nz oa">object Main extends App with OCR with Spell with NLP</span></pre><p id="92e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在可以建造我们的提取者<code class="fe le lf lg lh b">Flow</code>。注意，这个流接收一个类型的<code class="fe le lf lg lh b">OcrSuggestions</code>，输出一个<code class="fe le lf lg lh b">OcrSuggestionsPersons</code>类型。该类型与<code class="fe le lf lg lh b">OcrSuggestions</code>相同，但也包含一个“Persons”字符串列表。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ff9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经构建了 3 个附加流中的 2 个，最后需要添加一些数据提取:</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/fe81b4f94675ed513f4d8f07ee49e339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H67RNQ4Kyob_ubvQgmRHLQ.png"/></div></div></figure><h2 id="0934" class="nw mm it bd mn of og dn mr oh oi dp mv kr oj ok mz kv ol om nd kz on oo nh op bi translated">日期提取</h2><p id="29c3" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">从文本中提取日期有许多选择。我决定使用<a class="ae kf" href="http://natty.joestelmach.com/" rel="noopener ugc nofollow" target="_blank"> Natty </a>，但对试用 diggamma . ia 的<a class="ae kf" href="https://github.com/digamma-ai/timeextractor" rel="noopener ugc nofollow" target="_blank"> timeextractor 很感兴趣。</a></p><p id="f743" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我决定使用 OpenNLP 将 Tesseract 返回的整个文本拆分成句子，然后将这些句子传递给 Natty。让我们来看看我们简单整洁的特点:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9b93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们和我们的主要目标结合得很好</p><pre class="lj lk ll lm gt ns lh nt nu aw nv bi"><span id="e5e7" class="nw mm it lh b gy nx ny l nz oa">object Main extends App with OCR with Spell with NLP with Natty</span></pre><p id="67f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以构建一个<code class="fe le lf lg lh b">Flow</code>，它接受一个<code class="fe le lf lg lh b">OcrSuggestionsPersons</code>类型并输出一个<code class="fe le lf lg lh b">OcrSuggestionsPersonsDates</code>类型:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7652" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在已经完成了 OCR 流程！</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/0675e541f82169fa263e8892c6fdbe5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RapNHCIY9E5xVxETcFLRvA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">最终 OCR 流程</p></figure><p id="a315" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们对上图的最新回应是:</p><pre class="lj lk ll lm gt ns lh nt nu aw nv bi"><span id="a39c" class="nw mm it lh b gy nx ny l nz oa">{</span><span id="b69f" class="nw mm it lh b gy or ny l nz oa"><strong class="lh iu">   "suggestions"</strong>:[{<br/>      <strong class="lh iu">"Ihave"</strong>:["Have", "Shave", "I have"]<br/>   }],<br/>   <strong class="lh iu">"persons"</strong>:["Ladies"],<br/>   <strong class="lh iu">"dates"</strong>:[[<br/>       ["Wed Aug 11 16:20:57 PDT 2021"],<br/>        "eighteen months"<br/>   ]]</span><span id="2942" class="nw mm it lh b gy or ny l nz oa">}</span></pre><p id="d47b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，Natty 将“十八个月”解析为“从现在起十八个月”NLP 将“女士”标记为人称代词。我们可以争论这些元数据有多有用，但最终它比我们以前拥有的数据更多。</p><p id="7f65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你上传一张图片，同时我们的应用程序的网页在<a class="ae kf" href="http://localhost:8080," rel="noopener ugc nofollow" target="_blank"> http://localhost:8080，</a>运行，你会看到我高亮显示的各种结果的 HTML:</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi os"><img src="../Images/3d733f7ce56239e51b6eb18bf53c2f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SLhZZWfwB_Gf3ouowm_cSw.png"/></div></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="4220" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们尝试不同的图像…</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ot"><img src="../Images/cf278a8c19bb5988de4af617c7c89d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bYlnnNV9rDRA0dLjXx39eA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">如果你能说出这本书的名字，加分:)</p></figure><p id="f1db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这会产生以下内容作为 JSON 响应的一部分:</p><pre class="lj lk ll lm gt ns lh nt nu aw nv bi"><span id="9837" class="nw mm it lh b gy nx ny l nz oa"><strong class="lh iu">"persons"</strong>:["Gamble","Duncan"],<br/><strong class="lh iu">"dates"</strong>:[["Tue Feb 11 12:00:00 PST 2020"], "afternoon"]</span></pre><p id="f2e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的简单网页上的输出如下:</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ou"><img src="../Images/c33a9aa781eefa22635f14b61fe1f842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zoaa0GgCJF8A56v1H6SNPQ.png"/></div></div></figure><p id="cea4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OpenNLP 决定将“Duncan”和“Gamble”标记为 people，Hunspell 将“go-getters”标记为潜在的拼写错误，Natty 决定“午后”是 2020 年 2 月 11 日这一天的午后。</p><p id="67e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">😎希望你喜欢这第二个帖子！和往常一样，所有代码都在<a class="ae kf" href="https://github.com/duanebester/streaming-ocr" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>中进行了更新。</p></div></div>    
</body>
</html>