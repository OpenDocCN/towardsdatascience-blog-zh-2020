<html>
<head>
<title>3 Algorithm Interview Questions For Data Science and Software Engineering in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3 Python 中数据科学与软件工程的算法面试问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-algorithm-interview-questions-for-data-science-and-software-engineering-in-python-29fc86a07a6f?source=collection_archive---------14-----------------------#2020-05-15">https://towardsdatascience.com/3-algorithm-interview-questions-for-data-science-and-software-engineering-in-python-29fc86a07a6f?source=collection_archive---------14-----------------------#2020-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="47c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">熟悉常见的算法问题，为下一次面试做好准备</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c80894b9cfbf0f3ab10f862d42e74b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sMlpX6AWMp_Z1r9mNjq7xg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3373119" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/Tumisu-148124/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3373119" rel="noopener ugc nofollow" target="_blank"> Tumisu </a></p></figure><p id="cbfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我上一次数据科学面试 90%都是 python 算法问题。</p><p id="1fe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然你应该准备好解释一个 p 值，你也应该准备好回答传统的软件工程问题。</p><p id="87ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">算法问题是一种可以学习的技能，公司用它来淘汰没有准备好的候选人。</p><p id="5ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是 3 个常见的算法问题和答案，在难度谱的容易端。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3a88" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题 1:检查两个字符串是否是字谜</h1><p id="c098" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">变位词是通过重新排列另一个字符串中的字符而创建的字符串。</p><h2 id="fc06" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">说明:</h2><ol class=""><li id="6ba2" class="nl nm it lb b lc mu lf mv li nn lm no lq np lu nq nr ns nt bi translated">给定两个字符串，<code class="fe nu nv nw nx b">s1</code>和<code class="fe nu nv nw nx b">s2</code>，如果它们互为变位词，则返回<code class="fe nu nv nw nx b">True</code>。</li><li id="c8ba" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">必须使用所有字符。</li></ol><h2 id="e514" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">代码:</h2><p id="9a0d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="od">把这个复制到本地的一个代码编辑器里，写一个函数解决这个问题。</em></p><pre class="kj kk kl km gt oe nx of og aw oh bi"><span id="f4db" class="mz md it nx b gy oi oj l ok ol">def anagram(s1, s2):<br/>  #<br/>  # your code here<br/>  #</span></pre><h2 id="05f2" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">检查您的答案:</h2><p id="3b98" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="od">运行此程序以确认您的功能按预期运行。</em></p><pre class="kj kk kl km gt oe nx of og aw oh bi"><span id="55ef" class="mz md it nx b gy oi oj l ok ol">assert anagram('word', 'wodr')<br/>assert not anagram('dog', 'dogg')<br/>assert anagram('racecar', 'carrace')</span></pre><h2 id="283b" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">解决方案:</h2><p id="971d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个解决方案，但不是唯一的解决方案。</p><pre class="kj kk kl km gt oe nx of og aw oh bi"><span id="7c4e" class="mz md it nx b gy oi oj l ok ol">def anagram(s1, s2):<br/>    c1 = {}<br/>    c2 = {}<br/>    <br/>    def count_chars(s):<br/>        h = {}<br/>        for char in s:<br/>            if char in h:<br/>                h[char] += 1<br/>            else:<br/>                h[char] = 1<br/>        return h</span><span id="40d1" class="mz md it nx b gy om oj l ok ol">return count_chars(s1) == count_chars(s2)</span></pre><p id="4028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面，我们用每个字符串中的字符数创建了字典，然后比较字典的相等性。</p><p id="3804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间复杂度是 O(n) ,因为字符串迭代和字典查找依赖于输入字符串的长度。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2b6e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题 2:找出添加到句子中的单词</h1><h2 id="ee66" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">说明:</h2><ol class=""><li id="091f" class="nl nm it lb b lc mu lf mv li nn lm no lq np lu nq nr ns nt bi translated">给定一个句子，<code class="fe nu nv nw nx b">sent1</code>，以及带有附加词的同一个句子，<code class="fe nu nv nw nx b">sent2</code>，返回附加词。</li><li id="1776" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">每一句话，<code class="fe nu nv nw nx b">s1</code>，至少会有 1 个单词。</li></ol><h2 id="731f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">代码:</h2><pre class="kj kk kl km gt oe nx of og aw oh bi"><span id="b0c5" class="mz md it nx b gy oi oj l ok ol">def extra_word(sent1, sent2):<br/>  #<br/>  # your code here<br/>  #</span></pre><h2 id="e242" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">检查您的答案:</h2><pre class="kj kk kl km gt oe nx of og aw oh bi"><span id="a720" class="mz md it nx b gy oi oj l ok ol">assert extra_word('This is a dog', 'This is a fast dog') == 'fast'<br/>assert extra_word('answer', 'The answer') == 'The'<br/>assert extra_word('Can you solve algorithm questions', 'Can you solve hard algorithm questions') == 'hard'</span></pre><h2 id="a129" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">解决方案:</h2><pre class="kj kk kl km gt oe nx of og aw oh bi"><span id="86f4" class="mz md it nx b gy oi oj l ok ol">def extra_word(sent1, sent2):<br/>    words = {}<br/>    <br/>    for word in sent1.split(' '):<br/>        if word in words:<br/>            words[word] += 1<br/>        else:<br/>            words[word] = 1<br/>            <br/>    for word in sent2.split(' '):<br/>        if word in words:<br/>            words[word] -= 1<br/>        else:<br/>            return word</span></pre><p id="5c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面，我们通过字典统计了第一句话的单词。然后从同一本字典中减去第二句话中的单词。不在字典中的单词是要返回的单词。</p><p id="239d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间复杂度是<strong class="lb iu"> O(n) </strong>因为我们对每个句子迭代一次。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9254" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题 3:嘶嘶的嗡嗡声</h1><p id="74f4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是经典的<a class="ae ky" href="https://news.ycombinator.com/item?id=20778669" rel="noopener ugc nofollow" target="_blank"> fizzbuzz 面试问题</a>。</p><h2 id="52f8" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">说明:</h2><ol class=""><li id="878d" class="nl nm it lb b lc mu lf mv li nn lm no lq np lu nq nr ns nt bi translated">给定<code class="fe nu nv nw nx b">n</code>，返回从<code class="fe nu nv nw nx b">1</code>到<code class="fe nu nv nw nx b">n</code>的每个整数的值列表。</li><li id="0729" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">如果一个数能被 3 整除，则返回<code class="fe nu nv nw nx b">'Fizz'</code>代替它。</li><li id="34f2" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">如果这个数能被 5 整除，则返回<code class="fe nu nv nw nx b">'Buzz'</code>代替它。</li><li id="49f4" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">如果数字能被 3 和 5 整除，则返回<code class="fe nu nv nw nx b">'FizzBuzz'</code>代替它。</li></ol><h2 id="cd5d" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">代码:</h2><pre class="kj kk kl km gt oe nx of og aw oh bi"><span id="da9c" class="mz md it nx b gy oi oj l ok ol">def fizzbuzz(n):<br/>  #<br/>  # your code here<br/>  #</span></pre><h2 id="faf4" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">检查您的答案:</h2><pre class="kj kk kl km gt oe nx of og aw oh bi"><span id="30db" class="mz md it nx b gy oi oj l ok ol">output = fizzbuzz(1000)</span><span id="8bc8" class="mz md it nx b gy om oj l ok ol">assert output[8] == 'Fizz'<br/>assert output[99] == 'Buzz'<br/>assert output[198] == 199<br/>assert output[510] == 511<br/>assert output[998] == 'Fizz'</span></pre><h2 id="c947" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">解决办法</h2><pre class="kj kk kl km gt oe nx of og aw oh bi"><span id="2bf3" class="mz md it nx b gy oi oj l ok ol">def fizzbuzz(n):<br/>    answer = []<br/>    for i in range(1,n+1):<br/>        if i % 3 == 0 and i % 5 == 0:<br/>            answer.append("FizzBuzz")<br/>        elif i % 3 == 0:<br/>            answer.append("Fizz")<br/>        elif i % 5 == 0:<br/>            answer.append("Buzz")<br/>        else:<br/>            answer.append(i)<br/>    return answer</span></pre><p id="62e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面，我们创建了一个给定值列表<code class="fe nu nv nw nx b">n</code>。然后遍历每个值，并将值 Fizz、Buzz 或 FizzBuzz 添加到列表中。</p><p id="a2c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间复杂度是<strong class="lb iu"> O(n) </strong>因为我们遍历列表一次。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2294" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="75a4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="od">您是否对每周 5 个算法问题和答案的系列感兴趣？请在评论中告诉我。</em></p><p id="bcc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于算法问题，这些都很简单，并且都可以在 O(n)时间复杂度内解决。但是如果你不熟悉这类问题，最好从基础开始。</p><p id="6afc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在可预见的未来，算法问题将成为数据科学和软件工程面试的一部分。掌握这项技能的最好方法是每周做几道题。这样，如果你需要申请新的工作，你就可以随时准备好。</p></div></div>    
</body>
</html>