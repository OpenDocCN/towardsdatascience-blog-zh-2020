<html>
<head>
<title>Performance of numpy and pandas — comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫和熊猫的性能比较</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/performance-of-numpy-and-pandas-comparison-7b3e0bea69bb?source=collection_archive---------30-----------------------#2020-01-13">https://towardsdatascience.com/performance-of-numpy-and-pandas-comparison-7b3e0bea69bb?source=collection_archive---------30-----------------------#2020-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="27b2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用 python 实现算法时的常见错误及 pandas 和 numpy 中常用方法的效率分析。</h2></div><h1 id="d9a1" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">介绍</h1><p id="ee24" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">没有<strong class="lc iu"> numpy </strong>和<strong class="lc iu"> pandas </strong>，Python 中似乎就没有数据科学。(这也是 Python 在数据科学领域如此受欢迎的原因之一)。然而，将库转储到数据上很难保证性能。那到底怎么了？</p><p id="bb37" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">让我们从根本问题开始。在设计算法时，许多涉及计算的任务可以归纳为以下几类:</p><ul class=""><li id="0ac4" class="mb mc it lc b ld lw lg lx lj md ln me lr mf lv mg mh mi mj bi translated">给定条件下数据子集的选择，</li><li id="6085" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated">对每个数据/表格条目应用数据转换函数，</li><li id="d87b" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated">向量矩阵乘法(也称为典型的线性代数)。</li></ul><p id="fb05" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在本帖中，我们将尝试对这三种最常见的操作进行更多的阐述，并尝试理解发生了什么。对于所有的性能评估，我们使用了:</p><ul class=""><li id="6cb0" class="mb mc it lc b ld lw lg lx lj md ln me lr mf lv mg mh mi mj bi translated">Python 版本 3.6.7，</li><li id="bdb0" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated">Numpy 1.16.4 和熊猫 0.24.2，</li><li id="c754" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated">Ubuntu 16.04，</li><li id="f201" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated">电脑:英特尔酷睿 i5–7200 u CPU @ 2.50 GHz，</li><li id="e826" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated">IPython 和<code class="fe mp mq mr ms b">%timeit</code>命令。</li></ul><h1 id="4809" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">性能测试</h1><h2 id="b877" class="mt kj it bd kk mu mv dn ko mw mx dp ks lj my mz ku ln na nb kw lr nc nd ky ne bi translated">案例 1:数据子集的选择</h2><p id="9ced" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于第一种情况，我们从均匀随机生成的数据中选择一个正值子集。此外，我们以<em class="nf"> numpy </em>数组和<em class="nf"> pandas </em>数据帧的形式组织数据，作为大小为<code class="fe mp mq mr ms b">1 x N</code>的一维对象或大小为<code class="fe mp mq mr ms b">sqrt(N) x sqrt(N)</code>的二维数组，其中<code class="fe mp mq mr ms b">N</code>是元素的数量。对于每个<code class="fe mp mq mr ms b">N</code>，我们测试以下操作:</p><pre class="ng nh ni nj gt nk ms nl nm aw nn bi"><span id="a886" class="mt kj it ms b gy no np l nq nr">if DIM == 1:<br/>    npx = np.random.randn(N)<br/>else:<br/>    N = int(N**0.5)<br/>    npx = np.random.randn(N, N)<br/>dfx = pd.DataFrame(npx)</span><span id="3dbf" class="mt kj it ms b gy ns np l nq nr"># explicit loop (DIM == 1)<br/>%timeit [x &gt; 0 for x in npx]<br/># explicit loop (DIM == 2)                <br/>%timeit [x &gt; 0 for x in [y for y in npx]]   <br/><br/>%timeit npx &gt; 0                             # numpy<br/>%timeit np.where(npx &gt; 0, True, False)      # np.where<br/>%timeit dfx &gt; 0                             # dataframe<br/>%timeit dfx.applymap(lambda x: x &gt; 0)       # applymap<br/>%timeit dfx.apply(lambda x: x &gt; 0, axis=0)  # apply, axis=0<br/>%timeit dfx.apply(lambda x: x &gt; 0, axis=1)  # apply, axis=1<br/>%timeit dfx.pipe(lambda x: x &gt; 0)           # pipe</span></pre><figure class="ng nh ni nj gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nt"><img src="../Images/737c98e209da5ad43f1c6131d60c1660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gENr0IfasKD8GLJV.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">图一。选择数据子集。左图:一维数组。右图:二维数组。</p></figure><p id="1502" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">首先，<code class="fe mp mq mr ms b">numpy</code>无论如何是最快的。原因是它是 C 编译的，并且存储相同类型的数字(参见<a class="ae of" href="https://en.wikipedia.org/wiki/Locality_of_reference" rel="noopener ugc nofollow" target="_blank">这里的</a>)，与显式循环相反，它不对指向对象的指针进行操作。<code class="fe mp mq mr ms b">np.where</code>函数是在 numpy 数组上实现元素条件的常用方法。它经常派上用场，但是它的性能代价很小，这与函数调用的开销有关。</p><p id="077a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">当谈到 pandas dataframes 时，它们的主要优势是能够存储不同类型的关联数据，这改进了数据分析过程和代码可读性。同时，这种灵活性也是 dataframes 在性能方面的主要缺点。查看图 1，我们可以看到，无论数组大小如何，调用计算都需要付出 1 毫秒的初始代价。然后，剩下的就只看数组大小和…它的元素排列了！</p><p id="3fc1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><code class="fe mp mq mr ms b">x &gt; 0</code>是一个非常简单的条件，可以应用于任何数值数据。因为我们所有的日期元素都是数字，所以可以在所有行(<code class="fe mp mq mr ms b">df.apply(..., axis=0)</code>、列(<code class="fe mp mq mr ms b">df.apply(..., axis=1)</code>)、元素方式(<code class="fe mp mq mr ms b">df.applymap</code>)或整个数据帧(<code class="fe mp mq mr ms b">df.pipe</code>)上应用它，因此它给了我们一个很好的测试方法。比较一维数组和二维数组，我们可以立即发现<code class="fe mp mq mr ms b">apply</code>方法中<code class="fe mp mq mr ms b">axis</code>参数的重要性。虽然我们的数据可能不总是允许我们在这些方法之间进行选择，但是我们应该尝试沿着最短的轴(在这个例子中是列)对<em class="nf">进行矢量化。如果列数和行数相当，那么<code class="fe mp mq mr ms b">df.applymap</code>或<code class="fe mp mq mr ms b">df.pipe</code>是更好的选择。</em></p><p id="b1d0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">最后但同样重要的是，可以注意到阵列的形状也会影响缩放比例。除了 numpy(在初始常数之后)，数据帧上的执行时间不是线性的。尽管如此，与 numpy 和 pandas 方法相关的执行时间之间可能的交叉似乎发生在至少有<code class="fe mp mq mr ms b">1e15</code>个元素的区域，这就是云计算的用武之地。</p><h2 id="b16f" class="mt kj it bd kk mu mv dn ko mw mx dp ks lj my mz ku ln na nb kw lr nc nd ky ne bi translated">案例 2:对数据应用原子函数</h2><p id="1e91" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，让我们看看应用一个简单的原子计算需要什么:对每个数求平方根。为了避免陷入复数，让我们只使用正数。此外，我们引入了<code class="fe mp mq mr ms b">vsqrt</code>——<code class="fe mp mq mr ms b">sqrt</code>函数的矢量化版本(但不等同于<code class="fe mp mq mr ms b">np.sqrt</code>),以便考虑将外来函数引入 numpy 的情况。最后，我们来看看直接通过<code class="fe mp mq mr ms b">.apply</code>调用<code class="fe mp mq mr ms b">sqrt</code>，还是通过一个<code class="fe mp mq mr ms b">lambda</code>调用<code class="fe mp mq mr ms b">sqrt</code>的区别。</p><p id="7d5a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们测试以下功能:</p><pre class="ng nh ni nj gt nk ms nl nm aw nn bi"><span id="a34f" class="mt kj it ms b gy no np l nq nr">if DIM == 1:<br/>    npx = np.random.random((N, 1))<br/>else:<br/>    N = int(N**0.5)<br/>    npx = np.random.random((N, N))<br/>dfx = pd.DataFrame(npx)<br/><br/>def sqrt(x):<br/>    return x**0.5<br/><br/>vsqrt = np.vectorize(sqrt)<br/># explicit loop (DIM == 1)<br/>%timeit [sqrt(x) for x in npx]<br/># explicit loop (DIM == 2)                  <br/>%timeit [sqrt(x) for x in [y for y in npx]]<br/>     <br/>%timeit sqrt(npx)                               # numpy<br/>%timeit vsqrt(npx)                              # np.vectorize<br/>%timeit dfx.applymap(sqrt(x))                   # df.applymap<br/>%timeit dfx.apply(sqrt, axis=0)                 # df.apply, axis=0<br/>%timeit dfx.apply(sqrt, axis=1)                 # df.apply, axis=1<br/>%timeit dfx.apply(lambda x: sqrt(x), axis=0)    # df.apply, axis=0, as lambda<br/>%timeit dfx.apply(lambda x: sqrt(x), axis=1)    # df.apply, axis=1, as lambda</span></pre><figure class="ng nh ni nj gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nt"><img src="../Images/9174ebea8a34eae4bba7fb1e4079a325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*biGRv30ci-cuGr_O.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">图二。对数据应用函数。左图:一维数组。右图:二维数组。</p></figure><p id="9d5e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">同样，基本 numpy 击败了所有其他方法。与前一种情况相比，我们还可以看到 pandas dataframe 对象的类似行为。</p><p id="9932" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">然而，有趣的是，与显式循环相比，平方根函数的矢量化形式似乎表现不佳。虽然对于 1 维阵列几乎相同，但对于 2 维情况，它的性能远不如 loop，甚至不如 pandas。如果原始函数相对更复杂，包含多个循环和条件，也许它确实有意义？无论如何，构造可以直接应用于 numpy 数组的函数似乎更有效。</p><p id="86f0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">最后，图 2。显示了使用<code class="fe mp mq mr ms b">lambda</code>或直接调用<code class="fe mp mq mr ms b">df.apply</code>方法之间没有实际区别。匿名函数确实提供了更多的灵活性(当<code class="fe mp mq mr ms b">x</code>变成行或列时)，但是这里没有损失。</p><h2 id="9d72" class="mt kj it bd kk mu mv dn ko mw mx dp ks lj my mz ku ln na nb kw lr nc nd ky ne bi translated">案例 3:向量矩阵乘法</h2><p id="0c00" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后，本文的最后一个案例涉及到最常见的数字运算之一:计算向量和矩阵之间的点积。数学上，这个操作可以定义为<code class="fe mp mq mr ms b">y = A x</code>，其中<code class="fe mp mq mr ms b">y</code>的每个元素都是通过取</p><figure class="ng nh ni nj gt nu gh gi paragraph-image"><div class="gh gi og"><img src="../Images/969b3400c1a520f3233522f8687ee935.png" data-original-src="https://miro.medium.com/v2/resize:fit:262/0*tRYCBtpJ3Yo0X0h3"/></div></figure><p id="72f7" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><code class="fe mp mq mr ms b">M</code>次，对于<code class="fe mp mq mr ms b">N x M</code>数组，产生<code class="fe mp mq mr ms b">NM</code>乘法和<code class="fe mp mq mr ms b">N(M — 1)</code>加法。</p><p id="4736" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">暂时把熊猫放在一边，numpy 已经提供了一堆功能可以做同样的事情。</p><ul class=""><li id="2c3b" class="mb mc it lc b ld lw lg lx lj md ln me lr mf lv mg mh mi mj bi translated"><a class="ae of" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html" rel="noopener ugc nofollow" target="_blank"> np.dot </a> —两个数组的类属点积，</li><li id="4148" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated"><a class="ae of" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html" rel="noopener ugc nofollow" target="_blank"> np.matmul </a> —将所有数组的元素视为矩阵，</li><li id="fc6d" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated"><a class="ae of" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html" rel="noopener ugc nofollow" target="_blank"> np.inner </a> —替代<code class="fe mp mq mr ms b">np.dot</code>，但灵活性降低，</li><li id="244e" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated"><a class="ae of" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.tensordot.html" rel="noopener ugc nofollow" target="_blank"> np.tensordot </a> —最一般的(一般化到张量)点积。</li></ul><p id="e6e7" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">为简单起见，我们使用一个方阵，并计算以下维度的乘积<code class="fe mp mq mr ms b">(N x M) x (N x 1)</code>，产生<code class="fe mp mq mr ms b">N(2N — 1)</code>运算。</p><pre class="ng nh ni nj gt nk ms nl nm aw nn bi"><span id="cb37" class="mt kj it ms b gy no np l nq nr">A = np.random.randn(N, N)<br/>X = np.random.randn(N)<br/><br/>def naive(A, X):<br/>    Y = np.zeros(A.shape[1])<br/>    for i in range(A.shape[0]):<br/>        for j in range(A.shape[1]):<br/>            Y[j] += A[i, j]*X[i]<br/>    return Y<br/><br/>%timeit naive(A, X)<br/>%timeit np.dot(A, X)<br/>%timeit np.matmul(A, X)<br/>%timeit np.inner(A, X)<br/>%timeit np.tensordot(A, X, axes=1)</span></pre><figure class="ng nh ni nj gt nu gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d428215417004571757d2343a2d5c13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/0*z5CNGhMjQygkOXcA.png"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">图 3。向量矩阵乘法。黑色虚线表示操作次数。</p></figure><p id="28af" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">从图 3 中可以明显看出，定制的基于循环的实现甚至要差三个数量级。同时，上面列出的点积的不同变体之间没有真正的区别。最初的平坦特征可以用与函数调用本身相关联的惩罚来解释。函数越复杂(如<code class="fe mp mq mr ms b">np.tensordot</code>)，它就变得越高。然而，一旦数字相对较大，执行时间就由实际计算时间决定，而实际计算时间对于初始函数来说是不可知的。</p><h1 id="fa1a" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论</h1><p id="d3ee" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">研究了这三个案例后，以下建议是有意义的:</p><ul class=""><li id="8b26" class="mb mc it lc b ld lw lg lx lj md ln me lr mf lv mg mh mi mj bi translated">数学永远用 numpy，避免“幼稚计算”。</li><li id="9c88" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated">如果存在 numpy 本地方法，最好使用它们。</li><li id="be31" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated">如果没有，至少尝试将数据封装在 numpy 数组中。</li><li id="6df6" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated">如果使用熊猫数据帧，使用<code class="fe mp mq mr ms b">apply</code>、<code class="fe mp mq mr ms b">applymap</code>和<code class="fe mp mq mr ms b">pipe</code>。</li><li id="71a7" class="mb mc it lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated">但是，请记住，数据帧的形状会强烈影响特别是<code class="fe mp mq mr ms b">apply</code>方法的性能。</li></ul><p id="f56b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">那么…你的代码还是运行缓慢吗？再找找看！也许现在还不是从 python 转向 C 的时候？也许还有一两种方法可以让整个事情慢下来，或者你甚至已经进行了计算<a class="ae of" href="https://en.wikipedia.org/wiki/Seppuku" rel="noopener ugc nofollow" target="_blank">切腹自杀</a>？</p><h1 id="48e0" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">还会有更多…</h1><p id="f1b4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我计划把文章带到下一个层次，并提供简短的视频教程。</p><p id="b613" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如果您想获得关于视频和未来文章的更新，<strong class="lc iu">订阅我的</strong> <a class="ae of" href="https://landing.mailerlite.com/webforms/landing/j5y2q1" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iu">简讯</strong> </a> <strong class="lc iu">。你也可以通过填写<a class="ae of" href="https://forms.gle/bNpf9aqZJGLgaU589" rel="noopener ugc nofollow" target="_blank">表格</a>让我知道你的期望。回头见！</strong></p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><p id="af91" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><em class="nf">原载于</em><a class="ae of" href="https://zerowithdot.com/python-numpy-and-pandas-performance/" rel="noopener ugc nofollow" target="_blank"><em class="nf">https://zerowithdot.com</em></a><em class="nf">。</em></p></div></div>    
</body>
</html>