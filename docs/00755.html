<html>
<head>
<title>Adversarial Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对抗验证</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/adversarial-validation-ca69303543cd?source=collection_archive---------31-----------------------#2020-01-21">https://towardsdatascience.com/adversarial-validation-ca69303543cd?source=collection_archive---------31-----------------------#2020-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="de6e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">过度拟合的诊断工具</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/986a38a03d7176f6b34240dfd18a37f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dgx0Aojqvh6KYto3"/></div></div></figure><p id="7860" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">想和其他学习 ML 的人聊天？加入我们的</em> <a class="ae lo" href="http://discord.gg/xh2chKX" rel="noopener ugc nofollow" target="_blank"> <em class="ln">新 ML 不和谐服务器</em> </a> <em class="ln">！</em></p><p id="9fe5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">本帖原载于</em><a class="ae lo" href="https://blog.zakjost.com/post/adversarial_validation/" rel="noopener ugc nofollow" target="_blank"><em class="ln">blog.zakjost.com</em></a><em class="ln">。去那里可以更好地呈现内联代码。</em></p><h1 id="2ac6" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">介绍</h1><p id="c008" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">如果你在 Kaggle 上研究一些竞争获胜的解决方案，你可能会注意到提到“对抗性验证”(<a class="ae lo" href="https://www.kaggle.com/c/ieee-fraud-detection/discussion/111284" rel="noopener ugc nofollow" target="_blank">就像这个</a>)。这是什么？</p><p id="bee8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简而言之，我们构建一个分类器来尝试预测哪些数据行来自训练集，哪些来自测试集。如果两个数据集来自同一个分布，这应该是不可能的。但是，如果在你的训练和测试数据集的特征值中存在系统差异，那么分类器将能够成功地学会区分它们。你能学会区分它们的模型越好，你的问题就越大。</p><p id="c547" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但好消息是，你可以分析学习过的模型来帮助你诊断问题。一旦你理解了问题，你就可以着手解决它。</p><p id="1df0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章是为了配合我制作的一个 YouTube 视频来解释对抗性验证的直觉。这篇博文介绍了本视频中示例的代码实现，但是足够完整，可以自成一体。你可以在 github 上找到这篇文章的完整代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="bac2" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">学习对抗性验证模型</h1><p id="468a" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">首先，用一些样板导入语句来避免混淆:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="743a" class="mt lq iq mp b gy mu mv l mw mx">import pandas as pd<br/>from catboost import Pool, CatBoostClassifier</span></pre><h1 id="cdb3" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">数据准备</h1><p id="ea03" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">对于本教程，我们将使用来自 Kaggle 的<a class="ae lo" href="https://www.kaggle.com/c/ieee-fraud-detection/data" rel="noopener ugc nofollow" target="_blank"> IEEE-CIS 信用卡欺诈检测数据集</a>。首先，我假设您已经将训练和测试数据加载到 pandas DataFrames 中，并分别将其命名为<code class="fe my mz na mp b">df_train</code>和<code class="fe my mz na mp b">df_test</code>。然后，我们将通过替换丢失的值来进行一些基本的清理。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="211c" class="mt lq iq mp b gy mu mv l mw mx"># Replace missing categoricals with "&lt;UNK&gt;"<br/>df_train.loc[:,cat_cols] = df_train[cat_cols].fillna('&lt;UNK&gt;')<br/>df_test.loc[:,cat_cols] = df_test[cat_cols].fillna('&lt;UNK&gt;')<br/><br/># Replace missing numeric with -999<br/>df_train = df_train.fillna(-999)<br/>df_test = df_test.fillna(-999)</span></pre><p id="04ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于对抗性验证，我们希望学习一个模型来预测哪些行在训练数据集中，哪些行在测试集中。因此，我们创建一个新的目标列，其中测试样本用<code class="fe my mz na mp b">1</code>标记，训练样本用<code class="fe my mz na mp b">0</code>标记，如下所示:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="94b9" class="mt lq iq mp b gy mu mv l mw mx">df_train['dataset_label'] = 0<br/>df_test['dataset_label'] = 1<br/>target = 'dataset_label'</span></pre><p id="1c9b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们将训练一个模型来预测的目标。现在，训练和测试数据集是分开的，每个数据集只有一个目标值标签。如果我们在<em class="ln">这个</em>训练集上训练一个模型，它会知道一切都是 0。相反，我们希望重组训练和测试数据集，然后创建新的数据集来拟合和评估对抗性验证模型。我定义了一个用于组合、洗牌和重新分割的函数:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="0f2f" class="mt lq iq mp b gy mu mv l mw mx">def create_adversarial_data(df_train, df_test, cols, N_val=50000):<br/>    df_master = pd.concat([df_train[cols], df_test[cols]], axis=0)<br/>    adversarial_val = df_master.sample(N_val, replace=False)<br/>    adversarial_train = df_master[<br/>        ~df_master.index.isin(adversarial_val.index)<br/>    ]<br/>    return adversarial_train, adversarial_val<br/><br/>features = cat_cols + numeric_cols + ['TransactionDT']<br/>all_cols = features + [target]<br/>adversarial_train, adversarial_test = create_adversarial_data(df_train, df_test, all_cols)</span></pre><p id="c1fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">新数据集<code class="fe my mz na mp b">adversarial_train</code>和<code class="fe my mz na mp b">adversarial_test</code>，包括原始训练集和测试集的混合，目标表示原始数据集。<em class="ln">注:我在特性列表中添加了</em> <code class="fe my mz na mp b"><em class="ln">TransactionDT</em></code> <em class="ln">。其原因将变得显而易见。</em></p><p id="4945" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于建模，我将使用 Catboost。我通过将数据帧放入 Catboost 池对象来完成数据准备。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="c8d8" class="mt lq iq mp b gy mu mv l mw mx">train_data = Pool(<br/>    data=adversarial_train[features],<br/>    label=adversarial_train[target],<br/>    cat_features=cat_cols<br/>)<br/>holdout_data = Pool(<br/>    data=adversarial_test[features],<br/>    label=adversarial_test[target],<br/>    cat_features=cat_cols<br/>)</span></pre><h1 id="6882" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">建模</h1><p id="2312" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">这一部分很简单:我们只需实例化一个 Catboost 分类器，并将其应用于我们的数据:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="b60b" class="mt lq iq mp b gy mu mv l mw mx">params = {<br/>    'iterations': 100,<br/>    'eval_metric': 'AUC',<br/>    'od_type': 'Iter',<br/>    'od_wait': 50,<br/>}<br/><br/>model = CatBoostClassifier(**params)<br/>_ = model.fit(train_data, eval_set=holdout_data)</span></pre><p id="d817" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们继续在维持数据集上绘制 ROC 曲线:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/27d336299913c405071014f4e1bd411a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/0*mMAYfcbUh8oCFlAe.png"/></div></figure><p id="c65c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个完美的模型，这意味着有一个明确的方法来判断任何给定的记录是在训练集还是测试集中。这违反了我们的训练集和测试集是同分布的假设。</p><h1 id="775a" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">诊断问题和迭代</h1><p id="c354" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">为了理解该模型是如何做到这一点的，让我们来看看最重要的特性:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f278dc3c0b8e19ac704383ffe05a9b04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/0*r3R4G9z-NTsQLTuS.png"/></div></figure><p id="1f89" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TransactionDT 是最重要的特性。考虑到原始的训练和测试数据集来自不同的时间段(测试集出现在训练集的未来)，这是完全有意义的。该模型刚刚了解到，如果 TransactionDT 大于上一个训练样本，则它在测试集中。</p><p id="e980" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我包含 TransactionDT 只是为了说明这一点——通常不建议将原始日期作为模型特征。但是好消息是这项技术以如此戏剧性的方式找到了它。这种分析将清楚地帮助您识别这样的错误。</p><p id="57ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们排除 TransactionDT，再次运行这个分析。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="2631" class="mt lq iq mp b gy mu mv l mw mx">params2 = dict(params)<br/>params2.update({"ignored_features": ['TransactionDT']})<br/>model2 = CatBoostClassifier(**params2)<br/>_ = model2.fit(train_data, eval_set=holdout_data)</span></pre><p id="bc85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在 ROC 曲线看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/efd2b1666e5fcd4988b513288ed283d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/0*oTQNo3NLgwwdSClK.png"/></div></figure><p id="f240" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它仍然是一个相当强的模型，AUC &gt; 0.91，但比以前弱了很多。让我们来看看该模型的功能重要性:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f61c5174decfb4d8e9f6e9f103b36c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/0*8lnxnZkh8LCeZ2_F.png"/></div></figure><p id="5003" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，<code class="fe my mz na mp b">id_31</code>是最重要的特性。让我们看一些价值观来理解它是什么。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="7b9a" class="mt lq iq mp b gy mu mv l mw mx">[<br/>    '&lt;UNK&gt;', 'samsung browser 6.2', 'mobile safari 11.0',<br/>    'chrome 62.0', 'chrome 62.0 for android', 'edge 15.0',<br/>    'mobile safari generic', 'chrome 49.0', 'chrome 61.0',<br/>]</span></pre><p id="5aa5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该列包含软件版本号。显然，这在概念上类似于包含原始日期，因为特定软件版本的第一次出现将对应于其发布日期。</p><p id="e7ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们通过从列中删除任何不是字母的字符来解决这个问题:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="8d27" class="mt lq iq mp b gy mu mv l mw mx">def remove_numbers(df_train, df_test, feature):<br/>    df_train.loc[:, feature] = df_train[feature].str.replace(<br/>        r'[^A-Za-z]', '', regex=True<br/>    )</span><span id="1ae7" class="mt lq iq mp b gy ne mv l mw mx">    df_test.loc[:, feature] = df_test[feature].str.replace(<br/>        r'[^A-Za-z]', '', regex=True<br/>    )<br/><br/>remove_numbers(df_train, df_test, 'id_31')</span></pre><p id="3adf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们列的值如下所示:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="3268" class="mt lq iq mp b gy mu mv l mw mx">[<br/>    'UNK', 'samsungbrowser', 'mobilesafari',<br/>    'chrome', 'chromeforandroid', 'edge',<br/>    'mobilesafarigeneric', 'safarigeneric',<br/>]</span></pre><p id="2ed9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们使用这个清理后的列来训练一个新的对抗性验证模型:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="88bf" class="mt lq iq mp b gy mu mv l mw mx">adversarial_train_scrub, adversarial_test_scrub = create_adversarial_data(<br/>    df_train,<br/>    df_test,<br/>    all_cols,<br/>)<br/><br/>train_data_scrub = Pool(<br/>    data=adversarial_train_scrub[features],<br/>    label=adversarial_train_scrub[target],<br/>    cat_features=cat_colsc<br/>)<br/><br/>holdout_data_scrub = Pool(<br/>    data=adversarial_test_scrub[features],<br/>    label=adversarial_test_scrub[target],<br/>    cat_features=cat_colsc<br/>)<br/><br/>model_scrub = CatBoostClassifier(**params2)<br/>_ = model_scrub.fit(train_data_scrub, eval_set=holdout_data_scrub)</span></pre><p id="c40d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ROC 图现在看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/4093d1c8fea0b1728611b300882db5c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/0*Mx9CCR493PBX62c0.png"/></div></figure><p id="2edc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">业绩从 0.917 的 AUC 下降到 0.906。这意味着我们已经使模型更难区分我们的训练和测试数据集，但它仍然非常有能力。</p><h1 id="a31d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">结论</h1><p id="7f72" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">当我们天真地将交易日期放入特性集时，对抗性的验证过程有助于清楚地诊断问题。额外的迭代给了我们更多的线索，即包含软件版本信息的列在训练集和测试集之间有明显的差异。</p><p id="9fce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是流程不能做的是告诉我们如何修复它。我们仍然需要在这里运用我们的创造力。在本例中，我们只是从软件版本信息中删除了所有数字，但这丢弃了潜在的有用信息，并可能最终损害我们的欺诈建模任务，而这正是我们的真正目标。这个想法是<em class="ln">你想删除对预测欺诈不重要的信息，但对分离你的训练和测试集很重要</em>。</p><p id="0a1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更好的方法可能是找到一个数据集，给出每个软件版本的软件发布日期，然后创建一个“自发布以来的天数”列来替换原始版本号。这可能有助于更好地匹配训练和测试分布，同时还保持软件版本信息编码的预测能力。</p><h1 id="8e5b" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">资源</h1><ul class=""><li id="fcac" class="nf ng iq kt b ku mh kx mi la nh le ni li nj lm nk nl nm nn bi translated">第一名卡格尔解决方案<a class="ae lo" href="https://www.kaggle.com/c/ieee-fraud-detection/discussion/111284" rel="noopener ugc nofollow" target="_blank">报道</a></li><li id="7071" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">对抗验证<a class="ae lo" href="https://youtu.be/7cUCDRaIZ7I" rel="noopener ugc nofollow" target="_blank"> YouTube 视频</a></li><li id="27c4" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">GitHub 上的<a class="ae lo" href="https://github.com/zjost/blog_code/tree/master/adversarial_validation" rel="noopener ugc nofollow" target="_blank">示例代码</a></li></ul></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="95c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">别忘了加入我们的</em> <a class="ae lo" href="http://discord.gg/xh2chKX" rel="noopener ugc nofollow" target="_blank"> <em class="ln">新 ML 不和谐服务器</em> </a> <em class="ln">！</em></p><p id="30ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">原载于 https://blog.zakjost.com</em><a class="ae lo" href="https://blog.zakjost.com/post/adversarial_validation/" rel="noopener ugc nofollow" target="_blank"><em class="ln"/></a><em class="ln">。</em></p></div></div>    
</body>
</html>