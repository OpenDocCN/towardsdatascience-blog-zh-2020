<html>
<head>
<title>What is Google API Vision? And how to use it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是 Google API 愿景？以及如何使用它</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-is-google-api-vision-and-how-to-use-it-372a83e6d02c?source=collection_archive---------32-----------------------#2020-08-28">https://towardsdatascience.com/what-is-google-api-vision-and-how-to-use-it-372a83e6d02c?source=collection_archive---------32-----------------------#2020-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e83eee2b3a044f4d75cfa72395ac73f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ywd_QK_ptvoPt5Tk0PAYBA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://www.pexels.com/fr-fr/@artunchained" rel="noopener ugc nofollow" target="_blank">曼努埃尔·盖辛格，</a>佩克斯</p></figure><div class=""/><div class=""><h2 id="4bff" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated"><em class="ky">使用服务帐户通过 OCR 从图像中提取文本。</em></h2></div><h2 id="5af0" class="kz la jj bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="47e1" class="pw-post-body-paragraph lv lw jj lx b ly lz kk ma mb mc kn md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这篇文章源于一个有趣的知识提取项目。第一步是提取 pdf 文档的文本。我工作的公司是基于 Google 平台的，所以很自然，我想使用 API Vision 的 OCR，但是找不到使用 API 提取文本的简单方法。所以这个帖子。</p><blockquote class="mo mp mq"><p id="fcf8" class="lv lw mr lx b ly ms kk ma mb mt kn md mu mv mf mg mw mx mi mj my mz ml mm mn im bi translated">这个帖子的笔记本可以在<a class="ae jg" href="https://github.com/Christophe-pere/API_vision_google" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到</p></blockquote><h2 id="d055" class="kz la jj bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">谷歌 API 愿景</h2><p id="d153" class="pw-post-body-paragraph lv lw jj lx b ly lz kk ma mb mc kn md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">谷歌发布了<a class="ae jg" href="https://cloud.google.com/vision" rel="noopener ugc nofollow" target="_blank"> API </a>来帮助人们、行业和研究人员使用他们的功能。</p><blockquote class="mo mp mq"><p id="d06b" class="lv lw mr lx b ly ms kk ma mb mt kn md mu mv mf mg mw mx mi mj my mz ml mm mn im bi translated">Google Cloud 的 Vision API 拥有强大的机器学习模型，通过 REST 和 RPC APIs 进行预训练。标记图像，并将它们快速组织到数百万个预定义的类别中。您将能够检测物体和人脸，阅读印刷或手写文本，并将有用的元数据集成到您的图像目录中。(来源:<a class="ae jg" href="https://cloud.google.com/vision" rel="noopener ugc nofollow" target="_blank"> API 视觉</a>)</p></blockquote><p id="31bd" class="pw-post-body-paragraph lv lw jj lx b ly ms kk ma mb mt kn md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">我们对这篇文章感兴趣的 API 部分是 OCR 部分。</p><h2 id="4a00" class="kz la jj bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">光学字符识别</h2><p id="83d2" class="pw-post-body-paragraph lv lw jj lx b ly lz kk ma mb mc kn md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated"><a class="ae jg" href="https://cloud.google.com/vision/docs/ocr" rel="noopener ugc nofollow" target="_blank">光学字符识别</a>或 OCR 是一种在图像内部识别和检测字符的技术。大多数时候，卷积神经网络(CNN)是在一个非常大的不同类型和颜色的字符和数字数据集上训练的。您可以想象在每个像素或像素组上有一个小窗口切片，以检测字符或部分字符、空格、表格、线条等。</p><h2 id="5444" class="kz la jj bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">服务帐户</h2><blockquote class="mo mp mq"><p id="47d2" class="lv lw mr lx b ly ms kk ma mb mt kn md mu mv mf mg mw mx mi mj my mz ml mm mn im bi translated">服务帐户是一种特殊类型的 Google 帐户，旨在代表一个非人类用户，该用户需要进行身份验证并被授权访问 Google APIs 中的数据。(<a class="ae jg" href="https://cloud.google.com/iam/docs/understanding-service-accounts" rel="noopener ugc nofollow" target="_blank">来源:IAM 谷歌云</a>)</p></blockquote><p id="33e5" class="pw-post-body-paragraph lv lw jj lx b ly ms kk ma mb mt kn md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">基本上你可以把它想象成一个<a class="ae jg" href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" rel="noopener ugc nofollow" target="_blank"> RSA </a>密钥(通过互联网在机器之间进行高安全性通信的加密密钥)，用它你可以连接到谷歌服务(API、GCS、IAM……)。它的基本形式是一个<a class="ae jg" href="https://www.json.org/json-en.html" rel="noopener ugc nofollow" target="_blank"> json </a>文件。</p><h2 id="94e5" class="kz la jj bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">笔记本</h2><p id="9171" class="pw-post-body-paragraph lv lw jj lx b ly lz kk ma mb mc kn md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在这里，我将向您展示使用 API 和从图像中自动提取文本的不同函数。</p><p id="6c19" class="pw-post-body-paragraph lv lw jj lx b ly ms kk ma mb mt kn md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">需要安装的库:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="78c2" class="kz la jj nf b gy nj nk l nl nm">!pip install google-cloud<br/>!pip install google-cloud-storage<br/>!pip install google-cloud-pubsub<br/>!pip install google-cloud-vision<br/>!pip install pdf2image<br/>!pip install google-api-python-client<br/>!pip install google-auth</span></pre><p id="5748" class="pw-post-body-paragraph lv lw jj lx b ly ms kk ma mb mt kn md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">使用的库:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="834b" class="kz la jj nf b gy nj nk l nl nm">from pdf2image import convert_from_bytes<br/>import glob<br/>from tqdm import tqdm<br/>import base64<br/>import json<br/>import os<br/>from io import BytesIO<br/>import numpy as np<br/>import io<br/>from PIL import Image<br/>from google.cloud import pubsub_v1<br/>from google.cloud import vision</span><span id="fc4c" class="kz la jj nf b gy nn nk l nl nm">from google.oauth2 import service_account<br/>import googleapiclient.discovery<br/><em class="mr"># to see a progress bar</em><br/>tqdm().pandas()</span></pre><p id="2d92" class="pw-post-body-paragraph lv lw jj lx b ly ms kk ma mb mt kn md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">OCR 可以接受在 API 中使用的 pdf、tiff 和 jpeg 格式。在本帖中，我们将把 pdf 转换成 jpeg 格式，将许多页面连接成一张图片。使用 jpeg 的两种方式:</p><p id="5b21" class="pw-post-body-paragraph lv lw jj lx b ly ms kk ma mb mt kn md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">首先，您可以将您的<em class="mr"> pdf </em>转换成<em class="mr"> jpeg </em>文件，并将其保存到另一个存储库中:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="8464" class="kz la jj nf b gy nj nk l nl nm"><em class="mr"># Name files where the pdf are and where you want to save the results</em><br/>NAME_INPUT_FOLDER = "PDF FOLDER NAME"<br/>NAME_OUTPUT_FOLDER= "RESULT TEXTS FOLDER"</span><span id="1b7e" class="kz la jj nf b gy nn nk l nl nm">list_pdf = glob.glob(NAME_INPUT_FOLDER+"/*.pdf") <em class="mr"># stock the name of the pdf files </em></span><span id="f31d" class="kz la jj nf b gy nn nk l nl nm"><em class="mr"># Loop over all the files</em><br/>for i in list_pdf:<br/>        <em class="mr"># convert the pdf into jpeg</em><br/>        pages = convert_from_path(i, 500)<br/>        <br/>        for page in tqdm(enumerate(pages)):<br/>            <em class="mr"># save each page into jpeg </em><br/>            page[1].save(NAME_OUTPUT_FOLDER+"/"+i.split('/')[-1].split('.')[0]+'_'+str(page[0])+'.jpg', 'JPEG') <em class="mr"># keep the name of the document and add increment </em></span></pre><p id="9824" class="pw-post-body-paragraph lv lw jj lx b ly ms kk ma mb mt kn md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">在这里，您可以通过 API 使用您的 jpeg 文档。但是，你可以做得更好，不用保存<em class="mr"> jpeg </em>文件，直接在内存中使用它来调用 API。</p><h2 id="6d6e" class="kz la jj bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">设置凭据</h2><p id="8353" class="pw-post-body-paragraph lv lw jj lx b ly lz kk ma mb mc kn md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在深入之前，我们需要配置 Vision API 的凭证。你会发现，这很简单:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="30ee" class="kz la jj nf b gy nj nk l nl nm">SCOPES = ['<a class="ae jg" href="https://www.googleapis.com/auth/cloud-vision'" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/auth/cloud-vision'</a>]<br/>SERVICE_ACCOUNT_FILE = "PUT the PATH of YOUR SERVICE ACCOUNT JSON FILE HERE"</span><span id="715c" class="kz la jj nf b gy nn nk l nl nm"><em class="mr"># Configure the google credentials</em><br/>credentials = service_account.Credentials.from_service_account_file(<br/>        SERVICE_ACCOUNT_FILE, scopes=SCOPES)</span></pre><h2 id="1658" class="kz la jj bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">图片处理</h2><p id="05e8" class="pw-post-body-paragraph lv lw jj lx b ly lz kk ma mb mc kn md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这需要更多的代码，因为我们还要连接 10 页文档来创建一个“大图”并将其提供给 API。一次调用比 10 次调用更划算，因为每次请求 API 时都要付费。</p><p id="522d" class="pw-post-body-paragraph lv lw jj lx b ly ms kk ma mb mt kn md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">我们走吧:</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="no np l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">操作和连接图片以将它们提供给 API 的函数</p></figure><p id="c492" class="pw-post-body-paragraph lv lw jj lx b ly ms kk ma mb mt kn md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">使用这两个函数，您将能够加载一个 pdf 文件，将其转换为字节，创建一个“大图片”并将其馈送到函数<strong class="lx jk"><em class="mr">detect _ text _ document()</em></strong>(详细信息如下)。</p><p id="72e1" class="pw-post-body-paragraph lv lw jj lx b ly ms kk ma mb mt kn md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">函数<strong class="lx jk"><em class="mr">detect _ text _ document</em></strong>用于输入图片内容和凭证(您的服务帐户信息)。</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2815" class="pw-post-body-paragraph lv lw jj lx b ly ms kk ma mb mt kn md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">输出是从图像中提取的文本。这个函数的目标是将单词连接成段落和文档。</p><h2 id="84ad" class="kz la jj bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">怎么用？</h2><p id="608d" class="pw-post-body-paragraph lv lw jj lx b ly lz kk ma mb mc kn md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">您可以像这样使用这个函数块:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="db89" class="kz la jj nf b gy nj nk l nl nm">for doc_pdf in tqdm(list_pdf):</span><span id="f84e" class="kz la jj nf b gy nn nk l nl nm">        <em class="mr"># call the function which convert into jpeg, stack 10 images<br/>        # and call the API, save the output into txt file </em><br/>        concat_file_ocr(doc_pdf)</span></pre><p id="e8a9" class="pw-post-body-paragraph lv lw jj lx b ly ms kk ma mb mt kn md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">输入就是用<em class="mr"> glob </em>函数获得的路径。该凭证是在<strong class="lx jk"> <em class="mr">设置凭证</em> </strong>部分生成的。该循环将获取输入文件的每个 pdf，使用通过转换 pdf 获得的 jpeg 文件调用 API，并保存包含检测的文本文件。</p><h2 id="1979" class="kz la jj bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><p id="3b92" class="pw-post-body-paragraph lv lw jj lx b ly lz kk ma mb mc kn md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在这里，您将结束关于如何使用视觉 API 并自动生成包含检测的文本文件的教程。您知道如何使用您的服务帐户配置凭证，以及如何将 pdf 转换为 jpeg 文件(每页一个 jpeg)。是全部吗？不，我有一些奖金给你(见下文)。</p><h2 id="9980" class="kz la jj bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">好处 1:每页使用 API</h2><p id="d4e5" class="pw-post-body-paragraph lv lw jj lx b ly lz kk ma mb mc kn md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">前面的函数允许您使用 API 来连接页面。但是，我们可以在 pdf 文档的每一页使用 API。下面的函数将请求 API 将 pdf 转换成<em class="mr"> jpeg </em>格式的每一页。</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8ba8" class="pw-post-body-paragraph lv lw jj lx b ly ms kk ma mb mt kn md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">使用它非常简单，只需用 pdf 文件夹的路径和凭证调用这个函数。像这样:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="b728" class="kz la jj nf b gy nj nk l nl nm">if per_page: <em class="mr"># option True if you want to use per page</em><br/>    <em class="mr"># call the API vision per page of the pdf</em><br/>    for i in tqdm(list_pdf):<br/>        <em class="mr"># open the pdf and convert it into a PlImage format jpeg</em><br/>        call_ocr_save_txt(i, cred=credentials)</span></pre><h2 id="9bfc" class="kz la jj bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">好处 2:使用多重处理库</h2><p id="cf36" class="pw-post-body-paragraph lv lw jj lx b ly lz kk ma mb mc kn md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">只是为了好玩，你可以把这个 API 和多重处理一起使用(好吧，这在 python 中不是真正的多重处理，带有全局解释器锁(GIL))。但是，这里的代码:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="14ae" class="kz la jj nf b gy nj nk l nl nm">if multi_proc:<br/>    nb_threads = mp.cpu_count() <em class="mr"># return the number of CPU</em><br/>    print(f"The number of available CPU is {nb_threads}")<br/>    </span><span id="3b68" class="kz la jj nf b gy nn nk l nl nm">    <em class="mr"># if you want to use the API without stacking the pages</em><br/>    if per_page:<br/>        <em class="mr"># create threads corresponding to the number specified</em><br/>        pool = mp.Pool(processes=nb_threads)    <br/>        <em class="mr"># map the function with part of the list for each thread</em><br/>        result = pool.map(call_ocr_save_txt, list_pdf) <br/>        <br/>    if per_document:<br/>        pool = mp.Pool(processes=nb_threads) <br/>        result = pool.map(concat_file_ocr, list_pdf)</span></pre></div></div>    
</body>
</html>