<html>
<head>
<title>Build a Gender Classifier in Google Colab using TensorFlow and Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TensorFlow和Keras在Google Colab中构建性别分类器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-gender-classifier-in-google-colab-using-tensorflow-keras-and-tensorboard-2cd6f952d8aa?source=collection_archive---------30-----------------------#2020-04-20">https://towardsdatascience.com/build-a-gender-classifier-in-google-colab-using-tensorflow-keras-and-tensorboard-2cd6f952d8aa?source=collection_archive---------30-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a876" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用TensorFlow和Keras在Google Colab中从头开始构建一个基于CNN的性别分类器。使用TensorBoard可视化模型的训练</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/0f26609b0c7b3aead2e7e67dc9823af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*wgCTp-N5-Vl_ZW9IaVldPw.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">在这篇文章的结尾你将会得到什么。(来源:<a class="ae ku" href="https://images.unsplash.com/photo-1517486808906-6ca8b3f04846?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=500&amp;q=60" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>)</p></figure><p id="e89d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你好朋友们。在本文中，我们将使用TensorFlow和Keras提供的API来构建一个基于CNN的性别分类器。我们将在Google Colab上编写和执行代码。Colab提供免费的GPU服务。我们将使用这些来快速训练我们的模型。</p><p id="fd5f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我将使用来自IMDB-WIKI数据集的维基百科图片。我已经对数据集进行了预处理，从图像中裁剪出所有的脸，并将它们作为对象存储在。pickle格式在我的Google Drive里。如果你已经准备好数据集，你可以继续，如果你想准备一个和我在这篇文章中使用的数据集一样的数据集，你可以阅读我的另一篇文章，在那里我解释了如何创建一个Colab笔记本，处理数据并存储它们。</p><div class="lr ls gp gr lt lu"><a href="https://medium.com/@nachi2muthu13/preprocess-and-prepare-a-face-dataset-ready-for-cnn-models-885867907eb0" rel="noopener follow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">预处理和准备面部数据集，为CNN模型做好准备</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">苦苦寻找数据集？，让我们使用…从IMDB-WIKI数据集为CNN模型准备一个现成的人脸数据集</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">medium.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi ko lu"/></div></div></a></div><p id="dc84" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这篇文章中，我解释了每一行代码，最后，你会有信心自己构建一个多类分类器。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6cc2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">让我们编码</h1><p id="60c0" class="pw-post-body-paragraph kv kw it kx b ky ni ju la lb nj jx ld le nk lg lh li nl lk ll lm nm lo lp lq im bi translated">在Google Colabs上创建一个新的笔记本，并安装您的Google drive。不要错过在您的笔记本中将您的运行时类型更改为GPU。</p><p id="9116" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你是Google Colab的新手，不知道怎么做，你可以在我的<a class="ae ku" href="https://medium.com/@nachi2muthu13/preprocess-and-prepare-a-face-dataset-ready-for-cnn-models-885867907eb0" rel="noopener">以前的文章</a>中学习。</p><p id="025b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，让我们导入这段代码中需要的所有包。在一个新的单元格中导入所有的包。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块1:导入所需的包。</p></figure><p id="7556" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在我们已经导入了所有需要的包，让我们加载我存储在Google Drive中的数据集(PS:我已经在我的另一篇文章中展示了如何预处理数据并存储它。如果你没有自己的数据集，请阅读它。我已经在前面的部分添加了链接)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块2:导入数据集。</p></figure><p id="2e16" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第1行:</strong>读取存储的数据。二进制模式的pickle格式。</p><p id="a61a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第2行:</strong>使用pickle包将其转换为python对象。</p><p id="d636" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第4–5行:</strong>从加载的数据集中单独提取图像和性别数据。</p><p id="3b46" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第6行:</strong>显示图像数组的形状，单个图像的形状和性别数组的形状。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/817dee0a60cb50d3293b8a3a710a7e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*HHEmPzi15wCedfYwJT2sxw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图1:显示输入的形状</p></figure><p id="9dd7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在上面的输出中，我们可以看到有42252个图像，每个都是32x32的RGB图像。我们还有一个2D数组格式的每张图片的性别标签，每个子数组包含性别值(1.0:男性，0.0:女性)。为了更好地理解，您可以打印数组并进行检查。</p><p id="ee1a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，让我们看看我们将使用什么样的图像来训练模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块3:查看我们拥有的图像</p></figure><p id="9fa1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第4–11行:</strong>从我们的数据集中打印4张随机图像并显示它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/4dce38be8ae75151186288f72fd24949.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*2JdQ6MMKPIzps82XGeO9tA.png"/></div></figure><p id="de34" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如您在上面的输出中看到的，我们将用来训练我们的模型的图像只包含人脸及其性别。</p><p id="9007" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们现在将可视化我们的数据分布，以深入了解我们的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块4:绘制数据集的直方图。</p></figure><p id="ce51" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第1–12行:</strong>我创建了男性和女性两个类别，并将其添加到“性别绘图”变量中。使用这些分类数据，我们可以使用Plotly绘制直方图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/f209c7477887fc0ae85b2ddac24c579b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7AaFDCwfF6G7OIiOvq1qQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图2:我们数据集的直方图。</p></figure><p id="8e01" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们有30k男像，10k女像。这些图像足够了，因为我们正在执行二元分类。</p><p id="6c2e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们现在开始登船。执行下面的代码</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="e49d" class="ob mr it nx b gy oc od l oe of">%tensorboard --logdir "logs"</span></pre><p id="7643" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在“logdir”参数中，您应该给出保存模型日志数据的目录的路径。TensorBoard将在给定的目录中搜索日志并显示出来。如果您想将日志文件保存在Google Drive中，您可以给出相应的路径。在几个步骤中，我将向您展示如何向我们的模型添加回调来保存日志文件。</p><p id="46c8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">是时候创建我们的CNN模型了。首先，我们将模型所需的所有层添加到一个列表中，然后使用Keras中的顺序类创建模型。虽然这是一个二进制分类问题，而不是在最后一层使用sigmoid激活函数，但我使用了“二进制交叉熵”作为损失函数。我已经把这个问题当作一个只有两类的多类分类问题。我这样做是为了让你知道如何使用CNN实现多类分类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块5:创建我们的CNN模型。</p></figure><p id="ef45" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第一行:</strong>模型中的第一层是输入层。我们将图像的形状作为参数传递给它。</p><p id="0fdf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第3行:</strong>创建一个元组，其中包含我们模型中特定Conv2D层将分别拥有的过滤器数量。</p><p id="491d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第5–11行:</strong>遍历上面创建的元组，创建Conv2D层，Conv2D层具有“Relu”激活功能。然后为每个Conv2D函数添加一个“BatchNormalization”函数和MaxPooling2D。MaxPooling2D的池大小为2x2，每步2步。您可以更改这些值。</p><p id="f289" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第13–26行:</strong>每当在Conv2D层之后添加一个密集层时，应该在它们之间添加一个展平层。该图层会将Conv2D图层的权重从2D格式转换为密集图层可以使用的一维格式。每个密集层被赋予一个“Relu”激活函数和“BatchNormalization”函数。添加了Dropout函数，以防止模型过拟合。函数内部传递的参数是丢弃概率，如果传递0.1，则意味着10个输入中有1个将被随机丢弃。</p><p id="036a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第27–28行:</strong>当我们使用2个类进行分类时，我们使用输出大小为2的密集层。最后一个密集图层中输出大小的数量与您希望模型进行分类的类的数量相同。我们还将softmax层用于分类问题，因为它为每个预测返回一个列表，该列表包含图像属于相应类别的概率，并且该图像被分配到具有最高概率的类别。</p><p id="79a1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第31行:然后，我们将所有创建的图层添加到一个序列模型中。向顺序模型添加层还有其他方法，您可以参考相关文档。</p><p id="2863" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第32–34行:</strong>我们通过指定优化函数和损失函数来编译模型。因为它被视为多类分类问题，所以我们使用“分类交叉熵”作为损失函数。当针对二元分类问题创建模型时，我们必须使最后一个密集层中的输出为1，并且仅对最后一层使用sigmoid激活函数。与此同时，所使用的损失函数应该是“二元交叉熵”</p><p id="1d69" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第35行:</strong>我们为每个模型训练指定文件夹名。我们使用模型被训练的时间作为文件夹名称。</p><p id="7e5c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你想你的模型日志存储在你的Google Drive中，那么你必须以这样的格式指定路径。</p><p id="c6e7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如<code class="fe og oh oi nx b">log_dir = "drive/My Drive/Colab Notebooks/Tutorial/Gender Classifier/logs/" + datetime.datetime.now().strftime("%Y%m%D-%H%M%S")</code></p><p id="eb09" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">启动TensorBoard时，应提供相同的路径，直到“日志”文件夹。<code class="fe og oh oi nx b">log_dir = "drive/My Drive/Colab Notebooks/Tutorial/Gender Classifier/logs</code>。</p><p id="c6aa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第36行:</strong>在一个名为callbacks的变量中，我们创建了一个所有回调的列表，并将其传递给模型。这里我们只创建一个回调来保存日志供TensorBoard使用，我们从“keras.callbacks”调用TensorBoard类，并将保存日志的路径作为参数传递。</p><p id="b159" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">是时候训练我们的模特了。我们将使用80:20的比例进行培训和测试。训练数据被进一步分成80:20用于训练和验证数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块6:训练模型并评估它。</p></figure><p id="da49" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第1–3行:</strong>我们将数据分为训练数据和测试数据。</p><p id="2da9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第4行</strong>:我们将只使用80%的训练数据来训练模型，其余的将用作验证数据。因此将“数量_训练_示例”设置为可用于训练的图像数量的80%。</p><p id="bf42" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第5行:</strong>设置批量为64。出于训练目的，我们的训练数据将被分成多个批次，每个批次包含64幅图像。</p><p id="0c03" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第6–8行:</strong>我们正在从模型对象中调用font函数，以便我们的模型可以使用我们的数据进行训练。<br/> <strong class="kx iu"> Epoch </strong>设置为10，这意味着我们为训练提供的全部数据将用于训练模型10次。一个历元意味着使用给定的数据执行一次迭代训练，所提供的全部数据将被我们的模型使用一次。<br/> <strong class="kx iu"> steps_per_epoch </strong>是提供给我们模型的数据批次数。当达到steps_per_epoch计数时，模型知道特定的epoch已经结束。<br/> <strong class="kx iu"> batch_size </strong>是一批数据中出现的图像数量。<br/>如果设置为false，则模型将按照提供给它的顺序获取数据。建议将此设置为true，这样模型就不会被训练成特定的类。<br/> <strong class="kx iu"> validation_split </strong>是所提供的训练数据中可用于验证的部分。<br/> <strong class="kx iu">回调</strong>是在每个时期或每个步骤结束时必须执行的功能或操作。这是我们的TensorBoard回调将通过的地方。</p><p id="456a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第11行:</strong>使用我们之前分割的测试数据，我们评估我们的模型的准确性，并检查是否没有发生过度拟合。</p><p id="066b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">上述单元的执行为我们提供了每个时期的精确度和损失值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oj"><img src="../Images/f9ccf767feb4822148f4a648dee75a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELMJ8m8Bg8nr85ILaXKHYw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图3:模型精度和损失</p></figure><p id="6294" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如您在上面的输出中所看到的，该模型对于我们的训练数据具有很好的准确性。验证准确性也很好，这表明我们的模型没有过度拟合数据。评估结果表明，我们的模型对未知数据也有很好的表现。现在是我们使用TensorBoard可视化模型训练的时候了。</p><p id="65d0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">向上滚动到执行命令以启动TensorBoard的单元格。现在，您可以看到那里显示的图表。将有一个图表用于绘制模型的准确性，另一个用于绘制损失。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi ok"><img src="../Images/88fcb196b5ef0faf981eaefc9b1950df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w5guVB-siA0dc7uQrf4i4g.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图4:可视化我们模型的训练。</p></figure><p id="760e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您看不到此图表，请检查您是否为日志文件提供了正确的目录路径。TensorBoard是一个非常强大的可视化工具，你可以用它做很多事情。如果你有兴趣了解更多信息，我推荐你观看2017年TensorFlow dev峰会。</p><p id="bfe7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们进入下一步。我们现在将从我们的计算机摄像头获取输入，并让我们的模型对图像中的人进行分类。在我们编写获取相机输入的代码之前，让我们定义一个将RGBA格式的图像转换为RGB的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块7:将RGBA图像转换为RGB图像。</p></figure><p id="5e74" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第1–20行:</strong>该函数对图像执行数学运算以进行转换。感谢<a class="ae ku" href="https://stackoverflow.com/users/1475287/feng-wang" rel="noopener ugc nofollow" target="_blank">汪锋</a>，我从StackOverflow的回答中获得了这段代码。</p><p id="82be" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们定义一个函数来使用计算机中的网络摄像头捕捉图像。由于整个笔记本都在您的浏览器上运行，我们需要编写JavaScript代码来使浏览器访问网络摄像头，捕捉图片并将其发送到服务器进行处理。我简单解释一下代码。除非您对使用JavaScript通过网络摄像头捕捉图像感兴趣，否则可以跳过这一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块8:通过网络摄像头捕捉图像。(来源:<a class="ae ku" href="https://colab.research.google.com/notebooks/snippets/advanced_outputs.ipynb" rel="noopener ugc nofollow" target="_blank"> advanced_outputs.ipynb </a>)</p></figure><p id="08f5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第1行:</strong>我们定义了一个函数，它将我们想要的图像的大小和质量作为参数。</p><p id="8f10" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第2行:</strong>向Ipython.display包中的JavaScript函数传递我们用JavaScript编写的要执行的set代码。</p><p id="72ed" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第3–16行:</strong>我们正在创建两个元素。一个div来显示来自我们相机的输入流，一个capture按钮来点击捕获图像，“stream”包含负责视频流的类的对象。</p><p id="18b7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第22–31行:</strong>代码等待点击捕获按钮。一旦它被点击，显示在输出屏幕上的视频的特定帧被捕获并转换成像素字典，然后被返回。您可以在<a class="ae ku" href="https://developer.mozilla.org/en-US/docs/Web/API/ImageData/data" rel="noopener ugc nofollow" target="_blank"> MDN Web文档</a>中了解更多关于数据返回格式的信息。</p><p id="8a21" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第35行:</strong>执行里面写的JS代码。这里我们调用上面定义的JS函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块8:将捕获的图像转换成所需的格式。</p></figure><p id="3813" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第5行:</strong>我们调用python函数“take_photo ”,它反过来调用JS函数并捕获一张照片。</p><p id="1c25" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第7–9行:</strong>我们根据关键字对JS函数返回的像素进行排序，然后将图像调整为3D数组格式。</p><p id="9840" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第15行:</strong>由于获得的图像是RGBA彩色格式，我们要将其转换为RGB彩色格式并显示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/3b56ca4078a9b9cdf7475d1f7a37b9d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*Y1lhouPwgt6ZknJ5qw_PjQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图5:捕获的图像。</p></figure><p id="9fe3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们已经收到了需要分类的输入数据。我们将从图像中检测和裁剪人脸，将裁剪后的图像传递给模型，并获得其预测和显示输出。让我们定义两个函数，一个用于提取人脸，另一个用于显示带有标签的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块9:定义函数来处理我们的图像并显示输出。</p></figure><p id="a274" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第1–21行:</strong>此函数使用Dlib的基于CNN的人脸识别模型获取图像参数并检测其中的所有人脸，然后将它们从图像中裁剪出来。这个函数返回一个字典，包含所有的脸及其在图像上各自的坐标。</p><p id="d753" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第23–33行:</strong>该函数将原始图像、裁剪后的人脸以及模型对每个人脸的预测作为其参数。它在所有面上绘制矩形框，并在这些框上添加各自的标签，然后显示图像。</p><p id="117d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">是时候调用这些函数并获得输出了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">代码块10:对图像进行分类。</p></figure><p id="c354" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第1行:</strong>我们从图像中提取人脸。</p><p id="2482" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第3–6行:</strong>我们正在创建一个包含图像中所有人脸的图像数组。</p><p id="fd15" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第9–10行:</strong>我们预测每张人脸图像的标签。</p><p id="4354" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第12行:</strong>我们调用显示分类输出的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/b28b12bd3f7aeef62e1f7c92bea22eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*LvgDYw370RPHRpseOvU6tA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图6:最终的分类图像。</p></figure><p id="de23" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你也可以试着把一个有多张脸的图像分类。</p><p id="e6b4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">到此，我结束这篇文章。我希望你已经从这篇文章中学到了很多，现在可以用任何类型的对象和任何数量的类构建一个多类分类器。</p><p id="4500" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我在我的笔记本上附上了一个链接供你参考。</p><div class="lr ls gp gr lt lu"><a href="https://colab.research.google.com/drive/1d_mJjJJgdx_zqEBK4WgG0f7tQ1vsMaJB" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iu gy z fp lz fr fs ma fu fw is bi translated">谷歌联合实验室</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">性别分类器. ipynb</h3></div></div><div class="md l"><div class="on l mf mg mh md mi ko lu"/></div></div></a></div></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="e548" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如有任何疑问，请随时联系我。</p><p id="2572" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Instagram: <a class="ae ku" href="https://www.instagram.com/nachijr4/" rel="noopener ugc nofollow" target="_blank"> nachijr4 </a></p><p id="6b0a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">电子邮件:nachi2muthu13@gmail.com</p><p id="ab7d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">中:<a class="ae ku" href="https://medium.com/@nachi2muthu13" rel="noopener">纳奇穆图</a></p><p id="d771" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">领英:<a class="ae ku" href="https://www.linkedin.com/in/nachi-muthu-4351a5112/" rel="noopener ugc nofollow" target="_blank">纳奇穆图</a></p></div></div>    
</body>
</html>