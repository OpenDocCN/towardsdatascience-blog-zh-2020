<html>
<head>
<title>Eigenvalues and Eigenvectors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">特征值和特征向量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/eigenvalues-and-eigenvectors-89483fb56d56?source=collection_archive---------15-----------------------#2020-07-03">https://towardsdatascience.com/eigenvalues-and-eigenvectors-89483fb56d56?source=collection_archive---------15-----------------------#2020-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e315" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">计算和可视化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/abcd24769f3e36a468aa07195f835e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5_XBEdjLR5vQhm657DgRrg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这里有动画:<a class="ae ky" href="https://bdshaff.github.io/bdshaff.github.io/blog/2020-03-23-computing-eigenvalues-and-eigenvectors/" rel="noopener ugc nofollow" target="_blank">https://BDS haff . github . io/BDS haff . github . io/blog/2020-03-23-计算-特征值-特征向量/ </a></p></figure><h1 id="73eb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">这是怎么回事</h1><ul class=""><li id="d2f0" class="lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">首先，我将谈谈是什么让我对<em class="mj">特征值</em>实际上是如何计算的感到好奇。</li><li id="fbff" class="lr ls it lt b lu mk lw ml ly mm ma mn mc mo me mf mg mh mi bi translated">然后我分享一下我实现最简单的算法(<strong class="lt iu"> <em class="mj"> QR 方法</em> </strong>)做一些基准测试。</li><li id="04c9" class="lr ls it lt b lu mk lw ml ly mm ma mn mc mo me mf mg mh mi bi translated">最后，我将分享你如何将算法寻找<em class="mj">特征向量</em>的步骤动画化！</li></ul><h1 id="e36f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">他们无处不在</h1><p id="2284" class="pw-post-body-paragraph mp mq it lt b lu lv ju mr lw lx jx ms ly mt mu mv ma mw mx my mc mz na nb me im bi translated">特征值和特征向量在数学中随处可见，尤其是应用数学。统计学、机器学习、数据科学都属于这个范畴。</p><p id="be57" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">前段时间决定通过实现主成分分析(<em class="mj"> PCA </em>)来学习 Rcpp 和 C++。我知道<em class="mj"> PCA </em>问题的解决方案是样本方差-协方差矩阵的特征值分解。我意识到我需要用 C++编写我自己版本的内置<code class="fe nh ni nj nk b">eigen</code>函数，那时我意识到除了一个<em class="mj"> 2x2 </em>案例，我不知道<code class="fe nh ni nj nk b">eigen</code>实际上是如何工作的。我发现的是我在这里读到的<a class="ae ky" href="https://people.inf.ethz.ch/arbenz/ewp/Lnotes/chapter4.pdf" rel="noopener ugc nofollow" target="_blank">的<strong class="lt iu"> <em class="mj"> QR 法</em> </strong>。</a></p><h1 id="937e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">为什么 n &gt; 2 不一样</h1><p id="dc79" class="pw-post-body-paragraph mp mq it lt b lu lv ju mr lw lx jx ms ly mt mu mv ma mw mx my mc mz na nb me im bi translated">有了一个<em class="mj"> 2x2 </em>矩阵，我们可以手动求解特征值。这是可行的，因为一个 2x2 矩阵的行列式是一个二次多项式，所以我们可以用正规代数来分解和求解它。但是如何计算大型矩阵的特征值呢？事实证明，当你不能分解和求解多项式时，你真正应该做的是分解矩阵。纯属巧合的是，<em class="mj">数字爱好者</em> YouTube 频道最近发布了一个关于这个想法的视频<a class="ae ky" href="https://www.youtube.com/watch?v=wTUSz-HSaBg" rel="noopener ugc nofollow" target="_blank">在这里</a>。如果你对这种类型的内容感兴趣，值得一试！</p><h1 id="486a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">快速复习:它们是什么？</h1><p id="810d" class="pw-post-body-paragraph mp mq it lt b lu lv ju mr lw lx jx ms ly mt mu mv ma mw mx my mc mz na nb me im bi translated">首先，快速复习一下什么是<em class="mj">特征值</em>和<em class="mj">特征向量</em>。取一个方阵<strong class="lt iu"> <em class="mj"> X </em> </strong>。如果有一个矢量<strong class="lt iu"> <em class="mj"> v </em> </strong>和一个标量<strong class="lt iu"> <em class="mj"> λ </em> </strong>这样</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/5222d9b509eee51dea56b8a4dbf75e38.png" data-original-src="https://miro.medium.com/v2/resize:fit:356/format:webp/1*JwagXRw2UKIU8N5HADQsuQ.png"/></div></figure><p id="8ef8" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">那么<strong class="lt iu"> v </strong>就是<strong class="lt iu">T3】XT5<em class="mj">T7<em class="mj">λ</em></em></strong>就是<em class="mj"> </em> <strong class="lt iu"> <em class="mj"> X </em> </strong>对应的特征值。</p><p id="a85a" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">换句话说，如果你把<strong class="lt iu"> <em class="mj"> v </em> </strong>乘以<strong class="lt iu"> <em class="mj"> X </em> </strong>看作是对<em class="mj"> </em> <strong class="lt iu"> <em class="mj"> v </em> </strong>应用一个函数，那么对于这个特定的向量<strong class="lt iu"> <em class="mj"> v </em> </strong>来说，这个函数不过是一个拉伸/挤压标量乘法。通常，将一个向量乘以一个矩阵等于取向量分量的线性组合。但是如果你取一个<em class="mj">特征向量</em>，你不需要做所有的计算。只要乘以<em class="mj">特征值</em>就都好了。</p><h1 id="cbf6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">计算:QR 方法</h1><p id="50e8" class="pw-post-body-paragraph mp mq it lt b lu lv ju mr lw lx jx ms ly mt mu mv ma mw mx my mc mz na nb me im bi translated">计算<em class="mj">特征值</em>和<em class="mj">特征向量</em>的<strong class="lt iu"> <em class="mj"> QR 法</em> </strong>从我心爱的<em class="mj"> QR 矩阵分解</em>开始。我在<a class="ae ky" rel="noopener" target="_blank" href="/qr-matrix-factorization-15bae43a6b2">之前的帖子</a>中写过。这种分解允许将矩阵<strong class="lt iu"> <em class="mj"> X=QR </em> </strong>表示为正交矩阵<strong class="lt iu"> <em class="mj"> Q </em> </strong>和上三角矩阵<strong class="lt iu"> <em class="mj"> R </em> </strong>的乘积。同样，<strong class="lt iu"> <em class="mj"> Q </em> </strong>正交的事实很重要。</p><p id="34e8" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">用于寻找特征值的<strong class="lt iu"> <em class="mj"> QR 方法</em> </strong>的中心思想是将<em class="mj"> QR 矩阵分解</em>迭代应用于原始矩阵<strong class="lt iu"> <em class="mj"> X </em> </strong>。</p><h1 id="75d7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">相似矩阵</h1><p id="6f15" class="pw-post-body-paragraph mp mq it lt b lu lv ju mr lw lx jx ms ly mt mu mv ma mw mx my mc mz na nb me im bi translated">这里我需要提一下<strong class="lt iu"> <em class="mj"> X </em> </strong>的<em class="mj">特征值</em>的一个数学性质。如果我们取任何一个可逆矩阵<strong class="lt iu"> <em class="mj"> M </em> </strong>那么这个矩阵</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/4a4e31d7a93ff35ff96c8ecc165097ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*v2_xw2LoVhKlGTgRaP7Csw.png"/></div></figure><p id="a698" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">将具有与<strong class="lt iu"> <em class="mj"> X </em> </strong>相同的<em class="mj">特征值</em>。这样的矩阵<strong class="lt iu"> <em class="mj"> E </em> </strong>和<strong class="lt iu"> <em class="mj"> X </em> </strong>在形式上定义为<strong class="lt iu"> <em class="mj">相似矩阵</em> </strong>，简单来说就是它们具有相同的<em class="mj">特征值</em>。然而<em class="mj">特征向量</em>将会不同。同样，回想一下<strong class="lt iu"> <em class="mj"> QR </em> </strong>中的<strong class="lt iu"> <em class="mj"> Q </em> </strong>是正交的，因此是必然的。</p><h1 id="338f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">QR 算法</h1><p id="931d" class="pw-post-body-paragraph mp mq it lt b lu lv ju mr lw lx jx ms ly mt mu mv ma mw mx my mc mz na nb me im bi translated">所以，<strong class="lt iu"> <em class="mj"> QR 方法</em> </strong>的思想是迭代以下步骤</p><ol class=""><li id="0406" class="lr ls it lt b lu nc lw nd ly nn ma no mc np me nq mg mh mi bi translated">将<em class="mj"> QR 分解</em>应用于<strong class="lt iu"> <em class="mj"> X </em> </strong>以便</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/af57c66dd874aacd0c3080b8c8e31121.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*BUMo4DLadgEiyd97p-rjiA.png"/></div></figure><p id="0d53" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">2.让</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/6759250a94a0d2850f37f127375f04d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*agbkAjEo-0L1bWQvC3f9Ng.png"/></div></figure><p id="6acb" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">和计算</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/713b5b991b3be29adf753f3fc1cb0d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*m8TzV0Rt6Sadqc8pA8zhrA.png"/></div></figure><p id="a033" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">注:<strong class="lt iu"> <em class="mj"> E </em> </strong>是<strong class="lt iu"> <em class="mj">类似于</em> </strong>到<strong class="lt iu"> <em class="mj"> X </em> </strong>。它们的<em class="mj">特征值</em>是相同的。</p><p id="a9ab" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">3.然后分解</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/3a93903e23957a4ff489a98b96b4deb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*00DpGkWpuRD0HdG_CKB6Og.png"/></div></figure><p id="b2ae" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">4.因此</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9302adebbaed2458d90f943d50c001be.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*TgMm6kG4syIJYzif8Ayh_A.png"/></div></figure><p id="d5e1" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">和</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/2b1487ebc60532da5671b25585914e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*HMYzYVdbBotpldWMxxrlzw.png"/></div></figure><p id="bc28" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">5.用 <strong class="lt iu"> <em class="mj"> E </em> </strong>迭代单元本质上是对角的。</p><p id="9eea" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">当<strong class="lt iu"> <em class="mj"> E </em> </strong>是对角线时，你得到的是对角线上的<em class="mj">特征值</em>，而<strong class="lt iu"> <em class="mj"> V </em> </strong>是<strong class="lt iu">特征向量！</strong></p><p id="a8ac" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">这是<strong class="lt iu"> <em class="mj"> QR 法的最简单版本。有几个改进的版本，我就不赘述了，但是你可以在这里读到它们<a class="ae ky" href="https://people.inf.ethz.ch/arbenz/ewp/Lnotes/chapter4.pdf" rel="noopener ugc nofollow" target="_blank">。</a></em></strong></p><p id="aa24" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">接下来，我想用 R 和 C++编写一个函数来实现这个方法，并验证它是否有效。</p><h1 id="cef2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">简单实现</h1><p id="85fe" class="pw-post-body-paragraph mp mq it lt b lu lv ju mr lw lx jx ms ly mt mu mv ma mw mx my mc mz na nb me im bi translated">我们将这样做:</p><ol class=""><li id="f72b" class="lr ls it lt b lu nc lw nd ly nn ma no mc np me nq mg mh mi bi translated">展示一个用<code class="fe nh ni nj nk b">R</code>编写的函数，该函数明确实现了用于寻找<em class="mj">特征值</em>的<strong class="lt iu"> <em class="mj"> QR 方法</em> </strong>。</li><li id="ccd1" class="lr ls it lt b lu mk lw ml ly mm ma mn mc mo me nq mg mh mi bi translated">通过将结果与内置的<code class="fe nh ni nj nk b">eigen</code>函数进行比较来验证它是否工作。</li><li id="e181" class="lr ls it lt b lu mk lw ml ly mm ma mn mc mo me nq mg mh mi bi translated">在<code class="fe nh ni nj nk b">C++</code>中实现相同的功能，并通过<code class="fe nh ni nj nk b">myc</code>包可用。验证它是否也能正常工作。</li><li id="ed3d" class="lr ls it lt b lu mk lw ml ly mm ma mn mc mo me nq mg mh mi bi translated">最后，比较它们的性能。</li></ol><p id="499d" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">以下是我将使用的软件包:</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="ccd0" class="ob la it nk b gy oc od l oe of">library(tidyverse)<br/>library(microbenchmark)<br/>library(plotly)<br/>library(myc)</span></pre><h1 id="7e30" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">R 函数</h1><p id="07cf" class="pw-post-body-paragraph mp mq it lt b lu lv ju mr lw lx jx ms ly mt mu mv ma mw mx my mc mz na nb me im bi translated"><code class="fe nh ni nj nk b">my_eigen</code>是一个非常简单的函数。前几行执行<strong class="lt iu"> <em class="mj"> QR 方法</em> </strong>的初始迭代。然后 while 循环迭代，直到<strong class="lt iu"> <em class="mj"> E </em> </strong>矩阵的对角线稳定下来，并且不再变化超过小的余量。带有<code class="fe nh ni nj nk b">values</code>和<code class="fe nh ni nj nk b">vectors</code>的返回列表应该与<code class="fe nh ni nj nk b">eigen</code>函数返回的相同。对于<strong class="lt iu"> <em class="mj"> QR 分解</em> </strong>步骤，我使用的是<code class="fe nh ni nj nk b">myc</code>包中的<code class="fe nh ni nj nk b">myc_qr</code>。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="7662" class="ob la it nk b gy oc od l oe of">my_eigen &lt;- function(A, margin = 1e-20) {<br/>  Q &lt;- myc_qr(A)$Q<br/>  E &lt;- t(Q) %*% A %*% Q<br/>  U &lt;- Q<br/>  res &lt;- diag(E)<br/>  init &lt;- diag(A)<br/>  while (sum((init - res)^2) &gt; margin) {<br/>    init &lt;- res<br/>    Q &lt;- myc_qr(E)$Q<br/>    E &lt;- t(Q) %*% E %*% Q<br/>    U &lt;- U %*% Q<br/>    res &lt;- diag(E)<br/>  }<br/>  return(list(values = round(diag(E), 6), vecotrs = U))<br/>}</span></pre><h1 id="8228" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">验证它是否有效</h1><p id="feb9" class="pw-post-body-paragraph mp mq it lt b lu lv ju mr lw lx jx ms ly mt mu mv ma mw mx my mc mz na nb me im bi translated">让我们检查一下它是否工作。我将使用对称矩阵，因为我想确保特征值不是复数。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="46a0" class="ob la it nk b gy oc od l oe of">X &lt;- matrix(c(<br/>  3, 2, 3, 2,<br/>  5, 1, 5, 4,<br/>  9, 3, 2, 1,<br/>  4, 5, 6, 7<br/>), ncol = 4)<br/><br/>A &lt;- t(X) %*% X</span></pre><p id="212d" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">这是一个矩阵，我将使用它来验证我的函数是否按预期工作。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="68a2" class="ob la it nk b gy oc od l oe of">A</span><span id="61ba" class="ob la it nk b gy og od l oe of">##      [,1] [,2] [,3] [,4]<br/>## [1,]   26   40   41   54<br/>## [2,]   40   67   62   83<br/>## [3,]   41   62   95   70<br/>## [4,]   54   83   70  126</span></pre><p id="4b5e" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">下面是内置的<code class="fe nh ni nj nk b">eigen</code>函数返回的内容。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="d196" class="ob la it nk b gy oc od l oe of">eigen(A)</span><span id="4e00" class="ob la it nk b gy og od l oe of">## eigen() decomposition<br/>## $values<br/>## [1] 268.6301739  39.1116701   5.8239493   0.4342066<br/>## <br/>## $vectors<br/>##            [,1]        [,2]         [,3]       [,4]<br/>## [1,] -0.3085888  0.02606027 -0.001691293  0.9508370<br/>## [2,] -0.4823478  0.07140554 -0.858273366 -0.1600270<br/>## [3,] -0.5053596 -0.81601931  0.242450805 -0.1412152<br/>## [4,] -0.6455425  0.57300488  0.452306949 -0.2244074</span></pre><p id="2932" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">正如您在下面看到的，当调用<code class="fe nh ni nj nk b">my_eigen</code>函数时，结果是相同的。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="7cdb" class="ob la it nk b gy oc od l oe of">my_eigen(A)</span><span id="bfd7" class="ob la it nk b gy og od l oe of">## $values<br/>## [1] 268.630174  39.111670   5.823949   0.434207<br/>## <br/>## $vecotrs<br/>##           [,1]        [,2]         [,3]       [,4]<br/>## [1,] 0.3085888  0.02606027  0.001691289 -0.9508370<br/>## [2,] 0.4823478  0.07140567  0.858273355  0.1600270<br/>## [3,] 0.5053596 -0.81601935 -0.242450683  0.1412152<br/>## [4,] 0.6455425  0.57300481 -0.452307035  0.2244074</span></pre><p id="768b" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">当调用<code class="fe nh ni nj nk b">Rcpp</code>版本的<code class="fe nh ni nj nk b">myc_eigen</code>函数时，结果也是一样的。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="cb3b" class="ob la it nk b gy oc od l oe of">myc_eigen(A)</span><span id="8267" class="ob la it nk b gy og od l oe of">## $values<br/>## [1] 268.6301739  39.1116701   5.8239493   0.4342066<br/>## <br/>## $vectors<br/>##           [,1]        [,2]         [,3]       [,4]<br/>## [1,] 0.3085888  0.02606027  0.001691289 -0.9508370<br/>## [2,] 0.4823478  0.07140567  0.858273355  0.1600270<br/>## [3,] 0.5053596 -0.81601935 -0.242450683  0.1412152<br/>## [4,] 0.6455425  0.57300481 -0.452307035  0.2244074</span></pre><p id="690f" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">此外，我们可以通过比较将<strong class="lt iu"><em class="mj"/></strong>和<strong class="lt iu"> <em class="mj"> λ </em> </strong>应用于<em class="mj">特征向量</em>的结果，并检查它们是否相等，来验证计算的分解是否正确。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="41ee" class="ob la it nk b gy oc od l oe of">eigen_decomp &lt;- myc_eigen(A)<br/><br/>v &lt;- eigen_decomp$vectors[, 2]<br/>l &lt;- eigen_decomp$values[2]</span></pre><p id="9e6c" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">这里我们应用矩阵。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="9e4c" class="ob la it nk b gy oc od l oe of">as.numeric(A %*% v)</span><span id="7a5e" class="ob la it nk b gy og od l oe of">## [1]   1.019261   2.792791 -31.915878  22.411177</span></pre><p id="393f" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">和预期的缩放比例<strong class="lt iu"> <em class="mj"> v </em> </strong>由<strong class="lt iu"> <em class="mj"> λ </em> </strong>给出相同的矢量。数值似乎朝着第 7 个有效数字有一点分歧，但解决方案是可以接受的接近。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="bf36" class="ob la it nk b gy oc od l oe of">(l * v)</span><span id="13e8" class="ob la it nk b gy og od l oe of">## [1]   1.019261   2.792795 -31.915880  22.411175</span></pre><h1 id="94e5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">标杆管理</h1><p id="1d0e" class="pw-post-body-paragraph mp mq it lt b lu lv ju mr lw lx jx ms ly mt mu mv ma mw mx my mc mz na nb me im bi translated">出于兴趣，我想比较一下这些函数计算特征值的速度。看起来在一个小矩阵上，比如我们在内置的<code class="fe nh ni nj nk b">eigen</code>函数上面使用的<em class="mj"> 4x4 </em>矩阵，会慢一点。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="d171" class="ob la it nk b gy oc od l oe of">microbenchmark(eigen(A), my_eigen(A), myc_eigen(A))</span><span id="7d2b" class="ob la it nk b gy og od l oe of">## Unit: microseconds<br/>##          expr     min       lq      mean   median      uq     max<br/>##      eigen(A) 179.003 191.6580 211.15584 201.8395 230.539 326.666   <br/>##   my_eigen(A) 140.156 151.9090 161.32797 160.7745 169.035 221.650   <br/>##  myc_eigen(A)  61.102  65.6775  71.19684  69.7855  75.054  92.629   <br/></span></pre><p id="6018" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">如果我们采用更大的矩阵，那么<code class="fe nh ni nj nk b">eigen</code>当然会更快。这个<code class="fe nh ni nj nk b">Rcpp</code>版本的 is my 函数只比纯<code class="fe nh ni nj nk b">R</code>函数快一点，可能是因为它使用了一个矩阵乘法函数<code class="fe nh ni nj nk b">myc_matmult</code>，这个函数明显比<code class="fe nh ni nj nk b">%*%</code>操作符慢。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="0331" class="ob la it nk b gy oc od l oe of">X &lt;- matrix(rnorm(100), ncol = 10)<br/>A &lt;- t(X) %*% X<br/><br/>microbenchmark(eigen(A), my_eigen(A), myc_eigen(A))</span><span id="3ad2" class="ob la it nk b gy og od l oe of">## Unit: microseconds<br/>##      expr      min       lq      mean   median        uq      max<br/>    eigen(A)  187.839  203.035  361.0305  230.057  341.2605  1444.53<br/> my_eigen(A) 1698.668 1775.423 3067.5417 1911.548 2908.7345 18626.75<br/>myc_eigen(A) 1225.512 1299.820 2178.2306 1547.336 2394.2235 12239.43<br/></span></pre><h1 id="bd0b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">可视化和动画</h1><p id="acb8" class="pw-post-body-paragraph mp mq it lt b lu lv ju mr lw lx jx ms ly mt mu mv ma mw mx my mc mz na nb me im bi translated">显然自己实施<strong class="lt iu"> <em class="mj"> QR 方法</em> </strong>并不是为了更好的表现。然而，我们能做的是构建一个函数，跟踪值是如何计算的，也许能更好地了解它是如何工作的。</p><p id="6db0" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">下面是一个函数<code class="fe nh ni nj nk b">my_eigen2</code>，它执行与<code class="fe nh ni nj nk b">my_eigen</code>函数相同的计算，除了它不使用 while 循环，而是迭代给定的最大次数，并记录更新后的<em class="mj">特征值</em>。如果计算收敛，则迭代在达到给定的最大值之前停止。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="7f41" class="ob la it nk b gy oc od l oe of">my_eigen2 &lt;- function(A, margin = 1e-10, itrs = 40) {<br/>  Q &lt;- myc_qr(A)$Q<br/>  Qt &lt;- t(Q)<br/><br/>  Elist &lt;- vector("list", length = 21)<br/>  Ulist &lt;- vector("list", length = 21)<br/><br/>  E &lt;- t(Q) %*% A %*% Q<br/>  U &lt;- Q<br/><br/>  Elist[[1]] &lt;- E<br/>  Ulist[[1]] &lt;- U<br/><br/>  res &lt;- diag(E)<br/>  for (i in 1:itrs) {<br/>    init &lt;- res<br/>    Q &lt;- myc_qr(E)$Q<br/>    E &lt;- t(Q) %*% E %*% Q<br/>    U &lt;- U %*% Q<br/>    Elist[[i + 1]] &lt;- E<br/>    Ulist[[i + 1]] &lt;- U<br/>    res &lt;- diag(E)<br/>    print(sum((init - res)^2))<br/>    if (sum((init - res)^2) &lt; margin) {<br/>      break()<br/>    }<br/>  }<br/><br/>  return(list(<br/>    values = round(diag(E), 6),<br/>    vectors = U,<br/>    Elist = Elist[1:i],<br/>    Ulist = Ulist[1:i]<br/>  ))<br/>}</span></pre><h1 id="0378" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">想象一个 2 乘 2 的案例</h1><p id="04e2" class="pw-post-body-paragraph mp mq it lt b lu lv ju mr lw lx jx ms ly mt mu mv ma mw mx my mc mz na nb me im bi translated">为了可视化<strong class="lt iu"> <em class="mj"> QR 方法</em> </strong>如何工作，我决定使用一个<em class="mj"> 2x2 </em>协方差矩阵。这是为了使其与<em class="mj"> PCA </em>相关，并使其易于实际可视化。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="c471" class="ob la it nk b gy oc od l oe of">A &lt;- matrix(c(<br/>  1.0, 0.3,<br/>  0.3, 0.8<br/>), nrow = 2)<br/><br/>A</span><span id="f6b8" class="ob la it nk b gy og od l oe of">##      [,1] [,2]<br/>## [1,]  1.0  0.3<br/>## [2,]  0.3  0.8</span></pre><p id="58f1" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">首先，我们让<code class="fe nh ni nj nk b">my_eigen2</code>进行计算，并建立矩阵列表，记录<strong class="lt iu"> <em class="mj"> QR 方法</em> </strong>如何收敛到答案。在 9 个步骤之后，计算收敛。</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="698b" class="ob la it nk b gy oc od l oe of">eigen_decomps &lt;- my_eigen2(A, itrs = 30)</span><span id="68aa" class="ob la it nk b gy og od l oe of">## [1] 0.005127351<br/>## [1] 0.0003368977<br/>## [1] 1.882642e-05<br/>## [1] 1.011322e-06<br/>## [1] 5.382776e-08<br/>## [1] 2.858891e-09<br/>## [1] 1.517664e-10<br/>## [1] 8.055721e-12</span></pre><p id="019a" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">这些是实际的<em class="mj">特征值</em>和<em class="mj">特征向量</em>:</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="b3cc" class="ob la it nk b gy oc od l oe of">eigen_decomps$values</span><span id="6670" class="ob la it nk b gy og od l oe of">## [1] 1.216227 0.583773</span><span id="9e68" class="ob la it nk b gy og od l oe of">eigen_decomps$vectors</span><span id="e478" class="ob la it nk b gy og od l oe of">##           [,1]       [,2]<br/>## [1,] 0.8118117 -0.5839193<br/>## [2,] 0.5839193  0.8118117</span></pre><p id="4172" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">以下代码在计算的每一步提取两个<em class="mj">特征向量</em>的方向，并将它们堆叠到 data.frame 中。我们可以使用这些来计算斜率，然后将它们可视化在密度图上。</p><p id="2b6c" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">正确的斜率是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b2dc16480702d9e81710f5085c64ea3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*31VgadOrRsdYCYreeU7fmw.png"/></div></figure><p id="e678" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">和</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/6bbf9bc1b2c320a981f7a39350445e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*SFjclV9pNNvHN541GDbbEA.png"/></div></figure><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="e5c3" class="ob la it nk b gy oc od l oe of">animation_data &lt;-<br/>  map2(eigen_decomps$Elist, eigen_decomps$Ulist, <br/>            ~ as.data.frame(1 / .x %*% .y)) %&gt;%<br/>  bind_rows(.id = "frame") %&gt;%<br/>  rename(x1 = "V1", y1 = "V2") %&gt;%<br/>  bind_cols(d = rep(c("d1", "d2"), length(eigen_decomps$Elist))) %&gt;%<br/>  pivot_wider(names_from = d, values_from = c(x1, y1)) %&gt;%<br/>  bind_cols(<br/>    x0 = rep(0, length(eigen_decomps$Elist)),<br/>    y0 = rep(0, length(eigen_decomps$Elist))<br/>  ) %&gt;%<br/>  mutate(frame = as.numeric(frame)) %&gt;%<br/>  mutate(<br/>    slope1 = y1_d1 / x1_d1,<br/>    slope2 = y1_d2 / x1_d2<br/>  )<br/><br/>animation_data</span><span id="2ad3" class="ob la it nk b gy og od l oe of">## # A tibble: 8 x 9<br/>##   frame x1_d1 x1_d2 y1_d1 y1_d2    x0    y0 slope1 slope2<br/>##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;<br/>## 1     1 0.865  2.67 -7.00  1.76     0     0  -8.09  0.659<br/>## 2     2 0.893  2.79 -2.27  2.03     0     0  -2.54  0.727<br/>## 3     3 0.941  2.88 -1.71  2.10     0     0  -1.81  0.729<br/>## 4     4 0.975  2.91 -1.53  2.11     0     0  -1.57  0.725<br/>## 5     5 0.994  2.92 -1.46  2.11     0     0  -1.47  0.723<br/>## 6     6 1.00   2.93 -1.43  2.11     0     0  -1.43  0.722<br/>## 7     7 1.01   2.93 -1.42  2.11     0     0  -1.41  0.721<br/>## 8     8 1.01   2.93 -1.41  2.11     0     0  -1.40  0.721</span></pre><p id="a95c" class="pw-post-body-paragraph mp mq it lt b lu nc ju mr lw nd jx ms ly ne mu mv ma nf mx my mc ng na nb me im bi translated">使用<code class="fe nh ni nj nk b">ggplot</code>和<code class="fe nh ni nj nk b">plotly</code>,我们可以生成以下动画可视化</p><pre class="kj kk kl km gt nx nk ny nz aw oa bi"><span id="3d6e" class="ob la it nk b gy oc od l oe of">data.grid &lt;-expand.grid(x = seq(-5, 5, length.out = 200), <br/>                        y = seq(-5, 5, length.out = 200))</span><span id="1ac2" class="ob la it nk b gy og od l oe of">dens &lt;- cbind(data.grid, <br/>             z = mvtnorm::dmvnorm(data.grid, <br/>                                     mean = c(0, 0), <br/>                                     sigma = A))<br/><br/>ggplotly(<br/>  ggplot(dens, aes(x = x, y = y, z = z)) +<br/>    geom_contour(color = "blue", alpha = 0.3) +<br/>    coord_fixed(xlim = c(-2, 2), ylim = c(-2, 2), ratio = 1) +<br/>    geom_abline(aes(slope = slope1, intercept = 0, frame = frame),<br/>      color = "red", data = animation_data<br/>    ) +<br/>    geom_abline(aes(slope = slope2, intercept = 0, frame = frame),<br/>      color = "red", data = animation_data<br/>    ) +<br/>    theme_void() +<br/>    theme(<br/>      legend.position = "none",<br/>      axis.line = element_blank(),<br/>      panel.grid.major = element_blank()<br/>    ) +<br/>    geom_raster(aes(fill = z)) +<br/>    scale_fill_gradientn(colours = RColorBrewer::brewer.pal(n = 5, name = "BuGn"))<br/>) %&gt;%<br/>  animation_opts(frame = 500, redraw = TRUE) %&gt;%<br/>  style(hoverinfo = "skip")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/abcd24769f3e36a468aa07195f835e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5_XBEdjLR5vQhm657DgRrg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可以在这里查看我博客上的实际动画:<a class="ae ky" href="https://bdshaff.github.io/bdshaff.github.io/blog/2020-03-23-computing-eigenvalues-and-eigenvectors/" rel="noopener ugc nofollow" target="_blank">https://BDS haff . github . io/BDS haff . github . io/blog/2020-03-23-计算-特征值-和-特征向量/ </a></p></figure><h1 id="1ed3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">我的外卖</h1><ol class=""><li id="a086" class="lr ls it lt b lu lv lw lx ly lz ma mb mc md me nq mg mh mi bi translated">我真的很感谢 LAPACK 或 Armadillo 这样的数值线性代数库，因为经历了最简单的特征值计算方法，我可以更好地欣赏创建它们的所有工作。</li><li id="2599" class="lr ls it lt b lu mk lw ml ly mm ma mn mc mo me nq mg mh mi bi translated">通过这个练习，我对计算特征值背后的细节变得非常熟悉。虽然有时令人沮丧，但我真的觉得我学到了很多东西，在我看来，真正彻底地学习了一些东西的感觉是最好的感觉之一。</li></ol></div></div>    
</body>
</html>