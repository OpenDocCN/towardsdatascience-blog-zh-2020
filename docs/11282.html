<html>
<head>
<title>Sparse Group Lasso in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的稀疏群组套索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sparse-group-lasso-in-python-255e379ab892?source=collection_archive---------14-----------------------#2020-08-05">https://towardsdatascience.com/sparse-group-lasso-in-python-255e379ab892?source=collection_archive---------14-----------------------#2020-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="90ee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在回归中使用最佳变量选择技术之一</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5613539f62b4833a0c63735858b65c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z93Spy7iRR60Qyp3"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">准备使用套索，捕捉一些有意义的变量。普里西拉·杜·普里兹在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2054" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以昨天我为 python 发布了一个新的包:<a class="ae kv" href="https://github.com/alvaromc317/asgl" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> asgl </strong> </a> <strong class="ky ir"> </strong>(这个名字来源于自适应稀疏组套索)，它增加了许多在 R 包中已经可用但在 python 中不可用的功能，比如求解稀疏组套索模型，并且超越了这一点，增加了额外的功能来改善稀疏组套索可以提供的结果。</p><p id="7bc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将是关于回归中最先进的正则化技术系列的第一篇文章，我想开始谈谈稀疏群套索:它是什么以及如何使用它。具体来说，在这里我们将看到:</p><ul class=""><li id="5aa9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">什么是<strong class="ky ir">稀疏群套索</strong></li><li id="43d8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如何在<strong class="ky ir"> python </strong>中使用稀疏群组套索</li><li id="96c4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如何进行<strong class="ky ir"> k 倍交叉验证</strong></li><li id="ddad" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如何使用<strong class="ky ir">网格搜索</strong>才能找到最优解。</li></ul><h1 id="e5e4" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">什么是稀疏群套索</h1><p id="bd7e" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">为了理解什么是稀疏群组套索，我们需要(简要地)谈谈两种技巧:<strong class="ky ir">套索</strong>和<strong class="ky ir">群组套索</strong>。给定一个风险函数，例如线性回归风险，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/5dd741ff5535e5b256e81374e090562e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*Um06GD9tyjrsfHBzLTtb6A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">线性回归模型的风险函数</p></figure><p id="b516" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ne">套索:</em> </strong>定义了在β系数的绝对值上增加一个惩罚项，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/ec27d78ecfb980419a0ab1f0734c41f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*K8OzPWOOBEbHEPPZAB90aA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">套索惩罚公式</p></figure><p id="4c22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个定义提供了<strong class="ky ir">稀疏解</strong>，因为它会将一些β系数(与响应变量最不相关)置零。这种惩罚的效果可以使用λ参数来控制<strong class="ky ir">。较大的λ值提供了惩罚更重要的解决方案，因此β系数中有更多的零。这主要在<strong class="ky ir">高维数据集</strong>中有用，这里的变量比观察值多，但我们只期望变量中的一小部分真正有意义。</strong></p><p id="a8cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在某些情况下，X 中的预测变量具有自然的分组结构。例如，在生物统计学中，通常处理遗传数据集，其中预测因子被分组到遗传途径中。在股票市场分析中，人们可以将来自同一业务领域的公司分组。在气候数据中，人们可以对不同的地区进行分组 lasso 提供了单独的稀疏解决方案，而不是分组稀疏。</p><p id="d204" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ne">群拉索:</em> </strong>于是<strong class="ky ir"> </strong>群拉索来救援了。组套索是建立为属于同一组的系数的平方和。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ab954142ae0b38ef6afd6c6d08d8db2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*Zsw8eoBTWu9EEjKJdwLVag.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">群体套索惩罚公式</p></figure><p id="5395" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种方式，它考虑了预测器的可能<strong class="ky ir">分组结构，并且它将整组变量发送到零。如果所有组的大小都是 1(每个组只有一个预测值)，我们将求解一个套索模型。让我们用图形来看套索和套索组，</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/6df6074e237bfb20d0a62ecfd49f1ecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PxFCLA4oNCdrP0OYK0GHEQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">套索、成组套索和山脊惩罚比较</p></figure><p id="32bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上图中，我们有一个简单的问题，有三个系数，β₁ <br/> β₁₁和β₁₂.最后两个系数组成一个组，正如我们看到的，lasso(左图)没有考虑这个分组信息，但 group lasso 考虑了。所以群套索可以看成是群与群之间的套索，群内的脊。如果一个群体有意义，我们选择整个群体。如果不是，我们把它发送到零。</p><p id="bbc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ne">稀疏群套索:</em> </strong>最后就是这里了，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/d2dac279f64eeda62a74e66c1489f06c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*F2Fd7vUpjfTdO2rI2L0GHg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">稀疏群套索罚函数</p></figure><blockquote class="nj nk nl"><p id="2044" class="kw kx ne ky b kz la jr lb lc ld ju le nm lg lh li nn lk ll lm no lo lp lq lr ij bi translated">稀疏组套索是套索和套索组之间的线性组合，因此它提供了稀疏组之间和之内的解决方案。</p></blockquote><p id="09d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种技术从最有意义的组中选择最有意义的预测值，是近年来最好的变量选择方法之一。然而，直到现在，python… <em class="ne">的稀疏组套索还没有实现。</em></p><h1 id="af6a" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">迁移到 python:安装 asgl </strong></h1><p id="19c0" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">让我们从安装<code class="fe np nq nr ns b">asgl</code>开始。这可以使用<code class="fe np nq nr ns b">pip</code>轻松完成</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="1164" class="nx mh iq ns b gy ny nz l oa ob">pip install asgl</span></pre><p id="c3bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，你可以提取 github 库并运行<code class="fe np nq nr ns b">setup.py</code></p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="72ea" class="nx mh iq ns b gy ny nz l oa ob">git clone <a class="ae kv" href="https://github.com/alvaromc317/asgl" rel="noopener ugc nofollow" target="_blank">https://github.com/alvaromc317/asgl</a>.git<br/>cd asgl<br/>python setup.py</span></pre><h1 id="90ac" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">导入库</h1><p id="2b20" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">一旦我们安装了这个包，我们就可以开始使用它了。首先，让我们导入我们将在本例中使用的库和<code class="fe np nq nr ns b">BostonHousing</code>数据集。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="40f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，除了导入数据集，我们还创建了一个名为<code class="fe np nq nr ns b">group_index</code>的变量。这个变量描述了数据的分组结构，所以如果我们有 13 个预测值，<code class="fe np nq nr ns b">group_index</code>应该是一个长度为 13 的变量，如果前三个预测值组成一个组，它们应该有相同的<code class="fe np nq nr ns b">group_index</code>值。然而，<code class="fe np nq nr ns b">BostonHousing</code> dataset 没有自然的分组结构，所以为了本文的目的，我们在这里定义一个假的。</p><h1 id="d092" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">sgl 模型的参数</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="f532" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们看一下上面的稀疏群套索方程，我们可以看到<strong class="ky ir">有两个参数α和λ可以优化。</strong> λ控制我们希望给予惩罚的权重，因此λ值越大，产生的解越稀疏。α控制套索和组合套索之间的权衡。α等于 1 提供套索，α等于 0 提供组合套索。现在，通常，我们可以为这两个参数定义一个可能值的网格，并尝试找到使误差最小的组合。</p><p id="379a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们指定要求解的模型类型(lm，因为我们正在求解一个线性模型)、惩罚(sgl，因为我们需要稀疏组 lasso)、要使用的错误类型(MSE，因为我们将使用均方误差)以及最后，我们可以指明是要顺序还是并行运行该代码。<strong class="ky ir">并行执行</strong>利用了<code class="fe np nq nr ns b">multiprocess</code> python 库，可以比顺序执行更快地解决问题。</p><h1 id="de17" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">交叉验证</strong></h1><p id="9938" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们已经定义了 23 个可能的λ值和 20 个可能的α值的网格。共有 460 种参数组合。我们将使用交叉验证(并行运行)找到最佳组合</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9c63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以首先，我们定义一个<code class="fe np nq nr ns b">CV</code>对象，我们插入上面定义的所有参数信息。然后，我们运行<code class="fe np nq nr ns b">cross_validation()</code>函数，该函数将返回 460 个模型中的每一个在 k 次折叠中达到的误差。</p><p id="2a2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们<strong class="ky ir">搜索最小化均方误差的参数值</strong>，并将它们的值存储在<code class="fe np nq nr ns b">optimal_lambda</code>和<code class="fe np nq nr ns b">optimal_alpha</code>中。</p><p id="a1b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这么简单，我们找到了我们的最优模型。</p><h1 id="6aec" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">获得最终误差</h1><p id="b4d7" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">然而，应该记住，交叉验证误差有点偏差，因此为了获得最终预测误差，我们将使用最佳参数运行最终训练/测试分割。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="138f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们定义一个<code class="fe np nq nr ns b">ASGL</code>对象，我们将使用它来拟合一个简单的稀疏组套索模型(没有交叉验证)。然后，我们使用函数<code class="fe np nq nr ns b">train_test_split()</code>将数据分成 70%训练 30%测试，我们拟合模型，以便获得β系数的最终估计值(存储在<code class="fe np nq nr ns b">final_beta_solution</code></p><p id="71cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给定一个新的数据集，我们可以使用函数<code class="fe np nq nr ns b">ASGL.predict()</code>预测响应变量的值，并使用带有函数<code class="fe np nq nr ns b">error_calculator</code>的测试集计算最终预测误差。</p><p id="f544" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上就是如何用 python 实现稀疏群组套索。我希望你喜欢这篇文章，并发现它很有用，所以<em class="ne">继续关注</em>这个系列的未来文章，如果你有任何问题/建议，请不要犹豫，与我联系。</p><p id="2beb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要更深入地了解<code class="fe np nq nr ns b">asgl</code>包提供了什么，我推荐阅读 github 库中提供的<a class="ae kv" href="https://github.com/alvaromc317/asgl/blob/master/user_guide.ipynb" rel="noopener ugc nofollow" target="_blank"> jupyter 笔记本</a>。</p><p id="f07f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">祝你今天开心！玩的开心！</p></div></div>    
</body>
</html>