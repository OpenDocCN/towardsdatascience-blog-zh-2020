<html>
<head>
<title>Saving and Loading Keras model using JSON and YAML files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JSON和YAML文件保存和加载Keras模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/saving-and-loading-keras-model-42195b92f57a?source=collection_archive---------7-----------------------#2020-02-23">https://towardsdatascience.com/saving-and-loading-keras-model-42195b92f57a?source=collection_archive---------7-----------------------#2020-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2a93" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用JSON和YAML文件保存和加载深度学习模型的快速简单的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/228c9826cdeeb1703e4f6fbf2ae27e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v-f3Lohs8vr6InODTa4cAw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">维克托·弗雷塔斯在Unsplash上的照片</p></figure><blockquote class="ky"><p id="b6df" class="kz la it bd lb lc ld le lf lg lh li dk translated">你如何与在世界不同地方工作的其他团队成员分享你训练的深度学习模型，或者如何在训练期间或之后保存深度学习模型及其训练的权重，或者如何从你停止的地方恢复模型的训练？</p></blockquote><p id="1c10" class="pw-post-body-paragraph lj lk it ll b lm ln ju lo lp lq jx lr ls lt lu lv lw lx ly lz ma mb mc md li im bi translated"><strong class="ll iu">要回答以上问题我们需要保存一下</strong></p><ul class=""><li id="fa49" class="me mf it ll b lm mg lp mh ls mi lw mj ma mk li ml mm mn mo bi translated"><strong class="ll iu">模型建筑</strong></li><li id="5498" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated"><strong class="ll iu">模型的训练权重或参数</strong></li></ul><p id="df77" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">共享保存的文件将允许其他人重新创建模型来进行推理或从您停止的地方继续进一步的训练。可以通过加载模型来重新创建模型，并从包含模型架构和预训练权重的保存文件中训练权重。</p><p id="f2a1" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">使用不同的方法来保存和加载深度学习模型</p><ul class=""><li id="76a7" class="me mf it ll b lm mg lp mh ls mi lw mj ma mk li ml mm mn mo bi translated"><strong class="ll iu"> JSON文件</strong></li><li id="301c" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated"><strong class="ll iu"> YAML档案</strong></li><li id="2715" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated"><strong class="ll iu">检查点</strong></li></ul><p id="f85b" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">在本文中，您将学习如何将Keras开发的深度学习模型保存为JSON或YAML文件格式，然后重新加载该模型。</p><p id="3965" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">为了保存模型，我们首先创建一个基本的深度学习模型。我使用了时尚MNIST数据集，我们用它来保存，然后用不同的方法重新加载模型。</p><p id="9b4b" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">我们需要安装两个库:<code class="fe mx my mz na b"><strong class="ll iu">pyyaml and h5py</strong></code></p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="368b" class="nf ng it na b gy nh ni l nj nk"><strong class="na iu">pip install pyyaml<br/>pip install h5py</strong></span></pre><p id="81a8" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">我用的是Tensorflow 1.14.0</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="86ee" class="nf ng it na b gy nh ni l nj nk">#Importing required libararies<br/><strong class="na iu">import os<br/>import tensorflow as tf<br/>from tensorflow import keras</strong></span><span id="9b2b" class="nf ng it na b gy nl ni l nj nk">#Loading Fashion MNIST dataset<br/><strong class="na iu">(train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.fashion_mnist.load_data()</strong></span><span id="de3f" class="nf ng it na b gy nl ni l nj nk">#creating a smaller dataset <br/><strong class="na iu">train_labels = train_labels[:1000]<br/>test_labels = test_labels[:1000]</strong></span><span id="06a2" class="nf ng it na b gy nl ni l nj nk">#Normalizing the dataset<br/><strong class="na iu">train_images = train_images[:1000].astype('float32') / 255<br/>test_images = test_images[:1000].astype('float32') / 255</strong></span><span id="4022" class="nf ng it na b gy nl ni l nj nk"># Reshaping the data for inputing into the model<br/><strong class="na iu">train_images = train_images.reshape((train_images.shape[0],  28, 28,1))<br/>test_images = test_images.reshape((test_images.shape[0],  28, 28,1))</strong></span><span id="17a1" class="nf ng it na b gy nl ni l nj nk">#Defining and compiling the keras model<br/><strong class="na iu">def create_model():<br/>    model = tf.keras.Sequential()<br/>    # Must define the input shape in the first layer of the neural network<br/>    model.add(tf.keras.layers.Conv2D(filters=64, kernel_size=2, padding='same', activation='relu', input_shape=(28,28,1))) <br/>    model.add(tf.keras.layers.MaxPooling2D(pool_size=2))<br/>    model.add(tf.keras.layers.Dropout(0.3))<br/>    model.add(tf.keras.layers.Conv2D(filters=32, kernel_size=2, padding='same', activation='relu'))<br/>    model.add(tf.keras.layers.MaxPooling2D(pool_size=2))<br/>    model.add(tf.keras.layers.Dropout(0.3))<br/>    model.add(tf.keras.layers.Flatten())<br/>    model.add(tf.keras.layers.Dense(256, activation='relu'))<br/>    model.add(tf.keras.layers.Dropout(0.5))<br/>    model.add(tf.keras.layers.Dense(10, activation='softmax'))<br/>    <br/>    </strong>#Compiling the model<strong class="na iu"><br/>    model.compile(loss='sparse_categorical_crossentropy',<br/>             optimizer='adam',<br/>             metrics=['accuracy'])<br/>    <br/>    return model</strong></span><span id="576c" class="nf ng it na b gy nl ni l nj nk"># Create a basic model instance<br/><strong class="na iu">model = create_model()</strong></span><span id="8a0a" class="nf ng it na b gy nl ni l nj nk"><strong class="na iu">model.summary()</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/f30d9b69365bd28427daafdb7349aef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*o8mihDrEqoLzADSFOcc9xA.png"/></div></figure><h1 id="5857" class="nn ng it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">使用JSON文件保存和加载模型架构</h1><p id="d54c" class="pw-post-body-paragraph lj lk it ll b lm oe ju lo lp of jx lr ls og lu lv lw oh ly lz ma oi mc md li im bi translated">将模型保存和加载到JSON文件的步骤</p><ul class=""><li id="7dc5" class="me mf it ll b lm mg lp mh ls mi lw mj ma mk li ml mm mn mo bi translated">将训练数据拟合到模型中</li><li id="6bda" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated">使用<strong class="ll iu"> to_json() </strong>将模型架构保存到JSON文件中。返回的字符串将保存在一个JSON文件中</li><li id="06b2" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated">使用<strong class="ll iu"> save_weights() </strong>保存训练好的重量</li><li id="5529" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated">通过读取JSON文件从JSON文件中重新加载模型架构，然后使用<strong class="ll iu"> model_from_json() </strong>将模型架构重新加载到新模型中</li><li id="34db" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated">将使用<strong class="ll iu"> load_weights() </strong>重新加载已训练的重量</li></ul><p id="a52d" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated"><strong class="ll iu">将列车数据拟合到模型中</strong></p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="9107" class="nf ng it na b gy nh ni l nj nk">#Fit the train data to the model<strong class="na iu"><br/>model.fit(train_images, <br/>          train_labels,  <br/>          batch_size=64,<br/>          epochs=100,<br/>          validation_data=(test_images,test_labels))</strong></span></pre><p id="29cf" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated"><strong class="ll iu">将模型架构和权重保存到JSON文件</strong></p><p id="7a2c" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">使用<strong class="ll iu"> <em class="oj"> to_json() </em> </strong>将模型架构写入JSON文件，并使用<strong class="ll iu"><em class="oj">save _ weights()</em></strong>保存训练好的模型的权重</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="c41a" class="nf ng it na b gy nh ni l nj nk"><strong class="na iu">from keras.models import model_from_json</strong></span><span id="9b8f" class="nf ng it na b gy nl ni l nj nk"># serialize model to json<br/><strong class="na iu">json_model = model.to_json()</strong></span><span id="c1e4" class="nf ng it na b gy nl ni l nj nk">#save the model architecture to JSON file<br/><strong class="na iu">with open('fashionmnist_model.json', 'w') as json_file:<br/>    json_file.write(json_model)</strong></span><span id="da57" class="nf ng it na b gy nl ni l nj nk">#saving the weights of the model<br/><strong class="na iu">model.save_weights('FashionMNIST_weights.h5')</strong></span><span id="2eba" class="nf ng it na b gy nl ni l nj nk">#Model loss and accuracy<br/><strong class="na iu">loss,acc = model.evaluate(test_images,  test_labels, verbose=2)</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/08588f73826d58021db1669af49fff87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*DQR6RPB02mjlaCLP_DI0pA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原始模型的损失和准确性</p></figure><p id="fa6b" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated"><strong class="ll iu">将模型架构从JSON文件重新加载到新模型</strong></p><p id="d9af" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">我们已经创建了一个新的模型:<strong class="ll iu"> <em class="oj"> model_j </em> </strong>，它将与保存的模型具有相同的架构</p><p id="b04c" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">我添加了glorot_uniform库，因为我得到了初始化器的警告</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="2940" class="nf ng it na b gy nh ni l nj nk"><strong class="na iu">from keras.initializers import glorot_uniform</strong><br/>#Reading the model from JSON file<br/><strong class="na iu">with open('fashionmnist_model.json', 'r') as json_file:<br/>    json_savedModel= json_file.read()</strong></span><span id="44e1" class="nf ng it na b gy nl ni l nj nk">#load the model architecture <br/><strong class="na iu">model_j = tf.keras.models.model_from_json(json_savedModel)<br/>model_j.summary()</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/9e456e38e8b76104534fd5fe324e77c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*ycALouO31Wp1Dje2OwMLng.png"/></div></figure><p id="11fe" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">新模型与先前保存的模型具有相同的架构</p><p id="5a9d" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated"><strong class="ll iu">将训练好的重量重新加载到新模型中</strong></p><p id="d977" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">使用<strong class="ll iu"> <em class="oj"> load_weights() </em> </strong>将预训练的权重加载到新模型中</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="50f4" class="nf ng it na b gy nh ni l nj nk"><strong class="na iu">model_j.load_weights('FashionMNIST_weights.h5')</strong></span></pre><p id="54a3" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">只有模型架构和预训练的权重被加载到新模型中，但是缺少模型编译细节，所以我们需要编译模型。</p><p id="2b7b" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">我们可以指定不同的优化器来编译模型，比如将优化器从Adam改为“Rmsprop”或“SGD”</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="2dfd" class="nf ng it na b gy nh ni l nj nk">#Compiling the model<br/><strong class="na iu">model_j.compile(loss='sparse_categorical_crossentropy',<br/>         optimizer='SGD',<br/>         metrics=['accuracy'])</strong></span></pre><p id="d942" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">我们可以检查新模型的损失和准确性，以确认是否加载了相同的训练重量</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="5e05" class="nf ng it na b gy nh ni l nj nk">loss,acc = model_j.evaluate(test_images,  test_labels, verbose=2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/88d495836ecc282bbbc177efa0f20e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*sGLxVQW7RPVN8hnl8KznFQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用JSON文件的新模型的测试数据的模型损失和准确性</p></figure><h1 id="4b51" class="nn ng it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">使用YAML文件保存和加载模型架构</h1><p id="103d" class="pw-post-body-paragraph lj lk it ll b lm oe ju lo lp of jx lr ls og lu lv lw oh ly lz ma oi mc md li im bi translated">将模型保存和加载到YAML文件的步骤</p><ul class=""><li id="e9eb" class="me mf it ll b lm mg lp mh ls mi lw mj ma mk li ml mm mn mo bi translated">将训练数据拟合到模型中</li><li id="ecf2" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated">使用<strong class="ll iu"> to_yaml() </strong>将模型架构保存到YAML文件中。返回的字符串将保存在YAML文件中</li><li id="02b0" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated">使用<strong class="ll iu"> save()将训练好的重量保存在H5文件中。</strong></li><li id="abdd" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated">通过读取YAML文件从YAML文件中重新加载模型架构，然后使用<strong class="ll iu"> model_from_yaml() </strong>将模型架构重新加载到新模型中</li><li id="4595" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated">使用<strong class="ll iu"> save() </strong>保存训练后的重量，并使用<strong class="ll iu"> load_model() </strong>加载到新模型中</li></ul><p id="57bf" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">我们将使用之前的模型保存到YAML文件。我们不会再次拟合该模型，因为它已经被训练过了。</p><p id="6adf" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated"><strong class="ll iu">将模型架构保存到YAML文件</strong></p><p id="477c" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">使用<strong class="ll iu"> <em class="oj"> to_yaml() </em> </strong>将模型架构写入YAML文件</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="1a68" class="nf ng it na b gy nh ni l nj nk">#saving the model to a YAML file<br/><strong class="na iu">yaml_model= model.to_yaml()</strong></span><span id="6306" class="nf ng it na b gy nl ni l nj nk"># writing the yaml model to the yaml file<br/><strong class="na iu">with open('fashionmnist_yamlmodel.yaml', 'w') as yaml_file:<br/>    yaml_file.write(yaml_model)</strong></span></pre><p id="9481" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated"><strong class="ll iu">将模型架构从YAML文件重新加载到新模型</strong></p><p id="ebc3" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">从YAML中读取模型架构，并使用<strong class="ll iu"><em class="oj">model _ from _ YAML()</em></strong>将其恢复为新模型<strong class="ll iu"> <em class="oj"> model_y </em> </strong></p><p id="f69f" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">我们得到了与原始模型相同的模型架构</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="29ff" class="nf ng it na b gy nh ni l nj nk"><strong class="na iu">#Read  the model architecture from  YAML file</strong><br/><strong class="na iu">with open('fashionmnist_yamlmodel.yaml', 'r') as yaml_file:<br/>    yaml_savedModel=yaml_file.read()</strong></span><span id="b2cd" class="nf ng it na b gy nl ni l nj nk"># Load the saved Yaml model<br/><strong class="na iu">from keras.models import model_from_yaml<br/>model_y= tf.keras.models.model_from_yaml(yaml_savedModel)<br/>model_y.summary()</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/4d3ea59ca5aaa8e1ca623e4baf8099c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*po16KBGMzJokYwbGlJEEsA.png"/></div></figure><p id="fae4" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated"><strong class="ll iu">使用HDF5格式的<em class="oj">Save()</em></strong><strong class="ll iu">将权重保存在单个文件/文件夹</strong>中</p><ul class=""><li id="1150" class="me mf it ll b lm mg lp mh ls mi lw mj ma mk li ml mm mn mo bi translated"><strong class="ll iu">模型的架构，以便我们可以随时随地重新创建它</strong></li><li id="e646" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated"><strong class="ll iu">模型的训练权重</strong></li><li id="f884" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated"><strong class="ll iu">训练配置如损失函数、优化器等。</strong></li><li id="06a1" class="me mf it ll b lm mp lp mq ls mr lw ms ma mt li ml mm mn mo bi translated"><strong class="ll iu">优化器的状态</strong></li></ul><p id="48f6" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated"><strong class="ll iu"> Save()有助于导出模型并重新创建整个模型，或者从您离开的地方继续训练。</strong></p><p id="60e5" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">可以使用<strong class="ll iu"> <em class="oj"> load_model()、</em> </strong>恢复模型，这也负责使用保存的训练配置编译模型。</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="af00" class="nf ng it na b gy nh ni l nj nk">#saving the smodel's architecture, weights, and training configuration in a single file/folder.</span><span id="049a" class="nf ng it na b gy nl ni l nj nk"><strong class="na iu">model.save('fashionmnist.h5')</strong></span></pre><p id="5e4a" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated"><strong class="ll iu">恢复模型</strong></p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="de74" class="nf ng it na b gy nh ni l nj nk"># loading the model from the HDF5 file<br/><strong class="na iu">model_h5 = tf.keras.models.load_model('fashionmnist.h5')</strong></span></pre><p id="8d04" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">让我们在测试图像上评估新恢复的模型。注意，我们在这里没有编译模型</p><pre class="kj kk kl km gt nb na nc nd aw ne bi"><span id="c27c" class="nf ng it na b gy nh ni l nj nk"><strong class="na iu">loss,acc = model_h5.evaluate(test_images, test_labels, verbose=2)</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/b9d2181ae4fda935f8b22742ca659c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*px3oRBUHlbWkIMRHG0TdSw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用YAML文件的新模型的测试数据的模型损失和准确性</p></figure><p id="53e3" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">我们得到大致相同的损失和精度，因为我们没有在这里设置种子。</p><p id="c771" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated"><a class="ae op" href="https://github.com/arshren/save-and-load-model-and-weights/blob/master/Fashion%20MNIST-Save%20and%20load%20models.ipynb" rel="noopener ugc nofollow" target="_blank">保存模型并使用时尚MNIST重新加载模型的代码</a></p><h2 id="d825" class="nf ng it bd no oq or dn ns os ot dp nw ls ou ov ny lw ow ox oa ma oy oz oc pa bi translated">结论:</h2><p id="65c4" class="pw-post-body-paragraph lj lk it ll b lm oe ju lo lp of jx lr ls og lu lv lw oh ly lz ma oi mc md li im bi translated">我们现在可以保存权重，并使用JSON文件或YAML文件将它们重新加载到一个新的模型中，这将允许您与世界分享您出色的深度学习工作，或恢复您的训练以获得更好的表现。</p><p id="e55f" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated">使用检查点保存和加载模型将在下一篇文章中讨论</p><h2 id="7538" class="nf ng it bd no oq or dn ns os ot dp nw ls ou ov ny lw ow ox oa ma oy oz oc pa bi translated">参考资料:</h2><div class="pb pc gp gr pd pe"><a href="https://www.tensorflow.org/tutorials/keras/save_and_load" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">保存和加载模型| TensorFlow核心</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">您看到了如何将权重加载到模型中。手动保存它们与模型一样简单</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">www.tensorflow.org</p></div></div></div></a></div><p id="1688" class="pw-post-body-paragraph lj lk it ll b lm mg ju lo lp mh jx lr ls mu lu lv lw mv ly lz ma mw mc md li im bi translated"><a class="ae op" href="https://keras.io/getting-started/faq/#how-can-i-save-a-keras-model" rel="noopener ugc nofollow" target="_blank">https://keras . io/getting-started/FAQ/# how-can-I-save-a-keras-model</a></p></div></div>    
</body>
</html>