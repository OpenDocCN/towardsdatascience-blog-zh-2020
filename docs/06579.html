<html>
<head>
<title>Assertive Programming in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R 语言中的断言编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/assertive-programming-in-r-36c3cc290930?source=collection_archive---------51-----------------------#2020-05-24">https://towardsdatascience.com/assertive-programming-in-r-36c3cc290930?source=collection_archive---------51-----------------------#2020-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ba2d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">您的代码应该按预期工作，否则会立即失败</h2></div><p id="ccbb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能熟悉使用<em class="lb"> testthat </em>包的单元测试。单元测试的目标是检查你的功能是否被正确开发。断言检查你的函数是否被正确使用。</p><blockquote class="lc ld le"><p id="3547" class="kf kg lb kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">单元测试是为<strong class="kh ir">开发人员</strong>准备的，并根据命令执行。<br/>断言是针对<strong class="kh ir">用户</strong>的，并且在每次函数调用时执行。</p></blockquote><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/a291efef7ab83faff4a81028f28dbf9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e-wobHH2dZcjxrcZ"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">照片由 chuttersnap 在 Unsplash 上拍摄</p></figure><h1 id="fb7f" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">快速失败</h1><p id="a4ca" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">运行时测试，通常称为断言，是一小段代码，用于检查条件，如果条件不满足，测试就会失败。断言使你的代码能够快速失败——这是一件好事。当某个东西出错时，我们不希望我们的程序继续运行，直到错误复合并暴露出来。相反，我们希望程序在错误的源头立即失败，并给出清晰准确的错误消息。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="9826" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文的目标是让你的 R 函数快速失效。假设你的函数没有错误或者副作用，错误进入你的函数的唯一途径就是通过它的输入。在本文中，您将学习如何使用断言来识别不良输入并警告用户(包括未来的您)。</p><p id="b1bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输入有两种不好的方式:</p><ol class=""><li id="dc9f" class="nd ne iq kh b ki kj kl km ko nf ks ng kw nh la ni nj nk nl bi translated"><strong class="kh ir">功能输入包含错误</strong>。R 发现了一些错误:从不可能或丢失的值到十进制数中逗号和点的不一致使用。其他错误更加隐蔽。想想无效的信用卡号或不存在的邮政编码和糟糕的电子邮件格式。</li><li id="8792" class="nd ne iq kh b ki nm kl nn ko no ks np kw nq la ni nj nk nl bi translated">你在开发你的功能时考虑了一个特殊的用例。你无法想象用户试图使用你的代码的所有方式。他或她可能<strong class="kh ir">以技术上正确的输入使用你的功能，但不是以预期的方式。你试过用<code class="fe nr ns nt nu b">sort.list(list(2, 1, 3))</code>排序列表吗？</strong></li></ol><h1 id="7c7c" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">为什么 R 包“自信”</h1><p id="f53a" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">r 有几个用于编写断言的包。这篇文章提倡 R 包<em class="lb">自信</em>有三个原因:</p><ol class=""><li id="50ae" class="nd ne iq kh b ki kj kl km ko nf ks ng kw nh la ni nj nk nl bi translated">该软件包为许多不同的情况提供了大量的功能</li><li id="b2ca" class="nd ne iq kh b ki nm kl nn ko no ks np kw nq la ni nj nk nl bi translated">它的功能非常容易阅读</li></ol><p id="a16d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nr ns nt nu b">assert_all_are_positive(c(1, -2, 3))</code></p><p id="8e1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.并提供信息丰富的错误消息</p><pre class="lj lk ll lm gt nv nu nw nx aw ny bi"><span id="3f9a" class="nz lz iq nu b gy oa ob l oc od">Error: is_positive : c(1, -2, 3) contains non-positive values.<br/>There was 1 failure:<br/> Position Value Cause<br/>1 2 -2 too low</span></pre><p id="388d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">直接从<a class="ae mv" href="https://cran.r-project.org/" rel="noopener ugc nofollow" target="_blank">起重机</a>安装软件包，并将其加载到您的 R 会话中:</p><p id="f469" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nr ns nt nu b">install.packages("assertive")</code></p><p id="14a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nr ns nt nu b">library(assertive)</code></p><h1 id="ac70" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">写你的第一个断言</h1><p id="9dee" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">假设您编写了一个对数值向量的元素求和的函数:</p><pre class="lj lk ll lm gt nv nu nw nx aw ny bi"><span id="a78e" class="nz lz iq nu b gy oa ob l oc od">add_numbers &lt;- function(numbers) {<br/>  result &lt;- sum(numbers)<br/>  return(result)<br/>}</span></pre><p id="8ccb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向量的值可以是任何数字。让我们在函数的开头写一个断言来检查我们的输入向量:</p><pre class="lj lk ll lm gt nv nu nw nx aw ny bi"><span id="d6ee" class="nz lz iq nu b gy oa ob l oc od">add_numbers &lt;- function(numbers) {<br/><strong class="nu ir">  assert_is_numeric(numbers)</strong><br/>  result &lt;- sum(numbers)<br/>  return(result)<br/>}</span><span id="fda3" class="nz lz iq nu b gy oe ob l oc od">add_numbers(c(1, 2, 2, 3)) # pass</span></pre><p id="e4d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意断言是写在函数内部的<em class="lb">。这意味着它总是在那里，等待每次调用函数时被执行。检查一个断言只需要几毫秒的时间，这对于除了对性能要求最高的应用程序之外的所有应用程序来说都没问题。</em></p><h1 id="8b2e" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">检查多个条件</h1><p id="6cc1" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">假设您修改了函数，期望得到一个唯一的<em class="lb">值的向量。现在你需要两个断言:</em></p><ol class=""><li id="5b1d" class="nd ne iq kh b ki kj kl km ko nf ks ng kw nh la ni nj nk nl bi translated">一个用于检查向量是否为数字</li><li id="f9bb" class="nd ne iq kh b ki nm kl nn ko no ks np kw nq la ni nj nk nl bi translated">另一个检查向量没有重复值</li></ol><p id="d7f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以通过用来自<em class="lb">magritter</em>包的<a class="ae mv" href="https://magrittr.tidyverse.org/" rel="noopener ugc nofollow" target="_blank">转发管道</a> <code class="fe nr ns nt nu b">%&gt;%</code>链接两个或更多断言来保持代码的可读性:</p><pre class="lj lk ll lm gt nv nu nw nx aw ny bi"><span id="8477" class="nz lz iq nu b gy oa ob l oc od">library(magrittr)</span><span id="5502" class="nz lz iq nu b gy oe ob l oc od">add_unique_numbers &lt;- function(input_vector) {<br/><strong class="nu ir">  input_vector %&gt;% <br/>    assert_is_numeric %&gt;%<br/>    assert_has_no_duplicates<br/>  </strong>result &lt;- sum(input_vector)<br/>  return(result)<br/>}</span><span id="9843" class="nz lz iq nu b gy oe ob l oc od">add_unique_numbers(c(1.5, 2, 2, 3)) # fail</span></pre></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="ea94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有很多<em class="lb">断言</em>函数，适用于各种情况。全部背下来不太实际。只需在 CRAN 上搜索<a class="ae mv" href="https://cran.r-project.org/web/packages/assertive/assertive.pdf" rel="noopener ugc nofollow" target="_blank">包文档</a>就能找到适合你特定需求的功能。</p><p id="7dac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用一个练习来试试这个。下面的函数需要百分比值的向量，例如<code class="fe nr ns nt nu b">percentages &lt;- c(64, 55, 97, 85)</code>，并计算平均百分比。你能在<em class="lb"> assertive </em>包中找到合适的断言吗？</p><pre class="lj lk ll lm gt nv nu nw nx aw ny bi"><span id="e65b" class="nz lz iq nu b gy oa ob l oc od">calculate_mean_percentage &lt;- function(percentages) {<br/><strong class="nu ir">    # ... your assertion goes here <br/></strong>    result &lt;- mean(percentages)<br/>    return(result)<br/>}</span></pre><p id="d2cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">提示:在你的 R 控制台中编写</em> <code class="fe nr ns nt nu b">ls("package:assertive", pattern = "percent")</code> <em class="lb">来搜索 assertive 中名称与“百分比”匹配的函数。</em></p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="1498" class="ly lz iq bd ma mb of md me mf og mh mi jw oh jx mk jz oi ka mm kc oj kd mo mp bi translated">断言和谓词</h1><p id="b2f1" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">您可能会在这里看到一种模式。所有断言都由三部分组成:</p><ol class=""><li id="9bf2" class="nd ne iq kh b ki kj kl km ko nf ks ng kw nh la ni nj nk nl bi translated">他们总是以<code class="fe nr ns nt nu b">assert_</code>开头</li><li id="720f" class="nd ne iq kh b ki nm kl nn ko no ks np kw nq la ni nj nk nl bi translated">后跟谓语<code class="fe nr ns nt nu b">is_</code>或<code class="fe nr ns nt nu b">has_</code></li><li id="8f71" class="nd ne iq kh b ki nm kl nn ko no ks np kw nq la ni nj nk nl bi translated">并以期望结束，例如<code class="fe nr ns nt nu b">numeric</code></li></ol><p id="4a38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当检查对象的<em class="lb">单个元素</em>而不是对象本身时，谓词<code class="fe nr ns nt nu b">is_</code>在中变为<code class="fe nr ns nt nu b">all_are_</code>或<code class="fe nr ns nt nu b">any_are_</code>。例如，下面的断言检查传递给函数的所有数字是否都是整数:</p><pre class="lj lk ll lm gt nv nu nw nx aw ny bi"><span id="61ac" class="nz lz iq nu b gy oa ob l oc od">add_whole_numbers &lt;- function(whole_numbers) {<br/><strong class="nu ir">  assert_all_are_whole_numbers(whole_numbers)</strong><br/>  result &lt;- sum(whole_numbers)<br/>  return(result)<br/>}</span><span id="bf55" class="nz lz iq nu b gy oe ob l oc od">add_unique_numbers(c(1.5, 2, 2, 3)) # fail</span></pre></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="6346" class="ly lz iq bd ma mb of md me mf og mh mi jw oh jx mk jz oi ka mm kc oj kd mo mp bi translated">除了核对数字</h1><p id="689d" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">到目前为止，我们只处理了数字。但是<em class="lb">断言</em>包包含了各种情况下的断言。为了说明这一点，我们将用一些检查文本、日期甚至主机操作系统的例子来结束我们的讨论。</p><ul class=""><li id="3f5f" class="nd ne iq kh b ki kj kl km ko nf ks ng kw nh la ok nj nk nl bi translated">你的函数需要一个人名向量吗？<br/>检查缺失或空字符串:</li></ul><p id="44f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nr ns nt nu b">assert_all_are_non_missing_nor_empty_character()</code></p><ul class=""><li id="110c" class="nd ne iq kh b ki kj kl km ko nf ks ng kw nh la ok nj nk nl bi translated">有一个只在 Windows 上工作的功能？然后确保用户正在运行 Windows:</li></ul><p id="11b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nr ns nt nu b">assert_is_windows()</code></p><ul class=""><li id="dd9d" class="nd ne iq kh b ki kj kl km ko nf ks ng kw nh la ok nj nk nl bi translated">你的函数期望一个人的出生日期吗？<br/>确定事情已经过去:</li></ul><p id="528f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nr ns nt nu b">assert_is_in_past()</code></p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="40bb" class="ly lz iq bd ma mb of md me mf og mh mi jw oh jx mk jz oi ka mm kc oj kd mo mp bi translated"><strong class="ak">结论</strong></h1><p id="d7db" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">在本文中，您学习了如何使用<em class="lb"> assertive </em>包编写断言。多亏了断言，你的函数将做它们应该做的事情，或者快速失败，并给出一个清晰的错误消息。</p><h2 id="a9ea" class="nz lz iq bd ma ol om dn me on oo dp mi ko op oq mk ks or os mm kw ot ou mo ov bi translated"><em class="ow">参考文献</em></h2><p id="386c" class="pw-post-body-paragraph kf kg iq kh b ki mq jr kk kl mr ju kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">棉花理查德。(2017).<em class="lb">测试 R 代码(第一版)。</em>查普曼&amp;霍尔。</p><p id="8e47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">亨特安德鲁。托马斯戴夫。(1999).<em class="lb">《实用程序员》(第 25 版，2010 年 2 月)</em>。爱迪生韦斯利朗曼公司。</p></div></div>    
</body>
</html>