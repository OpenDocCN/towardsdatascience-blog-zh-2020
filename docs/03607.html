<html>
<head>
<title>Italian COVID-19 Analysis with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python进行意大利新冠肺炎分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/italian-covid-19-analysis-with-python-1bdb0e64d5ac?source=collection_archive---------24-----------------------#2020-04-05">https://towardsdatascience.com/italian-covid-19-analysis-with-python-1bdb0e64d5ac?source=collection_archive---------24-----------------------#2020-04-05</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><div class=""/><figure class="gm go ju jv jw jx gi gj paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gi gj jt"><img src="../Images/06f1ca2d08dffa4d22e0bca147b5f11d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*trYfW-d2eNP-L6J-00L3Dw.jpeg"/></div></div><p class="ke kf gk gi gj kg kh bd b be z dk translated">照片由<a class="ae ki" href="https://pixabay.com/it/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4957154" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a>从<a class="ae ki" href="https://pixabay.com/it/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4957154" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="45a3" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">本教程分析了意大利民间保护组织发布的关于新冠肺炎的数据，并建立了流行病结束的预测。在下面的文章中描述了这个预测器背后的一般概念:<a class="ae ki" href="https://medium.com/@angelica.loduca/predicting-the-end-of-the-coronavirus-epidemics-in-italy-8da9811f7740" rel="noopener">https://medium . com/@ angelica . lo duca/predicting-the-end-of-the-coronavirus-epiderations-in-Italy-8da 9811 f 7740</a>。代码可以从我的github资源库下载:<a class="ae ki" href="https://github.com/alod83/data-science/tree/master/DataAnalysis/covid-19" rel="noopener ugc nofollow" target="_blank">https://github . com/alod 83/data-science/tree/master/data analysis/新冠肺炎</a>。</p><p id="df6a" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">本教程的主要目的在于建立一个预测器，用于预测意大利新冠肺炎疫情新发病例的可能结束时间。建议的教程是基于意大利的数据，但它也可以推广到其他国家的数据。例如，关于西班牙的数据可在此链接获得:<a class="ae ki" href="https://github.com/datadista/datasets/tree/master/COVID%2019" rel="noopener ugc nofollow" target="_blank">https://github . com/data dista/datasets/tree/master/COVID % 2019</a>。</p><p id="fdd0" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">到目前为止，已经提出了不同的方法，例如R0传染指数(详见此处<a class="ae ki" href="http://theconversation.com/r0-how-scientists-quantify-the-intensity-of-an-outbreak-like-coronavirus-and-predict-the-pandemics-spread-130777" rel="noopener ugc nofollow" target="_blank">和</a>)。然而，在新冠肺炎流行病的情况下，估计R0并不简单。相反，本教程中提出的模型是基于对真实数据的观察，并且使用哪条曲线来拟合数据的决定是基于这样的观察。</p><p id="d021" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">本教程的一个可能的扩展是构建一个预测意大利整个流行病结束的预测器，即没有新的阳性病例登记的时间。这方面将是未来文章的主题。</p><p id="8da2" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">笔记本利用了<code class="fe lh li lj lk b">pandas</code>和<code class="fe lh li lj lk b">scikit-learn</code>库。</p><h1 id="cb7d" class="ll lm iw bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">输入数据</h1><h2 id="c9e0" class="mj lm iw bd ln mk ml dn lr mm mn dp lv ku mo mp lz ky mq mr md lc ms mt mh mu bi translated">从Github存储库导入CSV并构建EPI</h2><p id="bd03" class="pw-post-body-paragraph kj kk iw kl b km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc mz le lf lg ip bi translated">首先，我们从意大利Protezione Civile的Github库导入数据，然后计算流行病进展指数(EPI)。我们提取列<code class="fe lh li lj lk b">totale_casi</code>，其中包含自疫情开始以来的新冠肺炎感染总数，以及<code class="fe lh li lj lk b">tamponi</code>，其中包含自疫情开始以来的新冠肺炎拭子总数。我们将EPI存储在<code class="fe lh li lj lk b">y</code>变量中。最后，我们打印所有有数据的日期列表(<code class="fe lh li lj lk b">data['data']</code>)。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="682f" class="mj lm iw lk b gz ni nj l nk nl">data = pd.read_csv(“<a class="ae ki" href="https://raw.githubusercontent.com/pcm-dpc/COVID-19/master/dati-andamento-nazionale/dpc-covid19-ita-andamento-nazionale.csv" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/pcm-dpc/COVID-19/master/dati-andamento-nazionale/dpc-covid19-ita-andamento-nazionale.csv</a>") <br/>tc = data[‘totale_casi’]<br/>tt = data[‘tamponi’]<br/>y = []<br/>tt_increase = []<br/>for i in range(1, len(tt)):<br/> current_epi = (tc[i] — tc[i-1])/(tt[i]-tt[i-1])*100<br/> tt_increase.append(tt[i]-tt[i-1])<br/> y.append(current_epi)<br/>data[‘data’]</span></pre><p id="62b0" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">现在我们计算有数据的日子。我们可以使用变量<code class="fe lh li lj lk b">data['data']</code>。但是，这个变量是一个字符串，所以很难用它来拟合预测值。因此，我们使用一个通用变量<code class="fe lh li lj lk b">X</code>，它包含一个数字序列，从1到样本总数。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="efa5" class="mj lm iw lk b gz ni nj l nk nl">X = []<br/>for i in range(1, len(y)+1):<br/> X.append([i])</span></pre><h1 id="f04b" class="ll lm iw bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">初步情节</h1><h2 id="17dd" class="mj lm iw bd ln mk ml dn lr mm mn dp lv ku mo mp lz ky mq mr md lc ms mt mh mu bi translated">绘制EPI与天数的关系图，以及两条垂直线，分别代表限制法的开始及其效果</h2><p id="efbc" class="pw-post-body-paragraph kj kk iw kl b km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc mz le lf lg ip bi translated">现在我们可以绘制y对X，也就是绘制EPI对天数。我们还绘制了两条额外的线:1)对应于限制法则开始的日期，2)曲线开始下降的日期(一周后)。这两条线在剧情展示的时候就可以理解了。</p><p id="02ba" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">在意大利，限制法律始于3月9日，相当于第14天。换句话说，它对应于<code class="fe lh li lj lk b">y</code>和<code class="fe lh li lj lk b">X</code>变量中的14行。从3月9日开始的一个星期后，限购令的效果就会显现出来。他们就这样在第21天开始了。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="42ae" class="mj lm iw lk b gz ni nj l nk nl"># vertical line corresponding to the beginning of restriction laws. <br/>di = 14<br/>restrictions_x = [di,di,di,di,di,di]<br/>restrictions_y = [0,10,20,30,40,50]</span><span id="6d2e" class="mj lm iw lk b gz nm nj l nk nl"># vertical line corresponding to the beginning of effects of restriction laws (after a week)<br/>de = di + 7<br/>effects_x = [de,de,de,de,de,de]<br/>effects_y = [0,10,20,30,40,50]<br/>de</span></pre><p id="5778" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">现在我们可以绘制图表。我们可以通过<code class="fe lh li lj lk b">xticks()</code>函数将<code class="fe lh li lj lk b">X</code>值转换成日期。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="5d2c" class="mj lm iw lk b gz ni nj l nk nl">import matplotlib.pyplot as plt</span><span id="7d8e" class="mj lm iw lk b gz nm nj l nk nl">plt.scatter(X, y, color=’black’)<br/>plt.plot(restrictions_x,restrictions_y, color=’red’, linewidth=2)<br/>plt.plot(effects_x,effects_y, color=’green’, linewidth=2)<br/>plt.grid()<br/>plt.xlabel(‘Days’)<br/>plt.xlim(0,40)<br/>plt.ylim(0,50)<br/>plt.xticks([0,5,10,15,20,25,30,35,40],<br/> [“24 Febr”, “29 Febr”, “5 Mar”, “10 Mar”, “15 Mar”, “20 Mar”, “25 Mar”, “30 Mar”, “4 Apr”])</span><span id="ee69" class="mj lm iw lk b gz nm nj l nk nl">plt.ylabel(‘Epidemics Progression Index (EPI)’)<br/>plt.savefig(“EPI-all.png”)<br/>plt.show()</span></pre><figure class="na nb nc nd gu jx gi gj paragraph-image"><div class="gi gj nn"><img src="../Images/1494860802683abeed784b492ca1cade.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*uFub7ZVt8YxV0bH4pTSfLA.png"/></div></figure><p id="996d" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">我们注意到EPI从3月16日开始下降，也就是限制法令颁布后整整一周。因此，我们可以用线性回归来逼近从3月16日开始的曲线，该曲线递减。</p><h1 id="4aed" class="ll lm iw bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">建立模型</h1><h2 id="e397" class="mj lm iw bd ln mk ml dn lr mm mn dp lv ku mo mp lz ky mq mr md lc ms mt mh mu bi translated">建立代表EPI的线性回归方程，拟合回归方程并计算分数</h2><p id="d4d6" class="pw-post-body-paragraph kj kk iw kl b km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc mz le lf lg ip bi translated">我们从<code class="fe lh li lj lk b">sklearn</code>库中导入<code class="fe lh li lj lk b">linear_model</code>。然后我们从3月16日之前的<code class="fe lh li lj lk b">X</code>和<code class="fe lh li lj lk b">y</code>数据中剔除，并用<code class="fe lh li lj lk b">X</code>和<code class="fe lh li lj lk b">y</code>拟合<code class="fe lh li lj lk b">LinearRegression</code>模型。最后，我们通过<code class="fe lh li lj lk b">score()</code>函数计算模型的得分。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="19cf" class="mj lm iw lk b gz ni nj l nk nl">import numpy as np<br/>from sklearn import linear_model<br/>X = X[de:]<br/>y = y[de:]</span><span id="4d8a" class="mj lm iw lk b gz nm nj l nk nl">print(X)<br/># Linear Regression<br/>linear_regr = linear_model.LinearRegression()</span><span id="b4a6" class="mj lm iw lk b gz nm nj l nk nl"># Train the model using the training sets<br/>linear_regr.fit(X, y)</span><span id="2120" class="mj lm iw lk b gz nm nj l nk nl">linear_regr.score(X,y)</span></pre><h1 id="68c7" class="ll lm iw bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">预测未来趋势</h1><h2 id="1891" class="mj lm iw bd ln mk ml dn lr mm mn dp lv ku mo mp lz ky mq mr md lc ms mt mh mu bi translated">使用回归变量预测未来趋势。也计算误差</h2><p id="a801" class="pw-post-body-paragraph kj kk iw kl b km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc mz le lf lg ip bi translated">拟合后，我们通过函数<code class="fe lh li lj lk b">predict()</code>建立代表数据的线性曲线，并通过应用于<code class="fe lh li lj lk b">y</code>的真实值和预测值<code class="fe lh li lj lk b">y_pred</code>的函数<code class="fe lh li lj lk b">max_error()</code>计算模型的最大误差。该误差将用于构建两条新的线，最大线和最小线，这两条线将定义新样本移动的范围。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="ea7f" class="mj lm iw lk b gz ni nj l nk nl">from sklearn.metrics import max_error<br/>import math</span><span id="bd5f" class="mj lm iw lk b gz nm nj l nk nl">y_pred = linear_regr.predict(X)<br/>error = max_error(y, y_pred)<br/>error</span></pre><p id="fb61" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">现在，我们可以应用该模型来预测未来几天的EPI。我们构建了一个变量<code class="fe lh li lj lk b">X_test</code>，它包含过去的日子(即数据已经可用的日子)和未来的日子。我们定义包含预测天数的变量<code class="fe lh li lj lk b">gp</code>。</p><p id="b183" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">然后我们将我们的模型应用到<code class="fe lh li lj lk b">X_test</code>。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="aab9" class="mj lm iw lk b gz ni nj l nk nl">X_test = []</span><span id="45e7" class="mj lm iw lk b gz nm nj l nk nl">gp = 40</span><span id="71b3" class="mj lm iw lk b gz nm nj l nk nl">for i in range(de, de + gp):<br/> X_test.append([i])</span><span id="7235" class="mj lm iw lk b gz nm nj l nk nl">y_pred_linear = linear_regr.predict(X_test)</span></pre><p id="8356" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">变量<code class="fe lh li lj lk b">y_pred_linear</code>包含未来几天的预测IPE。然而，我们也应该考虑模型产生的误差。因此，我们构建两个新变量<code class="fe lh li lj lk b">y_pred_max</code>和<code class="fe lh li lj lk b">y_pred_min</code>，分别包含<code class="fe lh li lj lk b">y_pred + error</code>和<code class="fe lh li lj lk b">y_pred - error</code>。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="7ad3" class="mj lm iw lk b gz ni nj l nk nl">y_pred_max = []<br/>y_pred_min = []<br/>for i in range(0, len(y_pred_linear)):<br/> y_pred_max.append(y_pred_linear[i] + error)<br/> y_pred_min.append(y_pred_linear[i] — error)</span></pre><h1 id="d283" class="ll lm iw bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">绘图结果</h1><h2 id="7754" class="mj lm iw bd ln mk ml dn lr mm mn dp lv ku mo mp lz ky mq mr md lc ms mt mh mu bi translated">画三条线，分别代表预测的输出，最大误差和最小误差</h2><p id="582d" class="pw-post-body-paragraph kj kk iw kl b km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc mz le lf lg ip bi translated">现在我们准备绘制数据(<code class="fe lh li lj lk b">y_pred</code>、<code class="fe lh li lj lk b">y_pred_max</code>和<code class="fe lh li lj lk b">y_pred_min</code>)。为了让情节更吸引人，我们应该将数字(由<code class="fe lh li lj lk b">X_test</code>变量表示)转换成日期。因此，我们维护两个变量<code class="fe lh li lj lk b">x_ticks</code>和<code class="fe lh li lj lk b">date_prev</code>，它们分别包含<code class="fe lh li lj lk b">X_test</code>和相应标签的子集..</p><p id="4e9b" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">为了建立<code class="fe lh li lj lk b">x_ticks</code>和<code class="fe lh li lj lk b">date_prev</code>之间的映射，我们从变量<code class="fe lh li lj lk b">data['data']</code>中提取限制的日期，并通过函数<code class="fe lh li lj lk b">datetime.strptime()</code>将其转换为日期。我们将结果存储在变量<code class="fe lh li lj lk b">data_eff</code>中。</p><p id="cb43" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">我们构建<code class="fe lh li lj lk b">x_ticks</code>，通过对<code class="fe lh li lj lk b">X_test</code>的每一个<code class="fe lh li lj lk b">step</code>物品进行抽样。我们定义<code class="fe lh li lj lk b">date_prev[0] = data_eff</code>。对于每一项，我们可以通过将<code class="fe lh li lj lk b">step</code>添加到前一项来构建<code class="fe lh li lj lk b">date_prev</code>。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="d26e" class="mj lm iw lk b gz ni nj l nk nl">from datetime import datetime<br/>from datetime import timedelta</span><span id="5e5f" class="mj lm iw lk b gz nm nj l nk nl">data_eff = datetime.strptime(data[‘data’][de], ‘%Y-%m-%dT%H:%M:%S’)<br/># date previsione<br/>date_prev = []<br/>x_ticks = []<br/>step = 5<br/>data_curr = data_eff<br/>x_current = de<br/>n = int(gp/step)<br/>for i in range(0, n):<br/> date_prev.append(str(data_curr.day) + “/” + str(data_curr.month))<br/> x_ticks.append(x_current)<br/> data_curr = data_curr + timedelta(days=step)<br/> x_current = x_current + step</span></pre><p id="2722" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">现在我们可以画出所有的线。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="946d" class="mj lm iw lk b gz ni nj l nk nl">plt.grid()<br/>plt.scatter(X, y, color=’black’)</span><span id="71f4" class="mj lm iw lk b gz nm nj l nk nl">plt.plot(X_test, y_pred_linear, color=’green’, linewidth=2)<br/>plt.plot(X_test, y_pred_max, color=’red’, linewidth=1, linestyle=’dashed’)<br/>plt.plot(X_test, y_pred_min, color=’red’, linewidth=1, linestyle=’dashed’)</span><span id="ba0a" class="mj lm iw lk b gz nm nj l nk nl">plt.xlabel(‘Days’)<br/>plt.xlim(de,de+gp)</span><span id="7577" class="mj lm iw lk b gz nm nj l nk nl">plt.xticks(x_ticks, date_prev)<br/>plt.ylabel(‘Epidemics Progression Index (EPI)’)<br/>plt.yscale(“log”)</span><span id="817c" class="mj lm iw lk b gz nm nj l nk nl">plt.savefig(“EPI-prediction.png”)<br/>plt.show()</span></pre><figure class="na nb nc nd gu jx gi gj paragraph-image"><div class="gi gj nn"><img src="../Images/3a236b454b532eb3f540943b6c512a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*qrHpQ9S8pGD9Cgm37rtgog.png"/></div></figure><h1 id="fbb5" class="ll lm iw bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">EPI的0值预测</h1><h2 id="9fa9" class="mj lm iw bd ln mk ml dn lr mm mn dp lv ku mo mp lz ky mq mr md lc ms mt mh mu bi translated">预测EPI何时为0，即代表EPI的线何时穿过X轴</h2><p id="3b21" class="pw-post-body-paragraph kj kk iw kl b km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc mz le lf lg ip bi translated">首先，我们计算一个辅助函数，它将数字转换为日期。该功能将视为开始日期<code class="fe lh li lj lk b">data_eff</code>。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="54f2" class="mj lm iw lk b gz ni nj l nk nl">def n_to_date(n):<br/> return data_eff + timedelta(days=n-de)</span></pre><p id="6887" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">现在我们可以计算这条线何时穿过x轴。提醒一下，一条线的方程是y = ax + b，x轴的方程是y = 0。因此，我们必须求解包含这两个方程的系统。结果x = -b/a。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="83b7" class="mj lm iw lk b gz ni nj l nk nl">data_zero = round(- linear_regr.intercept_ / linear_regr.coef_[0])<br/>n_to_date(data_zero)</span></pre><p id="004e" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">前面的计算只对回归定义的直线进行。现在我们还应该计算<code class="fe lh li lj lk b">y_pred_max</code>和<code class="fe lh li lj lk b">y_pred_min</code>的值。我们定义一个辅助函数，叫做<code class="fe lh li lj lk b">build_line()</code>，从两点构建一条线，返回这条线的系数。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="90cf" class="mj lm iw lk b gz ni nj l nk nl">def build_line(x1,y1,x2,y2):<br/> m = float(y2 — y1)/(x2-x1)<br/> q = y1 — (m*x1)<br/> return [m,q]</span></pre><p id="738b" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">现在我们可以计算出<code class="fe lh li lj lk b">y_pred_min</code>和<code class="fe lh li lj lk b">y_pred_max</code>的结束日期。我们将max的零日期近似为获得值的<code class="fe lh li lj lk b">ceil()</code>，将min的零日期近似为获得值的<code class="fe lh li lj lk b">floor()</code>。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="fea7" class="mj lm iw lk b gz ni nj l nk nl">import math<br/>line_max = build_line(X_test[0][0], y_pred_max[0], X_test[1][0], y_pred_max[1])<br/>data_zero_max = math.ceil(- line_max[1] / line_max[0])<br/>n_to_date(data_zero_max)</span><span id="c835" class="mj lm iw lk b gz nm nj l nk nl">line_min = build_line(X_test[0][0], y_pred_min[0], X_test[1][0], y_pred_min[1])<br/>data_zero_min = math.floor(- line_min[1] / line_min[0])<br/>n_to_date(data_zero_min)</span></pre><h1 id="44b9" class="ll lm iw bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">预测一般日期的EPI值</h1><h2 id="ac89" class="mj lm iw bd ln mk ml dn lr mm mn dp lv ku mo mp lz ky mq mr md lc ms mt mh mu bi translated">通过添加代码来计算一般日期的EPI值，从而扩展本教程</h2><p id="2810" class="pw-post-body-paragraph kj kk iw kl b km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc mz le lf lg ip bi translated">我们定义了一个名为<code class="fe lh li lj lk b">date_to_n()</code>的辅助函数，它将一个通用日期转换为自开始日期起的天数。然后，我们将模型应用于获得的值。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="271d" class="mj lm iw lk b gz ni nj l nk nl">def date_to_n(my_date):<br/> initial_date = datetime.strptime(data[‘data’][0], ‘%Y-%m-%dT%H:%M:%S’)<br/> return (my_date — initial_date).days + 1</span><span id="dc91" class="mj lm iw lk b gz nm nj l nk nl">my_date = datetime.strptime(“2020–04–05”, ‘%Y-%m-%d’)<br/>n = date_to_n(my_date)<br/>predict = linear_regr.predict([[n]])</span></pre><h1 id="0760" class="ll lm iw bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">预测感染的最大数量</h1><h2 id="8542" class="mj lm iw bd ln mk ml dn lr mm mn dp lv ku mo mp lz ky mq mr md lc ms mt mh mu bi translated">在EPI的基础上，用逆方程计算感染总数。情节也是结果</h2><p id="9470" class="pw-post-body-paragraph kj kk iw kl b km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc mz le lf lg ip bi translated">现在我们可以建立感染总数的最大值。我们可以利用EPI的公式:<code class="fe lh li lj lk b">y_pred[i] = (tc[i] - tc[i-1])/(tt[i]-tt[i-1])*100</code>来计算<code class="fe lh li lj lk b">tt[i] = y_pred[i]*/(tt[i]-tt[i-1])*100) + tc[i]</code>的值。差值<code class="fe lh li lj lk b">tt[i]-tt[i-1]</code>代表<code class="fe lh li lj lk b">i</code>时刻的拭子数量，因此我们可以将其近似为<code class="fe lh li lj lk b">data['tamponi']</code>的平均值(存储在变量<code class="fe lh li lj lk b">tt_increase</code>中)。或者，我们也可以将差值计算为最小值或最大值。因此，我们计算<code class="fe lh li lj lk b">tt</code>(称为<code class="fe lh li lj lk b">avg_tt</code>)的平均值作为<code class="fe lh li lj lk b">tt_increase[de:]</code>的度量。度量作为函数的参数传递。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="961b" class="mj lm iw lk b gz ni nj l nk nl">def average(mylist):<br/> return sum(mylist)/len(mylist)</span><span id="6129" class="mj lm iw lk b gz nm nj l nk nl"># calculate the plateau considering the average increase of swabs<br/>def plateau(y_pred,data_end,metrics):<br/> avg_tt = metrics(tt_increase[de:])</span><span id="3d0b" class="mj lm iw lk b gz nm nj l nk nl">np_avg = []<br/> #np_start = data[‘totale_casi’][len(data[‘totale_casi’])-1]<br/> np_start = data[‘totale_casi’][de]<br/> np_avg.append(np_start)</span><span id="be43" class="mj lm iw lk b gz nm nj l nk nl">for i in range(0, data_end-de):<br/> np = y_pred[i]*avg_tt/100 + np_avg[i-1]<br/> np_avg.append(np)<br/> <br/> last_value = max(np_avg)<br/> for i in range(0, gp-len(np_avg)):<br/> np_avg.append(last_value)<br/> return np_avg</span></pre><p id="0188" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">现在，我们可以通过将最大值视为度量来计算<code class="fe lh li lj lk b">y_pred_min</code>、<code class="fe lh li lj lk b">y_pred_max</code>和<code class="fe lh li lj lk b">y_pred_linear</code>的平稳状态。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="dec1" class="mj lm iw lk b gz ni nj l nk nl">plateau_min = plateau(y_pred_min,data_zero_min, max)<br/>plateau_max = plateau(y_pred_max,data_zero_max, max)<br/>plateau_avg = plateau(y_pred_linear,int(data_zero), max)</span></pre><p id="1020" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">最后，我们绘制结果并打印最大值。</p><pre class="na nb nc nd gu ne lk nf ng aw nh bi"><span id="22f6" class="mj lm iw lk b gz ni nj l nk nl">plt.plot(X_test,plateau_min, color=’red’, linewidth=1, linestyle=’dashed’)<br/>plt.plot(X_test,plateau_max, color=’red’, linewidth=1, linestyle=’dashed’)<br/>plt.plot(X_test,plateau_avg, color=’green’, linewidth=2)<br/>plt.scatter(X,tc[de+1:], color=’black’, linewidth=2)<br/>plt.xlabel(‘Days’)<br/>plt.xlim(de,de+gp)<br/>#plt.ylim(0,50)<br/>plt.xticks(x_ticks, date_prev)<br/>#plt.yticks([0,20,30,40,50,60])</span><span id="07e4" class="mj lm iw lk b gz nm nj l nk nl">plt.ylabel(‘Total number of positives’)<br/>plt.grid()<br/>plt.show()</span></pre><figure class="na nb nc nd gu jx gi gj paragraph-image"><div class="gi gj nn"><img src="../Images/f2f6e20697e8bf7fdb3d554a6827c33d.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*Nj6CrO-NMiFrf3Cdppewhg.png"/></div></figure><h1 id="7363" class="ll lm iw bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">吸取的教训</h1><p id="2218" class="pw-post-body-paragraph kj kk iw kl b km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc mz le lf lg ip bi translated">本教程描述了一个简单的方法来建立一个预测意大利新冠肺炎流行病的结束。从本教程中，我们了解到:</p><ul class=""><li id="c99a" class="no np iw kl b km kn kq kr ku nq ky nr lc ns lg nt nu nv nw bi translated">在构建预测器之前，必须进行初步的数据探索。事实上，如果我们在所有可用数据上建立预测器(即从2月24日开始)，我们就不会使用线性回归来建立它；</li><li id="10e3" class="no np iw kl b km nx kq ny ku nz ky oa lc ob lg nt nu nv nw bi translated">预测器的建立还应考虑到现实生活(在我们的案例中，是意大利政府引入的限制法及其一周后的效果)；</li><li id="b798" class="no np iw kl b km nx kq ny ku nz ky oa lc ob lg nt nu nv nw bi translated">一旦建立了预测器，也应该考虑误差。因此，必须计算误差范围，以便有更准确的预测；</li><li id="2481" class="no np iw kl b km nx kq ny ku nz ky oa lc ob lg nt nu nv nw bi translated">真实(新)数据和预测值之间的比较总是受欢迎的，因为它允许您验证模型是否正确。</li></ul></div><div class="ab cl oc od ia oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ip iq ir is it"><p id="32ef" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated"><strong class="kl ix"> <em class="oj">编者按:</em> </strong> <em class="oj"> </em> <a class="ae ki" href="http://towardsdatascience.com/" rel="noopener" target="_blank"> <em class="oj">走向数据科学</em> </a> <em class="oj">是一份以数据科学和机器学习研究为主的中型刊物。我们不是健康专家或流行病学家，本文的观点不应被解释为专业建议。想了解更多关于疫情冠状病毒的信息，可以点击</em> <a class="ae ki" href="https://www.who.int/emergencies/diseases/novel-coronavirus-2019/situation-reports" rel="noopener ugc nofollow" target="_blank"> <em class="oj">这里</em> </a> <em class="oj">。</em></p></div></div>    
</body>
</html>