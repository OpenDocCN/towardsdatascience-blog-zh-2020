<html>
<head>
<title>What format should I store my ECG data in for DL training?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对于 DL 训练，我应该以什么格式存储我的 ECG 数据？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-format-should-i-store-my-ecg-data-in-for-dl-training-bc808eb64981?source=collection_archive---------35-----------------------#2020-02-14">https://towardsdatascience.com/what-format-should-i-store-my-ecg-data-in-for-dl-training-bc808eb64981?source=collection_archive---------35-----------------------#2020-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="47bc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">优化心电图数据布局提升深度学习训练性能的案例研究。</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/5bcae6d2c515b98bda205a8dc5c10c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B4J6JHrEa5ucuF-6"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@nci?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">国立癌症研究所</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4e69" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">从历史上看，我们保存数据是为了<em class="lw">我们</em>可以读取它。现在，随着数据科学的快速发展，机器正在读取我们的数据。我们正在从人类访问小数据转变为深度学习脚本重复访问大量数据。</p><p id="8670" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是将患者的 x 射线加载到监视器上进行视觉评估与通过神经网络运行 x 射线 1000 次之间的区别，神经网络将原始图像转换为向量，裁剪它，旋转它，模糊它，然后尝试识别气胸。</p><p id="8829" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这就是为什么我们看到 GPU 越来越多地用于深度学习——我们需要对我们的数据执行越来越多的数学运算。GPU 中的计算元素专为大规模数据并行数学运算而设计，这些运算是现代图形管道的基础。事实证明，深度学习工作流程背后的数学。</p><h1 id="f6e3" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">但是没有[数据→ GPU]那么简单</h1><p id="b747" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">虽然 GPU 执行深度学习的复杂数学，但每个训练工作都是一个管道，在 GPU 工作之前有一些步骤。</p><p id="1a92" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在训练中，在数据进入神经网络之前，它在一系列操作中得到预处理<strong class="lc iu">。预处理通常包括一系列任务:索引(列出)训练数据集中的项目，对它们进行洗牌，从存储中实际加载它们，然后执行变形。预处理通常发生在 CPU 上(通常发生在 GPU 服务器中的 CPU 上)。</strong></p><p id="2880" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，数据必须通过 CPU 从存储位置转移到 GPU 进行计算。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/2da69e6ef06d9ef4711de7e702695dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*luC9WQUx7z6Sqf2aXUuwNQ.png"/></div></figure><p id="63e1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">数据负载本身通常是训练管道最大吞吐量瓶颈的原因。</strong></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mv"><img src="../Images/98bfd2cf76ca834fa16f9528abe4a26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIbM7nLBxccBAF3Y40rPzw.png"/></div></div></figure><p id="509a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你正在加载一个病人的 x 光片给<em class="lw">看</em>，你可能会发现 0.04 秒的数据加载时间是可以接受的。您几乎不会注意到延迟，因为您的“回顾”时间可能有几分钟长。</p><p id="5c14" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">另一方面，一个只需要 0.001 秒来“检查”图像的 GPU 服务器会因为 0.04 秒的数据加载时间而变慢。和延迟化合物。对于包含不是一个项目而是数千个或数百万个项目的大规模训练数据集和迭代计算(例如，单个作业中的 20 个历元)，数据加载延迟会发生<em class="lw">很多次</em>。</p><p id="1e2f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">不管你的 GPU 有多快，你的训练工作只能和你的数据加载时间一样快。</strong></p><p id="8e13" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，确保数据加载高效会带来巨大的性能优势。</p><p id="0a53" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这篇文章描述了我们与 Geisinger 的成像科学和创新部门的项目，以优化心电图结果数据集的训练吞吐量。我们为优化测试生成了一个数据大小和类型匹配的模拟数据集。</p><h1 id="c8db" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">首先，确定性能基线</h1><p id="3efe" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">开始 DL 性能调查的一个好地方是检查数据加载工作持续时间和培训工作持续时间之间的比率。</p><p id="9293" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在我们运行这个基本任务分解之后，我们发现数据加载时间明显大于训练时间。这是非常低效的，因为在列车:负载比为 1:4 的情况下，<strong class="lc iu">我们的 GPU 在作业持续时间</strong>内处于空闲状态。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/7639cfda51697bbc4910b5da4d208759.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*M73aM9EqtE6QQ00pr3stOA.png"/></div></figure><p id="8ab4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在我们等待下一批加载时，每一批都有 75%的 GPU 时间处于空闲状态。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mx"><img src="../Images/8502444ecb39878215d588948f2393a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fz2TKc6rsIkqJ3H5TGKYIw.png"/></div></div></figure><p id="e269" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">我们需要更快地加载数据。</strong></p><h1 id="c287" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">为什么文件加载很慢？</h1><p id="323f" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">我们的合成训练数据代表来自 15 导联 ECG 测试的日志:15x 5GB HDF5 文件，每个文件包含 1，000，000 条记录(患者)。每个文件代表一个 ECG 通道，其中“patient_id”是关键字，该通道的结果是其记录。</p><p id="8b58" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们将 HDF5 视为键值存储，但该文件格式实际上是为了支持更复杂的数据结构而设计的。HDF ( <a class="ae kz" href="https://en.wikipedia.org/wiki/Hierarchical_Data_Format" rel="noopener ugc nofollow" target="_blank">分层数据格式</a>)非常适合存储包含大量元数据的大型数值数据集。它支持文件内的分组，有效地使 HDF 文件成为可移植的文件系统。HDF 主要用于 HPC 用例中的科学数据集。</p><p id="ab57" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然而，该功能的一个缺点是，每次读取 HDF5 文件都会产生大量开销。</p><p id="9c5c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以使用<a class="ae kz" href="https://strace.io/" rel="noopener ugc nofollow" target="_blank"> strace </a>来窥探在我们发出单个 read(通过<a class="ae kz" href="https://www.h5py.org/" rel="noopener ugc nofollow" target="_blank"> h5py </a> python 库发出)时发生的系统调用。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2ba5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">“lseek”用于将文件指针移动到文件中的特定位置，然后“read”用于实际读取数据。最后一行是一个 4992 字节的读取，以检索组成我们的 HDF5 文件的键值对中的一个值。前 5 次读取是对文件内的元数据(指针)的读取，这些元数据是定位所需数据所必需的。</p><p id="5db4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为什么会有这么多元数据读取？因为<a class="ae kz" href="https://support.hdfgroup.org/HDF5/doc/H5.format.html#Btrees" rel="noopener ugc nofollow" target="_blank"> HDF 使用</a> a <a class="ae kz" href="https://www.geeksforgeeks.org/introduction-of-b-tree-2/" rel="noopener ugc nofollow" target="_blank"> B 树</a>结构来帮助提高其类似文件系统的元数据查询的性能。就像在文件系统上一样，知道在哪里寻找数据可能比将数据移动到 CPU 中更困难。</p><p id="4997" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在看到 HDF 读取需要多少冗余系统调用后，我们确信有一种更具读取性能的方法来保存我们过于简单的数据集。我们并没有真正使用赋予 HDF 名字的层级功能。</p><h1 id="3258" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">最优会是什么样子？</h1><p id="5f1d" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">作为一个思想实验，我们从一个问题开始，“文件中键值数据的最佳布局是什么，以获得最大的读取吞吐量？”</p><p id="620a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们在解决什么？</p><p id="0c20" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> 1。我们不需要保存复杂的元数据</strong></p><p id="6564" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们用于记录的唯一描述性信息是密钥。</p><p id="0385" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们远离 HDF 中我们没有使用的功能。</p><p id="8ff6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> 2。快速读取单个记录和收集密钥列表</strong></p><p id="1fc3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">正如在培训工作中常见的那样，我们的脚本从打乱数据集开始。必须先枚举数据集的内容，然后才能洗牌。由于这个枚举步骤发生在每个作业的开始，我们不想通过缓慢的键收集(我们在 HDF5 中见过)来建立前端延迟。</p><p id="c632" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> 3。IO 越大越好</strong></p><p id="4000" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们更喜欢从远程存储上保存的数据集进行训练。为什么？首先，数据管理更简单，我们不必提前花费时间将数据集复制到本地设备。第二，我们的数据集太大，无法完全放入本地内存，所以如果我们从本地存储位置进行训练，我们必须管理一些数据分片过程。</p><p id="c417" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，由于我们将发出必须通过网络到达存储的读取，我们也可以通过增大读取大小来优化网络往返成本。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="7481" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们首先将所有 15 个心电图导联的数据合并成一个记录。这一变化既简化了我们的数据集，又有助于增加 IO 大小；现在，读取单个患者的心电图结果可以通过网络在 1 次旅行中收集，而不是 15 次。</p><p id="f29b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">每个记录包含来自所有 15 个 ECG 导联的数据阵列:</p><p id="1b9c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">[[第一频道]，…，[第十五频道] ]</p><p id="0d7e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以简单地通过其在数组中的位置将单个结果与其来自的 ECG 导联编号相关联。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/e11d3bb5d2de3f0189ec84ca8d3d9214.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*jx_a5nBm6QPwyDbr1sJZCg.png"/></div></figure><p id="379d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">键块包含每个记录的[key_id，value_location]。现在我们可以直接跳到文件中特定记录的数据。</p><p id="da6c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们在文件末尾存储了一个包含所有密钥的数组。打开文件后，我们会读取一个文件头，其中包含文件配置信息，如模式规范，最重要的是文件中关键块的位置。密钥加载效率极高，因为我们可以直接跳到密钥块的起始位置，然后一次性读取所有密钥。</p><p id="c47c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在 HDF5 文件中，密钥随机分布在整个文件中。在我们的新文件格式中拥有连续的键允许对键块进行大量的顺序读取，从而最小化网络开销。</p><h1 id="3797" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">30 倍的解决方案</h1><p id="7d23" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">由此产生的文件格式，我们将其命名为“Fleet”并在 GitHub 上提供，<strong class="lc iu">为我们的工作负载提供了比 HDF5 </strong>高 30 倍的读取吞吐量。更好的是，我们的火车:负载比现在超过了 1:1(对于远程存储和本地存储)。我们可以在 NFS 利用我们的心电图数据进行有效的训练。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/3fbffd2341562b7fc349e5707212eb2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*1aDd9avyqcj43Pmd0HoiQQ.png"/></div></figure><p id="866c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们认为这样一种轻量级的文件格式最适合用于深度学习训练的大型数值数据集。如果需要分组，可以创建附加的车队文件来代表每个组。</p><p id="75b5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Fleet 是一种开源文件格式。你可以在<a class="ae kz" href="https://github.com/PureStorage-OpenConnect/fleet-format/" rel="noopener ugc nofollow" target="_blank">舰队 GitHub 页面</a>上找到代码和几个助手脚本。</p><h1 id="f79e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">我们学到了什么</h1><p id="5d0f" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">虽然使用 JPEG 图像或张量记录的训练脚本已经在人工智能生态系统中进行了广泛的测试和调整，但其他文件格式的训练可能需要一些性能分析，以优化整体作业吞吐量。</p><p id="3980" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有时，训练数据集的格式可能会引入读取模式或计算需求，从而降低整体训练工作的速度。在这种情况下，我们通过切换到轻量级、读取优化的文件格式来优化训练性能。</p><p id="9bf2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">随着我们继续将深度学习方法应用于更广泛的用例和数据集，我们应该继续问自己，“如果我们解决了最佳训练吞吐量，我们的数据会是什么样的？”</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="d913" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这项研究是我的同事 Brian Gold 在 Pure Storage 和 Geisinger 的成像科学和创新部门共同开展的项目。特别感谢 David Vanmaanen、Sush Raghunath 和 Alvaro Ulloa Cerna。</p></div></div>    
</body>
</html>