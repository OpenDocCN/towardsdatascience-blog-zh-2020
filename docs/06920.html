<html>
<head>
<title>Clustering: chess openings classifier (Part I)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聚类:国际象棋开局分类器(第一部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/clustering-chess-openings-classifier-part-i-6299fbc9c291?source=collection_archive---------71-----------------------#2020-05-28">https://towardsdatascience.com/clustering-chess-openings-classifier-part-i-6299fbc9c291?source=collection_archive---------71-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="cb57" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">聚类方法</h2><div class=""/><div class=""><h2 id="09ba" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">第一部分:下载象棋游戏数据集</h2></div><p id="c5a1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在我的库中有完整的代码<a class="ae ln" href="https://github.com/arditoibryan/Projects/blob/master/20200526_Chess_Openings_Classifier/Chess_Downloader.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0922" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">聚类使我们能够在数据样本中发现模式。聚类应用有很多，我们选择的算法取决于我们需要解决的问题类型。在这个系列中，我将解释如何在成千上万的样本(象棋比赛)中找到最受专业人士欢迎的空缺。</p><h2 id="e2d7" class="lo lp it bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf iz bi translated">为什么要下象棋？</h2><p id="707b" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">对于初级分析师来说，最令人兴奋的事情之一就是处理任何类型的数据。为什么不处理象棋比赛数据？这些数据是开源的，可以很容易地大量找到，并且可以从多个来源获得。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/05db634e9ffea7ace9ec3ba047e2c614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-chvHCZs9239NSAM"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">由<a class="ae ln" href="https://unsplash.com/@felix_mittermeier?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菲利克斯·米特迈尔</a>在<a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="5d18" class="nb lp it bd lq nc nd ne lt nf ng nh lw ki ni kj lz kl nj km mc ko nk kp mf nl bi translated">什么是棋局开局？</h1><p id="bb64" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">在国际象棋理论中，比赛的初始阶段已经被研究和概念化了。冠军被用来研究以开局开始的游戏发展，而不是即兴发挥:大师们已经给数千个预定义的国际象棋游戏序列命名。职业棋手研究这些序列，以获得对敌人的竞争优势。</p><h1 id="cffd" class="nb lp it bd lq nc nd ne lt nf ng nh lw ki ni kj lz kl nj km mc ko nk kp mf nl bi translated">lichess.org</h1><p id="48f4" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">玩家玩免费象棋和提高技术的最好网站之一叫做lichess.org。这个网站允许开发者免费下载他们想要的所有数据，只有很小的数据流限制。</p><p id="099d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我通过标签找到了<a class="ae ln" href="https://lichess.org/player" rel="noopener ugc nofollow" target="_blank">lichess.org排名前50的玩家，并将他们的名字保存到一个python列表中。这是我开始从服务器下载数据所需的少数信息之一。在本教程中，我将简单地使用3个姓名标签，但是在我的代码中(</a><a class="ae ln" href="https://github.com/arditoibryan/Projects/blob/master/20200526_Chess_Openings_Classifier/Chess_Downloader.ipynb" rel="noopener ugc nofollow" target="_blank">在我的库</a>中)你会找到所有50个顶级棋手的姓名标签。</p><h1 id="baf0" class="nb lp it bd lq nc nd ne lt nf ng nh lw ki ni kj lz kl nj km mc ko nk kp mf nl bi translated">存储变量</h1><p id="8baf" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">我将开始设置主要变量，这些变量将通过我们的算法存储所有主要信息。</p><pre class="mm mn mo mp gt nm nn no np aw nq bi"><span id="92dd" class="lo lp it nn b gy nr ns l nt nu">#list of nametages<br/>player_list = ['Konevlad','Liem_Chess','Azzaro25']</span><span id="3294" class="lo lp it nn b gy nv ns l nt nu">#list of nametags that have been downloading successfully<br/>player_completed = list()</span><span id="713c" class="lo lp it nn b gy nv ns l nt nu">#all the downloaded matches<br/>game_dataset = list()</span></pre><p id="e62d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当我们运行我们的算法时，如果查询成功，player_completed和game_dataset将填充我们可以导出的信息。</p><h1 id="1f24" class="nb lp it bd lq nc nd ne lt nf ng nh lw ki ni kj lz kl nj km mc ko nk kp mf nl bi translated">下载功能</h1><p id="d31b" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">现在我需要创建一个可以执行单个请求的函数。因为要下载信息，我需要访问一个特定的链接，所以我将使用一个函数来创建允许我执行GET请求的正确字符串。我将多次运行这个函数，这样我将为我列表中的每个玩家创建一个链接，并且我将一次为每个玩家下载200个游戏。</p><pre class="mm mn mo mp gt nm nn no np aw nq bi"><span id="cf72" class="lo lp it nn b gy nr ns l nt nu">import requests<br/>import time<br/>#get request of single user<br/>def get_request(user):<br/>  print('trying ' + user)<br/>  if user in player_completed:<br/>    print('already existing')<br/>    return 0<br/>  else:<br/>    print(user)<br/>    response = requests.get('<a class="ae ln" href="https://lichess.org/api/games/user/'" rel="noopener ugc nofollow" target="_blank">https://lichess.org/api/games/user/'</a> + user, params={'max':200, 'pgnInJson':False})<br/>    return response</span></pre><p id="c227" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">不幸的是，数据是ndjson格式的。由于一个错误，我无法用任何已知的库来解码它:我需要即兴创作一个算法，可以提取每一个游戏并将其添加到一个列表中。</p><pre class="mm mn mo mp gt nm nn no np aw nq bi"><span id="7a08" class="lo lp it nn b gy nr ns l nt nu">#conversion one user response to all games returned as a list<br/>def games_to_list(response):<br/>  a = str(response.content)</span><span id="cc0f" class="lo lp it nn b gy nv ns l nt nu">lines = a.split("\\n");</span><span id="fd86" class="lo lp it nn b gy nv ns l nt nu">game_list = list()<br/>  for r in lines:<br/>    if "[" in r:<br/>      pass<br/>    else:<br/>      if r == '':<br/>        pass<br/>      else:<br/>        game_list.append(r)<br/>  game_list.remove("'")<br/>  return game_list</span></pre><h1 id="6dd9" class="nb lp it bd lq nc nd ne lt nf ng nh lw ki ni kj lz kl nj km mc ko nk kp mf nl bi translated">开始下载</h1><p id="6e60" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">现在是运行算法的时候了。像往常一样，我们不能过分强调在线数据库，否则，它们可能会让我们在几分钟内无法进行查询。如果每次出现问题时我们都必须手动重启下载算法，那么使用我们的浏览器手动下载这些数据会更舒服(这是我们想要避免的)。</p><pre class="mm mn mo mp gt nm nn no np aw nq bi"><span id="85a0" class="lo lp it nn b gy nr ns l nt nu">#for each player download a single request<br/>for _ in player_list:</span><span id="5712" class="lo lp it nn b gy nv ns l nt nu">response = get_request(_)<br/>  time.sleep(140)<br/>  if response == 0:<br/>    pass<br/>  else:<br/>    player_completed.append(_)<br/>    #download games into a list<br/>    game_list = games_to_list(response)<br/>    #add all games of a user to the final list: game_dataset<br/>    for _ in game_list:<br/>      game_dataset.append(_)</span></pre><p id="9974" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了解决这个问题，我将尝试每隔140秒向数据库发送一次查询(GET请求)。</p><p id="7e09" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">* * *如果我们不是第一次运行该算法，并且一些匹配(但不是标签列表中的所有匹配)已经存储在我们的变量中(换句话说，我们之前的尝试已经部分完成)，我添加了一个解决方法。该函数将发现它正在尝试下载列表中已经存在的标签:它将返回0作为输出，算法将传递它作为避免进行相同查询的措施。您可以为错误添加退出案例，以使其更加平滑。</p><h2 id="92cf" class="lo lp it bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf iz bi translated">输出</h2><p id="0296" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">正如我们所看到的，在为每个请求运行并等待必要的时间之后，算法应该输出每个请求的状态。</p><pre class="mm mn mo mp gt nm nn no np aw nq bi"><span id="fcce" class="lo lp it nn b gy nr ns l nt nu">trying Konevlad <br/>Konevlad <br/>trying Liem_Chess <br/>Liem_Chess <br/>trying Azzaro25 <br/>Azzaro25</span></pre><p id="bde0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我已经将成功下载的标签存储在一个特定的列表中。</p><pre class="mm mn mo mp gt nm nn no np aw nq bi"><span id="6941" class="lo lp it nn b gy nr ns l nt nu">player_completed<br/>['Konevlad', 'Liem_Chess', 'Azzaro25']</span></pre><p id="6c0c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所有匹配都存储在一个名为final_dataset的数据帧中。</p><pre class="mm mn mo mp gt nm nn no np aw nq bi"><span id="9a59" class="lo lp it nn b gy nr ns l nt nu">import pandas as pd<br/>game_dataset = pd.DataFrame(game_dataset)<br/>final_dataset = game_dataset.copy()<br/>final_dataset</span></pre><h1 id="cf86" class="nb lp it bd lq nc nd ne lt nf ng nh lw ki ni kj lz kl nj km mc ko nk kp mf nl bi translated">解决异常</h1><p id="45b6" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">要提取比赛中的每一步棋，每一行都必须是相同的格式。每一行(至少表面上)都有以下模式:</p><pre class="mm mn mo mp gt nm nn no np aw nq bi"><span id="1881" class="lo lp it nn b gy nr ns l nt nu">1. c4 c5 2. Nc3 g6 3. g3 Bg7 4. Bg2 e6...</span></pre><p id="dad3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但是，我需要检查有问题的行，这些行可能会在我们的数据分析中产生错误。因此，我将向所有不以1开头的行发送信号。</p><p id="7556" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">* * *这似乎是一种非常近似的发现异常的方法，但是在用聚类算法测试数据集之后，结果证明这已经足够了</p><pre class="mm mn mo mp gt nm nn no np aw nq bi"><span id="1da3" class="lo lp it nn b gy nr ns l nt nu">#non valid rows<br/>for _ in range(len(final_dataset.values)):<br/>  if final_dataset.values[_][0][0] != '1':<br/>    print(_)<br/>106 <br/>107</span></pre><p id="6e25" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">行106和107没有相同的模式，让我们更仔细地看看:</p><pre class="mm mn mo mp gt nm nn no np aw nq bi"><span id="0fbd" class="lo lp it nn b gy nr ns l nt nu">final_dataset[105:110]</span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/8cec5df691cdb29e9a7cf0925d6ec8b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*hSqWNhJFi0mAbvigZsEuAw.png"/></div></figure><p id="f3b8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因为行106和107有异常，我们将删除它们。如果您要下载成千上万的匹配，包含异常的行可能会更多。</p><pre class="mm mn mo mp gt nm nn no np aw nq bi"><span id="e2fb" class="lo lp it nn b gy nr ns l nt nu">#drop non valid rows<br/>final_dataset = final_dataset.drop([106, 107], axis=0)</span></pre><h1 id="6951" class="nb lp it bd lq nc nd ne lt nf ng nh lw ki ni kj lz kl nj km mc ko nk kp mf nl bi translated">导出数据帧</h1><p id="21cf" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">我们准备好导出数据集以用于分析目的:</p><pre class="mm mn mo mp gt nm nn no np aw nq bi"><span id="a875" class="lo lp it nn b gy nr ns l nt nu">#export dataset<br/>final_dataset.to_csv('chess.csv')</span></pre><p id="7cfb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae ln" rel="noopener" target="_blank" href="/clustering-chess-openings-classifier-part-ii-7a4f0ce9dcc9?source=post_stats_page---------------------------"> - &gt;进行第二部分</a></p></div></div>    
</body>
</html>