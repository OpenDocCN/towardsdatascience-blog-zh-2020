<html>
<head>
<title>Plotnine plot deconstruction: visualizing the Billboard Hot 100 using a rank plot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Plotnine 情节解构:使用等级情节可视化公告牌 100 大热门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/plotnine-plot-deconstruction-visualizing-the-billboard-hot-100-8048808fd629?source=collection_archive---------34-----------------------#2020-02-17">https://towardsdatascience.com/plotnine-plot-deconstruction-visualizing-the-billboard-hot-100-8048808fd629?source=collection_archive---------34-----------------------#2020-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="72d3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用 Python、Pandas 和 Plotnine 高效地可视化较长时间范围内的等级</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><p id="7f5a" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><em class="li">这是我写的一系列文章</em><a class="ae lj" href="https://towardsdatascience.com/tagged/plot-deconstruction-paul" rel="noopener" target="_blank"><em class="li"/></a><em class="li">中关于用 Python 制作朱朱情节的一部分。</em></p><h1 id="62ec" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">介绍</h1><p id="e38c" class="pw-post-body-paragraph km kn iq ko b kp mc jr kr ks md ju ku kv me kx ky kz mf lb lc ld mg lf lg lh ij bi translated">就我而言，ggplot2 是最好的绘图软件。所以当我发现有一个针对 Python 的图形语法的实现时，我抓住了这个机会。ggplot2 buffs 过渡到 plotnine 应该没问题，语法很像。</p><p id="8112" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">图形语法的优势在于对情节推理的一致性。这种一致性使得将情节想法表达成代码变得容易。与<a class="ae lj" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Seaborn </a>尤其是<a class="ae lj" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>相比，plotnine 更容易使用。然而，习惯 plotnine 的语法和思维方式确实需要一点时间，尤其是在标准散点图和条形图之外的时候。</p><p id="2f24" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">本文的目标不是提供 plotnine 教程，而是探索更高级的 plotnine 概念。如果你需要的话，这篇文章的确提供了很好的介绍。这些是我将在本文中讨论的主题:</p><ul class=""><li id="b1d5" class="mh mi iq ko b kp kq ks kt kv mj kz mk ld ml lh mm mn mo mp bi translated">数据的智能选择</li><li id="b378" class="mh mi iq ko b kp mq ks mr kv ms kz mt ld mu lh mm mn mo mp bi translated">对绘图中的不同图层使用不同的数据源</li><li id="3103" class="mh mi iq ko b kp mq ks mr kv ms kz mt ld mu lh mm mn mo mp bi translated">巧妙重新排列文本标签以避免标签重叠</li><li id="5a85" class="mh mi iq ko b kp mq ks mr kv ms kz mt ld mu lh mm mn mo mp bi translated">使用刻面技术水平堆叠时间序列数据</li></ul><p id="3c3f" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这篇文章的核心是以下情节:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/079bf7e901a8df7d4bc38168f0bce261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RwDdEwLqntU2iG3lK5kHww.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">2015 年公告牌 100 首热门歌曲中的前 15 首</p></figure><p id="bacc" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">该图显示了一首歌曲的图表位置(y 轴)在整个 2015 年的 Billboard Hot 100 轴)中如何变化。一条彩色线代表歌曲的轨迹，歌曲的标题由文本标签给出。红色箭头有助于识别哪个标题属于哪个行。解读剧情的最佳方式是挑选一首特定的歌曲，沿着彩色的线去探索它在一年中的轨迹是如何演变的。我从一本关于制作情节的教科书中获得了这个情节的想法，尽管我忘了是哪一本。在网上我可以找到类似的图<a class="ae lj" href="http://virginian.mdodd.com/string_diag.html" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae lj" href="https://stats.stackexchange.com/a/178344/7419" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="58e1" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在文章的其余部分，我将分解这个情节是如何构建的，以及我做出了哪些选择以及为什么做出这些选择。我假设您熟悉 ggplot2 或 plotnine、Python 和 Pandas 的语法基础。完整的 Python 笔记本可以在<a class="ae lj" href="https://gist.github.com/PaulHiemstra/2130dd9d8a5a297e6eef6cb9eadac212" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h1 id="65c0" class="lk ll iq bd lm ln nl lp lq lr nm lt lu jw nn jx lw jz no ka ly kc np kd ma mb bi translated">情节的分解</h1><p id="f791" class="pw-post-body-paragraph km kn iq ko b kp mc jr kr ks md ju ku kv me kx ky kz mf lb lc ld mg lf lg lh ij bi translated">为了生成该图，我使用了 Billboard top 100 的以下<a class="ae lj" href="https://data.world/kcmillersean/billboard-hot-100-1958-2017" rel="noopener ugc nofollow" target="_blank">数据集:</a></p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e8c5" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">它包含以下列:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ns"><img src="../Images/a5de76e08e79e915e5428495d5d8f59d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pZzqmKPEF4CgCSn1LCW9Q.png"/></div></div></figure><p id="9878" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">数据集中的每一行都是某首歌曲在特定一周的排行榜位置。与特定歌曲相关的所有行代表该歌曲的轨迹。我们的图的重要列是:</p><ul class=""><li id="283f" class="mh mi iq ko b kp kq ks kt kv mj kz mk ld ml lh mm mn mo mp bi translated">WeekID，每周图表位置的时间戳</li><li id="189a" class="mh mi iq ko b kp mq ks mr kv ms kz mt ld mu lh mm mn mo mp bi translated">周位置，实际图表位置</li><li id="4e6a" class="mh mi iq ko b kp mq ks mr kv ms kz mt ld mu lh mm mn mo mp bi translated">宋，宋的名字</li></ul><p id="6e81" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">以下代码获取这些数据，执行一些预处理并生成绘图:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/079bf7e901a8df7d4bc38168f0bce261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RwDdEwLqntU2iG3lK5kHww.png"/></div></div></figure><h2 id="1c18" class="nt ll iq bd lm nu nv dn lq nw nx dp lu kv ny nz lw kz oa ob ly ld oc od ma oe bi translated">智能数据选择</h2><p id="cd6d" class="pw-post-body-paragraph km kn iq ko b kp mc jr kr ks md ju ku kv me kx ky kz mf lb lc ld mg lf lg lh ij bi translated">在代码的第一部分(第 4-10 行),我对绘图数据进行了预处理。这里我做了两个重要的选择:</p><ul class=""><li id="9f08" class="mh mi iq ko b kp kq ks kt kv mj kz mk ld ml lh mm mn mo mp bi translated">我只使用前 100 名中前 15 名的数据</li><li id="e432" class="mh mi iq ko b kp mq ks mr kv ms kz mt ld mu lh mm mn mo mp bi translated">我会丢弃那些只在数据中出现了 4 周或更短时间的歌曲</li></ul><p id="9d35" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">通过从数据中删除不太重要的歌曲，我们减少了混乱，让我们更容易专注于 2015 年的最佳歌曲。</p><p id="3b5d" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为了丢弃这些罕见的歌曲，我首先计算一首歌曲在数据中出现的频率:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="58a6" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这是使用<code class="fe of og oh oi b">groupby </code>和<code class="fe of og oh oi b">count</code>的组合来完成的，两者都是熊猫函数。计算完计数后，我选择出现次数超过 4 次的歌曲(第 2 行),并使用这些歌曲作为热门 100 首歌曲的子集。</p><h2 id="f23d" class="nt ll iq bd lm nu nv dn lq nw nx dp lu kv ny nz lw kz oa ob ly ld oc od ma oe bi translated">使用不同的数据源</h2><p id="28ac" class="pw-post-body-paragraph km kn iq ko b kp mc jr kr ks md ju ku kv me kx ky kz mf lb lc ld mg lf lg lh ij bi translated">在我们的情节中，一首歌的标题只显示一次，而不是像<code class="fe of og oh oi b">geom_text</code>默认的那样显示在数据集中的每个点上。为了达到这个效果，我们需要为<code class="fe of og oh oi b">geom_text</code>使用一个单独的数据源。</p><p id="e997" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我选择了一首歌在排行榜上的最高位置来放置歌名。我使用以下代码构建了数据:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f916" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在自定义函数 highest_rank 中，我选择了<code class="fe of og oh oi b">Week Position</code>中最小值的索引。注意，最小值是最高等级。接下来，我选择最高等级的<code class="fe of og oh oi b">Week ID</code>和<code class="fe of og oh oi b">Week Position</code>并返回它们。注意，我们不能简单地使用<code class="fe of og oh oi b">groupby</code>和<code class="fe of og oh oi b">min </code> ( <code class="fe of og oh oi b">plot_data.groupby([‘Song’]).min()</code>)，我们需要属于最高图表位置的<code class="fe of og oh oi b">Week ID</code>和<code class="fe of og oh oi b">Week Position </code>在正确的位置绘制文本标签。最后，我们将函数应用于每首歌曲的数据。现在我们有了数据，我们只需要改变<code class="fe of og oh oi b">geom_text</code>的数据源，每首歌只打印一次标签。</p><p id="a618" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">每个 geom 图层使用不同的数据源是一个强大的技巧。例如，通过这种方式，您还可以仅通过提供引用这些面的数据，仅在绘图中所有面的子集内绘制一些几何图形。</p><h2 id="8033" class="nt ll iq bd lm nu nv dn lq nw nx dp lu kv ny nz lw kz oa ob ly ld oc od ma oe bi translated">智能地重新排列文本标签</h2><p id="1f55" class="pw-post-body-paragraph km kn iq ko b kp mc jr kr ks md ju ku kv me kx ky kz mf lb lc ld mg lf lg lh ij bi translated">通过减小文本标签的字体大小和限制标签的数量，我们已经消除了文本标签中的许多潜在重叠。但这种情况仍有可能发生。为了完全消除这种重叠，我使用了<code class="fe of og oh oi b">geom_text</code>的<code class="fe of og oh oi b">adjust_text</code>参数。这使用<code class="fe of og oh oi b"><a class="ae lj" href="https://github.com/Phlya/adjustText" rel="noopener ugc nofollow" target="_blank">adjustText</a></code> <a class="ae lj" href="https://github.com/Phlya/adjustText" rel="noopener ugc nofollow" target="_blank">包</a>智能计算标签的位置。以下代码设置了一些参数，并将其传递给<code class="fe of og oh oi b">geom_text</code>:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f618" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe of og oh oi b">expand_text</code>控制标签在 x 和 y 方向可以移动的距离，而<code class="fe of og oh oi b">arrowprops</code>控制从标签到其所属点的箭头外观。</p><h2 id="7a37" class="nt ll iq bd lm nu nv dn lq nw nx dp lu kv ny nz lw kz oa ob ly ld oc od ma oe bi translated">时间序列的堆叠</h2><p id="06d2" class="pw-post-body-paragraph km kn iq ko b kp mc jr kr ks md ju ku kv me kx ky kz mf lb lc ld mg lf lg lh ij bi translated">到目前为止，我们只处理了一年的数据。要将其扩展到多年，我们可以使用<code class="fe of og oh oi b">facet_wrap</code>将这些图堆叠起来:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/e96574e057ddde2769fb4d6525232470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvlU2tCllRjBBMLLFjoD8g.png"/></div></div></figure><p id="71e3" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这种方法相对于简单地绘制多个单独的图的优势在于，可以保证颜色在多年内保持不变。上面的图是使用以下代码生成的:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="57e8" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">前面代码中需要进行的更改用注释标记。这些变化是:</p><ul class=""><li id="1476" class="mh mi iq ko b kp kq ks kt kv mj kz mk ld ml lh mm mn mo mp bi translated">显然<em class="li">，选择多个年份的数据。</em></li><li id="9907" class="mh mi iq ko b kp mq ks mr kv ms kz mt ld mu lh mm mn mo mp bi translated"><em class="li">使用年份变量</em>扩展数据，在为标签生成最高等级时，也不要忘记包括年份。请注意，在<code class="fe of og oh oi b">groupby </code>中包含“年份”可确保标签在每年的最高级别<em class="li">绘制。这对跨越多年的歌曲很有帮助。</em></li><li id="e7cb" class="mh mi iq ko b kp mq ks mr kv ms kz mt ld mu lh mm mn mo mp bi translated"><em class="li">跨年度变量</em>facet _ wrap。记住使用<code class="fe of og oh oi b">scales=’free_x’</code>专门绘制每个方面的时标。</li></ul><p id="4317" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我很喜欢 plotnine 允许我用代码表达我的可视化想法的方式。尤其令人高兴的是，表现力扩展到了 plotnine 最复杂的部分。希望你学会了几个新招！</p></div></div>    
</body>
</html>