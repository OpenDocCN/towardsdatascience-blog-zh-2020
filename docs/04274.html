<html>
<head>
<title>How to Query Your Time Series Data More Efficiently Using Arctic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Arctic 更有效地查询时间序列数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-query-your-time-series-more-efficiently-using-arctic-40cb1c7b2680?source=collection_archive---------14-----------------------#2020-04-18">https://towardsdatascience.com/how-to-query-your-time-series-more-efficiently-using-arctic-40cb1c7b2680?source=collection_archive---------14-----------------------#2020-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b96e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">加快 Python 时序数据处理脚本的速度</h2></div><p id="d763" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有没有想过在处理大型时间序列数据集时，如何提高数据分析过程的时间效率？<a class="ae le" href="https://github.com/man-group/arctic" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">北极</strong> </a> <strong class="kk iu">也许就是你要找的。</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/41807dd5a5f9a1cda0610261b189e3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LD_17gFcBKy5SfOkApb3dw.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">史蒂文·勒勒姆在<a class="ae le" href="https://unsplash.com/s/photos/speed-track?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5036" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Arctic 是一个为 Python 设计的数据库，目的只有一个:<strong class="kk iu">性能</strong>。使用<a class="ae le" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> Mongo DB </a>作为底层数据库，高效存储数据，使用<a class="ae le" href="https://github.com/lz4/lz4" rel="noopener ugc nofollow" target="_blank"> LZ4 </a>压缩，每秒可以查询上亿行。</p><p id="3fd0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了性能数字之外，它还提供了一些非常有说服力的特性:</p><ul class=""><li id="0704" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">可以处理<a class="ae le" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">熊猫</a>、<a class="ae le" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> Numpy </a>和 Python 对象(通过酸洗)；</li><li id="ac1e" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">可以拍摄对象的多个版本的快照；</li><li id="cf6a" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">为您提供“大块”数据；</li><li id="2305" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">可以利用 MongoDB 的认证；</li><li id="c800" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">拥有三种不同类型的<em class="mj">商店。</em></li></ul><h1 id="a606" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">什么？商店？</h1><p id="1f5e" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated"><strong class="kk iu"> <em class="mj">存储引擎</em> </strong> <em class="mj"> </em> <strong class="kk iu">是直接与底层 MongoDB 数据库交互的机制。他们被称为斗牛士。为了使您的查询获得最佳性能，您可以选择 S <em class="mj"> tores: </em>中的三个内置参数之一</strong></p><ol class=""><li id="27fa" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld nh mb mc md bi translated"><strong class="kk iu"> <em class="mj">版本存储</em> <br/> </strong>默认存储。基于键值和时间序列。它使创建数据快照和检索数据变得容易，而不会损失任何性能。</li><li id="073c" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld nh mb mc md bi translated"><strong class="kk iu"><em class="mj">tick store</em><br/></strong>面向列，支持动态字段。适用于高频金融数据或任何持续跳动的数据。不支持快照。</li><li id="dc6c" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld nh mb mc md bi translated"><strong class="kk iu"><em class="mj">chunk store</em><br/></strong>允许以预定义的块大小存储数据。不支持快照。</li></ol><p id="2233" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以将自己的<em class="mj">存储</em>实现和插件放入 Arctic，以更好地适应您自己的数据。</p><blockquote class="ni nj nk"><p id="08c3" class="ki kj mj kk b kl km ju kn ko kp jx kq nl ks kt ku nm kw kx ky nn la lb lc ld im bi translated">“好的，我明白了，非常有说服力的观点，但是我不知道是否值得使用一个新的数据库……”你，读者，还没有被说服。</p></blockquote></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="a6a9" class="mk ml it bd mm mn nv mp mq mr nw mt mu jz nx ka mw kc ny kd my kf nz kg na nb bi translated">入门指南</h1><p id="48cc" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">那么，让我们看看使用 Arctic 有多简单，看看我是否能让你，<em class="mj">读者，</em>更深入地了解使用另一个数据库的想法。这将是一个非常简单的演练，只是为了说明北极的一些核心功能。</p><h2 id="af49" class="oa ml it bd mm ob oc dn mq od oe dp mu kr of og mw kv oh oi my kz oj ok na ol bi translated">安装</h2><p id="1bcb" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">首先，你需要安装并运行 MongoDB。你可以在<a class="ae le" href="https://docs.mongodb.com/manual/installation/" rel="noopener ugc nofollow" target="_blank">官方 MongoDB 文档页面阅读你的操作系统的说明。</a></p><p id="8d98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成后，我们可以使用<a class="ae le" href="https://pypi.org/project/pip/" rel="noopener ugc nofollow" target="_blank"> pip </a>安装 Arctic</p><pre class="lg lh li lj gt om on oo op aw oq bi"><span id="edd7" class="oa ml it on b gy or os l ot ou">pip install git+https://github.com/manahl/arctic.git</span></pre><p id="4eda" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要安装熊猫库，因为我们将处理<code class="fe ov ow ox on b"><a class="ae le" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html" rel="noopener ugc nofollow" target="_blank">DataFrames</a></code></p><pre class="lg lh li lj gt om on oo op aw oq bi"><span id="e3c5" class="oa ml it on b gy or os l ot ou">pip install pandas</span></pre><h2 id="2ede" class="oa ml it bd mm ob oc dn mq od oe dp mu kr of og mw kv oh oi my kz oj ok na ol bi translated"><strong class="ak">编码</strong></h2><p id="383c" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">首先:让我们将北极导入到我们的空 Python 脚本中</p><pre class="lg lh li lj gt om on oo op aw oq bi"><span id="48fe" class="oa ml it on b gy or os l ot ou">from arctic import Arctic</span></pre><p id="44f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们需要将 Arctic 连接到它的底层 MongoDB 实例。您可以将 Arctic 连接到托管在云上或本地网络中的任何 MongoDB 实例。因为我在笔记本电脑上运行 MongoDB，所以我将使用<code class="fe ov ow ox on b">localhost</code> <em class="mj"> </em>作为我的实例的地址。</p><pre class="lg lh li lj gt om on oo op aw oq bi"><span id="eb0a" class="oa ml it on b gy or os l ot ou">db = Arctic('localhost')</span></pre><p id="cebf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了！现在我们需要创建一个<em class="mj">库</em>。</p><p id="b9b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> Arctic 使用<em class="mj">库的概念分离不同的数据。</em> </strong>他们可以是市场、地区、用户等。</p><p id="2f37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，我将使用一个大约 160MB 的 CSV 文件，其中包含一些财务数据。让我们创建一个<em class="mj">财务</em>库来存储它。通过不向<code class="fe ov ow ox on b">initialize_library</code>方法传递一个<code class="fe ov ow ox on b">lib_type</code>值，Arctic 将默认这个库使用<em class="mj">版本存储</em>存储引擎。对于我们的例子来说，这很好。</p><pre class="lg lh li lj gt om on oo op aw oq bi"><span id="c256" class="oa ml it on b gy or os l ot ou">db.initialize_library('Finance')</span></pre><p id="9d49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要访问刚刚创建的<em class="mj">库</em>，以便向其中写入一些数据。让我们用库名索引我们的<code class="fe ov ow ox on b">db</code>对象。</p><pre class="lg lh li lj gt om on oo op aw oq bi"><span id="b581" class="oa ml it on b gy or os l ot ou">finance_library = db['Finance']</span></pre><p id="d7cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在写入数据之前，让我们打开时间序列数据文件。在本例中，我将使用一个名为<code class="fe ov ow ox on b"><a class="ae le" href="https://github.com/tgcandido/time-series-with-arctic/blob/master/finance.csv" rel="noopener ugc nofollow" target="_blank">finance.csv</a></code>的文件(本例中使用的 CSV 结构的演示文件)。</p><p id="941f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们使用 Pandas 库打开 CSV 文件。首先，我们需要导入库，然后使用<code class="fe ov ow ox on b"><a class="ae le" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html" rel="noopener ugc nofollow" target="_blank">read_csv</a></code>方法将内容读入一个熊猫<code class="fe ov ow ox on b">DataFrame</code>。</p><p id="dfa9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在将<code class="fe ov ow ox on b">string</code>转换为<code class="fe ov ow ox on b">datetime</code>之后，我们还会将<code class="fe ov ow ox on b">unix</code>列设置为<code class="fe ov ow ox on b">DataFrame</code>的索引。</p><pre class="lg lh li lj gt om on oo op aw oq bi"><span id="a9f9" class="oa ml it on b gy or os l ot ou">import pandas as pd<br/>df = pd.read_csv('finance.csv')<br/>df['unix'] = pd.to_datetime(df['unix'])<br/>df.set_index('unix', inplace=True)</span></pre><p id="cd32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧！我们准备将数据写入北极。为此，我们需要定义一个<em class="mj">符号。</em></p><p id="27f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<em class="mj">符号</em>是一个字符串，我们将使用它在一个库中读取或写入我们的数据。</p><p id="65df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们使用符号<code class="fe ov ow ox on b">Stocks</code>将我们加载的<code class="fe ov ow ox on b">df</code>的内容存储到库<code class="fe ov ow ox on b">finance_library</code>中。</p><pre class="lg lh li lj gt om on oo op aw oq bi"><span id="ae31" class="oa ml it on b gy or os l ot ou">finance_library.write('Stocks', df)</span></pre><p id="0f6c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过使用方法<code class="fe ov ow ox on b">read</code>并访问返回对象的<code class="fe ov ow ox on b">data</code>属性以获得结果<code class="fe ov ow ox on b">DataFrame</code>来验证数据是否被正确插入。</p><pre class="lg lh li lj gt om on oo op aw oq bi"><span id="41ea" class="oa ml it on b gy or os l ot ou">new_df = finance_library.read('Stocks').data</span></pre><p id="1da1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要执行查找特定时间间隔的查询，我们可以使用<code class="fe ov ow ox on b">read</code>方法中的<code class="fe ov ow ox on b">date_range</code>参数。</p><p id="bfd2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们需要从<code class="fe ov ow ox on b">arctic.date</code>导入<code class="fe ov ow ox on b">DateRange</code>:</p><pre class="lg lh li lj gt om on oo op aw oq bi"><span id="7d88" class="oa ml it on b gy or os l ot ou">from arctic.date import DateRange</span></pre><p id="bb66" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将一个<code class="fe ov ow ox on b">DateRange</code>的实例传递给<code class="fe ov ow ox on b">date_range</code>参数。我们可以通过调用它的构造函数并将开始日期和结束日期作为参数传递来创建它。</p><pre class="lg lh li lj gt om on oo op aw oq bi"><span id="b3f7" class="oa ml it on b gy or os l ot ou">custom_range = DateRange('2020-01-01', '2020-01-02')</span></pre><p id="383e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以运行查询:</p><pre class="lg lh li lj gt om on oo op aw oq bi"><span id="04e9" class="oa ml it on b gy or os l ot ou">range_df = finance_library.read('Stocks', date_range=custom_range).data</span></pre><p id="6e10" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样！在这个非常简单的例子中，我们通过实现一个处理一些财务数据的 Python 脚本看到了 Arctic 的主要特性。</p><p id="993f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">官方文档真的很好，几乎包含了所有需要的信息，从基础到高级特性。没有必要阅读软件包的源代码，但是如果您有兴趣了解 Arctic 的工作方式以及它是如何实现其高性能的，我鼓励您这样做。</p><p id="0c00" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但恐怕我不会说服你，<em class="mj">读者，</em>除非我给你看一些业绩数字，对吗？</p><h1 id="12e6" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">基准</h1><p id="4073" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">这些数字都是在我的 2.3 GHz 双核 13 英寸 2017 Mac Book Pro 上运行脚本获得的。</p><blockquote class="ni nj nk"><p id="c2c0" class="ki kj mj kk b kl km ju kn ko kp jx kq nl ks kt ku nm kw kx ky nn la lb lc ld im bi translated">请记住，这绝不是北极数据库的完整基准。这是用 Python 的时间库在 Arctic、MongoDB、SQLite 和普通 CSV 文件之间进行的简单比较。</p></blockquote><h2 id="033c" class="oa ml it bd mm ob oc dn mq od oe dp mu kr of og mw kv oh oi my kz oj ok na ol bi translated">性能比较</h2><p id="5682" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">下面是运行一个简单的 Pandas <code class="fe ov ow ox on b">read_csv</code>、一个 PyMongo 查询、<a class="ae le" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>查询(使用 SQLite 数据库)和一个 Arctic <code class="fe ov ow ox on b">read</code>查询(使用大约 160 MB 的财务数据作为源)的结果。</p><p id="cddd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在引擎返回结果后，PyMongo 和 SQLAlchemy 查询结果被解析成一个<code class="fe ov ow ox on b">DataFrame </code>，这个时间在基准测试中被考虑。两个数据库都由<code class="fe ov ow ox on b">unix</code>列索引。</p><ul class=""><li id="c1af" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">熊猫<code class="fe ov ow ox on b">read_csv</code>:4.6 秒</li><li id="1de3" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">PyMongo 查询:~28 秒</li><li id="64f6" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">SQLite 查询:大约 30 秒</li><li id="0e9c" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">北极<code class="fe ov ow ox on b">read</code> : ~1.45 秒</li></ul><p id="d9a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些结果来自于一个“get all”类型的查询。让我们尝试添加一个范围参数，看看结果是否成立。</p><pre class="lg lh li lj gt om on oo op aw oq bi"><span id="d7bc" class="oa ml it on b gy or os l ot ou">new_df = finance_library.read('Stocks', date_range=DateRange('2020-01-01', '2020-01-02')).data</span></pre><ul class=""><li id="b2a7" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">熊猫<code class="fe ov ow ox on b">read_csv</code>:4.9 秒</li><li id="6521" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">PyMongo 查询:~1.66 秒</li><li id="a420" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">SQLite 查询:~0.7 秒</li><li id="6634" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">北极<code class="fe ov ow ox on b">read</code>与<code class="fe ov ow ox on b">DateRange</code> : ~0.12 秒</li></ul><p id="e20a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在使用了<code class="fe ov ow ox on b">DateRange</code>之后，结果仍然支持 Arctic，这是我们在处理时间序列数据时使用的主要查询类型。</p><h2 id="20d3" class="oa ml it bd mm ob oc dn mq od oe dp mu kr of og mw kv oh oi my kz oj ok na ol bi translated">磁盘压缩</h2><p id="8294" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">同一个 CSV 文件用于播种每个数据库。</p><p id="b718" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是每个备选方案使用的磁盘空间量:</p><ul class=""><li id="9bab" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">普通 CSV 文件:160.8 MB</li><li id="4fa1" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">MongoDB 集合:347.31 MB</li><li id="0b90" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">SQLite: 297.9 兆字节</li><li id="dcb1" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><strong class="kk iu">北极:160.59 兆字节</strong></li></ul><h1 id="052f" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="6bb0" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated"><strong class="kk iu">在处理大型时间序列数据集时使用 Arctic 使我们能够实现显著的速度和压缩改进</strong>。凭借其简单的设置和使用，它可以提高生产力和节省一些宝贵的时间。</p><p id="e93c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使不使用其更高级的功能，如快照或其他存储引擎，我们也可以为使用 Arctic 处理时间序列数据提供有力的支持。</p><p id="4b9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">演练和基准测试的代码可以在这里找到<a class="ae le" href="https://github.com/tgcandido/time-series-with-arctic" rel="noopener ugc nofollow" target="_blank">。出于许可的原因，它不包含完整的 CSV 文件，但是我鼓励您使用您自己的一些数据来运行，看看您的结果是否与我的相似。</a></p><p id="d04d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你喜欢阅读这篇文章。</p><p id="7435" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你有，可以考虑在 <a class="ae le" href="https://twitter.com/ogaihtcandido" rel="noopener ugc nofollow" target="_blank"> <em class="mj">推特</em> </a> <em class="mj">上关注我。</em></p><p id="aee6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢你的时间。保重，继续编码！</p></div></div>    
</body>
</html>