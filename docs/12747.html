<html>
<head>
<title>A friendly introduction to Siamese Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">暹罗网络的友好介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-friendly-introduction-to-siamese-networks-85ab17522942?source=collection_archive---------0-----------------------#2020-09-02">https://towardsdatascience.com/a-friendly-introduction-to-siamese-networks-85ab17522942?source=collection_archive---------0-----------------------#2020-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eaa0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你不总是需要大量的数据来训练你的模型，学习如何创建一个每类只有少量图像的模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5bf5b16e2053930a2adbfa1bec5e745c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zP7LnAr3MmwTe0fSjYke0w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丽莎·阿尔格拉在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="c590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现代深度学习时代，神经网络几乎擅长每一项任务，但这些神经网络依赖于更多的数据才能表现良好。但是，对于某些问题，如人脸识别和签名验证，我们不能总是依赖于获得更多的数据，为了解决这类任务，我们有一种新型的神经网络架构，称为暹罗网络。</p><p id="860c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它仅使用少量图像来获得更好的预测。从很少的数据中学习的能力使得暹罗网络在最近几年更受欢迎。在本文中，我们将探讨它是什么以及如何使用 Pytorch 开发一个使用暹罗网络的签名验证系统。</p><h1 id="066d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是暹罗网！？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/e4be866289c03dad128da340b7525aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0E9104t29iMBmtvq7G1G6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">暹罗网用于<a class="ae ky" href="https://arxiv.org/abs/1707.02131" rel="noopener ugc nofollow" target="_blank">图章</a></p></figure><p id="2090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">连体神经网络是一类神经网络架构，其中<strong class="lb iu">包含两个或更多<em class="mo">相同的</em>子网络</strong>。<em class="mo">这里的‘相同’</em>是指，它们具有相同的配置，具有相同的参数和权重。参数更新在两个子网络上都是镜像的。它用于通过比较其特征向量来发现输入的相似性，因此这些网络被用于许多应用中</p><p id="569d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统上，神经网络学习预测多个类别。当我们需要向数据中添加/删除新的类时，这就带来了问题。在这种情况下，我们必须更新神经网络，并在整个数据集上重新训练它。此外，深度神经网络需要大量的数据来进行训练。另一方面，SNNs 学习相似性函数。因此，我们可以训练它来看看这两个图像是否相同(我们将在这里这样做)。这使我们能够对新的数据类别进行分类，而无需再次训练网络。</p><h2 id="a03f" class="mp lw it bd lx mq mr dn mb ms mt dp mf li mu mv mh lm mw mx mj lq my mz ml na bi translated">暹罗网络的利弊:</h2><p id="896a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">暹罗网络的主要优势是，</p><ul class=""><li id="5932" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><strong class="lb iu">对类别不平衡更鲁棒:</strong>在一次性学习的帮助下，给定每个类别的一些图像足以使暹罗网络在将来识别这些图像</li><li id="a1f9" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">对于具有最佳分类器的集成来说很好:</strong>鉴于其学习机制与分类有些不同，使用分类器对其进行简单平均可以比平均 2 个相关监督模型(例如 GBM &amp; RF 分类器)做得更好</li><li id="62a1" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">从语义相似性中学习:</strong> Siamese 侧重于学习将相同的类/概念紧密放置在一起的嵌入(在更深的层中)。于是，可以学习<em class="mo">的语义相似度</em>。</li></ul><p id="d5c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">连体网络的缺点是，</p><ul class=""><li id="e9b7" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><strong class="lb iu">比普通网络需要更多的训练时间:</strong>由于暹罗网络涉及二次对学习(查看所有可用信息)，它比普通分类类型的学习(逐点学习)要慢</li><li id="b75c" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">不输出概率:</strong>由于训练涉及成对学习，它不会输出预测的概率，而是输出与每个类的距离</li></ul><h2 id="72c9" class="mp lw it bd lx mq mr dn mb ms mt dp mf li mu mv mh lm mw mx mj lq my mz ml na bi translated">暹罗网络中使用的损失函数:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/ca5c716d775ad10d94e4f0f7b74fc78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPcSO_9ThH9p8aZHO43myg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对比缺失，作者创造的形象</p></figure><p id="e6d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于连体网络的训练通常涉及成对学习，所以在这种情况下不能使用交叉熵损失，主要有两个损失函数主要用于训练这些连体网络，它们是</p><p id="39e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">三重损失</strong>是一个损失函数，其中基线(锚)输入与正(真)输入和负(假)输入进行比较。从基线(锚)输入到正(真)输入的距离最小，从基线(锚)输入到负(假)输入的距离最大。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/36d877dc88b57e6921f28503af7f95a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*Wh4VeTKfHR4M4mh-z6fGUA.png"/></div></figure><p id="01c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的等式中，α是用于“拉伸”三元组中相似和不相似对之间的距离差异的余量项，fa、fp、fn 是锚定图像、正图像和负图像的特征嵌入。</p><p id="c84f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在训练过程中，将图像三元组(锚图像、负图像、正图像)(锚图像、负图像、正图像)作为单个样本输入到模型中。这背后的想法是锚和正图像之间的距离应该小于锚和负图像之间的距离。</p><p id="75c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">对比损失</strong>:是目前使用频率很高的一种流行损失函数，它是一种<strong class="lb iu"> <em class="mo">基于距离的损失</em> </strong>而不是更为传统的<strong class="lb iu"> <em class="mo">误差预测损失</em> </strong> <em class="mo">。</em>这种损失用于学习嵌入，其中两个相似的点具有低的欧几里德距离，而两个不相似的点具有大的欧几里德距离。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/80464e1201476f525c34703cbab1692b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uo5IovRsjW86b-vCBZGRvg.jpeg"/></div></div></figure><p id="1812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将 Dw 定义为欧几里德距离:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/185159b7b97d36c2bef9c087fef8d47f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OKHJ4cEjMpk9PuB-.png"/></div></div></figure><p id="1ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Gw 是我们的网络对一幅图像的输出。</p><h1 id="348c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用暹罗网络进行签名验证:</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/78d73694ae524d0d27bdcc891fca3ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwOBbwGXMZUy6OzkFAPTzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于签名验证的暹罗网络，图片由作者创建</p></figure><p id="784d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于连体网络主要用于验证系统，如人脸识别、签名验证等…让我们在 Pytorch 上实现一个使用连体神经网络的签名验证系统</p><h2 id="5717" class="mp lw it bd lx mq mr dn mb ms mt dp mf li mu mv mh lm mw mx mj lq my mz ml na bi translated">数据集和数据集预处理:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/e0aa7b603c1e31b65c9063eb3b169e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*aHFzVmM1cV3d6teiyBOoUA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ICDAR 数据集中的签名，图像由作者创建</p></figure><p id="db57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用 ICDAR 2011 数据集，该数据集由荷兰用户的签名(包括真品和伪造品)组成，数据集本身被分为序列和文件夹，在每个文件夹中，它由分为真品和伪造品的用户文件夹组成，数据集的标签也以 CSV 文件的形式提供，您可以从<a class="ae ky" href="https://drive.google.com/drive/folders/1hFljH9AKhxxIqH-3fj72mCMA6Xh3Vv0m?usp=sharing" rel="noopener ugc nofollow" target="_blank">这里</a>下载数据集</p><p id="ca28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，要将这些原始数据输入到我们的神经网络中，我们必须将所有图像转换为张量，并将 CSV 文件中的标签添加到图像中，为此，我们可以使用 Pytorch 中的自定义数据集类，下面是我们的完整代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b14d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在预处理数据集之后，在 PyTorch 中，我们必须使用 Dataloader 类加载数据集，我们将使用 transforms 函数将图像大小减少到 105 像素的高度和宽度，以便进行计算</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="0b49" class="mp lw it bd lx mq mr dn mb ms mt dp mf li mu mv mh lm mw mx mj lq my mz ml na bi translated">神经网络架构:</h2><p id="0a27" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在，让我们在 Pytorch 中创建一个神经网络，我们将使用类似的神经网络架构，如 Signet 论文中所述</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="32a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们创建了如下的网络，第一个卷积层使用 96 个大小为 11 的核过滤 105*105 的输入签名图像，步长为 1 个像素。第二卷积层将第一卷积层的(响应归一化和汇集的)输出作为输入，并用 256 个大小为 5 的核对其进行滤波。第三和第四卷积层彼此连接，没有任何层的汇集或标准化的介入。第三层具有 384 个大小为 3 的内核，连接到第二卷积层的(归一化、汇集和丢弃)输出。第四卷积层具有 256 个大小为 3 的核。这导致神经网络对于较小的感受域学习较少的较低级特征，而对于较高级或更抽象的特征学习更多的特征。第一全连接层具有 1024 个神经元，而第二全连接层具有 128 个神经元。这表明来自 SigNet 每一侧的最高学习特征向量具有等于 128 的维度，那么另一个网络在哪里呢？</p><blockquote class="oc od oe"><p id="c0af" class="kz la mo lb b lc ld ju le lf lg jx lh of lj lk ll og ln lo lp oh lr ls lt lu im bi translated">由于两个网络的权重被限制为相同，所以我们使用一个模型并连续输入两个图像。之后，我们使用两幅图像计算损失值，然后反向传播。这节省了大量内存，也提高了计算效率。</p></blockquote><h2 id="dcf0" class="mp lw it bd lx mq mr dn mb ms mt dp mf li mu mv mh lm mw mx mj lq my mz ml na bi translated">损失函数:</h2><p id="a5de" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">对于这个任务，我们将使用对比损失，其学习嵌入，其中两个相似的点具有低的欧几里德距离，而两个不相似的点具有大的欧几里德距离，在 Pytorch 中，对比损失的实现将如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="c899" class="mp lw it bd lx mq mr dn mb ms mt dp mf li mu mv mh lm mw mx mj lq my mz ml na bi translated">训练网络:</h2><p id="2232" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">暹罗网络的训练过程如下:</p><ul class=""><li id="d3be" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">初始化网络、损失函数和优化器(我们将在这个项目中使用 Adam)</li><li id="0e67" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">通过网络传递图像对的第一个图像。</li><li id="1e83" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">通过网络传递图像对的第二个图像。</li><li id="9c07" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">使用来自第一和第二图像的输出来计算损失。</li><li id="4e30" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">反向传播损失以计算我们模型的梯度。</li><li id="7bb5" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">使用优化器更新权重</li><li id="8ac7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">保存模型</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="68d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模型在 google colab 上训练了一个小时的 20 个时期，损失随时间变化的图表如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/88f6f9236f1f094999406c3689e195ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*UvuZt8ValuVAToV4AyYtuQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一段时间内的损耗图</p></figure><h2 id="a0a1" class="mp lw it bd lx mq mr dn mb ms mt dp mf li mu mv mh lm mw mx mj lq my mz ml na bi translated">测试模型:</h2><p id="f795" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在让我们在测试数据集上测试我们的签名验证系统，</p><ul class=""><li id="e7d6" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">使用 Pytorch 中的 DataLoader 类加载测试数据集</li><li id="39d0" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">传递图像对和标签</li><li id="63db" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">找出图像之间的欧几里德距离</li><li id="8ce1" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">基于欧几里得距离打印输出</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="5286" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预测如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/28f297cec46c3978f2a2723382c9e03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Vk-I-LdrnBDPNYx1bexRMg.png"/></div></figure><h2 id="9309" class="mp lw it bd lx mq mr dn mb ms mt dp mf li mu mv mh lm mw mx mj lq my mz ml na bi translated">结论:</h2><p id="dea3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在本文中，我们讨论了暹罗网络与普通深度学习网络的不同之处，并使用暹罗网络实现了一个签名验证系统，您可以在这里找到完整的代码<a class="ae ky" href="https://github.com/seanbenhur/siamese_net" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="ccb4" class="mp lw it bd lx mq mr dn mb ms mt dp mf li mu mv mh lm mw mx mj lq my mz ml na bi translated">参考资料:</h2><p id="8a80" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><a class="ae ky" href="https://hackernoon.com/one-shot-learning-with-siamese-networks-in-pytorch-8ddaab10340e" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/one-shot-learning-with-siamese-networks-in-py torch-8d daab 10340 e</a></p><div class="ok ol gp gr om on"><a href="https://arxiv.org/abs/1707.02131" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">SigNet:用于独立于书写者的离线签名验证的卷积暹罗网络</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">离线签名验证是生物特征识别和文档取证中最具挑战性的任务之一。不像其他人…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">arxiv.org</p></div></div></div></a></div><p id="60f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://innovationincubator.com/siamese-neural-network-with-pytorch-code-example/" rel="noopener ugc nofollow" target="_blank">https://innovationincubator . com/siamese-neural-network-with-py torch-code-example/</a></p><div class="ok ol gp gr om on"><a href="https://hackernoon.com/facial-similarity-with-siamese-networks-in-pytorch-9642aa9db2f7" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">PyTorch 中与暹罗网络的面部相似性</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">PyTorch 中用连体网络实现人脸相似性</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">hackernoon.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><p id="5ee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://neptune.ai/blog/content-based-image-retrieval-with-siamese-networks" rel="noopener ugc nofollow" target="_blank">https://Neptune . ai/blog/content-based-image-retrieval-with-siamese-networks</a></p></div></div>    
</body>
</html>