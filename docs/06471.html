<html>
<head>
<title>Lesser Known Python Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">鲜为人知的Python特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lesser-known-python-features-f87af511887?source=collection_archive---------4-----------------------#2020-05-23">https://towardsdatascience.com/lesser-known-python-features-f87af511887?source=collection_archive---------4-----------------------#2020-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b99c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中经常不为人知和被低估的功能示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/939daab2ae43e88e7133ed477bbd5ec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MpB5tnTsh4_4Manc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3eb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时不时地，当我了解到Python中的一个新特性，或者我注意到其他一些人不知道这个特性时，我会记下来。</p><p id="e947" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的几周里，有一些有趣的特性是我自己最近了解到的，或者意识到了其他一些特性——例如，在堆栈溢出方面，我以前并不知道。</p><p id="8376" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是对其中一些特性的快速浏览，以及每个特性的概要。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="337e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">divmod</h1><p id="b9f4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">非常有用的功能。<code class="fe mz na nb nc b">divmod()</code>函数对两个数执行模数除法<code class="fe mz na nb nc b">%</code>，然后返回商和余数。例如:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9046" class="nh md it nc b gy ni nj l nk nl">divmod(5, 2)</span></pre><p id="af65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b"><strong class="lb iu">[Out]:</strong> (2, 1)</code></p><p id="0e8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是简单地找出我们可以将<code class="fe mz na nb nc b">2</code>放入<code class="fe mz na nb nc b">5</code>的次数，而不用拆分这个数，这给了我们<code class="fe mz na nb nc b">2</code>，即商。在此之后，我们还有<code class="fe mz na nb nc b">1</code>剩余，这是我们的余数。</p><p id="f5e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于返回进程运行所用的时间(以小时、分钟和秒为单位)特别有用。像这样:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="918e" class="nh md it nc b gy ni nj l nk nl">start = datetime.datetime.now()</span><span id="982b" class="nh md it nc b gy nm nj l nk nl">    ...  # process code goes here</span><span id="aeef" class="nh md it nc b gy nm nj l nk nl">end = datetime.datetime.now()</span><span id="b55d" class="nh md it nc b gy nm nj l nk nl"># we get the total runtime in seconds<br/>runtime = (end - start).seconds  # we will assume 30000</span><span id="36ca" class="nh md it nc b gy nm nj l nk nl"># how many hours are in these secs, what are the remaining secs?<br/>hours, remainder = divmod(runtime, 3600)</span><span id="dd24" class="nh md it nc b gy nm nj l nk nl"># now how many minutes and seconds are in our remainder?<br/>mins, secs = divmod(remainder, 60)</span><span id="8d5f" class="nh md it nc b gy nm nj l nk nl">print("{:02d}:{:02d}:{:02d}".format(hours, mins, secs))</span></pre><p id="b086" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b"><strong class="lb iu">[Out]:</strong> "08:00:08"</code></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fd0a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">*args，**kwargs</h1><p id="8aff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，您可能会注意到函数定义包含这两个参数，比如<code class="fe mz na nb nc b">def func(x, y, *args, **kwargs)</code>。</p><p id="6c74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们实际上都非常简单。两者都允许我们向一个函数传递多个值，然后将这些值打包到一个生成器中。</p><p id="6ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将一个列表/生成器传递给一个标准参数，结果是相似的，就像这样:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3a1a" class="nh md it nc b gy ni nj l nk nl">def func(values):<br/>    for x in values:<br/>        print(x, end=" ")</span><span id="3cb0" class="nh md it nc b gy nm nj l nk nl">func(<strong class="nc iu">[1, 2, 3]</strong>)</span></pre><p id="d094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b"><strong class="lb iu">[Out]:</strong> '1 2 3 '</code></p><p id="772d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们使用<code class="fe mz na nb nc b">*args</code>——这将允许我们将每个值作为一个新的参数传递，而不是将它们都包含在一个列表中。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="042f" class="nh md it nc b gy ni nj l nk nl">def func(*values):<br/>    for x in values:<br/>        print(x, end=" ")</span><span id="c7db" class="nh md it nc b gy nm nj l nk nl">func(<strong class="nc iu">1, 2, 3</strong>)</span></pre><p id="4158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b"><strong class="lb iu">[Out]:</strong> 1 2 3</code></p><p id="1ab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们不需要输入<code class="fe mz na nb nc b">*args</code>，相反，我们输入了<code class="fe mz na nb nc b">*values</code>。我们使用的变量名无关紧要。由于只有一个星号<code class="fe mz na nb nc b">*</code>，它被定义为<code class="fe mz na nb nc b">*args</code>。</p><p id="7245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">*args</code>简单地从我们传递给函数的参数中创建一个元组。</p><p id="b00d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">**kwargs</code>另一方面，创造了字典。因此得名，<strong class="lb iu">k</strong>ey-<strong class="lb iu">w</strong>ord<strong class="lb iu">arg</strong>ument<strong class="lb iu">s</strong>。我们像这样使用它:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2dae" class="nh md it nc b gy ni nj l nk nl">def func(**values):<br/>    for x in values:<br/>        print(f"{x}: {values[x]}")</span><span id="6d40" class="nh md it nc b gy nm nj l nk nl">func(x=1, y=2, z=3)</span><span id="aff6" class="nh md it nc b gy nm nj l nk nl"><strong class="nc iu">[Out]:</strong> x: 1<br/>       y: 2<br/>       z: 3</span></pre><p id="6127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以随意调用变量，在本例中我们使用了<code class="fe mz na nb nc b">**values</code>。使用双星号<code class="fe mz na nb nc b">**</code>将其定义为<code class="fe mz na nb nc b">**kwargs</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5a36" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">（听力或阅读）理解测试</h1><p id="cd11" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这绝对是Python最有用的特性之一。理解表达是不可错过的。最常见的是<strong class="lb iu">列表理解</strong>，我相信你们中的绝大多数人都见过这些:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="68ea" class="nh md it nc b gy ni nj l nk nl">vals = [1, 2, 3, 4, 5]</span><span id="25aa" class="nh md it nc b gy nm nj l nk nl">[i**2 for i in vals]</span></pre><p id="19cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b"><strong class="lb iu">[Out]:</strong> [1, 4, 9, 16, 25]</code></p><p id="0e98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们不限于这些方括号。我们可以用几乎完全相同的语法定义一个<strong class="lb iu">生成器表达式</strong>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6e25" class="nh md it nc b gy ni nj l nk nl">(i**2 for i in vals)</span></pre><p id="9667" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b"><strong class="lb iu">[Out]:</strong> &lt;generator object &lt;genexpr&gt; at 0x7f0281730fc0&gt;</code></p><p id="fac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，生成器中的每个元素只有在被调用时才会被输出，我们可以用<code class="fe mz na nb nc b">list()</code>来实现:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2c26" class="nh md it nc b gy ni nj l nk nl">list((i**2 for i in vals))</span></pre><p id="af32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b"><strong class="lb iu">[Out]:</strong> [1, 4, 9, 16, 25]</code></p><p id="bcb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法上的另一个小变化是，我们甚至可以使用<strong class="lb iu">字典理解</strong>来构建字典:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="590b" class="nh md it nc b gy ni nj l nk nl">{i: i**2 for i in vals}</span><span id="6c40" class="nh md it nc b gy nm nj l nk nl"><strong class="nc iu">[Out]:</strong> {1: 1,<br/>        2: 4,<br/>        3: 9,<br/>        4: 16,<br/>        5: 25}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0e18" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">文件夹</h1><p id="2a92" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个特别有意思的字符串方法。其功能与<code class="fe mz na nb nc b">lower</code>相似。然而，<code class="fe mz na nb nc b">casefold</code>试图更积极地标准化更广泛的字符。</p><p id="663b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数情况下，<code class="fe mz na nb nc b">lower</code>和<code class="fe mz na nb nc b">casefold</code>的行为是相同的，但偶尔也会有不同:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="09f4" class="nh md it nc b gy ni nj l nk nl">"ς".casefold()  # both ς and σ are the Greek letter sigma</span><span id="3ab0" class="nh md it nc b gy nm nj l nk nl"><strong class="nc iu">[Out]:</strong> "σ"</span></pre><p id="f313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，使用<code class="fe mz na nb nc b">lower</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="03c7" class="nh md it nc b gy ni nj l nk nl">"ς".lower()  # however, lower recognizes them as different</span><span id="5527" class="nh md it nc b gy nm nj l nk nl"><strong class="nc iu">[Out]:</strong> "ς"</span></pre><p id="7fda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b"><strong class="lb iu">[Out]:</strong> False</code></p><p id="70c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，两个sigmas都已经是小写了。这取决于用例，可以如预期的那样运行。</p><p id="45d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果我们打算比较两个等价的希腊单词，一个使用σ，另一个使用ς.尽管相同，但只有<code class="fe mz na nb nc b">casefold</code>能让我们准确地比较它们:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7314" class="nh md it nc b gy ni nj l nk nl">"ἑρμῆσ" == "ἑρμῆς"</span><span id="ed19" class="nh md it nc b gy nm nj l nk nl"><strong class="nc iu">[Out]:</strong> False</span><span id="c782" class="nh md it nc b gy nm nj l nk nl">"ἑρμῆσ".lower() == "ἑρμῆς".lower()</span><span id="865b" class="nh md it nc b gy nm nj l nk nl"><strong class="nc iu">[Out]:</strong> False</span><span id="4016" class="nh md it nc b gy nm nj l nk nl">"ἑρμῆσ".casefold() == "ἑρμῆς".casefold()</span><span id="3685" class="nh md it nc b gy nm nj l nk nl"><strong class="nc iu">[Out]:</strong> True</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d0c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你从这篇文章中有所收获。特别是，<code class="fe mz na nb nc b">divmod</code>和<code class="fe mz na nb nc b">casefold</code>都是非常有趣的功能，我个人直到最近才使用过。</p><p id="82b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何独特的、有趣的或者相对不为人知的Python特性想要分享，请告诉我，我很乐意看到它们！欢迎通过<a class="ae ky" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或在下面的评论中联系我们。</p><p id="9872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="ca32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您喜欢这篇文章，您可能会对我之前关于另外四个鲜为人知的Python特性的文章感兴趣:</p><div class="nn no gp gr np nq"><a rel="noopener follow" target="_blank" href="/4-super-useful-python-features-993ae484fbb8"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">4个非常有用的Python特性</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">四个不太知名但非常有用的Python功能</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">towardsdatascience.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div></div></div>    
</body>
</html>