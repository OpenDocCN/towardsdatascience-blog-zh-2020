<html>
<head>
<title>Optimize Python Code in Jupyter Notebook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Jupyter笔记本中优化Python代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimize-python-code-in-jupyter-notebook-9df92832a23e?source=collection_archive---------11-----------------------#2020-02-19">https://towardsdatascience.com/optimize-python-code-in-jupyter-notebook-9df92832a23e?source=collection_archive---------11-----------------------#2020-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5c17" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无聊地等待缓慢的Python作业完成？让我们找到瓶颈并优化它。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/44b79b8207e254f9af1122e210625661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*FWsgI5BmwXz8sFbtuv_OSA.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由<a class="ae ku" href="https://pixabay.com/users/piro4d-2707530/?tab=videos" rel="noopener ugc nofollow" target="_blank"> PIRO4D </a>在<a class="ae ku" href="https://pixabay.com/videos/time-moondial-time-machine-6358/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上制作的视频</p></figure><p id="a242" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">想在Jupyter笔记本里让一个慢的Python代码变快？以sum aggregate为例，我们将使用<code class="fe lr ls lt lu b">%%time</code>测量运行时间，并使用<code class="fe lr ls lt lu b">%lprun</code>行分析器找到瓶颈。</p><h1 id="e794" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">要优化的函数:Sum聚合</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/2fb41c0f6023cab21791f7b8f0b2f31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*YyN9FDqLqJmdESfm61CieA.png"/></div></figure><p id="c016" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设Pandas没有group-by和aggregate函数，我们需要自己实现它。我们希望<strong class="kx iu">按名称聚合上表，并计算值</strong>的总和。</p><p id="2f17" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">也许，在我们的第一次迭代中，我们会产生如下代码。我们在字典的帮助下汇总该值(命名为⇨值)。通过迭代每一行，我们更新了字典的值。在迭代结束时，我们将字典转换回Pandas的数据框架。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7ed4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我们优化代码之前，我们需要问:“我们真的需要优化代码吗？为什么？”如果我们花更多的时间来优化，而不是多等一会儿来完成工作，这是不值得的，不是吗？</p><blockquote class="mq"><p id="8d31" class="mr ms it bd mt mu mv mw mx my mz lq dk translated">"过早优化是万恶之源."—姜懿翔·克努特</p></blockquote><p id="270f" class="pw-post-body-paragraph kv kw it kx b ky na ju la lb nb jx ld le nc lg lh li nd lk ll lm ne lo lp lq im bi translated">现在，让我们假设sum aggregate代码太慢，我们需要优化它。我们如何做到这一点？</p><h1 id="d2ef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">原则1:我们不能改进我们不能测量的东西</h1><blockquote class="mq"><p id="9c50" class="mr ms it bd mt mu mv mw mx my mz lq dk translated">“如果你不能衡量它，你就不能改善它。”—彼得·德鲁克</p></blockquote><p id="f138" class="pw-post-body-paragraph kv kw it kx b ky na ju la lb nb jx ld le nc lg lh li nd lk ll lm ne lo lp lq im bi translated">我们需要测量代码运行时间的能力来比较优化前后。我们有可能让事情变得更糟，特别是如果我们使用像Numpy和Pandas这样的外部库。我们不知道这个库是如何实现的。</p><p id="8b3d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">前缀为<code class="fe lr ls lt lu b">%%</code>的代码是IPython cell magic-function。我们可以通过向单元添加<code class="fe lr ls lt lu b">%%time</code>来测量单元的运行时间。我们不需要为此安装任何新的库。我们只需要导入<code class="fe lr ls lt lu b">time</code>，它是Python标准库的一部分。</p><pre class="kj kk kl km gt nf lu ng nh aw ni bi"><span id="4f1d" class="nj lw it lu b gy nk nl l nm nn"><strong class="lu iu">%%time<br/></strong>sum_aggregate_1(df, 'name', 'value').sort_values('value', ascending=False).head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/0ccebd1f2433cf3d25e7878cbcc9daaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*0lApL6WzZpUVtqcOGrk3hw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><em class="np"> sum_aggregate_1 </em>的运行时间</p></figure><p id="6a6f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">实测运行时间约为38 s，现在我们需要优化哪个部分？如果是我在猜，我会选择优化<code class="fe lr ls lt lu b">time.sleep()</code>部分。似乎显而易见。基于直觉的优化可能最终没有显著的改进，只是浪费时间。我们需要找到瓶颈。</p><h1 id="bdf9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">原则2:优化瓶颈</h1><blockquote class="mq"><p id="d607" class="mr ms it bd mt mu mv mw mx my mz lq dk translated">"除了瓶颈之外，任何地方的改进都是一种幻觉."—吉恩·金</p></blockquote><p id="b48f" class="pw-post-body-paragraph kv kw it kx b ky na ju la lb nb jx ld le nc lg lh li nd lk ll lm ne lo lp lq im bi translated">优化不是瓶颈的代码部分不会显著减少总运行时间。这就是为什么吉恩·金说，改进只是一种错觉，毫无用处。怎么才能找到瓶颈？</p><p id="5f8d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以使用<code class="fe lr ls lt lu b">line-profiler</code>库来获得每一行的执行时间。我们需要安装<code class="fe lr ls lt lu b">line-profiler</code>。之后，我们需要用<code class="fe lr ls lt lu b">%load_ext</code>导入魔法功能。</p><pre class="kj kk kl km gt nf lu ng nh aw ni bi"><span id="9055" class="nj lw it lu b gy nk nl l nm nn">! pip install line-profiler<br/>%load_ext line_profiler</span></pre><p id="b372" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们需要向线路分析器提供<code class="fe lr ls lt lu b">function to profile</code>和<code class="fe lr ls lt lu b">execution trigger</code>参数。在我们的例子中，我们想要分析的函数是<code class="fe lr ls lt lu b">sum_aggregate_1</code>，我们用<code class="fe lr ls lt lu b">sum_aggregate_1(random_df, 'name', 'value)</code>触发执行。</p><pre class="kj kk kl km gt nf lu ng nh aw ni bi"><span id="bad7" class="nj lw it lu b gy nk nl l nm nn"># %lprun -f [function to profile] [execution trigger]<br/># [function to profile]: sum_aggregate_1<br/># [execution trigger]: sum_aggregate_1(random_df, 'name', 'value')</span><span id="1ce3" class="nj lw it lu b gy nq nl l nm nn">%lprun -f sum_aggregate_1 sum_aggregate_1(random_df, 'name', 'value')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/6c31fd3c80e7efeeb84befcf96633f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjZ3_E-kznKeek84cFDCTA.png"/></div></div></figure><p id="4528" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">从结果中，我们可以看到该函数的主要瓶颈在第4行。现在，我们知道<code class="fe lr ls lt lu b">DataFrame.iterrows()</code>对于迭代来说非常慢。它花费了66%的执行时间。</p><p id="c24d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我们发现瓶颈之后，我们可以继续优化代码。我们可以简单地从搜索引擎中找到<code class="fe lr ls lt lu b">DataFrame.iterrows()</code>的替代品。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5092" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">一种替代方法是将键和值列作为Numpy数组。之后，压缩两个Numpy数组并遍历它。我们可以观察到瓶颈现在正从迭代部分转移到<code class="fe lr ls lt lu b">time.sleep()</code>部分。总运行时间从38秒减少到7秒</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/858adccd9b80e083470db558df2d2d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjnZTgRxIZsIbLtLZkG8Tg.png"/></div></div></figure><p id="c6fa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">通过反复寻找和优化瓶颈，我们首先进行最有效的优化。</strong>这就像使用“贪婪算法”的思维模式来确定优化的优先级。当代码运行时足够快时，我们可以停止优化，尽管做进一步的优化很诱人。</p><h1 id="9fa0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最后一个音符</h1><p id="09b8" class="pw-post-body-paragraph kv kw it kx b ky nx ju la lb ny jx ld le nz lg lh li oa lk ll lm ob lo lp lq im bi translated">进行优化时，需要记住三件非常重要的事情:</p><ol class=""><li id="e45b" class="oc od it kx b ky kz lb lc le oe li of lm og lq oh oi oj ok bi translated"><strong class="kx iu">在真正需要的时候进行优化<br/> </strong>如果代码不值得你花时间去优化，那就不要去优化，因为这样做不但不会使代码变得更快，反而有可能引入新的bug。</li><li id="5da5" class="oc od it kx b ky ol lb om le on li oo lm op lq oh oi oj ok bi translated"><strong class="kx iu">我们无法改进我们无法衡量的东西<br/> </strong>首先，我们必须选择我们想要优化的指标。之后，我们需要找到如何衡量它。目前，我们试图优化运行时间。在其他情况下，我们也可以选择优化内存使用。</li><li id="d77b" class="oc od it kx b ky ol lb om le on li oo lm op lq oh oi oj ok bi translated"><strong class="kx iu">优化瓶颈<br/>我们可以使用<code class="fe lr ls lt lu b">line-profiler</code>库来找到瓶颈。</strong></li></ol><p id="60da" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你可以从我的<a class="ae ku" href="https://colab.research.google.com/drive/1QREeU5FIsS2GIgRJJCz2QSGZG892LIR6" rel="noopener ugc nofollow" target="_blank"> Google Colab笔记本</a>中获取并运行上面的所有代码。从笔记本中，你可以看到我们如何分析一个类方法的例子。有一个例子可以说明如何分析触发函数调用的另一个函数。</p><p id="1a41" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">感谢阅读。希望这能帮助你在代码太慢的时候优化代码。如果您有任何建议或反馈，请留下评论或留言。</p></div></div>    
</body>
</html>