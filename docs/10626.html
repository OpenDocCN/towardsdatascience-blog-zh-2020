<html>
<head>
<title>Facial Data-Based Deep Learning: Emotion, Age and Gender Prediction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于面部数据的深度学习:情感、年龄和性别预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/facial-data-based-deep-learning-emotion-age-and-gender-prediction-47f2cc1edda7?source=collection_archive---------10-----------------------#2020-07-25">https://towardsdatascience.com/facial-data-based-deep-learning-emotion-age-and-gender-prediction-47f2cc1edda7?source=collection_archive---------10-----------------------#2020-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0f72f4a9e3ac3d50a333af037749fbb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_AtSOlTCnn9wcncW5cP1UQ.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">在<a class="ae jd" href="https://unsplash.com/s/photos/machine-learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae jd" href="https://unsplash.com/@_imkiran?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sai Kiran Anagani </a>拍摄的照片</p></figure><div class=""/><div class=""><h2 id="efde" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">我们如何利用深度学习从面部数据中提取信息？</h2></div><p id="336e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">深度学习在计算机视觉领域有着巨大的应用。计算机视觉的一些最重要的应用是在处理面部数据的领域。人脸检测和识别广泛应用于安全领域。如果您想探索这两个领域，请随意浏览:</p><ol class=""><li id="1f66" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><a class="ae jd" href="https://levelup.gitconnected.com/a-small-gui-application-based-on-computer-vision-and-python-imaging-libraries-using-opencv-e07b3f8c06c1" rel="noopener ugc nofollow" target="_blank">人脸检测</a>:在这篇文章中，我谈到了一个基于人脸检测的应用</li><li id="8c5b" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">人脸识别:这篇文章讲述了我们如何使用人脸识别来实现一个安全机制。</li></ol><p id="928b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的文章中，我已经尝试对这些机制是如何工作的给出了一个完整的解释。</p><p id="937c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将讨论基于面部的深度学习的另外两个最重要的应用，情感检测或面部表情检测，以及从面部图像预测年龄和性别。</p><p id="ce43" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，让我们直接开始吧。</p><h2 id="423d" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">情感检测</h2><p id="fe25" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">首先，让我们谈谈情绪检测或预测。</p><p id="38d3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这一部分，我们将使用<a class="ae jd" href="https://www.kaggle.com/shawon10/ckplus" rel="noopener ugc nofollow" target="_blank"> Kaggle 的 CKPlus 数据集</a>。</p><p id="6676" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">数据预处理</strong></p><p id="4254" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该数据集总共有 981 幅图像。这些图像根据七种不同的表情被分为七个标签:愤怒、轻蔑、厌恶、恐惧、快乐、悲伤和惊讶。每个表达式都有一个文件夹。因此，有七个文件夹存储 981 幅图像。</p><p id="96c5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们使用 listdir()按顺序列出类或文件夹。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="9110" class="mf mg jg ni b gy nm nn l no np"><strong class="ni jh">import</strong> <strong class="ni jh">os</strong><br/>files=os.listdir(fldr)<br/>&gt;&gt;<br/>['fear', 'contempt', 'happy', 'anger', 'surprise', 'disgust', 'sadness']</span><span id="49d8" class="mf mg jg ni b gy nq nn l no np">Exp=['fear', 'contempt', 'happy', 'anger', 'surprise', 'disgust', 'sadness']</span></pre><p id="6a97" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们将表达式按顺序保存在一个列表中，我们将参考该列表来创建标签。</p><p id="72d6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们对图像进行预处理。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="9151" class="mf mg jg ni b gy nm nn l no np"><strong class="ni jh">import</strong> <strong class="ni jh">cv2</strong><br/><strong class="ni jh">from</strong> <strong class="ni jh">google.colab.patches</strong> <strong class="ni jh">import</strong> cv2_imshow<br/>i=0<br/>last=[]<br/>images=[]<br/>labels=[]<br/><strong class="ni jh">for</strong> fle <strong class="ni jh">in</strong> files:<br/>  idx=Exp.index(fle)<br/>  label=idx<br/>  <br/>  total=fldr+'/'+fle<br/>  files_exp= os.listdir(total)</span><span id="6836" class="mf mg jg ni b gy nq nn l no np">  <strong class="ni jh">for</strong> fle_2 <strong class="ni jh">in</strong> files_exp:<br/>    file_main=total+'/'+fle_2<br/>    print(file_main+"   "+str(label))<br/>    image= cv2.imread(file_main)</span><span id="23d9" class="mf mg jg ni b gy nq nn l no np">    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)<br/>    image= cv2.resize(image,(48,48))<br/>    images.append(image)<br/>    labels.append(label)<br/>    i+=1<br/>  last.append(i)</span></pre><p id="c664" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码片段使用 OpenCV 打开并读取图像，将其尺寸调整为(48 x 48)尺寸。我已经把它转换成 RGB 图像，所以，它有三个通道。每个图像的大小为(48 x 48 x 3)。我们将在“图像”列表中添加图像，并在“标签”列表中添加相应的标签。让我们来可视化几个预处理后的例子。</p><div class="nd ne nf ng gt ab cb"><figure class="nr is ns nt nu nv nw paragraph-image"><img src="../Images/f58b4e51adec9e3a8e56ea1fab2ca8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:96/format:webp/1*XXX4tNWYdTk566pTCZYSXg.png"/></figure><figure class="nr is ns nt nu nv nw paragraph-image"><img src="../Images/9134fe5f687e5ff206e8f4554e4bde23.png" data-original-src="https://miro.medium.com/v2/resize:fit:96/format:webp/1*l7TEKU0rBA9zFI5B4QPEjA.png"/></figure><figure class="nr is ns nt nu nv nw paragraph-image"><img src="../Images/6bbd4d50bf40c38fbe2594680732299b.png" data-original-src="https://miro.medium.com/v2/resize:fit:96/format:webp/1*zCI28-O4sh9IHKNBDGdzww.png"/></figure></div><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="c9e1" class="mf mg jg ni b gy nm nn l no np"><strong class="ni jh">import</strong> <strong class="ni jh">tensorflow</strong> <strong class="ni jh">as</strong> <strong class="ni jh">tf</strong><br/><strong class="ni jh">from</strong> <strong class="ni jh">sklearn.model_selection</strong> <strong class="ni jh">import</strong> train_test_split<br/><strong class="ni jh">import</strong> <strong class="ni jh">numpy</strong> <strong class="ni jh">as</strong> <strong class="ni jh">np</strong><br/>images_f=np.array(images)<br/>labels_f=np.array(labels)</span><span id="79dd" class="mf mg jg ni b gy nq nn l no np">images_f_2=images_f/255<br/>labels_encoded=tf.keras.utils.to_categorical(labels_f,num_classes=num_of_classes)<br/>X_train, X_test, Y_train, Y_test= train_test_split(images_f_2, labels_encoded,test_size=0.25)</span></pre><p id="c87c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用上面的代码片段，我们将标签和图像转换为 NumPy 数组，并通过除以 255 来规范化图像数组。我使用了一键编码将标签编码成向量。我们将使用 25%的测试分割。</p><p id="1e24" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">型号</strong></p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="758e" class="mf mg jg ni b gy nm nn l no np"><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.layers</strong> <strong class="ni jh">import</strong> Dropout<br/><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.layers</strong> <strong class="ni jh">import</strong> Flatten,BatchNormalization<br/><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.layers</strong> <strong class="ni jh">import</strong> Dense, MaxPooling2D,Conv2D<br/><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.layers</strong> <strong class="ni jh">import</strong> Input,Activation,Add<br/><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.models</strong> <strong class="ni jh">import</strong> Model<br/><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.regularizers</strong> <strong class="ni jh">import</strong> l2<br/><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.optimizers</strong> <strong class="ni jh">import</strong> Adam</span><span id="886e" class="mf mg jg ni b gy nq nn l no np"><strong class="ni jh">def</strong> Convolution(input_tensor,filters):<br/>    <br/>    x = Conv2D(filters=filters,kernel_size=(3, 3),padding = 'same',strides=(1, 1),kernel_regularizer=l2(0.001))(input_tensor)<br/>    x = Dropout(0.1)(x)<br/>    x= Activation('relu')(x)</span><span id="cb32" class="mf mg jg ni b gy nq nn l no np">    <strong class="ni jh">return</strong> x<br/><strong class="ni jh">def</strong> model(input_shape):<br/>  inputs = Input((input_shape))<br/>  <br/>  conv_1= Convolution(inputs,32)<br/>  maxp_1 = MaxPooling2D(pool_size = (2,2)) (conv_1)<br/>  conv_2 = Convolution(maxp_1,64)<br/>  maxp_2 = MaxPooling2D(pool_size = (2, 2)) (conv_2)<br/>  conv_3 = Convolution(maxp_2,128)<br/>  maxp_3 = MaxPooling2D(pool_size = (2, 2)) (conv_3)<br/>  conv_4 = Convolution(maxp_3,256)<br/>  maxp_4 = MaxPooling2D(pool_size = (2, 2)) (conv_4)<br/>  flatten= Flatten() (maxp_4)<br/>  dense_1= Dense(128,activation='relu')(flatten)<br/>  drop_1=Dropout(0.2)(dense_1)<br/>  output= Dense(7,activation="sigmoid")(drop_1)</span><span id="3cde" class="mf mg jg ni b gy nq nn l no np">  model = Model(inputs=[inputs], outputs=[output])</span><span id="4550" class="mf mg jg ni b gy nq nn l no np">  model.compile(loss="categorical_crossentropy", optimizer="Adam",<br/>	metrics=["accuracy"])<br/>  <strong class="ni jh">return</strong> model</span></pre><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/02a9ec7b79360ad3ab9280f369430baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCYsrquKe4ZWMBEBrFMbnA.png"/></div></div></figure><p id="6bb6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用上述模型来预测表达式。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="f248" class="mf mg jg ni b gy nm nn l no np">History=Model.fit(X_train,Y_train,batch_size=32,validation_data=(X_test,Y_test),epochs=1000,callbacks=[callback_list])</span></pre><p id="c9e5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的片段将训练模型。</p><p id="00a4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该模型对测试数据给出了 100%的准确度。</p><blockquote class="ny nz oa"><p id="218d" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">注意:每当一个模型在测试数据上给出 100%的准确率时，我们需要检查训练准确率，如果那也是 100%的话。这意味着模型实际上是过度拟合的，测试集与训练集的分布非常接近。因此，它显示了巨大的成果。我认为在这种情况下，最好使用交叉验证来获得模型实际工作方式的正确直觉。</p></blockquote><p id="df0f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们继续评估。</p><p id="ee1a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">评价</strong></p><div class="nd ne nf ng gt ab cb"><figure class="nr is of nt nu nv nw paragraph-image"><img src="../Images/f989588035dac81e4e442704770ece39.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*moDsd6SFmHOBsIi8EOwqkA.png"/></figure><figure class="nr is of nt nu nv nw paragraph-image"><img src="../Images/bfa6e68a56d6d0aebcc55fb4740500a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*TsgqLR4QZJLuEs71WZr9jQ.png"/></figure></div><p id="eb61" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">两条曲线显示了模型的学习。第一条曲线显示了损失函数的下降，第二条曲线显示了精度随时期的增长。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="9c34" class="mf mg jg ni b gy nm nn l no np">Pred=Model.predict(X_test)<br/>Pred<br/>&gt;&gt;<br/>array([[1.68134073e-09, 5.25928086e-11, 5.46700324e-11, ...,         7.71565616e-01, 8.71616357e-05, 4.54742303e-06],        [5.06911943e-11, 5.20724059e-17, 2.85400745e-07, ...,         2.65912314e-12, 7.78120279e-01, 2.07833662e-14],        [5.95332267e-07, 7.41830490e-07, 1.73864496e-08, ...,         4.54492539e-01, 9.06203127e-07, 1.08237209e-05],        ...,        [1.56573861e-07, 3.44979071e-07, 3.86641860e-01, ...,         3.84031367e-08, 4.99448021e-08, 6.93729362e-13],        [1.91495033e-07, 7.53485918e-01, 1.24115175e-07, ...,         2.53645931e-06, 6.98523905e-09, 2.22882386e-06],        [5.07813091e-14, 1.79454021e-12, 1.35435105e-14, ...,         9.94049311e-01, 2.74002265e-09, 1.31444740e-08]], dtype=float32)</span></pre><p id="0449" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们获得如图所示的预测，让我们检查分类报告和混淆矩阵。</p><p id="bc0a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">分类报告:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="3196" class="mf mg jg ni b gy nm nn l no np">i=0 Y_test_l=[] <br/>Pred_l=[] <br/><strong class="ni jh">while</strong>(i&lt;len(Pred)):   <br/>  Y_test_l.append(int(np.argmax(Y_test[i])))     <br/>  Pred_l.append(int(np.argmax(Pred[i])))   <br/>  i+=1</span><span id="5611" class="mf mg jg ni b gy nq nn l no np">report=classification_report(Y_test_l, Pred_l)</span></pre><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi og"><img src="../Images/545a6fa0760e9154f277f1bc9ec2fd4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*U3cxf010pYjCObbhr-ZabQ.png"/></div></figure><p id="8058" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">混淆矩阵:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/42875145c1430384216302219a1cd87d.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*tOdw-ZMUHs_IxkilWzg9Cg.png"/></div></figure><p id="18f1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经看到了我们模型的混淆矩阵和分类报告。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="1f47" class="mf mg jg ni b gy nm nn l no np"><strong class="ni jh">def</strong> test_image(ind,images_f,images_f_2,Model):<br/>  cv2_imshow(images_f[ind])<br/>  image_test=images_f_2[ind]<br/>  print("Label actual:  " + Exp[labels[ind]]  )<br/>  pred_1=Model.predict(np.array([image_test]))<br/>  <em class="ob">#print(pred_1)</em><br/>  pred_class=Exp[int(np.argmax(pred_1))]<br/>  print("Predicted Label: "+ pred_class)</span></pre><p id="4ad5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的片段将让我们看看一些图像、它们的真实标签和预测标签。</p><div class="nd ne nf ng gt ab cb"><figure class="nr is oi nt nu nv nw paragraph-image"><img src="../Images/91f3de14d01b3b397d4a6a89d72d2e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*bdgjH3qLY5v3pdNK5IOpKw.png"/></figure><figure class="nr is oj nt nu nv nw paragraph-image"><img src="../Images/22b66ae1c37f63c0a9bffec397eb0737.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*WGz1MBUCoEALvjDZ_SM_Og.png"/></figure><figure class="nr is oi nt nu nv nw paragraph-image"><img src="../Images/70039916f067c31945c050a0559c9218.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/1*JKHsnzFIKvVtGrvlhISUqA.png"/></figure></div><div class="ab cb"><figure class="nr is ok nt nu nv nw paragraph-image"><img src="../Images/dbdd05f72063a3a383fa8e16ebe213b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*IKW1yPWsA4c8gYIXxTEV8g.png"/></figure><figure class="nr is ol nt nu nv nw paragraph-image"><img src="../Images/2e5ec8f9324e87e62c76d71bf3bf0829.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*PlGgyZT9_BPiexMl_YKsZw.png"/></figure><figure class="nr is om nt nu nv nw paragraph-image"><img src="../Images/6aa25561137369aa6bb7329013973672.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*04R1lnGgy0UhvODg7i9WMA.png"/></figure></div><p id="4328" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，我们已经看到了如何使用深度学习来预测情绪。让我们来看看年龄和性别预测。</p><h2 id="c30a" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">年龄和性别预测</h2><p id="47bf" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我们将使用 Kaggle 的<a class="ae jd" href="https://www.kaggle.com/jangedoo/utkface-new?" rel="noopener ugc nofollow" target="_blank"> UTKFace 数据集</a>来预测年龄和性别。</p><p id="27f1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">数据预处理</strong></p><p id="40b1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我使用了包含 9780 个文件的数据集。它有 9780 张年龄从 0 岁到 116 岁的男性和女性的人脸图片。每张图片都有标签显示相应的年龄和性别。男性由 0 给出，女性由 1 给出。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="ae8d" class="mf mg jg ni b gy nm nn l no np"><strong class="ni jh">import</strong> <strong class="ni jh">cv2</strong><br/>ages=[]<br/>genders=[]<br/>images=[]</span><span id="b3fa" class="mf mg jg ni b gy nq nn l no np"><strong class="ni jh">for</strong> fle <strong class="ni jh">in</strong> files:<br/>  age=int(fle.split('_')[0])<br/>  gender=int(fle.split('_')[1])<br/>  total=fldr+'/'+fle<br/>  print(total)<br/>  image=cv2.imread(total)</span><span id="4ca3" class="mf mg jg ni b gy nq nn l no np">  image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)<br/>  image= cv2.resize(image,(48,48))<br/>  images.append(image)<br/>  ages.append(age)<br/>  genders.append(gender)</span></pre><p id="c495" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码片段有助于获取数据和准备训练集。“图像”列表包含所有 9780 幅图像，每幅图像的大小为(48 x 48 x 3)。“年龄”列表具有相应的年龄,“性别”列表具有相应的性别。</p><p id="59ad" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看预处理后的图像。</p><div class="nd ne nf ng gt ab cb"><figure class="nr is of nt nu nv nw paragraph-image"><img src="../Images/3805c78b7fd6acdbbd361bbd8f91e362.png" data-original-src="https://miro.medium.com/v2/resize:fit:96/format:webp/1*w5EBuT-RGFR1qjgqTsyYlA.png"/></figure><figure class="nr is of nt nu nv nw paragraph-image"><img src="../Images/1dbb5c1bb1dc6efd0ead6ab3863b1a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:96/format:webp/1*-X6bBfuffhlFAYerR1vcLw.png"/><p class="iz ja gj gh gi jb jc bd b be z dk on di oo op translated">第一幅图像的年龄为 62 岁，性别为 0，第二幅图像的年龄为 67 岁，性别为 0</p></figure></div><p id="6083" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们需要检查我们的集合的分布。</p><div class="nd ne nf ng gt ab cb"><figure class="nr is oq nt nu nv nw paragraph-image"><img src="../Images/dffe4db91d6773e2c0d9335590f47445.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*PF4Yko07l6ouLdSMdH_MFQ.png"/></figure><figure class="nr is or nt nu nv nw paragraph-image"><img src="../Images/3d1cba81cd2df138fcacce0b5a2699c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*rQ-p9DcTwlEViFqN6BbAJw.png"/></figure></div><p id="3cad" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一个条形图显示了性别分布。它看起来很平衡。第二个线形图显示了不同年龄样本的变化。我们可以看到年龄小于 40 的样本比年龄大于 40 的样本数量要多得多。这造成了训练集分布的偏斜。</p><p id="ccf9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经看到，在这种情况下，我们实际上需要使用相同的模型来预测年龄和性别。因此，要为我们的训练集创建实际的标签，我们需要做一些处理。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="c5ee" class="mf mg jg ni b gy nm nn l no np">labels=[]</span><span id="7ca4" class="mf mg jg ni b gy nq nn l no np">i=0<br/><strong class="ni jh">while</strong> i&lt;len(ages):<br/>  label=[]<br/>  label.append([ages[i]])<br/>  label.append([genders[i]])<br/>  labels.append(label)<br/>  i+=1</span></pre><p id="62d8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码片段按索引方式获取每个图像样本的年龄和性别，并将每个样本转换成一个列表，并将它们附加到标签列表中。这样做是为了创建一维标签向量。</p><p id="04d4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此,“标签”列表的形状将是:</p><blockquote class="ny nz oa"><p id="73a5" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">[[[年龄(1)]，[性别(1)]，</p><p id="80ee" class="kv kw ob kx b ky kz kh la lb lc kk ld oc lf lg lh od lj lk ll oe ln lo lp lq ij bi translated">[[年龄(2)]，[性别(2)]，………………。[[年龄(n)]，[性别(n)]]]</p></blockquote><p id="e339" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将标签和图像列表转换成 NumPy 数组，规范化图像，并创建训练和测试数据分割。我们将使用 25%的测试分割。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="21f9" class="mf mg jg ni b gy nm nn l no np">images_f=np.array(images)<br/>labels_f=np.array(labels)<br/>images_f_2=images_f/255<br/>X_train, X_test, Y_train, Y_test= train_test_split(images_f_2, labels_f,test_size=0.25)</span></pre><p id="680f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">目前，我们的 Y_train 和 Y_test 的形式为:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="1611" class="mf mg jg ni b gy nm nn l no np">Y_train[0:5]<br/>&gt;&gt;array([[[36],<br/>        [ 0]],</span><span id="ca49" class="mf mg jg ni b gy nq nn l no np">       [[50],<br/>        [ 0]],</span><span id="634f" class="mf mg jg ni b gy nq nn l no np">       [[65],<br/>        [ 0]],</span><span id="7d31" class="mf mg jg ni b gy nq nn l no np">       [[ 3],<br/>        [ 0]],</span><span id="ebb7" class="mf mg jg ni b gy nq nn l no np">       [[25],<br/>        [ 1]]])</span></pre><p id="554c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要对它们进行转换，使 Y_train[0]表示性别标签向量，Y_train[1]表示年龄标签向量。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="0be4" class="mf mg jg ni b gy nm nn l no np">Y_train_2=[Y_train[:,1],Y_train[:,0]]<br/>Y_test_2=[Y_test[:,1],Y_test[:,0]]</span></pre><p id="d103" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个简单的代码片段为我们做了工作。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="c1cf" class="mf mg jg ni b gy nm nn l no np">Y_train_2[0][0:5]<br/>&gt;&gt;array([[0],<br/>       [0],<br/>       [0],<br/>       [0],<br/>       [1]])<br/>Y_train_2[1][0:5]<br/>&gt;&gt;array([[36],<br/>       [50],<br/>       [65],<br/>       [ 3],<br/>       [25]])</span></pre><p id="cd43" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们准备开始设计我们的模型。</p><p id="7136" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">型号</strong></p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="9bfc" class="mf mg jg ni b gy nm nn l no np"><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.layers</strong> <strong class="ni jh">import</strong> Dropout<br/><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.layers</strong> <strong class="ni jh">import</strong> Flatten,BatchNormalization<br/><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.layers</strong> <strong class="ni jh">import</strong> Dense, MaxPooling2D,Conv2D<br/><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.layers</strong> <strong class="ni jh">import</strong> Input,Activation,Add<br/><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.models</strong> <strong class="ni jh">import</strong> Model<br/><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.regularizers</strong> <strong class="ni jh">import</strong> l2<br/><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.optimizers</strong> <strong class="ni jh">import</strong> Adam<br/><strong class="ni jh">import</strong> <strong class="ni jh">tensorflow</strong> <strong class="ni jh">as</strong> <strong class="ni jh">tf</strong></span><span id="07e2" class="mf mg jg ni b gy nq nn l no np"><strong class="ni jh">def</strong> Convolution(input_tensor,filters):<br/>    <br/>    x = Conv2D(filters=filters,kernel_size=(3, 3),padding = 'same',strides=(1, 1),kernel_regularizer=l2(0.001))(input_tensor)<br/>    x = Dropout(0.1)(x)<br/>    x= Activation('relu')(x)</span><span id="2e18" class="mf mg jg ni b gy nq nn l no np">    <strong class="ni jh">return</strong> x<br/><strong class="ni jh">def</strong> model(input_shape):<br/>  inputs = Input((input_shape))<br/>  <br/>  conv_1= Convolution(inputs,32)<br/>  maxp_1 = MaxPooling2D(pool_size = (2,2)) (conv_1)<br/>  conv_2 = Convolution(maxp_1,64)<br/>  maxp_2 = MaxPooling2D(pool_size = (2, 2)) (conv_2)<br/>  conv_3 = Convolution(maxp_2,128)<br/>  maxp_3 = MaxPooling2D(pool_size = (2, 2)) (conv_3)<br/>  conv_4 = Convolution(maxp_3,256)<br/>  maxp_4 = MaxPooling2D(pool_size = (2, 2)) (conv_4)<br/>  flatten= Flatten() (maxp_4)<br/>  dense_1= Dense(64,activation='relu')(flatten)<br/>  dense_2= Dense(64,activation='relu')(flatten)<br/>  drop_1=Dropout(0.2)(dense_1)<br/>  drop_2=Dropout(0.2)(dense_2)<br/>  output_1= Dense(1,activation="sigmoid",name='sex_out')(drop_1)<br/>  output_2= Dense(1,activation="relu",name='age_out')(drop_2)<br/>  model = Model(inputs=[inputs], outputs=[output_1,output_2])<br/>  model.compile(loss=["binary_crossentropy","mae"], optimizer="Adam",<br/>	metrics=["accuracy"])<br/>  <br/>  <strong class="ni jh">return</strong> model</span></pre><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi os"><img src="../Images/3761947b960609582a5e5c1d9f079353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-UnGHUO21vt8Nsvb5fESHw.png"/></div></div></figure><p id="20b8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用上述模型来预测性别和年龄</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/bb21dcc627a73ad1fdc972531d86be8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*950zDfLK9dT1h4P97T1O7g.png"/></div></figure><p id="19d1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以上是我们模型的示意图。在“展平”层之后，我们将使用两个不同的致密层和对应于相应输出的漏失。现在，性别预测是一个分类问题，而年龄预测是一个回归问题，所以，我们将使用 sigmoid 作为性别预测的输出激活，ReLU 作为年龄预测的激活函数。类似地，我们将使用“二元交叉熵”作为性别的损失函数，使用“平均绝对误差”作为年龄的损失函数。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="b323" class="mf mg jg ni b gy nm nn l no np"><strong class="ni jh">from</strong> <strong class="ni jh">tensorflow.keras.callbacks</strong> <strong class="ni jh">import</strong> ModelCheckpoint <strong class="ni jh">import</strong> <strong class="ni jh">tensorflow</strong> <strong class="ni jh">as</strong> <strong class="ni jh">tf<br/></strong>fle_s='Age_sex_detection.h5'<br/>checkpointer = ModelCheckpoint(fle_s, monitor='val_loss',verbose=1,save_best_only=<strong class="ni jh">True</strong>,save_weights_only=<strong class="ni jh">False</strong>, mode='auto',save_freq='epoch')<br/>Early_stop=tf.keras.callbacks.EarlyStopping(patience=75, monitor='val_loss',restore_best_weights=<strong class="ni jh">True</strong>),<br/>callback_list=[checkpointer,Early_stop]<br/>History=Model.fit(X_train,Y_train_2,batch_size=64,validation_data=(X_test,Y_test_2),epochs=500,callbacks=[callback_list])</span></pre><p id="e446" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的片段将训练模型。</p><p id="c776" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该模型给出了 82%的性别分类准确率。</p><p id="6f98" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">评价</strong></p><p id="60ee" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看模型的损失曲线。</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/ab5ac01c0fe85c8149dc0d82756943d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*ie7vU9RLJFrMKVosxHlDvg.png"/></div></figure><p id="e4fe" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我们的模型生成的损失曲线。</p><p id="774a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看对年龄预测的评估:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/9b8ad132934ac2c9005685cc223e745e.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*2J4M9ZOvK5aeFxxshoy54w.png"/></div></figure><p id="acdd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上述曲线显示了黑色的模型跟踪线性回归线，蓝点显示了测试样品的分布。所以，我们可以看到我们的预测线几乎穿过了分布的中间。在 80 岁以上，样本很少，所以，可能由于这个原因，我们的模型表现得不是很好。</p><p id="019a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">性别预测评估:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/bf09abd77220baaaa1c985cafc0b2cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*PgPFR1uJ0D35rhnX1H-LeQ.png"/></div></figure><p id="c504" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的曲线显示了性别准确性随时代的增加。</p><p id="d397" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">性别分类的分类矩阵:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/a2a3f002e240849dd00000aebb46a690.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*5TVBsFrXeP3nYmo7661b1w.png"/></div></figure><p id="45c9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的模型获得了女性 0.84 和男性 0.78 的 F1 分数。所以，它对女性的分类比男性好。</p><p id="64f1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看我们集合中的一些样本及其相应的预测年龄和性别。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="90f7" class="mf mg jg ni b gy nm nn l no np"><strong class="ni jh">def</strong> test_image(ind,images_f,images_f_2,Model):       cv2_imshow(images_f[ind])   <br/>image_test=images_f_2[ind]   pred_1=Model.predict(np.array([image_test]))  <br/><em class="ob">#print(pred_1)</em>   <br/>sex_f=['Male','Female']   <br/>age=int(np.round(pred_1[1][0]))   <br/>sex=int(np.round(pred_1[0][0]))   <br/>print("Predicted Age: "+ str(age))   <br/>print("Predicted Sex: "+ sex_f[sex])</span></pre><p id="7384" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码片段有助于生成我们的示例:</p><div class="nd ne nf ng gt ab cb"><figure class="nr is ox nt nu nv nw paragraph-image"><img src="../Images/052f4730c16df67ec182697590bc6593.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*v2682w6mdgpaS1j722PKyQ.png"/></figure><figure class="nr is oy nt nu nv nw paragraph-image"><img src="../Images/3149880cdfd1e5cfe640428f3dddfb1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*EBIxi35docowjcPqygFDhw.png"/></figure></div><div class="ab cb"><figure class="nr is oz nt nu nv nw paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/b21918aa985878dedb14841112518337.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*5Ggj31oapdKmcwKSXUcLHg.png"/></div></figure><figure class="nr is pa nt nu nv nw paragraph-image"><img src="../Images/bf945037aa84c0deb896374eb6c798d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*Y2JAJ1PJ7We-AVHam3lg4A.png"/></figure></div><p id="ce3f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于最后一个样本，实际年龄标签是 62，预测年龄标签是 60。</p><p id="4152" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们可以使用面部数据来预测性别和年龄。</p><h2 id="76bf" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">结论</h2><p id="6b51" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在本文中，我们已经看到了如何从面部图像中预测情感、性别和性。</p><p id="e918" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GitHub 链接在这里是<a class="ae jd" href="https://github.com/abr-98/Face_data_based_deeplearning" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="6904" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望这篇文章有所帮助。</p></div></div>    
</body>
</html>