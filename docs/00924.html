<html>
<head>
<title>Model Lift — the missing link</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模型提升——缺失的一环</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/model-lift-the-missing-link-70eb37460e67?source=collection_archive---------8-----------------------#2020-01-27">https://towardsdatascience.com/model-lift-the-missing-link-70eb37460e67?source=collection_archive---------8-----------------------#2020-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/73af0c49c6b73c596762359a96ef1396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZExtj1DhQ24_oCX1L1wpQ.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">安杰伊·西曼斯基</p></figure><div class=""/><div class=""><h2 id="835f" class="pw-subtitle-paragraph kd je jf bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">如何向非技术观众谈论机器学习的结果</h2></div><p id="ac6a" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数据建模成功的一半是利益相关者/受众对我们模型的理解。关键是要理解他们的期望，并在我们的演示中使用简单的语言，让非技术人员也能理解。通常，受众是希望在某种交叉销售或保留活动中使用该模型的营销和/或财务团队成员。他们通常更感兴趣的是模型能在多大程度上提高竞选绩效，而不是模型本身有多好。这是一个微妙的区别，我将在稍后解释。</p><p id="a420" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为数据科学家，我们倾向于关注模型的整体性能，并通过使用ROC曲线和混淆矩阵来说明模型在区分积极和消极方面有多好。然而，这并不总是最好的方法。</p><p id="94ca" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jg">对模型在现实生活中如何部署的理解是关键点，它决定了应该如何评估模型。</strong></p><p id="5cca" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在识别欺诈行为、建立信用记分卡或识别癌症患者时，ROC是一种非常好的评估方法。在这些情况下，我们需要正确识别每个现有的或新的记录。</p><p id="9772" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，在市场营销或政治环境中，大多数活动只针对我们基础中的一个狭窄群体——那些对信息最开放的群体(<strong class="kx jg">目标群体</strong>)。因此，当务之急是了解模型在该组中的表现。组外的表现无关紧要。所以用评估整个基数的ROC，不一定是最好的选择。</p><p id="c626" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">其次</em>，我们的观众可能不理解一个混淆矩阵或者ROC。对他们来说，等于0.6或0.75的AUC是一个抽象的、无关紧要的数字。谈论特异性和敏感性是行不通的。我们必须开始用和我们的观众相同的频率广播，用他们自己的语言说话。需要调整的是我们，不是他们！请记住，你在那里不是要用你的知识给他们留下深刻印象，而是要传递一个关于你的模型的发现的明确信息。这条信息应该在几秒钟内就能被理解。为了实现这一点，我们需要比ROC更容易理解的东西，以及我们可以容易地对其进行估价的东西。这就是模特升降机的闪光点。</p><figure class="lt lu lv lw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ls"><img src="../Images/139813683fbfc38c21a05049be798bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbGeIKfZX2GjVhL3UlK8jw.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">来源:ADOBE STOCK</p></figure><blockquote class="lx ly lz"><p id="386f" class="kv kw lr kx b ky kz kh la lb lc kk ld ma lf lg lh mb lj lk ll mc ln lo lp lq ij bi translated">天才的定义是化繁为简<br/> <em class="jf">阿尔伯特·爱因斯坦</em></p></blockquote><p id="6eb4" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">模型提升告诉我们，通过使用我们的模型，我们可以在多大程度上改进活动。它告诉我们，在我们的选择中找到阳性(<em class="lr">商品</em>)的几率有多大，与随机找到它们相比如何？使用我们的模型和随机选择的成功率的比较是模型提升。</p><p id="4ae2" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">模型提升的好处在于，我们可以立即为我们的模型分配财务价值。如果我们的前十分位数中的模型提升相等，例如等于3，我们可以说，使用我们模型的前十分位数，该活动可以产生比基于随机选择的活动多3倍的收入。模型提升基本上是投资回报(ROI)，其中投资是我们建立的模型。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="b33f" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要获得模型提升，我们需要遵循以下步骤:</p><ul class=""><li id="cdd5" class="mk ml jf kx b ky kz lb lc le mm li mn lm mo lq mp mq mr ms bi translated">获取我们数据库中每个记录的模型概率得分。</li><li id="9f66" class="mk ml jf kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">使用概率分数对基础进行排序，并将其分成相等的组。十分位数似乎是最常见的选择，因此，在本文的其余部分，我将把这些组称为十分位数。</li><li id="41df" class="mk ml jf kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">计算每十分位数中阳性反应的比例(<strong class="kx jg"> <em class="lr">十分位数反应率</em> </strong>)</li></ul><figure class="lt lu lv lw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/25d74f6ee69ddf9faad1560326e83534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHTxyPXQcwrcBEO6KQn1nA.png"/></div></div></figure><ul class=""><li id="ea5b" class="mk ml jf kx b ky kz lb lc le mm li mn lm mo lq mp mq mr ms bi translated">计算<strong class="kx jg"> <em class="lr">平均响应率</em> </strong></li></ul><figure class="lt lu lv lw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/f20413347e0607cd4e78e9b4833cc6d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWb3DEUd_hUq28Qorzcf4A.png"/></div></div></figure><ul class=""><li id="c118" class="mk ml jf kx b ky kz lb lc le mm li mn lm mo lq mp mq mr ms bi translated">计算<strong class="kx jg"> <em class="lr">模型升力</em> </strong></li></ul><figure class="lt lu lv lw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/a11852084bea9da85bcce092dcea6a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pG7D60HL_B6jg3cmFridw.png"/></div></div></figure><p id="a1bf" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了说明这一点，让我们以一家葡萄牙银行的直接营销活动为例。数据来自<a class="ae mz" href="http://archive.ics.uci.edu/ml/index.php" rel="noopener ugc nofollow" target="_blank"> UCI机器学习库</a>并且在这里<a class="ae mz" href="https://raw.githubusercontent.com/madmashup/targeted-marketing-predictive-engine/master/banking.csv" rel="noopener ugc nofollow" target="_blank">可用。在运行数据清理、特征减少和重采样之后，我最终得到了这个数据集。包括数据清理在内的完整代码可以在</a><a class="ae mz" href="https://github.com/AndrzejSzymanski/TDS/blob/master/Model%20Lift.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我们的目标是找出有可能对报价做出积极回应的客户。我们的因变量是y，其中1=阳性反应(阳性)，0 =无/阴性反应(阴性)。</p><p id="963b" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数据集中的一个要素(呼叫持续时间)导致数据泄漏。通话时间可能是购买的结果，而不是购买的原因。第二，它是未知的，直到活动的数据被选择和调用。因此，它应该从选择用于建模的数据中排除。然而，由于我想专注于模型提升本身，我决定保留数据集中的所有变量。</p><p id="dd4b" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们需要将数据分成训练样本和测试样本</p><pre class="lt lu lv lw gt na nb nc nd aw ne bi"><span id="ff8a" class="nf ng jf nb b gy nh ni l nj nk">df= pd.read_csv('banking_campaign.csv')</span><span id="46af" class="nf ng jf nb b gy nl ni l nj nk">X = df.iloc[:,1:]<br/>y = df.iloc[:,0]</span><span id="472f" class="nf ng jf nb b gy nl ni l nj nk">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)</span></pre><p id="2463" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我选择了梯度推进建模</p><pre class="lt lu lv lw gt na nb nc nd aw ne bi"><span id="0afe" class="nf ng jf nb b gy nh ni l nj nk">from sklearn.ensemble import GradientBoostingClassifier<br/>from sklearn.metrics import classification_report</span><span id="6b86" class="nf ng jf nb b gy nl ni l nj nk">GBM = GradientBoostingClassifier(learning_rate=0.01, <br/>                                      n_estimators=1000,<br/>                                      max_depth=6, <br/>                                      min_samples_split=50, <br/>                                      min_samples_leaf=25, <br/>                                      subsample=0.8,<br/>                                      max_features=10, <br/>                                      random_state=10)<br/>GBM.fit(X_train,y_train)<br/>predictors=list(X_train)</span></pre><p id="8d91" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们简单看一下整体模型性能。</p><pre class="lt lu lv lw gt na nb nc nd aw ne bi"><span id="270b" class="nf ng jf nb b gy nh ni l nj nk">print('Accuracy of the GBM on test set: {:.3f}'.format(GBM.score(X_test, y_test)))<br/>pred=GBM.predict(X_test)<br/>print(classification_report(y_test, pred))<br/>from sklearn.metrics import roc_auc_score<br/>print (roc_auc_score(y_test, pred))</span></pre><figure class="lt lu lv lw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/66ca7599934b9097398f667805f43715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QXj6koLYjrnWteyPtPbBag.png"/></div></div></figure><p id="c85b" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该模型的ROC AUC得分为<strong class="kx jg"> 0.75 </strong>，但我们忽略它。</p><p id="b670" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">获得模型提升的第一步是获得概率。为此，我们使用<em class="lr"> predict_proba </em>。</p><pre class="lt lu lv lw gt na nb nc nd aw ne bi"><span id="dc79" class="nf ng jf nb b gy nh ni l nj nk">y_pred2=GBM.predict_proba(X_test)</span></pre><p id="da31" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jg"> y_pred2 </strong>中的第一个值是概率0(负数)，第二个值是概率1(正数)。</p><figure class="lt lu lv lw gt is gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5273078a8ad2172845f90442d1db515d.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*O4NuIMDiPUZUP-jVRDoOIw.png"/></div></figure><p id="d2da" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要计算模型提升，运行下面的代码。该代码生成一个pandas数据框，用于模型的最终评估和构建图形演示。</p><figure class="lt lu lv lw gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="93e3" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你需要做的是调用函数，指定你的测试因变量(y_test)，它的预测概率(y_pred2)和你想把基数分成的组数(我决定用十分位数，所以10)。</p><pre class="lt lu lv lw gt na nb nc nd aw ne bi"><span id="18bc" class="nf ng jf nb b gy nh ni l nj nk">ModelLift=lift(y_test,y_pred2,10)</span></pre><p id="4627" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出如下所示:</p><figure class="lt lu lv lw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/b4ee66bce8dd9a249e11d594a88c1fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6awPi-4P-AqO3a92Tg1NJw.png"/></div></div></figure><p id="8f26" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jg"> Scr_grp </strong>代表我们的十分位数，使用概率分数进行分类和拆分。现在我们可以比较积极和消极在十分位数中的分布。你可以看到，随着我们越来越接近十分位数，阳性反应的数量越来越少。十分位数1中有800例阳性，而十分位数10中只有1例阳性！这意味着我们的模型正在做正确的工作。</p><p id="eddd" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以计算响应率(<strong class="kx jg"> resp_rate </strong>)。应答率是十分位数中阳性的比例。对于十分位数1，它是800/(800+436)=0.65。同样，你可以看到在十分位数组中，回复率迅速下降。</p><p id="fd0c" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们需要计算<strong class="kx jg">升力</strong>。为此，我们需要测试组中阳性和阴性的总体比例，即:1376/12357 = 0.11。现在十分位数1的升程是5.84 (0.65/0.11)。这意味着基于十分之一选择的活动比基于随机选择的活动成功5.84倍。</p><p id="5746" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">表格中的其他特征有:<br/> cmltv_p_perc:累积阳性百分比<br/> cmltv_n_perc:累积阴性百分比<br/> cmltv_rand_p_perc:累积随机阳性百分比<br/> cmltv_resp_rate:累积响应率<br/> cmltv_lift:累积lift <br/> KS: Kolmogorov-Smirnov测试</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="41f6" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在比较这两条消息:</p><figure class="lt lu lv lw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/5708e9f65e0e0d8f9bac1f7faa36d65a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJAn9y77oLxm6bayJhf6VQ.png"/></div></div></figure><h1 id="1dcf" class="ns ng jf bd nt nu nv nw nx ny nz oa ob km oc kn od kp oe kq of ks og kt oh oi bi translated">和...相对</h1><figure class="lt lu lv lw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oj"><img src="../Images/9a9c631607bdac94a07b827bc8ba6317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8wA3ZNndKNvquOFAwVFDJw.png"/></div></div></figure><p id="a885" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，你告诉我我们的观众会对哪条消息感到兴奋！</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="34ce" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建一个图表是传递信息的最好方式，但是观众应该能够在几秒钟内掌握这个想法。因此，我会避免任何更复杂的东西，比如增益图。</p><p id="7476" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">展示结果时，我们需要回答三个问题:</p><ol class=""><li id="d35f" class="mk ml jf kx b ky kz lb lc le mm li mn lm mo lq ok mq mr ms bi translated">模型有效吗？</li><li id="5795" class="mk ml jf kx b ky mt lb mu le mv li mw lm mx lq ok mq mr ms bi translated">选择和模型性能有什么关系？</li><li id="337e" class="mk ml jf kx b ky mt lb mu le mv li mw lm mx lq ok mq mr ms bi translated">最优选择是什么？</li></ol><p id="1246" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们稍微调整一下输出。我将dataframe索引改成了更具信息性的内容，比如Decile1到10，并且只选择了范围内的变量。</p><pre class="lt lu lv lw gt na nb nc nd aw ne bi"><span id="c32d" class="nf ng jf nb b gy nh ni l nj nk">dec = ['Decile 1','Decile 2','Decile 3','Decile 4','Decile 5','Decile 6','Decile 7','Decile 8','Decile 9','Decile 10',]<br/>MLift=ModelLift[['Positives','Negatives','cmltv_lift','KS']].copy()<br/>MLift.index = (dec)</span></pre><p id="e25e" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用下面的代码，我们可以很快看到模型是如何工作的。</p><pre class="lt lu lv lw gt na nb nc nd aw ne bi"><span id="c723" class="nf ng jf nb b gy nh ni l nj nk">import cufflinks as cf<br/>cf.go_offline()<br/>cf.set_config_file(offline=False, world_readable=True)</span><span id="b1aa" class="nf ng jf nb b gy nl ni l nj nk">MLift[['Positives','Negatives']].iplot(kind='bar',yTitle='Volume',xTitle='Model decile', title='Positives &amp; Negatives by model decile')</span></pre><figure class="lt lu lv lw gt is"><div class="bz fp l di"><div class="ol np l"/></div></figure><p id="0fa3" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">选择大小和性能之间的关系可以使用累积提升来确定。</p><pre class="lt lu lv lw gt na nb nc nd aw ne bi"><span id="3486" class="nf ng jf nb b gy nh ni l nj nk">MLift[['cmltv_lift']].iplot(kind='bar',color='LightSkyBlue',yTitle='Lift',xTitle='Model decile', title='Cumulative Lift', yrange=[1.11, 6])</span></pre><figure class="lt lu lv lw gt is"><div class="bz fp l di"><div class="ol np l"/></div></figure><p id="f84e" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着目标群体的增加，我们可以期待更小的ROI(模型提升)。例如，如果我们决定同时使用十分位数1和2，ROI将从5.84(仅十分位数1)下降到2.87。尽管如此，这项活动将会比随机选择成功将近3倍！</p><p id="66b5" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用Kolmogorov-Smirnov测试确定最佳选择，该测试用简单的语言评估累积阳性和累积阴性之间的差异。这个测试在我们的数据中找到一个点，在这个点上我们可以用最小的负值得到最大的正值。为了说明这一点，我曾经建立增益图，但我改变了主意，我现在认为条形图更容易阅读！</p><pre class="lt lu lv lw gt na nb nc nd aw ne bi"><span id="ebf9" class="nf ng jf nb b gy nh ni l nj nk">MLift[['KS']].iplot(kind='bar',color='DarkSlateGrey', yTitle='Separation',xTitle='Model decile', title='Target separation')</span></pre><figure class="lt lu lv lw gt is"><div class="bz fp l di"><div class="ol np l"/></div></figure><p id="c809" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，最好的分割是大约十分位数2和3。在这一点上，我们已经得到了最大的积极因素和最小的消极因素。这是我们可以使用我们的模型实现收入最大化的点。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="d45c" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">概括地说，模型升力优于ROC的3个主要优点是:</p><p id="a2fa" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">即使是一个普通的模型仍然可以提供一些价值，并对营销活动做出重要贡献。</p><p id="7239" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">模型提升可以直接转化为收入。</p><p id="b8b0" class="pw-post-body-paragraph kv kw jf kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">模型提升容易理解，比混淆矩阵更少混淆！</p></div></div>    
</body>
</html>