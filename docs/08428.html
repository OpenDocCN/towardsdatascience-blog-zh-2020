<html>
<head>
<title>Parallelization caveats in R #1: performance issues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R #1中的并行化警告:性能问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/parallelization-caveats-in-r-1-the-basics-multiprocessing-and-multithreading-performance-eb584b7e850e?source=collection_archive---------13-----------------------#2020-06-19">https://towardsdatascience.com/parallelization-caveats-in-r-1-the-basics-multiprocessing-and-multithreading-performance-eb584b7e850e?source=collection_archive---------13-----------------------#2020-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bb34" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">R中的多处理的介绍，以及一些很难注意到但可能严重影响性能的缺陷。</h2></div><blockquote class="ki kj kk"><p id="55be" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="ko iu">关于这部作品</strong>。我以一篇独立的文章开始这篇文章，总结我在研究项目中遇到的并行处理问题。在看到这篇文章变得相当长之后，我决定将它分成多个部分，每个部分涵盖一种特定的陷阱，在最好的情况下，这些陷阱会导致错误，或者在最坏的情况下，会导致明显的糟糕性能或看不见的后果。因此，您将[有希望]看到多篇文章，这些文章涵盖了这些陷阱以及我已经成功应用于解决我的问题的解决方案。本文讨论基本的设置和可能的性能问题。</p></blockquote><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/f2f6526113e90e4c6cc82590032cd733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*69Bg5HWn7Q6xgj7LtzWp9Q.jpeg"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated"><a class="ae ly" href="https://unsplash.com/@artisanalphoto" rel="noopener ugc nofollow" target="_blank">手工摄影</a>在<a class="ae ly" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="813a" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">我们大多数人在工作中都遇到过代码速度不够快的情况，因为它只使用了一个CPU内核，需要几个小时才能完成。为了解决这个问题，我们求助于传统的多重处理技术，希望它能弥补我们计算的缓慢。然后，在快得多的30分钟的运行结束时，我们看到一个错误，它根本没有告诉我们哪里出错了，可能类似于<code class="fe mc md me mf b">Error reading from connection 7</code>(如果您来自搜索引擎，这不是涵盖这个特定错误消息的文章)。在本系列中，我将总结我在R中的并行性经验，并尝试指出在并行计算中可能会出错的地方。我不会深入讨论并行处理是如何工作的——尽管我将尝试至少定义我所使用的概念——本系列旨在收集在决定切换到并行模式时需要考虑和注意的事情。</p><p id="efb4" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">在第一部分中，我将谈论<em class="kn">为什么</em>我们会转向并行工作流(只是为了给我们一点动力)，然后我将展示一些在R中实现它的技术，最后我们将开始组合它们以在我们的计算机上释放完全的混乱，我们将看到为什么这个或那个不应该一起使用，或者为什么以某种方式做某事会减慢您的计算。好吧，也许我有点太戏剧化了，但是我最近设法冻结了一个32核服务器，给了它太多的事情去做——当然是不情愿的。</p><p id="a63a" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">最终，我决定写这些文章，因为我自己在编写代码时遇到了这些问题，而且没有现成的食谱(至少我还没有找到一本)可以指出我犯的错误——有些可能是语言或特定于包的错误，但大多数错误很难找出——并给我一些如何解决它们的建议。虽然本系列的大部分内容包含特定于R的建议，但我将要讨论的一些问题是语言不可知的，这意味着如果您使用MATLAB或Python或Assembly (hah)来做类似的工作，您可能会面临与我相同的问题。还要注意，我不是并行化大师(既不是<em class="kn">也不是</em>的R大师)，所以如果您发现什么不正确的地方或者需要更好的解释，请不要犹豫，告诉我！</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mg"><img src="../Images/a092e8184c5fd844b762c9558263cbdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rn4RukhEwd3ePZMjgLdF5A.jpeg"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">四个任务的顺序执行和并行执行的简化(理想)图(图片由作者提供)</p></figure><h1 id="3558" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">简介:“为什么还要并行？”</h1><p id="e52e" class="pw-post-body-paragraph kl km it ko b kp mz ju kr ks na jx ku lz nb kx ky ma nc lb lc mb nd lf lg lh im bi translated">你是否尝试过执行一个包含一些复杂数学运算的长循环？就像一系列的矩阵求逆，其结果被相乘，多个函数被调用，甚至可能解决一些二次优化问题，等等？如果你在代码运行的时候打开了任务管理器(或者在你喜欢的操作系统上打开了它),你可能会发现R进程并没有完全使用你的全部处理能力，而只是使用了一小部分。CPU使用百分比可以从大约50%(在2核CPU上)到4–5%(在24个[逻辑]核上)不等。你可能会问一个关键的问题:</p><blockquote class="ne"><p id="8743" class="nf ng it bd nh ni nj nk nl nm nn lh dk translated">如果R使用了我100%的CPU，我的计算不会运行得更快吗？</p></blockquote><p id="badf" class="pw-post-body-paragraph kl km it ko b kp no ju kr ks np jx ku lz nq kx ky ma nr lb lc mb ns lf lg lh im bi translated">答案很不幸只是:<em class="kn">大概是</em>。看，在我们开始让我们的代码使用更多的CPU之前，我们必须了解一些关于我们如何计算的事情，更重要的是，<em class="kn">我们的计算结果是否相互依赖</em>。一般来说，如果你有两个相互依赖的任务，那些<em class="kn">不能</em>并行执行(如果没有第一个的结果，第二个会怎么做？).否则，如果你的任务不相互依赖，它们可能<em class="kn">并行运行。你也可以把你的任务想象成一个<code class="fe mc md me mf b">for</code>循环的主体:如果你需要来自前一次迭代的数据，那就不能并行运行。</em></p><p id="cef6" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">为了创建一个更实际的例子，我们将计算矩阵行的总和。是的，有一个叫做<code class="fe mc md me mf b">rowSums</code>的函数可以更快地完成这项工作(你应该使用它来代替下面的实现)，但是这个例子应该足够简单来帮助我们理解基础知识。有一种方法可以做到这一点:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="479b" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">这段代码将计算矩阵中每一行的总和，并将其存储在<code class="fe mc md me mf b">results</code>向量中(请尽量避免像这样分配向量，因为它们将不得不动态增长，这是很昂贵的，一个额外的提示是使用<code class="fe mc md me mf b">results = numeric(nrow(bigMatrixWithLotsOfData))</code>来代替——假设您<em class="kn">知道</em>结果将是数字)。因此，我们将依次计算每一行<em class="kn">的总和</em>，一个接一个。但是事情是，<strong class="ko iu">对于任何一个</strong> <code class="fe mc md me mf b"><strong class="ko iu">i</strong></code> <strong class="ko iu">我们不需要任何其他迭代的结果</strong>！因此，如果我们的计算不相互依赖，我们可以<em class="kn">理论上</em>并行运行它们，将一些工作交给我们的其他CPU内核！</p><blockquote class="ki kj kk"><p id="bf14" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">顺便说一下，我会经常提到<code class="fe mc md me mf b">for</code>循环，因为R中一个流行的并行解决方案也使用它们——不过，我们不要太超前了。现在，关于什么有助于无错并行(线程安全等等)，将有更多的讨论，但这不是一个一般的并行计算讲座，而是关于<strong class="ko iu"> <em class="it">当进行并行处理时，什么可能出错</em> </strong> <em class="it"> </em>。</p></blockquote><p id="1a81" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">好的，那么并行计算行和需要什么呢？有几种方法可以实现它，但是所有的解决方案都涉及到立刻开始<em class="kn">多重、</em> <strong class="ko iu"> <em class="kn">独立</em> </strong> <em class="kn">计算</em>(就像为每个<code class="fe mc md me mf b">i</code>创建一个R实例)当它们都完成时，就把它们的结果粘在一起。现在，我将向您展示如何做到这一点。</p><h2 id="960a" class="nv mi it bd mj nw nx dn mn ny nz dp mr lz oa ob mt ma oc od mv mb oe of mx og bi translated">R中的并行处理:使用“foreach”的多处理</h2><p id="b3e2" class="pw-post-body-paragraph kl km it ko b kp mz ju kr ks na jx ku lz nb kx ky ma nc lb lc mb nd lf lg lh im bi translated">在R中，进行并行计算的一种典型方式是借助于<code class="fe mc md me mf b">foreach</code>包(<a class="ae ly" href="https://cran.r-project.org/web/packages/foreach/vignettes/foreach.html" rel="noopener ugc nofollow" target="_blank">这里有更多关于如何使用它的信息</a>)。它提供了一种便捷的方式将您的任务(<em class="kn"> jobs </em>)分配给多个进程，而不需要考虑如何以及何时将某个任务安排给某个进程。当这些过程完成时，这个包还会帮助您将结果连接成一个列表或向量(或者实际上是任何东西)。就其本身而言，这可能还不够，因为您需要提供所谓的<em class="kn">并行后端</em>(处理进程的创建和销毁，以及它们之间的通信)。包<code class="fe mc md me mf b">doParallel</code>提供了一个这样的后端。无需深入了解它们是如何工作的，这里有一段代码为我们做了并行行求和:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="0c58" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">我插入了一些更长的注释来说明这些指令的用途。该代码片段将让您快速了解如何使用该包来运行并行计算。通常，您会希望以<code class="fe mc md me mf b">item = theListToProcess</code>的形式向<code class="fe mc md me mf b">foreach</code>结构提供一个列表，然后您可以在您的子流程中用<code class="fe mc md me mf b">item</code>变量引用列表的当前元素——您可以为它选择(几乎)任何名称。</p><p id="168f" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">不幸的是，我们现实生活中的计算很少这么容易实现。也许我们正在运行复杂的模拟(计算多个矩阵的协方差，解决线性规划问题等等)，我们的结果只有在执行了一些函数后才会出现。也许您已经创建了顺序运行的代码，现在您想让它并行运行。也许你让你的代码并行运行，但实际上比顺序运行要慢(是的，这可能发生，我们会看到)。很多事情都可能出错，但是如果你注意其中的几个，你就可以编写出引起麻烦的几率更低的代码。</p><h2 id="2886" class="nv mi it bd mj nw nx dn mn ny nz dp mr lz oa ob mt ma oc od mv mb oe of mx og bi translated">首先，我可以并行化什么？</h2><p id="0520" class="pw-post-body-paragraph kl km it ko b kp mz ju kr ks na jx ku lz nb kx ky ma nc lb lc mb nd lf lg lh im bi translated">如果您已经有了一些代码，并且正在考虑通过并行执行来使它更快，那么停下来想想它计算最终结果的步骤是一个好主意。创建一个简单的流程图也很有帮助——看看下面的速写:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi oh"><img src="../Images/7dd21cf5d98e563a81c61ee204726f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kTuReNw2Ud17t6UAgYGOHg.jpeg"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">处理每日股票市场价格的程序的简化流程图(图片由作者提供)。</p></figure><p id="089b" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">该图显示了从数据集的某些部分组装投资组合的过程(例如，基于2020年6月1日和2020年6月5日之间的数据创建投资组合，然后基于2020年6月8日和2020年8月12日之间的数据创建投资组合，以此类推),并汇总这些操作的结果。在绿色区域，我们可以看到组装投资组合的过程<strong class="ko iu">不<em class="kn">而</em>相互依赖</strong>，只依赖于预先获得的数据，因此我们可以重新安排它们并行运行。一般来说，<code class="fe mc md me mf b">for</code>循环是开始观察的好地方:如果您没有将数据从一个迭代传递到另一个迭代(并且您也没有在循环之外修改数据<em class="kn">，您应该可以让那个循环并行运行(尽管尝试并行化一切很容易，请参见<em class="kn">性能</em>部分)。</em></p><p id="72b1" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">如果您已经嵌套了for循环，并希望将其中一个循环转换为并行任务，请确保您执行的是仍然可以独立运行的最外层循环(如果它不止循环几次)。</p><p id="8bd6" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">这可能是一项令人生畏的任务，而且真的没有通用的方法来做到这一点:你必须做出决定，将一些事情变成平行的，或者保持现状。或者，您可能需要重构代码，使其更易于并行化。现在——在这个<em class="kn">冗长的</em>介绍之后——让我们直入主题:</p><blockquote class="ne"><p id="0c12" class="nf ng it bd nh ni nj nk nl nm nn lh dk translated">什么可能出错(第1部分)？</p></blockquote><h1 id="0b12" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz oi ka mt kc oj kd mv kf ok kg mx my bi translated">无意中问了太多你的CPU也就是性能问题</h1><p id="6d10" class="pw-post-body-paragraph kl km it ko b kp mz ju kr ks na jx ku lz nb kx ky ma nc lb lc mb nd lf lg lh im bi translated">在本文的剩余部分，我们将看看一些看似微妙的问题，这些问题不一定会使R会话崩溃或抛出错误，而是会悄悄地削弱您的计算性能，甚至可能使您的计算机进入无响应状态。首先，我将讨论并行化的开销，这种开销随着并行执行的性能增长而慢慢减少。然后我们将了解为什么混合多种并行化技术是一个坏主意，最后我将向您展示两个边缘案例，如果与其他一些问题结合起来，可能会导致更多问题。</p><h2 id="ef6b" class="nv mi it bd mj nw nx dn mn ny nz dp mr lz oa ob mt ma oc od mv mb oe of mx og bi translated">并行化不是免费的:开销</h2><p id="3467" class="pw-post-body-paragraph kl km it ko b kp mz ju kr ks na jx ku lz nb kx ky ma nc lb lc mb nd lf lg lh im bi translated">很容易将并行化视为解决所有性能问题的金锤。事实上，</p><blockquote class="ki kj kk"><p id="0294" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">为什么我不应该并行运行所有的事情呢？</p></blockquote><p id="d4b1" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">问得好，但原因如下。很容易从上面的例子中得出结论，说“嗯，我有一个长度大于100的向量，让我们把它扔到32个进程上来计算一些东西”。问题是创建进程<strong class="ko iu">不自由</strong>，它们之间的通信也不自由。它们中的每一个都需要启动(至少在不分叉的时候),并且它们有自己的内存空间(Windows上的一个基本R实例可以占用30-50 MiB RAM，乘以12个进程就已经是480-600 MiB了——我们甚至还没有在它们上面加载包和数据！).如果您需要访问所有进程上的整个大型数据框架，那么需要将数据加载到所有进程上——不过，只需将真正需要的变量移动到您的进程上。如果您使用具有大量依赖项的包，它们将使用大约12倍多的RAM——在我们的12进程示例中。您很快就会明白为什么我们需要将数据加载到我们所有的流程中。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mg"><img src="../Images/7d91e009b9f67d26b284e407298367ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yIJNhR1XttTK7dJ2V4BRuQ.jpeg"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">还记得文章开头的这张图吗？这离现实又近了一步(图片由作者提供)。</p></figure><p id="3ff8" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">因为我在32个内核的Linux服务器上使用了一个“SOCK”集群(即我没有分叉我的进程)，我必须等到所有32个进程都正确初始化，这导致了大约45到90秒的等待时间:每个进程都必须加载多个包并调用一些函数来准备处理。在这种情况下，最好重新考虑启动时间(和增加的内存使用)是否真的值得多处理带来的性能提升。对我来说，这绝对是值得的，因为我解决了成千上万的二次规划问题:这里开销和并行执行时间的总和仍然比顺序运行时低得多。然而，对于小任务，选择更少的进程或者根本不并行会更有效率。</p><p id="7f23" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">在下一节中，我们将看到另一种提高速度的方法，而不必求助于多重处理，以及它是如何引起更多麻烦的。</p><h2 id="88a0" class="nv mi it bd mj nw nx dn mn ny nz dp mr lz oa ob mt ma oc od mv mb oe of mx og bi translated">多线程×多处理=不好</h2><p id="b45b" class="pw-post-body-paragraph kl km it ko b kp mz ju kr ks na jx ku lz nb kx ky ma nc lb lc mb nd lf lg lh im bi translated">如果你想让数学运算更快，从base R转换到<a class="ae ly" href="https://mran.microsoft.com/open" rel="noopener ugc nofollow" target="_blank">微软R Open (MRO) </a>可能是个不错的选择。它是R的一个略微修改的版本，依赖于一个不同的库(<a class="ae ly" href="https://software.intel.com/content/www/us/en/develop/tools/math-kernel-library.html" rel="noopener ugc nofollow" target="_blank">英特尔数学内核库(MKL) </a>)来进行数学计算。了解微软R Open很重要的一点是:( 1)它与base R兼容，更重要的是,( 2)由于采用了英特尔MKL，它通过以<em class="kn">多线程</em>的方式执行矩阵乘法和类似的矢量化任务，实现了更快的速度——可以在这里<a class="ae ly" href="https://mran.microsoft.com/documents/rro/multithread" rel="noopener ugc nofollow" target="_blank">看到微软进行的性能比较</a>。坚持住。什么，现在？</p><p id="a037" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">从概念上讲，所做的事情与我们在上面的行求和示例中所做的非常相似。<em class="kn">多线程</em>工作流，然而，创建单独的<em class="kn">线程</em>，而不是单独的<em class="kn">进程</em>(如同<em class="kn">多重处理</em>)。如果你不介意的话，我不会深入研究具体的技术差异，但我们也不要在这里留下一个黑洞。在<em class="kn">多线程</em>环境中，内存通常在计算(<em class="kn">线程</em>)之间共享，而在多处理环境中，每个进程都有自己的内存。如果您还记得上一节，这就是为什么我们必须初始化集群中的每个R进程:因为它们是独立的进程(实例),有自己的内存，所以每个进程都作为一个空的R实例启动，没有加载额外的包。一个进程可以有多个线程，所以这里也有一个层次结构，但就像我说的，这不是一个并行计算或操作系统大师级。</p><p id="bdf5" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">在高层次上，创建线程通常比创建进程便宜(CPU和内存方面也是如此)，但是对于线程，您必须非常小心内存，因为您可能会覆盖另一个线程正在处理的内容。但是在进程的情况下，由于独立的内存空间，这不是问题，但是您必须处理进程之间的通信(这是由并行后端和<code class="fe mc md me mf b">foreach</code>完成的)。每一种都有它们的优点和缺点，但是知道<strong class="ko iu">你可能会在不知情的情况下使用它们</strong>和<strong class="ko iu">可能会导致速度大幅下降</strong>就足够了。我们能把这叫做<em class="kn">过度平行化</em>吗？</p><p id="d331" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><strong class="ko iu">我们来数一数</strong>。您正在使用MRO (Microsoft R Open ),因为它在顺序工作流中更快，但是您注意到您的代码的一部分可以并行执行，所以您将并行<code class="fe mc md me mf b">foreach</code>放入其中。您有一个4核CPU (4个逻辑核，没有超线程)，因此您会产生4 R个进程。但是，您没有意识到的是，您正在创建4个<em class="kn"> MRO进程</em>，这些进程可能没有被告知并行情况，因此它们每个都决定使用4个线程来进行计算。你开始进行大量矩阵求逆或乘法的并行计算，却突然意识到。只是。<em class="kn">慢</em>。这怎么可能？</p><p id="d486" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">事实是，你实际上使用了<strong class="ko iu"> 4*4 = 16 </strong>个线程！<strong class="ko iu">CPU能够同时运行的线程数量的四倍</strong>。结果，你的CPU在这些线程之间来回切换，大大降低了矩阵运算和并行执行的速度。它可能会减慢到顺序执行会更快完成的程度。</p><p id="4c9b" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">为了避免这个问题，您应该使用MRO的命令(<code class="fe mc md me mf b">setMKLthreads</code>)将每个子进程上使用的线程数限制为1。我将给你一个使用<code class="fe mc md me mf b">doParallel</code>包实现这一点的完整例子。确保在实际的<code class="fe mc md me mf b">foreach</code>计算之前运行下面的代码片段<strong class="ko iu">！</strong></p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c121" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">很好。试着再次运行你的计算，你可能会注意到它们变得更快了，就像我一样。哦，顺便说一下，<code class="fe mc md me mf b">clusterEvalQ</code>只是在你所有的子进程上执行相同的代码(<a class="ae ly" href="https://www.rdocumentation.org/packages/parallel/versions/3.6.2/topics/clusterApply" rel="noopener ugc nofollow" target="_blank">文档在这里，</a>我稍后会谈到)。它可用于在您的流程上进行一些设置工作，如加载包和调整设置。</p><p id="a3cc" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">错过这一点的有趣之处在于<em class="kn">你可能甚至不会注意到背景中发生的事情。您不会得到任何错误，但在某些时候，您的计算可能会大大减慢。只要您的进程没有同时碰到一些繁重的多线程部分，您可能会没事，但是一旦它们碰到了，您会发现您的进度条(如果您正在使用的话)停止了，只是盯着监视器，心想“嗯，它似乎不能再快了”。我的模拟似乎也停止了，我想这是因为我使用了500×500的矩阵——它们在50×50的矩阵下运行良好！一旦我告诉MRO停止在它的每个进程上使用多线程，我的并行执行甚至可以在大(500×500)矩阵上运行！我在32核服务器上运行这些，所以我实际上产生了<em class="kn"> 32*32个线程</em>，太棒了。</em></p><p id="6c76" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">即使你不使用MRO，你仍然可能遇到这个问题。看，例如<code class="fe mc md me mf b">data.table</code>包也是多线程的，但是当<a class="ae ly" href="https://www.rdocumentation.org/packages/data.table/versions/1.12.8/topics/setDTthreads" rel="noopener ugc nofollow" target="_blank">文档</a>说它可以检测它是否运行在一个<em class="kn">分叉</em>进程上并切换回单线程操作时，我有点担心明确提到的<em class="kn">分叉</em>。分叉是创建集群时的另一种方法，它克隆进程(在Linux上传递<code class="fe mc md me mf b">type = "FORK"</code>到<code class="fe mc md me mf b">makeCluster</code>),但它在Windows上不起作用，所以我使用“SOCK”集群——我在Windows上开发我的代码，并在Linux服务器上运行它，这是最好的办法。为了扩展前面的代码，我们可以改为执行以下代码:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d857" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">这应该足以让你开始多线程和多处理。请记住，您需要确保您在子进程上使用的每个包都以单线程模式运行。软件包通常会告诉你它们是否像<code class="fe mc md me mf b">data.table</code>一样使用多线程。</p><p id="65d1" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">顺便说一下，如果您想知道MRO在单线程上的性能，当切换到单线程操作时，它不会变得无用。它仍然使用英特尔的MKL，即使在一个线程上，它也比base R的BLAS/LAPACK库快得多(参见我之前提到的基准测试，<a class="ae ly" href="https://mran.microsoft.com/documents/rro/multithread" rel="noopener ugc nofollow" target="_blank">这里</a>)。</p><p id="0bde" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><strong class="ko iu"> TLDR。</strong>你真的不想同时使用这两种类型的并行性，小心多处理环境中的多线程部分！</p><h2 id="86af" class="nv mi it bd mj nw nx dn mn ny nz dp mr lz oa ob mt ma oc od mv mb oe of mx og bi translated">“嘿，我们还在运行”——不是停止集群，或者只是认为已经停止了集群</h2><p id="650c" class="pw-post-body-paragraph kl km it ko b kp mz ju kr ks na jx ku lz nb kx ky ma nc lb lc mb nd lf lg lh im bi translated">关于性能还有一件事要提。看，我遇到过这样的问题，我几乎冻结了一台32核服务器。原来错误不仅仅是我生成了太多的线程，而是当我强行告诉主进程停止时，子进程没有退出(使用每个人都喜欢的组合键，<code class="fe mc md me mf b">CTRL + C</code>)。由于我在Windows机器上工作，我天真地认为事情在Linux机器上应该以大致相同的方式运行我的子进程:用<code class="fe mc md me mf b">CTRL + C</code>从控制台关闭主进程也应该停止子进程——只是看起来不是在Linux机器上。</p><p id="9847" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">这些子进程处于<em class="kn">过度并行化</em>的情况中:每个线程都在争夺CPU (1024个线程争夺32个内核！)，所以他们的预计完成时间基本上是<em class="kn">从来没有</em>。现在，由于我没有意识到这一点，我实际上重新启动了几次计算(在不断更新代码之后)，所以运行的子进程和线程比我想象的要多——这就是为什么您至少应该运行<code class="fe mc md me mf b">top</code>,如果不是<code class="fe mc md me mf b">htop</code>来从命令行检查您的服务器的性能。</p><p id="6e84" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">为了确保你的过程确实停止，在你开始计算之前，你可以做一些事情。r提供了一个名为<code class="fe mc md me mf b">on.exit </code>(此处为<a class="ae ly" href="https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/on.exit" rel="noopener ugc nofollow" target="_blank">文档</a>)的函数，这是一个方便的小工具，当函数退出时，它会执行代码，即使是在发出<code class="fe mc md me mf b">CTRL + C</code>的时候。我们可以使用它来尝试关闭我们的集群，而不管我们是否已经成功执行完当前函数:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="72f9" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">但那是两个停止命令，不是吗？是的，但是我真的想确保我的集群被正确关闭——它最终关闭了。我还将代码包装在一个<code class="fe mc md me mf b">try</code>块中，以防其中一个出错(例如，因为集群已经停止)。这两个命令是否都是必要的，我无法验证，但是尽管发出多个stop命令看起来很难看，但我从未遇到过这方面的问题。就像我说的，在Windows机器上你可能也不会有(如果你的主进程退出，子进程也会被关闭)，但是一旦你完成了对集群的处理并处理了异常关闭，显式地停止集群总是一个好主意。</p><h2 id="1767" class="nv mi it bd mj nw nx dn mn ny nz dp mr lz oa ob mt ma oc od mv mb oe of mx og bi translated">"多几百兆字节的内存怎么样？"—观看集群呼叫</h2><p id="a2f0" class="pw-post-body-paragraph kl km it ko b kp mz ju kr ks na jx ku lz nb kx ky ma nc lb lc mb nd lf lg lh im bi translated">虽然使用<code class="fe mc md me mf b">clusterCall</code>代替我们之前使用的<code class="fe mc md me mf b">clusterEvalQ</code>可能同样容易——以至于它们<em class="kn">看起来</em>是可交换的——但是这个函数有一个有趣的副作用，你可能没有意识到。为了进行模拟，我生成了一个巨大的表达式列表(占用了几百MiB的内存),然后将它馈送给并行的<code class="fe mc md me mf b">foreach</code>循环——集群的进程然后评估这些表达式，给我最终的结果。表达式列表是在我设置集群之前生成的，所以我在确定任务中没有错误之前不会启动集群。这个生成过程完成时没有出现错误(从base R进程的内存使用量的大幅增加可以看出)。然后为了设置我的集群，我从使用名为<code class="fe mc md me mf b">.packages</code>的<code class="fe mc md me mf b">foreach</code>参数切换到使用<code class="fe mc md me mf b">clusterCall()</code>来加载我需要的包，并为MKL和<code class="fe mc md me mf b">data.table</code>设置子进程的线程数。</p><p id="a026" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">这一切都很好，直到我突然注意到，每个子进程的内存使用量开始从40–50 MiB上升到大约6–900 MiB(准确地说，每个子进程的大小大致相同)，并且这种情况一个接一个地发生:进程产生，进程#1在几秒钟内从40 MiB上升到大约670 MiB，然后进程#2也这样做，以此类推。我花了相当多的调试时间来弄清楚到底发生了什么——我甚至没有在子进程上执行任何东西<em class="kn">,只有一个空的<code class="fe mc md me mf b">clusterCall</code>,内存仍然增加到这个荒谬的高数量。如果您想知道，这是导致问题的一行代码:</em></p><pre class="lj lk ll lm gt ol mf om on aw oo bi"><span id="5f23" class="nv mi it mf b gy op oq l or os">clusterCall(cl = parallelCluster, function () { }) # do nothing</span></pre><p id="3675" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">很奇怪吧。这怎么可能呢？此外，更好的是，当我从控制台执行<em class="kn">同样的代码行</em>时，这个内存使用问题没有发生:内存使用保持在40 MiB左右。当我从控制台而不是在函数中发出命令时，我可以在集群上加载包，而不会增加几乎1gb的内存使用。</p><p id="c3bb" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">鉴于本节的上下文，您可能会怀疑这个问题，但是我从未看到任何迹象表明<code class="fe mc md me mf b">clusterCall</code> <strong class="ko iu">首先将当前函数的所有局部变量复制到子进程上</strong>。这可能是一个方便的特性，可以在其上计算函数，而不必先显式地复制变量(在<code class="fe mc md me mf b">clusterExport</code>的帮助下)，但这仍然很令人头疼。</p><p id="ae44" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">所以，<strong class="ko iu">确保不要把太多(大)变量放入你从</strong>调用 <code class="fe mc md me mf b">clusterCall</code> <strong class="ko iu">的同一个函数中！相反，您可以尝试创建一个单独的函数，调用<code class="fe mc md me mf b">clusterCall</code>来设置您的集群，或者确保您在函数开始时调用这个函数，但是在发出<code class="fe mc md me mf b">makeCluster</code>之后(我相信所有的局部变量都会复制过来，所以如果您将一个巨大的数据帧作为参数传递给函数，它也可能会被复制到子进程)。有一个更简单的方法，尽管是</strong>，因为你可能不想用<code class="fe mc md me mf b">clusterCall</code>来做设置工作(比如加载包)。</p><p id="7b86" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">我推荐的另一个选择是用<code class="fe mc md me mf b">clusterEvalQ</code><strong class="ko iu"/>代替<strong class="ko iu">，特别是在初始化的时候。后者不接受函数作为第二个参数，而是接受一个表达式作为第二个参数(语法上类似)，并且不会导致将局部变量复制到集群中。如果您愿意，您仍然可以使用<code class="fe mc md me mf b">clusterExport</code>手动(显式)将变量移动到您的子流程中。所以用这个代替:</strong></p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5051" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">尽管如此，还是有它的用处！如果您想使用当前函数中的多个局部变量，并且不想在一个<code class="fe mc md me mf b">clusterExport</code>调用中显式地列出它们，这将非常方便。</p><p id="edcf" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">有趣的事实。根据<a class="ae ly" href="https://www.rdocumentation.org/packages/parallel/versions/3.6.2/topics/clusterApply" rel="noopener ugc nofollow" target="_blank">文档</a>(以及源代码)<code class="fe mc md me mf b">clusterEvalQ</code>在后台调用<code class="fe mc md me mf b">clusterCall</code>。这乍一看似乎很奇怪，因为<code class="fe mc md me mf b">clusterEvalQ</code>不会导致复制变量，但是我有一个答案，如果你还在阅读的话！由于<code class="fe mc md me mf b">clusterCall</code>被包装在<code class="fe mc md me mf b">clusterEvalQ</code>中，只有<code class="fe mc md me mf b">clusterEvalQ</code>的局部变量会被复制(除了表达式本身之外，没有局部变量)，所以没有额外的变量被复制到集群中。下面是<code class="fe mc md me mf b">clusterEvalQ</code>的源代码(代码取自包的<a class="ae ly" href="https://www.rdocumentation.org/packages/parallel/versions/3.6.2/source" rel="noopener ugc nofollow" target="_blank">源代码，我只是重新格式化了它——点击侧边栏上的<code class="fe mc md me mf b">ClusterApply.R</code>查看相关文件):</a></p><pre class="lj lk ll lm gt ol mf om on aw oo bi"><span id="880f" class="nv mi it mf b gy op oq l or os">clusterEvalQ &lt;- function(cl = NULL, expr) {<br/>  clusterCall(cl, eval, substitute(expr), env=.GlobalEnv)<br/>}</span></pre></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="a0b1" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">至此，我们已经结束了这个话题。虽然本文没有触及所有的并行化主题(比如多线程的OpenMP和<code class="fe mc md me mf b">Rcpp</code>),但我希望它提供的信息足以帮助您避免一些狡猾的陷阱。我也希望20分钟的阅读时间没有把你吓跑——我很容易过度解释自己。下一次，我将尝试涵盖一些确实会带来错误消息的问题(这样它们更容易被检测到)，但是这些消息可能不是很有帮助，并且可能很难调试和找到它们的根本原因——就像<em class="kn">偶尔</em>(即。<em class="kn">随机</em>得到一个<code class="fe mc md me mf b">Error reading from connection</code>错误。</p><p id="db7b" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">如果你有任何建议或更正，请在评论中添加！</p><p id="db74" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><strong class="ko iu">以下是我在本文中涉及或触及的主题(供参考)</strong></p><ul class=""><li id="1dd9" class="pa pb it ko b kp kq ks kt lz pc ma pd mb pe lh pf pg ph pi bi translated">如何用<code class="fe mc md me mf b">foreach</code>在R中进行多重处理，为什么你会想使用它</li><li id="18a4" class="pa pb it ko b kp pj ks pk lz pl ma pm mb pn lh pf pg ph pi bi translated">对于较小的任务，多处理的成本(称为开销)可能会超过并行处理的优势</li><li id="9cd7" class="pa pb it ko b kp pj ks pk lz pl ma pm mb pn lh pf pg ph pi bi translated">将多处理与多线程工作结合起来会意外地导致速度大幅下降</li><li id="41fe" class="pa pb it ko b kp pj ks pk lz pl ma pm mb pn lh pf pg ph pi bi translated">Microsoft R Open是使用多线程加速计算的一个很好的选择，尤其是在不使用多重处理的时候。它可能是base R版本的一个很好的替代品</li><li id="5467" class="pa pb it ko b kp pj ks pk lz pl ma pm mb pn lh pf pg ph pi bi translated">按下<code class="fe mc md me mf b">CTRL + C</code>不一定会终止集群的进程，只会终止您的主进程:确保您也能处理意外退出</li><li id="5c3a" class="pa pb it ko b kp pj ks pk lz pl ma pm mb pn lh pf pg ph pi bi translated"><code class="fe mc md me mf b">clusterCall</code>可以用你不想加载的数据填充你的子进程的内存，而你可能没有意识到这一点。如果您不需要您的变量在您的流程中神奇地变得可用，请使用<code class="fe mc md me mf b">clusterEvalQ</code>。</li></ul></div></div>    
</body>
</html>