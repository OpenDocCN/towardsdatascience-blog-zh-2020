<html>
<head>
<title>Sports Reference API Intro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">体育参考API简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sports-reference-api-intro-dbce09e89e52?source=collection_archive---------15-----------------------#2020-05-05">https://towardsdatascience.com/sports-reference-api-intro-dbce09e89e52?source=collection_archive---------15-----------------------#2020-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0036" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何建立令人敬畏的体育数据集</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e2dbc4aed614f286a426832f5c9e7ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jzfj4w5Nt5Q6uMJv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jcgellidon" rel="noopener ugc nofollow" target="_blank"> JC Gellidon </a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> UnSplash </a>拍摄</p></figure><p id="ab6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我每周体育主题系列的第二部分。每周，我都会展示以体育为中心的数据科学应用。</p><p id="efb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上周，在我的文章<a class="ae ky" rel="noopener" target="_blank" href="/beating-the-odds-8d26b1a83f1b">战胜困难</a>中，我展示了如何使用<a class="ae ky" href="https://sportsreference.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">体育参考API </a>建立一个关于NBA球队的数据集，然后使用该数据集找到那些超过常规赛积分差距的球队。本周我想深入探讨如何使用这个API为您的项目构建全面的数据集。</p><p id="c6c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我在网上浏览体育数据项目时，我看到很多人求助于从不同的来源下载表格，手动或通过网络搜集。然后通常需要将这些表连接起来，这是一个非常繁琐的过程，高度依赖于数据的质量。以这种方式构建大型数据集可能需要几天甚至几周的时间。不要成为那个人！令人欣慰的是，Sports Reference的出色工程师构建了一个API，可以方便快捷地访问Sports Reference关于MLB、NBA、NFL、NHL、NCAAF、NCAAB和世界各地许多足球联盟的海量数据库。</p><p id="2994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始使用Sports Reference API，您需要使用<code class="fe lv lw lx ly b">pip install sportsreference</code>像安装任何其他python包一样安装它。</p><p id="3907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Sports Reference API的基本思想是使用模块来实例化类对象，这些类对象包含类属性中的相关数据。所有运动中常见的基本模块是团队、时间表、比分、花名册和运动员。NCAAB和NCAAF也有排名和会议的模块。Football(英式足球)使用稍微不同的命名约定，但是一般的API结构是相同的。在后端，这些模块通过发送HTTP请求从Sports Reference的服务器上查询相关数据来创建类对象。没有必要担心把100年的棒球赛比分数据塞满你的硬盘(尽管我认为如果你真的想的话，你可以用API来做这件事)。</p><p id="008f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的部分中，我将展示NBA API的特性。如果你对另一项运动感兴趣，我鼓励你继续下去，因为基本的特征和过程本质上是一样的。该代码旨在在Jupyter笔记本上执行，但也可以很容易地适用于其他环境。</p><h1 id="a77f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">组</h1><p id="11c0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们从团队模块开始。以下命令创建Teams类的一个实例，并打印出它的所有方法和属性。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="412c" class="na ma it ly b gy nb nc l nd ne">from sportsreference.nba.teams import Teams</span><span id="227b" class="na ma it ly b gy nf nc l nd ne">teams2020 = Teams(year = '2020')<br/>print(dir(teams2020))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/e65669ffd25ca73c676ebb8269d7ecb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lApPdehc2wkJVBZJXGIXFg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">团队类方法和属性</p></figure><p id="bbc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Teams类的唯一公共属性是“dataframes”。该属性是一个30 x 47的数据帧，其中2020年的每个NBA球队都由一行表示。栏目包括得分、罚球次数、对手进攻篮板等。“dataframes”属性通常是访问高级团队信息的最简单方法。然而，也可以使用Teams类的实例作为迭代器。例如，下面的代码打印出每个队的名称和得分。团队数据框架的每一列也可以作为团队属性以这种方式访问。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="2a82" class="na ma it ly b gy nb nc l nd ne">for team in teams2020:<br/>    print(team.name, 'Points Scored:', team.points)</span></pre><h1 id="bc75" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">日程安排</h1><p id="bee5" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">顾名思义，Schedule模块用于访问关于团队日程的信息。这非常有用，因为Teams模块不包含关于赢/输记录的信息。让我们为密尔沃基雄鹿队2019赛季创建一个类的实例，并使用它返回一个包含每场比赛基本信息的数据帧。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="59c1" class="na ma it ly b gy nb nc l nd ne">from sportsreference.nba.schedule import Schedule</span><span id="c3e4" class="na ma it ly b gy nf nc l nd ne">mil2019 = Schedule('MIL', year = '2019')<br/>mil2019.dataframe.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/1a01ac8d29d76dd516f2213bc3b752dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dwvql039MUxax5RcRCiG8g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">密尔沃基雄鹿队2018-2019赛季的前5场比赛</p></figure><p id="2254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意boxscore_index列，这些boxscore索引可以与boxscore类一起使用，以获得更详细的游戏信息。与Teams模块类似，Schedule类的实例也可以用作迭代器。最后，Schedule类有一个“dataframe_extended”属性，它返回一个dataframe，其中每一行都是Boxscore类的一个实例。这为每个游戏提供了更丰富的数据，但由于构建了许多Boxscore类的实例，每个实例都需要单独的服务器请求，因此处理时间要长得多。</p><h1 id="2148" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Boxscore</h1><p id="6223" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们仔细看看密尔沃基雄鹿队2019年东部决赛第一场对阵多伦多猛龙队的比赛。从我们的时间表数据框架中，我们可以发现这场比赛的boxscore_index是“201905150MIL”。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="33f9" class="na ma it ly b gy nb nc l nd ne">from sportsreference.nba.boxscore import Boxscore</span><span id="7c8e" class="na ma it ly b gy nf nc l nd ne">game_data = Boxscore('201905150MIL')</span></pre><p id="e0dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过调用<code class="fe lv lw lx ly b">print(dir(game_data))</code>,我们可以看到Boxscore类比Teams和Schedule类有更多的属性。命令<code class="fe lv lw lx ly b">game_data.dataframe</code>将把这些属性编译成数据帧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/5fcda2fd9eb3e441ab212a7480f6275e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxCYbtU_dT8u83Rd6Tg50w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Boxscore数据框架</p></figure><p id="1a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，这并不完全是我们习惯看到的boxscore类型，但这里仍然有很多有用的数据。为了构建更类似于传统boxscore的东西，我们需要使用Boxscore类属性‘home _ players’和‘away _ players’。通过执行<code class="fe lv lw lx ly b">game_data.home_players</code>,我们看到这返回了一个BoxscorePlayer类对象的列表。此外，我们可以执行<code class="fe lv lw lx ly b">print(dir(game_data.home_players[0]))</code>来查看这个子类所有可用方法和属性的列表。由于BoxscorePlayer类具有“dataframe”属性，因此可以通过连接每个单独的BoxscorePlayer数据帧来构建更传统的boxscore数据帧。下面的代码就是这样做的。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="b2ef" class="na ma it ly b gy nb nc l nd ne">home_df = game_data.home_players[0].dataframe</span><span id="01e7" class="na ma it ly b gy nf nc l nd ne">for player in game_data.home_players[1:]:<br/>    home_df = pd.concat([home_df, player.dataframe], axis = 0)</span><span id="f98b" class="na ma it ly b gy nf nc l nd ne">home_df['name'] = [x.name for x in game_data.home_players]<br/>home_df.set_index('name', inplace = True)<br/>home_df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/34108bb02ba4c5a5dec811fac4d96fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aMVGdPDLMA8k0CIYgLJ90A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">2019年密尔沃基雄鹿队主场迎战多伦多猛龙队ECF队第一场比赛的比分</p></figure><p id="0463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过检查该数据帧的列，我们可以看到，我们不仅获得了所有传统的boxscore统计数据，还获得了一些高级统计数据。这总结了Boxscore模块的基本用例。</p><h1 id="dba7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">花名册</h1><p id="9ab1" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">花名册模块用于获取球队球员花名册的信息。让我们为2007年“我们相信”的勇士队创建一个花名册类的实例。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="be94" class="na ma it ly b gy nb nc l nd ne">from sportsreference.nba.roster import Roster</span><span id="0678" class="na ma it ly b gy nf nc l nd ne">gsw2007 = Roster('GSW', year = '2007')</span></pre><p id="1537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我在上面展示的，我们可以检查这个类对象的方法和属性，并看到只有一个属性，“players”。与我们刚刚为Boxscore模块查看的“home_players”属性非常相似,“players”属性是Player类实例的列表。我们稍后将更深入地讨论播放器模块。现在，让我们使用下面的代码片段简单地打印出名册上每个球员的姓名和球员id。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="390e" class="na ma it ly b gy nb nc l nd ne">for player in gsw2007.players:<br/>    print(player.name, ':', player.player_id)</span></pre><p id="28ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于花名册类为花名册上的每个球员创建一个球员类的实例，并且构造每个实例需要向Sports Reference的服务器发出请求，所以使用花名册类来完成这样一个简单的任务会非常慢。如果我们想用这种方法打印某个赛季联盟中每个球员的名字，我们可能需要等待5分钟以上来创建所有球员类实例。作为替代，我们可以使用关键字参数<code class="fe lv lw lx ly b">slim = True</code>调用花名册类。这将创建一个花名册类的实例，其中“players”属性只是一个字典，键是player _ ids，值是名称。下面的代码演示了这一功能。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="9a7a" class="na ma it ly b gy nb nc l nd ne">gsw2007slim = Roster('GSW', year = '2007', slim = True)<br/>gsw2007slim.players</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/9d9bab7e80ea6ceb0932fe00fcd8ccbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vjsz3JJ2a2XBJIKLon-SDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">2006-07赛季“我们相信”金州勇士队的名单</p></figure><h1 id="fad9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">运动员</h1><p id="4024" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">不足为奇的是，玩家模块用于获取单个玩家的信息。参考API <a class="ae ky" href="https://sportsreference.readthedocs.io/en/stable/nba.html#player" rel="noopener ugc nofollow" target="_blank">文档</a>，我们可以看到播放器模块包含一个抽象类AbstractPlayer，它由我们已经在Boxscore和花名册模块中看到的BoxscorePlayer和Player类继承。因此，获取球员数据的正确方式实际上是通过花名册和Boxscore模块。让我们使用为拜伦·戴维斯提取的player_id来获取他的统计数据。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="63e8" class="na ma it ly b gy nb nc l nd ne">from sportsreference.nba.roster import Player</span><span id="6034" class="na ma it ly b gy nf nc l nd ne">baron_davis = Player('davisba01')<br/>baron_davis.dataframe</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/42c87b6e4ada22e2a8e50ca8b65f7575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zt3IW7pZkrgvLoTdbi6Gxw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拜伦·戴维斯职业生涯和赛季统计</p></figure><p id="27cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段简单的代码为我们提供了拜伦·戴维斯职业生涯和每个赛季的89列数据。除了“dataframe”属性及其所有相关列之外，Player类还包含诸如“birth_date”、“height”、“weight”、“nationality”等属性。此外，可以使用命令<code class="fe lv lw lx ly b">baron_davis.points</code>查询单个职业统计数据，例如分数。类似地，我们可以使用命令<code class="fe lv lw lx ly b">baron_davis('2007').points</code>查询拜伦·戴维斯在2006–07赛季的总积分。根据用例，以这种更直接的方式访问玩家统计数据可能更容易，并且避免处理数据帧。</p><h1 id="d31a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">创建NBA球员数据集</h1><p id="02de" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在这篇文章的结尾，我将演示如何使用球队、花名册和球员模块来构建一个庞大的NBA球员统计数据集。这个数据集将会在我的下一篇文章中使用，我将会在这篇文章中关注NBA职业生涯中球员的发展和最终的衰落。</p><p id="e9e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是导入相关的模块并定义一个函数，该函数创建一个带有一些我手动定义的额外字段的播放器数据帧。最重要的是球员在各自赛季的1月1日的年龄。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="e6cf" class="na ma it ly b gy nb nc l nd ne"># Function to get player info from Player class object.</span><span id="49c3" class="na ma it ly b gy nf nc l nd ne">def get_player_df(player):<br/>    <br/>    # helper function to get player age during each season.<br/>    def get_age(year, bd):<br/>        if year[0] == "Career":<br/>            return None<br/>        else:<br/>            year_dt = datetime(int(year[0][0:4]) + 1, 1, 1)<br/>            age_years = relativedelta(year_dt, bd).years + <br/>                        relativedelta(year_dt, bd).months/12<br/>            return age_years<br/>        <br/>    # helper function to get year for each row and denote<br/>    # rows that contain career totals.<br/>    def get_year(ix):<br/>        if ix[0] == "Career":<br/>            return "Career"<br/>        elif ix[0] == "1999-00":<br/>            return "2000"<br/>        else:<br/>            return ix[0][0:2] + ix[0][-2:]<br/>    <br/>    # get player df and add some extra info<br/>    player_df = player.dataframe<br/>    player_df['birth_date'] = player.birth_date<br/>    player_df['player_id'] = player.player_id<br/>    player_df['name'] = player.name<br/>    player_df['year'] = [get_year(ix) for ix in player_df.index]<br/>    player_df['id'] = [player_id + ' ' + year for player_id,<br/>                       year in zip(player_df['player_id'],<br/>                       player_df['year'])]<br/>    player_df['age'] = [get_age(year, bd) for year,<br/>                        bd in zip(player_df.index,<br/>                        player_df['birth_date'])]<br/>    player_df.set_index('id', drop = True, inplace = True)<br/>    <br/>    return player_df</span></pre><p id="531c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我使用上面定义的函数来收集过去20年中在NBA打球的每个球员的整个职业生涯的球员数据。数据分为两个数据框架，一个在季节级别聚合数据，另一个在职业级别聚合数据。这是通过使用球队和花名册模块来迭代从2000年到2020年的每个NBA花名册来完成的。注意，我使用关键字变量<code class="fe lv lw lx ly b">slim = True</code>调用花名册类。如果没有这个设置，我将不得不为一个NBA球员的每个赛季创建一个球员实例，增加大约10倍的运行时间。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="9157" class="na ma it ly b gy nb nc l nd ne"># initialize a list of players that we have pulled data for<br/>players_collected = []<br/>season_df_init = 0<br/>career_df_init = 0<br/>season_df = 0<br/>career_df = 0</span><span id="8d5f" class="na ma it ly b gy nf nc l nd ne"># iterate through years.<br/>for year in range(2020, 1999, -1):<br/>    print('\n' + str(year))<br/>        <br/>    # iterate through all teams in that year.<br/>    for team in Teams(year = str(year)).dataframes.index:<br/>        print('\n' + team + '\n')<br/>        <br/>        # iterate through every player on a team roster.<br/>        for player_id in Roster(team, year = year,<br/>                         slim = True).players.keys():<br/>            <br/>            # only pull player info if that player hasn't<br/>            # been pulled already.<br/>            if player_id not in players_collected:<br/>                <br/>                player = Player(player_id)<br/>                player_info = get_player_df(player)<br/>                player_seasons = player_info[<br/>                                 player_info['year'] != "Career"]<br/>                player_career = player_info[<br/>                                player_info['year'] == "Career"]<br/>                <br/>                # create season_df if not initialized<br/>                if not season_df_init:<br/>                    season_df = player_seasons<br/>                    season_df_init = 1<br/>                <br/>                # else concatenate to season_df<br/>                else:<br/>                    season_df = pd.concat([season_df,<br/>                                   player_seasons], axis = 0)<br/>                    <br/>                if not career_df_init:<br/>                    career_df = player_career<br/>                    career_df_init = 1<br/>                <br/>                # else concatenate to career_df<br/>                else:<br/>                    career_df = pd.concat([career_df,<br/>                                   player_career], axis = 0)<br/>                <br/>                # add player to players_collected<br/>                players_collected.append(player_id)<br/>                print(player.name)</span></pre><p id="9896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是将生成的数据帧保存为您喜欢的文件格式。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="a14b" class="na ma it ly b gy nb nc l nd ne">season_df.to_csv('nba_player_stats_by_season.csv')<br/>career_df.to_csv('nba_player_stats_by_career.csv')</span></pre><p id="fd81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，这个脚本应该在大约30分钟内编译并保存您的数据集。如果你理解了最后一节的所有代码，那么你应该已经准备好开始使用体育参考API构建你自己的数据集了。</p><p id="98cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下周当我使用这个数据集分析NBA职业生涯轨迹时，请务必关注我的文章，也请查看我上周的文章<a class="ae ky" rel="noopener" target="_blank" href="/beating-the-odds-8d26b1a83f1b">战胜困难</a>。</p><p id="ef43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这本书，保重。</p></div></div>    
</body>
</html>