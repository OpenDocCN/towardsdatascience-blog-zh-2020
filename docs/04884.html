<html>
<head>
<title>Beating the Odds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">战胜困难</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/beating-the-odds-8d26b1a83f1b?source=collection_archive---------32-----------------------#2020-04-28">https://towardsdatascience.com/beating-the-odds-8d26b1a83f1b?source=collection_archive---------32-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="869d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用数据科学发现 NBA 最伟大的超常球员</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dc0e5c75b08d41325b351e0355e9d58d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KPxOsUfTWkTxYn6S"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com/photos/BfphcCvhl6E" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6e1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我每周体育主题系列的第一部分。每周我将展示数据科学的应用，并寻求对我们喜欢看的比赛提供深思熟虑的分析和见解。</p><p id="524a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我确定了 NBA 历史上超水平发挥的球队。数字显示的球队应该不是很好，但仍然无视他们的统计优势。事不宜迟，让我们把这事捅出去。</p><h2 id="ac77" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用运动参考 API 获取数据</h2><p id="d958" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，我们需要一些数据。谢天谢地，<a class="ae ky" href="https://www.sports-reference.com/" rel="noopener ugc nofollow" target="_blank">体育参考</a>提供了一个免费使用的<a class="ae ky" href="https://sportsreference.readthedocs.io/en/stable/sportsreference.html" rel="noopener ugc nofollow" target="_blank"> python API </a>，可以轻松访问超过半个世纪的篮球数据。API 还可以用来访问足球、棒球、曲棍球和英式足球的数据集；对于几乎所有与体育相关的数据项目来说，这都是一个很好的起点。要开始使用 Sports Reference API，您需要像使用 pip 或 conda 的任何其他 python 包一样安装它。</p><p id="b6c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装了 sports reference API 之后，让我们从获取我们希望包含在分析中的球队的数据开始。我选择了从 1980 年到现在的所有球队。下面的代码使用 Sports Reference Teams 模块构建一个 pandas 数据帧，其中每行代表一个队的一个赛季。它还会将索引设置为一个名为“id”的列，这是团队缩写和年份的简单组合，作为唯一的标识符。这个“id”索引将在以后合并到其他数据帧时派上用场。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4d64" class="lv lw it mu b gy my mz l na nb">import pandas as pd<br/>from sportsreference.nba.teams import Teams</span><span id="9e5b" class="lv lw it mu b gy nc mz l na nb">year = str(2020)<br/>all_team_df = Teams(year = year).dataframes<br/>all_team_df['id'] = all_team_df['abbreviation'].apply(lambda x: x + " 2020")<br/>print(2020)</span><span id="0163" class="lv lw it mu b gy nc mz l na nb">for i in range(2019,1979,-1):<br/>    year = str(i)<br/>    temp_df = Teams(year = year).dataframes<br/>    temp_df['id'] = temp_df['abbreviation'].apply(lambda x: x + " " + year)<br/>    all_team_df = pd.concat([all_team_df, temp_df], axis = 0)<br/>    print(i)</span><span id="a025" class="lv lw it mu b gy nc mz l na nb">all_team_df['year'] = all_team_df['id'].apply(lambda x: x.split(' ')[1])<br/>all_team_df.set_index('id', inplace = True)</span></pre><p id="4c48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面代码的结果是下面的 1134 x 47 数据帧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/588050379a7fc431d44399e405d93eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vbeS3jvY5cZPqDaHjf6v5g.png"/></div></div></figure><p id="0516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用命令<code class="fe ne nf ng mu b">all_team_df.columns</code>显示我们必须处理的数据帧的所有列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/bda7827cb7edcd5a56a91cb4f33e020c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBI2dkjdwc5PLQbC3dH0Pw.png"/></div></div></figure><p id="45f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有很多有用的数据，但是我们仍然缺少一些重要的信息。这个数据框架不包含任何关于输赢的内容！由于一个团队成功的最终衡量标准是赢得比赛，我们必须收集这些数据，并将其加入到我们正在构建的数据集。为此，我们将使用运动参考时间表模块。因为我们需要为 1134 个团队中的每一个团队创建并迭代一个 schedule 对象，所以定义一个助手函数来完成这项工作会使代码更加简洁。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="d546" class="lv lw it mu b gy my mz l na nb">from sportsreference.nba.schedule import Schedule</span><span id="899f" class="lv lw it mu b gy nc mz l na nb"># helper function to pull wins<br/>def get_wins(tid):<br/>    abb = tid.split(' ')[0]<br/>    year = int(tid.split(' ')[1])<br/>    games = 0<br/>    wins = 0<br/>    playoff_games = 0<br/>    playoff_wins = 0<br/>    <br/>    # Create schedule object for team and iterate through every game<br/>    for game in Schedule(abb, year = year):<br/>        if game.playoffs == False:<br/>            games += 1<br/>            if game.result == 'Win':<br/>                wins += 1<br/>        elif game.playoffs == True:<br/>            playoff_games += 1<br/>            if game.result == 'Win':<br/>                playoff_wins += 1<br/>    <br/>    return wins, games, playoff_wins, playoff_games</span><span id="dfd1" class="lv lw it mu b gy nc mz l na nb"># create dictionary and populate with team records for every year<br/>total_wins_dict = {}</span><span id="899b" class="lv lw it mu b gy nc mz l na nb">for y in range(1998, 1979, -1):<br/>    <br/>    tids = all_team_df[all_team_df['year'] == str(y)].index<br/>    <br/>    wins_dict = {'id': [], 'wins': [], 'games': [],<br/>                 'playoff_wins':   [], 'playoff_games': []}</span><span id="33cc" class="lv lw it mu b gy nc mz l na nb">    for i, tid in enumerate(tids):<br/>        wins, games, playoff_wins, playoff_games = get_wins(tid)<br/>        wins_dict['id'].append(tid)<br/>        wins_dict['wins'].append(wins)<br/>        wins_dict['games'].append(games)<br/>        wins_dict['playoff_wins'].append(playoff_wins)<br/>        wins_dict['playoff_games'].append(playoff_games)<br/>        <br/>    total_wins_dict[y] = wins_dict<br/>    print(y)</span><span id="f396" class="lv lw it mu b gy nc mz l na nb"># concatenate all team record data into one dataframe<br/>total_wins_df = pd.DataFrame(total_wins_dict[2020])</span><span id="2662" class="lv lw it mu b gy nc mz l na nb">for key in list(total_wins_dict.keys())[1:]:<br/>    temp_df = pd.DataFrame(total_wins_dict[key])<br/>    total_wins_df = pd.concat([total_wins_df, temp_df], axis = 0)</span><span id="c7df" class="lv lw it mu b gy nc mz l na nb">total_wins_df.set_index('id', inplace = True)</span></pre><p id="8fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成团队记录的数据框架后，下一步是将其与我们的其他数据合并，并将结果保存到 csv 文件中，以便于以后访问。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6924" class="lv lw it mu b gy my mz l na nb">all_data = pd.merge(left = all_team_df, right = total_wins_df,<br/>                    how = 'inner', left_index = True,<br/>                    right_index = True)</span><span id="a1cf" class="lv lw it mu b gy nc mz l na nb">all_data.to_csv('Data/all_team_data_1980-2020.csv')</span></pre><h2 id="b2c0" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">线性回归</h2><p id="9ab7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在我们可以进入这个分析的有趣部分，使用收集的数据来识别 NBA 最伟大的超水平发挥的球队。这里的想法是建立一个模型来预测一支球队赢得的比赛数量，然后看看哪些球队的表现最好。虽然我们有大量的数据来建立一个模型，但我会保持简单，只使用一个单一的特征，平均胜利幅度(MOV)。显然，一支得分比对手多的球队往往会表现得更好。让我们首先打开一个新笔记本并导入数据集。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="d7c5" class="lv lw it mu b gy my mz l na nb">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>import statsmodels.api as sm<br/>import numpy as np</span><span id="54c6" class="lv lw it mu b gy nc mz l na nb">%matplotlib inline</span><span id="6ce7" class="lv lw it mu b gy nc mz l na nb">data = pd.read_csv('Data/all_team_data_1980-2020.csv', index_col = 'id').drop('Unnamed: 0', axis = 1)</span></pre><p id="1817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们的数据集中没有 MOV 的列，但是可以使用“points”、“opp_points”和“games”列轻松创建。我们还将为常规赛胜率创建一个列，用作我们的目标变量，这有助于考虑在停摆缩短赛季中比赛的球队。最后，我们将把数据分为特性和目标，将数据输入线性回归模型，并生成回归结果的汇总表。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="79f8" class="lv lw it mu b gy my mz l na nb">data['MOV'] = [(points - opp_points) / games for points, opp_points,<br/>               games in zip(data['points'], data['opp_points'],<br/>               data['games'])]</span><span id="3fe8" class="lv lw it mu b gy nc mz l na nb">data['win_rate'] = [wins / games for wins, games in<br/>                    zip(data['wins'], data['games'])]</span><span id="c47c" class="lv lw it mu b gy nc mz l na nb"># create inputs<br/>X = pd.DataFrame(data['MOV'])<br/>X['intercept'] = [1 for x in range(data.shape[0])]</span><span id="eb22" class="lv lw it mu b gy nc mz l na nb">y = data['win_rate']</span><span id="e03c" class="lv lw it mu b gy nc mz l na nb"># create and fit linear regression model<br/>model = sm.OLS(y, X)<br/>fit = model.fit()<br/>fit.summary()</span></pre><p id="6d17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里生成的汇总表显示，这个极其简单的模型与我们的数据非常吻合，R 为 0.941。此外，该模型在获胜游戏数方面的平均绝对误差仅为 2.4 场。下面的代码生成了一个预测的和实际的 MOV 获胜的图形，以及一个模型残差的分布图。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="91e4" class="lv lw it mu b gy my mz l na nb"># create predictions for every team<br/>preds = fit.predict(X)</span><span id="afde" class="lv lw it mu b gy nc mz l na nb"># create a dataframe to hold all results<br/>results = pd.DataFrame({'id': data.index, 'prediction': preds})</span><span id="5812" class="lv lw it mu b gy nc mz l na nb"># merge with input data and actual results<br/>merge_cols = ['MOV', 'win_rate', 'wins', 'games', 'playoff_wins',<br/>              'playoff_games']</span><span id="f5d7" class="lv lw it mu b gy nc mz l na nb">results = pd.merge(left = results, right = data[merge_cols],<br/>                   how = 'inner', right_index = True,<br/>                   left_index = True)</span><span id="054e" class="lv lw it mu b gy nc mz l na nb"># use predicted win rate to predicted integer number of wins<br/>results['predicted_wins'] = [int(round((prediction) * games, 0)) for<br/>                             prediction, games in<br/>                             zip(results['prediction'],<br/>                             results['games'])]</span><span id="aece" class="lv lw it mu b gy nc mz l na nb"># create error columns<br/>results['error'] = [act - pred for act, pred in<br/>        zip(results['win_rate'], results['prediction'])]</span><span id="d9d6" class="lv lw it mu b gy nc mz l na nb"><br/>results['game_error'] = [wins - pwins for wins, pwins in<br/>                         zip(results['wins'],<br/>                         results['predicted_wins'])]</span><span id="d14d" class="lv lw it mu b gy nc mz l na nb">plt.figure(figsize=(15,6))</span><span id="d149" class="lv lw it mu b gy nc mz l na nb">plt.subplot(1,2,1)<br/>sns.scatterplot(x = X['MOV'], y = y)<br/>sns.lineplot(x = X['MOV'], y = preds, color = 'red')<br/>plt.title('Margin of Victory vs Win Rate')</span><span id="c030" class="lv lw it mu b gy nc mz l na nb">plt.subplot(1,2,2)<br/>sns.distplot(results['game_error'], bins = 21)<br/>plt.title('Residual Distribution');</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/b357e55a11488b31039a14a0208ca92d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKGaQH4TSht9bARLzQjF5g.png"/></div></div></figure><p id="2ef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用刚刚创建的结果数据框架，现在可以通过对“错误”列上的数据框架进行排序来轻松挑选出最优秀的学生。这些是根据他们的平均胜率预测赢得最多比赛的球队。这样做会产生以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/80b35da079527d7dbfd26d3918384a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmgLhxshgFg8agST3Rb5Mw.png"/></div></div></figure><p id="41c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具有讽刺意味的是，我们的分析刚刚确定了 1993 年的达拉斯小牛队，可以说是 NBA 历史上最差的球队之一，也是 NBA 历史上最伟大的超水平发挥的球队。这是一支输了 42 场 15 分以上，输了 26 场 20 分以上，输了一场 58 分的球队。除了输球，很难说这支球队在其他方面“超水平发挥”。这到底是怎么回事？为什么我们的模型产生了如此大的拟合，却导致了如此不合理的结果？</p><p id="9fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，这是一个很好的例子，说明为什么简单的线性回归永远不应该用来模拟比例。理论上，当比例被限制在 0 和 1 之间时，线性模型可以输出任何实数。如果 1993 年的小牛队公布了一个稍差的 MOV，我们的模型就会预测到一个负胜率！我们创建了一个模型，倾向于挑选非常差的团队作为优等生，非常好的团队作为劣等生。</p><h2 id="1f09" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">逻辑回归</h2><p id="6029" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">解决方法是使用逻辑回归而不是线性回归。不幸的是，sklearn 中方便的逻辑回归模块只适合分类数据，而不是实际比例。这意味着我们需要做一些额外的工作来将线性回归转换成逻辑回归。</p><p id="9718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">逻辑回归的核心是对比例、概率或分类的对数优势进行线性回归。因此，第一步是定义函数，将我们的目标变量“win_rate”转换为 log-odds，然后再转换回来。这些函数通常被称为 logit 和 sigmoid 函数，可以在我们的 python 笔记本中轻松定义如下:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6d23" class="lv lw it mu b gy my mz l na nb">def logit(p):<br/>    return np.log(p/(1-p))</span><span id="5fd8" class="lv lw it mu b gy nc mz l na nb">def sigmoid(x):<br/>    return 1 / (1 + np.exp(-x))</span></pre><p id="e859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将重复我们用来产生线性回归的过程，只有一些微小的变化。</p><ol class=""><li id="defd" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">我们的目标变量“win_rate”使用 logit 函数转换为对数赔率。</li><li id="fc30" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">使用具有单一特征“MOV”的常规线性回归来拟合目标，这与以前没有什么不同。</li><li id="8b51" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">使用 sigmoid 函数，我们的线性回归预测(以对数赔率的形式)被转换为更熟悉的“胜率”。</li></ol><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="be7c" class="lv lw it mu b gy my mz l na nb"># create inputs<br/>X = pd.DataFrame(data['MOV'])<br/>X['intercept'] = [1 for x in range(data.shape[0])]<br/>y = data['win_rate'].apply(logit)</span><span id="e0c8" class="lv lw it mu b gy nc mz l na nb"># create and fit linear regression model<br/>model = sm.OLS(y, X)<br/>fit = model.fit()<br/>fit.summary()</span><span id="e86d" class="lv lw it mu b gy nc mz l na nb"># generate predictions<br/>preds = [sigmoid(x) for x in fit.predict(X)]</span></pre><p id="890c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如预期的那样，这种逻辑回归模型对我们的数据产生了稍好的拟合，R 为 0.944，平均绝对误差仅为 2.3 场。虽然这只是比我们之前的模型稍微好一点，但是绘制结果显示更适合具有更极端的正或负 MOV 值的团队。这些图可以使用与以前几乎完全相同的代码生成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/bbb671bff5c18459def9a447a09464de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guejWLCSMOKlPrsjtfo2Kw.png"/></div></div></figure><h2 id="dbec" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">NBA 最伟大的成功者是…</h2><p id="758d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，我们实际上可以确定 NBA 最伟大的超水平球队。为了获得更有说服力的结果，让我们过滤输出，只包括至少赢得 4 场季后赛的球队。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a324" class="lv lw it mu b gy my mz l na nb">overachievers = results[results['playoff_wins'] &gt;= 4].sort_values(by = 'error', ascending = False)</span><span id="2c7b" class="lv lw it mu b gy nc mz l na nb">overachievers.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/02a3bb3f4acb7096e4bea48d5cfd880c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xPFghAUB7MaBxW36jtO5w.png"/></div></div></figure><p id="7c94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你知道了，NBA 最伟大的球员是 1987 年的金州勇士队。在乔·巴里·卡罗尔、斯里皮·弗洛伊德和克里斯·穆林的带领下，1986-87 赛季勇士队的 MOV 得分很低，只有 2.3。虽然这通常会导致一个令人失望的赛季，但 1986-87 年的勇士队获得了 42 场胜利，远远超过了他们预测的 34 场胜利，在西部联盟中排名第五。球队在两场控球比赛中取得了 63%的胜率，同时也在 30 场比赛中输掉了 10 分或更多。在季后赛中，勇士队在 5 场比赛中(3-2)击败了 4 号种子犹他爵士队，然后在 5 场比赛中(1-4)输给了被广泛认为是有史以来最好的球队之一的湖人队。</p><p id="1cd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你的阅读，我希望下周你能回来。</p><p id="5da2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/alexmuhr/Over_Under_Achiever_Analysis.git" rel="noopener ugc nofollow" target="_blank">链接到 Github </a></p></div></div>    
</body>
</html>