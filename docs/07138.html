<html>
<head>
<title>10 Smooth Python Tricks For Python Gods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蟒蛇神的10个流畅蟒蛇招数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-smooth-python-tricks-for-python-gods-2e4f6180e5e3?source=collection_archive---------1-----------------------#2020-06-01">https://towardsdatascience.com/10-smooth-python-tricks-for-python-gods-2e4f6180e5e3?source=collection_archive---------1-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="014a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使你的Python代码个性化和更好的10个技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/76fc9e061b573af477bb710e19bca6e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*shUrkvXszH1wJlm1LZRNvQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(Python logo src = http://python.org/)</p></figure><p id="e59c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然从表面上看，Python似乎是一门简单的语言，任何人都可以学习，而且确实如此，但是当人们知道自己对这门语言的掌握程度时，可能会感到惊讶。Python是很容易学习，但是很难掌握的东西之一。在Python中，做事情通常有多种方式，但是很容易做错事情，或者仅仅因为不知道模块的存在而重新创建标准库并浪费时间。</p><p id="bf6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不幸的是，Python标准库是一个巨大的怪兽，而且，它的生态系统绝对大得可怕。尽管可能有200万千兆字节的Python模块，但是您可以从Python中通常与科学计算相关的标准库和包中学习一些有用的技巧。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="23fc" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">№1:反转字符串</h1><p id="fa85" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">虽然这看起来很简单，但是用char循环反转一个字符串可能会很乏味和烦人。幸运的是，Python包含了一个简单的内置操作来执行这项任务。为此，我们只需访问字符串中的indice ::-1。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="cba3" class="nd mc it mz b gy ne nf l ng nh">a = "!dlrow olleH"<br/>backward = a[::-1]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/eb7526220ac202e418acdf6797420e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*qawlhf97ygXJUpH6kfhRcw.png"/></div></figure><h1 id="79c8" class="mb mc it bd md me nj mg mh mi nk mk ml jz nl ka mn kc nm kd mp kf nn kg mr ms bi translated">№2:变暗作为变量</h1><p id="f822" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在大多数语言中，为了将一个数组放入一组变量中，我们需要迭代地遍历这些值，或者按位置访问dim，如下所示:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="4ceb" class="nd mc it mz b gy ne nf l ng nh">firstdim = array[1]</span></pre><p id="1cdf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在Python中，有一种更酷、更快的方法可以做到这一点。为了将值列表转换为变量，我们可以简单地将变量名设置为与数组相同的长度:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="348e" class="nd mc it mz b gy ne nf l ng nh">array = [5, 10, 15, 20]<br/>five, ten, fift, twent = array</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/1efd79d1e62da0a1ff7f9ad9b82c18f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*Pml5jUXPXw5SI3OoyOt16A.png"/></div></div></figure><h1 id="2588" class="mb mc it bd md me nj mg mh mi nk mk ml jz nl ka mn kc nm kd mp kf nn kg mr ms bi translated">№3:迭代工具</h1><p id="f143" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">如果你打算花点时间在Python上，你肯定想熟悉itertools。Itertools是标准库中的一个模块，可以让你不断地进行迭代。它不仅使编写复杂的循环变得容易得多，还使您的代码更快、更简洁。这里只是使用Itertools的一个例子，但是有上百个例子:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="e9a5" class="nd mc it mz b gy ne nf l ng nh">c = [[1, 2], [3, 4], [5, 6]]<br/># Let's convert this matrix to a 1 dimensional list.<br/>import itertools as it<br/>newlist = list(it.chain.from_iterable(c))</span></pre><h1 id="29ba" class="mb mc it bd md me nj mg mh mi nk mk ml jz nl ka mn kc nm kd mp kf nn kg mr ms bi translated">№4:智能拆包</h1><p id="5f98" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">迭代解包值可能相当密集和耗时。幸运的是，Python有几个很酷的方法可以解包列表！一个例子是*，它将填充未赋值的值，并将它们添加到变量名下的新列表中。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="cd5a" class="nd mc it mz b gy ne nf l ng nh">a, *b, c = [1, 2, 3, 4, 5]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/00f5447086f576e1d5abe90d991ff4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*Fkfj8edZfI1IQN9Z41uyBg.png"/></div></figure><h1 id="8a38" class="mb mc it bd md me nj mg mh mi nk mk ml jz nl ka mn kc nm kd mp kf nn kg mr ms bi translated">№5:枚举</h1><p id="4154" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">如果你不知道枚举，你可能应该熟悉它。枚举将允许你获取列表中某些值的索引。当处理数组而不是数据框时，这在数据科学中特别有用。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="4a91" class="nd mc it mz b gy ne nf l ng nh">for i,w in enumerate(array):<br/>    print(i,w)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/f719f3eae632529474c31f46b7258257.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*eDh7KwD6TgSnhqbSewguBw.png"/></div></figure><h1 id="95e8" class="mb mc it bd md me nj mg mh mi nk mk ml jz nl ka mn kc nm kd mp kf nn kg mr ms bi translated">№6:命名切片</h1><p id="a78d" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在Python中分割列表非常容易！有各种各样很棒的工具可以用来做这件事，但是有一个很有价值的工具是给你的列表命名的能力。这对于Python中的线性代数尤其有用。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="c6ab" class="nd mc it mz b gy ne nf l ng nh">a = [0, 1, 2, 3, 4, 5]<br/>LASTTHREE = slice(-3, None)<br/>slice(-3, None, None)<br/>print(a[LASTTHREE])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/9b870867930963f37e6ad0c32f383176.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*VxOmBUxQfjuiaCEDIEa_oA.png"/></div></figure><h1 id="1cbe" class="mb mc it bd md me nj mg mh mi nk mk ml jz nl ka mn kc nm kd mp kf nn kg mr ms bi translated">№7:将相邻列表分组</h1><p id="af43" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在for循环中，对相邻循环进行分组当然很容易，尤其是通过使用zip()，但这肯定不是最好的方法。为了使事情变得简单和快速，我们可以用zip编写一个lambda表达式，将我们的相邻列表分组如下:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="51b0" class="nd mc it mz b gy ne nf l ng nh">a = [1, 2, 3, 4, 5, 6]  <br/>group_adjacent = lambda a, k: zip(*([iter(a)] * k)) <br/>group_adjacent(a, 3) [(1, 2, 3), (4, 5, 6)] <br/>group_adjacent(a, 2) [(1, 2), (3, 4), (5, 6)] <br/>group_adjacent(a, 1)</span></pre><h1 id="3f3e" class="mb mc it bd md me nj mg mh mi nk mk ml jz nl ka mn kc nm kd mp kf nn kg mr ms bi translated">№8:发生器的下一次()迭代</h1><p id="0fef" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在编程中的大多数正常情况下，我们可以通过使用计数器来访问一个索引并获得我们的位置号，它只是一个加到:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="40de" class="nd mc it mz b gy ne nf l ng nh">array1 = [5, 10, 15, 20]<br/>array2 = (x ** 2 for x in range(10))<br/>counter = 0</span><span id="570b" class="nd mc it mz b gy ns nf l ng nh">for i in array1:</span><span id="751c" class="nd mc it mz b gy ns nf l ng nh"># This code wouldn't work because 'i' is not in array2.<br/>   # i = array2[i]<br/>    i = array2[counter]<br/>#    ^^^ This code would because we are accessing the position of i</span></pre><p id="250e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，我们可以使用next()来代替它。接下来使用一个迭代器，它将我们当前的位置存储在内存中，并在后台遍历我们的列表。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="9b86" class="nd mc it mz b gy ne nf l ng nh">g = (x ** 2 for x in range(10))<br/>print(next(g))<br/>print(next(g))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/1b6251854634d157a657b3b22eb0e929.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*Aft1QzZJmym_Zp18nk9BYQ.png"/></div></figure><h1 id="18b8" class="mb mc it bd md me nj mg mh mi nk mk ml jz nl ka mn kc nm kd mp kf nn kg mr ms bi translated">№9:计数器</h1><p id="ce89" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">标准库中另一个很棒的模块是集合，今天我要向大家介绍的是集合中的计数器。使用计数器，我们可以很容易地得到一个列表的计数。这对于获取数据中值的总数、获取数据的空计数以及查看数据的唯一值非常有用。我知道你在想什么，</p><blockquote class="nu"><p id="448e" class="nv nw it bd nx ny nz oa ob oc od lt dk translated">“为什么不用熊猫呢？”</p></blockquote><p id="ae57" class="pw-post-body-paragraph ky kz it la b lb oe ju ld le of jx lg lh og lj lk ll oh ln lo lp oi lr ls lt im bi translated">这当然是一个有效的观点。然而，使用Pandas来实现这一点肯定会更加难以自动化，这也是您在部署算法时需要添加到虚拟环境中的另一个依赖项。此外，Python中的计数器类型有很多Pandas系列没有的特性，这使得它在某些情况下更加有用。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="4499" class="nd mc it mz b gy ne nf l ng nh">A = collections.Counter([1, 1, 2, 2, 3, 3, 3, 3, 4, 5, 6, 7]) <br/>A Counter({3: 4, 1: 2, 2: 2, 4: 1, 5: 1, 6: 1, 7: 1}) <br/>A.most_common(1) [(3, 4)] <br/>A.most_common(3) [(3, 4), (1, 2), (2, 2)]</span></pre><h1 id="310b" class="mb mc it bd md me nj mg mh mi nk mk ml jz nl ka mn kc nm kd mp kf nn kg mr ms bi translated">№10:出列</h1><p id="20f6" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">集合模块的另一个优点是出列。看看我们可以用这种类型做的所有巧妙的事情！</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="a629" class="nd mc it mz b gy ne nf l ng nh">import collections<br/>Q = collections.deque() <br/>Q.append(1) <br/>Q.appendleft(2) <br/>Q.extend([3, 4]) <br/>Q.extendleft([5, 6]) <br/>Q.pop()<br/>Q.popleft()<br/>Q.rotate(3) <br/>Q.rotate(-3)<br/>print(Q)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/c196420b5c102cc3a584d2945e14848f.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*peYl4f5uy9axfSyh71am0g.png"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="0238" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="31b3" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">现在你知道了，这些是我一直在使用的一些我最喜欢的Python技巧。虽然其中一些可能用得不多，但这些技巧往往非常通用和有用。幸运的是，标准库函数的Python工具箱肯定不会开始变得光秃秃的，而且里面肯定有更多的工具。很可能有一些我甚至不知道，所以总是有一些令人兴奋的东西要学！</p></div></div>    
</body>
</html>