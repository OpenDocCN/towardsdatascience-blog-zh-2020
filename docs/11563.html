<html>
<head>
<title>How to make your Python code more functional</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让您的 Python 代码更具功能性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-make-your-python-code-more-functional-b82dad274707?source=collection_archive---------13-----------------------#2020-08-11">https://towardsdatascience.com/how-to-make-your-python-code-more-functional-b82dad274707?source=collection_archive---------13-----------------------#2020-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f42" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及为什么这会使您的代码更加健壮、可测试和可维护</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b5ea29eb957fa0db9548c33e2415f1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2roVpFohHhl_WWcPrXQvw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python 很棒。以下是让它变得更好的方法。<a class="ae ky" href="https://unsplash.com/@davidclode?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">大卫·克洛德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/python?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e0b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">近年来，函数式编程越来越受欢迎。它不仅非常适合像数据分析和机器学习这样的任务。这也是一种使代码更容易测试和维护的强大方法。</p><p id="1a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">趋势显而易见:尽管它们仍处于小众位置，但像<a class="ae ky" href="https://elm-lang.org" rel="noopener ugc nofollow" target="_blank"> Elm </a>和<a class="ae ky" href="https://www.haskell.org" rel="noopener ugc nofollow" target="_blank"> Haskell </a>这样的纯函数式语言正在获得关注。有些功能性的语言，如<a class="ae ky" href="https://www.scala-lang.org" rel="noopener ugc nofollow" target="_blank"> Scala </a>和<a class="ae ky" href="https://www.rust-lang.org" rel="noopener ugc nofollow" target="_blank"> Rust </a>，正在起飞。像 C++、Python 这样的流行语言也在它们的清单中加入越来越多的函数式编程。</p><p id="bc05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经习惯了面向对象的代码，那么写函数式程序一开始看起来会很吓人。好消息是，您可以很好地混合使用函数式代码和面向对象代码。函数式编程的一些调整通常足以获得一些好处。所以让我们开始吧！</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/why-developers-are-falling-in-love-with-functional-programming-13514df4048e"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">为什么开发人员会爱上函数式编程</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">从 Python 到 Haskell，这种趋势不会很快消失</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><h1 id="4f5b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">纯函数</h1><p id="072f" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">非函数式编程的讨厌之处在于函数可能会有副作用。也就是说，它们利用了不一定出现在函数声明中的变量。</p><p id="00ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑这个简单的例子，我们将两个数字相加:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="7dc2" class="np mo it nl b gy nq nr l ns nt">b = 3<br/>def add_ab(a):<br/>    return a + b<br/>add_ab(5)</span></pre><p id="562b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">全局变量<code class="fe nu nv nw nl b">b</code>没有出现在<code class="fe nu nv nw nl b">add_ab</code>的声明中，所以如果你想调试它，你必须检查一下<code class="fe nu nv nw nl b">b</code>是否被使用了。听起来很简单，但是对于更大的程序来说可能会很乏味。我们可以很容易地解决这个问题，只要诚实地说出我们在函数中放入了什么:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="91cd" class="np mo it nl b gy nq nr l ns nt">def add_ab_functional(a, b):<br/>    return a + b<br/>add_ab_functional(5, 3)</span></pre><p id="c65b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个愚蠢的小例子。但是对于更大的程序，你会注意到当你不需要担心副作用时，理解和调试代码会容易得多。</p><h1 id="45c7" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">高阶函数</h1><p id="1ec1" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在函数式编程中，可以嵌套函数:要么设计一个以另一个函数作为参数的函数，要么编写一个返回另一个函数的函数。</p><p id="f24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个采用另一个函数的函数的例子，假设您有一个数字数组，并且您想要计算该数组的正弦、余弦和指数。理论上，你可以这样写(<code class="fe nu nv nw nl b">numpy</code>是一个数学的 Python 包):</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="71c4" class="np mo it nl b gy nq nr l ns nt">import numpy as np</span><span id="ff3e" class="np mo it nl b gy nx nr l ns nt"><em class="ny"># make a list of numbers as input values for functions</em><br/>numbers_list = np.arange(0, 2*np.pi, np.pi/10).tolist()</span><span id="736e" class="np mo it nl b gy nx nr l ns nt"><em class="ny"># calculate sine<br/></em>def do_sin(numbers):<br/>    return np.sin(numbers)<br/>sin_list = do_sin(numbers_list)</span><span id="6130" class="np mo it nl b gy nx nr l ns nt"><em class="ny"># calculate cosine<br/></em>def do_cos(numbers):<br/>    return np.cos(numbers)<br/>cos_list = do_cos(numbers_list)</span><span id="cc42" class="np mo it nl b gy nx nr l ns nt"><em class="ny"># calculate exponential<br/></em>def do_exp(numbers):<br/>    return np.exp(numbers)<br/>exp_list = do_exp(numbers_list)</span></pre><p id="4e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好也很简单，但是用完全相同的结构写三个不同的函数有点烦人。相反，我们可以编写一个函数，像这样使用其他函数:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="0db3" class="np mo it nl b gy nq nr l ns nt">import numpy as np</span><span id="6426" class="np mo it nl b gy nx nr l ns nt"><em class="ny"># make a list of numbers as input values for functions</em><br/>numbers_list = np.arange(0, 2*np.pi, np.pi/10).tolist()</span><span id="d2a7" class="np mo it nl b gy nx nr l ns nt"><em class="ny"># calculate with some function<br/></em>def do_calc(numbers, function):<br/>    return function(numbers)</span><span id="02fd" class="np mo it nl b gy nx nr l ns nt"><em class="ny"># calculate sin, cos, and exp</em><br/>new_sin_list = do_calc(numbers_list, np.sin)<br/>new_cos_list = do_calc(numbers_list, np.cos)<br/>new_exp_list = do_calc(numbers_list, np.exp)</span></pre><p id="ef0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不仅更加简洁易读。它也更容易扩展，因为您只需要为一个新的<code class="fe nu nv nw nl b">function</code>添加一行，而不是上面例子中的三行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/1dfbf3f2ecd412ecb147975d84dd029f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iB5mKo9MUP9sjR8oPM-RpQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数式编程的一个关键概念是将函数嵌套在一起。照片由<a class="ae ky" href="https://unsplash.com/@thisisengineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">this engineering RAEng</a>在<a class="ae ky" href="https://unsplash.com/s/photos/mathematics?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="d119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还可以把函数中函数的概念倒过来:不仅可以让一个函数把另一个函数作为自变量；你也可以让它返回一个参数。</p><p id="1017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一个数字数组，您需要<a class="ae ky" href="https://stackabuse.com/functional-programming-in-python/" rel="noopener ugc nofollow" target="_blank">将数组的每个元素</a>递增 2:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="771e" class="np mo it nl b gy nq nr l ns nt">def add2(numbers):     <br/>    incremented_nums = []     <br/>    for n in numbers:         <br/>        incremented_nums.append(n + 2)     <br/>        return incremented_nums</span><span id="265d" class="np mo it nl b gy nx nr l ns nt">print(add2([23, 88])) <em class="ny"># returns [25, 90]</em></span></pre><p id="2d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想增加一个数组的元素，当然，你可以复制粘贴这个函数并用这个增量替换<code class="fe nu nv nw nl b">2</code>。但是有一个更优雅的解决方案:我们可以编写一个函数，它接受任何增量，并返回另一个函数来执行<code class="fe nu nv nw nl b">add2</code>所做的事情，但是针对任何增量。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="4a43" class="np mo it nl b gy nq nr l ns nt">def add_num(increment):<br/>    def add_inc(numbers):<br/>        incremented_nums = []<br/>        for n in numbers:<br/>            incremented_nums.append(n + increment)<br/>        return incremented_nums<br/>    return add_inc</span><span id="876f" class="np mo it nl b gy nx nr l ns nt">add5_25 = add_num(5.25)<br/>print(add5_25([23.37,88.93])) <em class="ny"># returns [28.62, 94.18]</em></span></pre><p id="adca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个例程，每个新函数只需要一行来定义，而不是五行。像接受函数的函数一样，返回函数的函数更容易调试:如果你在<code class="fe nu nv nw nl b">add_num</code>中有一个错误，你只需要修复它。你不需要回去修改<code class="fe nu nv nw nl b">add2</code>和其他任何你用同样方式定义的函数。项目越大，回报就越多。</p><p id="18cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，尽管<code class="fe nu nv nw nl b">add_num</code>是以函数式风格编写的，但它并不纯粹是函数式的。它有一个副作用，<code class="fe nu nv nw nl b">numbers</code>，这使它成为一个不纯的函数。但是没关系:你不需要成为一种编程范式的奴隶；相反，你可以充分利用这两者来最大化你的生产力。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/aa2bbd39591682c33f367b393361e6a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UwOOzWeXCO8xh2NaiXwepw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">装饰者可以让你的代码更加优雅。费尔南多·埃尔南德斯在<a class="ae ky" href="https://unsplash.com/s/photos/developer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="4916" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">装修工</h1><p id="8939" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">当然，你可以将上面的两种方法结合起来，编写一个函数，它不仅接受一个函数作为参数，还返回一个函数。考虑这段代码，我们从上面扩展了<code class="fe nu nv nw nl b">add_num</code>函数:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="1433" class="np mo it nl b gy nq nr l ns nt">def add_num(message):<br/>    def add_inc(increment, numbers):<br/>        message()<br/>        incremented_nums = []<br/>        for n in numbers:<br/>            incremented_nums.append(n + increment)<br/>        return incremented_nums<br/>    return add_inc</span><span id="8885" class="np mo it nl b gy nx nr l ns nt">def message1():<br/>    print("Doing something...")</span><span id="a384" class="np mo it nl b gy nx nr l ns nt"><strong class="nl iu">message1 = add_num(message1)<br/></strong>print(message1(5, [28,93]))</span><span id="efee" class="np mo it nl b gy nx nr l ns nt"><em class="ny"># Doing something...<br/># [33, 98]</em></span></pre><p id="fd0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与上面示例的一个不同之处在于，您可以定制屏幕上输出的消息。例如，在一个更大的程序中，你可以扩展它来考虑不同的错误信息。</p><p id="e47d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">线条<code class="fe nu nv nw nl b">message1 = add_num(message1)</code>是魔法发生的地方:名字<code class="fe nu nv nw nl b">message1</code>现在指向<code class="fe nu nv nw nl b">add_num</code>的内层，即<code class="fe nu nv nw nl b">add_inc</code>。这叫装饰。</p><p id="897d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个区别是参数<code class="fe nu nv nw nl b">increment</code>被向下推了；这只是让下一步更容易处理。</p><p id="3208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe nu nv nw nl b">@</code>语法让装饰更加漂亮(其中的<code class="fe nu nv nw nl b">def add_num</code>部分保持不变):</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="0835" class="np mo it nl b gy nq nr l ns nt"><strong class="nl iu">@add_num<br/></strong>def message1():<br/>    print("Doing something...")</span><span id="b1fa" class="np mo it nl b gy nx nr l ns nt">print(message1(5, [28,93]))</span></pre><p id="ef44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，这只是编写装饰的一种更加简洁的方式。注意，使用 decorator<a class="ae ky" href="https://realpython.com/primer-on-python-decorators/" rel="noopener ugc nofollow" target="_blank">并不意味着</a>你的代码是有效的。更确切地说，装饰者受到函数式编程的启发，就像嵌套函数一样。上面的例子并不纯粹是函数式的，因为它包含了两个副作用，但是它仍然受到了函数式编程的启发。</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/elements-of-functional-programming-in-python-1b295ea5bbe0"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python 中函数式编程的要素</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">了解如何使用 Python 中的 lambda、map、filter 和 reduce 函数来转换数据结构。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="ob l mj mk ml mh mm ks ly"/></div></div></a></div><h1 id="9cd8" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">生成器表达式和列表理解</h1><p id="319a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">列表理解和生成器表达式是 Python 从纯函数式编程语言 Haskell 复制的概念。考虑下面的例子，我们试图计算几个平方数:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="f3bc" class="np mo it nl b gy nq nr l ns nt">numbers = [0, 1, 2, 3, 4]<br/>square_numbers = []</span><span id="04ef" class="np mo it nl b gy nx nr l ns nt">for x in range(5):<br/>    square_numbers.append(x**2)</span><span id="e608" class="np mo it nl b gy nx nr l ns nt">square_numbers <em class="ny"># [0, 1, 4, 9, 16]</em></span></pre><p id="8621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很笨拙，因为我们需要定义两个数组并编写一个<code class="fe nu nv nw nl b">for</code>循环。一个更简洁优雅的方法是用列表理解来做这件事:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="b024" class="np mo it nl b gy nq nr l ns nt">square_numbers = [x**2 for x in range(5)]<br/>square_numbers <em class="ny"># [0, 1, 4, 9, 16]</em></span></pre><p id="9cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过添加一个<code class="fe nu nv nw nl b">if</code>条件，您可以只选择特定的元素。例如，假设我们只想要偶数的平方数:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="091c" class="np mo it nl b gy nq nr l ns nt">even_square_numbers = [x**2 for x in range(5)<br/>    if x%2 == 0]<br/>even_square_numbers <em class="ny"># [0, 4, 16]</em></span></pre><p id="72a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表理解将列表的所有值存储在内存中。这对小对象来说很好，但是如果你处理大的列表，它们会让你的程序变得很慢。这就是生成器表达式发挥作用的地方:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="3054" class="np mo it nl b gy nq nr l ns nt">lots_of_square_numbers = (x**2 for x in range(10000))<br/>lots_of_square_numbers <em class="ny"># &lt;generator object &lt;genexpr&gt; at 0x1027c5c50&gt;</em></span></pre><p id="e548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器表达式不会立即计算对象。这就是为什么如果你试图调用它们，你只会看到一个有趣的表达式(输出的确切形式取决于你的操作系统)。但是，它们使它们以后可以访问。您可以像这样调用生成器表达式的元素:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="e19f" class="np mo it nl b gy nq nr l ns nt">next(lots_of_square_numbers) # 0<br/>next(lots_of_square_numbers) # 1<br/>next(lots_of_square_numbers) # 4<br/>...</span></pre><p id="f799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您可以创建生成器表达式中前几个元素的列表，如下所示:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="81a8" class="np mo it nl b gy nq nr l ns nt">[next(lots_of_square_numbers) for x in range(10)]<br/><em class="ny"># [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</em></span></pre><p id="c9f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其他技巧一样，这不会自动使您的代码变得纯粹实用。这只是从函数式编程中借用的一个概念，在许多情况下都很有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/6614afe1902a95c3ccde0bbf650b1a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_Kga4l0C7wJfyL6MfCYog.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Lambda 表达式可能是常规函数定义的一个很好的替代品。图片由<a class="ae ky" href="https://unsplash.com/@nesabymakers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> NESA 制作</a>在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="6231" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">小函数和 lambda 表达式</h1><p id="5659" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">如果想写一个<a class="ae ky" href="https://docs.python.org/3/howto/functional.html#small-functions-and-the-lambda-expression" rel="noopener ugc nofollow" target="_blank">小函数</a>，这样写也没什么不好:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="93c6" class="np mo it nl b gy nq nr l ns nt">def add_ab(a, b):<br/>    return a + b</span></pre><p id="0302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，你也可以用一个<code class="fe nu nv nw nl b">lambda</code>式的表达:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="4bfd" class="np mo it nl b gy nq nr l ns nt">add_ab2 = lambda a, b: a + b</span></pre><p id="cc9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的长度几乎是一样的，一旦你习惯了它的语法，就很容易读懂。用不用真的看个人口味了。但是正如我们将在下面看到的，它在某些情况下非常方便。</p><p id="fb74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，使用<code class="fe nu nv nw nl b">lambda</code>-表达式不一定会使你的代码功能化，即使它们是函数式编程的一个关键思想。</p><h1 id="671e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">内置 Python 函数</h1><h2 id="68c6" class="np mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">地图()</h2><p id="7baa" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">函数<code class="fe nu nv nw nl b">map()</code>主要返回生成器表达式。这是一个简单的例子:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="dea2" class="np mo it nl b gy nq nr l ns nt">numbers = [0, 1, 2, 3, 4]<br/>squared_numbers_map = list(map(lambda x: x**2, numbers))</span><span id="6692" class="np mo it nl b gy nx nr l ns nt">print(squared_numbers_map)<br/><em class="ny"># [0, 1, 4, 9, 16]</em></span></pre><p id="370f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你前面看到的，你可以用列表理解做同样的事情。然而，当您使用<code class="fe nu nv nw nl b">map()</code>函数时，有时您的代码会更具可读性。</p><h2 id="cde6" class="np mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">过滤器()</h2><p id="df66" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这类似于使用<code class="fe nu nv nw nl b">if</code>子句的列表理解，例如:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="2bf1" class="np mo it nl b gy nq nr l ns nt">squared_numbers_map_even = list(filter(lambda x: x%2 == 0, squared_numbers_map))</span><span id="ce60" class="np mo it nl b gy nx nr l ns nt">print(squared_numbers_map_even)<br/><em class="ny"># [0, 4, 16]</em></span></pre><p id="f9a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以像这样嵌套<code class="fe nu nv nw nl b">map()</code>和<code class="fe nu nv nw nl b">filter()</code>:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="28f8" class="np mo it nl b gy nq nr l ns nt">squared_numbers_map_even_new = list(filter(lambda x: x%2 == 0, list(map(lambda x: x**2, numbers))))</span><span id="7fff" class="np mo it nl b gy nx nr l ns nt">print(squared_numbers_map_even_new)<br/><em class="ny"># [0, 4, 16]</em></span></pre><h2 id="dbb1" class="np mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">枚举()</h2><p id="141c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">如果你在遍历一个列表，并且需要跟踪索引，<code class="fe nu nv nw nl b">enumerate()</code>是一个不错的选择:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="1475" class="np mo it nl b gy nq nr l ns nt">for num in enumerate(squared_numbers_map_even):<br/>    print(num)<br/><em class="ny"># (0, 0)<br/># (1, 4)<br/># (2, 16)</em></span></pre><h2 id="2189" class="np mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated">zip()</h2><p id="b3cf" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">如果需要从两个列表中创建元组，可以使用<code class="fe nu nv nw nl b">zip()</code>:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="c52f" class="np mo it nl b gy nq nr l ns nt">list(zip(['a', 'b', 'c'], (1, 2, 3)))<br/><em class="ny"># [('a', 1), ('b', 2), ('c', 3)]</em></span></pre><p id="3553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe nu nv nw nl b">zip()</code>像生成器表达式一样只返回可迭代的对象，所以<code class="fe nu nv nw nl b">list()</code>包含在这个表达式中。</p><h1 id="4302" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">functools 模块</h1><p id="51da" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">有时候你会有一个函数，它有几个参数，但是你需要修改几个参数。考虑这个简单的例子:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="695d" class="np mo it nl b gy nq nr l ns nt">import functools</span><span id="8b5a" class="np mo it nl b gy nx nr l ns nt">def add_lots_of_numbers(a, b, c, d):<br/>    return a + b + c + d</span><span id="c28a" class="np mo it nl b gy nx nr l ns nt">add_a_and_b_27 = functools.partial(add_lots_of_numbers, c=18, d=9)<br/>add_a_and_b_27(1,2) <em class="ny"># 30</em></span></pre><p id="8121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个模块中，除了<code class="fe nu nv nw nl b">functools.partial()</code>之外，还有<a class="ae ky" href="https://docs.python.org/3/howto/functional.html#the-functools-module" rel="noopener ugc nofollow" target="_blank">几个</a>功能，但这是迄今为止最重要的一个。和以前一样，<code class="fe nu nv nw nl b">partial()</code>并不总是导致函数式代码，但是它是从函数式编程中借用来的一个简洁的概念。</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/the-ultimate-guide-to-writing-better-python-code-1362a1209e5a"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">编写更好的 Python 代码的终极指南</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">让你的软件更快、更易读和更易维护并不需要这么难</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="oo l mj mk ml mh mm ks ly"/></div></div></a></div><h1 id="0b81" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">几个简单的小技巧就能帮上大忙</h1><p id="e673" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">当你开始编码的时候，你可能听说过很多关于面向对象编程的东西，而不是关于函数式编程的。这确实有道理，因为面向对象编程非常有用。</p><p id="1f94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是最近几年，我们遇到了越来越多的问题，当你掌握一些函数式编程的技巧时，这些问题就更容易解决了。</p><p id="bfd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不需要马上学习像 Elm 或者 Haskell 这样的函数式编程语言。相反，您可以提取它们最有用的方面，并直接在 Python 代码中使用它们。</p><p id="e0cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你知道了窍门，你会发现到处都有机会使用它们。编码快乐！</p></div></div>    
</body>
</html>