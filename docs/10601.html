<html>
<head>
<title>List Comprehensions in Python — Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的列表理解—解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/list-comprehensions-in-python-explained-294a464b5245?source=collection_archive---------57-----------------------#2020-07-24">https://towardsdatascience.com/list-comprehensions-in-python-explained-294a464b5245?source=collection_archive---------57-----------------------#2020-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bc9d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">何时使用和不使用列表理解。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6577775a731a5d66b9c69240bcf919e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*piOaGw2aoR0Ejz1CJCuyzg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">希尔特·彼得森在<a class="ae ky" href="https://unsplash.com/s/photos/list?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ed5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> List </strong>是 Python 中内置的数据结构，方括号中是数据点的集合。Python 中其他内置的数据结构有<strong class="lb iu">集合</strong>、<strong class="lb iu">元组</strong>、<strong class="lb iu">字典</strong>。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4f88" class="ma mb it lw b gy mc md l me mf">list_a = [4, 'data', 3.2, True]</span><span id="6916" class="ma mb it lw b gy mg md l me mf">list_a<br/>[4, 'data', 3.2, True]</span></pre><p id="077f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将讨论 python 中的列表理解及其优势。尽管列表理解非常实用，但也有列表理解不是最佳选择的情况。我们也将经历不使用列表理解的情况。</p><p id="ad86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表理解基本上是基于现有列表创建列表。下面是一个列表理解，它根据另一个列表中单词的长度创建一个列表。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="622c" class="ma mb it lw b gy mc md l me mf">words = ['data', 'science', 'machine', 'learning']</span><span id="b6e3" class="ma mb it lw b gy mg md l me mf">word_length = [len(i) for i in words]</span><span id="7a34" class="ma mb it lw b gy mg md l me mf">word_length<br/>[4, 7, 7, 8]</span></pre><p id="35c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表理解的基本语法是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/52561883858227bbc50410750a88a4bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKdU4XWiuSMu12VPCD1wdg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python 列表理解</p></figure><p id="0192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的例子中，expression 是 len(i)，item 是由“I”表示的“words”列表中的元素。当然，iterable 是“单词”列表。我们没有条件语句，让我们再做一个有条件的语句。例如，下面的 list comprehension 创建了一个单词长度大于 5 的列表。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7df4" class="ma mb it lw b gy mc md l me mf">words = ['data', 'science', 'machine', 'learning']</span><span id="4d7c" class="ma mb it lw b gy mg md l me mf">long_words = [i for i in words if len(i) &gt; 5]</span><span id="ff0b" class="ma mb it lw b gy mg md l me mf">long_words<br/>['science', 'machine', 'learning']</span></pre><p id="e609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表达式可以是任何返回值的表达式。Iterable 可以是任何可以迭代返回其元素的对象，如列表、集合、生成器。</p><p id="acf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">条件是至关重要的，因为它们允许过滤掉值或者只选择我们需要的。</p><p id="7789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，下面这段代码创建了一个由范围为(20)的偶数平方组成的列表。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8b3f" class="ma mb it lw b gy mc md l me mf">even_squares = [i*i for i in range(20) if i%2 == 0]</span><span id="eaea" class="ma mb it lw b gy mg md l me mf">even_squares<br/>[0, 4, 16, 36, 64, 100, 144, 196, 256, 324]</span></pre><p id="7b04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建一个具有矩阵最大行数的列表。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ba40" class="ma mb it lw b gy mc md l me mf">#Create a matrix<br/>import numpy as np<br/>A = np.random.randint(10, size=(4,4))<br/>A<br/>array([[1, 7, 4, 4],        <br/>       [5, 0, 0, 6],        <br/>       [7, 5, 8, 4],        <br/>       [1, 3, 2, 2]])</span><span id="651b" class="ma mb it lw b gy mg md l me mf">#select the max of rows<br/>max_element = [max(i) for i in A]<br/>max_element<br/>[7, 6, 8, 3]</span></pre><p id="f79e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以在表达式中加入一个条件。下面这段代码遍历“单词”列表。如果长度大于 7，它将获取单词。它写的是“短词”而不是长度不大于 7 的元素。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="058d" class="ma mb it lw b gy mc md l me mf">words = ['data', 'science', 'artificial', 'intelligence', 'machine', 'learning']</span><span id="9090" class="ma mb it lw b gy mg md l me mf">long_words = [i if len(i) &gt; 7 else 'short word' for i in words]</span><span id="1f34" class="ma mb it lw b gy mg md l me mf">print(long_words)<br/>['short word', 'short word', 'artificial', 'intelligence', 'short word', 'learning']</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="4e92" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated"><strong class="ak">列表理解 vs for 循环 vs 映射</strong></h1><p id="92fa" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们用列表理解所做的也可以用 for 循环或 map 函数来完成。让我们使用 for 循环和 map 函数来做第一个示例:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="36d4" class="ma mb it lw b gy mc md l me mf">#for loop<br/>word_length = []<br/>for word in words:<br/>   word_length.append(len(word))</span><span id="33e9" class="ma mb it lw b gy mg md l me mf">word_length<br/>[4, 7, 7, 8]</span><span id="fbca" class="ma mb it lw b gy mg md l me mf">#map function<br/>word_length = list(map(lambda x: len(x), words))</span><span id="cd9f" class="ma mb it lw b gy mg md l me mf">word_length<br/>[4, 7, 7, 8]</span></pre><p id="332f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用列表理解的优势:</p><ul class=""><li id="8c48" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">它们比循环相对更快。</li><li id="5976" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">它们被认为比循环和映射函数更具 pythonic 性。</li><li id="d099" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">列表理解的语法更容易阅读和理解。</li></ul><p id="553b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过创建一个包含前 50000 个整数的平方的列表来做一个比较:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/874fef1d83d01eeeafa991fcaf266738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*U5n_Kr_7EA0godYtrUW90A.png"/></div></figure><p id="5c78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，列表理解是最快的。</p><p id="d533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:每一个列表理解都可以用 for 循环来编写，但是并不是每一个 for 循环都可以用列表理解来表示。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="cf57" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated"><strong class="ak">什么时候不用清单理解</strong></h1><p id="0d45" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">列表理解将整个输出列表加载到内存中。这对于小型或中型的列表来说是可以接受的，甚至是可取的，因为它使操作更快。然而，当我们处理大型列表(例如 10 亿个元素)时，应该避免理解列表。这可能会导致您的计算机崩溃，由于内存需求的极端数额。</p><p id="ba9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这种大型列表，更好的替代方法是使用<strong class="lb iu">生成器</strong>，它实际上不会在内存中创建大型数据结构。生成器在使用项目时创建项目。项目使用后，生成器会将其丢弃。使用生成器，我们可以请求 iterable 中的下一项，直到到达末尾，每次存储一个值。</p><p id="be2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的生成器对前 1000 万个整数的平方求和。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7a7b" class="ma mb it lw b gy mc md l me mf">sum(i*i for i in range(10000000))</span><span id="b50f" class="ma mb it lw b gy mg md l me mf">333333283333335000000</span></pre><p id="7bdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">映射功能也不会导致内存问题。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1d75" class="ma mb it lw b gy mc md l me mf">sum(map(lambda i: i*i, range(10000000)))</span><span id="3644" class="ma mb it lw b gy mg md l me mf">333333283333335000000</span></pre><p id="10e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">天下没有免费的午餐！生成器或映射函数不会导致内存问题，但是它们比列表理解相对要慢。同样，列表理解的速度来自于内存的过度使用。您可以根据您的应用决定使用哪一种。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="f39b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>