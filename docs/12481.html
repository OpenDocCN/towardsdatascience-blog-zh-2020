<html>
<head>
<title>Deploy APIs With Python and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 和 Docker 部署 API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploy-apis-with-python-and-docker-4ec5e7986224?source=collection_archive---------5-----------------------#2020-08-28">https://towardsdatascience.com/deploy-apis-with-python-and-docker-4ec5e7986224?source=collection_archive---------5-----------------------#2020-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1c2f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Flask、Docker 和 Google Cloud 部署 API 的权威指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d4e8965db553b03f91ebfee9b6f6bbc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OpLSQ4dsODSjfBOO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@josephtpearson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约瑟夫·皮尔森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="382c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">这里有一些软件开发中的技巧，它们就像闸门一样阻挡着广阔的机会海洋。当学习其中一种技能时，似乎一个全新的世界突然被照亮了。</p><p id="596b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这篇文章，我们将涵盖我认为是这些技能之一。能够编写可部署到互联网并与 API 通信的代码。</p><p id="fbf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建一个可部署的 API 需要几个子技能，我们将在组装 API 时讨论这些子技能。然而，罗马不是一天建成的，精通(甚至能力)也不是——所以这不是一篇五分钟内从零到英雄的文章。</p><p id="6511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是一个介绍，我们将涵盖要点——不多不少。在本文的最后，我们将拥有一个托管在云上的全功能 API。</p><p id="f188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，我们将涵盖—</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="5986" class="mj mk it mf b gy ml mm l mn mo">&gt; <strong class="mf iu">Build an</strong> <strong class="mf iu">API </strong>with Flask<br/>&gt; <strong class="mf iu">Package </strong>our app with Docker<br/>&gt; <strong class="mf iu">Deploy </strong>with Google Cloud Platform (GCP)<br/>&gt; <strong class="mf iu">Test</strong> with Postman</span></pre><p id="042e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在这里找到本文<a class="ae ky" href="https://github.com/jamescalam/gcp-api" rel="noopener ugc nofollow" target="_blank">的 GitHub repo。</a></p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="dc4c" class="mw mk it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">用 Flask 构建 API</h1><p id="27a6" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们创建一个新文件夹，其中包含一个名为<code class="fe ns nt nu mf b">app.py</code>的 Python 脚本。该脚本将包含我们的 API 代码，其结构如下:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="8910" class="mj mk it mf b gy ml mm l mn mo">imports</span><span id="acc7" class="mj mk it mf b gy nv mm l mn mo">app initialization</span><span id="5f33" class="mj mk it mf b gy nv mm l mn mo">API class<br/>    GET method<br/>    POST method<br/>    DELETE method</span><span id="04ba" class="mj mk it mf b gy nv mm l mn mo">HTTP mapping</span></pre><p id="4936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果事情的顺序变得混乱——完整的<code class="fe ns nt nu mf b">app.py</code>脚本在这一部分的末尾，你可以在<a class="ae ky" href="https://github.com/jamescalam/gcp-api" rel="noopener ugc nofollow" target="_blank"> GitHub 上找到这个项目。</a></p><h2 id="4bd9" class="mj mk it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated">设置</h2><p id="fb0b" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><strong class="lb iu">导入和应用初始化</strong></p><p id="cb89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们在导入中设置了最低限度，并像这样初始化我们的 API flask 应用程序:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="0a33" class="mj mk it mf b gy ml mm l mn mo">from flask import Flask<br/>from flask_restful import Resource, Api, reqparse<br/>import pandas as pd<br/>import os</span><span id="b0ec" class="mj mk it mf b gy nv mm l mn mo">app = Flask(__name__)<br/>api = Api(app)</span></pre><h2 id="2362" class="mj mk it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated">API 类别</h2><p id="4aae" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在我们的 API 脚本中，我们需要定义一个包含 HTTP 方法 GET、POST 和 DELETE 的类。</p><p id="ea6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Flask 需要知道这个类是我们 API 的入口点，所以我们用类定义传入<code class="fe ns nt nu mf b">Resource</code>。我们将创建一个名为<code class="fe ns nt nu mf b">Places</code>的类:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="5482" class="mj mk it mf b gy ml mm l mn mo">class Places(Resources):<br/>    &lt;methods go here&gt;</span></pre><p id="8fab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要告诉 Flask 这个 API 类的入口点在哪里。例如，如果我们的 API 位于<code class="fe ns nt nu mf b">www.api.com</code>，我们可能想要指定在<code class="fe ns nt nu mf b"><a class="ae ky" href="http://www.api.com/places." rel="noopener ugc nofollow" target="_blank">www.api.com<strong class="lb iu">/places</strong></a></code> <a class="ae ky" href="http://www.api.com/places." rel="noopener ugc nofollow" target="_blank">提供<code class="fe ns nt nu mf b">Places</code>类的入口。</a></p><p id="697e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe ns nt nu mf b">add_resource</code>方法来做到这一点:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="cb33" class="mj mk it mf b gy ml mm l mn mo">api.add_resource(Places, '/places')</span></pre><p id="a307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法被放在类定义之外，并遵循类定义。</p><p id="5a07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这意味着我们可以在 API 中添加多个类和入口点。这对于更复杂的服务尤其有用——尽管在本文中我们将只讨论其中一个。</p><p id="a131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我们将把代码中嵌入的数据作为 Python 字典来操作。看起来是这样的:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="d76e" class="mj mk it mf b gy ml mm l mn mo">DATA = {<br/>    'places':<br/>        ['rome',<br/>         'london',<br/>         'new york city',<br/>         'los angeles',<br/>         'brisbane',<br/>         'new delhi',<br/>         'beijing',<br/>         'paris',<br/>         'berlin',<br/>         'barcelona']<br/>}</span></pre><p id="4d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">获取</strong></p><p id="edd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用这种方法来获取数据，在我们的例子中，数据就是我们的<code class="fe ns nt nu mf b">DATA</code>字典。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="ed29" class="mj mk it mf b gy ml mm l mn mo">def get(<em class="oh">self</em>):<br/>    <em class="oh"># return our data and 200 OK HTTP code<br/>    </em>return {'data': DATA}, 200</span></pre><p id="4133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">帖子</strong></p><p id="2dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">POST 方法用于将数据添加到我们的<code class="fe ns nt nu mf b">DATA['places']</code>列表中。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="f7af" class="mj mk it mf b gy ml mm l mn mo">def post(<em class="oh">self</em>):<br/>    <em class="oh"># parse request arguments<br/>    </em>parser = reqparse.RequestParser()<br/>    parser.add_argument('location', <em class="oh">required</em>=True)<br/>    args = parser.parse_args()</span><span id="ce6e" class="mj mk it mf b gy nv mm l mn mo"><em class="oh"># check if we already have the location in places list<br/>    </em>if args['location'] in DATA['places']:<br/>        <em class="oh"># if we do, return 401 bad request<br/>        </em>return {<br/>            'message': f"'{args['location']}' already exists."<br/>            }, 401<br/>    else:<br/>        <em class="oh"># otherwise, add the new location to places<br/>        </em>DATA['places'].append(args['location'])<br/>        return {'data': DATA}, 200</span></pre><p id="6978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了什么事？</p><ul class=""><li id="7414" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated"><code class="fe ns nt nu mf b">reqparse</code>库允许我们解析传递给 POST 请求的参数。例如，如果我们的 places API 位于 web 地址<code class="fe ns nt nu mf b">api.com/places</code>处，我们可以指定我们要添加的新位置的<code class="fe ns nt nu mf b">location</code>，如下所示:</li></ul><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="9f80" class="mj mk it mf b gy ml mm l mn mo">api.com/places?<strong class="mf iu">location=sydney</strong></span></pre><ul class=""><li id="8318" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated">在取出位置参数后，我们需要检查它是否已经存在于<code class="fe ns nt nu mf b">DATA['places']</code>中——这是我们用<code class="fe ns nt nu mf b">if</code>语句完成的。如果数据已经存在，我们简单地返回<code class="fe ns nt nu mf b">409 Conflict</code>和一条简短的消息，解释所提供的位置已经存在。</li><li id="f855" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">否则，我们可以将新位置添加到我们的<code class="fe ns nt nu mf b">DATA['places']</code>列表中，然后返回新的<code class="fe ns nt nu mf b">DATA</code>和一个<code class="fe ns nt nu mf b">200 OK</code> HTTP 代码。</li></ul><p id="15b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">删除</strong></p><p id="a0d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用 DELETE 作为 POST 的一个等价的相反的动作。用户指定要从<code class="fe ns nt nu mf b">DATA['places']</code>列表中移除的位置。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="e187" class="mj mk it mf b gy ml mm l mn mo">def delete(<em class="oh">self</em>):<br/>    <em class="oh"># parse request arguments<br/>    </em>parser = reqparse.RequestParser()<br/>    parser.add_argument('location', <em class="oh">required</em>=True)<br/>    args = parser.parse_args()</span><span id="ab7c" class="mj mk it mf b gy nv mm l mn mo"><em class="oh"># check if we have given location in places list<br/>    </em>if args['location'] in DATA['places']:<br/>        <em class="oh"># if we do, remove and return data with 200 OK<br/>        </em>DATA['places'].remove(args['location'])<br/>        return {'data': DATA}, 200<br/>    else:<br/>        <em class="oh"># if location does not exist in places list return 404<br/>        </em>return {<br/>            'message': f"'{args['location']}' does not exist."<br/>            }, 404</span></pre><p id="8772" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了什么事？</p><p id="c7dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个相等且相反的操作，我们稍微修改了 POST 逻辑:</p><ul class=""><li id="1d0b" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated">我们还是用同样的方法使用<code class="fe ns nt nu mf b">reqparse</code>。</li><li id="53bf" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">对于 location 参数，我们再次使用相同的<code class="fe ns nt nu mf b">if</code>语句来检查它是否已经存在于<code class="fe ns nt nu mf b">DATA['places']</code>中。如果是的话，我们从 T3 中 T2 它，并返回新的 T4 和一个 T5 HTTP 代码。</li><li id="39bf" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">否则，我们返回消息<code class="fe ns nt nu mf b">404 Not Found</code>，解释所提供的位置在<code class="fe ns nt nu mf b">DATA['places']</code>中不存在。</li></ul><h2 id="641b" class="mj mk it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated">总共</h2><p id="6087" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如果我们将所有这些部分放在一起，我们将得到以下脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="f5fa" class="mw mk it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">带 Docker 的包装</h1><p id="45d5" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">下一步，我们将创建一个 Docker 映像。这里有两个相似的术语——图像和容器。</p><p id="d80d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<strong class="lb iu">映像</strong>本质上是一个蓝图——而一个<strong class="lb iu">容器</strong>是一个根据蓝图构建的结构/部署。</p><p id="5e51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将创建我们的<strong class="lb iu">映像</strong>，然后将它部署到 Google cloud(在那里它将成为一个容器)。</p><p id="9699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建我们的 Docker 形象有三个关键步骤:</p><ol class=""><li id="eeb1" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu oy oo op oq bi translated">获取码头工人</li><li id="8f65" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu oy oo op oq bi translated">设置我们的 docker 文件</li><li id="e9db" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu oy oo op oq bi translated">建立我们的形象</li></ol></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="bbee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> 1。</span>Docker 文档能够比我更好地指导你完成安装过程！你可以在这里找到它们。</p><p id="b0d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于 Windows 或 Mac 上 Docker 的概述，请查看此视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz ox l"/></div></figure><p id="e1c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Windows 上的 Docker 为 1:46:21，Mac 上的 Docker 为 1:53:22。</p><p id="9ecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> 2。因为我们将 API 部署为 docker 容器，所以我们需要在目录中包含一个名为<strong class="lb iu"> Dockerfile </strong>的容器设置文件。</span></p><p id="3623" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的 docker 文件中，我们将为三个 Python 库使用<code class="fe ns nt nu mf b">RUN</code>命令——所有这些都将指定使用一个<strong class="lb iu"> requirements.txt </strong>文件。</p><p id="c6eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的简单 API，它看起来像这样:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="9b29" class="mj mk it mf b gy ml mm l mn mo">flask<br/>flask-restful<br/>gunicorn</span></pre><p id="4d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<strong class="lb iu"> Dockerfile，</strong>中，我们概述了我们的形象(容器蓝图)。Docker 将读取提供“构建”指令的<code class="fe ns nt nu mf b">Dockerfile</code>。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="6eb2" class="mj mk it mf b gy ml mm l mn mo">FROM python:3.6-slim-buster</span><span id="a59f" class="mj mk it mf b gy nv mm l mn mo">WORKDIR /app<br/>COPY . .</span><span id="aed1" class="mj mk it mf b gy nv mm l mn mo">RUN pip install -r requirements.txt</span><span id="9c8e" class="mj mk it mf b gy nv mm l mn mo">CMD exec gunicorn --bind :$PORT --workers 1 --threads 8 --timeout 0 app:app</span></pre><p id="90bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了什么？</p><ul class=""><li id="e985" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated">我们使用另一个<strong class="lb iu">官方</strong>图像和<code class="fe ns nt nu mf b">FROM python:3.6-slim-buster</code>初始化我们的图像。这个脚本初始化官方的 Docker Python 3.6‘slim-buster’图像——官方 Python 图像的完整列表在<a class="ae ky" href="https://hub.docker.com/_/python" rel="noopener ugc nofollow" target="_blank">这里</a>可以找到。</li><li id="e72f" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">接下来，我们将图像中的活动目录设置为带有<code class="fe ns nt nu mf b">WORKDIR /app</code>的<code class="fe ns nt nu mf b">/app</code>——这是我们的 Google Cloud 实例所期望的结构。</li><li id="1e6c" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">现在我们<code class="fe ns nt nu mf b">COPY</code>从源文件目录到镜像文件系统的所有东西。在这种情况下，从目录<code class="fe ns nt nu mf b">Dockerfile</code>所在—到活动图像目录<code class="fe ns nt nu mf b">/app</code>。</li><li id="f83f" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">我们的依赖关系列表<code class="fe ns nt nu mf b">requirements.txt</code>现在在镜像文件系统中，我们<code class="fe ns nt nu mf b">RUN pip install</code>递归地<code class="fe ns nt nu mf b">-r</code>遍历<code class="fe ns nt nu mf b">requirements.txt</code>的每一行。实质上就是:</li></ul><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="a1f0" class="mj mk it mf b gy ml mm l mn mo">pip install flask<br/>pip install flask-restful<br/>pip install gunicorn</span></pre><ul class=""><li id="73cd" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated">最后，我们使用<code class="fe ns nt nu mf b"><a class="ae ky" href="https://gunicorn.org/" rel="noopener ugc nofollow" target="_blank">gunicorn</a></code>包初始化我们的 HTTP 服务器。我们使用<code class="fe ns nt nu mf b">CMD</code>指令来执行<code class="fe ns nt nu mf b">gunicorn</code>并传递几个服务器设置参数。</li></ul><p id="247f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> 3。</span>我们的最后一步是构建 Docker 图像，稍后我们将把它上传到 Google 容器注册中心。</p><p id="c651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要构建映像，请打开 CLI，导航到包含我们的文件的目录，然后键入:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="aaeb" class="mj mk it mf b gy ml mm l mn mo">docker build -t tut-api .</span></pre><ul class=""><li id="1cd1" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated">这里，<code class="fe ns nt nu mf b">docker build</code>是 Docker 镜像构建命令。</li><li id="e3ff" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">我们使用<code class="fe ns nt nu mf b">-t</code>标志来指定我们的图像名称。</li><li id="10a0" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><code class="fe ns nt nu mf b">tut-api</code>仅仅是我们形象的名称，随便你怎么称呼它。</li><li id="67f4" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><code class="fe ns nt nu mf b">.</code>告诉 docker 将当前目录中的所有内容包含在映像中<em class="oh">(别忘了这一点，我几乎每次都这么做)</em>。</li></ul><p id="0950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以继续将我们的 API 部署到云中。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="a46d" class="mw mk it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">部署到云</h1><p id="314b" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">这里，我们将使用谷歌云平台(GCP)的容器注册表来存储我们的 Docker 映像，并使用 Cloud Run 来部署它。</p><h2 id="4470" class="mj mk it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated">项目和容器注册</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/4af6d2a15106e439eea1692ea350b11c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ayn9Ka8Cmj6ox-YbfB1CQ.png"/></div></div></figure><p id="8ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要建立一个项目。我们首先在云控制台中导航到<a class="ae ky" href="https://console.cloud.google.com/projectselector2/home/dashboard" rel="noopener ugc nofollow" target="_blank">项目选择器页面，然后点击<strong class="lb iu">创建项目</strong>。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/4cb357e27a359a259dfed8a67ff379c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cW-erwD12vgabMn4YMm8uw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">记下<strong class="bd pc">项目 ID </strong> —我们稍后会用到。</p></figure><p id="8f49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们简单地给我们的项目起个名字——我的是<strong class="lb iu"> medium </strong>。</p><p id="13ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要在谷歌控制台中导航到<a class="ae ky" href="https://console.cloud.google.com/gcr" rel="noopener ugc nofollow" target="_blank">容器注册表</a> (GCR)。如果我们已经正确设置了我们的项目，我们将会看到如下所示的屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/87a25ce5b8053e94fbdadbd1ef63fdb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c90eG7Xm4JwrysyNogKTWw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的空谷歌容器注册(GCR)屏幕。</p></figure><h2 id="a992" class="mj mk it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated">云构建</h2><p id="7e4d" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们将使用云构建将我们的映像构建到一个容器中。在我们这样做之前，我们需要为我们的项目启用云构建 API。只需<a class="ae ky" href="https://console.cloud.google.com/flows/enableapi?apiid=cloudbuild.googleapis.com" rel="noopener ugc nofollow" target="_blank">点击此处</a>并选择您正在进行的项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/a94a3baa2a850aecae66c02efcb6d7e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NsAwaEjqk8C1yWpfUGqn2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为云构建 API 注册项目。</p></figure><p id="8904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了项目设置，我们需要使用 Google Cloud SDK 将我们的 API Docker 映像推送到 GCR——我们从这里下载<a class="ae ky" href="https://cloud.google.com/sdk/install" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="fa42" class="mj mk it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated">证明</h2><p id="6470" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">安装完成后，我们需要登录 gcloud。为此，只需在 CMD 提示符(或等效的 CLI)中键入:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="007c" class="mj mk it mf b gy ml mm l mn mo">gcloud auth login</span></pre><p id="904b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令将打开我们的 web 浏览器，允许我们像往常一样登录。然后，我们将 Docker 配置为使用我们的凭证:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="8117" class="mj mk it mf b gy ml mm l mn mo">gcloud auth configure-docker</span></pre><h2 id="0987" class="mj mk it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated">上传到容器注册表</h2><p id="3851" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们将使用 GCR 来存储我们的形象。为了构建我们的容器并将其保存到注册表中，我们导航到我们的 API 目录并<code class="fe ns nt nu mf b">submit</code>它:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="d467" class="mj mk it mf b gy ml mm l mn mo">gcloud builds submit --tag gcr.io/[PROJECT-ID]/tut-api</span></pre><ul class=""><li id="42c0" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated"><code class="fe ns nt nu mf b">gcloud builds submit</code>是我们用来将图像提交给<strong class="lb iu">云构建</strong>的命令。</li></ul><p id="4187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的注册表位置作为<strong class="lb iu">目标映像</strong>提供，其中:</p><ul class=""><li id="dc77" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated"><code class="fe ns nt nu mf b"><em class="oh">gcr.io</em></code> <em class="oh">是</em> <a class="ae ky" href="https://cloud.google.com/container-registry/docs/pushing-and-pulling#tag_the_local_image_with_the_registry_name" rel="noopener ugc nofollow" target="_blank"> <em class="oh"> GCR 主机名</em> </a> <em class="oh">。</em></li><li id="a5bf" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><code class="fe ns nt nu mf b"><em class="oh">[PROJECT-ID]</em></code> <em class="oh">是我们的项目 ID，这是我们在创建项目时看到的——对我来说是</em> <code class="fe ns nt nu mf b"><em class="oh">medium-286319</em></code> <em class="oh">。</em></li><li id="1589" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><code class="fe ns nt nu mf b"><em class="oh">tut-api</em></code> <em class="oh">是我们的形象名称。</em></li></ul><p id="8113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们导航回我们的注册表，我们应该会看到我们新上传的 Docker 映像(这可能需要一些时间来构建，请查看您的云构建仪表板):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/748649a29a6e41292edc96c8e7f0b633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lLQJzENHRoOXOAEg2PA5Ag.png"/></div></div></figure><h2 id="0fb3" class="mj mk it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated">使用云运行部署</h2><p id="739c" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">有了 Docker 容器，我们就可以通过 Cloud Run 将它部署到 web 上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/7ed9cf0fd6d6bc41dabe8b7a3c9edbc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JziG7I9364N5zBjIT7wWWQ.png"/></div></div></figure><p id="4c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过点击左上角的导航按钮(在<a class="ae ky" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> GCP 控制台</a>中)并选择<strong class="lb iu">云运行</strong>来打开云运行控制台。</p><p id="c1d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将看到云运行界面，我们通过单击<strong class="lb iu">创建服务</strong>来部署我们的容器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/3fe4864a45bd80967a48f7de078c1bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AoQFPYeCbCgm9Q_5UCk0kA.png"/></div></div></figure><p id="d858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们(2)输入我们的首选部署设置，(3–4)选择我们的容器映像，以及(5)创建我们的部署！</p><p id="9133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的 API 被部署之后，我们可以在云运行控制台的顶部找到 API 的 URL。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/2f9064b838aef00a42a77b4e0910d15b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3dQqD4bXSA1KUhNM76FHg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd pc">云运行</strong>中 API 的 URL。</p></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="b8ca" class="mw mk it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">测试我们的部署</h1><p id="a81a" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">对于测试 API，<strong class="lb iu"> Postman </strong>是你的朋友——在这里找到<a class="ae ky" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank">下载链接</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/23802aaf53a85a7eb84e2844fa5705a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R3WPnAZm3ojJoka8TgE3fg.png"/></div></div></figure><p id="e7d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完成后，打开 Postman 并输入 API 的网址，例如:</p><p id="222d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu mf b"><a class="ae ky" href="https://tut-api-2abcdefgh-ew.a.run.app/." rel="noopener ugc nofollow" target="_blank">https://tut-api-2czbipghsq-ew.a.run.app/</a></code></p><p id="7ef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的代码中，我们将我们的<code class="fe ns nt nu mf b">Places</code>类的位置指定为<code class="fe ns nt nu mf b">/places</code>:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="d7da" class="mj mk it mf b gy ml mm l mn mo">api.add_resource(Places, '/places')</span></pre><p id="2aa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们知道要访问包含在<code class="fe ns nt nu mf b">Places</code>中的方法，我们必须将<code class="fe ns nt nu mf b">/places</code>添加到我们的 API 地址:</p><p id="d22a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu mf b"><a class="ae ky" href="https://tut-api-2abcdefgh-ew.a.run.app/places" rel="noopener ugc nofollow" target="_blank">https://tut-api-2czbipghsq-ew.a.run.app<strong class="lb iu">/places</strong></a></code></p><h2 id="af34" class="mj mk it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated">得到</h2><p id="cdf5" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">对于 GET 请求，这就是我们所需要的—将其输入地址栏，在下拉列表中单击<strong class="lb iu"> GET </strong>，然后单击<strong class="lb iu"> Send </strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/7e915ed78c6d24ceb7a2f84e42c3c684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BfEjwe5fgwf2kH6YfZnYdw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">顶栏显示我们正在向<a class="ae ky" href="https://tut-api-2czbipghsq-ew.a.run.app/places." rel="noopener ugc nofollow" target="_blank"><strong class="bd pc">https://tut-api-2czbipghsq-ew.a.run.app/places</strong>发送一个<strong class="bd pc"> GET </strong>请求。</a>底部区域显示我们的<strong class="bd pc">数据</strong>响应，右上角显示<strong class="bd pc">状态:200 OK </strong>。</p></figure><p id="bdd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也测试一下其他方法——记住为 POST 和 DELETE 请求添加我们的<code class="fe ns nt nu mf b">location</code>参数，并更新请求类型(在下拉列表中)。</p><h2 id="2c09" class="mj mk it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated">邮政</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/da0e86008e43e3e5909fe404d695cd18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PmZAC27vF9Y9VmdMTf-uOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在下拉列表中选择<strong class="bd pc">岗位</strong>，添加<strong class="bd pc">？location=sydney </strong>到地址栏，点击<strong class="bd pc">发送</strong>。我们将返回我们的<strong class="bd pc">数据</strong>附加 sydney。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/a420252caa0c0e58c0be27bf21cd541d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZzrS1hN80zTpXbHffPcZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">仍然使用<strong class="bd pc"> POST </strong>，我们将地址栏中的悉尼改为<strong class="bd pc">罗马</strong>，并点击<strong class="bd pc">发送</strong>。我们将返回一个<strong class="bd pc"> 401 未授权的</strong> HTTP 代码和一条简单的消息，告诉我们<strong class="bd pc">罗马</strong>已经存在。</p></figure><h2 id="2f9f" class="mj mk it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated">删除</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/2b282e11969cc02da4a2725dda404253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_PQhdpnc_tsJ_pF09S9-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在下拉列表中选择<strong class="bd pc">删除</strong>，我们保留<strong class="bd pc">位置</strong>为<strong class="bd pc">罗马</strong>，点击<strong class="bd pc">发送</strong>。我们将返回删除了<strong class="bd pc">罗马</strong>的<strong class="bd pc">数据</strong>。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/06cc2b1600b557384685f42dda08fef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lAuH7KvykusNSnDu1dmD7A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">现在，如果我们试图<strong class="bd pc">删除东京</strong>(不存在)——我们将返回一个<strong class="bd pc"> 404 Not Found </strong> HTTP 代码，并带有一条消息告诉我们<strong class="bd pc">东京</strong>不存在。</p></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="c715" class="mw mk it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">打开闸门</h1><p id="e6a7" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">这就是这个简单的 API 示例，它内置在 Flask 中，并使用 Docker 部署在 GCP 上。</p><p id="79fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，构建一个 API 并将其部署到 web 上是一个极其简单而高效的过程。这并不难，并为我们打开了一片广阔的机会之门。</p><p id="aace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章——如果你有任何问题或建议，请随时通过<a class="ae ky" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或在下面的评论中联系我们。如果你想要更多这样的内容，我也会在<a class="ae ky" href="https://www.youtube.com/c/jamesbriggs" rel="noopener ugc nofollow" target="_blank"> YouTube </a>上发布。</p><p id="9295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="60ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您喜欢这篇文章，并且有兴趣进一步拓展您在网络技术方面的技能组合，请在此尝试我的数据科学角度介绍:</p><div class="pp pq gp gr pr ps"><a rel="noopener follow" target="_blank" href="/how-to-use-angular-to-deploy-tensorflow-web-apps-5675b5a042cc"><div class="pt ab fo"><div class="pu ab pv cl cj pw"><h2 class="bd iu gy z fp px fr fs py fu fw is bi translated">如何使用 Angular 部署 TensorFlow Web 应用程序</h2><div class="pz l"><h3 class="bd b gy z fp px fr fs py fu fw dk translated">在角度构建的 web 应用程序中使用 Python 构建的模型</h3></div><div class="qa l"><p class="bd b dl z fp px fr fs py fu fw dk translated">towardsdatascience.com</p></div></div><div class="qb l"><div class="qc l qd qe qf qb qg ks ps"/></div></div></a></div></div></div>    
</body>
</html>