<html>
<head>
<title>Dealing with extra white spaces while reading CSV in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阅读熊猫 CSV 时处理多余的空格</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dealing-with-extra-white-spaces-while-reading-csv-in-pandas-67b0c2b71e6a?source=collection_archive---------3-----------------------#2020-07-12">https://towardsdatascience.com/dealing-with-extra-white-spaces-while-reading-csv-in-pandas-67b0c2b71e6a?source=collection_archive---------3-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1502" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么我们关心空白？内置熊猫功能，自定义处理。1M 测试数据的创建和性能测试。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b5d9478f2cd334954365cb48051c3658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cMhUzotU9QwALfQe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的同事说。csv 不是一篇论文，所以我们不希望逗号后面有任何空格(或任何其他分隔符)。同样的观点也适用于 rfc4180 的创建者，RFC 4180 通常被理解为 CSV 文件的指导方针。尽管如此，他们仍然是有创造力的开发者。csv 导出带有不必要的空格。这些额外的字符不仅增加了我们数据的大小，而且会带来更大的麻烦。</p><p id="d170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将:</p><ul class=""><li id="3c49" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="#965d" rel="noopener ugc nofollow">回顾我们为什么关注 CSV 中的空格</a></li><li id="3560" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#2362" rel="noopener ugc nofollow">使用 Pandas 的</a> <code class="fe mj mk ml mm b"><a class="ae ky" href="#2362" rel="noopener ugc nofollow">read_csv()</a></code> <a class="ae ky" href="#2362" rel="noopener ugc nofollow">方法</a>设置基准</li><li id="73c6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#0f5a" rel="noopener ugc nofollow">探索</a> <code class="fe mj mk ml mm b"><a class="ae ky" href="#0f5a" rel="noopener ugc nofollow">skipinitialspace</a></code> <a class="ae ky" href="#0f5a" rel="noopener ugc nofollow">参数</a></li><li id="83e1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#ab04" rel="noopener ugc nofollow">试试正则表达式分隔符</a></li><li id="786e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#c451" rel="noopener ugc nofollow">由于报价问题，放弃正则表达式分隔符</a></li><li id="80ce" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#9281" rel="noopener ugc nofollow">对加载的数据帧应用正则表达式</a></li><li id="46b4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#990f" rel="noopener ugc nofollow">测试</a> <code class="fe mj mk ml mm b"><a class="ae ky" href="#990f" rel="noopener ugc nofollow">str.strip()</a></code> <a class="ae ky" href="#990f" rel="noopener ugc nofollow">在所有字符串列上应用的列方式</a></li><li id="7500" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#2a2d" rel="noopener ugc nofollow">解释为什么 NaN 很重要</a></li><li id="2e6d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#b1dd" rel="noopener ugc nofollow">使用</a> <code class="fe mj mk ml mm b"><a class="ae ky" href="#b1dd" rel="noopener ugc nofollow">faker</a></code>生成 100 万行测试数据</li><li id="71b6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#f562" rel="noopener ugc nofollow">测量每个算法在空白区域清理的速度和有效性</a></li></ul><p id="3a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，你可以和我一起使用包含所有练习的 Jupiter 笔记本来遵循代码，这些练习可以从<a class="ae ky" href="https://github.com/vaasha/Data-Analysis_in-Examples/blob/master/White%20Spaces%20In%20CSVs/Dealing_with_white_space_in_csv_pandas.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载。</p><h2 id="965d" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">为什么空白是一个问题？</h2><ol class=""><li id="ec39" class="lv lw it lb b lc ng lf nh li ni lm nj lq nk lu nl mb mc md bi translated">比较失败</li></ol><p id="8d9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有和没有空格的字符串是不一样的。<code class="fe mj mk ml mm b">"ABC" != " ABC"</code>这两个 ABC 并不相等，但差别很小，你往往不会注意到。如果没有引号括住字符串，您很难<code class="fe mj mk ml mm b">ABC != ABC</code>。但是计算机程序在解释中是不会被腐蚀的，如果这些值是一个合并键，你将会得到一个空的结果。</p><p id="678a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.NaN 值</p><p id="04ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">空白字符串、空格和制表符在很多情况下被认为是熊猫中用 NaN 表示的空值。但是不确定数量的空格不会自动转换成 NaN 值，您可能会得到意想不到的结果，因为例如<code class="fe mj mk ml mm b">count(NaN) = 0</code>而<code class="fe mj mk ml mm b">count(" ")= 1</code>。</p><p id="2260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.大小</p><p id="95e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管空白几乎看不见，但是在文件中堆积数百万个空白，它们会占用一些空间。其他时候，它们可能会溢出数据库列的大小限制，导致更好的情况下出现错误，并修整最后一个字符，该字符的位置被前面的空格偷走。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="2362" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">熊猫里的空格怎么处理？</h2><p id="5584" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">让我们开始探索 Python 的 Pandas 库中处理 CSV 中空白的选项。作为基准，让我们简单地导入。使用<code class="fe mj mk ml mm b">pd.read_csv()</code>功能的带空格的 csv。</p><p id="cfbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了描述如何处理空白，我们将使用一个 4 行数据集(为了测试每种方法的性能，我们将生成一百万条记录，并在本文末尾尝试处理它)。我们的数据集包含这些列:</p><ul class=""><li id="11f1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu"> Id </strong>标识每行</li><li id="fbdf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">街道</strong>有起始和结尾空白</li><li id="3000" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">有前导空格的城市</strong></li><li id="9f67" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">工资</strong>是数字</li><li id="7d8a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">日期</strong>有日期格式</li></ul><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="1ba3" class="mn mo it mm b gy oa ob l oc od">data = """Id,Street,City,Salary,Date<br/>1, 5th Ave. , Indiana, 100, 2020-07-01<br/>2, Downing Street , San Francisco, 200, 2020-07-02<br/>3,  , New York, 300, 2020-07-03<br/>4,   1600 Amphitheatre, New York, 400, 2020-07-04<br/>"""</span></pre><p id="0fac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到数据包含不必要的空白，我们的目标是尽可能有效地删除它们。</p><p id="cbb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样我们就不必将这些数据存储到一个. csv 文件中，我们稍后会读取该文件，我们将使用<code class="fe mj mk ml mm b">io.StringIO(data).</code>将它传递给 Pandas</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="1828" class="mn mo it mm b gy oa ob l oc od">df = pd.read_csv(io.StringIO(data))</span></pre><p id="ddd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了衡量我们有多成功，我将创建一个函数<code class="fe mj mk ml mm b">df_statistics()</code>(见下文)，它遍历所有列并计算:</p><ul class=""><li id="bd2c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">字符串列:每行中数据的总长度</li><li id="224f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数字列:所有值的总和</li><li id="5cd5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">其他列:行数</li></ul><p id="9abb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可选地，如果提供了一个带有<code class="fe mj mk ml mm b">expected</code>长度的字典，它会将测量的长度或总和与我在数据帧中显示为一行的期望值进行比较。我们的基准实现了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/c1325aeb351b7764fd0eadd2bb34b60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zFVpQPJOl4IzhYm73b6T5g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较实际长度和预期长度的最终熊猫数据帧</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/a3404805d3680d0ea6524087d43d78a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZDTou35jJHQmo5MQw7q4hw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为了更好的可读性，让我们调换一下数据帧</p></figure><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="514c" class="mn mo it mm b gy oa ob l oc od">def df_statistics(df, expected=None):<br/>    """Calculates the length of all items in the column and determine column types<br/>       length of string<br/>       sum of numbers"""<br/>    <br/>    res = {}<br/>    for col in df.columns:<br/>        if pd.api.types.is_string_dtype(df[col]): <br/>            # calculate the length of each row and sum it<br/>            # careful, you cannot .apply(len) to columns which contain NAN, because NAN are float. - see <a class="ae ky" href="https://stackoverflow.com/questions/51460881/pandas-typeerror-object-of-type-float-has-no-len" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/51460881/pandas-typeerror-object-of-type-float-has-no-len</a><br/>            l = df[col].str.len().sum()<br/>        else:<br/>            try:# if it doesn't work, it's probably numeric value, so let's only sum<br/>                l = df[col].sum()<br/>            except:<br/>                l = df[col].count()<br/>        <br/>        # assigne lenght to the "column_name_lenght" column<br/>        res[str(col) + "_lenght"] = l<br/>        <br/>        # if a dict with expected values was provided, let's use it to compare with real values<br/>        if expected:<br/>            res[str(col) + "_diff"] = l-expected[col]<br/>            <br/>        # review the type of the colunmn   <br/>        res[str(col) + "_type"] = df[col].dtype<br/>    return res</span></pre></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="0f5a" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">使用 skipinitialspace</h2><p id="7ec6" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">因为<code class="fe mj mk ml mm b">.read_csv()</code>是用 C 写的，为了提高效率，使用这个方法的参数是处理空白的最佳选择。为此，有一个<code class="fe mj mk ml mm b">skipinitialspace</code>，它删除了分隔符后面的所有空格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/222416cfd0476177cf4965b35284bd4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AzL4_vs_P-Lom7DEVB_5yQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 skipinitialspace 的结果近乎完美</p></figure><p id="d360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为 City 列只包含前导空格，所以它们都被删除了。Steet 列的最后一行也是固定的，只包含两个空格的那一行变成了 NaN，因为两个空格被删除了，pandas 本身将空格表示为 NaN(除非另有说明，见下文)。)</p><p id="ff76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如何处理行尾的空格，即最后一个字符或数据和分隔符之间的空格。熊猫没有任何<code class="fe mj mk ml mm b">skiptrailingspaces</code>参数，所以我们必须使用不同的方法。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="ab04" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">正则表达式分隔符</h2><p id="45aa" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">你知道在熊猫中可以使用正则表达式分隔符吗？<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html" rel="noopener ugc nofollow" target="_blank"> read_csv 文档</a>说:</p><blockquote class="oh oi oj"><p id="84b1" class="kz la ok lb b lc ld ju le lf lg jx lh ol lj lk ll om ln lo lp on lr ls lt lu im bi translated">此外，长度超过 1 个字符且不同于<code class="fe mj mk ml mm b">'\s+'</code>的分隔符将被解释为正则表达式，并将强制使用 Python 解析引擎。注意，正则表达式分隔符容易忽略引用的数据。Regex 示例:<code class="fe mj mk ml mm b">'\r\t'</code>。</p></blockquote><p id="8490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们可以尝试分隔符<code class="fe mj mk ml mm b">sep="\s*[,]\s*"</code>。<code class="fe mj mk ml mm b">\s*</code>表示任意数量的空格，<code class="fe mj mk ml mm b">[,]</code>表示逗号。在 Jupiter notebook 中，还必须指定<code class="fe mj mk ml mm b">engine="pyhton"</code>，因为 regex 分隔符是通过 python 脚本处理的，而不是原生的基于 c 的代码。让我们来看看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/612854460ba3ad54529bc9418783843d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fjMF7Itoml8tSv0ilT_1CQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们不需要的所有空格都被删除，所有列都有预期的数据类型</p></figure><p id="4a89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果似乎很完美。所有不需要的空格都被删除(all _diff 列等于 0)，并且所有列都具有预期的数据类型和长度。但闪光的不都是金子。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="c451" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">带引号的正则表达式分隔符</h2><p id="8bb8" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">手册中有一个重要的注释:<code class="fe mj mk ml mm b">regex delimiters are prone to ignoring quoted data.</code></p><p id="2060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的数据没有被引用。但如果是的话，假设这条街会被引用:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="eaaa" class="mn mo it mm b gy oa ob l oc od">data = """Id,Street,City,Salary,Date<br/>1,<strong class="mm iu">"</strong> 5th Ave. ", Indiana, 100, 2020-07-01<br/>2,<strong class="mm iu">"</strong> Downing Street <strong class="mm iu">"</strong>, San Francisco, 200, 2020-07-02<br/>3,<strong class="mm iu">"</strong>  <strong class="mm iu">"</strong>, New York, 300, 2020-07-03<br/>4,<strong class="mm iu">"</strong>   1600 Amphitheatre<strong class="mm iu">"</strong>, New York, 400, 2020-07-04<br/>"""</span></pre><p id="43e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么正则表达式分隔符不仅会遗漏引号内的空格，而且还会将引号视为数据的一部分，额外空格的数量甚至会增加:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/9cd4b290fb7847f44f7d15000c3bd874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YtYIVPXWmfAOLkzjjpppdg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正则表达式分隔符与带引号的数据进行斗争，这不仅导致数据集中保留空格，而且引号也被视为字符串的有效部分</p></figure><p id="e188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果引号是为了屏蔽字符串中的分隔符(在我们的例子中是街道名称中的逗号),使其不被视为分隔符，则会出现更糟糕的情况。<code class="fe mj mk ml mm b">" Downing Street, London "</code>受引号保护的是一个包含逗号的有效字符串，但如果我们使用 regex 分隔符，它会认为还有另一个分隔符而失败:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="2b7d" class="mn mo it mm b gy oa ob l oc od">Expected 5 fields in line 3, saw 6. Error could possibly be due to <strong class="mm iu">quotes being ignored</strong> when a <strong class="mm iu">multi-char delimiter is used</strong>.</span></pre><p id="89ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以正则表达式分隔符真的不是一个选项。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="9281" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">之后应用正则表达式</h2><p id="5abf" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">我们仍然可以使用正则表达式，但只是作为第二步。我们将 CSV 读数分为 3 个步骤:</p><ul class=""><li id="bf8f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">阅读。csv，考虑带标准<code class="fe mj mk ml mm b">read_csv()</code>的报价</li><li id="eeae" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">替换空格</li><li id="9eaa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">删除空格后，将“”转换为 NaN</li></ul><p id="d632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了方便地测量这种操作的性能，让我们使用一个函数:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="5ed7" class="mn mo it mm b gy oa ob l oc od">def <strong class="mm iu">read_csv_regex</strong>(data, date_columns=[]):<br/>    df = pd.read_csv(data, quotechar='"', parse_dates=date_columns)<br/>    <br/>    # remove front and ending blank spaces<br/>    df = df.replace({"^\s*|\s*$":""}, regex=True) <br/>    <br/>    # if there remained only empty string "", change to Nan<br/>    df = df.replace({"":np.nan}) <br/>    return df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/da81e718a1931baa245eeac417380f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RBp3b1h0kmZ4VIORr3TjLg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">read_csv 处理引号，应用正则表达式将删除空格。</p></figure><p id="d828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果终于令人鼓舞。所有列都有预期的长度和类型。但是性能好吗？</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="990f" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">剥掉绳子</h2><p id="19d2" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">Python 有一个本地方法来删除前面和结尾的空格— <code class="fe mj mk ml mm b">.strip()</code>，我们可以很容易地在我们的数据上使用它。因为这是一个字符串操作，我们需要使用<code class="fe mj mk ml mm b">str.strip()</code>，它只能应用于字符串列。因此，我们必须检查该列是否是字符串格式。</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="5d93" class="mn mo it mm b gy oa ob l oc od"># use internal method api.types.is_string_dtype to find out if the columns is a string<br/>if pd.api.types.<strong class="mm iu">is_string_dtype</strong>(df["column_name"]):<br/>   df["column_name"] = df["column_name"].str.strip()</span></pre><p id="04da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们将操作包装到一个函数中，以便稍后在性能测试中使用它。像以前一样，我们将把所有空字符串转换成 NaN。</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="5a89" class="mn mo it mm b gy oa ob l oc od">def <strong class="mm iu">read_csv_strip</strong>(data, date_columns=[]):<br/>    df = pd.read_csv(data, quotechar='"', parse_dates=date_columns)<br/>    <br/>    # for each column<br/>    for col in df.columns:<br/>        # check if the columns contains string data<br/>        if pd.api.types.<strong class="mm iu">is_string_dtype</strong>(df[col]):<br/>            df[col] = df[col]<strong class="mm iu">.str.strip()</strong><br/>    df = df.replace({"":np.nan}) # if there remained only empty string "", change to Nan<br/>    return df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/0c6bd07ea9cb23438731f9a9194d118e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qDBp6kOmmCd2BDBUAOyi3g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果与使用正则表达式相同。</p></figure><p id="fd73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在字符串列上使用<code class="fe mj mk ml mm b">str.strip()</code>会导致相同质量的结果。比较每种方法的速度会很有趣。</p><blockquote class="oh oi oj"><p id="f69e" class="kz la ok lb b lc ld ju le lf lg jx lh ol lj lk ll om ln lo lp on lr ls lt lu im bi translated">注意:不要使用<code class="fe mj mk ml mm b">df[col].apply(len)</code>,而要使用<code class="fe mj mk ml mm b">df[col].str.len()</code>,因为<code class="fe mj mk ml mm b">apply(len)</code>在 NaN 值上失败，这些值在技术上是浮点而不是字符串。</p></blockquote></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="2a2d" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">NaN 值</h2><p id="378d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">为什么我们要把所有的空弦都变成 NaNs？默认情况下，熊猫认为所有这些值都是 nan:</p><blockquote class="oh oi oj"><p id="bc74" class="kz la ok lb b lc ld ju le lf lg jx lh ol lj lk ll om ln lo lp on lr ls lt lu im bi translated">'，' #不适用'，' #不适用'，' #不适用'，'-1。#IND '，'-1。#QNAN '，'-nan '，'-NaN '，' 1。#IND '，' 1。#QNAN '，''，' n/a '，' NA '，' null '，' NAN '，' N/A '，' NaN '，' NULL '</p></blockquote><p id="668a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有一个很好的理由，因为 NaN 值的行为不同于空字符串" "。</p><ul class=""><li id="fa2d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">count(NaN) = 0</code>而<code class="fe mj mk ml mm b">count("")=1</code></li><li id="dd88" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您可以对 NaN 值应用<code class="fe mj mk ml mm b">fillna()</code>或<code class="fe mj mk ml mm b">dropna()</code>方法</li></ul><p id="eefc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是 pandas 只是将一个空字符串<code class="fe mj mk ml mm b">""</code>转换成 NaN，而不是<code class="fe mj mk ml mm b">" "</code>一个空格、两个空格、制表符或类似的空空格。这就是为什么我们必须在？csv 已加载到数据帧中。</p><h1 id="cfb4" class="or mo it bd mp os ot ou ms ov ow ox mv jz oy ka my kc oz kd nb kf pa kg ne pb bi translated">特性试验</h1><h2 id="b1dd" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">生成测试数据</h2><p id="eb83" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">每种建议的方法有多快？我们会认为内置方法是最快的，但是它们不符合我们的目的。让我们准备一些数据，以便了解操作的实际速度。</p><p id="1aa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几行总是在一瞥之间被处理，所以我们需要大量的数据来测试性能，比如说一百万条记录。为此，我想试试 python 的<code class="fe mj mk ml mm b">faker</code>库，它有一个快速的界面来创建随机的名字、地址和其他数据。</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="c158" class="mn mo it mm b gy oa ob l oc od">import faker<br/>import random</span><span id="cc5f" class="mn mo it mm b gy pc ob l oc od"># initiate the faker with a seed<br/>f = faker.Faker()<br/>faker.Faker.seed(123)</span><span id="9f02" class="mn mo it mm b gy pc ob l oc od"># generate million lines with extra white spaces<br/>data = []<br/>for i in range(1000000):<br/>    data.append(["  " + f.address(),<br/>                 " " + f.name() + " ",<br/>                 " " + str(random.randint(1,1000000))])</span></pre><p id="cb65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我正在创建一个包含一百万行和三列的列表:</p><ul class=""><li id="4efe" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">地址开头多留两个空格</li><li id="0ee2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">以空格开头和结尾的名称</li><li id="15eb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">和用空格表示字符串的随机数</li></ul><p id="585c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成的数据帧具有以下参数</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="907f" class="mn mo it mm b gy oa ob l oc od">[In]: df = pd.DataFrame(data, columns=["Address","Name","Salary"])<br/>      df.info()<br/>[Out]:<br/>      &lt;class 'pandas.core.frame.DataFrame'&gt;<br/>      RangeIndex: 1000000 entries, 0 to 999999<br/>      Data columns (total 3 columns):<br/>      Address    1000000 non-null object<br/>      Name       1000000 non-null object<br/>      Salary     1000000 non-null object<br/>      dtypes: object(3)<br/>      memory usage: 22.9+ MB</span></pre><p id="8df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为 faker 生成的地址不仅包含逗号，还包含换行符，所以当我们将它们导出到 csv 时，它们将被用引号括起来。示例地址:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="9df3" class="mn mo it mm b gy oa ob l oc od">"  1068 Peterson Cape<br/>South Jacquelineville, RI 78829"</span></pre><p id="db69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">faker</code>提供了许多方法。如果您想要单行地址，例如使用<code class="fe mj mk ml mm b">.street_address()</code>或<code class="fe mj mk ml mm b">.street_address() + ", " + .city()</code>。你可以在这里研究<a class="ae ky" href="https://faker.readthedocs.io/en/master/" rel="noopener ugc nofollow" target="_blank"> faker 文档</a>。</p><h2 id="f562" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">100 万样本的性能</h2><p id="bf94" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">可以肯定的是，我们测量了合理的处理时间，并且没有受到 CPU 的一些峰值使用的影响，例如，当防病毒软件运行时，我们将对上述每种方法进行 7 次测试。</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="e45d" class="mn mo it mm b gy oa ob l oc od">import time</span><span id="9673" class="mn mo it mm b gy pc ob l oc od">def process_seven_times(function, params={}):<br/>    processing_time = []</span><span id="7b1f" class="mn mo it mm b gy pc ob l oc od">    for i in range(7):<br/>        start = time.time()<br/>        df = function("test_data.csv", **params)<br/>        processing_time.append(time.time() - start)</span><span id="695c" class="mn mo it mm b gy pc ob l oc od">    return processing_time, df</span></pre><p id="2fe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以为每个场景发布这段代码，但是最好使用 python 将函数存储在变量中的能力，准备一个包含所有函数的字典，并对其进行迭代。</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="26db" class="mn mo it mm b gy oa ob l oc od">functions = {"No space handling": {"function": pd.read_csv, "params": {}},<br/>            "Skipinitialspace": {"function": pd.read_csv, "params": {"skipinitialspace": True}},<br/>            "Regex Separator": {"function": pd.read_csv, "params": {"sep":"\s*[,]\s*", "engine":"python"}},<br/>             "Strip blank spaces": {"function": read_csv_strip, "params": {}},<br/>             "Load and apply regex": {"function": read_csv_regex, "params": {}},<br/>             "Load and apply regex column wise": {"function": read_csv_regex_col, "params": {}},         <br/>            }</span></pre><p id="875d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字典中的每个键都包括一个函数及其参数——skipinitialspace、separtor、engine 等。数据的路径总是相同的，所以我们不必作为参数重复多次。</p><p id="7d48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将存储处理时间，并使用<code class="fe mj mk ml mm b">df_statistics(df)</code>计算统计数据</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="9149" class="mn mo it mm b gy oa ob l oc od">results = []<br/>statistics = []</span><span id="bae3" class="mn mo it mm b gy pc ob l oc od">for name, function in functions.items():</span><span id="73f4" class="mn mo it mm b gy pc ob l oc od">    processing_time, df = process_seven_times(function, params=f["params"])</span><span id="e1ba" class="mn mo it mm b gy pc ob l oc od">   # create a Series with processing time and name it based on the    function used    <br/>    s = pd.Series(processing_time)<br/>    s.name = name<br/>    results.append(s)</span><span id="abf7" class="mn mo it mm b gy pc ob l oc od">    statistics.append(pd.DataFrame(df_statistics(df), index=[name]))</span></pre><p id="3e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几分钟后，当我们测试完所有功能后，我们可以显示结果:</p><pre class="kj kk kl km gt nw mm nx ny aw nz bi"><span id="8092" class="mn mo it mm b gy oa ob l oc od">stats_perf_df = pd.DataFrame(results)<br/>stats_perf_df["avg"] = stats_perf_df.mean(axis=1)<br/>stats_perf_df, stats_perf_df["avg"].plot(kind="bar")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/30379705595f626266b3185cfa63c517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sx_nslrKIL4MhGyek01j8A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每个函数运行 7 次，表明大型数据集上的正则表达式操作非常慢。</p></figure><p id="3a39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">性能测试证实了我们的预期。内置方法胜过自定义算法。尽管它们没有达到我们想要的效果，但我们可以使用<code class="fe mj mk ml mm b">str.strip()</code>从加载的数据帧中移除空白。大约是。比没有剥离的过程慢 50%，但仍然比使用正则表达式快 5 倍。</p><p id="ac03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，使用<code class="fe mj mk ml mm b">skipinitialspace</code>可以在没有任何空白处理的情况下完成加载，因此，如果速度是我们关注的问题，将这个参数与加载的数据帧的后处理结合起来可以带来更好的结果。您可以再次运行性能测试，以确认这不是一个异常。</p><h1 id="a1e4" class="or mo it bd mp os ot ou ms ov ow ox mv jz oy ka my kc oz kd nb kf pa kg ne pb bi translated">结论</h1><p id="4bf3" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">在数据集被额外的空格污染的情况下，空白处理非常重要，这不仅是为了减少数据的大小，而且主要是为了正确地将数据与其他源连接起来，并接收数据和 nan 聚合的预期结果。</p><p id="4080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas 包含一些内置参数，有助于处理最常见的情况。任何进一步的处理都必须由自定义函数来完成，这会降低处理速度。出于这个原因，请始终尝试与您的数据提供商达成一致。符合标准的 csv 文件。</p><p id="c8a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用 github 上的这个<a class="ae ky" href="https://github.com/vaasha/Data-Analysis_in-Examples/blob/master/White%20Spaces%20In%20CSVs/Dealing_with_white_space_in_csv_pandas.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本执行本文描述的所有代码。测试数据不包括在内，但您可以通过此笔记本生成它们。</a></p><div class="pe pf gp gr pg ph"><a rel="noopener follow" target="_blank" href="/exploratory-data-analysis-passport-numbers-in-pandas-4ccb567115b6"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">探索性数据分析——熊猫的护照号码</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">探索前导和尾随零，字母和数字的分布，常见前缀，正则表达式…</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">towardsdatascience.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv ks ph"/></div></div></a></div></div></div>    
</body>
</html>