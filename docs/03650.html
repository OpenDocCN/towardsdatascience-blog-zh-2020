<html>
<head>
<title>Array Oriented Programming with Python NumPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python NumPy 进行面向数组的编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/array-oriented-programming-with-python-numpy-e0190dd6ab65?source=collection_archive---------11-----------------------#2020-04-06">https://towardsdatascience.com/array-oriented-programming-with-python-numpy-e0190dd6ab65?source=collection_archive---------11-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e4c6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">再见平原，老 For-loops！你好 Numpy 数组！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ce138238b177741f4c7362d2128a9c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aa296fRbnRd_4C9tiVSNOA.png"/></div></div></figure><h1 id="bd6f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">NumPy 简介</h1><p id="cff6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">NumPy 是最受欢迎的用于高性能数组实现的 Python 库:数组上的操作比列表上的操作快得多，这在大数据世界中可以放大运行时差异。根据<a class="ae mi" href="https://libraries.io/pypi/numpy/dependents" rel="noopener ugc nofollow" target="_blank"> libraries.io </a>(截至 2020 年 4 月)4K 的图书馆依赖 NumPy，包括最流行的数据科学包，Pandas 和 SciPy。</p><p id="2967" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">NumPy 的美妙之处在于它提供了面向数组的编程风格。也就是说，它提供了带有内部迭代的<strong class="lo iu">函数式</strong>、<strong class="lo iu">矢量化</strong>操作，而不是使用条件 for 循环(或 n 维时的嵌套 for 循环)来处理数组元素，这使得数组操作更简单、更简洁。</p><p id="976b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">在本教程中，你将发现从初级到高级的所有你需要知道的东西，超过 10 个综合主题。但是如果你是已经进阶的人，不要害怕！您可以<strong class="lo iu"> <em class="mo">直接跳到最后两个部分(<a class="ae mi" href="#4ac5" rel="noopener ugc nofollow">高级</a> &amp; <a class="ae mi" href="#fa1d" rel="noopener ugc nofollow">专家</a>)，在那里将解决数组定向的“症结”以及基本的性能技巧。最后，您将能够将您的过程化编程风格转变为优雅、快速、无循环、基于数组的风格。</em></strong></p><blockquote class="mp"><p id="7688" class="mq mr it bd ms mt mu mv mw mx my mh dk translated">我们开始吧。。。</p></blockquote><figure class="na nb nc nd ne kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/b331f52f9a2433e1d0027ac2fa04e805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEEKXSZpWNXmT5-p8J0tmg.png"/></div></div></figure><h1 id="8172" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">➊ —阵列创建</h1><p id="e354" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">导入 NumPy <code class="fe nf ng nh ni b">import numpy as np</code>后，我们准备滚动:</p><h2 id="d3a2" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">一维</h2><p id="5fdf" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们可以通过传递元素列表来创建数组；本例中的整数:<br/> <code class="fe nf ng nh ni b">array = np.array([1, 2, 3, 5, 8, 13, 21])</code></p><p id="a728" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">📌您能在输出中注意到一些有趣的东西吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/6e306d3be3e1b664e73ca93dd47ef537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*vHfC1dZFzZzMKFBj6jz-jg.png"/></div></figure><p id="fc5b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">所有逗号分隔的值宽度相同，并且右对齐。由于最大数字 21 占据 2 个位置，所有其他值都被格式化为两个字符的字段。现在你知道为什么在[和 1 之间有一个前导空格了。😏</p><h2 id="c224" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">多维度</h2><p id="0385" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们将创建一个 2 行 3 列的数组，传递两个嵌套的列表，每个列表包含三个元素:<br/> <code class="fe nf ng nh ni b">array2x3 = np.array([[1, 2, 3], [10, 20, 30]])</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/97d474daefdb82c06743747c35a36e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*PCI5MWSCR6NmYbnhGFDKPA.png"/></div></figure><p id="b9cb" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">输出的格式基于维度的数量，对齐每行中的列:正如我们看到的，1 和 10 对齐，2 和 20 对齐，等等。</p><h2 id="a42f" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">阵列形状</h2><p id="ad78" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们可以用<code class="fe nf ng nh ni b">shape</code>属性确定数组的形状，该属性返回一个具有维度的元组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5b81e6810031d73ede35e3133d43e57e.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*bb24kxnh6IpsWwRhnXwXqg.png"/></div></figure><p id="7a78" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">以及带有<code class="fe nf ng nh ni b">ndim</code>属性的维数(即数组的秩)，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/5ce726aeb71f8ebd606a026a81e78a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*ApgmvFuyZbwNnkOYx8vwWw.png"/></div></figure><p id="8704" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><code class="fe nf ng nh ni b">ndim</code>与数组形状输出的轴数或长度(<code class="fe nf ng nh ni b">len</code>相同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/15ed8464f5d8f8f2ef996f5d328ec1f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*S56PYij6X_86cVBK9LMrKA.png"/></div></figure><h2 id="a883" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">元素数量</h2><p id="5826" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">使用属性<code class="fe nf ng nh ni b">size</code>我们可以得到数组的元素总数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/bc4c23142e76c4abacb941bf4e90334e.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*x__IKcrb_W86jTBx2KS4rQ.png"/></div></figure><h2 id="7b4e" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">元素类型和元素大小</h2><p id="06ef" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">由于 NumPy 是用 C 编写的，所以它使用它的数据类型。因此，整数被存储为<code class="fe nf ng nh ni b">int64</code>值——在 c #中对应于 64 位(即 8 字节)整数。</p><p id="676e" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">通过访问<code class="fe nf ng nh ni b">dtype</code>属性，确定数组的元素类型很容易:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/1433be9cc486d79d417813ab6c25bae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*HMI-jYZcQPDZ1aQo7vykPg.png"/></div></figure><p id="addc" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">以及存储每个元素所需的字节数，通过访问<code class="fe nf ng nh ni b">itemsize</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1835799e048a6e322faa8511377271c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*NqyU-GNRsFToJ4A27eDR2Q.png"/></div></figure><h2 id="1659" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">存储容量</h2><p id="d2a8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">内存占用(<code class="fe nf ng nh ni b">nbytes</code>)是元素数乘以字节数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/a7cb097c1bcca4d661c2ebf5e43c507f.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*wTUY-nkOGrTMwhVUN7cong.png"/></div></figure><h2 id="6861" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">常见数组</h2><p id="abb0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了用特定的值填充数组，NumPy 提供了三个特殊的函数:<code class="fe nf ng nh ni b">zeros</code>、<code class="fe nf ng nh ni b">ones</code>和<code class="fe nf ng nh ni b">full</code>，分别创建包含 0、1 或特定值的数组。请注意，零和一包含<code class="fe nf ng nh ni b">float64</code>值，但是我们显然可以定制元素类型。</p><ul class=""><li id="9d1c" class="oe of it lo b lp mj ls mk lv og lz oh md oi mh oj ok ol om bi translated">0 的 1D 数组:<code class="fe nf ng nh ni b">zeros = np.zeros(5)</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/c43971ef5e042e2b8ef7375dccfbe000.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*hIWGu6vwvwCKM9fFGTx68Q.png"/></div></figure><ul class=""><li id="7a23" class="oe of it lo b lp mj ls mk lv og lz oh md oi mh oj ok ol om bi translated">整数类型的 0 的 1D 数组:<code class="fe nf ng nh ni b">zeros_int = np.zeros(5, dtype = int)</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/4d9f9c27d129078f8567b738cfb3bb2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*oFZeTlYcD6eAruMewSiwtQ.png"/></div></figure><ul class=""><li id="fcd5" class="oe of it lo b lp mj ls mk lv og lz oh md oi mh oj ok ol om bi translated">1 的 2D 数组(2x 5):<code class="fe nf ng nh ni b">ones = np.ones((2, 5))</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/816ba398a5790c3e319e2cf4229828c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*lMkyrIsq4Lq1e4p0J0fj-A.png"/></div></figure><ul class=""><li id="43a0" class="oe of it lo b lp mj ls mk lv og lz oh md oi mh oj ok ol om bi translated">7 的 2D 阵列(2x 5):<code class="fe nf ng nh ni b">full = np.full((2, 5), 7)</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/6cc7abcc182df734752e76bb8b92b25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*3yQszRomcYc4HGJKFhaz1A.png"/></div></figure><h2 id="995a" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">均匀分布的范围</h2><p id="6f79" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">NumPy 为从范围创建数组提供了优化的函数。创建均匀间隔范围的两个最重要的函数是<code class="fe nf ng nh ni b">arange</code>和<code class="fe nf ng nh ni b">linspace</code>，分别用于整数和浮点。</p><p id="799f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu"> ◼️整数:给定区间<br/> </strong> <code class="fe nf ng nh ni b">np.arange(start, stop, step)</code>:在半开区间<code class="fe nf ng nh ni b">[start, stop)</code>内产生值，即包括启动但不包括停止的区间。默认<code class="fe nf ng nh ni b">start</code>值为 0，默认<code class="fe nf ng nh ni b">step</code>大小为 1。</p><ul class=""><li id="fdc2" class="oe of it lo b lp mj ls mk lv og lz oh md oi mh oj ok ol om bi translated">范围从 0 到 4，增量为 1:<br/>T21</li><li id="ecba" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated">范围从 5 到 9，增量为 1: <br/> <code class="fe nf ng nh ni b">np.arange(5, 10)</code></li><li id="4432" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated">范围从 2 到 8，增量为 2: <br/> <code class="fe nf ng nh ni b">np.arange(2, 10, 2)</code></li><li id="0ebc" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated">范围从 8 到 2，增量为-2: <br/> <code class="fe nf ng nh ni b">np.arange(8, 0, -2)</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/f2ee3954548a1b8b458780a1f4bebe0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*yLeNDmqnWYclUAm_08EVsQ.png"/></div></figure><p id="8313" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu"> ◼️浮点数:给定元素的个数<br/> </strong> <code class="fe nf ng nh ni b">np.linspace(start, stop, num, endpoint)</code>:返回<code class="fe nf ng nh ni b">num</code>个间隔均匀的样本，在间隔<code class="fe nf ng nh ni b">[start, stop]</code>内计算。间隔的<code class="fe nf ng nh ni b">endpoint</code>可以选择排除。默认<code class="fe nf ng nh ni b">num</code>值为 50，默认<code class="fe nf ng nh ni b">endpoint</code>为真。</p><ul class=""><li id="29ea" class="oe of it lo b lp mj ls mk lv og lz oh md oi mh oj ok ol om bi translated">5 从 1.0 到 2.0(不包括 2.0)的等间距元素:<br/> <code class="fe nf ng nh ni b">np.linspace(1, 2, num = 5, endpoint = False)</code></li><li id="3d7c" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated">5 从 1.0 到 2.0(包括 2.0)的等间距元素:<br/> <code class="fe nf ng nh ni b">np.linspace(1, 2, num = 5, endpoint = True)</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/7ca81bd22f12b5353bd5db47a44e4bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*FOjyYEDiI-fcBV6h1bLoGg.png"/></div></figure><blockquote class="mp"><p id="b5ad" class="mq mr it bd ms mt oy oz pa pb pc mh dk translated"><em class="pd">💡虽然我们可以通过将范围作为参数传递来创建数组，但我们总是更喜欢内置函数，因为它们可以优化性能。</em></p></blockquote><h2 id="463a" class="nj kv it bd kw nk pe dn la nm pf dp le lv pg np lg lz ph nr li md pi nt lk nu bi translated">随机范围</h2><p id="3447" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了生成随机范围，NumPy 提供了一些选项，但以下是最常用的:</p><p id="0358" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu">来自[0，1) <br/> </strong> <code class="fe nf ng nh ni b">np.random.rand(d0, d1, ...)</code>上的均匀分布的◼️随机样本，其中<code class="fe nf ng nh ni b">dn</code>是数组维数:</p><ul class=""><li id="2504" class="oe of it lo b lp mj ls mk lv og lz oh md oi mh oj ok ol om bi translated">具有 5 个随机样本的 1D 阵列:<br/> <code class="fe nf ng nh ni b">np.random.rand(5)</code></li><li id="edb8" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated">2 行 5 个随机样本的 2D 阵列:<br/> <code class="fe nf ng nh ni b">np.random.rand(2, 5)</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/9578ca9913d0ae828a2fa27ee6c5a251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tw5MihKz5biAjHTowVzvnA.png"/></div></div></figure><p id="bfa5" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu"> ◼️随机整数<br/> </strong> <code class="fe nf ng nh ni b">np.random.randint(low, high, size)</code>:返回从<code class="fe nf ng nh ni b">low</code>(含)到<code class="fe nf ng nh ni b">high</code>(不含)的随机整数。如果<code class="fe nf ng nh ni b">high</code>为无(默认)，则结果来自<code class="fe nf ng nh ni b">[0, low)</code>。</p><ul class=""><li id="e62c" class="oe of it lo b lp mj ls mk lv og lz oh md oi mh oj ok ol om bi translated">从 1 到 99 的 10 个随机整数:<br/> <code class="fe nf ng nh ni b">np.random.randint(low = 1, high = 100, size = 10)</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/a79c99605fa4487f159b2a6ca7d16d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*gmac9jv74Asf9vZWjmNrEg.png"/></div></figure></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><h1 id="46cf" class="ku kv it bd kw kx ps kz la lb pt ld le jz pu ka lg kc pv kd li kf pw kg lk ll bi translated">➋ —索引</h1><h2 id="7bfa" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">一维</h2><p id="004e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们可以使用方括号中的从<strong class="lo iu">零开始的</strong>索引来引用数组元素，例如在一个五元素数组中，第一个元素由<code class="fe nf ng nh ni b">[0]</code>访问，最后一个由<code class="fe nf ng nh ni b">[4]</code>访问。</p><p id="f1dd" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">也可以通过使用负的索引从末尾访问数组，从最后一个元素的-1 开始。所以在前面的例子中，最后一个元素(<code class="fe nf ng nh ni b">[4]</code>)可以用<code class="fe nf ng nh ni b">[-1]</code>访问，它的第一个元素(<code class="fe nf ng nh ni b">[0]</code>)可以用<code class="fe nf ng nh ni b">[-5]</code>访问:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi px"><img src="../Images/ff9ba097c673c8bf3935daaf4db810e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*vrSs9amO1yVSpbIjRl4MLQ.png"/></div></figure><p id="4cd5" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">所以在这个阵中:<br/> <code class="fe nf ng nh ni b">array1D = np.array([0, 1, 2, 3, 4])</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi py"><img src="../Images/718aa4df7a7d4ca71bd497b756ab9624.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*-0gYlxHWGaGfgaDZrce-bw.png"/></div></figure><p id="4880" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们可以选择第三个元素:<code class="fe nf ng nh ni b">array1D[2]</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/950cec9dacd632c952a5b32f3fed9268.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*DYGtvfT41wNU4slmaD7PDg.png"/></div></figure><p id="6a22" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">或者从结尾开始:<code class="fe nf ng nh ni b">array1D[-3]</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/33cd1ab1db072a886d00ca4a982e5348.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*eWA67JPO0GFl25biG7q-cA.png"/></div></figure><h2 id="ab45" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">多维度</h2><p id="35af" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">2D 数组可以用这个符号来访问:<code class="fe nf ng nh ni b">[row_index, column_index]</code>。</p><p id="fb31" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">所以在这个实例中:<br/> <code class="fe nf ng nh ni b">array2D = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/e6693c48125a1b33391c9f8d385894d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*xurAHAHHQxZG46hnrggKIw.png"/></div></figure><p id="f6c5" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们可以通过<code class="fe nf ng nh ni b">array2D[1, 2]</code>选择第 2 行第 3 列的元素</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c9d833cea5781d4bd971798dbafe9cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*hQNkeQRXcKDSJSbMtcr9xA.png"/></div></figure></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><h1 id="baea" class="ku kv it bd kw kx ps kz la lb pt ld le jz pu ka lg kc pv kd li kf pw kg lk ll bi translated">➌ —切片</h1><p id="0f4d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">使用<code class="fe nf ng nh ni b">[first:last]</code>符号将数组分割成原始元素的子集，这将返回一个包含从索引<code class="fe nf ng nh ni b">first</code>到<code class="fe nf ng nh ni b">last-1</code>的元素的子数组。</p><p id="7e28" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">→如果省略<code class="fe nf ng nh ni b">first</code>，则假设为 0，因此返回从开始到<code class="fe nf ng nh ni b">last-1</code>的元素。<br/> →如果省略<code class="fe nf ng nh ni b">last</code>，则假定数组的长度，因此返回从<code class="fe nf ng nh ni b">first</code>到末尾的元素。<br/> →如果<code class="fe nf ng nh ni b">first</code>和<code class="fe nf ng nh ni b">last</code>都省略，则返回整个数组。</p><h2 id="b03f" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">一维</h2><p id="80af" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">延续之前的<code class="fe nf ng nh ni b">array1D</code>示例:</p><ul class=""><li id="e791" class="oe of it lo b lp mj ls mk lv og lz oh md oi mh oj ok ol om bi translated">具有第 2 和第 3 个元素的子数组(从索引 1 到 2): <br/> <code class="fe nf ng nh ni b">array1D[1:3]</code></li><li id="a37f" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated">具有前 3 个元素的子数组(从开始到索引 2): <br/> <code class="fe nf ng nh ni b">array1D[:3]</code></li><li id="97f2" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated">具有最后 3 个元素的子数组(从第 2 个索引到结尾):<br/> <code class="fe nf ng nh ni b">array1D[2:]</code></li><li id="6270" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated">包含所有元素的子数组:<br/> <code class="fe nf ng nh ni b">array1D[:]</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/6adf30c918569e4c7ed2867faf7c4bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*pWrwYDA5xCmVRzVTxFFMNg.png"/></div></figure><h2 id="555a" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">多维度</h2><p id="a757" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">类似的原理也适用于 2D 数组，所以切片使用这个符号:<br/> <code class="fe nf ng nh ni b">[row_first:row_last, column_first:column_last]</code>。</p><p id="4180" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">→要选择多行，我们使用:<code class="fe nf ng nh ni b">[row_first:row_last, :]</code>。<br/> →要选择多个列，我们使用:<code class="fe nf ng nh ni b">[:, column_first:column_last]</code>。</p><p id="2756" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">承接前面<code class="fe nf ng nh ni b">array2D</code>的例子:</p><ul class=""><li id="ae45" class="oe of it lo b lp mj ls mk lv og lz oh md oi mh oj ok ol om bi translated">从行索引 0 到 1 和列索引 1 到 2 的子 2D 数组<br/> <code class="fe nf ng nh ni b">array2D[0:2, 1:3]</code></li><li id="da4c" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated">从开始到索引 2 有多列的子 2D 数组:<br/> <code class="fe nf ng nh ni b">array2D[:, :3]</code></li><li id="3e1b" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated">从索引 1 到结尾有多行的子 2D 数组:<br/> <code class="fe nf ng nh ni b">array2D[1:, :]</code></li><li id="94f4" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated">包含所有元素的子数组:<br/> <code class="fe nf ng nh ni b">array2D[:, :]</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/22f2596cd3ca5238b00f0c0ff7d64016.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*z37UVsG7fD0Ti9Zvs2_b0g.png"/></div></figure><p id="2364" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">下一节我们将解释为什么 Numpy 子数组只是视图！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/579c204618b464b30be62cc6f9220a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8i4Xn6pO-22lri2V-d5UCg.png"/></div></div></figure><h1 id="5542" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">➍ —复印</h1><h2 id="9237" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">浅薄的文案/观点</h2><p id="782e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">切片不会修改原始数组。新创建的数组使原始元素的<strong class="lo iu"> <em class="mo">浅</em> </strong>副本(或<strong class="lo iu"> <em class="mo">视图</em> </strong>)这意味着它复制元素的引用，但不复制它们所指向的对象。</p><p id="d95f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">换句话说，对新创建的数组的任何修改也将反映在原始数组中。</p><p id="2309" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这里是一个新创建的有 10 个元素的数组:<br/> <code class="fe nf ng nh ni b">originalArray = np.arange(0, 10)</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/5a7a0fe914073bf00f1d222e87f4fc29.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*gtQmV2zk2QcDtpQNL5CH5A.png"/></div></figure><p id="02a8" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们通过选择最后 5 个元素来分割它:<br/> <code class="fe nf ng nh ni b">subArray = originalArray[5:]</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/45bddf9a3998736a0bece81e7acec0ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*sJ71K8wyvviZOmeHbN3yWA.png"/></div></figure><p id="1265" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们通过使用内置的<code class="fe nf ng nh ni b">id</code>函数:<br/> <code class="fe nf ng nh ni b">display(id(originalArray))</code>和<code class="fe nf ng nh ni b">display(id(subArray))</code>，观察到原始数组和切片数组确实是两个不同的对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/39408cf51f5dc35ef7c9a45f31dcec54.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*Woq9xMQtXHk4RyRmWDbsig.png"/></div></figure><p id="7233" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">为了证明<code class="fe nf ng nh ni b">subArray</code>与<code class="fe nf ng nh ni b">originalArray</code>查看相同的数据，我们将修改<code class="fe nf ng nh ni b">subArray</code>的第一个元素:<br/> <code class="fe nf ng nh ni b">subArray[0] = subArray[0] * 10</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/75cbf88e47ea6d3e2d3ff7b50959fbdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*Npy1y-v8kSBFMHs88QXhSQ.png"/></div></figure><p id="ffe7" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">然后显示两个数组—原始值也发生了变化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/90aefa2f585c0d8f6c44549b5bee30ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*EiGQ-okftX9fFE985IbXUw.png"/></div></figure><h2 id="9455" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">深层拷贝</h2><p id="ecd4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">尽管浅层副本在共享数据时节省了内存，但有时还是有必要创建原始数据的独立副本。这个操作被称为<strong class="lo iu"> <em class="mo">深度</em> </strong>复制，在多线程编程中非常有用，在多线程编程中，程序的不同部分可能会试图同时修改数据，这可能会破坏数据。</p><p id="4f01" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">NumPy 提供了方法<code class="fe nf ng nh ni b">copy</code>，该方法返回一个新的数组对象，其中包含原始数组对象数据的深层副本。</p><p id="7dd4" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">重复前面的示例，我们可以看到，修改子数组时，原始数组没有受到影响。</p><p id="a225" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们先把<code class="fe nf ng nh ni b">originalArray</code>复制到<code class="fe nf ng nh ni b">newArray</code> : <br/> <code class="fe nf ng nh ni b">newArray = originalArray.copy()</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qj"><img src="../Images/2a39a9f5f6ab2c6f4f2bad931db3f78b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*INq_t610Vtwb4hhu_Kwkbw.png"/></div></div></figure><p id="2c5b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">然后我们修改第 6 个元素:<br/> <code class="fe nf ng nh ni b">newArray[5] = newArray[5] * 10</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/83054caa0b2aba0e6a1cdc7f5f94a35a.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*79INsBJvb2Sj5yZWpq6bBw.png"/></div></figure><p id="454b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">最后，我们显示两个数组——看看原始数组的值是如何保持不变的？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ql"><img src="../Images/3cec9a573d48421e57b0c98302981b7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*02jmNoliY9a6ulPvz27qHg.png"/></div></div></figure></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><h1 id="3a26" class="ku kv it bd kw kx ps kz la lb pt ld le jz pu ka lg kc pv kd li kf pw kg lk ll bi translated">➎ —元素式操作</h1><p id="bbfe" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">NumPy 提供了许多操作符，使我们能够编写简单的表达式来对整个数组执行操作。这是我们以后变得更高级和消除程序中 for 循环的垫脚石！</p><h2 id="eaaf" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">带标量</h2><p id="b648" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们可以用数组和标量执行基于元素的算术运算。在这些操作中，标量被应用于每个数组元素，所以这个代码片段给每个元素加 5:<code class="fe nf ng nh ni b">array + 5</code>。</p><p id="fac3" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">每个操作返回一个包含结果的新数组(即不修改原始数组)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qm"><img src="../Images/191fa4364cfc4abe421aa1ea3de802fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*Gw1QemCJ3Hc40iSULy38eg.png"/></div></figure><p id="3f73" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">增强赋值修改左操作数中的每个元素。在这个例子中:<code class="fe nf ng nh ni b">array += 1</code>，原始数组的元素现在增加 1。与前面的情况相反，这里没有发生内存分配，因为这种就地操作是首选的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qn"><img src="../Images/259759652726a09b23fbddceab183bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*XRzhAPouBJT4euSOZlLmZA.png"/></div></figure><p id="b540" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">乘、减、除、取幂和前面的加法一样简单。</p><p id="e641" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">📌标量操作是我们将在下一节讨论的最简单的广播形式。</p><h2 id="3584" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">数组之间</h2><p id="2a61" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们可以在<strong class="lo iu">相同形状</strong>的数组之间执行逐元素的算术运算。结果是两个数组的元素组合成一个新的数组。</p><p id="0d6a" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">在本例中，我们有两个数组，每个数组有 5 个元素:</p><pre class="kj kk kl km gt qo ni qp qq aw qr bi"><span id="4cdd" class="nj kv it ni b gy qs qt l qu qv">arrayA = np.arange(2, 12, 2)<br/>arrayB = np.arange(0, 5) + 1</span></pre><p id="7310" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">当我们添加它们:<code class="fe nf ng nh ni b">arrayA + arrayB</code>时，我们可以看到新的组合数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qw"><img src="../Images/4b61b2e8fd8537c6285b07d04742b1d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*uJPj_evVn_vYFTlPiGOCdg.png"/></div></figure><p id="b73f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">📌请注意，数组乘法不是矩阵乘法。这些元素只是按分量相乘。利用前面的数组，我们可以通过使用<code class="fe nf ng nh ni b">dot</code>函数<br/> <code class="fe nf ng nh ni b">np.dot(arrayA, arrayB)</code>来计算<strong class="lo iu">矩阵乘法</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qx"><img src="../Images/2d895ed03a34f897c230d17150dd3dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*mriyb6xEEHn58EUUVWYn4w.png"/></div></figure><h2 id="1214" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">比较</h2><p id="045e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当比较两个数组时，我们得到一个布尔数组，其中每个元素为真或假，表示各自的比较结果。</p><p id="ed5e" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">给定两个随机整数数组:</p><pre class="kj kk kl km gt qo ni qp qq aw qr bi"><span id="ec3c" class="nj kv it ni b gy qs qt l qu qv">compA = np.random.randint(low = 1, high = 10, size = 5)<br/>compB = np.random.randint(low = 1, high = 10, size = 5)</span></pre><p id="dc45" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们可以检查第一个数组的元素是否大于第二个数组的元素:<code class="fe nf ng nh ni b">compA &gt; compB</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qy"><img src="../Images/154d7c698e38897750a62224ba092116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*UEhzGZaNUuk9D3cApQxPGA.png"/></div></figure><p id="bff0" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">📌为了比较完整的数组是否相等，我们使用了<code class="fe nf ng nh ni b">array_equal</code>函数，如果两个数组具有相同的<em class="mo">形状</em>和相同的<em class="mo">元素</em> : <br/> <code class="fe nf ng nh ni b">np.array_equal(compA, compB)</code>，则该函数返回 True</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qz"><img src="../Images/d60740e25795ebc3d547a9d4daf50192.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*guyAvvTbjam8PSsuBVRExA.png"/></div></figure><h2 id="9e43" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">逻辑运算</h2><p id="32fb" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">此外，我们可以通过分别使用<code class="fe nf ng nh ni b">logical_or </code>和<code class="fe nf ng nh ni b">logical_and</code>函数，对数组元素应用逻辑 OR 和 and。</p><p id="b5ca" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">给定两个布尔数组:</p><pre class="kj kk kl km gt qo ni qp qq aw qr bi"><span id="2135" class="nj kv it ni b gy qs qt l qu qv">logA = np.array([True, True, False, False])<br/>logB = np.array([True, False, True, False])</span></pre><p id="ae22" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们得到:<br/> <code class="fe nf ng nh ni b">np.logical_or(logA, logB)</code>和<code class="fe nf ng nh ni b">np.logical_and(logA, logB)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ra"><img src="../Images/055b8f613fdae9b35f7381c3b21ec8bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Xkau1uM7Hy5pTWMn3UV8uA.png"/></div></figure><h2 id="2c25" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">通用函数</h2><p id="a705" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">此外，NumPy 提供了许多独立的通用函数(或<code class="fe nf ng nh ni b">ufuncs</code>)来执行各种元素操作。每个都返回一个包含结果的新数组。</p><p id="9cd3" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">官方文档列出了五个类别——数学、三角学、位操作、比较和浮点。建议快速浏览，这样你就知道什么是可用的。</p><blockquote class="mp"><p id="6961" class="mq mr it bd ms mt mu mv mw mx my mh dk translated">干得好！你晋级了！</p></blockquote><figure class="na nb nc nd ne kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/bec4063770d138e4d7413c4f676e74c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PGo_27y0VydbX8uEDVPa2g.png"/></div></div></figure><h1 id="4ac5" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">➏ —广播</h1><p id="5940" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">到目前为止，这些操作需要两个大小和形状相同的数组作为操作数。当阵列的形状与<strong class="lo iu">兼容</strong>时，广播就放松了这些限制，实现了一些简洁而强大的操作。</p><p id="bd00" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">较小的阵列在较大的阵列中“广播”。它可以让我们避免循环，也可以创建不必要的数据副本。</p><p id="e548" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">基于<a class="ae mi" href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" rel="noopener ugc nofollow" target="_blank">官方文件</a>:</p><blockquote class="rb rc rd"><p id="fdd7" class="lm ln mo lo b lp mj ju lr ls mk jx lu re ml lx ly rf mm mb mc rg mn mf mg mh im bi translated"><em class="it">在两个数组上操作时，NumPy 按元素比较它们的形状。它从</em> <strong class="lo iu"> <em class="it">尾随尺寸</em> </strong> <em class="it">开始，一直向前。<br/>两个维度兼容当:<br/></em><em class="it">它们相等，或者<br/></em><em class="it">其中一个为 1 <br/>如果不满足这些条件，抛出</em> <code class="fe nf ng nh ni b"><em class="it">ValueError: operands could not be broadcast together</em></code> <em class="it">异常。</em></p></blockquote><p id="a382" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们将通过几个循序渐进的乘法示例来演示广播的操作原理。很大程度上，较小的数组会“伸展”,以便与较大数组的每一行相乘。</p><blockquote class="mp"><p id="700b" class="mq mr it bd ms mt mu mv mw mx my mh dk translated">它在内存中不是字面意义上的拉伸；重复的是计算。</p></blockquote><h2 id="a868" class="nj kv it bd kw nk pe dn la nm pf dp le lv pg np lg lz ph nr li md pi nt lk nu bi translated">说明 1</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rh"><img src="../Images/4299c4ace42b581b60bff1879674487d.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*h4dvbFivv0ysL2SDJ1bZWA.png"/></div></figure><p id="0f10" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">在本例中，我们有一个 3x3 的表格和一个 1x3 的表格。</p><pre class="kj kk kl km gt qo ni qp qq aw qr bi"><span id="66ee" class="nj kv it ni b gy qs qt l qu qv">ex1A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])<br/>ex1B = np.array([2, 5, 10])</span></pre><p id="3f01" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们可以观察到广播条件得到满足，并且两个维度是兼容的:</p><p id="8e96" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">行维度:虽然它们不同(即 3 对 1)，但其中一个是 1。<br/>列尺寸:两者相同(即 3)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ri"><img src="../Images/df325d50483b32633b74e1d60a0d4a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:276/format:webp/1*w4AGNwyjpPG9Q0lgYo1L2A.png"/></div></figure><p id="c5fd" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">所以相乘的结果(<code class="fe nf ng nh ni b">ex1A * ex1B</code>)是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rj"><img src="../Images/90176194e083659ec4309ca7e32638d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*Pbk_gzaug9MEC3FFQ7TKIA.png"/></div></figure><h2 id="dd5b" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">说明 2</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rh"><img src="../Images/d6e12dbbac951c9529ce8e80ff173344.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*eKpUUKXkbIw4dEqH0Euy-g.png"/></div></figure><p id="ca48" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">在第二个示例中，我们有一个 3x3 的表和一个 3x1 的表。</p><pre class="kj kk kl km gt qo ni qp qq aw qr bi"><span id="e24f" class="nj kv it ni b gy qs qt l qu qv">ex2A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])<br/>ex2B = np.array([[2], [5], [10]])</span></pre><p id="2d24" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">同样，阵列是兼容的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ri"><img src="../Images/0cceb704dccfb15d7c2cf3a08e59bee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:276/format:webp/1*a-mEgMpZk8laN4wD493haA.png"/></div></figure><p id="fd17" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">所以相乘的结果(<code class="fe nf ng nh ni b">ex2A * ex2B</code>)是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rk"><img src="../Images/30de4308d81e09660ef40c584fe3112d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*hhjORwpEEGCMIuDIyC2ufA.png"/></div></figure><h2 id="e33d" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">说明 3</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rh"><img src="../Images/eeea69bad9f808f27f2c2410ec9d42a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*2DphL0OTtURkPb1Kmrn4OQ.png"/></div></figure><p id="9303" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">在第三个示例中，我们有一个 1x3 的表和一个 3x1 的表。</p><pre class="kj kk kl km gt qo ni qp qq aw qr bi"><span id="2b5b" class="nj kv it ni b gy qs qt l qu qv">ex3A = np.array([1, 2, 3])<br/>ex3B = np.array([[2], [5], [10]])</span></pre><p id="9923" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">同样，阵列是兼容的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ri"><img src="../Images/dd9bc5696695a3b4d8e5e10b894ef2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:276/format:webp/1*_-r552TsbIBk229tyDSBdw.png"/></div></figure><p id="5127" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">所以相乘的结果(<code class="fe nf ng nh ni b">ex3A * ex3B</code>)是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rl"><img src="../Images/7ae9b61627ef77be15289af7d32db43c.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*BA4ovF0rS0bbcZ2bU7Nf3A.png"/></div></figure><h2 id="4179" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">不相容尺寸</h2><p id="adbb" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在本例中，行数不同(即 3 对 2)，并且都不是 1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ri"><img src="../Images/348449fbca87bbfe66fd624edffae10d.png" data-original-src="https://miro.medium.com/v2/resize:fit:276/format:webp/1*ux8NB0isd-RTSutn77m2Vg.png"/></div></figure><p id="068e" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">同样，倒数第二个尺寸不匹配:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rm"><img src="../Images/6e609208ee17c188f90b17093ff10b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*bMFpYA0rVvo6BwPi1iupCQ.png"/></div></figure></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><h1 id="093a" class="ku kv it bd kw kx ps kz la lb pt ld le jz pu ka lg kc pv kd li kf pw kg lk ll bi translated">➐——塑造操纵</h1><p id="e76f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">了解播音之后，另一个重要的概念就是操控造型。让我们来看看一些技巧:</p><h2 id="36f7" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">使再成形</h2><p id="5b6d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">通常的做法是创建一个 NumPy 数组作为 1D，然后再将其整形为 multiD，反之亦然，保持元素总数不变。</p><p id="5992" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">📌<code class="fe nf ng nh ni b">reshape</code>返回一个新数组，它是原数组的<strong class="lo iu">浅</strong>副本。</p><p id="63d0" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这是一个有 9 个元素的 1D 数组:<code class="fe nf ng nh ni b">array09 = np.arange(1, 10)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rn"><img src="../Images/77e88aaed30a1ef1dc805c01e4b6f1ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*yV9K_TKazelOxAoswQDIAA.png"/></div></figure><p id="4705" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们可以将其重塑为一个 3x3 的数组:<code class="fe nf ng nh ni b">array09.reshape(3, 3)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ro"><img src="../Images/87ef8b8ab078f891cd8a5b54587bd178.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*UIJ8ufGxVS38ZkhSfQ5X6Q.png"/></div></figure><p id="979c" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">或者作为 9x1 数组:<code class="fe nf ng nh ni b">array09.reshape(9, 1)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ro"><img src="../Images/49655977e2a837da6eb5d0d7ac1ad9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*B8nRhlq1kES2M1_hnyx0hw.png"/></div></figure><h2 id="9d83" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">调整大小</h2><p id="404b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果我们需要改变元素的总数，那么我们需要调整数组的大小。如果我们扩大它，它将添加尾随零，直到它达到新的大小。否则，它将被截断为新的大小。</p><p id="5360" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">📌<code class="fe nf ng nh ni b">resize</code> <strong class="lo iu">修改了</strong>原来的阵列。</p><p id="a4ff" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">继续这个例子，我们可以将 9 元素数组扩大到 15 元素:<br/> <code class="fe nf ng nh ni b">array09.resize(15, refcheck = False)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rp"><img src="../Images/de43d157a4fd3ecdda54157b2388f7c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*FWS5ODrJaxCyhM-QsDUEkA.png"/></div></figure><p id="f3d6" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">或者我们可以将其截断为 5 个元素:<br/> <code class="fe nf ng nh ni b">array09.resize(5, refcheck = False)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rq"><img src="../Images/4c14833bdbfe1955302e2b36521c78c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*LBlz1_Ihxf1QWr3hydSOVQ.png"/></div></figure><p id="4a0e" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">📌扩大数组的另一个期望行为是让它重复自己，直到它达到新的大小。在这种情况下，我们可以使用<code class="fe nf ng nh ni b">resize</code>的“静态”版本，它将原始数组作为输入:<br/> <code class="fe nf ng nh ni b">np.resize(array09, 10)</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rr"><img src="../Images/23a2b6f9881c0403fda4722497c38af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*zxDX6Mnu5k9vieunl38hAQ.png"/></div></figure><h2 id="75eb" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">新维度</h2><p id="ac8e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在数组中插入一个新轴会增加数组的维数。<code class="fe nf ng nh ni b">newaxis</code>通常用于使阵列兼容广播。</p><p id="0966" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">在本例中，我们将了解如何将一个单行表格转置为一个单列表格:</p><pre class="kj kk kl km gt qo ni qp qq aw qr bi"><span id="05ef" class="nj kv it ni b gy qs qt l qu qv">array1x4 = np.array([1, 2, 3, 4])<br/>print(array1x4)<br/>print(np.shape(array1x4))</span><span id="3d35" class="nj kv it ni b gy rs qt l qu qv">array4x1 = array1x4[:, np.newaxis]<br/>print(array4x1)<br/>print(np.shape(array4x1))</span></pre><p id="056d" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">很整洁，对吧？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rt"><img src="../Images/a460904d9c119e97006ef183eabb3ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*PP5FYkH0V4jln9_JqykHag.png"/></div></figure><h2 id="1a97" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">变平与变松</h2><p id="d0b8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">展平是整形的逆操作。我们可以用方法<code class="fe nf ng nh ni b">flatten</code>和<code class="fe nf ng nh ni b">ravel</code>将多维数组展平成一维。方法<code class="fe nf ng nh ni b">flatten</code> <strong class="lo iu"> deep </strong>复制原始数组的数据，而<code class="fe nf ng nh ni b">ravel</code> <strong class="lo iu"> shallow </strong>复制它，[这样展平比较慢]。</p><p id="97c7" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">下面是一个 2x2 的数组:<code class="fe nf ng nh ni b">array2x2 = np.arange(1, 5).reshape(2, 2)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ru"><img src="../Images/68c6e1882411f0cc6baac779b0019c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*BTZFpV-rlzkz6p2WTicdHA.png"/></div></figure><p id="26f3" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们将它展平—深度复制:<code class="fe nf ng nh ni b">array2x2.flatten()</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rv"><img src="../Images/8e833bc67f0e16c0d707c804270e974f.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*N-BelNidapNhGEpcrlfI1g.png"/></div></figure><p id="e58b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">然后迅速重新设置为 2x2: <code class="fe nf ng nh ni b">array2x2 = array2x2.reshape(2, 2)</code></p><p id="2196" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">然后再解开——浅抄:<code class="fe nf ng nh ni b">array2x2.ravel()</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rw"><img src="../Images/a5ce06a3c037c4e9b9b4181eb79e4c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*uvB6EMoIl1ZR_peMJgaD_w.png"/></div></figure><h2 id="d252" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">移项</h2><p id="8cc0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">转置一个数组，也就是改变它的维度(意味着把它的形状从<code class="fe nf ng nh ni b">(X,Y)</code>变成<code class="fe nf ng nh ni b">(Y,X)</code>)也非常简单。</p><p id="ee7b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">📌<code class="fe nf ng nh ni b">transpose</code>返回一个新数组，它是原数组的<strong class="lo iu">浅</strong>副本。</p><p id="6080" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">下面是一个数组:<br/> <code class="fe nf ng nh ni b">toBeTransposed = np.arange(1, 5).reshape(2, 2)</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rx"><img src="../Images/e1334d2ba7e7638b583d996e22f26085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*Axe-kBFYkTcIx2vqdF04mg.png"/></div></figure><p id="bbaa" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这里是它的转置副本:<br/> <code class="fe nf ng nh ni b">toBeTransposed.transpose()</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ry"><img src="../Images/d498a6b779c2277f2af3978e4c3eca54.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*MlOZICgy5TY2F3tnvIrK2A.png"/></div></figure><h2 id="9217" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">加入</h2><p id="7a0e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">连接或串联意味着将两个或多个数组的内容放在一个数组中，沿着指定的轴，将它们“堆叠”在(<code class="fe nf ng nh ni b">axis = 1</code>)下面或(<code class="fe nf ng nh ni b">axis = 0</code>)旁边。有几个选项可以做到这一点，但<code class="fe nf ng nh ni b">concatenate</code>功能是最受欢迎的。</p><p id="aa3d" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这里有两个 3x3 数组，<code class="fe nf ng nh ni b">arr1</code>和<code class="fe nf ng nh ni b">arr2</code>:</p><pre class="kj kk kl km gt qo ni qp qq aw qr bi"><span id="8010" class="nj kv it ni b gy qs qt l qu qv">arr1 = np.arange(9).reshape(3, 3)<br/>arr2 = arr1 * 2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rz"><img src="../Images/06b7d7f3502b915b917d7d69867df5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*apC-nQLqqid-DTgT8zEQhQ.png"/></div></figure><p id="b6aa" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu"> ◼️垂直拼接【行式|轴= 0】<br/></strong><code class="fe nf ng nh ni b">np.concatenate((arr1, arr2))</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/f80a65ee43736da3ad2f9171b01f714a.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*7fSmYMW-C-h9XkqKZKf7SQ.png"/></div></figure><p id="df0f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu"> ◼️水平串联【列式|轴= 1】<br/></strong><code class="fe nf ng nh ni b">np.concatenate((arr1, arr2), axis = 1)</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi px"><img src="../Images/d9b1ba683a2e39aa6375165a35e9e1b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*v62cvcxbgDc8mYAUz9TGSg.png"/></div></figure><h2 id="f6bd" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">裂开</h2><p id="8b71" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">拆分是连接的反向操作，即我们将一个数组的内容沿着指定的轴拆分成多个子数组。<br/>我们可以将它们拆分成<strong class="lo iu">相同形状</strong>的数组，或者指示<strong class="lo iu">位置</strong>，在此之后应该进行拆分。</p><p id="f998" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">使用这个九元素数组(<code class="fe nf ng nh ni b">arr3</code>)，我们将看到这两种变化(在<code class="fe nf ng nh ni b">axis = 0</code>上):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi sa"><img src="../Images/76908ca4e05ad9e85292e7628b11c362.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*E5q24QmR92AdeA9dSnvNIw.png"/></div></figure><p id="9c05" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu"> ◼️均匀分割<br/> </strong> <code class="fe nf ng nh ni b">np.split(arr3, 3)<br/></code>将产生 3 个大小相等的子阵列:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi sb"><img src="../Images/29779e883d5ab180260b96c7f686d2c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*2zeArulD_0L5f0SSvrzG3w.png"/></div></figure><p id="fd2a" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu"> ◼️不均匀分割，基于一维数组<br/> </strong> <code class="fe nf ng nh ni b">np.split(arr3, [2, 7]))<br/></code>中指示的位置，将产生 3 个子数组，在第 2 个和第 7 个元素之后分割:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi sc"><img src="../Images/d6c0483c2743b3fa1a3cf3cb9954376f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*E9MDxT2Yb9NTpQmdHUzDyw.png"/></div></figure></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi sd"><img src="../Images/3cc23c836800d8b02a4c8a75e49371a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZA3p516c_1dUeXc38TEuhA.png"/></div></div></figure><pre class="kj kk kl km gt qo ni qp qq aw qr bi"><span id="ac5f" class="nj kv it ni b gy qs qt l qu qv">'Map, Filter and Reduce' are paradigms of functional programming. They allow us to write simpler, shorter code, without needing to bother about for-loops or if-else branching. Even if they <!-- -->are powerful on their own, 'the cherry on top' is that they can be chained together.</span><span id="a59b" class="nj kv it ni b gy rs qt l qu qv">The next three sections will cover <strong class="ni iu">exactly that</strong>, when it comes to NumPy arrays.</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi sd"><img src="../Images/3cc23c836800d8b02a4c8a75e49371a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZA3p516c_1dUeXc38TEuhA.png"/></div></div></figure></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><h1 id="0db5" class="ku kv it bd kw kx ps kz la lb pt ld le jz pu ka lg kc pv kd li kf pw kg lk ll bi translated">➑ —制图</h1><p id="3b63" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了将转换应用到 NumPy 数组中，我们将使用<code class="fe nf ng nh ni b">vectorize</code>函数。返回一个新数组，映射生效。</p><p id="1d9d" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">下面是一个简单的数组:<br/> <code class="fe nf ng nh ni b">toBeMapped = np.arange(0, 10)</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi se"><img src="../Images/c4bc57d34490556f0eeb78bf323ee0ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*fJMKxqmutqz9EYIXbPAewA.png"/></div></figure><p id="e4c3" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们现在将通过传递一个 lambda 匿名函数使数组的所有元素加倍:<br/> <code class="fe nf ng nh ni b">np.vectorize(lambda x: x * 2)(toBeMapped)</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/f1eda26b9b9ff30e1ee22a9b3bb62af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*dzVsmGQLGFtK0QexXnv68A.png"/></div></figure><p id="352c" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">如果我们有一个更复杂的计算(有许多行代码)，我们可以传递一个函数来代替。</p><p id="6fdd" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">📌根据文档，“提供<code class="fe nf ng nh ni b"><a class="ae mi" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html#numpy.vectorize" rel="noopener ugc nofollow" target="_blank">vectorize</a></code>功能主要是为了方便，而不是为了提高性能。该实现本质上是一个 for 循环。然而可读性是这里的关键，所以尽管它使用了 for 循环，但我们的代码没有！</p></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><h1 id="4d53" class="ku kv it bd kw kx ps kz la lb pt ld le jz pu ka lg kc pv kd li kf pw kg lk ll bi translated">➒滤波</h1><p id="3082" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Filter，用一元谓词测试每个元素。NumPy 为此提供了<code class="fe nf ng nh ni b">extract</code>函数。满足谓词的元素被保留；不符合的将被删除。返回一个新数组；过滤器不会修改原始数组。</p><p id="400f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">下面是我们的示例数组:<br/> <code class="fe nf ng nh ni b">toBeFiltered = np.arange(0, 9).reshape(3, 3)</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/54bafb400e9e12004c8c93cf16c9c30e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*L32-EgsrOwJjsJOY-5SsMw.png"/></div></figure><p id="7a22" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们要选择奇数:<br/> <code class="fe nf ng nh ni b">np.extract(toBeFiltered % 2 == 1, toBeFiltered)</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi sf"><img src="../Images/5f99435adc0c05f25c355a14fcf983fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*sQ7xSjnC-Oh10JoIlUQjUg.png"/></div></figure><p id="3c3f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">实现相同结果的等效方式如下:<br/> <code class="fe nf ng nh ni b">toBeFiltered[toBeFiltered % 2 == 1]</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi sg"><img src="../Images/90ff3689bd0b517f003818b5a085f89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*8iYMqSjeuor6HZXjD5jUPg.png"/></div></figure></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><h1 id="bb3b" class="ku kv it bd kw kx ps kz la lb pt ld le jz pu ka lg kc pv kd li kf pw kg lk ll bi translated">➓——还原</h1><p id="952d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当面对大量数据时，期望的步骤是通过在整个阵列或其一个轴上应用计算来减少维度。</p><p id="7063" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">下面是一个 2x3 的数组:<br/> <code class="fe nf ng nh ni b">toBeReduced = np.arange(1, 7).reshape(2, 3)</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi sh"><img src="../Images/24bc8803e2afa8d6baf4520e9b16f03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*dYb04XCKSc5MQnQZwyMcKQ.png"/></div></figure><h2 id="25f1" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">总和</h2><p id="af9f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo iu">整个数组<br/> </strong> <code class="fe nf ng nh ni b">toBeReduced.sum()<br/></code>上的◼️将产生一个代表所有元素之和的标量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi si"><img src="../Images/bc2088167a0e3a9004093b5a8d0bea5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*UOE9CrzjgaLaB2gYPFp4ug.png"/></div></figure><p id="61ca" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu"> ◼️按列[axis = 0] <br/> </strong> <code class="fe nf ng nh ni b">toBeReduced.sum(axis = 0)<br/></code>将产生一个 1x3 数组，其中每个元素是各自列的总和:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/4c21211668be375121b87304bfeec840.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*ERMd_bbS7JLUjXe8MmPfDg.png"/></div></figure><p id="9f4b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu"> ◼️按行[axis = 1] <br/> </strong> <code class="fe nf ng nh ni b">toBeReduced.sum(axis = 1)<br/></code>将产生一个 3x1 的数组，其中每个元素是各自行的总和:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi sj"><img src="../Images/ac85247d7fca334d8ccc774327cf1869.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*Mi0nrrbJrAIVEVd2fROlWA.png"/></div></figure><h2 id="1b54" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">其他削减</h2><p id="3fcb" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">他们都以同样的方式工作。例如:</p><p id="982e" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu"> ◼️最小/最大值<br/> </strong> <code class="fe nf ng nh ni b">toBeReduced.min()</code>和<code class="fe nf ng nh ni b">toBeReduced.max()</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi sk"><img src="../Images/efb932f6b8c748e5b03a002ebd2d54d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*M5Z2XBUHiMRRI7g3GU1ODw.png"/></div></figure><p id="fa0c" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><strong class="lo iu"> ◼️其他<br/>t27】另外两个重要的类别包括:</strong></p><ul class=""><li id="06f1" class="oe of it lo b lp mj ls mk lv og lz oh md oi mh oj ok ol om bi translated"><a class="ae mi" href="https://docs.scipy.org/doc/numpy/reference/routines.logic.html#truth-value-testing" rel="noopener ugc nofollow" target="_blank">逻辑归约(真值测试)</a></li><li id="410e" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated"><a class="ae mi" href="https://docs.scipy.org/doc/numpy/reference/routines.statistics.html" rel="noopener ugc nofollow" target="_blank">统计</a></li></ul><p id="4dc8" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我建议你浏览一下，然后边走边学。</p><blockquote class="mp"><p id="70c9" class="mq mr it bd ms mt mu mv mw mx my mh dk translated">我的赞美！你已经准备好为一个<strong class="ak">骰子</strong>叫牌了！</p></blockquote><figure class="na nb nc nd ne kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/a35353d463873936841b4c000ddd4925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H1HVUz52q_bKNF6aDjH6Cw.png"/></div></div></figure><h1 id="fa1d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">NumPy 性能提示和技巧</h1><p id="a4e8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了优化程序的性能，我们要做的第一件事就是将计算或内存分配移到 for 循环之外。我们已经介绍了很多关于 NumPy 技术的材料，但是让我们提炼这些技巧和诀窍，并使它们变得清晰，以帮助您编写更高性能的代码。</p><h2 id="0b7e" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">1️⃣ —矢量化</h2><p id="bc99" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">矢量化是以元素方式处理整个数组的操作。它们将 Python 的显式 for 循环转化为隐式、低级、优化和编译的 C 实现，因此您应该更喜欢它们。</p><h2 id="fc56" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">2️⃣ —副本</h2><p id="0ed0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你应该避免不必要的深层拷贝；尽可能使用浅层副本(或视图)和就地操作。</p><h2 id="c0b3" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">3️⃣ —广播</h2><p id="8ce4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在组合数组之前，应该使用广播对尽可能小的数组进行操作；最小的维度在内部被拉伸以匹配另一个维度，但是这个操作不涉及任何内存复制。</p><h2 id="d0eb" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">4️⃣——记忆</h2><p id="a3c0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Numpy 数组按行优先顺序存储，即展平的内存是逐行表示的。因此，将数据存储在连续的内存块中可以确保现代 CPU 的架构在内存访问模式和 CPU 缓存方面得到最佳利用。因此，以连续的方式访问或遍历一个数组比随机访问要快得多，所以你应该明智地选择如何在 n 维中表示数据。作为一个说明性的例子，沿行对元素求和比沿列快。</p><h2 id="2097" class="nj kv it bd kw nk nl dn la nm nn dp le lv no np lg lz nq nr li md ns nt lk nu bi translated">5️⃣ —函数阵列编程</h2><p id="c255" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你应该使用 Map、Filter、Reduce 来避免 for 循环和条件编程。</p><blockquote class="mp"><p id="1b98" class="mq mr it bd ms mt mu mv mw mx my mh dk translated">精彩！你坚持到了最后！</p></blockquote></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><h1 id="bf9d" class="ku kv it bd kw kx ps kz la lb pt ld le jz pu ka lg kc pv kd li kf pw kg lk ll bi translated">推荐阅读</h1><ul class=""><li id="779b" class="oe of it lo b lp lq ls lt lv sl lz sm md sn mh oj ok ol om bi translated"><a class="ae mi" href="https://github.com/rougier/numpy-100/blob/master/100_Numpy_exercises_with_solutions.md" rel="noopener ugc nofollow" target="_blank"> 100 Numpy 演习</a></li><li id="2f93" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated"><a class="ae mi" href="https://realpython.com/numpy-array-programming/" rel="noopener ugc nofollow" target="_blank">真正的 Python:用 NumPy 进行数组编程</a></li><li id="ad19" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated"><a class="ae mi" href="https://hal.inria.fr/inria-00564007/document" rel="noopener ugc nofollow" target="_blank">NumPy 数组:高效数值计算的结构</a><br/><strong class="lo iu"><em class="mo">* *</em></strong><em class="mo">必读</em> <strong class="lo iu"> <em class="mo"> ** </em> </strong></li><li id="589b" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated"><a class="ae mi" href="http://scipy-lectures.org/advanced/advanced_numpy/" rel="noopener ugc nofollow" target="_blank">科学讲座:高级数字</a></li><li id="f52c" class="oe of it lo b lp or ls os lv ot lz ou md ov mh oj ok ol om bi translated"><a class="ae mi" href="https://www.amazon.co.uk/Beautiful-Code-Leading-Programmers-Practice/dp/0596510047" rel="noopener ugc nofollow" target="_blank">美丽的代码</a>【论文 19:‘Numpy 中的多维迭代器’】</li></ul></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><h1 id="3828" class="ku kv it bd kw kx ps kz la lb pt ld le jz pu ka lg kc pv kd li kf pw kg lk ll bi translated">收场白</h1><p id="c20f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我希望 NumPy 的强大和它所带来的灵活性能让你有所启发。现在，您已经具备了帮助您优化代码性能并尽可能消除 for 循环所需的知识和技能。你需要做的就是:<br/>练习——练习——练习！</p><p id="e531" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">感谢阅读！</p></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><p id="685a" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><em class="mo">我经常在媒体上写关于领导力、技术&amp;的数据——如果你想阅读我未来的帖子，请</em><a class="ae mi" href="https://medium.com/@semika" rel="noopener"><em class="mo">‘关注’我</em> </a> <em class="mo">！</em></p></div></div>    
</body>
</html>