<html>
<head>
<title>Single Line of Code to Interchange Between Python Objects and JSON</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 对象和 JSON 之间交换的单行代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/single-line-of-code-to-interchange-between-python-objects-and-json-b0f23fbaaa65?source=collection_archive---------41-----------------------#2020-06-28">https://towardsdatascience.com/single-line-of-code-to-interchange-between-python-objects-and-json-b0f23fbaaa65?source=collection_archive---------41-----------------------#2020-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8e9c215aa23e9edd874641cfb4ce78ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JT1_0qUedbROkvpiVjcQVw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> geralt </a>在<a class="ae jg" href="https://pixabay.com/illustrations/binary-code-binary-binary-system-475664/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><h2 id="3042" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">Python 编程技巧</h2><div class=""/><div class=""><h2 id="7f7c" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">在 Python 对象和 JSON 之间序列化/反序列化的最简单方法是<code class="fe lh li lj lk b">Attr</code>和<code class="fe lh li lj lk b">Cattr</code></h2></div><p id="524b" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">在我以前的一篇文章中，我介绍了 Python 中面向对象编程(OOP)的最佳实践，即使用“Attrs”库。</p><div class="is it gp gr iu mh"><a rel="noopener follow" target="_blank" href="/probably-the-best-practice-of-object-oriented-python-attr-d8c26c0e8a4"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jt gy z fp mm fr fs mn fu fw js bi translated">可能是面向对象 Python 的最佳实践— Attr</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">让 Python 面向对象编程变得更加容易</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv ja mh"/></div></div></a></div><p id="e880" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">然而，在大多数情况下，我们使用 OOP 可能是因为它可以序列化为字符串，如 JSON 字符串。更方便的是，我们还应该能够将它反序列化回类实例以用于其他目的。</p><p id="f5ed" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">例如，其中最流行的用法之一是数据访问对象(DAO)。因此，我们可以用对象实现 CRUD 函数，以便与持久层无缝集成。</p><p id="10ac" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">因此，大多数时候，我们可能希望将 Python 对象序列化到 JSON 中，以便进行传输。相反，如果我们使用 Python 接收 JSON 类型的数据，我们也希望将 JSON 字符串反序列化为 Python 对象。</p><p id="b9d3" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">在本文中，我将介绍另一个库——“Cattr”，它可以与“attr”一起使用。我将把重点放在“Cattr”上，所以如果你对“attr”的功能感兴趣，请查看上面提到的文章。</p><h1 id="1ca3" class="mw mx jj bd my mz na nb nc nd ne nf ng ky nh kz ni lb nj lc nk le nl lf nm nn bi translated">安装和导入</h1><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/7543ec0646064999777247c304da9319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qSQkjtKFHf_yi2csvcZ3kQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/JoshuaWoroniecki-12734309/" rel="noopener ugc nofollow" target="_blank"> JoshuaWoroniecki </a>在<a class="ae jg" href="https://pixabay.com/photos/keyboard-computer-technology-light-5017973/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="7f11" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">首先，我们需要使用<code class="fe lh li lj lk b">pip</code>安装这两个库。</p><pre class="no np nq nr gt ns lk nt nu aw nv bi"><span id="438a" class="nw mx jj lk b gy nx ny l nz oa">pip install attrs<br/>pip install cattrs</span></pre><p id="1bcd" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">在本文中，我们从<code class="fe lh li lj lk b">attr</code>中需要的只是类和属性函数的注释，所以让我们将它们和库<code class="fe lh li lj lk b">cattr</code>一起导入。</p><pre class="no np nq nr gt ns lk nt nu aw nv bi"><span id="e15c" class="nw mx jj lk b gy nx ny l nz oa">from attr import attrs, attrib<br/>import cattr</span></pre><h1 id="dba3" class="mw mx jj bd my mz na nb nc nd ne nf ng ky nh kz ni lb nj lc nk le nl lf nm nn bi translated">Cattr 的基本用法</h1><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/989f0041b5be64c3f304c79c91550940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1yFK6xMA4rIuQm5ZFuRShg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/Free-Photos-242387/" rel="noopener ugc nofollow" target="_blank">在<a class="ae jg" href="https://pixabay.com/photos/desk-table-simple-mockup-1081708/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的</a>自由照片拍摄的照片</p></figure><p id="df6f" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">基本上，<code class="fe lh li lj lk b">cattr</code>用于在结构化和非结构化状态之间转换数据对象。例如，来自类的实例被认为是结构化数据，而 Python 字典和 JSON 对象被认为是非结构化数据。</p><p id="4749" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">假设我们要用不确定来规范一个列表中的数据，我们可以用<code class="fe lh li lj lk b">cattr</code>如下。</p><pre class="no np nq nr gt ns lk nt nu aw nv bi"><span id="7792" class="nw mx jj lk b gy nx ny l nz oa">from typing import Tuple</span><span id="dfc1" class="nw mx jj lk b gy ob ny l nz oa">cattr.structure([1.01, True, False, "2", "I will be ignored"], Tuple[int, int, int, int])</span></pre><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oc"><img src="../Images/79817c9d567238798bea4c131ee0b917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ne4ftRgTUFZccXb89lCAzA.png"/></div></div></figure><p id="48c3" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">请注意，我们使用的是来自<code class="fe lh li lj lk b">typing</code>库中的类型别名“Tuple ”,这是 Python 3 内置的。如果你不确定它是什么，这里是官方文档。</p><div class="is it gp gr iu mh"><a href="https://docs.python.org/3/library/typing.html" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jt gy z fp mm fr fs mn fu fw js bi translated">类型-支持类型提示- Python 3.8.3 文档</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">源代码:Lib/typing.py 注意 Python 运行时不强制函数和变量类型注释。他们可以是…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">docs.python.org</p></div></div></div></a></div><p id="3d37" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">在本例中，float、boolean 和 string 对象被调整为模板中指定的整数。此外，列表中的第 5 个对象被忽略，因为模板中只有 4 个元素。</p><h1 id="9994" class="mw mx jj bd my mz na nb nc nd ne nf ng ky nh kz ni lb nj lc nk le nl lf nm nn bi translated">Cattr 与 attr 合作</h1><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2636a3975895212dde3a2dc1f493f261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OPN9fEn2K6FT5MuX2HVF8Q.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/PublicDomainPictures-14/" rel="noopener ugc nofollow" target="_blank"> PublicDomainPictures </a>在<a class="ae jg" href="https://pixabay.com/photos/connect-connection-cooperation-20333/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片</p></figure><p id="d9cf" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated"><code class="fe lh li lj lk b">cattr</code>和<code class="fe lh li lj lk b">attr</code>一起处理班级的时候效果最好。</p><p id="0e29" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">假设我们如下定义这个类。</p><pre class="no np nq nr gt ns lk nt nu aw nv bi"><span id="ff46" class="nw mx jj lk b gy nx ny l nz oa"><a class="ae jg" href="http://twitter.com/attrs" rel="noopener ugc nofollow" target="_blank">@attrs</a><br/>class Person:<br/>  name = attrib()<br/>  age = attrib()</span><span id="ff1e" class="nw mx jj lk b gy ob ny l nz oa">def tell_age(self):<br/>    print(f'My name is {self.name} and my age is {self.age}.')</span></pre><p id="9222" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">当然，正如我在上一篇文章中介绍的，<code class="fe lh li lj lk b">attr</code>可以用于将实例序列化到字典中。</p><pre class="no np nq nr gt ns lk nt nu aw nv bi"><span id="5237" class="nw mx jj lk b gy nx ny l nz oa">from attr import asdict</span><span id="df8f" class="nw mx jj lk b gy ob ny l nz oa">p1 = Person('Chris', 32)<br/>asdict(p1)</span></pre><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/b8d5e99bc6deebd5e548c06567c936df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*jbTkqZ1bevSx1WL7QxpY-g.png"/></div></div></figure><p id="c5e8" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">当然，<code class="fe lh li lj lk b">cattr</code>也可以这样做。</p><pre class="no np nq nr gt ns lk nt nu aw nv bi"><span id="4309" class="nw mx jj lk b gy nx ny l nz oa">cattr.unstructure(p1)</span></pre><figure class="no np nq nr gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/59b11d1f0e9bc8fb75842d6da217fe91.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*K6fQ025l6DxSWVdbu95uZw.png"/></div></figure><p id="57c8" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">看起来来自<code class="fe lh li lj lk b">attr</code>的<code class="fe lh li lj lk b">asdict()</code>函数更直观。然而，这只是序列化。如果我们得到了一个字典，并想将它反序列化为一个<code class="fe lh li lj lk b">Person </code>对象，该怎么办？这次<code class="fe lh li lj lk b">attr</code>帮不上忙，但是我们可以用<code class="fe lh li lj lk b">cattr</code>。</p><pre class="no np nq nr gt ns lk nt nu aw nv bi"><span id="4dc8" class="nw mx jj lk b gy nx ny l nz oa">p2 = cattr.structure({'name': 'Chelsea', 'age': 1}, Person)</span></pre><figure class="no np nq nr gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/8188191868a52acf996a2dc0ea38c0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*gFDOXK-fZ-uWxH3uQ7tNYw.png"/></div></figure><h1 id="edfa" class="mw mx jj bd my mz na nb nc nd ne nf ng ky nh kz ni lb nj lc nk le nl lf nm nn bi translated">Cattr 使用字典列表</h1><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b653bd90d3ae77196b110fc43a984968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_FhOSy1nIN-OaXyZpq5gw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/josephredfield-8385382/" rel="noopener ugc nofollow" target="_blank">约瑟夫菲尔德</a>在<a class="ae jg" href="https://pixabay.com/photos/people-friends-together-happy-4050698/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片</p></figure><p id="70c4" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">上面的例子只是对单个字典的反序列化。实际上，这并不理想。如果我们想将字典列表反序列化为 Python 对象，该怎么办？在下面的例子中，我们有三个字典要在列表中描述。</p><pre class="no np nq nr gt ns lk nt nu aw nv bi"><span id="1db5" class="nw mx jj lk b gy nx ny l nz oa">p_list_raw = [<br/>  {'name': 'Alice', 'age': 20},<br/>  {'name': 'Bob', 'age': 25},<br/>  {'name': 'Chris', 'age': 32}<br/>]</span></pre><p id="8b45" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">要实现这一点，我们还需要定义一个“模板”。请注意，我们传入的参数不再是“人”，而是“人”对象的列表。因此，我们需要再次使用输入别名。</p><pre class="no np nq nr gt ns lk nt nu aw nv bi"><span id="9882" class="nw mx jj lk b gy nx ny l nz oa">from typing import List</span><span id="4f5e" class="nw mx jj lk b gy ob ny l nz oa">p_list = cattr.structure(p_list_raw, List[Person])</span></pre><figure class="no np nq nr gt iv gh gi paragraph-image"><div class="gh gi og"><img src="../Images/804d7a2724f6b361e2440a85b98979f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*gyljPv6a_qx6QwWpPqthKA.png"/></div></figure><p id="4691" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">因此，我们从 person 字典列表中得到一个 person 对象列表。</p><h1 id="1238" class="mw mx jj bd my mz na nb nc nd ne nf ng ky nh kz ni lb nj lc nk le nl lf nm nn bi translated">Cattr 使用 JSON</h1><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/dfd0c46a95fd538c0c319667dd10a779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IEvYj3jEUJTma7EYKloLWA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/SCY-1147075/" rel="noopener ugc nofollow" target="_blank"> SCY </a>在<a class="ae jg" href="https://pixabay.com/photos/laptop-book-information-online-819285/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="f564" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">当然，我们并不满足于仅仅序列化/去序列化 Python 字典。我们希望它是一个 JSON 对象！这也很容易。事实上，我们唯一需要做的就是导入<code class="fe lh li lj lk b">json</code>库，它也是一个 Python 内置模块。</p><p id="c8f0" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">回想一下，在前面的例子中，我们有一个 Python 对象列表<code class="fe lh li lj lk b">p_list</code>。</p><figure class="no np nq nr gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/bd04f9e07930868d5f181d34b25088ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*IdjNXQzozoA9EVCBxRgVnw.png"/></div></figure><p id="8048" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">要将其序列化为 JSON 数组，只需将<code class="fe lh li lj lk b">cattr</code>与<code class="fe lh li lj lk b">json.dumps()</code>函数一起使用，如下所示。</p><pre class="no np nq nr gt ns lk nt nu aw nv bi"><span id="61dc" class="nw mx jj lk b gy nx ny l nz oa">import json</span><span id="1d90" class="nw mx jj lk b gy ob ny l nz oa">json_obj = json.dumps(cattr.unstructure(p_list))<br/>print(json_obj)</span></pre><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/7bf204bf1729f3ee5cc49c51c968f58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PbjAmPdYFqUHYHGqOPOmsA.png"/></div></div></figure><p id="3c28" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">将 JSON 数组反序列化为 Python 对象列表也非常容易。简单地将<code class="fe lh li lj lk b">json.loads()</code>功能与<code class="fe lh li lj lk b">cattr</code>结合使用。</p><pre class="no np nq nr gt ns lk nt nu aw nv bi"><span id="4619" class="nw mx jj lk b gy nx ny l nz oa">p_list = cattr.structure(json.loads(json_obj), List[Person])</span></pre><figure class="no np nq nr gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/28dffa68fdc24657dafdb1311a2dc59d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*fTEaq2vCm46t7wv8lySrPw.png"/></div></figure><p id="006c" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">只是不要忘记我们需要输入别名“列表”作为模板。</p><p id="0c06" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">当然，上面的例子也显示了去序列化的对象可以用它们的类函数来调用:)</p><h1 id="14ed" class="mw mx jj bd my mz na nb nc nd ne nf ng ky nh kz ni lb nj lc nk le nl lf nm nn bi translated">摘要</h1><figure class="no np nq nr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a51d92b04fc271e90b3f26e9214091bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOdIoYj487hwNVMNYTN7VQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> geralt </a>在<a class="ae jg" href="https://pixabay.com/photos/learn-note-sign-directory-64058/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片</p></figure><p id="fbaf" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">在这篇文章中，我介绍了如何使用<code class="fe lh li lj lk b">cattr</code>和<code class="fe lh li lj lk b">attr</code>库来实现将 Python 对象序列化为 dictionary/JSON，以及以一种极其简单的方式将 dictionary 和 JSON 对象反序列化为 Python 对象。</p><p id="f94e" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">考虑到这在大多数其他编程语言中通常不是一件容易的事情，至少实现起来没有那么快，我想说这从一个方面反映了为什么人们喜欢 Python。</p><p id="a7e1" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">本文中的所有代码都可以在这里找到:</p><div class="is it gp gr iu mh"><a href="https://colab.research.google.com/drive/1fm8PWLVp2vHEhkArmUcDp6VdNqLSG-O1?usp=sharing" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jt gy z fp mm fr fs mn fu fw js bi translated">Attrs+Cattrs.ipynb</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">Google Colab</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">colab.research.google.com</p></div></div><div class="mq l"><div class="ok l ms mt mu mq mv ja mh"/></div></div></a></div><div class="is it gp gr iu mh"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jt gy z fp mm fr fs mn fu fw js bi translated">通过我的推荐链接加入 Medium 克里斯托弗·陶</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div><div class="mq l"><div class="ol l ms mt mu mq mv ja mh"/></div></div></a></div><p id="7d6b" class="pw-post-body-paragraph ll lm jj ln b lo lp kt lq lr ls kw lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated">如果你觉得我的文章有帮助，请考虑加入 Medium 会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>