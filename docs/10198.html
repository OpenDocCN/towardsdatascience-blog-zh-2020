<html>
<head>
<title>Visualizing Time Series Survival Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可视化时间序列生存数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visualizing-time-series-survival-data-36029652a393?source=collection_archive---------26-----------------------#2020-07-18">https://towardsdatascience.com/visualizing-time-series-survival-data-36029652a393?source=collection_archive---------26-----------------------#2020-07-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/7accadd70170bfa5d76b0720ffb2f9c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6wkEntAbI5s6rJMh"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Geran de Klerk 在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="2e4b" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">卡普兰-迈耶曲线</h2></div><p id="ed52" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们想象一下，你有关于你的研究对象“存活”了多久的数据。生存可以是字面意义上的(如在临床试验中)或比喻意义上的(如果你正在研究客户保持，当人们停止阅读一篇文章，或当一台机器坏了)。为了可视化数据，我们想要绘制一条生存曲线，叫做卡普兰-迈耶曲线，如下图所示。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/92b8765fffe8f1dd921befe9fc969a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmmedFYvutzohi6ZVsyNCQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">具有 95%置信区间的药物耐受性和使用的存活曲线(人工生成的数据，n ≈ 300)</p></figure><p id="6410" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">左边的曲线(使用人工生成的数据创建)旨在显示开始服药几天后仍在服药的人的百分比。在这种情况下，他们会停下来，因为药物不再控制疾病，或者因为它引起了太多的副作用。</p><p id="106f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理想情况下，通过简单地考虑在开始服药后的给定天数内服药的人的百分比，很容易计算出这条曲线。</p><p id="6d34" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，一些人(本例中约 25%)仍在服药。他们可能只是服用了很长一段时间(在这种情况下接近 10 年)而没有问题，或者他们可能只是刚刚开始服用。这种观察被称为“右删截”,因为我们不能及时观察到它们(向右)。</p><p id="741c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对此最简单的解决方案是卡普兰-迈耶曲线，也称为乘积极限估计量。还有其他解决方案，但它们需要对数据做出假设，并为数据提供一个模型。另一方面，我们通常的第一步是只看数据，卡普兰-迈耶曲线允许我们在不做假设的情况下这样做。</p><p id="0097" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将讨论如何计算卡普兰-迈耶曲线，最重要的是，显示的置信区间。更重要的是，我们将探讨计算置信区间(有时称为“对数”和“对数-对数”/指数格林伍德置信区间)的两种方法之间的差异。</p><h1 id="a19e" class="lz ma jj bd mb mc md me mf mg mh mi mj kp mk kq ml ks mm kt mn kv mo kw mp mq bi translated">卡普兰·迈耶的估计</h1><p id="601c" class="pw-post-body-paragraph ky kz jj la b lb mr kk ld le ms kn lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">如果你还没猜到，这种生存曲线起源于医学和精算界，字面上的关注是某人是否真的会死亡。因此，我们将采用这样的术语:研究中给定的受试者(比如说一个人)可能仍然活着，在这种情况下，观察是经过审查的(我们没有观察到一个事件)，或者他们可能已经在特定的时间点死亡(我们观察到了该事件)。</p><p id="0821" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，当我们说“时间”时，我们不是指字面上的日期，而是相对于参与者进入研究的时间。在人寿保险的例子中，那只是他们出生的时间。在上面的医学例子中，它是当某人开始服用药物时。</p><p id="512e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上世纪 50 年代的卡普兰-迈耶估计，用文字表述比用公式表述更容易。规则是:</p><ol class=""><li id="f9f8" class="mw mx jj la b lb lc le lf lh my ll mz lp na lt nb nc nd ne bi translated">一开始，100%的人都是活着的。</li><li id="51a2" class="mw mx jj la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">在每个时间点(以<em class="nk"> i </em>为索引)，计算存活的人的百分比，作为已知活了那么久的人的百分比。</li><li id="353a" class="mw mx jj la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">为了创建曲线，假设在时间<em class="nk"> i </em>幸存者的百分比是该时间和每个先前时间的生存机会百分比的乘积。</li></ol><p id="4b94" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，假设我们有三个人的记录。一个活到了 92 岁，一个死于 90 岁，一个死于 95 岁。90 岁时，66.7%的人口存活下来。92 岁时，100%存活。在 95 岁时，100%的人(不是 50 岁)会死亡。这是因为 92 岁的人没有计入 95 岁的人口中。</p><p id="8cbd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，某人被审查的次数(在我们的例子中是 92 次)不会影响曲线。事实上，只有我们观察到某人死亡的次数才算数。</p><p id="2848" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们用方程式来做。</p><ul class=""><li id="928c" class="mw mx jj la b lb lc le lf lh my ll mz lp na lt nl nc nd ne bi translated">让<em class="nk"> i </em>索引某事发生的时间(即某人死亡)。</li><li id="91c0" class="mw mx jj la b lb nf le ng lh nh ll ni lp nj lt nl nc nd ne bi translated">设<em class="nk"> d </em>为在时间<em class="nk"> i. </em>停止的人数</li><li id="0517" class="mw mx jj la b lb nf le ng lh nh ll ni lp nj lt nl nc nd ne bi translated">设 n 是在时间<em class="nk"> i. </em>时人口中(已知幸存)的人数</li></ul><p id="ed1b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生存函数的卡普兰-迈耶估计量为</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/2d16235c3c61894250033173f4646e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*1jPKyZDWuRP07FZgMCpFXA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">生存函数的 Kaplan-Meier 估计</p></figure><p id="cbaa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，生存百分比与当前时间<em class="nk"> t </em>之前所有时间的产品的乘积。</p><p id="805d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">卡普兰-迈耶估计量是生存函数的最大似然估计量，这使得它成为快速可视化的自然选择。</p><p id="ef62" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，你可以发现这是大多数处理时间序列数据的统计软件包。对于 python 来说，<code class="fe nn no np nq b"><a class="ae jg" href="https://www.statsmodels.org/stable/generated/statsmodels.duration.survfunc.SurvfuncRight.html#statsmodels.duration.survfunc.SurvfuncRight" rel="noopener ugc nofollow" target="_blank">statsmodels</a></code>或<code class="fe nn no np nq b"><a class="ae jg" href="https://lifelines.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">lifelines</a></code>是一些不错的选择。<code class="fe nn no np nq b"><a class="ae jg" href="https://cran.r-project.org/web/packages/survival/index.html" rel="noopener ugc nofollow" target="_blank">survival</a></code>作 R。</p><h1 id="c7ce" class="lz ma jj bd mb mc md me mf mg mh mi mj kp mk kq ml ks mm kt mn kv mo kw mp mq bi translated">格林伍德置信区间</h1><p id="b071" class="pw-post-body-paragraph ky kz jj la b lb mr kk ld le ms kn lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">棘手的部分在于计算置信区间。首先，我们假设在时间<em class="nk"> i. </em>有一个真实的“风险率”，换句话说，我们假设<em class="nk"> d </em>遵循一个<a class="ae jg" href="https://en.wikipedia.org/wiki/Binomial_distribution" rel="noopener ugc nofollow" target="_blank">二项式分布</a>，概率<em class="nk"> h </em>和样本量<em class="nk"> n、</em>在时间<em class="nk"> i. </em>各不相同，这意味着它有均值和方差<em class="nk"> nh </em>和<em class="nk"> nh(1-h) </em>。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/2600e9a0441c2df113d581871ab4534c.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*PnqP9CsCYgH3FhQE6g4y1Q.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><em class="ns"> d </em>的均值和方差</p></figure><p id="a931" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一个技巧是，由于<em class="nk"> S </em>的估计量是一个乘积，所以处理<em class="nk"> S 的对数</em>会更容易，因为它是一个和。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/06be1cf906be2b3d4f576752a695449c.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*O9iBXKRRsDzl8FaIAGNalw.png"/></div></figure><p id="e190" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们需要转移话题，谈谈泰勒级数近似，它将使我们能够进行一系列的计算。</p><h2 id="bc99" class="nu ma jj bd mb nv nw dn mf nx ny dp mj lh nz oa ml ll ob oc mn lp od oe mp of bi translated">德尔塔法</h2><p id="c9a7" class="pw-post-body-paragraph ky kz jj la b lb mr kk ld le ms kn lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">Delta 方法是处理随机变量(如对数)转换的一种方便而严格的方法。假设我们有一个随机变量 X 和一个函数<em class="nk"> f </em>(你应该认为它是对数)。如果我们假设 X 只是一个正则数(不是随机的)，那么我们可以写下关于一个点 c 的一阶泰勒展开式:</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi og"><img src="../Images/ad73bcd2612222f8d6206e828f0bf1de.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*OS_aFkAIOTI-4UtKzfC-AQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">f 的一阶泰勒展开</p></figure><p id="91c3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">delta 方法的本质洞见是，假设 X 是一个像样本均值或我们对 s 的估计一样的统计量，如果 c 是 X 的期望值，E[X]，那么在大样本量的极限下，X 将接近 c 并呈正态分布(由中心极限定理)，逼近将非常好。这让我们可以计算 f 的期望值:</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/e50278d0fac2c3c106c4bd2f8cdb960c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*QOP-JqLP-39jzlCOuTeqyA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">delta——期望值的方法近似值</p></figure><p id="03d1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更好的是，我们可以应用大一微积分的<a class="ae jg" href="https://en.wikipedia.org/wiki/Mean_value_theorem" rel="noopener ugc nofollow" target="_blank">中值定理</a>。假设我们已经测量了 X 的值，我们可以找到位于 c 和 X 之间的值 d，因此</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/6c70c0cac74e1ed3ffa7dd8175515133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*WroPDZGjxZBMLs2Mucw3Eg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">泰勒展开的中值定理</p></figure><p id="7431" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，在大样本量的限制下，X 更接近 c，因此 d 被挤压在它们之间，也更接近 c。因此，在大样本量的限制下非正式地工作，我们可以将上面的近似等式视为等式。</p><p id="048b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在假设我们知道 X 的方差取决于样本大小<em class="nk"> n </em>:</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/3aa48d3ee6f550bf438727fe1b1234d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*e1-F-yyIYau533i_U04LSA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">根据中心极限定理，x 关于其期望值是正态分布的</p></figure><p id="9e3f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到我们最初的泰勒展开，重新排列各项并乘以<em class="nk"> n </em>的平方根:</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/b8cb2c9ecf358d4cb5b5f45ea819f39c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*2auyJ-GZ3myh0IqX00OPNw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">f(X)的泰勒展开的重排</p></figure><p id="4b52" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着我们已经计算出 f(X)的方差是 x 乘以 fʹ(c 平方的方差。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/972fdd52a026c6f007735aba3509725d.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*iylUycb0bVYJ94NdAohiPw.png"/></div></figure><h2 id="8149" class="nu ma jj bd mb nv nw dn mf nx ny dp mj lh nz oa ml ll ob oc mn lp od oe mp of bi translated">运用德尔塔法</h2><p id="c51c" class="pw-post-body-paragraph ky kz jj la b lb mr kk ld le ms kn lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">请回忆一下，在我们离题进入德尔塔法之前，我们说过</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/06be1cf906be2b3d4f576752a695449c.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*O9iBXKRRsDzl8FaIAGNalw.png"/></div></figure><p id="9330" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们考虑使用 Delta 方法计算总和中每一项的方差。期望值是 1–h，所讨论的函数是导数为 1/x 的对数 log(x)(当然，我们只使用自然对数)。因此:</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/8a93545c0a64aaa6cce682c54322356c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1lDi6fBYhDvrDBHwFKukLw.png"/></div></div></figure><p id="e1c0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还可以计算每一项的方差。log(1-h)项没有方差(是常数)，第二项减去 h 也不影响方差。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi on"><img src="../Images/d3b962a0265b990c325ef875d3111f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*GrMHKU7jR0xxAC965U3kEA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">各项的方差</p></figure><p id="8959" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，一个简单的技术问题。通常，我们可以把方差加起来，来计算总和的方差。然而，从技术上讲，这两项并不独立，因为时间 I 的死亡会影响后面时间的分母 n。另一方面，感兴趣的项(d/n–h)具有均值 0，条件是知道所有以前的死亡，这使得这些项成为一个<a class="ae jg" href="https://en.wikipedia.org/wiki/Martingale_(probability_theory)" rel="noopener ugc nofollow" target="_blank">鞅</a>差(或者它们的和是一个鞅)。反过来，<a class="ae jg" href="https://en.wikipedia.org/wiki/Martingale_central_limit_theorem" rel="noopener ugc nofollow" target="_blank">鞅中心极限定理</a>告诉我们，方差实际上只是个体方差之和。</p><p id="a782" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们得到了 S 的对数的方差</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/d357f720189149d97633a4a7da072174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*Y20UOW8NCHJckqJRVSi1ww.png"/></div></figure><p id="7c9c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们可以再次应用德尔塔法</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi op"><img src="../Images/ac17f98b06e92e64b65f9191c59ee68d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*L43GDOrPGJsKIUg_569Svg.png"/></div></figure><p id="b118" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/219a7767b923843be827718251394e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*Z5HAZWB5Jbd5Z27yY56GLQ.png"/></div></figure><p id="d79d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以反过来估计为:</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/0b113bcd5d7507c171c6f2d5723fed46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*mWSVHjwRaV8cSj7n5L_vlA.png"/></div></figure><p id="5f2c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这又让我们通过假设 S 的估计量是正态分布(如果样本量足够大，就会是这种情况)来计算格林伍德置信区间。</p><p id="4862" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唷。</p><h2 id="2016" class="nu ma jj bd mb nv nw dn mf nx ny dp mj lh nz oa ml ll ob oc mn lp od oe mp of bi translated">指数格林伍德置信区间</h2><p id="a737" class="pw-post-body-paragraph ky kz jj la b lb mr kk ld le ms kn lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">现在，使用上面的格林伍德置信区间会导致一个问题，即您的置信区间可能会落在 0-1 边界之外。如果有一个图表，在这个图表上，你的置信区间允许有时候存活率是负的，这将是非常尴尬的。</p><p id="350e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的解决方案是注意我们使用了 log，因为它强制 S 为正。如果我们计算变换后的对数 S 的置信区间，我们至少可以保证得到的置信区间将大于 0(但也可以大于 1)。我们为此付出的“代价”是拥有一个不对称的置信区间。但是，如果我们要这样做，我们不妨一路走下去。如果我们用</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/fdf00356a444235d11be4ae90ef4dccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*bUSNH82VxylWVMQjv5ps-w.png"/></div></figure><p id="b2e1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么我们将得到保证位于 0–1 区间内的置信区间，因为 log(–log(X))只接受 0–1 范围内的参数；逆变换将确保我们在该范围内结束。</p><p id="d731" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不会给你数学；经过<em class="nk">变换的</em> S 的最终方差为</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/254b36aaa61ab27e92b74070fd4cc6a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DE5A2mYChxdrHAY9ZHLf1g.png"/></div></div></figure><p id="ffcf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">计算变换后的 s 的置信区间，然后用 x ⟼指数(-exp(x))撤消变换，以获得 s 的非对称置信区间</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="7f9d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的目标是写(相对)易懂的数据科学概念的解释，而不回避有时涉及的复杂数学。如果你喜欢这个，你我还有类似风格的解释<a class="ae jg" rel="noopener" target="_blank" href="/understanding-logistic-regression-coefficients-7a719ebebd35"><em class="nk"/></a><em class="nk"/><a class="ae jg" rel="noopener" target="_blank" href="/the-relationship-between-perplexity-and-entropy-in-nlp-f81888775ccc"><em class="nk">困惑</em></a><em class="nk"/><a class="ae jg" rel="noopener" target="_blank" href="/why-is-the-normal-distribution-so-normal-e644b0a50587"><em class="nk">中心极限定理</em> </a> <em class="nk">，或者</em> <a class="ae jg" rel="noopener" target="_blank" href="/expectation-maximization-explained-c82f5ed438e5"> <em class="nk">期望最大化</em> </a> <em class="nk">。</em></p><p id="d873" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nk">如果你不喜欢这个，多考虑一下</em> <a class="ae jg" href="https://medium.com/@rmcharan/regression-geometry-61fdd5515ab7" rel="noopener"> <em class="nk">回归</em> </a> <em class="nk">，奇异值分解</em><a class="ae jg" rel="noopener" target="_blank" href="/the-singular-value-decomposition-without-algebra-ae10147aab4c"><em class="nk"/></a><em class="nk">，或者</em> <a class="ae jg" rel="noopener" target="_blank" href="/build-intuition-for-the-fourier-transform-b0bd338c6d4f"> <em class="nk">傅立叶变换</em> </a> <em class="nk">。</em></p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><h1 id="6706" class="lz ma jj bd mb mc pa me mf mg pb mi mj kp pc kq ml ks pd kt mn kv pe kw mp mq bi translated">笔记</h1><p id="5a2c" class="pw-post-body-paragraph ky kz jj la b lb mr kk ld le ms kn lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">[1]很明显，如果 fʹ(c)为 0，事情会变得非常糟糕，所以这是一个很好的时机来说明这是一个额外的假设。查阅维基百科的文章，获得完全严格的处理方法。</p></div></div>    
</body>
</html>