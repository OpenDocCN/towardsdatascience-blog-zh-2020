<html>
<head>
<title>A Practical Guide on Missing Values with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫缺失价值观实用指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-practical-guide-on-missing-values-with-pandas-8fb3e0b46c24?source=collection_archive---------32-----------------------#2020-06-13">https://towardsdatascience.com/a-practical-guide-on-missing-values-with-pandas-8fb3e0b46c24?source=collection_archive---------32-----------------------#2020-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c37a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理缺失值的综合指南。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/268343fd4f20e0cf654d5b53766c6bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrkZTQ2FTXmS4hynR2Snrw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由 Zach Lucero 在 Unsplash 上拍摄</p></figure><p id="0381" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">缺失值表示我们没有关于特定观察(行)的特征(列)的信息。为什么不直接从数据集中删除那个观察值，然后继续呢？我们可以，但不应该。原因是:</p><ul class=""><li id="c295" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">我们通常有许多观察特征，所以我们不想仅仅因为一个缺失的特征而失去观察。数据是有价值的。</li><li id="f0dc" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">我们通常会有多个观测值缺失。在某些情况下，我们不能从数据集中删除许多观察值。还是那句话，数据是有价值的。</li></ul><p id="5c86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本帖中，我们将介绍如何检测和处理丢失的值，以及一些需要记住的要点。</p><p id="d25d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">帖子的概要:</p><ul class=""><li id="615e" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">缺少值标记</li><li id="8bba" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">检测缺失值</li><li id="3f38" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">缺少值的计算</li><li id="5db0" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">处理缺失值</li></ul><p id="f9e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一如既往，我们从进口熊猫开始。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="a201" class="mn mo it mj b gy mp mq l mr ms">import numpy as np<br/>import pandas as pd</span></pre><h1 id="ff61" class="mt mo it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated"><strong class="ak">缺少值标记</strong></h1><p id="90f6" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">Pandas 中默认的缺失值表示是<strong class="la iu"> NaN </strong>，但是 Python 的<strong class="la iu"> None </strong>也被检测为缺失值。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="c6c6" class="mn mo it mj b gy mp mq l mr ms">s = pd.Series([1, 3, 4, np.nan, None, 8])<br/>s</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/b3402f4932858f85261bff312cbd2d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*Jwe8W6iDqA4RysmAljBtGA.png"/></div></figure><p id="03c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然我们用整数创建了一个序列，但是值被向上转换为 float，因为 np.nan 是 float。熊猫 1.0 引入了缺失值的新表示法，即<strong class="la iu"> &lt; NA &gt; </strong>。它可以与整数一起使用，而不会导致向上转换。我们需要显式地请求 dtype 为 pd。Int64Dtype()。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="47ce" class="mn mo it mj b gy mp mq l mr ms">s = pd.Series([1, 3, 4, np.nan, None, 8], dtype=pd.Int64Dtype())<br/>s</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/744c2edee115ac2ce7922df7591b4ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*4Hert6qN8yUNYAwTN5SDPg.png"/></div></figure><p id="5499" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">整数值不会被强制转换为浮点型。</p><p id="0b96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个缺失的值表示是用于表示 datetime64[ns]数据类型的<strong class="la iu"> NaT </strong>。</p><blockquote class="nr ns nt"><p id="50ec" class="ky kz nu la b lb lc ju ld le lf jx lg nv li lj lk nw lm ln lo nx lq lr ls lt im bi translated"><strong class="la iu">注</strong>:名词性的不相等，而没有一个是相等的。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/d5a9dfbae64c22c34a8c4d2e8fb9cd69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*erg85B9OXFO9VDv8nkkIng.png"/></div></figure><blockquote class="nr ns nt"><p id="0083" class="ky kz nu la b lb lc ju ld le lf jx lg nv li lj lk nw lm ln lo nx lq lr ls lt im bi translated"><strong class="la iu">注意</strong>:并非所有丢失的值都是简洁明了的 np.nan 或 None 格式。例如，我们处理的数据集可能包含“？”和“- -”值。当将数据集读入熊猫数据帧时，我们可以将它们转换成 np.nan 表示。我们只需要将这些值传递给<code class="fe nz oa ob mj b">na_values</code>参数。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/c310c59d3f4bcf4031034aecbe2ecd02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/0*KS-Cec_KTDqlb3C2.png"/></div></div></figure></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="2f3d" class="mt mo it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated"><strong class="ak">检测缺失值</strong></h1><p id="6d4b" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">让我们首先创建一个示例数据框架，并向其中添加一些缺失的值。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="12f2" class="mn mo it mj b gy mp mq l mr ms">df = pd.DataFrame({<br/>'col_a':np.random.randint(10, size=8),<br/>'col_b':np.random.random(8),<br/>'col_c':[True, False, True, False, False, True, True, False],<br/>'col_d':pd.date_range('2020-01-01', periods=8),<br/>'col_e':['A','A','A','B','B','B','C','C']<br/>})</span><span id="ed0a" class="mn mo it mj b gy op mq l mr ms">df.iloc[2:4, 1:2] = np.nan<br/>df.iloc[3:5, 3] = np.nan<br/>df.iloc[[1,4,6], 0] = np.nan<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/a4be135ea45eb369d409f6ead879ee0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*3x0lrvYaXqa62M-JDX75Yw.png"/></div></figure><p id="cd09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们前面提到的，NaT 用于表示 datetime 缺失值。</p><p id="1df6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nz oa ob mj b">isna()</code>返回用布尔值表示缺失值的数据帧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/dcaaa99ef4b716252ec84afb30d92dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*m3F_Zp2jow7EfGXv87t_pw.png"/></div></figure><p id="ef62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nz oa ob mj b">isna().sum()</code>返回每列中缺失值的数量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/679b92024980a94c46e623d400b64c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*PExwm3vSnJj4WohnH0ST5g.png"/></div></figure><p id="00fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nz oa ob mj b">notna </code>与<code class="fe nz oa ob mj b">isna </code>相反，因此<code class="fe nz oa ob mj b">notna().sum()</code>返回非缺失值的个数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/86fa37b2df56731a3d71d595b0052b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*K1AXOIMaYfJ-VtEZg6RG6w.png"/></div></figure><p id="dbce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nz oa ob mj b">isna().any()</code>返回每列的布尔值。如果该列中至少有一个值缺失，则结果为真。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/b578cc584b50e555487f43688263d89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*V2NxBaLnI-sf6J4lqUGFYg.png"/></div></figure></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="ec5d" class="mt mo it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated"><strong class="ak">有缺失值的计算</strong></h1><p id="6a75" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">np.nan 和数字之间的算术运算返回 np.nan。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/5c46ffef5bbdd4443d2ab2064408fdd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*WJgd829Uf-3nABYQVV0C0A.png"/></div></figure><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="80d6" class="mn mo it mj b gy mp mq l mr ms">df['sum_a_b'] = df['col_a'] + df['col_b']<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/c1445d9a75e294f173fc15b9b9d7aca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*gvcdd3JQoJgIs_L-i8wHAQ.png"/></div></figure><p id="70ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像<code class="fe nz oa ob mj b">cumsum </code>和<code class="fe nz oa ob mj b">cumprod </code>这样的累积方法默认情况下会忽略缺失值，但是它们会保留缺失值的位置。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="91f2" class="mn mo it mj b gy mp mq l mr ms">df[['col_a','col_b']].cumsum()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/f9c74f25732276da4c1451dd393e27d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*BUvuY2jmV1H5IbJRkVyoHw.png"/></div></figure><p id="25c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过设置<code class="fe nz oa ob mj b">skipna </code>参数为假来改变这种行为。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="a31a" class="mn mo it mj b gy mp mq l mr ms">df[['col_a','col_b']].cumsum(skipna=False)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/9473a37eed741c939ae15c7d32e6adb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*-bwQsvYotcRQH-f1VTKPFQ.png"/></div></figure><p id="e2dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">缺失值现在包括在求和中。因此，第一个 nan 之后的所有值也是 nan。</p><p id="c20c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nz oa ob mj b">Groupby </code>函数默认排除缺失值。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="1e80" class="mn mo it mj b gy mp mq l mr ms">df[['col_e','col_a']].groupby('col_e').sum()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/09a64fddda4d3a0181615ef3c945791e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*sTG2g8vkOVHLeCj6akFwvw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/7e7168e7b331204035476aec443d5397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*dzomndaPXGhMAJbZCCAkdg.png"/></div></figure></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="9c78" class="mt mo it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated"><strong class="ak">处理缺失值</strong></h1><p id="15d0" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">主要有两种方法来处理缺失值。我们可以丢弃丢失的值，或者用合适的值替换它们。更好的选择是替换丢失的值，但是在某些情况下，我们可能需要删除它们。</p><p id="2177" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">删除缺失值</strong></p><p id="2661" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用<code class="fe nz oa ob mj b">dropna()</code>函数删除缺少值的行或列。<code class="fe nz oa ob mj b">how </code>参数用于设置下降条件。</p><ul class=""><li id="754a" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">how='any ':如果有任何缺少的值，则删除</li><li id="6c0c" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">how='all ':如果所有值都丢失，则删除</li></ul><p id="436a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们首先稍微修改一下我们的数据框架:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="5d49" class="mn mo it mj b gy mp mq l mr ms">df.iloc[7,:] = np.nan<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/31a13b91cd3af605298af164ea6794ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*dRRgHbYL78ZJUZ0ujR5miA.png"/></div></figure><p id="0ad3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nz oa ob mj b">how=’any’</code>将删除除第一行和第六行之外的所有行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/bd93d55fb2bc3e73d7d81627a4855e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*anZ-QusY4E2_qBbnBc2SQA.png"/></div></figure><p id="45e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nz oa ob mj b">how=’all’</code>只会删除最后一行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/42678c67daff1aee20954ca4d507e6bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*68NDwfOY60Qw3ZyIaIgM_g.png"/></div></figure><blockquote class="nr ns nt"><p id="9d93" class="ky kz nu la b lb lc ju ld le lf jx lg nv li lj lk nw lm ln lo nx lq lr ls lt im bi translated"><strong class="la iu">注意</strong>:为了将这些更改保存在原始数据帧中，我们需要将<code class="fe nz oa ob mj b">inplace </code>参数设置为真。</p></blockquote><p id="5c18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe nz oa ob mj b">thresh </code>参数，我们可以设置缺失值的阈值，以便删除某行/列。如果<code class="fe nz oa ob mj b">axis </code>参数设置为 1，Dropna 也进行列操作。</p><p id="6d5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">替换缺失值</strong></p><p id="c3ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nz oa ob mj b">fillna()</code>熊猫功能方便处理缺失值。使用<code class="fe nz oa ob mj b">fillna()</code>，缺失值可由特殊值或聚合值替代，如平均值、中值。此外，缺失的值可以用它之前或之后的值替换，这对时间序列数据集非常有用。</p><p id="8a86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以选择一个值来替换数据帧中所有缺失的值，但这没有任何意义。相反，我们可以创建一个字典，指示在不同的列中使用不同的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/55bd948b9dafdbcb153e83e09b24a9fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*S1kWiC6yUvfNfLgZ4Wr-RQ.png"/></div></figure><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="1df7" class="mn mo it mj b gy mp mq l mr ms">replacements = {'col_a':0, 'col_b':0.5, 'col_e':'Other'}<br/>df.fillna(replacements)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/35ba36b3814bcf843a492bd6d73d22ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*eunOKjAA7l5LtVu0HINRHw.png"/></div></figure><p id="3e2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用聚合函数作为值来替换缺失的值:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="e946" class="mn mo it mj b gy mp mq l mr ms">df['col_b'].fillna(df['col_b'].mean())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/cf929ee81720bea763e0a2dc38eb7222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*abZ86VVfDmI69TR_kZ_wig.png"/></div></figure><p id="9ad6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也可以使用<code class="fe nz oa ob mj b">method </code>参数用它们之前或之后的值来填充缺失的值。<strong class="la iu"> ffill </strong>代表“向前填充”，用前一行的值替换缺失的值。顾名思义，<strong class="la iu"> bfill </strong>(反向填充)做的正好相反。如果一列或一行中有许多连续的缺失值，我们可以使用<strong class="la iu"> limit </strong>参数来限制向前或向后填充的缺失值的数量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/8d599c803fb2fd010b894c9025a6461f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Lv5jl7wBNAI4gYxgB4SjLw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/86dfff6cfe18e4db4ebb6fe8e301377c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*07A14IrhAxBgd7ezjjQE6Q.png"/></div></figure><p id="387e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有缺少的值都用前一个单元格中的值填充。让我们将需要填充的缺失值的数量限制为 1:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/05c454dd634d2d02f6ba8c0ca993f82c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*fTi-BxpeSi0zWRuqEQlYZA.png"/></div></figure><p id="15b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们尝试使用 bfill 方法来填充缺失的值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/c733b4b233fa9419dd5c906c7707ad59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*6Wohz_vSUsX1UQLHVigv1Q.png"/></div></figure><p id="96ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">末尾的值仍然是缺失的，因为它们后面没有值。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="bd2c" class="mt mo it bd mu mv ok mx my mz ol nb nc jz om ka ne kc on kd ng kf oo kg ni nj bi translated"><strong class="ak">加成:插值</strong></h1><p id="7f70" class="pw-post-body-paragraph ky kz it la b lb nk ju ld le nl jx lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated"><code class="fe nz oa ob mj b">interpolate </code>通过插值填充缺失值，这对于序列或时间序列数据特别有用。默认方法是线性的，但可以使用方法参数进行更改。一些可用的选项是多项式，二次，三次。我们来做一个线性插值的例子。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="69c6" class="mn mo it mj b gy mp mq l mr ms">s = pd.Series(np.random.random(50))<br/>s[4, 5, 9, 11, 18, 19, 33, 34, 46, 47, 48] = np.nan<br/>s.plot()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/58229ad83c76d1a24765b9f4c4706851.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*_9Y8q4AtUJjn42RvAzz3Kg.png"/></div></figure><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="a1ed" class="mn mo it mj b gy mp mq l mr ms">ts.interpolate().plot()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/c3f5bc0ffd127cd45a9971ea5ece6352.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*cIeM6CHgS41dVmo4zGGRmA.png"/></div></figure></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="c2e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>