<html>
<head>
<title>Launch your own REST API using Flask &amp; Python in 7 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flask &amp; Python在7分钟内启动您自己的REST API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/launch-your-own-rest-api-using-flask-python-in-7-minutes-c4373eb34239?source=collection_archive---------19-----------------------#2020-06-15">https://towardsdatascience.com/launch-your-own-rest-api-using-flask-python-in-7-minutes-c4373eb34239?source=collection_archive---------19-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="af04" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">下面的文章介绍了使用Python、Flask和Sqlite3开发REST API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e626599d846b66d83812746ec8435e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZU1EQ7tYeQNQlhOhyonHFA.png"/></div></div></figure><h2 id="47a2" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">1.简介:</h2><p id="11bb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">应用程序编程接口(API)被定义为处理两个或更多中介(通常是用户和数据库之间)之间的交互的接口。更常见的是，大多数被访问的网站、被玩的视频游戏、甚至是被流式传输的视频都涉及到被利用的某种级别的API。作为数据科学家，我们经常使用API来检索信息，如股票价格、文章或其他类型的信息。数据科学家通常会发出HTTP请求，这通常会导致数据以JSON文件的格式返回。</p><p id="c257" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">表述性状态转移(REST)类型的API是一种架构风格，它使用HTTP请求来获取、上传、发布和删除数据(图1)。作为用户，当使用诸如<a class="ae mo" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>之类的软件或者诸如<em class="mp"> Requests </em>之类的普通Python库来发出HTTP请求时，我们经常会体验到API的客户端。然而，对于大多数Python开发者来说，API函数的底层框架仍然是一个“黑箱”。本文的目的是通过使用Flask框架从头开发一个API来探索这一领域。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/7789c45d521e4177a580112093548bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80h3nuv996e_bUASyFAohw.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">图1:REST API的主框架，其中API的客户端允许使用GET、POST、DELETE和PUT方法添加和删除数据。</p></figure><h2 id="d081" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">2.REST API的基础:</h2><p id="6ae6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">REST API背后的主要结构由三个关键项目组成:(url和端点，(2)方法，以及(3)数据。当客户机针对API发出HTTP请求以检索数据时，必须设计的第一项是URL。URL通常包含站点域、一系列目录层次结构，最后是端点，通常遵循图2所示的结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/971197ab2f01dae87ab8332142688777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4d8jTabnV-nTAZJkR4msCQ.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">图HTTP请求URL的一般结构。</p></figure><p id="20c6" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">使用REST API发出请求时，通常使用四种主要方法:GET、POST、PUT和DELETE。虽然这些方法大多是不言自明的，但主要的好处是可以使用这些方法从任何给定的数据库中检索、添加或删除数据。GET请求是最常见的请求类型，主要用于从服务器或数据库中检索数据。POST请求用于向API发送数据，以便创建或更新条目。与POST类似，PUT请求用于向API发送数据，以便创建或更新条目，但是，PUT请求是等幂的，这意味着可以多次应用该方法，而不会改变最终结果。最后，删除请求用于删除数据库中的某些条目。下面的图3总结了REST API背后的主要方法，使用了一个关于每个请求的示例解释命令。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/cfc1b4c81645d294b0f25dbde04ad3ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wpbYhweLr38h8fUnuFT0Fg.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">图3:REST API背后的四个主要方法，以及一个以职位发布为例总结功能的示例语句。*请注意，PUT方法类似于POST方法，但是它们是等幂的，多次调用相同的请求将产生相同的结果。另一方面，POST请求是非等幂的，发出相同的请求可能会导致意外的结果。</p></figure><p id="bdd4" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">最后，构成API的最后一项是要查询的实际数据，可以是从小的CSV文件到大的关系数据库。出于本文的目的，我通过转换一个示例CSV文件，使用Python的sqlite3库创建了一个数据库。</p><h2 id="e6be" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">3.准备数据库:</h2><p id="b327" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">出于本文的目的，我们将使用一个关于CS和数据科学职位的职位发布数据集来创建一个API。现在让我们继续使用<em class="mp"> sqlite3 </em>库创建一个数据库。出于本文的目的，为了简单起见，我们将坚持使用s <em class="mp"> qlite3 </em>库，然而，生产级数据库应该利用<a class="ae mo" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>或<a class="ae mo" href="https://azure.microsoft.com/en-us/services/postgresql/?&amp;ef_id=Cj0KCQjwuJz3BRDTARIsAMg-HxVl-J3edqbx_16MBsgl2jTI16XT6jhux1RTnqPpZl_3zzombPkkr6waAlJEEALw_wcB:G:s&amp;OCID=AID2000128_SEM_Cj0KCQjwuJz3BRDTARIsAMg-HxVl-J3edqbx_16MBsgl2jTI16XT6jhux1RTnqPpZl_3zzombPkkr6waAlJEEALw_wcB:G:s&amp;gclid=Cj0KCQjwuJz3BRDTARIsAMg-HxVl-J3edqbx_16MBsgl2jTI16XT6jhux1RTnqPpZl_3zzombPkkr6waAlJEEALw_wcB" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>来获得最大效率，这两者在AWS等云服务器上都很容易获得。我们从<em class="mp"> sqlite3 </em>开始，创建一个允许我们创建新的<em class="mp"> sqlite3 </em>连接的函数。这里的主要目标是准备一个函数，通过创建一个连接来创建一个新的数据库文件。</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="7313" class="ku kv it my b gy nc nd l ne nf">def createSqliteConnection(database):<br/>    """ <br/>    Function that creates a connection to a sqlite3 database file.</span><span id="308d" class="ku kv it my b gy ng nd l ne nf"><a class="ae mo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> database -- The path and name of the database file to connect to.<br/>    """<br/>    conn = None<br/>    try:<br/>        print("----------Attempting to connect to database using Sqlite3 version {version} ...".format(version = sqlite3.version))<br/>        conn = sqlite3.connect(database)<br/>        print("----------Successfully to connected to {database}".format(database = database))</span><span id="9d3b" class="ku kv it my b gy ng nd l ne nf">except Error as e:<br/>        print(e)<br/>    finally:<br/>        if conn:<br/>            conn.close()</span></pre><p id="c27c" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">创建数据库后，现在可以直接从CSV导入数据。</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="7d39" class="ku kv it my b gy nc nd l ne nf">def pandasToDatabase(csvDocument, database, tableName):<br/>    conn = sqlite3.connect(database) <br/>    df = pd.read_csv(csvDocument)<br/>    df.to_sql(tableName, conn, if_exists = "append", index = False)</span></pre><p id="005e" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">两个函数都完成后，我们现在可以继续执行这些函数:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="71bd" class="ku kv it my b gy nc nd l ne nf">if __name__ == '__main__':<br/>    createSqliteConnection("data/datasciencejobs_database.db")<br/>    pandasToDatabase("data/datasciencejobs_database.csv", "data/datasciencejobs_database.db", "tblJobs", )</span></pre><p id="02a8" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">这将导致创建一个名为:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="23a5" class="ku kv it my b gy nc nd l ne nf">data/datasciencejobs_database.db</span></pre><p id="4278" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">现在创建了主数据库文件，我们现在能够使用API直接从数据库中查询数据，从而避免了CSV的使用。这允许更快和更干净的连接。</p><h2 id="b222" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">4.创建Flask应用程序:</h2><p id="1f1f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">针对API的Flask应用程序的后端开发不同于大多数用户熟悉的标准的基于GUI的web应用程序。从高层次的角度来看，主要的区别可以总结在图4中。两者之间的主要区别在于，由于必须考虑图形用户界面，标准web应用程序的重点转向了HTML和布局功能。另一方面，API的主要关注点是信息的路由和流动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/457f80fd9a1f66b5bc8979a30850de42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cr0sank4I1iPGFJiPdRfNQ.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">图flask应用程序用于API时相对于标准web应用程序的一般高层次比较。</p></figure><p id="66a2" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">我们通过在<em class="mp"> app.py </em>文件中定义我们的“app”并创建一个Flask应用程序来开始这个过程。</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="442e" class="ku kv it my b gy nc nd l ne nf">app = flask.Flask(__name__)<br/>app.config["DEBUG"] = True</span></pre><p id="fd2f" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">然后，我们必须创建几个函数，当在URL中采用某些路线时，这些函数会显示数据。让我们从一个简单的'<em class="mp"> view all' </em>函数开始，它显示数据库中的所有条目。请注意，我们使用的是上面指定的GET方法。</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="b877" class="ku kv it my b gy nc nd l ne nf">@app.route('/api/v1/jobs/datascience/all', methods=['GET'])</span><span id="2618" class="ku kv it my b gy ng nd l ne nf">def apiViewAll():<br/>    conn = sqlite3.connect('data/datasciencejobs_database.db')<br/>    conn.row_factory = dictFactory<br/>    cur = conn.cursor()<br/>    all_books = cur.execute('SELECT * FROM tblJobs;').fetchall()<br/>    return jsonify(all_books)</span></pre><p id="1fe9" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">启用此功能后，最终用户现在能够查询我们数据库中的所有数据。目前，这还不是问题，因为数据库包含的条目不超过1000个，但是，随着数据库的增长，最终用户需要等待很长时间才能访问整个数据库，这将成为更大的问题。也就是说，任何REST API的高效设计的一部分是基于预定的文件服务器查询数据的能力，以便查询数据库的某些部分。假设数据库由列'<em class="mp"> id </em>'、<em class="mp"> datetime </em>'、<em class="mp"> country </em>'和' content '组成，一个“最佳设计”的API将允许用户使用前三个参数来查询数据。必须开发一个函数，允许通过指定'<em class="mp"> id </em>'、<em class="mp">日期时间</em>'或'<em class="mp">国家</em>'来使用多个端点过滤数据。请注意，如果没有指定任何条目，将发出错误404页面未找到。</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="75d3" class="ku kv it my b gy nc nd l ne nf">@app.route('/api/v1/jobs/datascience', methods=['GET'])</span><span id="8ff4" class="ku kv it my b gy ng nd l ne nf">def apiViewByFilter():<br/>    '''<br/>    Function that allows users to filter the results in the API     based on specified input.<br/>    '''<br/>    query_parameters = request.args<br/>    id = query_parameters.get('id')<br/>    dateTime = query_parameters.get('dateTime')<br/>    cleanContent = query_parameters.get('cleanContent')<br/>    country = query_parameters.get('country')<br/>    query = "SELECT * FROM tblJobs WHERE"</span><span id="6411" class="ku kv it my b gy ng nd l ne nf">    to_filter = []<br/>    if id:<br/>        query += ' id=? AND'<br/>        to_filter.append(id)</span><span id="ecc8" class="ku kv it my b gy ng nd l ne nf">    if dateTime:<br/>        query += ' dateTime=? AND'<br/>        to_filter.append(dateTime)</span><span id="9030" class="ku kv it my b gy ng nd l ne nf">    if cleanContent:<br/>        query += ' cleanContent=? AND'<br/>        to_filter.append(cleanContent)</span><span id="4294" class="ku kv it my b gy ng nd l ne nf">    if country:<br/>        query += ' country=? AND'<br/>        to_filter.append(country)</span><span id="7884" class="ku kv it my b gy ng nd l ne nf">    if not (id or dateTime or cleanContent or country):<br/>       return pageNotFound(404)</span><span id="fd2e" class="ku kv it my b gy ng nd l ne nf">    query = query[:-4] + ';'<br/>    conn = sqlite3.connect('data/datasciencejobs_database.db')<br/>    conn.row_factory = dictFactory<br/>    cur = conn.cursor()</span><span id="7f68" class="ku kv it my b gy ng nd l ne nf">    results = cur.execute(query, to_filter).fetchall()</span><span id="18e9" class="ku kv it my b gy ng nd l ne nf">    return jsonify(results)</span></pre><p id="19fe" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">最后，现在完成了API的所有部分，可以使用Flask的运行功能运行应用程序。</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="1e11" class="ku kv it my b gy nc nd l ne nf">app.run()</span></pre><p id="d3bc" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">API中指定的三个主要端点允许用户查询所有数据，或者基于“id”、“国家”和“日期时间”。</p><p id="efbc" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">例如，用户可以使用以下方式查询所有数据:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="cb8b" class="ku kv it my b gy nc nd l ne nf">‘127.0.0.1:5000/api/v1/jobs/datascience/all’</span></pre><p id="e1c4" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">用户还可以使用其中一个端点来查询数据:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="87a9" class="ku kv it my b gy nc nd l ne nf">‘127.0.0.1:5000/api/v1/jobs/datascience?country=United%20States’<br/>‘127.0.0.1:5000/api/v1/jobs/datascience?id=81953194’</span></pre><h2 id="c5bf" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">5.部署Flask应用程序:</h2><p id="c33a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">API完成并按预期运行后，下一个逻辑步骤是将应用程序部署到服务器。出于本教程的目的，API是使用本地端口在本地“部署”的。部署基于Flask的应用程序的一些最佳选项包括:<em class="mp"> AWS </em>、<em class="mp"> Heroku </em>和<em class="mp"> PythonAnywhere </em>。在探索了这三个版本之后，我个人发现<a class="ae mo" href="http://www.pythonanywhere.com" rel="noopener ugc nofollow" target="_blank">www.pythonanywhere.com</a>是这三个版本中最用户友好和最便宜的，拥有关于部署过程的<a class="ae mo" href="https://help.pythonanywhere.com/pages/Flask/" rel="noopener ugc nofollow" target="_blank">全面的文档</a>。</p><h2 id="f371" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论:</h2><p id="6d9b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">总之，为了理解管理这个功能的主要框架，我们对REST APIs进行了概述。为了存储我们感兴趣的数据，创建了一个SQL数据库。最后，使用Flask使用REST APIs的最佳实践开发了一个API，允许用户通过多个端点查询数据。</p><p id="cff6" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">欲了解更多信息和访问代码，请访问my <a class="ae mo" href="https://github.com/alkhalifas/flask-web-api" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p></div></div>    
</body>
</html>