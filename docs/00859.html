<html>
<head>
<title>Super-charged similarity metric calculations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超负荷相似性度量计算</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/super-charged-similarity-metric-calculations-969116abd948?source=collection_archive---------17-----------------------#2020-01-24">https://towardsdatascience.com/super-charged-similarity-metric-calculations-969116abd948?source=collection_archive---------17-----------------------#2020-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ed7b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">采用NumPy和TensorFlow</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6135981c0f9b9ed43b6515f2c8642f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_xAyQgNZSibMAJbj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔·内里克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="cd8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相似性检测是一种常用的方法，用于识别具有共同特征但不一定具有相同特征的项目。产品推荐和相关文章通常由相似性度量驱动。余弦相似性是最受欢迎的，将在这里讨论。本文将使用NumPy和TensorFlow评估Python中余弦相似性的性能。</p><h2 id="9931" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">NumPy和张量流</h2><p id="a31a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">NumPy是一个健壮而成熟的库，用于处理大型多维矩阵。NumPy拥有丰富的线性代数函数集合。调得很好，在CPU上运行速度非常快。</p><p id="b367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TensorFlow是一个数学和机器学习库，可以利用CPU和GPU。TensorFlow已经在生产中得到很好的证明，并用于支持高级机器学习算法。它还拥有丰富的线性代数函数集合。你用NumPy能做的大部分事情，在TensorFlow里也能做。</p><p id="1011" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者都是很棒的库，都可以计算数据集之间的相似性度量。</p><h2 id="0f6a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">计算余弦相似度</strong></h2><p id="c214" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果NumPy和TensorFlow尚未安装，可以通过pip安装。本文使用的是NumPy 1.17.4和TensorFlow 2.1</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="fa84" class="lv lw it mu b gy my mz l na nb">pip install numpy<br/>pip install tensorflow</span></pre><p id="a616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例代码显示了如何在NumPy和TensorFlow中计算余弦相似性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">NumPy和张量流余弦相似性</p></figure><p id="f41a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码将产生类似下面的输出。还会有很多TensorFlow消息，重要的是你要看到顶行是粗体的，以确保GPU正在被使用。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="d8e8" class="lv lw it mu b gy my mz l na nb"><strong class="mu iu">I tensorflow/core/common_runtime/gpu/gpu_device.cc:1555] Found device 0 with properties:</strong></span><span id="2094" class="lv lw it mu b gy ne mz l na nb">x: <br/> [[0.16522373 0.55317429 0.61327354 0.74017118 0.54443702]<br/> [0.46154321 0.17925365 0.3785271  0.71921798 0.91126758]<br/> [0.10342192 0.96612358 0.06434406 0.85482426 0.7329657 ]<br/> [0.1333734  0.99817565 0.42731489 0.46437847 0.40758545]<br/> [0.43727089 0.91457894 0.21971166 0.24664127 0.61568784]]<br/>y: <br/> [[0.15979143 0.47441621 0.20148356 0.99541121 0.41767036]]</span><span id="7e10" class="lv lw it mu b gy ne mz l na nb">np: <br/> [[0.91509268]<br/> [0.83738509]<br/> [0.91553484]<br/> [0.80027872]<br/> [0.7071257 ]]<br/>tf: <br/> [[0.91509268]<br/> [0.83738509]<br/> [0.91553484]<br/> [0.80027872]<br/> [0.7071257 ]]</span></pre><p id="a05c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最上面的两个数组显示了x的5x5数组和y的1x5数组。它还显示了y相对于x中每一行的余弦相似性，这是用NumPy和TensorFlow计算的。</p><p id="0d0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着用更多的数据来计算时间。</p><h2 id="e6ea" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">小型阵列的性能</h2><p id="2d1d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于第一个测试，我们将尝试两个小数组，计算x的1000x25数组和y的50x25数组之间的余弦相似性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">小型数据阵列的时序</p></figure><p id="2117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码将产生以下输出:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="636b" class="lv lw it mu b gy my mz l na nb">np time = 0.2509448528289795<br/>tf time = 0.7871346473693848<br/>similarity output equal: True</span></pre><p id="c826" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，NumPy比TensorFlow快，即使TensorFlow启用了GPU。与所有软件开发一样，没有一种尺寸可以满足所有问题的答案。NumPy仍然有一席之地，它在处理小数据时会表现得更好。</p><p id="b675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将数据从CPU复制到GPU会产生开销，构建要执行的GPU图形也会产生开销。随着数据的增长，开销与总体运行时间相比可以忽略不计，让我们尝试更大的数据阵列。</p><h2 id="2a3a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">大型阵列的性能</h2><p id="f596" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们将运行与上面几乎完全相同的代码，除了我们将增加数组的大小。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="b539" class="lv lw it mu b gy my mz l na nb">x = np.random.rand(10000, 25)<br/>y = np.random.rand(50, 25)</span></pre><p id="b427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个测试，我们将对x使用10000x25数组，对y使用50x25数组。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2f07" class="lv lw it mu b gy my mz l na nb">np time = 3.3217058181762695<br/>tf time = 1.129739761352539<br/>similarity output equal: True</span></pre><p id="676d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TensorFlow现在比NumPy快3倍。将数据复制到GPU并编译GPU图形的开销现在值得在性能上进行权衡。</p><p id="59e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试一个更大的数组。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="85b4" class="lv lw it mu b gy my mz l na nb">x = np.random.rand(25000, 100)<br/>y = np.random.rand(50, 100)</span></pre><p id="5d07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个测试，我们将对x使用25000x25的数组，对y使用50x100的数组。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="dd14" class="lv lw it mu b gy my mz l na nb">np time = 23.823707103729248<br/>tf time = 2.93641996383667<br/>similarity output equal: True</span></pre><p id="1ccb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，TensorFlow快了8倍。只要数据集能够适合GPU，性能增益将继续快速增长。</p><h2 id="e12a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">选择前N个索引</h2><p id="65f3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">计算余弦相似度将得到一个从0到1的浮点数组，1表示最相似，0表示最不相似。对于大多数用例，您需要计算相似性以及最佳关联记录。在NumPy和TensorFlow中都可以这样做，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">余弦相似度和最佳匹配选择</p></figure><p id="7a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码获得了一个按照最高余弦相似度排序的索引列表。选择并打印最上面的记录。</p><h2 id="1398" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="9acb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">NumPy和TensorFlow都有自己的位置。GPU不只是在所有情况下都让一切变得更快。对较小的数据集使用NumPy，对较大的数据集使用TensorFlow。始终根据您自己的数据进行测试，看看在您的特定情况下什么最有效。</p></div></div>    
</body>
</html>