<html>
<head>
<title>Restricted Boltzmann Machine Creation as Recommendation System for Movie Review (part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为电影评论推荐系统的受限玻尔兹曼机器创造(上)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/restricted-boltzmann-machine-how-to-create-a-recommendation-system-for-movie-review-45599a406deb?source=collection_archive---------18-----------------------#2020-04-14">https://towardsdatascience.com/restricted-boltzmann-machine-how-to-create-a-recommendation-system-for-movie-review-45599a406deb?source=collection_archive---------18-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9a33" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于受限波尔兹曼机器的直观介绍以及使用电影分级数据进行模型训练的详细数据处理步骤</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/5b9e5dfeb6777fe2e2f4f9d77faefdd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*37ERRgeQXhkvE9_y1YL2Mw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">通过<a class="ae ku" href="https://unsplash.com/photos/CiUR8zISX60" rel="noopener ugc nofollow" target="_blank">链接</a>改编自 unsplash 的 Img</p></figure><p id="1b39" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是如何建立一个受限波尔兹曼机器(RBM)作为推荐系统的第一部分。这里重点是<strong class="kx iu">数据处理</strong>。</p><blockquote class="lr ls lt"><p id="22bb" class="kv kw lu kx b ky kz ju la lb lc jx ld lv lf lg lh lw lj lk ll lx ln lo lp lq im bi translated">您将学习如何将原始电影分级数据转换为准备训练 RBM 模型的数据。它分为三个部分。</p></blockquote><ol class=""><li id="d0cc" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated">RBM 简介</li><li id="5631" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">问题陈述</li><li id="68a4" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">数据处理</li></ol><p id="8df4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在让我们开始旅程🏃‍♂️🏃‍♀️.</p><ol class=""><li id="1cc5" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated"><strong class="kx iu"> RBM 简介</strong></li></ol><p id="1fd5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，让我们从玻尔兹曼机(BM)说起。BM 是一种无监督的神经网络。如图 1 所示，BM 有三个明显的特征。</p><ul class=""><li id="2cfe" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq mm me mf mg bi translated">没有输出图层</li><li id="07c9" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq mm me mf mg bi translated">连接之间没有方向</li><li id="00da" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq mm me mf mg bi translated">每个神经元彼此紧密相连，甚至在输入节点(可见节点)之间也是如此</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/902ab051083d72f8662fae9931745673.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*pLekhdJK_TSNA7vutWigSQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 1 玻尔兹曼机器图(作者创建的 Img)</p></figure><blockquote class="ms"><p id="3a92" class="mt mu it bd mv mw mx my mz na nb lq dk translated">为什么 BM 这么特别？从根本上说，BM 并不期待投入。相反，它自己生成模型的状态或值。因此，BM 是一个生成性模型，而不是确定性模型。BM 不区分可见节点和隐藏节点。可见节点只是我们度量值的地方。</p></blockquote><blockquote class="lr ls lt"><p id="b438" class="kv kw lu kx b ky nc ju la lb nd jx ld lv ne lg lh lw nf lk ll lx ng lo lp lq im bi translated">然而，BM 有一个问题。随着节点数量的增加，连接的数量呈指数增长，这使得不可能计算完整的 BM。因此，建议采用 RBM，如图 2 所示。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/de9c8f32c33c233a6290093f29893579.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*sNc7QGS8J1-YtulCrTNPOA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 2 受限玻尔兹曼机器图(作者创建的 Img)</p></figure><p id="f6c2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">与完全 BM 相比，RBM 不允许隐藏节点之间的连接和可见节点之间的连接。这是唯一的区别📣📣。</p><p id="01f4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过训练过程，我们向 RBM 输入大量数据，RBM 学会了如何分配每个隐藏节点来表示电影的特征，如流派、演员、导演等。换句话说，调整每个节点的权重，使得隐藏节点更好地反映特征。</p><p id="5229" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">具体来说，RBM 将接受从可见节点到隐藏节点的输入。它尝试基于隐藏节点值来重构输入值。如果重构值不正确，则调整权重，RBM 再次重构输入。最后，RBM 被训练成最能代表生成所有数据的系统。好处是所有权重都经过优化，RBM 可以了解系统的正常和异常情况。</p><p id="e9d6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">2.<strong class="kx iu">问题陈述</strong></p><p id="f349" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">给出大量的电影分级数据来建立 RBM。任务是预测一个用户喜欢一部电影是 1，不喜欢是 0。</p><p id="cf2d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">3.<strong class="kx iu">数据处理</strong></p><p id="b7b2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">数据<em class="lu"> MovieLens 100K 电影收视率</em>来自<em class="lu">群镜头研究</em>T4】这里。简单看一下图 3 中的数据，<strong class="kx iu"> Movies </strong>数据包含电影的名称和类型，<strong class="kx iu"> Ratings </strong>数据包含用户 ID、电影 ID、从 0 到 5 的用户评级和时间戳，<strong class="kx iu"> User </strong>数据包含用户 ID、性别、年龄、工作代码和邮政编码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/6e56beaf66fb0dca0154471e3b75870c.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*LPHmZk8glcWtLaCv4IC3eQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 3 源数据集片段</p></figure><p id="b33d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">3.1 导入数据</p><p id="2351" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">数据集包含 80，000 行训练集和 20，000 行测试集。让我们读一读。具体来说，</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="5558" class="no np it nk b gy nq nr l ns nt">training_set = pd.read_csv(‘ml-100k/u1.base’, delimiter = ‘\t’)<br/>training_set = np.array(training_set, dtype = ‘int’)</span><span id="00bc" class="no np it nk b gy nu nr l ns nt">test_set = pd.read_csv(‘ml-100k/u1.test’, delimiter = ‘\t’)<br/>test_set = np.array(test_set, dtype = ‘int’)</span></pre><p id="c9d6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">注意，我们将 Dataframe 转换为 Numpy 数组，因为我们将使用 Pytorch 张量，它需要数组作为输入。</strong>图 4 显示了训练/测试集，包括用户 ID、电影 ID、评级和时间戳(对于模型训练是不可逆的)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/f0fb657d015a91ab43ffcb0c0f67e148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*b40AwXK9K76ih2-Uiaq1tQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 4 训练和测试数据集片段</p></figure><p id="240d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">3.2 数据结构创建</p><blockquote class="ms"><p id="67ef" class="mt mu it bd mv mw nw nx ny nz oa lq dk translated"><strong class="ak">为了准备训练/测试数据，我们需要以数组格式创建训练/测试集，每行代表一个用户，行中的每个单元格代表每部电影的评级。</strong>这是 RBM 的预期输入。</p></blockquote><p id="9f7f" class="pw-post-body-paragraph kv kw it kx b ky nc ju la lb nd jx ld le ne lg lh li nf lk ll lm ng lo lp lq im bi translated">为此，我们需要将用户总数作为行号，将电影总数作为列号。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a79a" class="no np it nk b gy nq nr l ns nt">nb_users = int(max(max(training_set[:, 0]), max(test_set[:, 0])))<br/>nb_movies = int(max(max(training_set[:, 1]), max(test_set[:, 1])))</span></pre><p id="2428" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们创建了一个数据转换函数，它返回一个列表列表。每个子列表代表一个用户对所有电影的评级。如果用户没有对电影进行分级，则将分级初始化为 0。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="72ce" class="no np it nk b gy nq nr l ns nt">def convert(data):<br/>    new_data = []<br/>    for id_users in range(1, nb_users + 1):<br/>        id_movies = data[:,1][data[:,0] == id_users]<br/>        id_ratings = data[:,2][data[:,0] == id_users]<br/>        ratings = np.zeros(nb_movies)<br/>        ratings[id_movies — 1] = id_ratings<br/>        new_data.append(list(ratings))<br/>    return new_data</span></pre><p id="f606" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过上面的转换，我们转换了训练集和测试集。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0a25" class="no np it nk b gy nq nr l ns nt">training_set = convert(training_set)<br/>test_set = convert(test_set)</span></pre><p id="947d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">图 5 显示了最终的训练集。同样，每行包含用户对所有电影的评级。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/037662beb29acaa89f49fac7020c2e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*WjCNG3iY0x4L26W6UEsD6A.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 5 最终训练数据集的片段</p></figure><p id="6565" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，我们将 list 类型的<strong class="kx iu">列表转换为<strong class="kx iu">张量</strong>，因为我们将使用 Pytorch 构建 RBM。</strong></p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="2f80" class="no np it nk b gy nq nr l ns nt">training_set = torch.FloatTensor(training_set)<br/>test_set = torch.FloatTensor(test_set)</span></pre><p id="0a1d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">3.3 二进制数据转换</p><p id="9b1e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们的任务是预测用户是否喜欢电影为 1，不喜欢为 0。RBM 将采用用户的电影评级，并试图预测未被用户评级的电影。因为要预测的评级是根据原始输入计算的，所以我们必须以一致的方式保持输入评级和预测评级。</p><p id="4667" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">具体来说，先前设置为 0 的评级被重置为-1，给出 1 或 2 的电影被设置为 0(不喜欢)，评级超过 3 的电影被设置为 1(喜欢)。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="2842" class="no np it nk b gy nq nr l ns nt">training_set[training_set == 0] = -1<br/>training_set[training_set == 1] = 0<br/>training_set[training_set == 2] = 0<br/>training_set[training_set &gt;= 3] = 1</span><span id="bd68" class="no np it nk b gy nu nr l ns nt">test_set[test_set == 0] = -1<br/>test_set[test_set == 1] = 0<br/>test_set[test_set == 2] = 0<br/>test_set[test_set &gt;= 3] = 1</span></pre><p id="a6bc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">太好了。我们成功地将原始评级数据转换为二进制评级数据，准备好训练模型。</p><p id="4410" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">太好了！这就是第 1 部分的全部内容。接下来的</strong> <a class="ae ku" href="https://medium.com/@vistaxjtu/restricted-boltzmann-machine-as-a-recommendation-system-for-movie-review-part-2-9a6cab91d85b" rel="noopener"> <strong class="kx iu">篇</strong> </a> <strong class="kx iu">将一步步走完如何打造一个 RBM。如果需要源代码，请访问我的</strong><a class="ae ku" href="https://github.com/luke4u/Movie-Rating-Prediction" rel="noopener ugc nofollow" target="_blank"><strong class="kx iu">Github</strong></a><strong class="kx iu">页面🤞🤞。</strong></p></div></div>    
</body>
</html>