<html>
<head>
<title>How To run SQL queries from a Jupyter Notebook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从 Jupyter 笔记本运行 SQL 查询</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-run-sql-queries-from-a-jupyter-notebook-aaa18e59e7bc?source=collection_archive---------5-----------------------#2020-07-20">https://towardsdatascience.com/how-to-run-sql-queries-from-a-jupyter-notebook-aaa18e59e7bc?source=collection_archive---------5-----------------------#2020-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3c66" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SQL IDEs 不能可视化数据。您知道吗，您可以使用 Jupyter 笔记本运行并可视化查询结果？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39582e5fe0bbb405aab97088aa348224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IlXhYMtQyfOI_rFh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">本·怀特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4e96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">如果</span>你在数据科学领域工作，你很可能会使用 SQL 来提取和预处理数据。我使用 JetBrains <a class="ae ky" href="https://www.jetbrains.com/datagrip/?gclid=CjwKCAjwmMX4BRAAEiwA-zM4JlAlxuoNVssIK6WNW44-KErOe8DZZqBsRaJ7C79bRmhn-0IwpCi2ZhoC0ggQAvD_BwE" rel="noopener ugc nofollow" target="_blank"> DataGrip </a>作为我的主要 SQL 编辑器已经有一段时间了。虽然 DataGrip 做得不错，但它没有提供可视化数据的方法。有没有更好的办法？</p><h2 id="9e7a" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated"><strong class="ak">这里有几个你可能会感兴趣的链接:</strong></h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="a134" class="me mf it my b gy nc nd l ne nf">- <a class="ae ky" href="https://trymito.io/" rel="noopener ugc nofollow" target="_blank">Complete your Python analyses 10x faster with Mito</a> [Product]</span><span id="cf78" class="me mf it my b gy ng nd l ne nf">- <a class="ae ky" href="https://aigents.co/skills" rel="noopener ugc nofollow" target="_blank">Free skill tests for Data Scientists &amp; ML Engineers</a> [Test]</span><span id="1e41" class="me mf it my b gy ng nd l ne nf">- <a class="ae ky" href="https://imp.i115008.net/c/2402645/1116216/11298" rel="noopener ugc nofollow" target="_blank">All New Self-Driving Car Engineer Nanodegree</a><strong class="my iu"> </strong>[Course]</span></pre><p id="9b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nh">你愿意多看一些这样的文章吗？如果是这样，你可以点击上面的任何链接来支持我。其中一些是附属链接，但你不需要购买任何东西。</em></p><h1 id="a417" class="ni mf it bd mg nj nk nl mj nm nn no mm jz np ka mp kc nq kd ms kf nr kg mv ns bi translated">用于 SQL 的 ide</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/c0b917159ac47934e55a4dc3b9c117a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*6G5cyylVWddKuwno.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Gif 来自<a class="ae ky" href="https://giphy.com/gifs/screen-monitor-closeup-26tn33aiTi1jkl6H6" rel="noopener ugc nofollow" target="_blank"> Giphy </a></p></figure><p id="9216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL 的集成开发环境通常不具备可视化查询结果的能力。在我看来，这是一件好事，因为每个 IDE 都有自己专有的方式来可视化数据，这是我们需要学习的。</p><blockquote class="nu"><p id="fe26" class="nv nw it bd nx ny nz oa ob oc od lu dk translated">我可视化数据的工作流程是:在 SQL IDE 中开发并执行查询，将数据导出到 CSV 并在 Jupyter 笔记本中可视化。</p></blockquote><h1 id="28ce" class="ni mf it bd mg nj nk nl mj nm nn no mm jz oe ka mp kc of kd ms kf og kg mv ns bi translated">在 Jupyter 笔记本中运行查询</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/331a4197b370afbafe34db82040d5f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/0*np_ulaRC_wLv9kxp.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Gif 来自<a class="ae ky" href="https://giphy.com/gifs/life-ol365-ollife-d5pBBi43j9FNUEZRwr" rel="noopener ugc nofollow" target="_blank"> Giphy </a></p></figure><p id="6166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当查询结果太大而无法在单个查询中处理时，该怎么办？一种解决方案是以更短的时间间隔运行查询，而不是一整年，您可以按月运行查询。</p><p id="83cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按月运行一个查询需要一年运行 12 次，这对于手工来说是不可行的——因为循环在这里很有用。</p><blockquote class="nu"><p id="917f" class="nv nw it bd nx ny nz oa ob oc od lu dk translated">拥有多种工具总是好的</p></blockquote><p id="ecca" class="pw-post-body-paragraph kz la it lb b lc oi ju le lf oj jx lh li ok lk ll lm ol lo lp lq om ls lt lu im bi translated">当面临这样的问题时，我一直使用<a class="ae ky" href="http://docs.sqlalchemy.org/en/latest/core/engines.html#database-urls" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>连接到数据库，并将数据提取到 pandas DataFrame，如下例所示:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="3df2" class="me mf it my b gy nc nd l ne nf">import sqlalchemy<br/>import pandas</span><span id="78b9" class="me mf it my b gy ng nd l ne nf">engine = sqlalchemy.create_engine(<br/>    sqlalchemy.engine.url.URL(<br/>        drivername="postgresql",<br/>        username="username",<br/>        password="password",<br/>        host="host",<br/>        port="port",<br/>        database="database",<br/>    ),<br/>    echo_pool=True,<br/>)<br/>print("connecting with engine " + str(engine))<br/>connection = engine.connect()</span><span id="f758" class="me mf it my b gy ng nd l ne nf">query = "select * from table"</span><span id="001b" class="me mf it my b gy ng nd l ne nf">df = pd.read_sql_query(query, connection)</span></pre><p id="e81c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在上面看到的，SQL 查询是用字符串编写的。即使您将查询字符串放在 Jupyter 笔记本的一个单独的单元格中，并且安装了格式化的 SQL 代码，它也不会格式化查询，因为它仍然是一个 Python 字符串。</p><p id="c4ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有没有更好的办法？</p><h1 id="1bf9" class="ni mf it bd mg nj nk nl mj nm nn no mm jz np ka mp kc nq kd ms kf nr kg mv ns bi translated">认识 ipython-sql</h1><p id="9795" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated">ipython-sql 使我们能够直接从 Jupyter 笔记本上运行 sql 查询。无需编写多行代码来连接数据库或将查询包装在字符串中。ipython-sql 使得从 Jupyter Notebook 查询数据库更加“干净”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/2a5bc438157e213af51afa7db9893a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jfyBjjpRnqyYut_JK5k8hw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 ipython-sql 查询 SQLite 数据库</p></figure><p id="2c19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要安装 ipython-sql，只需在 Jupyter 笔记本中运行以下命令:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="a35e" class="me mf it my b gy nc nd l ne nf">!pip install ipython-sql</span></pre><p id="ed73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后加载 SQL 模块:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="1f96" class="me mf it my b gy nc nd l ne nf">%load_ext sql</span></pre><p id="dbe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个连接字符串来连接数据库。对于 SQLite，它非常简单:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="a772" class="me mf it my b gy nc nd l ne nf">%sql sqlite://</span></pre><p id="e3c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您以前使用过<a class="ae ky" href="http://docs.sqlalchemy.org/en/latest/core/engines.html#database-urls" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>连接到数据库，您可以使用下面的代码来获得连接字符串:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="360e" class="me mf it my b gy nc nd l ne nf">print("connecting with engine " + str(engine))</span></pre><blockquote class="nu"><p id="bf5b" class="nv nw it bd nx ny ot ou ov ow ox lu dk translated">注意，每个单元格都需要用%%sql 注释。这告诉 Jupyter 笔记本，单元格中的代码是 SQL。</p></blockquote><p id="4431" class="pw-post-body-paragraph kz la it lb b lc oi ju le lf oj jx lh li ok lk ll lm ol lo lp lq om ls lt lu im bi translated">让我们将示例数据添加到 SQLite 数据库中:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="fde0" class="me mf it my b gy nc nd l ne nf">%%sql<br/>CREATE TABLE sales<br/>(<br/>    key       varchar(6),<br/>    ts        timestamp,<br/>    product   integer,<br/>    completed boolean,<br/>    price     float<br/>);<br/>INSERT INTO sales<br/>VALUES ('sale_1', '2019-11-08 00:00', 0, TRUE, 1.1),<br/>       ('sale_2', '2019-11-08 01:00', 0, FALSE, 1.2),<br/>       ('sale_3', '2019-11-08 01:00', 0, TRUE, 1.3),<br/>       ('sale_4', '2019-11-08 01:00', 1, FALSE, 1.4),<br/>       ('sale_5', '2019-11-08 02:00', 1, TRUE, 1.5),<br/>       ('sale_6', '2019-11-08 02:00', 1, TRUE, 1.5);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/7f8884da649e3d896543d75395522a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4N37iNW7JvdYgHXCVK1nQ.png"/></div></div></figure><p id="8c24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们查询数据库</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="16e1" class="me mf it my b gy nc nd l ne nf">%%sql</span><span id="ef70" class="me mf it my b gy ng nd l ne nf">select * from sales;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/dbf9485cfa3397cb8843391bdea66361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_Bjgt6JjJ7AeRdBq65MzQ.png"/></div></div></figure><p id="c11c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常管用！</p><p id="a61b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只运行了查询，但是结果没有分配给任何变量，这没有多大用处。幸运的是，Jupyter Notebook 使我们能够将一个单元格的先前输出设置为一个变量:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="8c41" class="me mf it my b gy nc nd l ne nf">result = _</span></pre><p id="c8c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查结果变量的类型:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="17ec" class="me mf it my b gy nc nd l ne nf">type(result)</span><span id="ada6" class="me mf it my b gy ng nd l ne nf"># sql.run.ResultSet</span></pre><p id="25ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们使用以下方法将结果集直接转换为 pandas 数据帧:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="3304" class="me mf it my b gy nc nd l ne nf">df = result.DataFrame()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/0bf47189aa5b1427e6364197887ab652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HSGopE8OeUmMJOuJ_oqN9A.png"/></div></div></figure><p id="b375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使我们能够交互式地探索数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/d0c6da9851f682a7e0cc4f3e5f04f5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CdRo44aaJepnWxwyajZmAw.gif"/></div></div></figure><h1 id="ab39" class="ni mf it bd mg nj nk nl mj nm nn no mm jz np ka mp kc nq kd ms kf nr kg mv ns bi translated">在你走之前</h1><p id="dea3" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated">在<a class="ae ky" href="https://twitter.com/romanorac" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，在那里我定期<a class="ae ky" href="https://twitter.com/romanorac/status/1328952374447267843" rel="noopener ugc nofollow" target="_blank">发关于数据科学和机器学习的</a>推特。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/b5d426b68cc5a21b1a35d0a157ebc4f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*69rP1pwjJi9mLSFE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cmhedger?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Courtney hedge</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div></div>    
</body>
</html>