<html>
<head>
<title>How to use Python classes effectively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何有效地使用 Python 类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-python-classes-effectively-10b42db8d7bd?source=collection_archive---------5-----------------------#2020-07-25">https://towardsdatascience.com/how-to-use-python-classes-effectively-10b42db8d7bd?source=collection_archive---------5-----------------------#2020-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c725" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当一堆功能对你来说是更好的选择时</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87aaa5ce45b9bc6238c0aef522867dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCfjT5DruSQ6dwCUSfxtVQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">做事的方式应该只有一种。但是上课的时候会很混乱。照片由<a class="ae ky" href="https://unsplash.com/@joeel56?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">妮可·沃尔夫</a>在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="2ee6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw mf bm di mg"><img alt="“T" class="ks mh mi mj mk ml fc n ih dh bf" src="../Images/342a2c9be12278887a431eff4c084f0d.png" width="93" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:186/1*ETmY8LRVPyvQ7IZ11Q_Q6g.jpeg"/><span class="l lw lx ly bm lz ma mb mc md di me">“T</span></span>这里应该只有一种——最好只有一种——显而易见的方法”，Python 的<a class="ae ky" href="https://www.python.org/dev/peps/pep-0020/" rel="noopener ugc nofollow" target="_blank">禅如是说。然而，在有些领域，即使是经验丰富的程序员也在争论什么是正确或错误的做事方式。</a></p><p id="eb0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中一个领域是 Python 类。从面向对象编程中借鉴来的，它们是非常漂亮的构造，可以在编码时扩展和修改。</p><p id="8c7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最大的问题是，类会使你的代码比必要的更复杂，更难阅读和维护。那么什么时候应该使用类，什么时候应该使用标准函数呢？</p><p id="3182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个故事是对这个问题的更深入的探究。所以如果你很急，你可以跳过下面的两个部分，直接向下滚动到第<em class="mm">部分，什么时候使用类</em>和<em class="mm">部分，当类不是一个好主意</em>的时候。</p><h1 id="6502" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">Python 类:非常基础</h1><p id="3177" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">类是允许您将数据结构和过程分组到一个地方的对象。例如，假设您正在编写一段代码来组织服装店的库存。</p><p id="8a40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以创建一个类，获取商店中的每件衣服，并存储关键数量，如衣服的类型、颜色和尺寸。我们还将添加一个选项来添加价格。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="59e3" class="np mo it nl b gy nq nr l ns nt">class Clothing(object):<br/>    def __init__(self, type, color, size, price=None):<br/>        self.type = type<br/>        self.color = color<br/>        self.size = size<br/>        self.price = price</span></pre><p id="50c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以定义该类的各种实例，并将它们组织起来:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="7078" class="np mo it nl b gy nq nr l ns nt">bluejeans = Clothing("jeans", "blue", 12)<br/>redtshirt = Clothing("t-shirt", "red", 10, 10)</span></pre><p id="af57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在类的定义之后添加这两行没有缩进的内容。这段代码将会运行，但是它不会做太多。我们可以在类定义中的<code class="fe nu nv nw nl b">__init__</code>函数下直接添加一个设置价格的方法:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="86dc" class="np mo it nl b gy nq nr l ns nt">    def set_price(self, price):<br/><em class="mm">        """Set the price of an item of clothing."""<br/></em>        self.price = price<br/>        print(f"Setting the price of the {self.color} {self.type} to ${price}.")</span></pre><p id="9d93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以添加一些例程来告诉我们价格，或者通过降低价格来促销商品:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="5307" class="np mo it nl b gy nq nr l ns nt">    def get_price(self):<br/><em class="mm">        """Get the price of an item of clothing, if price is set."""<br/></em>        try:<br/>            print(f"The {self.color} {self.type} costs ${self.price}.")<br/>        except:<br/>            print(f"The price of the {self.color} {self.type} hasn't been set yet!")</span><span id="25b1" class="np mo it nl b gy nx nr l ns nt">    def promote(self, percentage):<br/><em class="mm">        """Lower the price, if initial price is set."""<br/></em>        try:<br/>            self.price = self.price * (1-percentage/100)<br/>            print(f"The price of the {self.color} {self.type} has been reduced by {percentage} percent! It now only costs ${self.price:.0f}.")<br/>        except:<br/>            print(f"Oops. Set an initial price first!")</span></pre><p id="80ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在初始化该类实例的行之后添加一些方法调用:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="3662" class="np mo it nl b gy nq nr l ns nt">print("blue jeans -------------------")<br/>bluejeans.promote(20)<br/>bluejeans.set_price(30)<br/>bluejeans.get_price()</span><span id="7d2d" class="np mo it nl b gy nx nr l ns nt">print("red t-shirt ------------------")<br/>redtshirt.get_price()<br/>redtshirt.promote(20)</span></pre><p id="b71f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果运行该脚本，输出将如下所示:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="fb5c" class="np mo it nl b gy nq nr l ns nt">blue jeans -------------------<br/>Oops. Set an initial price first!<br/>Setting the price of the blue jeans to $30.<br/>The blue jeans costs $30.<br/>red t-shirt ------------------<br/>The red t-shirt costs $10.<br/>The price of the red t-shirt has been reduced by 20 percent! It now only costs $8.</span></pre><p id="9802" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你需要添加更多的例程，你可以把它们放在类定义中。</p><p id="91cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最棒的是，你可以添加和删除任意多的对象。删除属性的过程如下:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="17b9" class="np mo it nl b gy nq nr l ns nt">del redtshirt.price </span></pre><p id="e477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想删除整个对象，你可以这样做:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="7d58" class="np mo it nl b gy nq nr l ns nt">del redtshirt</span></pre><p id="8cab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些都是整洁、简单和可扩展的。试着用标准函数来实现，你可能会遇到更多的麻烦。</p><p id="acc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从理论的角度来看，有更多的理由说明 Python 类在许多情况下是一个美丽的概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/0ca6f385611b7ae385a80bf2abaf731d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TQQUbbUXA5xZGaAmLbCanw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正确使用时，类是强大的概念。Muhannad Ajjan 在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="7e80" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">理论上来说，课堂是很神奇的</h1><h2 id="6c36" class="np mo it bd mp nz oa dn mt ob oc dp mx li od oe mz lm of og nb lq oh oi nd oj bi translated">关注点分离:给每个类分配自己的工作</h2><p id="2795" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">如果你参加过计算机科学的讲座，很可能你已经偶然发现了“关注点分离”的原则。这基本上意味着你把你的程序分成不同的部分来处理不同的信息。</p><p id="7a6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从本质上来说，类允许你遵守这个原则。换句话说，当你开始写一个程序，并且你在考虑类的时候，你可能在构建一个好的架构，因为你确保了每个问题都有自己的位置。</p><h2 id="4a5f" class="np mo it bd mp nz oa dn mt ob oc dp mx li od oe mz lm of og nb lq oh oi nd oj bi translated">解耦:使维护更容易</h2><p id="7632" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在类中思考不仅有助于保持特性的分离，还能使它们相互独立。这不仅能保持物品的整洁；维护起来也方便了很多。</p><p id="2497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您在一个类中发现了一个 bug:您可以修复这个 bug，而不用担心其他类，因为它们之间没有联系。同样，你可以添加新的特性，而不用担心会与软件的其他部分纠缠在一起。</p><h2 id="f683" class="np mo it bd mp nz oa dn mt ob oc dp mx li od oe mz lm of og nb lq oh oi nd oj bi translated">实现隐藏:定义程序员能使用什么，不能使用什么</h2><p id="136d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">通过使用类，您可以确保方法只用于一组数据。这增加了代码的安全性，因为您不太可能在不属于它们的地方使用函数。</p><h2 id="4a4d" class="np mo it bd mp nz oa dn mt ob oc dp mx li od oe mz lm of og nb lq oh oi nd oj bi translated">封装:改变代码，但不改变用户体验</h2><p id="0052" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">将数据结构和方法存储在一起也称为封装。由于所有这些对最终用户都是隐藏的，这允许您修改数据结构和方法，而不会损害用户体验。</p><p id="deee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可能需要构建一个非常复杂的方法。封装的优点是用户不需要理解任何复杂性，因为他们可以像使用黑盒一样使用它。</p><p id="76ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不使用类来构建黑盒函数是完全可能的。然而，对于类，这种类型的功能实际上是可以保证的。</p><h2 id="b593" class="np mo it bd mp nz oa dn mt ob oc dp mx li od oe mz lm of og nb lq oh oi nd oj bi translated">继承:编写数据结构的 DNA</h2><p id="e51a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">有了类，你只需要定义一个数据结构一次。当定义一个类的实例时，该实例自动继承给定的结构。</p><p id="4823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，继承使得删除或修改实例或整个类变得非常容易。这使得整个结构更加灵活。</p><div class="ok ol gp gr om on"><a rel="noopener follow" target="_blank" href="/the-ultimate-guide-to-writing-better-python-code-1362a1209e5a"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">编写更好的 Python 代码的终极指南</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">让你的软件更快、更易读和更易维护并不需要这么难</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">towardsdatascience.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><h1 id="960c" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">何时使用类</h1><p id="aeeb" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">有了这么多的优点，用一个类来做任何事情都很有诱惑力。然而，在实践中，有些情况下使用类非常有意义，而有些情况下则没有意义。</p><h2 id="c603" class="np mo it bd mp nz oa dn mt ob oc dp mx li od oe mz lm of og nb lq oh oi nd oj bi translated">将数据和方法组合在一起</h2><p id="9b25" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">根据经验，当您有一组具有特定结构的数据，并且希望对其执行特定的方法时，请使用类。然而，只有在代码中使用多种数据结构时，这才是有效的。</p><p id="f3ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的整个代码不会处理一个以上的结构。如果你只有一种数据结构，那就真的要看手头的问题了。你可以通过有没有上课勾画出你的程序来得到一个大概的想法；通常你会很快发现哪个解决方案更简单。</p><h2 id="4aae" class="np mo it bd mp nz oa dn mt ob oc dp mx li od oe mz lm of og nb lq oh oi nd oj bi translated">当心全局变量</h2><p id="ed67" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">另一个经验法则是<a class="ae ky" href="https://www.reddit.com/r/learnpython/comments/6wsjt9/i_still_dont_get_when_to_use_class_vs_functions/" rel="noopener ugc nofollow" target="_blank">这个</a>:如果你想使用全局变量来访问数据，定义一个类并构建一个方法来访问每一段数据可能更容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/d5f286ea8c616e9fc3867b3961c47a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3b2c-y6iHSOezeYwUVDf5Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上课并不总是一个好主意。照片由<a class="ae ky" href="https://unsplash.com/@wocintechchat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜@ wocintechchat.com</a>在<a class="ae ky" href="https://unsplash.com/collections/10869614/people-working?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="e27f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">当上课不是个好主意时</h1><h2 id="7e09" class="np mo it bd mp nz oa dn mt ob oc dp mx li od oe mz lm of og nb lq oh oi nd oj bi translated">对堆使用 heapq</h2><p id="7fa2" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">与堆栈不同，<a class="ae ky" href="https://gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html" rel="noopener ugc nofollow" target="_blank">堆</a>是一种更灵活的存储数据的方式，因为它有无限的内存大小，并允许您调整变量的大小。另一方面，使用堆访问变量速度较慢，并且您必须自己管理内存。</p><p id="6932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个堆更适合你的目的，你不需要定义一个类。Python 的内置<code class="fe nu nv nw nl b">heapq</code>，或者堆队列算法，为你做了<a class="ae ky" href="https://devblogs.microsoft.com/python/idiomatic-python-functions-versus-classes/" rel="noopener ugc nofollow" target="_blank">工作</a>。</p><h2 id="1d14" class="np mo it bd mp nz oa dn mt ob oc dp mx li od oe mz lm of og nb lq oh oi nd oj bi translated">考虑使用 functools.partial()</h2><p id="2352" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">您可能很想使用一个类，因为您经常用相同的参数调用一个函数。在大多数情况下，用<code class="fe nu nv nw nl b">functools.partial()</code>来代替会更好。</p><p id="93ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现起来相当简单。假设您有一个将两个值相乘的函数，但是您一直使用它来将两个值加倍。为了避免重复代码，您可以这样写:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="7eb3" class="np mo it nl b gy nq nr l ns nt">from functools import partial</span><span id="ad63" class="np mo it nl b gy nx nr l ns nt">def multiply(x,y):<br/>    return x * y</span><span id="9868" class="np mo it nl b gy nx nr l ns nt">doubling = partial(multiply,2)<br/>print(doubling(4))</span></pre><p id="d0c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比定义一个新类简单多了！</p><h2 id="d2ba" class="np mo it bd mp nz oa dn mt ob oc dp mx li od oe mz lm of og nb lq oh oi nd oj bi translated">“面向未来”的课程</h2><p id="9cb7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">一些程序员痴迷于类，因为它们是如此的灵活和可扩展。这就是为什么，即使在声誉良好的公司和经验丰富的开发人员中，您也可能会遇到这样的代码:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="b04d" class="np mo it nl b gy nq nr l ns nt">class newclass:<br/>    """defining a new class to do something awesome"""<br/>    pass</span></pre><p id="37cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其背后的思想是，随着代码的增长，无论新的数据结构和方法是什么，都可能需要这个类。但这不是好习惯！</p><p id="4bf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">猜猜这三行代码是做什么的？完全没有。这些行并不难编码。如果你认为你以后还需要另一门课，并且你真的认为你将来会忘记它，你可以留下这样的评论:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="5762" class="np mo it nl b gy nq nr l ns nt"># initiate a new class here if needed for purpose XY</span></pre><p id="42c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管你想让你的代码具有可扩展性和不傻，初始化一个什么都不做的类通常不是一个好主意。</p><div class="ok ol gp gr om on"><a rel="noopener follow" target="_blank" href="/7-reasons-why-programmers-burn-out-44a40bf8948d"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">程序员精疲力竭的 7 个原因</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">和 7 种解决方法</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">towardsdatascience.com</p></div></div><div class="ow l"><div class="pd l oy oz pa ow pb ks on"/></div></div></a></div><h1 id="e138" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">底线是:Python 类是一把双刃剑</h1><p id="77b6" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">毫无疑问，阶级是一个强大的概念。正确使用，它们可以使你的代码更整洁，更可读和可维护。</p><p id="6ba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是它们被过度使用了。如果使用不当，它们会污染你的代码，直到你什么都不懂。</p><p id="2568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，特别是在简单的程序中，你可以使用一个类或一组通用函数，代码在长度和复杂性上非常相似。随着程序变得越来越复杂，差异变得越来越突出。</p><p id="32ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个意义上来说，Python 的禅坚持了它的结论:大多数时候，确实只有一种好的做事方式，不管有没有类。然而，这并不总是完全显而易见的。困难的部分是认识到哪条路是好的。</p><p id="a9b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mm">如果你有其他关于 Python 或其他编程语言的问题，请在评论中告诉我！感谢</em> <a class="pe pf ep" href="https://medium.com/u/3d4826ca4d12?source=post_page-----10b42db8d7bd--------------------------------" rel="noopener" target="_blank"> <em class="mm">卢卡斯·苏亚雷斯</em> </a> <em class="mm">询问何时使用类，何时不使用类的技巧。</em></p></div></div>    
</body>
</html>