<html>
<head>
<title>How to Loop Through Your Own Objects in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中遍历自己的对象</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-loop-through-your-own-objects-in-python-1609c81e11ff?source=collection_archive---------3-----------------------#2020-06-05">https://towardsdatascience.com/how-to-loop-through-your-own-objects-in-python-1609c81e11ff?source=collection_archive---------3-----------------------#2020-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a63d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Iterables，迭代和迭代您的自定义Python对象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/75ed0ec1685f5c6a325ed6a7fa8f8119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*M1BDxK7q4R2lmqamVxnqEA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片由<a class="ae ku" href="https://unsplash.com/@tine999" rel="noopener ugc nofollow" target="_blank">Tine ivani</a>通过Unsplash提供</p></figure><h2 id="6aef" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">目标</h2><p id="d29d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">本教程旨在帮助你理解什么是迭代和迭代器，以及它们之间的关系。其次，理解Python for循环是如何工作的，最终将有助于设计一个可以迭代的用户定义的自定义对象。</p><h2 id="02bb" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">可重复的</h2><p id="d6b6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">iterable是一个能够逐个返回其成员的对象。简单地说，iterable是可以使用Python中的for循环进行循环的任何东西。序列是一种非常常见的可迭代类型。内置序列类型的示例包括列表、字符串和元组。</p><h2 id="7a53" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">迭代器</h2><p id="0fa2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">迭代器是表示数据流的对象。您可以通过实现iterable的<strong class="lt iu"> iter </strong>内置函数来创建迭代器对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="cb28" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">迭代器可用于手动循环遍历iterable中的项目。迭代器反复传递给内置的<strong class="lt iu"> next </strong>函数，返回流中的连续项。当iterator中的条目被使用时，它就消失了，最终，当没有更多的数据可供检索时，就会引发一个<strong class="lt iu"> StopIteration异常</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h2 id="200c" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">了解Python for循环</h2><p id="5386" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">发展关于可迭代和迭代器的知识的核心是理解Python for循环是如何工作的。为了更好地说明这一点，让我们定义一个可以接受任何iterable的函数，并在不使用for循环的情况下遍历<em class="mr">。</em></p><p id="bfb1" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">我们的功能需要能够实现以下目标:</p><p id="030b" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">从iterable创建迭代器</p><p id="8e90" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">从迭代器中重复检索下一项</p><p id="95da" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">执行任何预期的操作</p><p id="0c2f" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">当没有更多要检索的项时，引发StopIteration异常。</p><p id="c041" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated"><em class="mr">在Python for循环中，iterable被转换成迭代器。</em></p><p id="a38f" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">我们的自定义函数首先将任何iterable转换为迭代器。在while循环中，我们从迭代器中获取下一项，并对该项执行任何操作。在这种情况下，我选择编写一个函数来将迭代器中的数字提升2的幂，但是可以采取任何操作，例如，我们甚至可以选择简单地打印出容器或集合中的数字。</p><p id="b2f7" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">Python中所有形式的迭代都是以这种方式工作的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h2 id="df45" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">关键定义</h2><p id="beb7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">为了更好地区分iterable和iterator，进一步细化它们的定义并注意它们的区别会很有帮助。迭代器不能被索引/切片(因为它们可以无限长)。此外，与可重复项不同，它们没有长度。在下面的例子中，试图获取迭代器对象的长度，my_iter_list引发了一个<strong class="lt iu">类型错误异常</strong>。</p><p id="63b1" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">iterable是可以循环的东西。</p><p id="26b0" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated"><strong class="lt iu"> &gt;迭代器是代表数据流的对象。它对一个iterable进行迭代。</strong></p><p id="bd5e" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">在为本文进行研究时，迭代器的一个简洁明了的定义来自于<a class="ae ku" href="https://stackoverflow.com/questions/2776829/difference-between-pythons-generators-and-iterators#:~:text=Every%20generator%20is%20an%20iterator,paragraph's%20definition%20of%20an%20iterator%20." rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>，如下所示:</p><blockquote class="ms mt mu"><p id="5b2f" class="lr ls mr lt b lu mm ju lw lx mn jx lz mv mo mb mc mw mp me mf mx mq mh mi mj im bi translated"><code class="fe my mz na nb b">iterator</code>是一个更一般的概念:任何对象的类都有一个<code class="fe my mz na nb b">next</code>方法(Python 3中的<code class="fe my mz na nb b">__next__</code>)和一个<code class="fe my mz na nb b">__iter__</code>方法(T4)</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="fece" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">迭代器允许用户使用和创建惰性迭代器。懒惰的迭代程序不做任何工作，直到我们向它们请求下一个项目。这个特性可以帮助我们处理内存中容纳不下的无限长的可重复项。这被称为<strong class="lt iu">惰性评估</strong>，可以帮助节省内存和CPU时间。</p><h2 id="c937" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">迭代器协议</h2><p id="eaed" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">如上所述，迭代器对象需要支持以下两种方法，这两种方法组合在一起构成了Python迭代器协议:</p><p id="b999" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated"><strong class="lt iu">邓德/魔术iter法:</strong></p><ul class=""><li id="065a" class="nc nd it lt b lu mm lx mn le ne li nf lm ng mj nh ni nj nk bi translated">迭代器。__iter__() <br/>返回迭代器对象本身。这是允许容器(也称为集合)和迭代器与<code class="fe my mz na nb b">for</code>和<code class="fe my mz na nb b">in</code>语句一起使用所必需的。</li></ul><p id="4ec2" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated"><strong class="lt iu">邓德/魔种下法:</strong></p><ul class=""><li id="aa95" class="nc nd it lt b lu mm lx mn le ne li nf lm ng mj nh ni nj nk bi translated">迭代器。__next__() <br/>从容器中返回下一个项目。如果没有更多的项，则引发StopIteration异常。</li></ul><h1 id="0e10" class="nl kw it bd kx nm nn no la np nq nr ld jz ns ka lh kc nt kd ll kf nu kg lp nv bi translated">创建自己的可迭代类型</h1><p id="49b4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">我们可能想要创建一个<strong class="lt iu">自定义迭代器</strong>。为此，我们需要一个定义了<strong class="lt iu"> __init__ </strong>、<strong class="lt iu"> __next__ </strong>和<strong class="lt iu"> __iter__ </strong>方法的类。</p><h2 id="1100" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">自定义团队</h2><p id="c3aa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">首先，让我们定义一个名为CustomIterTeams的自定义类。这个类没有内置的iterable行为，但是我们可以在类中实现代码，使我们的自定义用户定义对象的行为像iterable一样。</p><p id="f20a" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">有两种方法可以让自定义的用户定义对象表现得像iterable。第一种方法涉及定义两个dunder或magic方法，即__iter__()和__next__()。dunder iter方法只需要返回对象本身。这是因为，当我们编写for循环时，这将是我们打算迭代的对象。这个iter方法返回一个<strong class="lt iu">迭代器</strong>。</p><p id="fb7a" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated"><strong class="lt iu">在幕后，Python的for循环使用迭代器。</strong></p><p id="5480" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">我们的自定义对象现在是一个迭代器，可以使用dunder next方法返回流中的连续项。这两种方法共同支持迭代器协议。</p><p id="281f" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">在_ _ init _ _构造函数中，我们将对象中的索引设置为值-1。当调用下一个方法时，例如在for循环的第一次迭代中，索引的值增加1。然后，我们检查索引值是否大于用户在第一次创建对象时决定添加的球队列表的长度。如果索引小于团队的长度，我们只需从团队列表中返回具有范围内索引的团队。</p><p id="30ac" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">一旦索引等于或大于团队列表的长度，我们再次将索引重置回-1(正如它最初在init构造函数中设置的那样)，并引发一个<strong class="lt iu"> StopIteration异常</strong>。</p><p id="968e" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">用户现在能够迭代创建的团队。CustomIterTeams对象prem_teams现在是一个迭代器，我们可以遍历它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi nw"><img src="../Images/174a0323e6f640ff77f6725bb19b52e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yfOu8f4UyxVytRYFTZTwhQ.png"/></div></div></figure><p id="ea9b" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">一旦索引达到列表的长度，在引发StopIteration异常之前，会特意将索引重置为其原始值。实现此功能是为了让用户在同一个会话中执行对象的多次迭代，如下面的python提示所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/761d0850d02586e0b0d3315faf52ef1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*yZpNx1ftxkjzd-Lo_CMSNw.png"/></div></figure><p id="2370" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">我们现在还可以通过简单地实现dunder reserved方法来颠倒团队的顺序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi oc"><img src="../Images/8da66b6ef97228597895d755b4a5ef1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GhcPQo9LTRfhsNqpIKWTKg.png"/></div></div></figure><h2 id="4a79" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">定义自定义可迭代类型的简单方法</h2><p id="4cb0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">没有必要为了使用户定义的对象可迭代而定义一个dunder next方法。相反，我们只需要让dunder iter方法返回一个生成器，这个生成器在我们的团队中循环。<strong class="lt iu">每个生成器都是一个迭代器</strong>。生成器有一个内置的next方法，因此不需要在自定义python类中实现next方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi od"><img src="../Images/0e5486f48857802da1e4f74b5863e4a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qImZYBbdCNuXMwpK51mMfg.png"/></div></div></figure><p id="ac52" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le mo mb mc li mp me mf lm mq mh mi mj im bi translated">这段代码片段的github要点可以在<a class="ae ku" href="https://gist.github.com/StephenFordham/6d5a250bd2b721b6099ab650a481f1d5" rel="noopener ugc nofollow" target="_blank">这里</a>找到，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h2 id="2062" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">总结:</h2><p id="7aca" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">通过包含iter和next方法，或者简单地在iter方法中返回一个生成器，可以在自定义的类中实现迭代。这取决于程序员，但是iter和next方法的实现稍微长一点，可以添加更精细定义的行为。</p></div></div>    
</body>
</html>