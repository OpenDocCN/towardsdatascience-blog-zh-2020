<html>
<head>
<title>Basic Algorithms — Finding the Closest Pair</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本算法—寻找最接近的一对</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/basic-algorithms-finding-the-closest-pair-5fbef41e9d55?source=collection_archive---------4-----------------------#2020-02-10">https://towardsdatascience.com/basic-algorithms-finding-the-closest-pair-5fbef41e9d55?source=collection_archive---------4-----------------------#2020-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="922a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用分裂-征服算法确定二维平面上两点的最近对</h2></div><p id="77d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编写性价比高的算法是作为一名数据科学家成功的关键之一，而在<a class="ae le" rel="noopener" target="_blank" href="/basic-algorithms-counting-inversions-71aaa579a2c0">上一篇文章</a>中我们在计算一个数组中的求逆时使用了分裂-征服法，这种方法的成本远低于蛮力法。这一次，我们将看到另一种分裂-征服算法如何从二维平面上的一组点中找到最近的一对点。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/5f3de52c7d04a4008c2bca2ade2815ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iUdhT_8ZRjlH02lR"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae le" href="https://unsplash.com/@remypnt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雷米·佩内特</a>拍摄的照片</p></figure><p id="7204" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在时代广场或东京市中心仰望天空，我们会很容易找到最近的一对星星，因为在那里你只能看到几颗星星。如果你在一个不知名的地方，黑暗的夜空中无限多的星星会让你无法确定这一对。</p><p id="00ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对计算机来说也没什么不同；当他们确定平面上最接近的点对时，数据集的点越多，算法寻找距离最小的点对所需的时间就越长。成本的增加不仅仅是点的数量的线性增加，我们试图编写一个尽可能低的包含成本增加的算法。分裂-征服法在这个挑战中工作得很好，以类似的方式与算法计数倒置。</p><h2 id="4379" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">强力法——寻找最接近的一对</h2><p id="908c" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">蛮力方法是，像在一个数组中计算反转一样，计算宇宙中每一对点的距离。对于<em class="mt"> n </em>个点，我们需要测量<em class="mt"> n(n-1)/2 </em>个距离，成本是n的平方，即<em class="mt">θ(n)。</em>有了两个循环，这个算法的代码可以写成如下。</p><pre class="lg lh li lj gt mu mv mw mx aw my bi"><span id="6681" class="lv lw it mv b gy mz na l nb nc">def <strong class="mv iu">find_closest_brute_force</strong>(array):<br/>    <br/>    result = {}<br/>    result["p1"] = array[0]<br/>    result["p2"] = array[1]<br/>    result["distance"] = np.sqrt((array[0][0]-array[1][0])**2<br/>                                +(array[0][1]-array[1][1])**2)<br/>    <br/>    for i in range(len(array)-1):<br/>        for j in range(i+1, len(array)):<br/>            distance = np.sqrt((array[i][0]-array[j][0])**2<br/>                              +(array[i][1]-array[j][1])**2)<br/>            if distance &lt; result["distance"]:<br/>                result["p1"] = array[i]<br/>                result["p2"] = array[j]<br/>                result["distance"] = distance<br/>    return result</span><span id="771c" class="lv lw it mv b gy nd na l nb nc">return result</span></pre><p id="9750" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们想一个更好的方法，它的成本是。使用预分类和分治法是可能的。为了在一个坐标上对数组进行预排序，我们还使用了狭缝征服法，即合并排序算法。</p><h2 id="271d" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">合并排序</h2><p id="8060" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们用一种叫做合并排序的算法对数组进行排序，这种算法比强力排序算法要快。merge-sort算法拆分数组，对子数组进行排序(作为递归步骤)，比较两个子数组中最年轻的数字并挑选较年轻的，并重复该操作，直到两个子数组都用完为止。每个递归步骤的开销仅为<em class="mt">θ(n)</em>，因此算法的总开销保持在<em class="mt">θ(nlgn)。</em></p><pre class="lg lh li lj gt mu mv mw mx aw my bi"><span id="10b7" class="lv lw it mv b gy mz na l nb nc">def <strong class="mv iu">merge_sort</strong>(array, coordinate=0):<br/>    <br/>    length = len(array)</span><span id="66de" class="lv lw it mv b gy nd na l nb nc">    if length == 1:<br/>        return array</span><span id="97f0" class="lv lw it mv b gy nd na l nb nc">    if length == 2:<br/>        if array[0][coordinate] &gt; array[1][coordinate]:<br/>            return np.array([array[1], array[0]])<br/>        else:<br/>            return array<br/>    <br/>    elif length &gt; 2:<br/>        array_l = array[:length//2]<br/>        array_r = array[length//2:]<br/>        array_l_sorted = <strong class="mv iu">merge_sort</strong>(array_l, coordinate)<br/>        array_r_sorted = <strong class="mv iu">merge_sort</strong>(array_r, coordinate)<br/>        <br/>        l_length = len(array_l)<br/>        r_length = len(array_r)</span><span id="c9f3" class="lv lw it mv b gy nd na l nb nc">        l = 0<br/>        r = 0<br/>        <br/>        sorted_list = []<br/>        <br/>        for i in range(length):<br/>            if r == r_length:<br/>                sorted_list.append(array_l_sorted[l])<br/>                l += 1</span><span id="592d" class="lv lw it mv b gy nd na l nb nc">            elif l == l_length:<br/>                sorted_list.append(array_r_sorted[r])<br/>                r += 1             <br/>                <br/>            elif array_l_sorted[l][coordinate] &gt; array_r_sorted[r][coordinate]:<br/>                sorted_list.append(array_r_sorted[r])<br/>                r += 1<br/>                <br/>            elif array_l_sorted[l][coordinate] &lt; array_r_sorted[r][coordinate]:<br/>                sorted_list.append(array_l_sorted[l])<br/>                l += 1<br/>        <br/>        return np.array(sorted_list)</span></pre><h2 id="023c" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">分治法——寻找最接近的一对</h2><p id="b9bb" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">如上所述，我们的目标是写一个算法，以O(nlgn)的代价找到最近的一对点。使用分治算法，其递归步骤花费<em class="mt"> O(n) </em>每一步就足够了。该算法将阵列划分为子阵列，关键是看两个子阵列中最近的一对是否。</p><p id="7ef6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分裂征服算法按X坐标对数组进行排序，将排序后的数组一分为二，将该算法递归应用于子数组，并检查是否存在一个距离比子数组中的距离短的数组对。</p><pre class="lg lh li lj gt mu mv mw mx aw my bi"><span id="a50a" class="lv lw it mv b gy mz na l nb nc">def <strong class="mv iu">find_closest_nest</strong>(array):<br/>    X = <strong class="mv iu">merge_sort</strong>(array, 0)<br/>    length = len(X)<br/>    if length &lt; 4:<br/>        return <strong class="mv iu">find_closest_brute_force</strong>(array)<br/>    <br/>    else:<br/>        array_l = X[:length//2]<br/>        array_r = X[length//2:]</span><span id="43c8" class="lv lw it mv b gy nd na l nb nc">        dict_l = <strong class="mv iu">find_closest_nest</strong>(array_l)<br/>        dict_r = <strong class="mv iu">find_closest_nest</strong>(array_r)<br/>                    <br/>        if dict_l["distance"] &gt; dict_r["distance"]:<br/>            dict_both = dict_r<br/>        else:<br/>            dict_both = dict_l<br/>          <br/>        Y_list = []<br/>        for i in range(length):<br/>            if X[length//2-1][0]-dict_both["distance"] &lt; array[i][0] &lt; X[length//2-1][0]+dict_both["distance"]:<br/>                Y_list.append(array[i])</span><span id="b9f5" class="lv lw it mv b gy nd na l nb nc">        Y = <strong class="mv iu">merge_sort</strong>(np.array(Y_list), 1)<br/>      <br/>        <br/>        if len(Y) == 1:<br/>            dict_final = dict_both<br/>        elif len(Y) &lt; 8:<br/>            dict_y = <strong class="mv iu">find_closest_brute_force</strong>(Y)<br/>            if dict_both["distance"] &gt; dict_y["distance"]:<br/>                dict_final = dict_y<br/>            else:<br/>                dict_final = dict_both            <br/>        else:<br/>            for i in range(len(Y)-7):<br/>                dict_y = <strong class="mv iu">find_closest_brute_force</strong>(Y[i:i+7])        <br/>                <br/>                if dict_both["distance"] &gt; dict_y["distance"]:<br/>                    dict_final = dict_y<br/>                else:<br/>                    dict_final = dict_both<br/>    <br/>        return dict_final</span></pre><p id="b226" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一步，查看跨子阵列的对，需要一些技巧来将成本保持在线性水平(例如<em class="mt"> O(n) </em> ) <em class="mt">。</em>首先，我们将制作一个输入子集，它由距离X坐标中点<em class="mt"> d </em>距离内的点组成；<em class="mt"> d </em>是子阵列内的一对<strong class="kk iu">之间的最短距离。如果我们在子阵列上找到最近的一对点，这对点应该存在于距离将阵列分成子阵列的线的距离<em class="mt"> d </em>内。</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/8a7eecbc6c370969137451f3331a21c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*qJUNA6XLy4MtEw-k9rNMPg.png"/></div></figure><p id="4bfa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在右手侧所示的例子中，子阵列中最近的一对<strong class="kk iu">在右侧子阵列中确定(注意虚线上的点属于左侧子阵列)，其距离为<em class="mt"> d </em>。</strong></p><p id="4f98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果最接近的一对存在于左右子阵列中，那么这些点应该在从将阵列分成两个子阵列的虚线开始的<em class="mt"> d </em>的范围内。因此，我们可以查看阴影范围内的子集。</p><p id="9e64" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其次，我们通过Y坐标对上一步中获得的子集进行排序。我们表明，我们必须着眼于只有八个连续点的集合，每个在排序子集。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/42f5907a5a1b44237a8cd1f3d0c60faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*IFWYER3C7e2VNuipz6ysdw.png"/></div></figure><p id="1afe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如图所示，横跨左右子阵列的<em class="mt"> 2d* </em> d矩形中最多可以存在8个点(虚线上的点重复；两个属于左侧子阵列，另外两个在右侧)。</p><p id="f782" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三，我们查看按Y坐标排序的子集中的每组八个连续点。如果我们发现距离小于<em class="mt"> d </em>的一对，这意味着最近的一对存在于子阵列中。这一步开销<em class="mt"> O(n) </em>，这个递归算法的总开销停留在<em class="mt"> O(nlgn)。</em></p><h2 id="6c0e" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">性能检查</h2><p id="c2e0" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们了解到我们开发的分裂征服算法比暴力破解算法执行得更快。我们来比较两种算法的实际表现。在下面的图表中，两种算法的成本(执行时间)由不同大小的数组显示。这两条线清楚地表明，随着样本量的增加，分治法具有优势。这个结果证明了高效编码的重要性，这在上一篇文章中也讨论过。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ng"><img src="../Images/f3ac739474821776111050f65bb49356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1x0CT2gJqbDrFQOhwCtbA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">来源:作者的计算</p></figure></div></div>    
</body>
</html>