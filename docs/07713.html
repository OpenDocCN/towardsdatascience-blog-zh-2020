<html>
<head>
<title>Evaluating Clustering Results</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">评估聚类结果</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/evaluating-clustering-results-f13552ee7603?source=collection_archive---------21-----------------------#2020-06-09">https://towardsdatascience.com/evaluating-clustering-results-f13552ee7603?source=collection_archive---------21-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e51" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于评估聚类结果的标准</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/597a99c2263e0b5a8bef501452fb5c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qh9vrRET763DqIEwF0ufEg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b432" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">聚类方法的主要目标是获得高的类内相似性和低的类间相似性(同一类中的对象比不同类中的对象更相似)。在我关于<a class="ae lu" rel="noopener" target="_blank" href="/metagenomics-who-is-there-and-what-are-they-doing-9f204342eed9">宏基因组学</a>宁滨分析的工作中，我一直在使用不同的聚类方法，在这篇文章中，我想分享一些我的想法和我使用的技术。</p><h1 id="96d4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">聚类分析(聚类)</h1><p id="15be" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">根据<a class="ae lu" href="https://en.wikipedia.org/wiki/Cluster_analysis" rel="noopener ugc nofollow" target="_blank">维基百科</a>，</p><blockquote class="ms"><p id="a723" class="mt mu it bd mv mw mx my mz na nb lt dk translated"><strong class="ak">聚类分析</strong>或<strong class="ak">聚类</strong>是对一组对象进行分组的任务，使同一组中的对象(称为<strong class="ak">聚类</strong>)比其他组(聚类)中的对象彼此更加相似(在某种意义上)。</p></blockquote><p id="896a" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">我希望你熟悉分类中使用的术语，如TP、TN、FP、FN、准确度、精确度、召回率和F1分数。我不会深入这些条款的细节。如果你想回顾一下，我发现下面的文章非常有用。</p><ol class=""><li id="a4c1" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/accuracy-recall-precision-f-score-specificity-which-to-optimize-on-867d3f11124">准确度、召回率、精确度、F值&amp;特异性，在</a>上进行优化</li><li id="2795" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/accuracy-precision-recall-or-f1-331fb37c5cb9">准确度、精密度、召回率还是F1？</a></li><li id="96ee" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/beyond-accuracy-precision-and-recall-3da06bea9f6c">超越准确度:精确度和召回率</a></li></ol><h1 id="e3bf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">评估聚类结果时遇到的问题</h1><p id="cc39" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在我分析的一些案例中，聚类方法无法找到黄金标准中的正确聚类数。一些方法高估了聚类的数量，而另一些方法低估了聚类的数量。在这种情况下，我们不能使用用于分析分类结果的标准标准，因为分类结果的数量与黄金标准中的分类数量相同。</p><p id="0fc8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在浏览了我所在领域的相关文献后，我发现了一些标准，这些标准适用于我之前讨论过的情况。让我们看看如何继续我们的评估。</p><h1 id="8aad" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">评定标准</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/dc6ca4b6da7eab35444a89a9766a2dd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gkcc4TPf3__WuPpwmM6sqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。K x S矩阵(图片由作者提供)</p></figure><p id="be55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">聚类结果表示为一个<code class="fe nw nx ny nz b">K x S</code>矩阵，如图1所示，其中<code class="fe nw nx ny nz b">K</code>是聚类方法预测的聚类数，<code class="fe nw nx ny nz b">S</code>是黄金标准中存在的类数。</p><p id="1a9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，元素<strong class="la iu"> aₖₛ </strong>表示聚集到<strong class="la iu"> kᵗʰ </strong>集群的对象总数，并且属于黄金标准中的<strong class="la iu"> sᵗʰ </strong>类。</p><p id="f705" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在理想情况下，<code class="fe nw nx ny nz b">K = S</code>其中通过聚类方法预测的类的数量与黄金标准中存在的类的数量相同。但是，在某些情况下，<code class="fe nw nx ny nz b">K &lt; S</code>或<code class="fe nw nx ny nz b">K &gt; S</code>聚类方法预测的聚类数不等于黄金标准中存在的类别数。</p><p id="95e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用这个矩阵，我们可以找到以下标准。</p><ol class=""><li id="30d5" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">精确</li><li id="7d46" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">回忆</li><li id="7f3b" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">f1-分数</li><li id="6bc5" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">调整后的兰德指数</li></ol><h2 id="4b36" class="oa lw it bd lx ob oc dn mb od oe dp mf lh of og mh ll oh oi mj lp oj ok ml ol bi translated">精确</h2><p id="78e8" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">对于每个集群，我们都获得了分配了最大数量对象的黄金标准类。然后，我们对每个集群的最大对象数求和，并除以集群对象的总数。得到的值是<strong class="la iu"> <em class="om">精度</em> </strong> <em class="om"> </em>并使用<code class="fe nw nx ny nz b">K x S</code>矩阵，其计算如图2所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/7ef1867772677ed48d4a4e84bddb4e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gjTmKveajrc1eL71UTzYDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。精度方程(图片由作者提供)</p></figure><h2 id="5c47" class="oa lw it bd lx ob oc dn mb od oe dp mf lh of og mh ll oh oi mj lp oj ok ml ol bi translated">回忆</h2><p id="9f66" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">对于每个黄金标准类，我们获得分配了最大数量对象的聚类。然后，我们对每个黄金标准类的最大对象数求和，并除以集群对象和非集群对象的总数。得到的值就是<strong class="la iu"><em class="om"/></strong>(也叫<strong class="la iu"><em class="om"/></strong>)并利用<code class="fe nw nx ny nz b">K x S</code>矩阵，计算出来如图3所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/6f3d316f697c30710ca6149f8937fe9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*786IFcnmxmG-oFGEgaqZyg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3。回忆方程式(图片由作者提供)</p></figure><p id="bcb0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里<code class="fe nw nx ny nz b">U</code>表示未聚类对象的数量。</p><h2 id="3bce" class="oa lw it bd lx ob oc dn mb od oe dp mf lh of og mh ll oh oi mj lp oj ok ml ol bi translated">f1-分数</h2><p id="d070" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><strong class="la iu"><em class="om">-得分</em> </strong> <em class="om"> </em>是<strong class="la iu"> <em class="om">精度</em></strong><em class="om"/><strong class="la iu"><em class="om">召回</em> </strong>的调和平均值，计算方法如图4所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/d7a935f585be3f46beb074e3c32095c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqjaRmwOVPBcKZKc638-1Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4。F1分数等式(图片由作者提供)</p></figure><h2 id="0f8d" class="oa lw it bd lx ob oc dn mb od oe dp mf lh of og mh ll oh oi mj lp oj ok ml ol bi translated">调整后的兰德指数</h2><p id="0ddf" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><em class="om">调整后的兰德指数(ARI) </em>是<strong class="la iu"> <em class="om">兰德指数(RI) </em> </strong>的机会修正版。这是对聚类结果与其黄金标准分组相似程度的度量。使用<code class="fe nw nx ny nz b">K x S</code>矩阵，ARI的计算如图5所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/95d2ceaf1f9eb03847866712a27c1c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TB-8Rc_0vNQZOTVTr9BOcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5。ARI方程(图片由作者提供)</p></figure><p id="422d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里<code class="fe nw nx ny nz b">N</code>表示聚类对象的总数，并且<code class="fe nw nx ny nz b">(N 2)</code>(二项式系数)被计算为<code class="fe nw nx ny nz b">N(N-1)/2</code>。</p><h1 id="9209" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">示例演练</h1><p id="f7da" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">让我们看一个例子，我们将为给定的聚类结果计算不同的评估标准。假设金本位中有<strong class="la iu"> 257 </strong>个对象，我们知道每个对象的类别。</p><h2 id="7203" class="oa lw it bd lx ob oc dn mb od oe dp mf lh of og mh ll oh oi mj lp oj ok ml ol bi translated">情况1: K=S</h2><p id="3854" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">让我们假设一个理想的情况，其中我们在黄金标准中有5个类别，并且通过聚类方法预测了5个聚类。我们可以得到一个如下图所示的<code class="fe nw nx ny nz b">K x S</code>矩阵。</p><pre class="kj kk kl km gt or nz os ot aw ou bi"><span id="3374" class="oa lw it nz b gy ov ow l ox oy">64, 4, 1, 5, 0<br/>2, 37, 1, 6, 0<br/>0, 0, 44, 0, 0<br/>1, 1, 0, 72, 0<br/>0, 0, 0, 0, 9</span></pre><p id="bba9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们参照图1，行代表集群，列代表类。聚类到第一个聚类并属于黄金标准中的第一类(第一行和第一列的交叉点)的对象的数量是64。类似地，聚类到第一聚类并属于黄金标准中的第二类(第一行和第二列的交叉点)的对象的数量是4。</p><p id="760f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，每行和每列(64、37、44、72和9)的最大值可以在对角线中找到，这告诉我们第一个聚类对应于黄金标准中的第一类，第二个聚类对应于黄金标准中的第二类，依此类推。</p><p id="b485" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">聚集的对象总数将是<strong class="la iu"> 247 </strong>。</p><pre class="kj kk kl km gt or nz os ot aw ou bi"><span id="86a4" class="oa lw it nz b gy ov ow l ox oy">Total number of objects clustered <br/>=64+4+1+5+2+37+1+6+44+1+1+72+9<br/>=247</span></pre><p id="30f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">未聚类对象的数量将为<strong class="la iu"> 10 </strong>。</p><pre class="kj kk kl km gt or nz os ot aw ou bi"><span id="7941" class="oa lw it nz b gy ov ow l ox oy">Total number of unclustered objects<br/>=25<!-- -->7-<!-- -->247<br/>=10</span></pre><p id="d36f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们使用这个矩阵来计算精确度、召回率和F1值。</p><pre class="kj kk kl km gt or nz os ot aw ou bi"><span id="1288" class="oa lw it nz b gy ov ow l ox oy">Precision<br/>=(64+37+44+72+9)/(64+4+1+5+2+37+1+6+44+1+1+72+9)<br/>=91.50%</span><span id="d078" class="oa lw it nz b gy oz ow l ox oy">Recall<br/>=(64+37+44+72+9)/(64+4+1+5+2+37+1+6+44+1+1+72+9+10)<br/>=87.94%</span><span id="41e9" class="oa lw it nz b gy oz ow l ox oy">F1-score<br/>=2*(91.50*87.94)/(91.50+87.94)<br/>=89.68%</span></pre><h2 id="2db7" class="oa lw it bd lx ob oc dn mb od oe dp mf lh of og mh ll oh oi mj lp oj ok ml ol bi translated">案例2: K <s/></h2><p id="fff4" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">Let us assume a case where we have 5 classes in the gold standard and 4 clusters are predicted by the clustering method. We can see that two clusters have been combined (the third row with 44 and 9).</p><pre class="kj kk kl km gt or nz os ot aw ou bi"><span id="e81f" class="oa lw it nz b gy ov ow l ox oy">64, 4, 1, 5, 0<br/>2, 37, 1, 6, 0<br/>0, 0, 44, 0, 9<br/>1, 1, 0, 72, 0</span><span id="8b69" class="oa lw it nz b gy oz ow l ox oy">Total number clustered = 64+4+1+5+2+37+1+6+44+9+1+1+72 = 247<br/>Total number unclustered = 2<!-- -->57-<!-- -->247 = 10</span></pre><p id="0395" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Now, let us calculate the precision, recall and F1-score using this matrix.</p><pre class="kj kk kl km gt or nz os ot aw ou bi"><span id="f6d9" class="oa lw it nz b gy ov ow l ox oy">Precision<br/>=(64+37+44+72)/(64+4+1+5+2+37+1+6+44+9+1+1+72)<br/>=87.85%</span><span id="dfce" class="oa lw it nz b gy oz ow l ox oy">Recall<br/>=(64+37+44+72+9)/(64+4+1+5+2+37+1+6+44+9+1+1+72+10)<br/>=87.94%</span><span id="d877" class="oa lw it nz b gy oz ow l ox oy">F1-score<br/>=2*(87.85*87.94)/(87.85+87.94)<br/>=87.89%</span></pre><h2 id="dce7" class="oa lw it bd lx ob oc dn mb od oe dp mf lh of og mh ll oh oi mj lp oj ok ml ol bi translated">Case 3: K&gt; S</h2><p id="3dd4" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">让我们假设一种情况，其中我们在黄金标准中有5个类别，并且通过聚类方法预测了6个聚类。我们可以看到一个集群被拆分(第三行和第四行分别为24和20)。</p><pre class="kj kk kl km gt or nz os ot aw ou bi"><span id="db35" class="oa lw it nz b gy ov ow l ox oy">64, 4, 1, 5, 0<br/>2, 37, 1, 6, 0<br/>0, 0, 24, 0, 0<br/>0, 0, 20, 0, 0<br/>1, 1, 0, 72, 0<br/>0, 0, 0, 0, 9</span><span id="0ca2" class="oa lw it nz b gy oz ow l ox oy">Total number clustered = 64+4+1+5+2+37+1+6+24+20+1+1+72+9 = 247<br/>Total number unclustered = 2<!-- -->57-<!-- -->247 = 10</span></pre><p id="8ec6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们使用这个矩阵来计算精确度、召回率和F1值。</p><pre class="kj kk kl km gt or nz os ot aw ou bi"><span id="24ec" class="oa lw it nz b gy ov ow l ox oy">Precision<br/>=(64+37+24+20+72+9)/(64+4+1+5+2+37+1+6+24+20+1+1+72+9)<br/>=91.50%</span><span id="0da7" class="oa lw it nz b gy oz ow l ox oy">Recall<br/>=(64+37+24+72+9)/(64+4+1+5+2+37+1+6+24+20+1+1+72+9+10)<br/>=80.16%</span><span id="becb" class="oa lw it nz b gy oz ow l ox oy">F1-score<br/>=2*(91.50*80.16)/(91.50+80.16)<br/>=85.46%</span></pre><h1 id="1943" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">分析</h1><p id="e591" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">让我们仔细检查一下从每个示例案例中获得的值，如图6所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/6a5aa94236d1824195239ad9f5276312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5utWaH4nPQ-iez3DjfExiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6。精确度、召回率和F1分数值(图片由作者提供)</p></figure><p id="4980" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，如果聚类方法低估了聚类的数量(情况<code class="fe nw nx ny nz b">K&lt;S</code>)，即将聚类组合在一起，并且这些聚类将包含多个黄金标准类，则精度会降低，但召回率仍与理想情况相同。这是因为，对于组合仓，在行(44)中将只考虑最大值。</p><p id="5c9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，如果聚类方法高估了聚类的数量(案例<code class="fe nw nx ny nz b">K&gt;S</code>)，即分割实际聚类，黄金标准类由多个聚类表示，则召回率会降低，但精度仍与理想情况相同。这是因为，对于分离的箱，在列(24)中将只考虑最大值。</p><p id="0881" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nw nx ny nz b">K&lt;S</code>和<code class="fe nw nx ny nz b">K&gt;S</code>两种情况下，F1分数随着精确度或召回率的降低而降低。</p><p id="7335" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，我们可以看到，随着聚类方法预测的聚类数的增加，精确度增加，而召回率减少。</p><h1 id="03ab" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结束想法</h1><p id="6672" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我希望这篇文章对你的学习或研究工作有用。</p><p id="dd97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在下面附上了一个简单的脚本，你可以输入聚类结果和黄金标准，并获得精度，召回，F1分数和ARI值。这个脚本接收2个<code class="fe nw nx ny nz b">.csv</code>文件；一个用于聚类结果，另一个用于金标准。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="d91c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用命令运行这个脚本，</p><pre class="kj kk kl km gt or nz os ot aw ou bi"><span id="3c29" class="oa lw it nz b gy ov ow l ox oy">python evaluate.py --clustered clustering_result.csv --goldstandard gold_standard.csv</span></pre><p id="c373" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里clustering_result.csv和gold_standard.csv应该是<code class="fe nw nx ny nz b">object_id,cluster_id</code>的格式。将打印精确度、召回率、F1分数和ARI值。</p><p id="9f46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读！</p><p id="647e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯！</p><h1 id="b3e8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><p id="4499" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">[1] MetaCluster 5.0:一种用于噪声样本中低丰度物种的宏基因组数据的两轮宁滨方法。王<em class="om">等人。al </em>。生物信息学，第28卷，第18期，2012年9月15日，i356–i362页，DOI:<a class="ae lu" href="https://doi.org/10.1093/bioinformatics/bts397" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1093/bioinformatics/bts397</a></p><p id="0c9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[2]宁滨宏基因组重叠群的覆盖范围和组成。阿尔内贝格<em class="om"> et。艾尔。</em>《自然方法》2014年第11卷，第1144-1146页，土井:<a class="ae lu" href="https://doi.org/10.1038/nmeth.3103" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1038/nmeth.3103</a></p><p id="0880" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[3]使用dS2寡核苷酸频率相异度改善宏基因组数据的重叠群宁滨。王等人。艾尔。 BMC生物信息学18(425)，2017，DOI:<a class="ae lu" href="https://doi.org/10.1186/s12859-017-1835-1" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1186/s12859-017-1835-1</a></p><p id="4707" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[4] GraphBin:使用组装图的宏基因组重叠群的精细宁滨。Mallawaarachchi等人。艾尔。生物信息学，第36卷，第11期，2020年6月，第3307-3313页，DOI:<a class="ae lu" href="https://doi.org/10.1093/bioinformatics/btaa180" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1093/bioinformatics/btaa180</a></p></div></div>    
</body>
</html>