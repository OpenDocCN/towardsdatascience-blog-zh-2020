<html>
<head>
<title>Solving non-linear problems with genetic algorithms (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用遗传算法解决非线性问题(下)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solving-non-linear-problems-with-genetic-algorithms-part-2-f4ad33fd813a?source=collection_archive---------82-----------------------#2020-05-18">https://towardsdatascience.com/solving-non-linear-problems-with-genetic-algorithms-part-2-f4ad33fd813a?source=collection_archive---------82-----------------------#2020-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c028" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在这一系列文章中，探索遗传算法(也称为进化算法)如何帮助您解决非线性问题！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/24fd74752a977efac7b362f59d2fc804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aW6kEF9EFe9VG9gHFERpQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">乔尔·菲利普在<a class="ae kv" href="https://unsplash.com/s/photos/geometry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2ece" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本系列的第一部分(<a class="ae kv" href="https://medium.com/@pl.bescond/solving-non-linear-problems-with-genetic-algorithms-part-1-381702b0140e" rel="noopener">这里是</a>)，我介绍了优化非线性问题的问题，这些问题是不可微的，标准的优化库对这些问题没有用。</p><p id="c10b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你熟悉遗传算法，你就会知道它们通过保留最适应环境的个体来模仿自然选择过程。</p><blockquote class="ls lt lu"><p id="8db6" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">在我将在这些文章中使用的示例中，这可以翻译如下:<strong class="ky ir">个体特征</strong>(为每个特征设置的值的组合)<strong class="ky ir">与环境</strong>(非线性模型)<strong class="ky ir">交互，环境决定了个体的命运</strong>(回归结果离目标越近，生存的机会就越高！)</p></blockquote><p id="760e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先探索了一种非常简单的方法，包括将尽可能多的解决方案(=个体)应用于非线性模型，并挑选出最佳方案。</p><p id="be2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，随着特征数量和模型复杂程度的增加，这种方法可能需要大量的计算能力和时间。</p><p id="631b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们进入排列和突变(这是使用的传统方法)之前，我想提供一个我正在使用的具有良好效果的替代技术。</p><blockquote class="ls lt lu"><p id="c850" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">但是，请记住，我使用这种优化技术来解决行业建模问题，它可能(很可能)在其他领域失败。</p></blockquote><p id="7168" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将稍微改变最初的方法，通过逐渐减少探索的领域来最大化潜在解决方案的数量。</p><p id="8068" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用一个单一的特性来解释基本思想:X1:</p><p id="b22f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该特征的初始范围对应于最小-最大观察范围。所以，如果X1在30和50之间变化，我们应该创造具有相同特征的个体。</p><p id="5b11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，很可能X1的最佳值属于较小的范围。</p><p id="aea8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，考虑X1对应于一个温度，并且它对35到42之间的目标贡献最大。确切和最佳的温度将最终由其它生产参数和/或约束条件(流速、粘度等)来确定。).</p><p id="cd2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们选择原始观测宇宙，15个可能的X1值将是:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="8502" class="me mf iq ma b gy mg mh l mi mj">np.random.randint(30,51,15)</span><span id="f94a" class="me mf iq ma b gy mk mh l mi mj">[45, 50, 43, 38, 44, 35, 44, 41, 48, 45, 43, 33, 37, 43, 43]</span></pre><p id="f3a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而最明智的选择是:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="8acf" class="me mf iq ma b gy mg mh l mi mj">|np.random.randint(35,42,15)</span><span id="4d7d" class="me mf iq ma b gy mk mh l mi mj">[40, 40, 40, 35, 40, 36, 35, 35, 37, 36, 35, 36, 39, 38, 35]</span></pre><p id="2dfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们将建立一个算法，在每一个新的一代，将逐步缩小每个特征的探索范围，并保持生成的个体数量稳定。因此，我们将最大化获得具有最佳特征的个体的可能性。</p><p id="0260" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们直接进入代码吧！</p><p id="84a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在第一篇文章中所做的那样，我们将创建一个具有10个特征的回归示例，并在不微调任何超参数的情况下训练一个随机森林:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/09e527e01de6295c28228bed530e95a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DU1HOc_iMsQ9mfM6uiQ5bA.png"/></div></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="9eb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下函数将根据从上一个函数继承的特征(每个特征的最小-最大范围)和一些潜在的约束来创建新一代:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8f09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的函数将选择离目标最近的人:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="73e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们用定义数量的代创建整个过程(这里是5000，但是我们也可以在n次迭代之后停止该过程，而对个体没有任何改进)</p><p id="6bd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每一代将由100个个体组成；其中只有10个会把自己的特征传给下一个。</p><p id="b93d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次发现改进之处，我们都会强调出来。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="d01e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个过程的输出是:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="7bf2" class="me mf iq ma b gy mg mh l mi mj">Generation # / Distance from target<br/>0 : 3.5203594790711463<br/>1 : 0.17245788609726276<br/>2 : 0.021943158326713785<br/>5 : 0.013048357781954678<br/>8 : 0.004585642441860216<br/>20 : 0.0018902165603407184<br/>21 : 0.0000990125205220238<br/>88 : 0.00007448426300271649<br/>161 : 0.00005387409348855954<br/>164 : 0.000027555658107303316<br/>258 : 0.000009524267987615076<br/>284 : 0.0000043455700051708845</span></pre><p id="1dcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解与第一篇文章中描述的<a class="ae kv" href="https://medium.com/@pl.bescond/solving-non-linear-problems-with-genetic-algorithms-part-1-381702b0140e" rel="noopener">模型的区别，让我们比较它们的性能(第一列对应于创建的个体数量):</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/9811f10eed4eab9756afb0e4f2fe775c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skeI8kl1FLqrmpyLAMij2A.png"/></div></div></figure><p id="3e38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以清楚地看到，与以前的方法相比，这种新方法能够以更少的个体到达更小的目标距离！</p><p id="4550" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你是否热衷于探索其他方法来达到最佳解决方案？</p><p id="2b22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">跟随这一探索:</p><div class="mp mq gp gr mr ms"><a rel="noopener follow" target="_blank" href="/solving-non-linear-problems-with-genetic-algorithms-part-3-480347ca7d90"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">用遗传算法解决非线性问题(三)</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">在这一系列文章中，探索遗传算法(也称为进化算法)如何帮助您解决…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">towardsdatascience.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kp ms"/></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://pl-bescond.medium.com/pierre-louis-besconds-articles-on-medium-f6632a6895ad" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">皮埃尔-路易·贝斯康德关于媒介的文章</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">数据科学、机器学习和创新</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">pl-bescond.medium.com</p></div></div><div class="nb l"><div class="nh l nd ne nf nb ng kp ms"/></div></div></a></div></div></div>    
</body>
</html>