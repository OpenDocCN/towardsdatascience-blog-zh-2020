<html>
<head>
<title>How to Deploy a Pre-trained Keras Model with OpenCV and Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 OpenCV 和 Flask 部署预先训练好的 Keras 模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-deploy-a-pre-trained-keras-model-with-opencv-and-flask-86c9dab76a9c?source=collection_archive---------11-----------------------#2020-08-08">https://towardsdatascience.com/how-to-deploy-a-pre-trained-keras-model-with-opencv-and-flask-86c9dab76a9c?source=collection_archive---------11-----------------------#2020-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/889cde4269cd430584169ddc1a5b2b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ry19pGQLE9AWw82tau0gA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者照片</p></figure><p id="a645" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇文章中，我将分享如何使用 Flask、OpenCV 和 Keras 将预训练的模型部署到本地托管的计算机上。我最初使用 Flask、Keras 和 jquery 在 PythonAnywhere 上部署了这个模型。该应用程序是为要求学生或员工剃掉面部毛发的远程学校教室或工作场所设置而设计的。</p><p id="895b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该应用程序允许用户上传一张照片，然后点击一个按钮将带有编码图像数据的 post 请求发送到网站的后端。图像转换和分类在后端处理，结果在 html 响应中返回到前端。响应动态更新页面，如<code class="fe la lb lc ld b">Shaved</code>或<code class="fe la lb lc ld b">Unshaved</code>。</p><p id="360a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该应用程序的后端是在 Flask 中构建的，但我想允许一个实时视频流检测用户的面部，并在屏幕上标记分类。因为我已经有了一个模型和一个基本的 Flask 框架，所以我想在我的本地机器上使用 OpenCV 来完成剩下的工作。</p><p id="57d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你有一个模型，你可以遵循相同的格式，但如果你没有，我会推荐阅读我以前的博客文章(<a class="ae le" rel="noopener" target="_blank" href="/building-a-convolutional-neural-network-to-recognize-shaved-vs-unshaved-faces-cb96ea5bc0f0">建立一个卷积神经网络来识别剃毛与未剃毛的脸</a> &amp; <a class="ae le" rel="noopener" target="_blank" href="/how-to-spit-a-pickled-model-file-to-bypass-upload-limits-on-pythonanywhere-e051ea1cec2d">如何分割一个腌制的模型文件以绕过 PythonAnywhere 上的上传限制</a>)。</p><h1 id="0ab9" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">OpenCV</h1><blockquote class="md me mf"><p id="baee" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated"><em class="iq"> OpenCV(开源计算机视觉库)是一个开源的计算机视觉和机器学习软件库。OpenCV 旨在为计算机视觉应用提供一个公共基础设施，并加速机器感知在商业产品中的应用。</em></p><p id="fe75" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated"><a class="ae le" href="https://opencv.org/about/" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://opencv.org/about/</em></a></p></blockquote><p id="1690" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在阅读文档，观看 YouTube 视频和阅读博客帖子后，我发现了一篇非常有帮助的文章，<a class="ae le" rel="noopener" target="_blank" href="/covid-19-face-mask-detection-using-tensorflow-and-opencv-702dd833515b">新冠肺炎:使用 TensorFlow 和 OpenCV </a>的人脸面具检测，作者<a class="ae le" href="https://towardsdatascience.com/@mk.gurucharan?source=post_page-----702dd833515b----------------------" rel="noopener" target="_blank"> Gurucharan M K </a>。虽然 Gurucharan 使用 OpenCV 来检测新冠肺炎的面具，但我想先使用类似的格式来检测 a 是否有脸，然后确定该脸是否被剃掉。</p><p id="1b5d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对我的难题最有帮助的部分是首先检测人脸，这是通过使用人脸检测程序<strong class="ke ir"> <em class="mg">基于 Haar 特征的级联分类器</em> </strong>来检测人脸特征来完成的。</p><pre class="mk ml mm mn gt mo ld mp mq aw mr bi"><span id="cd93" class="ms lg iq ld b gy mt mu l mv mw">face_classifier = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')</span></pre><blockquote class="md me mf"><p id="acbf" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated"><strong class="ke ir"><em class="iq">Haar Cascade</em></strong><em class="iq">是一种</em> <strong class="ke ir"> <em class="iq">机器学习</em> </strong> <em class="iq">对象检测算法，用于识别图像或视频中的对象，基于 Paul Viola 和 Michael Jones 在 2001 年发表的论文《使用简单特征的快速对象检测</em><strong class="ke ir"><em class="iq">Cascade</em></strong><em class="iq">中提出的特征概念</em></p><p id="9514" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated"><a class="ae le" href="http://www.willberger.org/cascade-haar-explained/" rel="noopener ugc nofollow" target="_blank"><em class="iq">http://www.willberger.org/cascade-haar-explained/</em></a></p></blockquote><p id="cea3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">视频捕捉</strong></p><pre class="mk ml mm mn gt mo ld mp mq aw mr bi"><span id="0000" class="ms lg iq ld b gy mt mu l mv mw">video = cv2.VideoCapture(0)</span></pre><p id="10a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">停止视频</strong></p><pre class="mk ml mm mn gt mo ld mp mq aw mr bi"><span id="be69" class="ms lg iq ld b gy mt mu l mv mw">video.release()</span></pre><p id="4fc2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">显示视频</strong></p><pre class="mk ml mm mn gt mo ld mp mq aw mr bi"><span id="1a20" class="ms lg iq ld b gy mt mu l mv mw">(rval, im) =video.read()</span></pre><p id="a4af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">翻转视频</strong></p><pre class="mk ml mm mn gt mo ld mp mq aw mr bi"><span id="ef95" class="ms lg iq ld b gy mt mu l mv mw">im = cv2.flip(im, 1, 1)</span></pre><p id="6eb7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">调整视频大小</strong></p><pre class="mk ml mm mn gt mo ld mp mq aw mr bi"><span id="6ffa" class="ms lg iq ld b gy mt mu l mv mw">mini = cv2.resize(im, (im.shape[1] // 4, im.shape[0] // 4))</span></pre><p id="bc8a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">检测人脸</strong></p><pre class="mk ml mm mn gt mo ld mp mq aw mr bi"><span id="7142" class="ms lg iq ld b gy mt mu l mv mw">faces = face_classifier.detectMultiScale(mini)</span></pre><h1 id="0b46" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">瓶</h1><p id="4a30" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated">Flask 是一个用 Python 编写的微型 web 框架。它被归类为微框架，因为它不需要特殊的工具或库。它没有数据库抽象层、表单验证或任何其他组件，而现有的第三方库提供了通用功能。</p><p id="b262" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">安摩尔·贝尔有一篇写得很好的文章，题为“使用 Flask 和 OpenCV 的视频流”。根据这篇文章，我能够构建一个 html 网页模板，以及使用计算机内置摄像头将每帧预测的视频流传输到浏览器所需的路径。</p><p id="8d65" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">html 页面类似于我之前构建的页面，没有 jquery。</p><p id="f101" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是我用来显示主页的简单代码:</p><pre class="mk ml mm mn gt mo ld mp mq aw mr bi"><span id="54d3" class="ms lg iq ld b gy mt mu l mv mw">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Shaved or Not_Shaved &lt;/title&gt;&lt;/head&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;center&gt;&lt;h1&gt;Shaved or Not_Shaved Streaming App Demo&lt;/h1&gt;&lt;/center&gt;<br/>    &lt;center&gt;&lt;img id="bg" src="{{ url_for('video_feed') }}"&gt;&lt;/center&gt;<br/>    &lt;video id="video" autoplay&gt;Video Stream not available.&lt;/video&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="bb64" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了构建路线，我使用了以下代码来处理页面何时被加载，以及从我们的<code class="fe la lb lc ld b">camera.py</code>文件中提取的摄像机图像，该文件在网站被加载时被初始化。</p><p id="d80b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以下是我在<code class="fe la lb lc ld b">main.py</code>文件中使用的烧瓶代码:</p><pre class="mk ml mm mn gt mo ld mp mq aw mr bi"><span id="e330" class="ms lg iq ld b gy mt mu l mv mw">from flask import Flask, render_template, Response<br/>from camera import VideoCamera</span><span id="9995" class="ms lg iq ld b gy nc mu l mv mw">import os<br/>os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'<br/>app = Flask(__name__)</span><span id="52f2" class="ms lg iq ld b gy nc mu l mv mw">@app.route('/')<br/>def index():<br/>    # rendering webpage<br/>    return render_template('index.html')</span><span id="30a2" class="ms lg iq ld b gy nc mu l mv mw">def gen(camera):<br/>    while True:<br/>        #get camera frame<br/>        frame = camera.get_frame()<br/>        yield (b'--frame\r\n'<br/>               b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n\r\n')</span><span id="a29f" class="ms lg iq ld b gy nc mu l mv mw">@app.route('/video_feed')<br/>def video_feed():<br/>    return Response(gen(VideoCamera()),<br/>                    mimetype='multipart/x-mixed-replace; boundary=frame')<br/>if __name__ == '__main__':<br/>    # defining server ip address and port<br/>    app.run(host='0.0.0.0',port='5000', debug=True)</span></pre><h1 id="67f8" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">克拉斯</h1><blockquote class="md me mf"><p id="0d88" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated"><em class="iq"> Keras 是用 Python 编写的深度学习 API，运行在机器学习平台</em><a class="ae le" href="https://github.com/tensorflow/tensorflow" rel="noopener ugc nofollow" target="_blank"><em class="iq">tensor flow</em></a><em class="iq">之上。它的开发重点是支持快速实验。能够尽快从想法到结果是做好研究的关键。</em></p><p id="c108" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">【https://keras.io/about/】T5<a class="ae le" href="https://keras.io/about/" rel="noopener ugc nofollow" target="_blank">T6</a></p></blockquote><p id="7cad" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于 Keras 运行在 TensorFlow 之上，我们可以利用 TensorFlow 模块中的 Graph 和 Session 方法。虽然图和会话的细节超出了本文的范围，但是在部署您的模型以便在预定的会话期间可以访问时，您仍然可以使用下面的代码。</p><pre class="mk ml mm mn gt mo ld mp mq aw mr bi"><span id="01ca" class="ms lg iq ld b gy mt mu l mv mw">import pickle<br/>from keras import backend as K<br/>from tensorflow import Graph, Session</span><span id="b706" class="ms lg iq ld b gy nc mu l mv mw">global loaded_model<br/>graph1 = Graph()<br/>with graph1.as_default():<br/>	session1 = Session(graph=graph1)<br/>	with session1.as_default():<br/>		loaded_model = pickle.load(open('Combined_Model.p', 'rb'))</span></pre><h1 id="157d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">把这一切结合在一起。</h1><p id="c6d9" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated">最后一块是我们的<code class="fe la lb lc ld b">camera.py</code>文件。在这个例子中，我们的文件将包含一个函数，将我们的分割模型合并到一个 pickle 文件中。当应用程序加载时，我们将使用一个类摄像机来初始化相机，并将人脸检测程序与我们预先训练的 Keras 模型相结合。</p><pre class="mk ml mm mn gt mo ld mp mq aw mr bi"><span id="c66a" class="ms lg iq ld b gy mt mu l mv mw">import cv2<br/>import numpy as np<br/>import pickle<br/>from keras import backend as K<br/>from tensorflow import Graph, Session</span><span id="4777" class="ms lg iq ld b gy nc mu l mv mw"># defining face detector<br/>classifier=cv2.CascadeClassifier('haarcascade_frontalface_default.xml')</span><span id="c26c" class="ms lg iq ld b gy nc mu l mv mw">size = 4</span><span id="5956" class="ms lg iq ld b gy nc mu l mv mw">labels_dict={0:'shaved',1:'not_shaved'}</span><span id="5220" class="ms lg iq ld b gy nc mu l mv mw">color_dict={0:(0,255,0),1:(0,0,255)}</span><span id="ab9b" class="ms lg iq ld b gy nc mu l mv mw">global loaded_model<br/>graph1 = Graph()<br/>with graph1.as_default():<br/>	session1 = Session(graph=graph1)<br/>	with session1.as_default():<br/>		loaded_model = pickle.load(open('Combined_Model.p', 'rb'))</span><span id="e7ed" class="ms lg iq ld b gy nc mu l mv mw">class VideoCamera(object):<br/>    def __init__(self):<br/>        # capturing video<br/>        self.video = cv2.VideoCapture(0)</span><span id="6291" class="ms lg iq ld b gy nc mu l mv mw">    def __del__(self):<br/>        # releasing camera<br/>        self.video.release()<br/></span><span id="f34c" class="ms lg iq ld b gy nc mu l mv mw">    def get_frame(self):<br/>        # extracting frames<br/>        (rval, im) = self.video.read()<br/>        im = cv2.flip(im, 1, 1)<br/>        mini = cv2.resize(im, (im.shape[1] // size, im.shape[0] // size))<br/>        faces = classifier.detectMultiScale(mini)<br/>        for f in faces:<br/>            (x, y, w, h) = [v * size for v in f] #Scale the shapesize backup<br/>            #Save just the rectangle faces in SubRecFaces<br/>            face_img = im[y:y+h, x:x+w]<br/>            resized=cv2.resize(face_img,(300,300))<br/>            normalized=resized/255.0<br/>            reshaped=np.reshape(normalized,(1,300,300,3))<br/>            reshaped = np.vstack([reshaped])<br/>            K.set_session(session1)<br/>            with graph1.as_default():<br/>                results=loaded_model.predict(reshaped)<br/>            if results &gt;.5:<br/>                result = np.array([[1]])<br/>            else:<br/>                result = np.array([[0]])<br/>            label = np.argmax(result)<br/>            cv2.rectangle(im,(x,y),(x+w,y+h),color_dict[result[label][0]],2)<br/>            cv2.rectangle(im,(x,y-40),(x+w,y),color_dict[result[label][0]],-1)<br/>            cv2.putText(im, labels_dict[result[label][0]], (x, y-10),cv2.FONT_HERSHEY_SIMPLEX,0.8,(255,255,255),2)<br/>            # encode OpenCV raw frame to jpg and displaying it<br/>        ret, jpeg = cv2.imencode('.jpg', im)<br/>        return jpeg.tobytes()</span></pre><p id="e1d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，此应用程序仅限于您的本地计算机。希望这篇文章有帮助。我很乐意使用<code class="fe la lb lc ld b">Node.js</code>、<code class="fe la lb lc ld b">Tensorflow.js</code>和<code class="fe la lb lc ld b">OpenCV.js</code>公开部署这个模型，但是这超出了本文的范围。如果我得到 100 条评论，我会把它作为我的下一篇文章！</p><h1 id="2948" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">以下是我的 GitHub 回购的链接:</h1><p id="4437" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated"><a class="ae le" href="https://github.com/cousinskeeta/shavedVnotShaved_opencv" rel="noopener ugc nofollow" target="_blank">https://github.com/cousinskeeta/shavedVnotShaved_opencv</a></p><h1 id="dd0b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">资源:</h1><p id="ad72" class="pw-post-body-paragraph kc kd iq ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz ij bi translated"><a class="ae le" rel="noopener" target="_blank" href="/covid-19-face-mask-detection-using-tensorflow-and-opencv-702dd833515b">新冠肺炎:Gurucharan M K<a class="ae le" href="https://towardsdatascience.com/@mk.gurucharan?source=post_page-----702dd833515b----------------------" rel="noopener" target="_blank">使用 TensorFlow 和 OpenCV </a>的人脸面具检测</a></p><p id="bd18" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae le" href="https://medium.com/datadriveninvestor/video-streaming-using-flask-and-opencv-c464bf8473d6" rel="noopener">Anmol Behl</a>使用 Flask 和 OpenCV 进行视频流传输</p></div></div>    
</body>
</html>