<html>
<head>
<title>Implementing a Connected Component Labeling algorithm from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始实现连通分量标记算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-a-connected-component-labeling-algorithm-from-scratch-94e1636554f?source=collection_archive---------9-----------------------#2020-03-29">https://towardsdatascience.com/implementing-a-connected-component-labeling-algorithm-from-scratch-94e1636554f?source=collection_archive---------9-----------------------#2020-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ea03" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我将向你展示如何在MATLAB中实现这个算法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c6b5faef65534cbbba5f3f252f484307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XKUUfeTjaNQp1-cg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Guillaume Bourdages 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="e4c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">目录</strong></p><ul class=""><li id="9c50" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">什么是连通分量标记？</li><li id="6ebf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">一个例子的可视化</li><li id="a990" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">MATLAB中的代码</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="561e" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">什么是连通分量标记？</h1><p id="8744" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">这是一种计算机视觉算法，用于检测和计数二进制图像中相连区域的数量，也称为斑点。通常，这是在分割算法之后完成的。得到的分割(二进制)掩模然后通过连通分量标记算法运行，以计算不同区域的数量。</p><h2 id="82da" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak">目标</strong></h2><p id="0f04" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">该算法的输入是二值图像。目标是用相同的唯一标签标记每个连接的组件(或blob)。因为每个斑点都会被标记，所以我们可以推断出单个斑点的总数。需要注意的是，输出会因您使用的表示/连接而有所不同。</p><h2 id="5f9c" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak">不同的连接性</strong></h2><p id="9eff" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">有两种常见的方法来定义组件是否连接。一种是说一个像素只有4个邻居(有时称为4-连通性)。另一种是说明一个像素有8个邻居。参见图1。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/30ec690c87c114f536369cda7ea3472a.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*uAp5oSVEKTIVTVRPq3RVqw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图一。左图:4邻居表示法。右图:8邻居表示法。</p></figure><h2 id="7cf7" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak">样品</strong></h2><p id="43db" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">让我们看一个这个算法做什么的例子。注意两种表示之间的不同结果(图2和图3)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/4d14f8e103f3a2c4c7038ff6d26cc5ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKsIVqh6j1dHo5-gob9EZQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。假设采用<strong class="bd ny">4-连通性</strong>表示的算法结果。在这种情况下,“2”不是“3”的邻居。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/6075086b10620f1f51d48008f0c0f31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fccJzfWX8ii2kXqtPuwFcw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3。假设一个<strong class="bd ny">8-连通性</strong>表示的算法的结果。“2”是邻居。</p></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="cbf0" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak">算法是如何工作的？</strong></h2><p id="7782" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">该算法包括两次通过图像中的每个像素。</p><p id="6479" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第一遍:</strong></p><p id="cc0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每个非零像素，我们检查它的邻居。</p><ul class=""><li id="dd6c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如果它没有非零邻居——我们知道它是一个新组件——那么我们给它一个新标签。</li><li id="e4e5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果它有一个非零邻居——这些像素是相连的——我们给它与邻居相同的标签。</li><li id="a614" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果它有不止一个非零邻居，有两种情况:</li></ul><ol class=""><li id="65a9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nz ly lz ma bi translated">邻居都有相同的标签。所以我们给当前像素同样的标签。</li><li id="cf0b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nz ly lz ma bi translated">邻居有不同的标签。这是棘手的部分。我们知道所有这些像素现在都是相连的，所以标签应该都是一样的。我们如下解决这个问题。首先，我们将当前像素设置为邻居的最低标签。然后我们记下所有相连标签的等价性，也就是说，哪些不同的标签实际上应该是相同的。我们将在第二遍中解决这些问题！</li></ol><p id="4664" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个非零像素现在将有一个标签。然而，一些连接的区域将具有不同的标签。所以我们需要再次检查图像来纠正这一点。我们通过使用等价类的记录来做到这一点:所有等价的标签(即，指代相同的斑点)将获得相同的标签。</p><p id="e9b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第二遍:</strong></p><p id="4b6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每个带标签的像素:</p><ul class=""><li id="de4e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">检查此标签是否有等价标签，并解决它们。有几种方法可以解决这个问题。关于我的实现，请参见MATLAB部分。</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="e22f" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">逐步可视化</h1><p id="b5de" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">让我们来看一个算法做什么的详细例子。<strong class="ky ir"> <em class="oa"> </em> </strong>这个例子使用了一个<strong class="ky ir">8-连通性</strong>表示法。</p><p id="c49b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第一关。</strong>注意，图像在边框周围有一个填充。这只是为了使计算变得简单一点。通过填充，您在每个像素处考虑的窗口可以保持一致的大小。正如你所看到的，在每个像素上，它只考虑它左边的像素，以及它上面的三个像素。它不考虑所有的8个邻居，因为这样你就不必在整个过程中多次比较相同的像素对。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/c02d3ad0e1ecfa84defec7dc97a1cb10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/1*pu4WxS1MwbjYez2LNficfg.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd ny">算法的第一遍</strong>。由<a class="ae kv" href="http://www.dokyoungkim.com" rel="noopener ugc nofollow" target="_blank"> Dokyoung Kim </a>为本博客制作</p></figure><p id="7e5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第二遍。</strong>填充被移除，因为我们在这里不需要它。它检查每个像素，检查等价列表，并在必要时更新标签。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/52833db87785763a3c1e53ec6e09599e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/1*XeOz7ivM2BaFafKN0Pry4Q.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd ny">算法的第二遍</strong>。由<a class="ae kv" href="http://www.dokyoungkim.com" rel="noopener ugc nofollow" target="_blank"> Dokyoung Kim </a>为本博客制作</p></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="773e" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">MATLAB中的代码</h1><p id="6815" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">以下代码是该算法在MATLAB中使用8-连通性表示的实现。通过仅考虑其左侧和上方的像素，可以容易地将其改变为4-连通性表示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">MATLAB中的代码。</p></figure><p id="873a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将解释每一部分。</p><p id="a158" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第1部分:我们读取二进制图像，并给它一个零填充(大小=1)。</p><p id="1fa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第2部分:这是算法的第一遍。它循环遍历每个像素并给它一个标签；它还记录等同物。这些等价关系记录在一个散列表中，这样可以快速方便地查找标签。</p><p id="fa3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第3部分:散列表需要一些重组，所以第二遍会更容易。散列表产生如下结果:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="b472" class="nk mo iq of b gy oj ok l ol om">5 -&gt; 6 - 7<br/>6 -&gt; 8</span></pre><p id="e137" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们重组了散列表，这样它会产生如下结果:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="a023" class="nk mo iq of b gy oj ok l ol om">8 -&gt; 5<br/>7 -&gt; 5<br/>6 -&gt; 5</span></pre><p id="895a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第4部分:我们可以删除我们的填充，因为我们不再需要它。</p><p id="7dc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第5部分:现在我们可以做第二遍。我们检查每个非零像素。如果它是散列表中的一个键，我们只需查看<strong class="ky ir">值</strong>就可以知道它应该是哪个标签。</p><p id="1d77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们完成了，我们返回斑点的数量和带标签的图像。</p><p id="4975" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">备注:</strong></p><ul class=""><li id="c7dd" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">填充图像的MATLAB代码可以在<a class="ae kv" href="https://gist.github.com/Saafke/9a07fa30743c280ffd930c4e759e3c61" rel="noopener ugc nofollow" target="_blank">这里</a>找到。运行示例(GIF)的脚本可以在<a class="ae kv" href="https://gist.github.com/Saafke/c88852cc9bbb8efb8f77ae89ce457a30" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li><li id="dd70" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">Matlab还有一个<a class="ae kv" href="https://uk.mathworks.com/help/images/ref/bwlabel.html" rel="noopener ugc nofollow" target="_blank">内置的</a>函数来做连通分量标注。</li></ul></div></div>    
</body>
</html>