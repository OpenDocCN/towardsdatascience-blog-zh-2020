<html>
<head>
<title>Everything to Know to Pass your TigerGraph Certification Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过 TigerGraph 认证测试的所有知识</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/everything-to-know-to-pass-your-tigergraph-certification-test-6c3d313c0fce?source=collection_archive---------31-----------------------#2020-06-23">https://towardsdatascience.com/everything-to-know-to-pass-your-tigergraph-certification-test-6c3d313c0fce?source=collection_archive---------31-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/4949feb5ad188be144a06d5c59a9c33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wyME-EuSm7mFiQr1XKoIJQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">Jon Herke 拍摄的照片</p></figure><div class=""/><div class=""><h2 id="7aa6" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">为什么每个数据科学家都应该获得认证，以及如何获得认证</h2></div><h1 id="f830" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">什么是 TigerGraph，我为什么要获得认证？</h1><p id="67bd" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">被列为 Gartner 2019 年十大数据和分析趋势之一的图形技术是未来，允许用户对复杂的数据提出复杂的问题，TigerGraph 就是其中的一个例子。在这里，我们将介绍使用 TigerGraph 和学习图形技术所需的所有内容。如果你获得认证，你的可信度会增加，因此我强烈建议你试一试。此外，TigerGraph 是“企业唯一可扩展的图形数据库。”通过参加认证考试，你不仅会增加你的可信度，而且你还会学到一些几乎在任何地方都能帮到你的新东西。此外，参加考试是完全免费的，所以所需要的只是时间和愿意学习通过你的测试！</p><h1 id="3fa4" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">第一步:理论</h1><p id="887e" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">你将看到的前四个模块由理论组成。什么是图形技术？你能说出一些流行版本之间的区别和它们不同的应用吗？</p><h2 id="c578" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">图形数据库和分析</h2><p id="3e6e" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">一个图由通过<strong class="lo jg">边</strong>连接的<strong class="lo jg">个顶点</strong>(也称为节点)组成。所有的顶点和边组成一个<strong class="lo jg">模式</strong>。图表技术的强大之处在于数据是相互关联的，允许用户跨复杂的数据提出复杂的问题，而使用 SQL 有时是不可能的。节点和边可以有<strong class="lo jg">属性</strong>或属性，如年龄、位置、时间等。，它提供关于每个节点和边的细节；带有节点、顶点和属性的图称为<strong class="lo jg">属性图</strong>。</p><div class="mu mv mw mx gt ab cb"><figure class="my is mz na nb nc nd paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/70dbdcf9fbfa0051f0cc040f458e77f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*lsiEOuEftFGd6BGqH7mziA.png"/></div></figure><figure class="my is ne na nb nc nd paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/9785c5a23d1995115ba85685ca800d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*JWxNBKKqapbON_iliy7azg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk nf di ng nh translated">照片由 Shreya Chaudhary 拍摄。上面显示了一个基本的属性图和一个例子。每个顶点都与有向边或无向边(分别是一个箭头或一条线)相连，并且具有唯一的 primary_id。</p></figure></div><p id="560b" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">通过搜索不同的实体，图可以被用作一个<strong class="lo jg">参考网络</strong>，这些实体具有多个共同的顶点，并且相距几个<strong class="lo jg">跳</strong>(或边)。你可以在日常生活中找到推荐网络，比如你推荐的 LinkedIn 联系人或推荐的医生。</p><p id="d4b2" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">属性图与<strong class="lo jg">资源描述框架(RDF)图</strong>形成对比，因为 RDF 上的每个节点都是<strong class="lo jg">唯一资源标识符(URI) </strong>，它不能携带任何属性。它们有主语和宾语(节点)，用谓词(边)连接，但它们可能会变得冗长。</p><div class="mu mv mw mx gt ab cb"><figure class="my is nn na nb nc nd paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/77904e5f457242da58c86a94c23b1550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*G6iwLQyc30GHBLCldM2CCQ.png"/></div></figure><figure class="my is no na nb nc nd paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/a0d4287c254c80759b2c0a85c0370a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*mrEagg062cWEHYY0z4N12g.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk np di nq nh translated">照片由 Shreya Chaudhary 拍摄。这是一个 RDF。请注意，属性是独立的节点，而不是节点的属性。</p></figure></div><figure class="mu mv mw mx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/c91513d2831c1e8c941a5c3964026a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rT55nuYvdGOhsdHz5_MB1g.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">考试的时候一定要记住上面图表中的信息！</p></figure><h2 id="c2c6" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">管理关系</h2><p id="f206" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">接下来，我们将了解不同数据库存储关系的方法以及 graph 如何进行比较。<strong class="lo jg">关系数据库</strong>将每个实体存储在单独的表中，然后需要表连接来连接，这一操作可能需要几个小时，并且计算量很大。它可以用于索引和搜索一种类型的数据，并执行基本分析。关系数据库针对交易进行了优化，而不是深度分析。</p><figure class="mu mv mw mx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/cf9fbedbc276356b7c02148dfda7cf9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3yb4WemB0kCW_6l10PsQA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">照片由 Shreya Chaudhary 拍摄。这是一个在不同实体之间使用表连接的关系数据库的例子。</p></figure><p id="6281" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated"><strong class="lo jg">图形数据库</strong>，相比之下，是一个，单一的，预先连接的表。它们是为存储和分析关系而构建的自然存储模型。因为它的所有关系都是一级实体，针对深度分析优化的图形数据库往往比关系数据库快得多。</p><p id="41d8" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">与 NoSQL 相比，图形数据库更适合深度分析。一个这样的例子是<strong class="lo jg">键值</strong>数据库，它将所有数据存储在一个表中。键值数据库允许数据灵活性和快速键查找，但它是低级的。<strong class="lo jg">列族</strong>是大规模的高效处理，但是对于事务和更新来说很慢。文档可以处理像 XML 和 JSON 这样的结构，但是它通常非常专业。所有这些都需要遍历和分析关系，对表进行多次扫描，这使得它不适合分析深层关系。最后，<strong class="lo jg">图</strong>有利于处理关系，是上述结构中唯一能很好管理关系的，但并不是所有的图都能提供大规模的实时速度。总的来说，虽然 NoSQL 图可以存储各种各样的数据，但图是处理关系和实体的最佳选择。</p><figure class="mu mv mw mx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/57c750e947a9ce0bf044d10269256eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gq-feANTrvx4Qqd6VPTd-g.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">照片由 Shreya Chaudhary 拍摄。这显示了一个键值数据库，这是一个巨大的数据库，需要花费很多时间来迭代。</p></figure><h2 id="67f1" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">图的演变</h2><p id="3f06" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">目前有三种类型的图表:图表 1.0、图表 2.0 和图表 3.0。<strong class="lo jg"> Graph 1.0 </strong>使用单服务器和非并行架构的原生图形存储。<strong class="lo jg"> Graph 2.0 </strong>使用 NoSQL 基础进行存储扩展，并且可以支持两跳查询，但是它们不是为实时更新而设计的。<strong class="lo jg">然而，Graph 3.0 </strong>既是原生的又是并行的，支持超过十跳，运行跳和加载数据花费的时间更少。</p><p id="049c" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">由 TigerGraph 提供的图形 3.0(T1)支持 HTAP(混合事务和分析)。它还支持 OLTP 和 OLAP，具有实时性能，是一个事务图形，具有针对大规模数据集的可扩展性，可以使用深度链接多希望分析，易于开发和部署，并提供企业级安全性。TigerGraph 是世界上第一个本地并行和分布式图形，具有互操作性，与 MPP 并行，库中有许多图形算法，支持多重图形，使用 GSQL(类似于 SQL，便于转换)。图形工作室，一个图形用户界面，允许快速简单地创建图形和易于可视化。</p><h2 id="4520" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">数据科学能力</h2><p id="0714" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">图形支持许多机器学习和数据科学算法。这是其中一些的演练。</p><p id="5312" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated"><strong class="lo jg">深度链接分析</strong>支持查看三跳以上的数据。这可能会呈指数级增长。深度链接分析的一个例子是试图找到一个用户的欺诈历史。它不仅会查看浅层连接，还会查看深层连接，以检测用户的历史记录是否清晰。</p><p id="367c" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated"><strong class="lo jg">多维实体和模式匹配</strong>将在图形中寻找模式。</p><p id="d3ee" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated"><strong class="lo jg">关系共性</strong>寻找两个顶点的共同点，比如两个供应商的共同客户。</p><p id="36d6" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated"><strong class="lo jg">中枢社区检测</strong>搜索图中最有影响力的顶点，即边最多的顶点。这有助于发现社区中某个事物的相关性。</p><p id="ac55" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated"><strong class="lo jg">地理空间图形分析</strong>使用纬度和经度显示两个事物之间的距离。</p><p id="55f3" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated"><strong class="lo jg">时态图分析</strong>类似，但它着眼于实体和关系如何随时间变化。</p><p id="a37c" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated"><strong class="lo jg">机器学习和可解释的 AI </strong>可以通过提取特征和使用 graph studio(GUI)为图表提供视觉帮助，供 graph 使用。</p><h1 id="527a" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">第二步:TigerGraph 云</h1><p id="740d" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">要使用 TigerGraph Cloud，请前往<a class="ae nu" href="https://tgcloud.io/" rel="noopener ugc nofollow" target="_blank">https://tgcloud.io/</a>。登录，然后确保您对使用该资源感到满意。能够使用 GraphStudio 创建解决方案、上传数据、创建查询和构建图表。已经有几个很棒的关于这个的博客了，所以我在这里把它们链接起来。</p><p id="cf73" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">这里有一个我推荐:<a class="ae nu" href="https://www.tigergraph.com/2020/01/20/taking-your-first-steps-in-learning-tigergraph-cloud/" rel="noopener ugc nofollow" target="_blank">https://www . tiger graph . com/2020/01/20/taking-your-first-steps-in-learning-tiger graph-cloud/</a></p><h1 id="aff1" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">第 3 步:选择语句</h1><h2 id="253b" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">挑选</h2><p id="dc95" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">使用 Select 语句，可以从一组顶点遍历到另一组顶点。这是一般语法(必需的参数以粗体显示):</p><pre class="mu mv mw mx gt nv nw nx ny aw nz bi"><span id="94c3" class="mi kv jf nw b gy oa ob l oc od">resultSet = <strong class="nw jg">SELECT vSet FROM (edgeSet | vertexSet) </strong>[whereClause] [accumClause] [havingClause] [orderClause] [limitClause]<strong class="nw jg"> ;</strong></span></pre><p id="ca1b" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">当运行这个命令时，算法从 FROM 开始，遍历所有其他子句来“过滤”或操作它们，然后 SELECT 返回所有合适的顶点。</p><p id="e78d" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">以下是一个查询示例:</p><pre class="mu mv mw mx gt nv nw nx ny aw nz bi"><span id="f60e" class="mi kv jf nw b gy oa ob l oc od">CREATE QUERY GetFriends(vertex&lt;Users&gt; inputUser) FOR GRAPH Social {<br/>   Start = (inputUser);<br/>   Friends = SELECT t FROM Start:s- (IsFriend:e)-User:t;<br/>   PRINT Friends;<br/>}</span></pre><p id="e91b" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">在示例中，s 是起始节点，e 是边，t 是目标或最终节点。</p><h2 id="29e8" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">哪里和和</h2><p id="1257" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">其中过滤掉不符合特定条件的顶点。可以使用 AND 语句连接这些条件。</p><pre class="mu mv mw mx gt nv nw nx ny aw nz bi"><span id="33b4" class="mi kv jf nw b gy oa ob l oc od">CREATE QUERY GetFriends(vertex&lt;Users&gt; inputUser) FOR GRAPH Social {<br/>   Start = (inputUser);<br/>   Friends = SELECT t FROM Start:s- (IsFriend:e)-User:t<br/>             WHERE e.connectDt BETWEEN to_datetime("2019-01-01")<br/>             AND to_datetime("2020-01-01")<br/>             AND t.gender == "F";<br/>   PRINT Friends;<br/>}</span></pre><p id="d679" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">在本例中，它使用 connectDt 过滤 2019–01–01 和 2020–01–01 之间的所有边。接下来，它过滤掉所有性别属性为“F”的目标节点。最终，Friends 打印出 2019 年所有连接的女性朋友。</p><h2 id="99b4" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">累加器</h2><p id="f9c7" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">累加器可以是<strong class="lo jg">本地</strong>(用一个@表示)或<strong class="lo jg">全局</strong>(用两个@@表示)。局部累加器专用于每个顶点，全局累加器用于整个图形。</p><p id="5609" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">其次，累加器有更具体的类型:</p><ol class=""><li id="eac4" class="oe of jf lo b lp ni ls nj lv og lz oh md oi mh oj ok ol om bi translated"><strong class="lo jg">suma ccum&lt;int&gt;T5】存储所有通过的数字的累计。</strong></li><li id="7b75" class="oe of jf lo b lp on ls oo lv op lz oq md or mh oj ok ol om bi translated"><strong class="lo jg">MaxAccum&lt;int&gt;T7】存储通过的最大数。</strong></li><li id="6e41" class="oe of jf lo b lp on ls oo lv op lz oq md or mh oj ok ol om bi translated"><strong class="lo jg"> MinAccum &lt; int &gt; </strong>存储通过的最小数。</li><li id="0c11" class="oe of jf lo b lp on ls oo lv op lz oq md or mh oj ok ol om bi translated"><strong class="lo jg"> AvgAccum &lt; int &gt; </strong>存储所有传递的数字的移动平均值。</li><li id="3887" class="oe of jf lo b lp on ls oo lv op lz oq md or mh oj ok ol om bi translated"><strong class="lo jg"> SetAccum &lt; int &gt; </strong>要求所有元素都是唯一的。</li><li id="db90" class="oe of jf lo b lp on ls oo lv op lz oq md or mh oj ok ol om bi translated"><strong class="lo jg"> ListAccum &lt; int &gt; </strong>有一个按传入顺序排列的元素列表。</li><li id="9fd6" class="oe of jf lo b lp on ls oo lv op lz oq md or mh oj ok ol om bi translated"><strong class="lo jg"> MapAccum &lt; int，SumAccum &lt; int &gt; &gt; </strong>使用键值对像映射一样存储数据。</li><li id="1f80" class="oe of jf lo b lp on ls oo lv op lz oq md or mh oj ok ol om bi translated"><strong class="lo jg">HeapAccum&lt;Tuple&gt;</strong>将数据按升序或降序存储在元组中。还可以设置容量限制；当达到限制时，它将删除最高值或最低值。</li></ol><p id="42e2" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">这里有两个例子。第一个具有一跳全局 MinAccum:</p><pre class="mu mv mw mx gt nv nw nx ny aw nz bi"><span id="23ba" class="mi kv jf nw b gy oa ob l oc od">CREATE QUERY GetFriends(vertex&lt;Users&gt; inputUser) FOR GRAPH Social {<br/>   MinAccum&lt;uint&gt; @@youngFriend;<br/>   Start = (inputUser);<br/>   Friends = SELECT t FROM Start:s- (IsFriend:e)-User:t<br/>             WHERE e.connectDt BETWEEN to_datetime("2019-01-01")<br/>             AND to_datetime("2020-01-01")<br/>             AND t.gender == "F";<br/>             ACCUM @@youngFriend += t.age;<br/>   PRINT Friends;<br/>}</span></pre><p id="f791" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">第二个具有两跳本地 AvgAccums:</p><pre class="mu mv mw mx gt nv nw nx ny aw nz bi"><span id="096d" class="mi kv jf nw b gy oa ob l oc od">CREATE QUERY GetFriends(vertex&lt;Users&gt; inputUser) FOR GRAPH Social {<br/>   AvgAccum @avgAge;<br/>   Start = (inputUser);<br/>   Friends1Hop = SELECT t FROM Start:s- (IsFriend:e)-:t;<br/>   Friends2Hop = SELECT t <br/>                 FROM Friends1Hop:s- (IsFriend:e)-:t<br/>                 ACCUM t.@avgAge += s.age;<br/>   PRINT Friends2Hop;<br/>}</span></pre><h2 id="a0d7" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">累积后</h2><p id="882b" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">POST-ACCUM 独立于 ACCUM 子句。他们可以访问起始顶点或目标顶点(s 或 t 别名)。如果是全局累加器，工作会排队，在离开 POST-ACCUM 子句后生效。</p><p id="bf15" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">查看使用全局最大累加器和求和累加器进行规格化的示例:</p><pre class="mu mv mw mx gt nv nw nx ny aw nz bi"><span id="987e" class="mi kv jf nw b gy oa ob l oc od">CREATE QUERY GetFriends(vertex&lt;Users&gt; inputUser) FOR GRAPH Social {<br/>   SumAccum&lt;uint&gt; @sumAge;<br/>   SumAccum&lt;float&gt; @normCNum;<br/>   MaxAccum&lt;float&gt; @@maxCNum;<br/>   Start = (inputUser);<br/>   Friends1Hop = SELECT t FROM Start:s- (IsFriend:e)-:t;<br/>   Friends2Hop = SELECT t <br/>                 FROM Friends1Hop:s- (IsFriend:e)-:t<br/>                 ACCUM t.@cNum += 1<br/>                 POST-ACCUM @@maxCNum += t.@cNum;<br/>   Friends2Hop = select s FROM Freinds2Hop:s<br/>                 POST-ACCUM s.@normCNum += s.@cNum/@@maxCNum;<br/>   PRINT Friends2Hop;<br/>}</span></pre><h2 id="5bc2" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">拥有</h2><p id="00c5" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">HAVING 子句是过滤数据的另一种方式。它类似于 WHERE 子句，但是 HAVING 子句只能访问选定的顶点和属性，而 WHERE 子句可以访问起始顶点和目标顶点。</p><pre class="mu mv mw mx gt nv nw nx ny aw nz bi"><span id="ae0a" class="mi kv jf nw b gy oa ob l oc od">CREATE QUERY GetFriends(vertex&lt;Users&gt; inputUser) FOR GRAPH Social {<br/>   AvgAccum @avgAge;<br/>   Start = (inputUser);<br/>   Friends1Hop = SELECT t FROM Start:s- (IsFriend:e)-:t;<br/>   Friends2Hop = SELECT t <br/>                 FROM Friends1Hop:s- (IsFriend:e)-:t<br/>                 ACCUM t.@avgAge += s.age<br/>                 HAVING t.@avgAge &gt; 30;<br/>   PRINT Friends2Hop;<br/>}</span></pre><h2 id="7c88" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">排序依据和限制</h2><p id="6bf0" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">最后，ORDER BY 可以对结果进行升序或降序排序。限制设置累加器中值的最大数量。</p><pre class="mu mv mw mx gt nv nw nx ny aw nz bi"><span id="6ddc" class="mi kv jf nw b gy oa ob l oc od">CREATE QUERY GetFriends(vertex&lt;Users&gt; inputUser) FOR GRAPH Social {<br/>   AvgAccum @avgAge;<br/>   Start = (inputUser);<br/>   Friends1Hop = SELECT t FROM Start:s- (IsFriend:e)-:t;<br/>   Friends2Hop = SELECT t <br/>                 FROM Friends1Hop:s- (IsFriend:e)-:t<br/>                 ACCUM t.@avgAge += s.age<br/>                 ORDER BY t.@avgAge ASC<br/>                 LIMIT 2;<br/>   PRINT Friends2Hop;<br/>}</span></pre><p id="b182" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">上面的例子将结果排序为升序，然后获取前两个，也就是最小的两个。</p><h1 id="6bc4" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">步骤 4: GSQL 演示</h1><h2 id="6e45" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">图表模式</h2><p id="f652" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">对于模式中的每个顶点，您需要有一个主 ID。另外，对于每个顶点，你需要指定一个 FROM 和 to。请遵循以下语法:</p><pre class="mu mv mw mx gt nv nw nx ny aw nz bi"><span id="9a7d" class="mi kv jf nw b gy oa ob l oc od">CREATE VERTEX Test(PRIMARY_ID test_id STRING)<br/>CREATE VERTEX Test2(PRIMARY_ID test2_id STRING)<br/>CREATE DIRECTED EDGE TEST_TO_TEST2(FROM Test, To Test2)<br/>CREATE UNDIRECTED EDGE TEST2_TO_TEST(FROM Test2, To Test)</span></pre><h2 id="f154" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">加载数据</h2><p id="9b88" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">要加载数据，您需要定义一个加载作业。为此，您需要创建文件名变量并使用加载语句:</p><pre class="mu mv mw mx gt nv nw nx ny aw nz bi"><span id="b24f" class="mi kv jf nw b gy oa ob l oc od">DEFINE FILENAME f1 = “/path”<br/>LOAD f1 TO VERTEX person($”name”)</span></pre><h2 id="9b1c" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">图形检查</h2><p id="3d38" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">对于本模块，您需要熟悉如何使用终端或控制台来检查图表。您可以使用以下选项选择要使用的图表:</p><pre class="mu mv mw mx gt nv nw nx ny aw nz bi"><span id="5f97" class="mi kv jf nw b gy oa ob l oc od">use graph social</span></pre><p id="022b" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated">然后，您可以使用各种其他命令。列出的命令包括 from、to、directed、to、attributes、e_type。这里有一个例子:</p><pre class="mu mv mw mx gt nv nw nx ny aw nz bi"><span id="8643" class="mi kv jf nw b gy oa ob l oc od">SELECT * FROM person WHERE var=”Val”</span></pre><h2 id="cee8" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">基本 GSQL</h2><p id="e2b3" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">您将创建的查询将返回 JSON。你也可以使用 curl 来运行这个图表。知道如何创建查询和结果。</p><pre class="mu mv mw mx gt nv nw nx ny aw nz bi"><span id="8a5c" class="mi kv jf nw b gy oa ob l oc od">CREATE QUERY name(VERTEX=person p) FOR GRAPH social;<br/>Start = ()<br/>Result = SELECT tgt from Start:src -{friendship x} -person-tgt</span></pre><h2 id="b4ad" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">高级 GSQL</h2><p id="483c" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">本模块回顾了<strong class="lo jg">累加器</strong>，如 OrAccum 和 AvgAccum 以及本地和全局累加器。这些是累积变量的不同方法。请记住，要创建全局变量，请使用两个@@，否则只需使用一个@符号。</p><h2 id="cbeb" class="mi kv jf bd kw mj mk dn la ml mm dp le lv mn mo lg lz mp mq li md mr ms lk mt bi translated">GSQL 中的深度查询</h2><p id="1dde" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">对于深度查询，模块检查了<code class="fe os ot ou nw b">khop</code>和<code class="fe os ot ou nw b">run query name(parameters)</code>。</p><h1 id="22f1" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">其他来源</h1><p id="25b1" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">在本文中，我回顾了每个视频系列，并对每个视频系列进行了总结或描述。此外，考试中还有一些杂七杂八的题目，比如如何使用 gadmin。如果您有时间，我建议您也查看一下 TigerGraph 的文档。</p><p id="7e26" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated"><strong class="lo jg">gad min</strong>:<a class="ae nu" href="https://www.tigergraph.com/managing-tigergraph-servers-with-gadmin/" rel="noopener ugc nofollow" target="_blank">https://www . tiger graph . com/managing-tiger graph-servers-with-gad min/</a></p><p id="5ad4" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated"><strong class="lo jg"> TigerGraph 文档</strong>:<a class="ae nu" href="https://www.tigergraph.com/tigergraph-docs-gsql-101/" rel="noopener ugc nofollow" target="_blank">https://www.tigergraph.com/tigergraph-docs-gsql-101/</a></p><p id="48c7" class="pw-post-body-paragraph lm ln jf lo b lp ni kg lr ls nj kj lu lv nk lx ly lz nl mb mc md nm mf mg mh ij bi translated"><strong class="lo jg">视频系列原文链接</strong>:<a class="ae nu" href="https://community.tigergraph.com/t/tigergraph-getting-started-guide/11" rel="noopener ugc nofollow" target="_blank">https://community . tiger graph . com/t/tiger graph-getting-started-guide/11</a></p></div><div class="ab cl ov ow hu ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="ij ik il im in"><h1 id="cafa" class="ku kv jf bd kw kx pc kz la lb pd ld le kl pe km lg ko pf kp li kr pg ks lk ll bi translated">你现在准备好了</h1><p id="f696" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">这是 TigerGraph 认证考试的文本版本。现在，去<a class="ae nu" href="https://community.tigergraph.com/t/tigergraph-getting-started-guide/11" rel="noopener ugc nofollow" target="_blank">这里</a>获得认证并了解本文之外的更多内容。祝好运，学习愉快！</p></div></div>    
</body>
</html>