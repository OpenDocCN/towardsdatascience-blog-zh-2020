<html>
<head>
<title>TensorFlow 2.2+ and Custom Training Logic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow 2.2+和自定义培训逻辑</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tensorflow-2-2-and-a-custom-training-logic-16fa72934ac3?source=collection_archive---------37-----------------------#2020-06-24">https://towardsdatascience.com/tensorflow-2-2-and-a-custom-training-logic-16fa72934ac3?source=collection_archive---------37-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d143" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">最近的TensorFlow版本引入了tf.keras.Model的新方法train_step和<strong class="ak"> test_step </strong>，极大地改进了我们处理自定义训练循环的方式。我会告诉你怎么做。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d8b7c5591f69479adde36ad6524162a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UhvYGhxjtDw-em7uDUlTig.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:pexels.com<a class="ae kv" href="https://www.pexels.com/photo/contemporary-gradient-handrails-perspective-434645/" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="7aab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大家都熟悉标准模型——一个输入、一个输出、一个损失函数。也许还有几个指标。你可以用<a class="ae kv" href="https://www.tensorflow.org/api_docs/python/tf/keras/Sequential" rel="noopener ugc nofollow" target="_blank">顺序</a>或<a class="ae kv" href="https://www.tensorflow.org/guide/keras/functional" rel="noopener ugc nofollow" target="_blank">功能</a>的方式定义模型，编译并训练它。</p><p id="4d0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时候，会有<a class="ae kv" href="https://www.tensorflow.org/guide/keras/functional#models_with_multiple_inputs_and_outputs" rel="noopener ugc nofollow" target="_blank">多个输入</a>。或<a class="ae kv" href="https://www.tensorflow.org/guide/keras/functional#models_with_multiple_inputs_and_outputs" rel="noopener ugc nofollow" target="_blank">多路输出</a>。这仍然可以用这些API来实现。假设输出是“独立的”——损失函数(一个用于所有输出或一个用于每个输出)分别对每个输出起作用。</p><p id="eb46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时候，我们需要更进一步。也许损失是从更多的输出中计算出来的。或者有一些用于计算损失的附加信息。这是必须实现定制训练循环的时候。</p><p id="7af8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇博文中，我不会涉及这样的具体用例。相反，我将向您展示一个简化的示例，说明如何训练它的三种方式。稍后，我将继续一个更复杂的例子。敬请关注！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f753" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">示例问题</h1><p id="db3d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">即使在教程里，我也喜欢可运行的代码，甚至现实世界的问题。因此，让我们以TensorFlow数据集之一—<a class="ae kv" href="https://www.tensorflow.org/datasets/catalog/beans" rel="noopener ugc nofollow" target="_blank">bean</a>为例。</p><blockquote class="mw mx my"><p id="8ea0" class="kw kx mz ky b kz la jr lb lc ld ju le na lg lh li nb lk ll lm nc lo lp lq lr ij bi translated">Beans是一个使用智能手机相机在田间拍摄的豆子图像数据集。它包括3个类别:2个疾病类别和健康类别。描述的疾病包括角斑病和豆锈病。乌干达国家作物资源研究所的专家对数据进行了注释，数据由Makerere AI研究实验室收集。</p></blockquote><p id="b250" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它相当小(171.63 MiB，1295张图片)，使我们能够快速训练我们的模型。即使经过少量的时期，结果看起来也是有希望的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/7899a4fedfbf212bc43d84aa45460e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQ7-ro6NoFf4f_k_g1R63A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自beans数据集的示例图像和标签，来源<a class="ae kv" href="https://www.tensorflow.org/datasets/catalog/beans" rel="noopener ugc nofollow" target="_blank">tensorflow.org</a></p></figure><p id="0901" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://gist.github.com/liborvaneksw/60597e7f473a739e439b589e8dea295f" rel="noopener ugc nofollow" target="_blank">这里</a>是后面三章的通用代码，主要包含数据集的准备和训练设置。这与我们的主题没有直接联系，我不想让文章太长，所以如果你愿意，请查看随附的<a class="ae kv" href="https://gist.github.com/liborvaneksw/60597e7f473a739e439b589e8dea295f" rel="noopener ugc nofollow" target="_blank">要点</a>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b2c2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">标准编译和拟合方法</h1><p id="cdbf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这就是如何定义和训练一个简单的转移模型。没什么神秘的，但为了完整起见我会在这里展示一下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">像往常一样训练。关于导入、参数和数据集定义，参见<a class="ae kv" href="https://gist.github.com/liborvaneksw/60597e7f473a739e439b589e8dea295f" rel="noopener ugc nofollow" target="_blank">该代码</a>。</p></figure><p id="0faa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用了<a class="ae kv" href="https://www.tensorflow.org/api_docs/python/tf/keras/applications/MobileNetV2" rel="noopener ugc nofollow" target="_blank"> MobileNet </a>和几个附加层。<a class="ae kv" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/GlobalAveragePooling2D" rel="noopener ugc nofollow" target="_blank">globalaveragepool2d</a>将要素转换为单个矢量，该矢量可用于最终的密集图层。中间我用了<a class="ae kv" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Dropout" rel="noopener ugc nofollow" target="_blank">辍学</a>。请记住，数据集非常小，我们必须小心过度拟合。剩下的就简单了。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="03a5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">用老方法定制训练逻辑</h1><p id="22c2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">自定义训练循环的详细描述可在<a class="ae kv" href="https://www.tensorflow.org/tutorials/customization/custom_training_walkthrough" rel="noopener ugc nofollow" target="_blank">官方文档</a>中找到。如果我们将这一点转化为上一段中的问题，我们会得到以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自定义训练循环。关于导入、参数和数据集定义，参见<a class="ae kv" href="https://gist.github.com/liborvaneksw/60597e7f473a739e439b589e8dea295f" rel="noopener ugc nofollow" target="_blank">该代码</a>。</p></figure><p id="6510" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你看到所有的代码，只是关心跟踪损失和准确性？现在假设您有多个指标和几个回调，例如包括TensorBoard。你想要更好的输出。代码开始越来越多的扩展。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2316" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">未来:train_step()和test_step()</h1><p id="fae4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">从TensorFlow 2.2开始，不再需要所有这些锅炉板代码。你只需要告诉TensorFlow每个单独的训练步骤(可能还有测试步骤)将会是什么样子。其余的在<a class="ae kv" href="https://www.tensorflow.org/api_docs/python/tf/keras/Model" rel="noopener ugc nofollow" target="_blank"> tf.keras.Model </a>类中完成。我们就不拐弯抹角了，下面是代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用train_step()和test step()的示例。关于导入、参数和数据集定义，参见<a class="ae kv" href="https://gist.github.com/liborvaneksw/60597e7f473a739e439b589e8dea295f" rel="noopener ugc nofollow" target="_blank">该代码</a>。</p></figure><p id="8ee3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想指出两件事:</p><ul class=""><li id="fd52" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated">输入的格式通常是<strong class="ky ir"> x，y </strong>和可选的<strong class="ky ir">样品重量</strong>。您不需要在子类中遵守这一点。不过要小心，这是有后果的。很明显，您不能再使用fit方法的<code class="fe np nq nr ns b">class_weight</code>参数。即使您只向这三个参数添加了额外参数，也是如此。</li><li id="1e45" class="ng nh iq ky b kz nt lc nu lf nv lj nw ln nx lr nl nm nn no bi translated">您可以使用已编译的loss(损失)、metrics和optimizer。我建议你尽可能经常这样做。但是通常，当这些还不够时，您会覆盖这个方法。所以不要害怕从一个<code class="fe np nq nr ns b">compile</code>方法中去掉一些，定义你自己的或者完全离开<code class="fe np nq nr ns b">compile()</code>。</li></ul><h2 id="0ebc" class="ny ma iq bd mb nz oa dn mf ob oc dp mj lf od oe ml lj of og mn ln oh oi mp oj bi translated">没有编译的优化器、损失和指标</h2><p id="f3c7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">那么当你不考虑<code class="fe np nq nr ns b">compile()</code>的时候会发生什么呢？您仍然需要添加一些代码。但是请注意与完全定制的训练循环的巨大差异。您现在正在指定一个步骤的行为。因此，父模型类可以负责所有的支持功能。例如打印漂亮的进度条或者调用所有的回调函数。(它们可以以通常的方式作为参数提供给<code class="fe np nq nr ns b">fit</code>方法。)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9490" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我试图将所有重要的注释写入代码本身。因此，我在此仅补充一点。可以省略<code class="fe np nq nr ns b">metric()</code>属性，直接返回<code class="fe np nq nr ns b">train_step()</code>和<code class="fe np nq nr ns b">test_step()</code>中的<em class="mz"> name: (float) value </em>对。进度输出将是正常的，你会看到一个平均值。但不是在你的试镜中。在那里，您将获得与您返回的值完全相同的值。</p><h1 id="b8a1" class="lz ma iq bd mb mc ok me mf mg ol mi mj jw om jx ml jz on ka mn kc oo kd mp mq bi translated">最后的想法</h1><p id="aa41" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在这篇博文中，我向您介绍了在TensorFlow中训练模型的不同方法，包括覆盖Keras模型的新方法<code class="fe np nq nr ns b">train_step </code>和<code class="fe np nq nr ns b">test_step</code>。这个例子使用起来太简单了。但我希望它能达到演示不同方法的目的，而不需要解释复杂的模型。我想做的比一些即将到来的文章。</p><p id="a77d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你觉得这有用，请给我留言。如果你有任何问题，请随时这样做。我很乐意回答你。</p></div></div>    
</body>
</html>