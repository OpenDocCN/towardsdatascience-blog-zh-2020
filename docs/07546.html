<html>
<head>
<title>How to Use Machine Learning for Drug Discovery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将机器学习用于药物发现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-machine-learning-for-drug-discovery-1ccb5fdf81ad?source=collection_archive---------15-----------------------#2020-06-07">https://towardsdatascience.com/how-to-use-machine-learning-for-drug-discovery-1ccb5fdf81ad?source=collection_archive---------15-----------------------#2020-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/58b9ed7cb6ad0a97aeda8b0b1de926ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*sB2d1x_0GoP64Zd0aHkacQ.gif"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://elements.envato.com/user/wowomnom" rel="noopener ugc nofollow" target="_blank"> wowomnom </a>在<a class="ae jg" href="https://elements.envato.com/" rel="noopener ugc nofollow" target="_blank"> Envato元素</a>上定制一个图形(带许可证)</p></figure><h2 id="b263" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/tag/data-science" rel="noopener">数据科学</a></h2><div class=""/><div class=""><h2 id="bd40" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">一步一步的实用生物信息学教程</h2></div></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="d952" class="lo lp jj bd lq lr ls lt lu lv lw lx ly ky lz kz ma lb mb lc mc le md lf me mf bi translated">1.介绍</h1><p id="3148" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated">我们可能已经看到机器学习以这样或那样的形式应用。例如，机器学习已经与计算机视觉一起用于自动驾驶汽车和自助结账便利店，用于零售市场购物篮分析(即找到通常一起购买的产品)，用于推荐系统的娱乐，等等。</p><p id="b4af" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这代表了<strong class="mi jt"> <em class="nh">生物信息学教程</em> </strong>系列的第一篇文章(感谢<a class="ni nj ep" href="https://medium.com/u/983bdeefa40e?source=post_page-----1ccb5fdf81ad--------------------------------" rel="noopener" target="_blank"> Jaemin Lee </a>关于将我的文章发展成系列的建议！).在本文中，我将探索机器学习如何用于药物发现，特别是通过一步一步地向您展示如何在Python中建立一个简单的回归模型来预测分子的溶解度(<em class="nh">即</em>对数值)。需要注意的是，药物的<em class="nh">溶解度</em>是药物发现、设计和开发中一个重要的理化性质。在此，我们将转载一篇名为<a class="ae jg" href="https://pubs.acs.org/doi/10.1021/ci034243x" rel="noopener ugc nofollow" target="_blank"><em class="nh">“ESOL:从分子结构直接估算水溶性”</em> </a>的研究文章，作者是John S. Delaney。</p><p id="b870" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这款笔记本的灵感来自Pat Walters在<a class="ae jg" href="http://practicalcheminformatics.blogspot.com/2018/09/predicting-aqueous-solubility-its.html" rel="noopener ugc nofollow" target="_blank"> <em class="nh">【预测水溶性——比看起来更难】</em> </a>上的精彩博文，他在博文中重现了线性回归模型，其性能与Delaney的相似。这个例子在Walters合著的书<a class="ae jg" href="https://amzn.to/3cBOap1" rel="noopener ugc nofollow" target="_blank">、<em class="nh">生命科学的深度学习:将深度学习应用于基因组学、显微镜学、药物发现等】</em>、</a>中也有简要描述。</p><p id="b971" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">YouTube视频<a class="ae jg" href="https://www.youtube.com/watch?v=VXFFHHoE1wk" rel="noopener ugc nofollow" target="_blank"> <em class="nh">“使用Python进行计算药物发现的数据科学”</em> </a>中提供了展示本文所述实施的教程视频:</p><figure class="nk nl nm nn gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="73c8" class="lo lp jj bd lq lr nq lt lu lv nr lx ly ky ns kz ma lb nt lc mc le nu lf me mf bi translated">目录</h1><p id="f070" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated">1.<a class="ae jg" href="#d952" rel="noopener ugc nofollow">introduction </a><br/>2。<a class="ae jg" href="#b61f" rel="noopener ugc nofollow">材料</a><br/>2.1<a class="ae jg" href="#834d" rel="noopener ugc nofollow">Computing environmen </a>t <br/>2.2<a class="ae jg" href="#d106" rel="noopener ugc nofollow"> Installing prerequisite Python librar </a> y <br/> 2.3。<a class="ae jg" href="#0277" rel="noopener ugc nofollow"> Datase </a> t <br/> 3<a class="ae jg" href="#5ebf" rel="noopener ugc nofollow">方法</a><br/>3.1<a class="ae jg" href="#0277" rel="noopener ugc nofollow"> Datase </a> t <br/> 3.1.1读取数据集 <br/> 3.1.2。Examining the SMILES data <br/>3.2。<a class="ae jg" href="#7eb0" rel="noopener ugc nofollow"> Working with SMILES strin </a> g <br/> 3.2.1。convertit a molecule from the SMILES string to an rdkit object <br/> 3.2.2。Working with the rdkit object <br/> 3.2.3。Convert list of molecules to rdkit object <br/>3.3 转换分子列表到rdkit对象。<a class="ae jg" href="#823f" rel="noopener ugc nofollow">计算分子描述符</a>s<br/>3.3.1。Calculating LogP, MW and RB descriptors <br/> 3.3.2。计算芳香比例(T33) 3.3.2.1。芳香原子数(T34)3.3.2.2。重原子数(T35)3.3.2.3计算芳香比例(AP)描述符<br/> 3.4。<a class="ae jg" href="#63e3" rel="noopener ugc nofollow">数据集准备</a><br/>3.4.1Creating the X Matrix <br/> 3.4.2。首页 〉外文书 〉文学 〉西洋文学 〉Creating the Y Matrix (T41) 3.5<a class="ae jg" href="#f0d7" rel="noopener ugc nofollow">数据分割</a><br/>3.6线性回归模型(T46)(T47)<a class="ae jg" href="#804e" rel="noopener ugc nofollow"> 结果</a><br/> 4.1(T51)线性回归模型(T52)(T53) 4.1.1预测 X_train 数据的 LogS 值 <br/> 4.1.2。预测 X_test 数据的 LogS 值 <br/> 4.2。(T56) 比较线性回归方程(T57)<a class="ae jg" href="#a65b" rel="noopener ugc nofollow"> Deriving the Linear Regression Equatio </a> n <br/> 4.3.1基于列车集<br/> 4.3.2。基于完整数据集(用于比较)(T63) 4.4。<a class="ae jg" href="#de0c" rel="noopener ugc nofollow"> Scatter plot of experimental vs. predicted Log </a> S <br/> 4.4.1。Vertical Plot <br/> 4.4.2。横向 Plot</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="b61f" class="lo lp jj bd lq lr ls lt lu lv lw lx ly ky lz kz ma lb mb lc mc le md lf me mf bi translated">2.材料</h1><p id="1f86" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated">从学术背景来看，检索关于如何进行实验的信息的研究论文的最重要部分之一必须是<em class="nh">材料和方法</em>部分，因为它将基本上告诉我们需要什么材料以及做了什么和如何做。因此，在这一部分，我将讨论您需要开始做些什么。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="834d" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">2.1.计算环境</h2><p id="f203" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated">首先，决定你是想在本地计算机上工作还是在云上工作。如果你决定在本地计算机上工作，那么任何可以安装Python和Jupyter notebook的计算机(我推荐安装<a class="ae jg" href="https://docs.conda.io/projects/conda/en/latest/user-guide/install/" rel="noopener ugc nofollow" target="_blank"> conda </a>或<a class="ae jg" href="https://www.anaconda.com/products/individual" rel="noopener ugc nofollow" target="_blank"> Anaconda </a>)就足够了。如果你决定在云上工作，那就去谷歌实验室吧。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="d106" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">2.2.安装必备Python库</h2><p id="14de" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated">rdkit库是一个Python库，它允许我们处理化学结构和计算它们的分子属性(<em class="nh">即</em>用于量化每个分子的分子特征，我们可以随后在机器学习模型的开发中使用)。</p><p id="b2fa" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">我们现在将安装rdkit库，启动一个新笔记本，并确保创建一个包含以下文本的<strong class="mi jt">文本单元格</strong>:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="dda1" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt"># Install rdkit</strong></span></pre><p id="d4f8" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">在这个文本单元格的正下方，您想要创建一个新的代码单元格，并用以下代码块填充它:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="c9a0" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">! wget https://repo.anaconda.com/miniconda/Miniconda3-py37_4.8.2-Linux-x86_64.sh <br/>! chmod +x Miniconda3-py37_4.8.2-Linux-x86_64.sh <br/>! bash ./Miniconda3-py37_4.8.2-Linux-x86_64.sh -b -f -p /usr/local <br/>! conda install -c rdkit rdkit -y <br/>import sys <br/>sys.path.append('/usr/local/lib/python3.7/site-packages/')</strong></span></pre><p id="99d4" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">上面的2个单元格应该看起来像下面的截图:</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/2a39e4f82b1a38e92c4f008446bdf1cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUQLZt-f2rsK3VRuFyHnRw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">以上2个单元格(文本和代码单元格)的渲染。</p></figure></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="0277" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">2.3.数据集</h2><p id="d898" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated">我们现在将下载Delaney溶解度数据集，该数据集作为论文<a class="ae jg" href="https://pubs.acs.org/doi/10.1021/ci034243x" rel="noopener ugc nofollow" target="_blank"> ESOL:直接从分子结构</a>中的<a class="ae jg" href="https://pubs.acs.org/doi/suppl/10.1021%2Fci034243x" rel="noopener ugc nofollow" target="_blank">补充文件</a>提供。</p><p id="5100" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated"><strong class="mi jt"> <em class="nh">下载数据集</em> </strong> <br/>下载到Jupyter笔记本如下:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="26a6" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">! wget https://raw.githubusercontent.com/dataprofessor/data/master/delaney.csv</strong></span></pre></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="5ebf" class="lo lp jj bd lq lr ls lt lu lv lw lx ly ky lz kz ma lb mb lc mc le md lf me mf bi translated">3.方法</h1><h2 id="d809" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">3.1.资料组</h2><p id="a7f2" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated"><strong class="mi jt"> <em class="nh"> 3.1.1。读入数据集</em> </strong> <br/>读入我们从上述单元格下载的CSV数据。将数据分配到<code class="fe oq or os oh b">sol</code>数据框中。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="eeae" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">import pandas as pd<br/>sol = pd.read_csv('delaney.csv')</strong></span></pre><p id="4267" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">显示<code class="fe oq or os oh b">sol</code>数据帧给我们提供了以下信息:</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/e3898d6761a4f43d18ed5c85f5bbfc2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJ_CRYuKI6hshwpy2KnwCw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><em class="ou"> sol </em>数据框的内容。</p></figure><p id="3f82" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated"><strong class="mi jt"> <em class="nh"> 3.1.2。检验SMILES数据</em> </strong> <br/>化学结构由一串称为<strong class="mi jt"> SMILES </strong>符号的文本编码，这是简化分子输入行输入系统的首字母缩写。让我们看看<code class="fe oq or os oh b">sol</code>数据帧中<em class="nh">微笑</em>列的内容。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="fe30" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">sol.SMILES</strong></span></pre><p id="1133" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">运行上面的单元将为我们提供:</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/da828bd8158b114ae77672c3fba0422e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFWt52xLaQf7aIN5qjwLCg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">溶胶含量。SMILES(sol数据框架中的SMILES列)。</p></figure><p id="3627" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">每条线代表一种独特的分子。要选择第一个分子(第一行)，键入<code class="fe oq or os oh b">sol.SMILES[0]</code>，我们将看到的输出是<code class="fe oq or os oh b">ClCC(Cl)(Cl)Cl</code>。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="7eb0" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">3.2.使用微笑字符串</h2><p id="38c4" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated"><strong class="mi jt">3 . 2 . 1<em class="nh">。将一个分子从SMILES字符串转换成一个rdkit对象</em> </strong> <br/>让我们从导入必要的库函数开始:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="9e23" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">from rdkit import Chem</strong></span></pre><p id="e05f" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">现在，应用<code class="fe oq or os oh b">MolFromSmiles()</code>函数将SMILES字符串转换为rdkit分子对象:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="3956" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">Chem.MolFromSmiles(sol.SMILES[0])</strong></span></pre><p id="561c" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这将产生以下输出:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="a692" class="nv lp jj oh b gy ol om l on oo">&lt;rdkit.Chem.rdchem.Mol at 0x7f66f2e3e800&gt;</span></pre><p id="6a47" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated"><strong class="mi jt"> <em class="nh"> 3.2.2。使用rdkit对象</em> </strong> <br/>让我们对查询SMILES字符串执行一个简单的原子计数，我们首先将它转换成一个rdkit对象，然后应用<code class="fe oq or os oh b">GetNumAtoms()</code>函数。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="8096" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">m = Chem.MolFromSmiles('ClCC(Cl)(Cl)Cl')<br/>m.GetNumAtoms()</strong></span></pre><p id="c1a0" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这会产生以下输出:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="c892" class="nv lp jj oh b gy ol om l on oo">6</span></pre><p id="4461" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated"><strong class="mi jt">3 . 2 . 3<em class="nh">。将分子列表转换为rdkit对象</em> <br/> </strong>但是在我们进行任何描述符计算之前，我们必须先将SMILES字符串转换为rdkit对象，如3.2节所述。这里我们将做和上面描述的一样的事情，但是我们将利用<strong class="mi jt"> for </strong>循环来遍历微笑字符串列表。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="0916" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">from rdkit import Chem</strong></span><span id="c59d" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">mol_list= []<br/>for element in sol.SMILES:<br/>  mol = Chem.MolFromSmiles(element)<br/>  mol_list.append(mol)</strong></span></pre><p id="f666" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">接下来，我们将检查新的rdkit对象是否正在填充mol_list变量。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="e6fa" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">len(mol_list)</strong></span></pre><p id="4950" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">上面的行返回:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="8d67" class="nv lp jj oh b gy ol om l on oo">1144</span></pre><p id="8557" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这相当于1144个分子。现在，我们将看看变量的内容。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="19ca" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">mol_list[:5]</strong></span></pre><p id="c66c" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这会产生以下输出:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="f210" class="nv lp jj oh b gy ol om l on oo">[&lt;rdkit.Chem.rdchem.Mol at 0x7f66edb6d670&gt;,<br/> &lt;rdkit.Chem.rdchem.Mol at 0x7f66edb6d620&gt;,<br/> &lt;rdkit.Chem.rdchem.Mol at 0x7f66edb6d530&gt;,<br/> &lt;rdkit.Chem.rdchem.Mol at 0x7f66edb6d6c0&gt;,<br/> &lt;rdkit.Chem.rdchem.Mol at 0x7f66edb6d710&gt;]</span></pre></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="823f" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">3.3.计算分子描述符</h2><p id="53e5" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated">我们现在将通过一组用于建模的分子描述符来表示数据集中的每个分子。</p><p id="56b1" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">为了预测<strong class="mi jt">对数</strong>(水溶性对数)，Delaney的研究使用了4个分子描述符:</p><ol class=""><li id="b7e8" class="ow ox jj mi b mj nc mm nd mp oy mt oz mx pa nb pb pc pd pe bi translated"><strong class="mi jt"> cLogP </strong> <em class="nh">(辛醇-水分配系数)</em></li><li id="a6ca" class="ow ox jj mi b mj pf mm pg mp ph mt pi mx pj nb pb pc pd pe bi translated"><strong class="mi jt"> MW </strong> <em class="nh">(分子量)</em></li><li id="5144" class="ow ox jj mi b mj pf mm pg mp ph mt pi mx pj nb pb pc pd pe bi translated"><strong class="mi jt">RB</strong>T43】(可旋转债券数量)</li><li id="a3db" class="ow ox jj mi b mj pf mm pg mp ph mt pi mx pj nb pb pc pd pe bi translated"><strong class="mi jt"> AP </strong> <em class="nh">(芳香比例=芳香原子数/重原子数)</em></li></ol><p id="18b2" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">不幸的是，rdkit很容易计算前3个。至于AP描述符，我们将通过手动计算rdkit可以计算的芳香原子数<em class="nh">与重原子数</em>的比率来计算。</p><p id="899c" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated"><strong class="mi jt">3 . 3 . 1<em class="nh">。计算LogP、MW和RB描述符<br/> </em> </strong>我们现在将创建一个名为<code class="fe oq or os oh b">generate()</code>的自定义函数，用于计算3个描述符LogP、MW和RB。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="2d73" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">import numpy as np<br/>from rdkit.Chem import Descriptors</strong></span><span id="939e" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt"><em class="nh"># Inspired by: https://codeocean.com/explore/capsules?query=tag:data-curation</em><br/><br/>def generate(smiles, verbose=False):<br/><br/>    moldata= []<br/>    for elem in smiles:<br/>        mol=Chem.MolFromSmiles(elem) <br/>        moldata.append(mol)<br/>       <br/>    baseData= np.arange(1,1)<br/>    i=0  <br/>    for mol in moldata:        <br/>       <br/>        desc_MolLogP = Descriptors.MolLogP(mol)<br/>        desc_MolWt = Descriptors.MolWt(mol)<br/>        desc_NumRotatableBonds = Descriptors.NumRotatableBonds(mol)<br/>           <br/>        row = np.array([desc_MolLogP,<br/>                        desc_MolWt,<br/>                        desc_NumRotatableBonds])   <br/>    <br/>        if(i==0):<br/>            baseData=row<br/>        else:<br/>            baseData=np.vstack([baseData, row])<br/>        i=i+1      <br/>    <br/>    columnNames=["MolLogP","MolWt","NumRotatableBonds"]   <br/>    descriptors = pd.DataFrame(data=baseData,columns=columnNames)<br/>    <br/>    return descriptors</strong></span></pre><p id="14c5" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">让我们应用<code class="fe oq or os oh b">generate()</code>函数对<code class="fe oq or os oh b">sol.SMILES</code>(来自<code class="fe oq or os oh b">df</code>数据帧的微笑列)执行实际的描述符计算，并将描述符输出分配给<code class="fe oq or os oh b">df</code>变量。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="0c79" class="nv lp jj oh b gy ol om l on oo">df = generate(sol.SMILES)<br/>df</span></pre><p id="5983" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated"><code class="fe oq or os oh b">df</code>数据帧的输出如下所示。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/fd34f7df9b04df2741bfc922b2897665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bEI_-Y5TdJazov0J9SerQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">测向数据帧的内容。</p></figure><p id="a4d9" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated"><strong class="mi jt">3 . 3 . 2<em class="nh">。计算芳香比例<br/> </em> </strong>如上所述，计算<em class="nh">芳香比例</em>的方程式是用<em class="nh">芳香原子数</em>除以<em class="nh">重原子数</em>得到的。</p><p id="03eb" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">3.3.2.1。芳香原子数<br/> 这里我们将创建一个自定义函数来计算<strong class="mi jt">芳香原子数</strong>。有了这个描述符，我们可以用它来计算AP描述符。</p><p id="51eb" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">计算单个分子中芳香原子数的例子。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="8547" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">SMILES = 'COc1cccc2cc(C(=O)NCCCCN3CCN(c4cccc5nccnc54)CC3)oc21'</strong></span><span id="00a5" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">m = Chem.MolFromSmiles(SMILES)</strong></span><span id="6d0d" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">aromatic_atoms = [m.GetAtomWithIdx(i).GetIsAromatic() for i in range(m.GetNumAtoms())]</strong></span><span id="9745" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">aromatic_atoms</strong></span></pre><p id="fbad" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这给出了以下输出。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="324d" class="nv lp jj oh b gy ol om l on oo">[False,  False,  True,  True,  True,  True,  True,  True,  True,  False,  False,  False,  False,  False,  False,  False,  False,  False,  False,  False,  True,  True,  True,  True,  True,  True,  True,  True,  True,  True,  False,  False,  True,  True]</span></pre><p id="112c" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">现在让我们创建一个名为<code class="fe oq or os oh b">AromaticAtoms()</code>的自定义函数。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="0843" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">def AromaticAtoms(m):<br/>  aromatic_atoms = [m.GetAtomWithIdx(i).GetIsAromatic() for i in range(m.GetNumAtoms())]<br/>  aa_count = []<br/>  for i in aromatic_atoms:<br/>    if i==True:<br/>      aa_count.append(1)<br/>  sum_aa_count = sum(aa_count)<br/>  return sum_aa_count</strong></span></pre><p id="6fc8" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">现在，应用<code class="fe oq or os oh b">AromaticAtoms()</code>函数来计算查询SMILES字符串的芳香原子数。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="1abc" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">AromaticAtoms(m)</strong></span></pre><p id="8de0" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">输出是:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="8977" class="nv lp jj oh b gy ol om l on oo">19</span></pre><p id="15c2" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这意味着有19个芳香原子(即有19个原子是芳香环的一部分)。</p><p id="c56b" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">现在让我们扩大规模，并将其应用于整个微笑列表。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="d0b4" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">desc_AromaticAtoms = [AromaticAtoms(element) for element in mol_list]</strong></span><span id="65ae" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">desc_AromaticAtoms</strong></span></pre><p id="e1a8" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">现在，打印出结果。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="6ae2" class="nv lp jj oh b gy ol om l on oo">[0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 6, 0, 0, 0, 0, 6, 6, 0, 6, 6, 6, 6, 6, 0, 6, 6, 0, 0, 6, 10, 6, 6, 0, 6, 6, 6, 6, 10, 6, 0, 10, 0, 14, 0, 0, 14, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, ...]</span></pre><p id="7174" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">恭喜你！我们现在已经计算了整个数据集的芳香原子数。</p><p id="79ce" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">3.3.2.2。重原子数<br/> 这里，我们将使用rdkit库中的一个现有函数来计算重原子数。</p><p id="d688" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">计算单个分子重原子数的例子。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="4688" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">SMILES = 'COc1cccc2cc(C(=O)NCCCCN3CCN(c4cccc5nccnc54)CC3)oc21'<br/>m = Chem.MolFromSmiles(SMILES)<br/>Descriptors.HeavyAtomCount(m)</strong></span></pre><p id="2376" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这将产生以下输出。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="3579" class="nv lp jj oh b gy ol om l on oo">34</span></pre><p id="65c7" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">让我们扩大到整个微笑列表。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="e7ed" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">desc_HeavyAtomCount = [Descriptors.HeavyAtomCount(element) for element in mol_list]<br/>desc_HeavyAtomCount</strong></span></pre><p id="ee86" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">现在，打印出结果。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="0885" class="nv lp jj oh b gy ol om l on oo">[6, 5, 6, 5, 8, 4, 4, 8, 10, 10, 10, 9, 9, 10, 10, 10, 9, 9, 9, 8, 8, 4, 8, 4, 5, 8, 8, 10, 12, 4, 9, 9, 9, 15, 8, 4, 8, 8, 5, 8, 8, 12, 12, 8, 6, 8, 8, 10, 8, 12, 12, 5, 12, 6, 14, 11, 22, 15, 5, ...]</span></pre><p id="c9d7" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">3.3.2.3。计算芳香比例(AP)描述符<br/> 现在让我们把芳香原子数和重原子数结合在一起。</p><p id="b9e6" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">计算单个分子的例子。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="7fbd" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">SMILES = 'COc1cccc2cc(C(=O)NCCCCN3CCN(c4cccc5nccnc54)CC3)oc21'<br/>m = Chem.MolFromSmiles(SMILES)<br/>AromaticAtoms(m)/Descriptors.HeavyAtomCount(m)</strong></span></pre><p id="b9d0" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">输出是:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="0c58" class="nv lp jj oh b gy ol om l on oo">0.5588235294117647</span></pre><p id="27d0" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">让我们放大并计算整个微笑列表。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="dcf3" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">desc_AromaticProportion = [AromaticAtoms(element)/Descriptors.HeavyAtomCount(element) for element in mol_list]<br/>desc_AromaticProportion</strong></span></pre><p id="39e1" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这给出了输出:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="1a67" class="nv lp jj oh b gy ol om l on oo">[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.6, 0.6, 0.6666666666666666, 0.6666666666666666, 0.6, 0.6, 0.6, 0.6666666666666666, 0.6666666666666666, 0.6666666666666666, 0.75, 0.75, 0.0, 0.75, 0.0, 0.0, 0.0, 0.0, 0.6, 0.5, 0.0, 0.6666666666666666, 0.6666666666666666, 0.6666666666666666, 0.4, 0.75, 0.0, 0.75, 0.75, 0.0, 0.0, 0.75, 0.8333333333333334, 0.5, 0.75, 0.0, 0.75, 0.75, 0.6, 0.75, 0.8333333333333334, 0.5, ...]</span></pre><p id="3d55" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">现在让我们把这个新计算的<strong class="mi jt">芳烃比例</strong>描述符放到一个数据帧中。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/069a1c83649c2f9a4561f458fe7a4553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ad3EbGTFwtkWVAbpQ32SKg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">芳烃比例描述符数据帧的内容。</p></figure></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="63e3" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">3.4.数据集准备</h2><p id="d7e8" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated"><strong class="mi jt"> <em class="nh"> 3.4.1。创建X矩阵<br/> </em> </strong>让我们将2个数据帧中的所有计算描述符合并到1个数据帧中。在此之前，让我们先来看看我们将要组合的两个数据帧(<code class="fe oq or os oh b">df</code>和<code class="fe oq or os oh b">df_desc_AromaticProportion</code>)以及组合后的数据帧将会是什么样子，如下图所示。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/bef5c5031fd54a0940443e2bb9d04c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O750A4BB4vWVre2yf_sUhA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">组合两个包含描述符的数据帧以形成X矩阵的图示。</p></figure><p id="8a9f" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">让我们实际上结合2个数据帧来产生X矩阵。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="9d77" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">X = pd.concat([df,df_desc_AromaticProportion], axis=1)<br/>X</strong></span></pre><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/bde1666282540f6243056148cd04cfb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PvQ1_A5conVgE7790Sow0Q.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">通过组合两个数据帧创建的X矩阵数据帧的内容。</p></figure><p id="020a" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated"><strong class="mi jt">3 . 4 . 2<em class="nh">。创建Y矩阵<br/></em></strong>Y矩阵将从我们在本教程中要预测的1列中创建，这是对数值。在<code class="fe oq or os oh b">sol</code>数据框中，日志值包含在<code class="fe oq or os oh b">measured log(solubility:mol/L)</code>栏中。</p><p id="4334" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">让我们再看一下<code class="fe oq or os oh b">sol</code>数据框。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="5b56" class="nv lp jj oh b gy ol om l on oo">sol.head()</span></pre><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/cd70befe3808bbf34440aa18e75d9907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nbj1bGDKdS8bY__50q85qA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">突出显示日志列的sol数据框架的内容。</p></figure><p id="a1a4" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">对应于测得溶解度值(对数)的第二列(指数为1)将用作Y矩阵。因此，我们将选择第二列(在上图中以蓝色突出显示)。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="17ca" class="nv lp jj oh b gy ol om l on oo">Y = sol.iloc[:,1]<br/>Y</span></pre><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pl"><img src="../Images/7f019a8ec10d26d8b80ee72a2ddd5c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EujX5YwCT-dulwMoFpb4LA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Y矩阵的内容(对数列)。</p></figure></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="f0d7" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">3.5.数据分割</h2><p id="0b26" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated">我们现在将继续使用80/20的拆分比率来执行数据拆分(<em class="nh">即</em>我们通过将<code class="fe oq or os oh b">test_size</code>参数指定为0.2来完成此操作)，由此初始数据集的80%将用作训练集，而数据集的剩余20%将用作测试集。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="34cf" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">from sklearn.model_selection import train_test_split</strong></span><span id="ae3a" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">X_train, X_test, Y_train, Y_test = train_test_split(X, Y,<br/>                                                    test_size=0.2)</strong></span></pre></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="885b" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">3.6.线性回归模型</h2><p id="1aa7" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated">由于Delaney的最初研究和Walters的调查使用线性回归进行建模，因此为了便于比较，我们也将使用线性回归。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="2608" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">from sklearn import linear_model<br/>from sklearn.metrics import mean_squared_error, r2_score</strong></span><span id="4cf9" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">model = linear_model.LinearRegression()<br/>model.fit(X_train, Y_train)</strong></span></pre><p id="347d" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">在运行上面的代码块时，我们将看到下面的输出，它基本上打印出了用于模型构建的参数。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="b86d" class="nv lp jj oh b gy ol om l on oo">LinearRegression(copy_X=True, fit_intercept=True, n_jobs=None, normalize=False)</span></pre></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="804e" class="lo lp jj bd lq lr ls lt lu lv lw lx ly ky lz kz ma lb mb lc mc le md lf me mf bi translated">4.结果</h1><h2 id="b1bb" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">4.1.线性回归模型</h2><p id="4450" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated"><strong class="mi jt"> <em class="nh"> 4.1.1。预测X_train数据的对数值<br/> </em> </strong>来自第3.6节的训练模型将应用于此，以预测训练集中所有样本(分子)的对数值(<code class="fe oq or os oh b">X_train</code>)。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="39c2" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">Y_pred_train = model.predict(X_train)</strong></span><span id="3866" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">print('Coefficients:', model.coef_)<br/>print('Intercept:', model.intercept_)<br/>print('Mean squared error (MSE): %.2f'<br/>      % mean_squared_error(Y_train, Y_pred_train))<br/>print('Coefficient of determination (R^2): %.2f'<br/>      % r2_score(Y_train, Y_pred_train))</strong></span></pre><p id="7c16" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这将生成以下预测结果。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="3dc3" class="nv lp jj oh b gy ol om l on oo">Coefficients: [-0.7282008  -0.00691046  0.01625003 -0.35627645]<br/>Intercept: 0.26284383753800666<br/>Mean squared error (MSE): 0.99<br/>Coefficient of determination (R^2): 0.77</span></pre><p id="c282" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">让我们逐行分析上面的输出:</p><ul class=""><li id="f67d" class="ow ox jj mi b mj nc mm nd mp oy mt oz mx pa nb pm pc pd pe bi translated">在第一行，<code class="fe oq or os oh b">Coefficients</code>列出了每个独立变量的回归系数值(即由LogP、MW、RB和AP组成的4个分子描述符)</li><li id="fdd7" class="ow ox jj mi b mj pf mm pg mp ph mt pi mx pj nb pm pc pd pe bi translated">在第二行中，<code class="fe oq or os oh b">Intercept</code>实际上是X = 0时回归线经过的y截距值。</li><li id="c673" class="ow ox jj mi b mj pf mm pg mp ph mt pi mx pj nb pm pc pd pe bi translated">在第三行中，<code class="fe oq or os oh b">Mean squared error (MSE)</code>用作误差测量值(<em class="nh">即</em>越低越好)。</li><li id="f1e3" class="ow ox jj mi b mj pf mm pg mp ph mt pi mx pj nb pm pc pd pe bi translated">在第四行中，<code class="fe oq or os oh b">Coefficient of determination (R²)</code>是皮尔逊相关系数值的平方值，并用作线性回归模型的拟合优度的度量(<em class="nh">即</em>越高越好)</li></ul><p id="cd9c" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated"><strong class="mi jt">4 . 1 . 2<em class="nh">。预测X_test数据的对数值<br/> </em> </strong>接下来，来自3.6节的训练模型也将应用于此，以预测训练集中所有样本(分子)的对数值(<code class="fe oq or os oh b">X_train</code>)。</p><p id="d2fa" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">我们将打印出如下预测性能:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="4160" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">Y_pred_test = model.predict(X_test)</strong></span><span id="efde" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">print('Coefficients:', model.coef_)<br/>print('Intercept:', model.intercept_)<br/>print('Mean squared error (MSE): %.2f'<br/>      % mean_squared_error(Y_test, Y_pred_test))<br/>print('Coefficient of determination (R^2): %.2f'<br/>      % r2_score(Y_test, Y_pred_test))</strong></span></pre><p id="58f2" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">上述代码块产生以下预测结果。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="e614" class="nv lp jj oh b gy ol om l on oo">Coefficients: [-0.7282008  -0.00691046  0.01625003 -0.35627645]<br/>Intercept: 0.26284383753800666<br/>Mean squared error (MSE): 1.11<br/>Coefficient of determination (R^2): 0.75</span></pre></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="063b" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">4.2.比较线性回归方程</h2><p id="3360" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated"><a class="ae jg" href="https://pubs.acs.org/doi/10.1021/ci034243x" rel="noopener ugc nofollow" target="_blank">德莱尼</a>的工作提供了以下线性回归方程:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="3362" class="nv lp jj oh b gy ol om l on oo">LogS = 0.16 - 0.63 cLogP - 0.0062 MW + 0.066 RB - 0.74 AP</span></pre><p id="0788" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">由Pat Walters<a class="ae jg" href="http://practicalcheminformatics.blogspot.com/2018/09/predicting-aqueous-solubility-its.html" rel="noopener ugc nofollow" target="_blank">制作的复制品</a>提供了以下内容:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="d8db" class="nv lp jj oh b gy ol om l on oo">LogS = 0.26 - 0.74 LogP - 0.0066 MW + 0.0034 RB - 0.42 AP</span></pre><p id="17d1" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">本教程的复制给出了以下等式:</p><ul class=""><li id="deb0" class="ow ox jj mi b mj nc mm nd mp oy mt oz mx pa nb pm pc pd pe bi translated">基于列车组(如下文第4.3.1节所示)</li></ul><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="c8c8" class="nv lp jj oh b gy ol om l on oo">LogS =  0.26 - 0.73 LogP - 0.0069 MW 0.0163 RB - 0.36 AP</span></pre><ul class=""><li id="5e4c" class="ow ox jj mi b mj nc mm nd mp oy mt oz mx pa nb pm pc pd pe bi translated">基于完整的数据集(如下文第4.3.2节所示)</li></ul><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="ac01" class="nv lp jj oh b gy ol om l on oo">LogS =  0.26 - 0.74 LogP - 0.0066 MW + 0.0032 RB - 0.42 AP</span></pre></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="a65b" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">4.3.推导线性回归方程</h2><p id="d8eb" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated"><strong class="mi jt">4 . 3 . 1<em class="nh">。基于以下代码块中的训练集</em> </strong> <br/>，我们将使用第3.6节中构建的线性回归模型，其中训练集用于模型构建。为了便于参考，我将代码放在这里:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="9258" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">from sklearn import linear_model<br/>from sklearn.metrics import mean_squared_error, r2_score</strong></span><span id="5b9a" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">model = linear_model.LinearRegression()<br/>model.fit(X_train, Y_train)</strong></span></pre><p id="0a72" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">因此，我们只需直接从包含在<code class="fe oq or os oh b">model</code>变量中的先前构建的模型中打印出方程(<em class="nh">即</em>，通过调用模型变量的各个列)。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="d143" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">yintercept = '%.2f' % model.intercept_<br/>LogP = '%.2f LogP' % model.coef_[0]<br/>MW = '%.4f MW' % model.coef_[1]<br/>RB = '%.4f RB' % model.coef_[2]<br/>AP = '%.2f AP' % model.coef_[3]</strong></span><span id="2461" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">print('LogS = ' + <br/>      ' ' + <br/>      yintercept + <br/>      ' ' + <br/>      LogP + <br/>      ' ' + <br/>      MW + <br/>      ' ' + <br/>      RB + <br/>      ' ' + <br/>      AP)</strong></span></pre><p id="3561" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">运行上述代码块会得到以下等式输出:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="bb66" class="nv lp jj oh b gy ol om l on oo">LogS =  0.26 -0.73 LogP -0.0069 MW 0.0163 RB -0.36 AP</span></pre><p id="d0be" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated"><strong class="mi jt">4 . 3 . 2<em class="nh">。基于完整的数据集(用于比较)</em> </strong> <br/>这里我们将使用整个数据集来训练一个线性回归模型。<code class="fe oq or os oh b">fit()</code>功能允许使用X和Y数据矩阵作为输入参数来训练<code class="fe oq or os oh b">full</code> ( <em class="nh">即</em>线性回归模型)中定义的模型。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="3a7e" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">full = linear_model.LinearRegression()<br/>full.fit(X, Y)</strong></span></pre><p id="19fe" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这会产生以下输出:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="398a" class="nv lp jj oh b gy ol om l on oo">LinearRegression(copy_X=True, fit_intercept=True, n_jobs=None, normalize=False)</span></pre><p id="91c8" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">我们现在将打印出预测性能。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="19a8" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">full_pred = model.predict(X)</strong></span><span id="b373" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">print('Coefficients:', full.coef_)<br/>print('Intercept:', full.intercept_)<br/>print('Mean squared error (MSE): %.2f'<br/>      % mean_squared_error(Y, full_pred))<br/>print('Coefficient of determination (R^2): %.2f'<br/>      % r2_score(Y, full_pred))</strong></span></pre><p id="749c" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这将生成以下输出:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="3e7c" class="nv lp jj oh b gy ol om l on oo">Coefficients: [-0.74173609 -0.00659927  0.00320051 -0.42316387]<br/>Intercept: 0.2565006830997185<br/>Mean squared error (MSE): 1.01<br/>Coefficient of determination (R^2): 0.77</span></pre><p id="be92" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">最后，我们将打印出线性回归方程。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="2108" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">full_yintercept = '%.2f' % full.intercept_<br/>full_LogP = '%.2f LogP' % full.coef_[0]<br/>full_MW = '%.4f MW' % full.coef_[1]<br/>full_RB = '+ %.4f RB' % full.coef_[2]<br/>full_AP = '%.2f AP' % full.coef_[3]</strong></span><span id="6d9f" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">print('LogS = ' + <br/>      ' ' + <br/>      full_yintercept + <br/>      ' ' + <br/>      full_LogP + <br/>      ' ' + <br/>      full_MW + <br/>      ' ' + <br/>      full_RB + <br/>      ' ' + <br/>      full_AP)</strong></span></pre><p id="ffb8" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这将产生以下输出。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="eac0" class="nv lp jj oh b gy ol om l on oo">LogS =  0.26 -0.74 LogP -0.0066 MW + 0.0032 RB -0.42 AP</span></pre></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="de0c" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">4.4.实验测井与预测测井的散点图</h2><p id="3644" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated">在开始之前，让我们快速检查一下训练集和测试集的可变维度。</p><p id="898b" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这里我们正在检查列车组的尺寸。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="68d5" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">Y_train.shape, Y_pred_train.shape</strong></span></pre><p id="f3f4" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这会产生以下尺寸输出:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="eafd" class="nv lp jj oh b gy ol om l on oo">((915,), (915,))</span></pre><p id="f028" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这里我们检查测试集的维度。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="e5cb" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">Y_test.shape, Y_pred_test.shape</strong></span></pre><p id="541b" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated">这会产生以下尺寸输出:</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="cbee" class="nv lp jj oh b gy ol om l on oo">((229,), (229,))</span></pre><p id="7fa1" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated"><strong class="mi jt"> <em class="nh"> 4.4.1。垂直曲线图<br/> </em> </strong>现在让我们通过散点图来可视化实验对数值与预测对数值的相关性。我们将在两个散点图中分别显示测井曲线的实验值和预测值。在第一个版本中，我们将垂直堆叠两个散点图。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="de7c" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">import</strong> <strong class="oh jt">matplotlib.pyplot</strong> <strong class="oh jt">as</strong> <strong class="oh jt">plt</strong></span><span id="c63e" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">plt.figure(figsize=(5,11))<br/><br/><em class="nh"># 2 row, 1 column, plot 1</em><br/>plt.subplot(2, 1, 1)<br/>plt.scatter(x=Y_train, y=Y_pred_train, c="#7CAE00", alpha=0.3)<br/><br/><em class="nh"># Add trendline</em><br/><em class="nh"># https://stackoverflow.com/questions/26447191/how-to-add-trendline-in-python-matplotlib-dot-scatter-graphs</em><br/>z = np.polyfit(Y_train, Y_pred_train, 1)<br/>p = np.poly1d(z)<br/>plt.plot(Y_test,p(Y_test),"#F8766D")<br/><br/>plt.ylabel('Predicted LogS')<br/><br/><br/><em class="nh"># 2 row, 1 column, plot 2</em><br/>plt.subplot(2, 1, 2)<br/>plt.scatter(x=Y_test, y=Y_pred_test, c="#619CFF", alpha=0.3)<br/><br/>z = np.polyfit(Y_test, Y_pred_test, 1)<br/>p = np.poly1d(z)<br/>plt.plot(Y_test,p(Y_test),"#F8766D")<br/><br/>plt.ylabel('Predicted LogS')<br/>plt.xlabel('Experimental LogS')<br/><br/>plt.savefig('plot_vertical_logS.png')<br/>plt.savefig('plot_vertical_logS.pdf')<br/>plt.show()</strong></span></pre><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/e4bb2d436b583d803b19e2156a02ceeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*0GXKMba_x5MF_XJ1syAFEg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">预测值与实验值的散点图(显示为垂直图)。</p></figure><p id="2fee" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated"><strong class="mi jt"> <em class="nh"> 4.4.2。水平图<br/> </em> </strong>在第二个版本中，我们将水平放置两个散点图，如下面的代码块所示。</p><pre class="nk nl nm nn gt og oh oi oj aw ok bi"><span id="d913" class="nv lp jj oh b gy ol om l on oo"><strong class="oh jt">import</strong> <strong class="oh jt">matplotlib.pyplot</strong> <strong class="oh jt">as</strong> <strong class="oh jt">plt</strong></span><span id="82c2" class="nv lp jj oh b gy ov om l on oo"><strong class="oh jt">plt.figure(figsize=(11,5))<br/><br/><em class="nh"># 1 row, 2 column, plot 1</em><br/>plt.subplot(1, 2, 1)<br/>plt.scatter(x=Y_train, y=Y_pred_train, c="#7CAE00", alpha=0.3)<br/><br/>z = np.polyfit(Y_train, Y_pred_train, 1)<br/>p = np.poly1d(z)<br/>plt.plot(Y_test,p(Y_test),"#F8766D")<br/><br/>plt.ylabel('Predicted LogS')<br/>plt.xlabel('Experimental LogS')<br/><br/><em class="nh"># 1 row, 2 column, plot 2</em><br/>plt.subplot(1, 2, 2)<br/>plt.scatter(x=Y_test, y=Y_pred_test, c="#619CFF", alpha=0.3)<br/><br/>z = np.polyfit(Y_test, Y_pred_test, 1)<br/>p = np.poly1d(z)<br/>plt.plot(Y_test,p(Y_test),"#F8766D")<br/><br/>plt.xlabel('Experimental LogS')<br/><br/>plt.savefig('plot_horizontal_logS.png')<br/>plt.savefig('plot_horizontal_logS.pdf')<br/>plt.show()</strong></span></pre><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div class="gh gi po"><img src="../Images/6e0e9daf6611f637b063ecb89af16fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*7z_NBy44XoOz0eide7ia-w.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">预测值与实验值的散点图(显示为水平图)。</p></figure></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="fd46" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated"><a class="ae jg" href="http://newsletter.dataprofessor.org/" rel="noopener ugc nofollow" target="_blank">订阅我的邮件列表，获取我在数据科学方面的最佳更新(偶尔还有免费内容)!</a></h2></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="b713" class="lo lp jj bd lq lr ls lt lu lv lw lx ly ky lz kz ma lb mb lc mc le md lf me mf bi translated">关于我</h1><p id="ca30" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated">我是泰国一所研究型大学的生物信息学副教授和数据挖掘和生物医学信息学负责人。在我下班后的时间里，我是一名YouTuber(又名<a class="ae jg" href="http://bit.ly/dataprofessor/" rel="noopener ugc nofollow" target="_blank">数据教授</a>)制作关于数据科学的在线视频。在我做的所有教程视频中，我也在GitHub上分享Jupyter笔记本(<a class="ae jg" href="https://github.com/dataprofessor/" rel="noopener ugc nofollow" target="_blank">数据教授GitHub page </a>)。</p><div class="is it gp gr iu pp"><a href="https://www.youtube.com/dataprofessor?sub_confirmation=1" rel="noopener  ugc nofollow" target="_blank"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd jt gy z fp pu fr fs pv fu fw js bi translated">数据教授</h2><div class="pw l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">数据科学、机器学习、生物信息学、研究和教学是我的激情所在。数据教授YouTube…</h3></div><div class="px l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">www.youtube.com</p></div></div><div class="py l"><div class="pz l qa qb qc py qd ja pp"/></div></div></a></div><h2 id="9693" class="nv lp jj bd lq nw nx dn lu ny nz dp ly mp oa ob ma mt oc od mc mx oe of me jp bi translated">在社交网络上与我联系</h2><p id="2675" class="pw-post-body-paragraph mg mh jj mi b mj mk kt ml mm mn kw mo mp mq mr ms mt mu mv mw mx my mz na nb im bi translated">✅YouTube:<a class="ae jg" href="http://youtube.com/dataprofessor/" rel="noopener ugc nofollow" target="_blank">http://youtube.com/dataprofessor/</a><br/>♇网站:<a class="ae jg" href="https://www.youtube.com/redirect?redir_token=w4MajL6v6Oi_kOAZNbMprRRJrvJ8MTU5MjI5NjQzN0AxNTkyMjEwMDM3&amp;q=http%3A%2F%2Fdataprofessor.org%2F&amp;event=video_description&amp;v=ZZ4B0QUHuNc" rel="noopener ugc nofollow" target="_blank">http://dataprofessor.org/</a>(在建)<br/>♇LinkedIn:<a class="ae jg" href="https://www.linkedin.com/company/dataprofessor/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/company/dataprofessor/</a><br/>♇Twitter:<a class="ae jg" href="https://twitter.com/thedataprof" rel="noopener ugc nofollow" target="_blank">https://twitter.com/thedataprof</a><br/>♇Facebook:<a class="ae jg" href="https://www.youtube.com/redirect?redir_token=w4MajL6v6Oi_kOAZNbMprRRJrvJ8MTU5MjI5NjQzN0AxNTkyMjEwMDM3&amp;q=http%3A%2F%2Ffacebook.com%2Fdataprofessor%2F&amp;event=video_description&amp;v=ZZ4B0QUHuNc" rel="noopener ugc nofollow" target="_blank">http://facebook.com/dataprofessor/</a><br/>♇github:<a class="ae jg" href="https://github.com/dataprofessor/" rel="noopener ugc nofollow" target="_blank">https://github.com/dataprofessor/</a><br/>♇insta gram:<a class="ae jg" href="https://www.instagram.com/data.professor/" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/data.professor/【t19</a></p><p id="ee9d" class="pw-post-body-paragraph mg mh jj mi b mj nc kt ml mm nd kw mo mp ne mr ms mt nf mv mw mx ng mz na nb im bi translated"><strong class="mi jt"> <em class="nh">来自《走向数据科学》编辑的注释:</em> </strong> <em class="nh">虽然我们允许独立作者根据我们的</em> <a class="ae jg" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="nh">规则和指导方针</em> </a> <em class="nh">发表文章，但我们并不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae jg" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="nh">读者术语</em> </a> <em class="nh">。</em></p></div></div>    
</body>
</html>