<html>
<head>
<title>Creating Facial Recognition Software with Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习创建面部识别软件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-facial-recognition-software-with-deep-learning-b79931f24c5f?source=collection_archive---------56-----------------------#2020-09-08">https://towardsdatascience.com/creating-facial-recognition-software-with-deep-learning-b79931f24c5f?source=collection_archive---------56-----------------------#2020-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7e2b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">使用 Keras 和 OpenCV </em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/b2e1872b610e1489863213926063a78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUMexU3zpd10SkvMzt64oA.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank"> pixabay </a>在<a class="ae kz" href="https://www.pexels.com/photo/abstract-art-blur-bright-373543/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="1065" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">虽然用机器学习来进行面部识别的想法很早就被人知道了，但是自己创作这个软件还是挺有用的。</p><h1 id="f902" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">概念:</h1><p id="57b0" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">本文的目标是创建一个二元分类面部识别网络，允许一个人访问，而不允许另一个人访问。</p><p id="dbf9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我将使用 open-cv 访问计算机中的内置摄像头，并使用 haar-cascade 分类器来检测图像中的人脸。收集数据后，我会使用卷积神经网络对数据进行模型训练。</p><p id="3da3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">之后，当 OpenCV 检测到被授予访问权限的人时，它会在他/她的脸部周围画一个正方形，正方形上有“访问已验证”的字样。</p><h1 id="6dcd" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">代码:</h1><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="e10d" class="my lx it mu b gy mz na l nb nc">from numpy import unique<br/>from numpy import argmax<br/>import os<br/>import cv2<br/>from PIL import Image<br/>import numpy as np<br/>from tensorflow.keras import Sequential<br/>from tensorflow.keras import optimizers<br/>from tensorflow.keras.layers import Dense<br/>from tensorflow.keras.layers import Conv2D<br/>from tensorflow.keras.layers import MaxPooling2D<br/>from tensorflow.keras.layers import Flatten<br/>from tensorflow.keras.layers import Dropout<br/>from tensorflow.keras.layers import BatchNormalization<br/>from tensorflow.keras.layers import Dropout</span></pre><p id="6ec4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除了标准的 numpy 和 os 库用于数据访问和数据操作，我还使用 open-cv 和 PIL 进行图像处理。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="a666" class="my lx it mu b gy mz na l nb nc">def data_path():<br/>    file = 'XXXXXXXX'<br/>    os.chdir(file)<br/>    files = os.listdir()<br/>    files.remove('.DS_Store')<br/>    return file,files</span></pre><p id="c223" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是访问你计算机中数据的功能。要使此函数工作，请将变量文件更改为数据所在的相关目录。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="fb57" class="my lx it mu b gy mz na l nb nc">def data_setup(files,file):<br/>    pixels = [0]*len(files)<br/>    answers = list()<br/>    print(len(files))<br/>    for i in range(len(files)):<br/>        image = Image.open(files[i])<br/>        pixels[i]= np.asarray(image)<br/>        pixels[i] = pixels[i].astype('float32')<br/>        pixels[i] /= 210.0<br/>        if files[i][0] == 'm':<br/>            answers.append(1)<br/>        elif files[i][0] == 'n':<br/>            answers.append(0)<br/>    dataset = np.array(pixels)<br/>    for i in range(len(dataset)):<br/>        dataset[i] = dataset[i].reshape(320,320)<br/>    return np.asarray(dataset),np.asarray(answers)</span></pre><p id="b358" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">该函数访问数据，并将所有照片重新整形为 320 x 320 的图片。然后，它返回 X 和 y 值，即数据和真值。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="610f" class="my lx it mu b gy mz na l nb nc">def train(data,answers):<br/>    x_train = data<br/>    y_train = answers<br/>    x_train = np.array(x_train)<br/>    x_train = x_train.reshape((x_train.shape[0], x_train.shape[1], x_train.shape[2], 1))<br/>    print(x_train.shape)<br/>    in_shape = x_train.shape[1:]<br/>    print(len(data),len(answers))<br/>    model = Sequential()<br/>    model.add(Conv2D(10, (3,3), activation='relu', kernel_initializer='he_uniform', input_shape=in_shape))<br/>    model.add(MaxPooling2D((2, 2)))<br/>    model.add(Conv2D(10, (3,3), activation='relu', kernel_initializer='he_uniform', input_shape=in_shape))<br/>    model.add(MaxPooling2D((2, 2)))<br/>    model.add(Flatten())<br/>    model.add(Dense(1,activation ='sigmoid'))<br/>    model.compile(optimizer='adam', loss='binary_crossentropy',metrics = ['accuracy'])<br/>    model.fit(x_train, y_train, epochs=100, batch_size=100, verbose = 2, validation_split = 0.33)<br/>    return model</span></pre><p id="38ee" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个脚本创建、编译和训练卷积网络。使用的损失是二进制交叉熵，度量是准确度，因为我们希望网络以高准确度预测正确的人脸。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="2cf4" class="my lx it mu b gy mz na l nb nc">def face_recognition(model):<br/>    dirx = 'XXXXXXXXXXXXXXXXXXXXXXXXXX'<br/>    os.chdir(dirx)<br/>    face_cascade = cv2.CascadeClassifier('cascades/data/haarcascade_frontalface_alt.xml')<br/>    cap = cv2.VideoCapture(0)<br/>    while True:<br/>        ret,frame = cap.read()<br/>        gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<br/>        faces = face_cascade.detectMultiScale(gray,scaleFactor = 1.05, minNeighbors = 5)<br/>        for (x,y,w,h) in faces:<br/>            print('Face Detected')<br/>            roi_gray = gray[y:y+h,x:x+w]<br/>            roi_color = frame[y:y+h,x:x+w]<br/>            roi_gray = roi_gray.astype('float32')<br/>            roi_gray /= 210.0<br/>            classify = cv2.resize(roi_gray,(320,320))<br/>            if classify.shape == (320,320):<br/>                classify = classify.reshape((1, classify.shape[0], classify.shape[1], 1))<br/>                color = (255,0,0)<br/>                stroke = 2<br/>                end_cord_x = x+w<br/>                end_cord_y = y+h<br/>                pred = model.predict(classify)<br/>                print(pred)<br/>                if pred == 1:<br/>                    cv2.rectangle(frame,(x,y),(end_cord_x,end_cord_y),color,stroke)<br/>                    cv2.putText(frame, 'Access', (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (36,255,12), 2)<br/>                elif pred == 0:<br/>                    cv2.rectangle(frame,(x,y),(end_cord_x,end_cord_y),color,stroke)<br/>                    cv2.putText(frame, 'Denied Access', (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (36,255,12), 2)<br/>        if cv2.waitKey(20) &amp; 0xFF == ord('q'):<br/>            break<br/>        cv2.imshow('frame',frame)</span></pre><p id="76cd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">该脚本应用模型并实时进行预测，创建并标记有面的盒子。要使这个函数工作，您必须再次确定 haar-cascade 在哪个目录中。您可能需要将文件夹从外部位置移到正确的目录。</p><pre class="kk kl km kn gt mt mu mv mw aw mx bi"><span id="ac87" class="my lx it mu b gy mz na l nb nc">file,files=data_path()<br/>data,answers = data_setup(files,file)<br/>model = train(data,answers)<br/>face_recognition(model)</span></pre><p id="43cb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">程序的最后一部分操作所有功能，并启动实时面部识别。</p><h1 id="c9d9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">如何改进我的计划:</h1><p id="44e6" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">当我写程序时，我总是分享一个强大的框架，在那里可以添加更复杂的功能。以下是一些可以增加程序功能的方法:</p><ul class=""><li id="c425" class="nd ne it lc b ld le lg lh lj nf ln ng lr nh lv ni nj nk nl bi translated">多类分类</li></ul><p id="a56f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当给定每个人的一组平衡的照片时，尝试训练模型来预测这个人是谁，而不是二进制分类。</p><ul class=""><li id="c456" class="nd ne it lc b ld le lg lh lj nf ln ng lr nh lv ni nj nk nl bi translated">添加更多的哈尔级联分类器</li></ul><p id="598f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我使用的 haar-cascade 是正面人脸 cascade，只能检测正面人脸照片。你可以添加更多的分类器，这将使它工作，不管相机的角度。</p><h1 id="108e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">我的链接:</h1><p id="a665" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">如果你想看更多我的内容，点击这个<a class="ae kz" href="https://linktr.ee/victorsi" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iu">链接</strong> </a>。</p></div></div>    
</body>
</html>