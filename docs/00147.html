<html>
<head>
<title>Iterate Your R Code Efficiently!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高效迭代您的R代码！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/iterate-your-r-code-efficiently-3c621998eaea?source=collection_archive---------10-----------------------#2020-01-05">https://towardsdatascience.com/iterate-your-r-code-efficiently-3c621998eaea?source=collection_archive---------10-----------------------#2020-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8032" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在r中执行干净有效的迭代的一步一步的指南。</h2></div><p id="6d9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因纽特人实际上并没有一百个关于雪的名字。原来这是部分神话和部分误解。将类似的类比扩展到web speak，大约有一百种迭代代码的方法！除此之外，<em class="le"> </em>语法可能会令人困惑，我们中的一些人还会冒险懒散地求助于<em class="le">复制粘贴</em>代码4次。但重要的是要认识到，这是一条次优路线，坦率地说不切实际。根据一般经验，如果我们需要运行一个代码块两次以上，迭代是一个好主意！这有两个原因可以让你的代码更加丰富</p><ol class=""><li id="83e5" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated">它将注意力吸引到不同的代码部分，从而更容易发现操作的意图。</li><li id="b57b" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">由于其简洁的本质，您可能会遇到更少的错误。</li></ol><p id="7efc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可能需要一些时间来理解迭代的概念，但是相信我，这是值得的。</p><p id="53a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然你已经被说服去迭代——让我们直接开始吧！</p><p id="80ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们挑选内置的R数据集- <em class="le">空气质量。</em>以下是其中的一个片段-</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="49b3" class="mc md it ly b gy me mf l mg mh">   Ozone Solar.R  Wind Temp Month Day<br/>    41     190    7.4   67     5   1<br/>    36     118    8.0   72     5   2<br/>    12     149   12.6   74     5   3<br/>    18     313   11.5   62     5   4<br/>    23     299    8.6   65     5   7<br/>    19      99   13.8   59     5   8</span></pre><p id="ea4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">问题1 </strong>:你想求数据集中每个变量的标准差-</p><p id="7fea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以为每一列复制粘贴相同的代码</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="481f" class="mc md it ly b gy me mf l mg mh">sd(airquality$Ozone)<br/><em class="le"> 33.27597</em></span><span id="4ee5" class="mc md it ly b gy mi mf l mg mh">sd(airquality$Solar.R)<br/><em class="le">91.1523</em></span><span id="60ea" class="mc md it ly b gy mi mf l mg mh">sd(airquality$Wind)<br/><em class="le">3.557713</em></span><span id="76b8" class="mc md it ly b gy mi mf l mg mh">sd(airquality$Temp)<br/><em class="le">9.529969</em></span><span id="ee34" class="mc md it ly b gy mi mf l mg mh">sd(airquality$Month)<br/><em class="le">1.473434</em></span><span id="9c80" class="mc md it ly b gy mi mf l mg mh">sd(airquality$Day)<br/><em class="le">8.707194</em></span></pre><p id="f879" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，这对于大型数据集来说是不切实际的，并且打破了相同操作不运行两次以上的经验法则。我们有一个坚实的案例来迭代！</p><p id="635f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写一个<code class="fe mj mk ml ly b">for()</code>循环-</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5b28" class="mc md it ly b gy me mf l mg mh">stddev = vector("double", ncol(airquality))</span><span id="3706" class="mc md it ly b gy mi mf l mg mh">for(i in seq_along(airquality))             <br/>{<br/> stddev[[i]] = sd(airquality[[i]])          <br/> <br/>}<br/>stddev<br/><em class="le">33.275969 91.152302  3.557713  9.529969  1.473434  8.707194</em></span></pre><p id="b8fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该循环消除了任何重复，确实比第一种方法更有效。</p><p id="d06b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还必须暂停一下，注意虽然<code class="fe mj mk ml ly b">seq_along()</code>和<code class="fe mj mk ml ly b">length()</code>在for循环中通常交替使用来构建序列，但是有一个关键的区别。在零长度向量的情况下，<code class="fe mj mk ml ly b">seq_along()</code>做正确的事情，但是<code class="fe mj mk ml ly b">length()</code>取0和1的值。虽然您可能不会故意创建零长度向量，但很容易意外地创建它们。如果你使用<code class="fe mj mk ml ly b">1:length()</code>而不是<code class="fe mj mk ml ly b">seq_along()</code>，你可能会得到一个令人困惑的错误信息</p><p id="e0e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者你可以<em class="le">跳过</em>循环，用<em class="le">只用</em>一行来自base R的<code class="fe mj mk ml ly b">apply()</code>系列的<code class="fe mj mk ml ly b">sapply()</code>代码来完成这个技巧</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="19f3" class="mc md it ly b gy me mf l mg mh">sapply(airquality, sd)</span><span id="fbbc" class="mc md it ly b gy mi mf l mg mh"> Ozone      Solar.R      Wind      Temp     Month     Day <br/><em class="le">33.275969 91.152302  3.557713  9.529969  1.473434  8.707194</em></span></pre><p id="2aaa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是对R函数式编程能力的一个很好的应用，确实非常灵活地完成了工作。</p><p id="4588" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们在复杂性的阶梯上再跨一步，看看另一个问题。</p><p id="faaf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">问题2 </strong>:你想求出你的数据集中每一列的标准差<em class="le">和</em>中位数。</p><p id="fa84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们已经确定第一种方法<em class="le">复制粘贴</em>是不切实际的，我们权衡我们的迭代选项。</p><p id="b5a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从编写一个<code class="fe mj mk ml ly b">for()</code>循环开始-</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="4caa" class="mc md it ly b gy me mf l mg mh">stddev =vector("double", ncol(airquality))<br/> median =vector("double", ncol(airquality))</span><span id="b929" class="mc md it ly b gy mi mf l mg mh">for(i in seq_along(airquality))<br/> {<br/>   stddev[[i]] = sd(airquality[[i]])<br/>   median[[i]] = median(airquality[[i]])<br/>  }</span><span id="d4d2" class="mc md it ly b gy mi mf l mg mh"> stddev<br/> 33.275969 91.152302  3.557713  9.529969  1.473434  8.707194<br/> median<br/> 31.0 207.0   9.7  79.0   7.0  16.0</span></pre><p id="4748" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们走函数式编程路线。这里，不像前面的例子，我们可以直接使用R的内置<code class="fe mj mk ml ly b">sd()</code>函数来计算标准偏差并通过<code class="fe mj mk ml ly b">sapply()</code>传递，我们需要创建一个自定义函数，因为我们需要计算标准偏差和中位数。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="9e74" class="mc md it ly b gy me mf l mg mh">f &lt;- function(x){<br/>    list(sd(x),median(x))<br/> }</span><span id="9576" class="mc md it ly b gy mi mf l mg mh">sapply(airquality, f)</span><span id="1adc" class="mc md it ly b gy mi mf l mg mh">Ozone    Solar.R Wind     Temp     Month    Day     <br/>33.27597 91.1523 3.557713 9.529969 1.473434 8.707194<br/>31       207     9.7      79       7        16</span></pre><p id="f179" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个非常坚实的想法！将用户构建的函数传递给另一个函数的能力令人激动，并且清楚地展示了R解决各种任务的函数式编程能力。事实上，经验丰富的R用户很少使用循环，而是求助于函数式编程技术来解决所有的迭代任务。如上所述，在base R中应用函数族(<code class="fe mj mk ml ly b">apply()</code>、<code class="fe mj mk ml ly b">lapply()</code>、<code class="fe mj mk ml ly b">tapply()</code>等)是一种很好的方式，但是即使在函数式编程领域，也有一个包成为了人们的最爱——<em class="le">Purrr</em>。<em class="le"> purrr </em>系列函数具有更加一致的语法，并且内置了执行各种常见迭代任务的功能。</p><p id="c5d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Map() 函数构成了purrr迭代能力的基础。这是它的一些表现形式-</p><ul class=""><li id="d377" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld mm ll lm ln bi translated"><code class="fe mj mk ml ly b">map()</code>列清单。</li><li id="4664" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld mm ll lm ln bi translated"><code class="fe mj mk ml ly b">map_lgl()</code>做一个逻辑向量。</li><li id="fdc9" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld mm ll lm ln bi translated"><code class="fe mj mk ml ly b">map_int()</code>生成一个整数向量。</li><li id="c7ea" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld mm ll lm ln bi translated"><code class="fe mj mk ml ly b">map_dbl()</code>生成双向量。</li><li id="7fa5" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld mm ll lm ln bi translated"><code class="fe mj mk ml ly b">map_chr()</code>生成一个字符向量。</li></ul><p id="335a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用这个想法来解决我们之前计算每一列的中值和标准差的问题-</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b7cb" class="mc md it ly b gy me mf l mg mh">map_df(airquality, ~list(med = median(.x), sd = sd(.x)))</span></pre><p id="779a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，为了在复杂性阶梯上的另一个飞跃，让我们从<em class="le"> gapminder </em>库<em class="le">中挑选<em class="le"> gapminder </em>数据集。下面是其中的一个片段。(注:如果你没有听说过gapminder基金会，请点击这里查看它的网站。该基金会在将基本的全球事实放入背景中做了一些开创性的工作)</em></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5294" class="mc md it ly b gy me mf l mg mh">  country   continent year lifeExp  pop  gdpPercap<br/>  Afghanistan Asia     1952   28.8  8425333  779.<br/>  Afghanistan Asia     1957   30.3  9240934  821.<br/>  Afghanistan Asia     1962   32.0  10267083 853.<br/>  Afghanistan Asia     1967   34.0  11537966 836.<br/>  Afghanistan Asia     1972   36.1  13079460 740.<br/>  Afghanistan Asia     1977   38.4  14880372 786.</span></pre><p id="af89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">问题三:</strong>我想知道各大洲，各年份，哪个国家的人均GDP最高？</p><p id="791e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mj mk ml ly b">for()</code>循环方法-</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5c99" class="mc md it ly b gy me mf l mg mh">list = c(“continent”, “year”)<br/>DF= data.frame()</span><span id="8879" class="mc md it ly b gy mi mf l mg mh">for( i in list)<br/>{<br/> df = gapminder %&gt;% group_by_at(i) %&gt;% <br/> top_n(1, gdpPercap) %&gt;% <br/> mutate(Remark = paste0(“Country Max GDP Per capita in the “,i)) %&gt;% <br/> data.frame()<br/> DF = rbind(df,DF)<br/>}<br/>DF</span></pre><p id="eca4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mj mk ml ly b">Apply()</code>方法-</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="571f" class="mc md it ly b gy me mf l mg mh">do.call(rbind, lapply(list, function(x)<br/>{<br/>  gapminder %&gt;% group_by_at(x) %&gt;% <br/>    top_n(1, gdpPercap)%&gt;%<br/>    mutate(Remark = paste0("Country with the max GDP Per capita in the ",x)) %&gt;% <br/>    data.frame<br/>}))</span></pre><p id="cedf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mj mk ml ly b">Purrr::Map()</code>方法-</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5944" class="mc md it ly b gy me mf l mg mh">gapminder$year = as.character(gapminder$year)<br/>map_dfr(list, ~gapminder %&gt;% group_by(!!sym(.x)) %&gt;% <br/> top_n(1, gdpPercap)%&gt;%<br/> mutate(Remark = paste0(“Country with the max GDP Per capita in the “,.x)) %&gt;% data.frame()</span></pre><p id="94da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上三种方法都产生相同的输出(为了简洁起见，我没有在这里包括输出。你可以在我的Github <a class="ae mn" href="https://github.com/manasi1096/Iterations-in-R" rel="noopener ugc nofollow" target="_blank">这里</a>看看。同样，虽然您可以选择想要采用的迭代路线，但是函数式编程方式在cogency方面是明显的赢家。</p><p id="6943" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le"> Purrr </em>也有一些处理日常迭代任务的内置函数！下面我列出了几个受欢迎的。</p><p id="a0bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">任务</em> </strong>:对每一段数据进行分段回归。(这里，大陆):</p><p id="b84e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le"> Purrr解决方案</em> </strong>:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="548c" class="mc md it ly b gy me mf l mg mh">gapminder %&gt;% <br/> split(.$Continent) %&gt;% <br/> map(~lm(gdpPercap ~ lifeExp, data = .))</span></pre><p id="2bbb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">任务</strong>:保持变量基于任意条件。(此处，如果变量是因子):</p><p id="0c73" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"><em class="le"/></strong>:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="6833" class="mc md it ly b gy me mf l mg mh">gapminder %&gt;% <br/>  keep(is.factor) %&gt;% <br/>  str()</span></pre><p id="953a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">任务:</strong>检查任意变量是否满足任意条件(此处，任意变量是否为字符):</p><p id="82e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le"> Purrr解决方案:</em> </strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="8300" class="mc md it ly b gy me mf l mg mh">gapminder%&gt;% <br/>  some(is_character)</span></pre><p id="ff03" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">任务:</strong>检查每个变量是否满足任意条件(这里，如果每个变量都是整数):</p><p id="5292" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le"> Purrr解决方案:</em> </strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7bbc" class="mc md it ly b gy me mf l mg mh">gapminder %&gt;% <br/>  <!-- -->every(is.integer)<!-- -->)</span></pre><p id="c69c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦你习惯了<em class="le"> purrr </em>的语法，你将需要更少的时间来用r编写迭代代码。然而，你绝不能因为用r编写循环而感觉不好。事实上，它们是编程的基本模块之一，并且在其他语言中被大量使用。有些人甚至称循环为慢。他们错了！(好吧至少它们已经相当过时了，至于loops已经很多年没慢过了)。使用像<code class="fe mj mk ml ly b">map()</code>和<code class="fe mj mk ml ly b">apply()</code>这样的函数的主要好处不是速度，而是清晰:它们使你的代码更容易编写和阅读。</p><blockquote class="mo"><p id="39c1" class="mp mq it bd mr ms mt mu mv mw mx ld dk translated">重要的是你要解决你正在处理的问题，而不是写出最简洁优雅的代码(尽管那绝对是你想要努力的方向！)——哈德利·韦翰</p></blockquote><p id="35c1" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">感谢阅读！你可以在我的Github <a class="ae mn" href="https://github.com/manasi1096/Iterations-in-R" rel="noopener ugc nofollow" target="_blank">这里</a>查看代码，或者在这里联系我<a class="ae mn" href="https://www.linkedin.com/in/manasi-mahadik-a66b26146/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>