<html>
<head>
<title>Understanding Combinatorics: Number of Paths on a Grid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解组合学:网格上的路径数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-combinatorics-number-of-paths-on-a-grid-bddf08e28384?source=collection_archive---------6-----------------------#2020-04-10">https://towardsdatascience.com/understanding-combinatorics-number-of-paths-on-a-grid-bddf08e28384?source=collection_archive---------6-----------------------#2020-04-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9d50" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你能数出一个普通的 WxH 网格上有多少条路径吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f6008431910a646bcdfc980571ee2992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iLbduXU_1w1sTvh5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@leliejens?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">延斯·勒列</a>拍摄</p></figure><p id="b93f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> B </span> asic 组合学是编程人员不可或缺的工具，无论是开发人员、人工智能专家还是数据科学家。</p><blockquote class="me"><p id="e119" class="mf mg it bd mh mi mj mk ml mm mn lu dk translated">在本文中，我们将解决一个简单的组合问题:计算从一个普通 WxH 网格的一个角到另一个角的路径数。</p></blockquote><p id="018d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们从这个 3x3 的网格开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/3e121609298311a7a032f991b772af9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*_V3xKwyhgjLhCnIA97lLUA.png"/></div></figure><p id="a151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想从橙色方块到绿色方块。每一步我们都可能向右或向下移动。我们将用 R 表示向右移动的<strong class="lb iu">，用 D </strong>表示向下移动的<strong class="lb iu">。我们感兴趣的是我们可以选择的不同路径的数量。让我们手动列举路径:</strong></p><ul class=""><li id="f5aa" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">RRDD</li><li id="4c25" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">DDRR</li><li id="029c" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">RDRD</li><li id="6af4" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">DRDR</li><li id="52ae" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">RDDR</li><li id="f1a6" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">DRRD</li></ul><p id="4b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以得出结论，在这个网格中有<strong class="lb iu"> 6 条不同的路径</strong>。现在来看看这个 8×8 的网格:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/d6e7da3b550073fb390bbc208babba5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*ZPfPZf2wqOF5bOgopWCjzg.png"/></div></figure><p id="0860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你试图计算这个网格上的路径数，这将花费你相当长的时间。我们需要一些更聪明的数学方法。首先要注意的是，我们要走的步数并不取决于所走的路。</p><blockquote class="me"><p id="8dbe" class="mf mg it bd mh mi mj mk ml mm mn lu dk translated">以步数计算的距离总是一样的。</p></blockquote><p id="404f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个距离也被称为<strong class="lb iu"> L1 距离、城市街区距离或曼哈顿距离</strong>，因为纽约市中心的街区是方形的。</p><p id="254c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，我们注意到在正方形网格上，由于对称性，R 移动的次数必须等于 D 移动的次数。此外，我们在每条路径上需要 7+7=14 步(你可以很容易地沿着网格的边界移动)。这两个要求使得以如下方式重新定义 8×8 栅格的问题成为可能:</p><blockquote class="me"><p id="9f8d" class="mf mg it bd mh mi mj mk ml mm mn lu dk translated">找出字符串 RRRRRRRDDDDDDD 的不同排列的数目。</p></blockquote><p id="d89e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，排列的数量通常由<em class="nj"> N 定义！或 N*(N-1)*(N-2)*…*2 </em>，也称<strong class="lb iu">阶乘</strong>。据此，<em class="nj"> N </em>为弦的长度。在我们的情况下，14！= 87178291200.然而，我们必须考虑这样一个事实，即 R 和 D 的顺序并不重要；他们是一样的。两者不同排列的数量是 7！= 5040.我们必须数两遍这个数字，因为 R 和 D 是无法区分的。换句话说，我们分 14！7 点前！*7!。这给了我们 3432，这是正确的答案。</p><p id="cc73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将我们的公式推广到任何 NxN 网格，我们可以写成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/6cf82e5b5749e1d71187661c7578fc00.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*qXMWqcsFUVd9JpWzQlw7XQ.png"/></div></figure><p id="647d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，还有一种更简单的写法:<strong class="lb iu">数字 D = N！/ (K！* (N-K)！)也叫二项式系数，我们可以写成(N 选 K) </strong>。这个数字表示我们可以从一袋 N 个物体中挑选 K 个物体的方法的数量，不考虑挑选的顺序。因此，我们也可以把我们的公式写成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/bf64649fcf31d8f01ae0e6f0eef2d996.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*GuWrIQ_RLYMgwTwdFJvQiQ.png"/></div></figure><p id="f1e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更通用的 WxH 网格呢？在这种情况下，步数是(W-1) * (H-1)，我们必须选择(W-1) R 步(你可以自己检查)。因此，公式变为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/dfc80a2bef22753fdd0e257bb176b1e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*74BRQMLMfULwxokHOeLvhg.png"/></div></figure><p id="e071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，对吧？注意，我们可以选择(H-1) D 步，而不是选择(W-1) R 步。直觉上，这应该会给我们相同的答案，而<strong class="lb iu">确实是这样</strong>。换句话说，这意味着二项式系数是<strong class="lb iu">对称的:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/d15814cd3295a412df64ef78e782108d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*mXfEQBHScXBcCNtQQGNLjQ.png"/></div></figure><p id="00ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为练习，尝试在 30x20 甚至 99x99 的网格上计算路径的数量。你也可以试着写一个递归计算所有路径的程序，但是这样的程序在 99x99 的网格上要花很长时间才能完成！</p><h1 id="b9fe" class="no np it bd nq nr ns nt nu nv nw nx ny jz nz ka oa kc ob kd oc kf od kg oe of bi translated">结论</h1><p id="2b12" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">我希望你在这篇文章中学到了一些实用的组合学，并且你将被激励去学习更多关于这个迷人的主题。</p></div></div>    
</body>
</html>