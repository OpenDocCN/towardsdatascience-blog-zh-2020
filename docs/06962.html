<html>
<head>
<title>Software Testing and Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件测试和机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/software-testing-and-machine-learning-45f014968c62?source=collection_archive---------24-----------------------#2020-05-29">https://towardsdatascience.com/software-testing-and-machine-learning-45f014968c62?source=collection_archive---------24-----------------------#2020-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b0d4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于如何测试和信任软件中包含的机器学习的基础知识</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e3948b3b37467104e234ebb3a73234f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zMP5Ven4Eof8iy-r"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/photos/rt6QV85-AIE" rel="noopener ugc nofollow" target="_blank">亚历克斯·安德鲁斯</a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="c0a5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">概观</h1><p id="d9d9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们面对它，机器学习(ML)正在成为许多软件系统的标准部分。您系统中的训练模型可能会直接向用户显示预测，以帮助他们做出人类决策，或者它可能会在软件系统本身中做出自动决策。无论系统中的 ML 是内部开发的还是从第三方预先训练的模型 API 中检索的，如果正在使用利用训练模型预测的生产软件，则需要像测试软件的任何其他方面一样对其进行严格测试。在这篇文章中，我们将回顾一个经验法则框架，当涉及到 ML 时，如何测试你的软件，并识别一些常见的陷阱。</p><p id="a1cc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">作者注:ML 中的测试和变更管理是一个庞大的主题。本文的目的不是通过测试来帮助评估模型的准确性和性能有多强，而是理解模型的预测界面和行为。也就是说，通过以这种方式测试您的软件系统，您可能会发现常见的模型缺点和限制。</p><h1 id="bb67" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">不变测试</h1><p id="1076" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我们深入研究 ML 的引入如何改变系统之前，让我们快速讨论一下测试软件系统的原因。测试有助于开发人员确保系统的行为按照规定运行。程序和软件是不断变化的系统，如果由于各种原因而没有捕捉行为变化的自动化测试，系统就容易出错、失败和有缺陷。</p><p id="cf0e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">也就是说，我们所说的测试是什么意思？虽然有许多方法可以对一段代码进行单元测试，但是一种常见的测试方法是通过不变量。我们可以测试函数的哪些普遍真理？</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2fcb" class="mu kx iq mq b gy mv mw l mx my">def is_above_threshold(value):<br/>    return value &gt; THRESHOLD</span></pre><p id="b749" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是一个我们可以测试的函数的基本例子。立即浮现在脑海中的三个测试用例是检查一个低于<code class="fe mz na nb mq b">THRESHOLD</code>的数字、一个高于<code class="fe mz na nb mq b">THRESHOLD</code>的数字和<code class="fe mz na nb mq b">THRESHOLD</code>值本身。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f5c9" class="mu kx iq mq b gy mv mw l mx my">def test_over_threshold():<br/>    assert is_above_threshold(THRESHOLD + 1)</span><span id="171b" class="mu kx iq mq b gy nc mw l mx my">def test_under_threshold():<br/>    assert not is_above_threshold(THRESHOLD — 1)</span><span id="ead4" class="mu kx iq mq b gy nc mw l mx my">def test_threshold_edge():<br/>    assert not is_above_threshold(THRESHOLD)</span></pre><p id="736a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">太好了。因为这是 Python，我们可能还需要一些测试来尝试一些不同的输入类型。我们接受浮点数、整数、浮点数、无穷大吗？这些例子应该相当简单。我们唯一需要改变这些测试的时候就是函数的不变量改变的时候。假设我们把&gt;改成&gt; =。这将导致一个或多个测试失败，因为我们测试的不变量发生了变化。</p><p id="e0ea" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，我们知道这不是软件系统需要的所有测试。系统不仅仅是一两个相互调用的 Python 函数；它们通常由大型互连的功能层组成，通过网络协议与其他软件系统对话。为了处理这种复杂程度，我们需要集成测试。</p><h1 id="8ccf" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">集成测试</h1><p id="9bc9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">像单元测试一样，不同的开发人员对集成测试到底需要什么有不同的定义。为了这个例子的目的，我们想要测试我们的代码与我们系统的另一个组件一起工作。这个组件可以从数据库中读取数据，或者调用 rest API 并获取信息。这里有一个简单的例子，使用了前面的<code class="fe mz na nb mq b">is_above_threshold</code>函数:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e81f" class="mu kx iq mq b gy mv mw l mx my">def make_decision(user_input):<br/>    collected_value = component.get(user_input)</span><span id="fdee" class="mu kx iq mq b gy nc mw l mx my">    if is_above_threshold(collected_value):<br/>        return “Do it!”<br/>    else:<br/>        return “Don’t do it!”</span></pre><p id="be94" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们要测试的这个函数的属性是什么？</p><p id="5890" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先也是最重要的，我们要确保我们正确地使用了<code class="fe mz na nb mq b">component.get</code>的界面。我们需要向<code class="fe mz na nb mq b">make_decision</code>提供足够多不同的输入，以测试<code class="fe mz na nb mq b">component.get</code>的各种输出，确保我们没有错过其接口的任何可能的结果。这方面的一些例子:</p><ul class=""><li id="899c" class="nd ne iq lq b lr mk lu ml lx nf mb ng mf nh mj ni nj nk nl bi translated">给定文档，什么值可以作为输入传入？就像我们的单元测试示例一样，尝试边缘案例来捕获非正常情况下的行为。</li><li id="955b" class="nd ne iq lq b lr nm lu nn lx no mb np mf nq mj ni nj nk nl bi translated">如果输入错误，<code class="fe mz na nb mq b">component.get</code>会引发错误吗？如果是，我们是在这个函数中处理它，还是将其提交给<code class="fe mz na nb mq b">make_decision</code>的调用者？</li><li id="870d" class="nd ne iq lq b lr nm lu nn lx no mb np mf nq mj ni nj nk nl bi translated">如果<code class="fe mz na nb mq b">component.get</code>有时候返回非数值怎么办？在更复杂的情况下，如果<code class="fe mz na nb mq b">component.get</code>根据传入的输入返回不同的数据类型会怎样？</li></ul><p id="ec16" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些都是我们可以执行的有效测试，因为我们是在测试我们的代码是否为<code class="fe mz na nb mq b">component.get</code>的接口做好了准备，而不是深入到函数的实现中。</p><p id="e1e0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还想测试我们的代码是否工作正常。为了做到这一点，我们可以举几个<code class="fe mz na nb mq b">user_input</code>的好例子，确保我们最终得到预期的决策。</p><p id="3f60" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在大多数软件系统中，当我们使用一个库或组件时，我们可以期望组件已经通过了它自己的一套不变量和集成测试。因此，我们只需要测试交集的有效性。</p><p id="a0b2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">什么会导致这些测试发生变化？如果我们以任何方式更新了代码，改变了我们一些优秀的<code class="fe mz na nb mq b">user_input</code>例子的结果，那么我们将不得不更新测试以适应新的行为。</p><p id="eec9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，假设我们更新了库组件的主要版本，并且接口发生了变化。<code class="fe mz na nb mq b">get</code>函数不再是我们想要使用的方法。我们不希望我们的<code class="fe mz na nb mq b">make_decision</code>函数的行为改变。我们可以改变<code class="fe mz na nb mq b">make_decision</code>来适应新的 API，如果我们写的测试是正确的，它们不应该改变。</p><p id="062a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们已经完成了一些测试基础，真正的问题是当我们将 ML 添加到我们的软件系统中时会有什么不同？</p><h1 id="86c3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">让我们加上 ML</h1><p id="15a3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们马上弄清楚，许多用于构建 ML 模型的库都经过了很好的测试。[1]然而，在你的软件系统中使用 ML 通常不是直接使用那些测试良好的库函数，而是从库中创建的工件，你的训练模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/188e54a69d2943052f459671005b40e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTwZq7ceSHClNuAconBNig.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/photos/Wpnoqo2plFA" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c735" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当您的代码调用<code class="fe mz na nb mq b">model.predict</code>时，您可以保证所有相互调用的方法和函数层都在不变的级别上工作，但是您不能保证库知道您提供给模型的数据是什么样子。在前面的不变测试例子中，我们谈到了对可变类型的测试，比如 floats、ints、inf 等等。这同样适用于测试训练模型，但是数据类型可能要复杂得多。例如，数字 3 比有 30 个级别的分类特征更容易测试。那么，当我们讨论一个大得多的输入数据集时，我们之前为不变测试开发的三到八个测试成立吗？不完全是。</p><h1 id="3b35" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用 ML 进行不变测试</h1><p id="7335" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">经过训练的 ML 模型比我们之前用&gt;符号比较两个数字的例子要复杂得多。那么，当用一个经过训练的模型工件进行预测时，我们应该保持哪些不变量是正确的呢？让我们从一些基础开始:</p><ol class=""><li id="c500" class="nd ne iq lq b lr mk lu ml lx nf mb ng mf nh mj ns nj nk nl bi translated">模型的预测应该是确定性的。这意味着当我为一个预测传入一行数据时，每次都应该得到相同的预测。同样，在进行单行预测和批量预测时，预测一致性也应该成立。例如，不管第 3 行是单独的还是与第 1-10 行一起，对第 3 行的预测应该是相同的。</li><li id="e329" class="nd ne iq lq b lr nm lu nn lx no mb np mf nq mj ns nj nk nl bi translated">从单个兼容行扩展，我们应该能够在用于评估模型的相同测试数据上再现相同的误差度量分数。忽略度量分数是好是坏的事实，我们希望能够测试它没有改变。</li><li id="86f2" class="nd ne iq lq b lr nm lu nn lx no mb np mf nq mj ns nj nk nl bi translated">该模型应在一定时间内做出预测。一些复杂的输入数据可能会导致模型比不太复杂的输入数据花费更长的时间来进行预测，但是应该有一个您可以测量的上限。</li></ol><h1 id="16be" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">确定性模型</h1><p id="4450" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">模型会做出预测，但它们的预测应该是一致的。很像人，除非模型学习新的东西，否则它只能用当前已知的信息产生一个结果。在线机器学习有一个时间和地点，但我不会在这篇文章中深入探讨这个主题。</p><p id="d2cf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了测试一致性，我们需要我们的测试用例查看更多类型的输入数据。考虑使用用于评估模型的整个样本外数据集。这是在定型模型时未包括的数据，但具有实际结果，您可以将这些结果与模型预测进行比较。为了确保模型的确定性，我们不会将模型的预测与实际结果进行比较，而是与该模型对同一组数据做出的原始预测进行比较。如果您在每次测试运行时对这些数据进行预测，无论是作为合并请求的自动化的一部分，还是作为集成管道的一部分，您都将确保模型产生一致的预测。</p><p id="fe3a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">也许您担心原始的样本外数据没有覆盖足够多的可能输入到您的模型中的潜在输入。您可以计算彻底测试您的模型所需的总行数。让我们看一个玩具的例子:</p><p id="8644" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">假设您的模型使用 1000 行数据对五个特征进行了训练。其中三个特征分别为 5、10 和 30 级。另外两列是数字，每列有 500 个唯一值。若要计算总行数以彻底测试模型对每个数据组合的预测行为，您需要提供 5 * 10 * 30 * 500 * 500 = 3.75 亿行。这种级别的测试会告诉你你的模型在每一种可能的情况下会有什么样的表现，但是只针对模型已经学习的数据。</p><p id="b07f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面的详尽测试对于软件系统的 CI 管道来说是不切实际的。即使这个模型可以在十分之一秒内做出一个预测，测试仍然需要一万多个小时才能完成。这忽略了加载、预测和断言大量数据所需的硬件和基础设施。</p><p id="c5ce" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有了样本外数据及其结果，您就有了可以测试模型的良好数据样本，因为这是模型构建者和评估者用于评估目的的标准。它应该足以捕捉模型中的不变变化。在这种情况下，测试应该改变以适应不变的变化。不要忘记测试“边缘”案例，例如空值和数字数据或不属于模型定型数据的类别。</p><p id="c71e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果系统中的库或依赖项升级导致预测改变，这些测试也将失败。然而，正如我们前面提到的，通常库和依赖项升级不应该影响我们系统的外部行为，因此在这种情况下，模型代码可能需要以某种方式进行更改，以确保一致的预测。围绕训练模型的存储格式及其运行时环境，还有许多测试考虑事项。如果环境依赖关系被更新，当试图将模型加载到内存中时，一些存储格式，如 pickle，可能会导致运行时错误。[2]</p><h1 id="4960" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用 ML 进行集成测试</h1><p id="7ea8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们已经讨论了测试使用 ML 模型的软件系统所需的一些非常基本的不变量。在集成层面，幸运的是，我们可以保留一些与之前相同的概念。让我们看看如果用<code class="fe mz na nb mq b">model.predict</code>代替<code class="fe mz na nb mq b">component.get</code>，我们的<code class="fe mz na nb mq b">make_decision</code>函数会是什么样子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="af88" class="mu kx iq mq b gy mv mw l mx my">def make_decision(user_input):<br/>    prediction = model.predict(user_input)</span><span id="12bb" class="mu kx iq mq b gy nc mw l mx my">    if is_above_threshold(prediction):<br/>        return “Do it!”<br/>    else:<br/>        return “Don’t do it!”</span></pre><p id="7b70" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe mz na nb mq b">model.predict</code>调用的功能类似于<code class="fe mz na nb mq b">component.get</code>，从用户那里获取数据并产生我们需要评估的值。为了满足集成测试，您同样需要测试您是否正确地覆盖了<code class="fe mz na nb mq b">model.predict</code>接口，在必要的时候捕获或抛出错误。如果我们知道一个值中的空特性会导致 predict 产生一个错误，那么测试这种情况并让您的函数相应地处理它。再次提供几个输入系统的出色例子。</p><h1 id="336d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="9de2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们已经回顾了在您的系统中添加 ML 时需要考虑的一些基本问题。这一组初始测试是一个合理的基线，但是您还可以做得更多。[3]</p><p id="d7f4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，在部署模型之后对其进行监控。生产软件系统确实需要监控，以确保它们按预期工作。虽然我们的测试断言模型的行为不会改变，但我们无法测试模型的真实世界输入是如何改变的，并导致做出糟糕的预测。这是模型变更管理的重要一步。</p><p id="6c26" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">测试模型的预测界面和行为将确保开发人员理解模型的行为，并保持系统抗 bug。ML 模型将会被更多地使用，因此如何测试它们的通用最佳实践对于未来的软件开发将是至关重要的。</p><h2 id="b4ee" class="mu kx iq bd ky nt nu dn lc nv nw dp lg lx nx ny li mb nz oa lk mf ob oc lm od bi translated">脚注和参考文献:</h2><p id="6fa9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">[1]不是所有的图书馆都是完美的。你最终会遇到错误，发现库接口的局限性。在这些情况下，这是一个很好的机会来找到存储库，检查问题，看看其他人是否已经发现了 bug，提供一个最小的可重复的案例，并可能建议一个修复方法。</p><p id="7cb2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[2]参见<a class="ae kv" href="https://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled" rel="noopener ugc nofollow" target="_blank">酸洗文件</a></p><p id="844b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[3] D .斯卡利、加里·霍尔特、丹尼尔·戈洛文、尤金·达维多夫、托德·菲利普斯、迪特马尔·埃布纳、维奈·乔德里、迈克尔·杨、让-弗兰克 ois Crespo、丹·丹尼森，《机器学习系统中隐藏的技术债务》(2014 年)，NIPS'15</p></div></div>    
</body>
</html>