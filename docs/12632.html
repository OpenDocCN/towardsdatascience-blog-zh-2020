<html>
<head>
<title>Stack and Array Implementation with Python and NodeJs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 和 NodeJs 实现堆栈和数组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stack-and-array-implementation-with-python-and-nodejs-b8b260229e3a?source=collection_archive---------28-----------------------#2020-08-31">https://towardsdatascience.com/stack-and-array-implementation-with-python-and-nodejs-b8b260229e3a?source=collection_archive---------28-----------------------#2020-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e83ada6987511145128333882ef39c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yGH5ySSGGhS-QGSDuyawHw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="77db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<a class="ae la" href="https://medium.com/@pradeephbac/data-structures-and-algorithms-journey-80d225cfbbd8?source=friends_link&amp;sk=0eda1ea06843aa973538150dd9826c22" rel="noopener">的上一篇文章</a>中，我们讨论了数据结构和算法的基本定义。在这篇文章中，让我们更深入地挖掘数据结构的世界，特别是，让我们也为编码做一点尝试。</p><p id="ba16" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">本文目标:</strong></p><ol class=""><li id="97d4" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated">讨论数据类型、内置数据类型和派生数据类型。</li><li id="a5e2" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">介绍<strong class="ke ir">栈</strong>派生的数据结构</li><li id="4abc" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">在 Python <em class="lp"> { </em> <a class="ae la" href="https://github.com/pradeephbac/DataStructures_and_Algorithms/tree/master/Stack/python" rel="noopener ugc nofollow" target="_blank"> <em class="lp">代码</em> </a> <em class="lp"> }和</em> NodeJs <em class="lp"> { </em> <a class="ae la" href="https://github.com/pradeephbac/DataStructures_and_Algorithms/tree/master/Stack/nodejs" rel="noopener ugc nofollow" target="_blank"> <em class="lp">代码</em> </a> <em class="lp"> } </em>中实现和使用栈</li><li id="2f4f" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">介绍<strong class="ke ir">数组</strong>派生的数据结构</li><li id="cd58" class="lb lc iq ke b kf lk kj ll kn lm kr ln kv lo kz lg lh li lj bi translated">在 Python <em class="lp"> {code}和</em> NodeJs <em class="lp"> {code} </em>中实现和使用栈</li></ol><h2 id="8aa6" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kn lz ma mb kr mc md me kv mf mg mh mi bi translated">数据类型简介</h2><p id="394b" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">数据结构由一个或多个数据对象组成。数据对象代表我们将要使用精心设计的数据结构存储的数据。数据类型被认为是对数据结构中的几种数据类型进行分类的主要方式，如字符串、字符、整数等。在编程领域有两种主要的数据类型，即内置数据类型和派生数据类型。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/44cb133264244a3927a93ee6c9b4fbca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ohl_Wo67o-Jw8eLqGk74fA.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">常用的数据类型(图片由作者提供)</p></figure><h2 id="eced" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kn lz ma mb kr mc md me kv mf mg mh mi bi translated">内置数据类型</h2><p id="f4ea" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">这些是编程语言支持的基本数据类型。在特定的编程语言中主要称为<strong class="ke ir">主要数据类型</strong>。</p><h2 id="01a8" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kn lz ma mb kr mc md me kv mf mg mh mi bi translated">派生数据类型</h2><p id="afae" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">这些数据类型是使用一个或多个内置(主)数据类型实现的。所有的数据结构都是基于这种派生的数据类型开发的。在这篇文章中，我们将讨论栈的数组的数据结构和实现的例子。</p><h1 id="18c5" class="mt lr iq bd ls mu mv mw lv mx my mz ly na nb nc mb nd ne nf me ng nh ni mh nj bi translated">堆栈数据结构</h1><p id="74c4" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated"><strong class="ke ir">栈</strong>是一种<strong class="ke ir">抽象数据类型</strong> (ADT 是一种<strong class="ke ir">类型</strong>，用于其行为由一组值和一组操作定义的对象)是编程语言中的主要数据结构之一，对于初学者来说，这是一种容易理解的结构。<strong class="ke ir">LIFO(L</strong>ast<strong class="ke ir">I</strong>n<strong class="ke ir">F</strong>first<strong class="ke ir">O</strong>ut)<strong class="ke ir">T45】是一个栈的主要特长<strong class="ke ir">。</strong></strong></p><p id="ec02" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">像大多数数据结构一样，堆栈也表示真实世界的对象。例如，一堆硬币、一堆盒子等。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/c48990210789309b2b1d77bf7732639f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fy3QuM2wg4w031hezAt5Rw.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">真实世界的堆栈(图片由作者提供)</p></figure><p id="8eb9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">可以使用数组、列表、指针等来实现堆栈。说到堆栈，有一组函数被定义为在编程上下文中有效地使用堆栈。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/bb5009365137bad7b4362750219e12c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_fJ18jVcE2hRiGYMNGMfFA.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">堆栈操作(图片由作者提供)</p></figure><p id="9e9d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> Python 实现</strong></p><p id="2ef1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在 python 中，我们可以使用列表数据类型作为内置数据类型来实现堆栈数据结构。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1d9a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">{ code }请在 Github <a class="ae la" href="https://github.com/pradeephbac/DataStructures_and_Algorithms/tree/master/Stack/python" rel="noopener ugc nofollow" target="_blank">链接</a>中找到附件代码库。</p><p id="b020" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> NodeJs 实现</strong></p><p id="e26b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在 NodeJs 中，我们可以使用数组数据类型实现堆栈数据结构。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6c53" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="lp"> {code} </em>请在此 Github <a class="ae la" href="https://github.com/pradeephbac/DataStructures_and_Algorithms/tree/master/Stack/nodejs" rel="noopener ugc nofollow" target="_blank">链接</a>中找到附件代码库。</p><h1 id="5b0e" class="mt lr iq bd ls mu mv mw lv mx my mz ly na nb nc mb nd ne nf me ng nh ni mh nj bi translated">推送操作</h1><p id="2f4d" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">一旦你定义了栈类，其中一个主要的功能就是 push 函数。这里你将输入一个<strong class="ke ir">条目</strong>到数组的顶部。</p><p id="fddd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="lp">算法实现</em> </strong></p><p id="0751" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以在 stack 类中定义一个算法来实现 push 操作。</p><pre class="mp mq mr ms gt no np nq nr aw ns bi"><span id="8010" class="lq lr iq np b gy nt nu l nv nw"><strong class="np ir">Step 1 </strong>− Checks if the stack is full(assume that the list is implemented based on a  dynamic array) for the given size or not.</span><span id="c56f" class="lq lr iq np b gy nx nu l nv nw"><strong class="np ir">Step 2 </strong>− If the stack is full, print an error</span><span id="1b20" class="lq lr iq np b gy nx nu l nv nw"><strong class="np ir">Step 3 </strong>− If the stack is not full for the given maximum size, increase the top by one and point the pointer to the next empty space.</span><span id="5b05" class="lq lr iq np b gy nx nu l nv nw"><strong class="np ir">Step 4 </strong>− Add a new element to the new empty space which is in the top of the stack</span><span id="5523" class="lq lr iq np b gy nx nu l nv nw"><strong class="np ir">Step 5</strong> − Return success.</span></pre><h1 id="48a8" class="mt lr iq bd ls mu mv mw lv mx my mz ly na nb nc mb nd ne nf me ng nh ni mh nj bi translated">弹出操作</h1><p id="d5e8" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated"><strong class="ke ir"> pop </strong>函数将从堆栈中移除最顶端的元素，堆栈项目计数将减一。<em class="lp">尽管看起来像是从堆栈中移除了最顶端的元素，但是那个</em> <strong class="ke ir"> <em class="lp">元素并不会被完全移除</em> </strong> <em class="lp">，只有指针会移动到下面的位置。</em></p><p id="562d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="lp">算法实现</em> </strong></p><p id="e245" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以在 stack 类中定义一个算法来实现 pop 操作。</p><pre class="mp mq mr ms gt no np nq nr aw ns bi"><span id="c8af" class="lq lr iq np b gy nt nu l nv nw"><strong class="np ir">Step 1</strong> − Checks if the stack is empty by looking at the array length</span><span id="925c" class="lq lr iq np b gy nx nu l nv nw"><strong class="np ir">Step 2</strong> − If the stack is empty, print an error, exit</span><span id="e496" class="lq lr iq np b gy nx nu l nv nw"><strong class="np ir">Step 3</strong> − If the stack is not empty, get the element which is pointing at the top of the stack.</span><span id="4d9a" class="lq lr iq np b gy nx nu l nv nw"><strong class="np ir">Step 4</strong> − Decreases the size of the stack by 1, automatically the pointer of the top most item  will changed to the below item.</span><span id="afe4" class="lq lr iq np b gy nx nu l nv nw"><strong class="np ir">Step 5</strong> − Returns success.</span></pre><h1 id="e5da" class="mt lr iq bd ls mu mv mw lv mx my mz ly na nb nc mb nd ne nf me ng nh ni mh nj bi translated">窥视操作</h1><p id="a520" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated"><strong class="ke ir"> peek </strong>函数将显示堆栈中最顶端的元素，该操作不会像<strong class="ke ir"> pop </strong>操作那样从堆栈中移除该项。</p><p id="b1a1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="lp">算法实现</em> </strong></p><p id="061d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以在 stack 类中定义一个算法来实现 peek 操作。peek 操作只返回堆栈顶部的值。</p><pre class="mp mq mr ms gt no np nq nr aw ns bi"><span id="fec5" class="lq lr iq np b gy nt nu l nv nw"><strong class="np ir">Step 1</strong> − Checks if the stack is empty by looking at the array length</span><span id="b4eb" class="lq lr iq np b gy nx nu l nv nw"><strong class="np ir">Step 2</strong> − If the stack is empty, print an error, exit</span><span id="17c6" class="lq lr iq np b gy nx nu l nv nw"><strong class="np ir">Step 3 </strong>− If the stack is not empty, get the element which is pointing at the top of the stack.</span><span id="d60f" class="lq lr iq np b gy nx nu l nv nw"><strong class="np ir">Step 4</strong> −  Returns success.</span></pre><p id="2f60" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还有其他类似<strong class="ke ir"> isEmpty() </strong>，<strong class="ke ir"> isFull()，</strong>和<strong class="ke ir"> printStackItems() </strong>的函数可以作为支持函数，帮助你高效地使用堆栈。</p><p id="29c7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">栈实现和所有支持的功能实现都可以在这个代码库中找到。<a class="ae la" href="https://github.com/pradeephbac/DataStructures_and_Algorithms/tree/master/Stack" rel="noopener ugc nofollow" target="_blank"> <em class="lp">堆栈数据结构</em> </a></p><p id="f643" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用堆栈数据结构，因为我们将来在算法部分解决实际问题时会用到这些数据结构。</p><h1 id="7998" class="mt lr iq bd ls mu mv mw lv mx my mz ly na nb nc mb nd ne nf me ng nh ni mh nj bi translated">数组数据结构</h1><p id="6b74" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">当程序员实现他们的算法时，数组是最常用的数据结构之一。数组的一个特点是数组容器应该是固定大小的<strong class="ke ir"/>，所有元素应该是相同类型的<strong class="ke ir"/>。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/28aaa63dded013e41166d95344cd8734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ch_cB-iodW3JdvyN0KyAmw.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">数组表示(图片由作者提供)</p></figure><p id="6b56" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">除了数组中的所有元素应该是相同的数据类型之外，数组总是从第 0 个元素开始(<strong class="ke ir">零索引</strong>)，数组的大小意味着，它本身可以存储多少个元素。</p><p id="3cdd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在许多数据类型中，有一些主要的操作(功能)是为了有效地使用该数据类型而存在的。在数组数据类型中，有五种主要的操作。</p><h2 id="3a54" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kn lz ma mb kr mc md me kv mf mg mh mi bi translated">数组插入</h2><p id="a34d" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">向给定的索引中添加一个新元素称为数组插入。我们能够通过 python 和 nodejs 编程语言实现向给定索引插入元素。</p><p id="be89" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir"> nodejs </strong>中实现数组插入操作</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0b42" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir"> python </strong>中实现数组插入操作</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="e890" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kn lz ma mb kr mc md me kv mf mg mh mi bi translated">数组搜索</h2><p id="2f8a" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">我们可以基于<strong class="ke ir">值</strong>或<strong class="ke ir">索引</strong>对数组元素执行搜索操作。</p><p id="e0ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">按索引搜索意味着将相应的数组元素返回给定的索引，按值搜索意味着将相应的值返回给定的数组中的索引。</p><p id="1596" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir"> nodejs </strong>中实现数组插入操作</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6df9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir"> python </strong>中实现数组插入操作</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="e121" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kn lz ma mb kr mc md me kv mf mg mh mi bi translated">数组删除</h2><p id="5876" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">由于数组是固定大小的数据结构，从数组的给定位置删除一个元素有点棘手。在删除给定元素时，应该通过减小数组的大小来调整新数组。请参考下面的代码示例，它解释了如何用基本的编程技术从数组中删除给定的元素。</p><p id="d330" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir"> python </strong>中实现数组插入操作</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="728f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir"> Nodejs </strong>中实现数组插入操作</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="785a" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kn lz ma mb kr mc md me kv mf mg mh mi bi translated">数组更新</h2><p id="e09c" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">数组更新是一个非常简单的操作，只需要遍历给定的数组，直到找到需要更新的元素。请遵循以下代码示例，以便更熟悉阵列更新功能。</p><p id="946a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir"> nodejs — </strong> <a class="ae la" href="https://github.com/pradeephbac/DataStructures_and_Algorithms/blob/master/Array/nodejs/array_update.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="lp">代码</em> </strong> </a>中实现数组更新操作</p><p id="2a5a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir"> python — </strong> <a class="ae la" href="https://github.com/pradeephbac/DataStructures_and_Algorithms/blob/master/Array/python/array_update.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="lp">代码</em> </strong> </a>中实现数组更新操作</p><h2 id="1d26" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kn lz ma mb kr mc md me kv mf mg mh mi bi translated">数组遍历</h2><p id="0bd8" class="pw-post-body-paragraph kc kd iq ke b kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz ij bi translated">数组遍历就是打印一个序列中的所有数组元素。由于数组是零索引的数据类型，我们可以从零位置开始遍历数组结构来打印数组元素。</p><p id="2e0c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir"> nodejs — </strong> <a class="ae la" href="https://github.com/pradeephbac/DataStructures_and_Algorithms/blob/master/Array/nodejs/array_traversal.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="lp">代码</em> </strong> </a>中实现数组遍历操作</p><p id="2fe5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir"> python — </strong> <a class="ae la" href="https://github.com/pradeephbac/DataStructures_and_Algorithms/blob/master/Array/python/array_traversal.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="lp">代码</em> </strong> </a>中实现数组遍历操作</p><p id="5ac4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">总之，</strong>我们已经学会了如何高效地使用<a class="ae la" href="https://github.com/pradeephbac/DataStructures_and_Algorithms/tree/master/Stack" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">栈</strong> </a>和<a class="ae la" href="https://github.com/pradeephbac/DataStructures_and_Algorithms/tree/master/Array" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">数组</strong> </a> <strong class="ke ir"> </strong>。请找到下面的代码段，看看我们如何用 python 和 nodejs 实现堆栈和数组。</p><p id="430c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您只需要在您的机器上安装节点，就可以开始了。(节点安装<a class="ae la" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">链接</em> </a>)</p><p id="29d0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">开始编写代码，为接下来的课程做准备。</p><pre class="mp mq mr ms gt no np nq nr aw ns bi"><span id="6e6d" class="lq lr iq np b gy nt nu l nv nw"><strong class="np ir">FYI:</strong>  when you trying to implement data structure operations, always remember on “<strong class="np ir"><em class="lp">Algorithm to implement</em></strong>” and think in that direction. This approach will help you to get a deep understanding of the entire workflow of data structure usage.</span></pre><p id="3dcf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下一课中，我们将实现其他派生的数据结构，如<strong class="ke ir">队列、链表、双向链表、</strong>和<strong class="ke ir">循环链表</strong>，它们被认为是非常重要的数据结构，在开始使用算法之前需要先了解一下。</p><p id="d30e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于 Git 库克隆，请点击<a class="ae la" href="https://github.com/pradeephbac/DataStructures_and_Algorithms.git" rel="noopener ugc nofollow" target="_blank"> <em class="lp">这里</em> </a></p><p id="7686" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">更多课程见，编码快乐！</p></div></div>    
</body>
</html>