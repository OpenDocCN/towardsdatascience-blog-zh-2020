<html>
<head>
<title>How to Use Scala Pattern Matching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Scala模式匹配</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-scalas-pattern-matching-362a01aa32ca?source=collection_archive---------52-----------------------#2020-05-04">https://towardsdatascience.com/how-to-use-scalas-pattern-matching-362a01aa32ca?source=collection_archive---------52-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b42" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当if-else语句太长时，就该考虑模式匹配了。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/86f6a6173f263da01edcd9df4737c22f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F9gknXKAnoogyI4V"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Andrew Ridley 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="fd95" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">概观</h1><p id="88a6" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">模式匹配是Scala语言提供的最强大的工具之一。类似于Kotlin中的<code class="fe mu mv mw mx b">when</code>语句和Java中的<code class="fe mu mv mw mx b">switch</code>语句。</p><p id="856f" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">本质上，它将一个输入与我们想要匹配的所有可能的情况进行比较。在我看来，这是使用多行<code class="fe mu mv mw mx b">if-else</code>语句的一种优雅的替代方式，当有许多案例需要比较时，可读性更好。</p><p id="5060" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在本教程中，我们将通过几个不同的场景来学习如何在Scala中使用模式匹配。</p><p id="9f16" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">对科特林的<code class="fe mu mv mw mx b">when</code>说法感兴趣的，可以去看看这个<a class="ae ky" href="https://medium.com/better-programming/stop-using-if-else-and-start-using-when-in-kotlin-96485c2a51d2?source=friends_link&amp;sk=765f768351029adda0d2817c4b88cf72" rel="noopener">教程</a>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="71ab" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">Scala模式匹配剖析</h1><p id="e88c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Scala模式匹配的剖析如下。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="3316" class="nh lh it mx b gy ni nj l nk nl">objectToMatch match {<br/>  case object1 =&gt; println("You match object1.")<br/>  case object2 =&gt; println("You match object2.")<br/>  case _ =&gt; println("You match neither object1 nor object2.")<br/>}</span></pre><p id="f9cb" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><code class="fe mu mv mw mx b">objectToMatch</code>是你试图模式匹配的Scala对象的可能值。</p><p id="5f84" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><code class="fe mu mv mw mx b">case object1</code>和<code class="fe mu mv mw mx b">case object2</code>是你所知道的可能与<code class="fe mu mv mw mx b">objectToMatch</code>匹配的两种模式。</p><p id="45ee" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><code class="fe mu mv mw mx b">case _</code>是everything else子句，它本质上意味着<code class="fe mu mv mw mx b">objectToMatch</code>与<code class="fe mu mv mw mx b">object1</code>或<code class="fe mu mv mw mx b">object2</code>都不匹配。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1cfb" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">基本用法</h1><p id="ae95" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">既然我们已经理解了模式匹配的结构，让我们看一个简单的例子。</p><p id="9996" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">假设我们买了一袋混合水果，我们知道它通常含有苹果、香蕉、草莓或蓝莓。现在，我们有了一台能够对水果进行分类的扫描仪。如果我们使用Scala的模式匹配来编写程序，它会是这样的。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="9319" class="nh lh it mx b gy ni nj l nk nl">fruit match {<br/>  case "apple" =&gt; println("received an apple.")<br/>  case "banana" =&gt; println("received a banana.")<br/>  case "strawberry" =&gt; println("received a strawberry.")<br/>  case "blueberry" =&gt; println("received a blueberry.")<br/>  case _ =&gt; println("unable to classify this fruit. is it really a fruit?")<br/>}</span></pre><p id="0c74" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">如果您有一个名为<code class="fe mu mv mw mx b">fruit</code>的变量，并且分配给它的值是<code class="fe mu mv mw mx b">apple</code>，那么上面的模式匹配语句将把<code class="fe mu mv mw mx b">received an apple.</code>打印到您的控制台。诸如此类。</p><p id="a5fd" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">当<code class="fe mu mv mw mx b">fruit</code>的值既不是<code class="fe mu mv mw mx b">apple</code>、<code class="fe mu mv mw mx b">banana</code>、<code class="fe mu mv mw mx b">strawberry</code>也不是<code class="fe mu mv mw mx b">blueberry</code>时，语句会将<code class="fe mu mv mw mx b">unable to classify this fruit. is it really a fruit?</code>打印到控制台。</p><p id="4956" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">现在，如果你要为此写一个<code class="fe mu mv mw mx b">if-else</code>语句，它会是这样的。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="1518" class="nh lh it mx b gy ni nj l nk nl">if (fruit == "apple") <em class="nm">println</em>("received an apple.")<br/>else if (fruit == "banana") <em class="nm">println</em>("received a banana.")<br/>else if (fruit == "strawberry") <em class="nm">println</em>("received a strawberry.")<br/>else if (fruit == "blueberry") <em class="nm">println</em>("received a blueberry.")<br/>else <em class="nm">println</em>("unable to classify this fruit. is it really a fruit?")</span></pre><p id="b00f" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在我看来，模式匹配表达式比<code class="fe mu mv mw mx b">if-else</code>更具可读性，但是，嘿，这真的取决于你的偏好。归根结底，上述两种说法做的是同样的事情。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="429c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">与案例类匹配</h1><p id="153c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">除了匹配对象本身的值，我们还可以匹配可能的类型(或<code class="fe mu mv mw mx b">case class</code>)。</p><p id="3598" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">假设我们正在为一家超市的新鲜农产品部的计算机扫描仪编写一个分类程序。扫描仪将根据物品的类型给物品贴上标签，例如水果或蔬菜。我想这就是我们如何定义我们的特征和案例类。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="9e47" class="nh lh it mx b gy ni nj l nk nl">trait GroceryItem<br/><br/>case class Fruit(name: String) extends GroceryItem<br/><br/>case class Vegetable(name: String) extends GroceryItem</span></pre><p id="0208" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">现在，我们将编写一个函数，它将一个<code class="fe mu mv mw mx b">GroceryItem</code>对象作为其输入，并对它是<code class="fe mu mv mw mx b">Fruit</code>还是<code class="fe mu mv mw mx b">Vegetable</code>进行分类。这是它最简单的写法。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="6a22" class="nh lh it mx b gy ni nj l nk nl">def classifyGroceryItem(item: GroceryItem): Unit =<br/>  item match {<br/>    case _: Fruit =&gt; <em class="nm">println</em>("label item as fruit.")<br/>    case _: Vegetable =&gt; <em class="nm">println</em>("label item as vegetable.")<br/>    case _ =&gt; <em class="nm">println</em>("unable to label the item. this seems to be an item for other department.")<br/>  }</span></pre><p id="00b4" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">注意语法<code class="fe mu mv mw mx b">_: Fruit</code>。当我们想要对它的实例类型进行模式匹配时，我们应该这样写我们的<code class="fe mu mv mw mx b">case</code>。此外，该表达式实际上并不查看字段<code class="fe mu mv mw mx b">case class</code>的值(例如<code class="fe mu mv mw mx b">name</code>)。</p><p id="6267" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">如果我们还想匹配case类的字段，我们可以这样做(看第一个<code class="fe mu mv mw mx b">case</code>表达式)。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="4454" class="nh lh it mx b gy ni nj l nk nl">def classifyGroceryItem(item: GroceryItem): Unit =<br/>  item match {<br/>    case <em class="nm">Fruit</em>(name) if name == "apple" =&gt; <em class="nm">println</em>("item is a fruit and it's an apple.") <br/>    case _: Fruit =&gt; <em class="nm">println</em>("label item as fruit.")<br/>    case _: Vegetable =&gt; <em class="nm">println</em>("label item as vegetable.")<br/>    case _ =&gt; <em class="nm">println</em>("unable to label the item. this seems to be an item for other department.")<br/>  }</span></pre><p id="48e4" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">请注意，case表达式的顺序很重要。在上面的例子中，如果附加的<code class="fe mu mv mw mx b">case Fruit(name)</code>表达式放在<code class="fe mu mv mw mx b">case _: Fruit</code>之后，代码将永远不会到达它，因为它将立即匹配<code class="fe mu mv mw mx b">case _: Fruit</code>。</p><p id="34be" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">从这个例子中，我们还了解到我们可以在<code class="fe mu mv mw mx b">case</code>语句上添加一个<code class="fe mu mv mw mx b">if</code>语句。我发现这在某些情况下很有用。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2f8c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">与选项匹配</h1><p id="bbb7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在Scala中，我们可能有一个<code class="fe mu mv mw mx b">Option</code>类型的对象，这仅仅意味着我们可能有也可能没有值。</p><p id="dc8c" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">假设我们有一个函数，它根据商品的名称扫描超市的库存，如果找到了商品，就返回数量。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="c8d2" class="nh lh it mx b gy ni nj l nk nl">val inventory: Map[String, Int] = <em class="nm">Map</em>(<br/>  "apple" -&gt; 10,<br/>  "banana" -&gt; 15,<br/>  "strawberry" -&gt; 10,<br/>  "spinach" -&gt; 30,<br/>  "capsicum" -&gt; 25<br/>)<br/><br/>def findItemAndReturnQuantity(itemName: String): Option[Int] = {<br/>  inventory.get(itemName)<br/>}<br/><br/>findItemAndReturnQuantity("sugar") // res1: Option[Int] = None<br/>findItemAndReturnQuantity("spinach") // res2: Option[Int] = Some(30)</span></pre><p id="9435" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我们可以使用模式匹配来处理一个<code class="fe mu mv mw mx b">Option</code>对象。让我们编写一个函数来处理<code class="fe mu mv mw mx b">findItemAndReturnQuantity</code>函数的输出。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="84a1" class="nh lh it mx b gy ni nj l nk nl">def handleOptionItemQuantity(quantity: Option[Int]) =<br/>  quantity match {<br/>    case Some(value) =&gt; <em class="nm">println</em>(s"quantity is <strong class="mx iu">$</strong>value.")<br/>    case None =&gt; <em class="nm">println</em>("item is not available.")<br/>  }</span></pre><p id="6539" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">综合起来看:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="dd4c" class="nh lh it mx b gy ni nj l nk nl">handleOptionItemQuantity(findItemAndReturnQuantity("strawberry"))<br/>// quantity is 10.</span></pre><p id="ac1f" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">太好了。🙂</p><p id="1c09" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在我们结束这一部分之前，我想向您展示一个简单的提示。在某些情况下，比如这个<code class="fe mu mv mw mx b">Option</code>对象，编译器知道可能的结果是什么。因此，当您键入模式匹配表达式时，应该会看到下面的建议。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/ea5ddee8c6542b0937686ac05514b1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JXmSK6FZKG9QjfzAN7HnVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">匹配(详尽)</p></figure><p id="eda3" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">如果您选择<code class="fe mu mv mw mx b">match (exhaustive)</code>，它将自动填充值存在和不存在的情况。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="a92e" class="nh lh it mx b gy ni nj l nk nl">def handleOptionItemQuantity(quantity: Option[Int]) =<br/>  quantity match {<br/>    case Some(value) =&gt; <br/>    case None =&gt;<br/>  }</span></pre><p id="aff3" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">记住，如果需要的话，我们还可以在上面的表达式中添加<code class="fe mu mv mw mx b">if</code>语句。例如，当某个商品的库存量不足时，我们希望通知我们的员工。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="5419" class="nh lh it mx b gy ni nj l nk nl">def handleOptionItemQuantity(quantity: Option[Int]) =<br/>  quantity match {<br/>    case Some(value) if value &lt; 10 =&gt; <em class="nm">println</em>(s"low stock - quantity is <strong class="mx iu">$</strong>value.")<br/>    case Some(value) =&gt; <em class="nm">println</em>(s"quantity is <strong class="mx iu">$</strong>value.")<br/>    case None =&gt; <em class="nm">println</em>("item is not available.")<br/>  }</span></pre><p id="f04e" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">就是这样。😃</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="225e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">包裹</h1><p id="72aa" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当你读到这一节的时候，你已经学会了Scala模式匹配的基础知识。您现在应该能够在您的代码中使用它，或者替换一些现有的多行语句<code class="fe mu mv mw mx b">if-else</code>。</p><p id="78cd" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">如果你也像我一样用Kotlin编程，你可能想看看这篇关于Kotlin的when语句的教程<a class="ae ky" href="https://medium.com/better-programming/stop-using-if-else-and-start-using-when-in-kotlin-96485c2a51d2?source=friends_link&amp;sk=765f768351029adda0d2817c4b88cf72" rel="noopener">。它本质上相当于Scala对Kotlin的模式匹配。</a></p></div></div>    
</body>
</html>