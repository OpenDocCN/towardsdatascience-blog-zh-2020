<html>
<head>
<title>The Transformer: A Quick Run Through</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">变形金刚:快速浏览</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-transformer-a-quick-run-through-ce9b21b4f3ed?source=collection_archive---------38-----------------------#2020-05-02">https://towardsdatascience.com/the-transformer-a-quick-run-through-ce9b21b4f3ed?source=collection_archive---------38-----------------------#2020-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ed19" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索由 Transformer 支持的最佳自然语言建模。了解其架构和内部工作。</h2></div><blockquote class="ki kj kk"><p id="5ce3" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这是关于语言建模的第 5 部分系列的第 3 部分。</p></blockquote><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/d26d6b8e2a6ca866bcb22b90f02681ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nH_g5TTDBEs79y2M0lk6Fg.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">使用类变压器架构(BERT)解决机器翻译的任务(【translate.google.com】T2</p></figure><h1 id="0d63" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">介绍</h1><p id="574a" class="pw-post-body-paragraph kl km it ko b kp mr ju kr ks ms jx ku mt mu kx ky mv mw lb lc mx my lf lg lh im bi translated">在<a class="ae li" href="https://medium.com/p/d66e96ed754f" rel="noopener">的上一篇</a>文章中，我们看到了 ELMo 和 ULMFiT 如何在社区中提升语言模型预培训的重要性。这篇博客假设你已经通读了本系列文章的前两部分，并以此为基础。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mz"><img src="../Images/867e3374760ea2e806a505a26e9f5cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jA32Yzo7dXRDIWXhBMBy6A.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">使用转换器模型<a class="ae li" href="https://www.linkedin.com/in/mandardeshpande1995/" rel="noopener ugc nofollow" target="_blank"> (Mandar Deshpande) </a>将英语输入翻译成德语输出</p></figure><p id="1433" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated"><a class="ae li" href="https://arxiv.org/pdf/1706.03762.pdf" rel="noopener ugc nofollow" target="_blank">变换器</a>已经被视为通过递归神经网络最终消除序列模型训练的限制的模型。在语言建模和机器翻译中，围绕编码器-解码器堆栈的使用的想法被证明是在构建这种架构的过程中有价值的学习。Transformer 是一个简单的网络架构，完全基于注意力机制，完全放弃任何类型的递归和卷积。它已被证明可以很好地推广到其他语言理解和建模任务，具有大量和有限的训练数据。它还在英语到德语的翻译任务上取得了最先进的成果，并将其定位为 NLP 中模型预训练未来发展的首选架构。</p><h2 id="9ada" class="na ma it bd mb nb nc dn mf nd ne dp mj mt nf ng ml mv nh ni mn mx nj nk mp nl bi translated">编码器-解码器架构</h2><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/1430a4feeff51fd2c56548c93c557267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*AOQlFGXhx_ojDcEX1stg2g.png"/></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">变压器中使用的 6 个编码器-解码器架构<a class="ae li" href="https://www.linkedin.com/in/mandardeshpande1995/" rel="noopener ugc nofollow" target="_blank"> (Mandar Deshpande) </a></p></figure><p id="38fb" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">在这个模型中，多个编码器堆叠在一起，类似地，解码器也堆叠在一起。通常，每个编码器/解码器包括循环连接和卷积，并且来自每个编码器级的隐藏表示被向前传递以供下一层使用。大多数 seq2seq 任务可以很容易地使用这样一个编码器-解码器堆栈来解决，它按顺序处理输入序列中的每个单词。</p><h2 id="e571" class="na ma it bd mb nb nc dn mf nd ne dp mj mt nf ng ml mv nh ni mn mx nj nk mp nl bi translated">注意机制</h2><p id="cee9" class="pw-post-body-paragraph kl km it ko b kp mr ju kr ks ms jx ku mt mu kx ky mv mw lb lc mx my lf lg lh im bi translated">由于注意机制已经成为序列建模和各种任务中的转导模型的组成部分，允许建模依赖性，而不考虑它们在输入或输出序列中的距离。简单地说:注意机制帮助我们在不使用递归神经网络(RNN)的情况下解决神经网络中的长期依赖性问题。通过使用基于编码器-解码器的架构，这解决了 RNN 中所有时间步长上共享的隐藏状态所解决的确切目的。注意力模型根据正在解决的任务关注输入文本序列或图像的相关部分。</p><p id="1197" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">在常规 RNN 中，上下文是根据编码器产生的最终隐藏状态传递的，并使用它来产生翻译或文本的下一个标记。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nn"><img src="../Images/38ad6e60c8ee0d8d41720f4723293d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*znX_iUkc3TVNplPN3ukUFQ.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">没有注意机制的常规 seq2seq 模型只使用最后一个隐藏状态作为上下文向量<a class="ae li" href="https://www.linkedin.com/in/mandardeshpande1995/" rel="noopener ugc nofollow" target="_blank"> (Mandar Deshpande) </a></p></figure><p id="364b" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated"><strong class="ko iu">生成上下文向量的步骤:</strong></p><ol class=""><li id="343c" class="no np it ko b kp kq ks kt mt nq mv nr mx ns lh nt nu nv nw bi translated">根据任务初始化随机值和大小的上下文向量(例如 128，256，512)</li><li id="9aa1" class="no np it ko b kp nx ks ny mt nz mv oa mx ob lh nt nu nv nw bi translated">通过编码器处理输入序列中的一个令牌</li><li id="3e50" class="no np it ko b kp nx ks ny mt nz mv oa mx ob lh nt nu nv nw bi translated">使用编码器中的隐藏状态表示来更新上下文向量</li><li id="3ac9" class="no np it ko b kp nx ks ny mt nz mv oa mx ob lh nt nu nv nw bi translated">继续重复步骤 2 和 3，直到处理完整个输入序列</li></ol><p id="3fae" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">一旦上下文向量被完全更新，它就被传递给解码器，作为正在被翻译的单词/令牌的附加输入。<strong class="ko iu">上下文向量是一个有用的抽象，除了它充当输入序列的整个含义的表示</strong>的瓶颈。</p><p id="c89c" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated"><strong class="ko iu">注意机制将编码器堆栈中的所有中间隐藏状态传递给解码器</strong>，而不是将单个上下文向量传递给解码器。这使得解码器能够根据正被处理的当前单词/令牌的相关性来关注输入序列的不同部分。</p><p id="d843" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">与之前的 seq2seq 模型不同，注意力模型执行两个额外的步骤:</p><ol class=""><li id="ad1b" class="no np it ko b kp kq ks kt mt nq mv nr mx ns lh nt nu nv nw bi translated"><strong class="ko iu">更多数据从编码器传递到解码器</strong></li><li id="64bf" class="no np it ko b kp nx ks ny mt nz mv oa mx ob lh nt nu nv nw bi translated"><strong class="ko iu">注意力模型中的解码器使用该附加数据</strong>来聚焦来自输入序列的特定单词，并且<strong class="ko iu">使用具有最高 softmax 分数的隐藏状态作为上下文向量</strong></li></ol><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/fbc1b55c4763710a16467af462a9850f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*8W4HbTBuIYTtCBFyn8q1Rw.png"/></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">用于创建传递给解码器的上下文向量的注意机制<a class="ae li" href="https://www.linkedin.com/in/mandardeshpande1995/" rel="noopener ugc nofollow" target="_blank"> (Mandar Deshpande) </a></p></figure><h2 id="35f3" class="na ma it bd mb nb nc dn mf nd ne dp mj mt nf ng ml mv nh ni mn mx nj nk mp nl bi translated">窥视变压器内部</h2><p id="d308" class="pw-post-body-paragraph kl km it ko b kp mr ju kr ks ms jx ku mt mu kx ky mv mw lb lc mx my lf lg lh im bi translated">变换器由 6 个堆叠的编码器和 6 个堆叠的解码器组成，形成模型的主要架构。这个数字可以根据用例而变化，但是在<a class="ae li" href="https://arxiv.org/pdf/1706.03762.pdf" rel="noopener ugc nofollow" target="_blank">原始文件</a>中已经使用了 6。</p><p id="34e8" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">让我们考虑一个编码器和解码器堆栈，以简化我们对工作的理解。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi oc"><img src="../Images/8a1feedac6318df11dc708b26b1eea2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8expO2YnpyCR18OgnnHSoA.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">变压器<a class="ae li" href="https://www.linkedin.com/in/mandardeshpande1995/" rel="noopener ugc nofollow" target="_blank"> (Mandar Deshpande) </a>中编码器和解码器内部的组件</p></figure><h2 id="0026" class="na ma it bd mb nb nc dn mf nd ne dp mj mt nf ng ml mv nh ni mn mx nj nk mp nl bi translated">体系结构</h2><p id="a08a" class="pw-post-body-paragraph kl km it ko b kp mr ju kr ks ms jx ku mt mu kx ky mv mw lb lc mx my lf lg lh im bi translated">每个编码器包括一个自我关注层，其后是前馈网络。通常在注意力机制中，来自先前状态的隐藏状态被用于计算注意力。相反，自我关注使用来自同一层的训练嵌入来计算关注向量。为了说明，自我注意可以被认为是一种在句子中解决共指的机制:</p><p id="c233" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">“男人在吃饭，而他在想他的家人”</p><p id="f2fa" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">在上面的句子中，模型需要建立对<code class="fe od oe of og b">he </code>所指内容的理解，并且它是对<code class="fe od oe of og b">man.</code>的共指，这是由转换器中的自我关注机制实现的。关于自我关注(使用多个头部)的详细讨论超出了本博客的范围，可以在原始论文中找到。</p><p id="9e33" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">解码器也具有与编码器相同的两层，只是在这两层之间引入了额外的编码器-解码器注意力，以帮助模型从来自编码器的注意力向量中提取相关特征。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ca"><img src="../Images/37ceeb2744daf6afd775e0cb9e9d97af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DSRCXsde9_8dvbxq5ktUnw.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">简化的 2 个编码器与 2 个解码器堆叠在一起，探索内部架构<a class="ae li" href="https://www.linkedin.com/in/mandardeshpande1995/" rel="noopener ugc nofollow" target="_blank"> (Mandar Deshpande) </a></p></figure><p id="a210" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated"><strong class="ko iu">点式前馈网络<br/> </strong>需要注意的是，输入序列中的每个单词都在自我关注层共享计算，但每个单词都流经一个单独的前馈网络。前馈网络的输出被传递到堆栈中的下一个编码器，该编码器利用从先前编码器学习到的上下文。</p><p id="0feb" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated"><strong class="ko iu">位置编码<br/>这个增强的输入字嵌入作为输入被传递给编码器 1。由于该模型不使用任何递归或卷积，位置编码对输入句子中的相对位置信息进行编码。</strong></p><p id="49ba" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated"><strong class="ko iu">具有归一化的剩余连接<br/> </strong>使用剩余连接和层归一化将来自自我关注层的输出与原始单词嵌入相加。前馈层遵循类似的方案。</p><p id="f906" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated"><strong class="ko iu">与 Softmax <br/>全连接线性</strong>一旦堆栈中的最后一个解码器给出一个点向量，就需要将其转换成翻译后的单词。既然我们已经将所有需要的信息作为浮点数嵌入到这个输出向量中，我们只需要将它转换成翻译中可能的下一个单词的概率。</p><p id="bc39" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">全连接线性网络将浮点向量转换为分数，分数使用 softmax 函数转换为概率值。具有最高 softmax 值的索引被选择并从从训练集学习的输出词汇中检索。</p><h1 id="2041" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">变压器培训说明</h1><p id="49ed" class="pw-post-body-paragraph kl km it ko b kp mr ju kr ks ms jx ku mt mu kx ky mv mw lb lc mx my lf lg lh im bi translated">训练是受监督的，即使用带标签的训练数据集，该数据集可用作输出单词概率的比较和校正的基准。</p><p id="3422" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">本质上，翻译后的输出词汇表中的每个单词都被转换成一个独热向量，该向量只有在单词出现的索引处为 1，其他地方为 0。现在，一旦我们接收到由归一化概率值组成的 softmax 输出向量，我们就可以将其与独热向量进行比较，以改进模型参数/权重。</p><p id="f5df" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">这两个向量可以通过使用一些相似性度量进行比较，如<strong class="ko iu">余弦相似性、交叉熵和/或 Kullback-Leibler 散度</strong>。在训练过程的开始，输出概率分布比地面真实一号热向量偏离得更远。随着训练的进行和权重的优化，输出单词概率紧密地跟踪地面真实向量。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="9637" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">我希望这篇博客能帮助您理解 Transformer 是如何工作的，我计划在下一篇文章中探索 BERT 模型。</p><p id="7669" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated"><a class="ae li" rel="noopener" target="_blank" href="/language-modeling-c1cf7b983685">链接到第一部分</a>:语言建模 I <a class="ae li" rel="noopener" target="_blank" href="/language-modelingii-ulmfit-and-elmo-d66e96ed754f"> <br/>链接到第二部分</a>:语言建模 II: ELMo 和 ULMFiT <br/> <a class="ae li" rel="noopener" target="_blank" href="/the-transformer-a-quick-run-through-ce9b21b4f3ed">链接到第三部分</a>:变压器:快速浏览</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="d4cc" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">继续学习和成长，直到那时！</p><p id="c05a" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku mt kw kx ky mv la lb lc mx le lf lg lh im bi translated">在推特上和我联系:<a class="ae li" href="https://twitter.com/mandroid_6" rel="noopener ugc nofollow" target="_blank">https://twitter.com/mandroid_6</a></p><blockquote class="ki kj kk"><p id="1e3c" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">以上所有图片均由我创作，我有权使用它们。我从杰伊·阿拉姆马的博客  <em class="it">中获得了可视化的灵感</em></p></blockquote></div></div>    
</body>
</html>