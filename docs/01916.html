<html>
<head>
<title>Checkpointing Deep Learning Models in Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Keras 中的检查点深度学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/checkpointing-deep-learning-models-in-keras-a652570b8de6?source=collection_archive---------4-----------------------#2020-02-23">https://towardsdatascience.com/checkpointing-deep-learning-models-in-keras-a652570b8de6?source=collection_archive---------4-----------------------#2020-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1100" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用检查点保存深度学习模型，以及如何重新加载它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/db6c9f9c83ed1646ca56374969cb2d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjeivUS__DpGsFasRXUbLQ.png"/></div></div></figure><p id="7a07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">保存和加载深度学习模型的不同方法正在使用</strong></p><ul class=""><li id="76a7" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><a class="ae lz" href="https://medium.com/@arshren/saving-and-loading-keras-model-42195b92f57a" rel="noopener"> JSON 文件</a></li><li id="301c" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://medium.com/@arshren/saving-and-loading-keras-model-42195b92f57a" rel="noopener"> YAML 档案</a></li><li id="2715" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">检查站</li></ul><p id="d636" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，您将了解如何对使用 Keras 构建的深度学习模型进行检查点检查，然后将模型架构和训练好的权重恢复到新模型，或者从您停止的地方恢复训练</p><h2 id="4512" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">检查点的使用</h2><ul class=""><li id="52a6" class="lq lr it kw b kx my la mz ld na lh nb ll nc lp lv lw lx ly bi translated"><strong class="kw iu">允许我们使用预训练的模型进行推理，而不必重新训练模型</strong></li><li id="8de3" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><strong class="kw iu">从我们停止的地方继续训练过程，以防训练中断或用于微调模型</strong></li></ul><p id="3f63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在训练因任何原因中断的情况下，它可以自动保存您的模型。</p><h2 id="7951" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">使用检查点保存和加载模型和权重的步骤</h2><ul class=""><li id="e3bf" class="lq lr it kw b kx my la mz ld na lh nb ll nc lp lv lw lx ly bi translated">创建模型</li><li id="6dc3" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">指定我们要保存检查点文件的路径</li><li id="c4d6" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">创建回调函数来保存模型</li><li id="79d6" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">在培训期间应用回调函数</li><li id="b492" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">根据测试数据评估模型</li><li id="e1d4" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">使用 l <strong class="kw iu"> oad_weights() </strong>或<strong class="kw iu">从最近的检查点</strong>恢复重量，将预训练的重量加载到新型号上</li></ul><h2 id="decc" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">创建具有损失函数、指标和优化器的基础模型架构</h2><p id="d11b" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">我们为时尚 MNIST 数据集创建了多类分类模型</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="304c" class="mf mg it nh b gy nl nm l nn no"><strong class="nh iu"># Define the model architecture <br/>def create_model():<br/>    model = tf.keras.Sequential()<br/>    # Must define the input shape in the first layer of the neural network<br/>    model.add(tf.keras.layers.Conv2D(filters=64, kernel_size=2, padding='same', activation='relu', input_shape=(28,28,1))) <br/>    model.add(tf.keras.layers.MaxPooling2D(pool_size=2))<br/>    model.add(tf.keras.layers.Dropout(0.3))<br/>    model.add(tf.keras.layers.Conv2D(filters=32, kernel_size=2, padding='same', activation='relu'))<br/>    model.add(tf.keras.layers.MaxPooling2D(pool_size=2))<br/>    model.add(tf.keras.layers.Dropout(0.3))<br/>    model.add(tf.keras.layers.Flatten())<br/>    model.add(tf.keras.layers.Dense(256, activation='relu'))<br/>    model.add(tf.keras.layers.Dropout(0.5))<br/>    model.add(tf.keras.layers.Dense(10, activation='softmax'))<br/>    <br/>    #Compiling the model<br/>    model.compile(loss='sparse_categorical_crossentropy',<br/>             optimizer='adam',<br/>             metrics=['accuracy'])<br/>    <br/>    return model</strong></span><span id="7d3c" class="mf mg it nh b gy np nm l nn no">#create the model<br/><strong class="nh iu">model_ckpt= create_model()</strong></span></pre><p id="361a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">指定存储检查点文件的路径</strong></p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a99b" class="mf mg it nh b gy nl nm l nn no"><strong class="nh iu">checkpoint_path = "train_ckpt/cp.ckpt"</strong></span></pre><p id="e5c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">创建回调函数保存模型。</strong></p><p id="d63d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在训练的不同阶段应用回调函数，以给出内部训练状态的视图。</p><p id="f455" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用<strong class="kw iu"> <em class="nq">模型检查点</em> </strong>创建一个回调函数来保存模型权重。</p><p id="9c14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们将<strong class="kw iu"><em class="nq">save _ weight _ only</em></strong>设置为 True，那么将只保存重量。模型架构、损失和优化器将不会被保存。</p><p id="c517" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以指定是否要在每个时期或每隔<strong class="kw iu"> <em class="nq"> n </em> </strong>个时期保存模型。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="3741" class="mf mg it nh b gy nl nm l nn no"># Create a callback that saves the model's weights<br/><strong class="nh iu">cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_path,save_best_only=True, save_weights_only=True, verbose=1)</strong></span></pre><p id="55d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">模型检查点回调类</strong>具有以下参数:</p><ul class=""><li id="7dbe" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><strong class="kw iu">文件路径</strong>:指定我们想要保存模型的路径或文件名</li><li id="2fe6" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><strong class="kw iu">监控</strong>:我们想要监控的指标，比如损失或准确性</li><li id="addf" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><strong class="kw iu">详细度</strong> : 0 表示调试模式，1 表示信息</li><li id="844f" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><strong class="kw iu"> save_weights_only </strong>:如果设置为 True，则只保存模型权重，否则保存整个模型，包括模型架构、权重、损失函数和优化器。</li><li id="01df" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><strong class="kw iu"> save_best_only </strong>:如果设置为 True，则根据我们监控的数量，仅保存最佳模型。如果我们正在监控精度并且<strong class="kw iu"> <em class="nq"> save_best_only </em> </strong>被设置为 True，那么模型将在我们每次获得比先前精度更高的精度时被保存。</li><li id="780d" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><strong class="kw iu">模式</strong>:有三个选项- <strong class="kw iu">自动、最小或最大</strong>。<strong class="kw iu">如果我们正在监控精度，则将其设置为最大值，</strong>和<strong class="kw iu">如果我们正在监控损耗，则将其设置为最小值</strong>。如果我们将模式设置为自动，则方向会根据监控的数量自动推断</li><li id="7df8" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><strong class="kw iu"> save_freq 或 period </strong> : <strong class="kw iu">设置为‘epoch’或一个数字</strong>。当它设置为 epoch 时，模型在每个 epoch 后被保存。当我们指定一个数字，比如说 5，那么模型在每五个时期后被保存，如下面的代码所示</li></ul><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="e6a0" class="mf mg it nh b gy nl nm l nn no"># Create a callback that saves the model's weights every 5 epochs<br/><strong class="nh iu">cp_callback = tf.keras.callbacks.ModelCheckpoint(<br/>    filepath=checkpoint_path, <br/>    verbose=1, <br/>    save_weights_only=True,<br/>    save_freq=5)</strong></span></pre><p id="aa75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">在培训过程中应用回调</strong></p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="9536" class="mf mg it nh b gy nl nm l nn no"># Train the model with the new callback<br/># Pass callback to training<br/><strong class="nh iu">model_ckpt.fit(train_images, <br/>          train_labels,  <br/>          batch_size=64,<br/>          epochs=10,<br/>          validation_data=(test_images,test_labels),<br/>          callbacks=[cp_callback])</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/c27cb0d1e3618c0059709cd3779e1685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEOQv81wsv8w_bdkHKciBg.png"/></div></div></figure><p id="1458" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以看到，如果 val_loss 没有改善，那么权重就没有保存。每当丢失减少时，这些权重就会保存到检查点文件中</p><p id="6be8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">在测试图像上评估模型</strong></p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="48fa" class="mf mg it nh b gy nl nm l nn no"><strong class="nh iu">loss,acc = model_ckpt.evaluate(test_images,  test_labels, verbose=2)</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/115ae05ed2aa985d4f3d2cdbbf9d4ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*z0iUmhwAI-C6CJF6eUc9jg.png"/></div></figure><h2 id="134e" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">检查点文件</h2><p id="10f9" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">检查点文件以二进制格式将训练好的权重存储到检查点格式化文件的集合中</p><p id="c6fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">tensor flow<strong class="kw iu"><em class="nq">save()</em></strong>保存三种文件:检查点文件、索引文件、数据文件。它将<strong class="kw iu">图形结构</strong>与<strong class="kw iu">变量值</strong>分开存储。</p><p id="7431" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">检查点文件:包含索引文件以及一个或多个数据文件的前缀</strong></p><p id="4f8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">索引文件:指示哪些权重存储在哪个分片</strong>。当我在一台机器上训练该模型时，我们看到<strong class="kw iu"><em class="nq">CP . ckpt . data-00000-of-00002</em></strong>和<strong class="kw iu"><em class="nq">CP . ckpt . data-00001-of-00002</em></strong></p><p id="5353" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">数据文件:保存所有变量的值，无结构。可以有一个或多个数据文件</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/8358c781ba3281a1cf9e4e81a066aa2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*BFdyFKUDJwbIdZekBJohDg.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">检查点文件</p></figure><h2 id="60ec" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">加载预训练的重量</h2><p id="16bd" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">加载预训练重量的原因</p><ul class=""><li id="c478" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><strong class="kw iu">从我们停止的地方继续或</strong></li><li id="fe17" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><strong class="kw iu">中断后恢复或</strong></li><li id="b153" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><strong class="kw iu">加载预训练的重量进行推断</strong></li></ul><p id="1879" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们创建一个新的模型来加载预训练的权重。</p><p id="8109" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当加载具有预训练权重的新模型时，新模型应该具有与原始模型相同的架构。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="96ea" class="mf mg it nh b gy nl nm l nn no"># Create a basic model instance<br/><strong class="nh iu">model_ckpt2 = create_model()</strong></span></pre><p id="b0ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用<strong class="kw iu"><em class="nq">load _ weights()</em></strong>将预训练的权重加载到我们的新模型中。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="1264" class="mf mg it nh b gy nl nm l nn no"><strong class="nh iu">model_ckpt2.load_weights(checkpoint_path)</strong></span></pre><p id="4a30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用新模型对测试图像进行推断</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a169" class="mf mg it nh b gy nl nm l nn no"><strong class="nh iu">loss,acc = model_ckpt2.evaluate(test_images,  test_labels, verbose=2)<br/>print("Restored model, accuracy: {:5.2f}%".format(100*acc))</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/19283c9f52d5ea48986269a074ba9bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*XFzPc6qpw9bVfH3BXWLMhQ.png"/></div></figure><p id="b5bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">未经训练的模型将随机执行(大约 10%的准确度)</strong></p><h1 id="a9ae" class="nz mg it bd mh oa ob oc mk od oe of mn jz og ka mq kc oh kd mt kf oi kg mw oj bi translated">从我们停止的地方继续训练</h1><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="d2c9" class="mf mg it nh b gy nl nm l nn no"><strong class="nh iu">model_ckpt2.fit(train_images, <br/>          train_labels,  <br/>          batch_size=64,<br/>          epochs=10,<br/>          validation_data=(test_images,test_labels),<br/>          callbacks=[cp_callback])</strong></span></pre><p id="e18d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们看到现在精确度已经改变了</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="bdb6" class="mf mg it nh b gy nl nm l nn no">loss,acc = model_ckpt2.evaluate(test_images,  test_labels, verbose=2)<br/>print("Restored model, accuracy: {:5.2f}%".format(100*acc))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/8c272ba3a91b3dae4bb254f874d339fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*UhQJ-0BtKPqXiwKfREUvDA.png"/></div></figure><h2 id="41f7" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">从最新的检查点加载权重</h2><p id="d9e2" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated"><strong class="kw iu"><em class="nq">latest _ check point()</em></strong>查找最新保存的检查点文件的文件名</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="2d33" class="mf mg it nh b gy nl nm l nn no">#get the latest checkpoint file<br/><strong class="nh iu">checkpoint_dir = os.path.dirname(checkpoint_path)<br/>latest = tf.train.latest_checkpoint(checkpoint_dir)</strong></span></pre><p id="21d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们创建一个新的模型，从最新的检查点加载权重并进行推理</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a4d6" class="mf mg it nh b gy nl nm l nn no">Create a new model instance<br/><strong class="nh iu">model_latest_checkpoint = create_model()</strong></span><span id="5fce" class="mf mg it nh b gy np nm l nn no"># Load the previously saved weights<br/><strong class="nh iu">model_latest_checkpoint.load_weights(latest)</strong></span><span id="0f91" class="mf mg it nh b gy np nm l nn no"># Re-evaluate the model<br/><strong class="nh iu">loss, acc = model_latest_checkpoint.evaluate(test_images,  test_labels, verbose=2)<br/>print("Restored model, accuracy: {:5.2f}%".format(100*acc))</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/bc10da1dd5ea06c2df3a1a1a8f07b92e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*xehdAxT7eqXOY1tZ2sbaUw.png"/></div></figure><p id="a84b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">在文件名中包含纪元编号</strong></p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a13d" class="mf mg it nh b gy nl nm l nn no"># Include the epoch in the file name (uses `str.format`)<br/><strong class="nh iu">checkpoint_path = "training2/cp-{epoch:04d}.ckpt"</strong></span></pre><p id="c25f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lz" href="https://github.com/arshren/save-and-load-model-and-weights/blob/master/Fashion%20MNIST-Save%20and%20load%20models.ipynb" rel="noopener ugc nofollow" target="_blank">使用时尚 MNIST 保存模型和重新加载模型的代码</a></p><h2 id="d825" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">结论:</h2><p id="65c4" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">我们现在了解了如何使用<strong class="kw iu">模型检查点类、</strong>创建不同的检查点文件来创建回调函数，以及如何恢复预训练的权重</p><p id="6f0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">参考文献:</strong></p><p id="5888" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lz" href="https://www.tensorflow.org/tutorials/keras/save_and_load" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/tutorials/keras/save_and_load</a></p></div></div>    
</body>
</html>