<html>
<head>
<title>Defensive Query Writing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">防御性查询编写</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/defensive-query-writing-1fa07674899b?source=collection_archive---------82-----------------------#2020-06-15">https://towardsdatascience.com/defensive-query-writing-1fa07674899b?source=collection_archive---------82-----------------------#2020-06-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/370c95c2fd035956fa9f33c316b5a240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwTVKDjmoZvSmzAVdvgFug.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">照片来自<a class="ae jh" href="https://www.pexels.com/photo/police-army-commando-special-task-force-20258/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a></p></figure><h2 id="7f53" class="ji jj jk bd b dl jl jm jn jo jp jq dk jr translated" aria-label="kicker paragraph">数据工程</h2><div class=""/><div class=""><h2 id="0d89" class="pw-subtitle-paragraph kq jt jk bd b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dk translated">使用防御性编码原则编写 SQL 查询</h2></div><p id="8fe6" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi me translated">源自防御性编程，防御性查询编写是一种尝试确保查询运行不会失败的实践。就像在应用程序开发中一样，尽量避免愚蠢的错误，控制不可预见的情况。有时，您需要决定是希望查询失败，还是希望查询即使有一些不正确的数据也能运行。我将分享几个简单的例子，在这些例子中，我们可以在编写查询时使用这些实践。</p><h1 id="d7ea" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">检查数据库对象是否存在</h1><p id="f258" class="pw-post-body-paragraph li lj jk lk b ll nf ku ln lo ng kx lq lr nh lt lu lv ni lx ly lz nj mb mc md in bi translated">以创建和删除数据库对象为例。不要使用<code class="fe nk nl nm nn b">CREATE TABLE xyz</code>，使用<code class="fe nk nl nm nn b">CREATE TABLE IF NOT EXISTS xyz (id int)</code>或者如果你想重新创建丢失所有数据的表，你可以运行<code class="fe nk nl nm nn b">DROP TABLE IF EXISTS xyz</code>，然后运行<code class="fe nk nl nm nn b">CREATE TABLE IF NOT EXISTS xyz (id int)</code>。</p><p id="1415" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">同样的实践可以用于创建和删除数据库、视图、索引、触发器、过程、函数等等。我开始意识到，在大多数情况下，使用这个是有帮助的。</p><h1 id="90fe" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">使用数据库和列别名</h1><p id="2d77" class="pw-post-body-paragraph li lj jk lk b ll nf ku ln lo ng kx lq lr nh lt lu lv ni lx ly lz nj mb mc md in bi translated">防止自己出现<em class="no">不明确的列</em>错误。参见下面的例子，列<code class="fe nk nl nm nn b">city</code>可能同时出现在<code class="fe nk nl nm nn b">TABLE_1</code>和<code class="fe nk nl nm nn b">TABLE_2</code>中。你如何期望数据库知道你希望它选择哪个字段？</p><figure class="np nq nr ns gu iw"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="4744" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">通常，为数据库对象创建别名，然后使用别名而不是完整名称来访问这些数据库对象及其子对象是一个非常好的做法。显然，为了高效地完成这项工作，您需要遵循 SQL 样式表。我在这里写了更多关于它的内容—</p><div class="it iu gq gs iv nv"><a rel="noopener follow" target="_blank" href="/how-to-avoid-writing-sloppy-sql-43647a160025"><div class="nw ab fp"><div class="nx ab ny cl cj nz"><h2 class="bd ju gz z fq oa fs ft ob fv fx jt bi translated">如何避免编写草率的 SQL</h2><div class="oc l"><h3 class="bd b gz z fq oa fs ft ob fv fx dk translated">让您的 SQL 代码更易读、更容易理解</h3></div><div class="od l"><p class="bd b dl z fq oa fs ft ob fv fx dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj jb nv"/></div></div></a></div><h1 id="f9b6" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">使用极限，偏移</h1><p id="5780" class="pw-post-body-paragraph li lj jk lk b ll nf ku ln lo ng kx lq lr nh lt lu lv ni lx ly lz nj mb mc md in bi translated">不，我不是在说使用<code class="fe nk nl nm nn b">LIMIT</code>来限制最终查询中的记录数量。相反，我说的是这样的查询。</p><figure class="np nq nr ns gu iw"><div class="bz fq l di"><div class="nt nu l"/></div></figure><p id="6f37" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">返回列的子查询中的<code class="fe nk nl nm nn b">LIMIT</code>子句很重要，因为如果子查询返回多行，即对于<code class="fe nk nl nm nn b">TABLE_1</code>中的每条记录，如果<code class="fe nk nl nm nn b">TABLE_2</code>中有多条记录，它可以防止查询失败。这是编写更好的查询的一个非常有用的技巧。</p><p id="e47c" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">使用<code class="fe nk nl nm nn b">LIMIT</code>有一个警告。如果你不确定数据的质量或者你对数据库不够了解，使用<code class="fe nk nl nm nn b">LIMIT</code>经常会给你错误的答案。在某些情况下，您更希望作业失败时抛出错误，而不是查询返回不正确的结果集。</p><h1 id="f681" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">使用存储过程和预准备语句</h1><p id="a73f" class="pw-post-body-paragraph li lj jk lk b ll nf ku ln lo ng kx lq lr nh lt lu lv ni lx ly lz nj mb mc md in bi translated">信不信由你，SQL 注入仍然非常流行。近年来，许多受欢迎的公司发现自己受到了黑客攻击 SQL 注入的摆布。有非常具体的方法来防止您的应用程序受到这种攻击。关于这个话题最有资源的网站是 OWASP。</p><div class="it iu gq gs iv nv"><a href="https://owasp.org/www-community/attacks/SQL_Injection" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fp"><div class="nx ab ny cl cj nz"><h2 class="bd ju gz z fq oa fs ft ob fv fx jt bi translated">SQL 注入</h2><div class="oc l"><h3 class="bd b gz z fq oa fs ft ob fv fx dk translated">SQL 注入攻击包括通过从客户端到客户端的输入数据插入或“注入”SQL 查询</h3></div><div class="od l"><p class="bd b dl z fq oa fs ft ob fv fx dk translated">owasp.org</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj jb nv"/></div></div></a></div><p id="ef85" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">防止这些攻击背后的想法是通过使用准备好的语句或使用存储过程来安全地参数化您的查询。即使这些解决方案也要求在运行查询之前进行严格的验证检查——使用特殊字符、转义字符等等。</p><h1 id="4496" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">小心使用触发器</h1><p id="3a98" class="pw-post-body-paragraph li lj jk lk b ll nf ku ln lo ng kx lq lr nh lt lu lv ni lx ly lz nj mb mc md in bi translated">我有触发器的问题。我曾经试图在生产数据库触发的触发器上构建一个轻量级的数据转换管道。我在想什么，对吧？它是轻量级的，它本来可以工作更长时间，但由于应用程序中的一些 bug(很可能是关于事务边界的),它没有得到解决。即使那没有成功，我仍然真的非常喜欢触发器，但它们确实会带来自己的痛苦。</p><p id="c590" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">必须格外小心，确保触发器不是相互依赖的，并且在数据库应用程序中不可能有循环触发器。</p><h1 id="f57d" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">执行前模拟 DML 语句</h1><p id="a2a9" class="pw-post-body-paragraph li lj jk lk b ll nf ku ln lo ng kx lq lr nh lt lu lv ni lx ly lz nj mb mc md in bi translated">总是试图将您的生产查询模拟成<code class="fe nk nl nm nn b">SELECT</code>语句，即使您正在尝试<code class="fe nk nl nm nn b">DELETE</code>或<code class="fe nk nl nm nn b">UPDATE</code>。这样做会给你一个公平的想法，当你<code class="fe nk nl nm nn b">DELETE</code>或<code class="fe nk nl nm nn b">UPDATE</code>时，你实际上要做什么。这些年来，我发现这个方法真的很有用。这无疑增加了另一个耗费时间的步骤，但我认为这比额外的成本有好处。</p><p id="82b3" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">除了嘲讽之外，您还必须在您的开发/测试环境中运行相同的<code class="fe nk nl nm nn b">DELETE</code>和<code class="fe nk nl nm nn b">UPDATE</code>语句，这样您就可以在生产中做任何激烈的事情之前签署它们。</p><p id="7aa3" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这些是我的一些建议。<a class="ae jh" href="https://linktr.ee/kovid" rel="noopener ugc nofollow" target="_blank">我发现这些在处理数据系统时非常有用</a>。类似地，我在这里也谈到了许多提高数据库查询性能的好的、简单的 SQL 技巧</p><div class="it iu gq gs iv nv"><a rel="noopener follow" target="_blank" href="/easy-fixes-for-sql-queries-ff9d8867a617"><div class="nw ab fp"><div class="nx ab ny cl cj nz"><h2 class="bd ju gz z fq oa fs ft ob fv fx jt bi translated">SQL 查询的简单修复</h2><div class="oc l"><h3 class="bd b gz z fq oa fs ft ob fv fx dk translated">查询任何传统关系数据库的经验法则</h3></div><div class="od l"><p class="bd b dl z fq oa fs ft ob fv fx dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="ol l og oh oi oe oj jb nv"/></div></div></a></div><p id="a588" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">快乐阅读！</p></div></div>    
</body>
</html>