<html>
<head>
<title>Building a Dynamic Weather Download App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建动态天气下载应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-dynamic-weather-download-app-1ce64a6c3e61?source=collection_archive---------54-----------------------#2020-06-01">https://towardsdatascience.com/building-a-dynamic-weather-download-app-1ce64a6c3e61?source=collection_archive---------54-----------------------#2020-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="98ec" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Python、Dash和AWS简化加拿大历史天气数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2c97e0bae557e8b3311bbeed9803d82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Yt3fXMyV57ONJSVH"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@vidarnm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维达尔·诺德里-马西森</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="2ae1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文描述了我用来构建动态仪表板web应用程序的框架，该应用程序用于下载和可视化历史加拿大天气数据…快！！！</p><p id="4750" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">【WeatherHistoryCanda.com】查看App:<a class="ae kv" href="http://www.weatherhistorycanada.com" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a></p><p id="2fdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">获取代码:</strong> <a class="ae kv" href="https://github.com/david-hurley/env-can-wx-app" rel="noopener ugc nofollow" target="_blank"> GitHub Repo </a></p><h1 id="6316" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">动机</h1><p id="f2d2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="ls">加拿大有8000多个活跃和不活跃的政府气象站，它们都有开源数据。然而，下载数据并不容易。</em></p><p id="3311" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前，通过由加拿大环境和气候变化部(ECCC)维护的一个政府运营的门户网站<a class="ae kv" href="https://climate.weather.gc.ca/historical_data/search_historic_data_e.html" rel="noopener ugc nofollow" target="_blank">可以访问和下载加拿大的历史天气数据。虽然ECCC提供了优秀的开源数据服务，但下载门户还有待改进。该门户没有地图来直观地搜索和显示气象站的位置，下载仅限于一小部分数据，并且下载后无法绘制数据图表。</a></p><h1 id="10cf" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">目标</h1><p id="c72c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="ls">构建仪表板web应用程序，动态搜索、过滤和下载加拿大历史天气数据。</em></p><p id="0264" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">几个要求:</strong></p><ul class=""><li id="edc0" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">基于过滤标准显示气象站的交互式地图</li><li id="9796" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">任何时间范围内气象站数据的单个文件下载(即不再有多文件下载)</li><li id="c999" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">快速下载气象站数据(即分钟级)</li><li id="8dd2" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">气象站数据的交互式图形</li><li id="3acc" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">便宜的💰</li></ul><h1 id="ec4a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">步骤1:应用程序框架</h1><p id="c4e6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">最初，我制定了一个松散的概念，即我希望如何构建应用程序，例如使用哪个微服务框架，经过一些尝试和错误后，我确定了如下所示的架构。这是一个由前端进程、后台进程和数据库存储组成的标准结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/d6b7628167496515593c3496b1914d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4JdJi0vZs3L9PFNHdcoPg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">web应用程序框架概述</p></figure><h2 id="9839" class="nf lu iq bd lv ng nh dn lz ni nj dp md lf nk nl mf lj nm nn mh ln no np mj nq bi translated">Dash应用</h2><p id="149e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">对于小型仪表板应用，微服务是必由之路。它加速了开发，并且易于部署。我选择使用Python微服务框架<a class="ae kv" href="https://dash.plotly.com/introduction" rel="noopener ugc nofollow" target="_blank"> Plotly Dash </a>来构建我的应用程序。Dash是一个非常棒的工具，尤其是对于不熟悉JavaScript的人来说，因为它允许您用纯Python构建复杂的交互式仪表板！</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="f481" class="nf lu iq ns b gy nw nx l ny nz">##  BASIC MULTI-PAGE DASH APP FRAMEWORK</span><span id="3f61" class="nf lu iq ns b gy oa nx l ny nz">- app.py    # Flask server<br/>- index.py  # browser caching and page routing<br/>- tasks.py  # background job in Celery<br/>- Procfile  # Heroku commands on start-up<br/>- /pages<br/>    | -- __init__.py    <br/>    | -- homepage.py<br/>    | -- graphpage.py<br/>    | -- about.py<br/>- /assets<br/>    | -- CSS and JS</span></pre><h2 id="4958" class="nf lu iq bd lv ng nh dn lz ni nj dp md lf nk nl mf lj nm nn mh ln no np mj nq bi translated">后台作业</h2><p id="3f96" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我的应用程序的要点是允许用户下载历史天气数据。由于下载任务需要几秒到几分钟的时间来执行，因此无法在前端高效运行(即，这会引入延迟，并阻止应用程序快速响应传入的请求)。更好的解决方案是将长时间运行的任务作为后台作业执行，并将结果反馈给前端。</p><p id="4c97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我使用了Celery，一个异步任务队列，以及CloudAMQPs RabbitMQ消息代理和Heroku Redis结果存储。关于如何建立一个异步任务队列有很多很棒很详细的教程(<a class="ae kv" href="https://blog.miguelgrinberg.com/post/using-celery-with-flask" rel="noopener ugc nofollow" target="_blank">也就是Miguel Grinberg的博客</a>)，所以我在这里就不赘述了。相反，我提供了芹菜后台作业架构的概要。</p><ul class=""><li id="550d" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">消息代理:</strong>客户端发送一个请求来执行一个长时间运行的任务。消息代理(即RabbitMQ)接收请求，并将其放入消息队列，Celery worker在该队列中卸载并运行任务。</li><li id="5d88" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">这些是运行后台作业的进程，比如下载历史天气数据。在Celery中，您可以同时运行多个工作线程来处理多个请求。</li><li id="1d58" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">结果存储:</strong>用于存储任务结果的数据库(即Heroku Redis)。在我的例子中，我用它来存储气象站元数据，比如位置、海拔和站ID。</li></ul><p id="9989" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我强烈建议不要同时使用Heroku Redis作为结果存储和消息队列。我一开始尝试了这种方法，并不断达到允许的最大并发连接数。通过将消息队列分配给RabbitMQ，将结果存储分配给Heroku Redis，可以获得更多的并发连接。</p><h2 id="de28" class="nf lu iq bd lv ng nh dn lz ni nj dp md lf nk nl mf lj nm nn mh ln no np mj nq bi translated">数据库存储</h2><p id="3a62" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">最初，我的应用程序的结构是直接从ECCC服务器(第三方)下载数据。这被证明是缓慢的并且不是非常健壮的。相反，我把所有的ECCC数据(大约37 Gb)下载到一个AWS S3桶中。我通过使用AWS Lambda和SQS消息队列运行多个批量下载作业来实现这一点。一旦我有了S3桶中的数据，我就使用AWS Lambda和CloudWatch事件来更新每天午夜的活动气象站数据。结果是一个灵活的数据库，不依赖于ECCC服务器。</p><p id="84e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将数据存放在S3存储桶中的最大好处是，可以在应用中使用S3选择(即简单的SQL表达式)直接从S3的CSV文件中查询数据。我曾考虑过使用传统的SQL数据库，如MySQL，但在我的用例中，S3更便宜，而且非常适合持久存储。💪</p><h2 id="e406" class="nf lu iq bd lv ng nh dn lz ni nj dp md lf nk nl mf lj nm nn mh ln no np mj nq bi translated">赫罗库</h2><p id="1d5b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我选择使用Heroku云服务来部署我的应用程序。除了非常容易部署之外，我没有什么理由在DigitalOcean、Linode或EC2上使用Heroku这样的云服务。Heroku应用程序运行在dyno(虚拟Linux容器)上，有两种类型，一种是处理web进程(即HTTP流量)的web dyno，另一种是处理后台作业(即芹菜任务)的worker dyno。我最终在Heroku免费层用一个免费网站和worker dyno部署了这个应用程序。</p><p id="65eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我的用例，Heroku有一些缺点:</p><ul class=""><li id="8417" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">Heroku dynos有一个短暂的文件系统。这意味着应用程序保存到磁盘的文件(即下载)最终会丢失，web和worker dynos可能看不到相同的文件。如果一个文件被工人保存到磁盘，web dyno可能找不到它。</li><li id="43d1" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">Heroku可能很贵。例如，Heroku Redis插件在免费层有25mb的内存，不足以让我的应用程序存储完整的芹菜任务结果，下一层是15美元/月。</li></ul><p id="e69f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，通过使用AWS S3进行数据库存储，很容易就可以解决这两个问题。</p><h1 id="52bc" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">步骤3:构建仪表板过滤器功能</h1><p id="d063" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我想要一个简单的界面，在交互式地图上显示气象站，这样用户就可以根据气象站的位置和数据可用性等直观地过滤气象站。Dash库包括易于实现的高级组件，如图表、下拉框和输入框。Dash应用程序的结构是应用程序布局，由HTML和Dash核心组件组成，后面是创建链式交互的应用程序回调。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/6f707ae5b9e9d5254d1c05f9a1a0e882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mBPqYC25ALW9iDXk2H32kQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">交互式地图过滤</p></figure><p id="75f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">背景地图来自Mapbox API，气象站元数据(如气象站位置)在应用程序启动时从S3自动气象站加载。Dash中的回调很容易实现，包括输入组件(即省或站名)和输出组件(即地图图形)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Dash应用回调示例</p></figure><h1 id="b622" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">步骤4:构建仪表板下载功能</h1><p id="b768" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">单击地图上的气象站后，用户可以查看表格中的气象站元数据，并选择所需的气象站来下载数据。然后，用户可以设置下载间隔(即在站点记录数据的频率)和下载日期。完成后，会显示一条消息，让用户知道他们将要下载的内容。该消息还会激活“生成数据”按钮。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/1636570320980a7402e40c71a39500fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*C0EkpJdRhUqpeLS0Dp8HdQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">交互式气象站选择和下载</p></figure><p id="fa1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当点击“生成数据”按钮时，一个任务被发送到RabbitMQ消息队列，芹菜工人在那里接收它。芹菜任务使用选定的表格数据(即，站名、省等。)、下载日期和数据间隔，以查询S3相关CSV的子集。在Celery执行任务的同时，前端使用task.id查询task.state(即待定、进度、成功或失败)。这每250毫秒发生一次，并更新进度微调器的可见性。</p><p id="9dc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我没有使用Heroku，我可以将查询的数据保存到磁盘，或者如果我的数据较小，我可以在浏览器中缓存。相反，我将查询到的S3数据推回到S3的一个临时文件夹中。在前端，创建一个指向临时数据的S3预签名URL，并使用Flask routing链接到“下载数据”按钮。当用户点击“下载数据”按钮时，它重定向到临时数据并在浏览器中下载文件。</p><p id="23e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使我的下载结构稍慢且效率较低(例如，多个S3 GET和PUSH命令)，预签名URL的出色之处在于，客户端直接从S3下载，避免了将数据保存到服务器或缓存在浏览器中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">S3预签名URL的Flask路由示例</p></figure><h1 id="7785" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">步骤5:构建仪表板图形功能</h1><p id="0f30" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在我看来，能够近实时地可视化下载的数据对用户来说是最重要的功能，因为它允许他们在现场进行探索性的数据分析。</p><p id="abf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我选择使用Dash graph组件呈现三个基本图形来传达不同的数据统计(即季节性趋势的箱线图和数据分布的直方图),以呈现数字。即使是大型数据集(&gt; 500000个数据点)，折线图和直方图的渲染速度也相对较快，但箱形图可能会比较慢。为了保持几秒钟的渲染时间，我使用了箱线图的数据子样本。这是通过Pandas DataFrame.sample函数完成的，并保持分布与原始分布相同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/ee7b3adbe7d793b17c5566ddfd928c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VJHF9KFB3AWNIa5VGEuEaw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">下载数据的交互式绘图</p></figure><p id="ec38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所述，因为我使用Heroku，保存到磁盘不是一个选项，而且由于数据集可能超过50mb，使用Heroku Redis来存储Celery任务结果是不切实际的(例如，在空闲层上只有25mb的内存)。此外，在Dash回调和Dash页面之间共享数据可能很棘手。标准解决方案是使用dcc。存储组件(即在浏览器存储中)，但这只适用于小于几兆字节的数据。</p><p id="089e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过一些测试，我发现最大化成本和速度的解决方案是使用S3选择在S3和图形中查询数据。这样做的最大缺点是图形的加载时间较长(即从云数据库查询数据，而不是在本地检索)，并且需要在每次图形渲染时查询S3。</p><h1 id="aab2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">步骤6:部署应用程序</h1><p id="1a3e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Dash(即Flask)应用程序本身一次只能处理一个HTTP请求，因此要处理多个请求，应该使用Gunicorn WSGI web服务器将Dash部署到Heroku。Gunicorn web服务器允许您同时运行应用程序。Heroku对Gunicorn工作进程的配置有几个建议，比如在一个空闲层上将Gunicorn工作进程的数量限制在2-3个。</p><p id="0f06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正确设置Procfile、RabbitMQ、Heroku Redis和Celery配置是相当具有挑战性的。CloudAMQP <a class="ae kv" href="https://www.cloudamqp.com/docs/celery.html" rel="noopener ugc nofollow" target="_blank">推荐使用Celery时RabbitMQ消息队列的配置</a>。使用CloudAMQP自由层时最重要的方面是降低“后台”消息速率(即配置Celery worker在没有流言蜚语、混杂和心跳的情况下运行)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Heroku Procfile示例</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">芹菜配置示例</p></figure><h1 id="0f3a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">第七步:监控成本</h1><p id="d598" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果你的业余爱好应用花费你一大笔钱，你将无法支撑很久！我的应用程序目前每月花费约1-2美元，但这将随着规模的扩大而改变。</p><ul class=""><li id="dbb1" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir"> Heroku Dyno </strong>:自由层！</li><li id="908f" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir"> CloudAMQP RabbitMQ: </strong>自由层！</li><li id="99f6" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">Heroku Redis: 自由层！</li><li id="07fc" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">AWS S3:</strong>~ $ 1–2/月(取决于获取/推送命令的数量)</li></ul><h1 id="657f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">后续步骤</h1><p id="22d0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在未来版本的应用程序中，我想添加和更改一些内容。</p><ul class=""><li id="0ffa" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">迁移到DigitalOcean或其他IaaS云服务。这将允许我将数据保存到磁盘，或者在Redis缓存方面有更大的灵活性，并防止我的应用程序每次下载都需要GET和PUSH请求。</li><li id="9bc7" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">加速绘图。这可以通过仅缓存数据以生成初始图表或在浏览器中存储数据子集来实现。</li></ul><p id="d9c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，这是一个非常有趣的项目，我学到了很多关于全栈开发的知识！</p></div></div>    
</body>
</html>