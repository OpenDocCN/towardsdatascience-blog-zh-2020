<html>
<head>
<title>Generating Fractals with Blender and Animation-Nodes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用混合器和动画节点生成分形</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/generating-fractals-with-blender-and-animation-nodes-3ae79d02bf40?source=collection_archive---------11-----------------------#2020-03-04">https://towardsdatascience.com/generating-fractals-with-blender-and-animation-nodes-3ae79d02bf40?source=collection_archive---------11-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9ac7542ce3790d88095db62557db609a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Gga3EyaAemWLVVCCYSReeA.gif"/></div></div></figure><div class=""/><p id="b2b4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个使用Blender生成分形视觉效果的教程、例子和资源的集合。我将涵盖递归、n-flakes、L-系统、Mandelbrot/Julia集和导子等主题。</p><p id="923b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">为什么:</strong>如果你对分形图案着迷，对Blender中的过程化生成感兴趣，想对动画-节点和着色器节点有更好的理解和动手体验。</p><p id="25fd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">谁:</strong>此处所有内容均基于Blender 2.8.2和<a class="ae kz" href="https://animation-nodes.com/#download" rel="noopener ugc nofollow" target="_blank">动画-节点v2.1 </a>。我还依赖了一些简短的代码片段(Python ≥ 3.6)。</p><h1 id="e789" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">分形</h1><blockquote class="ly lz ma"><p id="4caa" class="kb kc mb kd b ke kf kg kh ki kj kk kl mc kn ko kp md kr ks kt me kv kw kx ky im bi translated">“美丽复杂，却又如此简单”</p></blockquote><p id="8e4f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">分形是具有分形维数的形状。这源于我们在它们扩展时测量它们的方式。理论分形在不同的尺度上是无限自相似的。</p><p id="ecb9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于我们的设置，我们不关心纯理论分形，因为除非在非常特殊的情况下，否则在Blender中是无法实现的。我们最关心的是<em class="mb">精细结构</em>(不同尺度的细节)和自相似的自然外观(由明显更小的自身副本组成)。</p><p id="54c6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">了解分形更多信息的其他建议资源:</p><ul class=""><li id="4e97" class="mf mg je kd b ke kf ki kj km mh kq mi ku mj ky mk ml mm mn bi translated"><a class="ae kz" href="https://www.youtube.com/watch?v=gB9n2gHsHN4" rel="noopener ugc nofollow" target="_blank">【YouTube】分形上的3 blue 1 brown</a></li><li id="4527" class="mf mg je kd b ke mo ki mp km mq kq mr ku ms ky mk ml mm mn bi translated"><a class="ae kz" href="https://www.goodreads.com/book/show/558059.The_Fractal_Geometry_of_Nature" rel="noopener ugc nofollow" target="_blank">【本书】benot b . Mandelbrot著《自然的分形几何》</a></li><li id="efe1" class="mf mg je kd b ke mo ki mp km mq kq mr ku ms ky mk ml mm mn bi translated"><a class="ae kz" href="https://www.goodreads.com/book/show/17803172-fractals" rel="noopener ugc nofollow" target="_blank">【书】分形:肯尼斯·法尔科内的简短介绍</a></li><li id="7297" class="mf mg je kd b ke mo ki mp km mq kq mr ku ms ky mk ml mm mn bi translated">przemyslaw Prusinkiewicz的《植物的算法之美》</li></ul><h1 id="ebd9" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">n-薄片</h1><p id="41c3" class="pw-post-body-paragraph kb kc je kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/N-flake" rel="noopener ugc nofollow" target="_blank"> n-flake(或polyflake) </a>是一种分形，通过用自身的多个缩放副本替换初始形状来构建，通常放置在对应于顶点和中心的位置。然后对每个新形状递归重复该过程。</p><h2 id="8424" class="my lb je bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">递归</h2><p id="852d" class="pw-post-body-paragraph kb kc je kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">这是我们探索分形的一个很好的起点，因为它允许我们通过一个简单的动画节点设置来涵盖<strong class="kd jf">递归</strong>和其他重要概念。</p><p id="16ec" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就引出了我们的主要问题:动画节点(目前)不支持纯递归。我们需要一些变通办法。一种选择是始终依赖纯Python脚本，正如我在<a class="ae kz" rel="noopener" target="_blank" href="/blender-2-8-grease-pencil-scripting-and-generative-art-cbbfd3967590">上一篇文章</a>中解释的那样，但我希望这篇文章的重点更多地放在动画节点上，所以我们可以做的是通过迭代和循环队列来近似递归。</p><p id="c30c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个想法是依靠<a class="ae kz" href="https://animation-nodes-manual.readthedocs.io/en/latest/user_guide/subprograms/loop.html" rel="noopener ugc nofollow" target="_blank">循环输入</a> <em class="mb">重新分配</em>选项来保存一个结果队列，我们可以在下一次迭代中处理这些结果。</p><p id="224c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们考虑正多边形的n片情况。给定若干线段<code class="fe nk nl nm nn b">n</code>(多边形的边数)、半径<code class="fe nk nl nm nn b">r</code>和中心<code class="fe nk nl nm nn b">c</code>，我们计算以<code class="fe nk nl nm nn b">c</code>为中心、半径<code class="fe nk nl nm nn b">r</code>的<code class="fe nk nl nm nn b">n</code>-多边形的点。对于每个新计算的点<code class="fe nk nl nm nn b">p</code>,我们重复这个过程(即，找到以<code class="fe nk nl nm nn b">p</code>为中心的多边形),但是通过一些预定义的因子调整半径<code class="fe nk nl nm nn b">r</code>。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/0d7cc908128d013deb745442d9bbf1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ELA7vQBB48RRsxRGO3DNyA.gif"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">n多边形动画-实际的节点设置</p></figure><p id="7533" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有主要的逻辑都在下面的循环中，它负责计算多边形点和新的半径，并重新分配它，以便下一次迭代可以处理它们。理解这一部分是很重要的:在第一次迭代中，循环处理给予<code class="fe nk nl nm nn b">Invoke Subprogram</code>节点的任何东西，而对于所有后续的迭代，循环将处理它在前一次迭代中更新的值。每次这些都被清理，这就是为什么我们维护两个队列(<code class="fe nk nl nm nn b">centers_queue </code>和<code class="fe nk nl nm nn b">all_centers</code>)，前者是我们还没有处理的中心，后者是到目前为止计算的所有中心的集合，它将被用作输出来创建我们的样条列表。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/2cca9adc8ecde76695db6fec1eeca04f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jadT60Os9IJm93P29Pgz7g.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">带有缩放和重新分配逻辑的主循环</p></figure><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/4d1f58db49789ec6f16003f3c2465fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oF3Ghjidm2MbE8v3fAB3Aw.png"/></div></div></figure><p id="32de" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个子程序都是Python脚本。这些例子让我觉得编码更简洁，不需要翻译成纯粹的节点。</p><p id="17e5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">计算正多边形的点:</p><pre class="np nq nr ns gt nz nn oa ob aw oc bi"><span id="179b" class="my lb je nn b gy od oe l of og">points = []<br/># compute regular polygon points for each given center<br/>for center in centers:<br/>    angle = 2*pi/segments  # angle in radians<br/>    for i in range(segments):<br/>        x = center[0] + radius*cos(angle*i)<br/>        y = center[1] + radius*sin(angle*i)<br/>        z = center[2]  # constant z values<br/>        points.append((x, y, z))<br/>    #points.append(points[-segments])  #  close the loop</span></pre><p id="a099" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">获取比例因子:</p><pre class="np nq nr ns gt nz nn oa ob aw oc bi"><span id="d380" class="my lb je nn b gy od oe l of og">from math import cos, pi</span><span id="f175" class="my lb je nn b gy oh oe l of og"># compute scale factor for any n-flake<br/># <a class="ae kz" href="https://en.wikipedia.org/wiki/N-flake" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/N-flake</a><br/>cumulative = 0<br/>for i in range(0, segments//4):<br/>    cumulative += cos(2*pi*(i+1) / segments)<br/>scale_factor = 1 / (2*(1 + cumulative))</span></pre><p id="51d4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">额外的循环设置是分割点，以便将每个多边形转化为单独的样条线。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/ee945b97ce4e384ec4798cf924e55569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B9foeVaWB--lwr_t4D950Q.png"/></div></div></figure><h2 id="c7e1" class="my lb je bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">转向3D规则多面体</h2><p id="203f" class="pw-post-body-paragraph kb kc je kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">我们可以很容易地调整这种设置来处理常规的固体。这一次，我们不是自己计算形状顶点，而是依赖于场景中已经存在的对象，获取它的顶点并递归地变换它们。我们利用矩阵属性和<code class="fe nk nl nm nn b">Compose Matrix</code>节点来最小化所需的工作量或节点。这是设置</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/9ba355951379a153ad3f66a147e7d483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TsObizUEd3q4JTocCdwbTw.png"/></div></div></figure><p id="d71d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Out <code class="fe nk nl nm nn b">matrix_queue</code>用恒等式变换矩阵(无平移、无旋转和单位比例)初始化，而我们的<code class="fe nk nl nm nn b">transformation</code>列表是我们的目标/输入对象顶点位置，由任意比例因子组成，当用于变换另一个矩阵时，这相当于说“在那里移动一切，并按给定因子缩放”。<br/>这里是执行转换循环和重新分配操作的改编递归部分。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/5821a20c3020f1984a5337890f6e2baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jxrYhnGPfa2EzC0A6gbX3w.png"/></div></div></figure><p id="c3e6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">柏拉图立体的示例结果(介于四次和五次迭代之间)。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/54e1a052656f0d93381b02e220b88446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lmvLotfvYt1Qne_qr0QWSw.gif"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">我讨厌二十面体</p></figure><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/6afb57f6ddc347ce832579304a6e1252.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/1*N_nm3CtJvbxUK-excswhpg.gif"/></div></figure><p id="4e0a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，可以更新原始平移矩阵，使得新实体不精确地放置在前身顶点上，而是放置在穿过前身中心和新顶点的线的任何点上，如侧面动画中所示。</p><p id="407d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然之前的转换矩阵仅仅是顶点的位置，但是我们现在做了一些矢量数学来将这些点从原始位置转移。如果我们从它们中减去物体中心，我们就得到感兴趣的方向向量。然后，我们可以将它除以任意值，以相应地放置新的递归实体。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/6953c4d70879aedc05e670884ebacfd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QY0io_O8Rz-ajmLmdTepZw.png"/></div></div></figure><p id="9472" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们只实例化最后一次迭代的对象，我们会得到正确的<strong class="kd jf">柏拉图立体分形。众所周知的例子是Sierpinski四面体和Menger海绵。</strong></p><div class="np nq nr ns gt ab cb"><figure class="oo iv op oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/5a7a398a534dfa87a49b55ec77fa0003.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*UpqBBBnY9ymMxEAJPXOLpQ.png"/></div></figure><figure class="oo iv op oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/1aa82794f7980296231a2f34ae72a364.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Wb6KvDbA0_5-_G7sICk6oQ.png"/></div></figure><figure class="oo iv op oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/61ddc7aeb557b95cc55a9ea145ee03ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*5p5-rbyVe_q-ClFSowgyHQ.png"/></div></figure></div><div class="ab cb"><figure class="oo iv op oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/8ac5f06b4ab10ae9569ae47a6b434a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0dOfxce3Hc3r_vR_LYh4Pg.png"/></div></figure><figure class="oo iv op oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/e40ea5ad5f7f52ad58780cdb20b7009e.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*neicDtxI2ky4Ttz3A8ycSg.png"/></div></figure><figure class="oo iv op oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/a73a0b1b420972055659ee2dd9e031d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*zof8_ThbXBSwrBOgS4gtQw.png"/></div><p class="nt nu gj gh gi nv nw bd b be z dk ou di ov ow translated">Eevee中渲染的示例，增加了布尔运算符以增加趣味性</p></figure></div><h2 id="8c9f" class="my lb je bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">要尝试的事情</h2><ul class=""><li id="0f26" class="mf mg je kd b ke mt ki mu km ox kq oy ku oz ky mk ml mm mn bi translated">在递归步骤中任意/随机更改polyflake类型</li><li id="d9e1" class="mf mg je kd b ke mo ki mp km mq kq mr ku ms ky mk ml mm mn bi translated">使用置换贴图来模拟额外的递归步骤，而无需创建更精细的额外几何体</li><li id="08b4" class="mf mg je kd b ke mo ki mp km mq kq mr ku ms ky mk ml mm mn bi translated">体积和纯着色器节点设置</li></ul><h1 id="3c55" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">l系统</h1><p id="f059" class="pw-post-body-paragraph kb kc je kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/L-system" rel="noopener ugc nofollow" target="_blank">一个L-系统(或林登迈耶系统)</a>是一个文法；指定如何通过一组规则、字母表和初始公理生成文本字符串的东西。它伴随着将这种字符串转换成几何图形的转换机制。</p><p id="c0b6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们对L系统感兴趣，因为它们可以用来生成自相似分形，也因为我们可以通过<code class="fe nk nl nm nn b">LSystem</code>节点免费获得它们。这里是一个将结果实例化为object的示例设置。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/ba130815207cd8ec37650131b5477a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tNmFCI4zG9cq0aoL2ov4kA.gif"/></div></div></figure><p id="cc57" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">边上的是由公理<code class="fe nk nl nm nn b">X</code>(初始状态)和两条规则<code class="fe nk nl nm nn b">X=F[+X][-X]FX</code>和<code class="fe nk nl nm nn b">F=FF</code>定义的分形图形。节点负责使系统进化到指定的代数，这可以是很好的分数，允许平滑过渡。它还将文本结果转换为网格。由于这个原因，你必须遵循公理和字母用法的特定惯例。</p><p id="03ac" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一个需要考虑的重要参数是高级节点设置中的<code class="fe nk nl nm nn b">Symbol Limit</code>，它指定了生成的字符串的最大长度。如果超过这个限制，系统将抛出一个错误。</p><h2 id="344f" class="my lb je bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">例子</h2><div class="np nq nr ns gt ab cb"><figure class="oo iv op oq or os ot paragraph-image"><img src="../Images/6fa185ed6efcb7ea19d3760838613a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/1*cmYlFrlZiCj3d0e_kx4F7w.gif"/></figure><figure class="oo iv op oq or os ot paragraph-image"><img src="../Images/bb6b60c7d8ec57f7b5e7c1492c710a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/1*r8Gn3vxZQc06C4JPLOOrZA.gif"/></figure><figure class="oo iv op oq or os ot paragraph-image"><img src="../Images/072c62e78c9216ada9cbda7deb1d12f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/1*0-rsy03WQSLNIG67dTOVWA.gif"/><p class="nt nu gj gh gi nv nw bd b be z dk ou di ov ow translated">龙曲线，分形植物，sierpinski三角形</p></figure></div><pre class="np nq nr ns gt nz nn oa ob aw oc bi"><span id="03c5" class="my lb je nn b gy od oe l of og">dragon curve - axiom: FX, rules: (X=X+YF, Y=-FX-Y), angle: 90</span><span id="0b36" class="my lb je nn b gy oh oe l of og">fractal plant - axiom: F, rules: (F=FF-[-F+F+F]+[+F-F-F]), angle: 22.5</span><span id="75f0" class="my lb je nn b gy oh oe l of og">sierpinski triangle - axiom: F-F1-F1, rules: (X=X+YF, Y=-FX-Y), angle: 120</span></pre><h2 id="1b3d" class="my lb je bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">要尝试的事情</h2><ul class=""><li id="49fb" class="mf mg je kd b ke mt ki mu km ox kq oy ku oz ky mk ml mm mn bi translated">3D L系统(例如方位角+倾斜度)和随机L系统。(<a class="ae kz" href="https://github.com/5agado/data-science-learning/tree/master/graphics/l_systems" rel="noopener ugc nofollow" target="_blank">见Python代码</a>)</li><li id="db79" class="mf mg je kd b ke mo ki mp km mq kq mr ku ms ky mk ml mm mn bi translated">步长规则，与增长成比例，这样视图可以在增加代数时保持不变</li></ul><h1 id="003e" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">曼德尔布罗特</h1><p id="13bf" class="pw-post-body-paragraph kb kc je kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">作为分形之父，最常见和最频繁展示的分形以他的名字命名也就不足为奇了。Mandelbrot集合与Julia集合一起为一种现象提供了理论基础，这种现象也是由简单的规则定义的，但能够产生一幅美丽和复杂的无限画面。</p><p id="f8e0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以把这些集合看作是“用坐标形式表示的函数的迭代”，其中我们处理的是复数的平面。Jeremy Behreandt的这篇文章提供了关于复数、Mandelbrot集合和更多内容的令人印象深刻的详细介绍，所有这些都包含在Blender的Python API和开放着色语言(OSL)中。</p><p id="fcf0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们完全可以在Blender节点中实现类似的结果(没有脚本)，但是像往常一样，我们受到设置中缺少的迭代/递归功能的限制。基本思想是围绕复数平面移动，如公式所示</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/da1740f6790137e41d27b099b370084a.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*4CQXJ2AJegrvvtoaKxVCtg.png"/></div></figure><p id="70c3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据每个点收敛到无穷大的速度给每个点着色。这里<code class="fe nk nl nm nn b">z</code>是我们的起点，<code class="fe nk nl nm nn b">c</code>可以是任意选择的复数。该公式可以用纯笛卡尔平面坐标形式改写为</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/97f949f78ad1463705b165502cf068cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*oxz2FlAI0EltwTBktxjTTQ.png"/></div></figure><p id="b227" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们现在用<code class="fe nk nl nm nn b">(x,y)</code>作为我们的点，用<code class="fe nk nl nm nn b">a</code>和<code class="fe nk nl nm nn b">b</code>作为我们的控制值(之前<code class="fe nk nl nm nn b">c</code>的实部和虚部)。<br/>这里是着色器节点设置中公式的翻译</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pd"><img src="../Images/a460f9c26ba85eb1181fc8b4cf402acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0y8BPsLLYcp1SzI-qGiFiw.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">坐标形式函数的节点设置</p></figure><p id="7c0a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mb"> iterations_count </em>部分用于跟踪有效的迭代，那些点没有分叉的迭代。出于实用目的，这可以通过检查向量幅度是否小于2来近似计算。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/0b87bf3a003d2a9c0e51926a2218f8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hiu56Z0ndl2XEPi5T2NErQ.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">Mandelbrot集合的设置</p></figure><p id="81ed" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们可以插入我们的纹理坐标，通过分离<code class="fe nk nl nm nn b">x</code>和<code class="fe nk nl nm nn b">y</code>如图所示。为<code class="fe nk nl nm nn b">a</code>和<code class="fe nk nl nm nn b">b</code>重用它们给了我们Mandebrot集合，或者我们可以传递自定义值来探索其他集合和结果。现在是丑陋的部分:我们必须通过非常不优雅的复制粘贴混乱来近似函数迭代，对我来说最终看起来像这样。100次迭代是提供良好结果的合理估计，你添加的越多，你得到的细节就越多，但是设置会很快变得很慢。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pf"><img src="../Images/bb75e7cf41d92415f89b7eecccf3ff04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FV37qqVl_DvwvHnrIxOnig.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">是..</p></figure><p id="2e6a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但至少我们现在有东西可以玩了</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/068d61da3b01f0b521da91f98e2c49d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/1*K6ULGIeAg6bkYcpFTCkXMQ.gif"/></div></figure><div class="np nq nr ns gt ab cb"><figure class="oo iv ph oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/9504e63c2716043b55f3b6feddb5398c.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*jhzL3Ba3laXitptV47iHow.png"/></div></figure><figure class="oo iv pi oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/2ef25251338c5d2e2d6d0d1a996818fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*BCLjOzhirXcCaT1xTa39rg.png"/></div></figure></div><div class="ab cb"><figure class="oo iv pj oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/89eeca0cf4b48f54b2f48ac792607fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*yaeKV5iUWbY2FO7Ovu0rvA.png"/></div></figure><figure class="oo iv pk oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/e4095260d24c7366c96b701e6217d0de.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*3h67hcumtFlcW_BwcmfKxg.png"/></div></figure></div><h2 id="f4dc" class="my lb je bd lc mz na dn lg nb nc dp lk km nd ne lo kq nf ng ls ku nh ni lw nj bi translated">曼德尔布尔</h2><p id="c092" class="pw-post-body-paragraph kb kc je kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/Mandelbulb" rel="noopener ugc nofollow" target="_blank"> Mandelbulb </a>是Mandelbrot集合的3D投影。另外<a class="ae kz" href="https://www.youtube.com/watch?v=WSQFt1Nruns" rel="noopener ugc nofollow" target="_blank">已经有一个很棒的教程</a>由<a class="ae kz" href="https://twitter.com/JonasDichelle" rel="noopener ugc nofollow" target="_blank"> Jonas Dichelle </a>编写，解释了如何在Blender nodes和Eevee中模拟Mandelbulb。鉴于这种方法依赖于体积学，也值得参考一下Gleb Alexandrov在Blender会议上关于3D星云的演讲。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/5b61a0cffc8d18d721a960ef6ebfa274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/1*E6PlqS-Zxpx4xeZfFAS6Pg.gif"/></div></figure><div class="np nq nr ns gt ab cb"><figure class="oo iv op oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/bce16aad8b6819a6025706babd28779a.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*GYduR63gKxjX62Mew8k4TA.png"/></div></figure><figure class="oo iv op oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/942067a7bc07d9327c7979aa04624d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*y3VLWDjBCAHuZT6oomJaIQ.png"/></div></figure><figure class="oo iv op oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/9109e5e7461b988055d94bf6b3bafd0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*fZoq3mmCXqiXCvUPVZ_iOA.png"/></div></figure></div><div class="ab cb"><figure class="oo iv op oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/8874a807c9403f3e423888bedce8bc9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*VuFmLz_tMLUoDCoi5DSjVg.png"/></div></figure><figure class="oo iv op oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/a594c3c7becbb335c5e1dfebc84ac2de.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*KiAyi2Jnp3FF5tMODKnjQQ.png"/></div></figure><figure class="oo iv op oq or os ot paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/d7d68c78e5cd033a7404dc551e3494bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*f8RVmXRUeiU4oFy7Mz1smA.png"/></div><p class="nt nu gj gh gi nv nw bd b be z dk ou di ov ow translated">玩弄公式和颜色</p></figure></div><h1 id="742c" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="4607" class="pw-post-body-paragraph kb kc je kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">我总是被那些从简单规则中展现出复杂性的现象所吸引，而将它们可视化的能力让这一切变得更加有趣。Blender只是让它变得如此简单，而animation-nodes只是已经存在的一组令人惊叹的工具/实用程序的又一个补充，特别是从过程的角度来看。</p><p id="5a4a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我承认<em class="mb">远离纯粹的编码对我来说有点可怕</em>，就像一种发自内心的感觉，我没有做正确的事情，但是从迭代和实验的角度来看，毫无疑问我可以通过使用节点来实现效率。我仍然相信一些部分更适合作为单独的脚本，并且人们应该总是首先用代码构建/理解基础，因为它为复杂性分解和组织以及解决问题的一般化提供了更好的框架。</p><p id="197e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我计划探索更多类似的主题，完善理论理解和实践能力，以令人信服的方式再现它们。</p><p id="e1a8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">具体来说，这些是当前最热门的条目:</p><ul class=""><li id="a82d" class="mf mg je kd b ke kf ki kj km mh kq mi ku mj ky mk ml mm mn bi translated">超越三维</li><li id="60f4" class="mf mg je kd b ke mo ki mp km mq kq mr ku ms ky mk ml mm mn bi translated">元胞自动机</li><li id="b18f" class="mf mg je kd b ke mo ki mp km mq kq mr ku ms ky mk ml mm mn bi translated">形态发生</li><li id="1ad4" class="mf mg je kd b ke mo ki mp km mq kq mr ku ms ky mk ml mm mn bi translated">反应扩散</li><li id="67b5" class="mf mg je kd b ke mo ki mp km mq kq mr ku ms ky mk ml mm mn bi translated">奇怪的吸引子</li><li id="b8bd" class="mf mg je kd b ke mo ki mp km mq kq mr ku ms ky mk ml mm mn bi translated">棋盘形布置</li><li id="fbb3" class="mf mg je kd b ke mo ki mp km mq kq mr ku ms ky mk ml mm mn bi translated">本轮</li></ul><p id="68bd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我欢迎任何建议、批评和反馈。</p></div><div class="ab cl pm pn hx po" role="separator"><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr"/></div><div class="im in io ip iq"><blockquote class="pt"><p id="ebd4" class="pu pv je bd pw px py pz qa qb qc ky dk translated">你可以在<a class="ae kz" href="https://www.instagram.com/amartinelli1/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上看到更多我“润色”的图形结果，在<a class="ae kz" href="https://twitter.com/5agado" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上阅读更多技术/故障解释，在<a class="ae kz" href="https://github.com/5agado/data-science-learning" rel="noopener ugc nofollow" target="_blank"> Github </a>上试用我的代码。</p></blockquote></div></div>    
</body>
</html>