<html>
<head>
<title>Configure XGBoost Models with YAML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用YAML配置XGBoost型号</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/configure-xgboost-models-with-yaml-defa99be90ef?source=collection_archive---------22-----------------------#2020-02-21">https://towardsdatascience.com/configure-xgboost-models-with-yaml-defa99be90ef?source=collection_archive---------22-----------------------#2020-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="765b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何使用YAML文件使您的模型快速共享，非常灵活，并为生产做好准备</p><h1 id="8e36" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">介绍</h1><p id="b53d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">没有什么比开始一个新的ML项目更令人愉快的了。首先，你用一些<a class="ae lr" rel="noopener" target="_blank" href="/data-cleaning-with-python-and-pandas-detecting-missing-values-3e9c6ebcf78b">数据清理</a>来弄脏你的手，然后你开始将那些干净的数据加载到熊猫df中，开始一些<a class="ae lr" href="https://medium.com/datadriveninvestor/introduction-to-exploratory-data-analysis-682eb64063ff" rel="noopener">探索性的数据分析</a>(在那里你不可避免地发现你需要回去做更多的数据清理……)接下来，你进入<a class="ae lr" rel="noopener" target="_blank" href="/feature-engineering-for-machine-learning-3a5e293a5114">特征工程</a>，然后最后，你处于准备构建一些模型和<a class="ae lr" rel="noopener" target="_blank" href="/comparing-different-classification-machine-learning-models-for-an-imbalanced-dataset-fdae1af3677f">实验</a>的阶段！</p><p id="e4e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在整个过程中，您可能已经将所有代码放在了您可信赖的jupyter笔记本中。现在，您想要实际应用您的模型，但是您该如何开始呢？你当然不能把笔记本投入生产。</p><p id="0be8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">人们可以写一本关于机器学习模型生产化的书。我并不想教你生产所需的所有工程步骤。相反，把这篇文章看作是生产化<a class="ae lr" href="https://medium.com/the-mission/the-kaizen-approach-to-achieving-your-biggest-goal-the-philosophy-of-constant-improvement-172033f8346" rel="noopener"> <em class="ls">改善</em> </a> <em class="ls">:你可以对你的代码做一个小小的改变来为生产做准备。</em></p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><p id="4512" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将向您展示如何使用YAML配置文件来使您的代码更整洁、更具可伸缩性、更易于维护，并且在运行实验时更高效。</p><h1 id="e1bc" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">YAML不是标记语言</h1><p id="b864" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><a class="ae lr" href="https://yaml.org/" rel="noopener ugc nofollow" target="_blank"> YAML </a>是一种递归命名的语言，用于以人类可读的格式存储信息[1]。</p><p id="68aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对yaml结构的详细讨论将使我们离题太远，所以为了满足我们的目的，让我们考虑下面的yaml块来初始化<a class="ae lr" rel="noopener" target="_blank" href="/a-beginners-guide-to-xgboost-87f5d4c30ed7"> XGBoost分类器</a>。该块定义了一个字典“模型设置”，将另一个字典作为其值<em class="ls">参数字典。</em><em class="ls">参数</em> <em class="ls">字典</em>保存我们想要设置的xgboost模型的每个参数的值。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="fc37" class="mj kp it mf b gy mk ml l mm mn"># basic yaml config<br/>model_settings:<br/>  random_state: 90210<br/>  objective: 'binary:logistic'<br/>  eval_metric: ['error', 'map', 'auc', 'aucpr']<br/>  n_jobs: -1<br/>  learning_rate: 0.01<br/>  colsample_bytree: 0.8<br/>  subsample: 0.75<br/>  reg_alpha: 2.5<br/>  reg_lambda: 1.25<br/>  max_depth: 7<br/>  gamma: 0.2<br/>  n_estimators: 1251<br/>  max_delta_step: 8.5<br/>  scale_pos_weight: 2.0</span></pre><p id="147a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过在yaml配置中编写模型的参数，您可以获得4个主要好处:</p><ol class=""><li id="e7d3" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated">在模型的初始化中，参数不再是硬编码的，这使得代码更加清晰</li><li id="e350" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">合作者可以通过传递单个文件(最好是在git repo中)轻松实现您的模型</li><li id="c3fa" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">对模型进行更改不再需要代码重构</li><li id="65b1" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">遵循(3)，您可以轻松地在您的模型上进行“假设”实验。例如<strong class="js iu"> <em class="ls">如果</em> </strong> <em class="ls">我把max-depth改成更深一层呢？</em></li></ol><h1 id="a67c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">您的模型的配置对象</h1><p id="8cb6" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们希望能够将yaml文件中包含的信息传递给项目中的其他脚本。为此，我们为您的项目定义了一个包含所有子类(将它们视为模块)的超类，这些子类将包含yaml中的值。通过这样做，我们可以强制类型，这样用户就不能在需要int的地方传递字符串。让我们定义一个这样的对象。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2511" class="mj kp it mf b gy mk ml l mm mn">class YamlDemo:<br/>    class ModelSettings:<br/>        def __init__(self, random_state: int, objective: str, eval_metric: list, n_jobs: int, <br/>                     learning_rate: float, colsample_bytree: float, subsample: float, <br/>                     reg_alpha: float, reg_lambda: float, max_depth: int, gamma: float, <br/>                     n_estimators: int, max_delta_step: float, scale_pos_weight: float):<br/>            self.random_state = random_state<br/>            self.objective = objective<br/>            self.eval_metric = eval_metric<br/>            self.n_jobs = n_jobs<br/>            self.learning_rate = learning_rate<br/>            self.colsample_bytree = colsample_bytree<br/>            self.subsample = subsample<br/>            self.reg_alpha = reg_alpha<br/>            self.reg_lambda = reg_lambda<br/>            self.max_depth = max_depth<br/>            self.gamma = gamma<br/>            self.n_estimators = n_estimators<br/>            self.max_delta_step = max_delta_step<br/>            self.scale_pos_weight = scale_pos_weight<br/>            <br/>    def __init__(self, model_settings: ModelSettings, config_path: str):<br/>        self.model_settings = model_settings<br/>        self.config_path = config_path</span></pre><h1 id="20eb" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">配置分析器</h1><p id="80cc" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">有了yaml配置和配置对象，最后一个组件是编写解析器来读取yaml并用值填充配置对象。一个简单的配置解析器函数可以帮你做到这一点。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4368" class="mj kp it mf b gy mk ml l mm mn">import yaml</span><span id="225e" class="mj kp it mf b gy nc ml l mm mn">def parse_config(config_path: str) -&gt; YamlDemo:<br/>    """<br/>    parses yaml config; returns populated YamlDemo object<br/>    """<br/>    with open(config_path, 'r') as stream:<br/>            try:<br/>                config_settings = yaml.safe_load(stream)<br/>            except yaml.YAMLError as e:<br/>                print(e)</span><span id="2365" class="mj kp it mf b gy nc ml l mm mn">model_settings = YamlDemo.ModelSettings(<br/>            random_state = config_settings["model_settings"]["random_state"],<br/>            objective = config_settings["model_settings"]["objective"],<br/>            eval_metric = config_settings["model_settings"]["eval_metric"],<br/>            n_jobs = config_settings["model_settings"]["n_jobs"],<br/>            learning_rate = config_settings["model_settings"]["learning_rate"],<br/>            colsample_bytree = config_settings["model_settings"]["colsample_bytree"],<br/>            subsample = config_settings["model_settings"]["subsample"],<br/>            reg_alpha = config_settings["model_settings"]["reg_alpha"],<br/>            reg_lambda = config_settings["model_settings"]["reg_lambda"],<br/>            max_depth = config_settings["model_settings"]["max_depth"],<br/>            gamma = config_settings["model_settings"]["gamma"],<br/>            n_estimators = config_settings["model_settings"]["n_estimators"],<br/>            max_delta_step = config_settings["model_settings"]["max_delta_step"],<br/>            scale_pos_weight = config_settings["model_settings"]["scale_pos_weight"]<br/>        )<br/>    config = YamlDemo(model_settings=model_settings, config_path=config_path)<br/>    assert isinstance(config, YamlDemo)<br/>    return config</span></pre><h1 id="d632" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">将配置对象传递给模型</h1><p id="d394" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">现在，这个过程的最后一步是将config对象中的信息传递给模型。</p><p id="98d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们必须解析我们的配置以获得一个填充的对象:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="cfd1" class="mj kp it mf b gy mk ml l mm mn">config_settings = parse_config('/Users/cole.brendel/Desktop/demo.yaml')</span></pre><p id="fbae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们获取一个示例数据集，以查看“运行中”的模型:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="cd15" class="mj kp it mf b gy mk ml l mm mn">from sklearn.datasets import load_iris<br/>X,y = load_iris(return_X_y=True)</span><span id="bc57" class="mj kp it mf b gy nc ml l mm mn"># notice how I set the value for `random_state` from the config!</span><span id="1f71" class="mj kp it mf b gy nc ml l mm mn">from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.33, random_state=config_settings.model_settings.random_state)</span></pre><p id="c6e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们将把这个配置传递给一个训练模型的函数。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2f56" class="mj kp it mf b gy mk ml l mm mn"># fits a model on the training set/evals on test set<br/>import pandas as pd<br/>from pandas import DataFrame<br/>import xgboost<br/>from xgboost import XGBClassifier<br/>from sklearn.metrics import classification_report</span><span id="16c9" class="mj kp it mf b gy nc ml l mm mn">def fit_xgb_model(config_settings: YamlDemo, X_train: DataFrame, y_train: DataFrame, X_test: DataFrame, y_test: DataFrame) -&gt; xgboost.XGBClassifier:<br/>    """<br/>    fits an XGB model and returns model obejct <br/>    """<br/>    <br/>    eval_set = [(X_test, y_test)]  # used for early stopping</span><span id="41e6" class="mj kp it mf b gy nc ml l mm mn"># populate the model with settings from config<br/>    xgb = XGBClassifier(<br/>        random_state=config_settings.model_settings.random_state,<br/>        objective=config_settings.model_settings.objective,<br/>        eval_metric=config_settings.model_settings.eval_metric,<br/>        eval_set=eval_set,<br/>        n_jobs=config_settings.model_settings.n_jobs,<br/>        learning_rate=config_settings.model_settings.learning_rate,<br/>        colsample_bytree=config_settings.model_settings.colsample_bytree,<br/>        subsample=config_settings.model_settings.subsample,<br/>        reg_alpha=config_settings.model_settings.reg_alpha,<br/>        reg_lambda=config_settings.model_settings.reg_lambda,<br/>        max_depth=config_settings.model_settings.max_depth,<br/>        gamma=config_settings.model_settings.gamma,<br/>        n_estimators=config_settings.model_settings.n_estimators,<br/>        max_delta_step=config_settings.model_settings.max_delta_step,<br/>        scale_pos_weight=config_settings.model_settings.scale_pos_weight<br/>    )<br/>    # fit the model<br/>    xgb_fit = xgb.fit(X_train, y_train)<br/>    <br/>    # predict on test set<br/>    y_pred = xgb.predict(X_test)<br/>    <br/>    # show results<br/>    print(classification_report(y_test, y_pred, digits=4, target_names=['setosa', 'versicolor', 'virginica']))<br/>    <br/>    return xgb_fit</span><span id="d4f9" class="mj kp it mf b gy nc ml l mm mn">xgb = fit_xgb_model(config_settings, X_train, y_train, X_test, y_test)</span></pre><p id="045f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有维奥莱！模型已经训练评估过了！</p><figure class="ma mb mc md gt ne gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/25266f828058f378e3f7cde4db6a2165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*FAAaNR_jkFIX3e6L5oo_YA.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">已配置XGBoost模型的分类报告</p></figure><h2 id="5dc1" class="mj kp it bd kq nl nm dn ku nn no dp ky kb np nq lc kf nr ns lg kj nt nu lk nv bi translated">这个过程的优点的简短题外话</h2><p id="c116" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">你可能会问自己:</p><blockquote class="nw nx ny"><p id="4b7d" class="jq jr ls js b jt ju jv jw jx jy jz ka nz kc kd ke oa kg kh ki ob kk kl km kn im bi translated">为什么我要写这些代码只是为了给我的模型传递一些参数呢？这看起来像一吨的工作和方式比必要的更多的代码！</p></blockquote><p id="b7b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确实，您可以简单地用所有的参数填充一个模型，但是您现在将自己锁定在那个配置中了！要进行更改，您需要进入并修改代码。如果你想向你的队友展示你的最新配置，它产生了最好的结果？你会复制/粘贴你的模型代码吗？为什么不把配置文件松掉呢？</p><p id="e9e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个配置只是冰山一角。通过使用我在这里概述的过程，您可以很容易地指定更多与您的模型管道相关的附加信息。例如，培训文件放在哪里？将该路径放入配置中！每个ETL应用后要运行哪些ETL，临时文件存放在哪里？<em class="ls">配置那个！RandomSearch应该运行多少次迭代？<em class="ls">再次配置！</em>为了让您对这些配置的范围有所了解，请考虑以下高度简化的<strong class="js iu">示例:</strong></em></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5f7a" class="mj kp it mf b gy mk ml l mm mn">ec2_settings:<br/>  ip_address: xxx.xxx.xxx<br/>  pem_file: '/Users/{}/Desktop/demo/ssh/my.pem'<br/>data_settings:<br/>  deploy_date: 'today' # or 'YYYY-MM-DD'<br/>  target_names: ['no', 'yes']<br/>  raw_bucket: '/Users/{}/Desktop/demo/datasets/raw'<br/>  etl_bucket_train: '/Users/{}/Desktop/demo/datasets/etl_train'<br/>  etl_bucket_score: '/Users/{}/Desktop/demo/datasets/etl_score'<br/>  tmp_bucket: '/Users/{}/Desktop/demo/datasets/tmp'<br/>  df_name: 'df.csv'<br/>logger_settings:<br/>  log_name: 'demo.log'<br/>  logs_path: '/Users/{}/Desktop/demo/logs'<br/>etl_settings:<br/>  pickles: '/Users/{}/Desktop/demo/src/etls/pickles'<br/>  target_variable: 'xxx_yyy'<br/>  idx_column: 'idx_col'<br/>model_settings:<br/>  pickles: '/Users/{}/Desktop/demo/src/modeling/pickles'<br/>  predictions: '/Users/{}/Desktop/demo/predictions'<br/>  eval_metric: ['error', 'map', 'aucpr']<br/>  n_iters: 500<br/>  sampling_points: 1000<br/>  optimization_metric: 'f1_weighted'<br/>  cv_folds: 5</span></pre><p id="889e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这样一个系统，分享结果和实验就变得简单了，就像把你的同事的文件从一个yaml文件中删除一样。</p><h1 id="2d59" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结论和下一步措施</h1><p id="84ac" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">现在，您已经拥有了开始为您的机器学习项目编写配置所需的所有工具！这个过程需要一些时间来建立，但从长远来看是值得的。</p><p id="9b46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以进行快速实验，并且不必与代码交互就可以对模型进行更改。你使其他科学家能够简单地改变一些设置并进行测试。通过将YAML读入python类，您可以轻松地强制类型并防止传递错误的值，然后再花钱购买昂贵的计算资源。</p><h1 id="3c1f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">参考</h1><p id="0122" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">[1]<a class="ae lr" href="https://yaml.org/" rel="noopener ugc nofollow" target="_blank">https://yaml.org/</a></p><p id="7158" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lr" href="https://conference.scipy.org/proceedings/scipy2010/pdfs/mckinney.pdf" rel="noopener ugc nofollow" target="_blank">python中统计计算的数据结构</a>，McKinney，第九届科学中的Python会议录，第445卷，2010年。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3347" class="mj kp it mf b gy mk ml l mm mn">@software{reback2020pandas,<br/>    author       = {The pandas development team},<br/>    title        = {pandas-dev/pandas: Pandas},<br/>    month        = feb,<br/>    year         = 2020,<br/>    publisher    = {Zenodo},<br/>    version      = {latest},<br/>    doi          = {10.5281/zenodo.3509134},<br/>    url          = {https://doi.org/10.5281/zenodo.3509134}<br/>}</span></pre><p id="1ecf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Harris，C.R .，Millman，K.J .，van der Walt，S.J .等人<em class="ls">用NumPy进行阵列编程</em>。自然585，357–362(2020)。DOI:<a class="ae lr" href="https://doi.org/10.1038/s41586-020-2649-2" rel="noopener ugc nofollow" target="_blank">10.1038/s 41586–020–2649–2</a>。</p><p id="6a1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lr" href="http://jmlr.csail.mit.edu/papers/v12/pedregosa11a.html" rel="noopener ugc nofollow" target="_blank">sci kit-learn:Python中的机器学习</a>，Pedregosa <em class="ls">等人</em>，JMLR 12，第2825–2830页，2011年。</p><p id="d9ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">陈，t .，&amp; Guestrin，C. (2016)。XGBoost:一个可扩展的树提升系统。第22届ACM SIGKDD知识发现和数据挖掘国际会议论文集<em class="ls">(第785–794页)。美国纽约州纽约市:ACM。<a class="ae lr" href="https://doi.org/10.1145/2939672.2939785" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1145/2939672.2939785</a></em></p></div></div>    
</body>
</html>