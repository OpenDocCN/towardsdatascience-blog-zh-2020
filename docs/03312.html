<html>
<head>
<title>10 things you’re doing wrong in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中你做错的 10 件事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-things-youre-doing-wrong-in-java-7608e2f050c7?source=collection_archive---------1-----------------------#2020-03-30">https://towardsdatascience.com/10-things-youre-doing-wrong-in-java-7608e2f050c7?source=collection_archive---------1-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de2d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Java 开发人员最常犯的错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/97dca489d7de9474b3ab5ed6cce42efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5OLGsk8ibgL72wWf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的职业生涯中，我面试过几十个软件工程师，从初级到高级技术领导。在许多情况下，候选人在基本概念上有差距。</p><p id="0a11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将根据我作为技术领导者和采访者的经验，列出 Java 开发人员最常犯的错误。</p><h1 id="69cb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1)忽略访问修饰符</h1><p id="7c0f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">不要问我为什么，考生经常忘记 Java 中受保护的访问修饰符的作用域。可能是面试中积累的焦虑和紧张，但通常他们只提到两者之一:</p><ul class=""><li id="63b7" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">受保护的字段、方法和构造函数可以从同一个包中访问</li><li id="e516" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">可以从子类中访问受保护的字段、方法和构造函数</li></ul><p id="85ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我真的不知道忘记哪个更糟糕，但不引用包级范围揭示了候选人从未测试过受保护的方法(受保护的项可从测试类路径访问，只要包是相同的)；公共的和受保护的方法是你的软件提供的 API 的一部分。所以忘记这个属性就相当于在一次采访中宣称<strong class="lb iu">从来没有为你的软件编写过有意义的测试！</strong></p><h1 id="cd4a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2)不使用 equals()</h1><p id="f7c9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你使用<code class="fe ng nh ni nj b">==</code>(比较运算符)而不是<code class="fe ng nh ni nj b">equals()</code>调用，那么你必须改变你的习惯，因为结果可能会让你大吃一惊。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/0875bbc199a242b0caf59e8a02da51e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PJVVlLAqEu9ptPNTHfVggw.png"/></div></div></figure><h2 id="6832" class="nl lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">说明</h2><p id="1012" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当你想比较两个<code class="fe ng nh ni nj b">String</code>时，千万不要用<code class="fe ng nh ni nj b">==</code>，一般来说，不要用任何物体。<code class="fe ng nh ni nj b">==</code>只是比较两个操作数的对象引用(内存地址比较)而不是它们的内容。</p><p id="1465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，字符串<code class="fe ng nh ni nj b">y</code>并没有受益于<em class="nx">字符串内部化</em>:它的内存地址不同于<code class="fe ng nh ni nj b">x</code>的地址。</p><h1 id="5c6e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3)字符串连接</h1><p id="f97d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你处理大量的字符串或者巨大的<code class="fe ng nh ni nj b">String</code>，你可能会在连接过程中<strong class="lb iu">浪费大量的内存</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/e0e8d27fec14f643ed5d7e78c2988419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mCgS9P00rJwdFC-9jmmTLQ.png"/></div></div></figure><p id="cce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，您正在创建几个<code class="fe ng nh ni nj b">StringBuilder</code>和<code class="fe ng nh ni nj b">String</code>对象:准确地说是 10.000.000 <code class="fe ng nh ni nj b">StringBuilder</code>和 10.000.001 <code class="fe ng nh ni nj b">String</code>！</p><h2 id="94f9" class="nl lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">说明</h2><p id="8012" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了理解正在发生的事情，我们必须后退一步。</p><p id="f0ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您使用<code class="fe ng nh ni nj b">+</code>操作符进行字符串连接时，您正在创建一个中间对象，它在将值赋给目标对象之前存储连接的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/eb4dbcd606a928d6a20831d6689765e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*R4fhOJvqYNNBOtaid4a61A.png"/></div></figure><p id="e5ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们一共创建了 3 个对象:2 个用于文字，1 个用于连接，即第一个字符串<code class="fe ng nh ni nj b">result</code>加上第二个<code class="fe ng nh ni nj b">" world!"</code>的副本。这是因为<code class="fe ng nh ni nj b">String</code>是不可变的。</p><p id="5c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是编译器足够聪明，可以将代码转换成以下代码(不适用于 java 9+，因为它使用了<code class="fe ng nh ni nj b"><a class="ae ky" href="https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/StringConcatFactory.html" rel="noopener ugc nofollow" target="_blank">StringContactFacotry</a></code>，但是结果非常相似)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/a4d6c03f881aa2c34e33f75e45cedb34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jggzc6u_CTqGOeI5PQGEaQ.png"/></div></div></figure><p id="093f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种优化移除了中间串联对象，内存被 2 个字符串文字和 1 个<code class="fe ng nh ni nj b">StringBuilder</code>占用。一般情况下，字符串对象的数量从<strong class="lb iu"> <em class="nx"> O(n ) </em> </strong>下降到<strong class="lb iu"> <em class="nx"> O(n) </em> </strong>。</p><p id="fe35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到第一个例子，编译器像这样优化代码</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/c3a871642a18038a825184056213dd17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8z-j53aUpfJZGOZ8PN6XIg.png"/></div></div></figure><p id="88d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器只是优化了内部连接，但是这会创建大量的<code class="fe ng nh ni nj b">StringBuilder</code>和<code class="fe ng nh ni nj b">String</code>对象！连接字符串的正确方法如下，只需要 1 个<code class="fe ng nh ni nj b">StringBuilder</code>和 1 个<code class="fe ng nh ni nj b">String</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/93c9db52111cf38b3ed76fe179ae2e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ScLQBjNTO_Su4tE7byQDLA.png"/></div></div></figure><p id="0847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不错的进步！</p><h1 id="ed05" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4)字符串形式的密码</h1><p id="9dac" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">将用户提供的密码存储在字符串对象中是一个安全问题，因为它们容易受到内存攻击。</p><p id="5064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该使用<code class="fe ng nh ni nj b">char[]</code>，因为<code class="fe ng nh ni nj b"><a class="ae ky" href="https://docs.oracle.com/en/java/javase/12/docs/api/java.desktop/javax/swing/JPasswordField.html" rel="noopener ugc nofollow" target="_blank">JPasswordField</a></code>和<a class="ae ky" href="https://github.com/Password4j/password4j" rel="noopener ugc nofollow" target="_blank"> Password4j </a>已经在做了。如果我们谈论 web 应用程序，大多数 web 容器在<code class="fe ng nh ni nj b">HttpServletRequest</code>对象中以<code class="fe ng nh ni nj b">String</code>的形式传递纯文本密码，所以在这种情况下，您几乎无能为力。</p><h2 id="3873" class="nl lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">说明</h2><p id="7cf1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">字符串由 JVM 缓存(interning)并存储在 PermGen 空间(Java 8 之前)或堆空间中。在这两种情况下，缓存的值仅在垃圾回收发生后被删除:这意味着您不知道特定的值何时从字符串池中被删除，因为垃圾回收器的行为是非确定性的。</p><p id="6794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个问题是<code class="fe ng nh ni nj b">String</code>是不可变的，所以你不能清除它们。然而<code class="fe ng nh ni nj b">char[]</code>并不是不可变的，在处理之后可以被删除(<em class="nx">例如</em>用<code class="fe ng nh ni nj b">0</code>替换每个元素)。通过这个简单的技巧，攻击者可以在内存中找到清零的数组，而不是明文密码。</p><h1 id="115f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5)返回空值</h1><p id="a8ca" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我发现过多少次这样的方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/12066bc369757da82aad947047b132ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUL03C0sWJH9yCGGTQ66gw.png"/></div></div></figure><p id="769b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回<code class="fe ng nh ni nj b">null</code>的问题是，您强迫调用者对结果进行空检查；在这种情况下，调用者希望如果没有条目，那么将返回一个空列表。</p><p id="b8da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你总是想返回一个异常或者一个特殊的对象(比如一个空列表),否则使用你的代码的应用程序将会受到<code class="fe ng nh ni nj b">NullPointerException</code>的影响</p><h1 id="5b55" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6)传递空值</h1><p id="5edd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">另一方面，传递<code class="fe ng nh ni nj b">null</code>意味着你想当然地认为你调用的代码可以管理一个<code class="fe ng nh ni nj b">null</code>。如果这不是真的，你的应用程序肯定会抛出一个<code class="fe ng nh ni nj b">NullPointerException</code>。</p><p id="cc35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你显式地传递<code class="fe ng nh ni nj b">null</code>时，你会在你的代码中产生很多混乱。下面是一个经典的例子</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/e2017e25380c4a57af8e6ae9118b02ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VVJ9oPGoQXduqlIGwiJUVQ.png"/></div></div></figure><p id="f9ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe ng nh ni nj b">init()</code>时，没有<code class="fe ng nh ni nj b">User</code>对象可用。那么，如果你连一个<code class="fe ng nh ni nj b">User</code>都没有，为什么要调用一个用<code class="fe ng nh ni nj b">User</code>操作的方法呢？如果你需要包含在<code class="fe ng nh ni nj b">grantAccessToUser()</code>中的逻辑，你应该用不同的方法提取并使用它，而不是传递一个<code class="fe ng nh ni nj b">null</code>。</p><h1 id="0e16" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">7)重方法</h1><p id="94c9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">以下示例可能会<strong class="lb iu">导致您系统的性能损失</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/b3c1a13e106d0e1bebca14ce8a25b9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JM-KlO99OBR0Meo8sPIbrQ.png"/></div></div></figure><p id="0caf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">Pattern.compile()</code>是一个重方法，不应该在每次需要检查字符串是否匹配相同模式时调用它。</p><h2 id="369d" class="nl lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">说明</h2><p id="ffbf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ng nh ni nj b">Pattern.compile()</code>预编译模式，以便使用更快的内存表示。与单个匹配相比，该操作需要不可忽略的计算能力。</p><p id="8891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提高性能的一个经典方法是在静态字段中缓存<code class="fe ng nh ni nj b">Pattern</code>对象，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/a7740843cc5a3bf78ffaa33ce9d58bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xKTDoILqM_DZbhTkxMDD-w.png"/></div></div></figure><p id="0941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当您重用同一个计算量很大的无状态对象时，都应该使用这种解决方案。</p><h1 id="3eb8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">8)使用“返回代码”而不是抛出异常</h1><p id="bb21" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在某种程度上，开发人员认为异常是邪恶的，他们倾向于编写返回奇怪值的方法，比如<code class="fe ng nh ni nj b">-1</code>或<code class="fe ng nh ni nj b">"C_ERR"</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/760aaa927829d2e699217daa6cc0150f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjIoLiQ-1Bs5tmFb4hQbSQ.png"/></div></div></figure><p id="d66b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个值得创建自定义<code class="fe ng nh ni nj b">Exception</code>的典型案例。然后，该示例可以重写如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/d48ff90ea2d8e91638bc9cd1d6bb1282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jx09g5QFm-_KmEl1TLDBJg.png"/></div></div></figure><p id="412e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，可读性和可维护性大大提高了。调用者不必处理每一个返回代码，只需读取<code class="fe ng nh ni nj b">DeviceStartException</code>的内容。</p><h1 id="eb7c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">9)迭代时触摸集合</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/88c4a883257c1ecd692fba583a9cd990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtmKllt7xB3KpG_QKLOKvA.png"/></div></div></figure><p id="a0e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码会抛出一个<code class="fe ng nh ni nj b">ConcurrentModificationException</code>。</p><h2 id="d7fc" class="nl lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">说明</h2><p id="b326" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在对列表进行迭代时从列表中删除一个项目会使列表迭代器表现不佳，<em class="nx">例如</em>跳过元素、重复元素、索引数组末尾等。这也是为什么很多收藏更喜欢扔个<code class="fe ng nh ni nj b">ConcurrentModificationException</code>的原因。</p><p id="f4f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该使用底层数组的迭代器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/fff6d5a7f8b0270d1973fdb065bf6b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a1Q8i--fc6He0QcHCjqA8A.png"/></div></div></figure><h1 id="570c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">10)使用字符串缓冲区</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/a93e64a3dfbc6f40cbba727058a5af2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxF1h4iHdjKknrBrFAfACw.png"/></div></div></figure><p id="ad28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe ng nh ni nj b">StringBuffer</code>的同步特性，这个例子<strong class="lb iu">产生了大量的开销</strong>。在更复杂的上下文中，读者可能会认为需要同步，而实际上并不需要。</p><p id="bfbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在一个项目中发现了一个<code class="fe ng nh ni nj b">StringBuffer</code>，这可能是因为一些遗留 API(即 Java 5 之前)需要它，很少是因为你的代码试图在并发上下文中添加<code class="fe ng nh ni nj b">String</code>。</p><p id="de9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe ng nh ni nj b">StringBuilder</code>代替:随 Java 5 引入，所有操作不同步。</p><h1 id="2206" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="93bd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这只是我在采访和许多活跃的项目中看到的错误的一个子集。我甚至没有提到 OOP 的陷阱，设计模式，过度工程，内存泄漏等等…</p><p id="9907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在犯这些错误，现在是时候改变你的编码风格，让你的应用程序更易维护，更安全。这并不难，避免这些陷阱会提高你作为开发人员的经验，并且会自动让你为下一次面试做好准备。</p><p id="d7c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续学习任何编程语言背后的理论，而不仅仅是语法，多写代码，使用静态代码分析器，比如 SonarQube，因为它可以指出实际的错误并突出潜在的错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/19926b0973101af971d71304aed3f251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6u51C_pl-UH3X3CbggmCjA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://xkcd.com/1513/" rel="noopener ugc nofollow" target="_blank"> xkcd </a></p></figure></div></div>    
</body>
</html>