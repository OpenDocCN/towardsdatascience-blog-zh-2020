<html>
<head>
<title>All the Things You Can Do With GitHub API and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可以用 GitHub API 和 Python 做的所有事情</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/all-the-things-you-can-do-with-github-api-and-python-f01790fca131?source=collection_archive---------4-----------------------#2020-06-15">https://towardsdatascience.com/all-the-things-you-can-do-with-github-api-and-python-f01790fca131?source=collection_archive---------4-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="be56" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">GitHub REST API 允许您管理问题、分支、回购、提交等等，所以让我们看看您如何使用 Python 来做到这一点！</h2></div><p id="0b94" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们大多数人每天都在使用 GitHub，要么使用 CLI，要么使用它的网站。然而，有时您需要自动执行这些相同的任务，例如创建 Gist、查询存储库分析或只是拉取、修改和推送新文件。使用<a class="ae le" href="https://developer.github.com/v3/" rel="noopener ugc nofollow" target="_blank"> GitHub API </a>可以很容易地完成所有这些事情，Python 可以在这方面提供帮助，让事情变得更加简单。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/5f824c707265a17ddb14beb222bcf360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIFzSq_50HYZiPX2eSiTmA.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@baileymahon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">贝利·马洪</a>在<a class="ae le" href="https://unsplash.com/s/photos/sea?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原始照片</p></figure><h1 id="8af6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们需要什么</h1><p id="aae4" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在我们开始使用 GitHub API 之前，我们首先需要生成一个个人访问令牌，它将允许我们根据 API 进行身份验证。我们可以通过点击<em class="ms">生成新令牌</em>在<a class="ae le" href="https://github.com/settings/tokens" rel="noopener ugc nofollow" target="_blank">https://github.com/settings/tokens</a>获得一个。您将被要求为令牌选择范围。您选择的范围将决定您能够对 API 执行哪些信息和操作。你应该小心那些以<code class="fe mt mu mv mw b">write:</code>、<code class="fe mt mu mv mw b">delete:</code>和<code class="fe mt mu mv mw b">admin:</code>为前缀的，因为这些可能具有相当大的破坏性。您可以在处的<a class="ae le" href="https://developer.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/" rel="noopener ugc nofollow" target="_blank">文档中找到每个范围的描述。</a></p><p id="a407" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了令牌，让我们测试它是否真的工作:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="289c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是预期的(经过修整的)回应，显示了我的公共<em class="ms">列表</em>:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="ca0e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用 Python 做这件事</h1><p id="b7a3" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们有了个人令牌，并用<code class="fe mt mu mv mw b">cURL</code>测试了它，所以现在我们可以切换到用 Python 做同样的事情。不过，我们有两个选择。我们可以使用原始请求，也可以使用。</p><p id="68e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ms"> PyGitHub </em>公开了一些 GitHub API 端点，用于最常见的操作，如存储库、问题或分支管理。它不能用于通过 GitHub API 公开的每一个单独的特性，所以在下面的章节中，我将展示<em class="ms"> PyGitHub </em>和<em class="ms"> Requests </em>调用的混合，这取决于是否可以用<em class="ms"> PyGitHub </em>来完成。</p><p id="cac1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们安装两个库(<em class="ms"> PyGitHub </em>和<em class="ms"> Requests </em>)并查看一个简单的例子:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="68f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<em class="ms"> PyGitHub </em>的示例:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="81dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<em class="ms">请求</em>的示例:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2c0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的两个片段都使用相同的 API 端点来检索指定存储库的所有开放问题。</p><p id="2a76" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这两种情况下，我们都从环境变量中获取 GitHub 令牌开始。接下来，在使用<em class="ms"> PyGitHub </em>的示例中，我们使用令牌来创建<code class="fe mt mu mv mw b">GitHub</code>类的实例，然后使用该实例来获取存储库并查询其处于<em class="ms">打开状态的问题</em>。结果是分页的问题列表，我们打印第一页。</p><p id="edb3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在使用原始 HTTP 请求的示例中，我们通过从用户名和存储库名称构建 API URL 并向其发送 GET 请求来获得相同的结果，该请求包含作为主体参数的<code class="fe mt mu mv mw b">state</code>和作为<code class="fe mt mu mv mw b">Authorization</code>头的令牌。唯一的区别是结果没有分页。以下是两个示例的结果:</p><p id="36ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个是<em class="ms"> PyGitHub </em>输出:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f320" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">二、原始 Python 字典列表(JSON):</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="e676" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">制造一个问题</h1><p id="0d47" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在讨论话题的时候，让我们也创造一个话题，好吗？</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0603" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是用例之一，在这里<em class="ms"> PyGitHub </em>非常方便。我们只需要获取存储库，针对它创建问题并指定一系列参数。在上面的代码片段中，我们使用了<code class="fe mt mu mv mw b">title</code>、<code class="fe mt mu mv mw b">body</code>、<code class="fe mt mu mv mw b">assignee</code>和<code class="fe mt mu mv mw b">labels</code>参数，但是您也可以添加里程碑或更多标签，使用它们的名称进行查询。</p><h1 id="d839" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创造一个要点</h1><p id="7c6e" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们可以创建的另一个东西是 GitHub <em class="ms"> Gist </em>，这次使用<em class="ms">请求</em>:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b597" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建<em class="ms">gist</em>的请求非常简单。在 POST 请求中，您需要指定<em class="ms">要点</em>是否应该是<code class="fe mt mu mv mw b">public</code>，接下来您需要填充将成为所述<em class="ms">要点</em>的一部分的<code class="fe mt mu mv mw b">files</code>列表，其中每个<em class="ms">关键字</em>是一个文件名，其<code class="fe mt mu mv mw b">content</code>包含文件的实际字符串内容。上面的代码使用<code class="fe mt mu mv mw b">json.dumps()</code>将 Python 字典转换成 JSON 字符串来创建请求体和通常的<em class="ms">授权</em>头。</p><p id="04d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面您可以看到预期响应的相关部分:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="17d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在创建了一个<em class="ms">要点</em>之后，你可能想要做其他的事情，比如更新它、列出提交、派生它或者只是获取它。对于所有这些操作，这些<a class="ae le" href="https://developer.github.com/v3/gists/" rel="noopener ugc nofollow" target="_blank">文档</a>中列出了一个 API 端点。</p><h1 id="9f36" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">以编程方式更新文件</h1><p id="1941" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">使用 GitHub API 的一个非常实用但非常复杂的用例是以编程方式获取、修改、提交并最终将一些文件推送到存储库。让我们来分解一下，看一个例子:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="cb0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从顶部开始，我们使用通常的存储库引用获取文件内容，将其解码为普通字符串并修改它。接下来，在<code class="fe mt mu mv mw b">push</code>函数中，我们从使用<code class="fe mt mu mv mw b">source.commit.sha</code>指定的提交创建新的分支。基于<code class="fe mt mu mv mw b">if</code>的陈述，我们有两个选择:更新现有文件或创建新文件。如果我们正在进行更新，我们首先检索现有文件以获得其散列和路径，然后我们使用先前修改的数据(<code class="fe mt mu mv mw b">content</code>)、提供的<code class="fe mt mu mv mw b">message</code>、<code class="fe mt mu mv mw b">branch</code>和<code class="fe mt mu mv mw b">author</code>对象来执行更新。另一方面，如果我们想在存储库中创建一个新文件，那么我们只需忽略传入现有文件的 SHA，就完成了。</p><h1 id="ba08" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">分析流量</h1><p id="b0c1" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">如果您对数据科学和分析更感兴趣，您可能会发现从存储库中查询视图/克隆统计数据的有用可能性:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="655d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从 GiHub 中检索数据所需的代码实际上只有一行用于<em class="ms">克隆</em>和一行用于<em class="ms">视图</em>。<code class="fe mt mu mv mw b">clones</code>和<code class="fe mt mu mv mw b">views</code>对象都包含<code class="fe mt mu mv mw b">count</code>、<code class="fe mt mu mv mw b">uniques</code>和<code class="fe mt mu mv mw b">views</code>属性。我们使用 print 语句中的前两个来分别显示实际的和唯一的克隆和视图。</p><p id="ec1e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">令人讨厌的(漂亮的)一行遍历包含每天视图<code class="fe mt mu mv mw b">count</code>的<code class="fe mt mu mv mw b">View</code>对象列表，以及我们提取到元组列表中的各个<code class="fe mt mu mv mw b">timestamp</code>。然后，我们找到具有最大值<code class="fe mt mu mv mw b">count</code>的元组，并在最后一行打印其日期和实际视图计数。这为我们提供了如下所示的输出:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="79ec" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">渲染降价</h1><p id="043f" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">这个例子使用 GitHub API，但是也可以用于非 GitHub 目的。我说的是 GitHub APIs 从 markdown 文本生成 HTML 的能力。如果你的网站不能直接显示 markdown，这可能很有用，但是你可以使用 GitHub API 为你创建 HTML。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="38a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，查询非常简单。我们所要做的就是发送文本到<code class="fe mt mu mv mw b">text</code> body 参数中，同时将模式设置为<code class="fe mt mu mv mw b">markdown</code>。上面的<code class="fe mt mu mv mw b">text</code>示例包括，<code class="fe mt mu mv mw b">code</code>片段，<em class="ms">斜体</em>和<em class="ms">粗体</em>文本，这正是我们以 HTML 形式返回的内容:</p><p id="442c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回应:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="527a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">更新提交状态</h1><p id="105c" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">你知道 CI 工具在你的提交旁边添加的这些漂亮的绿色对勾、黄色圆圈和难看的红叉吗？您想改变它们吗(也许只是为了好玩，也许是作为您自己的 CI 解决方案的一部分)？你当然知道。有这样的 API:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="07c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">令人惊讶的是(对我来说),这个模糊的 API 端点是<em class="ms"> PyGitHub </em>库的一部分。为了使用它，我们使用提交散列来检索 repo 及其提交。之后，我们通过使用参数描述其当前状态来为所述提交创建状态。</p><p id="6a81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以指定 4 种状态，即<code class="fe mt mu mv mw b">error</code>、<code class="fe mt mu mv mw b">failure</code>、<code class="fe mt mu mv mw b">pending</code>或<code class="fe mt mu mv mw b">success</code>——在这个例子中，我选择了<code class="fe mt mu mv mw b">success</code>。接下来，<code class="fe mt mu mv mw b">target_url</code>是<em class="ms">细节</em>链接指向的 URL。您可能已经注意到，<code class="fe mt mu mv mw b">description</code>和<code class="fe mt mu mv mw b">context</code>是下面对话框中显示的其他值。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mz"><img src="../Images/9696b432f0835cd9326d2d4955ff25fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KqZoIFbMXwhR-suoDkZCjQ.png"/></div></div></figure><p id="d784" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了能够验证状态改变实际上已经完成，我们接收到代表提交当前状态的<code class="fe mt mu mv mw b">CommitStatus</code>响应。在这种情况下看起来像这样:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="0940" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">添加对问题评论的反应</h1><p id="b6bb" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">GitHub 问题评论允许你添加各种<a class="ae le" href="https://developer.github.com/v3/reactions/#reaction-types" rel="noopener ugc nofollow" target="_blank">反应</a>到其中。所以，也许你想给某人的评论加上<code class="fe mt mu mv mw b">+1</code> / <code class="fe mt mu mv mw b">-1</code>。也许只是加入一些庆祝的表情符号。如果是这样的话，那么你可以用 Python 来实现:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a79d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了能够创建响应，我们需要注释 ID。可以从文档中此处显示的<a class="ae le" href="https://developer.github.com/v3/issues/comments/#list-comments-on-an-issue" rel="noopener ugc nofollow" target="_blank">API 中检索，或者点击问题评论右上角的<em class="ms">三点</em>图标，然后点击<em class="ms">复制链接</em>:</a></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi na"><img src="../Images/1922e7aee7a03a00f6c74d3cd45bd247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*taZTlEDYPTWK9iiGpxsQQw.png"/></div></div></figure><p id="4b0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样我们就可以在 URL 中插入<code class="fe mt mu mv mw b">owner</code>用户名、<code class="fe mt mu mv mw b">repo</code>姓名和这个<code class="fe mt mu mv mw b">comment_id</code>，在<code class="fe mt mu mv mw b">content</code>主体参数中插入表情名称(例如<code class="fe mt mu mv mw b">hooray</code>)。此外，我们还需要包括<code class="fe mt mu mv mw b">Accept</code>头，因为这个端点是开发者预览的一部分。</p><p id="8b55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的预期响应是<code class="fe mt mu mv mw b">201</code>,这意味着该反应已被创建，或者是<code class="fe mt mu mv mw b">200</code>,在这种情况下，该反应已经被预先添加。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="042b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们得到的(经过修整的)JSON 响应体:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="8471" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="5f4f" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">玩公共 API 是开始一个新项目的好方法(例如 CI 工具、存储库流量分析、GitHub 机器人), GitHub API 有很多这样的数据/内容。我在这里展示的只是一个小样本。要探索完整的 API，请查看这里的<a class="ae le" href="https://developer.github.com/v3/" rel="noopener ugc nofollow" target="_blank">文档</a>或者如果您不想弄乱 REST API，请查看<a class="ae le" href="https://pygithub.readthedocs.io/en/latest/examples.html" rel="noopener ugc nofollow" target="_blank"> <em class="ms"> PyGitHub </em>示例</a>。</p><p id="21af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢这篇文章，你应该看看我下面的其他 Python 文章！</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="123c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ms">本文最初发布于</em><a class="ae le" href="https://martinheinz.dev/blog/25?utm_source=tds&amp;utm_medium=referral&amp;utm_campaign=blog_post_25" rel="noopener ugc nofollow" target="_blank"><em class="ms">martinheinz . dev</em></a></p><div class="ni nj gp gr nk nl"><a rel="noopener follow" target="_blank" href="/automating-every-aspect-of-your-python-project-6517336af9da"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">自动化 Python 项目的各个方面</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">每个 Python 项目都可以从使用 Makefile、优化的 Docker 映像、配置良好的 CI/CD、代码…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz lp nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a rel="noopener follow" target="_blank" href="/ultimate-setup-for-your-next-python-project-179bda8a7c2c"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">下一个 Python 项目的最终设置</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">从零开始任何项目都可能是一项艰巨的任务…但如果您有这个最终的 Python 项目蓝图就不会了！</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz lp nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a rel="noopener follow" target="_blank" href="/implementing-grpc-server-using-python-9dc42e8daea0"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">使用 Python 实现 gRPC 服务器</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">你的下一个 API 不需要用 REST 和 JSON 来构建。gRPC 和协议缓冲区如何获得更好的性能…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="ob l nw nx ny nu nz lp nl"/></div></div></a></div></div></div>    
</body>
</html>