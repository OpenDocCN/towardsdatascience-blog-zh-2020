<html>
<head>
<title>10 Steps in Pandas to Process LAS File and Plot(part1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pandas 中处理 LAS 文件和绘图的 10 个步骤(第一部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-steps-in-pandas-to-process-las-file-and-plot-610732093338?source=collection_archive---------7-----------------------#2020-03-30">https://towardsdatascience.com/10-steps-in-pandas-to-process-las-file-and-plot-610732093338?source=collection_archive---------7-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="91dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我使用这些步骤来准备 LAS 格式的测井数据，以便用 python 绘图</h2></div><p id="fbd1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测井 ASCII 标准(LAS)是石油和天然气行业存储测井信息的常用格式。测井是通过深度间隔测量的地下岩石的物理特性。有几个商业软件可以读取这种格式。LAS 查看器有时是免费的，但功能有限。如果你想实现数据分析或高级数学计算，你必须购买许可证。</p><p id="eaba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面列出我使用最多的步骤:<br/> 1)读取文件<br/> 2)数据检查<br/> 3)列选择<br/> 4)缺失数据<br/> 5)删除行<br/> 6)统计<br/> 7)过滤<br/> 8)添加列<br/> 9)索引<br/> 10)绘图</p><p id="e87f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想使用我的示例数据，你可以访问堪萨斯大学的免费数据集。下载 2019 年 8 月的压缩文件，解压到您最喜欢的硬盘中。然后将文件号<em class="lf"> 1050383876 </em>复制到工作 Jupyter 笔记本目录中读取。你也可以直接从我的 Github <a class="ae le" href="https://github.com/mardani72/LAS_Pandas" rel="noopener ugc nofollow" target="_blank">账户</a>中获取本作品的全部 Jupyter 笔记本源文件和数据。</p><p id="d0f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">LAS 格式文件不能像熊猫那样用 python 中的通用库读取。首先我们需要安装<a class="ae le" href="https://lasio.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> lasio </em> </a> lib。lasio 被编写为与 python 兼容，并且具有 NumPy 和 ordereddict 依赖。运行以下代码进行安装:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="4932" class="lp lq it ll b gy lr ls l lt lu">pip install lasio<br/>pip install -r optional-packages.txt<br/>pip install --upgrade lasio</span></pre><h1 id="49b3" class="lv lq it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">1)读取文件</h1><p id="af32" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">导入熊猫、numpy 和 lasio 后，按如下方式读取 LAS 文件:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="f31b" class="lp lq it ll b gy lr ls l lt lu">import pandas as pd<br/>import numpy as np<br/>import lasio</span><span id="4531" class="lp lq it ll b gy mr ls l lt lu">las = lasio.read(r'1050383876.las')</span></pre><p id="c41e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">lasio 有很好的特性，比如曲线可以在 LAS 文件的头部分显示日志信息。运行:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="0ef6" class="lp lq it ll b gy lr ls l lt lu">las.curves</span></pre><figure class="lg lh li lj gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ms"><img src="../Images/788d2e75d7795f56352454187fbfce44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUOA7vBhuyK1nJWKh826PA.jpeg"/></div></div></figure><p id="f567" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这个命令，我们可以看到可用的曲线日志和基本信息，如文件中的单位和样本数据点数量。lasio 有其他功能，但我个人更喜欢将 LAS 文件转换成 pandas 数据帧，以获得其常用功能的优势:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="05ce" class="lp lq it ll b gy lr ls l lt lu">df = las.df()    #store las file in df variable as pandas dataframe</span></pre><h1 id="a5de" class="lv lq it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">2)数据检查</h1><p id="1415" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">在 pandas 中使用<em class="lf"> head() </em>函数，如果适合屏幕，我们可以看到 5 行和全部列。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="f71a" class="lp lq it ll b gy lr ls l lt lu">df.head()</span></pre><figure class="lg lh li lj gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi na"><img src="../Images/67f7b1751c39e73f57f748b33719c87f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRZXLInuTHc9iNyZXZdzJA.jpeg"/></div></div></figure><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="d224" class="lp lq it ll b gy lr ls l lt lu">df.shape</span></pre><figure class="lg lh li lj gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nb"><img src="../Images/2321708a541478238d4b90e78ffa773c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXsuJnT8mu0J98woi4qsjQ.jpeg"/></div></div></figure><p id="b709" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据帧有 17 个测井数据，列中有 7056 行作为深度间隔的采样点。我们可以认为井的较浅部分仅由 GR 记录，其余部分为空值。空值的 LAS 标准是-999.2500。</p><h1 id="8df5" class="lv lq it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">3)列选择</h1><p id="aff1" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">根据您的项目目的，您可以在数据集中选择不同的变量。首先，让我们看看这个文件中的可用日志:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="178a" class="lp lq it ll b gy lr ls l lt lu">df.columns</span></pre><figure class="lg lh li lj gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nc"><img src="../Images/42c45db360e51a5cb1e2664a27dc99fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYoBf3nlF9U0fWbGecJ5BQ.jpeg"/></div></div></figure><p id="ccef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这些日志中，我宁愿选择中子孔隙度、伽马射线、体积密度、声波、井径和计算声波孔隙度的列，并存储在一个新的变量中。请记住使用双括号，如下所示:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="fba0" class="lp lq it ll b gy lr ls l lt lu">df_selected = df[['CNPOR', 'GR', 'RHOB', 'DT', 'MELCAL', 'SPOR']]</span></pre><h1 id="43ad" class="lv lq it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">4)缺失数据</h1><p id="2aa1" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">缺少值在 LAS 文件中非常常见，因为感兴趣的深度可能因具体测量而异。LAS 文件中打印的值-999.2500 表示空值。缺失值在数据集的中间部分并不常见。通常，它发生在文件的头部或尾部。<em class="lf"> isna </em>函数如果位置有空值则返回 True，否则为 False。我们可以使用<em class="lf"> sum() </em>函数将这些布尔值相加，如下所示:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="4f7f" class="lp lq it ll b gy lr ls l lt lu">df_selected.isna().sum()</span></pre><figure class="lg lh li lj gt mt gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/99473f1a4fa179ebaac67227b882fc79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*13MLY1jKsyMTg0WVRyOixA.jpeg"/></div></figure><p id="e7e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们希望将 GR、DT 和 SPOR 作为重要的日志保存在数据集中。因此，为了消除丢失的值，我们可以删除其中一个日志丢失的行。</p><h1 id="9e0f" class="lv lq it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">5)删除行</h1><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="d6b9" class="lp lq it ll b gy lr ls l lt lu">df_dropped = df_selected.dropna(subset=['GR', 'DT', 'SPOR'],axis=0, how='any')</span></pre><p id="5b8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这行代码将删除一个(或多个)子集日志(' GR '，' DT '，' SPOR ')具有空值的所有行。</p><h1 id="f03e" class="lv lq it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">6)统计</h1><p id="8169" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">运行<em class="lf">描述</em>命令查看数据统计。这有助于查看数据范围和异常值。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="8134" class="lp lq it ll b gy lr ls l lt lu">df_dropped.describe()</span></pre><figure class="lg lh li lj gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ne"><img src="../Images/76f162b264622d1342cb74c694aa497d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxqdfnzHkmozr0VEw1pDlA.jpeg"/></div></div></figure><p id="9cb2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">岩石的岩石物理性质有一个正常范围。超出该范围的读数不应视为有效。这些范围是:</p><figure class="lg lh li lj gt mt gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/68f357e0bf306b1be2b7f1d82a8692ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*0e4kIWSNPZRA3l0B--IB1A.jpeg"/></div></figure><p id="5f3d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将此表与我们文件的统计数据进行比较，可以看出我们有一些值超出了范围，我们可以过滤数据集。例如,“SPOR”的最大值是 162 %,而这在自然界是不可能的。</p><h1 id="48f5" class="lv lq it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">7)过滤</h1><p id="917b" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">有几种方法可以过滤数据，比如 zscore。在这种方法中，我们可以去掉超出特定标准偏差范围(如 2 或更大)的值。我个人更喜欢高/低截滤波器，因为我可以控制最小值和最大值，如下所示:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="4822" class="lp lq it ll b gy lr ls l lt lu">df_filt1 = df_dropped.loc[(df_dropped.CNPOR &gt; -15) &amp; (df_dropped.CNPOR &lt;= 50)]<br/>df_filt2 = df_filt1.loc[(df_dropped.GR &gt; 0) &amp; (df_dropped.GR  &lt;= 250)]<br/>df_filt3 = df_filt2.loc[(df_dropped.RHOB&gt; 1) &amp; (df_dropped.RHOB&lt;= 3)]<br/>df_filt = df_filt3.loc[(df_dropped.DT &gt; 30) &amp; (df_dropped.DT &lt;= 140)]</span></pre><p id="4bab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不需要过滤 SPOR，因为它是 DT 的函数。</p><h1 id="0703" class="lv lq it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">8)添加列</h1><p id="d8ff" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">有时我们需要使用现有的日志计算一个参数，并存储在单独的列中。让我们用最简单的等式来计算页岩体积:</p><figure class="lg lh li lj gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ng"><img src="../Images/bae97ff4f5f4239c7620ef309de93f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nlhHqAoX1hXyxezGZ2SnXQ.jpeg"/></div></div></figure><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="edf4" class="lp lq it ll b gy lr ls l lt lu">df = df_filt.copy()      #make a copy of the latest dataset<br/>df['Vsh'] = (df.GR - df.GR.min()) / (df.GR.max() - df.GR.min())</span></pre><figure class="lg lh li lj gt mt gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/3bdd445e3298b74cfae082c63f044280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*o28-plKQMvk8G2fh6d-i6Q.jpeg"/></div></figure><p id="33f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">页岩体积作为名为 Vsh 的列添加。</p><h1 id="e9b6" class="lv lq it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">9)索引</h1><p id="62f2" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">当我们读取 LAS 文件时，lasio 将深度列转换为索引。我们可以将深度称为绘制 aim 和重新索引数据集的新列。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="c862" class="lp lq it ll b gy lr ls l lt lu">df_idx = df.rename_axis('Depth').reset_index()<br/>df_idx.head()</span></pre><figure class="lg lh li lj gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ni"><img src="../Images/ce3fdc74ded521f9ab4c6c0c2cc9fc04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t95ZQL5zJyBmi5R1HnKa9w.jpeg"/></div></div></figure><h1 id="1485" class="lv lq it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">10)绘图</h1><p id="76be" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">用 python 绘图是一个全面的讨论，但我将使用最简单的方法来可视化我的最终数据集。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="39e3" class="lp lq it ll b gy lr ls l lt lu">import matplotlib.pyplot as plt</span></pre><p id="68e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使代码可读和可重用，让我们定义一个函数:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="bcf8" class="lp lq it ll b gy lr ls l lt lu">def log_plot(logs):<br/>    logs = logs.sort_values(by='Depth')<br/>    top = logs.Depth.min()<br/>    bot = logs.Depth.max()<br/>    <br/>    f, ax = plt.subplots(nrows=1, ncols=6, figsize=(12,8))<br/>    ax[0].plot(logs.GR, logs.Depth, color='green')<br/>    ax[1].plot(logs.CNPOR, logs.Depth, color='red')<br/>    ax[2].plot(logs.DT, logs.Depth, color='black')<br/>    ax[3].plot(logs.MELCAL, logs.Depth, color='blue')<br/>    ax[4].plot(logs.RHOB, logs.Depth, color='c')<br/>    ax[5].plot(logs.Vsh, logs.Depth, color='m')<br/>    <br/>    for i in range(len(ax)):<br/>        ax[i].set_ylim(top,bot)<br/>        ax[i].invert_yaxis()<br/>        ax[i].grid()<br/>        <br/>    ax[0].set_xlabel("GR")<br/>    ax[0].set_xlim(logs.GR.min(),logs.GR.max())<br/>    ax[0].set_ylabel("Depth(ft)")<br/>    ax[1].set_xlabel("CNPOR")<br/>    ax[1].set_xlim(logs.CNPOR.min(),logs.CNPOR.max())<br/>    ax[2].set_xlabel("DT")<br/>    ax[2].set_xlim(logs.DT.min(),logs.DT.max())<br/>    ax[3].set_xlabel("MELCAL")<br/>    ax[3].set_xlim(logs.MELCAL.min(),logs.MELCAL.max())<br/>    ax[4].set_xlabel("RHOB")<br/>    ax[4].set_xlim(logs.RHOB.min(),logs.RHOB.max())<br/>    ax[5].set_xlabel("Vsh")<br/>    ax[5].set_xlim(logs.Vsh.min(),logs.Vsh.max())<br/>    <br/>    ax[1].set_yticklabels([]); ax[2].set_yticklabels([]);<br/>    ax[3].set_yticklabels([])<br/>    ax[4].set_yticklabels([]); ax[5].set_yticklabels([]) <br/>    <br/>    f.suptitle('Well:KOOCHEL MOUNTAIN #1', fontsize=14,y=0.94)</span></pre><p id="ef6b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像这样调用函数:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="5893" class="lp lq it ll b gy lr ls l lt lu">log_plot(df_idx)</span></pre><figure class="lg lh li lj gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nj"><img src="../Images/029d42cfb25eb6971742f95da33bd679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C2Hyw7eNHSeb1VlX5Ft6mA.png"/></div></div></figure><h1 id="6118" class="lv lq it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="4f54" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">在这项工作中，我阅读了一口单井的 LAS 文件，其中包括几份岩石物理测井记录。转换为 pandas 数据框便于流畅地使用和处理。这些步骤可以以不同的顺序实现。</p><p id="6fa3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您喜欢其他方式，建议改进，或者对类似的数据集有一些困难，请留下评论！</p></div></div>    
</body>
</html>