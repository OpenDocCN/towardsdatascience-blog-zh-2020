<html>
<head>
<title>Strings and Text in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的字符串和文本</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/strings-and-text-in-python-50be0452e0d3?source=collection_archive---------41-----------------------#2020-04-13">https://towardsdatascience.com/strings-and-text-in-python-50be0452e0d3?source=collection_archive---------41-----------------------#2020-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e8b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">拆分字符串和匹配文本</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a9f982b93eaf93218913ddcd7544880d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPeAwb512PBBKkgX4ilmyA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/photo/abstract-black-and-white-blur-book-261763/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="5611" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文本处理在许多有用的软件程序中起着重要的作用。文本处理的应用包括网页抓取、自然语言处理、文本生成等等。在本帖中，我们将讨论一些基本的文本处理操作。具体来说，我们将讨论如何在多个分隔符上拆分字符串，以及如何将文本匹配到特定的模式。</p><p id="c6f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><h1 id="73ec" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用“re.split()”拆分字符串</h1><p id="784b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设我们有一个包含几个编程语言名称的字符串:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d59a" class="mx lw it mt b gy my mz l na nb">my_string = 'python java sql c++ ruby'</span></pre><p id="7bdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用字符串方法“split()”来分隔该字符串中的名称，并将它们存储在一个列表中:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="078e" class="mx lw it mt b gy my mz l na nb">print(my_string.split())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/72c1e1d10699fc68016f6a12189b4789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*LXR2yutQpO0o98wI00IEoA.png"/></div></figure><p id="911f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然对于这个例子很有用，但是“split()”方法主要用于非常简单的情况。它不处理具有多个分隔符的字符串，也不考虑分隔符周围可能存在的空白。例如，假设我们的字符串有几个分隔符:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a9c1" class="mx lw it mt b gy my mz l na nb">my_string2 = 'python java, sql,c++;             ruby'</span></pre><p id="d2bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以是在抓取网站时接收文本数据的形式。让我们尝试对新字符串使用“split()”方法:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="cdc8" class="mx lw it mt b gy my mz l na nb">print(my_string2.split())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c9b42726dd839e6ef944ee3c62d49566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*uIqND3shoTMSy0TxEgRBUQ.png"/></div></figure><p id="3744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到字符串中的“sql”和“c++”部分没有被正确分割。要解决这个问题，我们可以使用“re.split()”方法在多个分隔符上拆分字符串。让我们导入正则表达式模块“re”，并将“re.split()”方法应用于我们的字符串:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="bc9b" class="mx lw it mt b gy my mz l na nb">import re<br/>print(re.split(r'[;,\s]\s*', my_string))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/72c1e1d10699fc68016f6a12189b4789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*LXR2yutQpO0o98wI00IEoA.png"/></div></figure><p id="144c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这非常有用，因为我们可以为分隔符指定多种模式。在我们的例子中，我们的字符串有逗号、分号和空格作为分隔符。每当发现一个模式时，整个匹配就成为位于匹配模式两侧的任何字段之间的分隔符。</p><p id="7763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看另一个使用不同分隔符' | '的例子:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="bfcf" class="mx lw it mt b gy my mz l na nb">my_string3 = 'python| java, sql|c++;             ruby'</span></pre><p id="2811" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将“re.split()”应用于新字符串:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="562b" class="mx lw it mt b gy my mz l na nb">print(re.split(r'[;|,\s]\s*', my_string3))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/72c1e1d10699fc68016f6a12189b4789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*LXR2yutQpO0o98wI00IEoA.png"/></div></figure><p id="ad03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到我们得到了想要的结果。现在，让我们讨论如何匹配文本开头和结尾的模式。</p><h1 id="dd9a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">匹配文本</h1><p id="4c79" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果我们需要以编程方式检查特定文本模式的字符串的开头或结尾，我们可以使用“str.startswith()”和“str.endswith()”方法。例如，如果我们有一个指定 url 的字符串:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="68c4" class="mx lw it mt b gy my mz l na nb">my_url = 'http://kaggle.com'</span></pre><p id="c706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用“str.startswith()”方法来检查我们的字符串是否以指定的模式开头:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="b94d" class="mx lw it mt b gy my mz l na nb">print(my_url.startswith('http:'))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f2601f4968e38361caad302780d825ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:136/format:webp/1*sQ78Zga26db2hTFegPRgCg.png"/></div></figure><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ff99" class="mx lw it mt b gy my mz l na nb">print(my_url.startswith('www.'))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/9cac34bb849806031894a6a6cce48591.png" data-original-src="https://miro.medium.com/v2/resize:fit:148/format:webp/1*GsrwHnS6Rbw6Tjc5Cz3prA.png"/></div></figure><p id="4454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以检查它是否以特定的模式结束:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="54fb" class="mx lw it mt b gy my mz l na nb">print(my_url.endswith('com'))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f2601f4968e38361caad302780d825ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:136/format:webp/1*sQ78Zga26db2hTFegPRgCg.png"/></div></figure><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4dbf" class="mx lw it mt b gy my mz l na nb">print(my_url.endswith('org'))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/9cac34bb849806031894a6a6cce48591.png" data-original-src="https://miro.medium.com/v2/resize:fit:148/format:webp/1*GsrwHnS6Rbw6Tjc5Cz3prA.png"/></div></figure><p id="7c8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更实际的例子是，如果我们需要以编程方式检查目录中的文件扩展名。假设我们有一个包含不同扩展名的文件的目录:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ffbf" class="mx lw it mt b gy my mz l na nb">my_directory = ['python_program.py', 'cpp_program.cpp', 'linear_regression.py', 'text.txt', 'data.csv']</span></pre><p id="b9e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用“str.endswith()”方法检查多个文件扩展名。我们只需要传递一组扩展值。让我们使用 list comprehension 和' str.endswith()'方法来过滤我们的列表，使它只包含'。cpp '和'。“py”文件:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7c54" class="mx lw it mt b gy my mz l na nb">my_scripts = [script for script in my_directory if script.endswith(('.py', '.cpp'))]<br/>print(my_scripts)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/6737f91d2310113d4c7b30452428a6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jiGHtxhNop4Y1SmtwRRhGw.png"/></div></div></figure><p id="0f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我就讲到这里，但是我鼓励你自己去研究代码。</p><h1 id="6ddd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="919c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">总之，在这篇文章中，我们讨论了如何使用“re.split()”方法沿着多个分隔符拆分字符串。我们还展示了如何使用“str.startswith()”和“str.endswith()”方法来检查特定文本模式的字符串的开头和结尾。我希望你觉得这篇文章有用/有趣。这篇文章的代码可以在 GitHub 上找到。感谢您的阅读！</p></div></div>    
</body>
</html>