<html>
<head>
<title>Ten Tricks To Speed Up Your Python Codes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高 Python 代码速度的十个技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ten-tricks-to-speed-up-your-python-codes-c38abdb89f18?source=collection_archive---------0-----------------------#2020-02-23">https://towardsdatascience.com/ten-tricks-to-speed-up-your-python-codes-c38abdb89f18?source=collection_archive---------0-----------------------#2020-02-23</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/c761f323c161b4dc880a81e81a90bfeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gkih1459OhvrtDVk_PiKrQ.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">君的轻音乐</p></figure><div class=""/><div class=""><h2 id="1b5a" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">每一步的微小进步，整体的巨大飞跃</h2></div><p id="98a0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">Python 很慢。</p><p id="2acf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">我打赌你可能会多次遇到这种关于使用 Python 的反驳，尤其是来自<code class="fe lu lv lw lx b">C</code>或<code class="fe lu lv lw lx b">C++</code>或<code class="fe lu lv lw lx b">Java</code>世界的人。在许多情况下都是这样，例如，循环或排序 Python 数组、列表或字典有时会很慢。毕竟，开发 Python 是为了让编程变得有趣和简单。因此，Python 代码在简洁性和可读性方面的改进必须以性能为代价。</p><p id="e918" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">话虽如此，近年来已经做了许多努力来提高 Python 的性能。我们现在可以通过使用<code class="fe lu lv lw lx b">numpy</code>、<code class="fe lu lv lw lx b">scipy</code>、<code class="fe lu lv lw lx b">pandas</code>和<code class="fe lu lv lw lx b"><a class="ae ly" href="http://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank">numba</a></code>以高效的方式处理大型数据集，因为所有这些库都在<code class="fe lu lv lw lx b">C/C++</code>中实现了它们的关键代码路径。还有另一个令人兴奋的项目，<a class="ae ly" href="https://www.pypy.org/" rel="noopener ugc nofollow" target="_blank"> Pypy 项目</a>，与<a class="ae ly" href="https://stackoverflow.com/questions/17130975/python-vs-cpython/17130986" rel="noopener ugc nofollow" target="_blank"> Cpython </a>(最初的 python 实现)相比，它将 Python 代码的速度提高了 4.4 倍。</p><blockquote class="lz ma mb"><p id="b97d" class="ky kz mc la b lb lc kk ld le lf kn lg md li lj lk me lm ln lo mf lq lr ls lt in bi translated">Pypy 的缺点是它对一些流行的科学模块(如 Matplotlib、Scipy)的覆盖有限或不存在，这意味着您不能在 Pypy 的代码中使用这些模块。</p></blockquote><p id="57ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">除了这些外部资源，<strong class="la jk">在日常编码实践中，我们还能做些什么来加速 Python 代码呢</strong>？今天和大家分享一下我在学习 Python 过程中经常用到的 10 招。</p><p id="300a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">像往常一样，如果你想自己重新运行这篇文章中的代码，可以从<a class="ae ly" href="https://github.com/Perishleaf/data-visualisation-scripts/tree/master/speed_up_python_code" rel="noopener ugc nofollow" target="_blank"> my Github </a>访问所有需要的数据和笔记本。</p></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><p id="e8a5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk"> 1。熟悉内置函数</strong></p><figure class="mo mp mq mr gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj mn"><img src="../Images/a08780e992d466ed330c0f0d3dfd7054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h1fNFlXgJ6tVrr-SNH3Jzw.png"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图 1 |<a class="ae ly" href="https://docs.python.org/3/library/functions.html" rel="noopener ugc nofollow" target="_blank">Python 3 中的内置函数</a></p></figure><p id="08b1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">Python 自带了许多在<code class="fe lu lv lw lx b">C</code>中实现的内置函数，这些函数非常快并且维护良好(图 1)。我们至少应该熟悉这些函数名，并且知道在哪里可以找到它们(一些常用的与计算相关的函数有<code class="fe lu lv lw lx b">abs()</code>、<code class="fe lu lv lw lx b">len()</code>、<code class="fe lu lv lw lx b">max()</code>、<code class="fe lu lv lw lx b">min()</code>、<code class="fe lu lv lw lx b">set()</code>、<code class="fe lu lv lw lx b">sum()</code>)。因此，每当我们需要进行一个简单的计算时，我们可以走正确的捷径，而不是笨拙地编写自己的版本。</p><p id="70ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">让我们以内置函数<code class="fe lu lv lw lx b">set()</code>和<code class="fe lu lv lw lx b">sum()</code>为例。如图 2 所示，使用<code class="fe lu lv lw lx b">set()</code>和<code class="fe lu lv lw lx b">sum()</code>分别比我们自己编写的函数快 36.1 倍和 20.9 倍。</p><figure class="mo mp mq mr gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj ms"><img src="../Images/3cc90830b215a2d6ac6acebf755bd578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6yOjjxv9t-WWKnP0SjvJg.png"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图 2 | set()和 sum()函数的示例</p></figure><p id="0654" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk"> 2。</strong><code class="fe lu lv lw lx b"><strong class="la jk">sort()</strong></code><strong class="la jk"><em class="mc">vs</em></strong><code class="fe lu lv lw lx b"><strong class="la jk">sorted()</strong></code></p><p id="a358" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">这两个函数都可以对列表进行排序。</p><p id="3d98" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">如果我们只想获得一个已排序的列表，而不关心原始列表，那么无论是对于基本排序还是在使用 <code class="fe lu lv lw lx b"><strong class="la jk">key</strong></code> <strong class="la jk">参数</strong>(<code class="fe lu lv lw lx b">key</code>参数指定了在进行比较之前要在每个列表元素上调用的函数)时，<code class="fe lu lv lw lx b"><strong class="la jk">sort()</strong></code> <strong class="la jk">都比</strong> <code class="fe lu lv lw lx b"><strong class="la jk">sorted()</strong></code> <strong class="la jk">要快一点，如图 3 所示。</strong></p><p id="c140" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">这是因为<code class="fe lu lv lw lx b">sort()</code>方法就地修改列表，而<code class="fe lu lv lw lx b">sorted()</code>构建一个新的排序列表并保持原始列表不变。换句话说，<code class="fe lu lv lw lx b">a_long_list</code>本身的值的顺序实际上已经改变了。</p><div class="mo mp mq mr gu ab cb"><figure class="mt iw mu mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><img src="../Images/32a9d765c1a3b4fdde15946ce15cf796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*r1thfpVtcalIxKYc_nlmLg.png"/></div></figure><figure class="mt iw mz mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><img src="../Images/4cd551c8510f28155722416f665c8fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*VKROtAo7M_iTgnpYV4aOBA.png"/></div><p class="jd je gk gi gj jf jg bd b be z dk na di nb nc translated">图 3| sort()和 sorted()</p></figure></div><p id="18ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">然而，<code class="fe lu lv lw lx b">sorted()</code>比<code class="fe lu lv lw lx b">sort()</code>更通用。这是因为<code class="fe lu lv lw lx b">sorted()</code>接受任何 iterable，而<code class="fe lu lv lw lx b">sort()</code>只为列表定义。因此，如果我们想对列表之外的东西进行排序，<code class="fe lu lv lw lx b">sorted()</code>是可以使用的正确函数。例如，我们可以根据字典的<code class="fe lu lv lw lx b">keys</code>或<code class="fe lu lv lw lx b">values</code>对其进行快速排序(图 4)。</p><figure class="mo mp mq mr gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nd"><img src="../Images/3428e93f4d055ea78d5d866842110989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mn27BBjg3h0VJgIwQ1yC8Q.png"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图 4 |已排序的()字典</p></figure><p id="535f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk"> 3。用符号代替它们的名字</strong></p><p id="284b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">如图 5 所示，当我们需要一个空的字典或列表对象时，不用使用<code class="fe lu lv lw lx b">dict()</code>或<code class="fe lu lv lw lx b">list()</code>，直接调用<code class="fe lu lv lw lx b">{}</code>(至于空集，需要使用<code class="fe lu lv lw lx b">set()</code>本身)和<code class="fe lu lv lw lx b">[]</code>。这个技巧不一定会加速代码，但是会让代码更复杂。</p><figure class="mo mp mq mr gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj ne"><img src="../Images/8de417ad6e2515ee66a697f5c168bef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68y7zOsZkWPg_WanT7YtSQ.png"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图 5 |直接使用 list()和 dict()符号</p></figure><p id="e992" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk"> 4。列表理解</strong></p><p id="1920" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">通常，当我们需要根据某些规则从一个旧列表创建一个新列表时，我们使用一个<code class="fe lu lv lw lx b">for</code>循环来遍历旧列表，并根据规则转换它的值，然后保存在一个新列表中。例如，假设我们想从<code class="fe lu lv lw lx b">another_long_list</code>中找到所有偶数，我们可以使用以下代码:</p><pre class="mo mp mq mr gu nf lx ng nh aw ni bi"><span id="2c32" class="nj nk jj lx b gz nl nm l nn no">even_num = []<br/>for number in another_long_list:<br/>    if number % 2 == 0:<br/>        even_num.append(number)</span></pre><p id="a301" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">但是，有一种更简洁、更优雅的方法可以实现这一点。如图 6 所示，<strong class="la jk">我们把原来的</strong> <code class="fe lu lv lw lx b"><strong class="la jk">for</strong></code> <strong class="la jk">循环放在仅仅一行代码</strong>中。而且，速度提高了差不多 2 倍。</p><figure class="mo mp mq mr gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj np"><img src="../Images/a33fbcd9b799ade10440f580bcbd8112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bl2QqA--jNMo7hau9_jcSA.png"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图 6 |列表理解</p></figure><p id="39c7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">结合<strong class="la jk">规则 3 </strong>，我们也可以将列表变成字典或集合，只需将<code class="fe lu lv lw lx b">[]</code>改为<code class="fe lu lv lw lx b">{}</code>。让我们重写图 5 中的代码，我们可以省略赋值的步骤，在符号内部完成迭代，就像这个<code class="fe lu lv lw lx b">sorted_dict3 = {key: value for key, value in sorted(a_dict.items(), key=lambda item: item[1])}</code>。</p><p id="eee2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">要分解这个，从最后开始。函数“<code class="fe lu lv lw lx b">sorted(a_dict.items(), key=lambda item: item[1])</code>”返回给我们一个元组列表(图 4)。这里，我们使用多重赋值来解包元组，对于列表中的每个元组，我们将<code class="fe lu lv lw lx b">key</code>赋给它的第一项，将<code class="fe lu lv lw lx b">value</code>赋给它的第二项(因为我们知道在这种情况下每个元组中有两项)。最后，每一对<code class="fe lu lv lw lx b">key</code>和<code class="fe lu lv lw lx b">value</code>都保存在一本字典中。</p><p id="f81f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk"> 5。使用</strong> <code class="fe lu lv lw lx b"><strong class="la jk">enumerate()</strong></code> <strong class="la jk">作为数值和索引</strong></p><p id="f579" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">有时，当我们遍历一个列表时，我们希望在表达式中同时使用它的值和索引。如图 7 所示，我们应该使用<code class="fe lu lv lw lx b">enumerate()</code>，它将列表的值转换成索引和值对。这也将我们的代码速度提高了大约 2 倍。</p><figure class="mo mp mq mr gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nq"><img src="../Images/9978c42c50abdc38d7efaedcff67cbea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P0NtVrVaLMzvRGj91SfeTQ.png"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图 7 | enumerate()示例</p></figure><p id="8a56" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk"> 6。使用</strong> <code class="fe lu lv lw lx b"><strong class="la jk">zip()</strong></code> <strong class="la jk">打包和解包多个迭代</strong></p><p id="0160" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">在某些情况下，我们需要遍历两个或更多的列表。然后我们可以使用<code class="fe lu lv lw lx b">zip()</code>函数，它将多个列表转换成一个元组列表(图 8)。注意，列表最好长度相同，否则，<code class="fe lu lv lw lx b">zip()</code>会在较短的列表结束后立即停止。</p><figure class="mo mp mq mr gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nr"><img src="../Images/2b4ea934eeb072867e9d7c3ddd213a0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rxaMJYmf-A3FUpXLt74z5g.png"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图 8 | zip()示例</p></figure><p id="bcce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">相反，要访问列表中每个元组的条目，我们也可以通过添加星号(*)和使用多重赋值来解压缩元组列表，就像这样，<code class="fe lu lv lw lx b">letters1, numbers1 = zip(*pairs_list)</code>。</p><p id="ddc1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk"> 7。组合</strong> <code class="fe lu lv lw lx b"><strong class="la jk">set()</strong></code> <strong class="la jk">和</strong> <code class="fe lu lv lw lx b"><strong class="la jk">in</strong></code></p><p id="73fc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">当我们想检查一个值是否存在于一个列表中时，一个笨拙的方法是构造这样一个函数:</p><pre class="mo mp mq mr gu nf lx ng nh aw ni bi"><span id="3644" class="nj nk jj lx b gz nl nm l nn no"><strong class="lx jk"># Construct a function for membership test</strong><br/>def check_membership(n):<br/>    for element in another_long_list:<br/>        if element == n:<br/>            return True<br/>    return False</span></pre><p id="de46" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">然后调用<code class="fe lu lv lw lx b">check_membership(value)</code>看<code class="fe lu lv lw lx b">another_long_list</code>里面的<code class="fe lu lv lw lx b">value</code>是否。然而，一种 pythonic 式的方法是通过调用<code class="fe lu lv lw lx b">value in another_long_list</code>来使用<code class="fe lu lv lw lx b">in</code>，如图 9 所示。这就像你直接问 python“嘿 Python，你能告诉我<code class="fe lu lv lw lx b">value</code>是否在<code class="fe lu lv lw lx b">another_long_list</code>里面吗”。</p><figure class="mo mp mq mr gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nd"><img src="../Images/44643e3793e866ac0e5edf52c882ac1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJN3RhyyAoZjCzdKDsYp8Q.png"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图 9 |使用 in 和 set()检查成员资格</p></figure><p id="273a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">为了更有效，我们应该首先使用<code class="fe lu lv lw lx b">set()</code>从列表中删除重复项，然后测试 set 对象中的成员资格。通过这样做，我们减少了需要检查的元素的数量。此外，<code class="fe lu lv lw lx b">in</code>是一个非常快速的集合操作。</p><p id="8cd9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">从图 9 中可以看出，尽管构建 set 对象花费了 20 毫秒，但这只是一次性投资，检查步骤本身仅用了 5.2 秒，这是 1962 倍的改进。</p><p id="2663" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">8。检查变量是否为真</p><p id="3a22" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">不可避免地，我们会使用大量的<code class="fe lu lv lw lx b">if</code>语句来检查空变量、空列表、空字典等等。我们也可以从这里节省一点时间。</p><p id="c585" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">如图 10 所示，我们不需要在<code class="fe lu lv lw lx b">if</code>语句中显式地声明<code class="fe lu lv lw lx b">== True</code>或<code class="fe lu lv lw lx b">is True</code>，取而代之的是我们只使用变量名。这节省了魔法函数<code class="fe lu lv lw lx b"><a class="ae ly" href="https://stackoverflow.com/questions/3588776/how-is-eq-handled-in-python-and-in-what-order" rel="noopener ugc nofollow" target="_blank">__eq__</a></code>用于比较两边值的资源。</p><figure class="mo mp mq mr gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj ns"><img src="../Images/24bf72d2364ff8ef4f3cf159408c0f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IKtzpLP4K9ypEJgoLCQ6rA.png"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图 10 |只需检查变量</p></figure><p id="ca5b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">同样，如果我们需要检查变量是否为空，我们只需要说<code class="fe lu lv lw lx b">if not string_returned_from_function:</code>。</p><p id="e95d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk"> 9。使用</strong>计数唯一值<code class="fe lu lv lw lx b"><strong class="la jk">Counters()</strong></code></p><p id="145d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">假设我们试图计算在<strong class="la jk">规则 1 </strong>、<code class="fe lu lv lw lx b">a_long_list</code>中生成的列表中的唯一值。一种方法是创建一个字典，其中的键是数字，值是计数。当我们迭代列表时，如果它已经在字典中，我们可以增加它的计数，如果它不在字典中，我们可以将它添加到字典中。</p><pre class="mo mp mq mr gu nf lx ng nh aw ni bi"><span id="6837" class="nj nk jj lx b gz nl nm l nn no">num_counts = {}<br/>for num in a_long_list:<br/>    if num in num_counts:<br/>        num_counts[num] += 1<br/>    else:<br/>        num_counts[num] = 1</span></pre><p id="9f23" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">然而，更有效的方法是在一行代码<code class="fe lu lv lw lx b">num_counts2 = Counter(a_long_list)</code>中使用<a class="ae ly" href="https://docs.python.org/3.8/library/collections.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">集合</strong> </a>中的<code class="fe lu lv lw lx b">Counter()</code>。是的，就是这么简单。如图 11 所示，它比我们编写的函数大约快 10 倍。</p><p id="a4a2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">如果我们想知道 10 个最常见的数字，<code class="fe lu lv lw lx b">Counter()</code>实例还有一个非常方便的<code class="fe lu lv lw lx b">most_common</code>方法。</p><figure class="mo mp mq mr gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nt"><img src="../Images/7b185de85ddcd2502e1bcf0604fcac7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQ-2D626K0D1CHmBX5L9DA.png"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图 11 |计数器()示例</p></figure><p id="0f3b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">总之，<strong class="la jk">收藏</strong>是一个很神奇的模块，我们应该把它保存到我们的日常工具箱中，随时使用。</p><p id="f5d0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">10。将 <code class="fe lu lv lw lx b"><strong class="la jk">for</strong></code> <strong class="la jk">循环放入</strong>函数中</p><p id="ef0e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">可能有一段时间，我们构建了一个函数，并且需要重复这个函数给定的次数。一个显而易见的方法是我们构建一个函数，然后将这个函数放入一个<code class="fe lu lv lw lx b">for</code>循环中。</p><p id="7568" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">但是，如图 12 所示，我们没有重复执行函数 100 万次(a_long_list 的长度为 1，000，000)，而是在函数内部集成了<code class="fe lu lv lw lx b">for</code>循环。这为我们节省了大约 22%的运行时间。这是因为函数调用是昂贵的，通过将函数写入列表理解来避免它是更好的选择。</p><figure class="mo mp mq mr gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nu"><img src="../Images/9520072752742b8bdbaba62e6237debf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NSlWjYS-4qTmsQTSi_bLg.png"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图 12 |函数内部的 put for 循环</p></figure></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><p id="1d03" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">仅此而已！感谢你阅读这篇文章。希望有些小技巧能对你有用。此外，您还使用了哪些其他方法来加速 Python 代码？如果你能留下评论来分享它们，我将不胜感激。</p></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><p id="0393" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">以下是您可能感兴趣的链接:</p><ul class=""><li id="6c79" class="nv nw jj la b lb lc le lf lh nx ll ny lp nz lt oa ob oc od bi translated"><a class="ae ly" href="https://docs.python.org/3/howto/sorting.html" rel="noopener ugc nofollow" target="_blank">如何使用</a> <code class="fe lu lv lw lx b"><a class="ae ly" href="https://docs.python.org/3/howto/sorting.html" rel="noopener ugc nofollow" target="_blank">sort()</a></code> <a class="ae ly" href="https://docs.python.org/3/howto/sorting.html" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe lu lv lw lx b"><a class="ae ly" href="https://docs.python.org/3/howto/sorting.html" rel="noopener ugc nofollow" target="_blank">sorted()</a></code>对列表进行排序</li><li id="2cfc" class="nv nw jj la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated"><a class="ae ly" href="https://realpython.com/list-comprehension-python/" rel="noopener ugc nofollow" target="_blank">在 Python 中何时使用列表理解</a></li><li id="369f" class="nv nw jj la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated"><a class="ae ly" href="https://www.youtube.com/watch?v=OSGv2VnC0go" rel="noopener ugc nofollow" target="_blank">将代码转换成漂亮、地道的 Python 语言</a></li><li id="8115" class="nv nw jj la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated"><a class="ae ly" href="https://medium.com/@mindfiresolutions.usa/advantages-and-disadvantages-of-python-programming-language-fd0b394f2121" rel="noopener">Python 编程语言的优缺点</a></li></ul></div><div class="ab cl mg mh hy mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="in io ip iq ir"><p id="f70d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">和往常一样，我欢迎反馈、建设性的批评以及听到关于您的数据科学项目的信息。可以通过<a class="ae ly" href="https://www.linkedin.com/in/jun-ye-29aaa769/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>和<a class="ae ly" href="https://junye0798.com/" rel="noopener ugc nofollow" target="_blank">我的网站</a>找到我。</p></div></div>    
</body>
</html>