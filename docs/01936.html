<html>
<head>
<title>NLP in Python: Extract Intentions from Conversations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的NLP:从对话中提取意图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/phrase-extraction-in-python-using-lists-tuples-and-lambda-functions-fa0d2eed6dbb?source=collection_archive---------24-----------------------#2020-02-23">https://towardsdatascience.com/phrase-extraction-in-python-using-lists-tuples-and-lambda-functions-fa0d2eed6dbb?source=collection_archive---------24-----------------------#2020-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d76c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">自然语言处理</h2><div class=""/><p id="41fa" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我遇到的python最重要和最有用的特性之一是它的Lambda函数。就Lambda函数的使用而言，所有的在线课程都只是皮毛。然而，真实世界的用例需要对其特性的高级理解和实现。</p><p id="3a5e" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在本文中，我们将看到lambda函数如何应用于包含复杂数据类型的列。我们将从基本操作开始，转到使用lambda函数的更高级的方法。我将给出一些例子，在这些例子中，我使用了lambda函数来处理一个数据帧，该数据帧由使用列表和元组的文本数据组成。</p><p id="2eb1" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我将对从Kaggle的一个竞赛中获得的文本数据进行<em class="kx">词性</em>标记，以演示实现。</p><p id="428d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">让我们开始吧。</p><h1 id="7705" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">基本面</strong></h1><p id="5ca0" class="pw-post-body-paragraph jz ka it kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw im bi translated">重要的事情先来。我快速复习了python中的列表、元组和lambda函数。</p><h2 id="9655" class="mb kz it bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu iz bi translated"><em class="mm">Python中的列表</em></h2><p id="3f5f" class="pw-post-body-paragraph jz ka it kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw im bi translated">List是python中的一个集合。它允许你有重复的条目，它是有序的和可变的。python中一个简单的列表例子。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="e4c2" class="mb kz it ms b gy mw mx l my mz">mylist = [‘R’,’Python’,’Scala’,’Java’,’Go’,’SQL’]</span><span id="0670" class="mb kz it ms b gy na mx l my mz">mylist[0:2]<br/>#OR<br/>mylist[:2]<br/><strong class="ms jd"><em class="kx">Out[1]:['R', 'Python']</em></strong></span><span id="6f3a" class="mb kz it ms b gy na mx l my mz"># Negative Indexing<br/>mylist[-1]<br/><strong class="ms jd"><em class="kx">Out[2]:'SQL'</em></strong></span></pre><p id="f0d5" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">列表还有其他一些操作，但是这超出了本文的范围。您可以删除、添加或更改项目。您可以创建一个重复的列表或合并两个列表。如果你想学习更多关于这些函数的知识，有很好的在线教程。</p><h2 id="5a5e" class="mb kz it bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu iz bi translated"><em class="mm">Python中的元组</em></h2><p id="dc50" class="pw-post-body-paragraph jz ka it kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw im bi translated">元组是一系列不可变的Python对象。元组和列表的主要区别在于元组是不可变的，并且使用圆括号而不是方括号。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="1a78" class="mb kz it ms b gy mw mx l my mz">mytuple = ('R','Python','Scala','Java','Go','SQL')</span><span id="da62" class="mb kz it ms b gy na mx l my mz">mytuple[0:2]<br/>#OR<br/>mytuple[:2]</span><span id="178a" class="mb kz it ms b gy na mx l my mz"><strong class="ms jd"><em class="kx">Out[3]:['R', 'Python']</em></strong></span><span id="10a1" class="mb kz it ms b gy na mx l my mz">mytuple[0] = 'Julia'<br/><br/><strong class="ms jd">TypeError: 'tuple' object does not support item assignment</strong></span></pre><h2 id="a204" class="mb kz it bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu iz bi translated">Python中的Lambda</h2><p id="33c3" class="pw-post-body-paragraph jz ka it kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw im bi translated">lambda函数是一个小型匿名函数，它可以接受任意数量的参数，但只能有一个表达式。</p><p id="6dfc" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">语法:<strong class="kb jd"><em class="kx">λ参数:表达式</em> </strong></p><p id="061a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">下面是一个使用lambda函数将两个数相加的简单例子。如您所见，它极大地简化了为每个操作创建独立函数的操作。当处理大型数据集，并且您希望对数据集的整列应用函数时，它变得非常有用。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="481e" class="mb kz it ms b gy mw mx l my mz">## Function to add 2 numbers <strong class="ms jd">without LAMBDA</strong> ## <br/>def addition(a,b):<br/>   return a+b</span><span id="9cc8" class="mb kz it ms b gy na mx l my mz">addition(3,5)</span></pre><p id="8bcd" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"><em class="kx">Out【6】:8</em></strong></p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0923" class="mb kz it ms b gy mw mx l my mz">## Function to add 2 numbers <strong class="ms jd">with</strong> <strong class="ms jd">LAMBDA </strong>##<br/> addition = lambda a,b:a+b</span><span id="0de2" class="mb kz it ms b gy na mx l my mz">addition(3,5)</span></pre><p id="a5b6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"><em class="kx">Out【7】:8</em></strong></p><h1 id="a834" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">深潜</h1><p id="2978" class="pw-post-body-paragraph jz ka it kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw im bi translated">现在我们已经对列表、元组和lambda函数有了基本的了解。让我们来做一个更真实的练习。</p><p id="4b12" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我已经从<a class="ae nb" href="https://www.kaggle.com/c/essay-scoring/data" rel="noopener ugc nofollow" target="_blank">这个</a>链接中提取了文本数据来做这个练习。最初的竞赛要求参与者对文本数据中的简短答案(EssayText)进行评分。下面是数据集的前5行。它由<strong class="kb jd"> 17207 </strong>行数据组成。</p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f9c00b376ddae8c4cf1d4fae9df48280.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*WPaNfKegr8Qj2FiwStSDjg.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">短文文本数据(<a class="ae nb" href="https://www.kaggle.com/c/essay-scoring/data" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>)</p></figure><p id="a632" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在我们的案例中，我们不打算为论文评分建立一个机器学习模型。我们将在<em class="kx">‘essay text’</em>列上构建一个词性(POS)提取器函数。我们将在这些列上运行一系列操作，目标如下-</p><ul class=""><li id="65f3" class="nk nl it kb b kc kd kg kh kk nm ko nn ks no kw np nq nr ns bi translated">了解数据框上的列表和元组操作</li><li id="ac11" class="nk nl it kb b kc nt kg nu kk nv ko nw ks nx kw np nq nr ns bi translated">用于数据帧的文本列的标记化和词性标注</li><li id="d447" class="nk nl it kb b kc nt kg nu kk nv ko nw ks nx kw np nq nr ns bi translated">使用lambda函数进行涉及列表和元组的复杂运算</li><li id="7b4c" class="nk nl it kb b kc nt kg nu kk nv ko nw ks nx kw np nq nr ns bi translated">python中带有FOR循环和条件IF的嵌套lambda函数</li></ul><ol class=""><li id="41e1" class="nk nl it kb b kc kd kg kh kk nm ko nn ks no kw ny nq nr ns bi translated"><strong class="kb jd">分词</strong> —第一步也是最重要的一步是<strong class="kb jd">将文本数据分词</strong>成单个单词。幸运的是，我们这里的数据已经是一个干净的文本，不像真实世界的NLP用例。这为我们节省了一些时间。我应用了两种类型的记号化-</li></ol><blockquote class="nz"><p id="c954" class="oa ob it bd oc od oe of og oh oi kw dk translated">句子标记化—它分隔文本中的各个句子。我使用了' \n '作为分隔符。</p><p id="e1c8" class="oa ob it bd oc od oj ok ol om on kw dk translated">单词标记化——它将句子分成单个单词。</p></blockquote><p id="5c82" class="pw-post-body-paragraph jz ka it kb b kc oo ke kf kg op ki kj kk oq km kn ko or kq kr ks os ku kv kw im bi translated">下面是使用<strong class="kb jd"> Lambda </strong>函数进行标记化的代码:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="6bb7" class="mb kz it ms b gy mw mx l my mz"><em class="kx">## Tokenize Sentences based on \n character ##</em><br/><em class="kx">textdata[“tokenized_sents”] = textdata[“EssayText”].apply(lambda row: row.splitlines())<br/> <br/>## Tokenize Words ##<br/>textdata[“tokenized_words”] = textdata[“tokenized_sents”].apply(lambda row: [nltk.word_tokenize(i) for i in row])</em></span><span id="9959" class="mb kz it ms b gy na mx l my mz"><em class="kx">## Remove empty elements in list of list ##<br/>textdata[“tokenized_words”] = textdata[“tokenized_words”].apply(lambda row: [x for x in row if x])</em></span><span id="852b" class="mb kz it ms b gy na mx l my mz"><em class="kx">textdata.head()</em></span></pre><p id="ab26" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">以上3个操作很好地利用了lambda函数，将函数应用于整个列。句子标记化根据' \n '字符分隔文本。</p><p id="5ee0" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">为了对单词进行标记，我们使用NLTK库中的<em class="kx"> word_tokenize </em>函数。每行有多个句子，因此，FOR循环用于迭代一行中的每个句子。</p><p id="6dab" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">第三个操作从列表中删除空元素，该列表是作为句子和单词标记化的一部分生成的。</p><p id="c253" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这是我们的数据框在标记化后的样子。我有意删除了未使用的列，如<em class="kx"> Score </em>和<em class="kx"> Essayset </em></p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/728d35d4a15434d0d2ab74523bc3046b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*RwjqVPdJpiV6BhbHbz6cJw.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">句子和单词标记化后的数据框架—作者提供的图像</p></figure><p id="fbdc" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">基于' \n '进行标记很容易，因为我们有一个现成的python函数<em class="kx"> splitlines()。</em>然而，在现实世界的场景中，你可能想要分割其他一些没有功能的角色。例如一个点或一个逗号。lambda函数仍然使它变得简单。这是我如何用点符号做的-</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="3296" class="mb kz it ms b gy mw mx l my mz"><em class="kx">## Tokenize Sentences based on ‘.’ character ##<br/>textdata[“tokenized_sents”] = textdata[“tokenized_sents”].apply(lambda row: [i.split(“.”) for i in row])</em></span></pre><p id="a0b8" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这里我们使用嵌套迭代，其中对于essaytext列中已经在' \n '字符上标记化的每个值，将在'.'上进一步标记化性格。</p><p id="c3d6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">**练习—你能通过使用lambda函数而不是FOR语句来尝试上面的方法吗？</p><p id="f40d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">滚动前先试一试。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="33ea" class="mb kz it ms b gy mw mx l my mz"><em class="kx">## Tokenize Sentences based on ‘.’ character ##<br/>textdata[“tokenized_sents”] = textdata[“tokenized_sents”].apply(lambda row: list(map(lambda m: m.split('.'), row)))</em></span></pre><p id="3586" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">嵌套的Lambda函数。让我们把这个留到博客的后半部分。</p><p id="6115" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> 2。词性标注</strong> —为了进行词性标注，我们将使用NLTK库提供的词性标注器。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="e84f" class="mb kz it ms b gy mw mx l my mz"><em class="kx">## Part-of-Speech Tagging for each word in the corpus ##<br/>textdata[“POS_tags”] = textdata[“tokenized_words”].apply(lambda row: [nltk.pos_tag(i) for i in row])</em></span></pre><p id="d8f1" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="kx">代码解释</em>——它将<em class="kx"> pos_tag </em>函数应用于每个单词，以确定其对应的词性。POS标签作为元组列表的<strong class="kb jd"> <em class="kx">列表存储在我们感兴趣的列中。对于这个特定的数据，元组列表就足够了，因为每个短文文本都是一个句子。然而，在你为每个文本选择多个句子的情况下，它将需要被存储为元组列表的列表。</em></strong></p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/8375410ef3b5e55534f944d688ab00f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*zzYYYOFHxSnOSOlpcZo1UQ.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">为文章文本中的每个单词生成的词性标签—按作者分类的图片</p></figure><p id="cc1b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">让我们仔细看看为第一篇短文文本生成的位置标签</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="fd3e" class="mb kz it ms b gy mw mx l my mz">[[('Some', 'DT'),<br/>  ('additional', 'JJ'),<br/>  ('information', 'NN'),<br/>  ('that', 'IN'),<br/>  ('we', 'PRP'),<br/>  ('would', 'MD'),<br/>  ('need', 'VB'),<br/>  ('to', 'TO'),<br/>  ('replicate', 'VB'),<br/>  ('the', 'DT'),<br/>  ('experiment', 'NN'),<br/>  ('is', 'VBZ'),<br/>  ('how', 'WRB'),<br/>  ('much', 'JJ'),<br/>  ('vinegar', 'NN'),<br/>  ('should', 'MD'),<br/>  ('be', 'VB'),<br/>  ('placed', 'VBN'),<br/>  ('in', 'IN'),<br/>  ('each', 'DT'),<br/>  ('identical', 'JJ'),<br/>  ('container', 'NN'),<br/>  (',', ','),<br/>  ('how', 'WRB'),<br/>  ('or', 'CC'),<br/>  ('what', 'WP'),<br/>  ('tool', 'NN'),<br/>  ('to', 'TO'),<br/>  ('use', 'VB'),<br/>  ('to', 'TO'),<br/>  ('measure', 'VB'),<br/>  ('the', 'DT'),<br/>  ('mass', 'NN'),<br/>  ('of', 'IN'),<br/>  ('the', 'DT'),<br/>  ('four', 'CD'),<br/>  ('different', 'JJ'),<br/>  ('samples', 'NNS'),<br/>  ('and', 'CC'),<br/>  ('how', 'WRB'),<br/>  ('much', 'JJ'),<br/>  ('distilled', 'JJ'),<br/>  ('water', 'NN'),<br/>  ('to', 'TO'),<br/>  ('use', 'VB'),<br/>  ('to', 'TO'),<br/>  ('rinse', 'VB'),<br/>  ('the', 'DT'),<br/>  ('four', 'CD'),<br/>  ('samples', 'NNS'),<br/>  ('after', 'IN'),<br/>  ('taking', 'VBG'),<br/>  ('them', 'PRP'),<br/>  ('out', 'IN'),<br/>  ('of', 'IN'),<br/>  ('the', 'DT'),<br/>  ('vinegar', 'NN'),<br/>  ('.', '.')]]</span></pre><p id="91ed" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">该库在识别每个单词的词性方面做得很好。接下来，我们将对这个元组列表执行一些复杂的操作，以利用列表和元组上的lambda函数。</p><p id="b2b1" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> 3。过滤</strong> —假设我们只对词类中包含名词、形容词和限定词的单词感兴趣。我们可以这样做-</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="bca1" class="mb kz it ms b gy mw mx l my mz">## PoS of interest ##<br/>pos_tags = [‘DT’,’NN’,’NNS’,’NNP’,’NNPS’,’JJ’,’JJR’,’JJS’]</span><span id="f660" class="mb kz it ms b gy na mx l my mz">## Filter words for which the POS belongs to the ‘pos_tags’ list<br/>textdata[“POS_tags”] = textdata[“POS_tags”].apply(lambda row: list(map(lambda m: [(x,y) for (x,y) in m if y in pos_tags], row)))</span></pre><p id="2275" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="kx">代码解释</em>-<em class="kx">pos _ tags</em>列表包含我们想要过滤的所有POS代码。lambda函数迭代每一行，内部lambda函数迭代每一行的多个句子，对于一个句子的每个元组列表(word，POSTag ), FOR循环迭代检查元组中的第二个元素是否出现在<em class="kx"> pos_tags </em>列表中。唷！</p><p id="0d63" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">再读一遍，推荐。</p><p id="f75b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">详细的<em class="kx">位置标签</em>列表-</p><ul class=""><li id="e298" class="nk nl it kb b kc kd kg kh kk nm ko nn ks no kw np nq nr ns bi translated">JJ形容词“小”</li><li id="07be" class="nk nl it kb b kc nt kg nu kk nv ko nw ks nx kw np nq nr ns bi translated">JJR形容词，比较级“较小”</li><li id="967d" class="nk nl it kb b kc nt kg nu kk nv ko nw ks nx kw np nq nr ns bi translated">JJS形容词，最高级“最小的”</li><li id="c405" class="nk nl it kb b kc nt kg nu kk nv ko nw ks nx kw np nq nr ns bi translated">名词，单数“椅子”</li><li id="076d" class="nk nl it kb b kc nt kg nu kk nv ko nw ks nx kw np nq nr ns bi translated">NNS名词复数“椅子”</li><li id="2751" class="nk nl it kb b kc nt kg nu kk nv ko nw ks nx kw np nq nr ns bi translated">NNP专有名词，单数‘Boris’</li><li id="22a0" class="nk nl it kb b kc nt kg nu kk nv ko nw ks nx kw np nq nr ns bi translated">NNPS专有名词，复数“英国人”</li><li id="5f54" class="nk nl it kb b kc nt kg nu kk nv ko nw ks nx kw np nq nr ns bi translated">DT限定词</li></ul><p id="1da2" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在让我们检查一下第一篇文章的位置标签</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="2796" class="mb kz it ms b gy mw mx l my mz">[[('Some', 'DT'),<br/>  ('additional', 'JJ'),<br/>  ('information', 'NN'),<br/>  ('the', 'DT'),<br/>  ('experiment', 'NN'),<br/>  ('much', 'JJ'),<br/>  ('vinegar', 'NN'),<br/>  ('each', 'DT'),<br/>  ('identical', 'JJ'),<br/>  ('container', 'NN'),<br/>  ('tool', 'NN'),<br/>  ('the', 'DT'),<br/>  ('mass', 'NN'),<br/>  ('the', 'DT'),<br/>  ('different', 'JJ'),<br/>  ('samples', 'NNS'),<br/>  ('much', 'JJ'),<br/>  ('distilled', 'JJ'),<br/>  ('water', 'NN'),<br/>  ('the', 'DT'),<br/>  ('samples', 'NNS'),<br/>  ('the', 'DT'),<br/>  ('vinegar', 'NN')]]</span></pre><p id="89a6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">它的工作，只有一行代码！难以置信！</p><p id="5c31" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> 4。整理</strong> —我想尝试的最后一个操作是根据单词的词性标签将它们组合在一起。也就是说，所有不同形式的名词将表示为“NN ”,所有不同形式的形容词将表示为“JJ ”,如下所示</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="1761" class="mb kz it ms b gy mw mx l my mz">[’NN’,’NNS’,’NNP’,’NNPS’] --&gt; 'NN'<br/>[’JJ’,’JJR’,’JJS’] --&gt; 'JJ'</span></pre><p id="9508" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">下面是我如何使用<strong class="kb jd">嵌套Lamda函数</strong>实现它的</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="642d" class="mb kz it ms b gy mw mx l my mz">## Types of NN and JJ tags ##<br/>noun_tags = [‘NN’,’NNS’,’NNP’,’NNPS’]<br/>adjective_tags = [‘JJ’,’JJR’,’JJS’]</span><span id="07d3" class="mb kz it ms b gy na mx l my mz">textdata[“POS_tags”] = textdata[“POS_tags”].apply(lambda row: list(map(lambda m: [(k,’NN’) if (v in noun_tags) else (k,v) for (k,v) in m], row)))</span><span id="1331" class="mb kz it ms b gy na mx l my mz">textdata[“POS_tags”] = textdata[“POS_tags”].apply(lambda row: list(map(lambda m: [(k,’JJ’) if (v in adjective_tags) else (k,v) for (k,v) in m], row)))</span></pre><p id="f2ae" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="kx">代码解释- </em>所以，迭代数据帧中的每一行(使用外部lambda)，然后迭代每一个句子(使用内部lambda)，然后迭代每一个句子中的元组(使用FOR loop)，如果元组的第二个元素出现在noun _tags/形容词_ tags列表中，那么将第二个元素改为' NN'/'JJ '。图解-</p><figure class="mn mo mp mq gt nd gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/411f217bbee4ba1f407b6922245da5f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*Pwjt8ShKpjgP7UkKh-bjwQ.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">校对的示意图(W = word)-按作者排序的图像</p></figure><p id="c63a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">让我们检查一下第一篇文章的结果。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="48a9" class="mb kz it ms b gy mw mx l my mz">[[('Some', 'DT'),<br/>  ('additional', 'JJ'),<br/>  ('information', 'NN'),<br/>  ('the', 'DT'),<br/>  ('experiment', 'NN'),<br/>  ('much', 'JJ'),<br/>  ('vinegar', 'NN'),<br/>  ('each', 'DT'),<br/>  ('identical', 'JJ'),<br/>  ('container', 'NN'),<br/>  ('tool', 'NN'),<br/>  ('the', 'DT'),<br/>  ('mass', 'NN'),<br/>  ('the', 'DT'),<br/>  ('different', 'JJ'),<br/>  ('samples', 'NN'),<br/>  ('much', 'JJ'),<br/>  ('distilled', 'JJ'),<br/>  ('water', 'NN'),<br/>  ('the', 'DT'),<br/>  ('samples', 'NN'),<br/>  ('the', 'DT'),<br/>  ('vinegar', 'NN')]]</span></pre><p id="287f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">结果在意料之中。令人惊讶的是，如果我们试图将以DT开头、以NN结尾的单词作为词性标签进行分组，我们会得到一个有意义的短语。就像第一篇文章，我们可以提取-</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="4270" class="mb kz it ms b gy mw mx l my mz"><em class="kx">‘Some additional information’</em></span><span id="dd26" class="mb kz it ms b gy na mx l my mz"><em class="kx">‘each identical container’ </em></span><span id="c7cf" class="mb kz it ms b gy na mx l my mz"><em class="kx">‘the vinegar’</em></span></pre><p id="3bfe" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我就纳闷了，这能用在哪里！</p></div></div>    
</body>
</html>