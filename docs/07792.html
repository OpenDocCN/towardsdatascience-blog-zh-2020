<html>
<head>
<title>Data Preprocessing with Scikit-Learn: Standardization and Scaling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Scikit-Learn 进行数据预处理:标准化和缩放</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-preprocessing-with-scikit-learn-standardization-and-scaling-cfb695280412?source=collection_archive---------15-----------------------#2020-06-10">https://towardsdatascience.com/data-preprocessing-with-scikit-learn-standardization-and-scaling-cfb695280412?source=collection_archive---------15-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4b09" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何预处理不同取值范围的数值特征</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aa4518c907dc2d68d1c81b88542d6775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_Q5mEC4UfJCFtFjcpMH1g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@charlesdeluvio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Charles Deluvio </a>在<a class="ae ky" href="https://unsplash.com/s/photos/different-size?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="36fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scikit-learn 是一个广泛使用的 Python 机器学习库。由于算法的多样性及其易于理解的语法，它在数据科学从业者中获得了极大的欢迎。除了现成的算法，scikit-learn 还提供了有用的数据预处理功能和方法。</p><p id="1bd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据预处理是机器学习或深度学习中极其重要的一步。我们不能只是将原始数据转储到一个模型中，然后期望它表现良好。即使我们构建了一个复杂的、结构良好的模型，它的性能也会和我们提供给它的数据一样好。因此，我们需要处理原始数据来提高模型的性能。</p><p id="8c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将介绍处理数值范围差异很大的数字特征(列)的方法。我们将应用标准化和缩放。让我们从这些转变背后的动机开始，然后用例子探讨它们之间的区别。</p><h1 id="e578" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">动机</strong></h1><p id="3347" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们适合机器学习模型的数据集通常有许多特征。不同要素的值很可能处于不同的范围内。例如，考虑一个试图预测房价的模型。房子的面积在 200 平方米左右，而房龄通常不到 20 年。大多数情况下，卧室的数量可以是 1、2 或 3 间。所有这些特征在决定房子的价格时都很重要。然而，如果我们在没有任何缩放的情况下使用它们，机器学习模型可能会对具有较高值的特征给予更多的重视。当要素的比例相对相似时，模型往往表现更好，收敛更快。</p><h1 id="b007" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">标准化和标准定标器</strong></h1><p id="4ba4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个问题的一个解决方案是<strong class="lb iu">标准化</strong>。将列视为变量。如果一个列是标准化的，则从每个值中减去该列的平均值，然后用该列的标准偏差除这些值。结果列的标准偏差为 1，平均值非常接近于零。因此，我们最终得到的变量(列)几乎呈正态分布。标准化可以通过<code class="fe ms mt mu mv b">StandardScaler.</code>实现</p><p id="d06d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预处理过程中使用的函数和转换器在<code class="fe ms mt mu mv b">sklearn.preprocessing</code>包中。让我们将这个包与 numpy 和熊猫一起导入。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0318" class="na lw it mv b gy nb nc l nd ne">import numpy as np<br/>import pandas as pd</span><span id="2638" class="na lw it mv b gy nf nc l nd ne">from sklearn import preprocessing</span></pre><p id="6978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建一个表示特征的样本矩阵。然后使用 StandardScaler 对象对其进行变换。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="f8f4" class="na lw it mv b gy nb nc l nd ne">a = np.random.randint(10, size=(10,1))<br/>b = np.random.randint(50, 100, size=(10,1))<br/>c = np.random.randint(500, 700, size=(10,1))</span><span id="05bb" class="na lw it mv b gy nf nc l nd ne">X = np.concatenate((a,b,c), axis=1)<br/>X</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/771426aa05962df2aa5304b193a82409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*XcLmmupniecxUATYWxNzYg.png"/></div></figure><p id="662b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">x 表示具有 3 列 10 行的数据帧中的值。列表示特征。每列的平均值和标准偏差:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/5c96e7d3d3c0f75028c44a1edf68c6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*1pFBGmGQR9rvQGeUyCAqkw.png"/></div></figure><p id="a353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些列在平均值和标准偏差方面有很大不同。</p><p id="69db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以创建一个 StandardScaler 对象并使 X 适合它。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="9200" class="na lw it mv b gy nb nc l nd ne">sc = preprocessing.StandardScaler().fit(X)</span></pre><p id="5842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以通过对 StandardScaler 对象应用 transform 方法来转换 x。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="18fa" class="na lw it mv b gy nb nc l nd ne">X_standardized = sc.transform(X)<br/>X_standardized</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/00f797ed7c3a5bb61a4917f40c19c8f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*e05ZmQPDu9HrSgY05a3CGw.png"/></div></figure><p id="032b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来计算变换后要素的平均值和标准差。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/1184c5a91eb5e7be6782165289393e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*oLfGbO8lBGtDt0GwSs8TCQ.png"/></div></figure><p id="214f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个特征的平均值非常接近于 0，并且所有特征都具有单位(1)方差。请注意，标准差是方差的平方根。标准差为 1 表示方差为 1。</p><p id="a9ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想在这里强调非常重要的一点。考虑到我们正在进行监督学习任务，因此我们将数据集分成训练和测试子集。在这种情况下，我们只对标准的 scaler 对象进行<code class="fe ms mt mu mv b">fit</code>训练集，而不是整个数据集。当然，我们需要转换测试集，但这是通过转换方法完成的。</p><ul class=""><li id="11f1" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">StandardScaler.fit(X_train)</li><li id="b64a" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">standard scaler . transform(X _ train)</li><li id="3051" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">standard scaler . transform(X _ test)</li></ul><p id="5a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将整个数据集拟合到标准缩放器对象会导致模型了解测试集。然而，模型不应该学习任何关于测试集的东西。它破坏了列车测试分离的目的。一般来说，这个问题被称为<strong class="lb iu">数据泄露。</strong></p><div class="ny nz gp gr oa ob"><a rel="noopener follow" target="_blank" href="/data-leakage-in-machine-learning-6161c167e8ba"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">机器学习中的数据泄漏</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">如何检测和避免数据泄露</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div><p id="c797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们转换测试集时，由于转换中使用的定标器是基于训练集的，因此这些特征将不具有精确的零均值和单位标准差。测试集中的变化量与训练集中的变化量相同。让我们创建一个样本测试集并转换它。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="951b" class="na lw it mv b gy nb nc l nd ne">X_test = np.array([[8, 90, 650], [5, 70, 590], [7, 80, 580]])<br/>X_test</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/2294406f3641b179231227896a5d1174.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*QGc3YTaT_JzxnkR4qaDqBw.png"/></div></figure><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="cf14" class="na lw it mv b gy nb nc l nd ne">X_test_transformed = sc.transform(X_test)<br/>X_test_transformed</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/d0fc9925eb707055687f086dd937ff05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*NBaGWz-vFm0cDP_5XnPruA.png"/></div></figure><p id="e537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试集各列的平均值和标准偏差:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/509701946730fdb3d11417d4d2f4c888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*VcCFXIFQ5IsiHnkWHlI9BA.png"/></div></figure></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><h1 id="7910" class="lv lw it bd lx ly pa ma mb mc pb me mf jz pc ka mh kc pd kd mj kf pe kg ml mm bi translated"><strong class="ak">最小最大缩放器和鲁棒缩放器</strong></h1><p id="cc30" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">将数值范围提高到相似水平的另一种方法是在特定范围内缩放它们。例如，我们可以将每一列压缩到 0 和 1 之间，使得缩放前的最小值和最大值在缩放后变成 0 和 1。这种缩放可以通过 scikit learn 的<code class="fe ms mt mu mv b"><strong class="lb iu">MinMaxScaler</strong></code> <strong class="lb iu"> </strong>来实现。默认范围是[0，1]，但是我们可以使用 feature_range 参数来更改它。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="9232" class="na lw it mv b gy nb nc l nd ne">from sklearn.preprocessing import MinMaxScaler</span><span id="4d63" class="na lw it mv b gy nf nc l nd ne">mm_scaler = MinMaxScaler()<br/>X_scaled = mm_scaler.fit_transform(X)<br/>X_scaled</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/2f26f66da6cf076f06bd05b68c256af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*k0hrA6J-Z9fYcqzzE-1YjQ.png"/></div></figure><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ee3c" class="na lw it mv b gy nb nc l nd ne">mm_scaler2 = MinMaxScaler(feature_range=(0,10))<br/>X_scaled2 = mm_scaler2.fit_transform(X)<br/>X_scaled2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/22d54922b26ce922e0f518fd334bc27c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*PAep9-yreovDDqR5wKH5zA.png"/></div></figure></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="f9ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">StandardScaler</code>和<code class="fe ms mt mu mv b">MinMaxScaler</code>对异常值不稳健。假设我们有一个值在 100 到 500 之间的特性，其异常值为 15000。如果我们用<code class="fe ms mt mu mv b">MinMaxScaler(feature_range=(0,1))</code>缩放这个特性，15000 被缩放为 1，所有其他值变得非常接近下限，即 0。因此，我们最终得到了一个不成比例的比例，这对模型的性能产生了负面影响。一种解决方案是移除异常值，然后应用缩放。然而，删除异常值并不总是一个好的做法。在这种情况下，我们可以使用 scikit-learn 的<code class="fe ms mt mu mv b"><strong class="lb iu">RobustScaler</strong></code> <strong class="lb iu"> </strong>。</p><p id="1325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b"><strong class="lb iu">RobustScaler</strong></code>顾名思义，对离群值具有鲁棒性。它会移除中位数，并根据分位数范围(默认为 IQR:四分位数范围)缩放数据。IQR 是第一个四分位数(第 25 个四分位数)和第三个四分位数(第 75 个四分位数)之间的范围。<code class="fe ms mt mu mv b">RobustScaler </code>不以预定间隔限制缩放范围。因此，我们不需要像对 MinMaxScaler 那样指定一个范围。</p><p id="1f6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过在之前的数据集中添加一行异常值来查看<code class="fe ms mt mu mv b">MinMaxScaler</code>和<code class="fe ms mt mu mv b">RobustScaler</code>之间的差异。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5598" class="na lw it mv b gy nb nc l nd ne">X_new = np.append(X, np.array([[50,420,1400]]), axis=0)</span><span id="abc3" class="na lw it mv b gy nf nc l nd ne">X_new</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/93e7a18efcedeb0a45e7ecfe6b33e109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*EDjzhTUyLYEIS9pWhcac9w.png"/></div></figure><p id="acaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先用 range [0，1]来套用<code class="fe ms mt mu mv b">MinMaxScaler </code>。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="04c2" class="na lw it mv b gy nb nc l nd ne">X_new_mm = mm_scaler.fit_transform(X_new)</span><span id="60a0" class="na lw it mv b gy nf nc l nd ne">X_new_mm</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/9a74cd481912cab6f0010a076097ae91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*K-Ig3mLhf3FriPbMzyZu1g.png"/></div></figure><p id="2839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超出范围上限的异常值。因此，所有其他值都非常接近下限。</p><p id="4a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">RobustScaler</code>怎么样？</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="7e35" class="na lw it mv b gy nb nc l nd ne">from sklearn.preprocessing import RobustScaler</span><span id="94f6" class="na lw it mv b gy nf nc l nd ne">r_scaler = RobustScaler()<br/>X_new_rs = r_scaler.fit_transform(X_new)</span><span id="cafc" class="na lw it mv b gy nf nc l nd ne">X_new_rs</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/cde6630df4df8ba21e6883d56a4a81d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*dqPkVrBj9EpD_xIEAec_vw.png"/></div></figure></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><h1 id="18f2" class="lv lw it bd lx ly pa ma mb mc pb me mf jz pc ka mh kc pd kd mj kf pe kg ml mm bi translated"><strong class="ak">什么时候用哪个？</strong></h1><p id="dff7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们已经讨论了标准定标器、最小最大定标器和鲁棒定标器。许多机器学习模型受益于具有相似规模的特征。然而，没有一个严格的规则来定义哪种转换对于特定的算法是最优的。</p><p id="5af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MinMaxScaler 和 StandardScaler 对异常值都很敏感。因此，在我们无法移除异常值的情况下，RobustScaler 是比其他两个更好的选择。</p><p id="f45f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在没有异常值的情况下，MinMaxScaler 在大多数情况下表现良好。然而，深度学习算法(例如，神经网络)和回归算法支持具有正态分布的特征。对于这种情况，StandardScaler 是更好的选择。</p><p id="e113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是最常用的转换技术，可以满足我们的一般需求。Scikit-learn 还提供了更多具体的转换，在预处理包的<a class="ae ky" href="https://scikit-learn.org/stable/modules/preprocessing.html" rel="noopener ugc nofollow" target="_blank">文档</a>中有解释。</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="dc87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>