<html>
<head>
<title>Performance Optimization in R: Parallel Computing and Rcpp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R 中的性能优化:并行计算和 Rcpp</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/performance-optimization-in-r-parallel-computing-and-rcpp-6b541cd5ccf6?source=collection_archive---------70-----------------------#2020-06-07">https://towardsdatascience.com/performance-optimization-in-r-parallel-computing-and-rcpp-6b541cd5ccf6?source=collection_archive---------70-----------------------#2020-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d303" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">R 中性能优化的快速介绍:并行和 Rcpp 包。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7415269a26f128170a59650988f466e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BoIkAVSloc4lcxiR-0G8Rw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://pixabay.com/users/alan9187-2347/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=534120" rel="noopener ugc nofollow" target="_blank"> alan9187 </a>来自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=534120" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><h2 id="7a0e" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">“平行”包装</h2><p id="662e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">通过使用并行计算，R 中的许多计算可以变得更快。一般来说，并行计算是在多个计算处理器或核心上同时执行较大计算的不同部分。</p><p id="83de" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><code class="fe mq mr ms mt b">parallel</code>包可用于将任务(编码为函数调用)并行发送到机器上的每个处理核心。</p><p id="c9d9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><code class="fe mq mr ms mt b">mclapply()</code>函数本质上是将对<code class="fe mq mr ms mt b">lapply()</code>的调用并行化。<code class="fe mq mr ms mt b">mclapply()</code>的前两个参数与<code class="fe mq mr ms mt b">lapply()</code>的参数完全相同。然而，<code class="fe mq mr ms mt b">mclapply()</code>有更多的参数(必须命名)，其中最重要的是<code class="fe mq mr ms mt b">mc.cores</code>参数，您可以使用它来指定您想要将计算划分到多少个处理器/内核上。例如，如果您的机器上有 4 个内核，您可以指定<code class="fe mq mr ms mt b">mc.cores = 4</code>来中断您的跨 4 个内核的并行化操作(尽管如果您正在后台运行除 R 之外的其他操作，这可能不是最好的主意)。</p><p id="966d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">你可能想用<code class="fe mq mr ms mt b">parallel</code>包检查的第一件事是你的计算机实际上是否有你可以利用的多个内核。</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="19ed" class="kw kx iq mt b gy my mz l na nb">require(parallel)<br/><br/>cores &lt;- detectCores()<br/>cores</span><span id="d719" class="kw kx iq mt b gy nc mz l na nb">## [1] 8</span></pre><p id="8c79" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><code class="fe mq mr ms mt b">mclapply()</code>函数(以及相关的<code class="fe mq mr ms mt b">mc*</code>函数)通过 Unix 风格的操作系统上的 fork 机制工作。由于使用了 fork 机制，Windows 操作系统的用户通常无法使用<code class="fe mq mr ms mt b">mc*</code>功能。</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="668e" class="kw kx iq mt b gy my mz l na nb">mclapply(1:7, FUN = function(x) return(x), mc.cores = cores-1)</span><span id="8fd1" class="kw kx iq mt b gy nc mz l na nb">## Error in mclapply(1:7, FUN = function(x) return(x), mc.cores = cores - : 'mc.cores' &gt; 1 is not supported on Windows</span></pre><p id="895d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在您的计算机上使用分叉机制是执行并行计算的一种方式，但它不是并行包提供的唯一方式。另一种使用计算机上的多核构建“集群”的方法是通过<em class="nd">插槽</em>。</p><p id="835c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">用 R 中的<code class="fe mq mr ms mt b">makeCluster()</code>函数构建一个套接字集群很简单。</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="6348" class="kw kx iq mt b gy my mz l na nb">cl &lt;- makeCluster(cores-1)</span></pre><p id="cb01" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><code class="fe mq mr ms mt b">cl</code>对象是整个集群的抽象，我们将使用它向各种集群函数表明我们想要进行并行计算。</p><p id="4cf4" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">为了在套接字集群上执行<code class="fe mq mr ms mt b">lapply()</code>操作，我们可以使用<code class="fe mq mr ms mt b">parLapply()</code>函数。</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="36a3" class="kw kx iq mt b gy my mz l na nb"># sample function<br/>test &lt;- function(){<br/>  Sys.sleep(2)<br/>  return(TRUE)<br/>}<br/><br/># call "test" in parallel apply<br/>parLapply(cl = cl, 1:7, fun = function(x) {<br/>  test()<br/>})</span><span id="c7a2" class="kw kx iq mt b gy nc mz l na nb">## Error in checkForRemoteErrors(val): 7 nodes produced errors; first error: could not find function "test"</span></pre><p id="f080" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">不幸的是，您会注意到在运行这段代码时有一个错误。原因是，虽然我们已经将硫酸盐数据加载到 R 会话中，但是这些数据对于由<code class="fe mq mr ms mt b">makeCluster()</code>函数生成的独立子进程是不可用的。数据，以及子进程执行代码所需的任何其他信息，需要通过<code class="fe mq mr ms mt b">clusterExport()</code>函数从父进程导出到子进程。需要导出数据是“多核”方法和“套接字”方法之间行为的一个关键区别。</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="77c9" class="kw kx iq mt b gy my mz l na nb"># export "test" to the cluster nodes<br/>clusterExport(cl, "test")<br/><br/># call "test" in parallel apply<br/>parLapply(cl = cl, 1:7, fun = function(x) {<br/>  test()<br/>})</span><span id="0352" class="kw kx iq mt b gy nc mz l na nb">## [[1]]<br/>## [1] TRUE<br/>## <br/>## [[2]]<br/>## [1] TRUE<br/>## <br/>## [[3]]<br/>## [1] TRUE<br/>## <br/>## [[4]]<br/>## [1] TRUE<br/>## <br/>## [[5]]<br/>## [1] TRUE<br/>## <br/>## [[6]]<br/>## [1] TRUE<br/>## <br/>## [[7]]<br/>## [1] TRUE</span></pre><p id="6be6" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">需要多长时间？</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="ca19" class="kw kx iq mt b gy my mz l na nb"># parallel<br/>t0 &lt;- proc.time()<br/>xx &lt;- parLapply(cl = cl, 1:7, fun = function(x) {<br/>  test()<br/>})<br/>t1 &lt;- proc.time()<br/>t1-t0</span><span id="6ba8" class="kw kx iq mt b gy nc mz l na nb">##    user  system elapsed <br/>##    0.03    0.00    2.05</span><span id="0c97" class="kw kx iq mt b gy nc mz l na nb"># serial<br/>t0 &lt;- proc.time()<br/>xx &lt;- lapply(1:7, FUN = function(x) {<br/>  test()<br/>})<br/>t1 &lt;- proc.time()<br/>t1-t0</span><span id="f099" class="kw kx iq mt b gy nc mz l na nb">##    user  system elapsed <br/>##    0.02    0.00   14.14</span></pre><p id="01f2" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><code class="fe mq mr ms mt b">clusterEvalQ()</code>计算每个集群节点上的文字表达式。它可以用于将包加载到每个节点中。</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="012e" class="kw kx iq mt b gy my mz l na nb"># load the zoo package in each node<br/>clusterEvalQ(cl = cl, require(zoo))</span><span id="b96c" class="kw kx iq mt b gy nc mz l na nb">## [[1]]<br/>## [1] TRUE<br/>## <br/>## [[2]]<br/>## [1] TRUE<br/>## <br/>## [[3]]<br/>## [1] TRUE<br/>## <br/>## [[4]]<br/>## [1] TRUE<br/>## <br/>## [[5]]<br/>## [1] TRUE<br/>## <br/>## [[6]]<br/>## [1] TRUE<br/>## <br/>## [[7]]<br/>## [1] TRUE</span><span id="e6d8" class="kw kx iq mt b gy nc mz l na nb"># call zoo functions in parallel apply <br/>parLapply(cl = cl, 1:7, fun = function(x) {<br/>  is.zoo(zoo())<br/>})</span><span id="adf7" class="kw kx iq mt b gy nc mz l na nb">## [[1]]<br/>## [1] TRUE<br/>## <br/>## [[2]]<br/>## [1] TRUE<br/>## <br/>## [[3]]<br/>## [1] TRUE<br/>## <br/>## [[4]]<br/>## [1] TRUE<br/>## <br/>## [[5]]<br/>## [1] TRUE<br/>## <br/>## [[6]]<br/>## [1] TRUE<br/>## <br/>## [[7]]<br/>## [1] TRUE</span></pre><p id="358e" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">一旦您完成了集群的工作，最好清理并停止集群子进程(退出 R 也会停止所有子进程)。</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="4fdb" class="kw kx iq mt b gy my mz l na nb">stopCluster(cl)</span></pre><h2 id="3d99" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">“Rcpp”包</h2><p id="ce92" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated"><code class="fe mq mr ms mt b">Rcpp</code>包提供了 C++类，使用 R 提供的<code class="fe mq mr ms mt b">.Call()</code>接口极大地方便了 R 包中 C 或 C++代码的接口。它在 R 之上提供了一个强大的 API，允许 R 和 C++之间直接交换丰富的 R 对象(包括 S3、S4 或引用类对象)。</p><p id="911c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">将 C++代码保存在自己的源文件中有几个好处(推荐)。然而，也可以进行 C++代码的内联声明和执行，这将在下面的示例中使用。</p><p id="762b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">让我们用 R 和 C++实现斐波那契数列:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b0df220d9843eaaca5620247690e9605.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*W6EfFH1p9w79_DfH84FEcQ.png"/></div></figure><p id="4741" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">与<em class="nd"> F₀=1 </em>和<em class="nd"> F₁=1 </em>。</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="8ed5" class="kw kx iq mt b gy my mz l na nb">fibR &lt;- function(n){<br/>  if(n==0) return(0)<br/>  if(n==1) return(1)<br/>  return(fibR(n-1) + fibR(n-2))<br/>}</span><span id="1332" class="kw kx iq mt b gy nc mz l na nb">Rcpp::cppFunction("<br/>int fibC(const int n){<br/>  if(n==0) return(0);<br/>  if(n==1) return(1);<br/>  return(fibC(n-1) + fibC(n-2));<br/>}")</span></pre><p id="c3dd" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">比较性能:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="8fbf" class="kw kx iq mt b gy my mz l na nb">require(microbenchmark)<br/>microbenchmark(fibR(20), fibC(20))</span><span id="d190" class="kw kx iq mt b gy nc mz l na nb">## Unit: microseconds<br/>##      expr     min       lq      mean   median       uq     max neval<br/>##  fibR(20) 11354.8 13077.50 16629.646 14720.85 18781.75 33800.5   100<br/>##  fibC(20)    35.6    39.05    68.486    51.10    57.10  1224.5   100</span></pre></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h2 id="4cec" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">参考</h2><p id="e550" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">[1]<a class="ae kv" href="https://bookdown.org/rdpeng/rprogdatascience/parallel-computation.html" rel="noopener ugc nofollow" target="_blank">https://book down . org/rd Peng/rprogdatascience/parallel-computation . html</a></p><p id="d9e3" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">[2]<a class="ae kv" href="http://heather.cs.ucdavis.edu/~matloff/158/RcppTutorial.pdf" rel="noopener ugc nofollow" target="_blank">http://heather.cs.ucdavis.edu/~matloff/158/RcppTutorial.pdf</a></p></div></div>    
</body>
</html>