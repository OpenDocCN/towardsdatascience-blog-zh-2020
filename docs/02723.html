<html>
<head>
<title>Implementing a data pipeline by chaining Python iterators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过链接Python迭代器实现数据管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-a-data-pipeline-by-chaining-python-iterators-b5887c2f0ec6?source=collection_archive---------23-----------------------#2020-03-16">https://towardsdatascience.com/implementing-a-data-pipeline-by-chaining-python-iterators-b5887c2f0ec6?source=collection_archive---------23-----------------------#2020-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b50d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">干净、快速、可扩展和简单的数据处理设计模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5d1f27960adbc1ea5e5dbde3f8bdad4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZa3ejrU0OKCFwCpGO6sWA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于罗迪昂·库察耶夫<a class="ae ky" href="https://unsplash.com/photos/xNdPWGJ6UCQ" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/xNdPWGJ6UCQ</a></p></figure><p id="aae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论如何通过几个步骤以相对高效和灵活的方式处理Python中的项目集合，同时保持代码的整洁。我们将通过创建迭代器来支持其他迭代器，以此类推，从而创建迭代器链。</p><p id="264f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你读过四人帮的书或类似的材料，你可能已经发现了迭代器设计模式。迭代器只是一个带有方法的对象，允许客户端代码使用它来遍历一个项目集合。迭代器的美妙之处在于它们封装(隐藏)了集合的本质。集合可以是数据库表上的一组行，或者是一个复杂的图形模型上的节点，或者只是内存数组中的元素，但是迭代器的用户并不知道它。他们只需要知道他们可以一个接一个地获得元素，直到集合用尽。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6cfb" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">Python中的迭代器和生成器</h2><p id="6f19" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Python对迭代器有很好的支持，为了理解它是如何工作的，让我们讨论几个概念。</p><p id="f48b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，Python中的<strong class="lb iu">迭代器</strong>是具有__next__方法的任何对象，该方法返回集合的下一个元素，直到集合结束，之后，每次调用时都会引发StopIteration异常。出于教学目的，让我们做一个非常简单的迭代器</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="dabf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果你试图在for循环中使用这个迭代器，你会得到一个“类型错误:‘我的迭代器’对象是不可迭代的”。这是因为for循环需要<strong class="lb iu"> iterables </strong>，它们是带有__iter__方法的对象，该方法返回迭代器。大多数集合(列表、字典、集合等。)都是可迭代的。它们不是迭代器(实际上，对它们调用next()会抛出一个错误)，但是它们可以创建一个迭代器，这样客户机代码就可以遍历它们。在我们的迭代器中，只需添加一个返回<em class="nc"> self </em>的__iter__方法就可以使它成为可迭代的。</p><p id="3626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是迭代器并不都是这样。另一个很棒的Python语法是生成器。生成器是一种迭代器，可以像函数一样创建，只需用yield替换return。让我们看看我们的迭代器示例如何作为一个生成器来翻译</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0e66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器也是可迭代的，可以直接在for循环中使用。需要记住的重要一点是，任何地方任何具有单一产出的函数(或方法)在被调用时都不会做任何事情。我的意思是，函数中没有一行代码会被执行。相反，该函数将创建并返回生成器对象。只有当你开始迭代生成器时，代码才会被执行。当您在生成器上调用__next__时，代码将一直执行到第一个yield。然后它会返回收益率上的值并停止。保存状态，因此__next__ time:)执行将在该yield之后立即恢复，并在到达下一个yield语句时停止。与return不同，你可以将一个收益率写在另一个收益率之下，两个收益率都会达到。最后，当生成器到达代码末尾时，它将引发StopIteration异常。如果return语句到达末尾，返回值将包含在异常中，不会被输出。</p><h2 id="3eb9" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">数据管道</h2><p id="06b2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">假设我们有一个需要进行一些处理的项目集合。现在，如果处理非常简单，你可以用一个方法完成，使用一些辅助方法等等。然而，在一个地方做所有的事情是一个非常糟糕的软件设计方法，这就是你如何得到有数百行代码的功能，当你不得不阅读它们时，你会想哭</p><p id="7f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">避免这种痛苦的一种方法是让项目通过一个简单的管道。在一个简单的管道中，每个方法接收一个项目，对其进行一些更改，然后返回转换后的项目。每种方法都可以保持简短。此外，它们共享相同的接口(item in，item out ),并且不需要知道它们在管道中的位置，或者在它们到达方法之前发生了什么。这允许您改变转换的顺序，或者甚至客户端可以在管道上挂钩新的方法(向开闭原则致敬)。</p><h2 id="098e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">定量</h2><p id="0117" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们刚刚介绍的简单管道的一个限制是，转换是在逐项的基础上进行的。但是，许多操作通过对批处理进行操作来提高效率。例如，假设一个远程API调用为您提供了处理项目所需的信息。如果API提供一个批量端点来发送一组项目并接收一组结果，这将比逐项调用API快得多。想想发送HTTP请求和等待响应需要多长时间，然后才能继续处理下一项。在我们的简单管道中，我们不能处理批处理，因为该方法接收单个项目，并且必须立即返回转换后的项目。</p><p id="7914" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这个问题的一个方法是让每个转换接收一个批处理并返回一个批处理。问题是最方便的批量可能因方法而异。方法A可能更适合500个批次的产品，但方法B只能吞下100个。此外，通过将批处理强加给每个人，简单的方法(如正则表达式替换)将变得更加复杂，因为必须解包输入批处理，完成它们的工作，然后组装输出批处理。</p><p id="bd89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么迭代器链在这种情况下如此方便。在迭代器链中，每个转换接收一个iterable项，并返回一个iterable转换项。我们将看到这种模式是如何在保持代码整洁的同时实现批处理的。</p><p id="6c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一个现实生活中简单的例子开始。如果逐项读取，从远程数据库服务器读取是一项开销很大的操作。分批提取要快得多。在阅读该示例之前，您可能想知道我正在使用psycopg库游标来访问PostgreSQL数据库。另外，我假设有一个format_item函数将从表数据构建item对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="089f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你以前没见过，“yield from iterable”语句是“for element in iterable:yield element”的简称。这个例子函数是…你猜对了，一个生成器函数。它返回一个项目生成器。这个生成器的客户端将一个接一个地获取项目，不需要知道任何关于数据库、批量大小或任何细节的信息。如果你想改变批量大小，什么也不会发生(除了性能问题)。如果你想改变数据库软件，没有人需要知道，如果你甚至想从文件中读取项目，这一切都没问题。这就是迭代器的美妙之处。</p><p id="2b36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经注意到了这个方法，它不是我描述的迭代器链式链接:它不接收iterable，尽管它返回一个。这是因为它是数据链的第一环，是数据的原始来源。这个链的最后一个链接也是特殊的，它接收一个iterable，但不返回一个。因此，让我们展示一个调用REST API的普通中间链接。我假设您有一个名为get_api_results的方法，它从api获取一批结果，并返回这批转换后的项目。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="44b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此方法接收一个项目生成器并返回另一个项目生成器。我敢打赌，在阅读代码之后，您可以看到批处理是如何工作的，但是没有一个八卦客户端会知道。</p><p id="05fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们说过，链的最终方法也是特殊的。这将只是通过迭代直到耗尽来消耗生成器，并将结果写到某个地方(例如另一个PostgreSQL DB)。这个方法上的批处理也是一样的。</p><p id="b77c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，使用这种方法，不需要批处理的方法可以保持简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="35cd" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">内存使用</h2><p id="4091" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们之前没有提到它，但是迭代器管道在内存使用方面非常有效。为了理解这一点，你可以把你头脑中的管道描绘成层叠排列的水容器(就像喷泉一样)。上面有一个大水箱(DB中的项目)，下面有一个大水箱(另一个DB中的转换项目)，水从一个容器流到另一个容器。每个容器的大小是生成器保存的批次。管道使用的内存大约是所有容器中水的总和。通常，这将比上面的大容器少很多，但是当容器真的很大时，这意味着加载所有的项目并在内存中处理它们会有天壤之别。</p><p id="35ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想到了一个问题，您应该注意，如果您在一个中间转换中用尽了迭代器，例如，如果您编写了类似于<em class="nc"> list(items) </em>的内容，那么所有的项都将在那个位置加载到内存中。看到许多项正在经历前面的转换，但没有超过那个点，直到所有项都被加载，只有这样它们才能继续向下游移动，这可能会令人困惑。你会在你的喷泉中间创造一个无限大的容器，一个吸啊吸，直到没有其他东西可吸，然后才打开让水继续流动的容器。</p><h2 id="a726" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">其他性能改进</h2><p id="bb45" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">显然，我们的迭代器管道还有很大的改进空间。管道可能会变得复杂，同时将功能分成简单的生成器。您可以想象如何链接生成器，甚至可以根据处理的结果交换它们。然而，最后我将只提到您可以添加的其他性能技巧。请记住，不必要的优化是编程中非常邪恶的根源。只有当性能成为问题时才进行优化，并始终确保优化对性能产生真正的、相当大的影响，否则就不值得。</p><p id="4fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">选择</strong></p><p id="a1ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您经常对管道进行更改，尝试这种或那种方法来获得您想要的最终结果，一些繁重的操作可能会降低您的速度。也许你引入了一个新的字符串转换，它只影响1%的项目，但是你每次运行都要处理所有的项目。一个简单的方法是使第一个生成器具有选择性，这样它只生成可能需要重新处理的项目。我的意思是，如果你知道如何选择这些项目。</p><p id="ec6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">缓存</strong></p><p id="284f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有同样的问题(管道上的更改只影响少数项目)，但是您不知道如何选择这些项目。那么你可以使用缓存。在缓存中，您将保存繁重操作的结果，您不想白白运行这些操作。</p><p id="d970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，你需要一种方法来检查你的项目的平等性。一般来说，它可能是所有项目内容的散列。但是你可能有一个特别的，更好的解决方案。您可以在管道上使用较慢的方法，将输入项的散列与构建输出所需的数据存储在一起。当从DB中读取时，可以将缓存包含到项中，当项到达slow方法时，该方法可以检查该项的哈希是否与缓存的哈希相同。如果是，您可以使用缓存的结果，而不是执行缓慢的操作。</p><p id="87e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">并行化(只是一瞥)</strong></p><p id="906e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些Python库提供了并行化迭代器的方法。老实说，我还没有认真尝试过，只是用一个名为<a class="ae ky" href="https://joblib.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> joblib </a>的库做了一点实验，这个库似乎拥有最简单的接口。像这样的代码应该在6个处理器上执行。试试看它是否适合你。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="32d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种特殊方法的一个缺点是将所有的项都加载到内存中，所以如果您正在处理一个大的数据池，您可能需要对整个管道本身进行批处理。</p><h2 id="116b" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">埃尔芬！</h2><p id="a1a2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">您刚刚学习了使用迭代器在Python中实现数据管道的基础，恭喜您！！！同样，你设法应付我糟糕的写作风格，赞美你。</p><p id="58de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这之后，你可能想学习更多关于Python中迭代器的知识，但是最重要的是，我邀请你来玩这个奇妙的语言特性，并自己犯一些错误。</p></div></div>    
</body>
</html>