<html>
<head>
<title>Implementing XGBoost from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始实现 XGBoost</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-xgboost-from-scratch-6b7f2eb593c?source=collection_archive---------18-----------------------#2020-03-06">https://towardsdatascience.com/implementing-xgboost-from-scratch-6b7f2eb593c?source=collection_archive---------18-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ceff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 numpy 实现一个最流行的机器学习模型的逐步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9f44b8e872e46167fcc6198943f8501d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FUXQVipq3qlSd5uI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安妮·斯普拉特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><blockquote class="kz la lb"><p id="568e" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">XGBoost 是一个优化的分布式梯度增强库，旨在高效、灵活和可移植。</p></blockquote><p id="4db1" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">它已经被用于几乎每一个机器学习黑客马拉松，并且通常是选择模型时的首选。</p><p id="31b6" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">但是理解它实际上是如何工作的总是困难的部分。起初，复杂的数学很难理解，所以我决定使用 Numpy 编写 XGBoost 的代码。这将有助于以简单的方式理解它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/a9719d0371c905128898f3a8c5bda399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1TdX-mAM9jVrauD9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@brucemars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁斯·马尔斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="b4a4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这是通过临时代码理解 XGBoost 的另一种方法。下面的代码是一个使用 numpy 开发的简单 XGBoost 模型。这段代码的主要目的是揭示 XGBoost 背后的数学原理。</p><h2 id="a2e8" class="md me it bd mf mg mh dn mi mj mk dp ml lz mm mn mo ma mp mq mr mb ms mt mu mv bi translated">导入基本库:</h2><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="01c8" class="md me it mx b gy nb nc l nd ne">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span></pre><p id="2171" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">numpy——实现 xgboost <br/> Pandas 背后的数学运算——将列表值转换为 data frame<br/>Matplotlib——绘制最终输出以可视化结果</p><p id="3eb4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">样本数据:</strong></p><p id="fb13" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">考虑以下数据，其中工作年限是预测变量，工资是目标。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="858d" class="md me it mx b gy nb nc l nd ne">year = [5,7,12,23,25,28,29,34,35,40]<br/>salary = [82,80,103,118,172,127,204,189,99,166]</span></pre><h2 id="6611" class="md me it bd mf mg mh dn mi mj mk dp ml lz mm mn mo ma mp mq mr mb ms mt mu mv bi translated">需要记住的几件重要事情:</h2><p id="7d49" class="pw-post-body-paragraph lc ld it lf b lg nf ju li lj ng jx ll lz nh lo lp ma ni ls lt mb nj lw lx ly im bi translated">使用<strong class="lf iu">回归树作为基础学习器</strong>，我们可以创建一个模型来预测工资。</p><p id="71f0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">为了简单起见，我们可以选择平方损失作为损失函数，我们的目标是最小化平方误差。</p><p id="f63e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">作为第一步，模型应该用函数 F0(x)初始化。F0(x)应该是使函数 F 在平均值处最小化的损失函数或 MSE(均方误差)最小化的函数</p><p id="fdc2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果我们取 MAE，函数会在中间值最小化</p><p id="bf26" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">数据构建</strong></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="2b65" class="md me it mx b gy nb nc l nd ne">df = pd.DataFrame(columns=['Years','Salary'])<br/>df.Years = year<br/>df.Salary = salary<br/>df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/e1aee629e217d9c6311ad16a293cb05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*Vc1E0iWtefXMjGZobKiDTQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上述代码片段的输出</p></figure><h2 id="01eb" class="md me it bd mf mg mh dn mi mj mk dp ml lz mm mn mo ma mp mq mr mb ms mt mu mv bi translated">几件更重要的事情:</h2><blockquote class="kz la lb"><p id="cc39" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">残差是 y 和 f0 之差，即(y-f0)</p></blockquote><p id="ee61" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们可以使用 F0(x)的残差来创建 h1(x)。h1(x)将是一棵回归树，它将尝试减少上一步的残差。h1(x)的输出不会是 y 的预测；相反，它将有助于预测将降低残差的连续函数 F1(x)。</p><p id="87c2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">加法模型 h1(x)计算树的每个叶子处的残差(y-F0)的平均值。</p><p id="6bd4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">分割完成后，计算上半部分和下半部分的平均值，我选择了一个随机分割点。</p><p id="8996" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">模型构建:</strong></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="1d66" class="md me it mx b gy nb nc l nd ne">for i in range(2):<br/>    f = df.Salary.mean()<br/>    if(i&gt;0):<br/>        df['f'+str(i)] = df['f'+str(i-1)] + df['h'+str(i)]<br/>    else:<br/>        df['f'+str(i)] = f<br/>    df['y-f'+str(i)] = df.Salary - df['f'+str(i)]<br/>    splitIndex = np.random.randint(0,df.shape[0]-1)<br/>    a= []<br/>    h_upper = df['y-f'+str(i)][0:splitIndex].mean()<br/>    h_bottom = df['y-f'+str(i)][splitIndex:].mean()<br/>    for j in range(splitIndex):<br/>        a.append(h_upper)<br/>    for j in range(df.shape[0]-splitIndex):<br/>        a.append(h_bottom)<br/>    df['h'+str(i+1)] = a<br/>    <br/>df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/0de8ad9afcceced1788d1e1001c5feaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4IKqcLNG7pyfwEmxBlIxuw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">2 次迭代后的输出</p></figure><p id="36e7" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果我们继续迭代 100 次，我们可以看到 MSE(Fi)的损失大幅下降</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="470e" class="md me it mx b gy nb nc l nd ne">for i in range(100):<br/>    f = df.Salary.mean()<br/>    if(i&gt;0):<br/>        df['f'+str(i)] = df['f'+str(i-1)] + df['h'+str(i)]<br/>    else:<br/>        df['f'+str(i)] = f<br/>    df['y-f'+str(i)] = df.Salary - df['f'+str(i)]<br/>    splitIndex = np.random.randint(0,df.shape[0]-1)<br/>    a= []<br/>    h_upper = df['y-f'+str(i)][0:splitIndex].mean()<br/>    h_bottom = df['y-f'+str(i)][splitIndex:].mean()<br/>    for j in range(splitIndex):<br/>        a.append(h_upper)<br/>    for j in range(df.shape[0]-splitIndex):<br/>        a.append(h_bottom)<br/>    df['h'+str(i+1)] = a<br/>    <br/>df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/77ec66488605de8802c9dff213835600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nZPnWi-hnHzcRhKhwk_lA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">100 次迭代后的输出</p></figure><p id="74fd" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们可以看到，随着迭代次数的增加，损失在减少，模型在适应数据集</p><h2 id="c4ed" class="md me it bd mf mg mh dn mi mj mk dp ml lz mm mn mo ma mp mq mr mb ms mt mu mv bi translated">可视化结果:</h2><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="77f4" class="md me it mx b gy nb nc l nd ne">plt.figure(figsize=(15,10))<br/>plt.scatter(df.Years,df.Salary)<br/>plt.plot(df.Years,df.f1,label = 'f1')<br/>plt.plot(df.Years,df.f10,label = 'f10')<br/>plt.plot(df.Years,df.f99,label = 'f99')<br/>plt.legend()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/3ca2dbcb972eaf7e4ca35f0bb56034c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RnNqyTycCZoRq98Uk6zajg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上述代码片段的绘图</p></figure><p id="e0cf" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">蓝线表示 1 次迭代后的输出，可以理解为随机。当我们到达第 100 次迭代时，模型适应数据，损失减少，从而使输出接近实际点。</p><p id="a3ef" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">代码可以在我的 github 回购上找到:【https://github.com/Sid11/XGBoost-Using-Numpy/】T2</p><p id="1085" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">希望你喜欢！</p></div></div>    
</body>
</html>