<html>
<head>
<title>Russian Alphabet Classification Using Monk AI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Monk AI 的俄语字母分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/russian-alphabets-classification-using-monk-ai-4df7d1ad8542?source=collection_archive---------54-----------------------#2020-08-26">https://towardsdatascience.com/russian-alphabets-classification-using-monk-ai-4df7d1ad8542?source=collection_archive---------54-----------------------#2020-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a9e1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让计算机视觉应用变得简单有效</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/df12b6ba85357f6d41e420c7bc773607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuibqNCq98e5dfOFLNePkw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸣谢:图片来自 F<a class="ae ky" href="https://www.flickr.com/" rel="noopener ugc nofollow" target="_blank">licker</a>的<a class="ae ky" href="https://www.flickr.com/photos/fotorus/" rel="noopener ugc nofollow" target="_blank"> Polyrus </a></p></figure><h1 id="6ff1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">目录:</h1><ol class=""><li id="d297" class="lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">介绍</li><li id="e124" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">关于数据集</li><li id="29cc" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">设置 Monk 和先决条件</li><li id="5b25" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">下载数据集</li><li id="d305" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">创建项目和实验</li><li id="4c3d" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">方法</li><li id="c44a" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">选择最佳模型</li><li id="8e97" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">结论</li></ol><h1 id="492d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">简介:</h1><p id="270f" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">对我们来说，对手写信息进行分类是一件容易的事情，但对计算机来说，这是一项令人不安和令人畏惧的工作。手写字符分类通常是一项具有挑战性的任务，因为任何字符都有无数种书写方式。</p><p id="04f7" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">尽管神经网络已经重新定义了这项任务，但它在开发这种分类器方面也发挥了巨大的作用，前提是为它提供了大量的数据来进行训练。</p><p id="974c" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">在这个特别的博客中，我们将探索俄语字母表，并以手写形式对它们进行分类。</p><h1 id="c29d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">关于数据集:</h1><p id="a784" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">在数据集中，我们有 14190 个彩色图像分布在 3 个图像文件夹中，包括所有 33 个类别的俄语字母表。</p><p id="6fcd" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">第一个文件夹具有条纹背景(具有很少的水平线和/或垂直线)，第二个文件夹具有白色背景，第三个文件夹具有图形类型背景(具有许多有序的水平线和垂直线)。</p><p id="c6c6" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">以下是数据集中的一些图像:</p><div class="kj kk kl km gt ab cb"><figure class="ng kn nh ni nj nk nl paragraph-image"><img src="../Images/fda8f1b2ab960fd082f8f94853334073.png" data-original-src="https://miro.medium.com/v2/resize:fit:64/format:webp/1*csKzYdpQodDgHgbHXD_lCg.png"/></figure><figure class="ng kn nh ni nj nk nl paragraph-image"><img src="../Images/f4185abba57de2b5eaf3895a3909f362.png" data-original-src="https://miro.medium.com/v2/resize:fit:64/format:webp/1*_UzpZMVjO65K3ZeIXX3SUA.png"/></figure><figure class="ng kn nh ni nj nk nl paragraph-image"><img src="../Images/be9245d1c39a0db715a789bc280aede4.png" data-original-src="https://miro.medium.com/v2/resize:fit:64/format:webp/1*IU0PjgWC4OQx21CJoC3IyA.png"/></figure></div><div class="ab cb"><figure class="ng kn nh ni nj nk nl paragraph-image"><img src="../Images/8f0e9de3e7ed39954de50933b425b8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:64/format:webp/1*UaJtPweCihTjTK8ynePUVQ.png"/></figure><figure class="ng kn nh ni nj nk nl paragraph-image"><img src="../Images/2c7ec30cea73e853aa326fac6f922013.png" data-original-src="https://miro.medium.com/v2/resize:fit:64/format:webp/1*7Yz1TFhJWbVJGgZIhZVR8Q.png"/></figure><figure class="ng kn nh ni nj nk nl paragraph-image"><img src="../Images/b108006141730f2d50a53bbb623f208d.png" data-original-src="https://miro.medium.com/v2/resize:fit:64/format:webp/1*0ZyIN9qZDWRJnMmtR0wUDA.png"/></figure></div><div class="ab cb"><figure class="ng kn nh ni nj nk nl paragraph-image"><img src="../Images/6b23d75c4e2854e63cce960558915cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:64/format:webp/1*5Fb-seAASmXWQ4fNa-i29Q.png"/></figure><figure class="ng kn nh ni nj nk nl paragraph-image"><img src="../Images/09378c834eeba022b86f08abfb812949.png" data-original-src="https://miro.medium.com/v2/resize:fit:64/format:webp/1*czH4zKldLGN6I7Q3TpARYA.png"/></figure><figure class="ng kn nh ni nj nk nl paragraph-image"><img src="../Images/9e73e184bed575644a53f8edc1392008.png" data-original-src="https://miro.medium.com/v2/resize:fit:64/format:webp/1*BAYcfWd-Un2pmhRPKCcl9g.png"/><p class="ku kv gj gh gi kw kx bd b be z dk nm di nn no translated">数据集的样本图像</p></figure></div><p id="623f" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">以下是用于预测目的的俄语字母及其相应的数字:</p><p id="462e" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi">а=&gt;1, б=&gt;2, в=&gt;3, г=&gt;4, д=&gt;5, е=&gt;6, ё=&gt;7, ж=&gt;8, з=&gt;9, и=&gt;10, й=&gt;11, к=&gt;12, л=&gt;13, м=&gt;14, н=&gt;15, о=&gt;16, п=&gt;17, р=&gt;18, с=&gt;19, т=&gt;20, у=&gt;21, ф=&gt;22, х=&gt;23, ц=&gt;24, ч=&gt;25, ш=&gt;26, щ=&gt;27, ъ=&gt;28, ы=&gt;29, ь=&gt;30, э=&gt;31, ю=&gt;32, я=&gt;33</p><p id="b281" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">所以不要担心，即使我们没有得到这篇文章，我们也会留下一些俄罗斯字母的印象！<br/>完整的数据集由 Olga Belitskaya 准备并上传，可以在这里找到:</p><div class="np nq gp gr nr ns"><a href="https://www.kaggle.com/olgabelitskaya/classification-of-handwritten-letters" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">手写信件的分类</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">俄罗斯字母的图像</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.kaggle.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og ks ns"/></div></div></a></div><p id="5d76" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">现在让我们开始设置僧侣和一些先决条件。</p><h1 id="e9d9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">设置 Monk 和先决条件</h1><p id="0ced" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">我们从安装 monk 库开始。</p><p id="8886" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">1.)我们在这里使用过 colab，所以这里是同样的安装过程。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="fade" class="om la it oi b gy on oo l op oq">#Installation process for colab<br/>pip install -U monk-colab</span></pre><p id="5343" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">虽然我们可以在<a class="ae ky" href="https://github.com/Tessellate-Imaging/monk_v1" rel="noopener ugc nofollow" target="_blank">僧库</a>探索其他的安装方式。</p><p id="0bfa" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">2.)将它添加到系统路径(每个终端或内核运行都需要)</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="4eab" class="om la it oi b gy on oo l op oq">import sys<br/>sys.path.append("monk_v1/");</span></pre><h1 id="60ac" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">下载数据集</h1><p id="fdb2" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">接下来，我们将从 Kaggle 直接获取数据集到 colab。为此，我们必须首先从 Kaggle 创建一个 API 令牌。</p><p id="1c24" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">转到您的 Kaggle 个人资料&gt;&gt;我的帐户&gt;&gt;向下滚动到 API 部分&gt;&gt;单击创建新的 API 令牌(记住，如果以前使用过，请使所有其他令牌过期)</p><p id="72a7" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">点击这个之后，kaggle.json 文件将被安装到您的系统中。<br/>接下来，再次进入数据集页面，在新笔记本选项的右侧，我们可以找到一个图标来复制 API 命令。此命令将用于下载数据集。<br/>现在，在 google colab 中上传 kaggle.json 文件，如下所示。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="53bb" class="om la it oi b gy on oo l op oq">! pip install -q kaggle<br/>from google.colab import files<br/>files.upload()<br/>#Upload the kaggle.json file here</span></pre><p id="3b79" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">此外，使用 API 命令下载数据集。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="3b08" class="om la it oi b gy on oo l op oq">! mkdir ~/.kaggle<br/>! cp kaggle.json ~/.kaggle/<br/>! chmod 600 ~/.kaggle/kaggle.json</span><span id="e872" class="om la it oi b gy or oo l op oq">#Download the full dataset zip file to Colab<br/>! kaggle datasets download -d 'olgabelitskaya/classification-of-handwritten-letters'</span></pre><p id="7bce" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">现在，解压缩这个文件并创建一个新文件，将所有数据集存储在一个地方。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="0746" class="om la it oi b gy on oo l op oq">#Unzip the downloaded zip file and put it under a new files section</span><span id="3c55" class="om la it oi b gy or oo l op oq">! unzip -qq sample.zip<br/>import zipfile<br/>zip_ref = zipfile.ZipFile('classification-of-handwritten-letters.zip', 'r')<br/>zip_ref.extractall('files')<br/>zip_ref.close()</span></pre><p id="a152" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">完成后，我们导入这些库和适当的后端。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="f738" class="om la it oi b gy on oo l op oq">import os<br/>import sys<br/>sys.path.append("monk_v1/");<br/>sys.path.append("monk_v1/monk/");</span><span id="9acc" class="om la it oi b gy or oo l op oq">#Importing MXNet Gluon API backend<br/>from monk.gluon_prototype import prototype</span></pre><p id="4f09" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">我在这里使用了<strong class="lt iu"> MXNet Gluon API </strong>作为后端，只用一行代码我们就可以选择我们想要的后端，不用担心以后会遇到不同的语法。使用 monk 库可以做到这一点，只需使用一种语法，我们就可以跨不同的框架工作，如 PyTorch、MXNet、Keras、TensorFlow。</p><h1 id="3e71" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">创建项目和实验</h1><p id="d03c" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">为了创建项目名和实验名，我们使用了 prototype 函数。我们现在可以在一个项目下创建多个实验，并在各个方面进行比较。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="571a" class="om la it oi b gy on oo l op oq">#Setup Project Name and Experiment Name</span><span id="4040" class="om la it oi b gy or oo l op oq">gtf = prototype(verbose=1);<br/>gtf.Prototype("Pilot", "Densenet_121");</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/7172e2df2695b4458a4c76f5193ff6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*M8YzeKrm8vMqnUVLv343aQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新项目形成！</p></figure><h1 id="05ec" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">方法</h1><p id="18c6" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">模型训练的方法:</p><p id="5a8d" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">我们没有连接三个图像文件夹，这将允许我们一起训练整个数据集。<br/>我们构建鲁棒模型的方法是首先通过使用受背景影响最小的图像(即第二图像文件夹)来训练模型。<br/>此外，该文件夹相当大(包含大量图像)，因此它可以在开始时有效地训练模型，并且我们可以通过更简单的数据了解模型的表现。</p><p id="80a0" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">这将在一定程度上确保模型是否学会提取所需的特征，并且我们可以通过分析相同的图来验证这一点。<br/>如果观察到模型已经学会正确地提取特征，那么我们可以用包含图形类型背景图像的下一个文件夹继续训练模型，即使这个文件夹足够大，因此希望它使模型学会忽略背景。</p><p id="a706" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">最后，我们用包含剥离背景的图像来更新和训练模型。</p><p id="b21b" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">这种方法使我们能够找出数据集的哪一部分没有被正确分类，如果结果不令人满意，我们可以分析所有图，确定模型在哪里表现不佳，并专注于该部分。</p><p id="5974" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">开发模型的方法:<br/> 1。)首先，选择后端(MXNet 胶子)，选择一些可能适合这个特定任务的基本模型。<br/> 2。)选择不太密集的变体，并比较它们的性能。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="5144" class="om la it oi b gy on oo l op oq">#Analysing basic models<br/>analysis_name = "analyse_models";</span><span id="0253" class="om la it oi b gy or oo l op oq">models = [["resnet34_v2", False, True],["densenet121", False, True],["vgg16", False, True],["alexnet",False,True],["mobilenetv2_1.0",False , True]];</span><span id="0f6b" class="om la it oi b gy or oo l op oq">epochs=5<br/>percent_data=15<br/>analysis = gtf.Analyse_Models(analysis_name, models, percent_data, num_epochs=epochs, state="keep_all");</span></pre><p id="5f63" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">3.)为模型调整参数。这是开发一个好模型最关键的部分。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="21d9" class="om la it oi b gy on oo l op oq">#Shuffle the data</span><span id="b305" class="om la it oi b gy or oo l op oq">gtf.update_shuffle_data(True);</span><span id="3aad" class="om la it oi b gy or oo l op oq">#For densenets batch size of 2 and 4 did not work well, batch size of 8 worked just fine , after which validation loss starts to increase</span><span id="b071" class="om la it oi b gy or oo l op oq">gtf.update_batch_size(8);</span><span id="1c3d" class="om la it oi b gy or oo l op oq">#learning rate 0.1 and 0.05 were not working well ,lr lesser than that didn't vary much w.r.t val and training loss .0.01 best choice</span><span id="7fb4" class="om la it oi b gy or oo l op oq">#Though optimizers like Adam and its variants are very fast at converging but the problem with them are they sometimes get stuck at local optima's.</span><span id="105c" class="om la it oi b gy or oo l op oq">#Whereas famous optimizers linke SGD and SGD plus momentum are slower to converge , but they dont get stuck at local optima easily.</span><span id="2815" class="om la it oi b gy or oo l op oq">#Here after analysing all these optimizers , sgd worked better.</span><span id="095b" class="om la it oi b gy or oo l op oq">#sgd was the best optimizer even for densenets</span><span id="997b" class="om la it oi b gy or oo l op oq">gtf.optimizer_sgd(0.01);</span><span id="2d19" class="om la it oi b gy or oo l op oq">gtf.Reload();</span></pre><p id="c837" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">在调整参数时，这种分析非常重要。</p><p id="9697" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">4.)使用相同的调整参数，尝试相同模型的更密集的变体。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="d7ca" class="om la it oi b gy on oo l op oq">#Comparing DenseNets for different depth of densenet variants.</span><span id="1380" class="om la it oi b gy or oo l op oq">analysis_name = "analyse_models";<br/>models = [["densenet121", False, True], ["densenet161", False, True], ["densenet169", False, True],["densenet201", False, True]];<br/>epochs=10<br/>percent_data=15<br/>analysis = get.Analyse_Models(analysis_name, models, percent_data, num_epochs=epochs, state="keep_none");</span></pre><p id="3352" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">如果我们直接选择密集网络，可能会因为梯度爆炸/递减而表现不佳，最终我们可能根本不会考虑这个选项。</p><h1 id="ce03" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">选择最佳模型</h1><p id="16b6" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">在所有这些努力之后，当暴露于看不见的数据时，很容易找出哪个模型能给你最好的结果。在这种情况下，结果是 Densenet，所选择的 dense net 的适当深度是 121，这足以给出期望的结果。<br/> Resnets 架构在经过调优后的整体性能上排名第二。Mobilenets 可能会表现得非常好，尽管这需要花费大量的训练时间和空间来完成这个特殊的任务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/a301ad549811e9a22c67768fe99657a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WddKAvOxQXR58ruEp5lKqQ.png"/></div></div></figure><p id="a9f6" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">这里的三个图是相同的模型，但是具有更新的数据。Densenet_121_3 在完整数据<br/>上进行训练。该图表明该模型在所有三种数据集上都学习得相当好。<br/>我们从我们的模型中获得了难以超越的验证性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/331481affbab276cf4de82a5bc8305fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*SlDTYwuk6skUxfuxxRS0eg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最终模型</p></figure><p id="655d" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">该模型看起来不像是过度拟合的，并且在对新图像进行分类时表现良好，确保该模型可以运行。<br/>如果我们可以对现有模型进行任何改进的话，那就是集中精力改进/增加带有图形类型背景的图像。如果我们仔细观察，在那些图像被更新和模型被训练之后，模型的性能下降了一点。<br/>这是另一个可以探索的工作领域。</p><h1 id="e09e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="e77d" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">我们已经使用各种架构执行了迁移学习，使用定义明确的方法构建了一个可靠的分类器。尽管这里有一点需要注意，创建项目和实验使我们很容易管理和比较实验/模型。</p><p id="c020" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">此外，我们可以使用很少的代码行执行如此多的复杂操作。如果我们采用传统的方法，在模型之间进行这样的比较将会花费我们不希望的代码，这可能很难调试。当我们使用 monk 库时，更新数据集和重新训练模型也是一项基本任务。</p><p id="6dda" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">还提到在某些领域可以做更多的工作，进一步提高模型的性能和可靠性。</p><p id="b01a" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">我们还使用一些测试图像进行了推断，请访问下面的代码链接查看它们。</p><p id="bdc6" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">对于整个代码:</p><div class="np nq gp gr nr ns"><a href="https://github.com/Sanskar329/Russian-Letters" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">sanskar 329/俄语字母</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">这个项目是关于分类俄语字母。总共有 33 类俄语字母。的目标是</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="ov l od oe of ob og ks ns"/></div></div></a></div><p id="a1e9" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">或者可以在<a class="ae ky" href="https://github.com/Tessellate-Imaging/monk_v1/blob/master/study_roadmaps/4_image_classification_zoo/Classifier%20-%20Russian%20Alphabets%20Dataset.ipynb" rel="noopener ugc nofollow" target="_blank">图像分类动物园</a>查看代码。</p><p id="6beb" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">对于更多此类应用:</p><div class="np nq gp gr nr ns"><a href="https://github.com/Tessellate-Imaging/monk_v1/tree/master/study_roadmaps/4_image_classification_zoo" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">镶嵌成像/monk_v1</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">Monk 是一个低代码深度学习工具，是计算机视觉的统一包装器。— Tessellate-Imaging/monk_v1</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="ow l od oe of ob og ks ns"/></div></div></a></div><p id="27b0" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">Monk 教程:</p><div class="np nq gp gr nr ns"><a href="https://github.com/Tessellate-Imaging/monk_v1/tree/master/study_roadmaps" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">镶嵌成像/monk_v1</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">模块 1:入门路线图第 1.1 部分:Monk 入门第 1.2 部分:Monk 的基本特性第 1.3 部分…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="ox l od oe of ob og ks ns"/></div></div></a></div><p id="9230" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">如果这篇文章能帮助你学到新的东西，请分享！</p><p id="b896" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">感谢阅读！</p></div></div>    
</body>
</html>