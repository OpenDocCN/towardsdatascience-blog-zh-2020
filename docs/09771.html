<html>
<head>
<title>Albert Vectorization (With Tensorflow Hub)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Albert 矢量化(带 Tensorflow Hub)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/albert-vectorization-with-tensorflow-hub-c6b892ed7ed4?source=collection_archive---------22-----------------------#2020-07-11">https://towardsdatascience.com/albert-vectorization-with-tensorflow-hub-c6b892ed7ed4?source=collection_archive---------22-----------------------#2020-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/131feecb8d0a2eb3a4bd8576215ebf74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rCPNtiH8SxU0RD9crIjbzA.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="af23" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">我们使用来自 tensorflow-hub 的预训练 Albert 嵌入对输入文本进行矢量化。它被用作 Keras 层，因此可以很容易地扩展以构建深度学习模型。</h2></div><p id="d52b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">BERT 的出现打破了 NLP 的传统范式。下游的模型构建现在是从一个以语言知识为基础的模型开始，而不是从零开始。ALBERT 可以被称为 lite BERT，它使用转换器-编码器架构，参数数量大大减少。在本文中，词汇大小也是 30K，与最初的 BERT 中使用的一样。ALBERT 区别于 BERT 的三个主要方面是分解嵌入参数化、跨层参数共享和句子顺序预测。</p><h1 id="dc5c" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">优于伯特</h1><p id="214d" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">当人们试图简单地放大模型的隐藏尺寸时，BERT like 模型可能提供质量差的性能。诸如因子分解嵌入参数化之类的参数缩减技术用于将隐藏层的大小与词汇嵌入的大小分开，这使得在不显著增加参数大小的情况下增加隐藏大小变得容易。而跨层参数共享防止参数随着网络的深度而增长。因此，这两种技术都显著减少了传统 BERT 的参数数量，而没有恶化性能和提高参数效率。通过引入句子顺序预测的自监督损失(SOP ), ALBERT 的性能得到进一步改善。</p><p id="8a7f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在本文中，我们将使用 tensorflow-hub 模块的 keras 层格式获得相应文本的 ALBERT 向量。</p><h1 id="d687" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">1.设置环境</h1><p id="3cb8" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">我们将使用 tensorflow keras API 制作一个模型，它将为文本输入提供 ALBERT 嵌入。环境设置包括安装所需的库和获取所需的 tensorflow-hub 模块以获得 ALBERT vectors。使用的库有:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a08c" class="mv lq je mr b gy mw mx l my mz">#tensorflow==2.2.0<br/>#tensorflow_hub=0.8.0<br/>#sentencepiece==0.1.91<br/>#tqdm==4.47.0<br/>#seaborn==0.10.1<br/>#numpy==1.19.0</span></pre><p id="1b4a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将使用 TF2 保存的艾伯特模型格式。您可以直接使用 tfhub 上的模块进行推断。但是对于生产场景，最好将模块放在本地。为此，我们需要首先获取模块的 zip 文件并将其解压缩。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="c2cf" class="mv lq je mr b gy mw mx l my mz"># mkdir albert_en_base<br/># mkdir 1<br/># wget <a class="ae na" href="https://tfhub.dev/tensorflow/albert_en_base/1https://tfhub.dev/tensorflow/albert_en_base/1" rel="noopener ugc nofollow" target="_blank">https://tfhub.dev/tensorflow/albert_en_base/1https://tfhub.dev/tensorflow/albert_en_base/1</a><br/># tar-xzf albert_en_base_1.tar.gztar-xzf albert_en_base_1.tar.gz<br/># rm -rf albert_en_base_1.tar.gzrm -rf albert_en_base_1.tar.gz</span></pre><h1 id="2b01" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">2.符号化</h1><p id="ce0d" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">我们将把 ALBERT 模块作为 keras 层导入。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="dc9c" class="mv lq je mr b gy mw mx l my mz">albert_layer = hub.KerasLayer("albert_en_base/1", trainable=False)</span></pre><p id="b531" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">棘手的是，艾伯特模块不能直接输入文本。它需要经过一个预处理层。</p><p id="dd5b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">首先，我们将使用 ALBERT tokenizer 对输入文本进行分词，它基于一个句子片断分词器，即子词级分词器。它是一个数据驱动的标记器，用来处理词汇表之外的单词。因为我们在每次输入时只有一个文本，所以句子的标记列表看起来像["[CLS]"]+标记+ ["[SEP]"]。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0a7c" class="mv lq je mr b gy mw mx l my mz">sp_model_file = albert_layer.resolved_object.sp_model_file.asset_path.numpy()<br/>tokenizer = FullSentencePieceTokenizer(sp_model_file)<br/>stokens = tokenizer.tokenize(sentence)<br/>stokens = stokens[:MAX_LEN]<br/>stokens = ["[CLS]"] + stokens + ["[SEP]"]</span></pre><p id="1081" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">例如，文本“车身由金属制成，具有高张力”会生成一个令牌列表，如下所示:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5e1a" class="mv lq je mr b gy mw mx l my mz">['▁the',<br/> '▁body',<br/> '▁is',<br/> '▁made',<br/> '▁of',<br/> '▁metallic',<br/> 'a',<br/> '▁and',<br/> '▁deliver',<br/> 'i',<br/> '▁high',<br/> '▁tension']</span></pre><p id="5f4a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，我们需要 3 个输入序列，可以馈入艾伯特模块。</p><ul class=""><li id="8044" class="nb nc je kv b kw kx kz la lc nd lg ne lk nf lo ng nh ni nj bi translated">标记 id:用于从 ALBERT vocab 字典中提取的句子中的每个标记。</li><li id="2df3" class="nb nc je kv b kw nk kz nl lc nm lg nn lk no lo ng nh ni nj bi translated">mask ids:for each token，用于屏蔽仅用于序列填充的标记(因此每个序列都有固定的长度)。</li><li id="904c" class="nb nc je kv b kw nk kz nl lc nm lg nn lk no lo ng nh ni nj bi translated">Segment ids 表示一个句子序列(我们这里的例子)，1 表示序列中有两个句子。</li></ul><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="6776" class="mv lq je mr b gy mw mx l my mz">def get_ids(tokens, tokenizer, max_seq_length):<br/>  """Token ids from Tokenizer vocab"""<br/>  token_ids = tokenizer.convert_tokens_to_ids(tokens,)<br/>  input_ids = token_ids + [0] * (max_seq_length-len(token_ids))<br/>  return input_ids</span><span id="d11c" class="mv lq je mr b gy np mx l my mz">def get_masks(tokens, max_seq_length):<br/>  return [1]*len(tokens) + [0] * (max_seq_length - len(tokens))</span><span id="19e2" class="mv lq je mr b gy np mx l my mz">def get_segments(tokens, max_seq_length):<br/>  """Segments: 0 for the first sequence, 1 for the second""<br/>  segments = []<br/>  current_segment_id = 0<br/>  for token in tokens:<br/>    segments.append(current_segment_id)<br/>    if token == "[SEP]":<br/>      current_segment_id = 1<br/>  return segments + [0] * (max_seq_length - len(tokens))</span><span id="bec3" class="mv lq je mr b gy np mx l my mz">ids = get_ids(stokens, tokenizer, MAX_SEQ_LEN)<br/><strong class="mr jf"># [2, 13, 1, 589, 17378, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</strong></span><span id="ef41" class="mv lq je mr b gy np mx l my mz">masks = get_masks(stokens, MAX_SEQ_LEN)<br/><strong class="mr jf"># [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</strong></span><span id="81a9" class="mv lq je mr b gy np mx l my mz">segments = get_segments(stokens, MAX_SEQ_LEN)<br/><strong class="mr jf"># [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</strong></span></pre><h1 id="f33d" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">3.艾伯特矢量化</h1><p id="9a68" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">现在我们已经准备好了所需的输入处理。我们将使用 tf keras API 建立一个模型，它将接受处理后的输入，并获得文本的 ALBERT 向量。输出艾伯特矢量包含 2 个矢量，一个是汇集输出和序列输出。pooled_output 是维度 1x768 的句子嵌入，序列输出是维度 1x(token_length)x768 的令牌级嵌入。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7bd6" class="mv lq je mr b gy mw mx l my mz">def get_model():<br/>  input_word_ids = tf.keras.layers.Input(shape=(MAX_SEQ_LEN,), dtype=tf.int32,name="input_word_ids")<br/>  input_mask = tf.keras.layers.Input(shape=(MAX_SEQ_LEN,), dtype=tf.int32,name="input_mask")<br/>  segment_ids = tf.keras.layers.Input(shape=(MAX_SEQ_LEN,), dtype=tf.int32,name="segment_ids")</span><span id="2f34" class="mv lq je mr b gy np mx l my mz">  pooled_output, sequence_output = albert_layer([input_word_ids, input_mask, segment_ids])</span><span id="243e" class="mv lq je mr b gy np mx l my mz">  model = tf.keras.models.Model(inputs=[input_word_ids, input_mask,  segment_ids], outputs=[pooled_output, sequence_output])<br/>  return model</span></pre><p id="f35e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">制作 keras 模型的想法是通过添加所需的层和参数，轻松地将其扩展到任何分类模型。</p><p id="fc0f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在所有的艰苦工作都完成了。将只需要一个推理函数来获得文本的相应艾伯特嵌入。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="61ae" class="mv lq je mr b gy mw mx l my mz">s = "This is a nice sentence."</span><span id="9dd2" class="mv lq je mr b gy np mx l my mz">def get_albert_vec(s):<br/>  stokens = tokenizer.tokenize(s)<br/>  stokens = ["[CLS]"] + stokens + ["[SEP]"]<br/>  ids = get_ids(stokens, tokenizer, MAX_SEQ_LEN)<br/>  masks = get_masks(stokens, MAX_SEQ_LEN)<br/>  segments = get_segments(stokens, MAX_SEQ_LEN)<br/>  input_ids = np.asarray(ids, dtype=np.int32).reshape(1,22)<br/>  input_masks = np.asarray(masks, dtype=np.int32).reshape(1,22)<br/>  input_segments = np.asarray(segments, dtype=np.int32).reshape(1,22)<br/>  return input_ids, input_masks, input_segments</span><span id="7e12" class="mv lq je mr b gy np mx l my mz">input_ids, input_masks, input_segments = get_albert_vec(s)<br/>pool_embs, word_embs = albert_model.predict(<br/>      [[input_ids, input_masks, input_segments]]<br/>)</span></pre><p id="f5bc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了快速检查句子嵌入的质量，让我们在一小组示例上运行它，并使用它们对应的归一化句子嵌入向量的点积来检查每对的句子相似性得分。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="13a7" class="mv lq je mr b gy mw mx l my mz">sentences = [<br/># Smartphones<br/>"I like my phone",<br/>"My phone is not good.",</span><span id="1bb9" class="mv lq je mr b gy np mx l my mz"># Weather<br/>"Recently a lot of hurricanes have hit the US",<br/>"Global warming is real",</span><span id="b148" class="mv lq je mr b gy np mx l my mz"># Asking about age<br/>"How old are you?",<br/>"what is your age?"]</span><span id="3637" class="mv lq je mr b gy np mx l my mz">run_and_plot(sentences)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/4daf8c2a6e05220d9a4b22dc66c90f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*MgCEGzIvbJ1xiYXNDKA1kQ.png"/></div></figure><h1 id="14db" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated"><strong class="ak">参考文献</strong></h1><div class="is it gp gr iu nr"><a href="https://github.com/sambit9238/Deep-Learning/tree/master/sarcasm_classifier/albert_tfhub" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd jf gy z fp nw fr fs nx fu fw jd bi translated">sambit 9238/深度学习</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ja nr"/></div></div></a></div><div class="is it gp gr iu nr"><a href="https://medium.com/doxastar/from-bert-to-albert-pre-trained-langaug-models-5865aa5c3762" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd jf gy z fp nw fr fs nx fu fw jd bi translated">从伯特到阿尔伯特:预训练的兰格模型</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">预训练语言模型的研究进展</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of ja nr"/></div></div></a></div><div class="is it gp gr iu nr"><a href="https://ai.googleblog.com/2019/12/albert-lite-bert-for-self-supervised.html" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd jf gy z fp nw fr fs nx fu fw jd bi translated">ALBERT:一个用于语言表达自我监督学习的 Lite BERT</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">自从一年前 BERT 问世以来，自然语言研究已经采用了一种新的范式，利用了大量的…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">ai.googleblog.com</p></div></div><div class="oa l"><div class="oh l oc od oe oa of ja nr"/></div></div></a></div><div class="is it gp gr iu nr"><a href="https://analyticsindiamag.com/googles-nlp-powered-pretraining-method-albert-is-leaner-meaner/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd jf gy z fp nw fr fs nx fu fw jd bi translated">谷歌的 NLP 驱动的预训练方法 ALBERT 更精简&amp;更刻薄</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">自然语言处理(NLP)是新兴技术中最多样化的领域之一。去年，搜索引擎…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">analyticsindiamag.com</p></div></div><div class="oa l"><div class="oi l oc od oe oa of ja nr"/></div></div></a></div><div class="is it gp gr iu nr"><a href="https://amitness.com/2020/02/albert-visual-summary/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd jf gy z fp nw fr fs nx fu fw jd bi translated">视觉论文摘要:阿尔伯特(A Lite BERT)</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">考虑下面给出的一个句子。作为人类，当我们遇到“苹果”这个词时，我们可以:联想“苹果”这个词…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">amitness.com</p></div></div><div class="oa l"><div class="oj l oc od oe oa of ja nr"/></div></div></a></div></div></div>    
</body>
</html>