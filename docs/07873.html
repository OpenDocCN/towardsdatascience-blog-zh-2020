<html>
<head>
<title>Split overlapping bounding boxes in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中分割重叠的边界框</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/split-overlapping-bounding-boxes-in-python-e67dc822a285?source=collection_archive---------34-----------------------#2020-06-11">https://towardsdatascience.com/split-overlapping-bounding-boxes-in-python-e67dc822a285?source=collection_archive---------34-----------------------#2020-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cd35" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从问题公式化到创建PyPI包，使用来自<a class="ae kf" href="https://www.kaggle.com/c/global-wheat-detection" rel="noopener ugc nofollow" target="_blank">全球小麦检测Kaggle竞赛</a>的数据进行测试，分5步完成教程。</h2></div><p id="828b" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在对象检测中，通常使用包围盒目标来识别图像中的对象。这些边界框有时可能会重叠。在一些像<strong class="ki ir"> Mask RCNN </strong>的模型中，边界框被直接预测，边界框的重叠不成问题。另一种可能的方法是将边界框转换为遮罩，并使用语义分割模型，如<strong class="ki ir"> U-Net </strong>。在这种情况下，如果最后你想分离单独的对象，重叠的遮罩可能是一个问题。</p><p id="93ca" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在这个故事中，我将讲述如何用Python开发一个算法来分离重叠的边界框，并在它们之间设置边距。我将使用来自全球小麦检测竞赛的数据。</p><p id="b15c" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">请注意，我并不是说这种方法是小麦检测竞赛的最佳方法。将来，我可能会写另一个关于这个主题的故事。</p><h2 id="631c" class="lc ld iq bd le lf lg dn lh li lj dp lk kp ll lm ln kt lo lp lq kx lr ls lt lu bi translated">目录</h2><ol class=""><li id="9efb" class="lv lw iq ki b kj lx km ly kp lz kt ma kx mb lb mc md me mf bi translated">问题定式化</li><li id="aae2" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb mc md me mf bi translated">写数学</li><li id="da3a" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb mc md me mf bi translated">用Python编写算法代码</li><li id="18f7" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb mc md me mf bi translated">在现实问题中测试代码</li><li id="bfb8" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb mc md me mf bi translated">用<a class="ae kf" href="https://github.com/fastai/nbdev" rel="noopener ugc nofollow" target="_blank"> fastai nbdev </a>创建一个Python包</li></ol><h2 id="de9f" class="lc ld iq bd le lf lg dn lh li lj dp lk kp ll lm ln kt lo lp lq kx lr ls lt lu bi translated">1.问题定式化</h2><p id="b71f" class="pw-post-body-paragraph kg kh iq ki b kj lx jr kl km ly ju ko kp ml kr ks kt mm kv kw kx mn kz la lb ij bi translated">让我们从考虑两个重叠边界框的情况开始。我们想要分开边界框，在它们之间留一些空白，如下图所示。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mo"><img src="../Images/3307b91f509d6d866a141ab7ad8ad5d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVjOpGo6MKWXSDtt3Wg7Zw.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">将两个边界框分开并留有一定边距的示例。图片由作者提供。</p></figure><p id="cd76" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">定义余量的程序如下:</p><ul class=""><li id="a2a8" class="lv lw iq ki b kj kk km kn kp ne kt nf kx ng lb nh md me mf bi translated">考虑由点A和B定义的线——每个边界框的质心——我们称之为AB。</li><li id="91b0" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">然后考虑一条垂直于A和B之间中点的直线——设它为ABp。</li><li id="1a5c" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">最后，上图中的两条线平行于ABp，其距离由我们选择的边距值给出。</li></ul><p id="faff" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在第4节的后面，我将展示该代码可以很容易地应用于多个相交边界框的情况。</p><h2 id="0d1e" class="lc ld iq bd le lf lg dn lh li lj dp lk kp ll lm ln kt lo lp lq kx lr ls lt lu bi translated">2.写数学</h2><p id="bcd8" class="pw-post-body-paragraph kg kh iq ki b kj lx jr kl km ly ju ko kp ml kr ks kt mm kv kw kx mn kz la lb ij bi translated">考虑下面的图像和等式，其中<strong class="ki ir">粗体</strong>符号表示向量。矢量<strong class="ki ir"> AB </strong>就是在第一个等式中定义的从A到B的矢量。然后我们可以考虑一个垂直于<strong class="ki ir"> AB </strong>的向量——我称之为<strong class="ki ir">ABp</strong>——使用第二个等式。最后，盒子A的边缘线上的点M可以由第三个等式定义。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ni"><img src="../Images/028d9d33e6974a09a4ddc8694583c40f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WLMtHSKZ66Sk4SWjZzTAtA.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">边缘线的形成。图片由作者提供。</p></figure><p id="f0a4" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">基本原理是:1)你从A开始；2)你向<strong class="ki ir"> AB </strong>方向移动，但只到了中点的一半；3)你以因子<em class="nj"> m </em>乘以<strong class="ki ir"> AB </strong>方向的单位矢量，向同一个方向稍微向后移动；4)你到达的点就是我定义的m点。</p><p id="5567" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">使用点M和矢量<strong class="ki ir"> ABp </strong> it <strong class="ki ir"> </strong>直接定义边缘线，我将在下一节展示。</p><h2 id="b063" class="lc ld iq bd le lf lg dn lh li lj dp lk kp ll lm ln kt lo lp lq kx lr ls lt lu bi translated">3.用Python编写算法代码</h2><p id="935a" class="pw-post-body-paragraph kg kh iq ki b kj lx jr kl km ly ju ko kp ml kr ks kt mm kv kw kx mn kz la lb ij bi translated">下面的函数接收两个边界框，并返回框a的切片区域。输入框为<a class="ae kf" href="https://shapely.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">形状良好的多边形</a>以及该函数返回的输出。现在让我们一行一行地深入代码。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ul class=""><li id="1342" class="lv lw iq ki b kj kk km kn kp ne kt nf kx ng lb nh md me mf bi translated">第1行:输入是两个包围盒——类型为<a class="ae kf" href="https://shapely.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">形状多边形</a>的<strong class="ki ir"> box_A </strong>和<strong class="ki ir"> box_B </strong>。<strong class="ki ir">边距</strong>设置框之间的距离应该有多大，而<strong class="ki ir"> line_mult </strong>只需要足够高，以保证线条完全穿过多边形。</li><li id="353e" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">第3行:向量AB <strong class="ki ir"> </strong> ( <strong class="ki ir"> vec_AB </strong>)是用盒子的质心定义的。</li><li id="47bb" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">第4行:类似于第3行，但垂直向量(<strong class="ki ir"> vec_ABp </strong>)遵循第2节中的等式。</li><li id="6c87" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">第5行:计算矢量AB的范数，因为稍后会用到它。</li><li id="3efc" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">第6行:根据第2节的等式定义<strong class="ki ir">分割点</strong>(点M)。</li><li id="cc1c" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">线7:使用shapely LineString类定义线，该类允许定义给定两点的线。请注意，这些点也是形状优美的几何图形。因此，该线被定义为从点M减去矢量ABp的倍数直到点M加上矢量ABp的倍数。</li><li id="16e1" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">第8行:一个shapely效用函数被用来将多边形一分为二。</li><li id="d5e3" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">第10行:对于第8行获得的每个多边形，检查是否包含中心点a。</li><li id="4e61" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">第11–15行:在这几行中，我分离了包含中心点的多边形(与此目的相关的一个)，并将其与另一个多边形(不包含中心点)和用于切片的线一起返回。额外返回的对象只是以防将来的应用程序会用到它。</li></ul><h2 id="0046" class="lc ld iq bd le lf lg dn lh li lj dp lk kp ll lm ln kt lo lp lq kx lr ls lt lu bi translated">4.在现实问题中测试代码</h2><p id="cb76" class="pw-post-body-paragraph kg kh iq ki b kj lx jr kl km ly ju ko kp ml kr ks kt mm kv kw kx mn kz la lb ij bi translated">第3节中定义的代码仅适用于两个边界框。为了将它应用于几个边界框，我定义了下面的代码，现在我将简单解释一下。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ul class=""><li id="c0ab" class="lv lw iq ki b kj kk km kn kp ne kt nf kx ng lb nh md me mf bi translated"><strong class="ki ir">intersection _ list</strong>-一个函数计算列表中所有多边形的交集。</li><li id="ea53" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated"><strong class="ki ir"> slice_all </strong> —该函数接收包含图像所有边界框的<a class="ae kf" href="https://geopandas.org/reference/geopandas.GeoDataFrame.html" rel="noopener ugc nofollow" target="_blank">地理数据框</a>(见下表)作为输入，并为每个边界框调用<strong class="ki ir"> slice_one </strong>。<strong class="ki ir"> slice_one </strong>简单地对给定的<strong class="ki ir"> box_A </strong>应用切片框功能，并考虑与之相交的所有框。当有几个相交的盒子时，使用<strong class="ki ir"> intersection_list </strong>函数获得最终的多边形。</li></ul><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/32ca20dfc3a230de8a43efec332eb952.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*hoAk8f7OhSuEk674V99R7Q.png"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">输入地理数据框的示例。图片由作者提供。</p></figure><p id="fde1" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir"> slice_all </strong>的结果是一个类似的地理数据框，但带有切片框。下图显示了原始边界框(左)和slice_all的结果(右)。如您所见，原始数据中有几个重叠区域，但应用刚刚开发的方法后没有重叠区域。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nn"><img src="../Images/96e66c6d763218df58e271d5b48464f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPvMA-UDKCxiyfG0A9BloQ.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">原始边界框(左)和应用所述方法后的结果(右)。图片由作者提供。</p></figure><h2 id="9569" class="lc ld iq bd le lf lg dn lh li lj dp lk kp ll lm ln kt lo lp lq kx lr ls lt lu bi translated">5.用fastai nbdev创建一个Python包</h2><p id="6b71" class="pw-post-body-paragraph kg kh iq ki b kj lx jr kl km ly ju ko kp ml kr ks kt mm kv kw kx mn kz la lb ij bi translated">fastai nbdev 可以说是创建Python包并将其上传到PyPI的最简单、最用户友好的方式。</p><ul class=""><li id="d4b8" class="lv lw iq ki b kj kk km kn kp ne kt nf kx ng lb nh md me mf bi translated">当您开始一个新项目时，请转到<a class="ae kf" href="https://github.com/fastai/nbdev" rel="noopener ugc nofollow" target="_blank"> nbdev </a> instructions，并使用该链接为模板创建一个存储库。这会让你很容易开始。</li><li id="8bb6" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">然后你应该为你的本地机器克隆这个库，<strong class="ki ir"><em class="nj">pip install nbdev</em></strong>并在项目目录下运行<strong class="ki ir"><em class="nj">nbdev _ install _ git _ hooks</em></strong>。</li><li id="218c" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">现在你可以像往常一样打开jupyter笔记本了。<strong class="ki ir"> <em class="nj"> settings.ini </em> </strong>文件包含您需要填写的设置信息，例如项目名称、您的github用户名以及您的软件包要求。</li><li id="099c" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">nbdev模板包括一个<strong class="ki ir"> <em class="nj"> index.ipynb </em> </strong>和一个<strong class="ki ir"><em class="nj">00 _ core . ipynb</em></strong>。这个索引将是GitHub<strong class="ki ir"><em class="nj">readme . MD</em></strong>文件。</li><li id="94de" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">然后在<strong class="ki ir"> <em class="nj"> 00_core.ipynb </em> </strong>上，你可以像往常一样开发你的代码，但是要记得在你的包<strong class="ki ir"> <em class="nj"> core.py </em> </strong>文件中的单元格顶部添加<em class="nj"> #export </em>注释——这个文件是nbdev从笔记本上生成的。<strong class="ki ir">你可以在他们的文档</strong>  <strong class="ki ir">中详细阅读如何使用</strong> <a class="ae kf" href="https://nbdev.fast.ai/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir"> nbdev。我强烈推荐！它将改变你编码的方式。</strong></a></li><li id="f1b4" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">准备就绪后，您可以在终端上运行<strong class="ki ir"><em class="nj">nbdev _ build _ lib</em></strong>和<strong class="ki ir"><em class="nj">nbdev _ build _ docs</em></strong>。然后，您可以提交您的更改并推送到github repo。检查回购，看看是否所有测试都通过了。导入外部包时，一个常见的错误是ModuleNotFoundError。您需要将它们包含在<strong class="ki ir"> <em class="nj"> settings.ini </em> </strong>中的要求下，这样软件包将与所有需要的依赖项一起安装。</li><li id="b6e7" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">当一切正常时，你可以通过运行命令<strong class="ki ir"> <em class="nj"> make pypi </em> </strong>将你的包上传到<a class="ae kf" href="https://pypi.org/" rel="noopener ugc nofollow" target="_blank"> PyPI </a>。但是，如果您以前没有这样做过，您需要在PyPI中创建一个帐户并设置一个配置文件(详细说明在<a class="ae kf" href="https://github.com/fastai/nbdev#adding-your-project-to-pypi" rel="noopener ugc nofollow" target="_blank"> nbdev页面上，这里是</a>)。</li></ul><p id="3b16" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">就是这样！我的包现在在PyPI a<a class="ae kf" href="https://pypi.org/project/splitbbox/" rel="noopener ugc nofollow" target="_blank">t https://pypi.org/project/splitbbox</a>上，可以pip安装了。</p><h2 id="40fb" class="lc ld iq bd le lf lg dn lh li lj dp lk kp ll lm ln kt lo lp lq kx lr ls lt lu bi translated">结束语</h2><ul class=""><li id="4428" class="lv lw iq ki b kj lx km ly kp lz kt ma kx mb lb nh md me mf bi translated">生成上面图片的代码可以在<a class="ae kf" href="https://www.kaggle.com/mnpinto/boudingbox2mask-without-overlap" rel="noopener ugc nofollow" target="_blank">这个Kaggle内核</a>或者<a class="ae kf" href="https://github.com/mnpinto/splitbbox/blob/master/00_core.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</li><li id="afb4" class="lv lw iq ki b kj mg km mh kp mi kt mj kx mk lb nh md me mf bi translated">如果你对未来关于使用<a class="ae kf" href="https://github.com/fastai/fastai2" rel="noopener ugc nofollow" target="_blank"> fastai2 </a>进行<a class="ae kf" href="https://www.kaggle.com/c/global-wheat-detection" rel="noopener ugc nofollow" target="_blank">全球小麦检测Kaggle竞赛</a>的故事感兴趣，请通过突出显示这句话让我知道！</li></ul></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="1802" class="nv ld iq bd le nw nx ny lh nz oa ob lk jw oc jx ln jz od ka lq kc oe kd lt of bi translated">关于我</h1><div class="og oh gp gr oi oj"><a rel="noopener follow" target="_blank" href="/my-3-year-journey-from-zero-python-to-deep-learning-competition-master-6605c188eec7"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">我的3年历程:从零Python到深度学习竞赛高手</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">自从2017年开始学习Python以来，我一直遵循的道路是成为一名独自参加Kaggle比赛的大师…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">towardsdatascience.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox my oj"/></div></div></a></div><p id="6493" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><em class="nj">感谢阅读！祝您愉快！</em></p></div></div>    
</body>
</html>