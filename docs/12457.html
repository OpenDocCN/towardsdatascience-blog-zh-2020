<html>
<head>
<title>Part 1: Import WikiData to Neo4j with Neosemantics library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第 1 部分:用 Neosemantics 库将 WikiData 导入 Neo4j</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/traveling-tourist-part-1-import-wikidata-to-neo4j-with-neosemantics-library-f80235f40dc5?source=collection_archive---------21-----------------------#2020-08-27">https://towardsdatascience.com/traveling-tourist-part-1-import-wikidata-to-neo4j-with-neosemantics-library-f80235f40dc5?source=collection_archive---------21-----------------------#2020-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="dc5c" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/traveling-tourist" rel="noopener" target="_blank">旅游的游客</a></h2><div class=""/><div class=""><h2 id="052f" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">从 WikiData 导入数据并打开街道地图 API，以在 Neo4j 中创建知识图表</h2></div><p id="8d69" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在短暂的暑假之后，我准备了一个新的博客系列。在这第一部分，我们将构建一个位于西班牙的古迹知识图表。你可能知道，我最近对通过<a class="ae lk" href="https://www.wikidata.org/wiki/Wikidata:Main_Page" rel="noopener ugc nofollow" target="_blank">维基数据 API </a>获得的知识财富产生了浓厚的兴趣和敬意。我们将继续完善我们的 SPARQL 语法知识，并从 WikiData API 中获取有关西班牙古迹的信息。我之前并没有意识到这一点，但是收集网上可用的 RDF 数据并将其导入 Neo4j 是一个如此受欢迎的话题，以至于<a class="ae lk" href="https://twitter.com/BarrasaDV" rel="noopener ugc nofollow" target="_blank">Jesus Barrasa</a>博士开发了一个<a class="ae lk" href="https://neo4j.com/labs/neosemantics/4.0/" rel="noopener ugc nofollow" target="_blank"> Neosemantics library </a>来帮助我们完成这个过程。</p><p id="104f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在本系列的下一部分，我们将看看<a class="ae lk" href="https://neo4j.com/docs/graph-data-science/current/" rel="noopener ugc nofollow" target="_blank"> Neo4j 图形数据科学库</a>中可用的寻路算法。</p><h1 id="ac3f" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated">议程</h1><ol class=""><li id="81e0" class="md me iq kq b kr mf ku mg kx mh lb mi lf mj lj mk ml mm mn bi translated">安装新语义库</li><li id="cc70" class="md me iq kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">图形模型</li><li id="0034" class="md me iq kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">构造 WikiData SPARQL 查询</li><li id="463e" class="md me iq kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">导入 RDF 图</li><li id="c7a6" class="md me iq kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">使用 OSM API 进行反向地理编码</li><li id="f47a" class="md me iq kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">验证数据</li></ol><h1 id="ffc3" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated">安装新语义库</h1><p id="56c6" class="pw-post-body-paragraph ko kp iq kq b kr mf ka kt ku mg kd kw kx mt kz la lb mu ld le lf mv lh li lj ij bi translated">在这个博客系列中，我们将使用标准的<a class="ae lk" href="https://neo4j.com/developer/neo4j-apoc/" rel="noopener ugc nofollow" target="_blank"> APOC </a>和<a class="ae lk" href="https://neo4j.com/graph-data-science-library/" rel="noopener ugc nofollow" target="_blank"> GDS </a>库，我们只需在<a class="ae lk" href="https://neo4j.com/download/" rel="noopener ugc nofollow" target="_blank"> Neo4j 桌面</a>应用程序中单击一下就可以安装它们。最重要的是，我们将把<a class="ae lk" href="https://neo4j.com/labs/neosemantics/4.0/" rel="noopener ugc nofollow" target="_blank">新语义</a>库添加到我们的堆栈中。它用于在 Neo4j 环境中与 RDF 数据进行交互。我们可以将 RDF 数据导入 Neo4j，或者以 RDF 格式导出属性图模型。</p><p id="9ebf" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了安装 Neosemantics 库，我们下载了<a class="ae lk" href="https://github.com/neo4j-labs/neosemantics/releases" rel="noopener ugc nofollow" target="_blank">最新版本</a>并将其保存到 Neo4j 插件文件夹中。我们还需要在 Neo4j 配置文件中添加下面一行。</p><p id="19dc" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe mw mx my mz b">dbms.unmanaged_extension_classes=n10s.endpoint=/rdf</code></p><p id="d894" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们现在准备启动我们的 Neo4j 实例。首先，我们需要用下面的 cypher 过程启动新语义配置。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="80b5" class="ni lm iq mz b gy nj nk l nl nm">CALL n10s.graphconfig.init({handleVocabUris: "IGNORE"})</span></pre><p id="1bcb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">查看一下<a class="ae lk" href="https://neo4j.com/labs/neosemantics/4.0/reference/" rel="noopener ugc nofollow" target="_blank">文档</a>中关于配置选项的信息。</p><h2 id="ada1" class="ni lm iq bd ln nn no dn lr np nq dp lv kx nr ns lx lb nt nu lz lf nv nw mb iw bi translated">图形模型</h2><p id="07b7" class="pw-post-body-paragraph ko kp iq kq b kr mf ka kt ku mg kd kw kx mt kz la lb mu ld le lf mv lh li lj ij bi translated">纪念碑在我们图表的中心。我们将它们的名称和图像的 URL 存储为节点属性。这些纪念碑受到了各种建筑风格的影响，我们将其表示为与建筑节点的关系。我们将把城市和州的纪念碑保存为一个两级分层位置树。</p><figure class="na nb nc nd gt ny gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5a50c9137789f8e46a5dc76d4ac3ecf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*Qm5-FfWXrVqY8CwtmBQW0w.png"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">用<a class="ae lk" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a>创建的图形模型</p></figure><p id="58d5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">Neosemantics 库需要对标记为 Resource 的节点的属性“uri”进行唯一约束。我们还将为州和城市节点添加索引。<code class="fe mw mx my mz b">apoc.schema.assert</code>过程允许我们通过一次调用定义许多索引和唯一约束。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="38e4" class="ni lm iq mz b gy nj nk l nl nm">CALL apoc.schema.assert(<br/>  {State:['id'], City:['id']},<br/>  {Resource:['uri']})</span></pre><h2 id="1afe" class="ni lm iq bd ln nn no dn lr np nq dp lv kx nr ns lx lb nt nu lz lf nv nw mb iw bi translated">构造 WikiData SPARQL 查询</h2><p id="4bbe" class="pw-post-body-paragraph ko kp iq kq b kr mf ka kt ku mg kd kw kx mt kz la lb mu ld le lf mv lh li lj ij bi translated">对我来说，构建新的 SPARQL 查询最简单的方法是使用<a class="ae lk" href="https://query.wikidata.org/" rel="noopener ugc nofollow" target="_blank"> WikiData 查询编辑器</a>。它有一个可爱的自动完成功能。它还有助于查询调试。</p><p id="384a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们想要检索位于西班牙<a class="ae lk" href="https://www.wikidata.org/wiki/Q29" rel="noopener ugc nofollow" target="_blank">的</a><a class="ae lk" href="https://www.wikidata.org/wiki/Q4989906" rel="noopener ugc nofollow" target="_blank">古迹</a>的所有实例。我发现在维基数据上找到各种实体最简单的方法就是简单地使用谷歌搜索。然后，您可以在网站上检查该实体的所有可用属性。我第一次看到的 SPARQL 查询如下所示:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="94e0" class="ni lm iq mz b gy nj nk l nl nm">SELECT * <br/>WHERE { ?item wdt:P31 wd:Q4989906 . <br/>        ?item wdt:P17 wd:Q29 . <br/>        ?item rdfs:label ?monumentName . <br/>          filter(lang(?monumentName) = "en") <br/>        ?item wdt:P625 ?location . <br/>        ?item wdt:P149 ?architecture . <br/>        ?architecture rdfs:label ?architectureName . <br/>          filter(lang(?architectureName) = "en") <br/>        ?item wdt:P18 ?image }</span></pre><p id="6f16" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe mw mx my mz b">WHERE</code>子句中的前两行定义了我们要寻找的实体:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="7698" class="ni lm iq mz b gy nj nk l nl nm">// Entity is an instance of monument entity<br/>?item wdt:P31 wd:Q4989906 . <br/>// Entity is located in Spain<br/>?item wdt:P17 wd:Q29 .</span></pre><p id="c27e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">接下来，我们还确定我们感兴趣的实体的属性。在我们的例子中，我们希望检索纪念碑的名称、图像、位置和建筑风格。如果我们在查询编辑器中运行这个查询，我们会得到以下结果。</p><figure class="na nb nc nd gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi of"><img src="../Images/79740fc4677be60ebc3c5fb595f89c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*THapeepDnuge1_Gk.png"/></div></div></figure><p id="c3e7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们已经在 SPARQL 查询的<code class="fe mw mx my mz b">WHERE</code>子句中定义了想要检索的信息。在用新语义导入数据之前，我们需要对数据格式进行一些调整。第一个也是最关键的是将<code class="fe mw mx my mz b">SELECT</code>条款改为<code class="fe mw mx my mz b">CONSTRUCT</code>。这样，我们将得到返回的 RDF 三元组，而不是信息表。你可以在这篇由<a class="ae lk" href="https://twitter.com/markhneedham" rel="noopener ugc nofollow" target="_blank">马克·李约瑟</a>写的<a class="ae lk" href="https://markhneedham.com/blog/2020/02/02/querying-wikidata-construct-select/" rel="noopener ugc nofollow" target="_blank">博客</a>中读到更多关于<code class="fe mw mx my mz b">SELECT</code>和<code class="fe mw mx my mz b">CONSTRUCT</code>的区别。</p><p id="39b2" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">有了 Neosemantics 库，我们可以预览使用<code class="fe mw mx my mz b">n10s.rdf.preview.fetch</code>过程后我们存储的图模型会是什么样子。我们将从检查一个空的<code class="fe mw mx my mz b">CONSTRUCT</code>语句的图表模式开始。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="117e" class="ni lm iq mz b gy nj nk l nl nm">WITH '<br/>CONSTRUCT <br/>WHERE { ?item wdt:P31 wd:Q4989906 .<br/>        ?item wdt:P17 wd:Q29 .<br/>        ?item rdfs:label ?monumentName .<br/>        ?item wdt:P625 ?location .<br/>        ?item wdt:P149 ?architecture .<br/>        ?architecture rdfs:label<br/>        ?architectureName .<br/>        ?item wdt:P18 ?image} limit 10 ' AS sparql<br/>CALL n10s.rdf.preview.fetch(<br/>  "https://query.wikidata.org/sparql?query=" +<br/>     apoc.text.urlencode(sparql),"JSON-LD",<br/>  { headerParams: { Accept: "application/ld+json"} ,<br/>    handleVocabUris: "IGNORE"})<br/>YIELD nodes, relationships<br/>RETURN nodes, relationships</span></pre><p id="4c15" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">结果</p><figure class="na nb nc nd gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi ok"><img src="../Images/198362d2326b98eb0934991aad1dee92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X7Glzd6RQhQW7erS.png"/></div></div></figure><p id="62ca" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">一个问题是节点没有标签。您可能还会注意到，关系类型提供的信息并不多，因为如果您不知道 WikiData 属性映射，P149 或 P31 没有多大意义。另一件事情是，图像的 URL 被存储为一个单独的节点，这一点在这个可视化中并不明显。如果您还记得之前的图形模型，我们决定将图像 URL 保存为 monument 节点的属性。</p><p id="7c11" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我不会讲太多细节，但是在<code class="fe mw mx my mz b">CONSTRUCT</code>子句中，我们可以定义我们的图表模式在 Neo4j 中应该是什么样子。我们还使用以下语法定义了要将图像的 URL 保存为纪念碑节点的属性，而不是单独的节点:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="af4d" class="ni lm iq mz b gy nj nk l nl nm">?item wdt:P18 ?image . <br/>  bind(str(?image) as ?imageAsStr)</span></pre><p id="d9fe" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们现在可以用更新后的<code class="fe mw mx my mz b">CONSTRUCT</code>语句预览新的查询。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="6bfe" class="ni lm iq mz b gy nj nk l nl nm">WITH ' PREFIX sch: &lt;http://schema.org/&gt; <br/>CONSTRUCT{ ?item a sch:Monument; <br/>            sch:name ?monumentName; <br/>            sch:location ?location; <br/>            sch:img ?imageAsStr; <br/>            sch:ARCHITECTURE ?architecture. <br/>          ?architecture a sch:Architecture; <br/>           sch:name ?architectureName } <br/>WHERE { ?item wdt:P31 wd:Q4989906 . <br/>        ?item wdt:P17 wd:Q29 . <br/>        ?item rdfs:label ?monumentName . <br/>          filter(lang(?monumentName) = "en") <br/>        ?item wdt:P625 ?location . <br/>        ?item wdt:P149 ?architecture . <br/>        ?architecture rdfs:label ?architectureName .  <br/>          filter(lang(?architectureName) = "en") <br/>        ?item wdt:P18 ?image . <br/>          bind(str(?image) as ?imageAsStr) } limit 100 ' AS sparql CALL n10s.rdf.preview.fetch(<br/>  "https://query.wikidata.org/sparql?query=" +  <br/>      apoc.text.urlencode(sparql),"JSON-LD", <br/>    { headerParams: { Accept: "application/ld+json"} ,   <br/>      handleVocabUris: "IGNORE"})<br/>YIELD nodes, relationships <br/>RETURN nodes, relationships</span></pre><p id="5f8b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">结果</p><figure class="na nb nc nd gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi ol"><img src="../Images/694cf2fc7fee264b71d368e134a08b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3I_7wqgWxi6irSYp.png"/></div></div></figure><h1 id="ebd8" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated">导入 RDF 图</h1><p id="2b65" class="pw-post-body-paragraph ko kp iq kq b kr mf ka kt ku mg kd kw kx mt kz la lb mu ld le lf mv lh li lj ij bi translated">现在，我们可以将图表导入 Neo4j。我们使用<code class="fe mw mx my mz b">n10s.rdf.import.fetch</code>而不是<code class="fe mw mx my mz b">n10s.rdf.preview.fetch</code>过程，并保持查询的其余部分不变。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="e0f7" class="ni lm iq mz b gy nj nk l nl nm">WITH 'PREFIX sch: &lt;http://schema.org/&gt; <br/>CONSTRUCT{ ?item a sch:Monument; <br/>            sch:name ?monumentName; <br/>            sch:location ?location; <br/>            sch:img ?imageAsStr; <br/>            sch:ARCHITECTURE ?architecture. <br/>           ?architecture a sch:Architecture; <br/>            sch:name ?architectureName } <br/>WHERE { ?item wdt:P31 wd:Q4989906 . <br/>        ?item wdt:P17 wd:Q29 . <br/>        ?item rdfs:label ?monumentName . <br/>         filter(lang(?monumentName) = "en") <br/>        ?item wdt:P625 ?location . <br/>        ?item wdt:P149 ?architecture . <br/>        ?architecture rdfs:label ?architectureName .<br/>         filter(lang(?architectureName) = "en") <br/>        ?item wdt:P18 ?image . <br/>         bind(str(?image) as ?imageAsStr) }' AS sparql <br/>CALL n10s.rdf.import.fetch(<br/>  "https://query.wikidata.org/sparql?query=" +   <br/>   apoc.text.urlencode(sparql),"JSON-LD", <br/>   { headerParams: { Accept: "application/ld+json"} , <br/>     handleVocabUris: "IGNORE"}) <br/>YIELD terminationStatus, triplesLoaded<br/>RETURN terminationStatus, triplesLoaded</span></pre><p id="fef3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们从一些探索性的图查询开始。我们将首先计算图表中纪念碑的数量。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="ee25" class="ni lm iq mz b gy nj nk l nl nm">MATCH (n:Monument) <br/>RETURN count(*)</span></pre><p id="fcde" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们已经将 1401 个纪念碑导入到我们的图表中。我们将继续计算按建筑风格分组的纪念碑的数量。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="6411" class="ni lm iq mz b gy nj nk l nl nm">MATCH (n:Architecture) <br/>RETURN n.name as monument, <br/>       size((n)&lt;--()) as count <br/>ORDER BY count DESC <br/>LIMIT 5</span></pre><p id="433e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">结果</p><figure class="na nb nc nd gt ny"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="1fc8" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">罗马式和哥特式建筑风格影响了大多数纪念碑。当我探索 WikiData 时，我注意到一种架构风格可以是其他架构风格的子类。作为练习，我们将把架构层次关系导入到我们的图表中。在我们的查询中，我们将迭代存储在图中的所有架构风格，并从 WikiData 中获取任何父架构风格，并将其保存回我们的图中。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="8124" class="ni lm iq mz b gy nj nk l nl nm">MATCH (a:Architecture) <br/>WITH ' PREFIX sch: &lt;http://schema.org/&gt; <br/>CONSTRUCT { ?item a sch:Architecture; <br/>             sch:SUBCLASS_OF ?style. <br/>            ?style a sch:Architecture; <br/>             sch:name ?styleName;} <br/>WHERE { filter (?item = &lt;' + a.uri + '&gt;) <br/>        ?item wdt:P279 ?style . <br/>        ?style rdfs:label ?styleName <br/>         filter(lang(?styleName) = "en") } ' AS sparql <br/>CALL n10s.rdf.import.fetch(<br/>  "https://query.wikidata.org/sparql?query=" + <br/>    apoc.text.urlencode(sparql),"JSON-LD", <br/>  { headerParams: { Accept: "application/ld+json"} , <br/>    handleVocabUris: "IGNORE"}) <br/>YIELD terminationStatus, triplesLoaded <br/>RETURN terminationStatus, triplesLoaded</span></pre><p id="3cf3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们现在可以看一些架构层次的例子。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="a5a5" class="ni lm iq mz b gy nj nk l nl nm">MATCH (a:Architecture)-[:SUBCLASS_OF]-&gt;(b:Architecture)<br/>RETURN a.name as child_architecture,<br/>       b.name as parent_architecture<br/>LIMIT 5</span></pre><p id="8b86" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">结果</p><figure class="na nb nc nd gt ny"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="15a5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">似乎现代主义是新艺术的子范畴，新艺术是装饰艺术的子范畴。</p><h1 id="3e84" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated">空间丰富</h1><p id="a4d8" class="pw-post-body-paragraph ko kp iq kq b kr mf ka kt ku mg kd kw kx mt kz la lb mu ld le lf mv lh li lj ij bi translated">起初，我想在维基数据中包含一些市政信息，但是事实证明，这些信息相对较少。不过不用担心，我后来意识到我们可以使用反向地理编码 API 来检索这些信息。APOC 有专门的反向地理编码程序。默认情况下，它使用开放的街道地图 API，但我们也可以定制它来与其他提供商合作。查看<a class="ae lk" href="http://neo4j-contrib.github.io/neo4j-apoc-procedures/3.5/utilities/spatial/#_configuring_custom_geocode_provider" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多信息。</p><p id="2ff3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">首先，我们必须将位置信息转换为空间点数据类型。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="f5cc" class="ni lm iq mz b gy nj nk l nl nm">MATCH (m:Monument) <br/>WITH m, <br/>   split(substring(m.location, 6, size(m.location) - 7)," ") as point <br/>SET m.location_point = point(<br/>  {latitude: toFloat(point[1]), <br/>   longitude: toFloat(point[0])})</span></pre><p id="6a9d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">查看 OSM 反向地理编码 API 的示例响应。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="dd55" class="ni lm iq mz b gy nj nk l nl nm">MATCH (m:Monument)<br/>WITH m LIMIT 1<br/>CALL apoc.spatial.reverseGeocode(<br/>  m.location_point.latitude,<br/>  m.location_point.longitude)<br/>YIELD data<br/>RETURN data</span></pre><p id="3e21" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">结果</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="ab5c" class="ni lm iq mz b gy nj nk l nl nm">{   <br/>    "country": "España",   <br/>    "country_code": "es",<br/>    "isolated_dwelling": "La Castanya",<br/>    "historic": "Monument als caiguts en atac Carlista 1874",      <br/>    "road": "Camí de Collformic a Matagalls",   <br/>    "city": "el Brull",<br/>    "municipality": "Osona",<br/>    "county": "Barcelona",<br/>    "postcode": "08559",<br/>    "state": "Catalunya" <br/>}</span></pre><p id="bf87" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">开放街道地图 API 有点有趣，因为它在城市、城镇和村庄之间有所不同。此外，位于加那利群岛的纪念碑没有国家可用，但却是加那利群岛的一部分。我们将把群岛作为一个州，把城市、城镇和村庄放在一个标签下。出于批处理的目的，我们将使用<code class="fe mw mx my mz b">apoc.periodic.iterate</code>程序。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="3104" class="ni lm iq mz b gy nj nk l nl nm">CALL apoc.periodic.iterate(<br/>  'MATCH (m:Monument) RETURN m',<br/>  'WITH m<br/>   CALL apoc.spatial.reverseGeocode(<br/>      m.location_point.latitude,m.location_point.longitude)<br/>    YIELD data<br/>   WHERE (data.state IS NOT NULL OR <br/>          data.archipelago IS NOT NULL)<br/>   MERGE (s:State{id:coalesce(data.state, data.archipelago)})<br/>   MERGE (c:City{id:coalesce(data.city, data.town, <br/>                             data.village, data.county)})<br/>   MERGE (c)-[:IS_IN]-&gt;(s)<br/>   MERGE (m)-[:IS_IN]-&gt;(c)',<br/>   {batchSize:10})</span></pre><p id="c802" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">该查询将花费很长时间，因为默认的限制延迟设置是 5 秒。如果您没有时间等待，我已经将空间结果保存到 GitHub 中，您可以在不到五秒钟的时间内使用以下查询轻松导入它们。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="ed26" class="ni lm iq mz b gy nj nk l nl nm">LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blogs/master/Traveling_tourist/traveling_tourist_cities.csv" as row<br/>MATCH (m:Monument{uri:row.uri})<br/>MERGE (c:City{id:row.city})<br/>MERGE (s:State{id:row.state})<br/>MERGE (m)-[:IS_IN]-&gt;(c)<br/>MERGE (c)-[:IS_IN]-&gt;(s);</span></pre><p id="37c1" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们将首先检查是否有任何遗迹的空间价值缺失。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="e6a6" class="ni lm iq mz b gy nj nk l nl nm">MATCH (m:Monument) <br/>RETURN exists ((m)-[:IS_IN]-&gt;()) as has_location, <br/>       count(*) as count</span></pre><p id="75e0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">结果</p><figure class="na nb nc nd gt ny"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="51d1" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们已经检索了几乎所有遗迹的空间信息。创建位置层次结构树时需要注意的是，树中的每个节点与其父节点只有一个传出关系。如果这个规则被打破，位置树的结构完整性将丢失，因为一些实体将具有不止一个位置。查看我的<a class="ae lk" href="https://tbgraph.wordpress.com/2017/04/01/neo4j-location-trees/" rel="noopener ugc nofollow" target="_blank">位置树帖子</a>获取更多关于如何绕过这个问题的信息。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="f546" class="ni lm iq mz b gy nj nk l nl nm">MATCH (c:City)<br/>WHERE size((c)-[:IS_IN]-&gt;()) &gt; 1<br/>RETURN c</span></pre><p id="574f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">幸运的是，我们在这里没有遇到这个问题。我们现在可以探索我们的空间丰富的结果。我们将看看位于加泰罗尼亚的按照建筑风格分组的古迹数量。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="d8bf" class="ni lm iq mz b gy nj nk l nl nm">MATCH (s:State{id:'Catalunya'})&lt;-[:IS_IN*2..2]-(:Monument)-[:ARCHITECTURE]-&gt;(architecture)<br/>RETURN architecture.name as architecture,<br/>       count(*) as count<br/>ORDER BY count DESC<br/>LIMIT 5</span></pre><p id="9982" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">结果</p><figure class="na nb nc nd gt ny"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="d82a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们快速看一下维基百科对教育目的的乡土建筑的定义。</p><blockquote class="oo op oq"><p id="61d3" class="ko kp or kq b kr ks ka kt ku kv kd kw os ky kz la ot lc ld le ou lg lh li lj ij bi translated">乡土建筑是以使用当地材料和知识为特征的建筑，通常没有专业建筑师的监督。</p></blockquote><p id="4141" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们还可以看看各州最常见的纪念碑建筑风格。我们将使用 Neo4j 4.0 中引入的子查询语法。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="3552" class="ni lm iq mz b gy nj nk l nl nm">MATCH (s:State)<br/>CALL {<br/>  WITH s<br/>  MATCH (s)&lt;-[:IS_IN*2..2]-()-[:ARCHITECTURE]-&gt;(a)<br/>  RETURN a.name as architecture, count(*) as count<br/>  ORDER BY count DESC LIMIT 1<br/>}<br/>RETURN s.id as state, architecture, count<br/>ORDER BY count DESC <br/>LIMIT 5</span></pre><p id="c92b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">结果</p><figure class="na nb nc nd gt ny"><div class="bz fp l di"><div class="om on l"/></div></figure><h1 id="e3e0" class="ll lm iq bd ln lo lp lq lr ls lt lu lv kf lw kg lx ki ly kj lz kl ma km mb mc bi translated">结论</h1><figure class="na nb nc nd gt ny gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi ov"><img src="../Images/9fe0f15b1abb86200336b20f28b2c664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oorJPCQYYgYF1X2F2uLIMA.png"/></div></div></figure><p id="558f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果你遵循了这篇文章中的步骤，你的图表应该看起来像上面的图片。我总是对只用 cypher 从各种 API 获取数据是如此容易印象深刻。如果您想调用任何自定义端点，您仍然可以使用<code class="fe mw mx my mz b">apoc.load.json</code>过程。</p><p id="e08b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在下一部分，我们将深入研究寻路算法。与此同时，<a class="ae lk" href="https://neo4j.com/try-neo4j/" rel="noopener ugc nofollow" target="_blank">试试 Neo4j </a>，加入<a class="ae lk" href="https://neo4j.com/tag/twin4j/" rel="noopener ugc nofollow" target="_blank"> Twin4j 简讯</a>。</p><p id="e93b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">和往常一样，代码可以在<a class="ae lk" href="https://github.com/tomasonjo/blogs/blob/master/Traveling_tourist/Part1%20-%20Import%20knowledge%20graph.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>