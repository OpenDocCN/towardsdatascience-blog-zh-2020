# 雅可比迭代和谱半径

> 原文：<https://towardsdatascience.com/jacobi-iteration-and-spectral-radius-b35d33f95573?source=collection_archive---------18----------------------->

## 求解大型线性方程组的一种方法。

![](img/671affd5553249e32b0918eaaff226e4.png)

资料来源:Huskyherz，via pixabay (CCO)

数值分析的主要支柱之一是求解大型线性方程组。为了解决这种系统，数值分析人员实施了多种方法；然而，我们今天要看的是雅可比迭代。

**问题陈述:**

大型线性系统可以很容易地用“Ax=b”形式的矩阵表示，其中“A”表示包含线性方程组有序系数的方阵，“x”表示所有不同的变量，“b”表示每个线性方程等于的常数。我们希望求解未知的 x 值，我们可以通过使用雅可比迭代来实现。

## **雅可比迭代:**

为了全面理解雅可比迭代，我们必须首先理解不动点迭代。这两种方法使用相同的方案，但是雅可比迭代可以应用于更大的方程组。在不动点迭代中，主要思想是取一个方程，用 Xn+1 = F(Xn)来排列，这样从某个初始 x 值(Xn)开始，代入 F(Xn)方程，我们得到一个新值(Xn+1)，然后用这个新值作为下一个 x 值代入 F(Xn)，以此类推。我们可以重复这个过程，直到方程的两边变得相等或大致相等，在这种情况下，我们就达到了我们的不动点解。下面是一个算出的小例子。这种方法并不总是收敛，并且有某些测试来确定它是否会收敛；然而，我们将坚持用这个简单的解释来总结现在的主要思想。

![](img/62320b3391e6726e1b7c9b18adb6de99.png)

现在，让我们看看在下面的例子中 Jacobi 迭代利用不动点迭代原理的方式。

**方程组示例:**

![](img/01a9fad88afa92b42aeaf6390719246b.png)

对于雅可比迭代，就像普通的不动点迭代一样，我们感兴趣的是获得一个方程，并重新排列它，使它采用 Xn+1 = F(Xn)的形式。唯一的区别是，使用雅可比迭代，我们不只是对一个方程进行迭代，而是对方程组中的每个方程进行迭代，因此每个方程都等于一个唯一的变量(一个方程等于 x1，另一个方程等于 x2，依此类推)。方程式的重组如下所示。

![](img/0b4cbb14f60c11d9d446c6fd2a4b68ab.png)![](img/61b81008b6c7d0d72777124b8c6d336b.png)

左边的方程组和右边的方程组没有什么不同。右边的系统是这样写的，更容易展示我们迭代这些方程的方式，以及它与定点迭代的关系。

为了迭代这个系统，我们可以从 X1、X2 和 X3 的一组初始值开始，并将这些值代入我们的方程。然后，我们可以使用我们的新值，并再次将它们放回等式中。如下所示，对最初的几次迭代重复这个过程。

![](img/ad91a1fc8b9c76d70d3e37b680805e50.png)![](img/9ef9248b0e18e276075bb118286122f5.png)

假设我们的方程组使用雅可比迭代收敛，如果我们继续这个过程，最终我们将收敛到我们的解，或者合理地接近给定的容差。虽然从概念上讲，这个过程非常简单，但是在检查收敛是否实际可行时，还是有一点细微的差别。

**形式雅可比迭代方程:**

雅可比迭代法可以用下面的等式来概括。“A”变量代表系数矩阵“A”的元素，“x”变量代表我们正在求解的未知 x 值，“b”代表每个方程的常数。

![](img/2dab340b7384fbfdcd4ae7a432576c44.png)![](img/cd7597751ae1c33be84ebcddfff8e635.png)

通过应用上面的雅可比迭代方程，我们得到了与之前在讨论不动点迭代和雅可比迭代之间的关系时从概念上导出的结论相同的结论。

![](img/bfc103f898dc9b87cda00070bc91bd90.png)![](img/eb01ff33578a98bdec7899bc9bd3259d.png)

我们的雅可比迭代公式的结果(左)。我们的 Jacobi 迭代的结果从概念上导出(右)。两者产生相同的结果，雅可比迭代公式只是使计算更简单，如果我们有一个非常大的线性系统。

**什么是“T”矩阵？为什么重要？:**

虽然雅可比迭代的实现非常简单，但是该方法不会总是收敛到一组解。由于这个事实，在实现雅可比迭代之前必须进行收敛测试。这个收敛测试完全依赖于一个叫做“T”矩阵的新矩阵。以雅可比迭代的矩阵表示为例。

![](img/d26a8f6788a66f83aeb94748c65508a2.png)

我们可以把这个方程组重新写成这样，把整个系统分解成“Xn+1 = TXn + c”的形式。换句话说，我们可以将等式右边的矩阵分解成系数矩阵和常数矩阵。流程如下所示。稍后将会展示为什么为了测试收敛性，将我们的方程组变成这种形式(Xn+1=TXn + c)是至关重要的。

![](img/3fa5f82f1f3f1ab8dfcc15d7578ac11c.png)![](img/2dda1b3a4f6ee2fa3c3f0ac577e390b1.png)

对于我们的具体例子，分解成这种形式的雅可比迭代矩阵将完全等价于

![](img/99515630be6e43fa51b37847509b06c8.png)

其中:

![](img/81b7ae33dc34293275827c5b69dc4701.png)

虽然上面的推导对于理解矩阵“T”的来源非常有用，但是没有必要每次都这样做以便实际找出矩阵“T”是什么。更确切地说，下面的步骤可以用来以更加简单和及时的方式填充“T”矩阵的每个元素。

![](img/5a9f2d25a12482d7d1b6da66dabf98ac.png)

这里小写的“a”代表我们更大的系数矩阵 a 的元素。

“T”矩阵极其重要，因为**我们的雅可比迭代方法收敛所需要的就是我们的矩阵“T”的谱半径严格小于 1。**

方阵的谱半径简单地定义为其特征值的最大绝对值。下面的证明展示了为什么我们首先求解矩阵“T”是如此重要，以及它与谱半径的关系如何创造了谱半径必须小于 1 的条件，如果我们希望看到我们的方法收敛的话。

**雅可比迭代的收敛性检验:**

![](img/9a51a33cb74c4421c86807fe609128c6.png)![](img/deea1248e6bfecfd428b7868ea129756.png)![](img/7a05e861ca5bc321ee4a7ea39d3cb181.png)

既然我们知道了如何测试收敛性(更重要的是，我们为什么要使用这种特定的测试)，我们就可以用我们的示例方程组来这样做了。我们已经解决了前面的“T”矩阵，所以剩下要做的就是找到它的所有特征值，并确保它们的绝对值严格小于 1。

下面列出了我们示例中“T”矩阵的特征值。

![](img/b6c210ba85c2c56f66d9e8d45f7d4fb6.png)

因为它们的绝对值都小于 1，我们的 Jacobi 迭代方法将收敛，剩下要做的就是实现一些 Python 代码来为我们运行迭代。

**实施:**

```
import math
import numpy as npdef JacobiIteration(n):
    x1 = np.zeros(n)
    x2 = np.zeros(n)
    x3 = np.zeros(n)

    for i in range(0,n-1):
        x1[i+1] = -x2[i] - 0.5*x3[i] + 3
        x2[i+1] = 0.5*x1[i] - 0.5*x3[i] + 1.5
        x3[i+1] = -0.5*x1[i] - x2[i] + 3.5
    print ("Our x1 value is",x1[-1],
           "\nOur x2 value is",x2[-1],
           "\nOur x3 value is",x3[-1])JacobiIteration(60)
```

在大约 60 次迭代之后，对于我们所有的 x 值，**从最初的零猜测开始**，我们可以看到，在给定计算机机器精度的情况下，我们已经收敛到我们的解。

![](img/022c100ab7bc08c7ade149a033412957.png)

在左边的图像中，我们可以看到每次迭代的输出。这仅仅是大约 30 次迭代，我们仍然处于极高的精确度之内。数组从上到下的顺序是 x1、x2、x3。他们一行一行地读，从左到右。

这就是雅可比迭代的全部内容。我们得到一个方程组，稍微重新排列一下，测试一下收敛性，运行一点代码，然后我们就完成了。

引用:

伯顿、理查德·l 和 j·道格拉斯。费尔斯。数值分析，作者理查德·l·伯顿，j·道格拉斯·费尔斯。第 9 版。布鲁克斯/科尔出版社，2010 年。第 452 页

Hector D. Ceniceros，2020 年，第 10.9 章:线性迭代方法的收敛性，讲义，数值分析 104B，加州大学圣巴巴拉分校，2020 年 2 月发表。