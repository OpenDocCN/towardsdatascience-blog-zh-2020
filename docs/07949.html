<html>
<head>
<title>Predicting Forest Cover Type with Tensorflow and model deployment in GCP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用张量流预测GCP森林覆盖类型及模型部署</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predicting-forest-cover-type-with-tensorflow-and-model-deployment-in-gcp-fbce9c047dcc?source=collection_archive---------43-----------------------#2020-06-12">https://towardsdatascience.com/predicting-forest-cover-type-with-tensorflow-and-model-deployment-in-gcp-fbce9c047dcc?source=collection_archive---------43-----------------------#2020-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1334" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过Kaggle竞赛开始使用Tensorflow并了解如何在GCP部署模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/accebbf32602c41d40d0c7b221e4d2eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMLGpI6kx6Wiqu2eNHSMCA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ky kz ep" href="https://medium.com/u/cb4f6856d71b?source=post_page-----fbce9c047dcc--------------------------------" rel="noopener" target="_blank">迪皮卡·巴德</a>利用张量流进行森林覆盖类型分类</p></figure><p id="2bb9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这篇文章中，我将分享:</p><ol class=""><li id="03b7" class="lw lx it lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">我如何开始使用Tensorflow</li><li id="b4e0" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">用深度学习解决一个卡格竞赛</li><li id="6eb7" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">在GCP部署模型</li><li id="b742" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">在GCP为曼梯·里建一条管道</li></ol><p id="4819" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">本项目使用的数据来自<a class="ae mk" href="https://www.kaggle.com/c/forest-cover-type-prediction/data" rel="noopener ugc nofollow" target="_blank">森林覆盖类型的Kaggle竞赛。</a>虽然这不是Kaggle上的一个活跃的竞争，但这正好符合我的数字/分类数据标准，可以很容易地进行预测，因此我们可以专注于在Tensorflow中建立模型，并为GCP建立一个小管道。数据的详细信息在其数据描述页面上提供。数据由美国地质调查局和USFS(林务局)提供。本问题将预测七种森林覆盖类型:</p><blockquote class="ml mm mn"><p id="1096" class="la lb mo lc b ld le ju lf lg lh jx li mp lk ll lm mq lo lp lq mr ls lt lu lv im bi translated">1 —云杉/冷杉<br/> 2 —黑松<br/> 3 —黄松<br/> 4 —杨木/柳树<br/> 5 —白杨<br/> 6 —花旗松<br/> 7 —克鲁姆霍尔茨</p></blockquote><p id="4a68" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我将通过以下步骤来解决这个问题:</p><ol class=""><li id="7100" class="lw lx it lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">正在加载数据集</li><li id="fd21" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">预处理数据集</li><li id="6100" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">Tensorflow入门</li><li id="c8ca" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">创建张量流数据集</li><li id="d3e4" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">用Keras建模</li><li id="3943" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">训练模型</li><li id="c5ab" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">测试模型</li><li id="fdcc" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">向Kaggle提交结果</li><li id="2f98" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">在GCP部署模型</li></ol><h1 id="c1da" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">1.正在加载数据集</h1><p id="db04" class="pw-post-body-paragraph la lb it lc b ld nk ju lf lg nl jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">从上述Kaggle竞赛中下载数据，并将其存储在您的google drive或本地的适当文件夹中。将文件夹路径设置为<code class="fe np nq nr ns b">FOLDER_NAME</code>变量。在我的例子中，我将数据存储在google drive中，并使用Google Colab读取输入文件。如果你想在Kaggle笔记本上写代码，你可以按照我在Kaggle<a class="ae mk" href="https://www.kaggle.com/dipikabaad0107/forest-cover-classification" rel="noopener ugc nofollow" target="_blank">和本文一起发表的代码来写。这些变化仅发生在Kaggle笔记本电脑加载和存储数据的情况下。</a></p><p id="634b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们从安装驱动器开始使用Google Colab:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2732" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这将给出一个链接，以获取代码，你需要输入到输入框出现。一旦完成，我们就可以在dataframe中加载数据了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c7d2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/c4f38c4e1c00dcf4aa97608e6e6fe033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YpAuxpm9pOMzEBHY1cV28w.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/4d2d3db9ec6acdec32a98e10e57fb124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MAgkaKLenyrm1ecuZO1TkA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">部分输出</p></figure><p id="fe3b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">训练数据集有15120行。从描述表中可以看出，土壤类型7和15具有恒定的0值，因此应将其移除。除了分类列(<code class="fe np nq nr ns b">Soil_Types</code>和<code class="fe np nq nr ns b">Wilderness_Areas</code>)之外，一些具有数值的列应该被规范化以获得更好的结果。在下一步中，我们将执行所有的预处理步骤，以便为预测准备好数据。</p><h1 id="63f7" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">2.预处理数据集</h1><p id="4c7b" class="pw-post-body-paragraph la lb it lc b ld nk ju lf lg nl jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">所有土壤类型的类别数据列将从一个热编码表合并为一列，类似的荒野区域列也将被转换。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c037" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/26e67af1721b5891b83d50e1c905a641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hoitk867ZJIdKQU5Fge9UA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/3c1de2d89160b98b51eb88a34435f627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sGVP1vUHTp9i3ElYCaw3OA.png"/></div></div></figure><p id="698f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">土壤类型8和25每种类型只有一行，因此它们被转换成另一列，标有NA下标。这是可选的，您也可以删除这些列。</p><p id="98ca" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于数字列，<code class="fe np nq nr ns b">MinMaxScaler</code>是将被应用来获得标准化列的转换器。在此之前，我们需要将数据分为训练、测试和验证，以便对这些数据进行标准化。</p><h2 id="55ee" class="nz mt it bd mu oa ob dn my oc od dp nc lj oe of ne ln og oh ng lr oi oj ni ok bi translated">将数据分为训练、val和测试</h2><p id="d67b" class="pw-post-body-paragraph la lb it lc b ld nk ju lf lg nl jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">数据将分为训练、验证和测试。培训占60%，测试占20%，验证占20%。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cfcf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/3ceb6d8bf8797741f3b78e11b1d9d2a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vn321UPg8q75otcoAIMGDA.png"/></div></div></figure><p id="dbc4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一旦数据被分割，归一化可以应用如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="a05b" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">3.Tensorflow入门</h1><p id="ce33" class="pw-post-body-paragraph la lb it lc b ld nk ju lf lg nl jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">Tensorflow是谷歌基于Theano (Python库)的开源深度学习库，用于研究和生产。你需要知道的一些核心组件是张量和图形。张量是一个n维向量或矩阵，用于存储数据和执行功能。Graph是描述节点之间所有操作和连接的地方，可以在多个CPU或GPU上运行。</p><p id="d4aa" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这篇文章中，我将解释我如何使用Tensorflow创建我的第一个模型，而不是tensorflow的基础知识。如果你有兴趣学习，可以从<a class="ae mk" href="https://www.tensorflow.org/overview" rel="noopener ugc nofollow" target="_blank">这里</a>过基础教程。我必须承认浏览Tensorflow文档不像PyTorch那么容易。使用PyTorch，我能够在一周内构建我的第一个模型，但使用Tensorflow文档，很难理解加载数据本身的正确方式，此外，函数格式之间存在冲突，并且它与其他版本的向后兼容性也存在问题。因此，接下来的教程将会导致其他不容易解决的错误。</p><p id="d37f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在你的机器或谷歌Colab中安装tensorflow。我用过Google Colab搭配GPU运行时。这个问题用的是Tensorflow 2。</p><pre class="kj kk kl km gt om ns on oo aw op bi"><span id="8276" class="nz mt it ns b gy oq or l os ot">!pip install tensorflow</span></pre><h1 id="b2c7" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated"><strong class="ak"> 4。创建张量流数据集</strong></h1><p id="83e4" class="pw-post-body-paragraph la lb it lc b ld nk ju lf lg nl jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">在所有的处理之后，我们将把数据放入<a class="ae mk" href="https://www.tensorflow.org/api_docs/python/tf/data/Dataset" rel="noopener ugc nofollow" target="_blank"> tensorflow数据集</a>。这将有助于<a class="ae mk" href="https://www.tensorflow.org/tutorials/structured_data/feature_columns" rel="noopener ugc nofollow" target="_blank">构建模型的输入管道</a>。对于数据集，必须定义batch_size，这是可以成批而不是一次访问数据的大小。你也可以随意调整行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c6b8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/d28e63cd9f3894a03122e4df6347af1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LI7C0UcyNw2fQIjjf-BwVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">输出的一部分(水平方向的列名无法放入一个屏幕截图中)</p></figure><h1 id="b51e" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">5.用Keras建模</h1><p id="f66a" class="pw-post-body-paragraph la lb it lc b ld nk ju lf lg nl jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">将使用具有前馈神经架构的tensorflow Keras构建模型。使用tensorflow Keras <code class="fe np nq nr ns b">layers.DenseFeatures</code>构建要素图层。分类列和数字列被分别处理，以创建代码中所示的输入层。模型在<code class="fe np nq nr ns b">build_model </code>函数中定义，具有100和50两个隐藏层，后面是包含输出神经元数量为8的输出层。它是8，因为类型是从1到8的整数值，而不是0到7。在混淆矩阵中，我们忽略了类0。使用优化器<code class="fe np nq nr ns b">adam</code>和激活功能<code class="fe np nq nr ns b">relu</code>。建筑模型和管线的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="a54c" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">6.训练模型</h1><p id="2ecf" class="pw-post-body-paragraph la lb it lc b ld nk ju lf lg nl jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">对于训练，我们为模型的拟合函数提供训练和验证数据集。验证损失使得在训练期间更容易发现模型的过度拟合。模型被训练100个纪元。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1965" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/1327ad63ad879c6a9644053018231f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKt8o8fRkI19Je8CSIuw1A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">部分输出</p></figure><p id="3965" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在输出中，很明显，网络是基于随着验证精度增加的训练精度来学习的。如果在某个点上，验证准确性在增加，而训练准确性在增加，那么这就是模型过度拟合的点。这样你就能知道在那个时候停止纪元。如果它是随机的，那么这个模型没有学到任何东西。有了设计好的架构，我在训练集和验证集上的准确率分别达到了85%和84%。</p><p id="802a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在模型摘要中，您可以看到每一层的参数数量。在第一个隐藏层中，51个输入特征连接到100个隐藏节点，对于完全连接的网络具有5100个权重，对于每个节点具有100个偏差参数，总计5200个参数。在下一层中，100个节点连接到50个节点，具有5000个连接，第二隐藏层中的每个节点具有50个偏置参数，构成5050个参数。类似地，计算下一批参数。这就是你阅读模型摘要的方式。它显示最后学习了多少个参数。最后模型被保存到一个目录中。</p><h1 id="7f66" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">7.测试模型</h1><p id="fc95" class="pw-post-body-paragraph la lb it lc b ld nk ju lf lg nl jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">为了测试模型如何处理测试数据，我们将对sklearn的报告进行分类。分类报告将显示每种森林覆盖类型的精确度、召回率和f1分数以及平均精确度等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b4ba" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/137964e8bab23feca1a345d4ae8e3a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qrG37tlew8E_nuJafOpq0Q.png"/></div></div></figure><p id="3ccf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">该模型的平均准确率达到了80%左右。对于前馈神经网络的简单结构，这是足够好的结果。现在，我们可以使用模型获得kaggle测试数据集的结果，并将其提交给kaggle。</p><h1 id="33e4" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">8.向Kaggle提交结果</h1><p id="8814" class="pw-post-body-paragraph la lb it lc b ld nk ju lf lg nl jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">我们需要预测kaggle上给出的测试数据的封面类型。该数据与第一步中下载的数据位于同一文件夹中。预期的输出是包含<code class="fe np nq nr ns b">Id</code>和<code class="fe np nq nr ns b">Cover_Type</code>列的csv文件。对训练数据进行的类似转换必须对测试数据进行。以下代码显示了如何获取测试数据的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3f27" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/329adcbfd2b8ef2e833c3e8dc94b6e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5A23A_A7SZejRVKoO6ISSw.png"/></div></div></figure><p id="6d6f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一旦你准备好了文件，你可以把它上传到Kaggle竞赛页面的我的提交部分。一旦提交，你可以在一段时间后看到分数。提交后，我在测试数据上得到了~62%的准确率。你可以用不同的实验做尽可能多的提交，努力提高这个分数。就这些，你可以开始参加不同的比赛，用不同种类的数据集做实验。我从有数字/分类数据的简单预测问题开始。我的目标是通过一个真实世界的例子来学习张量流，所以我从Kaggle竞争数据集开始，该数据集并不活跃，但有简单的问题需要处理。</p><h1 id="2f5a" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">9.在GCP部署模型</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/7e0e2b9d5bd7d13a5c2fb122d72922f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*I75jQuRh1R3_LvrW532UoQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">谷歌人工智能平台</p></figure><p id="2bdd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">前一节中保存的模型可用于部署在google cloud中，以便您拥有的任何应用程序都可以访问它。我认为你对谷歌云有基本的了解，并且在这方面有所建树。正如我不会解释的那样，如何开始学习GCP(你可以在coursera / GCP Qwiklabs上学习很多入门课程)。</p><p id="dc39" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">先决条件:</strong></p><p id="220f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可以创建一个免费的谷歌云账户，如果你还没有的话，它有300美元的免费信用。在接下来的步骤中，我们需要这一点。同时在你的电脑上安装GCP软件开发工具包。如果没有项目，在Google Cloud中创建一个项目。确保在IAM中下载一个服务帐户密钥，并存储在环境变量中。(关于通过命令控制台与GCP交互的基本设置，请参考谷歌云文档)</p><pre class="kj kk kl km gt om ns on oo aw op bi"><span id="1510" class="nz mt it ns b gy oq or l os ot">export GOOGLE_APPLICATION_CREDENTIALS=&lt;PATH TO KEY JSON FILE&gt;</span></pre><p id="f01c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">运行以下命令，使用Google Cloud帐户进行身份验证，并根据输出中的给定说明设置项目。</p><pre class="kj kk kl km gt om ns on oo aw op bi"><span id="56ee" class="nz mt it ns b gy oq or l os ot">gcloud auth login</span></pre><p id="4b59" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">第一步，将前面章节中的文件夹<code class="fe np nq nr ns b">forest_model_layer_100_50_epoch_100</code>上传到谷歌云存储中。我创建了一个bucket <code class="fe np nq nr ns b">forest-cover-model</code>并在那个位置上传了文件夹。</p><p id="fe32" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一旦完成，您就可以部署模型了。</p><pre class="kj kk kl km gt om ns on oo aw op bi"><span id="4f88" class="nz mt it ns b gy oq or l os ot">gcloud components install beta</span></pre><p id="8625" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这在部署模型之前是必需的。</p><pre class="kj kk kl km gt om ns on oo aw op bi"><span id="f974" class="nz mt it ns b gy oq or l os ot">gcloud beta ai-platform versions create v7 \</span><span id="35d7" class="nz mt it ns b gy oz or l os ot">--model ForestPredictor \</span><span id="1ee6" class="nz mt it ns b gy oz or l os ot">--origin gs://forest-cover-model/forest_model_layer_100_50_epoch_100/ \</span><span id="dd11" class="nz mt it ns b gy oz or l os ot">--runtime-version=2.1 \</span><span id="5883" class="nz mt it ns b gy oz or l os ot">--python-version=3.7</span></pre><p id="79df" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">v7版本是在我做了一些实验后有效的版本。可以以v1作为版本名。这样，您可以保留模型的不同版本。合适的运行时版本可以在<a class="ae mk" href="https://cloud.google.com/ai-platform/training/docs/runtime-version-list" rel="noopener ugc nofollow" target="_blank">这里</a>找到。Origin参数是存储模型的google存储路径的路径。</p><blockquote class="pa"><p id="f940" class="pb pc it bd pd pe pf pg ph pi pj lv dk translated">最初我计划用预处理类等定制预测例程。但不幸的是，在创建了所有这些之后，在部署的时候，我才知道它只适用于<code class="fe np nq nr ns b">tensorflow&gt;=1.13,&lt;2</code>。它正在发展，所以它可能会在未来支持，检查<a class="ae mk" href="https://cloud.google.com/ai-platform/prediction/docs/custom-prediction-routines" rel="noopener ugc nofollow" target="_blank">这里</a>的更新。(自定义管道的代码存在于我的库中，我已经分享给感兴趣的人)</p></blockquote><p id="a84a" class="pw-post-body-paragraph la lb it lc b ld pk ju lf lg pl jx li lj pm ll lm ln pn lp lq lr po lt lu lv im bi translated">要测试部署的模型，可以浏览到AI Platform &gt; Models，在模型名称下点击想要测试的版本号。有测试和使用选项，你可以给自定义输入。输入格式如下，使用下面的例子进行测试。</p><pre class="kj kk kl km gt om ns on oo aw op bi"><span id="0296" class="nz mt it ns b gy oq or l os ot">{<br/>   "instances":[<br/>      {<br/>         "Elevation":0.4107053527,<br/>         "Aspect":0.9833333333,<br/>         "Slope":0.2121212121,<br/>         "Horizontal_Distance_To_Hydrology":0.0,<br/>         "Vertical_Distance_To_Hydrology":0.2235142119,<br/>         "Horizontal_Distance_To_Roadways":0.3771251932,<br/>         "Hillshade_9am":0.7716535433,<br/>         "Hillshade_Noon":0.842519685,<br/>         "Hillshade_3pm":0.6141732283,<br/>         "Horizontal_Distance_To_Fire_Points":0.9263906315,<br/>         "Wilderness_Areas":"Wilderness_Area1",<br/>         "Soil_Types":"Soil_Type33"<br/>      }<br/>   ]<br/>}</span></pre><p id="de6c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您可以看到如下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/6b1254778963c8ac46fbdf49848648e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fs9_hINZbh5FoFJH1o-oSA.png"/></div></div></figure><p id="2aa0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">输出给出了输入的每种覆盖类型的概率。</p><p id="74ad" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一旦这些都工作正常，您就可以使用该模型对任何输入数据进行预测。我已经在<a class="ae mk" href="https://github.com/dipikabaad/Forest_Cover_Type_Classification" rel="noopener ugc nofollow" target="_blank"> Github资源库</a>中分享了代码。文件<code class="fe np nq nr ns b">forest_classification.py</code>包含调用模型和输入管道的代码。</p><p id="8976" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我将输入数据分成小块，因为它不能一次返回所有行的结果。这些是你需要在应用程序中管理的东西。如果您有兴趣探索如何为部署在GCP的模型创建管道，您可以参考该文档。</p><p id="90b0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Tadaa！您已经准备好在实际解决方案中使用该模型，并为各种实验维护版本控制，并在此基础上跟踪性能。在现实世界中，除了只是建立一个模型，这些技能是非常重要的。有趣的是，如果您愿意的话，您可以尝试看看这些管道在其他云环境中是如何构建的。如果您希望尝试如何使用各种参数或其他优化函数来优化模型，那么您可以参考<a class="ae mk" rel="noopener" target="_blank" href="/reflecting-and-comparing-different-sentiment-classification-models-for-restaurant-reviews-d109105b2cb7">我以前的文章</a>，在那里我提出了在深度神经网络中构建模型的改进/其他机会。尽管这是针对PyTorch的，但是无论您使用哪种框架，更改架构和参数的基础都是相同的。你必须找到在其他库中定义和做同样事情的方法。希望这能帮助你开始学习GCP和Kaggle以及Tensorflow框架！</p><p id="b227" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一如既往—愉快的实验和学习:)</p></div></div>    
</body>
</html>