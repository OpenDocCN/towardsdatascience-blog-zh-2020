<html>
<head>
<title>Using Bitcoin Data in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中使用比特币数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-bitcoin-historical-data-set-with-python-and-pandas-cd31417d1736?source=collection_archive---------27-----------------------#2020-05-26">https://towardsdatascience.com/getting-started-with-bitcoin-historical-data-set-with-python-and-pandas-cd31417d1736?source=collection_archive---------27-----------------------#2020-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ced6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Python和熊猫入门比特币历史数据集。</h2></div><p id="646e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近几个月，比特币和加密货币总体上一直在上涨。从3月份的突然崩盘开始，比特币的反应非常好，价格几乎翻了一倍。再加上本月早些时候大肆宣传的减半事件，现在有很多人好奇并希望开始投资和交易。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/d42f6ed01b6d1058a23d5e9b4a95d666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hzu0Y5UQHzGXGS7WY9wk5g.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">作者创建的图像</p></figure><p id="bebb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，在这里我展示了你开始分析比特币并将其转化为可用形式所需的Python代码。我将满怀希望地展示使用pandas库在Python中做到这一点是多么容易。完整的代码可以在文章的底部找到。</p><p id="e533" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您对加密货币不感兴趣，那么这可能也是一个很好的教程，展示了Python和pandas在数据操作和分析方面的强大功能，并且可能有一些有用的代码片段可以应用于其他项目。</p><h2 id="55a2" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">安装熊猫图书馆</h2><p id="314f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">首先，如果你还没有熊猫库，你需要安装它。只需在命令行中运行以下命令。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="adac" class="lr ls iq mq b gy mu mv l mw mx">pip install pandas</span></pre><p id="062a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，如果您像我一样使用Anaconda，您可以在您使用的环境中打开Anaconda终端，然后输入以下命令。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="daa0" class="lr ls iq mq b gy mu mv l mw mx">conda install pandas</span></pre><p id="746e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有出现错误，您应该已经正确安装了库。我们马上会做最后一次测试。</p><p id="bdff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于数据分析，我发现Jupyter Notebook是最好的IDE，因为它允许您以块的形式运行代码片段，因此在导入和操作大型数据集时可以节省大量时间。但是，任何IDE都可以。</p><h1 id="1309" class="my ls iq bd lt mz na nb lw nc nd ne lz jw nf jx mc jz ng ka mf kc nh kd mi ni bi translated">所以现在对于一些编码…</h1><p id="4485" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">打开一个新脚本并保存它。第一个任务是测试pandas库是否安装正确。运行以下代码将库导入到脚本中。如果没有出现错误，那么您可以继续本教程的其余部分。如果没有，你必须正确安装熊猫图书馆——谷歌将是你的朋友。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="e70a" class="lr ls iq mq b gy mu mv l mw mx">import pandas as pd</span></pre><h2 id="d475" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">获取数据集</h2><p id="b0ee" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我将使用的数据来自Kaggle，这是世界上最大的数据科学社区，也是寻找大量数据集的最佳地点之一。这个特殊的<a class="ae nj" href="https://www.kaggle.com/mczielinski/bitcoin-historical-data" rel="noopener ugc nofollow" target="_blank">数据集</a>是比特币从2012年1月1日到2020年4月22日的历史分钟数据。</p><p id="1c25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦您将csv文件下载并保存到与您的脚本相同的目录中，您现在将希望加载该数据。为此，我们在pandas中使用了<strong class="kh ir"> <em class="nk"> pd.read_csv() </em> </strong>方法，将数据文件名作为字符串传递。这将创建一个包含csv文件中所有数据的数据框。</p><p id="314b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还将运行<strong class="kh ir"> <em class="nk">。</em></strong>head()【方法】在数据帧上向我们显示我的前5行数据。如您所见，有一行数据后跟四行连续的NaN值。这是因为有些数据丢失了，因此我们需要做一些清理工作。这是由多种原因造成的，但似乎在这个数据集的早期，数据没有每分钟归档一次，因此丢失了大量数据块。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="8b36" class="lr ls iq mq b gy mu mv l mw mx">raw_data = pd.read_csv("bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv")<br/>raw_data.head()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nl"><img src="../Images/a0688d0360afddc09192e19ae5bd900f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oa9gKeTX1aTbSKQSQJ_W9Q.png"/></div></div></figure><p id="0afc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行<strong class="kh ir"> <em class="nk">。数据帧上的tail() </em> </strong>方法将显示最后5行，您可以看到这些行实际上已满。此外，请注意数据框索引列(最左侧)中该数据集中的行数。超过四百万！对于Excel来说太多了，但是Python和pandas可以轻松处理。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="1735" class="lr ls iq mq b gy mu mv l mw mx">raw_data.tail()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nm"><img src="../Images/dbaa1f65649a38fead7174b1e180324d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chptv_m1pxFVe6FlrP7X0A.png"/></div></div></figure><h2 id="14df" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">清理并格式化数据框</h2><p id="033c" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">因此，现在我们想要创建一个数据框，其中包含NaN值的所有行都被移除。对于熊猫来说，这非常简单，我们只需使用<strong class="kh ir"> <em class="nk">。dropna() </em> </strong>方法，并将其分配给一个新的数据帧，我们称之为<strong class="kh ir"> df </strong>。这是包含所有有用数据的数据框，我们将在以后的分析中使用这些数据。</p><p id="8a44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也称之为。<strong class="kh ir"><em class="nk">reset _ index()</em></strong>方法在数据帧上使索引列复位。这将为第一行数据分配一个从0开始的索引值，为第二行分配1，依此类推。我们还将传递参数<strong class="kh ir"> inplace=True </strong>。这在pandas中很常用，它告诉Python我们希望原始数据框成为该数据框的新编辑版本。如果<strong class="kh ir"> <em class="nk">原位</em> </strong>未设置为<strong class="kh ir"> <em class="nk">真</em> </strong>，那么我们正在处理的数据帧将在生产线运行后保持不变。使用<strong class="kh ir"> <em class="nk">探究这种行为。</em> </strong>头()【方法】查看指标值。</p><p id="7fd3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还传递第二个参数<strong class="kh ir"> drop=True </strong>。默认情况下。<strong class="kh ir"><em class="nk">reset _ index()</em></strong>方法将重置我们数据的索引，但原始索引列将被复制到一个名为<strong class="kh ir"> "index" </strong>的新列中。我们不需要这个额外的列，因此我们将删除它。这也可以使用<strong class="kh ir"> <em class="nk">来实现。</em></strong>drop()【方法】对数据框和指定列名进行drop。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="2c8b" class="lr ls iq mq b gy mu mv l mw mx">df = raw_data.dropna()<br/>df.reset_index(inplace=True, drop=True)<br/>df.head()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nn"><img src="../Images/0ced2a77ef907a6b4ad80a6e3165b7dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SOePLO--zDX7lX5nVvpDog.png"/></div></div></figure><h2 id="dee8" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">更改时间戳格式</h2><p id="0b98" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">您可以看到'<strong class="kh ir">时间戳'</strong>'列的格式很奇怪，这实际上是UNIX时间格式，因此我们想将其转换为UTC时间。我们使用<strong class="kh ir"> <em class="nk"> pd.to_datetime() </em> </strong>方法来实现。我们将传递我们想要对其执行此函数的数据的参数，这是我们数据的<strong class="kh ir">‘时间戳’</strong>列，我们还将传递参数<strong class="kh ir">unit =‘s’</strong>，它告诉函数我们输入的UNIX时间的单位是秒。我们使用下面的代码行将该函数的输出保存到数据框中的<strong class="kh ir">‘Timestamp’</strong>列。注意，在pandas中引用列中的数据，我们使用下面的概念<strong class="kh ir">df[‘Timestamp’]</strong>。<strong class="kh ir"> </strong>其中方括号内传递的字符串是列的名称。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="8a40" class="lr ls iq mq b gy mu mv l mw mx">df['Timestamp'] = pd.to_datetime(df['Timestamp'], unit='s')<br/>df.head()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi no"><img src="../Images/2d12aeb94cf08510c6a5e82771b4a364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXrR2pWk22AYu8YclOr6EA.png"/></div></div></figure><p id="2278" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，部分数据集实际上来自2011年。为了完整起见，我将删除这四行。当只有几行要删除时，最简单的方法是简单地指定列表中行的索引，并将其传递给<strong class="kh ir"> <em class="nk">。</em>降()</strong>法。我们还必须再次传入参数<strong class="kh ir"> inplace=True </strong>。最后像之前一样修正指数。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="46a7" class="lr ls iq mq b gy mu mv l mw mx">df.drop([0,1,2,3], inplace=True)<br/>df.reset_index(inplace=True, drop=True)<br/>df.head()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi np"><img src="../Images/3da6895079263939abeac502d3b75d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rf1vnnzyBiGZsBwWnd47hg.png"/></div></div></figure><h2 id="a870" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">绘制数据以进行目视检查</h2><p id="2aa6" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在，我们的数据有了一个很好的结构，希望所有数据都在我们的数据框中。验证此时一切正常的一个非常快速的方法是简单地绘制比特币随时间变化的价格。我们将通过以下方式做到这一点</p><p id="9551" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行<strong class="kh ir"> <em class="nk">。plot() </em> </strong>方法在数据帧上然后指定我们想要在x轴和y轴上的列。<strong class="kh ir"> <em class="nk">。pandas中的plot() </em> </strong>方法实际上在后台使用matplotlib库来显示图形，并将尝试为轴选择合理的默认设置。如果你愿意，这个图表当然可以定制。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="355e" class="lr ls iq mq b gy mu mv l mw mx">df.plot(x="Timestamp",y="Weighted_Price")</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nq"><img src="../Images/59d4005e6b3a4b2509aec09e0f36dfd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wrsu7ShppReQOW9-NGhtJw.png"/></div></div></figure><h2 id="12df" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">创建新列</h2><p id="67c4" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">太好了！因此，我们的数据看起来是正确的，因此我们可以进行更有趣的部分，即分析或处理数据。您可能想做的一件事是创建一个新列，以某种方式处理数据。一个例子是找出每个连续时间点之间的差异。</p><p id="8d1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用pandas内置的一个名为<strong class="kh ir"> <em class="nk">的方法来做到这一点。</em>diff()</strong>。我们只需使用下面的符号<strong class="kh ir"> df["新列的标题"] </strong>指定我们希望创建的列，并将其设置为我们希望找到的与<strong class="kh ir"> <em class="nk">不同的列。</em>diff()</strong>方法。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="0f41" class="lr ls iq mq b gy mu mv l mw mx">df["closeDiff"] = df["Close"].diff()<br/>df.head()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nr"><img src="../Images/6efeb01acb72135fc04ae3abdf06526f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4q7qleOEYWUqFDJ7b0m3hw.png"/></div></div></figure><p id="4675" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意我们创建的名为<strong class="kh ir">“closeDiff”</strong>的新列。</p><p id="b275" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们假设我们想要为数据中的每一年创建数据框。比如2019年所有数据的一个数据帧<strong class="kh ir"> df19 </strong>。一种方法是首先创建一个名为“<strong class="kh ir">year”</strong>的列，其中包含每个数据点的年份值。然后我们将创建一个新的dataframe，只包含“<strong class="kh ir">年”</strong>列等于2019年的数据行。</p><p id="a1e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们将首先创建一个'<strong class="kh ir"> year' </strong>列。我们将'<strong class="kh ir">时间戳'</strong>列输入到<strong class="kh ir"> pd中。DatetimeIndex </strong>类并请求。<strong class="kh ir">年份</strong>属性。这将返回我们每个时间戳的年值，我们将该数据分配给一个新列，我们将其定义为'<strong class="kh ir"> year' </strong>。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="abab" class="lr ls iq mq b gy mu mv l mw mx">df["year"] = pd.DatetimeIndex(df["Timestamp"]).year<br/>df.head()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ns"><img src="../Images/b39bd52689ac43c2e1e60c8e698fc088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_2GLVe58KLhCb_komgCMJg.png"/></div></div></figure><p id="7d8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以现在我们想要一个新的数据帧<strong class="kh ir"> df19 </strong>，它包含我们的数据帧<strong class="kh ir"> df </strong>中的所有行，这些行在“<strong class="kh ir">year”</strong>列中的值为2019。为此，我们编写了下面一行代码。这种表示法可能有点令人困惑，但在这里我们只是说，获取所有带有数据框<strong class="kh ir"> df </strong>的行，其中“<strong class="kh ir">year”</strong>列等于2019，并将其分配给一个名为<strong class="kh ir"> df19 </strong>的新数据框。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="bd26" class="lr ls iq mq b gy mu mv l mw mx">df19 =  df[df["year"] == 2019]<br/>df19.reset_index(inplace=True, drop=True)<br/>df19.head()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nt"><img src="../Images/800b7d961b370a4c3a29fbe36d136281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJQT5-t52faPqxplhEx30A.png"/></div></div></figure><p id="0911" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以像之前的数据一样绘图，但这一次只针对2019年。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="3f3c" class="lr ls iq mq b gy mu mv l mw mx">df19.plot(x="Timestamp",y="Weighted_Price")</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nq"><img src="../Images/d3e366475df06fb2877621aed96f301b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KGTBFwh_AIWvCesn5cKGrg.png"/></div></div></figure><h2 id="1baf" class="lr ls iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">保存数据</h2><p id="a092" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在你有了干净的数据，也许你已经增加了数据或者产生了一个子集。通常，您希望保存这些数据，这样就不必再次运行这些代码。使用<strong class="kh ir">和<em class="nk">非常简单。</em>to _ CSV()</strong>数据帧上的方法。下面是我用来保存<strong class="kh ir"> df19 </strong>数据帧的代码，这样我将来就可以很容易地使用它。您传递给该方法的第一个参数是您希望保存它的文件名，并且<strong class="kh ir"> index=False </strong>告诉Python不要将数据帧的索引保存到csv文件中通常不需要的列。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="27c9" class="lr ls iq mq b gy mu mv l mw mx">df19.to_csv('btc19.csv', index=False)</span></pre><p id="06d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你有了它，一个让你开始使用这个比特币历史数据集的基本框架，以及一些你可以在Python和pandas中做的基本事情。没有<strong class="kh ir">的全精简代码<em class="nk">。头()</em> </strong>和<strong class="kh ir"> <em class="nk">。</em> </strong>尾巴()【通话记录】见下图。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div></div>    
</body>
</html>