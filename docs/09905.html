<html>
<head>
<title>Machine Learning Made Easy by PyCaret</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyCaret 让机器学习变得简单</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-made-easy-by-pycaret-5be22394b1ac?source=collection_archive---------40-----------------------#2020-07-13">https://towardsdatascience.com/machine-learning-made-easy-by-pycaret-5be22394b1ac?source=collection_archive---------40-----------------------#2020-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="10dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">10 行代码的整个机器学习管道。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c724c02bfde3c41195a0f3f32df1a905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zrEF0EVRh0-x9RBYTD1NdQ.jpeg"/></div></div></figure><p id="a382" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://pycaret.org/" rel="noopener ugc nofollow" target="_blank"> PyCaret </a>是由<a class="ae lq" href="https://www.linkedin.com/in/profile-moez/?originalSubdomain=ca" rel="noopener ugc nofollow" target="_blank"> Moez Ali </a>创建的 python 开源低代码机器学习库，于 2020 年 4 月发布。它实际上是一个低代码库，允许用很少几行代码创建一个完整的机器学习管道。PyCaret 本质上是一个基于常见 python 机器学习库(如 scikit-learn、XGBOOST 等等)的包装器。</p><p id="aa6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">PyCaret 实现的是一个非常简单的函数式语法。例如，我们可以用一行代码比较 18 个分类模型。在本文中，我将使用 PyCaret 带您完成一个分类任务，并解释每个步骤的细节。</p><p id="d2a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从安装 PyCaret 开始:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="0109" class="lw lx it ls b gy ly lz l ma mb">!pip install pycaret</span></pre><p id="9dab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您使用 google colab 作为您的 IDE，并计划在笔记本中呈现交互式可视化，则需要执行以下代码:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="8a40" class="lw lx it ls b gy ly lz l ma mb">from pycaret.utils import enable_colab<br/>enable_colab()</span></pre><p id="e316" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用的数据集是 kaggle 上提供的“<a class="ae lq" href="https://www.kaggle.com/blastchar/telco-customer-churn" rel="noopener ugc nofollow" target="_blank">电信客户流失</a>”数据集。导入 numpy 和 pandas 后，我们可以将数据集读入 pandas 数据帧:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="a254" class="lw lx it ls b gy ly lz l ma mb">import numpy as np<br/>import pandas as pd</span><span id="5034" class="lw lx it ls b gy mc lz l ma mb">df = pd.read_csv("/content/Customer-churn.csv")<br/>df.shape<br/>(7043, 21)</span></pre><p id="f941" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数据集有 7043 个观察值(行)和 21 列。以下是列的列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/17a034cf6b7e2997f4c8f915b73957d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_16wKV9bIGfrIjw2x57feQ.png"/></div></div></figure><p id="6ba5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“CustomerID”没有任何提供信息的能力，因为它只是分配给每个客户的随机消息。“总费用”列是“任期”和“每月费用”列的乘积，因此我们也不需要此列。我们只删除这两列:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="ac71" class="lw lx it ls b gy ly lz l ma mb">df.drop(['customerID','TotalCharges'], axis=1, inplace=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/7405f1b3461b0699a0496b3742c146a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A0Tx-t4XEbdhRkY88BjtQg.png"/></div></div></figure><p id="29b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">任务是使用提供的功能预测客户是否会流失(即离开公司)。我将跳过 EDA 过程，因为这篇文章的重点是如何使用 PyCaret。先来导入 PyCaret 的分类模块:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="db97" class="lw lx it ls b gy ly lz l ma mb">from pycaret.classification import *</span></pre><h1 id="1477" class="mf lx it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated"><strong class="ak">设置</strong></h1><p id="c74b" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">PyCaret 工作流总是从<code class="fe nb nc nd ls b">setup</code>函数开始，该函数为整个机器学习流水线准备环境。因此，<code class="fe nb nc nd ls b">setup</code>必须在任何其他功能之前执行。</p><p id="3bae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得一提的是，setup 函数会推断数据类型，如果推断的数据类型正确，它会提示您按 enter 键。如果推断的数据类型有错误，您可以键入“quit”。有两个选项可以确定正确的数据类型:</p><ul class=""><li id="c5a1" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">使用 pandas 函数和方法手动更改数据类型</li><li id="c7f4" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">使用设置功能的<strong class="kw iu">数字特征</strong>和<strong class="kw iu">分类特征</strong>参数</li></ul><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="ed38" class="lw lx it ls b gy ly lz l ma mb">exp_clf = setup(data = df, target = 'Churn', session_id=111)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/29d608d6852c5419d93acd33362e1eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8IMVyidjVfaO0s-50XFlw.png"/></div></div></figure><p id="81fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的例子中，数据类型是正确的，所以我按 enter 键。设置功能所需的参数有:</p><ul class=""><li id="b21b" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">数据:数据帧的名称</li><li id="4a23" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">Target:目标列的名称(因变量)</li><li id="3867" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">Session_id:一个随机数，用作以后再现的种子</li></ul><p id="b3a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">执行设置功能后，我们会得到一个关于环境和参数设置的长长的信息列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/e63c728b08ce5d438dcdeb43b915c7fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcxj53nJcOzfC-ydvEyQZA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/43bad2369fac75efea15e18f106ff2ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CtqAUB0qCxSGWyw0vxAxQ.png"/></div></div></figure><p id="f44f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从列表中可以看出，这些参数允许您处理数据预处理步骤。它还将数据分成训练集和测试集。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="783a" class="mf lx it bd mg mh oc mj mk ml od mn mo jz oe ka mq kc of kd ms kf og kg mu mv bi translated"><strong class="ak">对比车型</strong></h1><p id="a3f5" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">一旦设置被执行，我们可以使用<code class="fe nb nc nd ls b">compare_models</code>来简单评估 PyCaret 模型库中所有模型的性能。有 18 个分类器可用。Compare_models 函数训练所有模型，并在 6 个常用分类指标下评估它们的性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/a380fd0b1417c01fa8d913b4c70e5db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nz9CnaJ1nExWlTP4eMS1DA.png"/></div></div></figure><blockquote class="oi"><p id="7699" class="oj ok it bd ol om on oo op oq or lp dk translated">用一行(实际上是两个单词)代码，我们能够在 6 个不同的度量下比较 18 个模型。</p></blockquote><p id="a927" class="pw-post-body-paragraph ku kv it kw b kx os ju kz la ot jx lc ld ou lf lg lh ov lj lk ll ow ln lo lp im bi translated">最佳的 15 个被显示。排序基于“准确性”指标，但可以使用<strong class="kw iu">排序</strong>参数进行更改。分数通过 10 倍分层交叉验证来计算。使用<strong class="kw iu">折叠</strong>参数可以改变折叠次数。</p><p id="3174" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们刚刚做了一个粗略的评估。下一步是从这个列表中挑选一些算法来进一步改进。我们选择什么取决于手头的任务。为了简单起见，我将根据精确度指标选择最佳算法，即逻辑回归。</p><p id="1654" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，最佳评估指标可能会因任务和数据而异。准确度可能不是分类任务的最佳选择，尤其是当我们有不平衡的数据集时。</p><h1 id="e989" class="mf lx it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated"><strong class="ak">创建模型</strong></h1><p id="85d0" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">下一步是用选择的算法使用<code class="fe nb nc nd ls b">create_model</code>函数创建一个模型。我们只需要传入模型的缩写。您可以检查函数的 docstring 来查找缩写。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="85ba" class="lw lx it ls b gy ly lz l ma mb">help(create_model)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/ec1e76f2cc49b419e986476eeb50dbf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d4jYjbZDZpcPPk2nlGbG7A.png"/></div></div></figure><p id="8db0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是时候创建一个逻辑回归模型了。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="5a27" class="lw lx it ls b gy ly lz l ma mb">logreg = create_model('lr')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/415596f0389f0a604993af266cb45aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7xIVJY9GS830fhty7-_uA.png"/></div></div></figure><p id="a4bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它返回一个数据框架，其中包含 10 重交叉验证的结果和 6 个不同的指标。平均值是我们从<code class="fe nb nc nd ls b">compare_models</code>函数中得到的值。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="bdb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">tune _ model</strong>vs<strong class="kw iu">create _ model</strong></p><p id="7986" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模型性能的一个关键因素是调整超参数。对于某些模型，超参数对模型的精度影响很大。此外，它们在防止模型过拟合或欠拟合方面起着关键作用。<strong class="kw iu"> Create_model </strong>函数使用超参数的默认设置。PyCaret 提供了<strong class="kw iu"> tune_model </strong>函数，该函数在预定义的搜索空间内调整超参数。tune_model 函数有两个要点:</p><ul class=""><li id="be40" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">与 create_model 函数一样，Tune_model 将模型名称作为输入。它不需要您首先训练一个模型，然后调整它。</li><li id="010f" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">默认情况下，tune_model 试图优化精度指标，但可以使用<strong class="kw iu">优化</strong>参数进行更改。</li></ul><p id="e9bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以按如下方式创建优化的逻辑回归模型:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="ba5d" class="lw lx it ls b gy ly lz l ma mb">tuned_logreg = tune_model('lr')</span></pre></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="c0ba" class="mf lx it bd mg mh oc mj mk ml od mn mo jz oe ka mq kc of kd ms kf og kg mu mv bi translated"><strong class="ak">剧情模式</strong></h1><p id="ca11" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">Plot_model 函数提供了进一步分析模型性能的工具。它将经过训练的模型作为输入，并返回指定的绘图。让我们复习一些例子。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="128d" class="lw lx it ls b gy ly lz l ma mb">plot_model(logreg, plot='auc')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/277852e42783cac384c559d7e043cfb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*28vJLYmrM4a3JPtYrtQ2qw.png"/></div></figure><p id="f4f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个接收器工作特性(ROC)曲线，它通过组合所有阈值的混淆矩阵，总结了不同阈值下的模型性能。ROC 曲线的 x 轴是真阳性率(灵敏度)，ROC 曲线的 y 轴是假阳性率(1-特异性)。</p><p id="14e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只是提供了一个估计器(一个训练过的模型)和一种类型的图给<code class="fe nb nc nd ls b">plot_model </code>，它产生了一个信息可视化。有 15 种不同的地块可供选择。让我们也创建混淆矩阵和特征重要性图:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="dcad" class="lw lx it ls b gy ly lz l ma mb">plot_model(logreg, plot='confusion_matrix')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/14818a6977aa7f2793123ee59134aab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*xMF1Tu0iSC9_Kbwu-EX9cQ.png"/></div></figure><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="8c82" class="lw lx it ls b gy ly lz l ma mb">plot_model(logreg, plot='feature')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/f89cd41b360ff536a788e3df6e7daf6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*4GIAYvEEYtU_3JNfeuZjFg.png"/></div></figure><p id="530a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意:Evaluate_model </strong>函数产生一个用户界面，其中包含给定模型的所有可用图。它只需要一个估计器(一个训练好的模型)作为输入。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/0ec58b6bbde35f2330e7f03dc7cf196e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HHxnC49HEs_iLrOjBoQKnQ.png"/></div></div></figure></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="7c94" class="mf lx it bd mg mh oc mj mk ml od mn mo jz oe ka mq kc of kd ms kf og kg mu mv bi translated"><strong class="ak">预测并最终确定模型</strong></h1><p id="0964" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated"><strong class="kw iu"> Predict_model </strong>函数用于对测试集进行预测。回想一下，我们在开始时运行的 setup 函数将数据集分为训练集和测试集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/be75be4c58c812ead25c764f1e441b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*yhYR2BM4DdeVuRDKjksRqQ.png"/></div></figure><p id="813c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了测试集上的评估指标之外，<code class="fe nb nc nd ls b">predict_model</code>还返回带有两个新列的 dataframe:</p><ul class=""><li id="fe9b" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">标签:预测</li><li id="f134" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">得分:预测的概率</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/49e120b1dab52b9d5da68ec2ba8842f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4s03nGLk27LanBTqqqaL9A.png"/></div></div></figure><p id="d010" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，预测是在测试集上进行的，但是我们可以使用<strong class="kw iu">数据</strong>参数提供要预测的新观察值:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="667f" class="lw lx it ls b gy ly lz l ma mb">predict_model(logreg, data=new_data)</span></pre><p id="0718" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们对训练集和测试集的性能感到满意，我们就可以使用带有<strong class="kw iu"> finalize_model </strong>函数的整个数据集(训练+集)来重新训练模型。目的是在部署模型之前利用整个数据集。请注意，在执行 finalize_model 函数之后，评估测试集的性能是没有意义的，因为模型已经看到了训练集和测试集中的所有观察值。确保在最终确定模型之前使用 predict_model。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="b0d7" class="lw lx it ls b gy ly lz l ma mb">final_logreg = finalize_model(logreg)</span></pre></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="b78e" class="mf lx it bd mg mh oc mj mk ml od mn mo jz oe ka mq kc of kd ms kf og kg mu mv bi translated"><strong class="ak">保存和加载模型</strong></h1><p id="3e70" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated"><strong class="kw iu"> Save_model </strong>函数，顾名思义，将训练好的模型与整个管道一起保存。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/417604c652243519519cd45e5e8f3115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*eQi8wSOPoQhco1TBkRqEFA.png"/></div></figure><p id="ce88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用<strong class="kw iu"> load_model </strong>函数加载已保存的模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/4b4ae63a1e0ddf92d9f38806f2bdc8b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*Tw3-IclwXx5xjmNrv_s9Tw.png"/></div></figure></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="8b96" class="mf lx it bd mg mh oc mj mk ml od mn mo jz oe ka mq kc of kd ms kf og kg mu mv bi translated"><strong class="ak">结论</strong></h1><p id="f7cf" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">我们已经讨论了整个机器学习管道，并实验了 PyCaret 如何简化编码。我们能够用大约 10 行代码创建和评估一个体面的模型。使用 PyCaret 的典型管道可以按顺序使用以下函数创建:</p><ul class=""><li id="64e4" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">设置()</li><li id="4ef2" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">比较模型()</li><li id="a395" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">create_model()或 tune_model()</li><li id="9018" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">绘图模型()</li><li id="7815" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">预测模型()</li><li id="48ff" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">save_model()和 load_model()</li></ul></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="a11e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p><h1 id="a1aa" class="mf lx it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated"><strong class="ak">参考文献</strong></h1><ul class=""><li id="595d" class="ne nf it kw b kx mw la mx ld ph lh pi ll pj lp nj nk nl nm bi translated">pycaret.org</li></ul></div></div>    
</body>
</html>