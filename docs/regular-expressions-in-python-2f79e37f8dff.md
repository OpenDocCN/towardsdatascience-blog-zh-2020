# Python 中的正则表达式

> 原文：<https://towardsdatascience.com/regular-expressions-in-python-2f79e37f8dff?source=collection_archive---------45----------------------->

## 在 re 模块中搜索并拆分**功能**

## **简介**

正则表达式或 *regex* 是一个字符序列，用于检查每个文本(字符串)中是否存在模式，例如，找出“123”是否存在于“Practical123DataScie”中。regex 解析器将“123”解释为在字符串中只匹配自身的普通字符。但是正则表达式的真正威力在于当一个*模式*包含称为 ***元字符*** 的特殊字符时。这些对于正则表达式匹配引擎有着独特的意义，并极大地增强了搜索能力。

Regex 功能驻留在一个名为`*re*`的模块中。因此，像 Python 中的所有模块一样，我们只需要如下导入它就可以开始工作了。

```
import re
```

本教程涵盖了 *re* 模块中非常有用的函数，例如分别用于搜索和替换的 *search()* 和 *split()* 。您还将学习用元字符创建复杂的匹配模式。

## **我)。搜索()功能**

正则表达式搜索通常被写成:

```
re.search(*pattern*, *string*)
```

这个函数遍历字符串，找到与模式匹配的第一个位置。如果不匹配，则返回 None。让我们看看下面的例子:

```
s1= "Practical123DataScie"
re.search("123", s1)Output: <re.Match object; span=(9, 12), match='123'>
```

输出为您提供了大量信息。它告诉你有一个匹配，并位于字符串的 s[9:12]。这是一个简单的例子，我们可能需要搜索复杂的模式。现在想象一下，你想找三个类似“456”或者“789”的连续数字。在这种情况下，我们需要使用模式，因为我们在寻找连续的数字，而我们不知道这些数字到底是什么。它们可能是“124”、“052”等等。我们如何做到这一点？

```
s2 = “PracticalDataScie052”
re.search(‘[0–9][0–9][0–9]’, s2)Output: <re.Match object; span=(17, 20), match='052'>
```

这里有很多概念要讲。这里用的图案是`‘[0-9][0-9][0-9]’.` 先来说说方括号 *([])* 。正则表达式或模式 *[…]* 告诉你匹配方括号中的任何单个字符。例如:

```
re.search(‘[0]’, s2)Output: <re.Match object; span=(17, 18), match='0'>
```

这个模式'[0]'告诉在 s2 字符串中定位字符 0，如果匹配就打印出来。如果我需要定位更多字符，比如三个数字，我可以写:

```
re.search(‘[0][5][2]’, s2)Output: <re.Match object; span=(17, 20), match='052'>
```

好吧，你是对的。我可以只输入' 052 '作为一个模式，在 s2 字符串中定位它，但是现在事情变得有趣了。我可以在方括号内创建另一个正则表达式，例如用于范围。我这么说是什么意思？这意味着使用 *(-)* ，我可以定位一系列字符。例如:

```
re.search(‘[0–9]’, s2)Output: <re.Match object; span=(17, 18), match='0'>
```

意思是找出 s2 内从 0 到 9 的任意一个数字。现在，让我们回到定位三个连续数字的问题上来。为此，我可以简单地写:

```
re.search(‘[0–9][0–9][0–9]’, s2)Output: <re.Match object; span=(17, 20), match='052'>
```

每个方括号内的每个范围告诉你在 s2 字符串中找出一个数字。我也可以使用字母范围。例如:

```
re.search(‘[a-z][0–9]’, s2)Output: <re.Match object; span=(16, 18), match='x0'>
```

这个例子告诉我们定位两个字符。第一个，任何小写字母，第二个字符应该是数字。输出(' x0 ')正是我们期望得到的。正则表达式 *'\d'* 等于' 0–9 '。所以，对于前面的例子，我也可以用:

```
re.search(‘[a-z][\d]’, s2)Output: <re.Match object; span=(16, 18), match='x0'>
```

## **二世)。split()函数**

与搜索函数类似，正则表达式拆分通常写成:

重新拆分(*图案*、*串*)

这个函数使用模式作为分隔符分割字符串，并将子字符串作为列表返回。让我们看看下面的例子:

```
re.split(‘[;]’, ‘Data;Science and; Data Analysis;courses’)Output: ['Data', 'Science and', ' Data Analysis', 'courses']
```

在这个例子中，模式是[；]，这意味着我们有分号(；)作为分隔符。只要字符串中有分号，它就会在那个位置被拆分并保存在一个列表中。我们可以有不止一个分隔符。让我们看一个更复杂的例子。

```
string = “Data12Science567programbyAWS025GoogleCloud”
re.split(‘\d+’, string)Output: ['Data', 'Science', 'programbyAWS', 'GoogleCloud']
```

在这个例子中，我们的模式是' \d+'，我们都知道' \d '模式表示任何数字(0 到 9)。通过在末尾添加一个“+”符号，将使模式匹配至少一个或多个数字。因此，在这种情况下，我们看到任何连续的数字都将被认为是分隔的，并且子字符串在列表中返回。

让我们考虑下面的字符串。我有两门【课程号】【编程语言】【课程名称】格式的课程。字符串写在两个不同的行中，单词之间的间距不相等。

```
string = ‘’’101              Python       DataScience 
                  102           R      DataAnalysis’’’
re.split(‘\s+’, string)Output: ['101', 'Python', 'DataScience', '102', 'R', 'DataAnalysis']
```

在本例中，' \s '模式匹配任何空白字符。通过在其末尾添加加号“+”，该模式将匹配至少 1 个或更多空格。

## **III)结论**

本教程中已经讨论了 re 模块中的搜索和分割功能。使用元字符创建不同的模式，在文本挖掘中会非常有益。