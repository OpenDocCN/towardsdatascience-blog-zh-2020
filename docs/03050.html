<html>
<head>
<title>Beeralytics — A Guide to Analyzing Beer Prices from Web Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">啤酒分析——从网络数据中分析啤酒价格的指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/beeralytics-a-guide-to-analyzing-beer-prices-from-web-data-37d4ba206071?source=collection_archive---------30-----------------------#2020-03-23">https://towardsdatascience.com/beeralytics-a-guide-to-analyzing-beer-prices-from-web-data-37d4ba206071?source=collection_archive---------30-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c2f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">使用散景在交货地点寻找价格最优惠的啤酒</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/380a27ff9ea82a4a7dfe00c8e1b6d85f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*BaKM502JefX361RSN9V9Rw.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@albanmartel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿尔班·马特尔</a>在<a class="ae kv" href="https://unsplash.com/s/photos/beers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="00f5" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">几周前，我和女朋友在酒吧喝酒，开始争论菜单上最便宜的啤酒是什么。挑战本身是20种左右的啤酒有多种尺寸和酒精含量，这使得简单的比较成为一个挑战。赌注下好了，我们开始做手机数学(我发誓我们一直都这么兴奋),用一个基本公式来标准化它们:</p><blockquote class="ls lt lu"><p id="2190" class="kw kx lv ky b kz la ju lb lc ld jx le lw lg lh li lx lk ll lm ly lo lp lq lr im bi translated">奥兹。每$' =(('总盎司。'* '酒精%') / 100) /价格</p></blockquote><p id="e785" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这表明，高ABV的IPAs是你的钱的最大价值！现在我又输给了我的女朋友，我很好奇这是一个当地的选择(也许酒吧很难出售这种饮料)还是这种定价在规模上是一致的？这似乎是一个有趣的数据科学问题，所以我开始头脑风暴来回答这个问题。</p><p id="8cd2" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">10年前，如果没有专有数据集或走访每家商店并记下所有价格，这可能是不可能的(我肯定店主喜欢这样)。相反，我们现在有过多的送货服务，如Drizly和Minibar，它们通过当地商店提供啤酒送货服务。</p><p id="f233" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">本文的其余部分将介绍如何使用Python <a class="ae kv" href="https://requests.readthedocs.io/en/master/" rel="noopener ugc nofollow" target="_blank"> Requests </a>库从网站中提取数据的方法、基于所提取数据类型的图表和库选择，以及使用<a class="ae kv" href="https://bokeh.org/" rel="noopener ugc nofollow" target="_blank"> Bokeh </a>库的中级到高级可视化技术。下面解释的最终文件和代码可以在这里找到并分支<a class="ae kv" href="https://github.com/mattygyo/minibar-project" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="ebf2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">数据争论</h1><p id="5b76" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">正如我在介绍中所说的，第一个挑战是捕获数据，以便我可以对其进行分析。两者都没有API，所以我开始研究他们的网站和网络调用的结构，看看哪一个/哪一个是可行的。Drizly有一种非常奇怪的方式将数据直接注入react组件，这样在网络调用中就不会有简单的JSON有效载荷(也许是为了混淆的目的？)，显然要花很多时间才能把它变成可用的形式。将焦点转移到Minibar上，我很快发现他们不仅有一个容易抓取的标准JSON有效载荷，而且还有一堆元数据，耶！</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/fa6a325cb6844cffa90173b112bb5765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ljn70BWQw22omTEM"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">XHR的JSON来电</p></figure><p id="ee96" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">一旦我发现了这一点，就可以使用Requests库来拉JSON了…或者我是这样认为的。创建一个简单的请求后，我遇到了一条错误消息:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nb"><img src="../Images/27c2625218945e2f56228234633af388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1n38Mj0O5ztshXpDq4zgQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">告诉我你的秘密</p></figure><p id="cc47" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">嗯，这有点尴尬。运行<code class="fe nc nd ne nf b">item_count.status_code</code>还确认了一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401" rel="noopener ugc nofollow" target="_blank"> 401未授权错误</a>，这意味着我们的响应正确地到达了服务器，但是由于请求中缺少某种凭证而被拒绝。由于令牌不是凭空创建的，并且站点不需要登录，唯一合乎逻辑的结论是，一旦用户访问站点，就必须为会话创建令牌。这促使我检查上面提到的XHR请求的请求头部分，瞧，我发现了一个不记名令牌:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ng"><img src="../Images/8b013b23c8aa7e87018882678323a836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynLPRupMXWTgHhxW_7T48g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">啊，缺失的拼图</p></figure><p id="21b3" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">一旦我添加了<a class="ae kv" href="https://requests.readthedocs.io/en/master/user/quickstart/#custom-headers" rel="noopener ugc nofollow" target="_blank">头参数</a>，我就能够确认这个工作并返回数据了！下一个挑战是弄清楚如何以编程方式获取不记名令牌并将其添加到请求中，因为令牌可能会在一定时间内自动过期。我的计划大致变成了:</p><ol class=""><li id="20cb" class="nh ni it ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">首先向<a class="ae kv" href="https://minibardelivery.com/" rel="noopener ugc nofollow" target="_blank">https://minibardelivery.com/</a>发出请求，因为它不需要特殊授权就可以访问并获取它给我的不记名令牌</li><li id="33f7" class="nh ni it ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">使用头有效负载中的载体向我的目标JSON目标发出请求</li><li id="b91e" class="nh ni it ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">循环遍历并将数据展平到一个数据帧中</li></ol><p id="80f9" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在主页上很难找到持有人，因为它不在任何XHR请求中，而是作为一个元名称标签包含在内:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nv"><img src="../Images/01cafa76c51220caf90734050e8292a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8aSwMTd6kDBFuv8J8E7fdw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">偷偷摸摸</p></figure><p id="6cca" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">那么如果它不在json中，我们如何获取它呢？简单，我们就当普通网页用<a class="ae kv" href="https://www.crummy.com/software/BeautifulSoup/" rel="noopener ugc nofollow" target="_blank">美汤</a>！这可以通过编写一个非常简单的函数来实现:</p><pre class="kk kl km kn gt nw nf nx ny aw nz bi"><span id="0f5e" class="oa ma it nf b gy ob oc l od oe">def get_token():<br/>    url = '<a class="ae kv" href="https://minibardelivery.com'" rel="noopener ugc nofollow" target="_blank">https://minibardelivery.com'</a><br/>    r = requests.get(url)<br/>    soup = BeautifulSoup(r.text, 'html.parser')<br/>    bearer_token = soup.findAll(attrs={"name":"access-token"})[0]['content']<br/>    return bearer_token</span></pre><p id="888f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如您所见，我们所做的只是向Beautiful Soup指定文本应该像HTML一样处理，然后告诉它返回access-token属性的内容。这使我们不用做任何复杂或容易出错的正则表达式来寻找令牌。既然我们可以随时动态获取数据，那么只需将它展平到一个数据帧中。</p><p id="d0ee" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">查看JSON，许多啤酒都有“变种”(不同的价格取决于包装尺寸/特定商店的销售额/容器类型等。)我也想捕捉和对比。使用下面的代码，我能够根据初始调用中的count变量遍历所有的beers，将每个变量添加为单独的行项目，然后将其输出到单个数据帧中</p><pre class="kk kl km kn gt nw nf nx ny aw nz bi"><span id="398d" class="oa ma it nf b gy ob oc l od oe">import requests<br/>import pandas as pd <br/>import numpy as np<br/>import time<br/>from bs4 import BeautifulSoup</span><span id="0058" class="oa ma it nf b gy of oc l od oe">def get_token():<br/>    url = '<a class="ae kv" href="https://minibardelivery.com'" rel="noopener ugc nofollow" target="_blank">https://minibardelivery.com'</a><br/>    r = requests.get(url)<br/>    soup = BeautifulSoup(r.text, 'html.parser')<br/>    bearer_token = soup.findAll(attrs={"name":"access-token"})[0]['content']<br/>    return bearer_token</span><span id="c263" class="oa ma it nf b gy of oc l od oe">url = '&lt;the json url&gt;'<br/>bearer_token = get_token()<br/>header = {'Authorization': 'bearer {}'.format(bearer_token)}<br/>item_count = round(requests.get(url+str(1), headers=header).json()['count']/20)</span><span id="4a3a" class="oa ma it nf b gy of oc l od oe">def alc_pct(x):<br/>    if x is None:<br/>        x = np.nan<br/>    else:<br/>        x = x['value']<br/>    return x</span><span id="4ec6" class="oa ma it nf b gy of oc l od oe">beer_df = pd.DataFrame([])<br/>for x in range(1,item_count+1):   <br/>    time.sleep(3)<br/>    data = requests.get(url+str(x), headers=header).json()<br/>    for i in range(0, len(data['product_groupings'])):<br/>        core_data = {key: data['product_groupings'][i][key] for key in data['product_groupings'][0].keys() &amp; {'name','type','brand'}} <br/>        core_data['hierarchy_type'] = data['product_groupings'][i]['hierarchy_type']['name']<br/>        core_data['hierarchy_subtype'] = data['product_groupings'][i]['hierarchy_subtype']['name']<br/>        core_data['alcohol_pct'] = alc_pct(next((item for item in data['product_groupings'][i]['properties'] if item["name"] == "Alcohol %"), None))<br/>        variant_df = pd.DataFrame([])<br/>        for v in range(0, len(data['product_groupings'][i]['variants'])):<br/>            variant_data = {key: data['product_groupings'][i]['variants'][v][key] for key in data['product_groupings'][i]['variants'][v].keys() <br/>                            &amp; {'price','short_pack_size','short_volume','container_type','supplier_id'}}<br/>            core_data.update(variant_data)<br/>            variant_df = variant_df.append(core_data, ignore_index=True)<br/>        beer_df = beer_df.append(variant_df)</span><span id="5803" class="oa ma it nf b gy of oc l od oe">beer_df.to_csv('beer_data.csv')</span></pre><p id="ad97" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">一旦我的数据框中有了大约2000瓶啤酒，我就使用<a class="ae kv" href="https://github.com/ResidentMario/missingno" rel="noopener ugc nofollow" target="_blank"> missingno </a>库来了解这些数据有多完整:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi og"><img src="../Images/d048a60234ace74110b83cce36364010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*2rm6mnqRUtAfDNCHHeSswQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">哎呀，酒精百分比</p></figure><p id="354d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">结果是，酒精百分比，我整个实验的关键，在很多啤酒中都找不到，大约是数据集的3/5。固执和热情蒙蔽了我的双眼，我做了任何一个理性的人在这种情况下都会做的事情——我从商店里拿了一罐6罐装啤酒，然后花了几个小时手动输入我在搜索https://untappd.com/<a class="ae kv" href="https://untappd.com/" rel="noopener ugc nofollow" target="_blank">等网站时找到的数值。最终，我完成了啤酒和数据输入，并准备进入下一阶段。</a></p><h1 id="7ee3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">选择正确的可视化</h1><p id="6634" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">现在我们有了一个好的数据集，我们需要考虑如何有效地可视化数据。数据有定量和分类两个维度，我们想要比较诸如啤酒类型、容器类型等。针对不同的属性。考虑到任何给定点的潜在数据点的数量，散点图是一个很好的选择，因为它们能够轻松地显示模式和相关性趋势。我还知道我想用可视化来执行一些不同的高级交互:</p><ul class=""><li id="7177" class="nh ni it ky b kz la lc ld lf nj lj nk ln nl lr oh nn no np bi translated">我希望它是高度互动的，因为“最好”的啤酒可能是我再也不想喝的(看着你<a class="ae kv" href="https://www.beeradvocate.com/beer/profile/29/66/" rel="noopener ugc nofollow" target="_blank">眼镜王蛇</a>)。我还想过滤和理解复杂的情况，如“价格最好的IPA 6包装，ABV至少为6%”</li><li id="3483" class="nh ni it ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">我希望能够将颜色映射到显示中的定量点和分类点。这将使得在查看不同度量时更容易识别模式成为可能。由于一些数据也是高度基数的，我想分配独特的颜色，而不是一遍又一遍地重新映射10或20种颜色。</li></ul><p id="7a9d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在尝试了一些熟悉的简单图形库之后，我意识到如果没有一个高度灵活和可定制的库，这是行不通的。我最终选择了<a class="ae kv" href="https://docs.bokeh.org/" rel="noopener ugc nofollow" target="_blank">散景</a>，它不仅有一个巨大的预制图表库，还提供了一些很棒的例子——尤其是这个<a class="ae kv" href="https://demo.bokeh.org/movies" rel="noopener ugc nofollow" target="_blank">移动评级一</a>。我决定这一个将适合我的需要，只有小的调整，所以它是全速前进！</p><h1 id="9d37" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">被散景弄得又脏又脏</h1><p id="fdde" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">我现在警告你，如果你想用散景做基本图形之外的事情，<a class="ae kv" href="https://docs.bokeh.org/en/latest/docs/user_guide.html" rel="noopener ugc nofollow" target="_blank">阅读文档</a>。一开始我很抗拒，结果我像一个迷路的孩子一样在Stack Overflow和Google上过滤了几个小时。理解在哪里访问和更新像字形这样的对象的结构以及<code class="fe nc nd ne nf b">ColumnDataSource</code>如何更新数据是你应该尝试和理解的关键概念，而不要深入太多。</p><p id="bb54" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我的第二个免责声明是，这些代码中的一些可能效率不高，但如果我试图调整/理解它，我就永远不会发表这些。</p><h1 id="a5d5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">脚手架</h1><p id="737a" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">在浏览了他们网站上的一些例子后，大部分散景都很容易理解，而且我基本上是用电影的例子。要点中的想法是:</p><ul class=""><li id="4e62" class="nh ni it ky b kz la lc ld lf nj lj nk ln nl lr oh nn no np bi translated">导入库和数据，创建所需的自定义指标，对数据集应用任何格式化/清理:</li></ul><pre class="kk kl km kn gt nw nf nx ny aw nz bi"><span id="0fd0" class="oa ma it nf b gy ob oc l od oe">import os<br/>import pandas as pd<br/>from bokeh.io import curdoc<br/>from bokeh.layouts import column, layout<br/>from bokeh.models import ColumnDataSource, Div, Select, Slider, LinearColorMapper, ColorBar, CategoricalColorMapper, Legend, LegendItem, CustomJS<br/>from bokeh.plotting import figure<br/>from bokeh.transform import jitter<br/>from bokeh.palettes import Reds9, Turbo256, d3<br/>from bokeh.models.widgets import CheckboxButtonGroup, DataTable, TableColumn</span><span id="6dce" class="oa ma it nf b gy of oc l od oe">df = pd.read_csv('beer_data.csv')<br/>df['brand'] = ['uncat' if str(x) == 'nan' else x for x in df['brand']]<br/>df['hierarchy_type'] = ['uncat' if str(x) == 'nan' else x for x in df['hierarchy_type']]<br/>df['hierarchy_subtype'] = ['uncat' if str(x) == 'nan' else x for x in df['hierarchy_subtype']]<br/>df['total_oz'] = df['short_pack_size_num'] * df['standard vol']<br/>df['cost_per_oz'] = round(df['price'] / df['total_oz'], 2)<br/>df['oz_of_alcohol_per_dollar'] = round(((df['total_oz'] * df['alcohol_pct']) / 100) / df['price'], 2)</span></pre><ul class=""><li id="df4c" class="nh ni it ky b kz la lc ld lf nj lj nk ln nl lr oh nn no np bi translated">为轴和颜色选择创建字典。用户可以选择x/y轴以及颜色所基于的尺寸/度量:</li></ul><pre class="kk kl km kn gt nw nf nx ny aw nz bi"><span id="e5f8" class="oa ma it nf b gy ob oc l od oe">axis_map = {<br/>    "Oz of Alcohol per $": "oz_of_alcohol_per_dollar",<br/>    "Cost per Oz": "cost_per_oz",<br/>    "ABV": "alcohol_pct",<br/>    "Pack Size": "short_pack_size_num",<br/>    "Volume (Oz)": "standard vol",<br/>    "Price": "price"}</span><span id="8d49" class="oa ma it nf b gy of oc l od oe">color_axis_map = {<br/>    "ABV": "alcohol_pct",<br/>    "Brand": "brand",<br/>    "Container Type": "container_type",<br/>    "Category": "hierarchy_type",<br/>    "Sub-Category": "hierarchy_subtype",<br/>    "Price": "price",<br/>    "Pack Size": "short_pack_size",<br/>    "Volume": "short_volume",<br/>    "Supplier": "supplier_id",<br/>    "Type": "type",<br/>    "Oz of Alcohol per $": "oz_of_alcohol_per_dollar",<br/>    "Cost per Oz": "cost_per_oz"}</span></pre><ul class=""><li id="5969" class="nh ni it ky b kz la lc ld lf nj lj nk ln nl lr oh nn no np bi translated">创建工具提示格式，一个解释图表的描述部分，然后我们将在边上使用的小部件过滤器。然后，我们将为图形和表格创建一个ColumnDataSource:</li></ul><pre class="kk kl km kn gt nw nf nx ny aw nz bi"><span id="ce15" class="oa ma it nf b gy ob oc l od oe">tooltips = [<br/>    ("Name", "<a class="ae kv" href="http://twitter.com/name" rel="noopener ugc nofollow" target="_blank">@name</a>"),<br/>    ("Brand", "<a class="ae kv" href="http://twitter.com/brand" rel="noopener ugc nofollow" target="_blank">@brand</a>"),<br/>    ("Price $", "<a class="ae kv" href="http://twitter.com/price" rel="noopener ugc nofollow" target="_blank">@price</a>"),<br/>    ("ABV", "<a class="ae kv" href="http://twitter.com/alcohol_pct" rel="noopener ugc nofollow" target="_blank">@alcohol_pct</a>"),<br/>    ("Category", "<a class="ae kv" href="http://twitter.com/hierarchy_type" rel="noopener ugc nofollow" target="_blank">@hierarchy_type</a>"),<br/>    ("Category Sub-type", "<a class="ae kv" href="http://twitter.com/hierarchy_subtype" rel="noopener ugc nofollow" target="_blank">@hierarchy_subtype</a>")]</span><span id="fc9c" class="oa ma it nf b gy of oc l od oe"># Create description at top of webpage<br/>desc = Div(text=open("description.html").read(), sizing_mode="stretch_width")</span><span id="dcee" class="oa ma it nf b gy of oc l od oe"># Create unique option lists for some of the widget filters<br/>container_options = list(df['container_type'].unique())<br/>pack_size_options = sorted(list(df['short_pack_size'].unique()))<br/>hierarchy_options = sorted(list(df['hierarchy_type'].unique()))<br/>sub_hierarchy_options = sorted(list(df['hierarchy_subtype'].unique()))<br/>brand_options = sorted(list(df['brand'].unique()))</span><span id="9cd3" class="oa ma it nf b gy of oc l od oe">for i in [pack_size_options, hierarchy_options, sub_hierarchy_options, brand_options]:<br/>    i.insert(0, "All")</span><span id="d353" class="oa ma it nf b gy of oc l od oe"># Create widget filters<br/>min_abv = Slider(title="ABV", start=0, end=20, value=1, step=1)<br/>jitter_amt = Slider(title="Jitter", start=0, end=1.0, value=0.1, step=0.1)<br/>container_check = CheckboxButtonGroup(labels=container_options, active=[0, 2])<br/>brand = Select(title="Brand of Beer", value="All", options=brand_options)<br/>pack_size = Select(title="Pack Size", value="All", options=pack_size_options)<br/>hierarchy = Select(title='Category', value="All", options=hierarchy_options)<br/>sub_hierarchy = Select(title='Sub-Category', value="All",<br/>                       options=sorted(sub_hierarchy_options))<br/>y_axis = Select(title="Y Axis", options=sorted(axis_map.keys()),<br/>                value="Oz of Alcohol per $")<br/>x_axis = Select(title="X Axis", options=sorted(axis_map.keys()), value="ABV")<br/>circle_color = Select(title="Circle Color",<br/>                      options=sorted(color_axis_map.keys()), value="Price")</span><span id="b7aa" class="oa ma it nf b gy of oc l od oe"># Create Column Data Sources that will be used by the plot and table<br/>source = ColumnDataSource(data=dict(df))<br/>table_source = ColumnDataSource(data=dict(df))</span></pre><p id="8413" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这看起来有很多代码，但主要是为过滤器创建唯一的列列表，将这些列表分配给小部件，并为过滤器设置默认值。</p><p id="642d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们还将添加一个部分来创建图形、字形和最终图表所需的所有样式。我们在这里有一个条形图和图例，因为我们需要切换它们的可见性，以便在定量和分类选择之间切换:</p><pre class="kk kl km kn gt nw nf nx ny aw nz bi"><span id="e1ad" class="oa ma it nf b gy ob oc l od oe">p = figure(background_fill_color='black', background_fill_alpha=0.5,<br/>           border_fill_color='gray', border_fill_alpha=0.25,<br/>           plot_height=250, plot_width=500,               toolbar_location='below', tooltips=tooltips, tools="pan,box_select,wheel_zoom,reset,help",<br/>           active_drag="box_select", active_scroll='wheel_zoom'))</span><span id="b8d4" class="oa ma it nf b gy of oc l od oe">c = p.circle(x=jitter('x', width=jitter_amt.value, range=p.x_range),<br/>             y=jitter('y', width=jitter_amt.value, range=p.y_range),<br/>             source=source, size='price', line_color=None,<br/>             fill_color={"field": color_axis_map[circle_color.value], "transform": cmap})</span><span id="548b" class="oa ma it nf b gy of oc l od oe">bar = ColorBar(background_fill_color='gray', background_fill_alpha=0, color_mapper=cmap, location=(0, 0), visible=True)</span><span id="85d3" class="oa ma it nf b gy of oc l od oe">legend = Legend(items=[LegendItem(label=dict(field="x"), renderers=[c])],location=(10, -30), background_fill_alpha=0, visible=False)</span><span id="d37b" class="oa ma it nf b gy of oc l od oe">columns = [<br/>    TableColumn(field="name", title='Name'),<br/>    TableColumn(field="type", title='Type'),<br/>    TableColumn(field="container_type", title='Container Type'),<br/>    TableColumn(field="short_pack_size", title='Pack Size'),<br/>    TableColumn(field="short_volume", title='Volume'),<br/>    TableColumn(field="price", title='Price'),<br/>    TableColumn(field="alcohol_pct", title='ABV'),<br/>    TableColumn(field="cost_per_oz", title='Cost per Oz'),<br/>    TableColumn(field="oz_of_alcohol_per_dollar", title='Oz of Alcohol per $')]</span><span id="bbe1" class="oa ma it nf b gy of oc l od oe">data_table = DataTable(source=table_source, columns=columns, selectable=False)</span><span id="0fe5" class="oa ma it nf b gy of oc l od oe">p.add_layout(bar, "right")<br/>p.add_layout(legend, 'right')</span></pre><p id="8a34" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">完美！既然基础知识已经完成，我们可以进入更高级的概念了。</p><h1 id="c169" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">挑战1 —色彩映射</h1><p id="e552" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">我想做的事情之一是将分类数据或定量数据映射到图上的点。我希望颜色条也能根据定量数据进行调整，否则异常值(比如小桶的价格)会扰乱过滤数据的颜色分布。在没有深入基本问题的情况下，我的逻辑最终是这样的:</p><ul class=""><li id="f263" class="nh ni it ky b kz la lc ld lf nj lj nk ln nl lr oh nn no np bi translated">基于默认变量定义初始颜色映射。我选择了price，所以我默认使用Bokeh的<code class="fe nc nd ne nf b">LinearColorMapper</code>,但是如果我默认使用一个分类值的话，我会把它变成一个<code class="fe nc nd ne nf b">CategoricalColorMapper</code></li><li id="2a07" class="nh ni it ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">创建一个<code class="fe nc nd ne nf b">rescale_color</code>函数，在更新时将线性颜色映射重新调整到新的最小/最大过滤值</li><li id="e7a8" class="nh ni it ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">创建一个<code class="fe nc nd ne nf b">categorical_color_scale</code>函数，将分类色标映射到提供的任何分类列表。我还添加了一个特殊的色标，用来更好地映射高度基数的数据(比如品牌)</li><li id="fa56" class="nh ni it ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">创建一个<code class="fe nc nd ne nf b">cat_linear_color_toggle</code>函数，在更新时确定颜色窗口小部件过滤器中的当前活动值是分类的还是定量的</li><li id="7d7e" class="nh ni it ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">创建一个<code class="fe nc nd ne nf b">show_hide_legend</code>函数来切换颜色条(定量图例)和图例(分类图例)的可见性</li></ul><pre class="kk kl km kn gt nw nf nx ny aw nz bi"><span id="2932" class="oa ma it nf b gy ob oc l od oe">def rescale_color(cmap, df):<br/>    """Rescale the linearcolormapper based on the dataframe provided"""<br/>    cmap.low = min(df[color_axis_map[circle_color.value]])<br/>    cmap.high = max(df[color_axis_map[circle_color.value]])<br/>    return cmap</span><span id="bfcd" class="oa ma it nf b gy of oc l od oe">def categorical_color_scale(color_list):<br/>    """Returns a different size color scale based on color list size"""<br/>    if len(color_list) &lt; 30:<br/>        colors = d3['Category20'][20]+d3['Category20b'][10]<br/>    else:<br/>        colors = Turbo256<br/>    return colors</span><span id="cb48" class="oa ma it nf b gy of oc l od oe">def cat_linear_color_toggle(color_col, df):<br/>    """Changes color scale based on whether color is displaying a quantitative<br/>    or categorical value upon a transformation"""<br/>    if df[color_col].dtype == 'float64' or df[color_col].dtype == 'int64':<br/>        color_mapper = rescale_color(cmap, df)<br/>    else:<br/>        cat_list = list(df[color_col].astype(str).unique())<br/>        color_mapper = CategoricalColorMapper(<br/>            factors=cat_list, palette=categorical_color_scale(cat_list))<br/>    return color_mapper</span><span id="50d7" class="oa ma it nf b gy of oc l od oe">def show_hide_legend(attr, old, new):<br/>    """Used for switching to and from categorical scale"""<br/>    color_val = color_axis_map[circle_color.value]<br/>    if df[color_val].dtype in (float, int):<br/>        p.legend.visible = False<br/>        bar.visible = True<br/>    else:<br/>        p.legend.visible = True<br/>        bar.visible = False</span></pre><p id="332f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在我们已经有了更新色标/图例的框架，我们可以继续讨论一旦用户与我们的小部件过滤器交互，如何更新所有内容。</p><h1 id="2a9d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">挑战2 —更新图表和过滤数据</h1><p id="8503" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">为此，我们将在很大程度上反映电影图表示例，但我将简要介绍一下这些概念。我们希望创建一个名为<code class="fe nc nd ne nf b">select_beer()</code>的函数，它将为我们的小部件过滤器找到所有当前值，然后根据这些选择过滤数据集:</p><pre class="kk kl km kn gt nw nf nx ny aw nz bi"><span id="15ea" class="oa ma it nf b gy ob oc l od oe">def select_beers():<br/>    """Filter data source based on widget filter input"""<br/>    container_check_val = container_check.active<br/>    abv_val = min_abv.value<br/>    brand_val = brand.value<br/>    pack_size_val = pack_size.value<br/>    hierarchy_val = hierarchy.value<br/>    sub_hierarchy_val = sub_hierarchy.value</span><span id="5ee2" class="oa ma it nf b gy of oc l od oe">selected = df[df['alcohol_pct'] &gt; abv_val]<br/>    if (container_check_val != 4):<br/>        container_name_list = [container_check.labels[i] for i in container_check_val]<br/>        if len(container_name_list) == 0:<br/>            container_name_list = container_options<br/>        selected = selected[selected.container_type.isin(container_name_list)==True]<br/>    if (brand_val != "All"):<br/>        selected = selected[selected.brand.str.contains(brand_val)==True]<br/>    if (pack_size_val != "All"):<br/>        selected = selected[selected.short_pack_size.str.contains(pack_size_val)==True]<br/>    if (hierarchy_val != "All"):<br/>        selected = selected[selected.hierarchy_type.str.contains(hierarchy_val)==True]<br/>    if (sub_hierarchy_val != "All"):<br/>        selected = selected[selected.hierarchy_subtype.str.contains(sub_hierarchy_val)==True]<br/>    return selected</span></pre><p id="c98d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们要写的下一件事是一个<code class="fe nc nd ne nf b">update()</code>函数，它将更新图形元素(例如轴的名称和所选啤酒的总数),以及更新<code class="fe nc nd ne nf b">ColumnDataSource</code>,这是图形上的数据是如何更新的。它将通过调用<code class="fe nc nd ne nf b">cat_linear_toggle</code>并更新图例，最终强制更新图例/色标。最后一点适用于新过滤数据的抖动:</p><pre class="kk kl km kn gt nw nf nx ny aw nz bi"><span id="13d0" class="oa ma it nf b gy ob oc l od oe">def update():<br/>    """Updates graph elements and source.data based on filtering"""<br/>    filtered_df = select_beers()<br/>    x_name = axis_map[x_axis.value]<br/>    y_name = axis_map[y_axis.value]<br/>    p.xaxis.axis_label = x_axis.value<br/>    p.yaxis.axis_label = y_axis.value<br/>    p.title.text = "%d beers selected" % len(filtered_df)<br/>    color_select = color_axis_map[circle_color.value]</span><span id="558b" class="oa ma it nf b gy of oc l od oe">source.data = dict(<br/>            x=filtered_df[x_name],<br/>            y=filtered_df[y_name],<br/>            name=filtered_df["name"],<br/>            brand=filtered_df["brand"],<br/>            price=filtered_df["price"],<br/>            container_type=filtered_df["container_type"],<br/>            hierarchy_type=filtered_df["hierarchy_type"],<br/>            hierarchy_subtype=filtered_df["hierarchy_subtype"],<br/>            short_pack_size=filtered_df["short_pack_size"],<br/>            alcohol_pct=filtered_df["alcohol_pct"],<br/>            short_volume=filtered_df["short_volume"],<br/>            supplier_id=filtered_df["supplier_id"],<br/>            type=filtered_df["type"],<br/>            oz_of_alcohol_per_dollar=filtered_df["oz_of_alcohol_per_dollar"],<br/>            cost_per_oz=filtered_df["cost_per_oz"])<br/>    table_source.data = source.data</span><span id="a4bc" class="oa ma it nf b gy of oc l od oe">transform_scale = cat_linear_color_toggle(color_select, filtered_df)<br/>    c.glyph.fill_color = {"field": color_select, "transform": transform_scale}<br/>    p.legend.items[0].label = {'field': color_select}<br/>    if filtered_df[color_select].dtype in (float, int):<br/>        bar.color_mapper = rescale_color(cmap, filtered_df)<br/>    c.glyph.x = jitter('x', width=jitter_amt.value, range=p.x_range)<br/>    c.glyph.y = jitter('y', width=jitter_amt.value, range=p.y_range)</span></pre><p id="37a7" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在这之后，我们需要做的就是为我们所有的控件设置回调。最终输出与电影示例中的普通散景非常相似。我在末尾添加了一个<code class="fe nc nd ne nf b">os.system(...)</code>,以便于在本地运行:</p><pre class="kk kl km kn gt nw nf nx ny aw nz bi"><span id="e632" class="oa ma it nf b gy ob oc l od oe"># Determine if legend type needs to change<br/>circle_color.on_change('value', show_hide_legend)</span><span id="04b6" class="oa ma it nf b gy of oc l od oe">controls = [min_abv, jitter_amt, container_check, brand, pack_size, hierarchy,<br/>            sub_hierarchy, x_axis, y_axis, circle_color]</span><span id="e338" class="oa ma it nf b gy of oc l od oe">for control in controls:<br/>    if (control == container_check):<br/>        container_check.on_change('active', lambda attr, old, new: update())<br/>    else:<br/>        control.on_change('value', lambda attr, old, new: update())</span><span id="b4ad" class="oa ma it nf b gy of oc l od oe">inputs = column(*controls, width=320, height=500)<br/>inputs.sizing_mode = "fixed"<br/>l = layout([[desc], [inputs, p], [data_table]], sizing_mode="scale_both")</span><span id="2b4a" class="oa ma it nf b gy of oc l od oe">update()  # initial load of the data</span><span id="ebfc" class="oa ma it nf b gy of oc l od oe">curdoc().add_root(l)<br/>curdoc().title = "Beer Plot"</span><span id="91a9" class="oa ma it nf b gy of oc l od oe">os.system("bokeh serve --show bokeh_scatter.py")</span></pre><p id="f905" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">运行这一切让我第一次看到了我们放在一起的东西，不错！</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi oi"><img src="../Images/de488dbf0478a7c493819cdc4ffdac4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSYyBkcXFX6nJSfiVZzH7Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最终的图形，过滤器，色标和数据表！</p></figure><h1 id="3796" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">最终挑战—基于图形选择的过滤</h1><p id="e725" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">在这一点上，我对输出感到非常满意，并认为我已经完成了，但是一旦我开始检查数据，我就试图突出显示图表上的点区域来过滤数据表。许多数据点相互重叠，如果没有办法看到底层的选择区域，就很难进行检查。散景图自然地通过它们的默认工具如<code class="fe nc nd ne nf b">box_select</code>来处理图表上的数据选择，但是没有默认的方法来在数据表上反映这一点。</p><p id="a539" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在阅读和搜索了更多相关信息后，我得出了一个不幸的结论，那就是使用默认库无法做到这一点……ughhhhh。幸运的是，Bokeh允许通过<a class="ae kv" href="https://docs.bokeh.org/en/latest/docs/user_guide/interaction/callbacks.html#javascript-callbacks" rel="noopener ugc nofollow" target="_blank"> CustomJS模型</a>使用JavaScript，我需要完成的事情只需要很少的JS知识。我们想要做的如下:</p><ul class=""><li id="8c32" class="nh ni it ky b kz la lc ld lf nj lj nk ln nl lr oh nn no np bi translated">当<strong class="ky iu">源</strong>数据上的<strong class="ky iu">选择</strong>发生变化时，创建一个执行定制javascript的回调</li><li id="427b" class="nh ni it ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">获取所选点的<strong class="ky iu">指数</strong></li><li id="6b67" class="nh ni it ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">如果selection &gt; 1，则创建一个空字典，然后用source.data中索引与索引匹配的数据填充</li><li id="3262" class="nh ni it ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">用新字典更新表格</li></ul><pre class="kk kl km kn gt nw nf nx ny aw nz bi"><span id="a34a" class="oa ma it nf b gy ob oc l od oe"># Use custom JS so that filtering on the graph affects the data table as well<br/>source.selected.js_on_change('indices', CustomJS(args=dict(source=source, table_source=table_source), code="""<br/>        var inds = cb_obj.indices;<br/>        var d1 = source.data;</span><span id="599e" class="oa ma it nf b gy of oc l od oe">if(inds.length == 0){<br/>            table_source.data = d1<br/>        }<br/>        else{<br/>        d2 = {'name': [], 'type': [], 'container_type': [],<br/>              'short_pack_size': [], 'short_volume': [], 'price': [],<br/>              'alcohol_pct': [], 'cost_per_oz': [], 'oz_of_alcohol_per_dollar': []}</span><span id="c1ae" class="oa ma it nf b gy of oc l od oe">for (var i = 0; i &lt; inds.length; i++) {<br/>            d2['name'].push(d1['name'][inds[i]])<br/>            d2['type'].push(d1['type'][inds[i]])<br/>            d2['container_type'].push(d1['container_type'][inds[i]])<br/>            d2['short_pack_size'].push(d1['short_pack_size'][inds[i]])<br/>            d2['short_volume'].push(d1['short_volume'][inds[i]])<br/>            d2['price'].push(d1['price'][inds[i]])<br/>            d2['alcohol_pct'].push(d1['alcohol_pct'][inds[i]])<br/>            d2['cost_per_oz'].push(d1['cost_per_oz'][inds[i]])<br/>            d2['oz_of_alcohol_per_dollar'].push(d1['oz_of_alcohol_per_dollar'][inds[i]])<br/>        }<br/>        table_source.data = d2<br/>        }<br/>    """))</span></pre><p id="02e8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们做到了！最终结果应该只显示数据表中反映的选定点，类似于我在图表上选择几个数据点时看到的内容:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi oj"><img src="../Images/8a205a7149185037cccc6f71d3d2261f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLbYatFsLaHuC1uyDShLjg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">选择被突出显示，表格被动态过滤</p></figure><h1 id="d542" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="79ef" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">我知道你可能在想什么——那真正的啤酒呢？！结果很少有惊喜，麦芽饮料品牌4Loko(又名罐装电池酸)是我所在地区最便宜的，每盎司酒精0.72美元，比第二名挑战者每盎司便宜0.10美元。“酒精%”(ABV)被证明是价值的最佳基线预测值，您可以通过<a class="ae kv" rel="noopener" target="_blank" href="/a-beginners-guide-to-grabbing-and-analyzing-salary-data-in-python-e8c60eab186e?source=friends_link&amp;sk=343d0c494a90e460a0c57f8867f74743">探索性数据分析</a>或其他方式进行确认。</p><p id="1e03" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">最终，您可能会做更多的事情，例如将额外的邮政编码区域或站点包括在此分析中，但是过多的丢失数据肯定会影响您在没有一些手动数据清理的情况下所能做的事情。使用散景也很有趣，但我不确定将来我会不会把它作为图形的首选。也许如果我正在做数据可视化的工作，我会考虑它，但是对于人们需要用图表显示的大多数东西来说，学习曲线是相当陡峭的。</p><p id="b33e" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">希望这对任何人都有帮助，并随时联系或在下面评论问题/评论。感谢阅读！</p></div></div>    
</body>
</html>