<html>
<head>
<title>How to model Italian COVID-19 outbreak through a skew normal distribution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过偏斜正态分布模拟意大利新冠肺炎疫情</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-model-italian-covid-19-outbreak-through-a-skew-normal-distribution-474abef1ec02?source=collection_archive---------30-----------------------#2020-04-28">https://towardsdatascience.com/how-to-model-italian-covid-19-outbreak-through-a-skew-normal-distribution-474abef1ec02?source=collection_archive---------30-----------------------#2020-04-28</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><div class=""/><figure class="gm go ju jv jw jx gi gj paragraph-image"><div class="gi gj jt"><img src="../Images/5ad1e48ac97da64cf1d96b6cbd8d3b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*JxUXNV7KldyyCYEpbjh8NA.png"/></div></figure><p id="951b" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">本教程使用Python分析与意大利新冠肺炎趋势相关的数据。数据由意大利公民保护组织发布。在下面的文章中描述了这个预测器背后的一般概念:<a class="ae ky" href="https://medium.com/@angelica.loduca/predicting-the-end-of-the-coronavirus-epidemics-in-italy-8da9811f7740" rel="noopener">https://medium . com/@ angelica . lo duca/predicting-the-end-of-the-coronavirus-epiderations-in-Italy-8da 9811 f 7740</a>。在我的<a class="ae ky" rel="noopener" target="_blank" href="/italian-covid-19-analysis-with-python-1bdb0e64d5ac">上一篇文章</a>中，我使用线性回归来逼近数据，在本文中，我们通过偏斜的正态分布来逼近EPI，这似乎比线性回归更好。</p><p id="3acb" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">您可以从<a class="ae ky" href="https://github.com/alod83/data-science/blob/master/DataAnalysis/covid-19/Italian_covid-19_analysis_skewnorm.ipynb" rel="noopener ugc nofollow" target="_blank"> my GitHub repository </a>下载笔记本，在那里您也可以找到线性模型的实现。</p><h1 id="f602" class="kz la iw bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">入门指南</h1><h2 id="0ffd" class="lx la iw bd lb ly lz dn lf ma mb dp lj kl mc md ln kp me mf lr kt mg mh lv mi bi translated">导入数据并计算EPI</h2><p id="9018" class="pw-post-body-paragraph ka kb iw kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ip bi translated">首先，我们从意大利Protezione Civile的Github库导入数据，然后计算流行病进展指数(EPI)。我们提取列<code class="fe mo mp mq mr b">totale_casi</code>，其中包含自疫情开始以来的新冠肺炎感染总数，以及<code class="fe mo mp mq mr b">tamponi</code>，其中包含自疫情开始以来的新冠肺炎拭子总数。我们将EPI存储在<code class="fe mo mp mq mr b">y</code>变量中。最后，我们打印所有有数据的日期列表(<code class="fe mo mp mq mr b">data[‘data’]</code>)。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="3ccf" class="lx la iw mr b gz na nb l nc nd">import pandas as pd<br/>data = pd.read_csv(“<a class="ae ky" href="https://raw.githubusercontent.com/pcm-dpc/COVID-19/master/dati-andamento-nazionale/dpc-covid19-ita-andamento-nazionale.csv" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/pcm-dpc/COVID-19/master/dati-andamento-nazionale/dpc-covid19-ita-andamento-nazionale.csv</a>") <br/>data.head()</span></pre><figure class="ms mt mu mv gu jx gi gj paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gi gj ne"><img src="../Images/0fa499999b9af1c735ba5efeac7d7de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uKDkh62DD34hlb8f_zaZ3w.png"/></div></div></figure><p id="d9ca" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">然后，我们计算要分析的指标:流行病进展指数(EPI)并将其存储在<code class="fe mo mp mq mr b">y</code>变量中。我们还定义了<code class="fe mo mp mq mr b">X</code>来存储天数。最后，我们跳过前15天，来考虑限制法的影响。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="24e9" class="lx la iw mr b gz na nb l nc nd">tc = data['totale_casi']<br/>tt = data['tamponi']<br/>y = []<br/>tt_increase = []<br/>for i in range(1, len(tt)):<br/>    current_epi = (tc[i] - tc[i-1])/(tt[i]-tt[i-1])<br/>    tt_increase.append(tt[i]-tt[i-1])<br/>    y.append(current_epi)</span><span id="b08e" class="lx la iw mr b gz nj nb l nc nd">X = []<br/>for i in range(1, len(y)+1):<br/>    X.append(i)</span><span id="4913" class="lx la iw mr b gz nj nb l nc nd">skip = 15<br/>X = X[skip:]<br/>y = y[skip:]</span></pre><p id="3e3a" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">现在我们可以绘制EPI趋势。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="7830" class="lx la iw mr b gz na nb l nc nd">import matplotlib.pyplot as plt<br/>import matplotlib<br/>import numpy as np</span><span id="d8b1" class="lx la iw mr b gz nj nb l nc nd">def my_plot(X,y):<br/>    plt.plot(X, y, color="black", linewidth=1)</span><span id="9cf8" class="lx la iw mr b gz nj nb l nc nd">plt.grid()<br/>    plt.xlabel('Number of days')<br/>    plt.ylabel('EPI')<br/>    plt.show()</span><span id="dccc" class="lx la iw mr b gz nj nb l nc nd">my_plot(X,y)</span></pre><figure class="ms mt mu mv gu jx gi gj paragraph-image"><div class="gi gj jt"><img src="../Images/fd24f2831ac6bd7e31a8cb842eeff3c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*4l70rKOJLV8OyT1KoZt70Q.png"/></div></figure><h1 id="1ab9" class="kz la iw bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">提取样本</h1><h2 id="38b7" class="lx la iw bd lb ly lz dn lf ma mb dp lj kl mc md ln kp me mf lr kt mg mh lv mi bi translated">在训练集和测试集中拆分数据</h2><p id="f933" class="pw-post-body-paragraph ka kb iw kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ip bi translated">为了测试模型，我们将<code class="fe mo mp mq mr b">X</code>和<code class="fe mo mp mq mr b">y</code>拆分成<code class="fe mo mp mq mr b">X_train</code>和<code class="fe mo mp mq mr b">y_train</code>。我们将在训练变量上训练模型，并将在测试变量上进行测试。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="bd3f" class="lx la iw mr b gz na nb l nc nd">from sklearn.model_selection import train_test_split</span><span id="e238" class="lx la iw mr b gz nj nb l nc nd">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)</span></pre><h1 id="8225" class="kz la iw bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">模型定义</h1><h2 id="da3c" class="lx la iw bd lb ly lz dn lf ma mb dp lj kl mc md ln kp me mf lr kt mg mh lv mi bi translated">通过偏斜正态分布近似数据</h2><p id="5d27" class="pw-post-body-paragraph ka kb iw kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ip bi translated">我们可以通过偏斜的正态分布来近似计算数据。我们将<code class="fe mo mp mq mr b">X</code>和<code class="fe mo mp mq mr b">y</code>转换成numpy数组，并定义了一个名为<code class="fe mo mp mq mr b">skewnorm()</code>的函数，它包含了偏斜正态分布的公式。我在这里找到了公式<a class="ae ky" href="https://stackoverflow.com/questions/15400850/scipy-optimize-curve-fit-unable-to-fit-shifted-skewed-gaussian-curve" rel="noopener ugc nofollow" target="_blank">。查看</a><a class="ae ky" href="https://www.vosesoftware.com/riskwiki/SkewNormaldistribution.php" rel="noopener ugc nofollow" target="_blank">这里的</a>了解更多关于偏斜正态分布的细节。或者，我们可以使用函数<code class="fe mo mp mq mr b">scipy.stats.skewnorm</code>，这里定义<a class="ae ky" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.skewnorm.html" rel="noopener ugc nofollow" target="_blank"/>，这里定义<a class="ae ky" href="https://kite.com/python/docs/scipy.stats.norm" rel="noopener ugc nofollow" target="_blank"/>，这里定义<a class="ae ky" href="https://www.geeksforgeeks.org/python-skew-normal-distribution-in-statistics/" rel="noopener ugc nofollow" target="_blank"/>。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="f847" class="lx la iw mr b gz na nb l nc nd">import numpy as np<br/>import math<br/>from scipy.optimize import curve_fit<br/>import scipy.special as sp</span><span id="478d" class="lx la iw mr b gz nj nb l nc nd">X = np.array(X)<br/>y = np.array(y)</span><span id="b8f5" class="lx la iw mr b gz nj nb l nc nd">def skewnorm(x, sigmag, mu, alpha, c,a):<br/>    <br/>    normpdf = (1/(sigmag*np.sqrt(2*math.pi)))*np.exp(-(np.power((x-mu),2)/(2*np.power(sigmag,2))))<br/>    <br/>    normcdf = (0.5*(1+sp.erf((alpha*((x-mu)/sigmag))/(np.sqrt(2)))))<br/>    return 2*a*normpdf*normcdf + c</span></pre><p id="78d6" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">现在我们能够通过<code class="fe mo mp mq mr b">scipy</code>函数<code class="fe mo mp mq mr b">curve_fit()</code>用训练数据拟合模型。曲线拟合是构建曲线或数学函数的过程，它对一系列数据点具有最佳拟合。<code class="fe mo mp mq mr b">curve_fit()</code>函数将样本和初始参数作为输入。该函数返回最佳参数<code class="fe mo mp mq mr b">popt</code>和协方差矩阵<code class="fe mo mp mq mr b">pcov</code>作为输出。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="d8a6" class="lx la iw mr b gz na nb l nc nd">popt, pcov = curve_fit(skewnorm, X_train, y_train, p0=(1./np.std(y_train), np.mean(y_train) ,0,0,0))</span></pre><p id="7265" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">拟合后，我们绘制训练集的结果。我们通过简单地调用函数<code class="fe mo mp mq mr b">skewnorm()</code>并使用函数<code class="fe mo mp mq mr b">curve_fit()</code>返回的参数来计算预测<code class="fe mo mp mq mr b">y_train_pred</code>。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="3a65" class="lx la iw mr b gz na nb l nc nd">y_train_pred = skewnorm(X_train,*popt)</span><span id="1f83" class="lx la iw mr b gz nj nb l nc nd">plt.scatter(X_train, y_train, color="black", linewidth=1, label='train')<br/>plt.scatter(X_train, y_train_pred, color="red", linewidth=1, label='model')<br/>plt.grid()<br/>plt.legend()<br/>plt.xlabel('Number of days')<br/>plt.ylabel('EPI')<br/>plt.show()</span></pre><figure class="ms mt mu mv gu jx gi gj paragraph-image"><div class="gi gj jt"><img src="../Images/505140b3a4cd1f8332236befa0d1b87f.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*HJJ29dT3zVkt78twD2F06g.png"/></div></figure><h1 id="3217" class="kz la iw bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">模型评估</h1><p id="91e3" class="pw-post-body-paragraph ka kb iw kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ip bi translated">我们在<code class="fe mo mp mq mr b">X</code>的剩余部分，即<code class="fe mo mp mq mr b">X_test</code>上测试模型。我们将函数<code class="fe mo mp mq mr b">skewnorm()</code>应用于<code class="fe mo mp mq mr b">X_test</code>。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="c723" class="lx la iw mr b gz na nb l nc nd">y_pred = skewnorm(X_test,*popt)</span></pre><p id="b64a" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">我们将预测值与实际值进行比较。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="3de9" class="lx la iw mr b gz na nb l nc nd">df = pd.DataFrame({'Actual': np.array(y_test).flatten(), 'Predicted': y_pred.flatten()})<br/>df</span></pre><figure class="ms mt mu mv gu jx gi gj paragraph-image"><div class="gi gj nk"><img src="../Images/47bb25cf248c3e451f7fcd46e76cbed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*FVpgtDQEyaf8erpvB6P_hg.png"/></div></figure><p id="30ee" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">我们计算所有的评估指标。请看:<a class="ae ky" href="https://www.datavedas.com/model-evaluation-regression-models/" rel="noopener ugc nofollow" target="_blank">https://www . data Vedas . com/model-evaluation-regression-models/</a>了解更多详情。</p><p id="0ee3" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">我们希望RMSE值尽可能低，RMSE值越低，模型的预测就越好。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="2a26" class="lx la iw mr b gz na nb l nc nd">from sklearn import metrics<br/>print('Mean Absolute Error:', metrics.mean_absolute_error(y_test, y_pred))  <br/>print('Mean Squared Error:', metrics.mean_squared_error(y_test, y_pred))  <br/>print('Root Mean Squared Error:', np.sqrt(metrics.mean_squared_error(y_test, y_pred)))</span></pre><figure class="ms mt mu mv gu jx gi gj paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gi gj nl"><img src="../Images/3b9d2afbe3efd785d658d9a85b816832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9Fb8AZVsWfgL330Rwvi2A.png"/></div></div></figure><p id="4047" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">我们还计算皮尔逊相关系数，以确定实际值和预测值之间是否存在相关性。我们使用包含在<code class="fe mo mp mq mr b">stats</code>库中的<code class="fe mo mp mq mr b">pearsonr()</code>函数。该函数返回皮尔逊相关系数作为第一个参数，p值作为第二个参数。</p><h2 id="2640" class="lx la iw bd lb ly lz dn lf ma mb dp lj kl mc md ln kp me mf lr kt mg mh lv mi bi translated">皮尔逊相关系数</h2><p id="503f" class="pw-post-body-paragraph ka kb iw kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ip bi translated">完美:如果值接近1，那么它就是完美的相关性:随着一个变量的增加，另一个变量也会增加(如果为正)或减少(如果为负)。</p><p id="adc9" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">高度:如果系数值介于0.50和1之间，则称之为强相关。中度:如果该值位于0.30和0.49之间，则称之为中度相关。低度:当值低于+ .29时，则称之为小相关。无相关性:当值为零时。相关页面:<a class="ae ky" href="https://www.statisticssolutions.com/pearsons-correlation-coefficient/" rel="noopener ugc nofollow" target="_blank">https://www . statistics solutions . com/pearsons-correlation-coefficient/</a></p><h2 id="a67c" class="lx la iw bd lb ly lz dn lf ma mb dp lj kl mc md ln kp me mf lr kt mg mh lv mi bi translated">p值</h2><p id="e202" class="pw-post-body-paragraph ka kb iw kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ip bi translated">我们想让它尽可能小。相关页面:<a class="ae ky" href="https://it.wikipedia.org/wiki/Valore_p" rel="noopener ugc nofollow" target="_blank">https://it.wikipedia.org/wiki/Valore_p</a></p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="3b6d" class="lx la iw mr b gz na nb l nc nd">from scipy import stats</span><span id="ccec" class="lx la iw mr b gz nj nb l nc nd">stats.pearsonr(y_test, y_pred)</span></pre><h1 id="9931" class="kz la iw bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">将模型扩展到全体人口</h1><h2 id="3935" class="lx la iw bd lb ly lz dn lf ma mb dp lj kl mc md ln kp me mf lr kt mg mh lv mi bi translated">将模型应用于所有可用数据</h2><p id="4db7" class="pw-post-body-paragraph ka kb iw kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ip bi translated">整个种群由<code class="fe mo mp mq mr b">X</code>和<code class="fe mo mp mq mr b">y</code>组成。我们通过将<code class="fe mo mp mq mr b">skewnorm()</code>函数应用于<code class="fe mo mp mq mr b">X</code>来计算<code class="fe mo mp mq mr b">y_pred</code>。然后我们绘制结果。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="6b43" class="lx la iw mr b gz na nb l nc nd">y_pred = skewnorm(X,*popt)<br/>plt.scatter(X_train, y_train, color="gray", label='train')<br/>plt.scatter(X_test, y_test,  color='green', label='test')<br/>plt.plot(X, y_pred, color='red', linewidth=2, label='prediction')<br/>plt.legend()</span><span id="64aa" class="lx la iw mr b gz nj nb l nc nd">plt.show()</span></pre><figure class="ms mt mu mv gu jx gi gj paragraph-image"><div class="gi gj jt"><img src="../Images/5ad1e48ac97da64cf1d96b6cbd8d3b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*JxUXNV7KldyyCYEpbjh8NA.png"/></div></figure><h1 id="02b7" class="kz la iw bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">未来趋势预测</h1><h2 id="9bcb" class="lx la iw bd lb ly lz dn lf ma mb dp lj kl mc md ln kp me mf lr kt mg mh lv mi bi translated">将模型应用于未来的日子</h2><p id="a3a6" class="pw-post-body-paragraph ka kb iw kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ip bi translated">现在我们试着预测未来50天的趋势。我们从包含在<code class="fe mo mp mq mr b">X</code>中的最后一天+ 1开始构建一个列表<code class="fe mo mp mq mr b">X_future</code>。然后，我们将函数<code class="fe mo mp mq mr b">skewnorm()</code>应用于<code class="fe mo mp mq mr b">X_future</code>，并绘制结果。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="b541" class="lx la iw mr b gz na nb l nc nd">X_future = []<br/>n_start = skip+len(X)<br/>for i in range(n_start, n_start + 50):<br/>    X_future.append([i])</span><span id="8065" class="lx la iw mr b gz nj nb l nc nd">y_future = skewnorm(X_future,*popt)</span><span id="c57a" class="lx la iw mr b gz nj nb l nc nd">plt.scatter(X_train, y_train, color="gray", label='train')<br/>plt.scatter(X_test, y_test,  color='green', label='test')<br/>plt.plot(X_future, y_future, color='red', linewidth=2, label='prediction')<br/>plt.legend()<br/>plt.grid()<br/>plt.show()</span></pre><figure class="ms mt mu mv gu jx gi gj paragraph-image"><div class="gi gj jt"><img src="../Images/25ffd626febf5d1e80fa9567e297303f.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*lKGvUfE1YWvueNGgd3LUuA.png"/></div></figure><p id="1092" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">现在，我们可以预测新冠肺炎疫情的结束。当y的值等于偏移<code class="fe mo mp mq mr b">c</code>时，就会发生这种情况，偏移在skewnorm公式(<code class="fe mo mp mq mr b">y[i] = c</code>)中定义。由于<code class="fe mo mp mq mr b">c</code>是一个浮点数，我们在移动逗号后将其转换为int。<code class="fe mo mp mq mr b">c</code>的值包含在<code class="fe mo mp mq mr b">curve_fit()</code>返回的<code class="fe mo mp mq mr b">popt</code>变量中。通过应用与<code class="fe mo mp mq mr b">c</code>相同的技术，我们也将<code class="fe mo mp mq mr b">y_future</code>转换为int。最后，我们使用函数<code class="fe mo mp mq mr b">np.where()</code>找到索引<code class="fe mo mp mq mr b">i</code>，使得<code class="fe mo mp mq mr b">y[i] = c</code>。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="a338" class="lx la iw mr b gz na nb l nc nd">c = int(popt[3]*10**9)<br/>y_search = np.array([int(i*10**9) for i in y_future])<br/>i = np.where(y_search == c)</span></pre><p id="0b3b" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">我们获得两个索引，我们取第一个并将其存储在<code class="fe mo mp mq mr b">x0</code>中。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="ca61" class="lx la iw mr b gz na nb l nc nd">x0 = i[0][0] + n_start<br/>y_future[i[0][0]]</span></pre><p id="8c8e" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">将天数转换为日期。数据从2020年2月24日开始。那我们已经跳过了15天。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="beb5" class="lx la iw mr b gz na nb l nc nd">from datetime import datetime<br/>from datetime import timedelta  <br/>data_eff = datetime.strptime(data['data'][skip], '%Y-%m-%dT%H:%M:%S')</span></pre><p id="7308" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">现在我们能够计算新冠肺炎疫情的结束时间，只需将<code class="fe mo mp mq mr b">x0</code>转换成日期。根据这一模型，疫情不会在2020年6月13日登记任何病例。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="7b07" class="lx la iw mr b gz na nb l nc nd">def n_to_date(n):<br/>    return data_eff + timedelta(days=n-skip)</span><span id="8a0d" class="lx la iw mr b gz nj nb l nc nd">n_to_date(int(x0))</span></pre><p id="904f" class="pw-post-body-paragraph ka kb iw kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ip bi translated">最后，我们实现了一个函数来预测某个通用日期的EPI值。</p><pre class="ms mt mu mv gu mw mr mx my aw mz bi"><span id="667c" class="lx la iw mr b gz na nb l nc nd">def date_to_n(my_date):<br/>    initial_date = datetime.strptime(data['data'][0], '%Y-%m-%dT%H:%M:%S')<br/>    return (my_date - initial_date).days + 1</span><span id="f2e5" class="lx la iw mr b gz nj nb l nc nd">my_date = datetime.strptime("2020-04-25", '%Y-%m-%d')<br/>n = date_to_n(my_date)<br/>predict = skewnorm([[n]],*popt)<br/>predict</span></pre><h1 id="f1ac" class="kz la iw bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">摘要</h1><h2 id="be05" class="lx la iw bd lb ly lz dn lf ma mb dp lj kl mc md ln kp me mf lr kt mg mh lv mi bi translated">对所吸取教训的简短总结</h2><p id="54b4" class="pw-post-body-paragraph ka kb iw kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ip bi translated">在本教程中，我们学习了以下概念:</p><ul class=""><li id="a900" class="nm nn iw kc b kd ke kh ki kl no kp np kt nq kx nr ns nt nu bi translated">在为数据集选择模型之前，重要的是绘制数据，以便了解数据是否具有特定的形状；</li><li id="cdb5" class="nm nn iw kc b kd nv kh nw kl nx kp ny kt nz kx nr ns nt nu bi translated">许多不同的模型可以用来表示数据。因此，评估模型的表现非常重要。在本教程中，我们使用了不同的度量来评估模型:平均绝对误差、均方误差、均方根误差、皮尔逊相关系数和p值；</li><li id="74b0" class="nm nn iw kc b kd nv kh nw kl nx kp ny kt nz kx nr ns nt nu bi translated"><code class="fe mo mp mq mr b">scipy</code>库提供了函数<code class="fe mo mp mq mr b">curve_fit()</code>，该函数允许对任何形状或曲线进行建模。困难在于定义表示曲线的数学方程。</li></ul></div></div>    
</body>
</html>