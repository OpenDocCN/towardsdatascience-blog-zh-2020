<html>
<head>
<title>In-Depth Pandas Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入的熊猫教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/in-depth-pandas-tutorial-5d896483ba8a?source=collection_archive---------27-----------------------#2020-05-02">https://towardsdatascience.com/in-depth-pandas-tutorial-5d896483ba8a?source=collection_archive---------27-----------------------#2020-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d1e7" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据科学速成班</h2><div class=""/><div class=""><h2 id="a2ab" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">处理关系数据的终极 Python 库</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/7194e872d8519861f066562eec1cb084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UyJsVG6GJhOLEaV6"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@millerthachiller?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">帕斯卡·米勒</a>在<a class="ae lh" href="https://unsplash.com/s/photos/panda?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d71c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本月早些时候，<a class="ae lh" href="https://medium.com/u/9ab35c11801?source=post_page-----49cfc5ed9136----------------------" rel="noopener"> Edward Qian </a>和我开始为有抱负的数据科学家编写一套综合课程，这些课程可以在我们的网站<a class="ae lh" href="http://www.dscrashcourse.com/" rel="noopener ugc nofollow" target="_blank">www.dscrashcourse.com</a>上找到</p><p id="eb76" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将把稍加修改的课程交叉发布到 Medium 上，让更多的观众可以看到。如果你觉得这些文章很有帮助，请到网站上查看更多的课程和练习题！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="9b20" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ml mm mn mo b">pandas</code>是一个 Python 库，可以轻松读取、导出和处理关系数据。本课将详细介绍其功能和用法。我们通常使用缩写形式来引用库。下面分享的所有代码都是用 Python 3 和<code class="fe ml mm mn mo b">pandas==0.24.2</code>编写的。</p><h1 id="af75" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">熊猫系列</h1><p id="4834" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">从官方文档来看，Series 是带有轴标签的一维 ndarray。<code class="fe ml mm mn mo b">ndarray </code>是在<code class="fe ml mm mn mo b">numpy </code>库中找到的一种特殊数据类型，它定义了一个固定大小元素的数组。简单来说，系列是表格或电子表格中具有相同数据类型的列。每个系列都有一个用于指示轴标签的索引。</p><p id="3092" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用<code class="fe ml mm mn mo b">pd.Series(['some', 'array', 'object'])</code>创建一个系列</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ca9e9580dfffd0f682dac19f7d7d48c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/0*IG4TJhzvR1X21G40.png"/></div></figure><h2 id="9f99" class="nn mq it bd mr no np dn mv nq nr dp mz lr ns nt nb lv nu nv nd lz nw nx nf iz bi translated">索引系列</h2><p id="3dbe" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">我们可以使用轴标签或它们的位置标签来查找系列值。如果未指定，系列轴标签(也称为系列索引)将默认为整数。我们也可以将索引设置为字符串。</p><pre class="ks kt ku kv gt ny mo nz oa aw ob bi"><span id="b1d6" class="nn mq it mo b gy oc od l oe of">sample_series = pd.Series(['some', 'array', 'object'], index=list('abc'))<br/> <br/># positional indexing: this returns the first value, which is 'some'<br/>sample_series[0]<br/><br/># label indexing: this also returns the first value 'some'<br/>sample_series['a']</span></pre><p id="7e4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是<code class="fe ml mm mn mo b">sample_series</code>的样子。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi og"><img src="../Images/db99ec2ea2abd90afb18b601c4ea3f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/0*-LSFDB_LooYStZpb.png"/></div></figure><p id="7f81" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以对一个系列进行切片以获取一系列值。使用轴标签时切片行为是不同的——与通常的 Python 切片相反，起点和终点都包括在内！</p><pre class="ks kt ku kv gt ny mo nz oa aw ob bi"><span id="0c22" class="nn mq it mo b gy oc od l oe of"># positional slicing: this returns the first two values sample_series[:2]  </span><span id="c455" class="nn mq it mo b gy oh od l oe of"># label slicing: this also returns the first two values<br/>sample_series[:'b']</span></pre><h1 id="afa0" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">熊猫数据框</h1><p id="617a" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">数据帧用于定义二维数据。使用索引标记行，使用列标题标记列。每一列都可以解释为一个系列。我们可以使用<code class="fe ml mm mn mo b">pd.DataFrame({'column 1': [1, 1], 'column 2': [2, 2]}).</code>创建一个数据帧</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/8f33ab30ebe8c6cdac2d7104a52f2382.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/0*DGma2mFHs6r-B2WA.png"/></div></div></figure><p id="7840" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者，我们也可以将表格数据读入数据帧。</p><pre class="ks kt ku kv gt ny mo nz oa aw ob bi"><span id="8116" class="nn mq it mo b gy oc od l oe of"># Read in a CSV file<br/>csv_dataframe = pd.read_csv('my_csv_file.csv')<br/> <br/># Read in an Excel file<br/>xls_dataframe = pd.read_excel('my_xls_file.xls')</span></pre><h2 id="7736" class="nn mq it bd mr no np dn mv nq nr dp mz lr ns nt nb lv nu nv nd lz nw nx nf iz bi translated">索引数据帧</h2><p id="6e31" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">我们可以使用方括号来索引数据帧列。让我们以我们创建的非常简单的数据帧为例。</p><pre class="ks kt ku kv gt ny mo nz oa aw ob bi"><span id="c6da" class="nn mq it mo b gy oc od l oe of">sample_dataframe = pd.DataFrame({'column 1': [1, 1], 'column 2': [2, 2]})<br/> <br/># get the column 'column 1'<br/>sample_dataframe['column 1']</span></pre><p id="a22f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于更复杂的索引，我们可以使用。iloc 或. loc。</p><ul class=""><li id="4a2d" class="oj ok it lk b ll lm lo lp lr ol lv om lz on md oo op oq or bi translated">loc 是一种基于标签的索引方法，它需要行和列的名称</li><li id="13cb" class="oj ok it lk b ll ot lo ou lr ov lv ow lz ox md oo op oq or bi translated"><em class="os"> iloc </em>是一种基于位置的索引方法，它需要值的位置</li></ul><p id="e6f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为我们没有为行指定轴标签，所以它们采用了默认的整数值。因此，该数据帧的位置标签和轴标签是相同的。</p><p id="9a40" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用以下两种方法之一检索第一行:</p><pre class="ks kt ku kv gt ny mo nz oa aw ob bi"><span id="bc89" class="nn mq it mo b gy oc od l oe of">sample_dataframe.iloc[0, :]<br/><br/>sample_dataframe.loc[0, :]</span></pre><h1 id="d9e1" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">探索熊猫的合成数据集</h1><p id="09b0" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">让我们创建另一个数据框架来说明一些功能。我们可以假装这些数据是从一家发行教育资料的公司获得的。</p><pre class="ks kt ku kv gt ny mo nz oa aw ob bi"><span id="ec39" class="nn mq it mo b gy oc od l oe of">data = pd.DataFrame({'customer_id': [1,2,3,4,5,6,7,8], <br/>                     'age': [29,43,22,82,41,33,63,57], <br/>                     'email_linked': [True,True,False,True,False,False,True,True],<br/>                     'occupation': ['teacher','highschool teacher','student','retired',<br/>                                    'tutor','unemployed','entrepreneur','professor']})</span></pre><p id="158a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于更大的数据帧，我们可以使用<code class="fe ml mm mn mo b">.head(n)</code>来查看前<em class="os"> n </em>行。要查看最后几行，我们可以使用<code class="fe ml mm mn mo b">.tail(n).</code>执行类似的操作，这对我们的小数据集来说都不是必需的，但是我们仍然可以使用<code class="fe ml mm mn mo b">data.head(3)</code>进行演示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/a3044791771f77aa2040642e4fe3b32b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/0*Af3s301u0sntdH_y.png"/></div></figure><h2 id="7cb7" class="nn mq it bd mr no np dn mv nq nr dp mz lr ns nt nb lv nu nv nd lz nw nx nf iz bi translated">过滤和索引数据帧</h2><p id="8bc8" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">假设我们想要运行一个电子邮件活动。我们首先提取相关的专栏来开展我们的活动。</p><pre class="ks kt ku kv gt ny mo nz oa aw ob bi"><span id="3257" class="nn mq it mo b gy oc od l oe of"># use double brackets to index multiple columns, single brackets for one column<br/>email_data = data[['customer_id', 'email_linked']]</span></pre><p id="27d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">并非所有的客户都有电子邮件链接，所以我们肯定要排除那些没有。</p><pre class="ks kt ku kv gt ny mo nz oa aw ob bi"><span id="0148" class="nn mq it mo b gy oc od l oe of"># the condition goes inside the square brackets email_data = email_data[email_data['email_linked']]</span></pre><h2 id="2f01" class="nn mq it bd mr no np dn mv nq nr dp mz lr ns nt nb lv nu nv nd lz nw nx nf iz bi translated">应用列式函数</h2><p id="5bc1" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">让我们写一个非常简单的函数来判断一个客户是否是教育者。这就是我们如何定义一个教育家。</p><pre class="ks kt ku kv gt ny mo nz oa aw ob bi"><span id="b9a7" class="nn mq it mo b gy oc od l oe of">def is_educator(occupation):<br/>    return 'teacher' in occupation.lower() or occupation.lower() in ['tutor', 'professor', 'lecturer']</span></pre><p id="f42b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以将这个函数应用到<em class="os">职业</em>列来创建一个新列。</p><pre class="ks kt ku kv gt ny mo nz oa aw ob bi"><span id="a41f" class="nn mq it mo b gy oc od l oe of">data['is_educator'] = data['occupation'].apply(is_educator)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oz"><img src="../Images/0f0f958af15892ed0f8f5e1b0c58cfe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DP8MlI49lNNiBT5g.png"/></div></div></figure><p id="763d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还可以转换数据帧中每一列的所有行。这就需要我们设置<code class="fe ml mm mn mo b">axis=0</code>(也是默认设置)。我们可以编写一个列式函数来删除任何包含缺失值的列。这只是为了演示——有更好的方法来处理缺失值(参见<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html" rel="noopener ugc nofollow" target="_blank">官方熊猫文档</a>)。</p><pre class="ks kt ku kv gt ny mo nz oa aw ob bi"><span id="1854" class="nn mq it mo b gy oc od l oe of">def remove_missing_columns(col):<br/>    if col.isnull().values.any():<br/>        return col<br/><br/>data.apply(remove_missing_columns, axis=0)</span></pre><h2 id="fabc" class="nn mq it bd mr no np dn mv nq nr dp mz lr ns nt nb lv nu nv nd lz nw nx nf iz bi translated">应用逐行函数</h2><p id="eb0c" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">我们还可以应用一个函数来转换一行中的每一列。这就要求我们设定<code class="fe ml mm mn mo b">axis=1.</code></p><pre class="ks kt ku kv gt ny mo nz oa aw ob bi"><span id="a248" class="nn mq it mo b gy oc od l oe of">def is_educator_above_50(row):<br/>    return row['age'] &gt; 50 and is_educator(row['occupation'])<br/><br/>data['is_educator_above_50'] = data.apply(is_educator_above_50, axis=1)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/33574dfa126a211ef36925f6cb63466e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tXKzP1Huw7UeBFk-.png"/></div></div></figure><h2 id="10d8" class="nn mq it bd mr no np dn mv nq nr dp mz lr ns nt nb lv nu nv nd lz nw nx nf iz bi translated">Groupby 操作</h2><p id="18e0" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">Groupby 操作对于分析 Pandas 对象和从大量数据中设计新功能非常有用。所有 groupby 操作都可以分解为以下步骤:</p><ul class=""><li id="6a57" class="oj ok it lk b ll lm lo lp lr ol lv om lz on md oo op oq or bi translated"><strong class="lk jd">将对象分成组</strong></li><li id="6340" class="oj ok it lk b ll ot lo ou lr ov lv ow lz ox md oo op oq or bi translated"><strong class="lk jd">对每组应用</strong>一个函数</li><li id="8a97" class="oj ok it lk b ll ot lo ou lr ov lv ow lz ox md oo op oq or bi translated"><strong class="lk jd">结合</strong>结果</li></ul><p id="ef51" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通常，对象会根据某些标准进行拆分，为每个组计算一个汇总统计数据，并组合成一个更大的对象。我们可以使用 groupby 运算来计算每种职业的平均年龄。</p><ul class=""><li id="b2e2" class="oj ok it lk b ll lm lo lp lr ol lv om lz on md oo op oq or bi translated">按<em class="os">职业</em>分割数据帧</li><li id="35e5" class="oj ok it lk b ll ot lo ou lr ov lv ow lz ox md oo op oq or bi translated">将一个<em class="os">均值</em>函数应用于每个职业</li><li id="27e2" class="oj ok it lk b ll ot lo ou lr ov lv ow lz ox md oo op oq or bi translated">把平均年龄结合成它自己的对象</li></ul><p id="05ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个操作的代码非常简单:<code class="fe ml mm mn mo b">data.groupby(by=['occupation']).mean()['age']</code></p><p id="25b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="os"> by </em>参数表示如何确定组，<em class="os"> mean() </em>是兴趣的统计量，按<em class="os">年龄索引</em>获取年龄的组统计量。输出是一个系列，其中<em class="os">职业</em>是轴标签。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/abf12aefa91ece7f9948221bfc65a7bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/0*9DTUU8TbsZk2QQyG.png"/></div></figure><p id="7c39" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用多个参数来划分群组，例如，职业和他们的电子邮件是否链接的组合:<code class="fe ml mm mn mo b">data.groupby(by=['email_linked', 'occupation']).mean()['age']</code></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/032515827d03573eaa3316fe74c89443.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/0*agkWsIxzbn4Ji8zO.png"/></div></figure><p id="699f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了<em class="os">意味着</em>，还有其他内置函数可以应用于每个组:<em class="os"> min，max，count，sum </em>等等。我们也可以使用<code class="fe ml mm mn mo b">agg() </code>来应用任何自定义功能。聚合方法对于返回多个汇总统计信息也很有用。</p><p id="8528" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，<code class="fe ml mm mn mo b">data.groupby(by=['occupation']).agg(['mean', 'sum'])['age']</code>将返回每个组的平均年龄以及年龄总和。</p><h2 id="b6fb" class="nn mq it bd mr no np dn mv nq nr dp mz lr ns nt nb lv nu nv nd lz nw nx nf iz bi translated">数据帧属性</h2><p id="dbb2" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">这些属性帮助我们探索和熟悉新的数据框架。</p><ul class=""><li id="d168" class="oj ok it lk b ll lm lo lp lr ol lv om lz on md oo op oq or bi translated"><code class="fe ml mm mn mo b">data.columns </code>返回所有列的列表</li><li id="6df2" class="oj ok it lk b ll ot lo ou lr ov lv ow lz ox md oo op oq or bi translated"><code class="fe ml mm mn mo b">data.shape </code>以(行数，列数)的形式返回维度</li><li id="4b3b" class="oj ok it lk b ll ot lo ou lr ov lv ow lz ox md oo op oq or bi translated"><code class="fe ml mm mn mo b">data.dtypes </code>返回每列的数据类型</li><li id="f4bf" class="oj ok it lk b ll ot lo ou lr ov lv ow lz ox md oo op oq or bi translated"><code class="fe ml mm mn mo b">data.index </code>返回索引值的范围</li></ul><h2 id="828a" class="nn mq it bd mr no np dn mv nq nr dp mz lr ns nt nb lv nu nv nd lz nw nx nf iz bi translated">以下是一些可能有帮助的额外阅读材料:</h2><ul class=""><li id="995b" class="oj ok it lk b ll nh lo ni lr pd lv pe lz pf md oo op oq or bi translated">参考<a class="ae lh" href="https://pandas.pydata.org/docs/" rel="noopener ugc nofollow" target="_blank">熊猫官方文档</a>了解语法、用法和更多例子。</li><li id="a5b0" class="oj ok it lk b ll ot lo ou lr ov lv ow lz ox md oo op oq or bi translated">书籍:<a class="ae lh" href="https://amzn.to/3feHPSY" rel="noopener ugc nofollow" target="_blank">用于数据分析的 Python:与 Pandas、NumPy 和 IPython 的数据角力</a></li></ul><h1 id="31fc" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">感谢您的阅读！</h1><p id="87f3" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">如果你喜欢这篇文章，你可能想看看我关于数据科学、数学和编程的其他文章。请在 Medium 上关注我的最新更新！</p></div></div>    
</body>
</html>