<html>
<head>
<title>Auto-Docs for Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的自动文档</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/auto-docs-for-python-b545ce372e2d?source=collection_archive---------13-----------------------#2020-05-09">https://towardsdatascience.com/auto-docs-for-python-b545ce372e2d?source=collection_archive---------13-----------------------#2020-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dd18" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写代码很无聊，为什么要浪费时间呢？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/896180a38a87b0c764917921970c967b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dtqgMc4D_NTnzJHR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aows?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿德里安</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b5ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管我们喜不喜欢，好的文档绝对是项目成功的关键<strong class="lb iu">。那么，为什么好的文档如此难找呢？</strong></p><p id="e12a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实中，它常常被忽视，被当作代码本身的劣质产品。制作好的、用户友好的文档实在是太耗时了。</p><p id="d816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种忽视是错误的。我们构建的工具的采用在很大程度上取决于易用性。如果文档难以浏览、理解，或者仅仅是使用起来没有吸引力，<strong class="lb iu"> </strong>用户不会喜欢它。</p><p id="1f0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，考虑到这一点，我相信我们都应该为简单而全面的文档而努力。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/da2a01c8182fa3044ecc3b3d8a58943e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NXfN_7wcau3q-Difr1G_Hg.gif"/></div></div></figure><p id="86da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将介绍如何为任何Python项目快速构建自动文档工具。有了它，只需几秒钟就可以为包含大量代码的复杂项目生成文档。</p><p id="5de3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正则表达式是我们的朋友，我们将在整篇文章中大量使用它们。我写这篇文章的目的是真正关注代码的这一方面，我希望你能从中学到很多东西(我当然有)。</p><p id="d9f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lw">如果你使用</em><a class="ae ky" href="https://numpydoc.readthedocs.io/en/latest/format.html" rel="noopener ugc nofollow" target="_blank"><em class="lw">NumPy/SciPy docstring标准</em> </a> <em class="lw">，你甚至可以使用我使用的确切代码，这些代码在</em> <a class="ae ky" href="https://github.com/jamescalam/autodocs" rel="noopener ugc nofollow" target="_blank"> <em class="lw"> GitHub这里有</em> </a> <em class="lw">！</em></p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="7576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始之前，现成的文档工具是现成的。用起来都没毛病，其实<a class="ae ky" href="https://docs.readthedocs.io/en/stable/intro/getting-started-with-sphinx.html" rel="noopener ugc nofollow" target="_blank">斯芬克斯</a>，唯一一个我综合使用过的其实很不错。</p><p id="13ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，到目前为止，我还没有其他工具能特别快速地生成我喜欢的文档样式。</p><p id="44f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，他们是好的，我建议你考虑你所有的选择。如果您对Sphinx(或另一个)工具满意，请使用它。如果你想以你自己的风格构建一些东西(并学习正则表达式)，使用这个指南。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/c9c98a267df3c6dd3ad4646c6f5d7e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZXBOWEfsBfZ44HPQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jorn Eriksen 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="af23" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结构</h1><p id="4072" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated"><strong class="lb iu"> autodocs </strong>文档结构可以表示为一棵树，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/554e6e2739501c81d1ef61c541d295b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oYX3DB30oPnIdiA1MISc6Q.png"/></div></div></figure><p id="b5c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由此我们可以看出，我们必须能够从代码中提取几个关键结构，它们是:</p><ul class=""><li id="1c77" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><strong class="lb iu">文档字符串</strong> : <em class="lw">(包含描述、参数、参数数据类型等)</em>这些是我们用来描述每个脚本、类和函数的块引用部分。</li><li id="a6bb" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">类</strong>:类定义本身、它们的描述(包含在docstring中)和方法。</li><li id="7a32" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">函数</strong>:函数本身及其文档字符串，包含函数描述和参数。</li><li id="4112" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">参数</strong>:包含在函数docstring中。每个参数包含一个描述、数据类型和一个“可选”标志。</li></ul><p id="204e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将采用这些组件中的每一个及其各自的子组件，并使用这些信息来开发另一个简化的、可理解的文档的树状结构。</p><h1 id="e662" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">文档字符串</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/13c0e88fd66f6f78a18e874da809ce50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KKTqUIZw7NGfXNZeRL4EBQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Numpy/Scipy标准文档字符串(包含在三重引号中的部分)。</p></figure><p id="6d86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们可以通过每个文档周围的三重引号来识别文档字符串。在regex中，我们写<code class="fe ns nt nu nv b">(?s)\"{3}.*?\"{3}</code>。</p><p id="dfa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了一些事情。</p><ul class=""><li id="09c9" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><code class="fe ns nt nu nv b">\</code>用作转义字符。我们将它放在Python <code class="fe ns nt nu nv b">"</code>或regex <code class="fe ns nt nu nv b">{[()]}</code>中有其他含义的字符前面，以“逃离”它们的原生含义。表明我们实际上只是想寻找那个字符。</li><li id="9320" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">我们有两组<code class="fe ns nt nu nv b">\"{3}</code>，这正好匹配我们的两组三重引号。</li><li id="b938" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe ns nt nu nv b">.*</code>匹配除换行符之外的任何字符，<code class="fe ns nt nu nv b">?</code>使其成为一个“懒惰”量词——停止正则表达式匹配<code class="fe ns nt nu nv b">"""</code>的第一个实例到<code class="fe ns nt nu nv b">"""</code>的最后一个实例，取而代之，我们匹配第一个和第二个、第三个和第四个实例，等等。</li><li id="55bd" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe ns nt nu nv b">(?s)</code>是一个全局模式修饰符，<code class="fe ns nt nu nv b">s</code>告诉正则表达式我们希望<code class="fe ns nt nu nv b">.*</code>也匹配换行符。</li></ul><h1 id="830d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">班级</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/e799abc8566453ec8c934ae4a9ecb199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6vuQEWLNYAlfocALyi6Aw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个类的示例格式，后跟一个类外函数。</p></figure><p id="c482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个类的开头可以很容易地通过单词<code class="fe ns nt nu nv b">class</code>后跟一个空格、几个字母和一个冒号来识别。</p><p id="698a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止我们匹配类开头之后的所有内容，我们将类的结尾标识为换行符直接跟在文本字符之后的第一个位置。</p><p id="d8e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在regex中，我们写<code class="fe ns nt nu nv b">(?sm)class [\w\d_]+:.*(^\w)</code>。</p><ul class=""><li id="336e" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><code class="fe ns nt nu nv b">[\w\d_]</code>匹配文本、数字和下划线字符，添加<code class="fe ns nt nu nv b">+</code>意味着它将匹配无限数量的这些字符。</li><li id="eb0f" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe ns nt nu nv b">(?sm)</code>还是我们的全局模式修饰符，<code class="fe ns nt nu nv b">m</code>标志告诉正则表达式我们希望<code class="fe ns nt nu nv b">^</code>和<code class="fe ns nt nu nv b">$</code>分别表示一行的开始和结束。</li><li id="1d42" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe ns nt nu nv b">(^.)</code>是一行的开始<code class="fe ns nt nu nv b">^</code>，后面紧跟着一个字符<code class="fe ns nt nu nv b">.</code>。</li></ul><h1 id="3532" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">功能</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/6a58a5b3a1e90e0817538750bc9d9d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0rlDD2AN8bgxOtZfz_YBw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们需要提取的例子。</p></figure><p id="6ec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">功能有点不同。不像类，我们捕获类中包含的所有内容(这样我们也可以提取类方法)，我们只需要函数名和docstring。</p><p id="b614" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，这使得我们的第一个函数匹配正则表达式更加容易，我们写<code class="fe ns nt nu nv b">(?s)def [\w\d_]+\(.*?\):\s+\"{3}.*?\"{3}</code>。</p><h2 id="c97a" class="ny mg it bd mh nz oa dn ml ob oc dp mp li od oe mr lm of og mt lq oh oi mv oj bi translated">描述</h2><p id="c503" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">每个函数还包含我们必须提取的名称、描述和参数列表。我们分几部分来做，参数提取稍微复杂一点，我们将在下一部分讨论。</p><p id="dabc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">函数</strong> <strong class="lb iu">名称</strong>我们用<code class="fe ns nt nu nv b">def [\w\d_]+\(</code>提取，用它我们去掉<code class="fe ns nt nu nv b">def</code>和<code class="fe ns nt nu nv b">(</code>，只留下函数名称。</p><pre class="kj kk kl km gt ok nv ol om aw on bi"><span id="b904" class="ny mg it nv b gy oo op l oq or">name = re.search(r"def [\w\d_+\(", func).group()<br/>name = name.replace("def ", "").replace("(", "").strip()</span></pre><p id="87f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">描述</strong> <code class="fe ns nt nu nv b">desc</code>和参数表<code class="fe ns nt nu nv b">params</code>是用<code class="fe ns nt nu nv b">(?s)\"{3}.*?\"{3}</code>拉出docstring并在<code class="fe ns nt nu nv b">Parameters\n</code>上拆分提取的。然后，我们删除三重引号和过多的空白。</p><pre class="kj kk kl km gt ok nv ol om aw on bi"><span id="e9c7" class="ny mg it nv b gy oo op l oq or">docstring = re.search(r"(?s)\"{3}.*\"{3}").group()<br/>desc, params = docstring.split("Parameters\n")<br/>desc = re.sub(r"\s+", " ", desc.replace('"""'<!-- -->, "")).strip()</span></pre><h1 id="dc7e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">因素</h1><p id="7e58" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我们的参数列表包含在<code class="fe ns nt nu nv b">params</code>中，看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/bbd40ebd0f6c58b770fc041d9875a8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Tk0BCGKV70hTRRpORQbKg.png"/></div></div></figure><p id="13b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了匹配每个参数，我们编写<code class="fe ns nt nu nv b">(?s)\w+ : .*?(?=\w+ :)</code>。</p><p id="4e06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在很大程度上，我们已经涵盖了这方面的所有内容，除了一个部分— <code class="fe ns nt nu nv b">(?=\w+ :)</code>。</p><p id="d3f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们知道<code class="fe ns nt nu nv b">\w+ :</code>将匹配后跟空格和冒号的多个字母。然而，它被包裹在<code class="fe ns nt nu nv b">(?=)</code>中。这被称为<strong class="lb iu">正向前瞻</strong>断言。</p><p id="bf34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过添加这个，我们告诉regex对<strong class="lb iu"> assert </strong> <code class="fe ns nt nu nv b">(?=)</code>声明，我们匹配的内容后面紧跟着<code class="fe ns nt nu nv b">\w :</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/e729fa56a793cff1ba6883c912e24461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/0*ex-Meor2Nu7h8NPa.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">截图来自<a class="ae ky" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">regex101.com</a></p></figure><p id="ce64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们把它放到一个在线正则表达式测试器中，我们可以看到它几乎完美地工作，但是不幸的是，它遗漏了最后一个参数(因为它后面没有跟随<code class="fe ns nt nu nv b">\w :</code>)。</p><p id="e861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过一次提取一个参数来解决这个问题。在这个循环中，如果我们发现没有找到参数，我们用修改后的参数finding regex <code class="fe ns nt nu nv b">(?s)\w+ : .*</code>再次尝试，提取最后一个参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><h2 id="d20a" class="ny mg it bd mh nz oa dn ml ob oc dp mp li od oe mr lm of og mt lq oh oi mv oj bi translated">参数细节呢？</h2><p id="167f" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我们最后的、最深的提取层要求我们提取参数名、数据类型、“可选”标志和描述。</p><p id="07b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们简单地用换行符<code class="fe ns nt nu nv b">\n</code>分割我们的参数文本<code class="fe ns nt nu nv b">new_param</code>。现在，在索引<code class="fe ns nt nu nv b">0</code>处，我们有了包含参数名、数据类型和可能的<em class="lw">可选</em>标志的第一行。让我们修改上面的代码来包含这个提取。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="0e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里唯一增加的逻辑就是<code class="fe ns nt nu nv b">:</code>对<code class="fe ns nt nu nv b">new_param</code>的第一行进行拆分，给我们<code class="fe ns nt nu nv b">name</code>和<code class="fe ns nt nu nv b">dtype</code>。接着检查<code class="fe ns nt nu nv b">dtype</code>中的单词<code class="fe ns nt nu nv b">'optional'</code>，给出<code class="fe ns nt nu nv b">optional</code>。</p><p id="a49d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们简单地将这些参数细节添加到新的<code class="fe ns nt nu nv b">params</code>字典中。给了我们这样的东西:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/cec219a22814acd26749e0da814d173a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*paVv1uWIlryHuygAVCKdEA.png"/></div></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="f0e8" class="mf mg it bd mh mi ox mk ml mm oy mo mp jz oz ka mr kc pa kd mt kf pb kg mv mw bi translated">我们的准则</h1><p id="925a" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">至此，我们已经完成了从代码中提取我们需要的所有内容的代码。我们已经创建了前面提到的树形结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/554e6e2739501c81d1ef61c541d295b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oYX3DB30oPnIdiA1MISc6Q.png"/></div></div></figure><p id="5204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">脚本或类行中包含的任何内容都将有一个专门的文档页面。脚本页面将包含名称、描述以及指向其下任何类的链接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/bd94c08e89a10cca9132431a663ec0b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*KJ7znXy6GjT003v1RVo6Pw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从单个脚本<strong class="bd pd"> docs.py </strong>生成的页面，其中包含一个名为<strong class="bd pd"> DocsBuilder </strong>的类。</p></figure><p id="9c49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构建文档时，我们将遍历项目中包含的每个脚本和类。迭代地为每一个构建文档。</p><p id="8225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个，我们可以继续为我们的文档构建HTML代码。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/db6aa16341a30238e86c1f4912cd57bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H1eXBQlRwHOCg04U"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@helloimnik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">你好我是尼克🎞</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h1 id="353e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">构建文档</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/dc80a1141cb5b52e25afcd9b03f9e2f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jCBM6A_dCyJLlh0NpccTYA.png"/></div></div></figure><p id="59ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些文档分为四个主要部分:</p><ul class=""><li id="0323" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">脚本/类<strong class="lb iu">信息</strong>。这出现在每一页的顶部。这是来自第一个脚本或类级docstring的信息。</li><li id="4cb5" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">面包屑<strong class="lb iu">导航</strong>栏。允许我们上下浏览文档级别。</li><li id="5417" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">类</strong>节。在这里，我们将有一个脚本类列表，单击一个类按钮将显示类描述和文档链接。</li><li id="005c" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">功能</strong>部分。这包含一个函数列表，详细说明了它们各自的参数。</li></ul><p id="8f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在动态构建这些部分之前，我们确实需要将<code class="fe ns nt nu nv b">&lt;head&gt;</code>信息添加到我们的初始HTML页面，现在我们将保持它非常简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="a12b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将为页面中的CSS和JS使用<a class="ae ky" href="https://getbootstrap.com/docs/4.4/getting-started/introduction/" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>。在<code class="fe ns nt nu nv b">&lt;head&gt;</code>中，我们使用<code class="fe ns nt nu nv b">&lt;link&gt;</code>元素附加引导CSS样式表。JS脚本是稍后添加的。</p><p id="739c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，我们可以将这段代码添加到三重引号块中，或者从文件中读取它。变量<code class="fe ns nt nu nv b">html</code>最初将只包含这个<code class="fe ns nt nu nv b">&lt;head&gt;</code>元素。</p><h1 id="a1c1" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">顶级信息</h1><p id="bc0a" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">这是我们的脚本/类信息，出现在我们页面的顶部。</p><p id="bb00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们独立地遍历每个脚本和类时，我们可以同样对待它们。两者之间的唯一区别是脚本页面将包含类部分，而类则不包含(除非您在类中有一个类)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="cfd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe ns nt nu nv b">docs.py</code>，<code class="fe ns nt nu nv b">fullpath</code>将只包含一个条目<code class="fe ns nt nu nv b">['docs']</code>。但是对于较低的级别，例如<code class="fe ns nt nu nv b">DocsBuilder</code>，这将包含通向类<code class="fe ns nt nu nv b">['docs', 'DocsBuilder']</code>的层列表。因此，我们的主标题是列表<code class="fe ns nt nu nv b">fullpath[-1]</code>中的最后一个索引。</p><p id="729b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顶层描述包含在<code class="fe ns nt nu nv b">desc</code>中。</p><h1 id="961c" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">面包屑导航</h1><p id="03d1" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">接下来是我们的导航部分，我们用最高级别的页面<code class="fe ns nt nu nv b">readme</code>初始化它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="b94d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们遍历<code class="fe ns nt nu nv b">fullpath</code>中的条目，创建一个到当前页面的完整“面包屑路径”。</p><p id="3822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为生成的文件名都是骆驼大小写，并且包括任何前面的类/脚本。我们将相同的格式应用于变量<code class="fe ns nt nu nv b">path</code>。这使得<code class="fe ns nt nu nv b"><strong class="lb iu">DocsBuilder </strong>-&gt; <strong class="lb iu">docs.docsbuilder</strong></code>。</p><h1 id="30eb" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">班级</h1><p id="4fd0" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">类别都存储在一个名为<code class="fe ns nt nu nv b">classes</code>的字典中。该字典包含类名和描述键值对。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="6add" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们检查当前级别是否包含类，如果没有，我们不添加类部分。</p><p id="dd7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有类，我们添加类和类按钮部分的开头。然后我们遍历<code class="fe ns nt nu nv b">classes</code>，为每个项目添加一个按钮，只包含类<code class="fe ns nt nu nv b">name</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/615112d65fe315a55e94dd1782914714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CEaY0dfHx9kM-8sNDzZ7dg.gif"/></div></div></figure><p id="c20a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们添加类按钮的结尾和类描述(和链接)的开头。我们遍历每个项目，添加按钮内容。这允许我们在点击按钮时显示课程描述和链接。</p><p id="cc18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们结束这节课。</p><h1 id="3801" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">功能</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/c808927648ef7027d72be05b6496637a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_P4ByqHhz7Vy8imSuhs3OQ.png"/></div></div></figure><p id="5a4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数存储在名为<code class="fe ns nt nu nv b">funcs</code>的字典中，格式如上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="569b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于每个函数内部都有额外的参数层，所以这里还会发生更多的事情。</p><p id="496b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有函数都包含在一个无序列表<code class="fe ns nt nu nv b">&lt;ul&gt;</code>中，其中每个列表项<code class="fe ns nt nu nv b">&lt;li&gt;</code>由一个函数组成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/79b16c1317e3c97d3cf6daca4b382ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AhV-szjkJITXlPq-v4dqSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包含在<kbd>标签中的函数示例。</kbd></p></figure><p id="260f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先添加函数<code class="fe ns nt nu nv b">name</code>，然后添加包含在<code class="fe ns nt nu nv b">&lt;kbd&gt;</code>元素中的函数示例，通过用<code class="fe ns nt nu nv b">","</code>连接所有参数来构建。</p><p id="4c21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是参数表。这里我们用标签<code class="fe ns nt nu nv b">&lt;table&gt;</code>和<code class="fe ns nt nu nv b">&lt;tbody&gt;</code>初始化表格的开头。一个循环逐行构建表，由参数名和描述组成。</p><p id="203e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这之后是几个标签结束部分。由于functions部分是页面的最终动态构建部分，我们可以添加Bootstrap JS脚本和结束标记。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="bd53" class="mf mg it bd mh mi ox mk ml mm oy mo mp jz oz ka mr kc pa kd mt kf pb kg mv mw bi translated">生成文档</h1><p id="4238" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">一旦我们将所有这些代码提取和页面构建脚本放在一起，我们就可以只用几行代码来构建文档。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/44c8ca0c865d98e5230845b281409e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e60cJDB1ZBIujTYUDVMDDQ.png"/></div></div></figure><p id="f6a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，在这里，你在整篇文章中看到的所有东西都被构建到了<code class="fe ns nt nu nv b">DocsBuilder</code>类中。</p><p id="6896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用的所有提取正则表达式都包含在<code class="fe ns nt nu nv b">extract</code>方法中。在<code class="fe ns nt nu nv b">build</code>方法中的HTML构建代码。</p><p id="9df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在包含许多脚本和类的更大的项目中运行过相同的脚本。尽管如此，所有文档都是在瞬间构建的。</p><p id="05f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://github.com/jamescalam/autodocs" rel="noopener ugc nofollow" target="_blank"> autodocs GitHub repo </a>中找到所有的代码。它绝不是一个完成的项目，所以请随时提出改进建议或指出不必要的代码！</p><p id="7f89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何其他问题或建议，请随时通过<a class="ae ky" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或在下面的评论中联系我们。</p><p id="8429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="82f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您喜欢这篇文章，您可能会对我最近写的另一篇关于处理来自web的文本数据的文章感兴趣。重点关注机器学习的数据准备:</p><div class="pj pk gp gr pl pm"><a rel="noopener follow" target="_blank" href="/web-scraping-and-pre-processing-for-nlp-2e78810b40f1"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd iu gy z fp pr fr fs ps fu fw is bi translated">面向自然语言处理的网页抓取和预处理</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">使用Python抓取和处理web上的文本数据</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">towardsdatascience.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa ks pm"/></div></div></a></div></div></div>    
</body>
</html>