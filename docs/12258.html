<html>
<head>
<title>How Automated Data Validation using Pandera Made Me More Productive!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Pandera 的自动化数据验证如何让我更有效率！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-automated-data-validation-made-me-more-productive-7d6b396776?source=collection_archive---------13-----------------------#2020-08-24">https://towardsdatascience.com/how-automated-data-validation-made-me-more-productive-7d6b396776?source=collection_archive---------13-----------------------#2020-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d750" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据科学家的重要策略</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fc04768f40ed5936f6651bfe8fff5b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TKmUYqRYN7w02Vst"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@franckinjapan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Franck V. </a>拍摄的照片</p></figure><p id="ad6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> D </span> ata 被称为 21 世纪的<em class="me">新石油</em>。篡改数据以提取和使用正确的信息来解决我们的问题非常重要。对人们来说，处理数据是令人兴奋的，有时也是乏味的。正如正确的说法，“数据科学家花 80%的时间清理数据”。作为该包的一部分，当遇到新数据集时，我会经历相同的过程。同样的活动不限于，直到机器学习(ML)系统实现并部署到生产中。在实时生成预测时，数据可能会由于不直观和不可预见的情况而发生变化，如人为干扰导致的错误、提交的错误数据、数据的新趋势、记录数据时出现的问题等等。包含多个步骤的简单 ML 系统如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/26e1090997d51528349c46e1b68f7edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cuxYHMLOrbG63D5PzgPm0Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者(普拉蒂克·甘地)创造的形象</p></figure><p id="6e0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要通过明确引入或标记另一个组件来稍微改变，在数据准备之后和特征工程之前，我们命名为<strong class="lb iu"> <em class="me">数据验证</em> </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/c637b5e8cdd396d94b6020745a62c941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CW_AsvewR_WlUNUcfk7ELQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者(普拉蒂克·甘地)创造的形象</p></figure><p id="1610" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章关注的是为什么数据验证很重要，以及如何使用不同的策略将它无缝地集成到他们的管道中。经过一些工作后，我学会了如何实现脚本来进行数据验证，以节省一些时间。除此之外，我<strong class="lb iu">使用一些预建的包来自动化它们</strong>，加速我的游戏！</p><h1 id="0f17" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">听听我的故事！</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/f4b165e846075e2ca88db47122c75e9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SKbj3a9QjTIa3phA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@roadtripwithraj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">公路旅行照片，Raj </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</p></figure><p id="ebef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://www.bmc.com/blogs/cio-ai-artificial-intelligence/" rel="noopener ugc nofollow" target="_blank"> Gartner </a>的数据，几乎<strong class="lb iu"> 85% </strong>的项目将<em class="me">无法投入生产</em>。机器学习(ML)管道在投入生产时通常会遇到几个问题。我经常遇到的一个主要问题是数据质量的妥协。一天花几个小时，一个月可能花几次，并且弄清楚由于某种原因传来的数据是不可接受的，这可能会很令人宽慰，但同时也会令人沮丧。导致数据类型改变的原因有很多，例如，引入了文本而不是整数，整数在异常值上(可能高出 10 倍)，或者数据馈送中没有接收到整个特定列，等等。这就是增加这个额外步骤如此重要的原因。手动验证可能会花费额外的精力和时间。使其自动化(在一定程度上)可以减轻数据科学团队的负担。我认为在管道中集成自动化数据验证有一些主要的好处:</p><ul class=""><li id="1d63" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><strong class="lb iu">节省几个小时的时间</strong></li><li id="feeb" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><strong class="lb iu">团队成员之间的挫折感</strong></li><li id="1aff" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><strong class="lb iu">通过关注其他领域提高效率</strong></li><li id="a72b" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">努力使您的生产模型<strong class="lb iu">更加精确</strong>；)</li></ul><p id="c0c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 社区已经构建了一些优秀的包，以非常智能的方式处理这些问题。我将分享一些我探索过的，以及我如何设计我的脚本使它们成为我的管道的一部分。</p><p id="6cf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据源</strong>:我用了一个最近的数据集来展示如何实现这些包。下面是获取<a class="ae ky" href="https://www.kaggle.com/c/covid19-global-forecasting-week-5/data?select=train.csv" rel="noopener ugc nofollow" target="_blank">数据</a>的链接。</p><h1 id="a8f0" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">数据验证包</h1><h2 id="09d3" class="no mi it bd mj np nq dn mn nr ns dp mr li nt nu mt lm nv nw mv lq nx ny mx nz bi translated">潘德拉:</h2><p id="c679" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">Pandera 提供了一个非常简单灵活的 API，用于对数据帧或系列数据进行数据验证。它还有助于执行复杂的统计验证，比如像 two_sample_ttest 这样的<a class="ae ky" href="https://pandera.readthedocs.io/en/stable/hypothesis.html#wide-hypotheses" rel="noopener ugc nofollow" target="_blank">假设检验</a>。更多关于包装和使用的细节可以在<a class="ae ky" href="https://pandera.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7b81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从数据集中抽取 10 行样本:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/d1884a187605ddb2c720190ef0f6ed86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qDP8pDJhASD18tRj6D3AAA.png"/></div></div></figure><p id="689c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，有多个不同数据类型的列:String、Int、Float、Datetime。我们需要<em class="me">定义我们期望的数据的模式</em>。我定义了一个简单的模式，没有任何严格的数据验证检查规则，如上面的代码所示。根据期望的数据类型，我们可以用<strong class="lb iu"><em class="me">【pa.Int】</em></strong><em class="me"/>来表示<em class="me">整数，</em> <strong class="lb iu"> <em class="me"> pa。字符串</em> </strong> <em class="me"> </em>为<em class="me">字符串，</em> <strong class="lb iu"> <em class="me"> pa。</em> </strong>浮子<em class="me"> </em>为<em class="me">浮子或</em> <strong class="lb iu"> <em class="me"> pa。日期时间</em> </strong> <em class="me"> </em>如果有<em class="me">一个日期时间</em>。这里我们设置<strong class="lb iu"> <em class="me">可空=真</em> </strong>如果我们期望<em class="me"/>值否则<strong class="lb iu"> <em class="me">假</em> </strong>。此外，如果我们设置<strong class="lb iu"><em class="me">compete = True</em></strong>，它会将列转换为预期的数据类型，而不会给出任何错误。例如，用于将<em class="me">浮点数转换为整数，将整数转换为字符串</em>等。在验证数据时，输出将是数据帧本身，因为它通过了所有的检查(试试看！！！).如果失败，输出将如下所示:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="56e2" class="no mi it oj b gy on oo l op oq">Traceback (most recent call last):<br/>...<br/>ValueError: cannot convert float NaN to integer</span></pre><p id="42a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于潘德拉，我已经探索了一些惊人的能力，我会尽可能详细地解释。</p><h2 id="e8ce" class="no mi it bd mj np nq dn mn nr ns dp mr li nt nu mt lm nv nw mv lq nx ny mx nz bi translated">设置必需的列:</h2><p id="257b" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">有时，列可能是可选的，而不是必需的。在这样的情况下，我们可以设置<strong class="lb iu"> <em class="me"> required = False。</em> </strong>由<em class="me">默认</em> <strong class="lb iu"> <em class="me">必填=真</em> </strong> <em class="me"> </em>用于所有列</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c4e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在下面的截图中看到的，它返回数据作为输出，没有任何错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/a631cee890cff08119b16fecd75a58e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqHzm6SuB4LP07cQ5087iQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对于“ID”列，需要设置输出= False</p></figure><p id="550e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试为同一列设置<strong class="lb iu"><em class="me">required = True</em></strong>并再次运行上面的代码。</p><h2 id="a85d" class="no mi it bd mj np nq dn mn nr ns dp mr li nt nu mt lm nv nw mv lq nx ny mx nz bi translated">处理新列:</h2><p id="9a5a" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">默认情况下，如果新列被添加到数据框中且未在方案中定义，则不会引发错误。但是，如果你愿意你可以设置<strong class="lb iu"> <em class="me"> strict = True。</em> </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e2b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码，我们看到它抛出了模式中没有定义的错误<em class="me">‘extra _ column’</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/e66d01445f8364652f72edc341d03b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sY64G3W-278ilXacTJhCHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">设置 strict = True 和 lazy = False 时“extra_column”出错</p></figure><p id="c97e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看到我的代码，我已经添加了<strong class="lb iu"> <em class="me"> lazy = True </em> </strong>，它给出了如下更详细的视图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/5b8a76db31db0ca2b99626b06d460a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbsC1OWpeCq-1Y9VQAr2cA.png"/></div></div></figure><h2 id="3965" class="no mi it bd mj np nq dn mn nr ns dp mr li nt nu mt lm nv nw mv lq nx ny mx nz bi translated">索引验证:</h2><p id="9dad" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">如果数据集中存在任何特定模式或具有任何特殊重要性，也可以验证索引。例如，参见下文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="956c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建并设置该列作为索引，以展示我们如何进行索引验证。在模式的括号之外，可以指定预期的索引格式。同样，输出与之前相同</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/9c602801e55f1fcfec25cb34c1be1961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XIr5UbKdDZRFjhqL_mWkkQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用索引验证后的输出</p></figure><p id="7c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们执行了一个单一的索引验证。多索引验证可以以类似的方式执行。点击查看<a class="ae ky" href="https://pandera.readthedocs.io/en/stable/dataframe_schemas.html#multiindex-validation" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="842d" class="no mi it bd mj np nq dn mn nr ns dp mr li nt nu mt lm nv nw mv lq nx ny mx nz bi translated">数据架构转换:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/1a992e9a7dccfe3304464a38cf173c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J0zdlWWi1AUUdFLi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@juricakoletic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尤里察·科莱蒂</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="c2a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们定义了验证数据的模式，在由于额外的计算(100%的时间都会发生)而引入新的列之后，就有可能在管道本身中转换模式。假设最初我们只有 Id<em class="me">、County、Province_State、Country_Region、人口</em>作为列。我们向模式中添加新列<em class="me"> Weight、Date、Target、TargetValue </em>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="448d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在打印如上所示的模式时，我们得到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/2d35eb5f326aaba11654a1fc88e5c2c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JxuVf9YWgR_VOXvV9ZGKSg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加列后转换的架构</p></figure><p id="15f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果需要，我们也可以从模式中删除一些列，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/3a4b8bc09b2e69a35512fce937fdfaba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93hNCE1vlWzkLZiimFE72g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">删除列后的架构</p></figure><h2 id="983d" class="no mi it bd mj np nq dn mn nr ns dp mr li nt nu mt lm nv nw mv lq nx ny mx nz bi translated">检查列属性:</h2><p id="ec60" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">用户可以使用<em class="me">检查</em>对象对列进行更详细的检查，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="bc96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandera 有一些可以直接使用的预置检查，比如<em class="me">大于等于</em>、<em class="me">小于</em>。也可以传递自定义检查，例如，这里我们使用了<em class="me"> lambda </em>参数来计算字符串的长度。这是 Pandera 中最好的功能之一，可以为数据验证策略带来更多的价值。点击了解更多详情<a class="ae ky" href="https://greatexpectations.io" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="438e" class="no mi it bd mj np nq dn mn nr ns dp mr li nt nu mt lm nv nw mv lq nx ny mx nz bi translated">如何以及何时使用:</h2><ul class=""><li id="2bd3" class="na nb it lb b lc oa lf ob li oy lm oz lq pa lu nf ng nh ni bi translated">我创建单独的脚本，一旦在进入下一步之前接收到最终数据，就运行并给出验证报告。人们也可以将它们集成为预处理的一部分。</li><li id="7785" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">人们也可以直接把它们用作装饰者。这里看<a class="ae ky" href="https://pandera.readthedocs.io/en/stable/decorators.html." rel="noopener ugc nofollow" target="_blank">如何</a>。</li><li id="6d52" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">除了直接在数据帧上使用之外，它还可以应用于<em class="me">系列</em>，特定的<em class="me">列检查</em>，甚至是<em class="me">逐元素检查</em>。</li><li id="e9fb" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">由于灵活性<em class="me"> regex 操作</em>也可以使用 Pandera 对数据执行。</li><li id="0633" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">重要的是，你不可能一开始就有一个完美的数据验证模式。更有可能的是，当您在长时间内实时遇到数据时，通过合并不同的验证策略，您将使数据验证模式更加“完美”, ML 管道更加健壮。</li></ul><h1 id="8d3f" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">其他包:</h1><h2 id="71a6" class="no mi it bd mj np nq dn mn nr ns dp mr li nt nu mt lm nv nw mv lq nx ny mx nz bi translated">远大前程:</h2><p id="9225" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">顾名思义，您可以为要验证的数据设置期望值。老实说，我和潘德拉相处得太好了，以至于我没有机会去发掘他的全部潜力。它看起来很容易实现，并且可以直接打包使用。下面是相同数据的一小段实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="8b1d" class="no mi it bd mj np nq dn mn nr ns dp mr li nt nu mt lm nv nw mv lq nx ny mx nz bi translated">地狱犬:</h2><p id="d1cb" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">这是另一个语法类似于 Pandera 的包。当数据为<strong class="lb iu"> <em class="me">字典格式</em> </strong>或<strong class="lb iu"> <em class="me"> JSON </em> </strong> <em class="me"> </em>格式时，更适用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="6788" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个包的更多细节可以在<a class="ae ky" href="https://docs.python-cerberus.org/en/stable/index.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="61a9" class="no mi it bd mj np nq dn mn nr ns dp mr li nt nu mt lm nv nw mv lq nx ny mx nz bi translated">漏勺:</h2><p id="401c" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">如果您的数据是通过 XML、JSON 或 HTML 表单 post 获得的，这是另一个很棒的包。换句话说，验证任何类型的字符串、映射和列表数据都是有益的。以下是一些有用的链接:</p><p id="3eea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">Github</em>:<a class="ae ky" href="https://github.com/Pylons/colander" rel="noopener ugc nofollow" target="_blank">https://github.com/Pylons/colander</a></p><p id="033c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">文献</em>:<a class="ae ky" href="https://docs.pylonsproject.org/projects/colander/en/latest/" rel="noopener ugc nofollow" target="_blank">https://docs.pylonsproject.org/projects/colander/en/latest/</a></p><h2 id="6673" class="no mi it bd mj np nq dn mn nr ns dp mr li nt nu mt lm nv nw mv lq nx ny mx nz bi translated">JsonSchema:</h2><p id="2ac2" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">JsonSchema 是 Python 的 JSON 模式的一个实现。顾名思义，这个包对于验证 JSON 数据非常有帮助。以下面这个包含有效 JSON 数据和无效 JSON 数据的例子为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c43c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行无效数据时，它会抛出一个错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/6d6e424ef33fcd28414491908995b752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOI_fCvIAgYBNjc_nwcCHg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无效数据的错误</p></figure><p id="1db2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，价格应该是数字，但提供的是字符串。关于它的更多细节可以在这里找到<a class="ae ky" href="https://github.com/Julian/jsonschema" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="55a0" class="no mi it bd mj np nq dn mn nr ns dp mr li nt nu mt lm nv nw mv lq nx ny mx nz bi translated">结论:</h2><p id="252c" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">这个帖子可能看起来主要是由 Pandera 主导的，因为它是我经常使用的软件包之一。写这个帖子纯粹是为了分享我踏上的航程。我确信人们可以从这些特定用例的包中获益更多。经常多走一英里可以达到非凡的效果。数据验证无疑是“额外努力”。开发数据验证策略可能会感觉到额外的工作，但是如果养成了创建自动化脚本的习惯，即使是处理一些小事情，也一定会受益匪浅。</p><blockquote class="pc pd pe"><p id="c083" class="kz la me lb b lc ld ju le lf lg jx lh pf lj lk ll pg ln lo lp ph lr ls lt lu im bi translated">如果您有任何意见和建议，请随时分享！</p></blockquote></div></div>    
</body>
</html>