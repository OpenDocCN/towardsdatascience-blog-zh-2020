<html>
<head>
<title>How to configure IAM roles for Fargate Tasks on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在AWS上为Fargate任务配置IAM角色</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-configure-iam-roles-for-fargate-tasks-on-aws-76ad54f11314?source=collection_archive---------18-----------------------#2020-06-13">https://towardsdatascience.com/how-to-configure-iam-roles-for-fargate-tasks-on-aws-76ad54f11314?source=collection_archive---------18-----------------------#2020-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d959" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基本思想和具体实现</h2></div><p id="6028" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇博文是关于AWS上无服务器批处理作业的特定类型架构的三篇技术深度文章之一。如果你想了解更多关于云设置的背景，请点击<a class="ae le" href="https://blog.codecentric.de/en/2020/06/cost-effective-batch-jobs-on-aws-serverless-infrastructure/" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多细节。已实现服务的总体情况如下所示:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/2ec7945e1beff7e24f686da08cf47f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BTBz6dXPkYnNI7-sTBWJw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">完整的架构(作者插图)。</p></figure><p id="d723" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，该架构由一个用于开发的组件块和另一个用于执行批处理作业的组件块组成。对于这篇博文，我们只关注这个架构的<strong class="kk iu">角色和策略</strong>。还有一个<a class="ae le" href="https://github.com/timo-boehm/serverless_batch_aws" rel="noopener ugc nofollow" target="_blank">公共代码库</a>，允许你基于Cloudformation脚本复制完整的服务及其所有部分。</p><p id="2a82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们谈到角色和策略时，我们会谈到<strong class="kk iu">身份和访问管理(IAM) </strong>。It <strong class="kk iu"> </strong>构成了每个AWS云架构的主要安全块。IAM限制了在给定的云环境中哪个实体可以做什么。对于这篇博文，您需要理解两个概念:<strong class="kk iu">角色</strong>和<strong class="kk iu">策略</strong>。</p><p id="32ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用户或服务想要在云中做一些事情时，他们承担<strong class="kk iu">角色</strong>。当您指定一个角色时，您可以限制可以使用它的实体的类型。例如，您可以为人类用户定义一个角色，允许他们查看所有内容，但不能更改任何内容。如果AWS服务试图使用该角色，它会失败。将角色视为用户或服务在您的云环境中可以做什么的组织保护伞。</p><p id="b5d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">策略</strong>，相反，<strong class="kk iu"> </strong>列出了角色可以执行的具体动作。与角色限制哪个实体可以承担它们一样，策略也限制它们可以使用哪些资源。</p><p id="fc12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你设计你的角色和政策时，坚持最小特权原则。也就是说，只允许服务需要的访问和操作。超出这个范围的任何扩展都是潜在的安全问题。例如，如果服务需要将数据写入S3存储桶，您不应该实现允许所有S3操作的策略。</p><p id="e51d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们进入大图之前，让我们先从云形成脚本的小入门开始。如果你已经有了云形成或者类似概念的经验，你可以略读或者跳过下面三段。</p><p id="4468" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> CloudFormation </strong>是针对<em class="lv">基础设施的AWS服务，代码为</em>。也就是说，您定义一个目标基础设施，将其推送给AWS，AWS为您提供它。您将资源组织在所谓的堆栈中，这使得调整、监控或删除它们变得非常容易。</p><p id="2ced" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在JSON或YAML文件中编写CloudFormation脚本。这里和代码库中的所有例子都是YAML文件，但是您也可以在JSON中做同样的事情。</p><p id="8c02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一组专门针对CloudFormation的命令可供您使用。在接下来的例子中，我使用了其中的三个:</p><ol class=""><li id="584e" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld mb mc md me bi translated"><strong class="kk iu">！Ref </strong>是内部参考；也就是说，CloudFormation从同一个脚本中插入一个值。</li><li id="26d0" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld mb mc md me bi translated"><strong class="kk iu">！Sub </strong>用于将变量替换成字符串。</li><li id="6108" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld mb mc md me bi translated"><strong class="kk iu">！GetAtt </strong>类似于“！Ref”但是指向资源的特定属性，而不是一般的引用。</li></ol></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="3730" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">大局</h1><p id="36fe" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">从角色和策略的角度来看，我们必须考虑服务的两个组成部分。对于每个部分，我们需要确定哪些服务需要与其他服务进行交互。没有传出交互的服务，如S3或代码库，可以保持原样。需要与其他组件进行交互的服务需要允许它们这样做的策略。</p><p id="31ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于<strong class="kk iu">开发组件</strong>，我们需要确保我们可以构建一个容器映像并将其推送到注册表中。对于<strong class="kk iu">批处理作业组件</strong>，我们需要确保触发器可以运行来自注册表的最新容器映像。</p><p id="3b2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了避免抽象的思考，让我们深入实现细节。我为每个构建块提供了一个概览图，以便您可以直观地了解。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="4b3b" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">实施细节</h1><p id="4438" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">如前所述，角色是策略的组织保护伞。为了简单起见，本例中的每个角色都只与一个策略相关。在我们研究每个策略之前，让我向您介绍一下角色的两个主要属性:</p><ol class=""><li id="3bdf" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld mb mc md me bi translated">AssumeRolePolicyDocument 定义了哪个服务可以承担这个角色。文档的<em class="lv">主体</em>部分(参见下面的代码片段以了解详细信息)描述了这一点。<em class="lv">动作</em>部分的<em class="lv"> sts </em>是<strong class="kk iu"> AWS安全令牌服务</strong>的缩写。该服务提供临时凭据来验证操作。</li><li id="6668" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld mb mc md me bi translated">ManagedPolicyArns指的是与该角色相关联的策略文档。ARN是一个亚马逊资源名称，作为在AWS上创建的资源的ID。</li></ol><p id="6535" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是以CodeBuild角色为例的CloudFormation中的情况:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="898a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最佳实践是为架构的每个组件定义一个角色。从技术上讲，您可以将策略嵌入到您的角色定义中。但是，如果创建一个单独的策略资源，阅读和维护起来会更容易。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f6fd" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">发展部分的政策</h1><p id="83d5" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">开发工作流中涉及到两个服务:<strong class="kk iu">代码管道</strong>和<strong class="kk iu">代码构建</strong>。CodePipeline是一个编排工具，每当开发人员将新版本的主分支推送到代码存储库时，它就会触发CodeBuild项目。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/70b84b2145f1a4abb6e3b1000bcf2c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*Cl-rBODSOkGv4JT_h9Va9A.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">代码管道策略(作者举例说明)。</p></figure><p id="cf95" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们看看<strong class="kk iu">代码管道</strong>。在我们的场景中，服务需要与三个服务交互:</p><ul class=""><li id="6b2c" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld nr mc md me bi translated">它需要从<strong class="kk iu"> CodeCommit </strong>接收更新，以在主分支中注册更改。</li><li id="005d" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld nr mc md me bi translated">反过来，它需要触发相关的<strong class="kk iu"> CodeBuild </strong>项目的新运行。</li><li id="3929" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld nr mc md me bi translated">它需要能够保存和收集从<strong class="kk iu"> S3 </strong>工件。</li></ul><p id="1496" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是CodePipeline在CloudFormation中的角色和相关策略:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="no np l"/></div></figure><blockquote class="ns nt nu"><p id="b723" class="ki kj lv kk b kl km ju kn ko kp jx kq nv ks kt ku nw kw kx ky nx la lb lc ld im bi translated"><strong class="kk iu">注意:</strong>为了简单起见，在这个例子和下面的例子中，我没有限制资源。在现实世界的实现中，最小特权原则也要求您最小化被访问的资源！</p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ny"><img src="../Images/6b7e764880c8e327b6dfc2dc7972996b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_xqfaF3rIk6GtooJGo50Cw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">代码构建策略(作者举例说明)。</p></figure><p id="88c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其次，还有<strong class="kk iu"> CodeBuild </strong>。它涉及四种不同的服务。</p><ul class=""><li id="1fb0" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld nr mc md me bi translated">它需要从<strong class="kk iu"> CodeCommit </strong>中克隆存储库。</li><li id="7f08" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld nr mc md me bi translated">它需要读写来自<strong class="kk iu"> S3 </strong>的工件。</li><li id="1603" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld nr mc md me bi translated">它需要将新图像推送到<strong class="kk iu">弹性容器注册中心(ECR) </strong>。</li><li id="ff6d" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld nr mc md me bi translated">它需要将日志信息写入<strong class="kk iu"> CloudWatch </strong>。</li></ul><p id="8e01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一点是可选的，但是我保证如果你漏掉了它，你会后悔的。相应的CloudFormation脚本如下所示:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1051" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开发组件的两个角色应该是不言自明的。现在事情变得有点复杂了。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="3a7e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">批处理作业组件的策略</h1><p id="377a" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">我们现在要为批处理作业定义角色和策略。也就是说，对于Fargate任务和触发它的CloudWatch规则。让我们先从稍微令人困惑的一个开始:Fargate任务。</p><p id="1ec7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然在架构图中一个盒子代表了<strong class="kk iu"> Fargat任务</strong>，但是它需要两个角色。想想你和老板的关系。你的老板有权给你分配任务。你需要工具来完成指定的工作。这也是你为法盖特所需要的。一个执行角色，也称为“老板角色”，一个任务角色，也称为“员工角色”</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/cc4e7aa37d74c391a8d1fc97c387a4ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*xdwmqa6ejoDc20aVVW-ixQ.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">Fargate policies(作者插图)。</p></figure><p id="a0d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">执行角色</strong>包含对两个服务的访问:</p><ul class=""><li id="7e05" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld nr mc md me bi translated">它需要访问<strong class="kk iu">弹性容器注册表(ECR) </strong>中的容器图像。否则，它将无法加载和启动批处理作业的容器映像。</li><li id="2d06" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld nr mc md me bi translated">与CodeBuild类似，它需要将日志信息写入<strong class="kk iu"> CloudWatch </strong>。</li></ul><p id="f57e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是CloudFormation中执行角色及其策略的样子:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2fc5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">任务角色</strong>的重要策略取决于开发人员在容器映像中放入了什么。也就是说，不知道开发人员实现了什么，您就不能决定正确的策略集。让我们假设该任务从S3加载一些数据，对其进行转换，并将其写回到另一个桶中。在这个简单的例子中，您需要为任务角色配置两个服务:</p><ul class=""><li id="6ad1" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld nr mc md me bi translated">它需要访问<strong class="kk iu"> S3 </strong>桶来获取数据并保存输出。</li><li id="595c" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld nr mc md me bi translated">它需要将日志信息写入<strong class="kk iu"> CloudWatch </strong>。</li></ul><p id="a448" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有关详细信息，请查看CloudFormation规范:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b2fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，特定的资源和操作完全取决于容器映像中实现的业务逻辑。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/08f033201dadcec76e26fcc5782479a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*8yQUbJbIE5C4XA8dkdCsFA.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">CloudWatch政策(作者插图)。</p></figure><p id="300d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后是<strong class="kk iu"> CloudWatch规则</strong>，它触发批处理作业。它的角色和政策也很简单，涉及两种服务:</p><ul class=""><li id="aecb" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld nr mc md me bi translated">如果需要，它需要访问<strong class="kk iu"> IAM </strong>来将角色传递给Fargate任务。</li><li id="4e5b" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld nr mc md me bi translated">它需要访问<strong class="kk iu">弹性容器服务(ECS) </strong>，这是<strong class="kk iu"> Fargate </strong>背后的编排服务。</li></ul><p id="3b92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是云形成规范:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a6b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一点上，一个自然的问题是:为什么有几个地方允许访问CloudWatch日志？为什么不为日志记录定义一个策略，并将它附加到所有需要它的角色上呢？</p><p id="124c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">避免这种情况的一个主要原因是:共享策略增加了资源之间的依赖性。这些依赖会在以后反噬你。如果您更改由几个角色承担的策略，您可能会在没有意识到的情况下破坏东西。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="c241" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这篇文章能帮助你更好地理解如何思考和构建IAM角色和策略。同样，如果你想了解更多关于架构的知识，请参考<a class="ae le" href="https://blog.codecentric.de/en/2020/06/cost-effective-batch-jobs-on-aws-serverless-infrastructure/" rel="noopener ugc nofollow" target="_blank">概念文章</a>。如果你打算重建它，看看<a class="ae le" href="https://github.com/timo-boehm/serverless_batch_aws" rel="noopener ugc nofollow" target="_blank">公共代码库</a>。此外，很快还会有一篇文章将这一讨论扩展到整个服务的具体构建块。如果你对这种服务的网络方面更感兴趣，我已经给<a class="ae le" rel="noopener" target="_blank" href="/network-configurations-for-fargate-tasks-6333314c4001">写了一篇关于这个</a>的博文。</p><p id="f076" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请在评论中告诉我你的想法和经历。我也很乐意在<a class="ae le" href="https://twitter.com/timo_data" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae le" href="https://www.linkedin.com/in/timo-boehm-datascience/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系。感谢您的阅读！</p></div></div>    
</body>
</html>