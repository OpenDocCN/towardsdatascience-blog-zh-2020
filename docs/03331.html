<html>
<head>
<title>Image Denoising with Gibbs Sampling (MCMC)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于吉布斯采样的图像去噪</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-denoising-with-gibbs-sampling-mcmc-concepts-and-code-implementation-11d42a90e153?source=collection_archive---------20-----------------------#2020-03-30">https://towardsdatascience.com/image-denoising-with-gibbs-sampling-mcmc-concepts-and-code-implementation-11d42a90e153?source=collection_archive---------20-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fea2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">概念和代码实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/41e347c28b720ebccd8268a1a7f8e00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RBAn0XpIqeH-yud-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="e561" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本教程中，我将向你展示如何实现吉布斯采样算法去噪图像。</p><p id="6c15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的目标是通过使用吉布斯采样(一种马尔可夫链蒙特卡罗(MCMC)方法)从受损图像(右)中去除噪声来恢复真实图像(左)。</p><div class="kj kk kl km gt ab cb"><figure class="lu kn lv lw lx ly lz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/302e9cbfe3814701d986a2d4bcaaeece.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*m4cmibwzgmcMf_bP9p6YtQ.png"/></div></figure><figure class="lu kn ma lw lx ly lz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/1f3ef3270499443d2e64b400799a352e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*REVHVKblJtPd_8sVtUKU4Q.png"/></div></figure></div><p id="7c26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本教程分为三个部分:</p><ol class=""><li id="9fc5" class="mb mc it la b lb lc le lf lh md ll me lp mf lt mg mh mi mj bi translated">MCMC 和 Gibbs 抽样的理论概念</li><li id="b383" class="mb mc it la b lb mk le ml lh mm ll mn lp mo lt mg mh mi mj bi translated">这个问题的数学推导</li><li id="6ba2" class="mb mc it la b lb mk le ml lh mm ll mn lp mo lt mg mh mi mj bi translated">Python 中的代码实现</li></ol><h1 id="0b41" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">MCMC 和 Gibbs 抽样</h1><p id="ee54" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">马尔可夫链蒙特卡罗(MCMC)是一种采样方法，用于通过从概率分布中随机采样并构建马尔可夫链来近似感兴趣参数的后验分布。</p><p id="2080" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Gibbs 采样是一种 MCMC 算法，它生成样本的马尔可夫链，每个样本都与其直接邻居一起计算。例如，在贝叶斯网络中，每个样本仅依赖于其父节点、共同父节点和子节点；在马尔可夫随机场中，每个样本都与其马尔可夫毯相关联。这个独立性属性简化了问题，因为为了获得状态 s 的样本值，我们只需要条件概率<strong class="la iu"> P(s|s_neighbors) </strong>。</p><p id="2b85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">MCMC 算法通常有一个预烧期，在此期间样本可能不准确。因此，在预烧期后收集样本，并使用蒙特卡罗方法估计后验概率。</p><h1 id="d3e8" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">数学演绎</h1><p id="7cae" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">吉布斯采样的应用之一是图像去噪。对于我们的图像去噪问题，给定一个有噪声的图像<strong class="la iu"> X </strong>，目标是将其恢复到原始图像<strong class="la iu"> Y </strong>，未知。</p><p id="6814" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们知道一个噪声图像数组<strong class="la iu"> X <em class="nm"> = {xij} </em> </strong>，其中<strong class="la iu"><em class="nm">xij∈{-1，+1} </em> </strong>表示第 I 行第 j 列的像素，图像是黑白的，<strong class="la iu"> <em class="nm"> xij </em> = 1 </strong>对应黑色，<strong class="la iu"> <em class="nm"> xij = </em> -1 </strong>对应白色。</p><p id="b2ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原始图像(无噪声)<strong class="la iu"> Y </strong>与有噪声图像<strong class="la iu"> X </strong>大小相同，其中<strong class="la iu"><em class="nm">yij</em>∈{-1，+1} </strong>表示添加噪声前 xij 的值。</p><p id="0074" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">去噪可以被视为概率推断，其中我们通过最大化后验分布<strong class="la iu"> p(Y|X) </strong>来执行最大后验(MAP)估计。由贝叶斯定理我们得到:<em class="nm"/><strong class="la iu"><em class="nm">p(Y | X)= p(X | Y)p(Y)/p(X)</em></strong>。在日志空间，这可以重写为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/5783d8607e0e847b7143fd58bd0452a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pSdpcouRwsQACY8A"/></div></div></figure><p id="35aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然给定了 X，最大化<strong class="la iu"> log p(Y|X) </strong>本质上等价于最小化<strong class="la iu">—log p(X | Y)—log p(Y)</strong>，这就是这个问题中的损失函数。</p><p id="6522" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用于图像去噪的经典结构是成对 MRF，如下图所示。每个节点<strong class="la iu"> <em class="nm"> yij </em> </strong>与其对应的输出 xij 和 4 个直接邻居(上、下、左、右)相连。因此，给定像素<strong class="la iu"> <em class="nm"> yij、</em> </strong>的 5 个邻居，我们可以确定<strong class="la iu"> <em class="nm"> yij </em> </strong>的概率分布，而无需查看其他像素。请注意，边缘上的像素具有较少的邻居。例如，y11 的邻居是 y12、y21 和 x11。为了方便起见，我们可以在实现算法时用 0 填充边缘，这样所有像素都有 5 个邻居。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/6baaaeb92b56c25e1d0b24d053692f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/0*BcUu_Wuw7ufa608L"/></div></figure><p id="71f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们的后验偏好是黑色，我们想要最大化的后验是<strong class="la iu"> p(Y=1|Y_neighbors) </strong>，其中<strong class="la iu"> Y= { <em class="nm"> yij </em> }对于 i = 1，…，N，j = 1，…，M </strong>。<strong class="la iu"> Y </strong>和<strong class="la iu"> X </strong>的联合概率为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/0e29d5b4cf06a97adc3c101ab5bec007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*NkugmA_jaNQrjM_-btekTQ.png"/></div></figure><p id="8eed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中 ita( <strong class="la iu"> <em class="nm"> η </em> </strong>)和 beta( <strong class="la iu"> <em class="nm"> β </em> </strong>)是我们的超参数，Z 是归一化常数。<strong class="la iu"> N(ij) </strong>是<strong class="la iu"> <em class="nm"> yij </em> </strong>除<strong class="la iu"> <em class="nm"> xij </em> </strong>外的对应邻居。</p><p id="150d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用贝叶斯规则，我们可以从联合分布中得到后验分布，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/28b150b636314461ce5eab28185ee4d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iP_uYf1riMC7_B-qF87yrw.png"/></div></div></figure><p id="63c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还可以得到损失函数<strong class="la iu">—log p(X | Y)——log p(Y)，</strong>写为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/584fd991b7d8743220abf6d83825788e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kialRIbsFBr0XLdcouwj7A.png"/></div></div></figure><p id="993f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们称之为能量，因为损失相当于玻尔兹曼分布中的能量，其中具有较低能量的状态总是具有较高的概率。</p><p id="70bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了所有的数学方程式，现在我们可以开始了！</p><p id="e831" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下一节中，我们将学习如何在 Python 中实现 Gibbs 采样来恢复图像。</p><h1 id="10a0" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">代码实现</h1><p id="6838" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">首先，我编写了一些伪代码来演示吉布斯采样的高级逻辑:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/fd6b6b019b9d35b5e0890e9d3e5b4594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GfDqYovc8oUvw5EOiFDgWg.png"/></div></div></figure><p id="b796" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们深入研究代码！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b43e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数<code class="fe nv nw nx ny b">denoise_image()</code>是入口函数。它调用另一个函数 get_posterior 来获得估计的后验概率<strong class="la iu"> p(Y=1|Y_neighbor) </strong>。将阈值设置为 0.5，我们可以从后验得到恢复的图像数组 Y。接下来，我们剥离图像数组的边缘并返回它。下面的 load_image 函数解释了为什么我们需要剥离数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f356" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nv nw nx ny b">load_image()</code>中，我们首先将 PNG 图像读入一个 numpy 数组，然后将 RGB 图像转换为灰度，并将像素重新缩放为{-1，1}。在这里，我们添加 0 填充到边缘，以帮助我们在以后搜索每个像素的邻居时处理拐角情况。</p><p id="d78e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以跳到<code class="fe nv nw nx ny b">get_posterior</code>函数中的主要逻辑实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="50f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在加载噪声图像<strong class="la iu"> X </strong>并随机初始化恢复图像<strong class="la iu"> Y </strong>之后，我们开始循环采样<strong class="la iu"> Y </strong>并计算后验概率<strong class="la iu"> P(Y|Y_neighbor) </strong>。</p><p id="0689" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在每一步，我们迭代 I，j，通过调用函数<code class="fe nv nw nx ny b">sample_y()</code>对<strong class="la iu"> Y </strong>中的每个像素<strong class="la iu"> <em class="nm"> yij </em> </strong>进行采样，并用采样值<strong class="la iu"> <em class="nm"> yij </em> </strong>更新<strong class="la iu"> Y </strong>。我们还跟踪能量(等式 6)，以便稍后可以可视化收敛。当老化期结束时，我们对 Y 中的<em class="nm"> yij </em>的事件<strong class="la iu"> <em class="nm"> yij </em> = 1 的总发生次数进行求和。</strong></p><p id="a3cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦采样完成，我们使用蒙特卡罗方法来获得后验概率，这实质上是将<strong class="la iu"> Y </strong>的聚合值除以总样本数。</p><p id="7caa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个样品<strong class="la iu"> <em class="nm"> yij </em> </strong>是怎么得到的？我们来看看函数<code class="fe nv nw nx ny b">sample_y()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ad9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nv nw nx ny b">sample_y()</code>功能需要 4 个输入:行和列索引 I 和 j、恢复图像阵列<strong class="la iu"> Y </strong>和噪声图像阵列<strong class="la iu"> X </strong>。该函数搜索<strong class="la iu"> <em class="nm"> yij </em> </strong>的<strong class="la iu"> <em class="nm"> </em> </strong>邻居<strong class="la iu"><em class="nm">yij _ neighbors</em></strong>并根据<strong class="la iu">等式(5) </strong>计算条件概率<strong class="la iu">P(<em class="nm">yij = 1 | yij _ neighbors</em>)</strong>。</p><p id="96e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nm"> yij </em> </strong> (1 或-1)的值用条件概率采样并由函数返回。</p><p id="7c11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们有两个助手函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="514a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nv nw nx ny b">plot_energy()</code>将节省的能量可视化，<code class="fe nv nw nx ny b">save_image()</code>帮助将去噪后的图像 numpy 数组转换为 PNG 图像。</p><p id="7dc2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们把所有东西放在<code class="fe nv nw nx ny b">main</code>模块中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ab8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们指定超参数 ita( <strong class="la iu"> <em class="nm"> η </em> </strong>)和 beta( <strong class="la iu"> <em class="nm"> β </em> </strong>)、总样本数和老化步骤。我们还设置了一个日志路径来记录能量。</p><p id="0989" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">来自<code class="fe nv nw nx ny b">denoise_image()</code>的输出降噪 _img 是恢复的图像阵列<strong class="la iu"> Y </strong>。</p><p id="7abb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">经过 100 步老化和 1000 步采样，我们可以看到我们的吉布斯采样做了一个体面的工作恢复损坏的图像，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/84e553c398b2146e4582049a6030bebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*MvqJt49pKn_SlTxehmEiBA.png"/></div></figure><p id="4241" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也可以检查能量汇聚。从下图中，我们发现虽然图像<strong class="la iu"> Y </strong>被随机初始化，但是能量很快收敛到一个低值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/97dfa033f410aa8a13a134fbb6e35de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*uLH6hJnQBOJwlkh-"/></div></figure><p id="2112" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！你可以在我的<a class="ae oa" href="https://github.com/VXU1230/Medium-Tutorials/tree/master/mcmc_gibbs" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到完整的代码实现。</p><h1 id="7bcb" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">我们从这篇文章中学到了什么</h1><ol class=""><li id="b6c5" class="mb mc it la b lb nh le ni lh ob ll oc lp od lt mg mh mi mj bi translated">马尔可夫链蒙特卡罗(MCMC)和吉布斯抽样；</li><li id="30f6" class="mb mc it la b lb mk le ml lh mm ll mn lp mo lt mg mh mi mj bi translated">基于成对马尔可夫随机场模型的地图推理:</li><li id="2b2d" class="mb mc it la b lb mk le ml lh mm ll mn lp mo lt mg mh mi mj bi translated">如何在 Python 中对图像去噪应用 Gibbs 采样</li></ol><p id="0906" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢这篇文章:)</p><h1 id="a6dc" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">参考</h1><ol class=""><li id="b979" class="mb mc it la b lb nh le ni lh ob ll oc lp od lt mg mh mi mj bi translated"><a class="ae oa" href="http://stanford.edu/class/ee367/Winter2018/yue_ee367_win18_report.pdf" rel="noopener ugc nofollow" target="_blank">马尔可夫随机场和吉布斯采样用于图像去噪</a></li><li id="1786" class="mb mc it la b lb mk le ml lh mm ll mn lp mo lt mg mh mi mj bi translated"><a class="ae oa" href="https://ermongroup.github.io/cs228-notes/inference/sampling/" rel="noopener ugc nofollow" target="_blank">采样方法</a></li></ol></div></div>    
</body>
</html>