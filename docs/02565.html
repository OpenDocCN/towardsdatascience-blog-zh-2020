<html>
<head>
<title>6 SQL Tricks Every Data Scientist Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个数据科学家都应该知道的6个SQL技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/6-sql-tricks-every-data-scientist-should-know-f84be499aea5?source=collection_archive---------1-----------------------#2020-03-12">https://towardsdatascience.com/6-sql-tricks-every-data-scientist-should-know-f84be499aea5?source=collection_archive---------1-----------------------#2020-03-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0375" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高分析效率的SQL技巧的第1部分</h2></div><p id="f0d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据科学家/分析师应该了解SQL，事实上，所有从事数据和分析工作的专业人士都应该了解SQL。在某种程度上，SQL是一种被低估的数据科学技能，因为它被认为是从数据库中提取数据的必要而不酷的方式，以提供给pandas和{tidyverse} —争论数据的更好的方式。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi le"><img src="../Images/dc680878cfd045435fc4f47c4d1fe6ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*gIC33_Ao-nCPa2q5Xl-vGA.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated"><a class="ae lq" href="https://webflow-blog.periscopedata.com/blog/why-were-launching-r-and-python-support" rel="noopener ugc nofollow" target="_blank">照片来源</a></p></figure><p id="3c7b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，随着行业中每天收集和产生大量数据，只要数据驻留在符合SQL的数据库中，SQL仍然是帮助您调查、过滤和聚合以彻底了解您的数据的最熟练的工具。通过对SQL进行切分，分析人员可以识别出值得进一步研究的模式，这常常会导致重新定义分析群体和变量，使之比初始范围小得多。</p><p id="e00a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，分析的第一步不是将庞大的数据集转移到Python或R中，而是使用SQL从我们的数据中获得信息性的见解。</p><p id="df13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在现实世界的关系数据库中，SQL不仅仅是SELECT、JOIN、ORDER BY语句。在这篇博客中，我将讨论6个技巧(和一个额外的技巧),让你的SQL分析工作更有效，并与Python和r等其他编程语言集成。</p><p id="39b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本练习中，我们将使用Oracle SQL处理下面的玩具数据表，该数据表包含多种类型的数据元素，</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lr"><img src="../Images/271b440cacf0371d3f35eecce833a6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXQELNgmZqWDBOuWb4mFHw.png"/></div></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">玩具数据表(带有变量定义)</p></figure><ol class=""><li id="ad0b" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld mb mc md me bi translated"><strong class="kk iu"> COALESCE()记录空/缺失数据</strong></li></ol><p id="e09e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当谈到重新编码丢失的值时，COALESCE()函数是我们的秘密武器，在这种情况下，它将NULL值重新编码为第二个参数中指定的任何值。对于我们的例子，我们可以将NULL_VAR重新编码为一个字符值‘MISSING’，</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="164b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码片段返回，</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/ecef92d41e00fa76640757ca8682bf96.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*lBZX417NcqAbFYsqGfOdoA.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">COALESCE()记录空值</p></figure><p id="9cc9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，一个重要的注意事项是，在数据库中，<strong class="kk iu"> <em class="mi">缺失值</em> </strong>可以用除NULL之外的各种方式编码。例如，它们可以是空字符串/空格(例如，我们表中的EMPTY_STR_VAR)，或者字符串“NA”(例如，我们表中的NA_STR_VAR)。在这些情况下，COALESCE()不起作用，但是可以用CASE WHEN语句来处理它们，</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mf mg l"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">何时对空或NA重新编码</p></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mj"><img src="../Images/f202d01b3ff0cc31002af4f8863c8812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TnjLJWR6NC_FgSApoRdT4A.png"/></div></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">以下情况下的输出</p></figure><p id="1f43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="mi"> ***更新2022:你也可以在我的频道这里看这个博客的视频版，</em> </strong></p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mk mg l"/></div></figure><p id="e3bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 2。计算运行总频率和累计频率</strong></p><p id="6c76" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们对给定点的总和(而不是单个值)感兴趣时，运行总计对于潜在分析人群细分和异常值识别非常有用。</p><p id="900b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面展示了如何计算变量NUM_VAR的累计和累计频率，</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mf mg l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/395b61437fa3db8f787c9034465d874d.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*fktE0oU8gIqufDjj1QB_qQ.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">累积频率的输出</p></figure><p id="3922" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们的输出(在左边)。</p><p id="a87a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有两个技巧，(1)SUM over<a class="ae lq" href="https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#SQLRF06174" rel="noopener ugc nofollow" target="_blank">ROWS UNBOUNDED previous</a>将计算到该点的所有先前值的总和；(2)创建一个JOIN_ID来计算总和。</p><p id="097a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<a class="ae lq" href="https://en.wikipedia.org/wiki/SQL_window_function" rel="noopener ugc nofollow" target="_blank">窗口函数</a>进行计算，根据累积频率，不难发现最后一条记录是异常值。</p><p id="4fe0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 3。查找没有自连接的极值记录</strong></p><p id="d673" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们的任务是返回每个惟一ID的NUM_VAR值最大的行。直观的查询是首先使用group by找到每个ID的最大值，然后对ID和最大值进行自连接。然而一种更简洁的方式是，</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mf mg l"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">具有最大值的记录</p></figure><p id="800c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个查询应该给出下面的输出，显示具有按ID分组的最大数量变量的行，</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mm"><img src="../Images/ff9657cd60a3891132209a2cf587a54f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7UYh5AXY8sxOvjam3CHtlg.png"/></div></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">具有最大NUM_VAR值的记录输出</p></figure><p id="6d45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 4。条件WHERE子句</strong></p><p id="3abb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大家都知道SQL中用于subsetting的WHERE子句。事实上，我发现自己更经常地使用条件WHERE子句。例如，对于玩具表，我们只想保持满足以下逻辑的行，</p><p id="1e29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">—如果SEQ变量in (1，2，3) &amp; diff(日期变量2，日期变量1)≥ 0</p><p id="01ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">— elif SEQ变量in (4，5，6) &amp; diff(日期变量2，日期变量1) ≥1</p><p id="2a2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">— else diff(DATE_VAR2，DATE_VAR1) ≥2</p><p id="990b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在条件WHERE子句就派上用场了，</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mf mg l"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">条件where子句</p></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/7877346a76e38b0dbc3cb80f4b98fa90.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*hJJw2gp6vmoRgufDYBqg1g.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">条件where子句的输出</p></figure><p id="fb55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">前面提到的逻辑应该消除ID = 19064的序列4，5，因为date2和date1之间的差= 0，这正是上面查询返回的结果。</p><p id="4f3c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 5。Lag()和Lead()处理连续行</strong></p><p id="3213" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Lag(查看前一行)和Lead(查看下一行)可能是我日常工作中最常用的两个分析函数<a class="ae lq" href="https://oracle-base.com/articles/misc/analytic-functions#using_analytic_functions" rel="noopener ugc nofollow" target="_blank">。简而言之，这两个函数允许用户一次查询多行，而无需自连接。更详细的解释可以在</a><a class="ae lq" href="https://www.techonthenet.com/oracle/functions/lag.php" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="0a18" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设，我们想要计算两个连续行(按序列排序)之间的NUM_VAR差异，</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="c477" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">LAG()函数返回前一行，如果没有(即每个ID的第一行)，PREV_NUM被编码为0，以计算如下所示的NUM_DIFF之差，</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/ef56beb22f40cc9a9a6d19e2a6e21d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*kmedEX6-wp2Q86TnxDH9ZQ.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">滞后的输出( )</p></figure><p id="726c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 6。将SQL查询与Python和R集成</strong></p><p id="fe93" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将SQL查询集成到Python和R中的先决条件是通过ODBC或JDBC建立数据库连接。由于这超出了本博客的范围，我将不在这里讨论它，然而，关于如何(创建ODBC或JDBC连接)的更多细节可以在<a class="ae lq" href="https://www.progress.com/blogs/complete-guide-to-r-for-datadirect-odbc-jdbc" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="eb7f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，假设我们已经将Python和R连接到我们的数据库，那么在Python中使用query的最直接的方法就是将它复制并粘贴为一个字符串，然后调用pandas.read_sql()，</p><pre class="lf lg lh li gt mp mq mr ms aw mt bi"><span id="5ebd" class="mu mv it mq b gy mw mx l my mz">my_query = "SELECT * FROM CURRENT_TABLE"<br/>sql_data = pandas.read_sql(my_query, connection)</span></pre><p id="62d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，只要我们的查询是简短的，并且没有进一步的修改，这种方法工作得很好。但是，如果我们的查询有1000行，或者我们需要不断地更新它，该怎么办呢？对于这些场景，我们会希望阅读<em class="mi">。sql </em>文件直接导入Python或者R .下面演示如何用Python实现一个getSQL函数，R中的思路也是一样的，</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="db4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，第一个arg sql_query包含一个独立的<em class="mi">。容易维护的sql </em>文件，像这样，</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="c6bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“ID_LIST”是我们将要放入的值的占位符字符串，可以使用下面的代码调用getSQL()。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="9d1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">额外提示，SQL中的正则表达式</strong></p><p id="b6cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管我并不总是在SQL中使用正则表达式，但它有时对于文本提取来说很方便。例如，下面的代码展示了如何使用REGEXP_INSTR()查找和提取数字的简单示例(更多细节请参见<a class="ae lq" href="https://www.techonthenet.com/oracle/functions/regexp_instr.php#:~:text=" rel="noopener ugc nofollow" target="_blank">，</a></p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="b75f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这篇博客对你有所帮助，完整的代码和玩具数据集可以在我的<a class="ae lq" href="https://github.com/YiLi225/SQL_Python_R" rel="noopener ugc nofollow" target="_blank"> github </a>中找到。😀</p><p id="24a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="mi">想要更多数据科学和编程技巧？使用</em> </strong> <a class="ae lq" href="https://yilistats.medium.com/membership" rel="noopener"> <strong class="kk iu"> <em class="mi">我的链接</em> </strong> </a> <strong class="kk iu"> <em class="mi">注册Medium，获得我所有内容的全部访问权限。</em> </strong></p><p id="9718" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="mi">还订阅我新创建的YouTube频道</em> </strong> <a class="ae lq" href="https://www.youtube.com/channel/UCbGx9Om38Ywlqi0x8RljNdw" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="mi">【数据与Kat对话】</em></strong></a><strong class="kk iu"><em class="mi"/></strong></p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mk mg l"/></div></figure><p id="9b06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，请阅读本迷你系列的第2部分，了解更多SQL分析技巧。</p><div class="na nb gp gr nc nd"><a rel="noopener follow" target="_blank" href="/extra-4-sql-tricks-every-data-scientist-should-know-d3ed7cd7bc6c"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">每个数据科学家都应该知道的额外4个SQL技巧</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">充分利用SQL加快您的分析工作</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">towardsdatascience.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr lk nd"/></div></div></a></div></div></div>    
</body>
</html>