<html>
<head>
<title>All the Core Functions of Python Pandas You Need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你需要知道的 Python 熊猫的所有核心功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/all-the-core-functions-of-python-pandas-you-need-to-know-d219cbd87636?source=collection_archive---------5-----------------------#2020-04-17">https://towardsdatascience.com/all-the-core-functions-of-python-pandas-you-need-to-know-d219cbd87636?source=collection_archive---------5-----------------------#2020-04-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c46edebc75e161c80cbcc440b7107747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGQrs_NblogXJpjVrMHeHA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/photos/street-art-graffiti-wall-painting-2254146/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae jg" href="https://pixabay.com/users/Sarah_Loetscher-4248505/" rel="noopener ugc nofollow" target="_blank"> Sarah_Loetscher </a>拍摄</p></figure><div class=""/><div class=""><h2 id="18b7" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">成为一名合格的 Python 数据分析师所需的所有 Pandas 函数。</h2></div><p id="bf6a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为 Python 编程语言中最受欢迎的库之一，Pandas 是数据 I/O、清理、转换和聚合的“必学”库。</p><p id="4b06" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在 Stack Overflow 中看到这类关于熊猫的问题是很常见的:</p><ul class=""><li id="65fd" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">如何将我的数据框转换为…</li><li id="e867" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如何计算一列的不同值…</li><li id="2723" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如何将列类型从…转换为…</li><li id="ac14" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如何合并两个数据框…</li><li id="a824" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">等等</li></ul><p id="4b56" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我看来，所有熊猫的新手都应该至少知道基本的熊猫功能，并在开始实际使用它们之前练习它们。不算太多，但是可以帮你解决大部分常规问题。</p><h1 id="ec10" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">功能列表</h1><p id="ba1f" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这些功能是什么？好的。在本文中，我用不同的表格将所有这些函数组织成不同的类别。如果你相信你可能已经知道一些(如果你曾经使用过熊猫你一定至少知道一些)，下面的表格是<strong class="la jk">TD；DL </strong>让你在通读之前检查你的知识。</p><p id="bdd7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">表格中的符号:</p><ul class=""><li id="241b" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">pd 熊猫</li><li id="7787" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk"> df </strong>:数据框对象</li><li id="8d2c" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk"> s </strong>:系列对象(数据框的一列)</li></ul><h2 id="89b3" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">数据输入输出</h2><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="6dec" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">数据预览</h2><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="9530" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">数据清理</h2><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="fe4a" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">数据转换</h2><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="cd1b" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">数据聚合</h2><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9ca9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，让我演示这些功能。我将给出它们的示例用法，但是当然，我不能列举这些函数可能被使用的所有场景。所以，强烈建议你自己练习。</p><h1 id="5669" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">数据输入输出</h1><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/f065d27ed42395fe39850b1ae6b221bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iNZ-xcvw6Mn7cAca"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@roadtripwithraj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">与 Raj </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的公路旅行拍摄</p></figure><p id="5368" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">CSV、Excel 和 JSON 文档的读写使用非常相似。请注意，您可以从本地路径或 URL 读取。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="9228" class="nf mj jj nz b gy od oe l of og"># Read from local path<br/>df1 = pd.read_csv('./data.csv')<br/>df2 = pd.read_excel('./data.xlsx', sheet_name='Sheet1')<br/>df3 = pd.read_json('http://example.com/data.json', orient='records')</span></pre><p id="5a91" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe oh oi oj nz b">read_excel</code>中，如果存在多个工作表，我们可以通过给出<code class="fe oh oi oj nz b">sheet_name</code>来指定加载哪个电子表格。</p><p id="c44f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于<code class="fe oh oi oj nz b">read_json</code>，正确使用<code class="fe oh oi oj nz b">orient</code>参数很重要。当 JSON 文档是一个数组时，最常用的是<code class="fe oh oi oj nz b">records</code>，如果您想使用根键作为索引，则使用<code class="fe oh oi oj nz b">index</code>。</p><p id="a227" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oh oi oj nz b">to_csv</code>、<code class="fe oh oi oj nz b">to_excel</code>、<code class="fe oh oi oj nz b">to_json</code>是对应的书写功能。重要的区别在于，我们需要从数据框对象而不是 Pandas 对象调用这些函数。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="d07c" class="nf mj jj nz b gy od oe l of og">df1.to_csv('./data.csv')<br/>df2.to_excel('./data.xlsx')<br/>df3.to_json('./data.json')</span></pre><p id="9824" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">直接从/向数据库读写要稍微复杂一些。Pandas 支持多个库，比如 SQL Server 的<code class="fe oh oi oj nz b">pymssql</code>和 MySQL 的<code class="fe oh oi oj nz b">pymysql</code>。然而，我最喜欢的是<code class="fe oh oi oj nz b">sqlalchemy</code>，它支持最流行的数据库，甚至包括云数据库，如雪花数据库。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="6c7e" class="nf mj jj nz b gy od oe l of og">from sqlalchemy import create_engine</span><span id="c52b" class="nf mj jj nz b gy ok oe l of og">db_engine = create_engine(<br/>    'snowflake://{user}:{password}@{account}/'.format(<br/>    user='...',<br/>    password='...',<br/>    account='...',<br/>))</span><span id="ba37" class="nf mj jj nz b gy ok oe l of og">df = pd.read_sql("SHOW TABLES", db_engine)<br/>df.head()</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/956411fd6d93bba1d1d13dc16b623cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AtsjcT21Ik7EBlonO_8wpg.png"/></div></div></figure><h1 id="8bae" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">数据预览</h1><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/f49fcc6a71845e6478fc1870edc5da09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SOU-BaWQniGOVoWC"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@christianw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Christian Wiediger </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="40cf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很多时候，我们想要得到我们所拥有的数据集的一个大概情况，或者仅仅想要检查数据是否已经被正确地加载到 Pandas 数据框中。为此，我们需要知道几个函数。</p><h2 id="c4dd" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.head()</h2><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="d2dc" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({<br/>    'id': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],<br/>    'name': ['Alice', 'Bob', 'Chris', 'David', 'Ella', 'Frank', 'Grace', 'Hellen', 'Iva', 'Jack']<br/>})</span><span id="8c08" class="nf mj jj nz b gy ok oe l of og">df.head()</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi on"><img src="../Images/570b8ba54403b2b89884b0a7661ca52b.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*XU8aZdvbGejfvR74MCIaaA.png"/></div></figure><p id="e72e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于演示的目的，我首先创建了一个包含两列的数据框——“id”和“name”。</p><p id="840f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，<code class="fe oh oi oj nz b">df.head()</code>函数显示前 5 行。</p><p id="1c4f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，你可以指定显示多少行，比如<code class="fe oh oi oj nz b">df.head(10)</code>显示 10 行。</p><h2 id="9cc4" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.tail()</h2><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/a26e9db012c402c40ceb5fec859c8657.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*l4m6HabO-4dNvEloDK4neQ.png"/></div></figure><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="6669" class="nf mj jj nz b gy od oe l of og">df.tail()</span></pre><p id="63dc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与<code class="fe oh oi oj nz b">df.head()</code>类似，该函数将显示尾部 n 行。</p><p id="34e4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当数据集被排序，并且您想要检查结果时，这将很有帮助。</p><h2 id="4db2" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.sort_values()</h2><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi op"><img src="../Images/f64237bd62c624261f4024397f2523e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*_1UObJBIPjPI15e-NLNGhQ.png"/></div></figure><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="5b93" class="nf mj jj nz b gy od oe l of og">df.sort_values(by='name', ascending=False, inplace=True)</span><span id="a165" class="nf mj jj nz b gy ok oe l of og">df.head()</span></pre><p id="0bcd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以按升序或降序排序。请注意，如果您想将排序后的数据框赋回您的变量，需要将<code class="fe oh oi oj nz b">inplace</code>设置为<code class="fe oh oi oj nz b">True</code>。否则，您的数据帧<code class="fe oh oi oj nz b">df</code>将不会改变。</p><h2 id="a21e" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.columns</h2><p id="4788" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">请注意，这不是函数，而是数据框的属性。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="ab2d" class="nf mj jj nz b gy od oe l of og">df.columns</span></pre><p id="5c66" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">获取属性值将返回以下结果。</p><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/88184bf6acd81ea0e42d5acba063a394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lfvptKuVYAAiODAXEdNuA.png"/></div></div></figure><p id="dd67" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，您可以为此属性分配一个列表来重命名数据框的所有列。例如:</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="3b2d" class="nf mj jj nz b gy od oe l of og">df.columns = ['no', 'firstname']</span></pre><h2 id="b093" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.dtypes</h2><p id="b71f" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这也是返回列的所有数据类型的数据框的属性。当您想要检查数据类型，尤其是处理<code class="fe oh oi oj nz b">datetime</code>列时，这非常有用。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="34ec" class="nf mj jj nz b gy od oe l of og">df.dtypes</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/6216c939c54a037066c6f8d520df3f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*KLc_LpdL6kDUkK5oms8tDw.png"/></div></figure><h2 id="651c" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.shape</h2><p id="7034" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这可能是我使用最多的属性。我们可能经常想要检查数据框的行数和列数。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="9ab9" class="nf mj jj nz b gy od oe l of og">df.shape</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi os"><img src="../Images/05f7a70707ccd3c53cf487d8ff3022bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*mYighLjKvJQgC8GVSnaq6A.png"/></div></figure><p id="b84b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，这个属性是一个元组，其中第一个元素是行数，第二个元素是列数。</p><h2 id="2a95" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.describe()</h2><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/61db013dc7e0f131610fded0118a5c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*c20qbJj3PWGN6bOGXPX0Wg.png"/></div></div></figure><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="2952" class="nf mj jj nz b gy od oe l of og">df.describe()</span></pre><p id="888e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们处理一些度量时，我们可能想要有一个数据分布的图像。<code class="fe oh oi oj nz b">df.describe()</code>给出了这个粗略的统计数据。</p><p id="9f9c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当对具有多列的数据框调用此函数时，非数字列将被忽略。</p><p id="9f7b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，<code class="fe oh oi oj nz b">id</code>列的统计数据没有任何意义，但是它演示了函数。</p><h2 id="8d61" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">s .值计数()</h2><p id="235f" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">此函数适用于熊猫系列，而非数据框。它计算序列中每个值的出现次数。</p><p id="8ad1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用一些重复的名称创建另一个数据框。然后，统计这个数据框中的名字频率。请注意，我们使用<code class="fe oh oi oj nz b">df.name</code>或<code class="fe oh oi oj nz b">df['name']</code>来获取数据框的名称列，作为一个可以应用<code class="fe oh oi oj nz b">value_counts()</code>功能的序列。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="e04f" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({'id': [1, 2, 3, 4, 5],<br/>                   'name': ['Alice', 'Bob', 'Chris', 'Chris', 'Alice']})<br/>df.name.value_counts()</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ou"><img src="../Images/892181077a35a03f21f5aefba8163523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*Vtj7WpgiUArGlLzuEhWXqg.png"/></div></div></figure><h1 id="f023" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">数据清理</h1><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/cbea9e1368b68d42b55d899ca56fb052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xg-BqON01uf3bmhT"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@thecreative_exchange?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上创意交流</a>拍摄的照片</p></figure><p id="fa9a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们得到的原始数据集不完美是很常见的。因此，我们需要在使用前清理数据集。以下是相关的熊猫函数。</p><h2 id="6a6e" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">伊斯纳酵母</h2><p id="a3dd" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">当我们想要过滤数据框中的“空”值时，此函数会有所帮助。让我们创建另一个数据框，在名称列中包含一些空值。注意，我们在 Python 中使用<code class="fe oh oi oj nz b">None</code>表示空对象。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="d225" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({'id': [1, 2, 3, 4, 5],<br/>                   'name': ['Alice', 'Bob', None, 'Chris', None]})</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/3ac7202a778500e8448aae1cb5bfe38d.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*7hZzupsqxLlUq2GByyJ1Lw.png"/></div></figure><p id="f7e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，假设我们想过滤掉所有的空值。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="d05a" class="nf mj jj nz b gy od oe l of og">df[~df.name.isna()]</span></pre><p id="3dda" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oh oi oj nz b">df.name</code>帮助获取数据框的“name”列作为一个序列，然后<code class="fe oh oi oj nz b">isna()</code>返回一系列表示名称是否为 null 的布尔值。之后，开头的<code class="fe oh oi oj nz b">~</code>符号反转了布尔值，因为我们想要保留没有空值的行。最后，数据帧<code class="fe oh oi oj nz b">df</code>将被这个布尔序列过滤，其中具有“假”布尔值的行将被丢弃。</p><h2 id="9a28" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.dropna()</h2><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="89d5" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({'id': [1, 2, 3, None, 5], 'name': ['Alice', 'Bob', None, 'Chris', None]})</span><span id="8f47" class="nf mj jj nz b gy ok oe l of og">df.dropna()</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/f4425babc7f17916073df66727cc86f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*RxUSYwRLgtEPX676CWNRgA.png"/></div></figure><p id="aad8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们有多个包含空值的列，并且我们希望过滤掉至少包含一个空值的所有行，该怎么办？我们仍然可以使用上面的方法，但是你需要对每一列重复很多次。</p><h2 id="e5c5" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.fillna()</h2><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="8f31" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({'id': [1, 2, 3, 4, 5],<br/>                   'name': ['Alice', 'Bob', None, 'Chris', None]})</span><span id="3ca9" class="nf mj jj nz b gy ok oe l of og">df.fillna('Unknown')</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/a8ee242a249ca7044b16c820704cde9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*Kq_la-DkDvqodK4M8CIdZA.png"/></div></figure><p id="8ae2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时，我们可能不想简单地丢弃具有空值的行。相反，我们希望用其他东西填充空值。</p><p id="a2a5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本例中，带有空值的 name 列被替换为“Unknown”字符串，我们仍然有这些行。</p><h2 id="5821" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.drop_duplicates()</h2><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="21b2" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({'id': [1, 2, 3, 4, 3],<br/>                   'name': ['Alice', 'Bob', 'Chris', 'David', 'Chris']})</span><span id="c449" class="nf mj jj nz b gy ok oe l of og">df.drop_duplicates()</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/2ad0648b016a797458f3eba39f75664b.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*FBZY2ZPtY-I3k-diUHOpRg.png"/></div></figure><p id="117f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时原始数据集可能有一些重复的行，而我们实际上并不需要它们。</p><p id="1374" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本例中，我们有两个 id = 3 的“Chris”。所以，函数丢弃了第二个。</p><h2 id="171a" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.drop()</h2><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="b942" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({'id': [1, 2, 3, 4, 3],<br/>                   'name': ['Alice', 'Bob', 'Chris', 'David', 'Ella'],<br/>                   'comments': ['', '', 'author', '', '']})</span><span id="e2ec" class="nf mj jj nz b gy ok oe l of og">df.drop(columns=['comments'])</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/dacff5ce576fb2d4c008aa346bb99d11.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*zTX-h9LWH9lHt3RaN8wCDA.png"/></div></figure><p id="1a6a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本例中，数据帧有 3 列。</p><p id="39f1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们不需要“comments”列，我们可以使用<code class="fe oh oi oj nz b">df.drop()</code>函数删除它。</p><p id="f051" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个函数也可以用来删除行。</p><h2 id="f7da" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.rename()</h2><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="284c" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({'id': [1, 2, 3, 4, 5],<br/>                   'name': ['Alice', 'Bob', 'Chris', 'David', 'Ella']})</span><span id="1dc0" class="nf mj jj nz b gy ok oe l of og">df.rename(columns={'id': 'no', 'name': 'firstname'})</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/ee84a185a1a68f6ed43f2350b8fc3413.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*KE_lMYybwnyHJW70HN3tFQ.png"/></div></figure><p id="1fbb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本例中，仍然使用列名“id”和“name”创建数据框。然而，<code class="fe oh oi oj nz b">df.rename()</code>函数有助于重命名列标题。</p><p id="13d2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，它将一个字典作为参数，其中键是旧的头，值是新的头。</p><h2 id="2a41" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.reset _ 索引()</h2><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="f582" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({'name': ['Alice', 'Bob', 'Chris', 'David', 'Ella']})</span><span id="33d6" class="nf mj jj nz b gy ok oe l of og">df.reset_index()</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/aed8929412736b3e83e165e9a4c695f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*yPWD8o0lX_qlA6vmHhx_ng.png"/></div></figure><p id="d804" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本例中，数据框只有“名称”列。那么，如果我们想创建另一个列作为标识呢？</p><p id="2369" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您认为行号中的某一列没有问题，只需使用<code class="fe oh oi oj nz b">df.reset_index()</code>函数。</p><p id="bce7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个函数还有一个典型的用法。假设我们刚刚清理了数据集，丢弃了一些重复的行。但是，索引将不再是连续的。如果你想有一个连续的索引，这个函数也有帮助。</p><h1 id="0c3c" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">数据转换</h1><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pd"><img src="../Images/0689213f648e04f3665d592af85df4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dpx4KDJWaACfW-rb"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@momentance?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SwapnIl Dwivedi </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0589" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在数据清理之后，我们可能需要转换数据。</p><h2 id="9b2b" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">pd.to_datetime()</h2><p id="6b42" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">通常，我们的原始数据集包含字符串格式的所有日期或时间。为了稍后的分析目的，比如排序，我们可能想要将这些字符串转换成<code class="fe oh oi oj nz b">datetime</code>对象。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="b3ac" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({'datetime': ['01/04/2020', '02/04/2020', '03/04/2020']})</span><span id="e37d" class="nf mj jj nz b gy ok oe l of og">pd.to_datetime(df.datetime, format='%d/%m/%Y')</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/a402d9ed1cf9776ec381174591ef0a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0G65DHiOHycV-Wpb-Jt9A.png"/></div></div></figure><p id="e034" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，这个函数返回一个序列，所以我们可以将它赋回数据框的列。</p><h2 id="56e2" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">s.astype()</h2><p id="4b48" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这个函数帮助我们轻松地转换列的数据类型。在本例中，创建的数据框的“id”字段包含所有字符串类型。然后，<code class="fe oh oi oj nz b">s.astype()</code>函数帮助将它们转换成整数。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="6afa" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({'id': ['1', '2', '3', '4', '5']})</span><span id="494c" class="nf mj jj nz b gy ok oe l of og">df.id.astype(int)</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/a64654a4a7e5efad11450aad181b42d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*JSHE6Sx0L0bGofBYM8Ss2g.png"/></div></figure><h2 id="5c44" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">s.apply()</h2><p id="b216" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这大概是我用的最多的功能了。虽然 Pandas 允许我们轻松地对一个数据帧的一整列执行一些转换，例如，<code class="fe oh oi oj nz b">df.col + 1</code>会将该列的所有值加 1。然而，有时我们可能需要做一些熊猫内置功能不支持的独特事情。在这种情况下，<code class="fe oh oi oj nz b">apply()</code>功能会有所帮助。</p><p id="5e0d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们使用<code class="fe oh oi oj nz b">apply()</code>函数时，通常会同时使用<code class="fe oh oi oj nz b">lambda</code>函数。在下面的例子中，我们手动使用<code class="fe oh oi oj nz b">apply()</code>功能实现了<code class="fe oh oi oj nz b">df.number + 1</code>。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="6688" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({'number': [1, 2, 3, 4, 5]})</span><span id="fbdc" class="nf mj jj nz b gy ok oe l of og">df.number.apply(lambda n: n+1)</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/6df45acfe2e4ad34053f739033b79111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*gbPdebdUnwg9gS3oGaKdYQ.png"/></div></figure><p id="7f0f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在某些特殊情况下，lambda 函数可能不够用。例如，我们有一大堆逻辑应用于一个列，而这些逻辑只能放在一个定制的函数中。因此，<code class="fe oh oi oj nz b">apply()</code>功能也可以与定制功能一起使用。</p><p id="3820" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的例子使用了一个定制的功能来做同样的事情。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="09cd" class="nf mj jj nz b gy od oe l of og">def add1(n):<br/>    return n+1</span><span id="8eba" class="nf mj jj nz b gy ok oe l of og">df.number.apply(add1)</span></pre><h2 id="8e84" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.apply()</h2><p id="70b0" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">如果我们需要在一个<code class="fe oh oi oj nz b">apply()</code>函数中使用多列怎么办？事实上，<code class="fe oh oi oj nz b">apply()</code>函数也可以用于数据框对象。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="1423" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({'num1': [1, 2, 3, 4, 5],<br/>                   'num2': [5, 4, 3, 2, 1]})</span><span id="e347" class="nf mj jj nz b gy ok oe l of og">df.apply(lambda row: row['num1'] + row['num2'], axis=1)</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/7fd4bda0df8d3edca5ef9aeb8bf5478f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*QBz1nzO25X9szFYe1NzJNg.png"/></div></figure><p id="6fd5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的示例中，数据框是用两个数字列创建的。然后，我们使用<code class="fe oh oi oj nz b">lambda</code>函数获取包含所有单元格的每一行。之后，我们仍然可以使用<code class="fe oh oi oj nz b">['col_name']</code>来访问这些值。因此，<code class="fe oh oi oj nz b">row[‘num1’] + row[‘num2’]</code>将返回两列值的总和。</p><p id="a79b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">非常重要的是，这里必须指定参数<code class="fe oh oi oj nz b">axis=1</code>，因为数据框对象上的<code class="fe oh oi oj nz b">apply()</code>函数将默认应用于行索引。</p><p id="f79e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，我们也可以使用定制功能。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="7388" class="nf mj jj nz b gy od oe l of og">def sum_cols(row):<br/>    return row['num1'] + row['num2']</span><span id="5dbe" class="nf mj jj nz b gy ok oe l of og">df.apply(sum_cols, axis=1)</span></pre><h2 id="4c34" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.explode()</h2><p id="cbf3" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我以前处理 JSON 文档的时候用这个函数。由于 JSON 的风格，有时我们有一个带有数组值的键。在这种情况下，我们可以轻松地展平数组。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="bf4c" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame([{<br/>    'name': 'Chris', <br/>    'languages': ['Python', 'Java']<br/>},{<br/>    'name': 'Jade',<br/>    'languages': ['Java', 'Javascript']<br/>}])</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/31b9cc5f7ce4d2e5eda04141c71bb012.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*Wzp1qmb1j_pr0SCIok811A.png"/></div></figure><p id="8054" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，直接从 JSON 文档加载的语言仍然是数组。然后，我们用<code class="fe oh oi oj nz b">df.explode()</code>函数把它拉平。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="43f8" class="nf mj jj nz b gy od oe l of og">df.explode('languages')</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/f3235cb8b03952c7c6ccd05eb1b2202d.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*yJj2_3R2vf3Skmk7MkVTsg.png"/></div></figure><h1 id="0e38" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">数据聚合</h1><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/8e14e41a1676c90926566cf081807b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VCxv7wEczaRleXlS"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">马丁·桑切斯在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2174" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据聚合在数据分析中起着重要的作用。Pandas 提供了许多执行数据聚合的方法。这里我整理了一些你必须知道的基本功能。</p><h2 id="1a0d" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">pd.concat()</h2><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="f4e3" class="nf mj jj nz b gy od oe l of og">df1 = pd.DataFrame({'id': [1, 2, 3],<br/>                   'name': ['Alice', 'Bob', 'Chris']})<br/>df2 = pd.DataFrame({'id': [4, 5],<br/>                    'name': ['David', 'Ella']})</span><span id="e3f7" class="nf mj jj nz b gy ok oe l of og">pd.concat([df1, df2])</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/5e21d09420ca09ed1c17eb49390abced.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*m9YNg9_qSjfy8zBdTdlVaw.png"/></div></figure><p id="126d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本例中，创建了两个数据框。</p><p id="e7a8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以使用<code class="fe oh oi oj nz b">pd.concat()</code>函数将它们连接在一起。</p><p id="f8a7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们也可以使用这个函数来垂直连接。对指数感到不舒服？你还记得<code class="fe oh oi oj nz b">df.reset_index()</code>功能吗？:)</p><h2 id="3668" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">pd.merge()</h2><p id="ff0f" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这是另一个我在实践中经常用到的。如果您有 SQL 查询的经验，这就像连接两个表一样。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="6b9f" class="nf mj jj nz b gy od oe l of og">df1 = pd.DataFrame({'id': [1, 2, 3],<br/>                   'name': ['Olivier', 'Jade', 'Chris']})<br/>df2 = pd.DataFrame({'id': [1, 2, 3],<br/>                    'language': ['Objective-C', 'Java', 'Python']})</span><span id="da2c" class="nf mj jj nz b gy ok oe l of og">pd.merge(df1, df2, on='id', how='inner')</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/6321e9407ff3ba843595e0a29d8a852a.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*AQAZsDs-aj8NzKvfKmtYcQ.png"/></div></div></figure><p id="9052" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上面的代码块所示，创建了两个数据框，分别包含“name”列和“language”列。然后，我们可以使用这个函数将它们“连接”在一起。请注意，我们需要指定哪一列用于与<code class="fe oh oi oj nz b">on='id'</code>连接，并指定两个数据帧如何连接<code class="fe oh oi oj nz b">how='inner'</code>。</p><h2 id="cb4c" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">df.groupby()和 df.groupby()。agg()</h2><p id="da69" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这两个函数一起演示会更好，因为函数<code class="fe oh oi oj nz b">df.groupby()</code>本身不能产生有意义的结果。它必须与适用于群组的其他功能一起使用，我相信<code class="fe oh oi oj nz b">df.groupby().agg()</code>是最常见的功能。</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="025f" class="nf mj jj nz b gy od oe l of og">df = pd.DataFrame({'id': [1, 2, 3, 4, 5],<br/>                   'name': ['Alice', 'Bob', 'Chris', 'David', 'Ella'],<br/>                   'language': ['Python', 'Java', 'Python', 'COBOL', 'Java'],<br/>                   'age': [21, 32, 31, 68, 29]})</span><span id="9dac" class="nf mj jj nz b gy ok oe l of og">df.groupby('language').agg({'name': 'count', 'age': 'mean'})</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/f9c2ab5fbb3ba9fa2139487d4fc25815.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*X27aNa78AfsXppu5PYrBPg.png"/></div></figure><p id="05fb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本例中，我们创建了一个包含“姓名”、“语言”和“年龄”的数据框。</p><p id="0c44" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，数据框按语言分组，我们计算这些人的姓名数量和平均年龄。嗯，列标题现在没有意义，但是我们可以使用<code class="fe oh oi oj nz b">df.rename()</code>函数来修复它们。</p><h2 id="4d17" class="nf mj jj bd mk ng nh dn mo ni nj dp ms lh nk nl mu ll nm nn mw lp no np my nq bi translated">pd.pivot_table()</h2><p id="cba6" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">对于上面的例子，我们也可以使用<code class="fe oh oi oj nz b">pd.pivot_table()</code>函数来实现它。也就是说，我们需要如下指定组键和测量值(使用上例中的相同数据框):</p><pre class="nr ns nt nu gt ny nz oa ob aw oc bi"><span id="6bfe" class="nf mj jj nz b gy od oe l of og">pd.pivot_table(df, <br/>               values=['name', 'age'], <br/>               index=['language'], <br/>               aggfunc={'name': 'count', 'age': ['min', 'max', 'mean']})</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/7643e2280a6c7a57f44c4f89f6c75997.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*g76y4HaL4KuMlT8H0Ugchg.png"/></div></figure><p id="94da" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，很明显，当我们有多级组键和度量值时，<code class="fe oh oi oj nz b">pd.pivot_table()</code>函数更方便。</p><h1 id="f4c3" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">摘要</h1><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pn"><img src="../Images/21113a862710d844bc6bd0cb6896aaef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TFiL0y0sgWrfishu"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="36c1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，Python 的 Pandas 库有更多的功能，使它成为 Python 中如此灵活和强大的数据分析工具。在这篇文章中，我只是整理了一些我认为最有用的基本原则。如果一个人能搞定所有这些问题，肯定可以开始使用熊猫来进行一些简单的数据分析。当然，要成为大师还有很多要学的。</p><div class="is it gp gr iu po"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="pp ab fo"><div class="pq ab pr cl cj ps"><h2 class="bd jk gy z fp pt fr fs pu fu fw ji bi translated">通过我的推荐链接加入 Medium 克里斯托弗·陶</h2><div class="pv l"><h3 class="bd b gy z fp pt fr fs pu fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pw l"><p class="bd b dl z fp pt fr fs pu fu fw dk translated">medium.com</p></div></div><div class="px l"><div class="py l pz qa qb px qc ja po"/></div></div></a></div><p id="7d6b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入 Medium 会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>