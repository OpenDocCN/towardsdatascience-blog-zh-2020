<html>
<head>
<title>Understand how to use NamedTuple and Dataclass in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解如何在 Python 中使用 NamedTuple 和 Dataclass</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understand-how-to-use-namedtuple-and-dataclass-in-python-e82e535c3691?source=collection_archive---------0-----------------------#2020-05-21">https://towardsdatascience.com/understand-how-to-use-namedtuple-and-dataclass-in-python-e82e535c3691?source=collection_archive---------0-----------------------#2020-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cc78" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建一个超出 __init__ 的 Python 对象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d0a2167bad247a7baab2a54f4fc2b563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uogTxM0a-lVa__VkjFBjew.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片<a class="ae ky" href="https://unsplash.com/@hiteshchoudhary" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kz">希斯·乔德里</strong> </a> <strong class="bd kz"> </strong>上<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kz">下</strong> </a></p></figure><p id="39d6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi lw translated"><span class="l lx ly lz bm ma mb mc md me di">如果</span>我要求你在 10 秒内为交易记录创建一个 Python 类，你会怎么做？可能大多数人都会用<code class="fe mf mg mh mi b">__init__</code>创建一个类。在本文中，我想分享 Python 中构造一个类的两个替代方案:<strong class="lc iu">名为 Tuple </strong>和<strong class="lc iu"> Dataclass </strong>。最后，我将比较这三个选项的性能，并就何时使用哪一个给出一些建议。</p><p id="0472" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="mj">我将在本文中把带有</em> <code class="fe mf mg mh mi b"><em class="mj">__init__</em></code> <em class="mj">的类称为“常规”Python 类。请让我知道它是否有正式名称。如果您想深入了解命名元组和数据类，请查看参考链接。</em></p><p id="d7b2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">每笔支付交易都有发送者、接收者、日期和金额。如果我使用常规的 Python 类，它可能看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/b469e182998b8a055bc09f3be9a8005a" rel="noopener ugc nofollow" target="_blank"> transaction.py </a></p></figure><p id="2a32" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">很直白。但是说实话，代码很多，至少很多行。在一个用例中，我从一个源(例如 Kafka)消费实时交易记录，我不希望有修改记录的灵活性。我如何以更干净的方式实现这一点？</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h2 id="2993" class="mt mu it bd mv mw mx dn my mz na dp nb lj nc nd ne ln nf ng nh lr ni nj nk nl bi translated">命名元组</h2><p id="7bcb" class="pw-post-body-paragraph la lb it lc b ld nm ju lf lg nn jx li lj no ll lm ln np lp lq lr nq lt lu lv im bi translated">命名元组是构造类的一个很好的选择。命名元组基本上是 Python 内置元组数据类型的扩展。Python 的 tuple 是一种简单的数据结构，用于对不同类型的对象进行分组。它的定义特征是<strong class="lc iu">是不可变的</strong>。</p><blockquote class="nr ns nt"><p id="b444" class="la lb mj lc b ld le ju lf lg lh jx li nu lk ll lm nv lo lp lq nw ls lt lu lv im bi translated">不可变对象是在创建后其状态不能被修改的对象。</p></blockquote><p id="fc5b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在 Python 中，不可变类型有<em class="mj"> int </em>，<em class="mj"> float </em>，<em class="mj"> bool </em>，<em class="mj"> str </em>，<em class="mj"> tuple </em>和<em class="mj"> unicode </em>。</p><p id="4965" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然而，内置元组类型的一个缺点是它给程序员增加了很多责任。当访问内置元组的一个属性时，需要知道它的索引。如果你正在开发一个将被成千上万的用户使用的库，这会引起一些混乱。</p><p id="1b2c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">另一种可能的方法是使用内置字典，像<code class="fe mf mg mh mi b">{"sender":"","receiver":"","date":"","amount":""}</code>。但是这里的问题是你需要正确的拼写键名。而且根本不是一个档次。</p><p id="837b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以使用命名元组来避免这些问题。命名元组允许我们给元素命名，所以我们可以通过属性名和它的索引来访问属性。</p><p id="3724" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Python3.8 中的命名元组实际上有两种类型，一种来自已经存在很久的<code class="fe mf mg mh mi b">collections</code>包，另一种来自从 Python3.6 开始引入的<code class="fe mf mg mh mi b">typing</code>包。</p><h2 id="27a2" class="mt mu it bd mv mw mx dn my mz na dp nb lj nc nd ne ln nf ng nh lr ni nj nk nl bi translated"><strong class="ak"><em class="nx">collections . named tuple</em></strong></h2><p id="4a3e" class="pw-post-body-paragraph la lb it lc b ld nm ju lf lg nn jx li lj no ll lm ln np lp lq lr nq lt lu lv im bi translated">我先从<code class="fe mf mg mh mi b"><a class="ae ky" href="https://docs.python.org/3.8/library/collections.html" rel="noopener ugc nofollow" target="_blank"><em class="mj">collections</em></a></code> <a class="ae ky" href="https://docs.python.org/3.8/library/collections.html" rel="noopener ugc nofollow" target="_blank"> <em class="mj">包</em> </a>。这个包提供了 Python 通用内置类型的替代方案，如<em class="mj">字典</em>、<em class="mj">列表</em>、<em class="mj">集合</em>和<em class="mj">元组</em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/26a46e42299300df75f856b50797e5d8" rel="noopener ugc nofollow" target="_blank">collections-named tuple . py</a></p></figure><p id="2a5d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这就是如何创建一个<code class="fe mf mg mh mi b">namedtuple</code>类。哇，就一行代码！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/c6d6ea34e7737d00a49ba8fc47280202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ua6aKmY9Upu7a8tswunTlA.png"/></div></div></figure><p id="afdc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们刚刚创建的<code class="fe mf mg mh mi b">Transaction</code>本质上是一个类。它有属性<em class="mj">发送者、接收者、日期、金额</em>和<code class="fe mf mg mh mi b">_fields</code>，允许我们通过名称和索引来访问属性。</p><p id="397a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="mj">创建一个对象</em> </strong></p><p id="1e93" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">创建一个<em class="mj"> namedtuple </em>对象和创建类一样简单。我还喜欢的是<em class="mj"> namedtuple </em>对象的表示。您也可以通过覆盖<code class="fe mf mg mh mi b">__repr__</code>方法在常规 Python 类中定制它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/f6349b3bc6731c57bc40e27c5dfad3be" rel="noopener ugc nofollow" target="_blank"> namedtuple-create.py </a></p></figure><p id="51d7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为属性分配默认值也是可能的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/06bf2ce8433c220e8175195cf8a26317" rel="noopener ugc nofollow" target="_blank">named tuple-create-default . py</a></p></figure><p id="48b6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">⚠️ ️ <strong class="lc iu">注意了！</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/03172fd592d454af8ff3b202975f998d" rel="noopener ugc nofollow" target="_blank">named tuple-create-default-career . py</a></p></figure><p id="afad" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这个例子中，我只将<code class="fe mf mg mh mi b">None</code>作为默认值分配给一个属性。分配了哪个属性？想想吧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/a121c549cc53a44a7966ee70cd285487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hyrps331WofMMREsOpC3wg.png"/></div></div></figure><p id="c209" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mf mg mh mi b">None</code>被分配给属性<code class="fe mf mg mh mi b">amount</code>，它是元组的最后一个属性。</p><p id="0e90" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里发生了什么事？我鼓励你在进一步阅读前思考一分钟。</p><p id="4e23" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">好吧。本质上，命名元组的创建遵循与常规 Python 类相同的语法。</p><p id="776a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">神奇的是，当我们创建一个类时，<strong class="lc iu">非默认参数不能跟在默认参数</strong>后面。在常规的 Python 类中，我们会立即注意到这个错误。这个语法规则也适用于命名元组，<strong class="lc iu">，所以默认值将从最后一个元素开始分配。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/23101c2437ff2d63728b4f71f254c9e2" rel="noopener ugc nofollow" target="_blank">named tuple-create-default-regular-class . py</a></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/0e61f8f1720e520bb6edc66c08e3590b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*Km_LZlVpJctfB9_ZvbGXRQ.png"/></div></figure><p id="1a90" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">回到子主题:创建对象。也可以使用<code class="fe mf mg mh mi b">_make()</code>方法创建一个<code class="fe mf mg mh mi b">namedtuple</code>对象。但是你需要记住属性的顺序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/e4595c0b2f7bf67f330b5bb5de55a198" rel="noopener ugc nofollow" target="_blank">named tuple-create-make . py</a></p></figure><p id="fe26" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="mj">访问属性</em> </strong></p><p id="a2f6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">访问<code class="fe mf mg mh mi b">namedtuple</code>中的属性也非常简单。事实上，它是一个元组，我们可以像访问基本元组一样访问属性。一个<code class="fe mf mg mh mi b">namedtuple</code>可以用<code class="fe mf mg mh mi b">_asdict()</code>转换成一本字典。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/cba968af7bebb383c6367616c8958f14" rel="noopener ugc nofollow" target="_blank"> namedtuple-access.py </a></p></figure><p id="d124" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="mj">分配属性</em> </strong></p><p id="fa30" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">等等？你刚才说 tuple 是一个不可变的数据类型，你怎么能在一个不可变的对象中分配属性呢？</p><p id="d631" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这取决于元组属性的数据类型。如果属性像<em class="mj"> str，float，int </em>一样是不可变的，那么我们就不能修改状态，比如<code class="fe mf mg mh mi b">("1.0","xiaoxu","2019-01-01")</code>。</p><p id="f7ab" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">但是如果属性本身像<em class="mj"> list 一样是可变的，</em>你可以改变列表中的元素，而不让元组知道这种改变。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b30052749183ff41f57e34ee3ede20dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*kE8FjNN5W_toechpcO97wQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有可变属性的 namedtuple</p></figure><p id="ad79" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这个例子中，发送者是一个可变对象的列表。在修改属性之前，我使用 Python 内置函数<code class="fe mf mg mh mi b">id</code>来检查链表的内存地址。</p><p id="8a4b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后，我将列表的第二个元素更改为“gaga ”,并打印出同一列表的 id。原来 id 是一样的！因此，对于<em class="mj">命名的元组，</em>状态没有改变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/a38da957e04eb881c0c145bef9744b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*Yp15NCauz6i-TrnfQA4jlQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有可变属性 2 的 namedtuple</p></figure><p id="ee6d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是如果我们用相同的元素创建一个新的列表:“jojo”和“gaga”，并试图将它分配给<em class="mj"> namedtuple </em>，这是行不通的，因为它们有不同的 id。</p><p id="203a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="mj">继承类</em> </strong></p><p id="588e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有时我们想要继承一个类并扩展其属性。在<code class="fe mf mg mh mi b">namedtuple</code>中，您可以使用<code class="fe mf mg mh mi b">@property</code>添加一个新属性。就像你看到的一样简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/f81bff245987a758f1eeaec0e9694e56" rel="noopener ugc nofollow" target="_blank">在命名元组中继承</a></p></figure><p id="bec1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="mj">分配字段名导致 csv 或 db 查询返回元组</em> </strong></p><p id="8d1f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我喜欢<code class="fe mf mg mh mi b">namedtuple</code>的另一个很酷的特性是，它可以将 csv 记录或 db 查询结果映射到一个<em class="mj"> namedtuple </em>对象。它可以减少样板代码的数量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/45d91b7d3f45fcece87007b695eebd3e" rel="noopener ugc nofollow" target="_blank">named duple-read-CSV-database . py</a></p></figure></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h2 id="28e4" class="mt mu it bd mv mw mx dn my mz na dp nb lj nc nd ne ln nf ng nh lr ni nj nk nl bi translated"><strong class="ak"> <em class="nx">打字。名为</em>的一对</strong></h2><p id="d90f" class="pw-post-body-paragraph la lb it lc b ld nm ju lf lg nn jx li lj no ll lm ln np lp lq lr nq lt lu lv im bi translated">创建一个名为的<em class="mj">元组的第二个选项是使用<code class="fe mf mg mh mi b">typing.NamedTuple</code>。它来自<code class="fe mf mg mh mi b">typing</code>包，所以每个属性都绑定到一个类型。在我看来，这就是<code class="fe mf mg mh mi b">collections.namedtuple</code>和<code class="fe mf mg mh mi b">typing.NamedTuple</code>的唯一区别。</em></p><p id="abe0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种格式看起来有点像常规的 Python 类，但是带有类型。确保你继承了<code class="fe mf mg mh mi b">typing.NamedTuple</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/63788271aeafdfa82cad3ce3d538eca0" rel="noopener ugc nofollow" target="_blank"> NamedTuple-create.py </a></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/ee9c5c111723b69bc435b10b9badc479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2z_yZIoeUtmXyxKbS9HIhA.png"/></div></div></figure><p id="a18e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">从<code class="fe mf mg mh mi b">typing.NamedTuple</code>创建的类有一个额外的字段<code class="fe mf mg mh mi b">_field_types</code>，显示每个属性的定义类型。</p><p id="83db" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有时候，如果你真的不想为某些属性定义类型，你可以使用 type <code class="fe mf mg mh mi b">Any</code>。静态类型检查器会将每个类型视为与任何类型兼容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/0882aef3fb73066eddde5b28ba7fdd67" rel="noopener ugc nofollow" target="_blank">named tuple-create-any . py</a></p></figure><p id="7d51" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="mj">创建一个对象，访问属性&amp;分配属性</em> </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/a6e3ec176f1845063e85146a00e9b5fa" rel="noopener ugc nofollow" target="_blank"> NamedTuple-access.py </a></p></figure><p id="57db" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在创建对象、访问属性和分配属性方面，<code class="fe mf mg mh mi b">typing.NamedTuple</code>与<code class="fe mf mg mh mi b">collections.tuple</code>相同。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h2 id="e62d" class="mt mu it bd mv mw mx dn my mz na dp nb lj nc nd ne ln nf ng nh lr ni nj nk nl bi translated"><strong class="ak"> <em class="nx">数据类</em> </strong></h2><p id="86a3" class="pw-post-body-paragraph la lb it lc b ld nm ju lf lg nn jx li lj no ll lm ln np lp lq lr nq lt lu lv im bi translated">Dataclass 是 Python 3.7 中引入的新特性。它被用作装饰器。它为我们实现了<code class="fe mf mg mh mi b">__init__</code>、<code class="fe mf mg mh mi b">__repr__</code>等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/a87e1901c497e1c95ca8f4edea1733d8" rel="noopener ugc nofollow" target="_blank"> dataclass-create.py </a></p></figure><p id="f351" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">命名元组的行为类似于元组，而<em class="mj">数据类</em>的行为更像常规的 Python 类。我为什么这么说？因为默认情况下，属性都是可变的，只能通过名称访问，而不能通过索引访问。</p><p id="d7d7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="mj">继承类</em> </strong></p><p id="66a3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当继承一个<em class="mj">数据类</em>时，子类的属性跟随父类，所以要小心默认值。如果父类中的一个字段被赋予了默认值，那么子类中的所有属性都应该有默认值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/5bbd894aa21467c863af8b963d8058a3" rel="noopener ugc nofollow" target="_blank"> dataclass-inherit.py </a></p></figure><p id="e4a9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="mj">不可变数据类</em> </strong></p><p id="eb91" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">命名元组的关键特性之一是不可变的。您也可以通过<em class="mj"> </em> <code class="fe mf mg mh mi b">frozen=True</code>在<em class="mj"> dataclass </em>中设置不可变的属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/b55f7262f12ddfad5b397fa844783888" rel="noopener ugc nofollow" target="_blank"> dataclass-immutable.py </a></p></figure><p id="f43d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在冻结的<em class="mj">数据类</em>中，如果试图修改状态，将引发<code class="fe mf mg mh mi b">FrozenInstanceError</code>异常。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h2 id="2563" class="mt mu it bd mv mw mx dn my mz na dp nb lj nc nd ne ln nf ng nh lr ni nj nk nl bi translated">性能比较</h2><p id="fdf8" class="pw-post-body-paragraph la lb it lc b ld nm ju lf lg nn jx li lj no ll lm ln np lp lq lr nq lt lu lv im bi translated">最后，我想比较一下常规 Python 类、<code class="fe mf mg mh mi b">collections.namedtuple</code>、<code class="fe mf mg mh mi b">typing.NamedTuple</code>和<code class="fe mf mg mh mi b">dataclass</code>的性能。比较内容包括:</p><ul class=""><li id="b64d" class="oe of it lc b ld le lg lh lj og ln oh lr oi lv oj ok ol om bi translated">对象的大小</li><li id="1d7b" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">创建对象的时间</li><li id="7c74" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">检索属性的时间到了</li></ul><p id="7611" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我已经创建了 5 个不同的类。最后一个是带有字段<code class="fe mf mg mh mi b">__slot__</code>的优化的<em class="mj">数据类</em>。<a class="ae ky" href="https://docs.python.org/3/reference/datamodel.html#slots" rel="noopener ugc nofollow" target="_blank">槽</a>用于使类更快，使用更少的内存。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/611cef8f11f31f6e88b8427d420a46c8" rel="noopener ugc nofollow" target="_blank">named tuple-data class-comparison-init . py</a></p></figure><p id="b607" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="mj">比较物体的大小</em> </strong></p><p id="d7ed" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">第一步是使用<code class="fe mf mg mh mi b">sys.getsizeof</code>比较每个创建对象的大小。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/38bceca4c75f948d55f03aecd5ff467a" rel="noopener ugc nofollow" target="_blank">named tuple-data class-size-comparison . py</a></p></figure><p id="8882" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="mj">比较时间创建一个对象</em> </strong></p><p id="3f3d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后我用 Python 内置函数<code class="fe mf mg mh mi b"><a class="ae ky" href="https://docs.python.org/3.8/library/timeit.html" rel="noopener ugc nofollow" target="_blank">timeit</a></code>对比对象创建时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/80097313ce7c27d1cfc114e23378d419" rel="noopener ugc nofollow" target="_blank">named tuple-data class-creation-comparison . py</a></p></figure><p id="9020" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="mj">比较时间访问属性</em> </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/3035f3e86a32b4df20d14500d1eb6f02" rel="noopener ugc nofollow" target="_blank">named duple-data class-access-comparison . py</a></p></figure><p id="8266" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="mj">结果</em> </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">named tuple-data class-comparsion-result . CSV</p></figure><p id="316d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">基于元组的对象通常较大，因为它们包含属性名和索引。具有槽的数据类具有最少的对象创建时间。常规 Python 类似乎擅长访问属性。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h2 id="e764" class="mt mu it bd mv mw mx dn my mz na dp nb lj nc nd ne ln nf ng nh lr ni nj nk nl bi translated">结论</h2><p id="6452" class="pw-post-body-paragraph la lb it lc b ld nm ju lf lg nn jx li lj no ll lm ln np lp lq lr nq lt lu lv im bi translated">在做决定之前，你必须了解你的要求。</p><ul class=""><li id="4031" class="oe of it lc b ld le lg lh lj og ln oh lr oi lv oj ok ol om bi translated">您希望对象是不可变的吗？</li><li id="321f" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">您希望在 Python 代码中显式输入吗？</li><li id="faad" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">你在乎记忆吗？</li><li id="6210" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">你喜欢简洁的风格还是易读的风格？</li></ul><p id="d294" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi">……</p><p id="e034" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">选择常规 Python 类，如果你……</strong></p><ul class=""><li id="a8f9" class="oe of it lc b ld le lg lh lj og ln oh lr oi lv oj ok ol om bi translated">用于创建任何带有<code class="fe mf mg mh mi b">__init__</code>的类。拥有<code class="fe mf mg mh mi b">__init__</code>让我感觉很安全。</li><li id="bbc3" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">每个人都能理解代码。</li><li id="3e6b" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">正在使用 3.6 以下的 Python 版本。</li><li id="b318" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">不需要不可变的对象。</li><li id="601d" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">不喜欢显式打字。</li></ul><p id="cbd6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">选择</strong> <code class="fe mf mg mh mi b"><strong class="lc iu">collections.namedtuple</strong></code> <strong class="lc iu">类如果你……</strong></p><ul class=""><li id="2612" class="oe of it lc b ld le lg lh lj og ln oh lr oi lv oj ok ol om bi translated">想要不可变的对象。</li><li id="1203" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">不喜欢显式打字。</li><li id="1220" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">想要更少的代码。少即是多！</li></ul><p id="e6b8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">选择</strong> <code class="fe mf mg mh mi b"><strong class="lc iu">typing.NamedTuple</strong></code> <strong class="lc iu">类如果你……</strong></p><ul class=""><li id="7446" class="oe of it lc b ld le lg lh lj og ln oh lr oi lv oj ok ol om bi translated">想要不可变的对象。</li><li id="0bec" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">确实需要显式输入。</li><li id="d584" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">想要更少的代码。少即是多！</li></ul><p id="4b5f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">选择</strong> <code class="fe mf mg mh mi b"><strong class="lc iu">dataclass</strong></code> <strong class="lc iu">如果你……</strong></p><ul class=""><li id="1f81" class="oe of it lc b ld le lg lh lj og ln oh lr oi lv oj ok ol om bi translated">希望灵活地使它既可变又不可变。</li><li id="c8c8" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">确实需要显式输入。</li><li id="1f0a" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">想要更少的代码。少即是多！</li><li id="e9d9" class="oe of it lc b ld on lg oo lj op ln oq lr or lv oj ok ol om bi translated">想要好的速度表现。</li></ul><p id="e087" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">希望你喜欢这篇文章！如果你有任何想法，请在下面留下你的评论。</p><h2 id="c0a7" class="mt mu it bd mv mw mx dn my mz na dp nb lj nc nd ne ln nf ng nh lr ni nj nk nl bi translated"><strong class="ak">资源</strong></h2><div class="os ot gp gr ou ov"><a href="https://dbader.org/blog/writing-clean-python-with-namedtuples" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">用命名元组编写干净的 Python-dbader.org</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">命名元组是手动定义类的一个很好的选择，它们还有一些其他有趣的特性…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">dbader.org</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://realpython.com/python-data-classes/" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">Python 3.7 中数据类的终极指南——真正的 Python</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">Python 3.7 中一个令人兴奋的新特性是数据类。数据类通常包含…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">realpython.com</p></div></div><div class="pe l"><div class="pk l pg ph pi pe pj ks ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://docs.python.org/3/library/dataclasses.html" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">数据类-数据类- Python 3.8.3 文档</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">这个模块提供了一个装饰器和函数，用于自动添加生成的特殊方法，比如和…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://docs.python.org/3/library/typing.html" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">类型-支持类型提示- Python 3.8.3 文档</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">源代码:Lib/typing.py 注意 Python 运行时不强制函数和变量类型注释。他们可以是…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="os ot gp gr ou ov"><a href="https://docs.python.org/3/library/collections.html" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">集合-容器数据类型- Python 3.8.3 文档</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">源代码:Lib/collections/__init__。py 3.3 版本新增。该类可以用来模拟嵌套的作用域，并且是…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">docs.python.org</p></div></div></div></a></div></div></div>    
</body>
</html>