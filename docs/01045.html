<html>
<head>
<title>Implementing Batch Normalization in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 中实现批处理规范化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-batch-normalization-in-python-a044b0369567?source=collection_archive---------1-----------------------#2020-01-30">https://towardsdatascience.com/implementing-batch-normalization-in-python-a044b0369567?source=collection_archive---------1-----------------------#2020-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0f01" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么以及如何在神经网络中实现批处理规范化</h2></div><p id="b8ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最近正在上斯坦福大学在线提供的用于视觉识别的<a class="ae le" href="http://cs231n.stanford.edu/index.html" rel="noopener ugc nofollow" target="_blank">卷积神经网络</a>，并且刚刚开始着手这门课程的第二个作业。在这项作业的一部分中，我们被要求在一个完全连接的神经网络中实现批量标准化。</p><p id="cde4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">向前传递的实现相对简单，但是处理起来更具挑战性的向后传递，花了我相当长的时间才完成。经过几个小时的工作和斗争，我终于克服了这个挑战。在这里，我想分享一些我对批处理规范化的笔记和想法。</p><p id="6631" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="lf">那么……什么是批量规格化呢？</em> </strong></p><p id="8455" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">批处理规范化处理神经网络初始化不良的问题。可以解释为<strong class="kk iu">在网络</strong>的每一层做预处理。它迫使网络中的激活在训练开始时呈现单位高斯分布。这确保了所有神经元在网络中具有大致相同的输出分布，并提高了收敛速度。</p><p id="40ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要了解为什么激活在网络中的分布很重要，你可以参考课程提供的<a class="ae le" href="http://cs231n.stanford.edu/slides/2019/cs231n_2019_lecture07.pdf" rel="noopener ugc nofollow" target="_blank">讲座幻灯片</a>的第 46-62 页。</p><p id="1cea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们在一个层上有一批激活<strong class="kk iu"> <em class="lf"> x </em> </strong>，零均值单位方差版本<strong class="kk iu"><em class="lf"><strong class="kk iu"><em class="lf">x</em></strong>的 x̂ </em> </strong>为</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/0afda380b13f49bdb5a4d719432f0650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4hV1_d5I-j_CwCJesmIJUw.png"/></div></div></figure><p id="f453" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这实际上是一个可微分的操作，这就是为什么我们可以在训练中应用批量标准化。</p><p id="504c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在实现中，我们在完全连接层或卷积层之后，非线性层之前插入批量标准化层。</p><h1 id="f12c" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">批处理规范化的正向传递</h1><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mk"><img src="../Images/cd3fd580ebfc2063abb491bed1c21cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQhPvRh08oKFC63swgWr_w.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">从<a class="ae le" href="https://arxiv.org/abs/1502.03167" rel="noopener ugc nofollow" target="_blank">原稿</a>批量规格化转换的算法</p></figure><p id="80e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从最初的<a class="ae le" href="http://arxiv.org/abs/1502.03167" rel="noopener ugc nofollow" target="_blank">研究论文</a>来看一下要旨。<br/>正如我前面说过的，批处理规范化的整个概念非常容易理解。在计算了一批激活<strong class="kk iu"> <em class="lf"> x </em> </strong>的均值和方差后，我们可以通过要点第三行的运算来归一化<strong class="kk iu"> <em class="lf"> x </em> </strong>。还要注意，在零均值和单位方差约束对于我们的网络太难的情况下，我们引入了可学习的比例和移位参数<strong class="kk iu"> <em class="lf"> γ </em> </strong>和<strong class="kk iu"> <em class="lf"> β </em> </strong>。</p><p id="c092" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以向前传递的代码看起来像这样:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9df1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的一点是，均值和方差的估计取决于我们发送到网络中的小批量，我们不能在测试时这样做。因此，测试时归一化的均值<strong class="kk iu"><em class="lf"/></strong>和方差<strong class="kk iu"><em class="lf"/></strong>实际上是我们在训练期间计算的值的移动平均值。</p><p id="dee6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也是为什么<strong class="kk iu">批量规格化具有规格化效果</strong>。我们在训练时添加了某种随机性，并在测试时平均掉这种随机性，以减少泛化错误(就像<a class="ae le" href="http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf" rel="noopener ugc nofollow" target="_blank">辍学</a>的效果一样)。</p><p id="c4f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我对这门课作业 2 中向前传球的完整实现:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="782d" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">反向传播</h1><p id="c5b7" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">现在我们想推导出一种计算批量标准化梯度的方法。具有挑战性的是，<strong class="kk iu"><em class="lf"/></strong>本身是<strong class="kk iu"> <em class="lf"> x </em> </strong>和<strong class="kk iu"> <em class="lf"> σ </em> </strong>是<strong class="kk iu"> <em class="lf"> μ </em> </strong>和<strong class="kk iu"> <em class="lf"> x </em> </strong>的函数。因此，当我们对这个归一化函数执行链式法则时，我们需要非常小心和清楚。</p><p id="e353" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发现参加课程时非常有用的一件事是<a class="ae le" href="http://cs231n.github.io/optimization-2/#sigmoid" rel="noopener ugc nofollow" target="_blank">计算图</a>的概念。它将一个复杂的函数分解成几个小而简单的操作，并帮助您以一种整洁、有组织的方式执行反向传播(通过推导每个简单操作的局部梯度并将它们相乘以获得结果)。</p><p id="d647" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kratzert 的帖子详细解释了使用计算图计算批量归一化梯度的每个步骤。查看一下，了解更多。</p><p id="ab46" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 Python 中，我们可以编写这样的代码:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b529" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种分阶段计算的一个缺点是，由于我们计算了大量的“中间值”,这些中间值在相乘时可能会被抵消，因此导出最终梯度需要更长的时间。为了让一切都变得更快，我们需要自己对函数求导来得到一个简单的结果。</p><p id="fa80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我写这篇文章的时候，我从 Kevin 的博客上找到了一篇<a class="ae le" href="https://kevinzakka.github.io/2016/09/14/batch_normalization/" rel="noopener ugc nofollow" target="_blank">的帖子，讲述了通过链式法则获得梯度的每一个步骤。它已经非常清楚地解释了细节，所以如果你对推导感兴趣，请参考它。</a></p><p id="f7ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，这是我的实现:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="77fc" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">摘要</h1><p id="df81" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">在本文中，我们了解了<strong class="kk iu">批处理规范化如何提高收敛</strong>以及为什么<strong class="kk iu">批处理规范化作为一种规范化</strong>。我们还在 python 中实现了<strong class="kk iu">前向传递和反向传播，用于批处理规范化</strong>。</p><p id="4da0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然你可能不需要担心实现，因为所有的东西都已经在那些流行的深度学习框架中了，但我始终相信，自己做事情可以让我们有更好的理解。希望你看完这篇文章后有所收获！</p></div></div>    
</body>
</html>