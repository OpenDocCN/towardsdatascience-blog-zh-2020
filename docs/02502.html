<html>
<head>
<title>Self-Balancing Binary Search Trees 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自平衡二分搜索法树101</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/self-balancing-binary-search-trees-101-fc4f51199e1d?source=collection_archive---------4-----------------------#2020-03-10">https://towardsdatascience.com/self-balancing-binary-search-trees-101-fc4f51199e1d?source=collection_archive---------4-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b7b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">自平衡二分搜索法树简介</h2></div><p id="d521" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">数据结构</strong>是一种在计算机中组织和存储数据的专门方法，通过这种方法，我们可以更有效地对存储的数据执行操作。在现有的众多数据结构中，二分搜索法树在高效操作中扮演着重要角色。由于我的上一篇文章<a class="ae le" rel="noopener" target="_blank" href="/8-common-data-structures-every-programmer-must-know-171acf6a1a42">每个程序员都必须知道的8种常见数据结构</a>收到了很多兴趣和友好的回复，所以我将在本文中简要解释一下自平衡二分搜索法树(BST)。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/a2d4cd2afe4f11fdee923d54fb6f2b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pbpIC4o1lKVUR2VrjQ_oKQ.png"/></div></div></figure><h1 id="1c82" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">什么是二分搜索法树？</h1><p id="4263" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">如果你读过我之前关于数据结构的文章，你就会知道<strong class="kk iu">二叉查找树(BST) </strong>是一棵二叉树，其中的数据以层次结构组织。</p><p id="adcf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">二叉查找树展示了一个独特的属性，称为<strong class="kk iu">二叉搜索树属性</strong>。</p><p id="757f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设<strong class="kk iu"> x </strong>是二叉查找树中的一个节点。</p><ul class=""><li id="4991" class="mo mp it kk b kl km ko kp kr mq kv mr kz ms ld mt mu mv mw bi translated">如果<strong class="kk iu"> y </strong>是x的<strong class="kk iu">左</strong>子树中的一个节点，那么<strong class="kk iu"> y.key ≤ x.key </strong></li><li id="d587" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">如果<strong class="kk iu"> y </strong>是x的<strong class="kk iu">右</strong>子树中的一个节点，那么<strong class="kk iu"> y.key ≥ x.key </strong></li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nc"><img src="../Images/6b5980019aaf297225ad4fe0f87db3e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ziYvZzrttFYMXkkV9u66jw.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">图一。二分搜索法树基本术语的可视化。</p></figure><h1 id="8689" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">什么是自平衡二分搜索法树？</h1><p id="d99d" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">自平衡二叉查找树(BST)是一种自动尝试始终保持其高度尽可能小的二叉查找树(即使在执行插入或删除等操作后)。</p><p id="4dc6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你翻阅过<a class="ae le" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank"> Big-O算法复杂度备忘单</a>，可以看到BST运算的平均时间复杂度为<em class="nh">θ(h)</em>，其中<em class="nh"> h </em>为树的高度。因此，在执行大量操作时，高度越小越好。因此，引入了自动平衡BST，它可以自动将高度保持在最小值。然而，您可能认为每次执行操作时都必须进行自平衡是低效的，但这可以通过确保稍后在BST上执行大量快速操作来补偿。</p><p id="bc8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">高度为<em class="nh"> h </em>的二叉树最多可以有<code class="fe ni nj nk nl b">2⁰+2¹+···+2ʰ = 2⁽ʰ⁺¹⁾−1</code>个节点。</p><blockquote class="nm"><p id="551f" class="nn no it bd np nq nr ns nt nu nv ld dk translated">n≤2⁽ʰ⁺⁾1</p><p id="156f" class="nn no it bd np nq nr ns nt nu nv ld dk translated">h ≥ ⌈log₂(n+1) - 1⌉ ≥ ⌊log₂(n)⌋</p></blockquote><p id="690b" class="pw-post-body-paragraph ki kj it kk b kl nw ju kn ko nx jx kq kr ny kt ku kv nz kx ky kz oa lb lc ld im bi translated">因此，对于自平衡BSTs，最小高度必须始终是向下舍入的<strong class="kk iu"> <em class="nh">对数</em> ₂( <em class="nh"> n) </em> </strong>。此外，如果每个节点的左右子节点的高度相差<strong class="kk iu"> -1 </strong>、<strong class="kk iu"> 0 </strong>或<strong class="kk iu"> +1 </strong>，则称二叉树是<strong class="kk iu">平衡的</strong>。该值被称为<strong class="kk iu">平衡系数</strong>。</p><blockquote class="ob oc od"><p id="1471" class="ki kj nh kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated"><strong class="kk iu">平衡因子=左子树的高度-右子树的高度</strong></p></blockquote><h1 id="616b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">自平衡二分搜索法树是如何平衡的？</h1><p id="751b" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">说到自平衡，BST在执行插入和删除操作后执行<strong class="kk iu">旋转</strong>。下面给出了两种类型的旋转操作，可以在不违反二叉搜索树属性的情况下执行这两种操作来平衡BST。</p><h2 id="9839" class="oh ls it bd lt oi oj dn lx ok ol dp mb kr om on md kv oo op mf kz oq or mh os bi translated">1.向左旋转</h2><p id="2f92" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当我们绕节点<em class="nh"> x </em>向左旋转时，节点<em class="nh"> y </em>成为子树的新根。节点<em class="nh"> x </em>成为节点<em class="nh"> y </em>的左子节点，子树<em class="nh"> b </em>成为节点<em class="nh"> x </em>的右子节点。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ot"><img src="../Images/f1729ef86992b8eddd7d6a50bace6b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y3Y4oYeIi8tu6ILcPDvJVQ.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">图二。在节点x上向左旋转</p></figure><h2 id="7d01" class="oh ls it bd lt oi oj dn lx ok ol dp mb kr om on md kv oo op mf kz oq or mh os bi translated">2.向右旋转</h2><p id="be45" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当我们围绕节点<em class="nh"> y </em>向右旋转时，节点<em class="nh"> x </em>成为子树的新根。节点<em class="nh"> y </em>成为节点<em class="nh"> x </em>的右子节点，子树<em class="nh"> b </em>成为节点<em class="nh"> y </em>的左子节点。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ou"><img src="../Images/31487af74c34ff5bba55b852d71c6168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDASVRN4ZYVsnRAzLkVTVg.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">图三。在节点y上向右旋转</p></figure><p id="fae3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，一旦您完成了旋转，前一个和最后一个树中节点的有序遍历是相同的，并且二叉搜索树属性保持不变。</p><h1 id="7586" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">自平衡二分搜索法树的类型</h1><p id="a0f3" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">下面给出了几种自平衡BST。</p><ol class=""><li id="028c" class="mo mp it kk b kl km ko kp kr mq kv mr kz ms ld ov mu mv mw bi translated">AVL树</li><li id="b0ac" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld ov mu mv mw bi translated">红黑色的树</li><li id="6033" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld ov mu mv mw bi translated">张开树木</li><li id="aa20" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld ov mu mv mw bi translated">Treaps</li></ol><h1 id="840d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">自平衡二分搜索法树的应用</h1><p id="d5e1" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">自平衡BST用于构建和维护有序列表，如优先级队列。它们也用于<a class="ae le" href="https://en.wikipedia.org/wiki/Associative_array" rel="noopener ugc nofollow" target="_blank">关联数组</a>，其中键-值对根据仅基于键的排序插入。</p><p id="8367" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">计算几何中的许多算法利用自平衡BST来有效地解决问题，例如<a class="ae le" href="https://en.wikipedia.org/wiki/Line_segment_intersection" rel="noopener ugc nofollow" target="_blank">线段相交</a>问题。此外，可以扩展自平衡BST来执行新的操作，这些操作可用于优化数据库查询或其他列表处理算法。</p><h1 id="cbb7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">AVL树作为自平衡BST的一个例子</h1><p id="738d" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated"><em class="nh">阿德尔森-维尔斯基和兰迪斯</em> ( <strong class="kk iu"> AVL </strong>)树是平衡的二叉树。AVL树中的所有节点存储它们自己的平衡因子。</p><blockquote class="nm"><p id="3931" class="nn no it bd np nq nr ns nt nu nv ld dk translated">在AVL树中，每个节点的平衡因子是-1、0或+1。</p></blockquote><p id="7112" class="pw-post-body-paragraph ki kj it kk b kl nw ju kn ko nx jx kq kr ny kt ku kv nz kx ky kz oa lb lc ld im bi translated">换句话说，对于AVL树中的所有节点，左侧子树的高度和右侧子树的高度之差不能超过1。</p><h2 id="c46c" class="oh ls it bd lt oi oj dn lx ok ol dp mb kr om on md kv oo op mf kz oq or mh os bi translated">AVL树示例</h2><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ow"><img src="../Images/20699c5748dd24fbe703311dd2125617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p_BEs3KOMWCM0uPPbrfFMw.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">图4。AVL树示例</p></figure><p id="02ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在图4中，节点上方红色的值是它们对应的平衡因子。您可以看到，在图4所示的AVL树的所有节点中都满足了平衡因子条件。</p><h1 id="17fe" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">AVL树的旋转</h1><p id="276c" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在AVL树中执行插入或删除后，我们必须检查所有节点是否满足平衡因子条件。如果树不平衡，那么我们必须做<strong class="kk iu">旋转</strong>来使它平衡。</p><p id="9c5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对AVL树进行的旋转可以分为四种主要类型，分为两类。他们是，</p><ol class=""><li id="7d35" class="mo mp it kk b kl km ko kp kr mq kv mr kz ms ld ov mu mv mw bi translated"><strong class="kk iu">单转</strong> — <strong class="kk iu">左(LL)转</strong>和<strong class="kk iu">右(RR)转</strong></li><li id="fa90" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld ov mu mv mw bi translated"><strong class="kk iu">双旋转</strong> — <strong class="kk iu">左右(LR)旋转</strong>和<strong class="kk iu">左右(RL)旋转</strong></li></ol><p id="3e99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面给出的图表将解释每种旋转类型。</p><h2 id="0acd" class="oh ls it bd lt oi oj dn lx ok ol dp mb kr om on md kv oo op mf kz oq or mh os bi translated">1.单次向左旋转(LL旋转)</h2><p id="1143" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在这种类型的旋转中，我们将所有节点向左移动一个位置。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ox"><img src="../Images/0561c1bd9e5584fa92ebf5de6cfc7d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xoMIfEzXR9jtQkBpU0LCig.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">图五。LL旋转</p></figure><h2 id="52e7" class="oh ls it bd lt oi oj dn lx ok ol dp mb kr om on md kv oo op mf kz oq or mh os bi translated">2.单次右旋转(右旋转)</h2><p id="872f" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在这种类型的旋转中，我们将所有节点向右移动一个位置。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ox"><img src="../Images/6cad773f47b7267a67e00f257f55ea15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lH8JUx-hsPwuuldD9slsag.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">图六。RR旋转</p></figure><h2 id="e199" class="oh ls it bd lt oi oj dn lx ok ol dp mb kr om on md kv oo op mf kz oq or mh os bi translated">3.左右旋转(左右旋转)</h2><p id="1d20" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">顾名思义，这种类型的旋转包括左旋和右旋。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oy"><img src="../Images/af4576613af036aa2531a35374c71174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*snGqykViLDcp1Jcx-fUWuw.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">图7。左右旋转</p></figure><h2 id="b876" class="oh ls it bd lt oi oj dn lx ok ol dp mb kr om on md kv oo op mf kz oq or mh os bi translated">4.左右旋转(左旋转)</h2><p id="0a13" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这种类型的旋转包括右旋转和左旋转。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oy"><img src="../Images/518365c24434540eda385d4f25ee8ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W5zSFsU-gr9LFEgZ4oD1fA.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">图8。RL旋转</p></figure><h1 id="81e2" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">向AVL树中插入元素</h1><p id="eb24" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">考虑图4中给出的AVL树。我们想给这个树添加一个新的节点105。图9显示了插入新节点和重新平衡树的步骤。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oz"><img src="../Images/221e8762f03c3b3a7c7f4ea558e9f2f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQpZMmPrfKREb3AZsfxEBg.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">图九。插入和平衡</p></figure><p id="aa4e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">添加节点105后，树中将总共有12个节点。如果我们计算出平衡树的可能高度，</p><blockquote class="nm"><p id="4c2a" class="nn no it bd np nq nr ns nt nu nv ld dk translated">h ≥ ⌈log₂(n+1) — 1⌉</p><p id="e7fa" class="nn no it bd np nq nr ns nt nu nv ld dk translated">h ≥ ⌈log₂(12+1) — 1⌉</p><p id="d6be" class="nn no it bd np nq nr ns nt nu nv ld dk translated">h ≥ ⌊log₂(12)⌋ = ⌊3.58496250072⌋ = 3</p></blockquote><p id="3415" class="pw-post-body-paragraph ki kj it kk b kl nw ju kn ko nx jx kq kr ny kt ku kv nz kx ky kz oa lb lc ld im bi translated">但是，插入后生成的树的高度为4。此外，节点102的平衡因子是-2。从这些事实可以看出，插入后得到的树是不平衡的。因此，我们必须通过旋转来平衡它。可以看到，应该旋转以节点102为根的子树，并且应该使用RL旋转。执行这个旋转后，我们得到一个高度为3的平衡树。</p><h1 id="dde7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">最后的想法</h1><p id="3242" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我希望这篇文章作为自平衡二分搜索法树的简单介绍对你有用，在这里我们以AVL树为例进行了讨论。我很想听听你的想法。😇</p><p id="0f20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非常感谢你的阅读。😊请继续关注接下来的文章，我将在其中解释更多关于自平衡BST的内容。</p><p id="d4e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干杯！😃</p><h1 id="4a31" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">参考</h1><p id="961b" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">[1] <a class="ae le" href="https://www.cpp.edu/~ftang/courses/CS241/notes/self%20balance%20bst.htm" rel="noopener ugc nofollow" target="_blank"> CS241 —讲义:自平衡二叉查找树</a></p><p id="0e0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[2] <a class="ae le" href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" rel="noopener ugc nofollow" target="_blank">自我平衡的二叉查找树——维基百科</a></p><p id="aab8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[3] <a class="ae le" href="http://www.btechsmartclass.com/data_structures/avl-trees.html" rel="noopener ugc nofollow" target="_blank">数据结构教程— AVL树|示例|平衡因子</a></p></div></div>    
</body>
</html>