<html>
<head>
<title>How do Python Generators Work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 生成器是如何工作的？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cpython-internals-how-do-generators-work-ba1c4405b4bc?source=collection_archive---------12-----------------------#2020-05-02">https://towardsdatascience.com/cpython-internals-how-do-generators-work-ba1c4405b4bc?source=collection_archive---------12-----------------------#2020-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7a42" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">CPython 解释器的内部</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c0be69dceee36ef78852ead1c02c8c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kY_lc7DKaVJbCqm_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0e77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将试图提供对 Python 生成器的深入理解，以及它们如何从内部操作。它将包括<strong class="ky ir">如何</strong>和<strong class="ky ir">为什么</strong>。部分将是独立的，你可以随意跳过。事不宜迟，让我们开始我们的旅程。⛵️</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b98e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是发电机？</h1><p id="5434" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">从<a class="ae kv" href="https://www.python.org/dev/peps/pep-0255/" rel="noopener ugc nofollow" target="_blank"> Python 2.2 </a>开始添加，生成器是可以暂停、恢复和迭代的独特函数。让我们看一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3c41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过定义包含<code class="fe my mz na nb b">yield</code>关键字的函数，该函数被标记为生成器。然后，我们按以下顺序运行生成器:</p><ol class=""><li id="3353" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">初始化发生器并将其放入<code class="fe my mz na nb b">g</code>。此时，我们有了一个尚未运行的新生成器对象。</li><li id="14c2" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">通过呼叫<code class="fe my mz na nb b">next()</code>推进发电机。这导致生成器前进到第一个<code class="fe my mz na nb b">yield</code>关键字，在途中打印“Hello”。</li><li id="004c" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">再次推进发电机。它打印“Goodbye ”,由于它到达了函数的末尾，它引发了一个<code class="fe my mz na nb b">StopIteration</code>异常并结束。</li></ol><p id="0c3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解这三个简单的步骤，我们首先需要从 Python 中一个函数如何运行的基础开始。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a9f4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">函数如何工作</h1><p id="fecf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">运行一个函数包括两个主要步骤:<strong class="ky ir">初始化</strong>和<strong class="ky ir">求值。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/cba2adc18bad6503b17cd9e8124278cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jsvl1UWRZgC41ctb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Jukan Tateisi 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="9c47" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">初始化功能</h2><p id="d50c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在幕后，CPython 在一个<strong class="ky ir">框架</strong>对象中运行一个函数。</p><p id="413f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个帧对象，有时称为<strong class="ky ir">堆栈帧</strong>，由以下字段组成:</p><ul class=""><li id="6a97" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr od ni nj nk bi translated"><strong class="ky ir"> <em class="oe">代码对象</em> </strong>，包含函数实际编译的代码。</li><li id="47f5" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr od ni nj nk bi translated"><strong class="ky ir"> <em class="oe">释放堆栈空间</em> </strong>，称为<strong class="ky ir"> <em class="oe"> value-stack </em> </strong>，用于运行解释器。</li><li id="5c7d" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr od ni nj nk bi translated"><strong class="ky ir"> <em class="oe">执行指针</em> </strong>为当前正在执行的代码行。</li><li id="2934" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr od ni nj nk bi translated">其他领域，如局部变量的映射。</li></ul><p id="62b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有帧场的列表可以在<a class="ae kv" href="https://github.com/python/cpython/blob/1b55b65638254aa78b005fbf0b71fb02499f1852/Include/cpython/frameobject.h#L17" rel="noopener ugc nofollow" target="_blank">代码</a>中看到，而更短的列表可以在<a class="ae kv" href="https://docs.python.org/3/library/inspect.html#types-and-members" rel="noopener ugc nofollow" target="_blank">文档</a>中看到。</p><p id="2672" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们初始化一个函数时，一个帧被<a class="ae kv" href="https://github.com/python/cpython/blob/6d86a2331e6b64a2ae80c1a21f81baa5a71ac594/Python/ceval.c#L4063" rel="noopener ugc nofollow" target="_blank">创建</a>。在伪代码中:</p><pre class="kg kh ki kj gt of nb og oh aw oi bi"><span id="5aad" class="nr ma iq nb b gy oj ok l ol om">f = Frame()</span></pre><p id="af56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们传递给函数的参数然后在框架内被赋值为:</p><pre class="kg kh ki kj gt of nb og oh aw oi bi"><span id="aa0e" class="nr ma iq nb b gy oj ok l ol om">f.f_locals["arg1"] = arg1<br/>f.f_locals["arg2"] = arg2</span></pre><p id="9d7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">帧的执行点<a class="ae kv" href="https://github.com/python/cpython/blob/master/Objects/frameobject.c#L880" rel="noopener ugc nofollow" target="_blank">被设置为函数中的第一行代码</a>:</p><pre class="kg kh ki kj gt of nb og oh aw oi bi"><span id="c8ef" class="nr ma iq nb b gy oj ok l ol om">f.lasti = 0  # Last Instruction<br/>f.lineno = 0 # Function line number on file</span></pre><p id="44e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，我们的函数开始运行。</p><h2 id="0dc4" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">运行功能</h2><p id="7052" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">几乎整个 Python 解释器可以概括为一个 C 级函数:<a class="ae kv" href="https://github.com/python/cpython/blob/25104949a5a60ff86c10691e184ce2ecb500159b/Python/ceval.c#L880" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">pye val _ eval frameex</strong></a>。</p><p id="56d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数就是解释器循环。由 3k 行代码组成，它的工作是<em class="oe">评估一个帧</em>，或者换句话说，运行它。Python 中的每个函数，解释器运行的每个字节码或操作码，都要经过那个函数。</p><p id="c622" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在“PyEval”期间，Python 对帧的唯一值栈进行操作。这条信息以后会很重要。</p><p id="7f86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，当你输入一个函数，并运行它，解释器创建一个帧，并进入解释器循环。</p><p id="e01a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个叫做 PythonTutor 的网站有一个非常好的关于这种机制的交互例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/07228430acc5fe93271316b85773eb70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i27f-vvbo26eoGgmAE-FZg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">PythonTutor 的例子截图</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5e98" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">发电机如何工作</h1><p id="f3b8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">与函数非常相似，运行一个生成器包括<strong class="ky ir">初始化</strong>步骤和<strong class="ky ir">评估</strong>步骤。</p><h2 id="38f1" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">初始化发电机</h2><p id="7ea7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在这一步，我们正在创建生成器对象。生成器对象由<strong class="ky ir">帧对象</strong>和<strong class="ky ir">代码对象</strong>组成。如果你想知道，是的，框架对象中也包含代码对象。在伪代码中:</p><pre class="kg kh ki kj gt of nb og oh aw oi bi"><span id="88bd" class="nr ma iq nb b gy oj ok l ol om">g = Generator()<br/>f = Frame() # Initialized as before<br/>g.gi_frame = f<br/>g.gi_code = f.f_code = Code()  # The compiled function</span></pre><p id="f215" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，我们的发电机<code class="fe my mz na nb b">g</code>已经准备好运行。</p><h2 id="8fe4" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">推进(运行)发电机</h2><p id="e14a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">每次我们调用<code class="fe my mz na nb b">next(g)</code>时，都会使用同一个<a class="ae kv" href="https://github.com/python/cpython/blob/25104949a5a60ff86c10691e184ce2ecb500159b/Python/ceval.c#L880" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">pye val _ eval frameex</strong></a>对<a class="ae kv" href="https://github.com/python/cpython/blob/master/Objects/genobject.c#L223" rel="noopener ugc nofollow" target="_blank">帧进行求值</a>。</p><p id="c2b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不同的是，在运行生成器时，我们可以到达<code class="fe my mz na nb b">yield</code>关键字，此时帧评估停止，生成器“暂停”。</p><p id="4e81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保存帧中的指针，标记我们当前的堆栈位置，以便准确地知道停止时发生器的状态。</p><p id="46f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的是要记住，与函数不同，当求值停止时<strong class="ky ir">框架不会被破坏</strong>，因为它仍然连接到生成器对象。这将允许我们稍后加载它。</p><p id="e58c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PyEval 返回，我们的调用函数恢复。</p><h2 id="d3a9" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">再次推进发电机</h2><p id="64cf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当我们再次推进发生器时，帧从<code class="fe my mz na nb b">gi_frame</code>加载，PyEval 在<strong class="ky ir">相同的帧</strong>上再次被调用。它检查我们停止的地方，转到我们的执行指针，并使用存储在帧中的值堆栈。</p><p id="c535" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们使用的是同一个堆栈，而且这个框架也包含了所有的局部变量，我们可以从完全相同的地方继续，就好像函数从来没有停止过一样。</p><p id="f608" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们到达生成器或返回语句的末尾时，<code class="fe my mz na nb b">StopIteration</code> <a class="ae kv" href="https://github.com/python/cpython/blob/master/Objects/genobject.c#L236" rel="noopener ugc nofollow" target="_blank">被抛出</a>，该帧被删除。<code class="fe my mz na nb b">gi_frame</code> <a class="ae kv" href="https://github.com/python/cpython/blob/master/Objects/genobject.c#L274" rel="noopener ugc nofollow" target="_blank">然后将</a>设置为<code class="fe my mz na nb b">None</code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ca91" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">发电机特征</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/fa7f14ae3b810b91cafcb1e49cdb1712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WF27jnx49SXjDEg_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">米克·豪普特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9de4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经知道了生成器内部是如何暂停和恢复的，让我们深入了解一些使生成器真正不同凡响的特性。</p><h2 id="691a" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">产生价值</h2><p id="150b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">生成器可以产生值，允许它们被迭代并以一种懒惰的方式返回结果。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7cff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在内部，产生值非常类似于获得函数的结果。当<strong class="ky ir"> PyEval </strong> <a class="ae kv" href="https://github.com/python/cpython/blob/25104949a5a60ff86c10691e184ce2ecb500159b/Python/ceval.c#L2191" rel="noopener ugc nofollow" target="_blank">到达</a>操作码<code class="fe my mz na nb b">YIELD_VALUE</code>时，弹出栈顶值并返回。很简单，不是吗？</p><h2 id="add5" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">从发电机返回</h2><p id="01a1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">生成器可以使用<code class="fe my mz na nb b">return</code>关键字返回一个结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4559" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，return 语句设置了<code class="fe my mz na nb b">StopIteration</code>异常。异常可以有参数，这里，发送给<code class="fe my mz na nb b">StopIteration</code>异常的第一个参数是返回值。</p><p id="2b5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以通过捕获异常并获取其第一个参数来检索返回值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="11ee" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">与发电机通信</h2><p id="61bb" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们还可以使用<code class="fe my mz na nb b"><a class="ae kv" href="https://docs.python.org/3/reference/expressions.html#generator.send" rel="noopener ugc nofollow" target="_blank">.send()</a></code>和<code class="fe my mz na nb b"><a class="ae kv" href="https://docs.python.org/3/reference/expressions.html#generator.throw" rel="noopener ugc nofollow" target="_blank">.throw()</a></code>与发电机通信:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6d9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们使用<code class="fe my mz na nb b">.send()</code>向生成器发送数字，它们是<code class="fe my mz na nb b">yield</code>关键字的返回值。</p><p id="122a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在内部，<code class="fe my mz na nb b">.send()</code>的工作方式是将值放在生成器堆栈的顶部。然后它评估帧，弹出栈顶值，把它放入我们的局部变量。</p><p id="9455" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，<code class="fe my mz na nb b">.throw()</code>通过向<strong class="ky ir"> PyEval </strong>发送一个<code class="fe my mz na nb b"><a class="ae kv" href="https://github.com/python/cpython/blob/25104949a5a60ff86c10691e184ce2ecb500159b/Python/ceval.c#L1315" rel="noopener ugc nofollow" target="_blank">throwflag</a></code>来说明发生了异常。然后，它正常处理异常。如果生成器没有捕捉到它，异常就会像普通函数一样向外传播。</p><h2 id="5194" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">嵌套生成器</h2><p id="c4fe" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">可以使用关键字<code class="fe my mz na nb b">yield from</code>嵌套生成器(或"<a class="ae kv" href="https://www.python.org/dev/peps/pep-0380" rel="noopener ugc nofollow" target="_blank">委托</a>"):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="302e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，使用<code class="fe my mz na nb b">yield from</code>创建了一种在最里面的发生器之间通信的方式，一直到外面。</p><p id="c712" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在内部，它通过使用生成器对象的<code class="fe my mz na nb b">gi_yieldfrom</code>字段来工作。它指向内部发生器，当你使用<code class="fe my mz na nb b">.send()</code>时它会一直进去。</p><p id="73de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当内部生成器返回时，它沿着链向上，并相应地设置<code class="fe my mz na nb b">yield from</code>的返回值。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="260f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="fe71" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在本文中，我对 CPython 生成器实现的内部工作方式提供了一些见解。虽然这篇文章不是初学者的材料，但它只是触及了这个主题的表面，要理解解释器是如何工作的还有很多。完整的实现当然是开源的，欢迎大家随意探索。享受😉</p></div></div>    
</body>
</html>