<html>
<head>
<title>Natural Language Processing — Beginner to Advanced (Part-3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自然语言处理—从初级到高级(第三部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/natural-language-processing-beginner-to-advanced-part-3-bbd536a89ecb?source=collection_archive---------27-----------------------#2020-05-06">https://towardsdatascience.com/natural-language-processing-beginner-to-advanced-part-3-bbd536a89ecb?source=collection_archive---------27-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d4af" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">NLP项目</h2><div class=""/><div class=""><h2 id="c8b7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">高级词汇处理——如何处理文本数据中的杂波，以及如何构建自己的拼写校正器。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f9fc153886b794933599d0a3f931c1c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDu4ild8z7ApWSX-RryxPQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://pixabay.com/users/3844328-3844328/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1870721" rel="noopener ugc nofollow" target="_blank">洛伦佐·卡法罗</a>从<a class="ae lh" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1870721" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</p></figure><p id="a10b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在“NLP项目”系列的<a class="ae lh" rel="noopener" target="_blank" href="/lexical-processing-for-nlp-basic-9fd9b7529d06">前一部分</a>中，我们学习了所有基本的词汇处理技术，比如去除停用词、标记化、词干化和词条化。</p><p id="efac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">即使经过了所有这些预处理步骤，文本数据中仍然存在大量噪声。例如，由于错误和选择而发生的拼写错误(非正式的词，如' lol '，' u '，' gud '等。).此外，由于发音不同(例如Mumbai，Bombay)而出现的单词拼写变化问题。</p><p id="67af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在上一部分中谈到的两种方法——词干化和词汇化——都是称为<strong class="lk jd">规范化</strong>的技术的一部分。基本上，规范化意味着将一个单词简化为它的基本形式。</p><p id="fdc3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有些情况下，我们不能仅仅通过词干化和词汇化来规范化一个单词。因此，我们需要另一种技术来正确地规范化单词。例如，如果单词“allowing”被拼错为“alowing ”,那么在阻止拼错的单词后，我们将有一个多余的标记“alow ”,并且词条化甚至不起作用，因为它只对正确的词典拼写起作用。</p><p id="41a4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样的问题也存在于不同方言中相同单词的发音上。例如，英式英语中使用的单词“幽默”在美式英语中被拼写为“幽默”。这两种拼写都是正确的，但是在词干之后，当用于形式“幽默”和“幽默”时，它们会给出两种不同的基本形式。</p><h1 id="e040" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">语音散列法</h1><p id="acba" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">有些词在不同的语言中有不同的发音。因此，它们最终的写法是不同的。例如，一个常见的印度姓氏如“Srivastava”也被拼写为“Shrivastava”、“Shrivastav”或“Srivastav”。因此，我们必须把一个特定单词的所有形式简化为一个单一的普通单词。</p><p id="6e12" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了达到这个目的，我们将了解一种叫做语音哈希的技术。语音散列法将相同的<strong class="lk jd">音素</strong>(声音的最小单位)组合到一个桶中，并为所有变体赋予相同的散列码。所以，单词“color”和“colour”有相同的代码。</p><blockquote class="nb nc nd"><p id="205c" class="li lj ne lk b ll lm kd ln lo lp kg lq nf ls lt lu ng lw lx ly nh ma mb mc md im bi translated">语音哈希是一种用于将具有不同变体但语音特征相同(即发音相同)的单词进行规范化的技术。</p></blockquote><p id="2409" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，<strong class="lk jd"> Soundexes </strong>是可以用来计算给定单词的哈希码的算法。语音哈希使用这些Soundex算法。算法因语言而异。美国的Soundex是最流行的Soundex算法，我们将使用它。此外，输入的单词来自哪种语言并不重要——只要单词听起来相似，它们就会获得相同的哈希代码。</p><p id="9c47" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">拼音哈希是一个<strong class="lk jd">四字</strong>码。因此，让我们通过应用以下步骤来计算单词“Chennai”的散列码(也称为Soundex)</p><ol class=""><li id="fce5" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">保留单词的首字母——Soundex的基本原理是，英语发音取决于辅音的首字母和模式。所以，C变成了第一个字母。</li><li id="f1e9" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">去掉所有的元音。所以我们现在有了“CHNN”。</li><li id="6d92" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">用数字替换辅音，如下所示(第一个字母后)</li></ol><ul class=""><li id="daff" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nw no np nq bi translated">b，f，p，v → 1</li><li id="c0da" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">c，g，j，k，q，s，x，z → 2</li><li id="60eb" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">d，t → 3</li><li id="09d5" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">l → 4</li><li id="5ce9" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">m，n → 5</li><li id="4c3f" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">r → 6</li><li id="edfc" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">h、w、y→未编码/已移除</li></ul><p id="2601" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">编码后，代码变成C55。</p><p id="7188" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">4.如果原姓名中有两个或两个以上同号字母相邻(步骤1之前)，只保留首字母；同样，由“h”或“w”分隔的具有相同数字的两个字母被编码为单个数字，而由元音分隔的这种字母被编码两次。这条规则也适用于第一个字母。现在，我们有两个5，所以我们将它们合并成一个，得到C5。</p><p id="d3c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">5.如果单词中的字母太少，我们无法分配三个数字，请添加零，直到有三个数字。如果我们有四个或更多的数字，只保留前三个。由于我们只有一个字母和一个数字，我们将在编码的末尾添加两个零，使其成为一个四字符代码。因此，我们得到C500作为“钦奈”的最终代码。</p><p id="08fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们看到像“Bengaluru”和“Bangalore”这样的城市名称的Soundex代码是相同的，B524，这就是我们的目标。</p><p id="d425" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，我们看到了如何处理一个特定单词的不同发音。接下来，让我们看看如何处理拼写错误。</p><h1 id="4a34" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">编辑距离</h1><p id="6df9" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">简而言之，编辑距离是将一个字符串转换为另一个字符串所需的最小编辑次数，即给定字符串到目标字符串。</p><p id="bf52" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，你一定想知道什么是编辑。因此，可能的编辑如下:-</p><ul class=""><li id="1c89" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nw no np nq bi translated"><strong class="lk jd">将一个字符插入给定的字符串。要将拼写错误的单词“Aquire”转换为正确的拼写“Acquire ”,我们需要在给定的拼写错误的字符串中插入字符“c”。</strong></li><li id="ca60" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">从给定的字符串中删除一个字符。要将“necessary”转换为“必需的”，我们需要从给定的字符串中删除多余的“c”。</li><li id="2c4f" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nw no np nq bi translated">给定字符串中字符的替换。为了将Absense转换成正确的形式Absense，我们需要用字符c代替字符s。</li></ul><p id="e5f6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最常见的编辑距离算法是<strong class="lk jd"> Levenshtein编辑距离</strong>，你可以在这里详细了解<a class="ae lh" href="https://medium.com/@ethannam/understanding-the-levenshtein-distance-equation-for-beginners-c4285a5604f0" rel="noopener">。还有另一个编辑选项叫做“转置操作”，你可以交换给定字符串的两个相邻字符。但是，该操作仅在</a><a class="ae lh" href="https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">damer au-Levenshtein</strong></a>编辑距离中可用。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="3df2" class="me mf it bd mg mh oe mj mk ml of mn mo ki og kj mq kl oh km ms ko oi kp mu mv bi translated">拼写纠正器</h1><p id="7705" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">拼写校正器是一个广泛使用的应用程序。如果您在电话上启用了“自动更正”功能，不正确的拼写将被正确的拼写替换。另一个例子是，当你使用谷歌这样的搜索引擎搜索任何东西，却打错了一个单词，它会提示正确的单词。拼写纠正是词汇处理的重要组成部分。在许多应用中，拼写校正形成了初始预处理层。</p><p id="7e5d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们看到了如何计算两个单词之间的编辑距离。现在，我们将使用编辑距离的概念来制作拼写校正器。我们现在来看看如何制作著名的<strong class="lk jd"> Norvig </strong>法术修正器。</p><p id="2413" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们需要大量拼写正确的文本。这个文本语料库也将作为我们的拼写校正器的字典搜索。在这里，文本“big.txt”的大型语料库只不过是一本书。这是古腾堡计划网站<a class="ae lh" href="https://www.gutenberg.org/" rel="noopener ugc nofollow" target="_blank">上以文本格式呈现的《夏洛克·福尔摩斯历险记》一书。</a></p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="84b6" class="oo mf it ok b gy op oq l or os"># function to tokenise words<br/>def words(document):<br/> “Convert text to lower case and tokenise the document”<br/> return re.findall(r’\w+’, document.lower())</span><span id="c95b" class="oo mf it ok b gy ot oq l or os"># create a frequency table of all the words of the document<br/>all_words = Counter(words(open('big.txt').read()))</span></pre><p id="8c3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将使用五个主要函数来查找单词的正确拼写，它们如下:</p><ol class=""><li id="8490" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated"><strong class="lk jd"> edits_one() </strong>:函数创建与输入单词相距一个编辑距离的所有可能单词。这个函数创建的大多数单词都是垃圾，即它们不是有效的英语单词。例如，如果我们将单词' laern '(单词' learn '的拼写错误)传递给edits_one()，它将创建一个列表，其中将出现单词' lgern '，因为它是远离单词' laern '的编辑。但这不是一个英语单词。只有一部分单词是真正的英语单词。</li></ol><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="3db7" class="oo mf it ok b gy op oq l or os">def edits_one(word):<br/> “Create all edits that are one edit away from `word`.”<br/> alphabets = ‘abcdefghijklmnopqrstuvwxyz’<br/> splits = [(word[:i], word[i:]) for i in range(len(word) + 1)]<br/> deletes = [left + right[1:] for left, right in splits if right]<br/> inserts = [left + c + right for left, right in splits for c in alphabets]<br/> replaces = [left + c + right[1:] for left, right in splits if right for c in alphabets]<br/> transposes = [left + right[1] + right[0] + right[2:] for left, right in splits if len(right)&gt;1]<br/> return set(deletes + inserts + replaces + transposes)</span></pre><p id="db2b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2.<strong class="lk jd"> edits_two() </strong>:函数创建一个所有可能的单词的列表，这些单词与输入单词相差两个编辑点。这些话大部分也会是垃圾。</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="6904" class="oo mf it ok b gy op oq l or os">def edits_two(word):<br/> “Create all edits that are two edits away from `word`.”<br/> return (e2 for e1 in edits_one(word) for e2 in edits_one(e1))</span></pre><p id="b23f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">3.<strong class="lk jd"> known(): </strong>函数从给定单词列表中过滤出有效的英语单词。它使用频率分布作为使用种子文档创建的字典。如果使用edits_one()和edits_two()创建的单词不在词典中，它们将被丢弃。</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="85e9" class="oo mf it ok b gy op oq l or os">def known(words):<br/> “The subset of `words` that appear in the `all_words`.”<br/> return set(word for word in words if word in all_words)</span></pre><p id="47c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">4.<strong class="lk jd"> possible_corrections(): </strong>该函数获取输入单词，并使用上述三个函数返回给定输入单词的正确拼写。首先，它检查输入单词的拼写，如果拼写是正确的，也就是说，如果该单词存在于字典中，它不返回拼写建议，因为它已经是一个正确的字典单词。</p><p id="7b4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果拼写不正确，它将搜索与输入单词相差一个编辑的每个词典单词，并返回它们的列表。如果词典中没有与给定单词相距一个编辑点的单词，那么它将搜索相距两个编辑点的所有词典单词，并返回它们的列表。如果没有两个编辑之外的单词，输入的单词被返回，这意味着拼写纠正器找不到替代词。</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="51cd" class="oo mf it ok b gy op oq l or os">def possible_corrections(word):<br/> “Generate possible spelling corrections for word.”<br/> return (known([word]) or known(edits_one(word)) or known(edits_two(word)) or [word])</span></pre><p id="7a7d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">5.<strong class="lk jd">prob():</strong>prob()函数将创建与每个建议的正确拼写相关联的概率，并返回具有最高概率的拼写，或者我们可以说，它采用建议的正确拼写并返回在我们的文本语料库中的输入单词中最频繁出现的拼写。</p><p id="d141" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是为什么我们需要一个大的文本语料库，而不是一本字典。字典只包含所有正确英语单词的列表。但是，文本语料库不仅包含所有正确的单词，还可以用来创建所有这些单词的频率分布。</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="d6c9" class="oo mf it ok b gy op oq l or os">def prob(word, N=sum(all_words.values())): <br/> “Probability of `word`: Number of appearances of ‘word’ / total number of tokens”<br/> return all_words[word] / N</span></pre><p id="3913" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们几乎完成了拼写校正器的构建。我们只需要把所有的代码片段放在一起，并把它们包装在一个新的函数中，这个函数使用到目前为止创建的所有函数。</p><pre class="ks kt ku kv gt oj ok ol om aw on bi"><span id="0ba2" class="oo mf it ok b gy op oq l or os">def spell_check(word):<br/> “Print the most probable spelling correction for `word` out of all the `possible_corrections`”<br/> correct_word = max(possible_corrections(word), key=prob)<br/> if correct_word != word:<br/> return “Did you mean “ + correct_word + “?”<br/> else:<br/> return “Correct spelling.”</span></pre><p id="31f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">瞧啊。我们已经成功地创建了一个简单却非常有效的拼写纠正器。我们现在可以使用它来纠正任何给定文本语料库的拼写。</p><p id="600c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是第三部分的内容。我们已经在第2部分和第3部分<a class="ae lh" rel="noopener" target="_blank" href="/lexical-processing-for-nlp-basic-9fd9b7529d06">中介绍了整个词汇处理过程。现在，我们将进入NLP的下一个主要部分——句法处理。干杯！</a></p></div></div>    
</body>
</html>