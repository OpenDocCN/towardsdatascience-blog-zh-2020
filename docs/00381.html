<html>
<head>
<title>Deep Learning for Tabular Data using PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyTorch对表格数据进行深度学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deep-learning-for-tabular-data-using-pytorch-1807f2858320?source=collection_archive---------3-----------------------#2020-01-12">https://towardsdatascience.com/deep-learning-for-tabular-data-using-pytorch-1807f2858320?source=collection_archive---------3-----------------------#2020-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e104" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于多类分类问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/849de66405261f567d03b83b990c70f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czGE98me8cXsQcyALWIAgA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://design-nation.icons8.com/intro-to-data-tables-design-349f55861803" rel="noopener ugc nofollow" target="_blank">信号源</a></p></figure><p id="ce46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">深度学习已被证明在计算机视觉、自然语言处理、信号处理等许多领域具有开创性。然而，当涉及到由分类或数字变量组成的更结构化的表格数据时，传统的机器学习方法(如随机森林，XGBoost)被认为表现更好。正如所料，神经网络已经赶上来了，并且在许多情况下表现得一样好，有时甚至更好。</p><p id="331e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用表格数据执行深度学习的最简单方法是通过<a class="ae kv" href="https://docs.fast.ai/tabular.html" rel="noopener ugc nofollow" target="_blank"> fast-ai库</a>，它给出了非常好的结果，但对于试图了解幕后真正发生了什么的人来说，它可能有点太抽象了。因此，在本文中，我介绍了如何构建一个简单的深度学习模型来处理Pytorch中关于多类分类问题的表格数据。</p><h1 id="0841" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Pytorch的一点背景</h1><p id="9f77" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Pytorch是一个流行的开源机器库。它和Python一样使用和学习简单。使用PyTorch的其他一些优势是它的多GPU支持和自定义数据加载器。如果你对基础知识不熟悉或者需要复习，这里是一个很好的起点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="d4c4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">密码</h1><p id="e13c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你想遵循代码，这是我的Jupyter笔记本:</p><div class="mr ms gp gr mt mu"><a href="https://jovian.ml/aakanksha-ns/shelter-outcome" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">动物_庇护所_结果</h2><div class="nb l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">使用jovian.ml共享</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh kp mu"/></div></div></a></div><h1 id="985c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资料组</h1><p id="5d1d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我使用了收容所动物结果Kaggle竞赛数据:</p><div class="mr ms gp gr mt mu"><a href="https://www.kaggle.com/c/shelter-animal-outcomes/data" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">收容所动物结果</h2><div class="ni l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">帮助改善收容所动物的结果</h3></div><div class="nb l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">www.kaggle.com</p></div></div><div class="nc l"><div class="nj l ne nf ng nc nh kp mu"/></div></div></a></div><p id="bc6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个表格数据集，在训练集中包含大约26k行和10列。除了<code class="fe nk nl nm nn b">DateTime</code>之外的所有列都是分类的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/bbc70c743b7e0b28fc5951bc09604380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3XiJhpnLKKyhLvZVlI41hQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自训练集的样本数据</p></figure><h1 id="b300" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题陈述</h1><p id="2cde" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">给定庇护所动物的某些特征(如年龄、性别、颜色、品种)，预测其结果。</p><p id="eafa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有5种可能的结果:<code class="fe nk nl nm nn b">Return_to_owner, Euthanasia, Adoption, Transfer, Died</code>。我们期望找到一个动物的结果属于5个类别中的每一个的概率。</p><h1 id="2107" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数据预处理</h1><p id="7470" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">尽管这一步骤很大程度上取决于特定的数据和问题，但仍有两个必要的步骤需要遵循:</p><h2 id="1e74" class="np lt iq bd lu nq nr dn ly ns nt dp mc lf nu nv me lj nw nx mg ln ny nz mi oa bi translated">摆脱<code class="fe nk nl nm nn b">Nan</code>价值观:</h2><p id="bb9c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">Nan</code>(非数字)表示数据集中缺少值。该模型不接受<code class="fe nk nl nm nn b">Nan</code>值，因此它们必须被删除或替换。</p><p id="da0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于数字列，处理这些值的一种流行方法是用0、均值、中值、众数或其他剩余数据的函数来估算它们。缺失值有时可能表示数据集中的基础要素，因此人们通常会创建一个与缺失值列相对应的新二进制列来记录数据是否缺失。</p><p id="d1a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于分类列，<code class="fe nk nl nm nn b">Nan</code>值可以认为是自己的类别！</p><h2 id="b424" class="np lt iq bd lu nq nr dn ly ns nt dp mc lf nu nv me lj nw nx mg ln ny nz mi oa bi translated">编码所有分类列的标签:</h2><p id="10f8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因为我们的模型只能接受数字输入，所以我们将所有的分类元素转换成数字。这意味着我们不用字符串来表示类别，而是用数字。选择代表类别的数字应在0到该列中不同类别总数(包括<code class="fe nk nl nm nn b">Nan</code>)的范围内。这是为了当我们为该列创建分类嵌入时，我们希望能够索引到我们的嵌入矩阵中，该矩阵对于每个类别都有一个条目。下面是一个简单的标签编码示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/aa73c434fdea3bf25bd183b31d568367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMJOngp5lOd-J_48Wz5G_g.png"/></div></div></figure><p id="1001" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用了scikit-learn库中的<code class="fe nk nl nm nn b"><a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html" rel="noopener ugc nofollow" target="_blank">LabelEncoder</a></code>类来编码分类列。您可以定义一个定制的类来完成这项工作，并跟踪类别标签，因为您也需要它们来编码测试数据。</p><h2 id="a733" class="np lt iq bd lu nq nr dn ly ns nt dp mc lf nu nv me lj nw nx mg ln ny nz mi oa bi translated">编码目标的标签:</h2><p id="65ab" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果目标有字符串条目，我们还需要对其进行标签编码。此外，确保维护一个将编码映射到原始值的字典，因为您将需要它来计算模型的最终输出。</p><h2 id="8355" class="np lt iq bd lu nq nr dn ly ns nt dp mc lf nu nv me lj nw nx mg ln ny nz mi oa bi translated">庇护所结果问题的特殊数据处理:</h2><p id="0fb5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">除了上述步骤，我还对示例问题做了一些处理。</p><ol class=""><li id="5efd" class="oc od iq ky b kz la lc ld lf oe lj of ln og lr oh oi oj ok bi translated">删除了<code class="fe nk nl nm nn b">AnimalID</code>栏，因为它很独特，对训练没有帮助。</li><li id="129a" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">删除了<code class="fe nk nl nm nn b">OutcomeSubtype</code>列，因为它是目标的一部分，但我们没有被要求预测它。</li><li id="35a8" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">删除了<code class="fe nk nl nm nn b">DateTime</code>列，因为记录输入时的确切时间戳似乎不是一个重要的特性。事实上，我最初试图将它拆分成单独的月和年列，但后来意识到将该列一起删除会得到更好的结果！</li><li id="4372" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">删除了<code class="fe nk nl nm nn b">Name</code>列，因为它有太多的<code class="fe nk nl nm nn b">Nan</code>值(缺少10k以上)。此外，它似乎不是决定动物结果的一个非常重要的特征。</li></ol><p id="17ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:在我的笔记本中，我堆叠了训练和测试列，然后进行了预处理，以避免必须根据测试集上的训练集标签进行标签编码(因为这将涉及到维护一个编码标签到实际值的字典)。在这里进行堆叠和处理是没问题的，因为没有数字列(因此没有进行输入),并且每列的类别数量是固定的。在实践中，我们绝不能这样做，因为这可能会将测试/验证集中的一些数据泄露给训练数据，并导致对模型的不准确评估。例如，如果您在类似<code class="fe nk nl nm nn b">age</code>的数字列中有缺失值，并决定用平均值对其进行估算，则平均值应仅在训练集(非堆叠训练-测试-有效集)上计算，并且该值也应用于估算验证和测试集中的缺失值。</p><h1 id="2f08" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">范畴嵌入</h1><p id="cebf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://arxiv.org/pdf/1604.06737.pdf" rel="noopener ugc nofollow" target="_blank">分类嵌入</a>与自然语言处理中常用的单词嵌入非常相似。基本思想是让列中的每个类别都有一个固定长度的向量表示。这与一次性编码的不同之处在于，我们不是使用稀疏矩阵，而是使用嵌入，为每个类别获得密集矩阵，其中相似类别在嵌入空间中具有彼此接近的值。因此，这个过程不仅节省了内存(因为对包含太多类别的列进行一键编码确实会破坏输入矩阵，而且它是一个非常稀疏的矩阵)，而且还揭示了分类变量的内在属性。</p><p id="1643" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果我们有一列颜色，我们为它找到嵌入，我们可以期望<code class="fe nk nl nm nn b">red</code>和<code class="fe nk nl nm nn b">pink</code>在嵌入空间中比<code class="fe nk nl nm nn b">red</code>和<code class="fe nk nl nm nn b">blue</code>更近</p><p id="12d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分类嵌入层相当于每个独热编码输入之上的额外层:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/5073ef241bae0f024781b5ebdf466f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nan-wbyvY4AKSv6wIsL3Bw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://arxiv.org/pdf/1604.06737.pdf" rel="noopener ugc nofollow" target="_blank">分类变量的实体嵌入</a>研究论文</p></figure><p id="8283" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的shelter outcome问题，我们只有分类列，但我会将值少于3的列视为连续列。为了决定每列嵌入向量的长度，我从fast-ai库中取了一个简单的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or mq l"/></div></figure><h1 id="343e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Pytorch数据集和数据加载器</h1><p id="f269" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们扩展了Pytorch提供的<code class="fe nk nl nm nn b"><a class="ae kv" href="https://pytorch.org/docs/stable/_modules/torch/utils/data/dataset.html#TensorDataset" rel="noopener ugc nofollow" target="_blank">Dataset</a></code>(抽象)类，以便在训练时更容易访问我们的数据集，并有效地使用<code class="fe nk nl nm nn b">DataLoader</code>模块来管理批处理。这包括根据我们的特定数据集覆盖<code class="fe nk nl nm nn b">__len__</code>和<code class="fe nk nl nm nn b">__getitem__</code>方法。</p><p id="2537" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们只需要嵌入分类列，所以我们将输入分成两部分:数字和分类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or mq l"/></div></figure><p id="55dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们选择批量大小，并将其与数据集一起提供给数据加载器。深度学习一般是批量进行的。<code class="fe nk nl nm nn b">DataLoader</code>帮助我们有效地管理这些批次，并在训练前重组数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or mq l"/></div></figure><p id="905f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要进行健全性检查，您可以遍历创建的数据加载器来查看每个批处理:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/75e94ad4b0781acf55e442f3f5892883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*afKk4yOMf8Bvc7V6a-aedA.png"/></div></div></figure><h1 id="3998" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模型</h1><p id="276c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们的数据被分成连续的和分类的部分。我们首先根据之前确定的大小将分类部分转换为嵌入向量，并将它们与连续部分连接起来，以馈送到网络的其余部分。这张图片展示了我使用的模型:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/87de5f832132d7c2d1eac50f91bb7b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9nlY-_6w9kKS-k3L5Wh5Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">住房结果模型</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or mq l"/></div></figure><h1 id="75e2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">培养</h1><p id="6eae" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们在训练集上训练模型。我已经使用了Adam优化器来优化交叉熵损失。训练非常简单:迭代每一批，向前传递，计算梯度，梯度下降，根据需要重复这个过程。可以看看<a class="ae kv" href="https://jovian.ml/aakanksha-ns/shelter-outcome" rel="noopener ugc nofollow" target="_blank">我的笔记本</a>了解代码。</p><h1 id="af27" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试输出</h1><p id="ab08" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">由于我们对找到测试输入的每个类的概率感兴趣，所以我们对模型输出应用了Softmax函数。我还提交了一个Kaggle来看看这个模型的表现如何:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/a1884ae21cb17526ef73a976eb640316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jc8eQkarx7hnlrLi26Hebw.png"/></div></div></figure><p id="da3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们做了很少的功能工程和数据探索，并使用了非常基本的深度学习架构，但我们的模型比大约50%的解决方案做得更好。这表明这种使用神经网络对表格数据建模的方法非常强大！</p><p id="1335" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">参考文献:</strong></p><ol class=""><li id="7dad" class="oc od iq ky b kz la lc ld lf oe lj of ln og lr oh oi oj ok bi translated">https://www . usfca . edu/data-institute/certificates/fundamentals-deep-learning—第2课</li><li id="472b" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated"><a class="ae kv" href="https://jovian.ml/aakashns/04-feedforward-nn" rel="noopener ugc nofollow" target="_blank">https://jovian.ml/aakashns/04-feedforward-nn</a></li></ol></div></div>    
</body>
</html>