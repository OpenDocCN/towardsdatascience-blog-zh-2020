<html>
<head>
<title>Handling Missing Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理缺失数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/handling-missing-data-f998715fb73f?source=collection_archive---------51-----------------------#2020-07-28">https://towardsdatascience.com/handling-missing-data-f998715fb73f?source=collection_archive---------51-----------------------#2020-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6fac" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener" target="_blank" href="/a-peek-into-missing-data-with-pandas-2fb9e5df8bd0"> PyTrix 系列</a></h2><div class=""/><div class=""><h2 id="ab7b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">PyTrix #7:处理缺失数据的各种技术</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e783be7d063cb8ec125dd693acf2afac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*odOM0-32oqlbOxfu"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@emilianovittoriosi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃米利亚诺·维托里奥西</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="8177" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 PyTrix 的上一个系列(<a class="ae lh" rel="noopener" target="_blank" href="/a-peek-into-missing-data-with-pandas-2fb9e5df8bd0?source=your_stories_page---------------------------">Pandas 的缺失数据一瞥</a>)中，我们提到了缺失数据和使用 Pandas 框架检测缺失值；这是那一集的摘录“当我们观察到数据中缺少值时，这是因为没有数据值存储在观察的变量中。缺失数据在实践中极为常见，会对从数据中得出的结论产生很大影响，因此数据科学家的大部分时间都花在了数据清理上。”</p><p id="ae6c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管我们探索了检测缺失数据的方法，但是我们并没有给出一个明确的解决方案来解决这个问题。在这篇文章中，我希望介绍一些我认为有用的策略，因为这是 PyTrix，当然我会分享一些有用的 Python 代码，我们可以用它们来完成这些任务。</p><blockquote class="me mf mg"><p id="6b21" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">注意:可以通过下面的链接访问完整的笔记本。此外，这篇文章是直接从 Jupyter 笔记本上创建的——要了解我是如何做到的<a class="ae lh" rel="noopener" target="_blank" href="/publishing-to-medium-from-jupyter-notebooks-53978dd21fac"> <strong class="lk jd">点击这里</strong> </a>。</p></blockquote><div class="ml mm gp gr mn mo"><a href="https://github.com/kurtispykes/demo/blob/master/pytrix/pytrix_handling_missing_data.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd jd gy z fp mt fr fs mu fu fw jc bi translated">kurtispykes/演示</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">permalink dissolve GitHub 是超过 5000 万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">github.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc lb mo"/></div></div></a></div><p id="16b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将使用来自 Kaggle 的臭名昭著的泰坦尼克号数据集，点击<a class="ae lh" href="https://www.kaggle.com/c/titanic/data?select=train.csv" rel="noopener ugc nofollow" target="_blank">此处</a>即可访问。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="3793" class="ni nj it ne b gy nk nl l nm nn">import numpy as np<br/>import pandas as pd</span><span id="78e1" class="ni nj it ne b gy no nl l nm nn"># reading the data<br/>df = pd.read_csv("../data/titanic_raw/train.csv")<br/>df.tail()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="ab gu cl np"><img src="../Images/bd88c629bfa1564f70b9aaea3a334bab.png" data-original-src="https://miro.medium.com/v2/format:webp/1*xfZeyKuU_2VJgFl65-J0Iw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 1</p></figure><p id="8bce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以在<em class="mh">图 1 </em>的年龄和客舱列中看到一些<code class="fe nq nr ns ne b">NaN</code>值，但是通过这种方式查看我们的数据将很难看出我们有多少缺失的数据。更好的解决方案是使用<code class="fe nq nr ns ne b">df.info()</code>,它将为我们提供每一列的非空计数和数据类型——参见<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.info.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="7035" class="ni nj it ne b gy nk nl l nm nn"># information on the columns<br/>df.info()</span><span id="7243" class="ni nj it ne b gy no nl l nm nn">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 891 entries, 0 to 890<br/>Data columns (total 12 columns):<br/> #   Column       Non-Null Count  Dtype  <br/>---  ------       --------------  -----  <br/> 0   PassengerId  891 non-null    int64  <br/> 1   Survived     891 non-null    int64  <br/> 2   Pclass       891 non-null    int64  <br/> 3   Name         891 non-null    object <br/> 4   Sex          891 non-null    object <br/> 5   Age          714 non-null    float64<br/> 6   SibSp        891 non-null    int64  <br/> 7   Parch        891 non-null    int64  <br/> 8   Ticket       891 non-null    object <br/> 9   Fare         891 non-null    float64<br/> 10  Cabin        204 non-null    object <br/> 11  Embarked     889 non-null    object <br/>dtypes: float64(2), int64(5), object(5)<br/>memory usage: 83.7+ KB</span></pre><p id="6726" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有列都有 891 个观察值，但我们在年龄列中只有 714/891 个非空观察值，在客舱列中有 204/891 个非空观察值，在上船列中有 889/891 个非空观察值。</p><p id="6ed1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在处理这些丢失的值之前，我必须指出，在理想情况下，我们应该对现有的数据进行深入分析，因为我们想首先了解数据丢失的原因。此外，在处理缺失值时，与领域专家交谈(如果你不是)也是一个重要的步骤，这样我们可以确保我们使用的任何技术都是合理的(从统计角度看)，并且我们仍然可以从我们的模型中获得准确的预测。</p><p id="3d09" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">原因很简单，如果缺失数据降低了样本的代表性，并因此扭曲了关于人口的推断，那么对于我们处理这个问题来说，确保我们的模型能够准确代表人口是至关重要的。</p><blockquote class="me mf mg"><p id="1d6e" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">由于我们的目的是探索处理缺失数据的各种技术，我们可以假设前面的需求已经实现。</p></blockquote><h2 id="be76" class="ni nj it bd nt nu nv dn nw nx ny dp nz lr oa ob oc lv od oe of lz og oh oi iz bi translated">删除</h2><p id="7f85" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">处理丢失数据的最简单方法是删除它们。也称为列表式删除，在这种方法中，如果一行缺少一个值，我们将从分析中删除整行。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="0ebb" class="ni nj it ne b gy nk nl l nm nn">df2 = df.copy() <br/><br/>print("Before removing rows with missing values")<br/>print(df2.shape)<br/>print("After removing rows with missing values")<br/>df2.dropna(inplace=True)<br/>print(df2.shape)</span><span id="741b" class="ni nj it ne b gy no nl l nm nn">Before removing rows with missing values<br/>(891, 12)<br/>After removing rows with missing values<br/>(183, 12)</span></pre><p id="cea5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从我们的数据中删除行可能会带来更多的伤害，而不是公正。在这个例子中，我们删除了 708 行(占观察值的 20.5%)，考虑到我们的样本大小，这是一个相当大的数据量。这是有问题的，因为减少数据量会降低我们分析的统计能力，因为这部分依赖于高样本量。</p><p id="8ce0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，如果缺失数据的原因不是随机的，如果我们决定进行列表式删除，我们将会在结果中产生偏差。非随机缺失数据的一个例子是当插入问题(例如，你挣多少？)在问卷中被问到。许多人可能不愿意分享这些信息，但回答其他问题却没有问题。这种偏见可能会发生，因为决定回答每个问题(包括干扰性问题)的人可能与不愿意回答干扰性问题的参与者有着非常不同的特征。</p><blockquote class="me mf mg"><p id="fff9" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>如果变量丢失了大部分数据，我们可以创建一个二进制标志变量来表示丢失(1)或不丢失(0)，并删除带有丢失值的初始列。</p></blockquote></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h2 id="5e20" class="ni nj it bd nt nu nv dn nw nx ny dp nz lr oa ob oc lv od oe of lz og oh oi iz bi translated">归罪</h2><p id="3470" class="pw-post-body-paragraph li lj it lk b ll oj kd ln lo ok kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">接下来的几项技术更侧重于插补，即使用替代值替换缺失数据的过程。尽管列表式删除因其简单性而成为处理缺失数据的最常见方式，但它也有缺陷。插补可以被视为避免这些陷阱的一种方法。</p><p id="a711" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">热甲板</strong></p><p id="3b31" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是从随机选择的相似记录中估算缺失值的地方。热卡插补的一种形式是最后一次观察结转(LOCF 插补)。LOCF 所做的是找到第一个缺失值，然后使用紧邻的前一个单元格的值来估算缺失值。这种方法符合这样一种信念，即最佳猜测是数据自上次测量以来没有发生变化。我们将用 Python 实现它。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="61d1" class="ni nj it ne b gy nk nl l nm nn"># looking at the data before imputation<br/>df_hot_deck = df.copy()<br/>df[887:]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="ab gu cl np"><img src="../Images/55ad163ddec423820db721660ce08074.png" data-original-src="https://miro.medium.com/v2/format:webp/1*mNw5HmU0Br2sEqc1x_01zA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 2</p></figure><p id="9111" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们将对该数据帧执行 LOCF，这将使用缺失值上方的单元格来估算所有缺失值</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="0793" class="ni nj it ne b gy nk nl l nm nn"># looking at the data after imputation<br/>df_hot_deck.fillna(method="ffill", inplace=True)<br/>df_hot_deck[887:]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="ab gu cl np"><img src="../Images/fcda06d2a5b6f3ea188fd323b1c19fef.png" data-original-src="https://miro.medium.com/v2/format:webp/1*gwf3-EA0hTqAUDl4EBoXyQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 3</p></figure><p id="478f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">众所周知，使用这种方法估算数据会增加偏差的风险，并可能导致我们的数据得出错误的结论，因此通常不建议使用这种方法——我不太确定人们是否在实践中使用这种方法。</p><p id="5dd8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">统计方法</strong></p><p id="8ae1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从技术上讲，这可能不是用来描述这些技术的正确术语，但是我想要一个总括术语，它将捕捉我们可以使用统计来估算我们的数据的所有不同方式。常见的统计有均值、中值和众数。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="68a9" class="ni nj it ne b gy nk nl l nm nn"># View all rows with a missing age<br/>df3 = df.copy()<br/>missing_age = df3[df3["Age"].isna()].index<br/><br/>df3[df3["Age"].isna()]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="ab gu cl np"><img src="../Images/c317f3d2baa9795c8b0d3597527abc6f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*v7luCL8PP8JlHfxOoUyRvg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 4</p></figure><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="5a78" class="ni nj it ne b gy nk nl l nm nn"># imputing all rows with missing age with the mean age<br/>df3["Age"].fillna(df3["Age"].mean(), inplace=True)<br/>df3.loc[missing_age]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="ab gu cl np"><img src="../Images/26f81f817b1bad74ad21f35e3d9dc737.png" data-original-src="https://miro.medium.com/v2/format:webp/1*q0YmJfKpMrmTZ16fmIT1WA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 5</p></figure><p id="a4a4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">均值插补减弱了任何涉及插补特征的相关性-保证插补变量和任何其他测量变量之间没有关系，这意味着这对于单变量数据来说可能是一种非常好的方法，但对于多变量来说不是很好-我们可以对分类数据使用模式值。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="008a" class="ni nj it ne b gy nk nl l nm nn"># current value counts of the embarked column<br/>df3["Embarked"].value_counts(dropna=False)</span><span id="12f3" class="ni nj it ne b gy no nl l nm nn">S      644<br/>C      168<br/>Q       77<br/>NaN      2<br/>Name: Embarked, dtype: int64</span><span id="48e9" class="ni nj it ne b gy no nl l nm nn"># view rows with missing values<br/>missing_embarked = df3[df3["Embarked"].isna()].index<br/>df3[df3["Embarked"].isna()]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="ab gu cl np"><img src="../Images/bd2a005d28434e363f668813d5dae85c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*FySrDFYrowRYda6M4A7x8A.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 6</p></figure><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="4b19" class="ni nj it ne b gy nk nl l nm nn"># fill the rows with missing values and view them<br/>df3["Embarked"].fillna(df["Embarked"].mode()[0], inplace=True)<br/>df3.loc[missing_embarked]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="ab gu cl np"><img src="../Images/260f2a87087432888bfe8600837bc249.png" data-original-src="https://miro.medium.com/v2/format:webp/1*isJDE94UzVLaRQjXMLnzDA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 7</p></figure><p id="a3ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">模型插补</strong></p><p id="2d74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，这可能是我用来命名这种现象的不好的术语。处理缺失数据插补的一种流行方法是使用模型来预测缺失值。尽管 kNN 已经被证明是非常有效的(通常被称为最近邻插补)，但是有许多模型可供选择。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="8f06" class="ni nj it ne b gy nk nl l nm nn">from sklearn.impute import KNNImputer</span><span id="d10d" class="ni nj it ne b gy no nl l nm nn">X = df[["Survived", "Pclass", "Age", "SibSp", "Parch", "Fare"]].copy() <br/><br/>knn_imputer = KNNImputer(n_neighbors=3)<br/>filled_df = pd.DataFrame(data=knn_imputer.fit_transform(X),<br/>                         columns=["Survived", "Pclass", "Age", "SibSp", "Parch", "Fare"])<br/>filled_df.loc[missing_age]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="ab gu cl np"><img src="../Images/119c5b30eb35b524534b1f71e2327bd0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*sIwtjsTny8nspvOGs6l29Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 8</p></figure><p id="fd0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nq nr ns ne b">KNNImputer</code>的<a class="ae lh" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.KNNImputer.html" rel="noopener ugc nofollow" target="_blank">文档</a>声明“使用训练集中找到的 n_neighbors 最近邻的平均值估算每个样本缺失值。如果两个样本都不缺少的特征是接近的，则这两个样本是接近的。”。因此，我移除了所有对象数据类型，因为这将在此算法的中引发错误。</p><blockquote class="me mf mg"><p id="9d1b" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd">注意</strong>:也有其他算法内置了处理缺失值的方法，比如 XGBoost</p></blockquote></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="0555" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您想与我联系，请在 LinkedIn 上留下回复或与我联系。</p><div class="ml mm gp gr mn mo"><a href="https://www.linkedin.com/in/kurtispykes/?originalSubdomain=uk" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd jd gy z fp mt fr fs mu fu fw jc bi translated">Kurtis Pykes -人工智能作家-走向数据科学| LinkedIn</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">在世界上最大的职业社区 LinkedIn 上查看 Kurtis Pykes 的个人资料。Kurtis 有一个工作列在他们的…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">www.linkedin.com</p></div></div><div class="mx l"><div class="ov l mz na nb mx nc lb mo"/></div></div></a></div></div></div>    
</body>
</html>