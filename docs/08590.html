<html>
<head>
<title>BigQuery: Creating Nested Data with SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery:使用SQL创建嵌套数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bigquery-creating-nested-data-with-sql-727b761f1755?source=collection_archive---------10-----------------------#2020-06-22">https://towardsdatascience.com/bigquery-creating-nested-data-with-sql-727b761f1755?source=collection_archive---------10-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3c5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我在我的另一篇文章<a class="ae ko" rel="noopener" target="_blank" href="/https-medium-com-martin-weitzmann-bigquery-sql-on-nested-data-cf9589c105f4"> BigQuery:嵌套数据上的SQL</a>中所阐述的，在嵌套数据上使用SQL是非常高效的——只要任务在后端是可并行化的。但是，如果您的数据来自平面表，例如CSV，则必须首先转换数据。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/3a65943c432911005ef17939ac4cffbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_IJ5GA2TNcw_GOyC4AfObA.jpeg"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">作者照片</p></figure><h1 id="abd6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">嵌套单个值</h1><p id="2d41" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">通常——在平面表场景中——您只需要使用<code class="fe mi mj mk ml b">JOIN</code>来组合两个表:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/e18abac72a668a8ce1b2e62e980ad13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*Z4Czuj3KrqEdF2KHjm66DQ.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">上面查询的结果表——试试吧！</p></figure><p id="f0b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是当然，我们永远不会保存这样的表，因为有些字段只是一遍又一遍地重复，占用存储空间，这反过来会产生可避免的成本。</p><p id="e1ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果我们使用表<code class="fe mi mj mk ml b">authors</code>和<em class="mp">将书籍放入数组</em>中，我们就不会重复作者字段。在BigQuery中，我们可以使用<code class="fe mi mj mk ml b"><a class="ae ko" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#array_agg" rel="noopener ugc nofollow" target="_blank">ARRAY_AGG()</a></code>轻松做到这一点，这是一个聚合函数，可以与<code class="fe mi mj mk ml b">GROUP BY</code>结合使用，将值放入数组中:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/e47e7ab71b3a27108d67dc58998e4b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*ZC5zqlWjFaMWih-EgQKnqw.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">嵌套在“works”数组中的标题——自己试试吧！</p></figure><p id="e5da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们保存这个结果表，我们将通过有效地存储信息来避免成本，并且我们可以去掉一些id，因为我们不再需要加入。</p><p id="9361" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它还降低了查询的复杂性，因为信息位于同一个表中。您不必想象表A和表B以及它们加入后的样子，然后才考虑如何选择和分组，您可以直接选择和分组。</p><p id="1c03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看这里的最后一个<code class="fe mi mj mk ml b">SELECT</code>语句——想象我们将结果表存储在某个地方，而不是放入<code class="fe mi mj mk ml b">WITH</code>。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">使用UNNEST()编写子查询(第24行)在<a class="ae ko" rel="noopener" target="_blank" href="/https-medium-com-martin-weitzmann-bigquery-sql-on-nested-data-cf9589c105f4"> BigQuery:嵌套数据上的SQL</a>中有介绍</p></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/7d544a7faaaddd8e2f727f971c6d5518.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*_WpyuUQaurxhYRwrf6RUeg.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">上面查询的结果表——试试看！</p></figure><p id="df98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们可以轻松地对数组应用各种聚合技术，或者简单地将数组与其父数组交叉连接以获得一个平面表。为了进一步分析，我们预先连接了表，但保持了存储效率。我们甚至引入了两个字段<em class="mp"> qtyTitles </em>和<em class="mp"> qtyCharacters </em>，它们已经告诉了我们关于数组的事情——这对数组聚合中的常见用例很有帮助。</p><h1 id="283a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">嵌套多个值</h1><p id="2872" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们引入另一个字段，看看如何在一个数组中存储多个字段。让我们快速思考一下:我们在一个数组中一次只能存储一种元素类型——这是一个简单的列表:<code class="fe mi mj mk ml b">[1,1,2,3,5,8]</code>。所以我们需要把多个值变成一个复数值的东西。对此的解决方案是<code class="fe mi mj mk ml b">STRUCT</code>，它基本上是一个带有要求的键-值对列表:键必须保持不变，值不允许改变它们的数据类型:<code class="fe mi mj mk ml b">[{a:1,b:x},{a:2,b:y},{a:3,b:z}]</code>。这也是BigQuery被称为“半结构化”的原因。</p><p id="39f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有几种方法可以构建结构，但是与<code class="fe mi mj mk ml b">ARRAY_AGG()</code>结合使用最方便的是函数<code class="fe mi mj mk ml b"><a class="ae ko" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#constructing_a_struct" rel="noopener ugc nofollow" target="_blank">STRUCT()</a></code>。只需选择要嵌入到数组中的字段，并将它们放入一个结构中:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">第15–17行显示了每个组(array_agg + group by)中被放入数组的结构</p></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/0fa180dd27e8dbf9a5a7f15748443fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*k7ydhm33f4oceeS4kpPEjw.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">带点的列标题表示结构</p></figure><p id="c020" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们准备了一个预连接表:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2c79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们甚至可以使用<code class="fe mi mj mk ml b">ARRAY()</code>和<code class="fe mi mj mk ml b">SELECT AS STRUCT</code>从现有的数组创建新的复杂数组。此外，窗口函数的作用域是由数组的边界自动确定的！</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mt"><img src="../Images/afe18e328849af94af047d756df1dd41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pSsVSfpp0THW3bkUE1gOVA.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">上面查询的结果表</p></figure><p id="a837" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建新数组或扩展旧数组——在这里，扩展更有意义。为此，我们只需在子查询中选择现有的列，例如<code class="fe mi mj mk ml b">ARRAY(SELECT AS STRUCT <strong class="js iu">*</strong>, UPPER(title) AS title ...</code></p><h1 id="a239" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">嵌套更复杂的值</h1><p id="034e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">虽然我们可以使用struct函数简单地将结构嵌套在结构中，但是如果我们想将数组嵌套在数组中，我们需要提前做一些计划。</p><p id="d37f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们介绍第三个表，它包含与一本书相关的标题。该表只有三个条目，只是为了让它暂时易于管理。</p><p id="45e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们必须首先创建最内层的数组，以便以后可以将它们嵌套在其他数组中:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">第22行的“忽略空值”有助于避免空数组错误</p></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/c816139063aef057c6397ee49a983ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*8cythuLr5EpGm_Kj5mbLgg.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">结果表—尝试为其他标题添加更多信息！</p></figure><p id="1571" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将最后一个<code class="fe mi mj mk ml b">SELECT</code>语句作为<em class="mp"> round1 </em>放入<code class="fe mi mj mk ml b">WITH</code>中，我们可以从<code class="fe mi mj mk ml b">SELECT * FROM authors LEFT JOIN round1 USING(id)</code>开始第2轮，并得到我们的作者…</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/25e705134cc0d9b6943aa0ed1c3fe551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*MfA6wqZALLX2zgSYMw_W2Q.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">为array_agg() round 2准备好的表！</p></figure><p id="cd8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从这里，我们可以使用相同的方法在更高的范围内再次聚合:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c4e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要为我们想要创建的每个深度级别的阵列进行一轮聚合:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/781193625e43d6b11acd941619a9b7d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*iit9vXfupZv7-ZECD3uAyA.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">阵列中的阵列——多么美妙的世界</p></figure><p id="af47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了在分析中达到这些值，相同的规则始终适用:</p><ul class=""><li id="3b1d" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">为了将数组聚合为一个值<em class="mp">，使用子查询</em></li><li id="651d" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">对数组中的值进行分组<em class="mp">使用交叉/左连接</em></li></ul><p id="92b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">交叉连接消除空行，而左连接保留空行。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nl"><img src="../Images/13e932b757e16dacecb6cf0fff19dae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uvp-UiXnejTbLXqBklEwLA.png"/></div></div></figure><p id="a15e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mp"> relatedTitles </em>从一个数组中抓取另一个数组中的信息，而<em class="mp"> relatedBooks </em>使用子查询交叉连接将两个数组中的信息合并为一个。</p><p id="9960" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这能让您对使用SQL在BigQuery中构造表的可能性有一点了解。我应该注意到，创建性能良好的表还有更多的方面。一定要看看<a class="ae ko" href="https://cloud.google.com/bigquery/docs/partitioned-tables" rel="noopener ugc nofollow" target="_blank">分区</a>和<a class="ae ko" href="https://cloud.google.com/bigquery/docs/clustered-tables" rel="noopener ugc nofollow" target="_blank">聚类</a>表的主题！使用<a class="ae ko" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language" rel="noopener ugc nofollow" target="_blank"> DDL </a>可以非常方便地做到这一点。如果你想用SQL语句插入数据，看看<a class="ae ko" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/dml-syntax#insert_statement" rel="noopener ugc nofollow" target="_blank">插入</a>结合<code class="fe mi mj mk ml b">WITH</code>语句准备数据。</p><p id="d550" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你有任何问题或意见，请告诉我。我很想知道您是如何在BigQuery中准备和优化表的！</p></div></div>    
</body>
</html>