<html>
<head>
<title>Heuristics What Why and How?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">启发式什么为什么和如何？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/heuristics-what-why-and-how-68aafc7e1e4b?source=collection_archive---------32-----------------------#2020-04-10">https://towardsdatascience.com/heuristics-what-why-and-how-68aafc7e1e4b?source=collection_archive---------32-----------------------#2020-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2c17" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">启发式算法在算法开发中的理解和应用</h2></div><p id="1cd3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">试探法是我们使用的一种近似方法，它不能保证在实现目标时是最优的。在本文中，我将通过一个简单易懂的例子来深入解释我们如何使用启发式算法进行算法开发。所以我将使用<strong class="kh ir"> <em class="lb"> A-Star (A*) </em> </strong>算法，用一个涉及最短路径的完整例子来说明启发式的使用和实现。</p><h1 id="9495" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">确定性方法</h1><p id="5bfd" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">确定性方法保证提供最佳解决方案。例如，<strong class="kh ir"> Dijkstra的算法</strong>可以认为是一种确定性算法，用于获得边权重为正的图中任意两点之间的最短路径。</p><h2 id="5434" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">作为确定性算法的Dijkstra算法</h2><p id="2bbd" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">该算法最基本的形式如下。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="2dc0" class="lz ld iq mq b gy mu mv l mw mx">function Dijkstra(Graph, Start)<br/>    vertex_set = {}<br/>    for each vertex v in Graph<br/>        dist[v] = INFINITY<br/>        parent[v] = NULL<br/>    dist[start] = 0</span><span id="b5ea" class="lz ld iq mq b gy my mv l mw mx">    while vertex_set not empty<br/>        u = min dist vertex from vertex_set<br/>        remove u from vertex_set<br/>        <br/>        for neighbour v of u<br/>            path = dist[u]+length(u,v)<br/>            if path &lt; dist[v]<br/>                dist[v] = path<br/>                parent[v] = u<br/>    return parent, dist</span></pre><p id="5b61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，在算法的开始，没有考虑关于目标节点的知识。因此，我们本质上执行到图的每一个其他可通过顶点的最短路径的穷举搜索。想象这张图是你国家的道路网。这能扩展到那个水平吗？Dijkstra算法的最佳最小优先级队列实现的时间复杂度为O(|V|+|E|log|V|)  。</p><h1 id="dda2" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">在Dijkstra算法中引入启发式算法</h1><p id="93c1" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">与其穷尽搜索<strong class="kh ir">源</strong> <strong class="kh ir">顶点</strong>的所有邻居，我们还不如挑选邻居，这样<strong class="kh ir">可能</strong>会给我们一条到图中<strong class="kh ir">目标</strong> <strong class="kh ir">顶点</strong>的更短路径。单词<strong class="kh ir">可能</strong>很重要，因为试探法经常以次优输出告终。</p><blockquote class="na"><p id="af58" class="nb nc iq bd nd ne nf ng nh ni nj la dk translated">我们如何猜测一个特定的节点是否会把我们引向一条更短的路径？</p></blockquote><p id="82c3" class="pw-post-body-paragraph kf kg iq kh b ki nk jr kk kl nl ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">这就是启发性的来源。例如，在道路网络的情况下，我们可以假设我们选择的交叉点越近，它到达目标城市的速度可能越快。为此，我们可以利用现成的GPS信息来计算出一个不是<em class="lb">那么精英的</em>，而是从空中两点之间的大致距离。尽管这可能不正确，但考虑到你可能会看到弯道和环形路，我们可以确定移动的大致方向一定是朝着目标城市。</p><p id="dd42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比较上面的猜测，你可能会注意到，如果我们选择了Dijkstra的算法，我们也会计算到目标节点的距离，而这些节点不在我们预期目标的方向上。最著名的启发式最短路径算法的可靠实现被称为<strong class="kh ir"> A* </strong>或<strong class="kh ir"> A-Star算法</strong>。</p><h1 id="f3ac" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">a星算法</h1><p id="c54d" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">伪代码如下所示。在<a class="ae mz" href="https://en.wikipedia.org/wiki/A*_search_algorithm" rel="noopener ugc nofollow" target="_blank"> wiki </a>中阅读更多内容。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a0f7" class="lz ld iq mq b gy mu mv l mw mx">function AStar(start, end, heuristic=h)<br/>    open_set = {start}<br/>    closed_set = {}</span><span id="d2da" class="lz ld iq mq b gy my mv l mw mx">    # distance so far to node<br/>    distance = lookup_table(default=INFINITY)<br/>    # guess to the end<br/>    guess = lookup_table(default=INFINITY)</span><span id="9e8a" class="lz ld iq mq b gy my mv l mw mx">    distance[start] = 0<br/>    guess[start] = h(start)</span><span id="74d6" class="lz ld iq mq b gy my mv l mw mx">    while open_set not empty<br/>        current = node with lowest guess from open_set<br/>        if current is goal: END<br/>        <br/>        open_set.remove(current)<br/>        closed_set.add(current)</span><span id="ea9d" class="lz ld iq mq b gy my mv l mw mx">        for neighbour of current<br/>            score = distance[current]+length(current,neighbour)<br/>            if score &lt; guess[neighbour]<br/>                distance[neighbour] = score<br/>                parent[neighbour] = current<br/>                guess[neighbour] = distance[neighbour]+h(neighbour)<br/>                if neighbour not in closed_set<br/>                    open_set.add(neighbour)</span></pre><p id="7d2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面代码中的一个问题是，您必须扫描一个数组来获得目标节点的最近邻居。但是，如果您想使用到目标节点的距离作为关键字将邻居存储在最小堆中，您可以在<strong class="kh ir"> <em class="lb"> O(1) </em> </strong>时间内完成此操作。我们可以用数据结构的知识来改进算法，这很简单(<a class="ae mz" rel="noopener" target="_blank" href="/8-common-data-structures-every-programmer-must-know-171acf6a1a42">阅读这篇文章以了解更多</a>)。让我们看看这个算法在python中的实现。</p><h1 id="2bb4" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">在Python中实现A-Star</h1><p id="6415" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我将在我的算法实现中使用以下导入。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="fee4" class="lz ld iq mq b gy mu mv l mw mx">import numpy as np<br/>import matplotlib.pyplot as plt # for visualizations<br/>import matplotlib.cm as cm      # for visualizations<br/>from collections import defaultdict<br/>import networkx as nx           # storing the graph structure<br/>import heapq                    # pythons heap implementation</span></pre><p id="4a69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将创建一个包装类来包含图的顶点(节点),这样我就可以在python的<code class="fe np nq nr mq b">heapq</code>实现中立即使用它们。我覆盖了包装器的<code class="fe np nq nr mq b">__lt__</code>函数，这样<code class="fe np nq nr mq b">heapq</code>将使用它的<code class="fe np nq nr mq b">val</code>属性到<code class="fe np nq nr mq b">heappush</code>和<code class="fe np nq nr mq b">heappop</code>元素。这个<code class="fe np nq nr mq b">val</code>对应于到目标节点的距离。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f1aa" class="lz ld iq mq b gy mu mv l mw mx">class NodeWrap:<br/>    def __init__(self, nid, dist_to_end):<br/>        self.nid = nid<br/>        self.val = dist_to_end<br/>        <br/>    def __lt__(self, other):<br/>        return self.val &lt; other.val</span></pre><p id="6b55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦算法运行并且我们有了遍历的顶点的父顶点，我就使用下面的代码来追踪最短路径。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="abe0" class="lz ld iq mq b gy mu mv l mw mx">def trace_path(parent_map, end):<br/>    node = end<br/>    path = []<br/>    while (node in parent_map):<br/>        path.append(node)<br/>        node = parent_map[node]<br/>    return path[::-1]</span></pre><h2 id="6fa8" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">实现图形和可视化矩阵</h2><p id="d016" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">因为这是为了学习的目的，所以我认为实时观察算法的运行是非常有趣的。因此，让我们将我们的问题建模如下。假设我们有一个2D地形，我们想从左下角到达右上角。我们的道路上有一个黑色的障碍物。</p><figure class="ml mm mn mo gt nt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/58206d8fd34972c283bca7239562d1e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*0pbIlOmovbz5NmTLw6YynA.png"/></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">要穿越的地形</p></figure><p id="f570" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我使用下面的代码填充这个地形。这是一个大小为<code class="fe np nq nr mq b">50x50</code>的简单矩阵。图像是一个矩阵，有三个通道用于<strong class="kh ir"> RGB </strong>。所以障碍简单来说就是带<code class="fe np nq nr mq b">[0, 0, 0]</code>的索引。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="2098" class="lz ld iq mq b gy mu mv l mw mx">mat = np.zeros((50, 50, 3), dtype=np.float32)</span><span id="1814" class="lz ld iq mq b gy my mv l mw mx">for x in range(50):<br/>    for y in range(50):<br/>        mat[x, y, 0] = 0.95<br/>        mat[x, y, 1] = 0.95<br/>        mat[x, y, 2] = 0.95<br/>        g.add_node("{},{}".format(x,y), x=x, y=y)</span><span id="c3ba" class="lz ld iq mq b gy my mv l mw mx"># end<br/>mat[49, 0, 0] = .0<br/>mat[49, 0, 1] = .0<br/>mat[49, 0, 2] = 0.8        <br/># start<br/>mat[0, 49, 0] = .0<br/>mat[0, 49, 1] = 0.8<br/>mat[0, 49, 2] = .0</span><span id="ffc4" class="lz ld iq mq b gy my mv l mw mx">for x in range(20, 50):<br/>    for y in range(20, 50):<br/>        if x&gt;y+5:<br/>            mat[x, y, 0] = .0<br/>            mat[x, y, 1] = .0<br/>            mat[x, y, 2] = .0</span><span id="f8a1" class="lz ld iq mq b gy my mv l mw mx">for x in range(0, 30):<br/>    for y in range(0, 30):            <br/>        if x&lt;y-5:<br/>            mat[x, y, 0] = .0<br/>            mat[x, y, 1] = .0<br/>            mat[x, y, 2] = .0</span><span id="ce94" class="lz ld iq mq b gy my mv l mw mx">for x in range(26, 30):<br/>    for y in range(10, 20): <br/>        mat[x, y, 0] = .0<br/>        mat[x, y, 1] = .0<br/>        mat[x, y, 2] = .0<br/>mat_copy = np.copy(mat)</span></pre><h2 id="1c19" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">创建网络x图</h2><p id="1e29" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">因为图形操作最好在具有图形功能的类似图形的数据结构上执行，所以让我们将地形迁移到图形上。每个像素将是我们图中的一个<strong class="kh ir"> <em class="lb">节点/顶点</em> </strong>。从每个<strong class="kh ir"> <em class="lb">节点/顶点</em> </strong>我们可以像棋盘上的女王一样在所有8个方向上遍历。在我们的例子中，边是存在的，除非可用的可逆邻居是黑色的。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="51fa" class="lz ld iq mq b gy mu mv l mw mx">g = nx.Graph()</span><span id="397d" class="lz ld iq mq b gy my mv l mw mx">def is_black(arr):<br/>    return sum(arr) == 0<br/>            <br/>for x in range(50):<br/>    for y in range(50):<br/>        xi = g.nodes["{},{}".format(x,y)]['x']<br/>        yi = g.nodes["{},{}".format(x,y)]['y']<br/>        for xj in range(xi-1, xi+2):<br/>            for yj in range(yi-1, yi+2):<br/>                if xi==xj and yi==yj or \<br/>                    xj&lt;0 or yj&lt;0 or \<br/>                    xj&gt;49 or yj&gt;49: <br/>                    continue<br/>                # if black not a neighbour<br/>                if is_black(mat[xi, yi]) \<br/>                    or is_black(mat[xj, yj]): <br/>                    continue<br/>                g.add_edge("{},{}".format(xi,yi), "{}, \      <br/>                               {}".format(xj,yj))</span></pre><h2 id="13ff" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">用检查点实现算法</h2><p id="f70c" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在我已经准备好了我的图表，我想实现并运行一个A-Star。同时，当算法搜索邻居时，我想对初始的2D地形进行快照，以便以后可视化。完整的python代码如下。这里我使用<strong class="kh ir">欧几里德距离</strong>作为距离启发式，这是从任何节点到目标的猜测。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f082" class="lz ld iq mq b gy mu mv l mw mx">def store_image(world, node, i):<br/>    global mat<br/>    x = world.nodes[node]['x']<br/>    y = world.nodes[node]['y']<br/>    <br/>    mat[x, y, 0] = 1<br/>    mat[x, y, 1] = .5<br/>    mat[x, y, 2] = .0<br/>    <br/>    fig = plt.figure(figsize=(10, 10))<br/>    plt.imshow(mat)<br/>    plt.axis('off')<br/>    plt.savefig("im-{}.png".format(i))<br/>    plt.close()</span><span id="6d03" class="lz ld iq mq b gy my mv l mw mx">def euclidean_dist(world, node1, node2):<br/>    x1 = world.nodes[node1]['x']<br/>    x2 = world.nodes[node2]['x']<br/>    y1 = world.nodes[node1]['y']<br/>    y2 = world.nodes[node2]['y']<br/>    <br/>    return ((x1-x2)**2 + (y1-y2)**2)**.5</span><span id="035a" class="lz ld iq mq b gy my mv l mw mx">def a_star(world, start, end):<br/>    stepper = 1<br/>    open_set = []<br/>    close_set = set()<br/>    parent_map = {}    <br/>    start_node = NodeWrap(start, 0)<br/>    heapq.heappush(open_set, start_node)<br/>    <br/>    store_image(world, start, stepper)<br/>    stepper += 1 <br/>    <br/>    cost_to_reach_node = defaultdict(lambda: float('inf'))<br/>    cost_to_reach_node[start] = 0<br/>    <br/>    guess_to_destination = defaultdict(lambda: float('inf'))<br/>    guess_to_destination[start] = euclidean_dist(world, start, end)<br/>    <br/>    while len(open_set) &gt; 0:<br/>        current = heapq.heappop(open_set)<br/>        if current.nid == end:<br/>            path = trace_path(parent_map, end) <br/>            return path<br/>        close_set.add(current.nid)<br/>        <br/>        for neighbor in world.neighbors(current.nid):<br/>            tentative_score = cost_to_reach_node[current.nid] + \<br/>                      euclidean_dist(world, current.nid, neighbor)<br/>            if tentative_score &lt; cost_to_reach_node[neighbor]:<br/>                parent_map[neighbor] = current.nid<br/>                cost_to_reach_node[neighbor] = tentative_score<br/>                guess_to_destination[neighbor] =     <br/>                          cost_to_reach_node[neighbor] + \<br/>                          euclidean_dist(world, neighbor, end)<br/>                <br/>                if neighbor not in close_set:<br/>                    neighbor_node = NodeWrap(neighbor,           <br/>                              euclidean_dist(world, neighbor, end))<br/>                    heapq.heappush(open_set, neighbor_node)<br/>                    store_image(world, neighbor, stepper)<br/>                    stepper += 1</span></pre><p id="cb44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用下面的runner代码片段运行上面的算法。注意，我使用了矩阵的副本，因为在算法中我们更新了初始的<code class="fe np nq nr mq b">mat</code>对象。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="2f92" class="lz ld iq mq b gy mu mv l mw mx">path = a_star(g, "49,0", "0,49")</span><span id="01fe" class="lz ld iq mq b gy my mv l mw mx"># trace path and visualize on terrain<br/>for node in path:<br/>    x = g.nodes[node]['x']<br/>    y = g.nodes[node]['y']<br/>    <br/>    mat_copy[x, y, 0] = 1<br/>    mat_copy[x, y, 1] = .5<br/>    mat_copy[x, y, 2] = .0</span><span id="d7ce" class="lz ld iq mq b gy my mv l mw mx">fig = plt.figure(figsize=(10, 10))<br/>plt.imshow(mat_copy)<br/>plt.axis('off')</span></pre><h2 id="099d" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">最终执行并创建GIF</h2><p id="2866" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">当我们在动画中看到事情是如何发生的时候，这种美就更加明显了。所以我会把我创作的所有图片组合起来，形成一个华丽的GIF。我使用下面的代码从我的快照图像中创建GIF。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6c6d" class="lz ld iq mq b gy mu mv l mw mx">import imageio<br/>import glob</span><span id="69ac" class="lz ld iq mq b gy my mv l mw mx">anim_file = 'out.gif'</span><span id="545f" class="lz ld iq mq b gy my mv l mw mx">with imageio.get_writer(anim_file, mode='I', fps=10) as writer:<br/>    filenames = glob.glob('im-*.png')<br/>    filenames = sorted(filenames, \<br/>        key=lambda x: int(x.replace("im-", "").replace(".png", "")))<br/>    last = -1<br/>    for i,filename in enumerate(filenames):<br/>        frame = 2*(i**0.5)<br/>        if round(frame) &gt; round(last):<br/>            last = frame<br/>        else:<br/>            continue<br/>        image = imageio.imread(filename)<br/>        writer.append_data(image)<br/>    image = imageio.imread(filename)<br/>    writer.append_data(image)<br/>    image = imageio.imread(filename)<br/>    writer.append_data(image)<br/>    image = imageio.imread(filename)<br/>    writer.append_data(image)</span></pre><p id="25a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做后，我们将有以下动画。</p><figure class="ml mm mn mo gt nt gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oa"><img src="../Images/e5230dc567f7cd52b7779746111975d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7yBjl5lCsnQnZzPh43GjfA.gif"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">动画</p></figure><h1 id="9660" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">结论</h1><p id="2d36" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们可以清楚地看到，遍历发生在一个非常狭窄的搜索空间。这使得搜索速度更快，我们不需要对所有节点进行彻底的搜索。</p><p id="4dd6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在大得多的图中，节点标记和索引等技术已经完成，因此不需要将图完全加载到运行时内存中。我希望以后能写更多关于这个话题的文章。现在，我希望你喜欢阅读这篇文章。你可以在这里看到完整的笔记本<a class="ae mz" href="https://gist.github.com/anuradhawick/a4bde038e039f08fed6195d94704f480" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>