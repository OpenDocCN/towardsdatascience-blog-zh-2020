<html>
<head>
<title>Advanced SQL Templates In Python with JinjaSql</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带JinjaSql的Python中的高级SQL模板</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/advanced-sql-templates-in-python-with-jinjasql-b996eadd761d?source=collection_archive---------4-----------------------#2020-01-13">https://towardsdatascience.com/advanced-sql-templates-in-python-with-jinjasql-b996eadd761d?source=collection_archive---------4-----------------------#2020-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8599" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Python函数、循环和可变预设增强您的SQL模板。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b47fd11380a1098a7422b720cf71eecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eaCFTSCb8QUce9os.jpg"/></div></div></figure><p id="bd6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<a class="ae ln" rel="noopener" target="_blank" href="/a-simple-approach-to-templated-sql-queries-in-python-adc4f0dc511">Python中模板化SQL查询的简单方法</a>中，我使用<a class="ae ln" href="https://github.com/hashedin/jinjasql" rel="noopener ugc nofollow" target="_blank"> JinjaSql </a>介绍了Python中SQL模板的基础知识。这篇文章使用预置、循环和自定义函数进一步展示了JinjaSql模板中的<a class="ae ln" href="http://jinja.pocoo.org/" rel="noopener ugc nofollow" target="_blank"> Jinja2 </a>的强大功能。让我们考虑一个日常用例，当我们有一个包含一些维度和一些数值的表，并且我们想要找到给定维度或维度组合的一些指标。下面的示例数据很小，而且完全是虚构的，但它足以演示高级功能。首先，我介绍数据集和SQL查询要回答的问题。然后，我将构建没有模板的查询，最后，展示如何使用SQL模板来参数化和生成这些查询。</p><h1 id="cd09" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">示例数据集</h1><p id="6300" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">让我们考虑一个包含一些商店购物记录的表<code class="fe ml mm mn mo b">transactions</code>。购买可以通过现金、信用卡或借记卡进行，这为数据增加了额外的维度。下面是创建和填充该表的代码。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="e8c4" class="mt lp iq mo b gy mu mv l mw mx"><strong class="mo ir">create</strong> <strong class="mo ir">table</strong> transactions (<br/>    transaction_id <strong class="mo ir">int</strong>,<br/>    user_id <strong class="mo ir">int</strong>,<br/>    transaction_date <strong class="mo ir">date</strong>,<br/>    store_id <strong class="mo ir">int</strong>,<br/>    payment_method <strong class="mo ir">varchar</strong>(10),<br/>    amount <strong class="mo ir">float</strong><br/>)<br/>;</span><span id="348b" class="mt lp iq mo b gy my mv l mw mx"><strong class="mo ir">insert</strong> <strong class="mo ir">into</strong> transactions<br/>(transaction_id, user_id, transaction_date, store_id, payment_method, amount)<br/><strong class="mo ir">values</strong><br/>    (1, 1234, ‘2019–03–02’, 1, 'cash', 5.25),<br/>    (1, 1234, ‘2019–03–01’, 1, 'credit', 10.75),<br/>    (1, 1234, ‘2019–03–02’, 2, 'cash', 25.50),<br/>    (1, 1234, ‘2019–03–03’, 2, 'credit', 17.00),<br/>    (1, 4321, ‘2019–03–01’, 2, 'cash', 20.00),<br/>    (1, 4321, ‘2019–03–02’, 2, 'debit', 30.00),<br/>    (1, 4321, ‘2019–03–03’, 1, 'cash', 3.00)<br/>;</span></pre><h1 id="aab7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">要计算的指标</h1><p id="6d47" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在研究一个数据集时，通常会查看所有维度的主要性能指标。在本例中，我们希望计算以下指标:</p><ul class=""><li id="ade1" class="mz na iq kt b ku kv kx ky la nb le nc li nd lm ne nf ng nh bi translated">交易数量</li><li id="ea77" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">平均交易金额</li><li id="e549" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">交易总额</li></ul><p id="5421" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要每个用户、商店和支付方式的这些指标。我们还想通过商店和支付方式来了解这些指标。</p><h1 id="8a23" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">单一维度的模板</h1><p id="6bd5" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">获取每个商店指标的查询是:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="c59f" class="mt lp iq mo b gy mu mv l mw mx"><strong class="mo ir">select</strong><br/>    store_id<br/>    , count(*) <strong class="mo ir">as</strong> num_transactions<br/>    , sum(amount) <strong class="mo ir">as</strong> total_amount<br/>    , avg(amount) <strong class="mo ir">as</strong> avg_amount<br/><strong class="mo ir">from</strong><br/>    transactions<br/><strong class="mo ir">group</strong> <strong class="mo ir">by</strong><br/>    store_id<br/><strong class="mo ir">order</strong> <strong class="mo ir">by</strong> total_amount <strong class="mo ir">desc</strong></span></pre><p id="d8c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了获得其他维度的相同指标，我们只需将<code class="fe ml mm mn mo b">select</code>和<code class="fe ml mm mn mo b">group by</code>子句中的<code class="fe ml mm mn mo b">store_id</code>改为<code class="fe ml mm mn mo b">user_id</code>或<code class="fe ml mm mn mo b">payment_method</code>。因此JinjaSql模板可能看起来像</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="df32" class="mt lp iq mo b gy mu mv l mw mx">_BASIC_STATS_TEMPLATE = '''<br/><strong class="mo ir">select</strong><br/>    {{ dim | sqlsafe }}<br/>    , count(*) <strong class="mo ir">as</strong> num_transactions<br/>    , sum(amount) <strong class="mo ir">as</strong> total_amount<br/>    , avg(amount) <strong class="mo ir">as</strong> avg_amount<br/><strong class="mo ir">from</strong><br/>    transactions<br/><strong class="mo ir">group</strong> <strong class="mo ir">by</strong><br/>    {{ dim | sqlsafe }}<br/><strong class="mo ir">order</strong> <strong class="mo ir">by</strong> total_amount <strong class="mo ir">desc</strong><br/>'''</span></pre><p id="a915" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了从JinjaSql模板生成SQL，我们将使用GitHub上的<a class="ae ln" href="https://github.com/sizrailev/life-around-data-code/blob/master/pylad/sql_templates_base.py" rel="noopener ugc nofollow" target="_blank"> sql_tempates_base.py </a>中可用的<code class="fe ml mm mn mo b">apply_sql_template</code>函数，这里介绍的<a class="ae ln" rel="noopener" target="_blank" href="/a-simple-approach-to-templated-sql-queries-in-python-adc4f0dc511">是</a>。为了生成带有<code class="fe ml mm mn mo b">payment_method</code>维度参数的SQL查询，我们按如下方式调用这个函数。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="be17" class="mt lp iq mo b gy mu mv l mw mx">params = {<br/>    'dim': 'payment_method'<br/>}<br/>sql = apply_sql_template(_BASIC_STATS_TEMPLATE, params)</span></pre><p id="bfc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的模板适用于单个维度，但是如果我们有多个维度呢？要生成适用于任意数量维度的通用查询，让我们创建一个函数的框架，该框架将维度列名列表作为参数，并返回SQL。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="7bce" class="mt lp iq mo b gy mu mv l mw mx"><strong class="mo ir">def</strong> get_basic_stats_sql(dimensions):<br/>    '''<br/>    Returns the sql computing the number of transactions,<br/>    as well as the total and the average transaction amounts<br/>    for the provided list of column names as dimensions.<br/>    '''<br/>    # TODO: construct params<br/>    <strong class="mo ir">return</strong> apply_sql_template(_BASIC_STATS_TEMPLATE, params)</span></pre><p id="0c78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本质上，我们希望将列名列表(如<code class="fe ml mm mn mo b">['payment_method']</code>或<code class="fe ml mm mn mo b">['store_id', 'payment_method']</code>)转换成包含列名的单个字符串，以逗号分隔的列表形式。这里我们有一些选项，因为它既可以在Python中完成，也可以在模板中完成。</p><h1 id="1348" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">传递在模板外部生成的字符串</h1><p id="5650" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">第一个选项是在将字符串传递给模板之前生成逗号分隔的字符串。我们可以简单地将列表中的成员连接在一起:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="3c55" class="mt lp iq mo b gy mu mv l mw mx"><strong class="mo ir">def</strong> get_basic_stats_sql(dimensions):<br/>    '''<br/>    Returns the sql computing the number of transactions,<br/>    as well as the total and the average transaction amounts<br/>    for the provided list of column names as dimensions.<br/>    '''<br/>    params = {<br/>       'dim': '\n    , '.join(dimensions)<br/>    }<br/>    <strong class="mo ir">return</strong> apply_sql_template(_BASIC_STATS_TEMPLATE, params)</span></pre><p id="a541" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">碰巧模板参数<code class="fe ml mm mn mo b">dim</code>在正确的位置，所以结果查询是</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="64f7" class="mt lp iq mo b gy mu mv l mw mx">&gt;&gt;&gt; print(get_basic_stats_sql(['store_id', 'payment_method']))<br/><strong class="mo ir">select</strong><br/>    store_id<br/>    , payment_method<br/>    , count(*) <strong class="mo ir">as</strong> num_transactions<br/>    , sum(amount) <strong class="mo ir">as</strong> total_amount<br/>    , avg(amount) <strong class="mo ir">as</strong> avg_amount<br/><strong class="mo ir">from</strong><br/>    transactions<br/><strong class="mo ir">group</strong> <strong class="mo ir">by</strong><br/>    store_id<br/>    , payment_method<br/><strong class="mo ir">order</strong> <strong class="mo ir">by</strong> total_amount <strong class="mo ir">desc</strong></span></pre><p id="01b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以使用</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="a74c" class="mt lp iq mo b gy mu mv l mw mx">dimension_lists = [<br/>    ['user_id'],<br/>    ['store_id'],<br/>    ['payment_method'],<br/>    ['store_id', 'payment_method'],<br/>]</span><span id="bfc0" class="mt lp iq mo b gy my mv l mw mx">dimension_queries = [get_basic_stats_sql(dims) <strong class="mo ir">for</strong> dims <strong class="mo ir">in</strong> dimension_lists]</span></pre><h1 id="cc07" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">模板中的预设变量</h1><p id="b2e9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">除了将预构建的字符串作为模板参数传递之外，还有一种方法是通过在顶部设置一个新变量，将列列表SQL生成移到模板本身中:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="071a" class="mt lp iq mo b gy mu mv l mw mx">_PRESET_VAR_STATS_TEMPLATE = '''<br/>{% <strong class="mo ir">set</strong> dims = '\n    , '.join(dimensions) %}<br/><strong class="mo ir">select</strong><br/>    {{ dims | sqlsafe }}<br/>    , count(*) <strong class="mo ir">as</strong> num_transactions<br/>    , sum(amount) <strong class="mo ir">as</strong> total_amount<br/>    , avg(amount) <strong class="mo ir">as</strong> avg_amount<br/><strong class="mo ir">from</strong><br/>    transactions<br/><strong class="mo ir">group</strong> <strong class="mo ir">by</strong><br/>    {{ dims | sqlsafe }}<br/><strong class="mo ir">order</strong> <strong class="mo ir">by</strong> total_amount <strong class="mo ir">desc</strong><br/>'''</span></pre><p id="358c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个模板比以前的版本可读性更好，因为所有的转换都发生在模板中的一个地方，同时也没有混乱。该功能应更改为</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="d025" class="mt lp iq mo b gy mu mv l mw mx"><strong class="mo ir">def</strong> get_stats_sql(dimensions):<br/>    '''<br/>    Returns the sql computing the number of transactions,<br/>    as well as the total and the average transaction amounts<br/>    for the provided list of column names as dimensions.<br/>    '''<br/>    params = {<br/>        'dimensions': dimensions<br/>    }<br/>    <strong class="mo ir">return</strong> apply_sql_template(_PRESET_VAR_STATS_TEMPLATE, params)</span></pre><h1 id="432a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">模板内的循环</h1><p id="8d7a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们也可以在模板中使用循环来生成列。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="6a87" class="mt lp iq mo b gy mu mv l mw mx">_LOOPS_STATS_TEMPLATE = '''<br/><strong class="mo ir">select</strong><br/>    {{ dimensions[0] | sqlsafe }}\<br/>    {% <strong class="mo ir">for</strong> dim <strong class="mo ir">in</strong> dimensions[1:] %}<br/>    , {{ dim | sqlsafe }}{% <strong class="mo ir">endfor</strong> %}<br/>    , count(*) <strong class="mo ir">as</strong> num_transactions<br/>    , sum(amount) <strong class="mo ir">as</strong> total_amount<br/>    , avg(amount) <strong class="mo ir">as</strong> avg_amount<br/><strong class="mo ir">from</strong><br/>    transactions<br/><strong class="mo ir">group</strong> <strong class="mo ir">by</strong><br/>    {{ dimensions[0] | sqlsafe }}\<br/>    {% <strong class="mo ir">for</strong> dim <strong class="mo ir">in</strong> dimensions[1:] %}<br/>    , {{ dim | sqlsafe }}{% <strong class="mo ir">endfor</strong> %}<br/><strong class="mo ir">order</strong> <strong class="mo ir">by</strong> total_amount <strong class="mo ir">desc</strong><br/>'''</span></pre><p id="b8f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个例子可能不是循环的最佳用途，因为一个预置变量可以很好地完成工作，而没有额外的复杂性。然而，循环是一个强大的构造，特别是当循环中有额外的逻辑时，比如条件(<code class="fe ml mm mn mo b">{% if ... %} — {% endif %}</code>)或嵌套循环。</p><p id="1b50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么上面的模板中发生了什么呢？列表的第一个元素<code class="fe ml mm mn mo b">dimensions[0]</code>是独立的，因为它不需要在列名前面加逗号。如果查询中有一个定义好的第一列，我们就不需要它了，for循环看起来就像</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="1702" class="mt lp iq mo b gy mu mv l mw mx">{% <strong class="mo ir">for</strong> dim <strong class="mo ir">in</strong> dimensions %}<br/>, {{ dim | sqlsafe }}<br/>{% <strong class="mo ir">endfor</strong> %}</span></pre><p id="665c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，for循环结构遍历剩余的元素<code class="fe ml mm mn mo b">dimensions[1:]</code>。同样的代码出现在<code class="fe ml mm mn mo b">group by</code>子句中，这也是不理想的，只是为了显示循环功能。</p><p id="41f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有人可能想知道为什么循环的格式如此奇怪。原因是SQL模板的流元素，比如<code class="fe ml mm mn mo b">{% endfor %}</code>，如果它们出现在单独的行上，就会生成一个空行。为了避免这种情况，在上面的模板中，<code class="fe ml mm mn mo b">{% for ... %}</code>和<code class="fe ml mm mn mo b">{% endfor %}</code>在技术上与前面的代码在同一行上(因此在第一个列名后面有反斜杠<code class="fe ml mm mn mo b">\</code>)。当然，SQL不关心空白，但是阅读SQL的人可能(也应该)关心空白。除了与模板中的格式进行斗争之外，还可以在打印或记录查询之前去掉生成的查询中的空行。为此，一个有用的功能是</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="ecf6" class="mt lp iq mo b gy mu mv l mw mx"><strong class="mo ir">import</strong> os</span><span id="ebd5" class="mt lp iq mo b gy my mv l mw mx"><strong class="mo ir">def</strong> strip_blank_lines(text):<br/>    '''<br/>    Removes blank lines from the text, including those containing only spaces.<br/>    <a class="ae ln" href="https://stackoverflow.com/questions/1140958/whats-a-quick-one-liner-to-remove-empty-lines-from-a-python-string" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/1140958/whats-a-quick-one-liner-to-remove-empty-lines-from-a-python-string</a><br/>    '''<br/>    <strong class="mo ir">return</strong> os.linesep.join([s <strong class="mo ir">for</strong> s <strong class="mo ir">in</strong> text.splitlines() <strong class="mo ir">if</strong> s.strip()])</span></pre><p id="4e02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">格式更好的模板就变成了</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="3a8f" class="mt lp iq mo b gy mu mv l mw mx">_LOOPS_STATS_TEMPLATE = '''<br/><strong class="mo ir">select</strong><br/>    {{ dimensions[0] | sqlsafe }}<br/>    {% <strong class="mo ir">for</strong> dim <strong class="mo ir">in</strong> dimensions[1:] %}<br/>    , {{ dim | sqlsafe }}<br/>    {% <strong class="mo ir">endfor</strong> %}<br/>    , count(*) <strong class="mo ir">as</strong> num_transactions<br/>    , sum(amount) <strong class="mo ir">as</strong> total_amount<br/>    , avg(amount) <strong class="mo ir">as</strong> avg_amount<br/><strong class="mo ir">from</strong><br/>    transactions<br/><strong class="mo ir">group</strong> <strong class="mo ir">by</strong><br/>    {{ dimensions[0] | sqlsafe }}<br/>    {% <strong class="mo ir">for</strong> dim <strong class="mo ir">in</strong> dimensions[1:] %}<br/>    , {{ dim | sqlsafe }}<br/>    {% <strong class="mo ir">endfor</strong> %}<br/><strong class="mo ir">order</strong> <strong class="mo ir">by</strong> total_amount <strong class="mo ir">desc</strong><br/>'''</span></pre><p id="c199" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">打印查询的调用是:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="c358" class="mt lp iq mo b gy mu mv l mw mx">print(strip_blank_lines(get_loops_stats_sql(['store_id', 'payment_method'])))</span></pre><p id="2978" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，所有的SQL模板都使用维度列表来产生完全相同的查询。</p><h1 id="759a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">在字典上循环的自定义维度</h1><p id="6926" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在上面的循环例子中，我们看到了如何遍历一个列表。也可以迭代一个字典。这很方便，例如，当我们想要别名或转换形成维度的部分或全部列时。假设我们想将借记卡和信用卡合并为一个值，并将其与现金交易进行比较。我们可以通过首先创建一个字典来定义<code class="fe ml mm mn mo b">payment_method </code>的转换并保持<code class="fe ml mm mn mo b">store_id</code>不变来实现。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="148a" class="mt lp iq mo b gy mu mv l mw mx">custom_dimensions = {<br/>    'store_id': 'store_id',<br/>    'card_or_cash': "case when payment_method = 'cash' then 'cash' else 'card' end",<br/>}</span></pre><p id="6624" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，<code class="fe ml mm mn mo b">credit</code>和<code class="fe ml mm mn mo b">debit</code>值都被替换为<code class="fe ml mm mn mo b">card</code>。然后，该模板可能如下所示:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="5c9f" class="mt lp iq mo b gy mu mv l mw mx">_CUSTOM_STATS_TEMPLATE = '''<br/>{% <strong class="mo ir">set</strong> dims = '\n    , '.join(dimensions.keys()) %}<br/><strong class="mo ir">select</strong><br/>    sum(amount) <strong class="mo ir">as</strong> total_amount<br/>    {% <strong class="mo ir">for</strong> dim, def <strong class="mo ir">in</strong> dimensions.items() %}<br/>    , {{ def | sqlsafe }} <strong class="mo ir">as</strong> {{ dim | sqlsafe }}<br/>    {% endfor %}<br/>    , count(*) <strong class="mo ir">as</strong> num_transactions<br/>    , avg(amount) <strong class="mo ir">as</strong> avg_amount<br/><strong class="mo ir">from</strong><br/>    transactions<br/><strong class="mo ir">group</strong> <strong class="mo ir">by</strong><br/>    {{ dims | sqlsafe }}<br/><strong class="mo ir">order</strong> <strong class="mo ir">by</strong> total_amount <strong class="mo ir">desc</strong><br/>'''</span></pre><p id="29da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我将<code class="fe ml mm mn mo b">total_amount</code>作为第一列，只是为了简化这个例子，避免单独处理循环中的第一个元素。另外，请注意,<code class="fe ml mm mn mo b">group by</code>子句使用了一个预置变量，并且不同于select查询中的代码，因为它只列出了生成的列的名称。产生的SQL查询是:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="2c30" class="mt lp iq mo b gy mu mv l mw mx">&gt;&gt;&gt; print(strip_blank_lines(<br/>...     apply_sql_template(template=_CUSTOM_STATS_TEMPLATE,<br/>...                        parameters={'dimensions': custom_dimensions})))</span><span id="660d" class="mt lp iq mo b gy my mv l mw mx"><strong class="mo ir">select</strong><br/>    sum(amount) <strong class="mo ir">as</strong> total_amount<br/>    , store_id <strong class="mo ir">as</strong> store_id<br/>    , <strong class="mo ir">case</strong> <strong class="mo ir">when</strong> payment_method = 'cash' <strong class="mo ir">then</strong> 'cash' <strong class="mo ir">else</strong> 'card' <strong class="mo ir">end</strong> <strong class="mo ir">as</strong> card_or_cash<br/>    , count(*) <strong class="mo ir">as</strong> num_transactions<br/>    , avg(amount) <strong class="mo ir">as</strong> avg_amount<br/><strong class="mo ir">from</strong><br/>    transactions<br/><strong class="mo ir">group</strong> <strong class="mo ir">by</strong><br/>    store_id<br/>    , card_or_cash<br/><strong class="mo ir">order</strong> <strong class="mo ir">by</strong> total_amount <strong class="mo ir">desc</strong></span></pre><h1 id="2b27" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">从JinjaSql模板中调用定制Python函数</h1><p id="15f9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">如果我们想用Python函数生成一部分代码呢？Jinja2允许用户注册自定义函数和其他包中的函数，以便在SQL模板中使用。让我们从定义一个函数开始，该函数生成我们插入到SQL中的字符串，用于转换定制维度。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="3699" class="mt lp iq mo b gy mu mv l mw mx"><strong class="mo ir">def</strong> transform_dimensions(dimensions: dict) -&gt; str:<br/>    '''<br/>    Generate SQL for aliasing or transforming the dimension columns.<br/>    '''<br/>    <strong class="mo ir">return</strong> '\n    , '.join([<br/>        '{val} as {key}'.format(val=val, key=key)<br/>        <strong class="mo ir">for</strong> key, val <strong class="mo ir">in</strong> dimensions.items()<br/>    ])</span></pre><p id="dbe0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个函数的输出是我们期望出现在<code class="fe ml mm mn mo b">select</code>子句中的内容:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="2131" class="mt lp iq mo b gy mu mv l mw mx">&gt;&gt;&gt; print(transform_dimensions(custom_dimensions))<br/>store_id <strong class="mo ir">as</strong> store_id<br/> , <strong class="mo ir">case</strong> <strong class="mo ir">when</strong> payment_method = 'cash' <strong class="mo ir">then</strong> 'cash' <strong class="mo ir">else</strong> 'card' <strong class="mo ir">end</strong> <strong class="mo ir">as</strong> card_or_cash</span></pre><p id="1a36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们需要用Jinja2注册这个函数。为此，我们将修改前面博客中的<a class="ae ln" href="http://www.lifearounddata.com/templated-sql-queries-in-python/" rel="noopener ugc nofollow" target="_blank">函数，如下所示。</a></p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="1c27" class="mt lp iq mo b gy mu mv l mw mx"><strong class="mo ir">from</strong> jinjasql <strong class="mo ir">import</strong> JinjaSql</span><span id="12ee" class="mt lp iq mo b gy my mv l mw mx"><strong class="mo ir">def</strong> apply_sql_template(template, parameters, func_list=None):<br/>    '''<br/>    Apply a JinjaSql template (string) substituting parameters (dict) and return<br/>    the final SQL. Use the func_list to pass any functions called from the template.<br/>    '''<br/>    j = JinjaSql(param_style='pyformat')<br/>    <strong class="mo ir">if</strong> func_list:<br/>        <strong class="mo ir">for</strong> func <strong class="mo ir">in</strong> func_list:<br/>        j.env.globals[func.__name__] = func<br/>    query, bind_params = j.prepare_query(template, parameters)<br/>    <strong class="mo ir">return</strong> get_sql_from_template(query, bind_params)</span></pre><p id="f47e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个版本有一个额外的可选参数<code class="fe ml mm mn mo b">func_list</code>，它需要是函数的一个<code class="fe ml mm mn mo b">list</code>。</p><p id="b336" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们改变模板来利用<code class="fe ml mm mn mo b">transform_dimensions</code>功能。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="14f0" class="mt lp iq mo b gy mu mv l mw mx">_FUNCTION_STATS_TEMPLATE = '''<br/>{% <strong class="mo ir">set</strong> dims = ‘\n , ‘.join(dimensions.keys()) %}<br/><strong class="mo ir">select</strong><br/>    {{ transform_dimensions(dimensions) | sqlsafe }}<br/>    , sum(amount) <strong class="mo ir">as</strong> total_amount<br/>    , count(*) <strong class="mo ir">as</strong> num_transactions<br/>    , avg(amount) <strong class="mo ir">as</strong> avg_amount<br/><strong class="mo ir">from</strong><br/>    transactions<br/><strong class="mo ir">group</strong> <strong class="mo ir">by</strong><br/>    {{ dims | sqlsafe }}<br/><strong class="mo ir">order</strong> <strong class="mo ir">by</strong> total_amount <strong class="mo ir">desc</strong><br/>'''</span></pre><p id="629a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们也不需要担心第一列没有逗号。下面的调用产生一个类似于上一节的SQL查询。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="a902" class="mt lp iq mo b gy mu mv l mw mx">&gt;&gt;&gt; print(strip_blank_lines(<br/>...     apply_sql_template(template=_FUNCTION_STATS_TEMPLATE,<br/>...                        parameters={‘dimensions’: custom_dimensions},<br/>...                        func_list=[transform_dimensions])))</span><span id="2539" class="mt lp iq mo b gy my mv l mw mx"><strong class="mo ir">select</strong><br/>    store_id <strong class="mo ir">as</strong> store_id<br/>    , <strong class="mo ir">case</strong> <strong class="mo ir">when</strong> payment_method = 'cash' <strong class="mo ir">then</strong> 'cash' <strong class="mo ir">else</strong> 'card' <strong class="mo ir">end</strong> <strong class="mo ir">as</strong> card_or_cash<br/>    , sum(amount) <strong class="mo ir">as</strong> total_amount<br/>    , count(*) <strong class="mo ir">as</strong> num_transactions<br/>    , avg(amount) <strong class="mo ir">as</strong> avg_amount<br/><strong class="mo ir">from</strong><br/>    transactions<br/><strong class="mo ir">group</strong> <strong class="mo ir">by</strong><br/>    store_id<br/>    , card_or_cash<br/><strong class="mo ir">order</strong> <strong class="mo ir">by</strong> total_amount <strong class="mo ir">desc</strong></span></pre><p id="773e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意我们如何将<code class="fe ml mm mn mo b">transform_dimensions</code>作为一个列表<code class="fe ml mm mn mo b">[transform_dimensions]</code>传递给<code class="fe ml mm mn mo b">apply_sql_template</code>。可以将多个函数作为函数列表传递给SQL模板，例如<code class="fe ml mm mn mo b">[func1, func2]</code>。</p><h1 id="6ad9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="a664" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">本教程详细介绍了JinjaSql的<a class="ae ln" rel="noopener" target="_blank" href="/a-simple-approach-to-templated-sql-queries-in-python-adc4f0dc511">基本用法</a>。它演示了在JinjaSql模板中使用预置变量、列表和字典循环以及定制Python函数来生成高级Sql代码。特别是在<code class="fe ml mm mn mo b">apply_sql_template</code>函数中添加了自定义函数注册，使得模板更加强大和通用。参数化SQL查询对于自动生成报告和减少需要维护的SQL代码量仍然是不可或缺的。一个额外的好处是，使用可重用的SQL代码片段，使用标准的Python单元测试技术来验证生成的SQL是正确的变得更加容易。</p><p id="13a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本帖中的<a class="ae ln" href="https://github.com/sizrailev/life-around-data-code/blob/master/pylad/advanced_sql_templates.py" rel="noopener ugc nofollow" target="_blank">代码是在</a><a class="ae ln" href="https://opensource.org/licenses/MIT" rel="noopener ugc nofollow" target="_blank"> MIT许可</a>下授权的。这篇文章最初出现在<a class="ae ln" href="http://www.lifearounddata.com/advanced-sql-templates-in-python-with-jinjasql/" rel="noopener ugc nofollow" target="_blank"> Life Around Data </a>博客上。</p><p id="cb0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">谢尔盖·伊兹拉列夫拍摄的照片</p></div></div>    
</body>
</html>