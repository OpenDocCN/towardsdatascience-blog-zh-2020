<html>
<head>
<title>Introduction to Streaming Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">流式算法简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-streaming-algorithms-b71808de6d29?source=collection_archive---------12-----------------------#2020-01-29">https://towardsdatascience.com/introduction-to-streaming-algorithms-b71808de6d29?source=collection_archive---------12-----------------------#2020-01-29</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="2f16" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated"><strong class="ak">用Python解释和实现的各种算法</strong></h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/5b9f76015a5a2176f05998b1789a1644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*92HlYLk5N-nu6GgX"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">乔恩·弗洛布兰特在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="478b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在过去，编程意味着永远记住内存限制。虽然在1990年拥有32mb内存是一笔财富，但现在有时甚至在一台家用电脑上拥有32gb<strong class="lc iv">内存都不够。随着硬盘、RAM和GPU内存的增长，可用的数据量也在增长。因此，拥有一套内存高效算法仍然是很重要的。</strong></p><h1 id="94b2" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">两个小例子</h1><p id="608d" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">一个典型的例子是互联网交换机，它监控不同的IP互相发送数据包。交换机的一个常见任务是找出<em class="mt">最重要的</em>，即一对两个IP地址，与其他对相比，IP₁在这些地址上与IP₂的通信非常频繁。这很有趣，因为这可能是一个拒绝服务攻击的指示器。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mu"><img src="../Images/94faaf49f31eba86fef97fcfc5400b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zWntPoHVm5y_Tz9R"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@webaroo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Webaroo.com.au</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="455f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这听起来是个简单的问题，对吗？只需实现从IP对(IP₁、IP₂)到从IP₁到IP₂.的通信数量的映射在Python中，这可以是字典、计数器类的实例或邻接矩阵。然后就可以在数据结构中搜索最高的<em class="mt"> k </em>计数，输出对应的IP地址。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj mv"><img src="../Images/757b61badcf9227a81106134a9277924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*ZThW8IcUdBjIF8ZAmmvDFA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">42.42.42.42经常满腹狐疑地和182.162.77.12交谈，154.78.122.56也经常满腹狐疑地和43.111.23.122交谈。这也许值得研究一下。</p></figure><p id="6773" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是现在想想这些数据结构的大小。一个更大的交换机可以接收来自数百万个IP(T21)的请求，并将它们路由到尽可能多的其他IP。</p><blockquote class="mw"><p id="ad9e" class="mx my iu bd mz na nb nc nd ne nf lv dk translated">这意味着我们最终可能会拥有数百万乘以数百万的IP对。</p></blockquote><p id="bad7" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">这一点，再加上交换机通常较低的存储容量，引发了许多问题。这种方法是不可能的:我们需要一种比存储所有内容占用更少内存的算法。一种方法是使用<a class="ae kz" href="https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch" rel="noopener ugc nofollow" target="_blank">计数分钟草图</a>。你也可以在YouTube上搜索“重量级人物”，如果你感兴趣，可以找到一些很好的解释和例子。</p></div><div class="ab cl nl nm hy nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="in io ip iq ir"><p id="8d7e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我听到你们中的一些人说:</p><blockquote class="mw"><p id="f421" class="mx my iu bd mz na nb nc nd ne nf lv dk translated">我为什么要关心网络的东西？我是一个机器学习的家伙，咄！—你</p></blockquote><p id="7428" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">嗯，还有一个来自机器学习世界的著名例子:<strong class="lc iv">梯度下降</strong>！</p><p id="84b2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们处理足够小的数据集，它可以完全适合(GPU) RAM，我们可以使用批量梯度下降，即一次将完整的数据放入内存并进行处理。然而，大多数时候我们的工作记忆太小，使得有必要使用<em class="mt">随机梯度下降</em>或<em class="mt">小批量梯度下降</em>，它们是所谓的<em class="mt">流算法</em>的例子。另一个例子是Hoeffding树算法，我在这里描述了<a class="ae kz" rel="noopener" target="_blank" href="/introducing-hoeffdings-inequality-for-creating-storage-less-decision-trees-b5135e65e51e">。</a></p><p id="5b77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我想向您展示几个流算法的例子，包括您可以使用的Python实现！除了让你意识到这个问题，我已经做到了。；)</p><h1 id="bae8" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated"><strong class="ak">直觉</strong></h1><p id="e444" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">对于流算法，我指的是能够处理非常大的，甚至可能是<em class="mt">无界的</em>数据集，并且仅使用恒定数量的RAM来计算一些期望的输出的算法。</p><p id="6deb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果数据集是无界的，我们称之为<em class="mt">数据流。</em>在这种情况下，如果我们在某个位置<em class="mt"> n </em>停止处理数据流，我们期望我们的算法有一个<strong class="lc iv">解，对应于到这一点</strong>看到的数据。</p><p id="6a7b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在下文中，假设我们的硬盘上有一个巨大的数据集，我们想要处理它而不需要立刻将它加载到我们的RAM中(因为我们不能),或者有一个输出数据流的源，例如Twitter上的传入tweets。两种情况都以同样的方式处理。</p><p id="6cac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我将用大型数据集的语言来表述即将出现的例子，因为我们知道它们是有限的，我不必一直提到我们停止读取数据流。</p><p id="4787" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们进一步假设我们可以准确地传递数据<strong class="lc iv">一次</strong>。</p><h1 id="dcda" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated"><strong class="ak">一个平缓的开始</strong></h1><p id="e452" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">让我们通过两个简单的例子来熟悉如何设计流算法。</p><h2 id="bc91" class="ns lx iu bd ly nt nu dn mc nv nw dp mg lj nx ny mi ln nz oa mk lr ob oc mm od bi translated">寻找最小值</h2><p id="6a23" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">假设有一个非常大的数字列表，对你的内存来说太大了。你想找出这个列表的最小值。在Python中，经典的解决方法是这样的:</p><pre class="kk kl km kn gu oe of og bn oh oi bi"><span id="a574" class="oj lx iu of b be ok ol l om on">print(min(my_list))</span></pre><p id="acb3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但这是假设<code class="fe oo op oq of b">my_list</code>已经在RAM中。那么，我们如何用另一种方式来解决这个问题呢？也许你已经找到了解决方案:</p><blockquote class="mw"><p id="0cb2" class="mx my iu bd mz na nb nc nd ne nf lv dk translated">只要一个数字接一个数字地读数据集，只要发现一个更小的数字，就更新最小值。</p></blockquote><p id="6aaf" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">更准确地说:读取第一个元素，并声明它是最小值。然后读取第二个元素，如果它小于当前最小值(第一个元素)，就声明它是最小值。否则，什么都不做。</p><p id="11ed" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后读取第三个元素，如果它小于当前最小值，就声明它是最小值。否则，什么都不做。</p><p id="5c77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后读取第四个元素，如果它小于当前最小值，则声明它为最小值。否则，什么都不做。</p><p id="2ea4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">好吧，我停下来，你知道这是怎么回事。这基本上行得通，因为</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj or"><img src="../Images/02b0c531e050cd28c6dcfa9ff24c95f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lcxBq9PE_nX791mRs-tXrQ.png"/></div></div></figure><p id="8b74" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用这个公式，你可以很容易地通过<a class="ae kz" href="https://en.wikipedia.org/wiki/Mathematical_induction" rel="noopener ugc nofollow" target="_blank">归纳</a>证明算法是正确的。读取第一个元素后，结果是正确的，因为<em class="mt"> a </em> ₁ &lt; ∞，因此min(<em class="mt">a</em>₁)=<em class="mt">a</em>₁.归纳步骤正是公式(想想吧！).但是说够了，让我们回到正轨。</p></div><div class="ab cl nl nm hy nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="in io ip iq ir"><p id="524e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Python中，我们可以使用下面这个非常简单的类来解决它:</p><pre class="kk kl km kn gu oe of og bn oh oi bi"><span id="aabf" class="oj lx iu of b be ok ol l om on">from math import inf<br/><br/>class StreamingMinimum:<br/>    def __init__(self):<br/>        self.result = inf  # Immediately replaced by the 1st element<br/><br/>    def update(self, element):<br/>        self.result = min(self.result, element)</span></pre><p id="c780" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过以下方式使用它</p><pre class="kk kl km kn gu oe of og bn oh oi bi"><span id="85f9" class="oj lx iu of b be ok ol l om on">import numpy as np<br/><br/>stream = iter(np.random.randn(10000))  # Simulate a stream<br/>s = StreamingMinimum()<br/><br/>for element in stream:<br/>    s.update(element)<br/><br/>print(s.result)</span></pre><p id="cd10" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">很简单，对吧？让我们增加一点难度。</p><h2 id="0ba2" class="ns lx iu bd ly nt nu dn mc nv nw dp mg lj nx ny mi ln nz oa mk lr ob oc mm od bi translated">寻找平均值</h2><p id="1f07" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">同样的设置:大数据集，但是现在我们要找的是均值而不是最小值。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj os"><img src="../Images/41b22f96914c2ed73206e566530c96ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*dWT5RecVbGG_96R_4gJANg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">当然，你知道公式！</p></figure><p id="f91d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以，我们现在的问题如下:</p><blockquote class="mw"><p id="ace8" class="mx my iu bd mz na nb nc nd ne nf lv dk translated">当我们已经有了前<em class="ot"> n </em>个元素的均值时，如何计算<em class="ot"> n+1 </em>个元素的均值？</p></blockquote><p id="8dc6" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">一个简单的解决方案是使用下面的标识，您可能在稍加思考后就会想到:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ou"><img src="../Images/9cc90e37c29f57dc3c964dd64ba237ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1MvVbNYifOoVbkbhKimUtA.png"/></div></div></figure><p id="9080" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以看到，我们不仅必须存储旧的平均值，而且还必须跟踪元素的数量<em class="mt"> n，</em>，因为这在公式<em class="mt">中是需要的。</em>在计算最小值的情况下，这是没有必要的。</p><p id="3ab7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个类是这样的:</p><pre class="kk kl km kn gu oe of og bn oh oi bi"><span id="689c" class="oj lx iu of b be ok ol l om on">class StreamingMean:<br/>    def __init__(self):<br/>        self.result = 0<br/>        self.n = 0<br/><br/>    def update(self, element):<br/>        self.result = (self.result * self.n + element) / (self.n+1)<br/>        self.n += 1</span></pre><p id="1a29" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以像以前一样再次测试这段代码。用<code class="fe oo op oq of b">StreamingMean</code>类代替<code class="fe oo op oq of b">StreamingMinimum</code>就行了。</p><p id="73b6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">健全性检查:结果大约为0，这也是我们对标准正态分布随机变量的预期。同样:检查这个算法的正确性是一个简单的归纳练习。</p></div><div class="ab cl nl nm hy nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="in io ip iq ir"><p id="41ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">既然你现在知道它是如何工作的，让我们来看一个更有趣的算法。</p><h1 id="a691" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">储层取样</h1><p id="b8db" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">假设您有一个大型数据集，并且想要对一个对象进行统一采样。你怎么能这样做？好吧，如果你知道数据集的大小<em class="mt"> n </em>，你可以在1和<em class="mt"> n之间均匀地抽取一个随机数<em class="mt"> k </em>，</em>扫描数据集，取第<em class="mt"> k </em>第<em class="mt">个元素。</em></p><p id="964a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是现在想象一下，你有一个数据流，你事先不知道有多少元素进来，也不知道什么时候想停止读取数据流。现在变得越来越困难，因为你不知道从哪个范围抽取随机指数。但是这个问题也有一个简单的解决方法，叫做<a class="ae kz" href="https://en.wikipedia.org/wiki/Reservoir_sampling" rel="noopener ugc nofollow" target="_blank">油藏取样</a>。</p><blockquote class="mw"><p id="609d" class="mx my iu bd mz na nb nc nd ne nf lv dk translated">这个想法是这样的:你有一个单独的盒子(容器)来存放元素。扫描数据流时，以一定概率用当前元素替换框内内容。</p></blockquote><figure class="ow ox oy oz pa ko gi gj paragraph-image"><div class="gi gj ov"><img src="../Images/25fd82a46194153ff16a62cc2f75d51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*iGwuIsjKFZN3vGu8Fmc23A.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">典型的水库。来源:超级马里奥世界</p></figure><p id="ed91" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我把这个想法留给你一个人，也许过一段时间你就能算出概率。跳过<em class="mt"> n个</em>元素后的目标是能够以1/ <em class="mt"> n个</em>的概率将每个元素放入盒子中。</p><p id="89e4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在最简单的情况下，从某个恒定概率<em class="mt"> p </em>开始。但是，举例来说，第一个元素出现在盒子里的概率是(1- <em class="mt"> p </em> ) <em class="mt"> ⁿ，</em>对于任何一个<em class="mt"> p </em> &lt; 1来说都是指数级的小，而不是我们所寻找的。</p><p id="8341" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">解决这个问题的一个办法是:我们扫描序列的时间越长，就必须降低交换的概率。什么是简单衰变率？1/ <em class="mt"> n </em>怎么样？让我们试试。</p><p id="f023" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">起初，盒子是空的。我们扫描第一个元素，用第一个元素填充盒子(概率1/1=1)。到目前为止一切顺利。</p><p id="77e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们来看第二个元素。我们用1/2的概率替换盒子里的内容。这一步之后，第一个元素在盒子里的概率是1/1 * 1/2 = 1/2，第二个元素在盒子里面的概率是1/2。完美！我们再做一个。</p><p id="84f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">到达第三个元素，它以1/3的概率替换盒子内的元素。第一个元素还在盒子里的概率是多少？就是它熬过了第一个<strong class="lc iv">(好吧，这个很容易)</strong> <strong class="lc iv">第二个第三个互换机会</strong>的概率:1/1 * 1/2 * 2/3 = 1/3。看起来不错！第二个元素呢？它必须在<strong class="lc iv">第二次和第三次互换机会</strong>中存活下来，这种机会发生的概率为1/2 * 2/3 = 1/3。好像管用！事实上，它确实如此，正如一个人可以用… <em class="mt">归纳</em>看到的那样！</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pb"><img src="../Images/87af28b968e313c3ba697af467f82625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aKNfFphkeqkEmivHA3FkDw.png"/></div></div></figure><p id="b1db" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">代码如下:</p><pre class="kk kl km kn gu oe of og bn oh oi bi"><span id="6fd8" class="oj lx iu of b be ok ol l om on">from random import random<br/><br/>class ReservoirSampler:<br/>    def __init__(self):<br/>        self.result = None<br/>        self.n = 0<br/><br/>    def update(self, element):<br/>        self.n += 1<br/>        if random() &lt; 1 / self.n:  # Satisfied with prob. 1/n.<br/>            self.result = element</span></pre><p id="ee23" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以快速检查一下它是否有效。让我们从大小为20的数据集重复采样。我们预计在大约5%的情况下抽取每个元素。</p><pre class="kk kl km kn gu oe of og bn oh oi bi"><span id="da7f" class="oj lx iu of b be ok ol l om on">results = []<br/><br/>for _ in range(1000000):<br/>    r = ReservoirSampler()<br/>    for s in range(20):<br/>        r.update(s)<br/><br/>    results.append(r.result)</span></pre><p id="a77e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">可视化<code class="fe oo op oq of b">results</code>给出了以下内容:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pc"><img src="../Images/72f3b877671832cc2c9907efad61df36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DL4sIpfsuXlbIMrdX_l0CA.png"/></div></div></figure><p id="af17" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以看到，在所有试验中，每种元素都被取样了大约5%。完美！</p><h1 id="ee43" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">结论</h1><p id="47a0" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">我们已经看到，即使在今天，内存高效的算法也是必要的。处理非常大的数据集的聪明技巧仍然是相关的，幸运的是，聪明人已经在这个领域投入了很多努力。</p><p id="3bea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我向您展示了三个非常简单的算法示例，它们应该可以教您如何解决内存极度受限的问题。</p><p id="78f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下一次，如果你的数据再一次不适合你的内存，考虑一下是否有办法以流的方式处理它！</p></div><div class="ab cl nl nm hy nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="in io ip iq ir"><p id="66ec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望你今天学到了新的、有趣的、有用的东西。感谢阅读！</p><p id="427f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">作为最后一点，如果你</strong></p><ol class=""><li id="1ffb" class="pd pe iu lc b ld le lg lh lj pf ln pg lr ph lv pi pj pk pl bi translated"><strong class="lc iv">想支持我多写点机器学习和</strong></li><li id="8130" class="pd pe iu lc b ld pm lg pn lj po ln pp lr pq lv pi pj pk pl bi translated"><strong class="lc iv">无论如何都计划获得一个中等订阅，</strong></li></ol><p id="8789" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">为什么不做</strong> <a class="ae kz" href="https://dr-robert-kuebler.medium.com/membership" rel="noopener"> <strong class="lc iv">通过这个环节</strong> </a> <strong class="lc iv">？这将对我帮助很大！😊</strong></p><p id="6424" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="mt">说白了，给你的价格不变，但大约一半的订阅费直接归我。</em></p><p id="52d1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">非常感谢，如果你考虑支持我的话！</p><blockquote class="mw"><p id="1e25" class="mx my iu bd mz na nb nc nd ne nf lv dk translated"><em class="ot">如有问题，在</em><a class="ae kz" href="https://www.linkedin.com/in/dr-robert-k%C3%BCbler-983859150/" rel="noopener ugc nofollow" target="_blank"><em class="ot">LinkedIn</em></a><em class="ot">上写我！</em></p></blockquote></div></div>    
</body>
</html>