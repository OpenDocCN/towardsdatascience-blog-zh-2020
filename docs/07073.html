<html>
<head>
<title>Understand __slots__ in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解 Python 中的 __slots__。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understand-slots-in-python-e3081ef5196d?source=collection_archive---------4-----------------------#2020-05-31">https://towardsdatascience.com/understand-slots-in-python-e3081ef5196d?source=collection_archive---------4-----------------------#2020-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6b62" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">改进 Python 代码的简单方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d41fe34e10f2d585d22476b4680e7980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wyjoB9uhK2SqCcBJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@ms88" rel="noopener ugc nofollow" target="_blank"> m </a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="8b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">当我们从一个类中创建一个对象时，该对象的属性将被存储在一个名为<code class="fe me mf mg mh b">__dict__</code>的字典中。我们使用这个字典来获取和设置属性。它允许我们在创建对象后动态地创建新的属性。</p><p id="64e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个简单的类<code class="fe me mf mg mh b">Article</code>，它最初有两个属性<code class="fe me mf mg mh b">date</code>和<code class="fe me mf mg mh b">writer</code>。如果我们打印出对象的<code class="fe me mf mg mh b">__dict__</code>，我们将得到每个属性的键和值。同时，我们也打印出以后需要的类的<code class="fe me mf mg mh b">__dict__</code>。之后，一个新的属性<code class="fe me mf mg mh b">reviewer</code>被添加到对象中，我们可以在更新后的<code class="fe me mf mg mh b">__dict__</code>中看到它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/0882068a8787e83ccf6ad9eb00bcd3a9" rel="noopener ugc nofollow" target="_blank"> without_slots.py </a></p></figure><h2 id="2283" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">够好吗？</h2><p id="bbe7" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在我们找到更好的解决方案之前，我们不能说这不好。Dictionary 在 Python 中非常强大，但是在创建成千上万的对象时，我们可能会面临一些问题:</p><ol class=""><li id="57d8" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">字典需要记忆。数百万个对象肯定会耗尽内存。</li><li id="8da1" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">字典实际上是一个哈希表。hash map <em class="nw"> </em>中<em class="nw"> get/set </em>的<a class="ae ky" href="https://wiki.python.org/moin/TimeComplexity" rel="noopener ugc nofollow" target="_blank">时间复杂度</a>最坏情况为 O(n)。</li></ol><h2 id="9bf9" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">__ 插槽 _ _ 解决方案</h2><blockquote class="nx ny nz"><p id="a67b" class="kz la nw lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated">来自<a class="ae ky" href="https://docs.python.org/3.8/reference/datamodel.html#object.__slots__" rel="noopener ugc nofollow" target="_blank"> Python 文档</a> : __slots__ 允许我们显式<strong class="lb iu">声明数据成员</strong>(如属性)和<strong class="lb iu">拒绝 __dict__ </strong>和 __weakref__(除非在 __slots__ 中显式声明或在父代中可用。)</p></blockquote><p id="fa49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这和我提到的问题有什么关系呢？</p><p id="c668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个类<code class="fe me mf mg mh b">ArticleWithSlots</code>。两个类之间的唯一区别是额外的字段<code class="fe me mf mg mh b">__slots__</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/c2bdcea4352e462a0bff3b4dc5369ac7" rel="noopener ugc nofollow" target="_blank"> with-slots.py </a></p></figure><p id="761d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">__slots__</code>是在<strong class="lb iu">类级别</strong>上创建的，这意味着如果我们打印<code class="fe me mf mg mh b">ArticleWithSlots.__dict__</code>，我们应该能够看到它。此外，我们还看到了类级别上的两个额外属性，<code class="fe me mf mg mh b">date: &lt;member 'date' ..&gt;</code>和<code class="fe me mf mg mh b">writer: &lt;member 'writer' ..&gt;</code>，它们属于类<a class="ae ky" href="https://docs.python.org/3/howto/descriptor.html#id1" rel="noopener ugc nofollow" target="_blank"> member_descriptor </a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/7c84804c435261e05447d5608d7a8c44" rel="noopener ugc nofollow" target="_blank"> with_slots_dict.py </a></p></figure><p id="b18f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">Python 中的描述符是什么？</strong></p><p id="89d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在讨论描述符之前，我们应该理解 Python 中访问属性的默认行为。当你执行<code class="fe me mf mg mh b">article.writer</code>时，Python 将调用方法<code class="fe me mf mg mh b">__getattribute__()</code>，在<code class="fe me mf mg mh b">__dict__</code>、<code class="fe me mf mg mh b">self.__dict__["writer"]</code>中进行查找并返回值。</p><p id="78dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如果查找键是具有描述符方法之一的对象，那么默认行为将被描述符方法覆盖。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/ef823991c115a13e25cba5b05055c227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H41ppXUYOBfaMDwEjGEeaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ArticleWithSlots 类的屏幕截图</p></figure><p id="eb9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">描述符方法包括<code class="fe me mf mg mh b">__get__()</code>、<code class="fe me mf mg mh b">__set__()</code>和<code class="fe me mf mg mh b">__delete__()</code>。描述符只是一个 Python 对象，它实现了至少一个描述符方法。</p><p id="57ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">__slots__</code>通过描述符方法的实现，自动为每个属性创建一个描述符。你可以在截图中找到它们。意味着对象将使用<code class="fe me mf mg mh b">__get__()</code>、<code class="fe me mf mg mh b">__set__()</code>和<code class="fe me mf mg mh b">__delete__()</code>与属性交互，而不是默认行为。</p><p id="ed0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据<a class="ae ky" href="http://python-history.blogspot.com/2010/06/inside-story-on-new-style-classes.html" rel="noopener ugc nofollow" target="_blank">吉多·范·罗苏姆</a>，<code class="fe me mf mg mh b">__get__()</code>，<code class="fe me mf mg mh b">__set__()</code>的实现用数组代替字典，完全用 C 实现，效率高。</p><h2 id="4456" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">__slots__ 具有更快的属性访问速度</h2><p id="fa39" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在下面的代码中，我比较了<code class="fe me mf mg mh b">Article</code>和<code class="fe me mf mg mh b">ArticleWithSlots</code>的对象创建时间和属性访问时间。<code class="fe me mf mg mh b">__slots__</code>快 10%左右。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/301d118202f34cb678a6836bb92f338a" rel="noopener ugc nofollow" target="_blank">比较时间. py </a></p></figure><p id="1b72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">__slots__</code>有稍微好一点的性能是因为<strong class="lb iu"> </strong> <a class="ae ky" href="https://wiki.python.org/moin/TimeComplexity" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">的时间复杂度</strong></a><strong class="lb iu"><em class="nw">的 get/set </em>操作<em class="nw"> </em>在最坏的情况下比一个链表中的字典要快。由于<code class="fe me mf mg mh b">O(n)</code>只发生在最坏的情况下，我们大多数时候不会注意到差异，尤其是当你有少量数据的时候。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/88bb9e12bb151c2952cf8f8bdb1698d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*wMus2zFzl8WlAVIbIIdTVg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据来源:<a class="ae ky" href="https://wiki.python.org/moin/TimeComplexity" rel="noopener ugc nofollow" target="_blank">wiki.python.org</a></p></figure><h2 id="8142" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">__slots__ 减少了 RAM 的使用</h2><p id="649b" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">由于属性可以作为数据成员(比如属性)来访问，所以没有必要将它们存储在字典<code class="fe me mf mg mh b">__dict__</code>中。其实，<code class="fe me mf mg mh b">__slots__</code>根本就否定了<code class="fe me mf mg mh b">__dict__</code>的创作。所以如果打印<code class="fe me mf mg mh b">article_slots.__dict__</code>，会得到 AttributeError 异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="028a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种行为减少了对象的 RAM 使用。我将使用<a class="ae ky" href="https://pypi.org/project/Pympler/" rel="noopener ugc nofollow" target="_blank"> pympler </a>比较<code class="fe me mf mg mh b">article</code>和<code class="fe me mf mg mh b">article_slots</code>的大小。不使用<code class="fe me mf mg mh b">sys.getsizeof()</code>的原因是<code class="fe me mf mg mh b">getsizeof()</code>不包括被引用对象的大小。但是，<code class="fe me mf mg mh b">__dict__</code>是一个被引用的对象，在<code class="fe me mf mg mh b">getsizeof()</code>中将被忽略。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/ecdb5a0bec2f3bb094f45c6c851458c4" rel="noopener ugc nofollow" target="_blank"> getsizeof vs pympler </a></p></figure><p id="2819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原来<code class="fe me mf mg mh b">article_slots</code> <strong class="lb iu">比</strong>节省 50%以上的内存。哇，如此惊人的进步！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/d5cd7231b77073e0932feb6f1b5fe840" rel="noopener ugc nofollow" target="_blank"> ram 使用比较. py </a></p></figure><p id="6043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这么好的性能是因为<code class="fe me mf mg mh b">article_slots</code>没有<code class="fe me mf mg mh b">__dict__</code>属性，实际上节省了很多内存。</p><h2 id="3724" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">什么时候使用和不使用 __slots__？</h2><p id="5c41" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">到目前为止，看起来<code class="fe me mf mg mh b">__slots__</code>是一个非常好的特性。能不能每节课都加？</p><p id="534a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是否定的！显然，有一些权衡。</p><p id="04ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nw">固定属性</em> </strong></p><p id="17ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe me mf mg mh b">__dict__</code>的原因之一是它在创建对象后的灵活性，在这里你可以添加新的属性。然而，<code class="fe me mf mg mh b">__slots__</code>将在您创建类时修复属性。因此，以后不可能添加新的属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/46410c04cfb576bdaba6ef1f6634006f" rel="noopener ugc nofollow" target="_blank"> fix_attributes.py </a></p></figure><p id="f060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是…</p><p id="aa36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，你想利用<code class="fe me mf mg mh b">__slots__</code>，也有在运行时添加新属性的灵活性。你可以通过在<code class="fe me mf mg mh b">__slots__</code>中添加<code class="fe me mf mg mh b">__dict__</code>作为属性来实现。只有新添加的属性会出现在<code class="fe me mf mg mh b">__dict__</code>中。当您的类有 10 个以上的固定属性，并且您希望以后有 1 个或 2 个动态属性时，这将非常有用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/6d3fb9393122f88c040219131e57c445" rel="noopener ugc nofollow" target="_blank"> slots_dict.py </a></p></figure><p id="533e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nw">继承</em> </strong></p><p id="30a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想继承一个包含<code class="fe me mf mg mh b">__slots__</code>的类，你不必在子类中重复这些属性。否则，子类会占用更多的空间。此外，重复的属性在父类中将是不可访问的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/6d3fb9393122f88c040219131e57c445" rel="noopener ugc nofollow" target="_blank">继承 _ 插槽. py </a></p></figure><p id="65c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您继承一个命名的元组时，情况也是如此。你不需要在子类中重复属性。如果你想了解更多关于 NamedTuple 的信息，你可以阅读<a class="ae ky" rel="noopener" target="_blank" href="/understand-how-to-use-namedtuple-and-dataclass-in-python-e82e535c3691">我的文章</a>专门讨论这个话题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/a7acb19869d7867c92736f42277eb5de" rel="noopener ugc nofollow" target="_blank">继承 _ 命名 _ 元组. py </a></p></figure><p id="5a54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以在子类中添加<code class="fe me mf mg mh b">__dict__</code>属性。或者，你不把<code class="fe me mf mg mh b">__slots__</code>放在子类中，它默认会有<code class="fe me mf mg mh b">__dict__</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/e1b606f4528639d52d53a75768ce19c9" rel="noopener ugc nofollow" target="_blank">继承 _ 插槽 _ 字典. py </a></p></figure><p id="1279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你继承了一个没有<code class="fe me mf mg mh b">__slots__</code>的类，那么子类将包含<code class="fe me mf mg mh b">__dict__</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/a4c568a423bace0ed24c0bc694dfb253" rel="noopener ugc nofollow" target="_blank">继承 _ 字典. py </a></p></figure><h2 id="b3f8" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">结论</h2><p id="39a9" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">希望你已经理解了什么是<code class="fe me mf mg mh b">__slots__</code>以及实现的一些细节。在文章的最后，我想分享来自我自己的经验和互联网的利弊(链接在参考资料中)。</p><p id="729e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nw">优点</em></p><p id="943a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您对内存使用有压力时,<code class="fe me mf mg mh b">__slots__</code>绝对有用。只需一行代码就可以非常容易地添加或删除。在<code class="fe me mf mg mh b">__slots__</code>中将<code class="fe me mf mg mh b">__dict__</code>作为一个属性的可能性给了开发人员更多的灵活性来管理属性，同时兼顾性能。</p><p id="6ec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nw">缺点</em></p><p id="04e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要清楚你在做什么，你想用<code class="fe me mf mg mh b">__slots__</code>实现什么，特别是当用它继承一个类的时候。继承的顺序、属性名称会对性能产生巨大的影响。</p><p id="fbbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不能用非空的<code class="fe me mf mg mh b">__slots__</code>继承<code class="fe me mf mg mh b">int</code>、<code class="fe me mf mg mh b">bytes</code>、<code class="fe me mf mg mh b">tuple</code>等内置类型。此外，你不能给<code class="fe me mf mg mh b">__slots__</code>中的属性赋予默认值。这是因为这些属性应该是描述符。相反，您可以在<code class="fe me mf mg mh b">__init__()</code>中指定默认值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/f03ef70361b9abd9cbe625a3fb547f25" rel="noopener ugc nofollow" target="_blank"> slots_error.py </a></p></figure><p id="da4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章！如果你有任何想法，请在下面留下你的评论。</p><h2 id="b524" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">参考</h2><div class="of og gp gr oh oi"><a href="https://stackoverflow.com/questions/472000/usage-of-slots" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">__slots__ 的用法？</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">特殊属性 __slots__ 允许您显式地声明您希望对象具有哪些实例属性…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">stackoverflow.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="http://python-history.blogspot.com/2010/06/inside-story-on-new-style-classes.html" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">新型课堂的内幕</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">警告，这篇文章很长，而且非常专业。]从表面上看，新型的类看起来非常类似于…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">python-history.blogspot.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://wiki.python.org/moin/TimeComplexity" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">时间复杂性- Python Wiki</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">本页记录了当前 CPython 中各种操作的时间复杂度(也称为“Big O”或“Big Oh”)。其他…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">wiki.python.org</p></div></div></div></a></div><div class="of og gp gr oh oi"><a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">3.数据模型- Python 3.8.3 文档</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">对象是 Python 对数据的抽象。Python 程序中的所有数据都由对象或关系来表示…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">docs.python.org</p></div></div></div></a></div></div></div>    
</body>
</html>