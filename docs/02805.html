<html>
<head>
<title>Setup version increment and automated release process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设置版本增量和自动发布流程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/setup-version-increment-and-automated-release-process-591d87ea1221?source=collection_archive---------5-----------------------#2020-03-18">https://towardsdatascience.com/setup-version-increment-and-automated-release-process-591d87ea1221?source=collection_archive---------5-----------------------#2020-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5469" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我将向您展示发布过程和版本增量的自动化有多容易</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f854f5447e972f340f8de0db9f56c675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iQ47Rj061zRZOV5Y"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2827" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我热衷于过程自动化，并且我坚信在开发阶段对过程自动化的时间和金钱投资是首要需求，无论项目持续多长时间。当您投资于流程自动化时，您将进一步大幅降低维护费用。</p><p id="885d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为ML文章中没有适当涉及的一个主题是发布过程自动化和项目版本增量。我不想在这个帖子中讨论可能的发布选项，这不是关于它的。在这里，我们将讨论如何设置CI/CD工具的发布流程(Bitbucket管道、Gitlab管道等)。)我认为可以肯定地说，在大多数情况下，release是一个文件或一组文件，它们将以某种方式集成到客户端现有的解决方案中(无论它是一个包含spring boot应用程序的jar文件，一组用于模型训练和预测的python脚本，还是一个运行核心应用程序的docker映像)。问题陈述:我们希望管理产品版本，我们希望能够返回到具体的版本，以便能够测试和诊断生产中发生的问题。</p><h2 id="1e2e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">版本控制</h2><p id="27e3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，让我们定义版本字符串中的数字是什么意思。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/745431cacdef0ad7dfe3c42c90fa77ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nk3OlP6d79iZAN3uWhvW7A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">版本字符串</p></figure><p id="7bf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从语义版本定义(【https://semver.org/】T4)</p><p id="27dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给定一个版本号<strong class="ky ir">少校。MINOR . PATCH-pre _ release-label</strong>，递增:</p><ol class=""><li id="9716" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated"><strong class="ky ir">主要</strong>版本当您做出不兼容的API更改时</li><li id="4ea9" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">以向后兼容的方式添加功能时的次要版本</li><li id="7332" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated"><strong class="ky ir">补丁</strong>版本当你做向后兼容的bug修正。</li></ol><p id="f00b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">预发布标签</strong>是版本的占位符，在发布前保留。</p><p id="24e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个最佳实践定义，但是当然，您可以选择自己的版本化方案。所以根据这个定义，我们需要定义三个任务:</p><ol class=""><li id="9d43" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">发布并增加主要版本</li><li id="0c57" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">释放并增加次要版本</li><li id="5495" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">发布并增加补丁版本</li></ol><p id="4efe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是定义除了git标记之外，如何在GIT历史中表示发布。有几种技术可以实现这一点，最流行的是分离发布分支或分离提交。在本帖中，我们将讨论分离提交，因为它更容易自动化(不需要合并)。</p><h2 id="51e6" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">分离提交</h2><p id="9095" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们从理论开始。分离提交不属于任何分支，只能直接指向。在不知道提交散列的情况下，如何在git历史中搜索它？你只需要给它分配一个git标签。然后，您可以在任何VCS UI中通过标签过滤git历史。</p><h2 id="5394" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">版本文件</h2><p id="aa96" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">不知何故，你必须保持实际的版本字符串。最简单的方法是将它保存在存储库根目录下的文本文件中。版本文件的策略:</p><ol class=""><li id="1440" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">不能手动更改文件内容</li><li id="273e" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">它不能在特征分支中改变(最佳实践是创建一个流水线步骤，它与主步骤进行比较)</li><li id="f41b" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">文件仅在发布后更改，并自动直接提交到主分支。</li></ol><h2 id="d0cb" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">设置CI/CD管道</h2><p id="2ccf" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">对于您的CI/CD管道文件，您必须添加三个定制/手动步骤/作业，它们将执行release和适当的增量。并选择性地添加步骤/作业，该步骤/作业仅在功能分支上运行，并检查版本文件是否根据主文件进行了更改。</p><p id="ff40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Bash脚本检查版本文件是否相对于主文件发生了更改:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="5511" class="ls lt iq ng b gy nk nl l nm nn">git diff --exit-code VERSION</span></pre><p id="4641" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是最有趣的部分:</p><ol class=""><li id="52f3" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">我们必须创建一个脚本来管理版本文件的功能:获得版本，获得版本与占位符，增加版本主要/次要/补丁</li><li id="367f" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">我们必须定义发布分支限制策略(发布只能在主分支上进行)并创建分离的提交推送流。</li><li id="b95c" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">定义CI/CD释放步骤(这里我们将为Bitbucket管道和Gitlab管道定义它)</li></ol><p id="5d93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我讨厌写bash脚本。我只使用bash来定义高级步骤并从中运行python脚本，因为我坚信bash脚本具有难看的符号，对于经验较少的Linux用户来说不可读，并且从长期角度来看不可维护。<code class="fe no np nq ng b">fire</code>库可以帮助你轻松编写好的CLI-runnable python脚本。查看我之前的帖子:</p><div class="nr ns gp gr nt nu"><a rel="noopener follow" target="_blank" href="/a-simple-way-to-create-python-cli-app-1a4492c164b6"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">创建python CLI应用程序的简单方法</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">将机器学习应用程序包装到命令行界面的简单示例</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">towardsdatascience.com</p></div></div><div class="od l"><div class="oe l of og oh od oi kp nu"/></div></div></a></div><p id="d986" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">版本文件管理脚本(没什么有趣的讨论，只是文件写操作):</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="6953" class="ls lt iq ng b gy nk nl l nm nn">#!/usr/bin/env python<br/>import os<br/>import re<br/><br/>import fire<br/><br/>pre_release_placeholder = 'SNAPSHOT'<br/>version_filepath = os.path.join('.', 'VERSION')<br/>version_pattern = re.compile(fr'^\d+.\d+.\d+(-{pre_release_placeholder})?$')<br/><br/><br/>def get(with_pre_release_placeholder: bool = False):<br/>    with open(version_filepath, 'r') as version_file:<br/>        version_lines = version_file.readlines()<br/>        assert len(version_lines) == 1, 'Version file is malformed'<br/>        version = version_lines[0]<br/>        assert version_pattern.match(version), 'Version string is malformed'<br/>        if with_pre_release_placeholder:<br/>            return version<br/>        else:<br/>            return version.replace(f'-{pre_release_placeholder}', '')<br/><br/><br/>def write_version_file(major: int, minor: int, patch: int):<br/>    version = f'{major}.{minor}.{patch}-{pre_release_placeholder}'<br/>    with open(version_filepath, 'w') as version_file:<br/>        version_file.write(version)<br/><br/><br/>def inc_patch():<br/>    version = get()<br/>    major, minor, patch = version.split('.')<br/>    write_version_file(major, minor, int(patch) + 1)<br/><br/><br/>def inc_minor():<br/>    version = get()<br/>    major, minor, patch = version.split('.')<br/>    write_version_file(major, int(minor) + 1, patch)<br/><br/><br/>def inc_major():<br/>    version = get()<br/>    major, minor, patch = version.split('.')<br/>    write_version_file(int(major) + 1, minor, patch)<br/><br/><br/>if __name__ == "__main__":<br/>    fire.Fire({<br/>        'get': get,<br/>        'inc-patch': inc_patch,<br/>        'inc-minor': inc_minor,<br/>        'inc-major': inc_major<br/>    })</span></pre><p id="1abc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们开发发布脚本。首先，我们必须检查发布脚本是否运行在正确的分支上:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="b09c" class="ls lt iq ng b gy nk nl l nm nn"># Bitbucket<br/>commit=${BITBUCKET_COMMIT:-$(git rev-parse HEAD)}</span><span id="c6d9" class="ls lt iq ng b gy oj nl l nm nn"># Gitlab<br/>commit=${CI_COMMIT_SHA:-$(git rev-parse HEAD)}</span><span id="554c" class="ls lt iq ng b gy oj nl l nm nn"># Define ALLOWED_RELEASE_BRANCH in VCS pipelines secret variables.<br/>branch=${ALLOWED_RELEASE_BRANCH:-master}<br/><br/>if ! git branch -a --contains "${commit}" | grep -e "^[* ]*remotes/origin/${branch}\$"<br/>then<br/>  echo -e "###\n### Not on ${branch}. Only ${branch} commits can be released.\n###"<br/>  exit 1<br/>else<br/>  echo -e "###\n### Releasing of ${commit} on ${branch}\n###"<br/>fi</span></pre><p id="e94e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后你必须写一些释放的东西，如:发布docker图像或复制到S3水桶或任何你需要的。不要忘记使用正确的版本文件:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="f31a" class="ls lt iq ng b gy nk nl l nm nn">version=$(./scripts/version.py get)<br/>version_file=VERSION</span><span id="9dfa" class="ls lt iq ng b gy oj nl l nm nn">echo ${version} &gt; ${version_file}</span></pre><p id="e447" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们必须在之前的步骤版本文件中使用modified推送一个分离的提交:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="6d29" class="ls lt iq ng b gy nk nl l nm nn"># Define some cool release pusher to ditinguish from amnual commits :)<br/>git config user.name "Elon Musk"<br/>git config user.email "elon.musk@spacex.com"<br/><br/>echo "Pushing detached tag of new version"<br/>git add ${version_file}<br/>git commit -m "Release version ${version}"<br/>git tag  -a ${version} -m "Release version ${version} tag"<br/>git push origin ${version}</span></pre><p id="c50c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">取回主分支并使用预发布占位符增加版本:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="c09c" class="ls lt iq ng b gy nk nl l nm nn">echo "Pushing new version to ${branch}"<br/>git fetch origin "${branch}:${branch}" || git pull<br/>git checkout "${branch}"</span><span id="2e7f" class="ls lt iq ng b gy oj nl l nm nn"># Parameter of the script<br/>release_type=${1}<br/>./scripts/version.py inc-${release_type}<br/><br/>next_working_version=$(./scripts/version.py get --with-pre-release-placeholder)<br/>git add ${version_file}<br/>git commit -m "Incrementing working version to ${next_working_version} after ${version} release."<br/>git push origin ${branch}</span></pre><p id="3858" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已。我们已经创建了一个干净的发布脚本。现在让我们开发Bitbucket和Gitlab管道步骤片段。</p><p id="6c30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">比特桶</strong>:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="62f0" class="ls lt iq ng b gy nk nl l nm nn">image:<br/>  name: python:3.7.6-slim-buster<br/><br/>pipelines:<br/>  default:<br/>    - step:<br/>        - name: Test version file not changed<br/>        - script:<br/>            - git diff --exit-code VERSION<br/><br/>  custom:<br/>    release-inc-patch:<br/>      - step:<br/>          caches:<br/>            - pip<br/>          name: Release current version and increment patch version<br/>          script:<br/>            - apt-get update &amp;&amp; apt-get install -y git<br/>            - pip install fire==0.2.1<br/>            - ./scripts/release.sh patch<br/><br/>    release-inc-minor:<br/>      - step:<br/>          caches:<br/>            - pip<br/>          name: Release current version and increment minor version<br/>          script:<br/>            - apt-get update &amp;&amp; apt-get install -y git<br/>            - pip install fire==0.2.1<br/>            - ./scripts/release.sh minor<br/>    release-inc-major:<br/>      - step:<br/>          caches:<br/>            - pip<br/>          name: Release current version and increment major version<br/>          script:<br/>            - apt-get update &amp;&amp; apt-get install -y git<br/>            - pip install fire==0.2.1<br/>            - ./scripts/release.sh major</span></pre><p id="2a4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行自定义管道步骤:<a class="ae kv" href="https://confluence.atlassian.com/bitbucket/run-pipelines-manually-861242583.html" rel="noopener ugc nofollow" target="_blank">https://confluence . atlassian . com/bit bucket/run-pipelines-manually-861242583 . html</a></p><p id="658b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Gitlab </strong>:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="1aac" class="ls lt iq ng b gy nk nl l nm nn">test-version-changed:<br/>  stage: test<br/>  name: Test version file not changed<br/>  script:<br/>    - git diff --exit-code VERSION<br/><br/>release-inc-patch:<br/>  stage: deploy<br/>  image: python:3.7.6-slim-buster<br/>  caches:<br/>    - pip<br/>  name: Release current version and increment patch version<br/>  script:<br/>    - apt-get update &amp;&amp; apt-get install -y git<br/>    - pip install fire==0.2.1<br/>    - ./scripts/release.sh patch<br/>  when: manual<br/>  only:<br/>    - master<br/><br/>release-inc-minor:<br/>  stage: deploy<br/>  image: python:3.7.6-slim-buster<br/>  caches:<br/>    - pip<br/>  name: Release current version and increment minor version<br/>  script:<br/>    - apt-get update &amp;&amp; apt-get install -y git<br/>    - pip install fire==0.2.1<br/>    - ./scripts/release.sh minor<br/>  when: manual<br/>  only:<br/>    - master<br/><br/>release-inc-major:<br/>  stage: deploy<br/>  image: python:3.7.6-slim-buster<br/>  caches:<br/>    - pip<br/>  name: Release current version and increment major version<br/>  script:<br/>    - apt-get update &amp;&amp; apt-get install -y git<br/>    - pip install fire==0.2.1<br/>    - ./scripts/release.sh major<br/>  when: manual<br/>  only:<br/>    - master</span></pre><p id="6d28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行手动作业:<a class="ae kv" href="https://forum.gitlab.com/t/gitlab-ci-run-pipeline-manually/13797" rel="noopener ugc nofollow" target="_blank">https://forum . git lab . com/t/git lab-ci-run-pipeline-manually/13797</a></p><p id="fb6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！你能在我的GitHub上找到的所有资源:【https://github.com/mbalatsko/release-version-increment】<strong class="ky ir"/></p><p id="fe61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章将是有用的和信息丰富的。期待您的反馈！</p></div></div>    
</body>
</html>