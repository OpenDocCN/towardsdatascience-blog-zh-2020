<html>
<head>
<title>Numpy Array Cookbook: Generating and Manipulating Arrays in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Numpy 数组指南:在 Python 中生成和操作数组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/numpy-array-cookbook-generating-and-manipulating-arrays-in-python-2195c3988b09?source=collection_archive---------10-----------------------#2020-04-10">https://towardsdatascience.com/numpy-array-cookbook-generating-and-manipulating-arrays-in-python-2195c3988b09?source=collection_archive---------10-----------------------#2020-04-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2984" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我的 numpy 数组清单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/19bd1731ca0c58dcefdabdca07653594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0Dg7QfSYtWhSAu-afi8-g.png"/></div></div></figure><p id="ce2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我曾经作为一名数据科学家毫无准备地走进一家公司。虽然我期望成为训练模型，但我的角色却是软件工程，这个应用程序使用了我所见过的最大量的 numpy。</p><p id="ddae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然我已经多次使用<code class="fe lq lr ls lt b">np.array()</code>将一个列表转换成一个数组，但我并没有为一行又一行的<code class="fe lq lr ls lt b">linspace</code>、<code class="fe lq lr ls lt b">meshgrid</code>和<code class="fe lq lr ls lt b">vsplit</code>做好准备。</p><p id="4b12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我想能够读写代码，我需要尽快熟悉 numpy。</p><p id="0265" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我为自己构建的 numpy 数组函数和示例的精选列表。</p><p id="5f9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在第一部分介绍数组的背景信息，然后讨论一些高级函数，这些函数将帮助您更快地处理数据。</p><p id="4c5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">目录:</strong>T17】1。阵列概述<br/> 2。生成数组<br/> 3。操纵数组</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="c858" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">1)阵列概述</h1><h2 id="e32c" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">什么是数组？</h2><p id="a40c" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">数组是存储同类数据的数据结构。这意味着所有的元素都是同一类型。</p><p id="28b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Numpy 的数组类是<code class="fe lq lr ls lt b">ndarray</code>，意思是“N 维数组”。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="3791" class="mt mc it lt b gy no np l nq nr">import numpy as np</span><span id="cad7" class="mt mc it lt b gy ns np l nq nr">arr = np.array([[1,2],[3,4]])<br/>type(arr)</span><span id="ad2e" class="mt mc it lt b gy ns np l nq nr">#=&gt; numpy.ndarray</span></pre><p id="957f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它是 n 维的，因为它允许根据初始化时传递的形状创建几乎无限维的数组。</p><p id="5ef7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">例如:</strong> <code class="fe lq lr ls lt b">np.zeros((2))</code>生成一个 1D 数组。<code class="fe lq lr ls lt b">np.zeros((2,2))</code>生成一个 2D 数组。<code class="fe lq lr ls lt b">np.zeros((2,2,2))</code>生成一个 3D 数组。<code class="fe lq lr ls lt b">np.zeros((2,2,2,2))</code>生成一个 4D 数组。诸如此类…</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="8d74" class="mt mc it lt b gy no np l nq nr"><strong class="lt iu">np.zeros((2))</strong><br/>#=&gt; array([0., 0.])</span><span id="d429" class="mt mc it lt b gy ns np l nq nr"><strong class="lt iu">np.zeros((2,2))</strong><br/>#=&gt; array([[0., 0.],<br/>#=&gt;        [0., 0.]])</span><span id="4406" class="mt mc it lt b gy ns np l nq nr"><strong class="lt iu">np.zeros((2,2,2))</strong><br/>#=&gt; array([[[0., 0.],<br/>#=&gt;         [0., 0.]],<br/>#=&gt; <br/>#=&gt;        [[0., 0.],<br/>#=&gt;         [0., 0.]]])<br/>...</span></pre><h2 id="15cd" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">数组与列表</h2><ul class=""><li id="728b" class="nt nu it kw b kx nf la ng ld nv lh nw ll nx lp ny nz oa ob bi translated">数组比列表使用更少的内存</li><li id="3bd8" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">阵列有更多的功能</li><li id="51c5" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">数组要求数据是同质的；列表不</li><li id="0e97" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">数组上的算术运算类似于矩阵乘法</li></ul><h2 id="af8a" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">重要参数</h2><p id="b3dd" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated"><strong class="kw iu"> shape: </strong>表示数组维数的元组。形状为<code class="fe lq lr ls lt b">(2,3,2)</code>的数组是一个 2×3×2 的数组。看起来像下面。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="62d6" class="mt mc it lt b gy no np l nq nr">np.zeros((2,3,2))</span><span id="960e" class="mt mc it lt b gy ns np l nq nr">#=&gt; array([[[0., 0.],<br/>#=&gt;         [0., 0.],<br/>#=&gt;         [0., 0.]],<br/>#=&gt; <br/>#=&gt;        [[0., 0.],<br/>#=&gt;         [0., 0.],<br/>#=&gt;         [0., 0.]]])</span></pre><p id="4a85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> dtype: </strong>存储在数组中的值的类型。数组是同质的，所以我们不能混合多种数据类型，如字符串和整数。<code class="fe lq lr ls lt b">dtype</code>的值可以是<code class="fe lq lr ls lt b">np.float64</code>、<code class="fe lq lr ls lt b">np.int8</code>、<code class="fe lq lr ls lt b">int</code>、<code class="fe lq lr ls lt b">str</code>或<a class="ae oh" href="https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html" rel="noopener ugc nofollow" target="_blank">几种其他类型</a>中的一种。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="c0da" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">2)生成数组</h1><h2 id="98d6" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated"><strong class="ak">零点</strong></h2><p id="9489" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">生成具有指定形状的零数组。</p><p id="c45b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您希望在开始训练之前将 ML 模型中的权重初始化为 0 时，这很有用。这也常用于初始化一个具有特定形状的数组，然后用您自己的值覆盖它。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="7614" class="mt mc it lt b gy no np l nq nr">np.zeros((2,3))<br/>#=&gt; array([[0., 0., 0.],<br/>#=&gt;        [0., 0., 0.]])</span></pre><h2 id="8154" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated"><strong class="ak">一念之差</strong></h2><p id="3492" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">生成具有指定形状的一个数组。</p><p id="6e25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您需要在增量相减之前将值初始化为 1，这很有用。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="8b14" class="mt mc it lt b gy no np l nq nr">np.ones((2,3))<br/>#=&gt; array([[1., 1., 1.],<br/>#=&gt;        [1., 1., 1.]])</span></pre><h2 id="220a" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">空的</h2><p id="05b6" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated"><code class="fe lq lr ls lt b">np.empty()</code>与 0 和 1 略有不同，因为它没有在数组中预设任何值。有些人说初始化稍微快一点，但这可以忽略不计。</p><p id="6bd5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了代码可读，在用数据填充数组之前初始化数组时，有时会用到这种方法。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="08ad" class="mt mc it lt b gy no np l nq nr">arr = np.empty((2,2))<br/>arr<br/>#=&gt; array([[1.00000000e+000, 1.49166815e-154],<br/>#=&gt;        [4.44659081e-323, 0.00000000e+000]])</span></pre><h2 id="f39f" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">全部</h2><p id="d851" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">用给定值初始化数组。</p><p id="8857" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面我们用<code class="fe lq lr ls lt b">10</code>初始化一个数组。然后是另一个有<code class="fe lq lr ls lt b">['a','b']</code>对的数组。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="3dfa" class="mt mc it lt b gy no np l nq nr"><strong class="lt iu">np.full((3,2), 10)</strong><br/>#=&gt; array([[10, 10],<br/>#=&gt;        [10, 10],<br/>#=&gt;        [10, 10]])</span><span id="cdba" class="mt mc it lt b gy ns np l nq nr"><strong class="lt iu">np.full((3,2), ['a','b'])</strong><br/>#=&gt; array([['a', 'b'],<br/>#=&gt;        ['a', 'b'],<br/>#=&gt;        ['a', 'b']], dtype='&lt;U1')</span></pre><h2 id="4de4" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">排列</h2><p id="25de" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">这可能是你在现实生活中见过最多的。它从一个“类数组”对象初始化一个数组。</p><p id="ad85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您将数据存储在另一种数据结构中，但需要将其转换为 numpy 对象以便传递给 sklearn，这将非常有用。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="f289" class="mt mc it lt b gy no np l nq nr">li = ['a','b','c']<br/>np.array(li)</span><span id="8327" class="mt mc it lt b gy ns np l nq nr">#=&gt; array(['a', 'b', 'c'], dtype='&lt;U1')</span></pre><p id="15ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="oi">注意:</em> <code class="fe lq lr ls lt b"><em class="oi">np.array</em></code> <em class="oi">还有一个参数叫做</em> <code class="fe lq lr ls lt b"><em class="oi">copy</em></code> <em class="oi">，可以设置为</em> <code class="fe lq lr ls lt b"><em class="oi">True</em></code> <em class="oi">来保证生成一个新的数组对象，而不是指向一个已有的对象。</em></p><h2 id="91ed" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">_ 喜欢</h2><p id="201c" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">有几个<code class="fe lq lr ls lt b">_like</code>函数对应于我们已经讨论过的函数:<code class="fe lq lr ls lt b">empty_like</code>、<code class="fe lq lr ls lt b">ones_like</code>、<code class="fe lq lr ls lt b">zeros_like</code>和<code class="fe lq lr ls lt b">full_like</code>。</p><p id="b22f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它们生成的数组与传入的数组形状相同，但具有自己的值。所以<code class="fe lq lr ls lt b">ones_like</code>生成一个 1 的数组，但是你传递给它一个现有的数组，它取那个数组的形状，而不是你直接指定形状。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="66f4" class="mt mc it lt b gy no np l nq nr">a1 = np.array([[1,2],[3,4]])<br/>#=&gt; array([[1, 2],<br/>#=&gt;        [3, 4]])</span><span id="cf61" class="mt mc it lt b gy ns np l nq nr">np.ones_like(a1)<br/>#=&gt; array([[1, 1],<br/>#=&gt;        [1, 1]])</span></pre><p id="5b54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意第二个 1 的数组是如何呈现第一个数组的形状的。</p><h2 id="7a41" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">边缘</h2><p id="b217" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">用随机值生成一个数组。</p><p id="f005" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您希望将模型中预先训练的权重初始化为随机值时，这很有用，这可能比将它们初始化为零更常见。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="ad26" class="mt mc it lt b gy no np l nq nr">np.random.rand(3,2)<br/>#=&gt; array([[0.94664048, 0.76616114],<br/>#=&gt;        [0.395549  , 0.84680126],<br/>#=&gt;        [0.42873   , 0.77736086]])</span></pre><h2 id="ffa6" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">阿萨瑞</h2><p id="28e0" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated"><code class="fe lq lr ls lt b">np.asarray</code>是<code class="fe lq lr ls lt b">np.array</code>的包装器，设置参数<code class="fe lq lr ls lt b">copy=False</code>。参见上面的<code class="fe lq lr ls lt b">np.array</code>。</p><h2 id="0969" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">阿兰格</h2><p id="358f" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">生成一个值数组，其间隔设置在上限和下限之间。这是 numpy 版本的<code class="fe lq lr ls lt b">list(range(50,60,2))</code>列表。</p><p id="a260" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面我们生成一个 50 到 60 之间的每秒值的数组。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="6fec" class="mt mc it lt b gy no np l nq nr">np.arange(50,60,2)<br/>#=&gt; array([50, 52, 54, 56, 58])</span></pre><h2 id="f1b8" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">林空间</h2><p id="ac57" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">生成两个其他数字之间间隔相等的数字数组。我们不是像<code class="fe lq lr ls lt b">arange</code>那样直接指定区间，而是指定在上限和下限之间生成多少个数。</p><p id="5cfb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面我们返回一个由 10 到 20 之间的 6 个数字和 0 到 2 之间的 5 个数字组成的数组。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="6912" class="mt mc it lt b gy no np l nq nr">np.linspace(10, 20, 6)<br/>#=&gt; array([10., 12., 14., 16., 18., 20.])</span><span id="8713" class="mt mc it lt b gy ns np l nq nr">np.linspace(0, 2, 5)<br/>#=&gt; array([0. , 0.5, 1. , 1.5, 2. ])</span></pre><p id="a9fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们是如何指定数组中元素的数量，而不是指定区间本身的。</p><h2 id="71c2" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">网格</h2><p id="5ff3" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">基于两个输入数组生成坐标矩阵。</p><p id="8d05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可能有点棘手。让我们看一个例子。生成 2 个数组并将它们传递给<code class="fe lq lr ls lt b">np.meshgrid</code>。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="e82b" class="mt mc it lt b gy no np l nq nr">x = np.array([1,2,3])<br/>y = np.array([-3,-2,-1])<br/> <br/>xcors, ycors = np.meshgrid(x, y) </span><span id="774e" class="mt mc it lt b gy ns np l nq nr">xcors<br/>#=&gt; [[1 2 3]<br/>#=&gt; [1 2 3]<br/>#=&gt; [1 2 3]]</span><span id="dca4" class="mt mc it lt b gy ns np l nq nr">ycors<br/>#=&gt; [[-3 -3 -3]<br/>#=&gt; [-2 -2 -2]<br/>#=&gt; [-1 -1 -1]]</span></pre><p id="1ded" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们可以看到两个不同的矩阵输出，基于输入数组的值和形状。</p><p id="158c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是不要把它想象成两个独立的矩阵。这些实际上是一对(x，y)坐标，代表平面上的点。下面我把它们组合起来了。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="bae6" class="mt mc it lt b gy no np l nq nr">[[(1, -3), (2, -3), (3, -3)]<br/> [(1, -2), (2, -2), (3, -2)],<br/> [(1, -1), (2, -1), (3, -1)]]</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="dfb9" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">3)操纵数组</h1><h2 id="3038" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">复制</h2><p id="59c7" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">制作现有阵列的副本。</p><p id="7db5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将一个数组赋给一个新的变量名将会指向原来的数组。你需要<strong class="kw iu">小心</strong>这种行为，这样你就不会无意中修改现有的变量。</p><p id="c529" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑这个例子。虽然我们修改了<code class="fe lq lr ls lt b">a2</code>，但是<code class="fe lq lr ls lt b">a1</code>的值也会改变。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="0ea2" class="mt mc it lt b gy no np l nq nr">a1 = np.array([1,2,3])<br/>a2 = a1</span><span id="ae51" class="mt mc it lt b gy ns np l nq nr">a2[0] = 10<br/>a1<br/>#=&gt; array([10,  2,  3])</span></pre><p id="96be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在比较一下这个。我们修改了<code class="fe lq lr ls lt b">a2</code>但是<code class="fe lq lr ls lt b">a1</code>没有改变…因为我们做了一个拷贝！</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="e123" class="mt mc it lt b gy no np l nq nr">a1 = np.array([1,2,3])<br/>a2 = a1.copy()</span><span id="985f" class="mt mc it lt b gy ns np l nq nr">a2[0] = 10<br/>a1<br/>#=&gt; array([1, 2, 3])</span></pre><h2 id="64d6" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">形状</h2><p id="93d6" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">获取数组的形状。</p><p id="2e1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在处理大规模多维数组时非常有用，因为无法观察维度。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="58aa" class="mt mc it lt b gy no np l nq nr">a = np.array([[1,2],[3,4],[5,6]])<br/>a.shape<br/>#=&gt; (3, 2)</span></pre><h2 id="e488" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">使再成形</h2><p id="dc74" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">重塑数组。</p><p id="196b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这非常有用，我无法想象没有它会使用像 Keras 这样的库。让我们看一个创建和整形数组的例子。</p><p id="b199" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生成一个数组。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="ebdd" class="mt mc it lt b gy no np l nq nr">a = np.array([[1,2],[3,4],[5,6]])<br/>a<br/>#=&gt; array([[1, 2],<br/>#=&gt;        [3, 4],<br/>#=&gt;        [5, 6]])</span></pre><p id="1120" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">检查它的形状。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="ed1b" class="mt mc it lt b gy no np l nq nr">a.shape<br/>#=&gt; (3, 2)</span></pre><p id="78e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将阵列从 3x3 调整为 2x3。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="2073" class="mt mc it lt b gy no np l nq nr">a.reshape(2,3)<br/>#=&gt; array([[1, 2, 3],<br/>#=&gt;        [4, 5, 6]])</span></pre><p id="aee0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将数组展平为一维。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="1199" class="mt mc it lt b gy no np l nq nr">a.reshape(6)<br/>#=&gt; array([1, 2, 3, 4, 5, 6])</span></pre><p id="d17d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将阵列重新整形为 6x1 矩阵。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="117a" class="mt mc it lt b gy no np l nq nr">a.reshape(6,1)<br/>#=&gt;array([[1],<br/>#=&gt;       [2],<br/>#=&gt;       [3],<br/>#=&gt;       [4],<br/>#=&gt;       [5],<br/>#=&gt;       [6]])</span></pre><p id="57c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将数组重塑为 3 维，2x3x1。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="2487" class="mt mc it lt b gy no np l nq nr">a.reshape(2,3,1)<br/>#=&gt; array([[[1],<br/>#=&gt;         [2],<br/>#=&gt;         [3]],<br/>#=&gt; <br/>#=&gt;        [[4],<br/>#=&gt;         [5],<br/>#=&gt;         [6]]])</span></pre><h2 id="b6ef" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">调整大小</h2><p id="6f15" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">类似于<code class="fe lq lr ls lt b">reshape</code>但是它改变了原来的数组。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="9bd4" class="mt mc it lt b gy no np l nq nr">a = np.array([['a','b'],['c','d']])<br/>a<br/>#=&gt;array([['a', 'b'],<br/>#=&gt;       ['c', 'd']], dtype='&lt;U1')</span><span id="bce2" class="mt mc it lt b gy ns np l nq nr">a.reshape(1,4)<br/>#=&gt; array([['a', 'b', 'c', 'd']], dtype='&lt;U1')</span><span id="b713" class="mt mc it lt b gy ns np l nq nr">a<br/>#=&gt;array([['a', 'b'],<br/>#=&gt;       ['c', 'd']], dtype='&lt;U1')</span><span id="2cbc" class="mt mc it lt b gy ns np l nq nr">a.resize(1,4)<br/>a<br/>#=&gt; array([['a', 'b', 'c', 'd']], dtype='&lt;U1')</span></pre><p id="7785" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意调用<code class="fe lq lr ls lt b">reshape</code>并没有改变<code class="fe lq lr ls lt b">a</code>，但是调用<code class="fe lq lr ls lt b">resize</code>却永久地改变了它的形状。</p><h2 id="6d02" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">移项</h2><p id="619a" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">转置一个数组。</p><p id="1797" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在生成 pandas 数据框或进行计数或求和等聚合计算之前，我们可以交换行和列吗？</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="c996" class="mt mc it lt b gy no np l nq nr">a = np.array([['s','t','u'],['x','y','z']])<br/>a<br/>#=&gt; array([['s', 't', 'u'],<br/>#=&gt;        ['x', 'y', 'z']], dtype='&lt;U1')</span><span id="077a" class="mt mc it lt b gy ns np l nq nr">a.T<br/>#=&gt; array([['s', 'x'],<br/>#=&gt;        ['t', 'y'],<br/>#=&gt;        ['u', 'z']], dtype='&lt;U1')</span></pre><p id="2cdc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意所有的东西是如何在<code class="fe lq lr ls lt b">s</code>和<code class="fe lq lr ls lt b">z</code>之间的对角线上翻转的。</p><h2 id="51a7" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">变平</h2><p id="4502" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">将数组展平为一维并返回一个副本。</p><p id="29f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这实现了与下面的<code class="fe lq lr ls lt b">reshape(6)</code>相同的结果。但是当您事先不知道数组的大小时,<code class="fe lq lr ls lt b">flatten</code>会很有用。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="c856" class="mt mc it lt b gy no np l nq nr">a = np.array([[1,2,3],['a','b','c']])<br/>a.flatten()<br/>#=&gt; array(['1', '2', '3', 'a', 'b', 'c'], dtype='&lt;U21')</span><span id="9906" class="mt mc it lt b gy ns np l nq nr">a.reshape(6)<br/>#=&gt; array(['1', '2', '3', 'a', 'b', 'c'], dtype='&lt;U21')</span></pre><h2 id="342f" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">解开…的纠结</h2><p id="71f7" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">将类似数组的对象展平为一维。类似于<code class="fe lq lr ls lt b">flatten</code>，但是它返回数组的视图而不是副本。</p><p id="4090" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最大的好处是它可以用在非数组上，比如列表，而在列表中<code class="fe lq lr ls lt b">flatten</code>会失败。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="80fb" class="mt mc it lt b gy no np l nq nr">np.ravel([[1,2,3],[4,5,6]])<br/>#=&gt; array([1, 2, 3, 4, 5, 6])</span><span id="eb2c" class="mt mc it lt b gy ns np l nq nr">np.flatten([[1,2,3],[4,5,6]])<br/>#=&gt; AttributeError: module 'numpy' has no attribute 'flatten'</span></pre><h2 id="08a2" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">hsplit</h2><p id="9156" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">将数组水平分割成子数组。</p><p id="28ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以将这想象成将矩阵中的每一列拆分成自己的数组。</p><p id="ea9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果每一列描述一个对象，每一行是这些对象的一个时间段，则在 ML 中用于拆分时间序列数据。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="9cc7" class="mt mc it lt b gy no np l nq nr">a = np.array(<br/>    [[1,2,3],<br/>     [4,5,6]])<br/>a<br/>#=&gt; array([[1, 2, 3],<br/>#=&gt;        [4, 5, 6]])</span><span id="b430" class="mt mc it lt b gy ns np l nq nr">np.hsplit(a,3)</span><span id="7f65" class="mt mc it lt b gy ns np l nq nr"># #=&gt; [array([[1],[4]]), <br/># #=&gt;  array([[2],[5]]), <br/># #=&gt;  array([[3],[6]])]</span></pre><h2 id="9d53" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">vsplit</h2><p id="1122" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">将数组垂直拆分成子数组。</p><p id="ffeb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以将这想象成将每一行拆分成自己的列。</p><p id="39b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果每一行代表一个对象，每一列是这些对象的一个不同的特性，那么在 ML 中就很有用。</p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="ae37" class="mt mc it lt b gy no np l nq nr">a = np.array(<br/>    [[1,2,3],<br/>     [4,5,6]])<br/>a<br/>#=&gt; array([[1, 2, 3],<br/>#=&gt;        [4, 5, 6]])</span><span id="e514" class="mt mc it lt b gy ns np l nq nr">np.vsplit(a,2)</span><span id="f1d3" class="mt mc it lt b gy ns np l nq nr">#=&gt; [array([[1, 2, 3]]), <br/>#=&gt; array([[4, 5, 6]])]</span></pre><h2 id="d55c" class="mt mc it bd md mu mv dn mh mw mx dp ml ld my mz mn lh na nb mp ll nc nd mr ne bi translated">堆</h2><p id="3639" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">连接轴上的数组。</p><p id="ac77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这本质上与<code class="fe lq lr ls lt b">vsplit</code>和<code class="fe lq lr ls lt b">hsplit</code>相反，它将独立的数组组合成一个数组。</p><p id="506c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">沿着<code class="fe lq lr ls lt b">axis=0</code></p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="bdbb" class="mt mc it lt b gy no np l nq nr">a = np.array(['a', 'b', 'c'])<br/>b = np.array(['d', 'e', 'f'])</span><span id="d8db" class="mt mc it lt b gy ns np l nq nr">np.stack((a, b), axis=0)<br/>#=&gt; array([['a', 'b', 'c'],<br/>#=&gt;       ['d', 'e', 'f']], dtype='&lt;U1')</span></pre><p id="c082" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">沿着<code class="fe lq lr ls lt b">axis=1</code></p><pre class="kj kk kl km gt nk lt nl nm aw nn bi"><span id="6765" class="mt mc it lt b gy no np l nq nr">a = np.array(['a', 'b', 'c'])<br/>b = np.array(['d', 'e', 'f'])</span><span id="d6bd" class="mt mc it lt b gy ns np l nq nr">np.stack((a, b), axis=1)<br/>#=&gt; array([['a', 'd'],<br/>#=&gt;        ['b', 'e'],<br/>#=&gt;        ['c', 'f']], dtype='&lt;U1')</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="d625" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="0df3" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">我认为这是 numpy 的基础。当您在工作中阅读现有代码或在线学习教程时，您会反复遇到这些函数。</p><p id="1e5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">熟悉以上内容意味着你不会陷入理解如何使用<code class="fe lq lr ls lt b">meshgrid</code>来生成 matplotlib 图表的困境。或者如何快速添加维度，使您的数据符合 Keras 模型的输入要求。</p><p id="4362" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有哪些你离不开的 numpy 函数？</p></div></div>    
</body>
</html>