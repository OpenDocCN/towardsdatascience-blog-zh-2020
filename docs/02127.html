<html>
<head>
<title>The Binomial Regression Model: Everything You Need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二项式回归模型:你需要知道的一切</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-binomial-regression-model-everything-you-need-to-know-5216f1a483d3?source=collection_archive---------4-----------------------#2020-02-29">https://towardsdatascience.com/the-binomial-regression-model-everything-you-need-to-know-5216f1a483d3?source=collection_archive---------4-----------------------#2020-02-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e57cfbc2e6411a1f4046eda35485be29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OngSgqV2Tr6Kx7i8E1VSAg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">RMS泰坦尼克号(来源:<a class="ae jg" href="https://en.wikipedia.org/wiki/Titanic#/media/File:RMS_Titanic_3.jpg" rel="noopener ugc nofollow" target="_blank">维基百科</a>CC0下)</p></figure><div class=""/><div class=""><h2 id="f5fc" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">外加一个使用Python和statsmodels的逐步教程</h2></div><p id="2330" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文分为两个部分:</p><ol class=""><li id="3455" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><strong class="la jk">第1节:二项式回归模型简介:</strong>我们将介绍二项式回归模型，了解它如何适应广义线性模型家族，以及为什么它可以用于预测随机事件的概率。</li><li id="ca4e" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">第2部分:使用二项式回归模型:</strong>我们将使用<em class="mi"> Python </em>和<em class="mi"> statsmodels </em>库在真实世界的Titanic数据集上训练一个二项式回归模型。我们将看到为什么二项式回归模型是预测泰坦尼克号生存几率的正确模型。我们还将学习如何解释拟合模型的回归系数，这是一项必须学习的技能，在巨大数据集的情况下会产生惊人的结果。</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b940" class="mq mr jj bd ms mt mu mv mw mx my mz na kp nb kq nc ks nd kt ne kv nf kw ng nh bi translated">第一节</h1><h2 id="7beb" class="ni mr jj bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">二项式回归模型简介</h2><p id="34e5" class="pw-post-body-paragraph ky kz jj la b lb nu kk ld le nv kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">给定回归变量的向量，二项式回归模型可用于预测看到事件的几率。例如，在给定当前温度、湿度、气压、一年中的时间、地理位置、海拔高度等的情况下，可以使用二项式回归模型来预测未来2小时内开始下雨的可能性。</p><p id="407a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在二项式回归模型中，因变量<strong class="la jk"> <em class="mi"> y </em> </strong>是一个离散的随机变量，取值为0、1、5、67等。每个值代表在<em class="mi"> m次</em>试验中观察到的“成功”次数。因此<strong class="la jk"> <em class="mi"> y </em> </strong>遵循二项式分布。</p><p id="696a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的等式给出了在独立伯努利试验中观察到<em class="mi"> k </em>成功的概率。每次伯努利试验的成功概率=π，失败概率= <em class="mi"> (1- </em> π <em class="mi"> ) </em>。抛硬币是伯努利试验的最简单的例子，其中π = (1-π) = 0.5。</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/4eb6b7bafc625a53da77f95fe81fa254.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*AVg_a9bFB-1xHNGHvUjvqw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><strong class="bd oe"> P </strong>概率<strong class="bd oe">M</strong>as<strong class="bd oe">F</strong>二项分布随机变量<strong class="bd oe"> y </strong>的函数(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="a811" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">竖括号中的术语(m k)是‘组合’的符号，读作<em class="mi">‘m choose k’</em>。它给出了从一组<em class="mi"> m </em>可能的结果中选择<em class="mi"> k </em>结果的不同方法。</p><p id="b9b2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在一个回归模型中，我们会假设因变量<strong class="la jk"> <em class="mi"> y </em> </strong>依赖于一个<em class="mi"> (n X p) </em>大小的回归变量矩阵<strong class="la jk"> <em class="mi"> X </em> </strong>。<strong class="la jk"> <em class="mi"> X </em> </strong>中第<em class="mi">行可以表示为<strong class="la jk"> <em class="mi"> x_i </em> </strong>是一个大小为<em class="mi"> (1 X p)的向量。</em>对应第I个结果<em class="mi"> y_i </em>。</em></p><p id="8124" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">人们通常以符号形式表示<em class="mi"> y_i </em>取某一值<em class="mi"> k </em>为<em class="mi">的概率，条件是回归变量</em> <strong class="la jk"> <em class="mi"> X </em> </strong> <em class="mi">取值</em> <strong class="la jk"> <em class="mi"> x_i. </em> </strong>，可以写成<em class="mi">Pr(y _ I = k |</em><strong class="la jk"><em class="mi">X</em></strong><em class="mi"/></p><p id="9d2d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在可以将二项分布的<strong class="la jk"> <em class="mi"> y </em> </strong>在回归<strong class="la jk"> <em class="mi"> y </em> </strong>对<strong class="la jk"> <em class="mi"> X </em> </strong>的概率分布表述为<strong class="la jk"> <em class="mi"> </em> </strong>如下:</p><ul class=""><li id="ab43" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt of ma mb mc bi translated">在上面提到的PMF方程的L.H.S .上，我们将无条件概率<em class="mi"> Pr(y=k) </em>替换为条件概率<em class="mi">Pr(y _ I = k |</em><strong class="la jk"><em class="mi">X</em></strong><em class="mi">=</em><strong class="la jk"><em class="mi">X _ I</em></strong><em class="mi">)。</em></li><li id="8261" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">在R.H.S中，我们将用条件概率<em class="mi"> π_i </em>代替观察成功的无条件概率<em class="mi"> π </em>，其中<em class="mi"> π_i </em>是数据集第<em class="mi">行与第</em>行观察成功的概率，即当回归向量<strong class="la jk">X</strong><em class="mi">=</em><strong class="la jk"><em class="mi">X</em></strong></li></ul><p id="4b79" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过这两个替换，二项式分布的<strong class="la jk"> <em class="mi"> y </em> </strong>的PMF变成如下:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi og"><img src="../Images/fc7209a573834860868e4cccaeda3ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*Fa-RxexXYlNlJXw2yRh_LQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">在<strong class="bd oe"> X </strong>回归的二项分布<strong class="bd oe"> y </strong>的条件概率分布(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="5fdf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的等式中，对于某个X=x_i，观察成功的概率<em class="mi"> π_i </em>，通常表示为某个函数g(。)的<strong class="la jk"> <em class="mi"> x_i的</em> </strong>。用象征性的术语来说:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d39df629c095eb94a10a811e6f6aa86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*-o_ilro3Zjvsa83N50HIOw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">成功的概率表示为回归矩阵第I行的某个函数<strong class="bd oe"> X </strong>(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="df0c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的一组概念可以用一个简单的例子形象地描述出来，如下所示:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/a1d17f1bd96d34cc0045bdeb065a715a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oRgXcYegg0Eqn2OksU_NZA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">二项式分布的y对X(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="dc61" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上图中，<em class="mi"> y_1，y_2，y_3，…y_10 </em>是十个二项分布的随机变量。它们也发生在因变量<strong class="la jk"><em class="mi">【y】</em></strong>的组成成分上，即一个(10×1)矩阵如下:<br/><strong class="la jk"><em class="mi">y</em></strong>=<br/>[【y _ 1】，<br/>【y _ 2】，<br/>【y _ 3】，<br/> …，<br/>【y _ 10】。<br/>在这种情况下，相应的回归变量矩阵<strong class="la jk"> <em class="mi"> X </em> </strong>也恰好是一个10×1的矩阵，因为只涉及一个回归变量:<br/><strong class="la jk"><em class="mi">X</em></strong><em class="mi">=<br/>[[1]，<br/>【2】，<br/>【3】，<br/>【4】，<br/> …，<br/>【10】]。</em></p><p id="385e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为，<strong class="la jk"><em class="mi"/></strong>y是一个随机变量，具有spread <em class="mi"> m </em>，该图显示了对于每个值的<strong class="la jk"><em class="mi">X</em></strong><em class="mi">=</em><strong class="la jk"><em class="mi">X _ I</em></strong>，<strong class="la jk"><em class="mi"/></strong>y可以取其<em class="mi">期望值</em><em class="mi">附近的任何二项分布值)的<strong class="la jk"> <em class="mi"> x_i的</em> </strong>。因此，<em class="mi"> y_i </em>的期望值，即<em class="mi"> _i </em>，可以表示为<strong class="la jk"> <em class="mi"> x_i. </em> </strong>的某个函数</em></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="a7c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">二项式回归模型是广义线性模型家族的一部分。glm用于对响应变量<strong class="la jk"><em class="mi"/></strong>的<em class="mi">期望值</em>和解释变量向量<strong class="la jk"> <em class="mi"> X </em> </strong>的<em class="mi">线性组合</em>之间的关系进行建模。</p><p id="b480" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mi">E(</em><strong class="la jk"><em class="mi">y</em></strong><em class="mi">|</em><strong class="la jk"><em class="mi">X</em></strong><em class="mi">)</em>与<strong class="la jk"><em class="mi">×T120】</em></strong>之间的关系通过合适的<em class="mi">链接函数来表示，如</em>所示:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/96eaf066b491b887d1ad797ea12a2aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*sfdX9hDzhl-Loqg907Kfkg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="ffef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的等式中，<em class="mi"> g(。)</em>是将<strong class="la jk"> <em class="mi"> X </em> </strong> <em class="mi"> </em>上<strong class="la jk"> <em class="mi"> y </em> </strong>的<a class="ae jg" rel="noopener" target="_blank" href="/3-conditionals-every-data-scientist-should-know-1916d48b078a">条件期望</a>与回归变量<strong class="la jk"> <em class="mi"> x_i </em> </strong>的线性组合联系起来的链接函数。<strong class="la jk"> <em class="mi"> X </em> </strong>为大小为<em class="mi"> (n X p) </em>的回归变量矩阵，其中<em class="mi"> n= </em>行，每一行中的<em class="mi"> p= </em>回归变量，<strong class="la jk"><em class="mi">X</em></strong><em class="mi">=</em><strong class="la jk"><em class="mi">X _ I</em></strong>为该大小为(1 X p)的矩阵中第<em class="mi">与</em>行</p><p id="4b7e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当<strong class="la jk"><em class="mi">【y】</em></strong>为二项分布时，我们感兴趣的是确定<strong class="la jk"> <em class="mi">的条件期望与单次伯努利试验</em> </strong> <em class="mi">的概率π在</em><strong class="la jk"><em class="mi">X</em></strong><em class="mi">=</em><strong class="la jk"><em class="mi">X _ I</em></strong><em class="mi">、I。</em>所以二项式回归模型的GLM方程可以写成如下:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/3d3dc3d83769b381d2c93ce6fff14775.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*gWF2l2BD-To45Hdxi0NNYQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>)</p></figure><p id="d603" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在二项式回归模型的情况下，<strong class="la jk">链接函数<em class="mi"> g(。)</em></strong></p><p id="bf10" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">逻辑(logit)链接函数，也称为对数优势函数:</strong></p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/cb32d0e81453ca8b8c04b2d3ff7e0554.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*QJRwmCtarJUHC3gHgHkXAw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">物流环节功能(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="01c1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">逻辑函数被称为log-odds函数，因为它被表示为成功概率与失败概率的比值，即成功概率的对数。我们将在本文的后面使用这个链接函数。</p><p id="fdd1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">概率单位链接功能:</strong></p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/efd667e674b80a4db2583fa00b45b307.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*HK0GKX3fFQY_zWZlLfvoCA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">probit链接功能(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="481e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">probit(概率单位的缩写)链接函数用于模拟具有二元是/否结果的事件的发生。该链接函数被表示为累积分布函数φ的倒数。)的标准正态分布N(0，1)。</p><p id="74a3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Colin Cameron和Pravin K. Trivedi所著的《计数数据 的<a class="ae jg" href="http://cameron.econ.ucdavis.edu/racd/count.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">回归分析》一书很好地介绍了第3.6节<em class="mi">中的概率单位链接函数:有序和其他离散选择模型</em>。在那里，你还会发现一个非常清晰的推导，为什么Probit模型的链接函数恰好是CDF的逆函数。)的正态分布。</strong></a></p><p id="2a02" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">双对数函数:</strong></p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi on"><img src="../Images/5b8f75753cefcc562a1aa814e1ddd54d.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*F06aW-lwaydtZcPe5M1EXg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">日志-日志链接功能(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a></p></figure><p id="02f7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">双对数函数对于模拟“<a class="ae jg" rel="noopener" target="_blank" href="/the-poisson-process-everything-you-need-to-know-322aa0ab9e9a">泊松计数过程</a>非常有用，其中概率分布的参数(通常包含平均值)位于概率分布公式的指数中，<em class="mi">和</em>该参数也表示为回归变量线性组合的指数。因此，它具有双指数格式:exp(exp(—<strong class="la jk"><em class="mi">)β。x_i </em> </strong> <em class="mi"> ) </em>因此需要两个连续的对数运算来得到<strong class="la jk"> <em class="mi"> β。x_i </em> </strong>项下降到‘地平面’。</p><p id="e791" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">互补双对数链接功能:</strong></p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi on"><img src="../Images/0d056f705d5c4aef5b2f427c142490b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*ukQufWYOq5kBtq4VFChXgQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">互补的双对数链接功能(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="339f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之所以称之为互补对数对数，是因为它对<em class="mi"> (1-π_i) </em>(即故障概率)起作用，而不是对<em class="mi"> π_i. </em>起作用</p><p id="3db6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将使用<strong class="la jk">逻辑</strong>又名<strong class="la jk">逻辑</strong>又名<strong class="la jk">对数几率</strong>链接函数来构建我们的二项式回归模型。这又是一次，这一次表达方式略有不同。在R.H.S .上，我用粗体向量符号代替了求和:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/77ec487bbf3b0c4179b6b0572270cf6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*ekLmJ2NU_qfNjlNPi3mVDw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">log-odds链接功能(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f665" class="mq mr jj bd ms mt mu mv mw mx my mz na kp nb kq nc ks nd kt ne kv nf kw ng nh bi translated">第二节</h1><h2 id="5b23" class="ni mr jj bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">用二项式回归模型预测泰坦尼克号的生存几率</h2><p id="c9e3" class="pw-post-body-paragraph ky kz jj la b lb nu kk ld le nv kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">我们将使用<strong class="la jk"> Titanic数据集</strong>作为例子来理解适合二项式回归模型的用例种类。</p><p id="eaf0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个到<a class="ae jg" href="https://web.stanford.edu/class/archive/cs/cs109/cs109.1166/stuff/titanic.csv" rel="noopener ugc nofollow" target="_blank">原始数据集</a>的链接。</p><p id="88cf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">泰坦尼克号数据集包含了命运多舛的远洋客轮泰坦尼克号上2229名灵魂中的887人的信息。每个乘客的记录包含以下属性:</p><ul class=""><li id="6c25" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt of ma mb mc bi translated">名字</li><li id="32d8" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">乘客等级(1/2/3)</li><li id="f187" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">性</li><li id="6e4e" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">年龄</li><li id="caea" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">乘客是否由兄弟姐妹、父母或子女陪同</li><li id="23d5" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">他们付的车费，最重要的是，</li><li id="5e2f" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated"><strong class="la jk">他们是否幸存(1 =幸存，0 =死亡)</strong></li></ul><p id="d9af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用Python和<em class="mi"> Pandas </em>数据分析库，让我们将数据集加载到Pandas数据框中，并打印出前几行:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="7c30" class="ni mr jj oq b gy ou ov l ow ox"><strong class="oq jk">import </strong>pandas <strong class="oq jk">as </strong>pd</span><span id="e6ef" class="ni mr jj oq b gy oy ov l ow ox">df = pd.read_csv(<strong class="oq jk">'titanic_dataset.csv'</strong>, header=0)</span><span id="3572" class="ni mr jj oq b gy oy ov l ow ox">df.head(10)</span></pre><p id="6529" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将打印出以下输出:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/86ca798ec3e9f644626cd1b614fdfdaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*goeOhTpEFqMaTWQMNlAUVA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Titanic数据集的前10行(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="860b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将关注四个关键属性:</p><ul class=""><li id="082b" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt of ma mb mc bi translated">乘客等级</li><li id="8608" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">年龄</li><li id="73e4" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">性</li><li id="1fdf" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">幸存(他们是否幸存)</li></ul><p id="4c54" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从数据框中删除其余的列:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="0b9c" class="ni mr jj oq b gy ou ov l ow ox"><strong class="oq jk"><em class="mi">#Drop the columns that our model will not use<br/></em></strong>df = df.drop([<strong class="oq jk">'Name'</strong>,<strong class="oq jk">'Siblings/Spouses Aboard'</strong>, <strong class="oq jk">'Parents/Children Aboard'</strong>, <strong class="oq jk">'Fare'</strong>], axis=1)</span><span id="a817" class="ni mr jj oq b gy oy ov l ow ox"><strong class="oq jk"><em class="mi">#print the top 10 rows<br/></em></strong>df.head(10)</span></pre><p id="2101" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这会打印出以下内容:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/20e465a5a0fca5797d36f767e8c31170.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*BmsxEELyGfPwAe0IWzTcsA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">精简的Titanic数据集的前10行(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><h2 id="287c" class="ni mr jj bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">构建二项式回归模型的案例</h2><blockquote class="pb"><p id="99f3" class="pc pd jj bd pe pf pg ph pi pj pk lt dk translated">我们假设，当泰坦尼克号正在下沉时，<em class="pl">【阶级，年龄，性别】</em>的组合极大地影响了乘客的生还几率。</p></blockquote><p id="7a5b" class="pw-post-body-paragraph ky kz jj la b lb pm kk ld le pn kn lg lh po lj lk ll pp ln lo lp pq lr ls lt im bi translated">请注意，<em class="mi">‘幸存’</em>列包含一个[0，1]伯努利随机变量。</p><p id="7fd7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么我们可以说下面的话吗？</p><p id="add2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="mi">回归变量X</em></strong><em class="mi">=【p类别，年龄，性别】，</em>并且，</p><p id="d7b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="mi">因变量是布尔变量y </em> </strong> <em class="mi"> =【幸存】</em></p><p id="7877" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不，我们不能。让我们看看为什么…</p><h2 id="9657" class="ni mr jj bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">为什么不用Probit回归模型？</h2><p id="b089" class="pw-post-body-paragraph ky kz jj la b lb nu kk ld le nv kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">由于<strong class="la jk"> <em class="mi"> y </em> </strong>是一个布尔变量，因此使用<strong class="la jk">概率单位回归模型</strong>似乎是一个简单明了的例子。但是请注意，如果一个人不幸在泰坦尼克号这样的船上，他想知道的是<em class="mi">而不是</em>这个二元问题的答案:我会100%确定地活下来还是会100%确定地死去？相反，更有用的是知道生存几率。</p><p id="422e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果你是一名22岁的女性，在船的二等舱，你会想知道你的生存几率是1/10，1/4，1/50等等。</p><p id="427a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是在组织泰坦尼克号数据集的方式中，幸存的响应变量<strong class="la jk"><em class="mi"/></strong>具有是/否，即<strong class="la jk"> 1/0格式。</strong>换句话说，<em class="mi">幸存的</em>具有伯努利分布，即:</p><p id="38b7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mi"> Pr( </em> <strong class="la jk"> <em class="mi">幸存</em> </strong> <em class="mi"> =0) = </em> π <em class="mi">，<br/> Pr( </em> <strong class="la jk"> <em class="mi">幸存</em></strong><em class="mi">= 1)=(1-</em>π<em class="mi">)<br/></em>其中π是介于0和1之间的某个概率。</p><p id="fe4d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们想要的是让<strong class="la jk"> <em class="mi"> y </em> </strong>来表示几率，即在<em class="mi"> m </em>独立、相同的试验中，成功(存活)与失败(死亡)的比率。</p><p id="0b75" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mi">换句话说，我们要的是对于</em><strong class="la jk"><em class="mi"/></strong><em class="mi">y来说有一个</em> <strong class="la jk"> <em class="mi"> Log-Odds分布</em> </strong> <em class="mi">。</em></p><p id="0b37" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们不是使用真或假、1或0类型的概率单位回归模型，而是要建立一个二项式回归模型，其中响应变量是二项式分布的，链接函数是<strong class="la jk"> Logit </strong>，即log-odds函数。</p><p id="dd05" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">链接功能将允许我们将生存几率与回归变量<strong class="la jk"><em class="mi">×回归变量</em></strong><em class="mi">=【p class，Age&amp;Sex】</em>加截距的线性组合联系起来，如下所示:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/9a0e2c7932edb7bc44bcfcbd8665314d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*CiNl82NvO-qndhsCvK1wjA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="3c87" class="ni mr jj bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">如何将<em class="pl"> y </em>从伯努利变量转换为二项式变量:</h2><p id="a777" class="pw-post-body-paragraph ky kz jj la b lb nu kk ld le nv kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">要将响应变量<strong class="la jk"><em class="mi">【y】</em></strong>从伯努利转换为二项式，我们必须将具有相同组合<strong class="la jk"><em class="mi">×T58】</em></strong>值【Pclass，Age and Sex】的数据集行组合在一起。在我们着手做这件事之前，有一件小事我们需要注意，那就是年龄属性。你看，年龄，在数据集中的表达方式，是一个0.42到80的连续变量。</p><p id="7454" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分别为0.42岁和0.67岁的婴儿有不同的存活几率，这似乎不太可能。同样的逻辑也适用于26、27、28、29岁的年轻人。岁，其他情况以此类推。</p><p id="1923" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要使年龄数据更加细化，以便限制组的数量。让我们通过将整个年龄范围分成5岁大小的箱来实现这一点，并将每个箱标记如下:<br/> (0，5)→5<br/>(5，10)→10<br/>(10，15)→15等等。pandas.cut() 方法非常灵活:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="bb7f" class="ni mr jj oq b gy ou ov l ow ox"><strong class="oq jk">#define the bins<br/></strong>age_range_bins=[0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80]</span><span id="d0ff" class="ni mr jj oq b gy oy ov l ow ox"><strong class="oq jk">#define the label for each bin. Num labels = Num bins - 1<br/></strong>age_range_labels=[5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80]</span><span id="28cb" class="ni mr jj oq b gy oy ov l ow ox"><strong class="oq jk">#Cut up the age range into multiple bins and stuff them into a new Age_Range column<br/></strong>df[<strong class="oq jk">'Age_Range'</strong>]=pd.cut(df[<strong class="oq jk">'Age'</strong>],age_range_bins,labels=age_range_labels)</span><span id="0224" class="ni mr jj oq b gy oy ov l ow ox"><strong class="oq jk">#Print the output<br/></strong>df.head(10)</span></pre><p id="99a6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们得到以下输出。请注意我们添加的新<strong class="la jk"> Age_Range </strong>列:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/43ff0745dff2c455cd29e45fe7929d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*8IqZ_NUc4H-gBwKBdWwXfg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="581f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们删除年龄列，因为我们将使用年龄范围:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="1d3a" class="ni mr jj oq b gy ou ov l ow ox"><strong class="oq jk">#Drop the age column<br/></strong>df = df.drop([<strong class="oq jk">'Age'</strong>],axis=1)</span></pre><p id="77aa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经按照我们想要的方式设置了解释变量，让我们开始按照组合<em class="mi"> [Pclass，Sex，Age_Range]对样本进行分组。</em>我们先用熊猫<strong class="la jk"><em class="mi">group by()</em></strong><em class="mi"/>的方法。</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="8bb7" class="ni mr jj oq b gy ou ov l ow ox"><strong class="oq jk">#Group by ['Pclass', 'Sex', 'Age_Range'] <br/></strong>groups = df.<strong class="oq jk">groupby</strong>([<strong class="oq jk">'Pclass'</strong>, <strong class="oq jk">'Sex'</strong>, <strong class="oq jk">'Age_Range'</strong>])</span><span id="7610" class="ni mr jj oq b gy oy ov l ow ox"><strong class="oq jk">#Get the counts for each group. This is the number of passengers in each group who have survived<br/></strong>df_grouped_counts = groups.count()</span><span id="feab" class="ni mr jj oq b gy oy ov l ow ox"><strong class="oq jk">#Get the size (number of passengers) in each group<br/></strong>df_grouped_survived = groups.sum()</span></pre><p id="20d1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将每组的幸存者人数和乘客人数合并到每个分组数据框中。(我们马上会看到这对我们有什么帮助):</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="44cf" class="ni mr jj oq b gy ou ov l ow ox">df_grouped_counts.to_csv(<strong class="oq jk">'df_grouped_counts.csv'</strong>)<br/>df_grouped_counts_1 = pd.read_csv(<strong class="oq jk">'df_grouped_counts.csv'</strong>, header=0)<br/><br/>df_grouped_survived.to_csv(<strong class="oq jk">'df_grouped_survived.csv'</strong>)<br/>df_grouped_survived_1 = pd.read_csv(<strong class="oq jk">'df_grouped_survived.csv'</strong>, header=0)</span></pre><p id="ce5e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，让我们构建一个新的数据帧，它包含:</p><ul class=""><li id="44ac" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt of ma mb mc bi translated">分组的列Pclass、Sex、Age_Range，</li><li id="9bdb" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">每组中相应的幸存者数量，</li><li id="1d62" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">每组的乘客总数，即组的大小，</li><li id="ad4b" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">每组死亡的乘客人数。</li></ul><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="cec6" class="ni mr jj oq b gy ou ov l ow ox"><strong class="oq jk">#Create a new Data Frame<br/></strong>df_grouped = pd.DataFrame()</span><span id="a05c" class="ni mr jj oq b gy oy ov l ow ox"><strong class="oq jk">#Copy over the Pclass, Sex and Age Range columns<br/></strong>df_grouped[<strong class="oq jk">'Pclass'</strong>] = df_grouped_counts_1[<strong class="oq jk">'Pclass'</strong>]<br/>df_grouped[<strong class="oq jk">'Sex'</strong>] = df_grouped_counts_1[<strong class="oq jk">'Sex'</strong>]<br/>df_grouped[<strong class="oq jk">'Age_Range'</strong>] = df_grouped_counts_1[<strong class="oq jk">'Age_Range'</strong>]</span><span id="f484" class="ni mr jj oq b gy oy ov l ow ox"><strong class="oq jk">#Copy over the num passengers from the counts grouped Data Frame<br/></strong>df_grouped[<strong class="oq jk">'Total'</strong>] = df_grouped_counts_1[<strong class="oq jk">'Survived'</strong>]</span><span id="309c" class="ni mr jj oq b gy oy ov l ow ox"><strong class="oq jk">#Copy over the num survivors from the summation grouped Data Frame<br/></strong>df_grouped[<strong class="oq jk">'Survived'</strong>] = df_grouped_survived_1[<strong class="oq jk">'Survived'</strong>]</span><span id="d06f" class="ni mr jj oq b gy oy ov l ow ox"><strong class="oq jk">#Add a column containing the number who died<br/></strong>df_grouped[<strong class="oq jk">’Died’</strong>] = df_grouped[<strong class="oq jk">’Total’</strong>] - df_grouped[<strong class="oq jk">’Survived’</strong>]</span></pre><p id="6262" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们打印出分组数据集的前20行:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="5dd8" class="ni mr jj oq b gy ou ov l ow ox">df_grouped.head(20)</span></pre><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/66a4dccc2bd0f2756ab9133ef1b1688b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*74Qua3bSW0M6e4v_2-0JKg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">泰坦尼克号数据集的前20行按[阶级、性别、年龄范围]分组(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>)</p></figure><p id="4782" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看分组数据集告诉我们什么。为了便于说明，我突出显示了第9、14和19行:</p><p id="0094" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第9行中，我们发现有10名年龄在(45，50)范围内的女性拥有头等舱机票，其中9人幸存。因此，这组女性的生还几率相当高(9比1)，尤其是如果她住在头等舱的话。</p><p id="e6c8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第19排，我们看到有4名年龄在15- 20岁的男性乘客，其中只有一人幸存。</p><p id="5e8c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第14排，我们看到没有任何年龄(70-75岁)的女性乘客占据头等舱。这就是为什么我们在该组的汇总列中看到NaNs:[1，女性，75]。</p><p id="3fa6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从数据框中删除所有这样的NaN行:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="19fa" class="ni mr jj oq b gy ou ov l ow ox">df_grouped = df_grouped.dropna()</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="8faf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用Python和statsmodels构建二项式回归模型</p><p id="a739" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们构建二项式模型之前，让我们完成最后一项数据准备任务，即，用整数1和2替换“女性”和“男性”字符串:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="9caa" class="ni mr jj oq b gy ou ov l ow ox">df_grouped=df_grouped.replace(to_replace={<strong class="oq jk">'female'</strong>: 1, <strong class="oq jk">'male'</strong>: 2})</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="cf07" class="ni mr jj bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">使用Python和statsmodels构建二项式回归模型</h2><p id="1e85" class="pw-post-body-paragraph ky kz jj la b lb nu kk ld le nv kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">我们将使用statsmodels库提供的优秀支持来构建和训练二项式回归模型。</p><p id="7a4e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们划分出训练和测试数据集:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="8d1d" class="ni mr jj oq b gy ou ov l ow ox"><strong class="oq jk">import </strong>numpy <strong class="oq jk">as </strong>np</span><span id="52d4" class="ni mr jj oq b gy oy ov l ow ox"><strong class="oq jk"><em class="mi">#Separate out the training and test sets<br/></em></strong>mask = np.random.rand(len(df_grouped)) &lt; 0.85</span><span id="134d" class="ni mr jj oq b gy oy ov l ow ox">df_train = df_grouped[mask]</span><span id="355a" class="ni mr jj oq b gy oy ov l ow ox">df_test = df_grouped[~mask]</span></pre><p id="100b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用<a class="ae jg" href="https://patsy.readthedocs.io/en/latest/quickstart.html" rel="noopener ugc nofollow" target="_blank"><strong class="la jk"><em class="mi">patsy</em></strong></a><strong class="la jk"><em class="mi"/></strong>语法来设置回归模型的公式。我们在下面提到的公式中所说的是，因变量是由dataframe的<strong class="la jk"><em class="mi"/></strong><strong class="la jk"><em class="mi"/></strong>列组成的矩阵，而回归变量是<strong class="la jk"> <em class="mi"> Pclass </em> </strong>、<strong class="la jk"> <em class="mi"> Age_Range </em> </strong>和<strong class="la jk"> <em class="mi"> Sex </em> </strong>。</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="61fd" class="ni mr jj oq b gy ou ov l ow ox"><strong class="oq jk"><em class="mi">#Construct the Binomial model's regression formula in Patsy syntax.<br/></em></strong>formula = <strong class="oq jk">'Survived + Died ~ Pclass + Age_Range + Sex'</strong></span></pre><p id="7498" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用这个公式，让我们从我们一分钟前创建的训练和测试数据帧中雕刻出<strong class="la jk"> <em class="mi"> X </em> </strong>和<strong class="la jk"> <em class="mi"> y </em> </strong>设计矩阵:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="4f96" class="ni mr jj oq b gy ou ov l ow ox"><strong class="oq jk">from </strong>patsy <strong class="oq jk">import </strong>dmatrices</span><span id="5360" class="ni mr jj oq b gy oy ov l ow ox"><strong class="oq jk">#Carve out the training matrices from the training data frame using the regression formula<br/></strong>y_train, X_train = dmatrices(formula, df_train, return_type=<strong class="oq jk">'dataframe'</strong>)</span><span id="3eb8" class="ni mr jj oq b gy oy ov l ow ox"><strong class="oq jk">#Carve out the testing matrices from the testing data frame using the regression formula<br/></strong>y_test, X_test = dmatrices(formula, df_test, return_type=<strong class="oq jk">'dataframe'</strong>)</span></pre><p id="7904" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将<em class="mi"> X_train </em>和<em class="mi"> y_train </em>输入到二项式回归模型类的实例中，并训练模型:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="b1a8" class="ni mr jj oq b gy ou ov l ow ox"><strong class="oq jk">import</strong> statsmodels.api <strong class="oq jk">as</strong> sm</span><span id="bcf9" class="ni mr jj oq b gy oy ov l ow ox">binom_model = sm.<strong class="oq jk">GLM</strong>(y_train, X_train, <strong class="oq jk">family</strong>=sm.families.Binomial())</span><span id="c287" class="ni mr jj oq b gy oy ov l ow ox">binom_model_results = binom_model.fit()</span></pre><p id="9354" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们打印出适合的模型摘要:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="4700" class="ni mr jj oq b gy ou ov l ow ox">print(binom_model_results.summary())</span></pre><p id="bf30" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这会打印出以下内容:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pu"><img src="../Images/26a1077a581e20994a8da55d260f2dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5qaxb3UVlYqROvWGOoCEQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">二项式回归模型的训练结果(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><h2 id="8ad1" class="ni mr jj bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">如何解释回归结果:</h2><p id="d83f" class="pw-post-body-paragraph ky kz jj la b lb nu kk ld le nv kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">在上面的输出中，statsmodels告诉我们，它已经训练了一个类型为<strong class="la jk">二项式</strong>的<strong class="la jk">广义线性模型</strong>，因为我们要求它这样做，它使用了<strong class="la jk">对数比链接函数</strong>，并且使用了<a class="ae jg" href="https://en.wikipedia.org/wiki/Iteratively_reweighted_least_squares" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">迭代加权最小二乘(IRLS) </strong> </a>算法来训练我们的模型<strong class="la jk">。</strong></p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/ee78cfb02bd4611e595baadf26032608.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*xuIDILFhU4NNSZns3BzEkQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">GLM模型=二项式(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/178edad8974d8cd7d6517faaa011a54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*vVZqzXWmtA2moeSCAcXOUQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">链接函数= log-odds(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/dd0cc2eb2f2c73c4959b0692db74383d.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*vMTP7V3240V_B6fuiTv36w.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">训练算法= IRLS(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="250b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Statsmodels报告说我们的模型有3个自由度:<strong class="la jk"> <em class="mi">【性别、阶级和年龄范围】</em> </strong>，这似乎是正确的:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/f26f10892622782f7aac0a0dcee0cea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*vuMBT7McOc3wfbU2Kp4EMw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="f755" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于二项式模型，statsmodels为您计算三种拟合优度:<strong class="la jk">最大对数似然、偏差</strong>和<strong class="la jk">皮尔森卡方</strong>。我们不会进一步检查它们，因为这三个度量只有在比较两个或更多二项式回归模型的拟合优度时才有用，在这种情况下，我们没有用:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/f50fdf2d13d4d464b55f217c6e3e0692.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*iZ_owCPJizjUqU18c1UaVA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="60c3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看<strong class="la jk"> <em class="mi">装上</em> </strong>的系数:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi px"><img src="../Images/941e3703429c27a4f84cb3194ba522aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*SaNMTEA2iQDaPXZ6SuChHw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><em class="pl"> β_0，β_1，β_2，β_3 </em>(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="8250" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如p值所示，所有回归系数在0.1%的误差范围内具有统计显著性，所有p值均为&lt; 0.001:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi py"><img src="../Images/fa1bbf9db8cbce80fb122c6c29b2c241.png" data-original-src="https://miro.medium.com/v2/resize:fit:234/format:webp/1*XlTtWhy4j_mpaSClh64kpw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">p values (Image by <a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a></p></figure><p id="a0d2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看每个系数告诉我们什么。</p><h2 id="6bd6" class="ni mr jj bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">如何解释模型系数:</h2><p id="7d64" class="pw-post-body-paragraph ky kz jj la b lb nu kk ld le nv kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">对于logit link函数，拟合系数可解释如下:</p><p id="b50f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">年龄范围:</strong>其系数为-0.0446。请注意负值。解释这个系数的方法是，保持所有其他变量不变，<strong class="la jk">乘客年龄每增加一个单位，他们生存的几率<em class="mi">减少</em>一个因子= exp(-0.0446) = 0.9564。</strong>即乘客的年龄每增加一个单位，需要将他们的生存几率乘以0.9564，从而每次将生存几率减少一定的量。例如，如果二等舱的12岁男性乘客在灾难中的已知生存几率为8:9，那么二等舱的22岁男性乘客的生存几率为(8/9) * 0.9564 ⁰ =大约6:10。</p><p id="48e2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">Pclass:</strong>Pclass的系数为-1.2008。再次注意负号。乘客舱等的降级对乘客在泰坦尼克号上的生还几率有着更加戏剧性的影响。Pclass变量编码为一等舱=1，二等舱=2，三等舱=3。<strong class="la jk">因此，客舱等级每增加一个单位<em class="mi"/>，即从一等舱下降<em class="mi">到二等舱再到三等舱</em>，在保持年龄和性别不变的情况下，生存几率会降低exp(-1.2008) = 0.30的系数！</strong>也就是说，每降一个单位，你的生存几率就会乘以0.30。例如，如果一个30岁的男性乘客在泰坦尼克号上有7 : 9的生存几率，只要将他降一级到2级，他的生存几率就降低到(7/9)*0.3 =大约1:4。将等级进一步降低到第三等级会将几率降低到(7/9)*0.3*0.3 = 7 : 100。</p><p id="5878" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">性别:</strong>最后，注意性别变量的非常大的负系数-2.6526。在沉没的泰坦尼克号上，与女乘客相比，男乘客生还的机会非常渺茫。保持Pclass和年龄不变，<strong class="la jk">男性乘客的生还几率仅为女性乘客的exp(-2.6526)= 7%</strong>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="6919" class="ni mr jj bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">预言；预测；预告</h2><p id="d683" class="pw-post-body-paragraph ky kz jj la b lb nu kk ld le nv kn lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">回想一下，我们已经将测试数据集放在数据帧<em class="mi"> df_test </em>中。是时候在这个数据集上测试我们模型的性能了。为此，我们将首先向测试数据帧添加一个<em class="mi">幸存百分比</em>列，我们将要求我们的模型预测其值:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="12f9" class="ni mr jj oq b gy ou ov l ow ox">df_test['Pcnt_Survived'] = df_test['Survived']/df_test['Total']</span></pre><p id="a5fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用<strong class="la jk"> <em class="mi">。</em>predict()</strong>方法对结果对象和通过测试的数据集得到预测的存活率:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="3853" class="ni mr jj oq b gy ou ov l ow ox">predicted_survival_rate = binom_model_results.predict(X_test)</span></pre><p id="1e25" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们绘制实际存活率与预测存活率的对比图:</p><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="6d8b" class="ni mr jj oq b gy ou ov l ow ox"><strong class="oq jk">import </strong>matplotlib.pyplot <strong class="oq jk">as </strong>plt</span><span id="132d" class="ni mr jj oq b gy oy ov l ow ox">plt.xlabel(<strong class="oq jk">'Actual Survival Rate'</strong>)<br/>plt.ylabel(<strong class="oq jk">'Predicted Survival Rate'</strong>)</span><span id="b017" class="ni mr jj oq b gy oy ov l ow ox">plt.scatter(df_test['Pcnt_Survived'], predicted_survival_rate, color = <strong class="oq jk">'blue'</strong>)</span><span id="1af1" class="ni mr jj oq b gy oy ov l ow ox">plt.show()</span></pre><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/37784a6103aba24e178446635d1ad2e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*q_UjTbJbiupTeFrCn0L_Dg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">实际存活率与预测存活率(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="3b66" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，当存活率接近该范围的上限(即1.0)时，拟合变得不可接受。在很大程度上，预测的准确性取决于样本大小，即每组乘客的大小，按元组[类别、性别、年龄范围]分组。对于训练集中的某些组，组大小太小，模型无法以有意义的方式进行训练。对于测试数据集中的这种组合，精确度会很低，这是可以理解的。</p><p id="6b1f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是完整源代码的链接:</p><figure class="oa ob oc od gt iv"><div class="bz fp l di"><div class="qa qb l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">二项式_回归. py</p></figure><p id="7b01" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里是本文中使用的Titanic数据集的<a class="ae jg" href="https://gist.github.com/sachinsdate/8b212e2c589a70910dfd04fae7d0f788" rel="noopener ugc nofollow" target="_blank">链接。</a></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="6090" class="ni mr jj bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">摘要</h2><ul class=""><li id="aec4" class="lu lv jj la b lb nu le nv lh qc ll qd lp qe lt of ma mb mc bi translated">二项式回归模型可以用来预测事件发生的几率。</li><li id="6239" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">二项式回归模型是广义线性模型家族中的一员，它使用合适的链接函数来建立响应变量<strong class="la jk"> <em class="mi"> y </em> </strong>的条件预期与解释变量<strong class="la jk"> <em class="mi"> X </em> </strong>的线性组合之间的关系。</li><li id="34c3" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">在二项式回归模型中，我们通常使用对数优势函数作为连接函数。</li><li id="e578" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt of ma mb mc bi translated">逻辑回归模型是二项式回归模型的一种特殊情况，在这种情况下，数据集中每组解释变量的大小为一。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="66d6" class="ni mr jj bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">进一步阅读</h2><div class="is it gp gr iu qf"><a rel="noopener follow" target="_blank" href="/3-conditionals-every-data-scientist-should-know-1916d48b078a"><div class="qg ab fo"><div class="qh ab qi cl cj qj"><h2 class="bd jk gy z fp qk fr fs ql fu fw ji bi translated">每个数据科学家都应该知道的3个条件</h2><div class="qm l"><h3 class="bd b gy z fp qk fr fs ql fu fw dk translated">条件期望、条件概率和条件方差:回归建模者的实践见解</h3></div><div class="qn l"><p class="bd b dl z fp qk fr fs ql fu fw dk translated">towardsdatascience.com</p></div></div><div class="qo l"><div class="qp l qq qr qs qo qt ja qf"/></div></div></a></div><pre class="oa ob oc od gt op oq or os aw ot bi"><span id="1622" class="ni mr jj oq b gy ou ov l ow ox"><a class="ae jg" href="https://www.crcpress.com/Generalized-Linear-Models/McCullagh-Nelder/p/book/9780412317606" rel="noopener ugc nofollow" target="_blank">McCullough, P., Nelder, J. A. (FRS). <strong class="oq jk">Generalized Linear Models</strong>. 2nd Ed. (1989) Chapman &amp; Hall</a></span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="9289" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mi">感谢阅读！我写关于数据科学的主题。如果你喜欢这篇文章，请关注我的</em><a class="ae jg" href="https://timeseriesreasoning.medium.com" rel="noopener"><strong class="la jk"><em class="mi">Sachin Date</em></strong></a><em class="mi">以获得关于如何使用Python进行数据科学的信息、见解和编程建议。</em></p></div></div>    
</body>
</html>