<html>
<head>
<title>Clustering Geospatial Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聚类地理空间数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/clustering-geospatial-data-f0584f0b04ec?source=collection_archive---------1-----------------------#2020-08-04">https://towardsdatascience.com/clustering-geospatial-data-f0584f0b04ec?source=collection_archive---------1-----------------------#2020-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bf7a59d41b19f964ce71b34753c515bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LgqxDMP5qD1HE_uM33zZrg.png"/></div></div></figure><div class=""/><div class=""><h2 id="ce47" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">使用交互式地图绘制机器学习和深度学习聚类</h2></div><h2 id="6fc0" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">摘要</h2><p id="8ff6" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">在本文中，我将使用数据科学和 Python，展示如何将不同的聚类算法应用于地理空间数据，以解决零售合理化业务案例。</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mi"><img src="../Images/06845dad056d8611e7147ea2b90b7751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HVqgJmxiSK2Z9Mswe_niUg.gif"/></div></div></figure><p id="efa8" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated"><a class="ae ms" href="https://www.investopedia.com/terms/r/rationalization.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="lr jf">门店合理化</strong> </a>是公司为了提高经营效率，降低成本而进行的重组。由于 T4 和新冠肺炎的危机，世界各地的几家零售企业正在关闭店铺。这并不仅仅是金融危机的症状，事实上许多公司已经将投资集中在使他们的业务更加数字化上。</p><p id="2921" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated"><a class="ae ms" href="https://en.wikipedia.org/wiki/Cluster_analysis" rel="noopener ugc nofollow" target="_blank"> <strong class="lr jf">聚类</strong> </a> <strong class="lr jf"> </strong>是对一组对象进行分组的任务，使同一组中的观察值彼此之间比其他组中的观察值更相似。这是<a class="ae ms" href="https://en.wikipedia.org/wiki/Unsupervised_learning" rel="noopener ugc nofollow" target="_blank">无监督学习</a>(没有目标变量时的机器学习)最受欢迎的应用之一。</p><p id="9d8d" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated"><a class="ae ms" href="https://en.wikipedia.org/wiki/Spatial_analysis" rel="noopener ugc nofollow" target="_blank"> <strong class="lr jf">地理空间分析</strong> </a>是处理卫星图像、GPS 坐标和街道地址以应用于地理模型的数据科学领域。</p><p id="8030" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">在本文中，我将使用地理数据聚类来解决零售合理化问题。我将展示一些有用的 Python 代码，这些代码可以很容易地应用于其他类似的情况(只需复制、粘贴、运行)，并通过注释遍历每一行代码，以便您可以复制这个示例(下面是完整代码的链接)。</p><div class="is it gp gr iu mt"><a href="https://github.com/mdipietro09/DataScience_ArtificialIntelligence_Utils/blob/master/machine_learning/example_clustering.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jf gy z fp my fr fs mz fu fw jd bi translated">mdipietro 09/data science _ 人工智能 _ 实用工具</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">permalink dissolve GitHub 是超过 5000 万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">github.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh ja mt"/></div></div></a></div><p id="f8a0" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">我将使用"<strong class="lr jf"> Starbucks Stores dataset </strong>"提供所有正在运营的商店的位置(下面的链接)。我将选择一个特定的地理区域，除了所提供的纬度和经度之外，我将模拟数据集中每个商店的一些业务信息(成本、容量、员工)。</p><div class="is it gp gr iu mt"><a href="https://www.kaggle.com/starbucks/store-locations" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jf gy z fp my fr fs mz fu fw jd bi translated">星巴克在全球的位置</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">运营中的每家星巴克店的名称、所有权类型和位置</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">www.kaggle.com</p></div></div><div class="nc l"><div class="ni l ne nf ng nc nh ja mt"/></div></div></a></div><p id="1872" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">特别是，我将经历:</p><ul class=""><li id="f7cb" class="nj nk je lr b ls mn lv mo lc nl lg nm lk nn mh no np nq nr bi translated">设置:导入包，读取地理数据，创建业务功能。</li><li id="019c" class="nj nk je lr b ls ns lv nt lc nu lg nv lk nw mh no np nq nr bi translated">数据分析:用<em class="nx">叶子</em>和<em class="nx"> geopy </em>在地图上展示商业案例。</li><li id="e694" class="nj nk je lr b ls ns lv nt lc nu lg nv lk nw mh no np nq nr bi translated">聚类:用<em class="nx"> scikit-learn </em>的机器学习(K-Means / Affinity Propagation)，用<em class="nx"> minisom </em>的深度学习(自组织映射)。</li><li id="d678" class="nj nk je lr b ls ns lv nt lc nu lg nv lk nw mh no np nq nr bi translated">商店合理化:构建确定性算法来解决业务案例。</li></ul></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h2 id="9f58" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">设置</h2><p id="862d" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">首先，我需要导入以下包。</p><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="0da6" class="kt ku je og b gy ok ol l om on"><strong class="og jf">## for data</strong><br/>import <strong class="og jf">numpy </strong>as np<br/>import <strong class="og jf">pandas </strong>as pd</span><span id="2f90" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## for plotting</strong><br/>import <strong class="og jf">matplotlib</strong>.pyplot as plt<br/>import <strong class="og jf">seaborn </strong>as sns</span><span id="59f0" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## for geospatial</strong><br/>import <strong class="og jf">folium</strong><br/>import <strong class="og jf">geopy</strong></span><span id="af78" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## for machine learning</strong><br/>from <strong class="og jf">sklearn </strong>import preprocessing, cluster<br/>import <strong class="og jf">scipy</strong></span><span id="8c9e" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## for deep learning</strong><br/>import <strong class="og jf">minisom</strong></span></pre><p id="91d8" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">然后我将把数据读入一个熊猫数据帧。</p><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="b915" class="kt ku je og b gy ok ol l om on">dtf = pd.read_csv('data_stores.csv')</span></pre><p id="28ae" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">原始数据集包含超过 5，000 个城市和 25，000 家商店，但是出于本教程的目的，我将只处理一个城市。</p><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="a718" class="kt ku je og b gy ok ol l om on">filter = <strong class="og jf">"Las Vegas"</strong></span><span id="7169" class="kt ku je og b gy oo ol l om on">dtf = dtf[dtf["City"]==filter][["City","Street Address","Longitude","Latitude"]].reset_index(drop=True)</span><span id="15de" class="kt ku je og b gy oo ol l om on">dtf = dtf.reset_index().rename(columns={"index":"id"})<br/>dtf.head()</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/42ef6d1ef8b11a8af25397d23d83c175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hJ7ECkivXOysFCM0k37bSA.png"/></div></div></figure><p id="3495" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">在那个地区，有 156 家商店。为了继续进行业务案例，我将<strong class="lr jf">模拟每个商店的一些信息</strong>:</p><ul class=""><li id="53a3" class="nj nk je lr b ls mn lv mo lc nl lg nm lk nn mh no np nq nr bi translated"><em class="nx">潜在能力</em>:员工的总能力(例如，10 表示商店最多可容纳 10 名员工)</li><li id="5fca" class="nj nk je lr b ls ns lv nt lc nu lg nv lk nw mh no np nq nr bi translated"><em class="nx">员工</em>:当前员工级别(如 7 表示该店目前有 7 名员工在运营)</li><li id="a02c" class="nj nk je lr b ls ns lv nt lc nu lg nv lk nw mh no np nq nr bi translated"><em class="nx">容量</em>:当前剩余容量(如 10–7 = 3，商店仍可容纳 3 名员工)</li><li id="46b5" class="nj nk je lr b ls ns lv nt lc nu lg nv lk nw mh no np nq nr bi translated"><em class="nx">成本</em>:公司维持店铺运营的年度成本(<em class="nx">低</em>、<em class="nx">中</em>、<em class="nx">高</em>)</li></ul><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="9309" class="kt ku je og b gy ok ol l om on">dtf["<strong class="og jf">Potential</strong>"] = np.random.randint(low=3, high=10+1, size=len(dtf))</span><span id="3779" class="kt ku je og b gy oo ol l om on">dtf["<strong class="og jf">Staff</strong>"] = dtf["<strong class="og jf">Potential</strong>"].apply(lambda x: int(np.random.rand()*x)+1)</span><span id="fb3a" class="kt ku je og b gy oo ol l om on">dtf["<strong class="og jf">Capacity</strong>"] = dtf["<strong class="og jf">Potential</strong>"] - dtf["<strong class="og jf">Staff</strong>"]</span><span id="8255" class="kt ku je og b gy oo ol l om on">dtf["<strong class="og jf">Cost</strong>"] = np.random.choice(["high","medium","low"], size=len(dtf), p=[0.4,0.5,0.1])</span><span id="7825" class="kt ku je og b gy oo ol l om on">dtf.head()</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/267f82732ea0a0a4bf3379c317c1301e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sdx91gEttdPnVrXged1r0w.png"/></div></div></figure><p id="2746" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">请注意，这只是一个模拟，这些数字是随机产生的，并不真正反映星巴克(或任何其他公司)的业务。</p><p id="dcf0" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">现在一切都准备好了，我将从分析业务案例开始，然后构建一个聚类模型和一个合理化算法。</p><p id="88ac" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">我们开始吧，好吗？</p><h2 id="c646" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">数据分析</h2><p id="1e83" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">假设我们拥有一家零售企业，我们不得不关闭一些商店。我们希望在不裁员的情况下实现利润最大化(通过成本最小化)。</p><p id="2887" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">费用分配如下:</p><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="5e4f" class="kt ku je og b gy ok ol l om on"><strong class="og jf">x = "Cost"</strong></span><span id="d4f8" class="kt ku je og b gy oo ol l om on">ax = dtf[x].value_counts().sort_values().plot(kind="barh")<br/>totals = []<br/>for i in ax.patches:<br/>    totals.append(i.get_width())<br/>total = sum(totals)<br/>for i in ax.patches:<br/>     ax.text(i.get_width()+.3, i.get_y()+.20, <br/>     str(round((i.get_width()/total)*100, 2))+'%', <br/>     fontsize=10, color='black')<br/>ax.grid(axis="x")<br/>plt.suptitle(x, fontsize=20)<br/>plt.show()</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/1cb427ea76c7b2d1046923ce09d1a743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPqeXUSnhZwAlS0BTcHKiQ.png"/></div></div></figure><p id="185c" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">目前，只有一小部分商店在满负荷运转(剩余容量= 0)，这意味着有些商店的员工数量很少(剩余容量很高):</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/2426d6b3aaf3c8ae160d684fc812d8a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhS_uIuZ9BMeC0bx3UUSYQ.png"/></div></div></figure><p id="4272" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">让我们把这些信息在地图上形象化。首先，我需要获得地理区域的坐标来启动地图。我会用<a class="ae ms" href="https://geopy.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> <em class="nx"> geopy </em> </a>来做:</p><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="0376" class="kt ku je og b gy ok ol l om on">city = <strong class="og jf">"Las Vegas"</strong></span><span id="1a88" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## get location</strong><br/>locator = geopy.<strong class="og jf">geocoders</strong>.<strong class="og jf">Nominatim</strong>(user_agent="MyCoder")<br/>location = locator.geocode(city)<br/>print(location)</span><span id="5ad2" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## keep latitude and longitude only</strong><br/>location = [location.latitude, location.longitude]<br/>print("[lat, long]:", location)</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/e08c0c0acda6ef8cddbeac90b0eca1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i6ocU0wB-sv98snwjy3YxA.png"/></div></div></figure><p id="6144" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">我将使用<a class="ae ms" href="https://python-visualization.github.io/folium/quickstart.html#Getting-Started" rel="noopener ugc nofollow" target="_blank"><em class="nx"/></a><em class="nx"/>创建地图，这是一个非常方便的包，允许我们绘制交互式地图，而无需加载<a class="ae ms" href="https://en.wikipedia.org/wiki/Shapefile" rel="noopener ugc nofollow" target="_blank"> shapefile </a>。每个商店应通过一个点来识别，该点的大小与其当前的员工人数成比例，颜色基于其成本。我还将向默认地图添加一小段 HTML 代码来显示图例。</p><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="1048" class="kt ku je og b gy ok ol l om on">x, y = <strong class="og jf">"Latitude", "Longitude"</strong><br/>color =<strong class="og jf"> "Cost"<br/></strong>size =<strong class="og jf"> "Staff"<br/></strong>popup =<strong class="og jf"> "Street Address"</strong><br/>data = dtf.copy()</span><span id="2043" class="kt ku je og b gy oo ol l om on"><strong class="og jf"><br/>## create color column</strong><br/>lst_colors=["red","green","orange"]<br/>lst_elements = sorted(list(dtf[color].unique()))<br/>data["color"] = data[color].apply(lambda x: <br/>                lst_colors[lst_elements.index(x)])</span><span id="97d4" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## create size column (scaled)</strong><br/>scaler = preprocessing.MinMaxScaler(feature_range=(3,15))<br/>data["size"] = scaler.fit_transform(<br/>               data[size].values.reshape(-1,1)).reshape(-1)</span><span id="0fa3" class="kt ku je og b gy oo ol l om on"><strong class="og jf"><br/>## initialize the map with the starting location<br/></strong>map_ = folium.<strong class="og jf">Map</strong>(location=location, tiles="cartodbpositron",<br/>                  zoom_start=11)</span><span id="2d3f" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## add points</strong><br/>data.apply(lambda row: folium.<strong class="og jf">CircleMarker</strong>(<br/>           location=[row[x],row[y]], popup=row[popup],<br/>           color=row["color"], fill=True,<br/>           radius=row["size"]).add_to(map_), axis=1)</span><span id="0e8d" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## add html legend<br/></strong>legend_html = """&lt;div style="position:fixed; bottom:10px; left:10px; border:2px solid black; z-index:9999; font-size:14px;"&gt;&amp;nbsp;&lt;b&gt;"""+color+""":&lt;/b&gt;&lt;br&gt;"""<br/>for i in lst_elements:<br/>     legend_html = legend_html+"""&amp;nbsp;&lt;i class="fa fa-circle <br/>     fa-1x" style="color:"""+<strong class="og jf">lst_colors[lst_elements.index(i)]</strong>+""""&gt;<br/>     &lt;/i&gt;&amp;nbsp;"""+str(i)+"""&lt;br&gt;"""<br/>legend_html = legend_html+"""&lt;/div&gt;"""</span><span id="4947" class="kt ku je og b gy oo ol l om on">map_.get_root().<strong class="og jf">html.add_child</strong>(folium.<strong class="og jf">Element</strong>(legend_html))</span><span id="4112" class="kt ku je og b gy oo ol l om on"><strong class="og jf"><br/>## plot the map</strong><br/>map_</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ou"><img src="../Images/a8e452147b98d2eb2ce8bd92862417a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VdecXRu4Sf3VeYTubGEFmg.gif"/></div></div></figure><p id="b27f" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">我们的目标是尽可能多地关闭高成本商店(红点),将员工转移到位于同一社区的低成本商店(绿点)。因此，我们将最大化利润(通过关闭高成本商店)和效率(通过让低成本商店满负荷工作)。</p><p id="fcf5" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">我们如何在不选择距离阈值和地理边界的情况下定义邻域？嗯，答案是……集群。</p><h2 id="9d62" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">使聚集</h2><p id="f640" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">有几种算法可以使用，这里列出了主要的<a class="ae ms" href="https://scikit-learn.org/stable/modules/clustering.html" rel="noopener ugc nofollow" target="_blank">和</a>。我将尝试 K-Means、相似性传播、自组织映射。</p><p id="2b53" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated"><a class="ae ms" href="https://en.wikipedia.org/wiki/K-means_clustering" rel="noopener ugc nofollow" target="_blank"> <strong class="lr jf"> K-Means </strong> </a>旨在将观察值划分为预定义数量的聚类(<em class="nx"> k </em>)，其中每个点属于具有最近均值的聚类。它首先随机选择 k 个质心并将这些点分配给最近的聚类，然后用聚类中所有点的平均值更新每个质心。当您需要获得精确的组数时，这种算法很方便(例如，保持最小数量的运营商店)，并且它更适合于少量的偶数聚类。</p><p id="b142" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">这里，为了定义正确的 k，我将使用<a class="ae ms" href="https://en.wikipedia.org/wiki/Elbow_method_(clustering)" rel="noopener ugc nofollow" target="_blank">肘方法</a>:绘制方差作为集群数量的函数，并选择使曲线变平的<em class="nx"> k </em>。</p><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="3b13" class="kt ku je og b gy ok ol l om on">X = dtf[[<strong class="og jf">"Latitude","Longitude"</strong>]]<strong class="og jf"><br/></strong>max_k =<strong class="og jf"> 10</strong></span><span id="4110" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## iterations</strong><br/>distortions = [] <br/>for i in range(1, max_k+1):<br/>    if len(X) &gt;= i:<br/>       model = cluster.KMeans(n_clusters=i, init='k-means++', max_iter=300, n_init=10, random_state=0)<br/>       model.fit(X)<br/>       distortions.append(model.inertia_)</span><span id="ac43" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## best k: the lowest derivative</strong><br/>k = [i*100 for i in np.diff(distortions,2)].index(min([i*100 for i <br/>     in np.diff(distortions,2)]))</span><span id="17ae" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## plot</strong><br/>fig, ax = plt.subplots()<br/>ax.plot(range(1, len(distortions)+1), distortions)<br/>ax.axvline(k, ls='--', color="red", label="k = "+str(k))<br/>ax.set(title='The Elbow Method', xlabel='Number of clusters', <br/>       ylabel="Distortion")<br/>ax.legend()<br/>ax.grid(True)<br/>plt.show()</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/76abaf213da6cf5f5d46e91c012819b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aMKJFRAA6NiaYYipTnNHKA.png"/></div></div></figure><p id="7fe8" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">我们可以尝试使用<em class="nx"> k = 5 </em>，这样 K-Means 算法将找到 5 个理论质心。此外，我还将确定真正的质心(离聚类中心最近的观测值)。</p><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="477e" class="kt ku je og b gy ok ol l om on">k = 5<br/>model = cluster.<strong class="og jf">KMeans</strong>(n_clusters=k, init='k-means++')<br/>X = dtf[[<strong class="og jf">"Latitude","Longitude"</strong>]]</span><span id="0d1d" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## clustering</strong><br/>dtf_X = X.copy()<br/>dtf_X["cluster"] = model.fit_predict(X)</span><span id="4b0b" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## find real centroids</strong><br/>closest, distances = scipy.<strong class="og jf">cluster.vq.vq</strong>(model.cluster_centers_, <br/>                     dtf_X.drop("cluster", axis=1).values)<br/>dtf_X["centroids"] = 0<br/>for i in closest:<br/>    dtf_X["centroids"].iloc[i] = 1</span><span id="5ab3" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## add clustering info to the original dataset<br/></strong>dtf[["<strong class="og jf">cluster</strong>","<strong class="og jf">centroids</strong>"]] = dtf_X[["<strong class="og jf">cluster</strong>","<strong class="og jf">centroids</strong>"]]<br/>dtf.sample(5)</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/fdb7804b8ba623291ae3136c999fb151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*soLpnEdBeePzLNG_WkiQ2Q.png"/></div></div></figure><p id="819f" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">我向数据集添加了两列:"<em class="nx"> cluster </em>"表示观察值属于哪个簇，以及"<em class="nx"> centroids </em>"如果观察值也是质心(最靠近中心)，则为 1，否则为 0。让我们计划一下:</p><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="9c30" class="kt ku je og b gy ok ol l om on"><strong class="og jf">## plot</strong><br/>fig, ax = plt.subplots()<br/>sns.<strong class="og jf">scatterplot</strong>(x="Latitude", y="Longitude", data=dtf, <br/>                palette=sns.color_palette("bright",k),<br/>                hue='cluster', size="centroids", size_order=[1,0],<br/>                legend="brief", ax=ax).set_title('Clustering <br/>                (k='+str(k)+')')</span><span id="50ec" class="kt ku je og b gy oo ol l om on">th_centroids = model.cluster_centers_<br/>ax.scatter(th_centroids[:,0], th_centroids[:,1], s=50, c='black', <br/>           marker="x")</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/f0d1e59050b55f194d3028fa663a709a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ighr6bQcNEwvnhRXHvC3mA.png"/></div></div></figure><p id="0e0b" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated"><a class="ae ms" href="https://en.wikipedia.org/wiki/Affinity_propagation" rel="noopener ugc nofollow" target="_blank"> <strong class="lr jf">相似性传播</strong> </a>是一种基于图形的算法，将每个观察值分配给其最近的样本。基本上，所有的观察“投票”给它们想要关联的其他观察，这导致将整个数据集划分成大量不均匀的聚类。当您不能指定簇的数量时，这是非常方便的，并且它适用于地理空间数据，因为它可以很好地处理非平面几何。</p><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="0ca2" class="kt ku je og b gy ok ol l om on">model = cluster.<strong class="og jf">AffinityPropagation</strong>()</span></pre><p id="8bff" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">使用之前的相同代码，您可以拟合模型(找到 12 个簇)，并且您可以使用下面的代码来绘图(不同之处在于<em class="nx"> k </em>在开始时没有声明，并且没有理论上的质心):</p><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="089c" class="kt ku je og b gy ok ol l om on">k = dtf["cluster"].nunique()</span><span id="daba" class="kt ku je og b gy oo ol l om on">sns.<strong class="og jf">scatterplot</strong>(x="Latitude", y="Longitude", data=dtf, <br/>                palette=sns.color_palette("bright",k),<br/>                hue='cluster', size="centroids", size_order=[1,0],<br/>                legend="brief").set_title('Clustering <br/>                (k='+str(k)+')')</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/f8f33cec2b0349d1e14c450ab26b1ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mj5tzTu6gS-f-pK4RnEOkQ.png"/></div></div></figure><p id="8bf8" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated"><a class="ae ms" href="https://en.wikipedia.org/wiki/Self-organizing_map" rel="noopener ugc nofollow" target="_blank"> <strong class="lr jf">自组织地图</strong> </a> (SOMs)由于使用深度学习而大不相同。事实上，SOM 是一种人工神经网络，它使用无监督学习进行训练，以产生输入空间的低维表示，称为“地图”(也称为<a class="ae ms" href="https://en.wikipedia.org/wiki/Hybrid_Kohonen_self-organizing_map" rel="noopener ugc nofollow" target="_blank"> Kohonen 层</a>)。基本上，输入连接到形成映射的<em class="nx"> n x m </em>神经元，然后为每个观察计算“获胜”神经元(最近的)，并使用横向距离将神经元聚集在一起。这里，我将尝试使用 4x4 SOM:</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/5acf999105970a46b2ea0c2175bd7c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pwaWkZMX-PrEGHImTboI2g.png"/></div></div></figure><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="7a88" class="kt ku je og b gy ok ol l om on">X = dtf[[<strong class="og jf">"Latitude","Longitude"</strong>]]<br/>map_shape = <strong class="og jf">(4,4)</strong></span><span id="7d45" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## scale data</strong><br/>scaler = preprocessing.<strong class="og jf">StandardScaler</strong>()<br/>X_preprocessed = scaler.fit_transform(X.values)</span><span id="5966" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## clustering<br/></strong>model = minisom.<strong class="og jf">MiniSom</strong>(x=map_shape[0], y=map_shape[1], <br/>                        input_len=X.shape[1])<br/>model.train_batch(X_preprocessed, num_iteration=100, verbose=False)</span><span id="2023" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## build output dataframe</strong><br/>dtf_X = X.copy()<br/>dtf_X["cluster"] = np.<strong class="og jf">ravel_multi_index</strong>(np.array(<br/>      [model.winner(x) for x in X_preprocessed]).T, dims=map_shape)</span><span id="b3eb" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## find real centroids<br/></strong>cluster_centers = np.array([vec for center in model.get_weights() <br/>                            for vec in center])</span><span id="9a3d" class="kt ku je og b gy oo ol l om on">closest, distances = scipy.<strong class="og jf">cluster.vq.vq</strong>(model.cluster_centers_, <br/>                                         X_preprocessed)<br/>dtf_X["centroids"] = 0<br/>for i in closest:<br/>    dtf_X["centroids"].iloc[i] = 1</span><span id="4ce9" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## add clustering info to the original dataset<br/></strong>dtf[["cluster","centroids"]] = dtf_X[["cluster","centroids"]]</span><span id="911a" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## plot<br/></strong>k = dtf["cluster"].nunique()</span><span id="f75d" class="kt ku je og b gy oo ol l om on">fig, ax = plt.subplots()<br/>sns.<strong class="og jf">scatterplot</strong>(x="Latitude", y="Longitude", data=dtf, <br/>                palette=sns.color_palette("bright",k),<br/>                hue='cluster', size="centroids", size_order=[1,0],<br/>                legend="brief", ax=ax).set_title('Clustering <br/>                (k='+str(k)+')')</span><span id="ddd5" class="kt ku je og b gy oo ol l om on">th_centroids = scaler.inverse_transform(cluster_centers)<br/>ax.scatter(th_centroids[:,0], th_centroids[:,1], s=50, c='black', <br/>           marker="x")</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/0044c3d7e7fa929b4edbaf449e7ca658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Hu2EeU8jcYV_Jl3KMUMGQ.png"/></div></div></figure><p id="196a" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">独立于您用来对数据进行聚类的算法，现在您有了一个多了两列的数据集("<em class="nx"> cluster </em>"，"<em class="nx"> centroids </em>")。我们可以用它来可视化地图上的星团，这次我也要用一个标记来显示质心。</p><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="9268" class="kt ku je og b gy ok ol l om on">x, y = <strong class="og jf">"Latitude", "Longitude"</strong><br/>color =<strong class="og jf"> "cluster"<br/></strong>size =<strong class="og jf"> "Staff"<br/></strong>popup =<strong class="og jf"> "Street Address"<br/></strong>marker = "<strong class="og jf">centroids</strong>"<br/>data = dtf.copy()</span><span id="2824" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## create color column</strong><br/>lst_elements = sorted(list(dtf[color].unique()))<br/>lst_colors = ['#%06X' % np.random.randint(0, 0xFFFFFF) for i in <br/>              range(len(lst_elements))]<br/>data["color"] = data[color].apply(lambda x: <br/>                lst_colors[lst_elements.index(x)])</span><span id="e604" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## create size column (scaled)</strong><br/>scaler = preprocessing.MinMaxScaler(feature_range=(3,15))<br/>data["size"] = scaler.fit_transform(<br/>               data[size].values.reshape(-1,1)).reshape(-1)</span><span id="f59c" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## initialize the map with the starting location<br/></strong>map_ = folium.<strong class="og jf">Map</strong>(location=location, tiles="cartodbpositron",<br/>                  zoom_start=11)</span><span id="957a" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## add points</strong><br/>data.apply(lambda row: folium.<strong class="og jf">CircleMarker</strong>(<br/>           location=[row[x],row[y]], popup=row[popup],<br/>           color=row["color"], fill=True,<br/>           radius=row["size"]).add_to(map_), axis=1)</span><span id="0fd9" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## add html legend<br/></strong>legend_html = """&lt;div style="position:fixed; bottom:10px; left:10px; border:2px solid black; z-index:9999; font-size:14px;"&gt;&amp;nbsp;&lt;b&gt;"""+color+""":&lt;/b&gt;&lt;br&gt;"""<br/>for i in lst_elements:<br/>     legend_html = legend_html+"""&amp;nbsp;&lt;i class="fa fa-circle <br/>     fa-1x" style="color:"""+<strong class="og jf">lst_colors[lst_elements.index(i)]</strong>+""""&gt;<br/>     &lt;/i&gt;&amp;nbsp;"""+str(i)+"""&lt;br&gt;"""<br/>legend_html = legend_html+"""&lt;/div&gt;"""</span><span id="9ab7" class="kt ku je og b gy oo ol l om on">map_.get_root().<strong class="og jf">html.add_child</strong>(folium.<strong class="og jf">Element</strong>(legend_html))</span><span id="3d0c" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## add centroids marker</strong><br/>lst_elements = sorted(list(dtf[marker].unique()))<br/>data[data[marker]==1].apply(lambda row: <br/>           folium.<strong class="og jf">Marker</strong>(location=[row[x],row[y]], <br/>           popup=row[marker], draggable=False,          <br/>           icon=folium.<strong class="og jf">Icon</strong>(color="black")).add_to(map_), axis=1)</span><span id="da53" class="kt ku je og b gy oo ol l om on"><strong class="og jf">## plot the map</strong><br/>map_</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/87a8a8388c8031ea99495052fa3e3aa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNWyqAaheDhZ1b2wALwHRw.png"/></div></div></figure><p id="fd39" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">现在我们有了集群，我们可以在每个集群内部开始商店合理化。</p><h2 id="c30d" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">商店合理化</h2><p id="1649" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">因为本文的主要焦点是地理空间数据的聚类，所以我将保持这一部分非常简单。在每个集群中，我将选择潜在目标(高成本商店)和中心(低成本商店)，并将目标的员工重新安置在中心，直到后者达到满负荷。当一个目标的所有员工都被转移时，商店可以关闭。</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/b7d0f448d7f9cfc71a0abdccdd58c675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MtpFLSkRrKtIEa-xvR_scg.gif"/></div></div><p class="pd pe gj gh gi pf pg bd b be z dk translated">集群内的迭代</p></figure><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="ef5f" class="kt ku je og b gy ok ol l om on">dtf_new = pd.DataFrame()</span><span id="fbe4" class="kt ku je og b gy oo ol l om on">for c in sorted(dtf["cluster"].unique()):<br/>    dtf_cluster = dtf[dtf["cluster"]==c]<br/>    <br/>   <strong class="og jf"> ## hubs and targets</strong><br/>    lst_hubs = dtf_cluster[dtf_cluster["Cost"]=="low"<br/>               ].sort_values("Capacity").to_dict("records")<br/>    lst_targets = dtf_cluster[dtf_cluster["Cost"]=="high"<br/>               ].sort_values("Staff").to_dict("records")</span><span id="f50a" class="kt ku je og b gy oo ol l om on">    <strong class="og jf">## move targets</strong><br/>    for target in lst_targets:<br/>         for hub in lst_hubs:<br/>             <strong class="og jf">### if hub has space</strong><br/>             if hub["Capacity"] &gt; 0:<br/>                residuals = hub["Capacity"] - target["Staff"]</span><span id="49ff" class="kt ku je og b gy oo ol l om on">                <strong class="og jf">#### case of hub has still capacity: do next target</strong><br/>                if residuals &gt;= 0:<br/>                   hub["Staff"] += target["Staff"]<br/>                   hub["Capacity"] = hub["Potential"] - hub["Staff"]<br/>                   target["Capacity"] = target["Potential"]<br/>                   target["Staff"] = 0<br/>                   break</span><span id="1813" class="kt ku je og b gy oo ol l om on">                <strong class="og jf">#### case of hub is full: do next hub</strong><br/>                else:<br/>                   hub["Capacity"] = 0<br/>                   hub["Staff"] = hub["Potential"]<br/>                   target["Staff"] = -residuals<br/>                   target["Capacity"] = target["Potential"] - <br/>                                          target["Staff"]</span><span id="f05f" class="kt ku je og b gy oo ol l om on">    dtf_new = dtf_new.append(pd.DataFrame(lst_hubs)<br/>                 ).append(pd.DataFrame(lst_targets))</span><span id="d7a8" class="kt ku je og b gy oo ol l om on">dtf_new = dtf_new.append(dtf[dtf["Cost"]=="medium"]<br/>                 ).reset_index(drop=True).sort_values(<br/>                 ["cluster","Staff"])<br/>dtf_new.head()</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/3fca5254ac03f375b0857aba0347292d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1I-tlALhqPW7l6m1JPkyfQ.png"/></div></div></figure><p id="4f60" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">这是一个非常简单的算法，可以通过多种方式进行改进:例如，将中等成本的商店纳入等式，并在低成本商店全部满员时重复这一过程。</p><p id="d125" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">让我们看看我们用这个基本流程关闭了多少家高成本商店:</p><pre class="mj mk ml mm gt of og oh oi aw oj bi"><span id="3d06" class="kt ku je og b gy ok ol l om on">dtf_new["<strong class="og jf">closed</strong>"] = dtf_new["<strong class="og jf">Staff</strong>"].apply(lambda x: 1 <br/>                                           if x==0 else 0)<br/>print("closed:", dtf_new["<strong class="og jf">closed</strong>"].sum())</span></pre><p id="45a3" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">我们成功关闭了 19 家商店，但我们是否也保持了该地区的均匀覆盖，这样顾客就不需要去另一个社区逛商店了？让我们在地图上标出关闭的商店(<em class="nx"> marker = "closed" </em>)来想象一下后果:</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/a093709b08bb0b7d28b83de653912d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gPLPyPzcEw7fHgv94zPGtQ.png"/></div></div></figure><h2 id="6af9" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">结论</h2><p id="a09b" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">这篇文章是一篇关于<strong class="lr jf">如何在零售商业案例</strong>中使用聚类和地理空间分析的教程。我使用模拟数据集来比较流行的机器学习和深度学习方法，并展示了如何在交互式地图上绘制输出。我还展示了一个简单的确定性算法来提供业务案例的解决方案。</p><p id="aee6" class="pw-post-body-paragraph lp lq je lr b ls mn kf lu lv mo ki lx lc mp lz ma lg mq mc md lk mr mf mg mh im bi translated">我希望你喜欢它！如有问题和反馈，或者只是分享您感兴趣的项目，请随时联系我。</p><blockquote class="pj"><p id="3199" class="pk pl je bd pm pn po pp pq pr ps mh dk translated">👉<a class="ae ms" href="https://linktr.ee/maurodp" rel="noopener ugc nofollow" target="_blank">我们来连线</a>👈</p></blockquote></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><blockquote class="pt pu pv"><p id="0215" class="lp lq nx lr b ls mn kf lu lv mo ki lx pw mp lz ma px mq mc md py mr mf mg mh im bi translated">本文是用 Python 进行机器学习系列<strong class="lr jf">的一部分</strong>，参见:</p></blockquote><div class="is it gp gr iu mt"><a rel="noopener follow" target="_blank" href="/machine-learning-with-python-classification-complete-tutorial-d2c99dc524ec"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jf gy z fp my fr fs mz fu fw jd bi translated">用 Python 进行机器学习:分类(完整教程)</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">数据分析和可视化、特征工程和选择、模型设计和测试、评估和解释</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">towardsdatascience.com</p></div></div><div class="nc l"><div class="pz l ne nf ng nc nh ja mt"/></div></div></a></div><div class="is it gp gr iu mt"><a rel="noopener follow" target="_blank" href="/machine-learning-with-python-regression-complete-tutorial-47268e546cea"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jf gy z fp my fr fs mz fu fw jd bi translated">Python 机器学习:回归(完整教程)</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">数据分析和可视化、特征工程和选择、模型设计和测试、评估和解释</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">towardsdatascience.com</p></div></div><div class="nc l"><div class="qa l ne nf ng nc nh ja mt"/></div></div></a></div><div class="is it gp gr iu mt"><a rel="noopener follow" target="_blank" href="/deep-learning-with-python-neural-networks-complete-tutorial-6b53c0b06af0"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jf gy z fp my fr fs mz fu fw jd bi translated">Python 深度学习:神经网络(完整教程)</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">用 TensorFlow 建立、绘制和解释人工神经网络</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">towardsdatascience.com</p></div></div><div class="nc l"><div class="qb l ne nf ng nc nh ja mt"/></div></div></a></div><div class="is it gp gr iu mt"><a rel="noopener follow" target="_blank" href="/modern-recommendation-systems-with-neural-networks-3cc06a6ded2c"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jf gy z fp my fr fs mz fu fw jd bi translated">基于神经网络的现代推荐系统</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">使用 Python 和 TensorFlow 构建混合模型</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">towardsdatascience.com</p></div></div><div class="nc l"><div class="qc l ne nf ng nc nh ja mt"/></div></div></a></div></div></div>    
</body>
</html>