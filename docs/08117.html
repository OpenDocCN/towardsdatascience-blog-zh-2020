<html>
<head>
<title>How B+Tree Indexes Are Built In A Database?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">B+树索引是如何在数据库中构建的？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-b-tree-indexes-are-built-in-a-database-6f847fb3cfcc?source=collection_archive---------26-----------------------#2020-06-15">https://towardsdatascience.com/how-b-tree-indexes-are-built-in-a-database-6f847fb3cfcc?source=collection_archive---------26-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5df4e95a3f4e8ac163daeda14b75ddb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HJU2fOwrZY3qwZmF"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@niko_photos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> niko photos </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="cc0e" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">使用图表来说明如何在数据库管理系统中建立 B+树索引</h2></div><p id="1d06" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您不是 DBA 或数据库开发人员，您可能不知道数据库索引的机制。但是只要你会写一些 SQL 查询，你一定听说过数据库索引，知道索引可以提高 SQL 查询的性能。</p><p id="1e69" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我以前的一篇文章中，我介绍了 B+树索引，它仍然被大多数数据库管理系统(DBMS)使用。它可以提高大多数条件下的 SQL 查询性能。</p><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/why-we-need-indexes-for-database-tables-25198145a8ca"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">为什么我们需要数据库表的索引</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">引入没有任何公式和计算机科学理论的 B+树索引</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi ja lu"/></div></div></a></div><p id="a20f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有一个图是我用来举例的，如下图所示。</p><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mj"><img src="../Images/a431bcd64ef9defc5bb6c80ae5bf343c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-i_EluPLupSju9uxCg3GQ.png"/></div></div></figure><p id="8da2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你很好奇 b+树为什么是这个样子吗？具体来说，为什么顶级节点只有一个数字为 5 的节点？为什么叶节点 7 是单独的？在本文中，我将介绍如何从头开始构建 B+树索引。</p><h1 id="dfef" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">将键插入 B+树</h1><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ng"><img src="../Images/e928e07be6a6c260c0670f616789f99a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PRX2pu73EU1MMR-7"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@outoforbit?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">古斯塔夫·古尔斯特兰德</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="62b6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从一个空表开始，忽略它的其他列，只关注创建了 B+树索引的键列。</p><p id="d333" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，假设我们开始使用这张桌子。因此，一系列条目将被插入到表中。因为键列上有一个 B+树索引，所以需要在逐个插入数据行时构建索引。</p><p id="108c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管通常键字段可能是按顺序插入的，当然，情况并不总是这样。为了演示一般情况下的机制，让我们假设密钥是随机插入的。例如，顺序如下:</p><pre class="mk ml mm mn gt nh ni nj nk aw nl bi"><span id="26d7" class="nm mp jj ni b gy nn no l np nq">5, 7, 8, 1, 4, 6, 2, 3, 9</span></pre><p id="2ecc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">需要强调的是，建立 B+树指数的方法并不只有一种。因此，我们需要在我们的例子中有一些假设。不用担心，所有 b+树索引的机制都是一样的。</p><blockquote class="nr"><p id="80af" class="ns nt jj bd nu nv nw nx ny nz oa lt dk translated">假设 1:硬盘驱动器的每个块可以存储两个密钥</p></blockquote><p id="957e" class="pw-post-body-paragraph ky kz jj la b lb ob kk ld le oc kn lg lh od lj lk ll oe ln lo lp of lr ls lt im bi translated">当然，在实践中，这个数字小得不可能。但这会让我们的例子更容易理解。</p><p id="4371" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的。现在，我们可以将前两个数字插入到索引中。</p><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div class="gh gi og"><img src="../Images/04fc5695a048d6e8fdf5e35e6359aa65.png" data-original-src="https://miro.medium.com/v2/resize:fit:288/format:webp/1*hT_I0knxhUJnI82wG-M7ug.png"/></div></figure><p id="ef43" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为假设 1，当我们插入两个值时，我们不需要担心任何事情。这些值必须排序，所以 5 在左边，而 7 在右边。请注意，该节点是一个叶节点，因为此时我们不需要任何非叶节点，因为一个叶节点中只能存储两个值。</p><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/2d61e188b72a00479d45c5ef5de5d579.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*ooO1tDwU1U19DptvyBU_GA.png"/></div></figure><p id="73b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们插入一个新数字“8”时，我们首先假设我们需要将它插入到现有的叶节点中。然而，它将以一个具有三个值“5，7，8”的节点结束。基于假设 1，我们需要拆分节点，因为该块只能存储两个值。</p><blockquote class="nr"><p id="04a5" class="ns nt jj bd nu nv nw nx ny nz oa lt dk translated">假设 2:当一个节点被拆分时，左边节点的右值去更高一级</p></blockquote><p id="edef" class="pw-post-body-paragraph ky kz jj la b lb ob kk ld le oc kn lg lh od lj lk ll oe ln lo lp of lr ls lt im bi translated">我们需要作出假设 2 来定义每当一个节点被分割时哪个值去更高的级别。请注意，也可能有这样的假设，如右节点的左值上升，我们只需要定义它并遵循它。</p><p id="6661" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，不能存储在该块中的最后一个值“8”被分裂，成为新的叶节点。之后，左边的节点是“5”和“7”，最右边的值是“7”，所以会上一级。</p><p id="d71a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们有了一个非叶节点。这个新节点需要用左右两个指针来创建。左指针指向值较小的节点，而右指针指向值较大的节点。</p><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/538ba077379e3b00424323a76e9cc776.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*1FmB11b2-9HvRbW8R7w_Pw.png"/></div></figure><p id="d9a4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，当我们插入数字“1”时，叶节点“5，7”变成了“1，5，7”，这导致了另一次分裂。最后一个值“7”将被分离出来，成为一个新的叶节点。请注意，编号“7”不会被合并到另一个编号为“8”的节点中，这是因为 B+Tree 不具备这一功能，同时这会造成额外的索引构建开销。没有必要。</p><p id="3944" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后基于假设 2，左边节点最右边的值是数字“5”。它达到了更高的水平。已经有一个数字为“7”的节点，所以简单地在“7”的左边插入数字 5。别忘了让指针指向的节点小于或等于“5”。</p><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/d1edb1cccb0c1c5d8a6c89abeebbb8c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*OZ1n3SJtr0igPoQeWuyRWQ.png"/></div></div></figure><p id="9fba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一个值是“4”。又造成了分裂，于是数字 4 基于假设 2 上了一层楼。但是，第一级非叶节点“5，7”已经得到了两个值。基于假设 1，需要拆分。</p><p id="9eb3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">毫无疑问，基于假设 1，数字“5”应该上升到第二级非叶节点。但是，要知道数字 5 将不再存在于一级非叶节点中，这一点非常重要。这是 B+树的机制之一，在非叶子节点中不应该有任何重复的值。</p><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/1db9edd6a3ae786029f6f7c8e90aba83.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*pyI6nOHZKOLG6db0CATWKQ.png"/></div></figure><p id="b018" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">插入数字“6”相对容易。因为叶节点“5”还有一个空格，所以数字“6”会被插入到这个节点中，没有任何其他效果。</p><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/f975d2189bebe6abf264c0b1a711824d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*GerLiRWS85WwSQ-VEtYSqw.png"/></div></figure><p id="c827" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当插入数字“2”时，需要拆分叶节点“1，2，4”。基于假设 2，数字“2”需要被提升。由于非叶节点“4”仍然有空间，所以数字“2”在那里结束，没有进一步的影响。</p><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/2e920250a8145cd7f025e0741aaebe7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSZvB4Jn2HB7BpGwc1JfUQ.png"/></div></div></figure><p id="6935" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后两个数字“3”和“9”可以在叶节点上找到它们的位置。因此，不再需要分割。</p><p id="96c6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，所有的 9 个数字都以这种随机顺序插入到 B+树索引中。</p><h1 id="0e82" class="mo mp jj bd mq mr ms mt mu mv mw mx my kp mz kq na ks nb kt nc kv nd kw ne nf bi translated">摘要</h1><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/0fd35a26d87b1a086b297e8c5dc30023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A30NMHC2pqHlDFVL"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">特雷·吉普森在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="cfce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我使用了图表来说明如何从头开始构建 B+树。事实证明，在 B+树索引的实现之间，假设可能是不同的。然而，机制是相同的。</p><p id="1ebd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为最经典的索引类型，B+树已经使用了几十年，并且仍然被大多数数据库管理系统使用。尽管它可能不再是最先进的索引，但我相信它仍然是标志性的，DBA、数据分析师和软件开发人员都应该知道。</p><div class="is it gp gr iu lu"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">通过我的推荐链接加入 Medium 克里斯托弗·陶</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">medium.com</p></div></div><div class="md l"><div class="oo l mf mg mh md mi ja lu"/></div></div></a></div><p id="7d6b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">如果你觉得我的文章有帮助，请考虑加入灵媒会员来支持我和成千上万的其他作家！(点击上面的链接)</strong></p></div></div>    
</body>
</html>