<html>
<head>
<title>Understanding Python Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Python生成器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-python-generators-741d33f177b7?source=collection_archive---------26-----------------------#2020-04-03">https://towardsdatascience.com/understanding-python-generators-741d33f177b7?source=collection_archive---------26-----------------------#2020-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a76d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中的生成器简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9bcc306c6a6cc6a0b981790d106e2742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oVcsegBP1aD7aZf9Wo91NA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/photo/alternative-alternative-energy-clouds-eco-energy-433308/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="c1bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器函数是python中的函数，它提供了一种执行迭代的简单方法。这很有用，因为处理列表要求我们将每个值存储在内存中，这对于大量输入来说是不实际的。此外，与生成器的简单实现相比，从头构建迭代器需要大量代码。例如，在构建迭代器类时，需要定义dunder方法“__iter__()”和“__next__()”，跟踪内部状态，并在没有其他值要返回时引发“StopIteration”。为了演示生成器函数的强大功能，我们将比较一个用于生成从0到<em class="lv"> n </em>的正整数的函数的不同实现。</p><p id="f21c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><p id="9332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们定义一个函数，它接受一个整数作为输入，并返回一个小于或等于输入的正整数列表:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2197" class="mb mc it lx b gy md me l mf mg">def generate_list(input_value):<br/>    number, numbers = 0, []<br/>    while number &lt;= input_value:<br/>        numbers.append(number)<br/>        number += 2<br/>    return numbers</span></pre><p id="d91f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们用我们的函数定义一个从0到<em class="lv"> n </em> = 10的正整数列表:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="3481" class="mb mc it lx b gy md me l mf mg">values = generate_list(10)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/63a17d8d7884c5ab963d1a718affec05.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*5YE1Q_3ySyg2FLkEZiDICQ.png"/></div></figure><p id="0df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用内置的sum方法对结果列表进行求和:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9118" class="mb mc it lx b gy md me l mf mg">print("Sum of list: ", sum(values))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/aefa78fdcf6c5dce63e4c5c35e804d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*xsy31Bu2fv0AoheG0hJhUw.png"/></div></figure><p id="9ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的问题是完整的列表是在内存中构建的。当您处理大量数据时，这就成了问题。我们可以使用生成器模式来修正这个问题。</p><p id="45c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们将生成器实现为迭代器对象。我们的类将需要dunder方法“__init__()”、“__iter__()”和“__next__()”。当没有额外的值要返回时，我们还需要引发“StopIteration”。让我们首先定义我们的“__init__()”方法:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="0d9e" class="mb mc it lx b gy md me l mf mg">class iterator_object(object):<br/>    def __init__(self, input_value):<br/>        self.input_value = input_value<br/>        self.numbers = 0</span></pre><p id="137c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的“__init__()”方法中，我们初始化了类属性。接下来，让我们定义dunder方法' __iter__()':</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="3ca1" class="mb mc it lx b gy md me l mf mg">class iterator_object(object):<br/>    ...<br/>    def __iter__(self):<br/>        return self</span></pre><p id="b77a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们添加我们的“__next__()”方法:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="0044" class="mb mc it lx b gy md me l mf mg">class iterator_object(object):<br/>    ...<br/>    def __next__(self):<br/>       return self.next()</span></pre><p id="e5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以定义类方法“next()”:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2f41" class="mb mc it lx b gy md me l mf mg">class iterator_object(object):<br/>   ...<br/>   def next(self):<br/>        if self.number &lt;= self.input_value:<br/>            current, self.number = self.number, self.number + 2<br/>            return current<br/>        else:<br/>            raise StopIteration()</span></pre><p id="47d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以定义一个输入值为10的类实例，并打印出结果迭代器对象的总和:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="0150" class="mb mc it lx b gy md me l mf mg">value = iterator_object(10)<br/>print("Sum using an Iterator Object: ", sum(value))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/764977011b5cdb820630645af8577976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*saBtRSzy0RgHdtIyLuQQDA.png"/></div></figure><p id="a6e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们所期望的结果。注意，为了将我们的生成器实现为迭代器对象，我们需要编写相当多的代码:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="26a4" class="mb mc it lx b gy md me l mf mg">class iterator_object(object):<br/>    def __init__(self, input_value):<br/>        self.input_value = input_value<br/>        self.number = 0<br/>        <br/>    def __iter__(self):<br/>        return self<br/>    def __next__(self):<br/>       return self.next()<br/>   <br/>    def next(self):<br/>        if self.number &lt;= self.input_value:<br/>            current, self.number = self.number, self.number + 2<br/>            return current<br/>        else:<br/>            raise StopIteration()</span></pre><p id="e6d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，python提供了‘yield’关键字，当使用时，它提供了构建迭代器的捷径。我们可以用yield来定义同样的函数:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="d67a" class="mb mc it lx b gy md me l mf mg">def generator_function(input_value):<br/>    number = 0<br/>    while number &lt;= input_value:<br/>        yield number<br/>        number += 2</span></pre><p id="f09a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们调用输入值为10的生成器，并打印结果的总和:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="c745" class="mb mc it lx b gy md me l mf mg">value = generator_function(10)<br/>print("Sum using a Generator: ", sum(value))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/a88b494908dbb66ac2d6384de816fb91.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*-Y4A3NXBvZo5pP__gKZb2g.png"/></div></figure><p id="05e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们用比迭代器对象实现少得多的代码实现了相同的结果，同时保留了迭代器的优点。我就讲到这里，但是您可以自己随意摆弄代码。</p><h2 id="4def" class="mb mc it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">结论</h2><p id="8e03" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">总之，在这篇文章中，我们讨论了python中的生成器函数。我们概述了同一个函数的三个实现，以展示生成器函数的强大功能。我们讨论了在列表上执行一些操作对于大量输入来说是如何成为问题的。我们通过构建一个生成器函数的迭代器对象实现解决了这个问题。这个解决方案需要大量代码。最后，我们讨论了使用yield语句来定义生成器函数，这为构建迭代器提供了一条捷径。我希望你对这篇文章感兴趣/有用。这篇文章中的代码可以在<a class="ae ky" href="https://github.com/spierre91/medium_code/blob/master/basic_python/generators_tutorial.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。感谢您的阅读！</p></div></div>    
</body>
</html>