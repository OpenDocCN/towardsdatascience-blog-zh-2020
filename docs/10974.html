<html>
<head>
<title>Enrich your train fold with a custom sampler inside an imblearn pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 imblearn 管道中的自定义采样器丰富您的火车文件夹</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/enrich-your-train-fold-with-a-custom-sampler-inside-an-imblearn-pipeline-68f6dff964bf?source=collection_archive---------39-----------------------#2020-07-30">https://towardsdatascience.com/enrich-your-train-fold-with-a-custom-sampler-inside-an-imblearn-pipeline-68f6dff964bf?source=collection_archive---------39-----------------------#2020-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c869" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在交叉验证中使用扩充数据并不像看起来那么简单。这是如何在 sklearn 中做到的。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0311199116d6fe7bce38fed5c6e48434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTHIknmiIfwOZJfefc9fdg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">艾德亚多·桑奇兹在 Unsplash 上拍摄的照片</p></figure><p id="b275" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当涉及到小数据集时，生活会变得复杂。在医学中，一个数据集很容易包含不到 100 个患者/行。但是在另一个维度上，它可以变得非常大——轻松超过 3000 个特征。</p><p id="1995" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，有时您会找到扩充数据的方法，在我的例子中，这意味着您将数据集乘以稍微不同的特征值。这样你就可以增加你的训练数据。当然这是我真正做的事情的简化版本，但那是另外一个故事了。有不同的方法来扩充您的数据，但是本文并不打算涵盖数据扩充的广泛领域。</p><p id="9b9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但你必须小心，数据增强是一种强大的武器，必须谨慎使用。即使正确使用，也不能保证提高估计器的性能。</p><p id="d2c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顺便说一句，如果没有我的同事和 StackOverflow 的人的帮助，我是写不出这篇文章的！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="92e9" class="mb mc it bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">在您的流程中何处使用增强数据</h2><p id="10fe" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">一旦你有了一组扩充的数据来丰富你的原始数据集，你就会问自己如何以及在哪个点上合并它们。通常，您使用 sklearn 及其模块来评估您的估计器或搜索最佳超参数。包括<code class="fe mz na nb nc b">RandomizedSearchCV </code>或<code class="fe mz na nb nc b">cross_validate </code>在内的流行模块可以选择通过类似<code class="fe mz na nb nc b">KFold</code>的交叉验证方法。通过利用交叉验证方法来测量估计器的性能，您的数据被分成一个训练集和一个测试集。这是在 sklearn 方法下动态完成的。</p><p id="a307" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这通常是好的，这意味着你不需要过多的麻烦。当您想要将扩充数据用于交叉验证方法时，只有一个问题——您不希望在您的测试文件夹中有扩充数据。这是为什么呢？你想知道你的估计器在现实中表现如何，而你的增广数据并没有反映现实。此外，您希望只增加训练集中的数据，而不希望在训练文件夹中增加数据。</p><h2 id="8b53" class="mb mc it bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">如何只在需要扩充的地方扩充</h2><p id="230a" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">回到问题，在你的交叉验证中，有没有可能影响训练测试拆分？是的，<code class="fe mz na nb nc b">imblearn.pipeline.Pipeline </code>来救援了。这个管道类似于你可能从 sklearn 了解到的管道，你可以在一个所谓的管道中链接处理步骤和估计器。对我们来说，<strong class="la iu">的巨大差异和优势在于它在交叉验证中的工作方式。它只在列车上运行！</strong></p><p id="3add" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个好消息，但是您仍然需要定义一个方法来丰富您的原始数据并在管道中传递它。最简单的方法是使用 imblearn 的<code class="fe mz na nb nc b">FunctionSampler </code>将任何函数转换成可以在管道中传递的采样器。imblearn 网站上有大量的文档。但是，也许你想做一些更复杂的事情，并建立自己的采样器。这就是 sklearn 的<code class="fe mz na nb nc b">BaseEstimator </code>发挥作用的地方，它是一个定制估算器的基类。我们可以用它来构建我们的采样器。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5fcb" class="mb mc it nc b gy nh ni l nj nk">import pandas as pd<br/>from sklearn.base import BaseEstimator</span><span id="5425" class="mb mc it nc b gy nl ni l nj nk">class EnrichWithAugmentedData(BaseEstimator):<br/>    """<br/>    Resampler to pass augmented data in a imblearn pipeline<br/>    In this example I pass a list of augmented data frames with identical endpoints y to be merged with the original data X<br/>    """<br/>    <br/>    def __init__(self, augmented_sets):<br/>        self.augmented_sets = augmented_sets<br/>        <br/>    def fit_resample(self, X, y):<br/>        return self.resample(X, y)<br/>        <br/>    def resample(self, X, y):<br/>        self.data = []<br/>        for i, df in enumerate(self.augmented_sets):<br/>            self.data.append(self.augmented_sets[i].copy())<br/>        for i, df in enumerate(self.data):<br/>            self.data[i] = self.data[i].loc[X.index, :]<br/>        X = pd.concat([X, *self.data], axis=0)<br/>        n = len(self.data) + 1<br/>        y = pd.concat([y]*n, axis=0)<br/>        return X, y</span><span id="64a5" class="mb mc it nc b gy nl ni l nj nk"># Feel free to comment my code, I am a physicist :D</span></pre><p id="2f2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以使用我们的采样器来构建具有任何估计器的管道:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="fd90" class="mb mc it nc b gy nh ni l nj nk">from xgboost import XGBClassifier<br/>from imblearn.pipeline import Pipeline</span><span id="8615" class="mb mc it nc b gy nl ni l nj nk">augmented_sets = [df_augmented_01, df_augmented_02]</span><span id="2c6f" class="mb mc it nc b gy nl ni l nj nk">model = XGBClassifier()<br/>ewad = EnrichWithAugmentedData(augmented_sets)<br/>pipeline = Pipeline([('ewad', ewad), ('model', model)])</span></pre><p id="6e84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们想利用管道中的<code class="fe mz na nb nc b">RepeatedStratifiedKFold </code>进行一次<code class="fe mz na nb nc b">RandomizedSearchCV</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ad85" class="mb mc it nc b gy nh ni l nj nk">cv = RepeatedStratifiedKFold(<br/>    n_splits=5, <br/>    n_repeats=10, <br/>    random_state=101<br/>    )</span><span id="5a5c" class="mb mc it nc b gy nl ni l nj nk"># make sure that you have the suffix with the name of your pipeline step in front of your parameter name!<br/>parameter_grid = {<br/>    'model__max_depth':[2, 3, 4],<br/>    'model__learning_rate':np.arange(0.005, 0.5, 0.05),<br/>}</span><span id="c1ee" class="mb mc it nc b gy nl ni l nj nk"># make sure that you do not refit, because the refit will be without your augmented data!<br/>gs = RandomizedSearchCV(<br/>    estimator=pipeline, <br/>    n_iter=3000,<br/>    param_distributions=parameter_grid, <br/>    scoring='roc_auc', <br/>    n_jobs=-1, <br/>    cv=cv, <br/>    verbose=1,<br/>    random_state=101,<br/>    refit=False<br/>)<br/>grid_result = gs.fit(X, y)</span><span id="f8e6" class="mb mc it nc b gy nl ni l nj nk">print("Best: {:.2f} using {}".format(<br/>    grid_result.best_score_, <br/>    grid_result.best_params_<br/>))</span></pre><p id="7e25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您也可以用<code class="fe mz na nb nc b">cross_validate</code>使用相同的程序，用<code class="fe mz na nb nc b">pipeline.steps[1][1]</code>获得最佳模型和特征重要性，作为特征选择方法。如果您使用扩充数据进行训练，那么它很有可能会影响评估者选择的特征。</p><p id="a3ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这篇文章能帮助一些数据科学家同行。</p></div></div>    
</body>
</html>