# 如何将 Minimax 应用到 2048 年

> 原文：<https://towardsdatascience.com/playing-2048-with-minimax-algorithm-1-d214b136bffb?source=collection_archive---------24----------------------->

## [用极大极小算法玩 2048】](https://towardsdatascience.com/tagged/playing-2048-with-minimax)

## 2048 年——一个简单的游戏，但是给计算机编程来解决它就不简单了

![](img/c9fd8e1df10c8f522582ed92dfe63956.png)

作者图片

最小最大值是一种被指定用于玩对抗性游戏的算法，即有对手参与的游戏。在本文中，我们将看到如何应用极大极小算法来解决 2048 游戏。这是 3 部分系列的第一篇文章。这一部分将包括在概念层面上规划我们的游戏程序，在接下来的两篇文章中，我们将看到实际的 Python 实现。

这里我假设你已经知道了极大极小算法的一般工作原理，并且只关注如何将它应用到 2048 年的游戏中。所以，如果你还不知道极小极大算法，看看:

[](/understanding-the-minimax-algorithm-726582e4f2c6) [## 理解极大极小算法

### 用人工智能玩游戏

towardsdatascience.com](/understanding-the-minimax-algorithm-726582e4f2c6) 

在 2048 年应用极小极大时，我们需要考虑的主要 4 件事，实际上不仅仅是 2048 年，而是任何其他游戏，如下:

**1。我们如何把 2048 年想成一个双人游戏？麦克斯是谁？敏是谁？**

**2。我们如何决定一个游戏状态何时是终结？**

**3。我们如何评价一个游戏状态的分数/效用？**

**4。我们如何确定一个游戏状态的子节点？**

上面的第一点是因为这就是 minimax 的工作方式，它需要两个玩家:max 和 Min。其他 3 件事来自算法的伪代码，如下所示:

![](img/1d13d89bc487c9032ba26580f2b79e2c.png)

当我们编写算法的一般形式时，我们只关注突出显示的函数/方法的结果(“它应该确定状态是否是终结的”、“它应该返回分数”、“它应该返回该状态的子代”)，而没有考虑它们实际上是如何完成的**；那是游戏特有的。**

**现在，当我们想将这个算法应用到 2048 年时，我们将注意力转移到“如何”**部分:我们实际上如何为我们的游戏做这些事情？****

## ****我们如何把 2048 年想成一个双人游戏？麦克斯是谁？敏是谁？****

****回想一下极大极小算法，我们需要 2 个玩家，一个最大化分数，一个最小化分数；我们称它们为最大值和最小值。****

****当我们在 2048 年比赛时，我们想要一个大比分。麦克斯是谁？我们。我们想最大化我们的分数。****

****谁想最小化我们的分数？嗯…没有人。有游戏本身，电脑，随机产生大部分是 2 和 4 的棋子。但是，它并不是真正的对手，因为我们实际上需要这些棋子来增加我们的分数。我不认为这个游戏把这些棋子放在我们不利的地方，它只是随机地放置它们。****

****但是极大极小算法需要一个对手。因此，我们将认为 Min 是放置这些瓷砖的游戏本身，虽然在游戏中瓷砖是随机放置的，但我们将认为我们的 Min 玩家试图以最糟糕的方式放置瓷砖。****

## ****我们如何决定一个游戏状态何时是终结？****

****这是一个简单的问题:当游戏结束，或者我们达到了一定的深度时，游戏状态被认为是一个终结状态。当游戏棋盘上满是瓷砖，我们无法移动时，我们将认为游戏已经结束。****

****游戏树上的深度阈值是为了限制每次移动所需的计算。如果我们让算法遍历整个博弈树，这将花费太多的时间。我们希望限制这个深度，这样算法将为我们需要做出的每一步给出相对快速的答案。对于 2048 游戏，5-6 的深度很好。****

## ****我们如何评价一个游戏状态的分数/效用？****

****2048 游戏的目标是将瓷砖合并成更大的瓷砖，直到你得到 2048，甚至超过这个数字。在上面的文章图像中，您可以看到我们的算法如何获得 4096 的图块。但是我们应该在极小极大中使用的确切度量是有争议的。人们可以认为一个好的效用函数应该是最大瓦片值，因为这是主要目标。但是如果我们在同样的最大值下有更多的游戏配置呢？我们如何区分它们？我认为我们应该考虑是否还有其他大的部分，这样我们可以稍后再合并它们。****

****那么，我们是否应该将所有瓷砖价值的总和视为我们的效用？但是这个总数也可以通过在棋盘上填满小方块来增加，直到我们没有更多的移动。我认为我们应该惩罚这个占据了太多棋盘空间的游戏。所以，用这个总数除以非空瓷砖的数量，对我来说是个好主意。我们希望在尽可能小的空间里展示尽可能多的价值。****

****![](img/eda3e1fb3695804985646c000c052fcc.png)****

## ****我们如何确定一个游戏状态的子节点？****

****在极小极大博弈树中，一个博弈状态 S 的子博弈状态是所有其他的博弈状态，这些博弈状态只需一步就可以到达。我们如何确定 S 的子代取决于从 S 移动到它的一个子代的玩家是什么类型的。****

****如果玩家是 Max(也就是我们——试图赢得游戏)，那么它可以按下其中一个箭头键:上、下、右、左。根据游戏状态的不同，并非所有这些移动都是可能的。所以麦克斯的可能行动也可能是这四个行动的子集。****

****![](img/c8e5564fdc68e0dba34eebdcfe049db5.png)****

****作者图片****

****而在这种情况下，S 的子系就是 Max 在做其中一个动作时可以达到的游戏状态。****

****有哪些招式可以做到 Min？闵的工作是把瓷砖放在棋盘的空白方格上。这些牌大多数是 2 和 4，但它也可以使用我们在棋盘上拥有的牌。然而，我们将只考虑 2 和 4 作为可能的瓦片；这是为了避免不必要的大分支因子，并节省计算资源。如前所述，我们认为 Min 试图做对我们最不利的一步棋，那就是放一张小牌(2 / 4)。****

****所以，如果参与人是 Min，可能的移动是所有空方块的集合和集合{2，4}的叉积。而 S 的子就是这其中一步棋所能达到的所有博弈状态。****

****下面是一个简单的例子:****

****![](img/b2150b334f70cbfd1fd33eab6f44fadd.png)****

****作者图片****

****在上图中，两个没有阴影的方块是游戏棋盘上仅有的空白方块。Min 能做的移动是在每一个上面放一个 2 或者放一个 4，这样总共有 4 个可能的移动。****

****暂时就这样了。在下一篇文章中，我们将看到如何通过`Grid`类在 Python 中表示游戏棋盘。这个类将包含我们完成任务所需的所有游戏逻辑。****

****[](/how-to-represent-the-game-state-of-2048-a1518c9775eb) [## 如何表现 2048 年的游戏状态

### …以及如何以面向对象的方式做到这一点

towardsdatascience.com](/how-to-represent-the-game-state-of-2048-a1518c9775eb)**** 

*****我希望这些信息对您有用，感谢您的阅读！*****

****这篇文章也贴在我自己的网站[这里](https://www.nablasquared.com/how-to-apply-minimax-to-2048/)。随便看看吧！****