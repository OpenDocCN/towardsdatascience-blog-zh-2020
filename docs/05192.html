<html>
<head>
<title>AI Teaches itself to play a game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能自学玩游戏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ai-teaches-itself-to-play-a-game-f8957a99b628?source=collection_archive---------49-----------------------#2020-05-03">https://towardsdatascience.com/ai-teaches-itself-to-play-a-game-f8957a99b628?source=collection_archive---------49-----------------------#2020-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="682a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Pygame构建了一个简单的游戏，并应用NEAT(增强拓扑的神经进化)算法来训练AI。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/ec230f96b4fb063829eced1afdf83549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*88TOynhe5mUmr0eQyL-ing.gif"/></div></figure><p id="2a21" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这篇文章是关于教AI如何玩一个我用pygame库做的简单游戏。游戏是这样的，球应该继续在管子之间的缝隙中滚动，如果球碰到了任何一根管子，我们就输了。当一个球成功通过管道之间的缝隙时，分数将增加1。</p><p id="a656" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上面的Gif图像显示了神经网络如何一代又一代地改进的训练过程，并且可以使用下面的三个值在游戏窗口中看到进度状态。</p><ul class=""><li id="575e" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><strong class="ks iu">分数:</strong>分数/成功穿越的管道数。</li><li id="a7cf" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated"><strong class="ks iu">一族</strong>:算法正在学习的世代/突变数。</li><li id="597d" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated"><strong class="ks iu">球:</strong>表示当前世代中存活的球数。</li></ul><p id="7f16" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">构建游戏界面的完整代码和相关文件都在我的<a class="ae ma" href="https://github.com/Msanjayds/AI_KISS/tree/master/1.%20AI/RollingBall" rel="noopener ugc nofollow" target="_blank"> <strong class="ks iu"> Git repo </strong> </a> <strong class="ks iu">里。</strong></p><p id="939c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在让我们使用<strong class="ks iu"> <em class="mb"> </em> </strong> <em class="mb">整齐的</em>(扩充拓扑的神经进化)来进行<strong class="ks iu"> </strong>训练部分。NEAT是一种创建人工神经网络的进化算法，该算法的详细描述是<a class="ae ma" href="https://neat-python.readthedocs.io/en/latest/neat_overview.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ks iu">这里的</strong> </a>。这里的基本思想是网络不依赖于固定的结构，NEAT允许它通过遗传算法进化。因此，当需要完成手头的任务时，它通过添加节点、连接和层来自己构建最佳网络。</p><p id="1bba" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一旦我们准备好一个游戏，我们将下面的输入/参数输入到NEAT算法中，以创建一个完成任务的最佳神经网络，在我们的例子中，是将球滚动通过间隙。</p><p id="fc41" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们通过一个<a class="ae ma" href="https://github.com/Msanjayds/AI_KISS/blob/master/1.%20AI/RollingBall/config.txt" rel="noopener ugc nofollow" target="_blank"> <strong class="ks iu">配置文件传递所有这些参数。</strong> </a></p><p id="5764" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> <em class="mb">网络的输入:</em> </strong>告诉NEAT算法网络可以期望什么样的输入，我们需要什么样的输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/fc23519dbe30fe94250eb6a063b2e41e.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*fZUFk94FPV9_EpVf9zbxww.png"/></div></figure><ul class=""><li id="c741" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">由于这是一个简单的游戏，我已经将隐藏层的数量设置为0，如果需要，我们可以尝试另一个数量。</li><li id="3994" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">我正在为网络传递3个输入。球在Y轴上的位置、球和顶部管道之间的距离以及球和底部管道之间的距离。</li><li id="7ded" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated"><strong class="ks iu"> Num_Output </strong> s:设置为1，即输出单节点。基于输出节点的值，我们决定跳转或不跳转。</li></ul><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="8f82" class="mi mj it me b gy mk ml l mm mn"># we used tanh activation function so result will be between -1 &amp; 1. if over 0.5 jump</span><span id="3d23" class="mi mj it me b gy mo ml l mm mn">if output[0] &gt; 0.5: <br/>   ball.jump()</span></pre><p id="0aab" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> <em class="mb">激活功能</em> </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/0a9f433056509c9ff3364dbece261a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*aGaNdsI16RDNgRdKulmBtg.png"/></div></figure><ul class=""><li id="7fcc" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><strong class="ks iu">激活默认值:</strong>使用哪个激活函数来确定输出值，在本例中，我使用了Tanh。我们可以使用其他激活函数，如sigmoid/relu等。</li><li id="c61a" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated"><strong class="ks iu"> Activation_mutate_rate </strong>:变异时选择其他激活函数的概率。</li><li id="4d19" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated"><strong class="ks iu">激活选项:</strong>突变/育种过程中随机使用的其他激活功能。</li></ul><p id="54d5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> <em class="mb">适应度参数</em> </strong> <em class="mb"> : </em>评价网/球像距离多好的方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/2415266ab6bb95141351599c84627465.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*aWkAcm_BhCFd9osYCRIpWg.png"/></div></figure><ul class=""><li id="1895" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><strong class="ks iu"> Fitness_criterion: </strong>可以有最小值/最大值/平均值。这告诉了NEAT如何挑选最好的网/球。体能分最高的球是最好的。</li><li id="418d" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated"><strong class="ks iu"> Fitness_threshold </strong>:停止训练前达到的最大体能分数。</li><li id="e387" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated"><strong class="ks iu"> Pop_size: </strong>任意值，我们可以随便玩。它表示每一代有多少个球。用20个成员/球开始零代，测试它们，选择最好的，繁殖/变异它们以产生下一代的20个球，并继续该过程。</li><li id="71d3" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated"><strong class="ks iu">灭绝时重置:</strong>如果这个评估为<code class="fe mr ms mt me b">True</code>，当a中的所有物种(球)同时因停滞而灭绝时，会产生一个新的随机种群。</li></ul><p id="75fc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在neat中，我们将群体成员称为基因组/物种，一旦基因组的属性如上所述被设置，NEAT开始通过创建球的群体来构建网络，我们将其设置为20。每个球都与控制它的完全随机的神经网络相关联&amp;每个网络都有自己的随机权重和偏好。所以我们测试了每一个神经网络，通过评估它们的适应性来看它们做得有多好。健康取决于我们玩什么任务/游戏，在这种情况下，球前进了多远。在游戏中，每通过一个管道，我们就给它的健康值加1。</p><p id="77ea" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在第一代结束时，当所有的球都用完了，尼特看到他们中哪个表现最好。然后，它挑选上一代球/网络中的最佳球/网络(得分最高的两个或三个)，对它们进行变异和繁殖，以创建一组新的种群。在这篇<a class="ae ma" href="https://neat-python.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> <strong class="ks iu">论文</strong> </a>中详细解释了这些神经网络实际上是如何繁殖和变异的。</p><p id="2fe4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们将拥有上一代最好物种/球的后代。所以我们希望这些下一代物种/球比上一代表现得更好。neat实际上做的是，更新权重，随机添加/删除节点和连接，直到它找到一个最适合我们正在解决的问题的架构。它从一个简单的网络开始，必要时会变得复杂。我们需要继续这个过程，直到我们对表现满意为止。</p><p id="db8f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">经过几代人的慢慢学习和变得更好，它终于学会了一种前进而不碰壁的模式。在这种情况下，使用当前的参数集，在第四代中，AI开始表现得更好，并达到了一个从未失败的点，正如我们在上面的gif图像中看到的那样。</p><p id="f110" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一旦分数达到我们设置的健身阈值，那么我们可以通过使用pickle保存与该球相关联的神经网络来退出训练。然后用一个球和我们保存的最好的网络创建一个游戏。现在，它可以无缝地演奏，永远不会碰到管子。</p><p id="f217" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">感谢阅读，快乐学习。:-)</p></div></div>    
</body>
</html>