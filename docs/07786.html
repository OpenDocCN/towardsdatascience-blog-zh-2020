<html>
<head>
<title>GraphQL Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL 最佳实践</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graphql-best-practices-3fda586538c4?source=collection_archive---------9-----------------------#2020-06-10">https://towardsdatascience.com/graphql-best-practices-3fda586538c4?source=collection_archive---------9-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="443e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在使用 GraphQL 6 个月之后，我分享了我对创建 graph QL 服务器的良好实践的想法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7bbaac5b7419cafe22a7f367323c6589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U8gStHxjwHgV9ZC5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@wesson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威森·王</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="6881" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">首先</h1><p id="365d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">GraphQL 是一种 API 查询语言，也是一种用现有数据完成这些查询的运行时语言。它为 API 中的数据提供了一个完整的、可理解的描述，并且让客户能够准确地要求他们所需要的，仅此而已。</p><p id="1aea" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它是由脸书开发的，作为他们移动应用的内部解决方案，后来向社区开源。</p><h1 id="ffab" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">最佳实践</h1><p id="a453" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你看一下官方的<a class="ae ky" href="https://graphql.org/learn/best-practices/" rel="noopener ugc nofollow" target="_blank"> GraphQL 最佳实践</a>页面，你会注意到它只分享了一些更常见的最佳实践的简要描述，在我看来，这只是一些指南，并没有支持实现的细节。我将尝试分享一些使用 GraphQL 的后端应用程序的具体实现。</p><p id="dfd2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这绝对不是一个完整的指南；这只是关于如何避免经常出现的最大陷阱的最佳实践和说明的列表。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="4ff6" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">将精益数据模型用于简单的查询和变异</h1><p id="c9ba" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当您开始创建模式时，设计数据模型可能会很棘手。有多种方法可以做到这一点，尽管大多数实现都可以正常工作，但是只有当您尝试扩展实现时，问题才会浮出水面。</p><p id="a494" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一般来说，看看已经在使用 GraphQL 的平台总是好的。Github  API 是理解输入和输出对象如何建模以及查询和变异如何暴露的好地方。</p><p id="69d3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">作为一般的经验法则。让你的<a class="ae ky" href="http://spec.graphql.org/June2018/#sec-Root-Operation-Types" rel="noopener ugc nofollow" target="_blank">突变</a>尽可能小。保持输入精简，并精心命名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="542d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">突变<code class="fe ng nh ni nj b">addComment</code>简单、简洁、清晰。它接受一个输入<code class="fe ng nh ni nj b">AddCommentInput</code>并返回一个<code class="fe ng nh ni nj b">Comment</code>。我们正在应用一个非空的修饰符(！)以确保输入有效负载不能为空。这里需要注意的一点是<strong class="lt iu">我们发送回创建/更新的对象</strong>。这允许客户端更新状态，以便用户知道是否有更新。</p><p id="b533" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">相当整洁！</p><p id="873c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如有任何问题或讨论，请随时联系我。我在推特上有空。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="092c" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">使用嵌套对象减少网络调用</h1><p id="cd2a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">上例中的类型<code class="fe ng nh ni nj b">Comment</code>是一个只有一个字段的简单类型。假设我们想将<code class="fe ng nh ni nj b">userId</code>作为<code class="fe ng nh ni nj b">Comment</code>的一部分发送回去。一种可能的方法是这样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d79e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">虽然这看起来是一种快速简单的方法，但是有一个小问题。对于前端来说，<code class="fe ng nh ni nj b">userId</code>本身并不是很有用，它最终必须调用<code class="fe ng nh ni nj b">userId</code>来获取用户。这确实很不方便，也没有最大限度地发挥 GraphQL 的威力。在 GraphQL 中，嵌套输出类型要好得多。这样，我们可以用一个请求调用所有的东西，还可以用<a class="ae ky" href="https://github.com/facebook/dataloader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>执行缓存和批处理。</p><p id="43a4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">方法将是在<code class="fe ng nh ni nj b">Comment</code>中发送<code class="fe ng nh ni nj b">User</code>。它看起来会像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7bb5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后查询看起来像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="6405" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">启用正确的错误处理</h1><p id="9d84" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是几乎每个人在开始时都会忘记的事情之一，然后当应用程序变得庞大时，覆盖错误情况就变得非常麻烦。当涉及到 GraphQl 错误处理时可能会非常棘手，因为响应总是有一个 HTTP 状态<code class="fe ng nh ni nj b">200 OK</code>。如果请求失败，JSON 有效负载响应将包含一个名为<code class="fe ng nh ni nj b">errors</code>的根字段，其中包含失败的详细信息。</p><p id="0293" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果没有适当的错误处理，响应将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2e6c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这一点帮助都没有——回复并没有告诉你到底哪里出了问题。这就是为什么大多数应用程序失败了，却没有真正给用户提供正确的消息或后备选项。处理错误本身就是一个很大的话题，我为此写了一篇单独的博客，里面有一个完整的运行示例。可以在这里找到。</p><div class="nk nl gp gr nm nn"><a href="https://medium.com/better-programming/error-handling-with-graphql-spring-boot-and-kotlin-ed55f9da4221" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">用 GraphQL、Spring Boot 和科特林处理错误</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">使用 Spring Boot 和 Kotlin 对 GraphQL 错误和异常建模</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ks nn"/></div></div></a></div><p id="7214" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">简而言之，实现后的输出如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="7067" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">使用接口和联合进行抽象</h1><p id="92cb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://graphql.github.io/graphql-spec/June2018/#sec-Interfaces" rel="noopener ugc nofollow" target="_blank">接口</a>作为父对象，其他对象可以继承。</p><blockquote class="oc od oe"><p id="b824" class="lr ls of lt b lu mn ju lw lx mo jx lz og mp mc md oh mq mg mh oi mr mk ml mm im bi translated">接口类型扩展用于表示从某个原始接口扩展而来的接口。例如，这可能用于表示多种类型的常见本地数据，或者由 GraphQL 服务(它本身是另一个 GraphQL 服务的扩展)来表示。</p></blockquote><p id="88b7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">并且<a class="ae ky" href="https://graphql.github.io/graphql-spec/June2018/#sec-Unions" rel="noopener ugc nofollow" target="_blank">联合</a>是一种表示许多对象的对象类型。</p><blockquote class="oc od oe"><p id="e87d" class="lr ls of lt b lu mn ju lw lx mo jx lz og mp mc md oh mq mg mh oi mr mk ml mm im bi translated">GraphQL 联合表示可能是 GraphQL 对象类型列表中的一个对象，但是在这些类型之间不提供有保证的字段。它们与接口的不同之处还在于，对象类型声明它们实现什么接口，但不知道包含它们的联合是什么。</p></blockquote><p id="6f52" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">考虑下面的例子。这个概要文件是一个由<code class="fe ng nh ni nj b">User</code>和<code class="fe ng nh ni nj b">Company</code>实现的接口。很少有字段是必填的。可以根据不同的类型和要求添加附加字段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2732" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当您的查询需要返回两种类型时，可以使用类似的联合。您的<code class="fe ng nh ni nj b">search</code>查询可以返回<code class="fe ng nh ni nj b">User</code>或<code class="fe ng nh ni nj b">Company</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="113c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">关于更详细的解释和实现，你可以阅读这个。</p><div class="nk nl gp gr nm nn"><a href="https://medium.com/better-programming/using-graphql-with-spring-boot-interfaces-and-unions-a76f62d62867" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">通过 Spring Boot 使用 GraphQL:接口和联合</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">GraphQL 的接口和联合提供了一种在查询中处理多种字段类型的好方法</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="oj l ny nz oa nw ob ks nn"/></div></div></a></div></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="03b3" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">使用片段重用已定义的类型</h1><p id="a9b8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">片段是 GraphQL 中可重用的东西。你可以假设像编程语言中的函数一样的片段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b2c7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用扩展运算符(<code class="fe ng nh ni nj b">...</code>)消耗片段。这样会减少很多冗余代码。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="4ce5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢阅读。我希望它能帮助您实现一个健壮的 GraphQL 服务器。这些方法屡试不爽。如果你有除此之外的建议，请随时回复。如有任何问题或讨论，请随时联系我。我在推特上有空。</p><p id="4a31" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你想知道 GraphQL 是否适合你，你可能会有兴趣阅读这篇文章。</p><div class="nk nl gp gr nm nn"><a href="https://levelup.gitconnected.com/6-months-of-using-graphql-faa0fb68b4af" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">使用 GraphQL 个月</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">在后端使用 GraphQL 做了 6 个月的项目后，我衡量了这项技术是否适合…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nw l"><div class="ok l ny nz oa nw ob ks nn"/></div></div></a></div><p id="1f57" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">参考资料:</p><ul class=""><li id="5f69" class="ol om it lt b lu mn lx mo ma on me oo mi op mm oq or os ot bi translated"><a class="ae ky" href="http://spec.graphql.org/June2018/#sec-Unions" rel="noopener ugc nofollow" target="_blank"> GraphQL 规格</a></li><li id="d3eb" class="ol om it lt b lu ou lx ov ma ow me ox mi oy mm oq or os ot bi translated"><a class="ae ky" href="https://graphql.org/learn/best-practices/" rel="noopener ugc nofollow" target="_blank"> GraphQL 最佳实践</a></li><li id="d7e5" class="ol om it lt b lu ou lx ov ma ow me ox mi oy mm oq or os ot bi translated"><a class="ae ky" href="https://medium.com/better-programming/using-graphql-with-spring-boot-interfaces-and-unions-a76f62d62867" rel="noopener"> GraphQL 接口和联合</a></li><li id="b5e5" class="ol om it lt b lu ou lx ov ma ow me ox mi oy mm oq or os ot bi translated"><a class="ae ky" href="https://medium.com/better-programming/error-handling-with-graphql-spring-boot-and-kotlin-ed55f9da4221" rel="noopener"> GraphQL 错误处理</a></li></ul></div></div>    
</body>
</html>