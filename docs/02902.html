<html>
<head>
<title>Grid Search for Hyperparameter Tuning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超参数调谐的网格搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/grid-search-for-hyperparameter-tuning-9f63945e8fec?source=collection_archive---------6-----------------------#2020-03-20">https://towardsdatascience.com/grid-search-for-hyperparameter-tuning-9f63945e8fec?source=collection_archive---------6-----------------------#2020-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e6c0aa1acef79f8de12affdf5df4a6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJMc9evUQdalxnZ8PHoD5Q.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.flickr.com/photos/gedankenstuecke/186651353/" rel="noopener ugc nofollow" target="_blank">图像来源</a></p></figure><p id="57a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">各位机器学习爱好者好！由于实习的原因，我已经有一段时间没有在 Medium 上写东西了。当我在做我的项目时，我面临着一种情况，我需要用不同的超参数来尝试不同的分类器。我发现每次都很难手动更改超参数并使它们适合我的训练数据。原因如下:</p><ul class=""><li id="0e97" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">这很费时间</li><li id="68ae" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">很难跟踪我们尝试过的超参数，我们仍然必须尝试</li></ul><p id="2f82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我很快询问谷歌是否有解决我的问题的方法，谷歌向我展示了来自 Sklearn 的名为<strong class="ki iu">的东西。让我用一个简单的例子来分享我是如何利用这个 GridSearchCV 来解决我的问题的。</strong></p><h2 id="a347" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">什么是 GridSearchCV？</h2><p id="f1b8" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">GridSearchCV 是一个库函数，是 sklearn 的 model_selection 包的成员。它有助于遍历预定义的超参数，并使您的估计器(模型)适合您的训练集。因此，最后，您可以从列出的超参数中选择最佳参数。</p><p id="97a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除此之外，您可以为每组超参数指定交叉验证的次数。</p><h2 id="4610" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">带解释的示例</h2><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="b11c" class="ls lt it mv b gy mz na l nb nc">from sklearn.model_selection import GridSearchCV<br/>from sklearn.neighbors import KNeighborsClassifier</span><span id="843d" class="ls lt it mv b gy nd na l nb nc">kn = KNeighborsClassifier()</span><span id="57e9" class="ls lt it mv b gy nd na l nb nc">params = {<br/>    'n_neighbors' : [5, 25],<br/>    'weights': ['uniform', 'distance'],<br/>    'algorithm': ['auto', 'ball_tree', 'kd_tree', 'brute']<br/>}</span><span id="7b1a" class="ls lt it mv b gy nd na l nb nc">grid_kn = GridSearchCV(estimator = kn,<br/>                        param_grid = params,<br/>                        scoring = 'accuracy', <br/>                        cv = 5, <br/>                        verbose = 1,<br/>                        n_jobs = -1)</span><span id="4dce" class="ls lt it mv b gy nd na l nb nc">grid_kn.fit(X_train, y_train)</span></pre><p id="89cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来分解一下上面的代码块。像往常一样，您需要从 sklearn 库中导入<strong class="ki iu"> GridSearchCV </strong>和<strong class="ki iu">估计器</strong>/模型(在我的例子中是 KNClassifier)。</p><p id="3cc4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是定义您想要尝试的超参数。这取决于你选择的评估者。您所需要做的就是创建一个字典(我的代码中的变量 params ),它将超参数作为键，并有一个 iterable 来保存您需要尝试的选项。</p><p id="838f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后你要做的就是创建一个 GridSearchCV 的对象。这里基本上需要定义几个命名参数:</p><ol class=""><li id="3541" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld ne lk ll lm bi translated"><strong class="ki iu">估计器</strong>:您创建的估计器对象</li><li id="cd80" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ne lk ll lm bi translated"><strong class="ki iu"> params_grid </strong>:保存您想要尝试的超参数的字典对象</li><li id="a2b9" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ne lk ll lm bi translated"><strong class="ki iu">评分</strong>:您想要使用的评估指标，您可以简单地传递一个有效的评估指标字符串/对象</li><li id="e41a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ne lk ll lm bi translated"><strong class="ki iu"> cv </strong>:您必须为每组选定的超参数尝试交叉验证的次数</li><li id="e42a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ne lk ll lm bi translated"><strong class="ki iu"> verbose </strong>:您可以将它设置为 1，以便在将数据放入 GridSearchCV 时得到详细的打印结果</li><li id="8f89" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld ne lk ll lm bi translated"><strong class="ki iu"> n_jobs </strong>:如果 it -1 将使用所有可用的处理器，您希望为该任务并行运行的进程数。</li></ol><p id="b7e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些都是你需要定义的。然后你要像平时一样拟合你的训练数据。您将得到如下所示的第一行:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="a6e7" class="ls lt it mv b gy mz na l nb nc">Fitting 5 folds for each of 16 candidates, totalling 80 fits<br/>...<br/>...<br/>...</span></pre><p id="78b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你不明白这是什么意思吗？简单！因为我们必须为 n_neighbors 尝试两个选项，两个用于权重，四个用于算法，所以总共有 16 种不同的组合我们应该尝试。对于每个组合，我们有 5 个 CV 拟合，因此我们的 GridSearcCV 对象将测试 80 个不同的拟合。</p><p id="dea0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种适合的时间取决于你正在尝试的超参数的数量。一旦一切完成，您将得到如下输出:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="996e" class="ls lt it mv b gy mz na l nb nc">[Parallel(n_jobs=1)]: Done  80 out of  80 | elapsed: 74.1min finished]</span></pre><p id="c76d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后要知道什么是最好的参数，你可以简单地打印出来</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="9f8e" class="ls lt it mv b gy mz na l nb nc"># extract best estimator<br/>print(grid_kn.best_estimator_)</span><span id="9c20" class="ls lt it mv b gy nd na l nb nc">Output:<br/>KNeighborsClassifier(algorithm='auto', <br/>leaf_size=30, metric='minkowski',metric_params=None, n_jobs=-1, n_neighbors=25, p=2, weights='distance')</span><span id="d46d" class="ls lt it mv b gy nd na l nb nc"># to test the bestfit<br/>print(grid_kn.score(X_test, y_test))</span><span id="f275" class="ls lt it mv b gy nd na l nb nc">Output:<br/>0.9524753</span></pre><p id="5615" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很酷不是吗？现在你所要做的就是改变估计量，定义一个你必须尝试的超参数字典。希望这对你有帮助。要了解更多关于 GridSearchCV 的内容，请查看 sklearn 的官方文档。</p></div></div>    
</body>
</html>