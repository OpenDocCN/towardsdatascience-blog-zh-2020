<html>
<head>
<title>Level up your code with Python decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python decorators提升你的代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/level-up-your-code-with-python-decorators-c1966d78607?source=collection_archive---------17-----------------------#2020-06-07">https://towardsdatascience.com/level-up-your-code-with-python-decorators-c1966d78607?source=collection_archive---------17-----------------------#2020-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1542" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">日志记录、类型检查、异常处理等等！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a063054df8c7cae8474856e5c8844171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynhIIh7Fq7fIAKqFRSrrew.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由pexels上的<a class="ae ky" href="https://www.pexels.com/photo/brush-painting-the-white-wall-6368/" rel="noopener ugc nofollow" target="_blank"> kaboompics </a></p></figure><p id="4cb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每一个Python用户的生活中，都会有一个阶段，你可以从写好代码提升到伟大的代码。</p><p id="39de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你掌握了Python的核心功能，比如列表理解和三元运算符，你就应该准备好编写更具可读性的Python了。装饰器是提升代码可读性的关键，这里我们将介绍它们的基础知识，以及使用它们的3种方法。</p><h2 id="f8ec" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">什么是室内设计师？</h2><p id="418b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">简而言之，装饰器是包装其他函数的函数。如果你在一个功能的开始和结束都想要一些东西，那么装饰者会让你的生活变得更容易。</p><p id="617e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装饰者可以被看作是函数定义前的一个<code class="fe mt mu mv mw b">@</code>符号。你可能已经在一个<a class="ae ky" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank"> flask app </a>或<a class="ae ky" href="https://click.palletsprojects.com/en/7.x/" rel="noopener ugc nofollow" target="_blank"> click CLI </a>中发现了它们，但是解释它们如何工作的最简单的方法是通过一个简短的例子来完成。</p><p id="4dad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设在函数的开始，我们想打印“开始”，在函数的结尾，我们想打印“完成”。为了实现这一目标，我们可以采取以下措施:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="80ac" class="lv lw it mw b gy nb nc l nd ne">def circle_area(radius):<br/>    print("Started: circle_area")<br/>    area = 3.142 * radius ** 2<br/>    print("Finished")<br/>    return area</span><span id="dad7" class="lv lw it mw b gy nf nc l nd ne">area = circle_area(2)</span></pre><p id="e379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法是可行的，但是现在我们的代码充斥着打印语句。函数的实际内容可以只用一行来写，但是我们用了三行！因此，让我们通过创建一个包含我们操作的主要成分的新函数和另一个仅包含打印语句的函数来使这一点更清楚:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="ce9c" class="lv lw it mw b gy nb nc l nd ne">def circle_area(radius):<br/>    return 3.142 * radius ** 2</span><span id="ba69" class="lv lw it mw b gy nf nc l nd ne">def circle_area_and_print(radius):<br/>    print("Started: circle_area_and_print")<br/>    area = circle_area(radius)<br/>    print("Ended")<br/>    return area</span><span id="8b83" class="lv lw it mw b gy nf nc l nd ne">area = circle_area_and_print(2)</span></pre><p id="495a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，你可能会说这看起来并不清楚，因为我们比以前拥有更多的代码。乍一看，您可能会注意到我们添加的代码可读性更好。然而，我们的工作还没有完成，如果我们想从代码中得到更多呢？</p><p id="5097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比方说，我们也想在其他函数之前和之后打印。作为懒惰的数据科学家，我们不希望多次编写同一行代码，所以让我们尝试概括我们已经拥有的代码。我们可以用这个新的<code class="fe mt mu mv mw b">printer</code>函数做到这一点。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="2f65" class="lv lw it mw b gy nb nc l nd ne">def printer(function):<br/>    def new_function(*args):<br/>        print(f"Started: {function.__name__}")<br/>        output = function(*args)<br/>        print("Finished")<br/>        return output<br/>    return new_function</span><span id="f737" class="lv lw it mw b gy nf nc l nd ne">def circle_area(radius):<br/>    return 3.142 * radius ** 2</span><span id="d909" class="lv lw it mw b gy nf nc l nd ne">area = printer(circle_area)(2)</span></pre><p id="d326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<code class="fe mt mu mv mw b">printer</code>函数在这里做什么呢？</p><p id="5436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数的美妙之处在于，它构造了一个新函数，方法是在执行传递的函数之前和之后，将我们的原始函数添加到打印语句中。现在<code class="fe mt mu mv mw b">printer</code>返回了新的函数句柄，允许我们获取任意函数并使用打印语句返回它。</p><p id="3bed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是Python装饰器真正发挥作用的地方。现在我们已经编写了<code class="fe mt mu mv mw b">printer</code>函数来返回原始函数的修改版本，我们需要做的就是在函数定义前加上<code class="fe mt mu mv mw b">@printer</code>:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="da45" class="lv lw it mw b gy nb nc l nd ne">@printer<br/>def circle_area(radius):<br/>    return 3.142 * radius ** 2</span><span id="3259" class="lv lw it mw b gy nf nc l nd ne">area = circle_area(2)</span></pre><p id="acfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在这个简单的例子中，当您将printer decorator的使用与我们在开始时编写的代码进行比较时，我们的代码要清晰得多。</p><h2 id="c737" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">我还能用它们做什么？</h2><p id="5ecd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">装饰者有一些巧妙的技巧，可以让你的代码更容易理解和阅读。</p><p id="4439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看看:</p><ol class=""><li id="c2fe" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">日志记录(类似于第一个例子，但更有用)</li><li id="d2b6" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">类型检查</li><li id="da1b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">错误处理</li></ol><h2 id="3d91" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">1.记录</h2><p id="9d47" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于第一个示例，我们需要在脚本中编写一个小函数来设置日志记录:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="0ac5" class="lv lw it mw b gy nb nc l nd ne">import logging</span><span id="6bc0" class="lv lw it mw b gy nf nc l nd ne">def setup_logging(name="logger",<br/>                  filepath=None,<br/>                  stream_log_level="DEBUG",<br/>                  file_log_level="DEBUG"):<br/>    <br/>    logger = logging.getLogger(name)<br/>    logger.setLevel("DEBUG")<br/>    formatter = logging.Formatter(<br/>        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'<br/>    )</span><span id="7877" class="lv lw it mw b gy nf nc l nd ne">    ch = logging.StreamHandler()<br/>    ch.setLevel(getattr(logging, stream_log_level))<br/>    ch.setFormatter(formatter)<br/>    logger.addHandler(ch)</span><span id="c263" class="lv lw it mw b gy nf nc l nd ne">    if filepath is not None:<br/>        fh = logging.FileHandler(filepath)<br/>        fh.setLevel(getattr(logging, file_log_level))<br/>        fh.setFormatter(formatter)<br/>        logger.addHandler(fh)</span><span id="4c0f" class="lv lw it mw b gy nf nc l nd ne">    return logger</span><span id="c72f" class="lv lw it mw b gy nf nc l nd ne">logger = setup_logging(name="default_log",filepath="logger.log")</span></pre><p id="8699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以编写新的日志装饰器了:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="f924" class="lv lw it mw b gy nb nc l nd ne">def log_decorator(log_name):<br/>    def log_this(function):<br/>        logger = logging.getLogger(log_name)<br/>        def new_function(*args,**kwargs):<br/>            logger.debug(f"{function.__name__} - {args} - {kwargs}")<br/>            output = function(*args,**kwargs)<br/>            logger.debug(f"{function.__name__} returned: {output}")<br/>            return output<br/>        return new_function<br/>    return log_this</span></pre><p id="2aa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比我们之前看到的<code class="fe mt mu mv mw b">printer</code>装饰稍微复杂一些。这一次，我们想要构建一个可以接受参数(记录器的名称)的装饰器。</p><p id="8d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而装饰函数只能接受一个参数，所以我们将这个函数包装在另一个可以接受许多参数的函数中。你需要一段时间来理解这种类似于inception的函数包装，但是一旦你这样做了，它就是数据科学家工具箱中的无价工具。</p><h2 id="18b2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">2.类型检查</h2><p id="02c0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在这是一个有争议的问题，所以抓紧你的帽子，我们可能会经历一段颠簸的旅程…</p><p id="53c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些人会说这种修饰类型检查函数输入的方式被许多人认为是“非Pythonic化的”。Python是一种动态类型的语言，所以冒着惹起太多麻烦的风险，重要的是要注意，一般来说，在编写Python时，我们应该请求原谅，而不是请求许可。</p><p id="f262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果你愿意对Python的法则有点厚脸皮，那么你会发现这是一个非常方便的工具，尤其是在开发代码的时候。当识别正在传递的错误类型时，它变得非常清楚。</p><p id="9444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住所有这些，下面是代码:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="af01" class="lv lw it mw b gy nb nc l nd ne">def accepts(*types):<br/>    def check_accepts(function):<br/>        assert len(types) == function.__code__.co_argcount,\<br/>            "Number of typed inputs must match the function inputs"<br/>        def new_function(*args, **kwargs):<br/>            for (a, t) in zip(args, types):<br/>                assert isinstance(a, t), \<br/>                       "arg %r does not match %s" % (a,t)<br/>            return function(*args, **kwargs)<br/>        return new_function<br/>    return check_accepts</span><span id="e267" class="lv lw it mw b gy nf nc l nd ne">@accepts((int,float))<br/>def circle_area(radius):<br/>    return 3.142 * radius ** 2</span></pre><p id="244b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在我们已经确保了<code class="fe mt mu mv mw b">circle_area</code>函数的输入只接受类型<code class="fe mt mu mv mw b">ints</code>或<code class="fe mt mu mv mw b">floats</code>，否则它将引发一个<code class="fe mt mu mv mw b">AssertionError</code>。</p><h2 id="b0db" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">3.错误处理</h2><p id="9db8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于这个例子，让我们假设我们试图从一个API访问数据，但是这个API每分钟只允许给定数量的请求。我们可以编写一个装饰器来包装API调用，并继续尝试获取数据，直到成功。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="8e19" class="lv lw it mw b gy nb nc l nd ne">import api<br/>import time<br/>API_WAIT_TIME = 5 #minutes<br/>MAX_RETRIES = 10</span><span id="80f2" class="lv lw it mw b gy nf nc l nd ne">def error_handling(api_function):<br/>    def trial(*args, num_retries=0, **kwargs):<br/>        try:<br/>            return api_function(*args, **kwargs)<br/>        except api.error.RateLimitError:<br/>            if num_retries &gt; MAX_RETRIES:<br/>                raise RuntimeError("Too many retries")<br/>            else:<br/>                msg = f"rate limit reached. Waiting {API_WAIT_TIME} minutes ..."<br/>                time.sleep(API_WAIT_TIME * 60)<br/>                return trial(*args, num_retries=num_retries + 1, **kwargs)</span><span id="a045" class="lv lw it mw b gy nf nc l nd ne">    return trial</span></pre><p id="8b89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次我们从<code class="fe mt mu mv mw b">api</code>模块请求数据时，我们都可以使用这个装饰器。装饰器将继续尝试，直到它获得数据或达到允许的最大重试次数，如果是这种情况，将引发一个<code class="fe mt mu mv mw b">RuntimeError</code>。</p><p id="e852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，这个函数的一个非常相似的版本可以用来任意捕捉不同的异常，并以不同的方式处理它们。我将让读者自己去思考使用这种装饰器的新方法。</p><h2 id="0224" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">我们学到了什么？</h2><p id="0538" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">希望您现在对什么是Python装饰器有了更好的了解，并且有信心在您的代码库中使用它(如果没有，那么我让您失望了……)。</p><p id="ecfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的关键是，如果你有一个函数经常出现在另一个函数的开头和结尾，那么装饰器将是你新的最好的朋友。装饰者将帮助你的代码不仅可读性更好，而且更加模块化和可重用。</p></div></div>    
</body>
</html>