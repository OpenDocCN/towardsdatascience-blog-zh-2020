<html>
<head>
<title>SQL Unit Testing Stored Procedure for SQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL Server 的 SQL 单元测试存储过程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-unit-testing-stored-procedure-for-sql-server-9565d86ac458?source=collection_archive---------46-----------------------#2020-08-31">https://towardsdatascience.com/sql-unit-testing-stored-procedure-for-sql-server-9565d86ac458?source=collection_archive---------46-----------------------#2020-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f49e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本文中，我们将对招聘服务的 SQL Server 数据库的存储过程进行 SQL 单元测试。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/c05be435bf0f7033419ec0900cf9439f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sahusFqi3LF7F20U7gkmnA.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图片来自<a class="ae kz" href="https://www.piqsels.com/en/public-domain-photo-zkulb" rel="noopener ugc nofollow" target="_blank"> Piqsels </a> (CC0)</p></figure><p id="2aeb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">单元测试是数据库开发过程的重要组成部分。它的主要目标是测试数据库对象的组成部分，以便在项目早期识别任何故障或缺陷。这种方法允许数据库开发人员确保他们所做的更改得到验证，并且项目将正常工作。在本文中，我们将主要关注对 SQL Server 数据库中的存储过程进行单元测试，并举例说明使用 dbForge 单元测试工具进行单元测试是多么简单。</p><p id="7364" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">之前，我们讨论了<a class="ae kz" rel="noopener" target="_blank" href="/sql-database-design-basics-with-example-8dcce4b0c687">为招聘服务创建 SQL Server 数据库的过程。</a></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi lw"><img src="../Images/082070c7d7aa3d2bd1e964ca8e0487cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_VCdmAOKS692KsdKt2wsQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.1 .招聘服务的数据库模式</p></figure><p id="bb19" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如上所示，数据库包含以下实体:</p><ul class=""><li id="6838" class="lx ly it lc b ld le lg lh lj lz ln ma lr mb lv mc md me mf bi translated">雇员</li><li id="3e3c" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv mc md me mf bi translated">公司</li><li id="9627" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv mc md me mf bi translated">位置</li><li id="80de" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv mc md me mf bi translated">项目</li><li id="01f7" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv mc md me mf bi translated">技能</li></ul><p id="614a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">尽管如此，在这一系列文章中，我们不知何故忽略了单元测试的一个重要方面。所以现在，我建议我们更仔细地研究一下这种方法，并通过实现 SearchEmployee 存储过程来举例说明这种方法，该存储过程用于基于特定技能的员工搜索。为了确保数据的完整性，我们应该在技能表上添加一个唯一的约束，如下所示:</p><pre class="kk kl km kn gt ml mm mn mo aw mp bi"><span id="4b32" class="mq mr it mm b gy ms mt l mu mv">ALTER TABLE [dbo].[Skill] ADD CONSTRAINT UniqueSkillName UNIQUE(SkillName);</span></pre><p id="e6c8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是，在此之前，请使用以下查询确保 SkillName 字段中的数据不包含任何重复条目:</p><pre class="kk kl km kn gt ml mm mn mo aw mp bi"><span id="315b" class="mq mr it mm b gy ms mt l mu mv">SELECT <br/>      [SkillName] <br/>FROM [JobEmpl].[dbo].[Skill] <br/>GROUP BY [SkillName] <br/>HAVING COUNT(*) &gt; 1;</span></pre><p id="3d14" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">假设您有重复的条目，那么您需要将所有记录规范化为 SkillName 字段中彼此相关的唯一值。</p><p id="478f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">好了，完成了一点:我们在技能名称中创建了一个惟一性约束。</p><p id="dff7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，该实现 SearchEmployee 存储过程了，如下所示:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="aad6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为什么不更详细地研究一下 SearchEmployee 存储过程的工作呢？</p><p id="18d0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，它有两个输入参数:</p><ol class=""><li id="2043" class="lx ly it lc b ld le lg lh lj lz ln ma lr mb lv my md me mf bi translated">@SkillList 是技能列表，用分号分隔。</li><li id="8d1b" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">@CountNotSkill 表示可以缺席的技能数(默认为 1)。</li></ol><p id="44bf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在让我们转到 SearchEmployee 存储过程的主体:</p><ol class=""><li id="5e05" class="lx ly it lc b ld le lg lh lj lz ln ma lr mb lv my md me mf bi translated">首先，我们定义了一个变量@count_skills，它用于计算数据库中与输入参数@SkillList 中报告的数量相对应的技能数量。</li><li id="0ce7" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">接下来，用内置函数<a class="ae kz" href="https://docs.microsoft.com/en-us/sql/t-sql/functions/string-split-transact-sql?view=sql-server-2017" rel="noopener ugc nofollow" target="_blank"> STRING_SPLIT </a>将@SkillList 字符串转换成临时表#tbl_skill_tmp。</li><li id="6e1d" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">然后，从技能表中找到所有合适的技能，并放入一个名为#tbl_skill_tmp 的新临时表中。</li><li id="8233" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">之后@算技能按照 par.1 算。</li><li id="55ab" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">随后，基于设定的技能收集关于项目(项目表)和作业历史(作业历史表)的必要信息；结果会进入一个名为#tbl_skill_tmp 的临时表。</li><li id="aabf" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">接下来，在 par 中获得的信息。5 根据 skill 和 employee 的标识符进行分组，结果放入临时表#tbl_res。</li><li id="288d" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">此外，在段落中获得的信息。6 与 Employee 表相结合，以获得雇员的详细信息(名和姓)，并且结果被存储到临时表#tbl_res2 中。该查询还统计每项技能在年、月和天中应用了多长时间，以使后续分析更加方便。</li><li id="0e8f" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">之后，从 par.7 的结果中检索雇员的信息，并将最终结果放入临时表#tbl_empl 中。</li><li id="457c" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">然后，对表#tbl_skill 和#tbl_empl 进行笛卡尔积运算，结果放入临时表#tbl_skill_empl。</li><li id="b9da" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">接下来，创建一个名为#tbl_res3 的临时表，它包括两个临时表#tbl_skill_empl 和#tbl_res2 的乘积，其中每对 employee 和 skill 都具有在第 7 段中获得的匹配信息</li><li id="d75e" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">然后，将符合输入参数的员工标识符收集到临时表#tbl_empl_res 中。此时，如果技能已经使用了至少 6 个月，则该技能被视为有效。</li><li id="320f" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">接下来，跟踪员工的结果输出和他们的技能，使用时间以年、月和天来衡量，以及他们的应用程序的开始和结束日期。</li><li id="bfd5" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">然后，您将看到关于我们感兴趣的技能的员工历史的详细总结。</li><li id="b7ef" class="lx ly it lc b ld mg lg mh lj mi ln mj lr mk lv my md me mf bi translated">最后，我们删除在这个存储过程中创建的所有临时表。</li></ol><p id="8150" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">经过上述步骤，我们可以提取出在 C#和 T-SQL 语言以及 ASP.NET 技术方面有能力的员工的名字，条件是最多有一个人缺乏技能，如下所示:</p><pre class="kk kl km kn gt ml mm mn mo aw mp bi"><span id="adc3" class="mq mr it mm b gy ms mt l mu mv">EXEC [dbo].[SearchEmployee] @SkillList = N'C#;T-SQL;ASP.NET'<br/>                                                ,@CountNotSkill = 1;</span></pre><h1 id="b7ae" class="mz mr it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">创建并运行存储过程的 SQL Server 单元测试</h1><p id="35b1" class="pw-post-body-paragraph la lb it lc b ld nq ju lf lg nr jx li lj ns ll lm ln nt lp lq lr nu lt lu lv im bi translated">为了简化单元测试，这个存储过程应该分成两部分:第一部分输出主要信息，第二部分输出找到的雇员的详细历史记录。然而，为了便于理解，我们将展示如何对存储过程应用单元测试。</p><p id="53a9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">至于我们要应用的工具:它是<a class="ae kz" href="https://www.devart.com/dbforge/sql/unit-test/" rel="noopener ugc nofollow" target="_blank">单元测试</a>工具，内置于 SSMS，也是<a class="ae kz" href="https://www.devart.com/dbforge/sql/studio/" rel="noopener ugc nofollow" target="_blank">db forge Studio for SQL Server</a>的一部分。</p><p id="2ba0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们来看看这个工具在<a class="ae kz" href="https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017" rel="noopener ugc nofollow" target="_blank"> SSMS </a>中的功能。</p><p id="a676" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">右键单击 JobEmpl 数据库，并在下拉列表中选择单元测试“安装测试框架…”:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e37a46fe5e844810a826251bfc957766.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*R4F7EhY8vcqZrz3u_H9a5A.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.2 .开始安装测试框架</p></figure><p id="336a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">类似地，右键单击 JobEmpl 数据库中的任何节点都可以调用该菜单。</p><p id="e76e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">接下来，确保服务器和数据库正确无误，然后单击“安装”:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/4dc28785e86bff026f93c39720f587db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*lPAswkUgnCPuiqk0S9FTPA.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.3 .安装测试框架</p></figure><p id="71a3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">安装过程如下:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/32c8e5a0c87a7d3acb013b495fdd0bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*-NkL0uFrvttfnCoqa2Nu_w.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.4 .测试框架安装流程</p></figure><p id="a6c3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">安装过程结束时，您将收到一条完成消息。单击“完成”按钮:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/6bf0dabd93d6076b54ff07e4208bd25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*nfwA2hYy7cJBi1HvfXMyRQ.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.5 .测试框架安装的成功完成</p></figure><p id="6c1f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请注意 JobEmpl 数据库。在下面，您可以看到 tSQLt 对象(表、视图、函数和存储过程)已经创建:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/93f23c0cda37f6f099dc772d47c85eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*1Wqe-9rUiQrE0xEoTJZbSA.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">目标 5–1 创建的 tSQLt 对象(第 1 部分)</p></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/4ee21b0ba9861c6fca89ec52dcd2af57.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*rRhZKOZt371V0Cce-JSlCA.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">img . 5–2 创建 tSQLt 对象(第 2 部分)</p></figure><p id="44e0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">接下来，要创建一个测试，右键单击 JobEmpl 数据库并选择单元测试“添加新测试…”命令:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/1c3b15ef8a3158260422653b6642b5c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*gV0eJ5roYJLgze80Xlvi7w.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.6 .新单元测试的创建</p></figure><p id="c0d6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们现在需要为名为 UT_SearchEmployee_Exception 的新测试定制设置，并单击“Add Test”:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ob"><img src="../Images/77dfcd6a3a172de34cc30d5c2d1cf6dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*fjGLJsemNJ_HpecMTp42sw.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.7 .自定义已创建测试的设置</p></figure><p id="077f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">测试创建结束时，会出现一个信息窗口。单击“完成”按钮:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/58d63e1cd047035f8aaf499a5429383f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*vvEj7gxPbK4py9muwCMX_w.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.8 .测试创建的成功完成</p></figure><p id="4a98" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后，您将在 SSMS 看到一个新选项卡，代码如下:</p><pre class="kk kl km kn gt ml mm mn mo aw mp bi"><span id="8dc1" class="mq mr it mm b gy ms mt l mu mv">-- Comments here are associated with the test. <br/>-- For test case examples, see: http://tsqlt.org/user-guide/tsqlt-tutorial/ ALTER PROCEDURE CL1.[test UT_SearchEmployee_Exception] <br/>AS <br/>BEGIN <br/>--Assemble <br/>-- This section is for code that sets up the environment. It often <br/>-- contains calls to methods such as tSQLt.FakeTable and tSQLt.SpyProcedure <br/>-- along with INSERTs of relevant data. <br/>-- For more information, see http://tsqlt.org/user-guide/isolating-dependencies/ </span><span id="cbf6" class="mq mr it mm b gy od mt l mu mv">--Act <br/>-- Execute the code under test like a stored procedure, function or view <br/>-- and capture the results in variables or tables. </span><span id="ef6b" class="mq mr it mm b gy od mt l mu mv">--Assert <br/>-- Compare the expected and actual values, or call tSQLt.Fail in an IF statement. <br/>-- Available Asserts: tSQLt.AssertEquals, tSQLt.AssertEqualsString, tSQLt.AssertEqualsTable <br/>-- For a complete list, see: http://tsqlt.org/user-guide/assertions/ EXEC tSQLt.Fail 'TODO:Implement this test.' </span><span id="3a50" class="mq mr it mm b gy od mt l mu mv">END;</span></pre><p id="0a8d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">从链接来看，该工具有几个内置函数(tSQLt 框架),这些函数有很多功能:在它们的帮助下，您可以针对不同的条件测试不同的数据库对象。让我们考虑一些例子:<br/> 1)你可以检查两个表中的数据是否匹配。<br/> 2)您可以检查某个对象是否在数据库中(如果在，则测试运行成功，如果不在，则测试失败)，等等。</p><p id="d388" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">唉，在 T-SQL 中不可能捕获多个输出(几个集合)。通常，这在中执行。NET，这是一个创建复杂测试的安全地方。最近，有一种倾向，主要是进行测试。MS SQL Server 的. NET 级别。</p><p id="8bc0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">无论如何，让我们回到 T-SQL。</p><p id="0d0a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了简单起见，我们在存储过程中注释掉详细信息的输出，也就是说，我们在 SearchEmployee:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6fa1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在我们的例子中，测试相当简单，它将检查以下规则:必须有数据，否则，它将输出一条消息，说明技能可能不正确，并且存储过程没有正常工作。</p><p id="c28a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">未能实现该规则表明，要么数据不存在，必须基于不同的标准进行搜索，要么标准定义不正确，必须进行修正。这也可能意味着存储过程本身无法正常运行。</p><p id="8484" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，我们返回到之前生成的代码，并将其更改如下:</p><pre class="kk kl km kn gt ml mm mn mo aw mp bi"><span id="83e6" class="mq mr it mm b gy ms mt l mu mv">-- Comments here are associated with the test. <br/>-- For test case examples, see: http://tsqlt.org/user-guide/tsqlt-tutorial/ <br/>ALTER PROCEDURE CL1.[test UT_SearchEmployee_Exception] <br/>AS <br/>BEGIN <br/>  CREATE TABLE #tbl ([EmployeeID] INT, [LastName] NVARCHAR(255),  [FirstName] NVARCHAR(255), <br/>  [SkillID] INT, [SkillName] NVARCHAR(255), [StartDate] DATETIME, [FinishDate] DATETIME, <br/>  [Years] INT, [Months] INT, [Days] INT); </span><span id="ada5" class="mq mr it mm b gy od mt l mu mv">  INSERT INTO #tbl <br/>  EXEC [dbo].[SearchEmployee] @SkillList = N'programming'<br/>                                             ,@CountNotSkill = 1; </span><span id="f16d" class="mq mr it mm b gy od mt l mu mv">  IF(NOT EXISTS(SELECT TOP(1) 1 FROM #tbl)) <br/>    EXEC tSQLt.Fail 'Nothing found. Check input parameters and stored procedure code'; </span><span id="af5a" class="mq mr it mm b gy od mt l mu mv">  DROP TABLE #tbl; <br/>END;</span></pre><p id="4e1b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，让我们在 JobEmpl 数据库上再单击一次右键，并在下拉菜单中选择单元测试“查看测试列表”命令:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/6a0a3ded51df82276f73767d5e86e35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*Uj6nnhtBuNY8yoqBcIggDA.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.9 .调用查看测试列表命令</p></figure><p id="40be" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">之后，我们选择我们需要的测试并运行它:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b5a06b6d2d9f1dd4dcba172f8c0a58de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*Re9NIMJwtOqd5PgM3WstKg.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.10 .运行给定的测试</p></figure><p id="8d21" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">正如我们在下面看到的，测试并不成功:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi og"><img src="../Images/630b8e4d72fb938f2e5630fa7b48692f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*SW-yd_WUAWOcdWaRvqaPRQ.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.11 .运行单元测试导致错误</p></figure><p id="5c6b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">需要强调的是，您可以选择多个单元测试并启动它们，或者只启动其中的几个。如有必要，您可以创建和删除测试。在这里，我们将通过点击“打开测试”命令来打开所选择的测试:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi og"><img src="../Images/630b8e4d72fb938f2e5630fa7b48692f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*SW-yd_WUAWOcdWaRvqaPRQ.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.12 .选择打开单元测试的命令</p></figure><p id="3602" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们希望将代码更改如下:</p><pre class="kk kl km kn gt ml mm mn mo aw mp bi"><span id="7d4b" class="mq mr it mm b gy ms mt l mu mv">-- Comments here are associated with the test. <br/>-- For test case examples, see: http://tsqlt.org/user-guide/tsqlt-tutorial/ <br/>ALTER PROCEDURE CL1.[test UT_SearchEmployee_Exception] <br/>AS <br/>BEGIN <br/>    CREATE TABLE #tbl ([EmployeeID] INT, [LastName] NVARCHAR(255), [FirstName] NVARCHAR(255), <br/>    [SkillID] INT, [SkillName] NVARCHAR(255), [StartDate] DATETIME, [FinishDate] DATETIME, <br/>    [Years] INT, [Months] INT, [Days] INT); </span><span id="ac75" class="mq mr it mm b gy od mt l mu mv">    INSERT INTO #tbl <br/>    EXEC [dbo].[SearchEmployee] @SkillList = N'C#;T-SQL;ASP.NET'<br/>                                               ,@CountNotSkill = 1; </span><span id="1daf" class="mq mr it mm b gy od mt l mu mv">   IF(NOT EXISTS(SELECT TOP(1) 1 FROM #tbl)) <br/>         EXEC tSQLt.Fail 'Nothing found. Check input parameters and stored procedure code'; </span><span id="edbe" class="mq mr it mm b gy od mt l mu mv">   DROP TABLE #tbl; <br/>END;</span></pre><p id="3626" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">接下来，让我们再次运行测试:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b98362af333b5a4447c724fa48649f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*lBbMpGqz8uQg0ADfesVIRA.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.13 .单元测试的成功完成</p></figure><p id="a49a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">结果，测试成功运行。错误的发生仅仅是因为“编程”技能不在数据库中，我们必须进一步详细描述该技能。</p><p id="efc3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除此之外，我们可以重命名测试类和测试本身，并更新测试信息:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/97b0cb35f1ab0b2cd2a62df3d3d45bdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*vCSH2swQGY-4NWwy7DK8iQ.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.14 .重命名和更新测试类信息的可能性</p></figure><p id="0d5c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您也可以运行测试并在窗口底部的测试结果中打开更改:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/45ef3961ca21e1944ec4a8d55d2afab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*OaQYhofxOSEESz5xOhL2rA.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Img.15 .测试结果功能</p></figure><p id="9c96" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最终，在单元测试的帮助下，您可以覆盖所创建的解决方案的大部分甚至全部功能。底线是单元测试是 DevOps 基本原则的一部分，因为它们在这个自动化过程中扮演着关键角色之一。如果您努力加快和保护数据库发布，您可以应用 DevOps automation 的几个解决方案之一，例如<a class="ae kz" href="https://www.devart.com/dbforge/sql/database-devops/" rel="noopener ugc nofollow" target="_blank">devo PS Automation for SQL Server</a>。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="3c69" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="or">原载于 2020 年 8 月 31 日</em><a class="ae kz" href="https://blog.devart.com/sql-unit-testing-stored-procedure-with-dbforge-unit-test-for-sql-server.html" rel="noopener ugc nofollow" target="_blank"><em class="or">【https://blog.devart.com】</em></a><em class="or">。</em></p></div></div>    
</body>
</html>