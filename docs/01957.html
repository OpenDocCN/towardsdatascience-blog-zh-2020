<html>
<head>
<title>Neo4j vs GRAKN Part II: Semantics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Neo4j vs GRAKN 第二部分:语义</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/neo4j-vs-grakn-part-ii-semantics-11a0847ae7a2?source=collection_archive---------13-----------------------#2020-02-24">https://towardsdatascience.com/neo4j-vs-grakn-part-ii-semantics-11a0847ae7a2?source=collection_archive---------13-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df72" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">语义之战:谁对数据建模更好？</h2></div><p id="b8c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">亲爱的读者，在这一部分，我将带你进入语义学的世界。在第一部分中，我们从总体上比较了 Grakn 和 Neo4j 世界，以了解范式差异如何导致不同的做事方式。在本文中，Grakn 和 Neo4j 将在建模和表示能力方面展开竞争，这是一场旨在征服语义世界的肉搏战😄</p><p id="ddc8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我职业生涯的早期，我从事知识工程(我从事搜索引擎维基化组件)。让我惊讶的是，在过去的 10 年里，知识图在可伸缩性、语言支持、开发者/用户界面、高效存储方面有了巨大的改进；但是就语义表达能力而言，没有什么能改变那么多。仍然有实例、关系、阶级和我们，那些努力尝试赋予意义的人。不管你是初学者还是更高级的，都没有区别。我们都知道这样一个事实:对任何一种语义收费都是困难的。这完全是另一个故事，我将在图形学习和知识库支持的聊天机器人帖子(即将推出)中详细介绍。</p><p id="3fca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不会让你等太久，让战斗开始吧:</p><h1 id="fbc1" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">1.文档和社区</h1><p id="a740" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">对于任何开源项目来说，最重要的是文档和社区支持。</p><p id="eec9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Neo4j 提供了<a class="ae mb" href="https://neo4j.com/developer/get-started/" rel="noopener ugc nofollow" target="_blank">文档、</a> <a class="ae mb" href="https://neo4j.com/graphacademy/online-training/introduction-to-neo4j/" rel="noopener ugc nofollow" target="_blank">视频教程、</a> <a class="ae mb" href="https://github.com/neo4j" rel="noopener ugc nofollow" target="_blank">一个胖 Github </a>、一个<a class="ae mb" href="https://community.neo4j.com/" rel="noopener ugc nofollow" target="_blank">社区</a>和一个<a class="ae mb" href="https://stackoverflow.com/questions/tagged/neo4j" rel="noopener ugc nofollow" target="_blank"> Stackoverflow 存档</a>。如果我搜索<code class="fe mc md me mf b">Neo4j tutorial</code>和<code class="fe mc md me mf b">GRAKN tutorial</code>，我会看到:</p><div class="mg mh mi mj gt ab cb"><figure class="mk ml mm mn mo mp mq paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><img src="../Images/2e4b33324656d95c2368d023f2cca379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*BqJH2wy4Gl3b0Y0LtikNrA.png"/></div></figure><figure class="mk ml mx mn mo mp mq paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><img src="../Images/93e207b99d54b4b027ef7848add9519a.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*CQ3eeKYU8BlIEDcR7ZDNPQ.png"/></div><p class="my mz gj gh gi na nb bd b be z dk nc di nd ne translated">看起来相当棒</p></figure></div><p id="4aa0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Grakn 提供了<a class="ae mb" href="https://dev.grakn.ai/docs/general/quickstart" rel="noopener ugc nofollow" target="_blank">文档</a>，<a class="ae mb" href="https://www.youtube.com/channel/UCwSkFrXPcQT2zo3XVWWFhUw" rel="noopener ugc nofollow" target="_blank">教程</a>，<a class="ae mb" href="https://github.com/graknlabs/grakn" rel="noopener ugc nofollow" target="_blank">充满示例的 Github repo，</a> <a class="ae mb" href="https://grakn.ai/community" rel="noopener ugc nofollow" target="_blank">一个社区</a>以及自己的<a class="ae mb" href="https://stackoverflow.com/questions/tagged/grakn" rel="noopener ugc nofollow" target="_blank"> Stackoverflow 空间</a>。我看到了精彩的文档和社区对这两者的支持。</p><p id="9ade" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Neo4j: 10/10，Grakn: 10/10</p><h1 id="1a6a" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">2.语言支持</h1><p id="8d2c" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">Grakn 提供 Java、Node.js 和 Python 客户端，涵盖了现代开发栈的相当一部分。Neo4j 在这方面提供了更多的变化；他们正式支持的驱动程序。NET、Java、JavaScript、Go 和 Python。Ruby、PHP、Erlang 和 PERL 驱动程序由社区贡献者提供。我发现 Grakn 的语言支持对于现代开发来说足够且体面；然而，Neo4j 因其提供的多样性而大放异彩。Neo4j 相对轻松地赢得了这一轮。不支持 C++，我各扣一分😄</p><p id="fa54" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Neo4j: 9/10，Grakn: 8/10</p><h1 id="3e95" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">3.OWL 导入</h1><p id="39ce" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">如果一个人从事知识表示或关联数据方面的工作，很可能他已经拥有大量 OWL 格式的本体资源。Grakn 没有直接导入 OWL 文件的方法，必须解析文件并创建自己的 Grakn 本体。更多关于这个问题的消息来自他们自己的口:【https://discuss.grakn.ai/t/migrating-owl-to-grakn/556】T2，尽管他们有一个 XML 导入器。加载器是 JSON、CSV 和 XML。</p><p id="398d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来到 Neo4j 情况就有点不一样了。Neo4j 团队似乎花了很大力气给他们的图形方法带来更多语义，并构建了<code class="fe mc md me mf b">neosemantics</code>。这个<a class="ae mb" href="https://github.com/neo4j-labs/neosemantics" rel="noopener ugc nofollow" target="_blank">贡献</a>包括了关于<a class="ae mb" href="https://neo4j.com/docs/labs/nsmntx/current/import/" rel="noopener ugc nofollow" target="_blank"> RDF 导入</a>、<a class="ae mb" href="https://neo4j.com/docs/labs/nsmntx/current/importing-ontologies/" rel="noopener ugc nofollow" target="_blank"> OWL 导入</a>的综合页面以及对它们的推理/推论。我觉得这种努力令人印象深刻。<code class="fe mc md me mf b">Neo4j</code>还如预期支持 XML、CSV、JSON 导入。你也可以阅读<a class="ae mb" href="https://lju-lazarevic.github.io/ImportingRDFSOWL.html" rel="noopener ugc nofollow" target="_blank">这篇文章</a>了解更多猫头鹰&amp; Neo4j duo，我真的很喜欢它。</p><p id="1533" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Neo4j: 8/10 表示努力，Grakn: 8/10 表示提供了一种本体语言</p><h1 id="b42e" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">4.语义关系</h1><p id="7b26" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">OWL 支持许多属性特征，包括自反性、非自反性、传递性、对称性、非对称性……如果你想建立一个<em class="nf">友谊网络</em>你需要<em class="nf">对称性</em>(友谊是相互的，如果 Carry 是 Barry 的朋友，Barry 当然是 Carry 的朋友)；如果你需要一个希腊神话的模型，你需要<em class="nf">及物性</em>:奥德修斯是赫尔墨斯的曾孙，特勒戈诺斯是奥德修斯和泰坦喀尔刻的儿子，那么显然特勒戈诺斯是赫尔墨斯的后代。</p><figure class="mg mh mi mj gt ml gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/4fe24290404f06ec65a97a6e950a76fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*E-VudOXPlTxePfN9WM-gug.png"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">下降关系:传递和不对称。猫头鹰风格，在被保护人内部拍摄的照片</p></figure><p id="956a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是 OWL 在游戏中发挥其全部语义力量的地方，使自己区别于 RDFS 和其他三联商店或图形信息持有者。OWL 从来没有像 T2 一样成为一个裸露的信息容器，它允许开发者对有意义的现实世界关系进行建模。</p><figure class="mg mh mi mj gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nh"><img src="../Images/58604498a1e3d4287bb7d029bc77567d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ClEYBXqeDZrXp4JWzWt6Cg.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">OWL 支持的酒店特征，在被保护人内部拍摄的照片</p></figure><p id="d91e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">语义关系是充分发挥语义力量的必要条件。我尝试了一下如何定义与 Grakn 的对称关系:</p><pre class="mg mh mi mj gt ni mf nj nk aw nl bi"><span id="3df0" class="nm lf it mf b gy nn no l np nq">friendship isa relation-type<br/>  relates friend;</span><span id="7ea5" class="nm lf it mf b gy nr no l np nq">person isa entity-type,  <br/>  plays-role friend;</span></pre><p id="c136" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定义传递关系有点棘手，但是<a class="ae mb" href="https://stackoverflow.com/questions/58802094/how-to-define-a-transitive-relation-in-graql" rel="noopener ugc nofollow" target="_blank">可行</a>😉Grakn 的思维方式通常侧重于本体和知识表示(即使底层存储是一个图)，如果您熟悉 OWL，Grakn 会有宾至如归的感觉。</p><p id="2dc5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来到 Neo4j 思维方式，Neo4j 是知识图，他喜欢做图。那么在这一点上，人们应该只把<em class="nf">关系看作是边。我看不出在创建时间上限制关系的直接方法。Neo4j 通常不允许无方向的边，然后创建一个具有任意方向的关系，并在查询时丢弃边方向<a class="ae mb" href="https://graphaware.com/neo4j/2013/10/11/neo4j-bidirectional-relationships.html" rel="noopener ugc nofollow" target="_blank">，就像这样</a>:</em></p><div class="mg mh mi mj gt ab cb"><figure class="mk ml ns mn mo mp mq paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><img src="../Images/23b82bcb7ce5359b309616a60134064a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*XwwVEro7QsIoNWxl1W0-0A.png"/></div></figure><figure class="mk ml nt mn mo mp mq paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><img src="../Images/dd046dd581c1e1d0b7288025a6045fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*j07K5yVggwhYGW_zIJVA3Q.png"/></div><p class="my mz gj gh gi na nb bd b be z dk nu di nv ne translated">出于效率和空间原因，创建具有任意方向的边。摘自上面的链接。</p></figure></div><p id="3761" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查询看起来像:</p><pre class="mg mh mi mj gt ni mf nj nk aw nl bi"><span id="546f" class="nm lf it mf b gy nn no l np nq">//find all partner companies of Neo4j </span><span id="ff46" class="nm lf it mf b gy nr no l np nq">MATCH (neo)-[:PARTNER]-(partner)  </span><span id="4fa6" class="nm lf it mf b gy nr no l np nq">which is union of </span><span id="1c44" class="nm lf it mf b gy nr no l np nq">MATCH (neo)-[:PARTNER]-&gt;(partner)  (edge is directed to partner)<br/>and<br/>MATCH (neo)&lt;-[:PARTNER]-(partner)  (edge is directed to neo)</span><span id="2f3d" class="nm lf it mf b gy nr no l np nq">(notice the edge directions)</span></pre><p id="5ff9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">传递关系和传递性在 Neo4j 中非常重要😉我们在图形算法的文章中探讨了这个问题。更多关于 Neo4j 的关系，你可以<a class="ae mb" href="https://medium.com/neo4j/graph-data-modeling-all-about-relationships-5060e46820ce" rel="noopener">访问</a>。</p><p id="5769" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经看到 Grakn 喜欢做超图。与 Neo4j 不同，超图提供了一个宽松的节点/边概念，并允许 Grakn 关系涉及两个以上的角色。</p><pre class="mg mh mi mj gt ni mf nj nk aw nl bi"><span id="ffd3" class="nm lf it mf b gy nn no l np nq">define<br/><br/>law-suit sub relation,<br/>  relates court,<br/>  relates judge,<br/>  relates DA,<br/>  relates defendant;</span><span id="af62" class="nm lf it mf b gy nr no l np nq">person sub entity,<br/>  has name,<br/>  plays judge,<br/>  plays DA,<br/>  plays defendant;</span><span id="d133" class="nm lf it mf b gy nr no l np nq">name sub attribute,<br/>  datatype string;</span></pre><p id="9418" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在 Grakn <a class="ae mb" href="https://blog.grakn.ai/modelling-data-with-hypergraphs-edff1e12edf0" rel="noopener ugc nofollow" target="_blank">博客</a>上阅读更多关于这个主题的内容。这是对真实世界数据建模的一个非常重要的特性，否则人们必须经历许多不必要的痛苦，类似于<a class="ae mb" href="https://www.w3.org/TR/swbp-n-aryRelations/" rel="noopener ugc nofollow" target="_blank"> OWL ways </a>。</p><h1 id="ebd2" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">5.推理者</h1><p id="7b90" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">Grakn 中的推理通过<code class="fe mc md me mf b">inference rules</code>工作。如何定义规则相当简单，在模式创建期间创建推理规则集。根据文档，规则不是直接存储在图中，而是根据查询时间进行推断。推理规则看起来像</p><pre class="mg mh mi mj gt ni mf nj nk aw nl bi"><span id="be59" class="nm lf it mf b gy nn no l np nq">define rule-id sub rule,<br/>  when LHS then RHS;</span></pre><p id="0a82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显而易见的是:如果满足左侧<em class="nf">的条件</em>，那么请推断右侧<em class="nf">的条件</em>。让我们看一个例子，这是人们如何自然地定义一个 being <a class="ae mb" href="https://dev.grakn.ai/docs/schema/rules" rel="noopener ugc nofollow" target="_blank"> siblings </a>关系:</p><pre class="mg mh mi mj gt ni mf nj nk aw nl bi"><span id="96a2" class="nm lf it mf b gy nn no l np nq">define<br/><br/>people-with-same-parents-are-siblings sub rule,<br/>when {<br/>    (mother: $m, $x) isa parentship;<br/>    (mother: $m, $y) isa parentship;<br/>    (father: $f, $x) isa parentship;<br/>    (father: $f, $y) isa parentship;<br/>    $x != $y;<br/>}, then {<br/>    ($x, $y) isa siblings;<br/>};</span></pre><p id="a4be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RHS 可以描述一个推断的关系，或者一个实体的一些属性。例如，在这个如何推断城市大洲的例子中，RHS 是关于实体-属性关系的推断，即<code class="fe mc md me mf b">has:</code></p><pre class="mg mh mi mj gt ni mf nj nk aw nl bi"><span id="d76f" class="nm lf it mf b gy nn no l np nq">city-in-continent sub inference-rule,<br/>when { <br/>(contains-city: $country1, in-country: $city1) isa has-city;           $country1 has continent $continent1;<br/>}then <br/>{ <br/>$city1 has inf-continent $continent1; <br/>};</span></pre><p id="09d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，人们可以推断实体、属性和关系，也就是节点、属性和边。我真的很喜欢 Grakn 的方式，Graql 的语义美在这一点上闪闪发光。效率对我的观察也很好。如果想了解更多，可以跳转到<a class="ae mb" href="https://blog.grakn.ai/inference-made-simple-f333fd8abce4" rel="noopener ugc nofollow" target="_blank">这篇帖子</a>。</p><p id="1d83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，推理是 Graql 的核心部分，不幸的是 Cypher 没有内置推理。Neo4j 仍然没有放弃，并且<a class="ae mb" href="https://github.com/neo4j-labs/neosemantics" rel="noopener ugc nofollow" target="_blank">新语义</a>再次发挥作用以获得更多语义。正如在<a class="ae mb" href="https://neo4j.com/docs/labs/nsmntx/current/inference/" rel="noopener ugc nofollow" target="_blank">文档</a>中所描述的，可以推断出<code class="fe mc md me mf b">WHERE</code>子句中导入的本体的节点和关系:</p><pre class="mg mh mi mj gt ni mf nj nk aw nl bi"><span id="6c7c" class="nm lf it mf b gy nn no l np nq">CALL semantics.inference.nodesLabelled('Crystallography',  <br/>     { catNameProp: "dbLabel", catLabel: "LCSHTopic", subCatRel:     "NARROWER_THAN" }) <br/>YIELD node<br/>RETURN node.identifier as id, node.title as title, labels(node)   as categories</span></pre><p id="56ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，在 Neo4j 图表上，我看不到简单直接的推理方式。这并不奇怪，因为 Neo4j 喜欢做一个图表。实际上，这里的比较根本不适用。</p><p id="936f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Neo4j: 4/10 为努力；Grakn: 10/10 完美推理。格拉克无疑是这里的赢家。</p><h1 id="3fd7" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">6.语义力量</h1><p id="fc38" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">正如我多次写 Neo4j 喜欢做图；他们的正式名称是一个<em class="nf">图形数据库。</em>另一方面，Grakn 喜欢成为<em class="nf">知识图</em>并且更加面向知识；他们仍然没有牺牲语义，提供一种本体语言来创建和查询图形。我真的很喜欢 Graql 面向语义，它隐藏了底层的图形，使它看起来像只是本体编写和推理。这是纯粹的美。如果你像我一样站在语义学的角度，你会喜欢这种烟雾和镜子。</p><p id="abd7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Cypher 看起来像一个简单的数据库查询(尽管它包含很多语义并提供路径查询)。这感觉就像为您的旧日志数据库编写 SQL 查询，虽然它非常正确和高效，但并不令人兴奋。</p><p id="5096" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在建模关系类别中，Grakn 凭借支持<code class="fe mc md me mf b">n-ary</code>关系胜出。老实说，我很惊讶为什么以前没有人实现<code class="fe mc md me mf b">n-ary</code>关系，把我们从巨大的痛苦中拯救出来。</p><p id="14bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个巨大的优势是，Grakn 提供了逻辑完整性，这是 NoSQL 和图形数据库普遍缺乏的，Neo4j 也是如此。同时，它可以像 Neo4j 提供的 NoSQL 一样水平扩展。这两个平台的水平扩展能力给我留下了非常深刻的印象，而没有从语义上妥协；但是 Grakn 以其逻辑完整性赢得了我的心。</p><p id="aa61" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不会坚持太久的，胜利者是格拉克。我发现 Grakn 在语义上比 Graql 更具表现力，能够以一种有机的方式表达子类和子关系，定义抽象实体、属性和关系的能力，允许 n 元关系，有一个内置的推理机…使 Grakn 成为这里的赢家。</p><p id="9974" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">neo4j:7/10；2010 年 9 月</p><h1 id="c665" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">8.文本支持</h1><p id="0acb" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">这一节是根据我的口味加的，因为我喜欢文字，你懂的😉(抱歉地理编码/空间人，这是我的博客😅)</p><p id="550b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Grakn <code class="fe mc md me mf b">match</code>支撑<code class="fe mc md me mf b">regex </code>和<code class="fe mc md me mf b">contains</code>。典型的查询可能如下所示:</p><pre class="mg mh mi mj gt ni mf nj nk aw nl bi"><span id="ee6b" class="nm lf it mf b gy nn no l np nq">match $phone-number contains "+49"; get;</span><span id="1cd9" class="nm lf it mf b gy nr no l np nq">match $x like "eat(ery|ing)"; get;</span></pre><p id="f4ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非常方便的方法<code class="fe mc md me mf b">startswith</code>和<code class="fe mc md me mf b">endswith</code>根本没有实现，我有点不高兴(不要说用<code class="fe mc md me mf b">^</code>写一个正则表达式，所有的美都在于方法的名字)。</p><p id="d658" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，Neo4j 的<code class="fe mc md me mf b"><a class="ae mb" href="https://neo4j.com/docs/cypher-manual/current/clauses/where/" rel="noopener ugc nofollow" target="_blank">WHERE</a></code>支持<code class="fe mc md me mf b">regex</code>、<code class="fe mc md me mf b">contains</code>、<code class="fe mc md me mf b">startswith</code>和<code class="fe mc md me mf b">endswith</code>。人们可以这样询问:</p><pre class="mg mh mi mj gt ni mf nj nk aw nl bi"><span id="da2f" class="nm lf it mf b gy nn no l np nq">MATCH (n)<br/>WHERE n.name STARTS WITH 'Mar'<br/>RETURN n.name, n.age</span></pre><p id="424a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然方法非常相似，但我非常喜欢文档中对字符串方法的强调。Neo4j 在这里征服我的心。</p><p id="8204" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Neo4j: 10/10，Grakn:9/10；由于以上原因，我的评价可能不太客观😄</p><h1 id="1cb8" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">获胜者是…</h1><p id="5c79" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">Grakn。</p><p id="bd2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Neo4j 和 Cypher 竞争很激烈，但是激烈到没有足够的语义来打倒 Grakn 和 Graql。</p><h1 id="1031" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">下一步是什么</h1><p id="ccaa" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">亲爱的读者们，我们到达了比赛的终点；我希望你喜欢这场血腥的战斗。接下来是图形算法的对比，猜猜谁是杀手对手😄我们将通过构建两个推荐系统来探索图算法，一个在 Grakn 中，另一个在 Neo4j 中。同时你可以访问我的其他文章，也可以在<a class="ae mb" href="https://duygua.github.io" rel="noopener ugc nofollow" target="_blank">https://duy gua . github . io</a>上访问我。在那之前保持快乐和和谐👋</p></div></div>    
</body>
</html>