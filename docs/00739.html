<html>
<head>
<title>How to reuse your Python models without retraining them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何重用您的 Python 模型而无需重新训练它们</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-reuse-your-python-models-without-retraining-them-39cd685659a5?source=collection_archive---------15-----------------------#2020-01-21">https://towardsdatascience.com/how-to-reuse-your-python-models-without-retraining-them-39cd685659a5?source=collection_archive---------15-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8d120538752fe8785866f879d794589f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJAStV7WAnn6xl-Sl4RdwQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="dbc7" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">Python 的对象序列化库简介</h2></div><blockquote class="kt ku kv"><p id="ec44" class="kw kx ky kz b la lb kf lc ld le ki lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">注:在计算机科学中，保存一个对象以备后用的过程叫做<strong class="kz jf"> <em class="je">序列化</em> </strong>，而加载一个保存的对象叫做<strong class="kz jf"> <em class="je">反序列化</em> </strong>。</p></blockquote><p id="0ffb" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">作为一名数据科学家，您可能希望重用您的一个模型，而不必重新训练它。</p><p id="e9c4" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">避免需要重新训练你的模型是特别有用的，因为它允许“部署”模型，即把你训练好的模型转移到一个公共服务器上，任何有互联网连接的人都可以查询预测。</p><p id="316e" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">例如，假设您已经创建了一个简单的 scikit-learn 模型，您希望保存它并在以后重用它。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c8c7" class="mf mg je mb b gy mh mi l mj mk">&gt;&gt;&gt; from sklearn.datasets import load_iris<br/>&gt;&gt;&gt; from sklearn.tree import DecisionTreeClassifier<br/>&gt;&gt;&gt; model = DecisionTreeClassifier()<br/>&gt;&gt;&gt; X, y = load_iris(return_X_y=True)<br/>&gt;&gt;&gt; clf = model.fit(X,y)</span></pre><p id="8871" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">在这种情况下，我们的训练模型存储在 Python 对象<code class="fe ml mm mn mb b">clf</code>中。</p><p id="f1f2" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">为了保存<code class="fe ml mm mn mb b">clf</code>对象供以后重用，我们将使用内置的<code class="fe ml mm mn mb b">pickle</code>库。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7165" class="mf mg je mb b gy mh mi l mj mk">&gt;&gt;&gt; import pickle<br/>&gt;&gt;&gt; with open('clf.pickle', 'wb') as f:<br/>...     pickle.dump(clf, f)</span></pre><p id="9211" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">我们通过指定<code class="fe ml mm mn mb b">wb</code>用“写字节模式”打开了一个名为<code class="fe ml mm mn mb b">clf.pickle</code>的文件，并且我们已经在变量<code class="fe ml mm mn mb b">f</code>中存储了对该文件的引用。</p><p id="51e8" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">然后，我们使用<code class="fe ml mm mn mb b">pickle.dump</code>方法将对象<code class="fe ml mm mn mb b">clf</code>保存在文件<code class="fe ml mm mn mb b">clf.pickle</code>中。在幕后，Python 实际上将<code class="fe ml mm mn mb b">clf</code>对象转换成一系列字节，稍后它可以将这些字节转换回原始的<code class="fe ml mm mn mb b">clf</code>对象。</p><p id="782f" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">您可以检查工作目录的内容现在包含一个名为<code class="fe ml mm mn mb b">clf.pickle</code>的文件。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0d7a" class="mf mg je mb b gy mh mi l mj mk">&gt;&gt;&gt; import os<br/>&gt;&gt;&gt; os.listdir()<br/>['clf.pickle']</span></pre><p id="579d" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">如果您通过键入<code class="fe ml mm mn mb b">exit()</code>退出当前的 Python 会话，然后启动一个新的 Python 提示符，那么您可以重新加载<code class="fe ml mm mn mb b">clf</code>对象来恢复训练好的模型。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c5bd" class="mf mg je mb b gy mh mi l mj mk">&gt;&gt;&gt; import pickle<br/>&gt;&gt;&gt; with open('clf.pickle', 'rb') as f:<br/>...     clf = pickle.load(f)<br/>&gt;&gt;&gt; type(clf)<br/>sklearn.tree._classes.DecisionTreeClassifier</span></pre><p id="a039" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">注意我们如何通过指定<code class="fe ml mm mn mb b">rb</code>以“读取字节”模式打开文件<code class="fe ml mm mn mb b">clf.pickle</code>，然后将对该文件的引用存储在变量<code class="fe ml mm mn mb b">f</code>中。</p><p id="d103" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">然后，<code class="fe ml mm mn mb b">pickle.load</code>能够读取文件<code class="fe ml mm mn mb b">clf.pickle</code>并返回一个新的对象，该对象与我们最初传递给<code class="fe ml mm mn mb b">pickle.dump</code>的<code class="fe ml mm mn mb b">clf</code>对象<em class="ky">完全相同。</em></p><blockquote class="mo"><p id="6e11" class="mp mq je bd mr ms mt mu mv mw mx ls dk translated">任何 Python 对象都可以使用 pickle.dump 保存到一个文件中，并且可以使用<code class="fe ml mm mn mb b"><strong class="ak">pickle.load</strong></code>从文件中加载完全相同的对象</p></blockquote><p id="f829" class="pw-post-body-paragraph kw kx je kz b la my kf lc ld mz ki lf lt na li lj lu nb lm ln lv nc lq lr ls im bi translated">因此，我们可以使用从文件中加载的新的<code class="fe ml mm mn mb b">clf</code>对象在<em class="ky">中进行预测，就像我们使用原始的<code class="fe ml mm mn mb b">clf</code>对象进行预测一样。</em></p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="82df" class="mf mg je mb b gy mh mi l mj mk">&gt;&gt;&gt; clf.predict([<br/>...     [1,1,0,0],<br/>...     [1,0,1,1]<br/>... ])<br/>[0,0]</span></pre><p id="9c65" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">当然，将训练好的模型保存到本地目录中的文件意味着其他人将不能重用该模型。将训练好的模型保存到其他程序可以访问的数据库中会更方便。</p><h2 id="d97c" class="mf mg je bd nd ne nf dn ng nh ni dp nj lt nk nl nm lu nn no np lv nq nr ns nt bi translated">将腌制模型保存到数据库中</h2><p id="a2cd" class="pw-post-body-paragraph kw kx je kz b la nu kf lc ld nv ki lf lt nw li lj lu nx lm ln lv ny lq lr ls im bi translated">pickle 模块允许将对象转换为内存中的字节，然后我们可以用它将训练好的模型保存在数据库中。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f9e8" class="mf mg je mb b gy mh mi l mj mk">&gt;&gt;&gt; pickled_clf = pickle.dumps(clf)<br/>&gt;&gt;&gt; type(pickled_clf)<br/>bytes</span></pre><p id="9608" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">请注意我们如何使用<code class="fe ml mm mn mb b">pickle.dumps</code>方法，即“<strong class="kz jf"> dump s </strong> tring”，而不是<code class="fe ml mm mn mb b">pickle.dump</code>方法。</p><p id="54d5" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated"><code class="fe ml mm mn mb b">dumps</code>方法直接返回一个<em class="ky">字节的</em>对象<code class="fe ml mm mn mb b">pickled_clf</code>，而不是将其写入文件。(<code class="fe ml mm mn mb b">dumps</code>方法的命名被选择为与其他序列化库一致，并且它不返回<code class="fe ml mm mn mb b">str</code>类型对象)。</p><p id="9737" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">我们现在可以将<code class="fe ml mm mn mb b">pickled_clf</code>字节对象直接保存到数据库中。</p><p id="f9fe" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">例如，假设我们有一个名为<code class="fe ml mm mn mb b">db.sqlite3</code>的 sqlite3 数据库，其中包含一个名为<code class="fe ml mm mn mb b">models</code>的表，该表带有一个<code class="fe ml mm mn mb b">BLOB</code>(即字节)字段。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f830" class="mf mg je mb b gy mh mi l mj mk">sqlite3 db.sqlite3 "create table models(name TEXT, data BLOB);"</span></pre><p id="1efd" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">为了将经过酸洗的模型保存到那个表中，我们可以使用<code class="fe ml mm mn mb b">sqlite3</code>模块。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="5434" class="mf mg je mb b gy mh mi l mj mk">&gt;&gt;&gt; import sqlite3<br/>&gt;&gt;&gt; conn = sqlite3.connect('db.sqlite3')<br/>&gt;&gt;&gt; query = 'insert into models values (?, ?)'<br/>&gt;&gt;&gt; conn.execute(query, ['clf', pickled_clf])<br/>&gt;&gt;&gt; conn.commit()</span></pre><p id="4037" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">然后，我们可以从数据库中重新加载 pickled 对象，然后将 bytes 对象转换回原始模型。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c906" class="mf mg je mb b gy mh mi l mj mk">&gt;&gt;&gt; cursor = conn.execute('select * from models')<br/>&gt;&gt;&gt; name, pickled_clf = cursor.fetchone()<br/>&gt;&gt;&gt; clf = pickle.loads(pickled_clf)</span></pre><p id="d68b" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">注意我们是如何使用<code class="fe ml mm mn mb b">pickle.loads</code>方法加载分类器的。正如我们使用<code class="fe ml mm mn mb b">pickle.load</code>来恢复用<code class="fe ml mm mn mb b">pickle.dump</code>保存的对象一样，我们也可以使用<code class="fe ml mm mn mb b">pickle.loads</code>来恢复用<code class="fe ml mm mn mb b">pickle.dumps</code>保存的对象。</p><p id="6597" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">现在，您可以重用该模型，而无需重新训练它。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="20a3" class="mf mg je mb b gy mh mi l mj mk">&gt;&gt;&gt; clf.predict([<br/>...     [1,1,0,0],<br/>...     [1,0,1,1]<br/>... ])<br/>[0,0]</span></pre></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="7f18" class="pw-post-body-paragraph kw kx je kz b la lb kf lc ld le ki lf lt lh li lj lu ll lm ln lv lp lq lr ls im bi translated">感谢阅读！如果你觉得这个教程有用，我在 Medium 上写了关于 Python 和数据科学的技巧，所以你可以关注我来获得更多类似的文章。</p><div class="is it gp gr iu og"><a rel="noopener follow" target="_blank" href="/top-features-of-pandas-1-0-26abff08d1b6"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jf gy z fp ol fr fs om fu fw jd bi translated">熊猫 1.0 的主要特性</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">您今天就可以开始使用的新改进</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ja og"/></div></div></a></div><div class="is it gp gr iu og"><a href="https://levelup.gitconnected.com/3-python-list-comprehension-tricks-you-might-not-know-yet-5891d904ee76" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jf gy z fp ol fr fs om fu fw jd bi translated">你可能还不知道的 3 个 Python 列表理解技巧</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">列表理解不仅仅是为了列表</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ja og"/></div></div></a></div></div></div>    
</body>
</html>