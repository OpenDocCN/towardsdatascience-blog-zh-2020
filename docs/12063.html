<html>
<head>
<title>Loading Custom Image Dataset for Deep Learning Models: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为深度学习模型加载自定义图像数据集:第 1 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/loading-custom-image-dataset-for-deep-learning-models-part-1-d64fa7aaeca6?source=collection_archive---------2-----------------------#2020-08-20">https://towardsdatascience.com/loading-custom-image-dataset-for-deep-learning-models-part-1-d64fa7aaeca6?source=collection_archive---------2-----------------------#2020-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="40af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将自定义图像数据集加载到深度学习模型的不同技术的简单指南。</h2></div><p id="7ea7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">在本文中，您将学习如何从自定义数据中加载和创建图像训练和测试数据集，作为深度学习模型的输入。您将学习使用加载数据集。</em>T3】</strong></p><ul class=""><li id="7076" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated"><strong class="kk iu">开<em class="le">CV2</em>开</strong></li><li id="4e52" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="kk iu"> <em class="le"> PIL </em> </strong></li></ul><p id="6094" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里使用的数据集是来自 Kaggle 的<a class="ae lt" href="https://www.kaggle.com/puneet6060/intel-image-classification/version/2" rel="noopener ugc nofollow" target="_blank">英特尔图像分类</a>。</p><p id="bcd4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">英特尔图像分类数据集已经分为训练、测试和 Val，我们将仅使用训练数据集来了解如何使用不同的库加载数据集。</p><h2 id="e106" class="lu lv it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">为深度学习模型加载自定义数据集的典型步骤</h2><ol class=""><li id="a9b1" class="lf lg it kk b kl mn ko mo kr mp kv mq kz mr ld ms ll lm ln bi translated"><strong class="kk iu">打开图像文件</strong>。文件的格式可以是 JPEG、PNG、BMP 等。</li><li id="7e93" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld ms ll lm ln bi translated"><strong class="kk iu">调整图像大小以匹配深度学习模型的输入层的输入大小</strong>。</li><li id="9e95" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld ms ll lm ln bi translated"><strong class="kk iu">将图像像素转换为浮点数据类型。</strong></li><li id="0e3b" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld ms ll lm ln bi translated"><strong class="kk iu">将图像</strong>归一化，使像素值从 0 到 255 在 0 和 1 之间缩小。</li><li id="4243" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld ms ll lm ln bi translated"><strong class="kk iu">深度学习模型的图像数据应该是 numpy 数组或者张量对象。</strong></li></ol><h2 id="2c12" class="lu lv it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">自定义图像数据的文件夹结构</h2><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/511b36c8ccb161fd9db37f5f24d0656d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*Zo7x43YnriSNffbabZ3vvA.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">每个类别都是一个文件夹，包含该特定类别的图像。</p></figure><h2 id="a084" class="lu lv it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">使用 CV2 加载图像数据</h2><p id="3a4f" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr nf kt ku kv ng kx ky kz nh lb lc ld im bi translated"><strong class="kk iu">导入所需的库</strong></p><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="eae9" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">import pandas as pd<br/>import numpy as np<br/>import os<br/>import tensorflow as tf<br/>import cv2<br/>from tensorflow import keras<br/>from tensorflow.keras import layers, Dense, Input, InputLayer, Flatten<br/>from tensorflow.keras.models import Sequential, Model<br/>from  matplotlib import pyplot as plt<br/>import matplotlib.image as mpimg</strong><br/><strong class="nj iu">%matplotlib inline</strong></span></pre><p id="d6a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从其中一个文件夹中随机打印五张图像</p><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="2d81" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">plt.figure(figsize=(20,20))</strong></span><span id="e332" class="lu lv it nj b gy nr no l np nq"><strong class="nj iu">test_folder=r'CV\Intel_Images\seg_train\seg_train\forest'<br/>for i in range(5):<br/>    file = random.choice(os.listdir(img_folder))<br/>    image_path= os.path.join(img_folder, file)<br/>    img=mpimg.imread(image_path)<br/>    ax=plt.subplot(1,5,i+1)<br/>    ax.title.set_text(file)<br/>    plt.imshow(img)</strong></span></pre><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ns"><img src="../Images/4f64a5fc191591cfda1584354286b9a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ugZfxV0Q00GDL17gu2tI8A.png"/></div></div></figure><p id="c3a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">设置加载数据集的图像尺寸和源文件夹</strong></p><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="9dcd" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">IMG_WIDTH=200<br/>IMG_HEIGHT=200<br/>img_folder=r'CV\Intel_Images\seg_train\seg_train\'</strong></span></pre><p id="faf0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">从文件夹中的图像创建图像数据和标签</strong></p><p id="e007" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的函数中</p><ul class=""><li id="1d95" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated">源文件夹是包含不同类的图像的输入参数。</li><li id="63c7" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">从文件夹中读取图像文件，并将其转换为正确的颜色格式。</li><li id="180d" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">根据模型所需的输入尺寸调整图像的大小</li><li id="a7ba" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">将图像转换为数据类型为 float32 的 Numpy 数组</li><li id="833f" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">归一化图像数组，使值在 0 和 1 之间从 0 到 255 缩小，以获得类似的数据分布，这有助于加快收敛。</li></ul><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="0a35" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">def create_dataset(img_folder):<br/>   <br/>    img_data_array=[]<br/>    class_name=[]<br/>   <br/>    for dir1 in os.listdir(img_folder):<br/>        for file in os.listdir(os.path.join(img_folder, dir1)):<br/>       <br/>            image_path= os.path.join(img_folder, dir1,  file)<br/>            image= cv2.imread( image_path, cv2.COLOR_BGR2RGB)<br/>            image=cv2.resize(image, (IMG_HEIGHT, IMG_WIDTH),interpolation = cv2.INTER_AREA)<br/>            image=np.array(image)<br/>            image = image.astype('float32')<br/>            image /= 255 <br/>            img_data_array.append(image)<br/>            class_name.append(dir1)<br/>    return img_data_array, class_name</strong></span><span id="508a" class="lu lv it nj b gy nr no l np nq"># extract the image array and class name<br/><strong class="nj iu">img_data, class_name =create_dataset(r'CV\Intel_Images\seg_train\seg_train')</strong></span></pre><p id="dfb4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">将文本标签转换成数字代码</strong></p><p id="98e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为类的所有唯一值创建一个字典</p><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="8e7f" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">target_dict={k: v for v, k in enumerate(np.unique(class_name))}<br/>target_dict</strong></span></pre><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b4383351e847fc7fbb6fc72a567fc680.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*psgeuRVUZpPgfwFqEpg4JQ.png"/></div></figure><p id="335f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据字典将 class_names 转换成它们各自的数值</p><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="4f58" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">target_val=  [target_dict[class_name[i]] for i in range(len(class_name))]</strong></span></pre><p id="3290" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个简单的深度学习模型并编译它</p><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="531c" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">model=tf.keras.Sequential(<br/>        [<br/>            tf.keras.layers.InputLayer(input_shape=(IMG_HEIGHT,IMG_WIDTH, 3)),<br/>            tf.keras.layers.Conv2D(filters=32, kernel_size=3, strides=(2, 2), activation='relu'),<br/>            tf.keras.layers.Conv2D(filters=64, kernel_size=3, strides=(2, 2), activation='relu'),<br/>            tf.keras.layers.Flatten(),<br/>            tf.keras.layers.Dense(6)<br/>        ])</strong></span><span id="7e73" class="lu lv it nj b gy nr no l np nq"><strong class="nj iu">encoder.compile(optimizer='rmsprop', loss='sparse_categorical_crossentropy', metrics=['accuracy'])</strong></span></pre><p id="86e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们最终拟合数据集来训练模型。我们可以使用 Numpy 数组作为输入</p><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="8f17" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">history = model.fit(x=np.array(img_data, np.float32), y=np.array(list(map(int,target_val)), np.float32), epochs=5)</strong></span></pre><p id="59e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用<strong class="kk iu"> <em class="le"> tf.cast() </em> </strong>将输入数据转换成张量来训练模型</p><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="22cf" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">history = model.fit(x=tf.cast(np.array(img_data), tf.float64), y=tf.cast(list(map(int,target_val)),tf.int32), epochs=5)</strong></span></pre><p id="e799" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将通过使用不同的库加载图像数据集来使用相同的模型进行进一步的训练</p><h2 id="4eed" class="lu lv it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">使用 PIL 加载图像数据</h2><p id="c195" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr nf kt ku kv ng kx ky kz nh lb lc ld im bi translated">添加附加库以使用 PIL 加载影像数据集</p><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="b17c" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">from PIL import Image</strong></span></pre><p id="c8f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">使用 PIL 从文件夹中的图像创建图像数据和标签</strong></p><p id="3570" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的函数中</p><ul class=""><li id="9635" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated">源文件夹是包含不同类的图像的输入参数。</li><li id="c750" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">使用 PIL 打开文件夹中的图像文件。</li><li id="e3e3" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">根据模型所需的输入尺寸调整图像的大小</li><li id="4f47" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">将图像转换为数据类型为 float32 的 Numpy 数组</li><li id="f0c3" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">归一化图像阵列以加快收敛速度。</li></ul><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="5886" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">def create_dataset_PIL(img_folder):<br/>    <br/>    img_data_array=[]<br/>    class_name=[]<br/>    for dir1 in os.listdir(img_folder):<br/>        for file in os.listdir(os.path.join(img_folder, dir1)):<br/>       <br/>            image_path= os.path.join(img_folder, dir1,  file)<br/>            image= np.array(Image.open(image_path))<br/>            image= np.resize(image,(IMG_HEIGHT,IMG_WIDTH,3))<br/>            image = image.astype('float32')<br/>            image /= 255  <br/>            img_data_array.append(image)<br/>            class_name.append(dir1)<br/>    return img_data_array , class_name<br/>PIL_img_data, class_name=create_dataset_PIL(img_folder)</strong></span></pre><p id="2557" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">将文本标签转换成数字代码</strong></p><p id="eeec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我们用于 CV2 的相同代码</p><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="b048" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">target_dict={k: v for v, k in enumerate(np.unique(class_name))}<br/>target_val=  [target_dict[class_name[i]] for i in range(len(class_name))]</strong></span></pre><p id="b0a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建和编译一个简单的深度学习模型</p><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="f8f3" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">model=tf.keras.Sequential(<br/>        [<br/>            tf.keras.layers.InputLayer(input_shape=(IMG_HEIGHT,IMG_WIDTH, 3)),<br/>            tf.keras.layers.Conv2D(filters=32, kernel_size=3, strides=(2, 2), activation='relu'),<br/>            tf.keras.layers.Conv2D(filters=64, kernel_size=3, strides=(2, 2), activation='relu'),<br/>            tf.keras.layers.Flatten(),<br/>            tf.keras.layers.Dense(6)<br/>        ])</strong></span><span id="bf0f" class="lu lv it nj b gy nr no l np nq"><strong class="nj iu">encoder.compile(optimizer='rmsprop', loss='sparse_categorical_crossentropy', metrics=['accuracy'])</strong></span></pre><p id="7ae8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们最终拟合数据集来训练模型。我们可以使用 Numpy 数组作为输入</p><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="d867" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">history = model.fit(x=np.array(PIL_img_data, np.float32), y=np.array(list(map(int,target_val)), np.float32), epochs=5)</strong></span></pre><p id="3293" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用<strong class="kk iu"> <em class="le"> tf.cast() </em> </strong>将输入数据转换成张量来训练模型</p><pre class="mu mv mw mx gt ni nj nk nl aw nm bi"><span id="b34e" class="lu lv it nj b gy nn no l np nq"><strong class="nj iu">history = model.fit(x=tf.cast(np.array(PIL_img_data), tf.float64), y=tf.cast(list(map(int,target_val)),tf.int32), epochs=5)</strong></span></pre><p id="0ef5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了几个步骤之外，使用 CV2 和 PIL 加载数据集的过程是相同的。</p><p id="3688" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，这将帮助您使用 CV2 和 PIL 库加载数据集。</p><p id="0e55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用 CV2 和 PIL 加载数据集的代码在此<a class="ae lt" href="https://github.com/arshren/Load_Dataset" rel="noopener ugc nofollow" target="_blank">可用</a>。</p><p id="aa4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一篇文章中，我们将使用。T13】</p><ul class=""><li id="1f73" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated"><strong class="kk iu"><em class="le"/></strong></li><li id="c606" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="kk iu"> <em class="le"> Tensorflow 核心包括 tf.data </em> </strong></li></ul></div></div>    
</body>
</html>