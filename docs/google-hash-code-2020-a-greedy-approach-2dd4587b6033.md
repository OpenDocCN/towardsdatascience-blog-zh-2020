# 谷歌哈希代码 2020:贪婪的方法

> 原文：<https://towardsdatascience.com/google-hash-code-2020-a-greedy-approach-2dd4587b6033?source=collection_archive---------8----------------------->

## 我们如何在比利时获得第 16/204 名，在全球获得第 531/10724 名

## 谷歌哈希代码

![](img/5846798bae550fab5c70382380eb0a64.png)

谷歌每年都会组织一场名为 Hash Code 的编程比赛。目标是在 2 到 4 人的团队中在 4 小时内解决一个优化问题。这项比赛吸引了来自世界各地的成千上万的参赛者。这是我第一次听说它，所以我决定和布拉姆·斯廷温克尔以及 T2·皮特·德·克雷默一起参加。

## 扫描多个图书馆中的图书

今年的目标是通过在有限的几天内扫描分布在不同图书馆的不同书籍来获得最高分。同一本书可以在不止一个图书馆买到。每本书都有一个分数，每本书只能获得一次分数(即扫描两本相同的书只能获得一次分数)。此外，每个图书馆都有特定的“注册”时间(启动/开始时间)和不同的吞吐量(每天可以扫描的图书数量)。在每个时间实例中，只有一个图书馆可以执行注册过程，而书籍的扫描可以并行进行。示例(和(非最佳)解决方案):

![](img/4514170170932df9336e31ca4ceac201.png)

最优化问题的一个简单例子。书 0，1，2，3，4，5 分别被赋予 1，2，3，6，5，4 的分数。总点数将是:点数(第 0 天)+ … +点数(第 6 天)。第 0-2 天不奖励任何积分，因为没有扫描书籍。第三天 4 分，第四天 3 分，第五天 9 分。第 6 天不计分，因为书 2 和书 3 已经扫描过了。总分为 16 分。这当然不是一个很好的解决方案，因为 book 4 永远不会被扫描，而 library 0 的注册时间更短，吞吐量更高。

总的来说，我们有 6 个不同的输入/问题，具有不同数量的特征(许多图书馆，许多书，所有书的分数相同，没有书的副本，等等。).

## 第一种方法

我们的第一个方法是给每个图书馆分配一个分数，这个分数由它在截止日期前可以扫描的书籍的分数总和组成:

![](img/a2a04ab08e078d4998efbe19b5105916.png)

通过计算可以及时扫描的最高书籍分数的总和，计算所有图书馆在一次扫描中的分数

然后，我们按照分数的顺序(降序)开始注册图书馆。这导致了大约 1510 万分的分数。

## 重新计算分数

第一种方法非常快，因为它只对库执行一次遍历。不幸的是，它没有得到那么好的分数，因为它没有考虑到重要的因素。这种因素的一个例子是，在每个时刻只有一个库可以执行它的注册过程。因此，我们可以安排一个新的库在前一个库的注册过程之后开始扫描。我们更新了代码以选择最佳库，然后跟踪已经过去的总注册时间:

![](img/24dbb64aee92a25c80af07e9b89dc13b.png)

我们现在跟踪一个 time_total 变量

这次更新取得了 1550 万的成绩。虽然我们的代码现在慢了很多，因为它是库数量的平方(给每个库分配分数→选择最好的一个→更新计数器→重复)。因此，我们不再能够解决第四个输入问题，因为库的数量太多了。

## 从池中移除扫描的图书

另一个重要的因素是，扫描同一本书的多份副本并没有额外加分。由于我们的代码已经记录了经过的总时间，我们只需使用一个 set 来存储已经分配的书籍。

![](img/0ef05e6037c513bc48118436d2935777.png)

我们最新的配方。书籍和指定书籍是集合，\是集合差

## 考虑注册时间

我们及时进行的最后一项调整是更新公式，以计算在考虑注册时间时可以达到的平均分数，而不是只计算总和。这对于每个图书馆的图书数量很少的一些问题来说非常重要，因为当他们扫描完所有的图书时会有很多空闲时间。在第一次迭代中，它会选择得分最高的图书馆，忽略它的吞吐时间。最终的公式和最终版本的代码可以在下面找到:

![](img/74bcdd7c352ba9bed7551fc0df2530ee.png)

除以注册时间会产生显著的增益

这次更新是迄今为止最重要的一次，因为它将我们的分数提高到了 2660 万。

## 问题 D 的简化快速版本

在完成所有这些更新后，我们只剩下大约 20 分钟的时间了。我们决定把重点放在问题 D 上，因为只有我们的代码的第一个版本解决了这个问题(这个版本不太好)。通过检查输入，我们看到这个问题有一些非常独特的性质:所有的图书馆都有相同的吞吐量和注册时间，每本书的分数都是相同的。唯一的区别是图书馆里有多少书。因此，我们通过计算每个图书馆中尚未扫描的书籍数量来计算我们的分数。这一过程持续了大约 15 分钟，在只剩下几分钟的时间里，我们成功地提高了问题 D 的 20000 分，使我们的分数达到大约 2680 万分，这使我们在比利时排名第 16/204 位，在全球排名第 531/10724 位。

![](img/2f107db65acb93b7f7a59639d16bd4b3.png)

我们资格赛的证书。

## 吸取的教训和可能的改进

*   我们检查我们的输入问题太晚了。每个问题都有独特的性质，你贪婪的方法应该适合这些。
*   为了编写针对每个子问题的定制方法，您确实需要快速拥有一个强大的基础版本。
*   为了进一步提高分数，可以进行不同的调整。排名第一的成绩是 27203691，只比我们的分数高 1.5%。可能的改进包括(I)考虑书籍的频率；㈡稍微修改公式；(iii)局部邻域搜索(对解决方案进行小的修改以检查它是否改进)；㈣等等。

我们绝对做得不错，这是一次有趣的挑战！如果你是排名在我们之上的 530 个团队中的一员，或者有一些可能改进的想法，一定要让我们知道！

## 附录:最佳解决实践问题

今年，还提供了一个简单的玩具问题，作为真正比赛的热身。问题陈述很简单，你得到一个披萨的集合，每个披萨有不同的切片数和一个数字 M，目标是订购披萨，使得切片总数接近(不超过)M:

![](img/b8ceb8067f2ae58201dc0dc47fce6ef0.png)

如果 M 等于 17，那么订购比萨饼 S0、S2 和 S3 是最佳解决方案，因为这将给我们总共 16 块。

很容易看出这只是对**背包问题**的一种重新表述。对于像古罗比这样的强有力的解决者来说，这简直是小菜一碟:

我们基本上用 K 个二进制变量创建了一个数组 asm，K 是比萨饼的数量。如果 asm[i] = 1，那么这意味着我们正在订购 pizza i。目标是 asm[i]*score[i]之和尽可能高(或者与 M 之差尽可能低)，附加约束是它不能超过 M。脚本将读取目录中的所有文件，并写出输出文件。