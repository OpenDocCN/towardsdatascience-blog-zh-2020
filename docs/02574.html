<html>
<head>
<title>Design Optimization with Ax in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 中的 Ax 进行设计优化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/design-optimization-with-ax-in-python-957b1fec776f?source=collection_archive---------10-----------------------#2020-03-12">https://towardsdatascience.com/design-optimization-with-ax-in-python-957b1fec776f?source=collection_archive---------10-----------------------#2020-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9795" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">人类在联合优化非线性、高维函数方面很糟糕。这是事实。在机器学习的时代，计算机可以为我们做决定，有工具可以触及如此多的工程领域。在本教程中，我将重点介绍脸书的工具<a class="ae kl" href="https://ax.dev/" rel="noopener ugc nofollow" target="_blank"> Ax </a>，它将使用贝叶斯优化来优化用户定义的高维非线性目标。Ax，<strong class="jp ir">自适应实验平台</strong>，是脸书的一个开源工具，用于优化复杂的非线性实验。这真的很尖锐，让我们开始吧。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/81eb0820516236b6a01b81b28a6bd36e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51iIIXuz2K81KkVqZd1s8g.jpeg"/></div></div><p class="lf lg gj gh gi lh li bd b be z dk translated">来源—作者。</p></figure><h1 id="77de" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">数学总结</h1><p id="f162" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">该代码使用贝叶斯优化来迭代地探索状态空间，并将高斯过程拟合到底层模型(实验)。如果你只是想看代码结构，跳过这一部分。注意— <em class="mm"> Ax 可以使用其他模型和方法，但是我只关注最适合我的问题的工具</em>。</p><h2 id="4ebd" class="mn lk iq bd ll mo mp dn lp mq mr dp lt jy ms mt lx kc mu mv mb kg mw mx mf my bi translated">高斯过程—建模</h2><p id="4394" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">高斯过程(GP)是一种非线性近似工具。这是跨函数空间的回归。它所做的是获取一个特征向量(x)和一组结果 f(x ),并在两者之间拟合一个连续函数。利用这样的分布，预测是在对特征进行调节的情况下完成的。但是它的名字<strong class="jp ir">高斯</strong>过程是怎么来的呢？</p><blockquote class="mz"><p id="4631" class="na nb iq bd nc nd ne nf ng nh ni kk dk translated">“高斯过程是高斯概率分布的推广”——卡尔·爱德华·拉斯姆森。</p></blockquote><p id="08f2" class="pw-post-body-paragraph jn jo iq jp b jq nj js jt ju nk jw jx jy nl ka kb kc nm ke kf kg nn ki kj kk ij bi translated">公式是回归问题的概率估计。不确定性估计仍然在这里—现在函数<em class="mm"> f(x) </em>被一个<em class="mm"> GP(m(x)，k(x，x')) </em>的<strong class="jp ir">均值</strong> (m(x)=E[f(x)])和<strong class="jp ir">协方差</strong> (k(x，x '))函数捕获。用于映射两个变量之间的协方差的函数(在高斯分布中，这只是一个数字)，是它正在建模的概率分布。美妙之处在于，通过智能选择插值函数，<em class="mm">您可以从有限采样中获得状态空间中所有潜在点的平滑近似值</em>。</p><p id="1050" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">推荐阅读—拉斯姆森，卡尔·爱德华。"机器学习中的高斯过程."<em class="mm">关于机器学习的暑期学校</em>。施普林格，柏林，海德堡，2003。</p><h2 id="b224" class="mn lk iq bd ll mo mp dn lp mq mr dp lt jy ms mt lx kc mu mv mb kg mw mx mf my bi translated">贝叶斯优化—学习</h2><p id="e4a7" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">贝叶斯优化(BO)是一种优化非线性问题的工具。它会给你一组设计参数，让你在下一次迭代中尝试。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi no"><img src="../Images/75a82c888d02c3f6074052458bdcfe8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*uFEsYe5gjjFO9Hvc7vimbA.png"/></div></figure><p id="0bfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是怎么做到的？有两个关键点:1)它迭代地训练一个 GP 模型，2)它使用一个<strong class="jp ir">采集函数</strong>对一组点采样的潜在增益进行建模。最常用的获取函数(抽样函数)是期望改善(EI)。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi np"><img src="../Images/57ad5403cac1f79a8112eff35fd20537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYMRHBrgDprvm2iMOUuqOw.png"/></div></div></figure><p id="bdd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数基于预期比当前最佳值(<em class="mm"> x* </em>)提高最多的参数，对下一组参数(<em class="mm"> x </em>)进行采样。最终发生的是，EI 将在高不确定性(潜在高回报)区域的勘探与回报接近最优的微调区域之间取得平衡。<em class="mm"> BO 将在每次迭代中训练一个新的模型，看看哪里有改进的潜力，评估模型(功能)，然后重新训练。</em></p><p id="fcac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">推荐阅读——Shahriari，Bobak 等人的《把人带出循环:贝叶斯优化综述》IEEE 会议录 104.1(2015):148–175。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nq"><img src="../Images/f76b328af7984711c9493ee4a42c1d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uC200N4qmOxG2vH5Zu2rIg.png"/></div></div><p class="lf lg gj gh gi lh li bd b be z dk translated">来自作者的 BO 的简单说明。</p></figure></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="f763" class="lj lk iq bd ll lm nr lo lp lq ns ls lt lu nt lw lx ly nu ma mb mc nv me mf mg bi translated">Python 教程</h1><p id="8515" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">本教程基于设计一个微机电系统(MEMs)跳跃机器人，我的代码可以在这里找到。这个项目有两个方面:</p><ol class=""><li id="4b5f" class="nw nx iq jp b jq jr ju jv jy ny kc nz kg oa kk ob oc od oe bi translated">根据一组约束方程优化设计——一个从第一原理导出的<strong class="jp ir">分析模型</strong>——可能与非线性交织在一起。在 sim.py 中找到，教程对此进行了解释。</li><li id="fd65" class="nw nx iq jp b jq of ju og jy oh kc oi kg oj kk ob oc od oe bi translated">通过拟合真实世界中发生的事情的模型来改进<strong class="jp ir">实验建模</strong>和设计效率。真实世界的实验数据显示在 example.py. <em class="mm">中，可以对其进行改进，以给出实验数据符合分析模型的概率可能性。</em></li></ol><div class="ok ol gp gr om on"><a href="https://github.com/natolambert/mems-bo" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd ir gy z fp os fr fs ot fu fw ip bi translated">natolambert/mems-bo</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">微机电系统设计的贝叶斯优化。在 GitHub 上创建一个帐户，为 natolambert/mems-bo 开发做出贡献。</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div></div></a></div></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="d5d5" class="lj lk iq bd ll lm nr lo lp lq ns ls lt lu nt lw lx ly nu ma mb mc nv me mf mg bi translated">代码</h1><p id="c827" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">现在我将介绍如何用 python 实现这种优化。请打开这个文件并跟随:<a class="ae kl" href="https://github.com/natolambert/mems-bo/blob/master/sim.py" rel="noopener ugc nofollow" target="_blank">https://github.com/natolambert/mems-bo/blob/master/sim.py</a>(<em class="mm">注意，代码可能比教程更新得更快，但核心元素仍然保留</em>)。</p><h2 id="5c16" class="mn lk iq bd ll mo mp dn lp mq mr dp lt jy ms mt lx kc mu mv mb kg mw mx mf my bi translated">属国</h2><p id="f739" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">我的例子利用了脸书的两个工具，python ≥3.7。</p><ol class=""><li id="66aa" class="nw nx iq jp b jq jr ju jv jy ny kc nz kg oa kk ob oc od oe bi translated">Ax，<em class="mm">适应性实验平台</em>(<a class="ae kl" href="https://ax.dev/" rel="noopener ugc nofollow" target="_blank">https://ax.dev/</a>)。这将为我们处理所有的数学问题，优化一个复杂的函数并将结果可视化。</li><li id="edff" class="nw nx iq jp b jq of ju og jy oh kc oi kg oj kk ob oc od oe bi translated">Hydra，<em class="mm">一个优雅地配置复杂应用的框架</em>(<a class="ae kl" href="https://hydra.cc/" rel="noopener ugc nofollow" target="_blank">https://hydra.cc/</a>)。这将通过改变一个简单的配置文件来处理任何设计问题。</li></ol><p id="1ef4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是 python 文件头的样子——没有太多的依赖关系。</p><pre class="ku kv kw kx gt ow ox oy oz aw pa bi"><span id="1cb3" class="mn lk iq ox b gy pb pc l pd pe">from ax import *<br/>import numpy as np<br/>import pandas as pd<br/><br/>from models import jumper<br/><br/>import os<br/>import sys<br/>import hydra<br/>import logging<br/><br/># A couple requirements for running Hydra <br/>sys.path.append(os.getcwd())<br/>log = logging.getLogger(__name__)</span></pre><h2 id="853d" class="mn lk iq bd ll mo mp dn lp mq mr dp lt jy ms mt lx kc mu mv mb kg mw mx mf my bi translated">定义优化问题</h2><p id="be67" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">优化问题必须采取特定的形式，并且是每个新项目需要编写的唯一代码。我们需要的是一个<strong class="jp ir">模型</strong>，它接受一个<em class="mm">字典</em>的参数，并返回一个<em class="mm">字典</em>的度量，其中的项目是试验的平均值和标准误差度量。注意— <em class="mm">标准误差是可选的，只是很好地融入支持建模的不确定性估计</em>。下面是跳跃机器人的一个例子，它设置了 3 个设计参数<strong class="jp ir"> <em class="mm"> w，N，L</em></strong><em class="mm"/>(<em class="mm">w</em>:弹簧宽度，<em class="mm"> N </em>:弹簧折叠数，<em class="mm"> L </em>:弹簧长度)，它返回 3 个指标:<strong class="jp ir"> <em class="mm">储能，</em></strong><strong class="jp ir"><em class="mm"/></strong>，以及</p><pre class="ku kv kw kx gt ow ox oy oz aw pa bi"><span id="329f" class="mn lk iq ox b gy pb pc l pd pe">def jumper(parameters):<br/>    rho = 2300<br/>    E = 170e9<br/>    T = 550e-6<br/>    lamb = 13.75<br/>    w = parameters["w"]<br/>    x_max = 5e-3<br/>    N = parameters["N"]<br/>    L = parameters["L"]<br/><br/>    k = 8 * (E * w ** 3 * T) / (N * L ** 3)<br/>    x = x_max<br/>    x_cant = x / (4 * N)<br/>    F_required = k * x<br/>    strain = (3 / 2) * (x_cant) * w / (L / 4) ** 2<br/>    U_stored = 0.5 * k * x ** 2<br/><br/>    return {"Energy": (U_stored, 0.0),<br/>            "Strain": (strain, 0.0),<br/>            "Force": (F_required, 0.0)}</span></pre><h2 id="84f7" class="mn lk iq bd ll mo mp dn lp mq mr dp lt jy ms mt lx kc mu mv mb kg mw mx mf my bi translated">程序化地生成状态空间</h2><p id="b0b9" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">这是我们利用九头蛇的地方。Hydra 将为我们加载这个 config.yaml，并从命令行将其与主要的实验配置交织在一起，因此我们可以轻松地更改我们的问题、搜索空间或约束。</p><p id="0584" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优化问题由三部分定义:</p><ol class=""><li id="1686" class="nw nx iq jp b jq jr ju jv jy ny kc nz kg oa kk ob oc od oe bi translated"><strong class="jp ir">状态空间:</strong>状态空间可以在变量范围、固定设计变量或离散选择变量上定义。对数比例和数据类型工具通过投影到更均匀的空间来帮助模型拟合。</li><li id="86f6" class="nw nx iq jp b jq of ju og jy oh kc oi kg oj kk ob oc od oe bi translated"><strong class="jp ir">约束:</strong> Ax 支持两种类型的约束——结果约束和参数约束。<em class="mm">结果约束</em>(如下所示)将结果限制在某个值之上或之下，在本例中，力和应变受到约束，因此物理设备可以运行而不会破碎。<em class="mm">可添加参数约束</em>以确保设计变量在相互关系内。</li><li id="ce5c" class="nw nx iq jp b jq of ju og jy oh kc oi kg oj kk ob oc od oe bi translated"><strong class="jp ir">目标度量:</strong>度量决定了模型中要优化的目标(最大或最小)。Ax 可以处理联合优化。</li></ol><p id="50bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是<a class="ae kl" href="https://github.com/natolambert/mems-bo/blob/master/conf/model/jumper.yaml" rel="noopener ugc nofollow" target="_blank"> jumper.yaml </a>。</p><pre class="ku kv kw kx gt ow ox oy oz aw pa bi"><span id="f2ba" class="mn lk iq ox b gy pb pc l pd pe">problem:<br/>  space:<br/>    N:<br/>      type: range<br/>      bounds: [1,6]<br/>      value_type: int<br/>      log_scale: false<br/>    L:<br/>      type: range<br/>      bounds: [5e-4, 1.9e-3]<br/>      value_type: float<br/>      log_scale: true<br/>    w:<br/>      type: range<br/>      bounds: [4.0e-5, 4.0e-4]<br/>      value_type: float<br/>      log_scale: false<br/>  constraints:<br/>    Strain:<br/>      type: LEQ<br/>      value: 0.5e-2<br/>    Force:<br/>      type: LEQ<br/>      value: 15.0e-3<br/>  metric:<br/>    name: Energy<br/>    minimize: false</span></pre><p id="ae3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">git 上有用于将配置转换成 Ax 对象的<a class="ae kl" href="https://github.com/natolambert/mems-bo/blob/8e456fbdce524d1fccc0a7d0b5992c4bc48ce1c6/sim.py#L43" rel="noopener ugc nofollow" target="_blank">函数</a>。Ax 的框架然后使用一个实验性的 API，该 API 将用于其余的代码——所有的优化过程都浓缩到这个对象中。</p><pre class="ku kv kw kx gt ow ox oy oz aw pa bi"><span id="e9f6" class="mn lk iq ox b gy pb pc l pd pe">exp = SimpleExperiment(<br/>    name="MEMS Optimization",<br/>    search_space=SearchSpace(search_space),<br/>    evaluation_function=jumper,<br/>    objective_name="Energy",<br/>    minimize=False,<br/>    outcome_constraints=outcome_con,<br/>)</span></pre><h2 id="b1ff" class="mn lk iq bd ll mo mp dn lp mq mr dp lt jy ms mt lx kc mu mv mb kg mw mx mf my bi translated">优化循环</h2><p id="aa6b" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">这里有两个重要的参与者:</p><ol class=""><li id="47ea" class="nw nx iq jp b jq jr ju jv jy ny kc nz kg oa kk ob oc od oe bi translated">SOBOL:这是一个用于准随机搜索的<a class="ae kl" href="https://en.wikipedia.org/wiki/Sobol_sequence" rel="noopener ugc nofollow" target="_blank">搜索范例</a>,它比纯粹的随机搜索产生更均匀的覆盖范围。</li><li id="af59" class="nw nx iq jp b jq of ju og jy oh kc oi kg oj kk ob oc od oe bi translated">GPEI:这是贝叶斯优化器的高斯过程模型，内置了预期改善获取功能。</li></ol><p id="89a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优化循环运行一个搜索阶段，以确保模型的均匀覆盖，然后 GPEI 将快速优化模型参数到最佳值。</p><p id="e812" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进行搜索。</p><pre class="ku kv kw kx gt ow ox oy oz aw pa bi"><span id="d9ed" class="mn lk iq ox b gy pb pc l pd pe">sobol = Models.SOBOL(exp.search_space)<br/>num_search = cfg.bo.random<br/>for i in range(num_search):<br/>    exp.new_trial(generator_run=sobol.gen(1))<br/>    exp.trials[len(exp.trials) - 1].run()</span></pre><p id="4c12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">训练一个模特。</p><pre class="ku kv kw kx gt ow ox oy oz aw pa bi"><span id="be7d" class="mn lk iq ox b gy pb pc l pd pe"># data = exp.fetch_data()<br/>gpei = Models.BOTORCH(experiment=exp, data=exp.eval())</span></pre><p id="397b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">迭代改进。</p><pre class="ku kv kw kx gt ow ox oy oz aw pa bi"><span id="609c" class="mn lk iq ox b gy pb pc l pd pe">num_opt = cfg.bo.optimized<br/>for i in range(num_opt):<br/>    print(f"Running GP+EI optimization trial {i + 1}/{num_opt}...")<br/>    # Reinitialize GP+EI model at each step with updated data.<br/>    batch = exp.new_trial(generator_run=gpei.gen(1))<br/>    gpei = Models.BOTORCH(experiment=exp, data=exp.eval())</span></pre></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="39e2" class="lj lk iq bd ll lm nr lo lp lq ns ls lt lu nt lw lx ly nu ma mb mc nv me mf mg bi translated">结果呢</h1><p id="ba2b" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">高斯过程之上的贝叶斯优化产生了奇妙的、可解释的结果。在这里，我们将展示模型如何覆盖设计空间，以及优化器如何改进目标。</p><h2 id="1c9d" class="mn lk iq bd ll mo mp dn lp mq mr dp lt jy ms mt lx kc mu mv mb kg mw mx mf my bi translated">设计空间</h2><p id="c937" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">通过一个简单的函数，Ax 可以可视化多个变量中 GP 的<em class="mm">先验</em>。这给了我们一个可视化设计权衡的好方法。</p><pre class="ku kv kw kx gt ow ox oy oz aw pa bi"><span id="308a" class="mn lk iq ox b gy pb pc l pd pe">plot_contour(model=gpei,<br/>                    param_x="N",<br/>                    param_y="w",<br/>                    metric_name="Energy",<br/>                    lower_is_better=cfg.metric.minimize)</span></pre><p id="b31b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面我们将看到的是显示不同空间的 GP 均值和协方差的图。直观地说，平均值是目标的估计值(在这种情况下是<strong class="jp ir">能量</strong>)。标准误差是协方差估计值——不确定性估计值，它与预期改善的抽样有关。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi pf"><img src="../Images/1fac9b640b561d10a5ea2629bc66baaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iud7G5pyJt5pnuP8qOiJBA.png"/></div></div><p class="lf lg gj gh gi lh li bd b be z dk translated">春季褶皱宽度与褶皱数量模型景观。左边是预测储存能量的平均值，右边是模型的不确定性。</p></figure><div class="ku kv kw kx gt ab cb"><figure class="pg ky ph pi pj pk pl paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><img src="../Images/e5c25ab5c2a8b7cb41afa6fa2aaa854c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*L6ymWMrzvSX4meLmRQmjvg.png"/></div></figure><figure class="pg ky pm pi pj pk pl paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><img src="../Images/2529f452e7861ccb3db8c888b7658257.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*wqMc7iKzL8Xblpu9pY_-1w.png"/></div><p class="lf lg gj gh gi lh li bd b be z dk pn di po pp translated">左:N 对 L 模型景观。右:左对右模型景观。</p></figure></div><p id="81a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">曲线显示，NvL 和 LvW 空间中有非常特定的区域可以创建功能性设备。这对应于物理约束。检查模型在探索过程中如何演变并向最终景观收敛也很有用，这可以通过将相同的绘图代码添加到学习循环中来完成。</p><h2 id="1309" class="mn lk iq bd ll mo mp dn lp mq mr dp lt jy ms mt lx kc mu mv mb kg mw mx mf my bi translated">学习曲线</h2><p id="e042" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">迭代解决问题最重要的部分是改进。如果工具除了随机抽样之外没有显示进展，那还有什么意义呢？有了 Ax，我们可以很容易地观察到学习进度随时间的变化，方法单一。</p><pre class="ku kv kw kx gt ow ox oy oz aw pa bi"><span id="837a" class="mn lk iq ox b gy pb pc l pd pe">optimization_trace_single_method(<br/>    y=objective_means.T, ylabel=cfg.metric.name,<br/>    model_transitions=[cfg.bo.random], trace_color=(114, 110, 180),<br/>)</span></pre><p id="5087" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是迭代与储存能量的关系图(通过机器人质量标准化以最大化跳跃高度)。垂直虚线的左边是随机 SOBOL 迭代，右边是 GPEI 迭代。很明显，系统正在学习，最终，在最优区域的预期改善如此之低，以至于回报下降(它正在探索状态空间的其他不确定区域。)</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi pq"><img src="../Images/8a5bb10ab58aa088877ac3655028b58b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DTs8HOy9xSpEu_obnMbGXg.png"/></div></div></figure></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="358d" class="lj lk iq bd ll lm nr lo lp lq ns ls lt lu nt lw lx ly nu ma mb mc nv me mf mg bi translated">结论</h1><p id="498f" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">希望您能看到这个工具的威力，以及将它应用于各种问题是多么容易。Ax 框架非常强大，我已经在多个项目中使用它(学习机器人控制器是 MEMs 设计的另一个方面)。</p><p id="cee4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有人可能会问，为什么我们不能用当今最流行的回归工具——神经网络来做这样的迭代更新呢？答案在于近似平滑度和数据覆盖范围。GPs 的强大之处在于，该模型在测量点之间拟合出平滑的近似值，从而在标记的训练集之外给出<strong class="jp ir">惊人、稳定的预测。试图用神经网络来做这件事是非常危险的，因为神经网络<strong class="jp ir">在训练分布</strong>之外发散。这又是何时使用哪种机器学习模型的另一个例子。</strong></p><p id="b132" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">当正确的工具应用于结构化问题时，机器学习效果最佳</strong>——而不是当任意工具被扔向任何问题时。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="ebd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多？订阅我关于机器人、人工智能和社会的时事通讯！</p><div class="ok ol gp gr om on"><a href="https://robotic.substack.com/" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd ir gy z fp os fr fs ot fu fw ip bi translated">自动化大众化</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">一个关于机器人和人工智能的博客，让它们对每个人都有益，以及即将到来的自动化浪潮…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">robotic.substack.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw ld on"/></div></div></a></div></div></div>    
</body>
</html>