<html>
<head>
<title>SQL Server with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的SQL Server</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-server-with-python-679b8dba69fa?source=collection_archive---------1-----------------------#2020-05-22">https://towardsdatascience.com/sql-server-with-python-679b8dba69fa?source=collection_archive---------1-----------------------#2020-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1bf1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">世界上最喜欢的数据库+世界上最喜欢的语言</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7395ee0d677f0024bd146a8a85f0f868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3BBuLpIOhYybdhh0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马丁·桑切斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大家都用SQL，大家都用Python。SQL是数据库事实上的标准。另一方面，Python是全明星，是数据分析、机器学习和web开发的顶级语言。想象两者都在一起。</p><p id="52cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实际上非常容易设置。我们可以快速利用Python的动态特性，在SQL中控制和构建查询。最精彩的部分？设置完成后，您不需要做任何事情。</p><p id="caac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个惊人的工具一起，让我们达到自动化和效率的新高度。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="da8f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">pyodbc</h1><p id="0b1e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们在两种技术之间的桥梁是<code class="fe mz na nb nc b">pyodbc</code>。这个库允许轻松访问ODBC数据库。</p><p id="41c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ODBC是开放式数据库连接的缩写，是一种用于访问数据库的标准化应用程序编程接口(API ),由SQL Access group在90年代早期开发。</p><p id="9b32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">兼容的数据库管理系统(DBMS)包括:</p><ul class=""><li id="d4b6" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">IBM Db2</li><li id="1638" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">MS Access</li><li id="aaf2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">MS SQL Server</li><li id="66a1" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">关系型数据库</li><li id="85c4" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">神谕</li></ul><p id="26e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用MS SQL Server。在很大程度上，这应该可以直接转移到任何兼容ODBC的数据库中使用。唯一需要更改的应该是连接设置。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ce6a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">连接</h1><p id="eec9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们需要做的第一件事是创建一个到SQL server的连接。我们可以使用<code class="fe mz na nb nc b">pyodbc.connect</code>来做到这一点。在这个函数中，我们还必须传递一个连接字符串。</p><p id="5497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个连接字符串必须指定DBMS <code class="fe mz na nb nc b">Driver</code>、<code class="fe mz na nb nc b">Server</code>、要连接的特定<code class="fe mz na nb nc b">Database</code>以及我们的连接设置。</p><p id="19b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们假设我们想要连接到服务器<code class="fe mz na nb nc b">UKXXX00123,45600</code>，数据库<code class="fe mz na nb nc b">DB01</code>，为此我们想要使用<code class="fe mz na nb nc b">SQL Server Native Client 11.0</code>。</p><p id="676f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从内部连接，因此是可信的连接(我们不需要输入用户名和密码)。</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="ddb2" class="nv md it nc b gy nw nx l ny nz">cnxn_str = ("Driver={SQL Server Native Client 11.0};"<br/>            "Server=UKXXX00123,45600;"<br/>            "Database=DB01;"<br/>            "Trusted_Connection=yes;")</span></pre><p id="5e9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的连接现在初始化为:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="fdc9" class="nv md it nc b gy nw nx l ny nz">cnxn = pyodbc.connect(cnxn_str)</span></pre><p id="83f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们不通过可信连接访问数据库，我们将需要输入通常用于通过SQL Server Management Studio (SSMS)访问服务器的用户名和密码。</p><p id="5889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举个例子，如果我们的用户名是<code class="fe mz na nb nc b">JoeBloggs</code>，我们的密码是<code class="fe mz na nb nc b">Password123</code>，我们应该立即更改密码。</p><p id="beeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在更改那个可怕的密码之前，我们可以这样连接:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="4fec" class="nv md it nc b gy nw nx l ny nz">cnxn_str = ("Driver={SQL Server Native Client 11.0};"<br/>            "Server=UKXXX00123,45600;"<br/>            "Database=DB01;"<br/>            "UID=JoeBloggs;"<br/>            "PWD=Password123;")</span><span id="259c" class="nv md it nc b gy oa nx l ny nz">cnxn = pyodbc.connect(cnxn_str)</span></pre><p id="af81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们连接到数据库，我们可以开始通过Python执行SQL查询。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7519" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">运行查询</h1><p id="a02c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，我们在SQL Server上运行的每个查询都包括游标初始化和查询执行。此外，如果我们在服务器内部进行任何更改，我们还需要将这些更改提交给服务器(我们将在下一节中讨论)。</p><p id="d672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要初始化游标，请执行以下操作:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="17db" class="nv md it nc b gy nw nx l ny nz">cursor = cnxn.cursor()</span></pre><p id="6d50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，每当我们想要执行查询时，我们就使用这个<code class="fe mz na nb nc b">cursor</code>对象。</p><p id="e9fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先从名为<code class="fe mz na nb nc b">customers</code>的表中选择前1000行:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="712a" class="nv md it nc b gy nw nx l ny nz">cursor.execute("SELECT TOP(1000) * FROM customers")</span></pre><p id="3a0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是在服务器内部执行的操作，因此实际上没有任何东西返回给Python。因此，让我们看看如何从SQL中提取这些数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="66f1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">提取数据</h1><p id="b4c7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了将SQL中的数据提取到Python中，我们使用了<code class="fe mz na nb nc b">pandas</code>。Pandas为我们提供了一个非常方便的函数<code class="fe mz na nb nc b">read_sql</code>，这个函数，你可能已经猜到了，从SQL中读取数据。</p><p id="5259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">read_sql</code>需要一个查询和连接实例<code class="fe mz na nb nc b">cnxn</code>，就像这样:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="b544" class="nv md it nc b gy nw nx l ny nz">data = pd.read_sql("SELECT TOP(1000) * FROM customers", cnxn)</span></pre><p id="0777" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将从<code class="fe mz na nb nc b">customers</code>表中返回包含前1000行的数据帧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="56f2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在SQL中更改数据</h1><p id="76aa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，如果我们想要更改SQL中的数据，我们需要向原始的初始化连接添加另一个步骤，执行查询过程。</p><p id="dde4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在SQL中执行查询时，这些更改保存在临时存在的空间中，它们不是直接对数据进行的。</p><p id="3d3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使这些变化永久化，我们必须<code class="fe mz na nb nc b">commit</code>它们。让我们连接<code class="fe mz na nb nc b">firstName</code>和<code class="fe mz na nb nc b">lastName</code>列，创建一个<code class="fe mz na nb nc b">fullName</code>列。</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="e4c6" class="nv md it nc b gy nw nx l ny nz">cursor = cnxn.cursor()</span><span id="139f" class="nv md it nc b gy oa nx l ny nz"># first alter the table, adding a column<br/>cursor.execute("ALTER TABLE customer " +<br/>               "ADD fullName VARCHAR(20)")</span><span id="709c" class="nv md it nc b gy oa nx l ny nz"># now update that column to contain firstName + lastName<br/>cursor.execute("UPDATE customer " +<br/>               "SET fullName = firstName + " " + lastName")</span></pre><p id="3f2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，<code class="fe mz na nb nc b">fullName</code>在我们的数据库中不存在。我们必须<code class="fe mz na nb nc b">commit</code>将这些改变永久化:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="b84f" class="nv md it nc b gy nw nx l ny nz">cnxn.commit()</span></pre><h1 id="ffea" class="mc md it bd me mf ob mh mi mj oc ml mm jz od ka mo kc oe kd mq kf of kg ms mt bi translated">后续步骤</h1><p id="3c0b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦我们完成了需要完成的操作任务。我们可以将数据提取到Python中——或者，我们也可以将数据提取到Python中，并在那里进行操作。</p><p id="4ac6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您采用哪种方法，一旦数据出现在Python中，我们就可以用它做许多以前不可能做的有用的事情。</p><p id="e99a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许我们需要执行一些每日报告，我们通常会用它来查询SQL server中最新的一批数据，计算一些基本的统计数据，并通过电子邮件发送结果。</p><p id="1784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们实现自动化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="04c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，我们结束了！运行这段代码可以快速提取前一周的数据，计算我们的关键度量，并向我们的老板发送一份摘要。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="ba48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，通过几个简单易行的步骤，我们已经初步了解了如何使用SQL和Python的集成来快速建立一个更高效、自动化的工作流。</p><p id="3b13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现这非常有用，不仅仅是对于上面描述的用例。</p><p id="cb22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python只是打开了我们以前仅用SQL无法通过的新路线。</p><p id="06a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我知道你的观点、想法或用例，我很乐意听到它们！如果你想要更多这样的内容，我也会在YouTube上发布。</p><p id="807e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="1476" class="nv md it bd me oi oj dn mi ok ol dp mm li om on mo lm oo op mq lq oq or ms os bi translated"><a class="ae ky" href="https://bit.ly/nlp-transformers" rel="noopener ugc nofollow" target="_blank">🤖《变形金刚》NLP课程70%的折扣</a></h2></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="00f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您喜欢这篇文章，您可能有兴趣更深入地了解Python的电子邮件自动化。我在以前的一篇文章中讨论过这个问题，如果您感兴趣，请查看:</p><div class="ot ou gp gr ov ow"><a rel="noopener follow" target="_blank" href="/notify-with-python-41b77d51657e"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">用Python通知</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">使用Python构建的电子邮件通知让生活更轻松</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div><p id="3069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/jamescalam/pysqlplus" rel="noopener ugc nofollow" target="_blank">这个GitHub repo </a>还包含文档和代码，展示了一些有用方法的实现。</p></div></div>    
</body>
</html>