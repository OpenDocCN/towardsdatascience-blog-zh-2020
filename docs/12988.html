<html>
<head>
<title>Approaching AIcrowd’s LNDST problem in under 50 lines of code!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用不到 50 行代码解决 AIcrowd 的第一个问题！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/approaching-aicrowds-lndst-problem-in-under-50-lines-of-code-b8b5fb536f2b?source=collection_archive---------54-----------------------#2020-09-06">https://towardsdatascience.com/approaching-aicrowds-lndst-problem-in-under-50-lines-of-code-b8b5fb536f2b?source=collection_archive---------54-----------------------#2020-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><p id="2d83" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这篇文章中，我将说明如何解决一个核心的计算机视觉问题，即所谓的<em class="kv">语义分割</em>。简单地说，语义分割的目标是根据图像中显示的内容，简单地将给定图像中的每个像素分类到特定的类别。</p><p id="28af" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">LNDST 是语义分割的经典例子，可以使用<a class="ae kw" rel="noopener" target="_blank" href="/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53#:~:text=A%20Convolutional%20Neural%20Network%20(ConvNet,differentiate%20one%20from%20the%20other.">CNN</a>解决。Landsat 数据集由 400x400 RGB 卫星图像组成，这些图像取自 Landsat 8 号卫星。在每个图像中，可以有水和背景。我们的分类器应该将每个像素预测为<code class="fe kx ky kz la b">0 - background</code>或<code class="fe kx ky kz la b">1 - water</code>。排名的标准是<a class="ae kw" href="https://en.wikipedia.org/wiki/F1_score" rel="noopener ugc nofollow" target="_blank">F1/骰子得分</a>。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/1128f83e1e0718f651e7b3a2fd16fd21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZSXhOkOXc-ngWLZ6wh0tbg.jpeg"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">由<a class="ae kw" href="https://unsplash.com/@spacex" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae kw" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><p id="5b99" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将使用 FastAI v1 来解决这个问题。FastAI 是一个流行的包装器，它与 PyTorch 框架协同工作。我选择 FastAI 来解决这个问题，因为它提供了几个特性，比如学习率查找器、可以用几行代码创建的数据加载器，以及其他几个好东西。确保您已经下载了<a class="ae kw" href="https://www.aicrowd.com/challenges/ai-for-good-ai-blitz-3/problems/lndst/dataset_files" rel="noopener ugc nofollow" target="_blank">数据集</a>，并将其提取到名为<em class="kv"> data 的文件夹中。</em>我们开始吧！</p><pre class="lc ld le lf gt lr la ls lt aw lu bi"><span id="ee06" class="lv lw it la b gy lx ly l lz ma">from fastai.vision import *</span></pre><p id="8de4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">上面一行导入了 FastAI 的视觉模块。</p><pre class="lc ld le lf gt lr la ls lt aw lu bi"><span id="403c" class="lv lw it la b gy lx ly l lz ma">path = Path('data')<br/>path_img = path/'train_images'<br/>path_lbl = path/'train_gt'</span><span id="efda" class="lv lw it la b gy mb ly l lz ma">img_names = get_image_files(path_img)<br/>lbl_names = get_image_files(path_lbl)</span></pre><p id="7e93" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv"> img_names </em>和<em class="kv"> lbl_names </em>是包含训练图像及其各自遮罩的列表。</p><pre class="lc ld le lf gt lr la ls lt aw lu bi"><span id="a6bd" class="lv lw it la b gy lx ly l lz ma"># Batch Size<br/>bs = 8</span><span id="227d" class="lv lw it la b gy mb ly l lz ma"># Labels<br/>labels = ['background', 'water']</span><span id="b179" class="lv lw it la b gy mb ly l lz ma"># Mapping fuction mapping x names and y names<br/>def get_y_fn(x):<br/>    dest = x.name.split('.')[0] + '.png'\<br/>    return path_lbl/dest</span><span id="6351" class="lv lw it la b gy mb ly l lz ma">src = (SegmentationItemList.from_folder(path_img)<br/>        # Load in x data from folder<br/>        .split_by_rand_pct()<br/>        # Split data into training and validation set<br/>        .label_from_func(get_y_fn, classes=labels)<br/>        # Label data using the get_y_fn function<br/>)</span><span id="4b91" class="lv lw it la b gy mb ly l lz ma"># Define our image augmentations<br/>tfms = get_transforms(flip_vert=True, max_lighting=0.1, max_zoom=1.05, max_warp=0.)</span><span id="04d1" class="lv lw it la b gy mb ly l lz ma">data = (src.transform(tfms, size=400, tfm_y=True)<br/>        # Augments the images and the mask<br/>        .databunch(bs=bs)<br/>        # Create a databunch<br/>        .normalize(imagenet_stats)<br/>        # Normalize for imagenet mean and std<br/>)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mc"><img src="../Images/4d236455b3c6871f663a32900578dbd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yy-hxUdMxRVywQ8Co9igjQ.png"/></div></div></figure><p id="c4ce" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">上面的代码创建了一个<em class="kv"> ImageDataBunch </em>对象，它处理数据处理的所有方面，比如预处理、扩充、分割成训练集和验证集等等。现在让我们来看一看我们的一小批数据。</p><pre class="lc ld le lf gt lr la ls lt aw lu bi"><span id="ca7f" class="lv lw it la b gy lx ly l lz ma">data.show_batch(8, figsize=(10,10))</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi md"><img src="../Images/ed0fee46bf5bd897eb6a7307ce7021fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PdFgMoc5u4inlKaVgJe91A.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">这是在应用旋转、翻转等随机变换后的随机小批量。</p></figure><p id="aa0b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们的数据已经准备好了，让我们创建一个模型并训练它。有几种架构可用于解决细分任务，如 U-Net、FPN、DeepLabV3 和 PSPNet。我们将在本文中使用 U-Net。</p><pre class="lc ld le lf gt lr la ls lt aw lu bi"><span id="da5e" class="lv lw it la b gy lx ly l lz ma"># Pretrained Encoder<br/>encoder = <!-- -->models.resnet34</span><span id="415d" class="lv lw it la b gy mb ly l lz ma">learn = unet_learner(data, encoder, metrics=dice)</span></pre><p id="64a7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">FastAI 的<em class="kv"> unet_learner </em>方法创建了一个<em class="kv"> Learner </em>类的实例。<em class="kv">学员</em>班处理完整的培训循环并打印指定的指标。该方法特别使用给定的编码器构建了一个类似 U-Net 的架构，并只为编码器部分加载 imagenet 预训练权重。如果你不确定 U 网是如何工作的，看看这篇文章。请注意，我们将骰子作为一个度量来传递，这将让我们了解我们的模型在测试集上的表现。</p><pre class="lc ld le lf gt lr la ls lt aw lu bi"><span id="fd5b" class="lv lw it la b gy lx ly l lz ma">learn.lr_find()<br/>learn.recorder.plot()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi me"><img src="../Images/3e31fcbcac327488f657ab5ab197536a.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*NcKntMjQA4C5t6XmUmd-uA.png"/></div></figure><p id="4302" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个图表给了我们一个最佳学习率的概念。根据 FastAI 的说法，最佳学习率应该是图中最陡的向下斜率，在该斜率处，损失快速下滑至最小值。在这种情况下，它可以是 1e-5 左右的任何值。</p><pre class="lc ld le lf gt lr la ls lt aw lu bi"><span id="799d" class="lv lw it la b gy lx ly l lz ma"># Fit the model<br/>learn.fit_one_cycle(10, 1e-5)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/da5e0480c5a465b496d980f98a4b8da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*CIxudW2bzF1MaWaJR0PbiA.png"/></div></figure><p id="d1a0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，我们以 1e-5 的最大学习速率运行 10 个纪元。FastAI 使用一个周期策略进行学习率调度，这在本文<a class="ae kw" href="https://arxiv.org/pdf/1803.09820.pdf" rel="noopener ugc nofollow" target="_blank">中</a>提到过。该初始训练仅更新解码器的参数，保留预训练编码器的权重。一旦我们的模型训练得足够好，我们也可以解冻编码器，并训练更多的编码器。</p><pre class="lc ld le lf gt lr la ls lt aw lu bi"><span id="0b7a" class="lv lw it la b gy lx ly l lz ma"># Unfreeze and train some more<br/>learn.unfreeze()<br/>learn.fit_one_cycle(10, slice(1e-6, 1e-5))</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/57fa28f42ef1ad0b057cd6bea8c120c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*acWjSdOEm4oUpXZOT77YrA.png"/></div></figure><p id="a243" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，我们用有区别的学习速率训练更多的时期，其中较早的层用较低的最大学习速率训练，并且学习速率对于随后的层组增加。现在我们的模型已经训练好了，我们将直观地检查模型是否工作正常。</p><pre class="lc ld le lf gt lr la ls lt aw lu bi"><span id="5beb" class="lv lw it la b gy lx ly l lz ma">learn.show_results(rows=3, figsize=(10,10))</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/6de588aa3f3edcae4f9320dfec2efb00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*NFy7_LSoF50_aHq32kGFgg.png"/></div></figure><p id="1e8f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在一切都设置好了，我们可以在测试集上运行推理并提交了！</p><pre class="lc ld le lf gt lr la ls lt aw lu bi"><span id="5e6c" class="lv lw it la b gy lx ly l lz ma">from glob import glob<br/>lst = sorted(glob('.data/test_images/*') , key=lambda x: int(x.split('_')[-1].split('.')[0]))</span><span id="3b8c" class="lv lw it la b gy mb ly l lz ma">main_array = []</span><span id="9de0" class="lv lw it la b gy mb ly l lz ma">for i in lst:<br/>    # Open image<br/>    img = open_image(i)<br/>    mask = learn.predict(img)[0]</span><span id="2905" class="lv lw it la b gy mb ly l lz ma">    # Convert torch tensor to numpy array<br/>    mask = mask.data.numpy()</span><span id="7beb" class="lv lw it la b gy mb ly l lz ma">    # Flatten the array<br/>    mask = mask.flatten()<br/>    main_array.append(mask)</span><span id="e946" class="lv lw it la b gy mb ly l lz ma">main_array = np.asarray(main_array)<br/>main_array_flat = np.reshape(main_array,(-1)).astype(np.uint8)</span><span id="d727" class="lv lw it la b gy mb ly l lz ma">with open('submission.npy', 'wb') as f:<br/>    np.save(f,main_array_flat)</span></pre><p id="6e01" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">上面的代码在测试集上运行推理，并创建一个可以提交到 AIcrowd 网站的提交文件。</p><h1 id="774e" class="mi lw it bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated"><strong class="ak">结论</strong></h1><p id="d935" class="pw-post-body-paragraph jx jy it jz b ka nf kc kd ke ng kg kh ki nh kk kl km ni ko kp kq nj ks kt ku im bi translated">这绝对不是可能让你在排行榜上获得最佳成绩的完整解决方案。但这绝对是一个很好的起点，人们可以在此基础上开发他们的解决方案。对上述解决方案的一些改进可以是进行交叉验证、集成、测试时间增加、检查除交叉熵损失之外的不同损失函数，等等。最后，我想祝贺 AIcrowd 的团队创造了这个精彩的平台，举办了这场令人敬畏的短时间闪电战比赛，这无疑鼓励了初学者步入机器学习的世界。</p></div></div>    
</body>
</html>