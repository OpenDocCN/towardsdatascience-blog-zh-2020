<html>
<head>
<title>Precision, Recall and Predicting Cervical Cancer with Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习在宫颈癌预测中的应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/precision-recall-and-predicting-cervical-cancer-with-machine-learning-367221e70538?source=collection_archive---------12-----------------------#2020-01-05">https://towardsdatascience.com/precision-recall-and-predicting-cervical-cancer-with-machine-learning-367221e70538?source=collection_archive---------12-----------------------#2020-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3eb0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">OSEMN代表什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ed9e51619f6f14b04f296b1a56153532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gbyIbZP1xDmRYC55lR-atg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从Adobe Stock获得许可的图像</p></figure><p id="9eb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">机器学习通常被描述为人工智能的一个子集，通常涉及创建能够以各种方式分析数据以做出预测的“模型”。它已经在无数领域证明了自己的用处，包括像“推荐引擎”这样众所周知的应用程序，它根据“学习”用户过去的行为来推荐用户喜欢的内容。作为我进入数据科学之旅的一部分，我编写并测试了几个机器学习模型，以使用关于女性的数据集进行预测，以及在哪里进行活检以确定是否存在宫颈癌。</p><p id="a5f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据集是从加州大学欧文分校(UCI)的机器学习库中获得的，位于这个<a class="ae md" href="https://archive.ics.uci.edu/ml/datasets/Cervical+cancer+%28Risk+Factors%29#" rel="noopener ugc nofollow" target="_blank">链接</a>。这些信息是在委内瑞拉加拉加斯的“加拉加斯大学医院”收集的，由35个因素组成，包括858名患者的人口统计信息、习惯和历史医疗记录。由于隐私问题(缺少值)，一些患者选择不回答一些问题。我之前写过一篇关于处理丢失数据的简短文章<a class="ae md" rel="noopener" target="_blank" href="/dealing-with-missing-data-17f8b5827664?source=friends_link&amp;sk=5ecf67f2141e50bcd47dc37b33e96deb">这里</a>。该数据集来自于2017年5月首次在线发表的一篇研究论文。</p><p id="6c8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">目标、挑战和‘目标’</strong></p><p id="3c2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个项目的目标是开发一个机器学习模型，该模型可以使用每个妇女可能的风险因素的35个变量尽可能好地预测宫颈癌的存在。使用这种类型的数据开发预测模型时面临的一个挑战是精确度和召回率之间的平衡:</p><ul class=""><li id="ae92" class="me mf it la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">精度表示模型预测的癌症中实际存在癌症的比例。</li><li id="0738" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">回忆表示模型准确预测的所有癌症病例的比例。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/e0ac954d985bf4170b1f78fad66c55fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*Mv0JgHn_ulRiRIy1A0OuzQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由沃尔伯提供—自己的作品，CC BY-SA 4.0</p></figure><div class="mt mu gp gr mv mw"><a href="https://commons.wikimedia.org/w/index.php?curid=36926283" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">Precisionrecall.svg</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">来自维基共享，自由媒体仓库</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">commons.wikimedia.org</p></div></div></div></a></div><p id="bb54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为不“捕捉”甚至一个癌症病例都可能导致死亡，所以模型应该强调回忆分数。更可取的做法是不“遗漏”任何癌症患者，即使这意味着将一些实际上没有患病的患者“标记”为患有癌症。</p><p id="c159" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用此类数据创建预测模型的另一个挑战是，阳性病例(存在癌症)通常只占数据集中患者总数的一小部分。这就产生了所谓的“不平衡”数据集，即。在我们试图预测的两个类别中，个体的数量是不相等的。不平衡的数据使得机器学习模型的预测更加困难，因为与阴性(没有癌症)病例相比，可以学习的“阳性”(存在癌症)病例更少。有了这样不平衡的数据，预测模型可以很容易地以牺牲精度为代价获得很高的召回率，反之亦然。例如，想象一个包含1，000名患者的数据集，其中10人患有癌症，这是一个非常现实的场景:</p><ul class=""><li id="c57c" class="me mf it la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">一个预测每个人都患有癌症的模型的召回率为100%，但精确度为1%。像这样的预测模型没有任何价值。然后，所有的病人都要接受活组织检查，记录所有的癌症病例，但对990名妇女进行不必要的检查。</li></ul><p id="8948" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，预测模型的目标是以尽可能少的“假阳性”(预测有癌症，但实际上没有癌症)识别尽可能高百分比的癌症病例。</p><p id="1ba4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个模型I测试将首先通过查看召回率进行评估，然后是F1分数，F1分数是反映精确度和召回率同等平衡权重的衡量标准:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/2c8a0f2dd63a085d91255b5b184a98d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*Y56niUfUxzxcxJkI-hQCEw.png"/></div></figure><p id="6f90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我开发模型的方法遵循OSEMN协议:</p><ul class=""><li id="fb1e" class="me mf it la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">获得</li><li id="7115" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">矮树</li><li id="5b51" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">探索</li><li id="c0a9" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">模型</li><li id="32b9" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">口译</li></ul><p id="3bf6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该项目是在Jupyter笔记本中开发的，使用了scikit-learn的数据科学包以及笔记本中记录的其他一些资源。笔记本和运行它所需的所有文件可以在我的GitHub库<a class="ae md" href="https://github.com/giorosati/dsc-3-final-project-online-ds-pt-100118" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="72c1" class="ng nh it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated"><strong class="ak">获得&amp;磨砂</strong></h1><p id="3e97" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">在初始化笔记本并将数据集加载到Pandas数据框架后，我查看了它包含的值的类型以及哪些因素缺少信息。在dataframe导入阶段，我用NumPy“NaN”填充了所有缺失的值。以下是用红色显示缺少值的变量的数据概述:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/a9c746cfc443b615051b6f79b5505e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndsuXhbgY08_dD_xZO0Tlg.png"/></div></div></figure><p id="ce5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">创造一些新的因素</strong></p><p id="c333" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管某些因素中缺失值的百分比相对较小，但我不想丢失这些因素中可能存在的任何信息:</p><ul class=""><li id="455e" class="me mf it la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">性伴侣数量</li><li id="35b4" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">第一次性交</li><li id="e9dc" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">怀孕数量</li></ul><p id="2594" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我创建了新的布尔因子来区分已知信息的记录和未给出数据的记录。如果记录有值，则这些新因子的值为true (1)，如果记录缺少该因子的数据，则这些新因子的值为false (0):</p><ul class=""><li id="3432" class="me mf it la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">已知有_ number _ partners _吗</li><li id="2b47" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">第一次性交是已知的</li><li id="a8b4" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">已知怀孕次数吗</li></ul><p id="dba4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我编写了一个从现有列创建新列的函数:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="5367" class="oj nh it of b gy ok ol l om on">def new_bool(df, col_name):<br/>   bool_list = []<br/>   for index, row in df.iterrows():<br/>      value = row[col_name]<br/>      value_out = 1<br/>      if pd.isna(value):<br/>         value_out = 0<br/>      bool_list.append(value_out)<br/>   return bool_list</span></pre><p id="3361" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是如何使用此函数创建每个新因子(列)的示例:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="5f5d" class="oj nh it of b gy ok ol l om on"># create new factor ‘is_number_partners_known’<br/>df[‘is_number_partners_known’] = new_bool(df, ‘Number of sexual partners’)</span></pre><p id="d0f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这三个原始因子也有缺失值，我稍后会将它们与所有其他缺失值一起处理。</p><p id="c754" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">处理数据中的“漏洞”</strong></p><p id="b605" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我创建了一个函数来显示给定因子的计数图、箱线图和一些汇总统计数据，这样我可以更好地了解这些因子的分布情况:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="b022" class="oj nh it of b gy ok ol l om on">def countplot_boxplot(column, dataframe):<br/>   fig = plt.figure(figsize=(15,20))<br/>   fig.suptitle(column, size=20)<br/> <br/>   ax1 = fig.add_subplot(2,1,1)<br/>   sns.countplot(dataframe[column])<br/><br/>   plt.xticks(rotation=45)</span><span id="0638" class="oj nh it of b gy oo ol l om on">   ax2 = fig.add_subplot(2,1,2)<br/>   sns.boxplot(dataframe[column])<br/><br/>   plt.xticks(rotation=45)<br/>   plt.show()<br/> <br/>   print(‘Min:’, df2[column].min())<br/>   print(‘Mean:’, df2[column].mean())<br/>   print(‘Median:’, df2[column].median())<br/>   print(‘Mode:’, df2[column].mode()[0])<br/>   print(‘Max:’, df2[column].max())<br/>   print(‘**********************’)<br/>   print(‘% of values missing:’, (df2[column].isna().sum() / len(df2))*100)</span></pre><p id="67db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在评估了每个因素后，我决定如何最好地处理缺失的值。这里有一个“第一次性交”因素的流程示例，它代表女性第一次经历性交的年龄。我运行了上面的函数，传递了列名:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="fbba" class="oj nh it of b gy ok ol l om on">countplot_boxplot('First sexual intercourse', df2)</span></pre><p id="de80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是输出结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/70542ea7b62a2df1fe642a2d0a7d5a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GF-5985xdplKvn1iV0pNwA.png"/></div></div></figure><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="f51a" class="oj nh it of b gy ok ol l om on">Min: 10.0<br/>Mean: 16.995299647473562<br/>Median: 17.0<br/>Mode: 15.0<br/>Max: 32.0<br/>**********************<br/>% of values missing: 0.8158508158508158</span></pre><p id="655c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过观察这两个图，很明显，分布是有点正常的，在范围的高端有一个长“尾巴”。同样重要的是，这个因子只有不到1%的值丢失，所以无论我用什么来填充丢失的值，对模型的影响都是最小的。我选择用中间值来填充这里缺失的值。</p><p id="cf1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我继续检查每个因子，用零、平均值或中值替换缺失值，但有几个因子需要一些额外的思考:</p><ul class=""><li id="82b0" class="me mf it la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">STDs:自首次诊断以来的时间</li><li id="2012" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">STDs:自上次诊断以来的时间</li></ul><p id="c2e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">超过90%的患者对这些因素没有价值。我可以简单地删除这些因素——机器学习模型无法处理缺失值——但我不想丢失10%患者的信息，这些信息对这些因素有价值。我注意到“父”因子“STDs:Number of diagnostics”也缺少相同数量的值。我的假设是，这些女性拒绝回答这个问题和这两个相关的问题。我选择用零填充所有三个因子中缺失的值:</p><ul class=""><li id="6996" class="me mf it la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">性传播疾病:诊断数量</li><li id="3e0f" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">STDs:自首次诊断以来的时间</li><li id="4a15" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">STDs:自上次诊断以来的时间</li></ul><p id="55b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在“STD's (number)”因素上遇到了类似的情况。我再次运行我的函数来可视化数据:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="808d" class="oj nh it of b gy ok ol l om on">countplot_boxplot('STDs (number)', df2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/bc185900bb6454d42aa987e444514e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LRo3RDaMJycULwUI6Jmf-g.png"/></div></div></figure><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="09c4" class="oj nh it of b gy ok ol l om on">Min: 0.0<br/>Mean: 0.17662682602921648<br/>Median: 0.0<br/>Mode: 0.0<br/>Max: 4.0<br/>**********************<br/>% of values missing: 12.237762237762238</span></pre><p id="1953" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的值几乎为零，大约有12%的数据丢失。由于零在这个因子的分布中占主导地位，我觉得用零代替缺失值是最好的选择。此外，12个单独的布尔因子中的每一个都有大约12%的缺失值。我还用零替换了所有单个布尔“STD”因子中缺失的值。</p><h1 id="a3ad" class="ng nh it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated"><strong class="ak">探索</strong></h1><p id="64be" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">填充所有缺失值后，关联热图显示两个因素完全没有信息:</p><ul class=""><li id="2c79" class="me mf it la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">性病:宫颈湿疣</li><li id="ee60" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">性病:艾滋病</li></ul><p id="d744" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我从数据库中删除了这些因素，然后运行了一个关联热图，显示每个因素如何单独与目标变量“活检”相关。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/b83f3ee2698708f23cae63bee5fc7880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ChFYqblQXbwHC4yxcPK9TA.png"/></div></div></figure><p id="a395" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这张热图表明<strong class="la iu">自身</strong>的因素:</p><ul class=""><li id="a89c" class="me mf it la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">席勒</li><li id="2173" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">欣塞尔曼</li><li id="bc76" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">城市学</li></ul><p id="ade1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是最有用的。</p><h1 id="0b45" class="ng nh it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated"><strong class="ak">型号</strong></h1><p id="81a3" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">下一步是将数据分成训练集和测试集:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="22f4" class="oj nh it of b gy ok ol l om on">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state= 10)</span></pre><p id="31db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用80%的数据进行训练，并指定一个random_state以确保可重复性。</p><p id="dfb0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该数据集中的非布尔因子:</p><ul class=""><li id="56ed" class="me mf it la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">年龄</li><li id="3a89" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">性伴侣数量</li><li id="f4f1" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">第一次性交</li><li id="af19" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">怀孕数量</li><li id="57cd" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">吸烟(年)</li><li id="6dfa" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">烟(包/年)</li><li id="b68e" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">激素避孕药(年)</li><li id="ac43" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">宫内节育器(年)</li><li id="15c4" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">性传播疾病(数量)</li><li id="cf09" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">STD(诊断数量)</li><li id="3e71" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">STDs:自首次诊断以来的时间</li><li id="8b0d" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">STDs:自上次诊断以来的时间</li></ul><p id="8f6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有非常不同的范围。我标准化了每个因素的值(使每个因素的范围从0到1)，以便机器学习算法不会仅仅因为它的范围较大而偏向任何因素。对于给定的因素，每个患者的值之间的关系保持不变，但现在每个因素都有相同的尺度。这防止了不同因素之间的不同等级，从而使模型对该因素的重要性的评估产生偏差。值得注意的是，标准化(或规范化)是对训练和测试数据集分别进行的。我不想让模型对将要测试的数据有任何了解。模型必须只从测试集中学习。</p><p id="2cdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前所述，这是一个“不平衡”的数据集，只有大约10%的记录具有目标变量的“真”值。一些机器学习模型具有内置功能来补偿这一点，而一些没有。我测试了来自不平衡学习的一个名为SMOTE(合成少数过采样技术)的包，以创建一个平衡的数据集——其中有相等数量的真和假目标变量记录。这只在训练数据上进行，而不在测试数据上进行。下面是创建这种重采样训练数据的语法:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="2c2d" class="oj nh it of b gy ok ol l om on">sm = SMOTE(sampling_strategy='auto', random_state=10)</span><span id="bcee" class="oj nh it of b gy oo ol l om on">X_train_res, y_train_res = sm.fit_resample(X_train, y_train)</span></pre><p id="246c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">查看原始数据和重采样数据的差异:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="aa5d" class="oj nh it of b gy ok ol l om on">X_train.shape   #the original data</span><span id="21c3" class="oj nh it of b gy oo ol l om on">(686, 36)<br/></span><span id="5f55" class="oj nh it of b gy oo ol l om on">X_train_res.shape   #the resampled data</span><span id="144c" class="oj nh it of b gy oo ol l om on">(1294, 36)</span></pre><p id="ce19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建了608条“虚构”记录(1，294减去686)来“平衡”数据集。这些新记录被创建为与目标变量为真的现有记录相似。</p><p id="05bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我可以用原始的“不平衡”数据集或重新采样的“平衡”数据集来测试任何模型。我发现，当给定这种重新采样的训练数据时，逻辑回归和KNN模型表现得更好，但是决策树、随机森林和支持向量机(SVM)模型在使用原始不平衡数据但实现它们自己的内置类权重参数时表现得更好。</p><p id="d82f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了方便测试每个模型，我创建了一个函数来返回我想了解的每个模型的性能信息:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="91d7" class="oj nh it of b gy ok ol l om on">def analysis(model, X_train, y_train):<br/>    model.fit(X_train, y_train)</span><span id="2566" class="oj nh it of b gy oo ol l om on"># predict probabilities<br/>    probs = model.predict_proba(X_test)</span><span id="3f4e" class="oj nh it of b gy oo ol l om on"># keep probabilities for the positive outcome only<br/>    probs = probs[:, 1]</span><span id="c4a1" class="oj nh it of b gy oo ol l om on"># predict class values<br/>    preds = model.predict(X_test)</span><span id="04f7" class="oj nh it of b gy oo ol l om on"># calculate precision-recall curve<br/>    precision, recall, thresholds = precision_recall_curve(y_test, probs)</span><span id="54a7" class="oj nh it of b gy oo ol l om on"># calculate average precision<br/>    average_precision = average_precision_score(y_test, probs)<br/>    <br/>    # recall score for class 1 (Predict that Biopsy is True)<br/>    rs = recall_score(y_test, preds)</span><span id="6589" class="oj nh it of b gy oo ol l om on"># calculate F1 score<br/>    f1 = f1_score(y_test, preds)</span><span id="8d25" class="oj nh it of b gy oo ol l om on"># calculate precision-recall AUC<br/>    auc_score = auc(recall, precision)</span><span id="a10a" class="oj nh it of b gy oo ol l om on"># create chart<br/>    # In matplotlib &lt; 1.5, plt.fill_between does not have a 'step' argument<br/>    step_kwargs = ({'step': 'post'}<br/>                   if 'step' in signature(plt.fill_between).parameters<br/>                   else {})<br/>    plt.step(recall, precision, color='b', alpha=0.2, where='post')<br/>    plt.fill_between(recall, precision, alpha=0.2, color='b', **step_kwargs)</span><span id="537e" class="oj nh it of b gy oo ol l om on"># plot a "no skill" line<br/>    plt.plot([0, 1], [0.5, 0.5], linestyle='--')</span><span id="b132" class="oj nh it of b gy oo ol l om on">plt.xlabel('Recall')<br/>    plt.ylabel('Precision')<br/>    plt.ylim([0.0, 1.05])<br/>    plt.xlim([0.0, 1.0])<br/>    plt.title('Precision-Recall curve: Average Precision={0:0.3f}'.format(average_precision))<br/>    plt.show()</span><span id="868b" class="oj nh it of b gy oo ol l om on"># print(confusion_matrix(y_test, preds))<br/>    print('Classification Report:')<br/>    print(classification_report(y_test, preds))</span><span id="9b5a" class="oj nh it of b gy oo ol l om on">print('f1=%.3f auc=%.3f recall=%.3f' % (f1, auc_score, rs))</span></pre><p id="3bb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">GridSearchCV方法用于搜索我测试的大多数模型的最佳参数。下面是一个使用GridSearchCV和随机森林分类器的示例:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="3387" class="oj nh it of b gy ok ol l om on">forest = RandomForestClassifier(random_state=10, n_jobs=-1)</span><span id="4ac0" class="oj nh it of b gy oo ol l om on">forest_param_grid = {<br/>    'class_weight': ['balanced'],<br/>    'criterion': ['gini', 'entropy' ],<br/>    'max_depth': [2, 3, 4, 5, 6, 7, 8],<br/>    'n_estimators': [20, 40, 50, 60, 80, 100, 200]}</span><span id="80be" class="oj nh it of b gy oo ol l om on">forest_grid_search = GridSearchCV(forest, <br/>                                  param_grid = forest_param_grid, <br/>                                  scoring = 'recall',<br/>                                  cv=3,<br/>                                  return_train_score=True)</span></pre><p id="8b15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本例中，“class_weight”被设置为“balanced ”,以让随机森林实现其内置方法，这些方法针对其正在接受训练的不平衡数据进行调整。然后，我使用测试数据拟合模型:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="5085" class="oj nh it of b gy ok ol l om on">forest_grid_search.fit(X_train, y_train)</span></pre><p id="1c3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">GridSearchCV发现以下参数值效果最佳:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="8e7c" class="oj nh it of b gy ok ol l om on">Optimal Parameters: {'class_weight': 'balanced', 'criterion': 'gini', 'max_depth': 2, 'n_estimators': 20}</span></pre><p id="f036" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于这些信息，我重新运行了另一个GridSearchCV来进一步细化参数值:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="a8bd" class="oj nh it of b gy ok ol l om on">forest_param_grid = {<br/>    'class_weight': ['balanced'],<br/>    'criterion': ['gini'],<br/>    'max_depth': [2, 3, 4],<br/>    'n_estimators': [10, 15, 20, 25, 30]}</span><span id="550e" class="oj nh it of b gy oo ol l om on">forest_grid_search = GridSearchCV(forest, <br/>                                  param_grid = forest_param_grid, <br/>                                  scoring = 'recall',<br/>                                  cv=3,<br/>                                  return_train_score=True)</span></pre><p id="9cfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">找到的最佳值是:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="ed9e" class="oj nh it of b gy ok ol l om on">Optimal Parameters: {'class_weight': 'balanced', 'criterion': 'gini', 'max_depth': 2, 'n_estimators': 10}</span></pre><p id="db60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用这些值创建了一个新的随机林，然后使用测试数据进行预测:</p><h1 id="bbb5" class="ng nh it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">口译</h1><p id="46f1" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">以下是优化随机森林的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/037f881da015890a555554d7382be226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*MXJFTvT9AqzWlnlvZGb3DQ.png"/></div></figure><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="9549" class="oj nh it of b gy ok ol l om on">Classification Report:<br/>              precision    recall  f1-score   support<br/><br/>           0       0.99      0.96      0.97       156<br/>           1       0.67      0.88      0.76        16<br/><br/>    accuracy                           0.95       172<br/>   macro avg       0.83      0.92      0.86       172<br/>weighted avg       0.96      0.95      0.95       172<br/><br/>f1=0.757 auc=0.555 recall=0.875</span></pre><p id="8444" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该模型能够“找到”88%的癌症女性(回忆)，并且其67%的癌症预测是正确的(精确度)。</p><p id="abfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了查看这个模型使用了什么特性，我使用了一个特性重要性图表。红色条代表每个特征的重要性，每个红色条顶部的黑线代表该特征在所有树中重要性的标准偏差。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/fc436989e6d1537beade112ba7f52d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6EIaL1RGPcn0aESAyPOBYg.png"/></div></div></figure><p id="c850" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有趣的是,“年龄”因素和“性学”因素——一种诊断测试——一样重要。</p><p id="21e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">决策树和随机森林的一个优点是它们的可解释性。下图显示了该项目中表现最佳的单一决策树是如何工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/f37568eae8d98e77dcaa6df1fdd05dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbYQnotrQ5uAeJP6QuQ00Q.png"/></div></div></figure><p id="a557" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该树仅使用这些因素:</p><ul class=""><li id="ead7" class="me mf it la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">席勒</li><li id="49e5" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">Dx:CIN</li><li id="92c4" class="me mf it la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">年龄</li></ul><p id="18a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对每个病人进行分类。随机森林模型在10种不同的树中使用了15个因子，以获得稍好的性能。(查看Jupyter笔记本以查看所有的树)。</p><p id="7900" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在对我研究的所有模型进行调优和测试之后，以下是每种模型的最佳结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/f025b9ecbd2a2bdcc0dd7976bf66bbb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czTM6a8dMQUg9UYJWKq6xA.png"/></div></div></figure><p id="2002" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用原始不平衡数据的随机森林模型表现最好，其次是决策树模型。</p><p id="4ca1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在未来的帖子中，我打算探索神经网络预测模型是否可以改善这些F1和回忆分数。</p><p id="c767" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。我一直对了解数据科学如何让世界更好地为每个人服务很感兴趣。如果您知道数据科学“发挥作用”的情况，请分享！</p><h1 id="8376" class="ng nh it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">数据集引用:</h1><p id="806d" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">凯尔温·费尔南德斯、海梅·卡多佐和杰西卡·费尔南德斯。具有部分可观察性的迁移学习应用于宫颈癌筛查。伊比利亚模式识别和图像分析会议。斯普林格国际出版公司，2017年。<a class="ae md" href="https://archive.ics.uci.edu/ml/datasets/Cervical+cancer+%28Risk+Factors%29" rel="noopener ugc nofollow" target="_blank">https://archive . ics . UCI . edu/ml/datasets/子宫颈+癌症+% 28风险+因素%29# </a></p></div></div>    
</body>
</html>