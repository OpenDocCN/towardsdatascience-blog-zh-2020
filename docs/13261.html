<html>
<head>
<title>GCP Serverless Design Pattern: Adhering to rate &amp; concurrency limits with Cloud Tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GCP 无服务器设计模式:遵守云任务的速率和并发限制</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/gcp-serverless-design-pattern-adhering-to-rate-concurrency-limits-with-cloud-tasks-30aa756da763?source=collection_archive---------44-----------------------#2020-09-11">https://towardsdatascience.com/gcp-serverless-design-pattern-adhering-to-rate-concurrency-limits-with-cloud-tasks-30aa756da763?source=collection_archive---------44-----------------------#2020-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ec10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管我认为自己了解与数据工程相关的多种 GCP 产品，但我之前从未听说过云任务的用例。</p><p id="e2f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章旨在通过提出一个具体的问题，并从发布者与云任务的角度讨论它，来阐明云任务的用例。</p><h1 id="8667" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">挑战</h1><p id="33bb" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">作为客户数据细分项目的一部分，我遇到了将用户数据发送到<a class="ae lo" href="https://developers.google.com/adwords/api/docs/reference/v201809/AdwordsUserListService?hl=de" rel="noopener ugc nofollow" target="_blank"> Google Ads 再营销受众 API </a>的挑战，该 API 有以下限制:</p><ol class=""><li id="5f91" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">每个请求只能包含大约 50.000 条用户记录。随着每个请求的记录越来越多，性能会以指数级的速度增长。</li><li id="2068" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">每个 Google Ads 帐户一次只能处理一(1)个请求。同时提交另一个请求会导致所有其他正在进行的请求出错。</li><li id="c94f" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">每个请求需要一到五分钟来处理。</li></ol><p id="db62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">项目背景:</strong></p><p id="d0b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要发送给 API 的数据将以 CSV 文件的形式从 BigQuery 到达云存储。每个预期的 CSV 文件将包含 50，000 到 4，000，000 条记录。</p><p id="8770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编排引擎(Cloud Composer)只负责在 BigQuery 中运行业务逻辑，并将结果保存到云存储中。Cloud composer 不处理传出数据管道，因为传出数据管道应该是反应式的&amp;无服务器的。</p><p id="6411" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要细分的客户群包含大约 400 万客户，每个客户至少属于一个细分市场。编排引擎将在 BigQuery 中运行一个业务逻辑查询——每个片段将被推送到 Google Ads——导致 7 个不同的文件在几分钟内到达云存储。</p><h1 id="9b4d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">局部解决</h1><p id="46de" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当一个新文件进入云存储时，一个事件可以被提交到 PubSub，或者立即反馈到云功能。更多关于这个<a class="ae lo" href="https://cloud.google.com/storage/docs/pubsub-notifications" rel="noopener ugc nofollow" target="_blank">的信息在这里</a>。</p><p id="ed87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过设置从云存储桶触发的云功能，我们可以通过将文件分成更小的部分来解决 api 限制 1(每个请求最多 50k 条记录)。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/2a5f79c1bcf11652aef698ca411f9d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ua85DWAQLABp1CdeUdtXBg.png"/></div></div></figure><p id="1ba9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是现在呢？简单地循环原始文件并将部分记录推送到 Google Ads 中是一种非常脆弱的处理方式。只需考虑以下几点:</p><h2 id="f0e8" class="mp km iq bd kn mq mr dn kr ms mt dp kv jy mu mv kz kc mw mx ld kg my mz lh na bi translated">我们期望该函数运行多长时间？</h2><p id="dd43" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">4.000.000/50.000=80 份。假设 50.000 条记录的每个部分需要 5 分钟来传输。我们谈论的是近 7 小时的连续运行时间。这远远超出了云功能所支持的范围。</p><h2 id="7f0e" class="mp km iq bd kn mq mr dn kr ms mt dp kv jy mu mv kz kc mw mx ld kg my mz lh na bi translated"><strong class="ak">如果我们已经在传输一个文件了，而另一个文件到达了 GCS 怎么办？</strong></h2><p id="f92c" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如前一节所述，我们的编排引擎将为每个片段生成一个文件。这意味着，当我们开始向谷歌广告推送第一个片段的大块时，另一个片段将会出现，并并行触发云功能的执行。根据 API 限制的第二(2)点，这将导致两个请求都失败。如果没有某种方法来确保只有一个并发的调度发生，我们将不得不把到达云存储的数据段之间的时间分散开。</p><h1 id="ba7f" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">Cloud PubSub 的问题(针对本次挑战)</h1><p id="0406" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我最初的方法是遵循 Google 设计的这个解决方案中概述的架构:<a class="ae lo" href="https://cloud.google.com/solutions/serverless-integration-solution-for-google-marketing-platform" rel="noopener ugc nofollow" target="_blank"> <em class="nb">一个 GMP </em> </a> <em class="nb">的无服务器集成解决方案。</em>该解决方案结合使用了启动器和传输功能，以及 3 个 PubSub 主题。要了解他们提议的架构，请阅读解决方案的<a class="ae lo" href="https://cloud.google.com/solutions/serverless-integration-solution-for-google-marketing-platform#architectural_overview" rel="noopener ugc nofollow" target="_blank"> <em class="nb">架构概述</em> </a>部分。</p><p id="2466" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为该解决方案中使用的架构可以精简一点，解释如下:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nc"><img src="../Images/9b943319b92061725641229da4e960ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BefR7EOXF-FMbb7KXSks3A.png"/></div></div></figure><ol class=""><li id="1ecf" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">新文件登陆云存储，触发云功能<em class="nb">启动器</em></li><li id="134e" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><em class="nb"> Initiator </em>将文件分割成几个较小的部分，并将它们发布到 PubSub 主题<em class="nb">操作日志</em>。</li><li id="478d" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">完成(2)后，<em class="nb">发起方</em>向<em class="nb">操作触发器</em>发布主题发送一条空消息</li><li id="2303" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><em class="nb">操作触发器</em>通过订阅<em class="nb">操作执行器</em>推送空消息</li><li id="9f01" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><em class="nb">操作执行器</em>执行并从<em class="nb">操作日志中提取信息开始。</em> <strong class="jp ir">如果<em class="nb">操作日志</em>中没有消息，则不执行任何操作。循环到此结束。</strong></li><li id="fcb9" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">如果从<em class="nb">操作日志</em>中检索到消息，<em class="nb">操作执行器</em>会尝试将其推送到 Google Ads。</li><li id="5934" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">如果上一步(6)成功，<em class="nb">操作执行器</em>确认之前从<em class="nb">操作日志</em>拉取的消息，并向<em class="nb">操作触发器</em>发布空消息<em class="nb">。<strong class="jp ir">从 4 继续。</strong></em></li></ol><h2 id="b6a5" class="mp km iq bd kn mq mr dn kr ms mt dp kv jy mu mv kz kc mw mx ld kg my mz lh na bi translated">这种方法的问题</h2><p id="e701" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我认为这种方法有几个问题:</p><ul class=""><li id="b530" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk nd lv lw lx bi translated">如果<em class="nb">操作执行器</em>出错或失败，整个循环可能会中断。如果错误是由 Google Ads API 端错误引起的，您需要在代码中捕捉到这一点，并向<em class="nb">操作触发器</em>发送一条空消息以继续循环。这并不符合快速失效的原则(下面会有更多的介绍),而且开发起来更加困难。</li><li id="21c9" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nd lv lw lx bi translated">如果当操作日志中只剩下一(1)条消息时发生上述错误，则该消息不可从<em class="nb">操作日志</em>中提取，直到确认截止日期过去。随后执行的<em class="nb">操作执行器</em>会认为没有更多的消息，并结束循环。</li><li id="02fb" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nd lv lw lx bi translated">为了遵守 Google Ads API 的限制 2(并发请求)，在<em class="nb">操作触发器</em>和<em class="nb">操作执行器</em>之间只能有一条消息流动。当第二个段文件到达云存储时，这将被违反。</li><li id="e0e2" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nd lv lw lx bi translated">我相信调试和理解架构是复杂的。</li></ul><p id="a07c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们没有输出 API (Google Ads)的限制，这个解决方案会更好。</p><p id="f2bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这种方法不经过深思熟虑是不可行的，所以我决定寻找替代方法。</p><h1 id="76f0" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">云任务简介</h1><p id="e434" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">云任务是一个分布式任务队列。您可以定义一个或多个可以向其发送任务的队列。队列就像它们听起来的那样。任务是要做的事情，通常定义为“运行这个 HTTP-请求，等待直到你得到一个 200/OK-响应代码”，如果没有，在 X 时间内再试一次。</p><p id="d57b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在一个队列级别上，你有以下(和更多)</strong> <a class="ae lo" href="https://cloud.google.com/tasks/docs/configuring-queues#routing" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">设置</strong> </a> <strong class="jp ir"> : </strong></p><ul class=""><li id="304e" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk nd lv lw lx bi translated">每秒最大分派数:这个队列处理新任务的速度有多快？</li><li id="beb3" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nd lv lw lx bi translated"><em class="nb">最大并发调度:</em>可以同时运行/执行多少个任务？</li><li id="dacc" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nd lv lw lx bi translated"><em class="nb">最大尝试次数:</em>一个任务在进入“失败”状态之前可以尝试多少次？</li></ul><p id="7b64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在一个任务级别上你有以下(和更多)</strong> <a class="ae lo" href="https://cloud.google.com/tasks/docs/creating-http-target-tasks" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">设置</strong> </a> <strong class="jp ir"> : </strong></p><ul class=""><li id="948d" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk nd lv lw lx bi translated">任务类型:在本文中，我们将只讨论 HTTP 目标类型。</li><li id="8849" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nd lv lw lx bi translated"><em class="nb">HTTP Task HTTP Method</em>:HTTP 方法(GET/POST)</li><li id="e78f" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nd lv lw lx bi translated"><em class="nb"> HTTP 任务请求体</em>:HTTP 请求体。最大 100kb。</li></ul><p id="2deb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，云任务不是一个消息队列(像 PubSub)，它只是感兴趣的任务定义，并支持最大 100kb 的请求体来描述在哪里可以找到任何最终数据。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ne"><img src="../Images/c5ee70454381085de77b7fd3b2102bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itDLLIb9xPfFFad1A3rSqg.jpeg"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">现实生活中的排队。图片来源:https://unsplash.com/photos/Xbh_OGLRfUM 亚历山大·波波夫<a class="ae lo" href="https://unsplash.com/photos/Xbh_OGLRfUM" rel="noopener ugc nofollow" target="_blank"/></p></figure><h1 id="4564" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">云任务的完整解决方案</h1><p id="a651" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">为了将云任务与我们的部分解决方案集成，我们可以将到达云存储的大传输段文件分解成多个位，并为每个位创建一个任务。我们会将所有这些任务发送到一个任务队列，我们已经将<em class="nb"> Max concurrent dispatches </em>设置为一(1)，以避免溢出 Google Ads API。</p><p id="1b01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于云任务不执行任务(它们只调用 HTTP-endpoint 并等待 200/OK 代码返回)，我们将实际的 Google Ads API 调用放在云函数中。</p><h2 id="980a" class="mp km iq bd kn mq mr dn kr ms mt dp kv jy mu mv kz kc mw mx ld kg my mz lh na bi translated">架构概述</h2><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nj"><img src="../Images/482618b1cc95ff3f387a9d1417e3f204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ksF0toIqJQ5RDPb6miE_lg.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">利用云任务将一个大请求分解成多个小请求的架构图。</p></figure><ol class=""><li id="3001" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">BigQuery 将结果输出文件写入 GCS。</li><li id="328d" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">完成写入 GCS 后，云功能<em class="nb">任务创建器</em>从 GCS 触发。</li><li id="afe6" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><em class="nb">任务创建者</em><em class="nb">任务创建者</em>从 GCS 中的触发文件的文件名中获取目标 API 和其他属性，并将其与任务主体中的部分文件的路径一起发送。</li><li id="24ac" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><em class="nb">段队列</em>中的任务被逐一处理，每个调用云函数<em class="nb">任务处理程序</em>。</li><li id="d663" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">对于<em class="nb">任务处理程序</em> <strong class="jp ir"> <em class="nb"> </em> </strong>的每次调用，它都会解码任务主体并检索 GCS 中部分文件的路径以及 API 配置。然后，它将部分文件推送到 Google Ads，并在完成后向云任务返回 200/OK 响应代码。</li></ol><h2 id="1a8d" class="mp km iq bd kn mq mr dn kr ms mt dp kv jy mu mv kz kc mw mx ld kg my mz lh na bi translated">这个架构给了我们什么？</h2><p id="5c5e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">云任务充当我们的输入和输出之间的缓冲，确保输出符合 API 的速率限制。</p><p id="866d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它还通过提供重试层来帮助我们提高开发速度，使我们能够编写集成代码，而<a class="ae lo" href="https://en.wikipedia.org/wiki/Fail-fast" rel="noopener ugc nofollow" target="_blank">很快就会失败。</a>如果<em class="nb">任务处理器</em>函数失败，就让它失败，默认发送一个 http-error-code 给云任务。云任务将在适当的时候重试该任务。只要错误是在谷歌广告方面，任务最终将成功执行。</p><h2 id="69b1" class="mp km iq bd kn mq mr dn kr ms mt dp kv jy mu mv kz kc mw mx ld kg my mz lh na bi translated">向外扩展</h2><p id="6eaa" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">它也很容易向外扩展，以支持谷歌广告中更多的帐户(假设一个广告商活跃在几个国家),我们只需要在云任务中创建额外的队列。我们向<em class="nb">任务创建器</em>添加了一些代码，以便它可以动态选择任务队列，还向<em class="nb">任务处理器</em>添加了一些代码，以便它可以动态获取 API 凭证/配置。除此之外，可以使用完全相同的功能。</p><h1 id="4ba5" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">最后的话</h1><p id="ced0" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">这个用例显然不是打算由 PubSub 解决的，我很高兴它不是，因为它教会了我很多关于 PubSub 的局限性。</p><p id="9c80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">云任务显然是针对这一领域的问题，这是一个非常容易上手的服务。我强烈建议每个人都尝试一下，因为它可能是处理低性能 API 的最佳(无服务器)服务之一。</p><p id="0cd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我计划在这个集成挑战中结合云任务和 PubSub。我有一个他们如何合作的想法。</p><p id="68c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想进一步讨论这个问题，或者不同意我提出的任何观点，请随意发表评论。我是来学习的👨‍💻🤓</p></div></div>    
</body>
</html>