<html>
<head>
<title>Normalization vs Standardization, which one is better</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">规范化与标准化，哪个更好</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/normalization-vs-standardization-which-one-is-better-f29e043a57eb?source=collection_archive---------14-----------------------#2020-04-22">https://towardsdatascience.com/normalization-vs-standardization-which-one-is-better-f29e043a57eb?source=collection_archive---------14-----------------------#2020-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2497" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本教程中，让我们看看哪一个是最好的特征工程技术。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9292438440b2f5d5749ea27bc1e74256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*sS20G4rBJLNNwCzBs0g7gA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源于<a class="ae ku" href="https://github.com/Tanu-N-Prabhu/Python/blob/master/Normalization_vs_Standardization_which_one_is%C2%A0better.ipynb" rel="noopener ugc nofollow" target="_blank">作者</a>(塔努·南达·帕布)</p></figure><p id="7653" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">众所周知<strong class="kx iu">特征工程是一个将原始数据转换成数据集的问题</strong>。有各种各样的特征工程技术可用。两种最广泛使用且最容易混淆的特征工程技术是:</p><ul class=""><li id="1318" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><strong class="kx iu">正常化</strong></li><li id="c1c1" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx iu">标准化</strong></li></ul><p id="3bb1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">今天，在这个美好的白天或夜晚，我们将探索这两种技术，并了解数据分析师在解决数据科学问题时做出的一些常见假设。此外，本教程的全部代码可以在下面我的<a class="ae ku" href="https://github.com/Tanu-N-Prabhu/Python/blob/master/Normalization_vs_Standardization.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到</p><div class="mf mg gp gr mh mi"><a href="https://github.com/Tanu-N-Prabhu/Python/blob/master/Normalization_vs_Standardization.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd iu gy z fp mn fr fs mo fu fw is bi translated">塔努-北帕布/Python</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">permalink dissolve GitHub是4000多万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">github.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw ko mi"/></div></div></a></div></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="1b0b" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">正常化</h1><h2 id="4967" class="nw nf it bd ng nx ny dn nk nz oa dp no le ob oc nq li od oe ns lm of og nu oh bi translated">理论</h2><p id="8c73" class="pw-post-body-paragraph kv kw it kx b ky oi ju la lb oj jx ld le ok lg lh li ol lk ll lm om lo lp lq im bi translated">规范化是将数字特征转换为标准范围值的过程。值的范围可以是[-1，1]或[0，1]。例如，假设我们有一个数据集，包含两个名为“<strong class="kx iu">年龄</strong>和“<strong class="kx iu">体重</strong>的特征，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ca322ef3d3565fa10269fbbf5c463954.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*7wCRiAl1iftWn2_Uc7_I8Q.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源于<a class="ae ku" href="https://github.com/Tanu-N-Prabhu/Python/blob/master/Normalization_vs_Standardization_which_one_is%C2%A0better.ipynb" rel="noopener ugc nofollow" target="_blank">作者</a>(塔努·南达·帕布)</p></figure><p id="885a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设名为“<strong class="kx iu">年龄</strong>的特征的实际范围是<strong class="kx iu"> 5 </strong>到<strong class="kx iu"> 100。</strong>我们可以通过从“<strong class="kx iu">年龄</strong>”列的每个值中减去<strong class="kx iu"> 5 </strong>，然后将结果除以<strong class="kx iu">95</strong>(100–5)，从而将这些值归一化到<strong class="kx iu"> [0，1] </strong>的范围内。为了让你的大脑清楚，我们可以把上面的内容写成一个公式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/28b1bc69802cfae859ad24ab04c75648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*i0oJBKdU7QgTLjwRTAvhIA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片鸣谢<a class="ae ku" href="http://themlbook.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd op">安德烈·布尔科夫的百页机器学习书</strong> </a></p></figure><p id="66a0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">其中<strong class="kx iu"> min^(j) </strong>和<strong class="kx iu"> max^(j) </strong>是数据集中特征j的最小<strong class="kx iu">值和最大<strong class="kx iu">值。</strong></strong></p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="0a5f" class="nw nf it bd ng nx ny dn nk nz oa dp no le ob oc nq li od oe ns lm of og nu oh bi translated">履行</h2><p id="6888" class="pw-post-body-paragraph kv kw it kx b ky oi ju la lb oj jx ld le ok lg lh li ol lk ll lm om lo lp lq im bi translated">现在你知道了它背后的理论，让我们看看如何把它投入生产。通常有两种方法来实现它:<strong class="kx iu">传统的老式手工方法</strong>和另一种使用<code class="fe oq or os ot b"><strong class="kx iu">sklearn preprocessing</strong></code>库。今天我们就借助<code class="fe oq or os ot b">sklearn</code>库来进行归一化。</p><p id="4182" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">使用sklearn预处理-规格化器</strong></p><p id="e22c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在将“<strong class="kx iu">年龄</strong>”和“<strong class="kx iu">体重</strong>”值直接提供给该方法之前，我们需要将这些数据帧转换成一个<code class="fe oq or os ot b">numpy</code>数组。为此，我们可以使用如下所示的<code class="fe oq or os ot b">to_numpy()</code>方法:</p><pre class="kj kk kl km gt ou ot ov ow aw ox bi"><span id="d1c2" class="nw nf it ot b gy oy oz l pa pb"><strong class="ot iu"># Storing the columns Age values into X and Weight as Y</strong></span><span id="6786" class="nw nf it ot b gy pc oz l pa pb">X = df['Age']<br/>y = df['Weight']<br/>X = X.to_numpy()<br/>y = y.to_numpy()</span></pre><p id="4ed3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">上述步骤非常重要，因为<code class="fe oq or os ot b">fit()</code>和<code class="fe oq or os ot b">transform()</code>方法都只对数组有效。</p><pre class="kj kk kl km gt ou ot ov ow aw ox bi"><span id="9a5a" class="nw nf it ot b gy oy oz l pa pb">from <strong class="ot iu">sklearn.preprocessing</strong> import <strong class="ot iu">Normalizer</strong></span><span id="9295" class="nw nf it ot b gy pc oz l pa pb">normalizer = <strong class="ot iu">Normalizer</strong>().<strong class="ot iu">fit</strong>([X])<br/>normalizer.<strong class="ot iu">transform</strong>([X])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/aad8b8e41364d7e2fec1c86c59b3a1c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*n_CO9ucb0U5NNhfJ5wiE0A.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源于<a class="ae ku" href="https://github.com/Tanu-N-Prabhu/Python/blob/master/Normalization_vs_Standardization_which_one_is%C2%A0better.ipynb" rel="noopener ugc nofollow" target="_blank">作者</a>(塔努·南达·帕布)</p></figure><pre class="kj kk kl km gt ou ot ov ow aw ox bi"><span id="322c" class="nw nf it ot b gy oy oz l pa pb">normalizer = <strong class="ot iu">Normalizer</strong>().<strong class="ot iu">fit</strong>([y])<br/>normalizer.<strong class="ot iu">transform</strong>([y])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/890a29667e3fc6f44c1f494203344eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*KXay7y1tW4kaNEnjZZvGKg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源于<a class="ae ku" href="https://github.com/Tanu-N-Prabhu/Python/blob/master/Normalization_vs_Standardization_which_one_is%C2%A0better.ipynb" rel="noopener ugc nofollow" target="_blank">作者</a>(塔努·南达·帕布)</p></figure><p id="f3b5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如上所示，两个数组的值都在范围<strong class="kx iu">【0，1】</strong>内。关于该库的更多细节可以在下面找到:</p><div class="mf mg gp gr mh mi"><a href="https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-normalization" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd iu gy z fp mn fr fs mo fu fw is bi translated">6.3.预处理数据-sci kit-学习0.22.2文档</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">sklearn.preprocessing包提供了几个常用的实用函数和转换器类来改变raw…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">scikit-learn.org</p></div></div><div class="mr l"><div class="pf l mt mu mv mr mw ko mi"/></div></div></a></div></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="1071" class="nw nf it bd ng nx ny dn nk nz oa dp no le ob oc nq li od oe ns lm of og nu oh bi translated">我们应该在什么时候对数据进行规范化？</h2><p id="f8f0" class="pw-post-body-paragraph kv kw it kx b ky oi ju la lb oj jx ld le ok lg lh li ol lk ll lm om lo lp lq im bi translated">虽然规范化不是强制性或必需的(必须做的事情)。有两种方法可以帮助你</p><ul class=""><li id="61bb" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">标准化数据将<strong class="kx iu">提高学习速度</strong>。这将提高构建(训练)和测试数据的速度。试试看！！</li><li id="c52c" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">它将避免<strong class="kx iu">数字溢出</strong>。真正的意思是，标准化将确保我们的输入大致在一个相对较小的范围内。这将避免问题，因为计算机通常在处理非常小或非常大的数字时会有问题。</li></ul></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="52b1" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">标准化</h1><h2 id="d3a6" class="nw nf it bd ng nx ny dn nk nz oa dp no le ob oc nq li od oe ns lm of og nu oh bi translated">理论</h2><p id="1059" class="pw-post-body-paragraph kv kw it kx b ky oi ju la lb oj jx ld le ok lg lh li ol lk ll lm om lo lp lq im bi translated">标准化或<strong class="kx iu"> z值标准化</strong>或<strong class="kx iu">最小-最大缩放</strong>是一种重新调整数据集值的技术，使其具有标准正态分布的属性，其中<strong class="kx iu"> μ </strong> = 0(平均值-要素的平均值)和<strong class="kx iu"> σ = </strong> 1(平均值的标准偏差)。这可以写成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/f991b8f9b8ed78697bf0c057027caea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*JAmQxAfwtO9AM1xTzMIIXw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片鸣谢<a class="ae ku" href="http://themlbook.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd op">安德烈·布尔科夫的百页机器学习书</strong> </a></p></figure><h2 id="10b5" class="nw nf it bd ng nx ny dn nk nz oa dp no le ob oc nq li od oe ns lm of og nu oh bi translated">履行</h2><p id="fc73" class="pw-post-body-paragraph kv kw it kx b ky oi ju la lb oj jx ld le ok lg lh li ol lk ll lm om lo lp lq im bi translated">现在实现标准化的方法很多，就像规范化一样，我们可以使用<code class="fe oq or os ot b">sklearn</code>库，使用<code class="fe oq or os ot b">StandardScalar</code>方法，如下所示:</p><pre class="kj kk kl km gt ou ot ov ow aw ox bi"><span id="f262" class="nw nf it ot b gy oy oz l pa pb">from <strong class="ot iu">sklearn.preprocessing</strong> import <strong class="ot iu">StandardScaler</strong></span><span id="2cd3" class="nw nf it ot b gy pc oz l pa pb">sc = <strong class="ot iu">StandardScaler</strong>()<br/>sc.<strong class="ot iu">fit_transform</strong>([X])<br/>sc.<strong class="ot iu">transform</strong>([X])</span><span id="2beb" class="nw nf it ot b gy pc oz l pa pb">sc.<strong class="ot iu">fit_transform</strong>([y])<br/>sc.<strong class="ot iu">transform</strong>([y])</span></pre><p id="f07d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你可以从下面阅读更多关于图书馆的信息:</p><div class="mf mg gp gr mh mi"><a href="https://scikit-learn.org/stable/modules/preprocessing.html#standardization-or-mean-removal-and-variance-scaling" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd iu gy z fp mn fr fs mo fu fw is bi translated">6.3.预处理数据-sci kit-学习0.22.2文档</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">sklearn.preprocessing包提供了几个常用的实用函数和转换器类来改变raw…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">scikit-learn.org</p></div></div><div class="mr l"><div class="ph l mt mu mv mr mw ko mi"/></div></div></a></div></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="6240" class="nw nf it bd ng nx ny dn nk nz oa dp no le ob oc nq li od oe ns lm of og nu oh bi translated">z分数标准化</h2><p id="bdaf" class="pw-post-body-paragraph kv kw it kx b ky oi ju la lb oj jx ld le ok lg lh li ol lk ll lm om lo lp lq im bi translated">同样，我们可以用熊猫<code class="fe oq or os ot b">mean</code>和<code class="fe oq or os ot b">std</code>来做必要的事情</p><pre class="kj kk kl km gt ou ot ov ow aw ox bi"><span id="e8d9" class="nw nf it ot b gy oy oz l pa pb"><strong class="ot iu"># Calculating the mean and standard deviation</strong></span><span id="d139" class="nw nf it ot b gy pc oz l pa pb">df = (df - df.<strong class="ot iu">mean</strong>())/df.<strong class="ot iu">std</strong>()<br/>print(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/d4a57d87f9f639e215a1e75f5db6ee29.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*E4xQiFzvvaZ4Xpzlf6eW6w.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源于<a class="ae ku" href="https://github.com/Tanu-N-Prabhu/Python/blob/master/Normalization_vs_Standardization_which_one_is%C2%A0better.ipynb" rel="noopener ugc nofollow" target="_blank">作者</a>(塔努·南达·帕布)</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="f803" class="nw nf it bd ng nx ny dn nk nz oa dp no le ob oc nq li od oe ns lm of og nu oh bi translated"><strong class="ak">最小-最大缩放比例</strong></h2><p id="e08a" class="pw-post-body-paragraph kv kw it kx b ky oi ju la lb oj jx ld le ok lg lh li ol lk ll lm om lo lp lq im bi translated">在这里，我们可以用熊猫<code class="fe oq or os ot b">min</code>和<code class="fe oq or os ot b">max</code>来做必要的事情</p><pre class="kj kk kl km gt ou ot ov ow aw ox bi"><span id="5f9a" class="nw nf it ot b gy oy oz l pa pb"><strong class="ot iu"># Calculating the minimum and the maximum </strong></span><span id="6846" class="nw nf it ot b gy pc oz l pa pb">df = (df-df.<strong class="ot iu">min</strong>())/(df.<strong class="ot iu">max</strong>()-df.<strong class="ot iu">min</strong>())<br/>print(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/da78b7de72587359dfcd9edd15dd7af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/1*ayvqQm_UOI6LnsBRmDAR1A.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源于<a class="ae ku" href="https://github.com/Tanu-N-Prabhu/Python/blob/master/Normalization_vs_Standardization_which_one_is%C2%A0better.ipynb" rel="noopener ugc nofollow" target="_blank">作者</a>(塔努·南达·帕布)</p></figure><p id="6458" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通常，<strong class="kx iu"> Z分数归一化</strong>是首选，因为<strong class="kx iu">最小-最大缩放</strong>容易导致<strong class="kx iu">过拟合</strong>。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="84a6" class="nw nf it bd ng nx ny dn nk nz oa dp no le ob oc nq li od oe ns lm of og nu oh bi translated">什么时候实际使用标准化和规范化？</h2><p id="f89c" class="pw-post-body-paragraph kv kw it kx b ky oi ju la lb oj jx ld le ok lg lh li ol lk ll lm om lo lp lq im bi translated">以上问题没有一个答案。如果你有一个<strong class="kx iu">小数据集</strong>并且<strong class="kx iu">有足够的时间</strong>，那么你可以尝试上述两种技术并选择最好的一种。以下是你可以遵循的经验法则:</p><ul class=""><li id="648d" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">你可以在<strong class="kx iu">无监督学习算法</strong>上使用<strong class="kx iu">标准化</strong>。在这种情况下，标准化<strong class="kx iu">比规范化</strong>更有利。</li><li id="3167" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">如果你在数据中看到一个<strong class="kx iu">钟形曲线</strong>，那么<strong class="kx iu">标准化</strong>更可取。为此，您必须绘制您的数据。</li><li id="cc20" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">如果你的数据集有<strong class="kx iu">极高的</strong>或<strong class="kx iu">低值</strong> ( <strong class="kx iu">异常值</strong>)，那么<strong class="kx iu">标准化</strong>更可取，因为通常情况下，标准化会<strong class="kx iu">将</strong>这些值压缩到一个<strong class="kx iu">小范围</strong>。</li></ul><p id="154d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在除了上述情况之外的任何其他情况下，一个人的<strong class="kx iu">规范化</strong>保持良好。如果你有足够的时间，再次尝试这两种特征工程技术。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="7cfe" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">好了，你们已经到了教程的结尾。我希望你们今天学到了一些东西。我使用了名为<strong class="kx iu"/><a class="ae ku" href="http://themlbook.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kx iu">的<a class="ae ku" href="http://themlbook.com/" rel="noopener ugc nofollow" target="_blank">教材</a>作为参考(第5章)来编写本教程。你可以看一下。如果你们对本教程有任何疑问，可以在下面的评论栏里找到。我会尽量尽快回答。在那之前注意安全，再见。下次见。欲了解更多关于<a class="ae ku" href="http://www.datafied.world/explore" rel="noopener ugc nofollow" target="_blank">的更新，请使用</a>来读写更多的python笔记本。</strong></a></p><div class="mf mg gp gr mh mi"><a href="http://www.datafied.world/" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd iu gy z fp mn fr fs mo fu fw is bi translated">数据化</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">创建作品集*上传Jupyter笔记本*用您的数据讲述故事*创建免费作品集探索笔记本…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">www . data fed . world</p></div></div><div class="mr l"><div class="pk l mt mu mv mr mw ko mi"/></div></div></a></div></div></div>    
</body>
</html>