<html>
<head>
<title>Intro to R: Linear Algebra</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R 简介:线性代数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intro-to-r-linear-algebra-2a4de2506c93?source=collection_archive---------8-----------------------#2020-03-14">https://towardsdatascience.com/intro-to-r-linear-algebra-2a4de2506c93?source=collection_archive---------8-----------------------#2020-03-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/02bd809cdcbde05e47f010e58f9620e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJw6-TqwbY_LapF121AksQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="19a8" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">向量索引，特征向量求解器，奇异值分解，等等</h2></div><p id="ff63" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">r 是一种特别为数据分析、数据可视化和机器学习开发的非常强大的语言，这使得它成为任何有抱负的数据科学家的必学之作。</p><p id="6141" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">r 对线性代数尤其得心应手。它的内置数据类型(如向量和矩阵)与内置函数(如特征值和行列式解算器)和动态索引功能配合得很好。</p><p id="c1bf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这篇介绍 R 的文章将涵盖 R 中的以下线性代数主题实现:</p><h2 id="46ad" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">向量</h2><ul class=""><li id="b15d" class="mi mj je kv b kw mk kz ml lc mm lg mn lk mo lo mp mq mr ms bi translated">向量分配</li><li id="f847" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">向量运算</li><li id="1d11" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">生成序列</li><li id="d302" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">逻辑向量</li><li id="6543" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">缺少值</li><li id="9a31" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">索引向量</li></ul><h2 id="bbec" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">阵列和矩阵</h2><ul class=""><li id="c364" class="mi mj je kv b kw mk kz ml lc mm lg mn lk mo lo mp mq mr ms bi translated">数组</li><li id="ceb0" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">数组索引</li><li id="6469" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">矩阵索引</li><li id="ef63" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">2 个数组的外积</li><li id="387e" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">演示:2x2 个位数矩阵的所有可能的行列式</li><li id="17f0" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">数组的广义转置</li><li id="43fd" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">矩阵乘法</li><li id="8415" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">特征值和特征向量</li><li id="b4d8" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">奇异值分解和行列式</li><li id="38a9" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">最小二乘拟合和 QR 分解</li><li id="3422" class="mi mj je kv b kw mt kz mu lc mv lg mw lk mx lo mp mq mr ms bi translated">形成分块矩阵</li></ul></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="5698" class="nf lq je bd lr ng nh ni lu nj nk nl lx kk nm kl ma kn nn ko md kq no kr mg np bi translated">向量</h1><h2 id="fd48" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">向量分配</h2><p id="55a8" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">r 操作数据结构，其中最简单的是数字向量。向量是有序的数字集合。要创建一个包含四个元素<code class="fe nt nu nv nw b">1</code>、<code class="fe nt nu nv nw b">2</code>、<code class="fe nt nu nv nw b">3</code>和<code class="fe nt nu nv nw b">4</code>的向量<code class="fe nt nu nv nw b">x</code>，可以使用连接函数<code class="fe nt nu nv nw b">c()</code>。</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="a2ff" class="lp lq je nw b gy of og l oh oi">x &lt;- c(1, 2, 3, 4)</span></pre><p id="f945" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">赋值操作符<code class="fe nt nu nv nw b">&lt;-</code>用在这个场景中，指向被赋值的对象。在大多数情况下，<code class="fe nt nu nv nw b">&lt;-</code>可以与<code class="fe nt nu nv nw b">=</code>切换。</p><p id="91fe" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">也可以使用功能<code class="fe nt nu nv nw b">assign()</code>:</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="409f" class="lp lq je nw b gy of og l oh oi">assign('x', c(1, 2, 3, 4))</span></pre><p id="5484" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">运算符</p><p id="546d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">也可以从另一个方向进行分配:</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="d31f" class="lp lq je nw b gy of og l oh oi">c(1, 2, 3, 4) -&gt; x</span></pre><h2 id="22c2" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">向量运算</h2><p id="9dec" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">向量也可以有多种用途。</p><p id="464f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">操作<code class="fe nt nu nv nw b"> y &lt;- c(x, 0, x)</code>会将向量<code class="fe nt nu nv nw b">1, 2, 3, 4, 0, 1, 2, 3, 4 </code>分配给变量<code class="fe nt nu nv nw b">y</code>。</p><p id="a0c1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">向量可以与常数自由相乘和相加:</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="3e11" class="lp lq je nw b gy of og l oh oi">v &lt;- 2*x + y + 1</span></pre><p id="c6a9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">注意，即使<code class="fe nt nu nv nw b">x</code>和<code class="fe nt nu nv nw b">y</code>长度不同时，该操作也有效。在这种情况下，R 将简单地循环使用 x(有时是分数),直到它满足 y 的长度。由于 y 是 9 个数字长，x 是 4 个单位长，x 将重复 2.25 次以匹配 y 的长度。</p><p id="f98b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">算术运算符<code class="fe nt nu nv nw b">+</code>、<code class="fe nt nu nv nw b">-</code>、<code class="fe nt nu nv nw b">*</code>、<code class="fe nt nu nv nw b">/</code>、<code class="fe nt nu nv nw b">^</code>都可以使用。<code class="fe nt nu nv nw b">log</code>、<code class="fe nt nu nv nw b">exp</code>、<code class="fe nt nu nv nw b">sin</code>、<code class="fe nt nu nv nw b">cos</code>、<code class="fe nt nu nv nw b">tan</code>、<code class="fe nt nu nv nw b">sqrt</code>等等也可以。<code class="fe nt nu nv nw b">max(x)</code>和<code class="fe nt nu nv nw b">min(x)</code>代表一个向量<code class="fe nt nu nv nw b">x</code>的最大和最小元素，<code class="fe nt nu nv nw b">length(x)</code>是<code class="fe nt nu nv nw b">x</code>中元素的个数。<code class="fe nt nu nv nw b">sum(x)</code>给出<code class="fe nt nu nv nw b">x</code>中元素的总和，而<code class="fe nt nu nv nw b">prod(x)</code>给出它们的乘积。</p><p id="84f2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">mean(x)</code>计算样本均值，<code class="fe nt nu nv nw b">var(x)</code>返回样本方差。<code class="fe nt nu nv nw b">sort(x)</code>返回一个向量，其大小与 x 相同，元素按升序排列。</p><h2 id="a35a" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">生成序列</h2><p id="91da" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">r 有很多生成数列的方法。<code class="fe nt nu nv nw b">1:30</code>与<code class="fe nt nu nv nw b">c(1, 2, …, 29, 30)</code>相同。冒号作为表达式中的最高优先级，所以<code class="fe nt nu nv nw b">2*1:15</code>将返回<code class="fe nt nu nv nw b">c(2, 4, …, 28, 30)</code>而不是<code class="fe nt nu nv nw b">c(2, 3, …, 14, 15)</code>。</p><p id="4cc3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">30∶1 可以用于反向生成序列。</p><p id="d279" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">seq()</code>功能也可用于生成序列。<code class="fe nt nu nv nw b">seq(2,10) </code>返回与<code class="fe nt nu nv nw b">2:10</code>相同的向量。在<code class="fe nt nu nv nw b">seq()</code>中，用户还可以指定要执行的步长:<code class="fe nt nu nv nw b">seq(1,2,by=0.5)</code>返回<code class="fe nt nu nv nw b">c(1, 1.5, 2)</code>。</p><p id="df62" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">类似的功能还有<code class="fe nt nu nv nw b">rep()</code>，用各种方式复制一个对象。比如<code class="fe nt nu nv nw b">rep(x, times=5)</code>会端到端返回<code class="fe nt nu nv nw b">x</code>的五个副本。</p><h2 id="ea3d" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">逻辑向量</h2><p id="0641" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">R 中的逻辑值有 TRUE、FALSE 和 NA。逻辑向量是由条件设定的。<code class="fe nt nu nv nw b">val &lt;- x &gt; 13</code>将<code class="fe nt nu nv nw b">val</code>设置为与<code class="fe nt nu nv nw b">x</code>长度相同的向量，条件满足时取值<code class="fe nt nu nv nw b">TRUE</code>，条件不满足时取值<code class="fe nt nu nv nw b">FALSE</code>。</p><p id="3831" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">r 中的逻辑运算符有<code class="fe nt nu nv nw b">&lt;</code>、<code class="fe nt nu nv nw b">&lt;=</code>、<code class="fe nt nu nv nw b">&gt;</code>、<code class="fe nt nu nv nw b">&gt;=</code>、<code class="fe nt nu nv nw b">==</code>、<code class="fe nt nu nv nw b">!=</code>，分别表示小于、小于或等于、大于、大于或等于、等于、不等于。</p><h2 id="0d16" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">缺少值</h2><p id="666b" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">如果<code class="fe nt nu nv nw b">x</code>的对应元素是<code class="fe nt nu nv nw b">NA</code>，函数<code class="fe nt nu nv nw b">is.na(x)</code>返回一个与<code class="fe nt nu nv nw b">x</code>大小相同的逻辑向量。</p><p id="aea5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">x == NA</code>与<code class="fe nt nu nv nw b">is.na(x)</code>不同，因为<code class="fe nt nu nv nw b">NA</code>不是数值，而是不可用数量的标记。</p><p id="8995" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">第二种“缺失值”是由数值计算产生的，如<code class="fe nt nu nv nw b">0/0</code>。在这种情况下，<code class="fe nt nu nv nw b">NaN</code>(非数字)值被视为<code class="fe nt nu nv nw b">NA</code>值；也就是说，<code class="fe nt nu nv nw b">is.na(x)</code>将为<code class="fe nt nu nv nw b">NA</code>和<code class="fe nt nu nv nw b">NaN</code>值返回<code class="fe nt nu nv nw b">TRUE</code>。<code class="fe nt nu nv nw b">is.nan(x)</code>只能用于识别<code class="fe nt nu nv nw b">NaN</code>值。</p><h2 id="6d7a" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">索引向量</h2><p id="819e" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">第一种索引是通过逻辑向量。<code class="fe nt nu nv nw b">y &lt;- x[!is.na(x)]</code>将<code class="fe nt nu nv nw b">y</code>设置为不等于<code class="fe nt nu nv nw b">NA</code>或<code class="fe nt nu nv nw b">NaN</code>的<code class="fe nt nu nv nw b">x</code>值。</p><p id="871e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">(x+1)[(!is.na(x)) &amp; x&gt;0] -&gt; z</code>将<code class="fe nt nu nv nw b">z</code>设置为<code class="fe nt nu nv nw b">x+1</code>中非<code class="fe nt nu nv nw b">Na</code>或<code class="fe nt nu nv nw b">NaN</code>且大于 0 的值。</p><p id="ecd9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">第二种方法是用一个正整数量的矢量。在这种情况下，这些值必须在设置<code class="fe nt nu nv nw b">{1, 2, …, length(x)}</code>中。向量的相应元素被选择并以该顺序连接以形成结果。重要的是要记住，与其他语言不同，R 中的第一个索引是 1，而不是 0。</p><p id="63fb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">x[1:10]</code>返回<code class="fe nt nu nv nw b">x</code>的前 10 个元素，假设<code class="fe nt nu nv nw b">length(x)</code>不小于 10。<code class="fe nt nu nv nw b">c(‘x’, ‘y’)[rep(c(1,2,2,1), times=4)]</code>产生长度为 16 的字符向量，其中<code class="fe nt nu nv nw b">‘x’, ‘y’, ‘y’, ‘x’</code>重复四次。</p><p id="6ba5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">负整数向量指定要排除而不是包含的值。<code class="fe nt nu nv nw b">y &lt;- x[-(1:5)]</code>将<code class="fe nt nu nv nw b">y</code>设置为除了<code class="fe nt nu nv nw b">x</code>的前五个值之外的所有值。</p><p id="2acb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最后，当对象具有 names 属性来标识其组件时，可以使用字符串向量。有了水果<code class="fe nt nu nv nw b">&lt;- c(1, 2, 3, 4)</code>，可以用<code class="fe nt nu nv nw b">names(fruit) &lt;- c(‘mango’, ‘apple’, ‘banana’, ‘orange’)</code>设置矢量水果的各个指标的名称。然后，可以用<code class="fe nt nu nv nw b">lunch &lt;- fruit[c(‘apple’, ‘orange’)]</code>按名称调用元素。</p><p id="7f3a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这样做的好处是字母数字名称有时比索引更容易记忆。</p><p id="fdc8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">请注意，索引表达式也可以出现在赋值的接收端，其中只对向量的那些元素执行赋值。例如，<code class="fe nt nu nv nw b">x[is.na(x)] &lt;- 0</code>用值<code class="fe nt nu nv nw b">0</code>替换向量<code class="fe nt nu nv nw b">x</code>中的所有<code class="fe nt nu nv nw b">NA</code>和<code class="fe nt nu nv nw b">NaN</code>值。</p><p id="2bac" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">再比如:<code class="fe nt nu nv nw b">y[y&lt;0] &lt;- -y[y&lt;0]</code>和<code class="fe nt nu nv nw b">y &lt;- abs(y)</code>作用相同。代码只是用小于 0 的值的负值替换所有小于 0 的值。</p><h1 id="0006" class="nf lq je bd lr ng oj ni lu nj ok nl lx kk ol kl ma kn om ko md kq on kr mg np bi translated">阵列和矩阵</h1><h2 id="53d0" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">数组</h2><p id="06d9" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">数组是数据条目的下标集合，不一定是数字。</p><p id="e0c1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">维度向量是非负整数的向量。如果长度是<em class="oo"> k </em>那么数组就是<em class="oo"> k </em>维的。尺寸从 1 到尺寸向量中给定的值进行索引。</p><p id="4995" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">向量可以被 R 作为数组使用，作为它的<code class="fe nt nu nv nw b">dim </code>属性。如果<code class="fe nt nu nv nw b">z</code>是一个 1500 个元素的向量，赋值<code class="fe nt nu nv nw b">dim(z) &lt;- c(100, 5, 3)</code>将意味着<code class="fe nt nu nv nw b">z</code>现在被视为一个 100 乘 5 乘 3 的数组。</p><h2 id="200b" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">数组索引</h2><p id="526e" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">数组的单个元素可以通过给定数组名，后跟方括号中的下标来引用，下标由列分隔。</p><p id="6277" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一个 3 乘 4 乘 6 的向量<code class="fe nt nu nv nw b">a</code>可以通过<code class="fe nt nu nv nw b">a[1, 1, 1]</code>调用它的第一个值，通过<code class="fe nt nu nv nw b">a[3, 4, 6]</code>调用它的最后一个值。</p><p id="4bd7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">a[,,]</code>代表整个数组；因此，<code class="fe nt nu nv nw b">a[1,1,]</code>在<code class="fe nt nu nv nw b">a</code>中取第一个二维横截面的第一行。</p><h2 id="f036" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">索引矩阵</h2><p id="0837" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">下面的代码生成一个 4 乘 5 的数组:<code class="fe nt nu nv nw b">x &lt;- array(1:20, dim = c(4,5))</code>。</p><p id="eb03" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">数组由值的向量和矩阵的维数指定。首先从上到下计算值，然后从左到右计算值。</p><p id="e8c7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">array(1:4, dim = c(2,2))</code>会回来</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="d675" class="lp lq je nw b gy of og l oh oi">1 3<br/>2 4</span></pre><p id="092c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">而不是</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="2c0e" class="lp lq je nw b gy of og l oh oi">1 2<br/>3 4</span></pre><p id="ff08" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">索引矩阵中不允许负索引。<code class="fe nt nu nv nw b">NA</code>和零值是允许的。</p><h2 id="491b" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">2 个数组的外积</h2><p id="e19b" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">对数组的一个重要操作是外积。如果<code class="fe nt nu nv nw b">a</code>和<code class="fe nt nu nv nw b">b</code>是两个数值数组，那么它们的外积就是一个数组，其维数向量是由两个维数向量串联而成，其数据向量是由<code class="fe nt nu nv nw b">a</code>的数据向量与<code class="fe nt nu nv nw b">b</code>的数据向量的元素的所有可能乘积而成。用运算符<code class="fe nt nu nv nw b">%o%</code>计算外积:</p><p id="c237" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">ab &lt;- a %o% b</code></p><p id="553f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">实现这一点的另一种方法是</p><p id="0100" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">ab &lt;- outer(a, b, ‘*’)</code></p><p id="2944" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">事实上，任何函数都可以使用 outer()函数应用于两个数组。假设我们定义了一个函数<code class="fe nt nu nv nw b">f &lt;- function(x, y) cos(y)/(1+x²)</code>。该函数可以通过<code class="fe nt nu nv nw b">z &lt;- outer(x, y, f)</code>应用于两个向量<code class="fe nt nu nv nw b">x</code>和<code class="fe nt nu nv nw b">y</code>。</p><h2 id="bd24" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">演示:2x2 个位数矩阵的所有可能的行列式</h2><p id="1c0b" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">考虑 2 乘 2 矩阵的行列式[a，b；c，d]其中每个条目是从 0 到 9 的非负整数。问题是找到这种形式的所有可能矩阵的行列式，并用高密度图表示该值出现的频率。</p><p id="7d2e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">换句话说，如果每个数字都是独立均匀随机选取的，求行列式的概率分布。</p><p id="2b30" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一个聪明的方法是使用 outer(0 函数两次。</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="7e46" class="lp lq je nw b gy of og l oh oi">d &lt;- outer(0:9,0:9)<br/>fr &lt;- table(outer(d, d, ‘-’))<br/>plot(fr, xlab = ‘Determinant’, ylab = ‘Frequency’)</span></pre><p id="9643" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">第一行将 d 赋给这个矩阵:</p><figure class="nx ny nz oa gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/70c0c8ef5905da7247839b0f31321457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iz6ycXHGRjenRrX0eKD2bw.png"/></div></div></figure><p id="a7cb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">第二行再次使用 outer()函数计算所有可能的行列式，最后一行绘制了它。</p><figure class="nx ny nz oa gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/bd3b38ef60221c152429f6956dea648f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pTVW-vjiL4MXZzVPeAz3YA.png"/></div></div></figure><h2 id="84bd" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">数组的广义转置</h2><p id="87f0" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">函数<code class="fe nt nu nv nw b">aperm(a, perm)</code>可以用来排列数组 a，参数 perm 必须是整数{1，…，<em class="oo"> k </em>的排列，其中<em class="oo"> k </em>是<em class="oo"> a </em>中下标的个数。该函数的结果是一个与 a 大小相同的数组，但是由<code class="fe nt nu nv nw b">perm[j]</code>给出的旧维度变成了新的<code class="fe nt nu nv nw b">j-th</code>维度。</p><p id="ac03" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一个简单的思考方法是矩阵转置的推广。如果<code class="fe nt nu nv nw b">A</code>是一个矩阵，那么<code class="fe nt nu nv nw b">B</code>就是<code class="fe nt nu nv nw b">A</code>的转置:</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="695c" class="lp lq je nw b gy of og l oh oi">B &lt;- aperm(A, c(2, 1))</span></pre><p id="742f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这些特殊情况下，功能<code class="fe nt nu nv nw b">t()</code>执行换位。</p><h2 id="a801" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">矩阵乘法</h2><p id="1e58" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">运算符%*%用于矩阵乘法。如果<code class="fe nt nu nv nw b">A</code>和<code class="fe nt nu nv nw b">B</code>是相同大小的方阵，<code class="fe nt nu nv nw b">A*B</code>是两个矩阵的元素乘积。<code class="fe nt nu nv nw b">A %*% B</code>是点积(矩阵积)。</p><p id="45cd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果 x 是一个向量，那么<code class="fe nt nu nv nw b">x %*% A %*% x</code>就是一个二次型。</p><p id="dc4e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">crossprod()</code>执行叉积；因此，<code class="fe nt nu nv nw b">crossprod(X, y)</code>与操作<code class="fe nt nu nv nw b">t(X) %*% y</code>相同，但效率更高。</p><p id="991c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">diag(v)</code>，其中<code class="fe nt nu nv nw b">v</code>是一个向量，给出一个对角矩阵，向量的元素作为对角元素。<code class="fe nt nu nv nw b">diag(M)</code>，其中<code class="fe nt nu nv nw b">m</code>是一个矩阵，给出<code class="fe nt nu nv nw b">M</code>的主对角线元素的向量(与 Matlab 中的约定相同)。<code class="fe nt nu nv nw b">diag(k)</code>，其中<code class="fe nt nu nv nw b">k</code>为单个数值，通过<code class="fe nt nu nv nw b">k</code>单位矩阵返回一个<code class="fe nt nu nv nw b">k</code>。</p><h2 id="285b" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">线性方程和反演</h2><p id="9bb2" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">解线性方程组是矩阵乘法的逆运算。当...的时候</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="c3a3" class="lp lq je nw b gy of og l oh oi">b &lt;- A %*% x</span></pre><p id="534e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在只给定<code class="fe nt nu nv nw b">A</code>和<code class="fe nt nu nv nw b">b</code>的情况下，向量<code class="fe nt nu nv nw b">x</code>就是线性方程组的解。这可以用 R 快速解决</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="017c" class="lp lq je nw b gy of og l oh oi">solve(A, b)</span></pre><h2 id="77bc" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">特征值和特征向量</h2><p id="a15b" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">函数<code class="fe nt nu nv nw b">eigen(Sm)</code>计算对称矩阵 Sm 的特征值和特征向量。结果是一个列表，第一个元素名为 values，第二个元素名为 vectors。<code class="fe nt nu nv nw b">ev &lt;- eigen(Sm)</code>将该列表分配给<code class="fe nt nu nv nw b">ev</code>。</p><p id="159f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">ev$val</code>是<code class="fe nt nu nv nw b">Sm</code>特征值的向量，<code class="fe nt nu nv nw b">ev$vec</code>是对应特征向量的矩阵。</p><p id="33e0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">对于大型矩阵，如果使用表达式不需要计算特征向量，最好避免计算它们</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="e722" class="lp lq je nw b gy of og l oh oi">evals &lt;- eigen(Sm, only.values = TRUE)$values</span></pre><h2 id="7ab5" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">奇异值分解和行列式</h2><p id="9784" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">函数<code class="fe nt nu nv nw b">svd(m)</code>采用任意矩阵参数<code class="fe nt nu nv nw b">m</code>，并计算<code class="fe nt nu nv nw b">m</code>的奇异值分解。这包括具有与<code class="fe nt nu nv nw b">m</code>相同的列间距的标准正交列<code class="fe nt nu nv nw b">U</code>的矩阵、其列间距是<code class="fe nt nu nv nw b">m</code>的行间距的标准正交列<code class="fe nt nu nv nw b">V</code>的第二矩阵以及正条目的对角矩阵<code class="fe nt nu nv nw b">D</code>，使得</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="6a10" class="lp lq je nw b gy of og l oh oi">m = U %*% D %*% t(V)</span></pre><p id="7348" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">det(m)</code>可用于计算方阵的行列式<code class="fe nt nu nv nw b">m</code>。</p><h2 id="11cd" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">最小二乘拟合和 QR 分解</h2><p id="b523" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">函数<code class="fe nt nu nv nw b">lsfit()</code>返回一个列表，给出最小二乘拟合过程的结果。像这样的任务</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="12b8" class="lp lq je nw b gy of og l oh oi">ans &lt;- lsfit(X, y)</span></pre><p id="e0a6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">给出最小二乘拟合的结果，其中 y 是观察向量，X 是设计矩阵。</p><p id="e013" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">ls.diag()</code>可用于回归诊断。</p><p id="6bbb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一个密切相关的函数是 qr()。</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="051f" class="lp lq je nw b gy of og l oh oi">b &lt;- qr.coef(Xplus,y)<br/>fit &lt;- qr.fitted(Xplus,y)<br/>res &lt;- qr.resid(Xplus,y)</span></pre><p id="f6a4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这些计算出<code class="fe nt nu nv nw b">y</code>到<code class="fe nt nu nv nw b">fit</code>中<code class="fe nt nu nv nw b">X</code>范围的正交投影，到<code class="fe nt nu nv nw b">res</code>中正交补码的投影，以及<code class="fe nt nu nv nw b">b</code>中投影的系数向量。</p><h2 id="a73a" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">形成分区<code class="fe nt nu nv nw b">Matrices</code></h2><p id="422f" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">矩阵可以通过函数<code class="fe nt nu nv nw b">cbind()</code>和<code class="fe nt nu nv nw b">rbind()</code>从其他向量和矩阵中构建。</p><p id="4763" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">cbind()</code>通过横向(按列)绑定矩阵形成矩阵，<code class="fe nt nu nv nw b">rbind()</code>通过纵向(按行)绑定矩阵。</p><p id="4117" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在赋值<code class="fe nt nu nv nw b">X &lt;- cbind(arg_1, arg_2, arg_3, …)</code>中，<code class="fe nt nu nv nw b">cbind()</code>的参数必须是任意长度的向量，或者是具有相同列大小(相同行数)的列。</p><p id="5130" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe nt nu nv nw b">rbind()</code>对行执行相应的操作。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="6169" class="lp lq je bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">感谢阅读！</h2><p id="2299" class="pw-post-body-paragraph kt ku je kv b kw mk kf ky kz ml ki lb lc nq le lf lg nr li lj lk ns lm ln lo im bi translated">我希望这篇关于 R 的介绍能够让您对 R 在线性代数中的强大功能有所了解。</p></div></div>    
</body>
</html>