# 数据开发中的审计与测试

> 原文：<https://towardsdatascience.com/auditing-vs-testing-in-data-development-2c3feda3a1e4?source=collection_archive---------24----------------------->

## “你如何测试数据？”

![](img/02cbb3ba208eac6b4c08248f6114a597.png)

在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上[科学高清](https://unsplash.com/@scienceinhd?utm_source=medium&utm_medium=referral)拍摄的照片

> “你如何测试数据？”

每当有人想讨论数据堆栈的现代化时，这个问题总是排在列表的首位。最常见的情况是，软件工程师负责解开 SQL 脚本和存储过程的网络，当他们发现“dev”和“prod”只是数据开发人员的 SQL 编辑器中不同的连接设置时，他们感到很苦恼。数据开发的发展非常缓慢，可以说缺乏自动化测试/测试驱动的开发是这种懒惰的一个重要原因。TDD 和 CI/CD 已经成为快速可靠的软件开发领域的爆炸性催化剂，一旦被采用，它们将对数据开发产生同样的影响。问题是 ***如何*** 进行数据转换/模型测试并不十分直观。数据给软件设计增加了一层活动部件，可以感觉几乎不可能测试；但是和任何类型的开发一样，如果事情感觉太复杂，你可能需要考虑的更小。那么*如何*测试数据呢？容易；你不知道。你 ***测试*** 软件，你 ***审核*** 数据。

![](img/2eabe2b1f9e1a42333924e6078740613.png)

非结构化开发和 TDD 在技术上都是编程的方式，就像它们在技术上都是电话一样。图片来自美国国会图书馆印刷品和照片部吉尔伯特·h·格罗夫纳收藏。

# 数据不是软件，但数据软件是软件

《剑桥词典》将软件定义为控制计算机工作的指令。在 ELT 入库流程的情况下，软件是 SQL(或 python，或 R 等。)来决定如何更改或处理数据。数据是这个软件处理的东西。这种区别看起来很明显，但明确地说出来仍然很重要，因为它是如此多混乱的根源。当我们编写软件测试时，关键是我们只测试软件。

# 事情在哪里变糟？

想象你拥有一家冰淇淋工厂(我们都可以做梦)。你的价值链大概是这样的:

![](img/17e951d2b88eea653cfa143e12cd9512.png)

假设你决定测试你的产品，所以你去商店买了一加仑的石头路。令你惊恐的是，你发现冰淇淋酸得要命！从这个测试中，我们知道有几个不同的地方可能会出错:

*   这个牛奶场可能一开始就生产了劣质牛奶
*   罐车可能污染了牛奶(不良 EL 工艺)
*   工厂可能会让牛奶变质(转化软件错误)

如果一个测试告诉你出了问题，但是不能帮助你确定它发生在价值链的什么地方，那么这个测试就是没有价值的。[单一责任原则](https://en.wikipedia.org/wiki/Single_responsibility_principle)告诉我们任何一点软件都应该只做一件事，并且把那件事做好。我们的测试也不例外！

如果不只是去商店测试，而是设立测试点，会怎么样？

*   在对牛奶做任何处理之前，在牛奶场检查牛奶
*   从罐车上接受牛奶之前，先检查一下
*   就在装运前，检查工厂生产线末端的冰淇淋
*   检查店面的冰淇淋

现在如果你在奶牛场发现一批酸奶，就没必要再往前走了。如果你在工厂生产线的末端收到一盒变质的冰淇淋，你知道它在加工过程中变酸了。

***审计*** 你的数据是在对牛奶做任何事情之前检查它。审计所做的唯一一件事( [SRP](https://en.wikipedia.org/wiki/Single_responsibility_principle) )就是确保我们的源数据按照我们的预期到达。

***测试*** 您的转换/模型逻辑是在冰淇淋被处理后检查它。测试所做的唯一一件事( [SRP](https://en.wikipedia.org/wiki/Single_responsibility_principle) )就是确保给定一个预期的数据输入，你的代码会像预期的那样运行。

# 事情变得混乱

审核和测试之间的界限最初可能很难看出，原因如下:

*   **代码看起来一样，一定是重复工作。开发人员对我们代码库中相同的文本段落有一种精心策划的恐惧。干编程告诉我们，任何两个看起来几乎相同的东西都应该被参数化/注入/粉碎成某种形式的单一的、可调用的执行。当我们的测试和审计提出类似的问题时，很容易尝试多任务处理。不要这样做！审计和测试可能会问同样的问题，但它们是在非常不同的环境中进行的。例如，在`user_id`中发现一个`NULL`值的审计告诉您有一个源数据问题或变更。转换测试中相同的`NULL`值告诉您您的 SQL 是不正确的。审计`NULL`只能*意味着源数据有问题，因为您的转换还没有触及它。一个测试`NULL`只能*意味着你的 SQL 代码有 bug，因为源数据通过了审计。****
*   ***测试是工具，不是数据。测试的唯一目的是促进发展。给定一个不可变的输入，我们应该期待一个不可变的输出(否则我们会有更大的问题)。因此，测试是确定我们在输入和输出之间精心制作的逻辑何时“完成”的一种方式为了让测试有用，它们需要足够快，能够在我们开发的过程中一遍又一遍地运行，并且足够全面，以至于我们“目测”来验证我们工作的任何东西都有一个等价的自动化测试。有效测试的一个核心要求是，我们可以相信所提供的源数据与我们得到的承诺完全一致。***
*   ***审计是实质性的(和大量的元数据)**。为了让我们的测试信任源数据，我们的审计不能信任源数据。审计对源数据有期望(即`user_id`永远不会是`NULL`)，并检查以确保这些期望得到满足(`SELECT * FROM products WHERE user_id IS NULL`)。当源数据没有通过这项检查时，审计人员并没有生气，他们只是感到失望——他们通过停止 ELT 过程来表达这种失望。*

# *实践中的理论*

*理解审计-测试模型最简单的方法是浏览一个例子。*

*这里我们有来自一个电子商务网站的源数据，如下所示:*

*![](img/f0060f4aa63d9a6a51d1f00d7dd3f217.png)*

*我们相信:
-所有记录*必须*有一个`user_id`值
- ip_region 只能是`east`、`west`、`north`或`south`*

*因此，我们编写了在每次从源系统批量加载后运行的审计:*

```
*## audit_users_user_id_is_not_null
SELECT * FROM "DATA_LAKE"."USERS" WHERE user_id IS NULL;## audit_users_region_in_set
SELECT * FROM "DATA_LAKE"."USERS" WHERE ip_region NOT IN ('west','east','south')*
```

*如何运行审计可以有多种方式(从实现的角度来看)。重要的是:
-审计在任何转换之前首先运行。
-当所有审核通过时，ELT 正常进行。
-当审核失败时，会详细记录失败情况，ELT 会暂停并发出警报。*

****注意:****[*Kimball*](https://www.kimballgroup.com/2014/03/design-tip-164-built-your-audit-dimension/)*围绕审计级别和记录模式做了大量的工作，这些不在本文的范围之内。***

**从事聚合转换的开发人员也可以编写一个测试，在`user_id`中寻找`NULL`值:**

```
**## test_user_id_never_null
SELECT * FROM "DATA_WAREHOUSE"."DIM_USER" WHERE user_id IS NULL;**
```

**但是关键的区别在于:**开发人员的测试只是为了告诉他们代码是否正确**。审计层承诺所有记录都有`user_id`值，所以开发过程中的任何`NULL`值都意味着代码有 bug。开发人员可以根据承诺的输入安全地编写测试来检查预期的输出，当所有测试都通过时，代码就可以发布了。**

**如果没有`user_id`的记录进来，ELT 停止。所有记录都有一个`user_id`的信念不再被认为是正确的。通过审计记录调查缺失行的`user_id`,发现所有有问题的行都正好来自 2020–03–02t 11:10:53，是由一个应用程序错误引起的，该错误已被修补。还要注意的是，在那个时间戳没有创建有效的行。新的承诺是所有行都将有一个`user_id`，除了在 2020–03–02t 11:10:53 创建的记录。审计代码被调整以反映我们现在认为是真实的，应用程序代码被调整以*处理数据的新现实*。**

**审计记录可以(并且经常)被注释，以便为所有这些复杂性创建上下文。其结果是丰富的数据演变历史记录和高性能的开发工作流程，优化您最有价值的资产—数据开发人员带宽。**