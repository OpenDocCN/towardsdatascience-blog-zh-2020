<html>
<head>
<title>Introduction to Genetic Algorithm and Python Implementation For Function Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数优化的遗传算法和 Python 实现简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-genetic-algorithm-and-python-implementation-for-function-optimization-fd36bad58277?source=collection_archive---------9-----------------------#2020-04-20">https://towardsdatascience.com/introduction-to-genetic-algorithm-and-python-implementation-for-function-optimization-fd36bad58277?source=collection_archive---------9-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/10e888bcac0903697c45c19dd45060ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XcyBTchTgEpwqs-Y4nDBxw.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图片由来自<a class="ae kf" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4828422" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kf" href="https://pixabay.com/users/french1944-12643700/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4828422" rel="noopener ugc nofollow" target="_blank">威廉·弗伦奇</a>拍摄</p></figure><p id="941b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，在这篇文章中，我将尝试给你一个遗传算法如何工作的想法，我们将实现函数优化的遗传算法。那么，我们开始吧。</p><p id="e97d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">遗传算法是一种基于搜索的优化技术。它经常用于寻找最优或最接近的最优解。它是由霍兰德引进的。它基于达尔文的自然选择理论。在解释遗传算法如何工作之前，让我先解释一下达尔文的自然选择理论。在他的理论中，他将自然选择定义为“一个特征的每一个微小的变化，如果有用的话，被保留下来的原则”。这个概念简单而有力:最能适应环境的个体更有可能生存和繁衍。[ <a class="ae kf" href="https://en.wikipedia.org/wiki/Natural_selection" rel="noopener ugc nofollow" target="_blank">维基百科</a> ]有时这个理论被描述为“适者生存”。那些比其他人更适合的人有机会在这场进化中生存下来。遗传算法就是关于这个的。它模仿自然选择的过程来寻找最佳解决方案。</p><p id="adf4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在遗传学中，我们将使用一些生物学术语，如群体、染色体、基因、选择、交叉、突变。现在，首先，让我们试着理解这些术语的含义。</p><h2 id="b5c2" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">群体、染色体、基因</h2><p id="522a" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在这个过程的开始，我们需要初始化这个问题的一些可能的解决方案。群体是给定问题的所有可能解决方案的子集。换句话说，我们可以说群体是一组染色体。染色体是解决当前问题方法之一。每条染色体都是一组基因。</p><p id="6f76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为简单起见，我们可以将染色体描述为一个字符串。因此，我们可以说群体是一些字符串的集合(每个字符是一个二进制值，或者是 0，或者是 1)。字符串中的每个字符都是一个基因。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/81934a7071201fd5a050832410aae3ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*wDiDa61xUo-LfGdqaZPIbA.png"/></div></figure><p id="2979" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了开始遗传算法的过程，我们首先需要初始化种群。我们可以用两种方法初始化群体。第一个是随机的，第二个是启发式的。用一些随机群体开始算法总是更好。</p><h2 id="279d" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">适应度函数</h2><p id="2800" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">初始化种群后，我们需要计算这些染色体的适应值。现在的问题是这个适应度函数是什么，它是如何计算适应度值的。</p><p id="830e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个例子，假设我们有一个方程，f(x) = -x + 5。我们需要有最大值且约束为 0≤x≤31 的解。</p><p id="fc44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们考虑一下，我们有一个随机的四条染色体的群体，如下所示。我们的染色体长度是 5 as 2⁵=32，0≤x≤31。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/e7c63de65211c3c38cb242ed83217970.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*wpkYYdrTd4dnPyll899vdA.png"/></div></figure><p id="7d9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的适应度函数将计算每个染色体的函数值，如问题陈述中所述:</p><p id="d472" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于第一条染色体，01110 表示整数 14。所以，f(x) = -(14*14) + 5 = -191。</p><p id="1ae7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于第二条染色体，10101 表示整数 21。所以，f(x) = -(21*21) + 5 = -436。</p><p id="2171" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于第三条染色体，00011 表示整数 3。所以，f(x) = -(3*3) + 5 = -4。</p><p id="9119" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于第四条染色体来说，10111 在整数上意味着 23。所以，f(x) = -(23*23) + 5 = -524。</p><h2 id="d438" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">亲代选择</h2><p id="8949" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">亲本选择通过使用由适应度函数计算的染色体的适应度值来完成。基于这些适应值，我们需要选择一对具有最高适应值的染色体。</p><p id="bae1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多方法适合度计算喜欢轮盘赌轮选择，等级选择。</p><p id="97b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在轮盘赌轮选择中，具有最高适应值的染色体具有最大的可能性被选为亲本。但是在这个选择过程中，可以选择更低的。</p><p id="7c29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在等级选择中，染色体根据它们的适应度值从高到低排序。作为一个例子，根据上面计算的那些适应值，我们可以从高到低排列那些染色体，如第 3 &gt;第 1 &gt;第 2 &gt;第 4。因此，在选择阶段，将基于从适应度函数计算的适应度值来选择第三和第一染色体。</p><h2 id="721d" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">交叉</h2><p id="884f" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">交叉用于通过产生子代或后代来改变一代代染色体的编程。亲代染色体用于创建这些后代(生成的染色体)。</p><p id="b6f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了创造后代，有一些方法，如单点杂交，两点或多点杂交。</p><p id="0497" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于单点杂交，首先，我们需要选择一个点，然后在亲代染色体之间交换被该点分割的这些部分，以产生后代。你可以使用颜色组合，以便于理解。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/2a699f440a598a22603d9d83032db447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-H-g_w9dfGqsP42EL4I1jw.png"/></div></div></figure><p id="721c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于两点交叉，我们需要选择两个点，然后交换比特。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/4a4490f6555ea1bfbd22929abd5d13ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVKuqSz0bCn4wC-kF3eYvA.png"/></div></div></figure><p id="41de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，这些新的后代被添加到种群中。</p><h2 id="e45b" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">变化</h2><p id="ba24" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">突变给种群带来多样性。有不同种类的突变，如位翻转突变、交换突变、倒位突变等。这些太简单了。</p><p id="8077" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在比特翻转突变中，只需选择一个或多个比特，然后翻转它们。如果所选位为 0，则将其转换为 1，如果所选位为 1，则将其转换为 0。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/fc217cac79bdd446faa8195654f38e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*-Hc6azOBEhxtUaxvJVDhGw.png"/></div></figure><p id="db1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在交换位突变中，选择两个位并交换它们。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/d63a6954de9701e14d35a35c933d6e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dW693DhVKbBSClyHUSNVcg.png"/></div></div></figure><p id="e19e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在逆突变中，只需反转位。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/f3ed0d9c51ba3a7791cbf6adf824836d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U22K8cNVf4v3d1vP7g1K4g.png"/></div></div></figure><h1 id="3abb" class="mn lf it bd lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na nb nc lv nd bi translated"><strong class="ak">遗传算法在 Python 中的实现</strong></h1><p id="cb46" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">让我们尝试用 python 实现函数优化的遗传算法。</p><p id="8c1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">问题陈述</strong></p><p id="6993" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有一个方程，f(x) = -x + 5。我们需要有最大值且约束为 0≤x≤31 的解。使用概率 0.2 来选择初始群体。</p><p id="ebfa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在这里 找到完整的代码<a class="ae kf" href="https://www.kaggle.com/aaawnrahman/genetic-algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">。</strong></a></p><p id="9ac4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">初始人口</strong></p><p id="652b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随机初始化优于启发式初始化。因此，这里随机初始化用于群体初始化。</p><pre class="md me mf mg gt ne nf ng nh aw ni bi"><span id="050e" class="le lf it nf b gy nj nk l nl nm"><em class="nn">#initialize population</em><br/>import random<br/>best=-100000<br/>populations =([[random.randint(0,1) for x <strong class="nf iu">in</strong> range(6)] for i <strong class="nf iu">in</strong> range(4)])<br/>print(type(populations))<br/>parents=[]<br/>new_populations = []<br/>print(populations)</span></pre><p id="3319" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">健身功能</strong></p><p id="5374" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">适应性函数计算染色体的适应性值。适应度函数的功能取决于问题的要求。</p><pre class="md me mf mg gt ne nf ng nh aw ni bi"><span id="9eb4" class="le lf it nf b gy nj nk l nl nm"><em class="nn">#fitness score calculation ............</em><br/>def fitness_score() :<br/>    global populations,best<br/>    fit_value = []<br/>    fit_score=[]<br/>    for i <strong class="nf iu">in</strong> range(4) :<br/>        chromosome_value=0<br/>        <br/>        for j <strong class="nf iu">in</strong> range(5,0,-1) :<br/>            chromosome_value += populations[i][j]*(2**(5-j))<br/>        chromosome_value = -1*chromosome_value if populations[i][0]==1 else chromosome_value<br/>        print(chromosome_value)<br/>        fit_value.append(-(chromosome_value**2) + 5 )<br/>    print(fit_value)<br/>    fit_value, populations = zip(*sorted(zip(fit_value, populations) , reverse = True))<br/>    best= fit_value[0]<br/>    <br/>fitness_score()</span></pre><p id="4c7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">选择</strong></p><p id="ae57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基于适合度分数选择最适合的染色体。这里使用等级选择过程。</p><pre class="md me mf mg gt ne nf ng nh aw ni bi"><span id="94a1" class="le lf it nf b gy nj nk l nl nm">def selectparent():<br/>    global parents<br/>    <em class="nn">#global populations , parents</em><br/>    parents=populations[0:2]<br/>    print(type(parents))<br/>    print(parents)<br/>selectparent()</span></pre><p id="f547" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">交叉</strong></p><p id="3070" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在选择了最合适的亲本后，需要进行杂交来产生后代。这里使用单点交叉。</p><pre class="md me mf mg gt ne nf ng nh aw ni bi"><span id="5d7e" class="le lf it nf b gy nj nk l nl nm">def crossover() :<br/>    global parents<br/>    <br/>    cross_point = random.randint(0,5)<br/>    parents=parents + tuple([(parents[0][0:cross_point +1] +parents[1][cross_point+1:6])])<br/>    parents =parents+ tuple([(parents[1][0:cross_point +1] +parents[0][cross_point+1:6])])<br/>    <br/>    print(parents)</span></pre><p id="2a6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">突变</strong></p><p id="9bfc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">交叉完成后，进行变异以保持一代到另一代的多样性。在这里，我们将单点位翻转突变。</p><pre class="md me mf mg gt ne nf ng nh aw ni bi"><span id="4411" class="le lf it nf b gy nj nk l nl nm">def mutation() :<br/>    global populations, parents<br/>    mute = random.randint(0,49)<br/>    if mute == 20 :<br/>        x=random.randint(0,3)<br/>        y = random.randint(0,5)<br/>        parents[x][y] = 1-parents[x][y]<br/>    populations = parents<br/>    print(populations)</span></pre><p id="7b41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要多次迭代整个过程，直到找到我们的最佳解决方案。</p><p id="b79c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你会在<a class="ae kf" href="https://www.kaggle.com/aaawnrahman/genetic-algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">卡格尔</strong> </a>上找到完整的代码。</p><h2 id="dc37" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">参考</h2><ol class=""><li id="0e16" class="no np it ki b kj lx kn ly kr nq kv nr kz ns ld nt nu nv nw bi translated"><a class="ae kf" href="https://www.tutorialspoint.com/genetic_algorithms/genetic_algorithms_mutation.htm" rel="noopener ugc nofollow" target="_blank">遗传算法—变异</a></li><li id="2a44" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated"><a class="ae kf" href="https://www.tutorialspoint.com/genetic_algorithms/genetic_algorithms_mutation.htm" rel="noopener ugc nofollow" target="_blank">遗传算法——交叉</a></li><li id="03c7" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated"><a class="ae kf" href="https://www.tutorialspoint.com/genetic_algorithms/genetic_algorithms_parent_selection.htm" rel="noopener ugc nofollow" target="_blank">遗传算法—亲本选择</a></li><li id="565b" class="no np it ki b kj nx kn ny kr nz kv oa kz ob ld nt nu nv nw bi translated"><a class="ae kf" href="https://www.tutorialspoint.com/genetic_algorithms/genetic_algorithms_population.htm" rel="noopener ugc nofollow" target="_blank">遗传算法—种群初始化</a></li></ol><h2 id="0a38" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">最后，感谢您的阅读。感谢您的任何反馈。</h2></div></div>    
</body>
</html>