<html>
<head>
<title>Deep Dive into Querying Elasticsearch. Filter vs Query. Full-text search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入查询Elasticsearch。过滤器与查询。全文搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deep-dive-into-querying-elasticsearch-filter-vs-query-full-text-search-b861b06bd4c0?source=collection_archive---------0-----------------------#2020-01-21">https://towardsdatascience.com/deep-dive-into-querying-elasticsearch-filter-vs-query-full-text-search-b861b06bd4c0?source=collection_archive---------0-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="419c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">或者如何理解缺少哪些官方文档</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0e2019ccf41334cea219a485efec6bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bf_dVk-tbmQtHAh_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@paramir?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃胡德·纽豪斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="97db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我必须用一句话来描述Elasticsearch，我会说:</p><blockquote class="lv"><p id="013b" class="lw lx it bd ly lz ma mb mc md me lu dk translated">当<strong class="ak">搜索</strong>与<strong class="ak">分析</strong>大规模相遇时(接近实时)</p></blockquote><p id="8456" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">Elasticsearch是目前十大最受欢迎的开源技术之一。公平地说，它结合了许多本身并不独特的关键特性，然而，当结合起来时，它可以成为最好的搜索引擎/分析平台。</p><p id="8300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更准确地说，Elasticsearch之所以如此受欢迎，是因为它结合了以下特点:</p><ul class=""><li id="4f2a" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">使用相关性评分进行搜索</li><li id="72ee" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">全文搜索</li><li id="6aff" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">分析(聚合)</li><li id="04c5" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">无模式(对数据模式没有限制)，NoSQL，面向文档</li><li id="0977" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">丰富的数据类型选择</li><li id="fa62" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">水平可伸缩</li><li id="9ce3" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">容错的</li></ul></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d4b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为我的副业项目与Elasticsearch一起工作时，我很快意识到官方文档看起来更像是从所谓的文档中“压榨”出来的。我不得不在谷歌上搜索了很多次，所以我决定收集这篇文章中的所有信息。</p><p id="1c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将主要写查询/搜索Elasticsearch集群。有许多不同的方法可以实现或多或少相同的结果，因此，我将尝试解释每种方法的利弊。</p><p id="5261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更重要的是，我将向您介绍两个重要的概念——<strong class="lb iu">查询和过滤上下文</strong>——它们在文档中没有得到很好的解释。我会给你一套规则，告诉你什么时候用哪种方法更好。</p><p id="c05e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果读完这篇文章后，我想让你记住一件事，那就是:</p><blockquote class="lv"><p id="78ed" class="lw lx it bd ly lz ma mb mc md me lu dk translated">查询时真的需要给文档打分吗？</p></blockquote></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="7ceb" class="nh ni it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">查询上下文与过滤上下文</h2><p id="30b2" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">当我们谈论Elasticsearch时，总会有一个相关性分数。<strong class="lb iu">相关性分数是一个严格的正数，表示每个文档满足搜索标准的程度。</strong>该分数相对于分配的最高分数，因此，分数越高，文档与搜索标准的相关性越好。</p><p id="455e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，过滤器和查询是两个不同的概念，在编写查询之前，您应该能够理解这两个概念。</p><p id="99cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，<strong class="lb iu">过滤上下文</strong>是一个是/否选项，其中每个<strong class="lb iu">文档要么匹配查询，要么不匹配</strong>。一个很好的例子是SQL <code class="fe of og oh oi b">WHERE</code>后跟一些条件。SQL查询总是返回严格符合条件的行。SQL查询不可能返回不明确的结果。</p><blockquote class="oj ok ol"><p id="883d" class="kz la om lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated"><strong class="lb iu">过滤器被自动缓存，不会影响相关性分数。</strong></p></blockquote><p id="ac72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，elastic search<strong class="lb iu">查询上下文</strong>向您展示<strong class="lb iu">每个文档与您的需求的匹配程度</strong>。为此，查询使用分析器来查找最佳匹配。</p><p id="c616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经验法则是<strong class="lb iu">对</strong>使用过滤器:</p><ul class=""><li id="4fb6" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">是/否搜索</li><li id="d425" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">搜索精确值(数字、范围和关键字)</li></ul><p id="d922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">使用查询进行</strong>:</p><ul class=""><li id="eaa0" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">不明确的结果(某些文档比其他文档更适合)</li><li id="0c9a" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">全文搜索</li></ul><blockquote class="lv"><p id="b65f" class="lw lx it bd ly lz oq or os ot ou lu dk translated">除非你需要相关性分数或全文搜索，否则请尽量使用过滤器。滤镜“更便宜”。</p></blockquote><p id="5f5a" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">另外，<strong class="lb iu"> Elasticsearch会自动缓存过滤器</strong>的结果。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="ab06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第1部分。第二。我将谈到查询(可以转换成过滤器)。请不要混淆<strong class="lb iu">结构化vs全文</strong>和<strong class="lb iu">查询vs过滤器</strong>——那是两回事。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="d8ca" class="ov ni it bd nj ow ox oy nm oz pa pb np jz pc ka ns kc pd kd nv kf pe kg ny pf bi translated">1.结构化查询</h1><p id="1e57" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">结构化查询也称为<strong class="lb iu">术语级查询</strong>，是一组检查文档是否应该被选择的查询方法。因此，在许多情况下并不真正需要相关性分数——文档要么匹配，要么不匹配(尤其是数字)。</p><p id="bbc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">术语级查询仍然是查询，因此它们将返回分数。</p><p id="423b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">术语查询</strong></p><p id="18c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回字段值与条件完全匹配的文档。术语查询在某种程度上是SQL <code class="fe of og oh oi b">select * from table_name where column_name =...</code>的替代</p><p id="ce44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">术语查询直接进入倒排索引，这使得它很快。当处理文本数据时，最好仅对<code class="fe of og oh oi b">keyword</code>字段使用<code class="fe of og oh oi b">term</code>。</p><pre class="kj kk kl km gt pg oi ph pi aw pj bi"><span id="bf03" class="nh ni it oi b gy pk pl l pm pn">GET /_search<br/>{<br/>    "query": {<br/>        "term": {<br/>            "&lt;field_name&gt;": {<br/>                "value": "&lt;your_value&gt;"<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="1b42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">默认情况下，术语查询是在查询上下文中运行的，因此，它会计算得分。即使返回的所有文档的分数都相同，也需要额外的计算能力。</strong></p><h2 id="5d56" class="nh ni it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">带过滤器的术语查询</h2><p id="5099" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">如果我们想加速术语查询并将其缓存，那么它应该被包装在一个<code class="fe of og oh oi b">constant_score</code>过滤器中。</p><p id="de44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得经验法则吗？如果您不关心相关性分数，请使用此方法。</p><pre class="kj kk kl km gt pg oi ph pi aw pj bi"><span id="19eb" class="nh ni it oi b gy pk pl l pm pn">GET /_search<br/>{<br/>    "query": {<br/>        "<strong class="oi iu">constant_score</strong>" : {<br/>            "<strong class="oi iu">filter</strong>" : {<br/>                "term" : {"&lt;field_name&gt;" : "&lt;your_value&gt;"}<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="60af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，该查询不计算任何相关性分数，因此速度更快。而且，它是自动缓存的。</p><p id="9596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速建议——对于<code class="fe of og oh oi b">text</code>字段，使用<code class="fe of og oh oi b">match</code>而不是<code class="fe of og oh oi b">term</code>。</p><p id="6d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，术语查询直接指向倒排索引。术语查询接受您提供的值，并按原样搜索它，这就是为什么它非常适合查询没有任何转换就存储的<code class="fe of og oh oi b">keyword</code>字段。</p><p id="fd02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">条款查询</strong></p><p id="7a7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经猜到，术语<strong class="lb iu"> </strong>查询允许您返回与<strong class="lb iu">至少一个</strong>精确术语匹配的文档。</p><p id="c55f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">术语查询在某种程度上是SQL的替代品<code class="fe of og oh oi b">select * from table_name where column_name is in...</code></p><p id="8c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解Elasticsearch中的查询字段可能是一个列表很重要，例如<code class="fe of og oh oi b">{ "name" : ["Odin", "Woden", "Wodan"] }</code>。如果您执行的<code class="fe of og oh oi b">terms</code>查询包含以下名称之一，那么该记录将被匹配——它不必匹配字段中的所有值，而只需匹配一个值。</p><pre class="kj kk kl km gt pg oi ph pi aw pj bi"><span id="fd38" class="nh ni it oi b gy pk pl l pm pn">GET /_search<br/>{<br/>    "query" : {<br/>        "terms" : {<br/>            "name" : ["Frigg", "Odin", "Baldr"]<br/>        }<br/>    }<br/>}</span></pre><h2 id="3541" class="nh ni it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">术语集查询</h2><p id="1e2d" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">与术语查询相同，但这次您可以指定在查询的字段中应该有多少确切的术语。</p><p id="d674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以指定需要匹配的数量——一个、两个、三个或全部。但是，这个数字是另一个数字字段。因此，每个文档都应该包含这个编号(特定于这个特定的文档)。</p><h2 id="a6e5" class="nh ni it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">范围查询</h2><p id="b92e" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">返回查询字段值在定义范围内的文档。</p><p id="cc6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相当于SQL <code class="fe of og oh oi b">select * from table_name where column_name is between...</code></p><p id="639f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">范围查询有自己的语法:</p><ul class=""><li id="6b2e" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated"><code class="fe of og oh oi b">gt</code>大于</li><li id="204b" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe of og oh oi b">gte</code>大于或等于</li><li id="8f34" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe of og oh oi b">lt</code>小于</li><li id="63ca" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe of og oh oi b">lte</code>小于或等于</li></ul><p id="e1de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字段值应≥ 4且≤ 17的示例:</p><pre class="kj kk kl km gt pg oi ph pi aw pj bi"><span id="e18d" class="nh ni it oi b gy pk pl l pm pn">GET _search<br/>{<br/>    "query": {<br/>        "range" : {<br/>            "&lt;field_name&gt;" : {<br/>                "gte" : 4,<br/>                "lte" : 17<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="6fb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">范围查询也适用于日期。</p><h2 id="edae" class="nh ni it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">正则表达式、通配符和前缀查询</h2><p id="7ac1" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">Regexp查询返回字段与您的<a class="ae ky" href="https://en.wikipedia.org/wiki/Regular_expression" rel="noopener ugc nofollow" target="_blank">正则表达式</a>匹配的文档。</p><p id="1716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你从未使用过正则表达式，那么我强烈建议你至少了解一下它是什么以及什么时候可以应用它。</p><p id="5114" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elasticsearch的regexp是Lucene的。它有标准的保留字符和运算符。如果你已经使用过Python的<code class="fe of og oh oi b">re</code>包，那么在这里使用它应该不成问题。唯一不同的是Lucene的引擎不支持<code class="fe of og oh oi b">^</code>、<code class="fe of og oh oi b">$</code>等锚点运算符。</p><p id="3479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在官方文档中找到regexp的完整列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="po ng l"/></div></figure><p id="57f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了regexp查询，Elsticsearch还有通配符和前缀查询。从逻辑上讲，这两个只是正则表达式的特例。</p><p id="29be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，我找不到关于这3个查询的性能的任何信息，因此，我决定自己测试一下，看看是否有什么显著的不同。</p><p id="b66d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用<code class="fe of og oh oi b">rehexp</code>和<code class="fe of og oh oi b">wildcard</code>查询比较通配符查询时，我没有发现任何性能差异。如果你知道有什么不同，请，<a class="ae ky" href="https://twitter.com/bugaralife" rel="noopener ugc nofollow" target="_blank"> tweet </a> me。</p><h2 id="35b3" class="nh ni it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated"><strong class="ak">已有查询</strong></h2><p id="a1c8" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">由于Elasticsearch是无模式的(或者没有严格的模式限制)，当不同的文档有不同的字段时，这是一种相当常见的情况。因此，知道一个文档是否有某个字段是非常有用的。</p><blockquote class="oj ok ol"><p id="99df" class="kz la om lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated"><a class="ae ky" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl-exists-query.html" rel="noopener ugc nofollow" target="_blank"> Exists查询返回包含字段索引值的文档</a></p></blockquote><pre class="kj kk kl km gt pg oi ph pi aw pj bi"><span id="4d3c" class="nh ni it oi b gy pk pl l pm pn">GET /_search<br/>{<br/>    "query": {<br/>        "exists": {<br/>            "field": "&lt;your_field_name&gt;"<br/>        }<br/>    }<br/>}</span></pre><h1 id="28e3" class="ov ni it bd nj ow pp oy nm oz pq pb np jz pr ka ns kc ps kd nv kf pt kg ny pf bi translated">2.全文查询</h1><p id="7124" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">全文查询适用于非结构化文本数据。<strong class="lb iu">全文查询利用了分析器。</strong>因此，我将简要概述Elasticsearch的分析器，以便我们可以更好地分析全文查询。</p><h2 id="b88d" class="nh ni it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">弹性搜索的分析管</h2><p id="2e86" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">每次将<code class="fe of og oh oi b">text</code>类型的数据插入到Elasticsearch索引中时，都会对其进行分析，然后存储在倒排索引中。因为analyzer还适用于全文搜索，所以根据您对analyzer的配置，它会影响您的搜索功能。</p><p id="9aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="om">分析仪管道</em> </strong>由三个阶段组成:</p><p id="3764" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符过滤器(0+) →记号赋予器(1) →记号过滤器(0+)</p><p id="9668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总有一个<strong class="lb iu">记号赋予器</strong>和<strong class="lb iu">零个或多个字符&amp;记号过滤器</strong>。</p><p id="195d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="om"> 1)字符过滤器</em> </strong>按原样接收文本数据，然后它可能在数据被标记化之前对其进行预处理。字符过滤器用于:</p><ul class=""><li id="9a88" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">替换匹配给定正则表达式的字符</li><li id="489e" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">替换匹配给定字符串的字符</li><li id="4252" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">清除HTML文本</li></ul><p id="d8f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="om"> 2)记号赋予器</em> </strong>将字符过滤后接收的文本数据(如果有)分解成记号。例如，<code class="fe of og oh oi b">whitespace</code> tokenizer简单地通过空白字符(这不是标准的)来分隔文本。因此，<code class="fe of og oh oi b">Wednesday is called after Woden.</code>将被拆分成<code class="fe of og oh oi b">Wednesday,</code> <code class="fe of og oh oi b">is,</code> <code class="fe of og oh oi b">called,</code> <code class="fe of og oh oi b">after,</code> <code class="fe of og oh oi b">Woden.</code>。有许多<a class="ae ky" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/analysis-tokenizers.html" rel="noopener ugc nofollow" target="_blank">内置标记器</a>可用于创建定制分析器。</p><p id="5842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="om">标准记号赋予器</em> </strong>在删除标点符号后用空格将文本断开。对于绝大多数语言来说，这是最中性的选择。</p><p id="0058" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了标记化，<strong class="lb iu"> <em class="om">标记化器</em> </strong>还执行以下操作:</p><ul class=""><li id="01ec" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">跟踪代币顺序，</li><li id="0dd7" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">注意每个单词的开头和结尾</li><li id="de1d" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">定义令牌的类型</li></ul><p id="09d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="om"> 3)令牌过滤器</em> </strong>对令牌应用一些变换。您可以选择将许多不同的令牌过滤器添加到您的分析器中。一些最受欢迎的是:</p><ul class=""><li id="fc77" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">小写字母</li><li id="1995" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">词干分析器(适用于多种语言！)</li><li id="7693" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">删除重复项</li><li id="1b1f" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">转换为等效的ASCII码</li><li id="f420" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">模式的变通方法</li><li id="d174" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">令牌计数限制</li><li id="448a" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">令牌的停止列表(从停止列表中删除令牌)</li></ul><p id="ab3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们知道分析器由什么组成时，我们可能会考虑如何处理我们的数据。然后，我们可能<a class="ae ky" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/analyzer-anatomy.html" rel="noopener ugc nofollow" target="_blank">通过选择合适的组件来组成一个最适合我们情况的分析器</a>。分析器<strong class="lb iu">可以在每个字段的基础上指定。</strong></p><p id="cc19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论够了，我们来看看默认分析器是怎么工作的。</p><p id="b059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">标准分析仪</strong>为默认分析仪。它有0字符过滤器，标准记号，小写和停止记号过滤器。您可以随心所欲地构建您的定制分析器，但是也有一些内置分析器。</p><p id="9940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些最有效的开箱即用分析器是语言分析器，它们利用每种语言的特性进行更高级的转换。因此，如果您事先知道数据的语言，我建议您从标准分析器切换到数据语言之一。</p><p id="9b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">全文查询将使用索引数据时使用的同一分析器。</strong>更准确地说，您的查询文本将与搜索字段中的文本数据经历相同的转换，因此两者处于同一级别。</p><h2 id="f3e9" class="nh ni it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">匹配查询</h2><p id="9f95" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">匹配查询是查询<code class="fe of og oh oi b">text</code>字段的标准查询。</p><p id="ac85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe of og oh oi b">text</code>类型字段之外，我们可以将<code class="fe of og oh oi b">match</code>查询称为<code class="fe of og oh oi b">term</code>查询的等效查询(而在处理文本数据时，<code class="fe of og oh oi b">term</code>应该只用于<code class="fe of og oh oi b">keyword</code>类型字段)。</p><pre class="kj kk kl km gt pg oi ph pi aw pj bi"><span id="acb7" class="nh ni it oi b gy pk pl l pm pn">GET /_search<br/>{<br/>  "query" : {<br/>    "match" : {<br/>      "&lt;text_field&gt;" {<br/>        "query" : "&lt;your_value&gt;"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="feae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，传递给<code class="fe of og oh oi b">query</code>参数(必需的)的字符串将由应用于搜索字段的分析器进行处理。除非您使用<code class="fe of og oh oi b">analyzer</code>参数自己指定分析仪。</p><p id="f24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您指定要搜索的短语时，它会被分析，结果总是一组标记。默认情况下，Elasticsearch将在所有这些令牌之间使用<code class="fe of og oh oi b">OR</code>操作符。这意味着至少应该有一个匹配——尽管匹配越多，得分越高。您可以在<code class="fe of og oh oi b">operator</code>参数中将其切换到<code class="fe of og oh oi b">AND</code>。在这种情况下，要返回文档，必须在文档中找到所有的标记。</p><p id="71c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望在<code class="fe of og oh oi b">OR</code>和<code class="fe of og oh oi b">AND</code>之间有一些东西，您可以指定<code class="fe of og oh oi b"><a class="ae ky" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl-minimum-should-match.html" rel="noopener ugc nofollow" target="_blank">minimum_should_match</a></code>参数，该参数指定应该匹配的子句的数量。它可以用数字和百分比来指定。</p><p id="8cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">fuzziness</code>参数(可选)允许你省略错别字。<a class="ae ky" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> Levenshtein距离</a>用于计算。</p><p id="13e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您将<code class="fe of og oh oi b">match</code>查询应用到<code class="fe of og oh oi b">keyword</code>字段，那么它将执行与<code class="fe of og oh oi b">term</code>查询相同的操作。更有趣的是，如果您将存储在倒排索引中的令牌的确切值传递给<code class="fe of og oh oi b">term</code>查询，那么它将返回与<code class="fe of og oh oi b">match</code>查询完全相同的结果，但速度更快，因为它将直接进入倒排索引。</p><h2 id="fa8e" class="nh ni it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">匹配短语查询</h2><p id="fcba" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">与<code class="fe of og oh oi b">match</code>相同，但顺序和接近度很重要。匹配查询不知道顺序和接近度，因此，只可能用不同类型的查询来实现短语匹配。</p><pre class="kj kk kl km gt pg oi ph pi aw pj bi"><span id="41dc" class="nh ni it oi b gy pk pl l pm pn">GET /_search<br/>{<br/>    "query": {<br/>        "match_phrase" : {<br/>            "&lt;text_field&gt;" : {<br/>                "query" : "&lt;your_value&gt;",<br/>                "slop" : "0"<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="29b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">match_phrase</code>查询有<code class="fe of og oh oi b">slop</code>参数(默认值为0 ),负责跳过术语。因此，如果指定<code class="fe of og oh oi b">slop</code>等于1，那么短语中的一个单词可能会被省略。</p><h2 id="9f45" class="nh ni it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">多匹配查询</h2><p id="a6ef" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">多匹配查询的工作与<code class="fe of og oh oi b">match</code>相同，唯一的区别是它应用于多个字段。</p><pre class="kj kk kl km gt pg oi ph pi aw pj bi"><span id="fcb2" class="nh ni it oi b gy pk pl l pm pn">GET /_search<br/>{<br/>  "query": {<br/>    "multi_match" : {<br/>      "query":    "&lt;your_value&gt;", <br/>      "fields": [ "&lt;text_field1&gt;", "&lt;text_field2&gt;" ] <br/>    }<br/>  }<br/>}</span></pre><ul class=""><li id="f610" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">可以使用通配符指定字段名称</li><li id="8b7d" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">默认情况下，每个字段的权重相等</li><li id="c25a" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">每个字段对分数的贡献可以增加</li><li id="3cc5" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">如果在<code class="fe of og oh oi b">fields</code>参数中没有指定字段，则将搜索所有符合条件的字段</li></ul><p id="593a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">multi_match</code>有<a class="ae ky" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl-multi-match-query.html" rel="noopener ugc nofollow" target="_blank">不同类型的</a>。我不会在这篇文章中一一描述，但我会解释最流行的:</p><p id="6f81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">best_fields</code> type(默认)更喜欢在一个字段中找到搜索值的标记的结果，而不是在不同字段中找到搜索标记的结果。</p><p id="ad2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">most_fields</code>与<code class="fe of og oh oi b">best_fields</code>型有些相反。</p><p id="1836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">phrase</code>类型的行为与<code class="fe of og oh oi b">best_fields</code>相似，但搜索的是类似于<code class="fe of og oh oi b">match_phrase</code>的整个短语。</p><p id="aa3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我强烈建议浏览一下官方文件,看看这些领域的分数是如何计算出来的。</p><h1 id="f6f3" class="ov ni it bd nj ow pp oy nm oz pq pb np jz pr ka ns kc ps kd nv kf pt kg ny pf bi translated">3.复合查询</h1><p id="cb26" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">复合查询将其他查询包装在一起。复合查询:</p><ul class=""><li id="331a" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">组合te分数</li><li id="a826" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">更改包装查询的行为</li><li id="7a97" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">将查询上下文切换到筛选器上下文</li><li id="5c06" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">以上任意组合</li></ul><h2 id="2c59" class="nh ni it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">布尔查询</h2><p id="0b23" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated"><a class="ae ky" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl-bool-query.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">布尔查询</strong> </a> <strong class="lb iu">将其他查询组合在一起。</strong>它是最重要的复合查询。</p><p id="d630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">布尔查询允许您将查询上下文中的搜索与过滤上下文搜索相结合。</p><p id="9b01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">布尔查询有四个可以组合在一起的事件(类型):</p><ul class=""><li id="7294" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated"><code class="fe of og oh oi b">must</code>或“必须满足条款”</li><li id="c682" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe of og oh oi b">should</code>或“如果满足条款，相关性分数的附加分数”</li><li id="8394" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe of og oh oi b">filter</code>或“必须满足该条款，但不计算相关性分数”</li><li id="44a9" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe of og oh oi b">must_not</code>或“与必须成反比，对相关性得分没有贡献”</li></ul><p id="54ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">must</code>和<code class="fe of og oh oi b">should</code> → <strong class="lb iu">查询上下文</strong></p><p id="c241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">filter</code>和<code class="fe of og oh oi b">must_not</code> → <strong class="lb iu">过滤上下文</strong></p><p id="8726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于熟悉SQL的人来说<code class="fe of og oh oi b">must</code>是<code class="fe of og oh oi b">AND</code>而<code class="fe of og oh oi b">should</code>是<code class="fe of og oh oi b">OR</code>运算符。因此，必须满足<code class="fe of og oh oi b">must</code>子句中的每个查询。</p><h2 id="4bfe" class="nh ni it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">提升查询</h2><p id="339b" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">对于大多数查询来说，Boosting查询类似于<code class="fe of og oh oi b">boost</code>参数，但并不相同。提升查询返回匹配<code class="fe of og oh oi b">positive</code>子句的文档，并降低匹配<code class="fe of og oh oi b">negative</code>子句的文档的分数。</p><h2 id="ec53" class="nh ni it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">常数分数查询</h2><p id="df1d" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">正如我们在前面的<code class="fe of og oh oi b">term</code>查询示例中看到的，<code class="fe of og oh oi b">constant_score</code>查询将任何查询转换成关联分数等于<code class="fe of og oh oi b">boost</code>参数(默认为1)的过滤上下文。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="966a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">总结一下</strong>，Elasticsearch适合现在很多用途，有时候很难理解什么是最好用的工具。</p><p id="6064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您记住的主要一点是，您并不总是需要使用最先进的功能来解决简单的问题。</p><p id="1d81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不需要相关性分数来检索数据，请尝试切换到过滤器上下文。</p><p id="e280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，理解Elasticsearch如何在幕后工作是至关重要的，因此我建议您始终了解您的分析器是做什么的。</p><p id="0b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Elasticsearch中有更多的查询类型。我试着描述一下用得最多的。我希望你喜欢它。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="a766" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我知道你是否愿意阅读另一个帖子，在那里我给出了所有问题的真实例子。</p><p id="b5ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我计划在Elasticsearch上发布更多帖子，所以不要错过。</p><p id="bd6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个相当长的，所以如果你到了那里:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt pg oi ph pi aw pj bi"><span id="b71a" class="nh ni it oi b gy pk pl l pm pn">About me</span><span id="5270" class="nh ni it oi b gy pu pl l pm pn">My name is Artem, I build <a class="ae ky" href="https://newscatcherapi.com/" rel="noopener ugc nofollow" target="_blank">newscatcherapi.com</a> - ultra-fast API to find news articles by any topic, country, language, website, or keyword.</span><span id="5709" class="nh ni it oi b gy pu pl l pm pn">I write about Python, cloud architecture, elasticsearch, data engineering, and entrepreneurship.</span></pre></div></div>    
</body>
</html>