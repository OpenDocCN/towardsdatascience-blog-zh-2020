<html>
<head>
<title>Table Design Best Practices for ETL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">表 ETL 的设计最佳实践</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/table-design-best-practices-for-etl-200accee9cc9?source=collection_archive---------33-----------------------#2020-08-19">https://towardsdatascience.com/table-design-best-practices-for-etl-200accee9cc9?source=collection_archive---------33-----------------------#2020-08-19</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/9d620be7d258efe67ae34f5488f43b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNRmZb0AOl9FUYCfp-X6AA.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated"><a class="ae jh" href="https://unsplash.com/@realaxer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">田宽</a>在<a class="ae jh" href="https://unsplash.com/s/photos/pipeline?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><div class=""/><div class=""><h2 id="4738" class="pw-subtitle-paragraph kh jj jk bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">如何为 ETL 管道设计源系统表</h2></div><p id="48bc" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">不久以前，在源系统(应用程序数据库)中设计表的方法曾经是——我们不关心 ETL。弄清楚后，我们将专注于构建应用程序。过去几年是 ETL 方法发展的大好时光，许多开源工具来自一些大型科技公司，如 Airbnb、LinkedIn、Google、脸书等等。随着云成为主流，Azure、谷歌和微软等提供商已经确保他们构建并支持数据工程领域的所有开源技术。</p><p id="ef44" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我参与过许多 ETL 项目，其中一些失败得很惨，其余的都成功了。ETL 项目出错的方式有很多。我们今天将讨论最重要的一个方面——源系统中的表设计。</p><blockquote class="lv"><p id="1edd" class="lw lx jk bd ly lz ma mb mc md me lu dk translated">ETL 管道和构建它们的源系统一样好。</p></blockquote><p id="6bfd" class="pw-post-body-paragraph kz la jk lb b lc mf kl le lf mg ko lh li mh lk ll lm mi lo lp lq mj ls lt lu in bi translated">不管在 ETL 管道的 T 层做了多少努力，这个说法都是完全正确的。转换层通常被误解为修复应用程序和应用程序生成的数据的所有错误的层。这绝对不是真的。不多说了，让我们看看在设计将要被 ETL 到目标系统的表时，您应该考虑的最低要求——</p><h1 id="194a" class="mk ml jk bd mm mn mo mp mq mr ms mt mu kq mv kr mw kt mx ku my kw mz kx na nb bi translated"><strong class="ak">强制唯一性</strong></h1><p id="2fb9" class="pw-post-body-paragraph kz la jk lb b lc nc kl le lf nd ko lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">这一点应该不说，但我看到系统也没有强制执行(作为设计的一部分)。唯一键本质上是单列还是组合并不重要。但是，可能会要求用户在没有惟一键的情况下对表进行满负荷，并在每次满负荷后推断出变化。这个解决方案实际上比听起来更糟糕。</p><h1 id="0171" class="mk ml jk bd mm mn mo mp mq mr ms mt mu kq mv kr mw kt mx ku my kw mz kx na nb bi translated"><strong class="ak">启用增量 ETL </strong></h1><p id="7061" class="pw-post-body-paragraph kz la jk lb b lc nc kl le lf nd ko lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">使数据工程师能够通过访问<code class="fe nh ni nj nk b">created_timestamp</code>和<code class="fe nh ni nj nk b">updated_timestamp</code>等简单字段来识别新的和更新的记录。确保这两个字段都是由数据库而不是应用程序填充的。如果要从应用程序中填充日期时间或时间戳字段，应该有一个单独的日期时间或时间戳字段。这些应该被定义为—</p><pre class="nl nm nn no gu np nk nq nr aw ns bi"><span id="6e29" class="nt ml jk nk b gz nu nv l nw nx">1. created_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP<br/>2. updated_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</span></pre><p id="8693" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">只追加主键总是递增的表可以正常工作。您不需要为这些设置审计时间戳列。</p><h1 id="e4e5" class="mk ml jk bd mm mn mo mp mq mr ms mt mu kq mv kr mw kt mx ku my kw mz kx na nb bi translated"><strong class="ak">定义&amp;记录关系</strong></h1><p id="fb8f" class="pw-post-body-paragraph kz la jk lb b lc nc kl le lf nd ko lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">在大多数情况下，我们将关系数据库作为源系统来处理。因此，理解源系统中的数据流和沿袭是非常重要的。在大多数情况下，负载的目标系统中的数据流和沿袭保持不变，尽管这不是强制性的。这里有两件事会有帮助——来自产生数据的应用程序的服务架构图和源数据库的 ER 图。</p><h1 id="b28f" class="mk ml jk bd mm mn mo mp mq mr ms mt mu kq mv kr mw kt mx ku my kw mz kx na nb bi translated">那又怎样？</h1><p id="a91e" class="pw-post-body-paragraph kz la jk lb b lc nc kl le lf nd ko lh li ne lk ll lm nf lo lp lq ng ls lt lu in bi translated">所有这些问题都可以被完全或部分解决，即使这些点在源系统中没有被注意到，但是没有一个解决方案是可持续的。是的，这就是开始构建一个整洁的 ETL 管道所需要的一切。</p><p id="e9fb" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">作为一个规则，ETL 系统的任务应该仅仅是通过一个通用的转换层将数据从一个地方移动到另一个地方(这个层不处理 bug，特殊的一次性情况)。记住垃圾进垃圾出的普遍原则——如果源系统中有错误的数据，那么目标系统也会有错误的数据。</p><p id="6b34" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我在很多地方看到的一个实践是，数据团队试图修补有问题的数据，并暂时处理它。它通常会一直工作到冲刺阶段结束，而同样的问题总是会回来困扰你。抵制诱惑，不要养成像这样解决问题的习惯。正确的做法是报告问题，修复源系统中的数据，并在有问题的时间段内进行干净的重新加载。与显示在应用程序 UI 和 data BI 仪表板上的不同数据相比，重新加载更容易证明。</p><h1 id="a443" class="mk ml jk bd mm mn mo mp mq mr ms mt mu kq mv kr mw kt mx ku my kw mz kx na nb bi translated"><strong class="ak">参考文献</strong></h1><div class="it iu gq gs iv ny"><a href="https://medium.com/@rchang/a-beginners-guide-to-data-engineering-part-ii-47c4e7cbda71" rel="noopener follow" target="_blank"><div class="nz ab fp"><div class="oa ab ob cl cj oc"><h2 class="bd jl gz z fq od fs ft oe fv fx jj bi translated">数据工程初学者指南—第二部分</h2><div class="of l"><h3 class="bd b gz z fq od fs ft oe fv fx dk translated">数据建模、数据分区、流程和 ETL 最佳实践</h3></div><div class="og l"><p class="bd b dl z fq od fs ft oe fv fx dk translated">medium.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om jb ny"/></div></div></a></div><div class="it iu gq gs iv ny"><a href="https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fp"><div class="oa ab ob cl cj oc"><h2 class="bd jl gz z fq od fs ft oe fv fx jj bi translated">设计数据密集型应用程序</h2><div class="of l"><h3 class="bd b gz z fq od fs ft oe fv fx dk translated">数据是当今系统设计中许多挑战的核心。困难的问题需要解决，例如…</h3></div><div class="og l"><p class="bd b dl z fq od fs ft oe fv fx dk translated">www.oreilly.com</p></div></div><div class="oh l"><div class="on l oj ok ol oh om jb ny"/></div></div></a></div><div class="it iu gq gs iv ny"><a href="https://www.timmitchell.net/post/2017/01/10/why-data-warehouse-projects-fail/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fp"><div class="oa ab ob cl cj oc"><h2 class="bd jl gz z fq od fs ft oe fv fx jj bi translated">为什么数据仓库项目会失败</h2><div class="of l"><h3 class="bd b gz z fq od fs ft oe fv fx dk translated">数据仓库项目是组织可以采取的最明显和最昂贵的计划之一。可悲的是，他们…</h3></div><div class="og l"><p class="bd b dl z fq od fs ft oe fv fx dk translated">www.timmitchell.net</p></div></div><div class="oh l"><div class="oo l oj ok ol oh om jb ny"/></div></div></a></div></div></div>    
</body>
</html>