<html>
<head>
<title>Using Scikit-learn’s Binary Trees to Efficiently Find Latitude and Longitude Neighbors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Scikit-learn 的二叉树有效地查找经纬度邻居</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-scikit-learns-binary-trees-to-efficiently-find-latitude-and-longitude-neighbors-909979bd929b?source=collection_archive---------4-----------------------#2020-09-03">https://towardsdatascience.com/using-scikit-learns-binary-trees-to-efficiently-find-latitude-and-longitude-neighbors-909979bd929b?source=collection_archive---------4-----------------------#2020-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7eb5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在不破坏 Python 解释器的情况下将多组 GPS 坐标连接在一起</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e31b3f2ff05946455cfdc6afd6c25521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LGBlcBzaqETabxsVZLE5eQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://pixabay.com/users/mohamed_hassan-5229782/" rel="noopener ugc nofollow" target="_blank">穆罕默德·哈桑</a>来自<a class="ae kv" href="https://pixabay.com/illustrations/car-trip-road-trip-travel-map-3880508/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="f2ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自纬度和经度数据的工程特征看起来像是一项杂乱的任务，可能会诱使新手创建自己的<a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">应用函数</em> </strong> </a>(或者更糟:一个巨大的<a class="ae kv" href="https://www.w3schools.com/python/python_for_loops.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> for 循环</strong> </a>)。然而，这些类型的<a class="ae kv" href="https://www.freecodecamp.org/news/brute-force-algorithms-explained/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">强力</em> </strong> </a>方法是潜在的陷阱，当数据集的大小增加时，这些陷阱会很快暴露出来。</p><p id="4b78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:假设您有一个包含<em class="ls"> n </em>项的数据集。将这些<em class="ls"> n </em>项与<em class="ls"> n-1 </em>其他项进行显式比较所需的时间基本上接近<em class="ls"> n </em>。这意味着数据集中的行每增加一倍，查找所有最近邻的时间就会增加 4 倍！ </p><p id="00b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，你不需要计算每个点之间的距离。在<a class="ae kv" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">scikit-learn</em></strong></a>中有一些数据结构可以有效地确定邻居权限，这些数据结构利用了<a class="ae kv" href="https://algs4.cs.princeton.edu/24pq/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">优先级队列</em> </strong> </a>的力量。</p><p id="c41f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们可以在邻居模块 中找到<a class="ae kv" href="https://scikit-learn.org/stable/modules/neighbors.html#nearest-neighbor-algorithms" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">，本指南将向您展示如何使用这些难以置信的类中的两个来轻松解决这个问题。</strong></a></p><h1 id="01ee" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">入门指南</h1><p id="8975" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，我们加载库。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7bcf" class="mv lu iq mr b gy mw mx l my mz">import numpy as np<br/>from sklearn.neighbors import BallTree, KDTree</span><span id="fdf1" class="mv lu iq mr b gy na mx l my mz"># This guide uses Pandas for increased clarity, but these processes<br/># can be done just as easily using only scikit-learn and NumPy.<br/>import pandas as pd</span></pre><p id="f2a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们将根据从<a class="ae kv" href="https://www.ncdc.noaa.gov/data-access/land-based-station-data" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"/></a><strong class="ky ir">国家海洋和大气管理局公开获得的气象站位置制作两个样本数据框架。</strong></p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="062d" class="mv lu iq mr b gy mw mx l my mz"># Column names for the example DataFrame.<br/>column_names = ["STATION NAME", "LAT", "LON"]</span><span id="3430" class="mv lu iq mr b gy na mx l my mz"># A list of locations that will be used to construct the binary<br/># tree.<br/>locations_a = [['BEAUFORT', 32.4, -80.633],<br/>       ['CONWAY HORRY COUNTY AIRPORT', 33.828, -79.122],<br/>       ['HUSTON/EXECUTIVE', 29.8, -95.9],<br/>       ['ELIZABETHTON MUNI', 36.371, -82.173],<br/>       ['JACK BARSTOW AIRPORT', 43.663, -84.261],<br/>       ['MARLBORO CO JETPORT H E AVENT', 34.622, -79.734],<br/>       ['SUMMERVILLE AIRPORT', 33.063, -80.279]]</span><span id="417f" class="mv lu iq mr b gy na mx l my mz"># A list of locations that will be used to construct the queries.<br/># for neighbors.<br/>locations_b = [['BOOMVANG HELIPORT / OIL PLATFORM', 27.35, -94.633],<br/>       ['LEE COUNTY AIRPORT', 36.654, -83.218],<br/>       ['ELLINGTON', 35.507, -86.804],<br/>       ['LAWRENCEVILLE BRUNSWICK MUNI', 36.773, -77.794],<br/>       ['PUTNAM CO', 39.63, -86.814]]</span><span id="3d5e" class="mv lu iq mr b gy na mx l my mz"># Converting the lists to DataFrames. We will build the tree with<br/># the first and execute the query on the second.<br/>locations_a = pd.DataFrame(locations_a, columns = column_names)<br/>locations_b = pd.DataFrame(locations_b, columns = column_names)</span></pre><p id="3ad4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这创建了两个极小的数据帧:一个有 7 行，一个有 4 行。对于这么小的数据集，我们将要使用的数据结构不会在性能上提供任何帮助(实际上会是一个障碍)。<a class="ae kv" href="https://scikit-learn.org/stable/modules/neighbors.html#nearest-neighbor-algorithms" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">文档</strong> </a>提供了更多关于何时选择一种算法比另一种算法更有利的信息。</p><h1 id="b1df" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用 k-d 树</h1><p id="a5d7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们先用一棵<a class="ae kv" href="https://en.wikipedia.org/wiki/K-d_tree" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls"> k-d 树</em> </strong> </a>来演示。它会将数据点分割成二叉树，每次评估一个维度，并在中间值上进行分割。然后，将使用另一组点和值 k 对其执行查询，以确定每个点要返回多少个相邻点。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1010" class="mv lu iq mr b gy mw mx l my mz"># Takes the first group's latitude and longitude values to construct<br/># the kd tree.<br/>kd = KDTree(locations_a[["LAT", "LON"]].values, metric='euclidean')</span><span id="307b" class="mv lu iq mr b gy na mx l my mz"># The amount of neighbors to return.<br/>k = 2</span><span id="a771" class="mv lu iq mr b gy na mx l my mz"># Executes a query with the second group. This will return two<br/># arrays.<br/>distances, indices = kd.query(locations_b[["LAT", "LON"]], k = k)</span></pre><p id="8830" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果是两个数组。一个用于距离，一个包含相邻位置的索引(指用于构建树的数据帧)。</p><p id="eba1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，索引可以被<a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.map.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">映射到</em> </strong> </a>到有用的值，并且两个数组容易地<a class="ae kv" href="https://pandas.pydata.org/docs/user_guide/merging.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">与其余数据合并</em> </strong> </a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/6e13488343819c1ee564e4f62347a917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YDuZSNo9IOVhaZ5KHiu0wA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示的距离是原始坐标之间的欧几里德距离。</p></figure><h2 id="7beb" class="mv lu iq bd lv nc nd dn lz ne nf dp md lf ng nh mf lj ni nj mh ln nk nl mj nm bi translated">一些限制</h2><p id="4f14" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">k-d 树在没有大量维度的情况下表现很好。虽然这似乎适合这里的数据；在纬度和经度的情况下，基于欧几里德距离的差异进行评估将会以精度为代价。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/68ea8077c5bba40020c53c3762953aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5jIPfcdli5Q3t5reMhHEkQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://pixabay.com/illustrations/globe-earth-magnifying-glass-hand-71443/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kv" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a></p></figure><p id="341c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更接近地近似坐标间的实际距离，我们可以使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Haversine_formula" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls"/></strong></a>。不幸的是，k-d 树算法对此不起作用，因为它对于每个维度都有一种有点僵硬的方法。要查看哪些可用的距离度量可用于 k-d 树数据结构，请使用以下命令:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b832" class="mv lu iq mr b gy mw mx l my mz">KDTree.valid_metrics</span></pre><h1 id="d4de" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用球树</h1><p id="2051" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Ball_tree" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">球树</em> </strong> </a>类似于一个 k-d 树，除了它不是在一个单独的维度上进行划分，而是根据到中心的径向距离来划分点。它能更好地处理更高维度的数据，也允许使用哈弗斯度规。</p><p id="3392" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要在 scikit-learn 中使用具有哈弗线距离的球树，必须首先将坐标从角度转换为弧度。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8ac5" class="mv lu iq mr b gy mw mx l my mz"># Creates new columns converting coordinate degrees to radians.<br/>for column in locations_a[["LAT", "LON"]]:<br/>    rad = np.deg2rad(locations_a[column].values)<br/>    locations_a[f'{column}_rad'] = rad<br/>for column in locations_b[["LAT", "LON"]]:<br/>    rad = np.deg2rad(locations_b[column].values)<br/>    locations_b[f'{column}_rad'] = rad</span></pre><p id="add6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，这两个 API 几乎是相同的，并且大部分过程将在最小的修改下重复。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="4cbb" class="mv lu iq mr b gy mw mx l my mz"># Takes the first group's latitude and longitude values to construct<br/># the ball tree.<br/>ball = BallTree(locations_a[["LAT_rad", "LON_rad"]].values, metric='haversine')</span><span id="d4be" class="mv lu iq mr b gy na mx l my mz"># The amount of neighbors to return.<br/>k = 2</span><span id="8657" class="mv lu iq mr b gy na mx l my mz"># Executes a query with the second group. This will also return two<br/># arrays.<br/>distances, indices = ball.query(locations_b[["LAT_rad", "LON_rad"]].values, k = k)</span></pre><p id="5f10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">最后一点注意:</strong>返回的距离将基于半径为 1 的<a class="ae kv" href="https://en.wikipedia.org/wiki/Unit_sphere" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">单位球体</em> </strong> </a>。如果您想查看反映典型测量值的值，这是一个简单的转换。</p><ul class=""><li id="1c4e" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated"><strong class="ky ir">到英里:</strong>距离 x 3,958.8(地球的半径以英里为单位)</li><li id="d722" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><strong class="ky ir">到千米:</strong>距离 x 6,371(地球半径以千米为单位)</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/0abe45f45f964978d62aa69734f6d8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0TINkL7Az9JU3Tp7abO8Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">以英里为单位的最终数据帧。</p></figure><p id="f18a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中只有 12 个数据点，使用具有哈弗斯度量的球树的优势无法显示。但是在一个更大的稀疏度更低的数据集中，这将是你在用纬度和经度进行评估时想要做出的选择。</p><p id="2ba0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这两种算法都不仅限于这种用例，此处显示的步骤可以扩展到可以通过多种距离度量之一排序的任何一组要素。</p><p id="9964" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们建模的复杂系统有无数的影响因素，这些因素导致了数据科学家们一直在努力减少的误差水平。有了这些工具，您将更有能力有效地发现其他因素，并将特征工程提升到一个新的水平。</p></div></div>    
</body>
</html>