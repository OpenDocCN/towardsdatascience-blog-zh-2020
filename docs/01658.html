<html>
<head>
<title>Tour of Python Itertools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Itertools之旅</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tour-of-python-itertools-2af84db18a5e?source=collection_archive---------3-----------------------#2020-02-15">https://towardsdatascience.com/tour-of-python-itertools-2af84db18a5e?source=collection_archive---------3-----------------------#2020-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bb7d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们探索两个伟大的Python库——ITER tools和more_itertools，看看如何利用它们进行数据处理…</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5177c3018ecd24f0cc9df8c9a7bfe2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aT_slIuZQ9Gmf6GOyugflQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">特雷弗·科尔在<a class="ae ky" href="https://unsplash.com/s/photos/snake?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="57d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多很棒的Python库，但大多数都无法与内置的<code class="fe lv lw lx ly b">itertools</code>和<code class="fe lv lw lx ly b">more-itertools</code>相提并论。当涉及到在Python中处理/迭代一些数据时，这两个库实际上是整个厨房水池。然而，乍一看，这些库中的函数似乎并不那么有用，所以让我们来看看(在我看来)最有趣的函数，包括如何充分利用它们的例子！</p><h1 id="a2b4" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">压缩</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="45d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当涉及到过滤序列时，您有相当多的选项，其中之一是<code class="fe lv lw lx ly b">compress</code>，它采用iterable和boolean选择器，并输出iterable的项目，其中选择器中对应的元素是<code class="fe lv lw lx ly b">True</code>。</p><p id="7816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用它将一个序列的过滤结果应用到另一个序列，就像上面的例子一样，我们创建了一个日期列表，其中对应的计数大于3。</p><h1 id="ccdd" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">积聚</h1><p id="1bc2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">顾名思义——我们将使用这个函数来累加一些(二元)函数的结果。这方面的例子可以是运行最大值或阶乘:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="55e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不关心中间结果，您可以使用<code class="fe lv lw lx ly b">functools.reduce</code>(在其他语言中称为<code class="fe lv lw lx ly b">fold</code>)，它只保留最终值，并且内存效率更高。</p><h1 id="9f6f" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">循环</h1><p id="e6d4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个函数采用iterable并从中创建无限循环。例如，在游戏中，玩家轮流游戏，这是很有用的。你可以用<code class="fe lv lw lx ly b">cycle</code>做的另一件很酷的事情是创建简单的无限旋转器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="5ad9" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">三通</h1><p id="f17f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">来自<code class="fe lv lw lx ly b">itertools</code>模块的最后一个是<code class="fe lv lw lx ly b">tee</code>，这个函数从一个迭代器创建多个迭代器，这允许我们<em class="lz">记住</em>发生了什么。例如来自<em class="lz"> itertools recipes </em>(还有<code class="fe lv lw lx ly b">more_itertools</code>)的<code class="fe lv lw lx ly b">pairwise</code>函数，它从输入iterable返回成对的值(当前值和前一个值):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="825e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当您需要指向同一数据流的多个单独指针时，这个函数就非常方便。不过在使用它的时候要小心，因为它在内存方面的开销非常大。同样需要注意的是，在对原始iterable使用了<code class="fe lv lw lx ly b">tee</code>之后，不应该再使用它，因为它会弄乱(无意中推进)那些新的<code class="fe lv lw lx ly b">tee</code>对象。</p><h1 id="5f6b" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">更多_itertools</h1><p id="21fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，让我们仔细看看<code class="fe lv lw lx ly b">more_itertools</code>图书馆提供了什么，因为有许多有趣的功能，你可能没有听说过。</p><h2 id="24c6" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">划分</h2><p id="a6e4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从<code class="fe lv lw lx ly b">more_itertools</code>开始的第一个是<code class="fe lv lw lx ly b">divide</code>。顾名思义，它将iterable分成若干个子iterable。正如你在下面的例子中看到的，子元素的长度可能不一样，因为它取决于被划分的元素的数量和子元素的数量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="d049" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">划分</h2><p id="3fd8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用这个函数，我们也将划分我们的iterable，但是这次使用一个<em class="lz">谓词</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的第一个例子中，我们使用简单的<em class="lz"> lambda </em>函数将日期列表分为最近的和旧的。对于第二个例子，我们基于扩展名对文件进行分区，同样使用<em class="lz"> lambda </em>函数，该函数将文件名分为名称和扩展名，并检查扩展名是否在允许的列表中。</p><h2 id="538a" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">连续组</h2><p id="84d8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您需要查找连续的数字、日期、字母、布尔或任何其他可排序的对象，那么您可能会发现<code class="fe lv lw lx ly b">consecutive_groups</code>很方便:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="587b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们有一个日期列表，其中一些日期是连续的。为了能够将这些日期传递给<code class="fe lv lw lx ly b">consecutive_groups</code>函数，我们首先必须将它们转换成序数。然后使用列表理解，我们迭代由<code class="fe lv lw lx ly b">consecutive_groups</code>创建的连续序数日期组，并使用<code class="fe lv lw lx ly b">map</code>和<code class="fe lv lw lx ly b">fromordinal</code>函数将它们转换回<code class="fe lv lw lx ly b">datetime.datetime</code>。</p><h2 id="9906" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">副作用</h2><p id="e078" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设您需要在迭代条目列表时产生副作用。这种副作用可能是，例如，写入日志、写入文件或类似于以下示例中计数发生的事件数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="313f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们声明了一个简单的函数，它将在每次被调用时递增一个计数器。然后，这个函数和名为<code class="fe lv lw lx ly b">events</code>的非特定iterable一起传递给<code class="fe lv lw lx ly b">side_effect</code>。稍后当事件迭代器被使用时，它将为每一项调用<code class="fe lv lw lx ly b">increment_num_events</code>,给我们最终的事件计数。</p><h2 id="7261" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">倒塌</h2><p id="f23c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是另一个名为<code class="fe lv lw lx ly b">flatten</code>的<code class="fe lv lw lx ly b">more_itertools</code>函数的更强大版本。<code class="fe lv lw lx ly b">collapse</code>允许你展平多层嵌套。它还允许您指定基本类型，以便您可以在剩余一层列表/元组的情况下停止扁平化。此功能的一个用例是展平<em class="lz">熊猫</em>T3】。以下是一些更通用的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1bd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个通过折叠<code class="fe lv lw lx ly b">os.walk</code>返回的可重复项来生成文件和目录路径的列表。在第二种方法中，我们采用嵌套列表形式的树数据结构，并将其折叠以获得所述树的所有节点的平面列表。</p><h2 id="eff7" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">拆分_at</h2><p id="41cf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">回到拆分数据。<code class="fe lv lw lx ly b">split_at</code>函数根据谓词将iterable拆分成列表。这类似于字符串的基本<code class="fe lv lw lx ly b">split</code>,但是这里我们用iterable代替字符串，用谓词函数代替分隔符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面，我们使用行列表来模拟文本文件。该<em class="lz">“文本文件”</em>包含带有<code class="fe lv lw lx ly b">-------------</code>的行，用作分隔符。这就是我们用来把这些行分割成独立列表的谓词。</p><h2 id="5d4f" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">水桶</h2><p id="5746" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您需要根据某种条件将iterable分成多个桶，那么<code class="fe lv lw lx ly b">bucket</code>就是您要找的。它通过使用<em class="lz">键</em>函数拆分输入可迭代对象来创建子可迭代对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="72c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们展示了如何基于条目类型存储iterable。我们首先声明几种类型的形状，并创建它们的列表。当我们用上面的<em class="lz">键</em>函数调用这个列表上的<code class="fe lv lw lx ly b">bucket</code>时，我们创建了一个<em class="lz">桶</em>对象。这个对象像内置的<em class="lz">Python</em>T10】一样支持查找。此外，正如您所看到的，整个bucket对象中的每一项都是一个生成器，因此我们需要对它调用<code class="fe lv lw lx ly b">list</code>来实际获取其中的值。</p><h2 id="77b0" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">Map_reduce</h2><p id="45bf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于所有数据科学人士来说，这个库中最有趣的函数可能就是<code class="fe lv lw lx ly b">map_reduce</code>。我不打算详细说明MapReduce如何工作，因为这不是本文的目的，已经有很多关于它的文章了。我要给你展示的是如何使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<em class="lz"> MapReduce </em>实现允许我们指定3个函数:<em class="lz"> key </em>函数(用于分类)，<em class="lz"> value </em>函数(用于转换)，最后<em class="lz"> reduce </em>函数(用于缩减)。这些函数中的一些可以省略，以产生<em class="lz"> MapReduce </em>过程中的中间步骤，如上所示。</p><h2 id="932b" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">一起排序\</h2><p id="f535" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您处理的是数据的电子表格，那么很有可能您需要按某一列对其进行排序。这对于<code class="fe lv lw lx ly b">sort_together</code>来说是一个简单的任务。它允许我们指定根据哪一列对数据进行排序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="56eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数的输入是可迭代对象(列)和<code class="fe lv lw lx ly b">key_list</code>的列表，它告诉<code class="fe lv lw lx ly b">sort_together</code>使用哪些可迭代对象进行排序以及优先级。在上述示例中，首先按出生日期<em class="lz">对<em class="lz">“表格”</em>进行排序，然后按在</em>列更新的<em class="lz">进行排序。</em></p><h2 id="46b3" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">可寻找的</h2><p id="b93f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们都喜欢迭代器，但是在Python中你应该一直小心使用它们，因为它们的一个<em class="lz">特性</em>是它们消耗提供的iterable。感谢<code class="fe lv lw lx ly b">seekable</code>，他们不必如此:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f93a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">seekable</code>是一个将iterable封装在一个对象中的函数，使得在迭代器中来回遍历成为可能，甚至在一些元素被消耗之后。在这个例子中，你可以看到我们在遍历了整个迭代器后得到了<code class="fe lv lw lx ly b">StopIteration</code>异常，但是我们可以返回并继续处理它。</p><h2 id="e3ce" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">过滤_例外</h2><p id="3e11" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们看看下面的场景:您收到了混合数据，其中包含文本和数字，并且都是字符串形式。然而，您只想处理数字(浮点数/整数):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="40a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">filter_except</code>通过将iterable的元素传递给提供的函数(<code class="fe lv lw lx ly b">float</code>)并检查它是否抛出错误(<code class="fe lv lw lx ly b">TypeError, ValueError</code>)来过滤输入iterable的项目，只保留通过检查的元素。</p><h2 id="a779" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">每个都是唯一的</h2><p id="4f2a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe lv lw lx ly b">unique_to_each</code>是<code class="fe lv lw lx ly b">more_itertools</code>库中比较晦涩的函数之一。它接受一堆iterables并从每个iterables中返回元素，这些元素不在另一个iterables中。最好看看例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/48358a7c565c6ebb1ef4626df5e855b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/0*WEbgNuKg6foxCy70"/></div></figure><p id="636e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们使用<em class="lz">邻接表</em>(实际上是<code class="fe lv lw lx ly b">dict</code>)来定义图数据结构。然后，我们将每个节点的邻居作为一个集合传递给<code class="fe lv lw lx ly b">unique_to_each</code>。它输出的是一个节点列表，如果相应的节点被删除，这些节点将被隔离。</p><h2 id="da51" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">数字_范围</h2><p id="30f3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种方法有很多用例，因为需要迭代一系列非整数值是很常见的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b2e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">numeric_range</code>的好处在于它的行为方式与基本的<code class="fe lv lw lx ly b">range</code>相同。您可以像上面的例子一样指定<code class="fe lv lw lx ly b">start</code>、<code class="fe lv lw lx ly b">stop</code>和<code class="fe lv lw lx ly b">step</code>参数，这里我们首先使用<code class="fe lv lw lx ly b">1.7</code>和<code class="fe lv lw lx ly b">3.5</code>之间的小数，步长为<code class="fe lv lw lx ly b">0.3</code>，然后使用<code class="fe lv lw lx ly b">2020/2/10</code>和<code class="fe lv lw lx ly b">2020/2/15</code>之间的日期，步长为2天。</p><h2 id="f1d2" class="mz mb it bd mc na nb dn mg nc nd dp mk li ne nf mm lm ng nh mo lq ni nj mq nk bi translated">制作_装饰</h2><p id="6074" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后但同样重要的是，<code class="fe lv lw lx ly b">make_decorator</code>使我们能够使用其他itertools作为装饰器，从而修改其他函数的输出，产生迭代器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子使用了<code class="fe lv lw lx ly b">map_except</code>函数并从中创建了decorator。这个装饰器将使用被装饰函数的结果作为它的第二个参数(<code class="fe lv lw lx ly b">result_index=1</code>)。在我们的例子中，修饰函数是<code class="fe lv lw lx ly b">read_file</code>，它模拟读取某个文件的数据，并输出一个可能是也可能不是浮点数的字符串列表。然而，输出首先被传递给decorator，它映射并过滤掉所有不需要的项目，只给我们留下浮动。</p><h1 id="209b" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结论</h1><p id="2d8b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我希望你在这篇文章中学到了一些新的东西，因为如果你经常处理大量的数据，那么<code class="fe lv lw lx ly b">itertools</code>和<code class="fe lv lw lx ly b">more_itertools</code>可以让你的生活变得更加容易。然而，使用这些库和函数需要一些练习才能有效。所以，如果你认为你可以利用这篇文章中展示的一些东西，那么就去检查一下<a class="ae ky" href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noopener ugc nofollow" target="_blank"> itertools recipes </a>或者强迫自己尽可能多地使用这些东西，以适应它。😉</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="0f99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/16" rel="noopener ugc nofollow" target="_blank"><em class="lz">martinheinz . dev</em></a></p></div></div>    
</body>
</html>