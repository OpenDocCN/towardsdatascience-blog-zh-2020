<html>
<head>
<title>Apache Sedona stands out for processing geospatial data at Scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Sedona在大规模处理地理空间数据方面表现突出</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/geospark-stands-out-for-processing-geospatial-data-at-scale-548077270ec0?source=collection_archive---------7-----------------------#2020-05-12">https://towardsdatascience.com/geospark-stands-out-for-processing-geospatial-data-at-scale-548077270ec0?source=collection_archive---------7-----------------------#2020-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b3d8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">空间数据洪流</h2></div><p id="1be9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在过去十年中，可用的地理空间数据量大幅增加。这些数据包括但不限于:天气地图、社会经济数据和地理标记的社交媒体。例如，美国国家航空航天局的宇宙飞船一直在监测地球的状况，包括陆地温度、大气湿度。截至今天，美国宇航局已经发布了超过22PB的卫星数据。今天，我们在全球拥有近50亿台移动设备。因此，移动应用程序产生了大量的网络视频数据。例如，Lyft、优步和摩拜单车每天从数百万骑行者那里收集万亿字节的GPS数据。事实上，我们在移动设备上所做的一切都会在地球表面留下数字痕迹。此外，配备GPS的移动设备和物联网(IoT)传感器的前所未有的普及，导致不断产生结合周围环境状态的大规模位置信息。例如，一些城市已经开始在十字路口安装传感器，以监测环境、交通和空气质量。</p><p id="2ed1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理解隐藏在数据中的丰富的地理空间属性可能会极大地改变我们的社会。这包括许多正在进行深入研究的课题，如气候变化分析、森林砍伐研究、人口迁移、疫情扩散分析、城市规划、交通、商业和广告。这些数据密集型地理空间分析应用高度依赖底层数据管理系统(DBMSs)来高效地检索、处理、争论和管理数据。</p><h1 id="31ee" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">阿帕奇塞多纳(前GeoSpark)概述</h1><p id="5fd8" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">Apache Sedona(以前的GeoSpark)(http://sedona.apache.org)是一个集群计算框架，可以大规模处理地理空间数据。GeoSpark扩展了Apache Spark中的核心数据结构弹性分布式数据集(RDD ),以在集群中容纳大地理空间数据。SpatialRDD由分布在Spark集群中的数据分区组成。空间RDD可以通过RDD变换创建，也可以从永久存储的文件中加载。该层提供了许多API，允许用户从各种数据格式中读取异构空间对象。</p><p id="c906" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GeoSpark允许用户使用现成的空间SQL API和RDD API进行查询。RDD API提供了一组用操作编程语言编写的接口，包括Scala、Java、Python和r。空间SQL接口为用户提供了一个声明性语言接口，因此他们在创建自己的应用程序时可以享受更多的灵活性。这些SQL API实现了SQL/MM Part 3标准，该标准广泛用于许多现有的空间数据库，如PostGIS(在PostgreSQL之上)。接下来，我们将展示如何使用GeoSpark。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/25dea2bd75f62683119093b058ca2e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*tdyvghDo3tZTO_QBglPiBw.png"/></div></figure><h1 id="e9a7" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">Apache Sedona中支持的空间数据源</h1><p id="2508" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">过去，研究人员和从业人员开发了许多用于不同目的的地理空间数据格式。然而，异构数据源使得将地理空间数据集成在一起极其困难。例如，WKT格式是一种广泛使用的空间数据格式，它将数据存储在人类可读的制表符分隔值文件中。Shapefile是一个空间数据库文件，它包括多个子文件，如索引文件和非空间属性文件。此外，地理空间数据通常具有不同的形状，如点、多边形和轨迹。</p><p id="6be8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目前，Sedona (GeoSpark)可以从本地磁盘、亚马逊S3和Hadoop分布式文件系统(HDFS)等不同的外部存储系统中读取WKT、WKB、GeoJSON、Shapefile和NetCDF / HDF格式的数据到空间RDDs。空间RDDs现在可以容纳七种类型的空间数据，包括点、多点、面、多面、线串、多线串、几何集合和圆。此外，具有不同形状的空间对象可以共存于同一空间RDD中，因为Sedona采用了灵活的设计，该设计概括了不同空间对象的几何计算接口。</p><p id="836c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">空间RDD内置几何库:</strong>空间数据科学家需要在Apache Sedona中挖掘空间对象的一些几何属性，比如周长、面积、交集，这是相当常见的。空间RDD配备了一个内置的几何库来执行大规模的几何运算，因此用户不会涉及复杂的计算几何问题。目前，系统在该库中提供了20多种不同的功能，并将它们分为两个不同的类别</p><p id="f01e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">常规几何函数应用于空间RDD中的每个空间对象。对于每个对象，它都会生成相应的结果，如周长或面积。输出必须是常规RDD或空间RDD。</p><p id="c2e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">几何聚合函数应用于空间RDD以生成聚合值。它只为整个空间RDD生成单个值或空间对象。例如，系统可以计算整个空间RDD的边界框或多边形并集。</p><h1 id="9113" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">使用RDD API运行查询</h1><p id="1264" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">这里，我们概述了使用GeoSpark RDD API创建空间RDD和运行空间查询的步骤。示例代码是用Scala编写的，但也适用于Java。</p><p id="48b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">设置依赖关系:</strong>在开始使用Apache Sedona(即GeoSpark)之前，用户必须将相应的包作为依赖关系添加到他们的项目中。为了便于管理依赖项，GeoSpark的二进制包托管在Maven中央存储库中，该存储库包含了全世界所有基于JVM的包。只要项目由Apache Maven和sbt等流行的项目管理工具管理，用户就可以通过在POM.xml和build.sbt等项目规范文件中添加工件id来轻松添加Apache Sedona。</p><p id="a7c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">初始化Spark Context:</strong>Spark或Apache Sedona中的任何RDD都必须由Spark Context创建。因此，GeoSpark应用程序的第一项任务是启动SparkContext。下面的代码片段给出了一个例子。为了使用自定义空间对象和索引序列化程序，用户必须在SparkContext中启用它们。</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="1b44" class="mo lf it mk b gy mp mq l mr ms">val conf = new SparkConf()</span><span id="8612" class="mo lf it mk b gy mt mq l mr ms">conf.setAppName(“GeoSparkExample”)</span><span id="5c06" class="mo lf it mk b gy mt mq l mr ms">// Enable GeoSpark custom Kryo serializer<br/>conf.set(“spark.serializer”, classOf[KryoSerializer].getName)</span><span id="672a" class="mo lf it mk b gy mt mq l mr ms">conf.set(“spark.kryo.registrator”, classOf[GeoSparkKryoRegistrator].getName)</span><span id="a549" class="mo lf it mk b gy mt mq l mr ms">val sc = new SparkContext(conf)</span></pre><p id="9017" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">创建一个空间RDD:</strong>Spatial rdd中的空间对象并不局限于某种几何类型，而是对更多的场景开放。它允许包含混合类型几何图形的输入数据文件。例如，WKT文件可能包括三种类型的空间对象，如线串、多边形和多重多边形。目前，该系统可以加载许多不同数据格式的数据。这是由一组文件阅读器完成的，如WktReader和GeoJsonReader。例如，用户可以调用ShapefileReader来读取ESRI形状文件。</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="a13a" class="mo lf it mk b gy mp mq l mr ms">val spatialRDD = ShapefileReader.readToGeometryRDD(sc, filePath)</span></pre><p id="c7e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">变换坐标参考系统:</strong> Apache Sedona不控制空间RDD中对象的坐标单位(即基于度数或基于米)。计算两个坐标之间的距离时，GeoSpark只需计算欧几里得距离。在实践中，如果用户想要获得精确的地理空间距离，他们需要将坐标从基于度数的坐标参考系统(CRS)，即WGS84，转换到平面坐标参考系统(即EPSG: 3857)。GeoSpark为用户提供了这一功能，使他们可以对空间RDD中的每个对象执行这一转换，并使用集群扩展工作负载。</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="a63d" class="mo lf it mk b gy mp mq l mr ms">// epsg:4326: is WGS84, the most common degree-based CRS</span><span id="8916" class="mo lf it mk b gy mt mq l mr ms">val sourceCrsCode = “epsg:4326"</span><span id="780e" class="mo lf it mk b gy mt mq l mr ms"> // epsg:3857: The most common meter-based CRS</span><span id="6755" class="mo lf it mk b gy mt mq l mr ms">val targetCrsCode = “epsg:3857"</span><span id="42a5" class="mo lf it mk b gy mt mq l mr ms">objectRDD.CRSTransform(sourceCrsCode, targetCrsCode)</span></pre><p id="6da4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">构建空间索引:</strong>用户可以调用API在空间RDD上构建分布式空间索引。目前，系统提供两种类型的空间索引，四叉树和R树，作为每个分区上的本地索引。这一步的代码如下:</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="b98a" class="mo lf it mk b gy mp mq l mr ms">spatialRDD.buildIndex(IndexType.QUADTREE, false) // Set to true only if the index will be used join query</span></pre><p id="d942" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">编写一个空间范围查询:</strong>空间范围查询返回位于一个地理区域内的所有空间对象。例如，范围查询可能会找到菲尼克斯大都市地区的所有公园，或者返回用户当前位置一英里范围内的所有餐馆。就格式而言，空间范围查询以一组空间对象和一个多边形查询窗口作为输入，并返回位于查询区域内的所有空间对象。空间范围查询将范围查询窗口和空间RDD作为输入，并返回与查询窗口相交/被查询窗口完全覆盖的所有几何。假设用户拥有空间RDD。他或她可以使用以下代码对该空间RDD发出空间范围查询。空间范围查询的输出格式是另一种空间RDD。</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="7b49" class="mo lf it mk b gy mp mq l mr ms">val rangeQueryWindow = new Envelope(-90.01, -80.01, 30.01, 40.01)</span><span id="9708" class="mo lf it mk b gy mt mq l mr ms"> /*If true, return gemeotries intersect or are fully covered by the window; If false, only return the latter. */</span><span id="d12a" class="mo lf it mk b gy mt mq l mr ms">val considerIntersect = false</span><span id="7586" class="mo lf it mk b gy mt mq l mr ms">// If true, it will leverage the distributed spatial index to speed up the query execution</span><span id="e4b5" class="mo lf it mk b gy mt mq l mr ms">val usingIndex = false</span><span id="8d8c" class="mo lf it mk b gy mt mq l mr ms">var queryResult = RangeQuery.SpatialRangeQuery(spatialRDD, rangeQueryWindow, considerIntersect, usingIndex)</span></pre><p id="af66" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">编写空间K最近邻查询:</strong>将K、查询点和空间RDD作为输入，并在RDD中找到与查询点最近的K个几何。如果用户拥有空间RDD，他或她可以执行如下查询。空间KNN查询的输出格式是包含K个空间对象的列表。</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="96bc" class="mo lf it mk b gy mp mq l mr ms">val geometryFactory = new GeometryFactory()</span><span id="3df7" class="mo lf it mk b gy mt mq l mr ms">val pointObject = geometryFactory.createPoint(new Coordinate(-84.01, 34.01)) // query point</span><span id="ac8c" class="mo lf it mk b gy mt mq l mr ms">val K = 1000 // K Nearest Neighbors</span><span id="1d4c" class="mo lf it mk b gy mt mq l mr ms">val usingIndex = false</span><span id="79c5" class="mo lf it mk b gy mt mq l mr ms">val result = KNNQuery.SpatialKnnQuery(objectRDD, pointObject, K, usingIndex)</span></pre><p id="daf5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">编写一个空间连接查询:</strong>空间连接查询是用一个空间谓词组合两个或更多数据集的查询，比如距离和包含关系。生活中也有一些真实的场景:告诉我所有有湖的公园，告诉我所有500英尺内有杂货店的加油站。空间连接查询需要两组空间对象作为输入。它从这两个数据集的叉积中找到一个子集，使得每个记录都满足给定的空间谓词。在Sedona中，空间连接查询将两个空间RDDs A和B作为输入。对于A中的每个对象，从B中查找被它覆盖/相交的对象。a和B可以是任何几何类型，并且不必具有相同的几何类型。空间RDD空间分区可以显著提高连接查询的速度。有三种空间划分方法:KDB树、四叉树和R树。两个空间rdd必须由同一个空间分区网格文件进行分区。换句话说，如果用户首先对空间RDD A进行分区，那么他或她必须使用A的数据分割器对b进行分区。示例代码如下:</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="29a0" class="mo lf it mk b gy mp mq l mr ms">// Perform the spatial partitioning</span><span id="9d0e" class="mo lf it mk b gy mt mq l mr ms">objectRDD.spatialPartitioning(joinQueryPartitioningType)</span><span id="8a35" class="mo lf it mk b gy mt mq l mr ms">queryWindowRDD.spatialPartitioning(objectRDD.getPartitioner)</span><span id="865d" class="mo lf it mk b gy mt mq l mr ms">// Build the spatial index</span><span id="1d50" class="mo lf it mk b gy mt mq l mr ms">val usingIndex = true</span><span id="8060" class="mo lf it mk b gy mt mq l mr ms">queryWindowRDD.buildIndex(IndexType.QUADTREE, true) // Set to true only if the index will be used join query</span><span id="f920" class="mo lf it mk b gy mt mq l mr ms">val result = JoinQuery.SpatialJoinQueryFlat(objectRDD, queryWindowRDD, usingIndex, considerBoundaryIntersection)</span></pre><h1 id="3911" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">使用SQL APIs运行空间查询</h1><p id="8b5a" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">这里，我们概述了使用GeoSpark的空间SQL接口管理空间数据的步骤。SQL接口遵循SQL/MM Part3空间SQL标准。具体来说，GeoSpark将可用的空间SQL函数分为三类:(1)构造函数:创建一个几何类型列(2)谓词:评估一个空间条件是真还是假。谓词通常用于WHERE子句、HAVING子句等(3)几何函数:对给定的输入执行特定的几何运算。这些函数可以生成几何图形或数值，如面积或周长。</p><p id="6c6f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使用该系统，用户需要添加GeoSpark作为他们项目的依赖项，如前一节所述。</p><p id="881a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">启动SparkSession:</strong>Spark或Sedona中的任何SQL查询都必须由SparkSession发出，Spark session是集群的中央调度器。要启动SparkSession，用户应使用如下代码:</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="28af" class="mo lf it mk b gy mp mq l mr ms">var sparkSession = SparkSession.builder()</span><span id="6e85" class="mo lf it mk b gy mt mq l mr ms">.appName(“GeoSparkExample”)</span><span id="a68f" class="mo lf it mk b gy mt mq l mr ms">// Enable GeoSpark custom Kryo serializer</span><span id="a4c5" class="mo lf it mk b gy mt mq l mr ms">.config(“spark.serializer”, classOf[KryoSerializer].getName)</span><span id="233c" class="mo lf it mk b gy mt mq l mr ms">.config(“spark.kryo.registrator”, classOf[GeoSparkKryoRegistrator].getName)</span><span id="f748" class="mo lf it mk b gy mt mq l mr ms">.getOrCreate()</span></pre><p id="21d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注册SQL函数:</strong> GeoSpark在Spark的catalyst优化器中增加了新的SQL API函数和优化策略。为了启用这些功能，用户需要使用如下代码将GeoSpark显式注册到Spark会话。</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="73f2" class="mo lf it mk b gy mp mq l mr ms">GeoSparkSQLRegistrator.registerAll(sparkSession)</span></pre><p id="83f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">创建一个几何类型列:</strong> Apache Spark提供了一些格式解析器，可以将数据从磁盘加载到Spark DataFrame(一个结构化的RDD)中。在获得数据帧之后，想要运行空间SQL查询的用户必须首先在该数据帧上创建几何类型列，因为在关系数据系统中每个属性都必须有一个类型。这可以通过一些构造函数来完成，例如ST\_GeomFromWKT。在这一步之后，用户将获得一个空间数据框架。以下示例显示了该函数的用法。</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="41b8" class="mo lf it mk b gy mp mq l mr ms">SELECT ST_GeomFromWKT(wkt_text) AS geom_col, name, address<br/>FROM input</span></pre><p id="ce83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">转换坐标参考系:</strong>与RDD API类似，空间SQL APIs也提供了一个函数，即ST_Transform，用于转换空间对象的坐标参考系。它的工作原理如下:</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="8b41" class="mo lf it mk b gy mp mq l mr ms">SELECT ST_Transform(geom_col, “epsg:4326", “epsg:3857") AS geom_col<br/>FROM spatial_data_frame</span></pre><p id="4860" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">编写一个空间范围查询:</strong> GeoSpark空间SQL APIs有一组谓词，用于评估空间条件是真还是假。ST\_Contains是一个经典函数，它将两个对象A作为输入，如果A包含B，则返回true。在给定的SQL查询中，如果A是单个空间对象，B是列，则这将成为GeoSpark中的空间范围查询(请参见下面的代码)。</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="9e9d" class="mo lf it mk b gy mp mq l mr ms">SELECT *<br/>FROM spatial_data_frame<br/>WHERE ST_Contains (ST_Envelope(1.0,10.0,100.0,110.0), geom_col)</span></pre><p id="14f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">编写一个空间KNN查询:</strong>要使用SQL APIs执行空间KNN查询，用户需要首先计算查询点和其他空间对象之间的距离，按升序排列距离，并取前K个对象。以下代码查找点(1，1)的5个最近邻点。</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="3536" class="mo lf it mk b gy mp mq l mr ms">SELECT name, ST_Distance(ST_Point(1.0, 1.0), geom_col) AS distance<br/>FROM spatial_data_frame<br/>ORDER BY distance ASC<br/>LIMIT 5</span></pre><p id="ab69" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">编写一个空间连接查询:</strong>空间SQL中的空间连接查询也使用前面提到的评估空间条件的空间谓词。但是，要触发连接查询，空间谓词的输入必须至少包含两个几何类型的列，这两个列可以来自两个不同的数据帧，也可以来自同一数据帧。以下查询涉及两个空间数据帧，一个面列和一个点列。它查找每一对可能的$ &lt; $polygon，point$ &gt; $以使多边形包含该点。</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="b298" class="mo lf it mk b gy mp mq l mr ms">SELECT *<br/>FROM spatial_data_frame1 df1, spatial_data_frame2 df2<br/>WHERE ST_Contains(df1.polygon_col, df2.point_col)</span></pre><p id="c3d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">执行几何运算:</strong> GeoSpark提供超过15个SQL函数。用于几何计算。用户可以在其空间SQL查询中轻松调用这些函数，GeoSpark将并行运行该查询。例如，获取每个空间对象的面积的一个非常简单的查询如下:</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="dfe6" class="mo lf it mk b gy mp mq l mr ms">SELECT ST_Area(geom_col)<br/>FROM spatial_data_frame</span></pre><p id="f77d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">系统还提供空间对象的聚集功能。它们通常将数据帧中的所有空间对象作为输入，并产生单个值。例如，以下代码计算数据框中所有面的并集。</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="6702" class="mo lf it mk b gy mp mq l mr ms">SELECT ST_Union_Aggr(geom_col)<br/>FROM spatial_data_frame</span></pre><h1 id="d945" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">通过Zeppelin笔记本与GeoSpark互动</h1><p id="810b" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">尽管Spark在每个版本中都捆绑了交互式Scala和SQL shells，但这些shell并不用户友好，并且无法进行复杂的分析和图表。数据科学家倾向于使用图形界面交互式地运行程序和绘制图表。从1.2.0开始，GeoSpark (Apache Sedona)提供了一个为Apache Zeppelin基于web的笔记本量身定制的氦插件。用户可以在Zeppelin web笔记本上执行空间分析，Zeppelin会将任务发送到底层Spark集群。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/f37464cc0c608a17a7f374dc558eab85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYlvsXeeIExSB-Vku0UeGQ.png"/></div></div></figure><p id="aca6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用户可以在Zeppelin笔记本上创建一个新段落，并用Scala、Python或SQL编写代码，与GeoSpark进行交互。此外，用户可以点击界面上的不同选项，并要求GeoSpark在查询结果上呈现不同的图表，如条形图、折线图和饼图。例如，Zeppelin可以将以下查询的结果可视化为条形图，并显示美国每个县的地标数量。</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="28f5" class="mo lf it mk b gy mp mq l mr ms">SELECT C.name, count(*)<br/>FROM US_county C, US_landmark L<br/>WHERE ST_Contains(C.geom_col, L.geom_col)<br/>GROUPBY C.name</span></pre><p id="28e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个例子是找到美国每个县的面积，并将其可视化在条形图上。相应的查询如下。这实际上利用了GeoSpark中提供的几何功能。</p><pre class="mc md me mf gt mj mk ml mm aw mn bi"><span id="3429" class="mo lf it mk b gy mp mq l mr ms">SELECT C.name, ST_Area(C.geom_col) AS area<br/>FROM US_county C</span></pre><h1 id="a52c" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">Apache Sedona如何处理空间数据洪流</h1><h2 id="a62a" class="mo lf it bd lg mz na dn lk nb nc dp lo kr nd ne lq kv nf ng ls kz nh ni lu nj bi translated">空间数据划分</h2><p id="439d" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">此外，空间rdd配备了分布式空间索引和分布式空间分区来加速空间查询。所采用的数据分区方法适合集群中的空间数据处理。空间rdd中的数据根据空间数据分布进行分区，并且附近的空间对象很可能被放入同一个分区中。空间分区的效果是双重的:(1)当运行以特定空间区域为目标的空间查询时，GeoSpark可以通过避免对空间上不接近的分区进行不必要的计算来加速查询。(2)它可以将空间RDD分割成多个数据分区，每个分区具有相似数量的记录。这样，系统可以确保负载平衡，并避免在集群中执行计算时掉队。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/c71db28feeaf19ac01ec89db7f0a48fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wdriTIbaf1b6EME7O0QbKg.png"/></div></div></figure><h2 id="1d12" class="mo lf it bd lg mz na dn lk nb nc dp lo kr nd ne lq kv nf ng ls kz nh ni lu nj bi translated">空间索引</h2><p id="3b64" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">Sedona使用分布式空间索引来索引集群中的空间rdd。这个分布式索引由两部分组成(1)全局索引:存储在主机上，在空间分区阶段生成。它索引空间rdd中分区的包围盒。拥有这样一个全局索引的目的是修剪那些保证没有合格的空间对象的分区。(2)局部索引:建立在空间RDD的每个分区上。因为每个本地索引只作用于它自己分区中的数据，所以它可以有一个很小的索引大小。给定一个空间查询，空间RDD中的本地索引可以加速并行查询。</p><h2 id="b741" class="mo lf it bd lg mz na dn lk nb nc dp lo kr nd ne lq kv nf ng ls kz nh ni lu nj bi translated">空间RDD定制串行器</h2><p id="4581" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">Sedona为空间对象和空间索引提供了定制的序列化程序。所提出的序列化器可以将空间对象和索引序列化为压缩的字节数组。该序列化程序比广泛使用的kryo序列化程序更快，并且在运行复杂的空间操作(例如空间连接查询)时占用的内存更少。将空间对象转换为字节数组时，序列化程序遵循Shapefile的编码和解码规范。</p><p id="b66c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">序列化器还可以序列化和反序列化本地空间索引，如四叉树和R树。对于序列化，它使用深度优先搜索(DFS)按照预先排序策略遍历每个树节点(首先写入当前节点信息，然后写入其子节点)。对于反序列化，它将遵循序列化阶段使用的相同策略。反序列化也是一个递归过程。当序列化或反序列化每个树节点时，索引序列化程序将调用空间对象序列化程序来处理单个空间对象。</p><h1 id="37ee" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">结论</h1><p id="caf7" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">总之，Apache Sedona为数据科学家处理大规模地理空间数据提供了一个易于使用的界面。目前，该系统支持SQL、Python、R和Scala以及许多空间数据格式，例如ShapeFiles、ESRI、GeoJSON和NASA格式。以下是GitHub资源库的链接:</p><div class="nk nl gp gr nm nn"><a href="http://sedona.apache.org" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">阿帕奇塞多纳(孵化中)</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">Apache Sedona(孵化)是一个用于处理大规模空间数据的集群计算系统。塞多纳扩展阿帕奇…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">sedona.apache.org</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob mh nn"/></div></div></a></div><p id="52ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GeoSpark有一个活跃的小型社区，由来自工业界和学术界的开发人员组成。您还可以在此尝试更多编码示例:</p><div class="nk nl gp gr nm nn"><a href="https://github.com/apache/incubator-sedona/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">阿帕奇/孵化器-塞多纳</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">Apache Sedona(孵化)是一个用于处理大规模空间数据的集群计算系统。塞多纳扩展阿帕奇…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="oc l ny nz oa nw ob mh nn"/></div></div></a></div><p id="4b33" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有更多问题，请随时在<a class="ae od" href="https://twitter.com/mosarwat" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上给我发消息</p></div></div>    
</body>
</html>