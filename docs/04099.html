<html>
<head>
<title>Announcing PyCaret 1.0.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">宣布 PyCaret 1.0.0</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/announcing-pycaret-an-open-source-low-code-machine-learning-library-in-python-4a1f1aad8d46?source=collection_archive---------3-----------------------#2020-04-15">https://towardsdatascience.com/announcing-pycaret-an-open-source-low-code-machine-learning-library-in-python-4a1f1aad8d46?source=collection_archive---------3-----------------------#2020-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c712e381ff0fbf0ac3d7bf516af4e92f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xtb7t4Rlxq8jFLXZn_sdyQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="3ec0" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">Python 中一个开源的<strong class="ak">低代码</strong>机器学习库。</h2></div><p id="7360" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们很兴奋地宣布<a class="ae lm" href="https://www.pycaret.org" rel="noopener ugc nofollow" target="_blank"> PyCaret </a>，这是一个用 Python 编写的开源机器学习库，用于在<strong class="ks jc">低代码</strong>环境中训练和部署有监督和无监督的机器学习模型。PyCaret 允许您从选择笔记本电脑环境开始，在几秒钟内从准备数据到部署模型。</p><p id="dd98" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">与其他开源机器学习库相比，PyCaret 是一个替代的低代码库，可以用来替换数百行代码，只需要几个单词。这使得实验快速有效。PyCaret 本质上是几个机器学习库和框架的 Python 包装器，比如<a class="ae lm" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>、<a class="ae lm" href="https://xgboost.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> XGBoost </a>、<a class="ae lm" href="https://github.com/microsoft/LightGBM" rel="noopener ugc nofollow" target="_blank"> Microsoft LightGBM </a>、<a class="ae lm" href="https://spacy.io/" rel="noopener ugc nofollow" target="_blank"> spaCy </a>等等。</p><p id="1328" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">py caret<strong class="ks jc">简单</strong> <strong class="ks jc">好用</strong>。PyCaret 中执行的所有操作都顺序存储在一个完全为<strong class="ks jc">部署编排的<strong class="ks jc">管道</strong>中。</strong>无论是输入缺失值、转换分类数据、特征工程还是超参数调整，PyCaret 都能实现自动化。要了解 PyCaret 的更多信息，请观看这段 1 分钟的视频。</p><figure class="ln lo lp lq gt is"><div class="bz fp l di"><div class="lr ls l"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated"><em class="lx"> PyCaret 1.0.0 发布 Python 中的开源低代码机器学习库</em></p></figure><h1 id="4d8f" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">PyCaret 入门</h1><p id="c02a" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">PyCaret 版本 1.0.0 的第一个稳定版本可以使用 pip 安装。使用命令行界面或笔记本环境，运行下面的代码单元来安装 PyCaret。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="8aab" class="na lz jb mw b gy nb nc l nd ne">pip install pycaret</span></pre><p id="25b6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你使用的是<a class="ae lm" href="https://notebooks.azure.com/" rel="noopener ugc nofollow" target="_blank"> Azure 笔记本</a>或<a class="ae lm" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>，运行下面的代码单元来安装 PyCaret。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="9a78" class="na lz jb mw b gy nb nc l nd ne">!pip install pycaret</span></pre><p id="b540" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">安装 PyCaret 时，所有依赖项都会自动安装。<a class="ae lm" href="https://github.com/pycaret/pycaret/blob/master/requirements.txt" rel="noopener ugc nofollow" target="_blank">点击此处</a>查看完整的依赖关系列表。</p><h1 id="136a" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">没有比这更容易的了👇</h1><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/6a303c3b885afa77328a9bb6fc1c94d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QG6SjFXOV6wqY_00D1fsLw.gif"/></div></div></figure><h1 id="b22d" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">📘循序渐进的教程</h1><h1 id="476f" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">1.获取数据</h1><p id="d86b" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">在本分步指南中，我们将使用<strong class="ks jc">“糖尿病”</strong>数据集，目标是根据血压、胰岛素水平、年龄等几个因素预测患者结果(二进制 1 或 0)。数据集可以在 PyCaret 的<a class="ae lm" href="https://github.com/pycaret/pycaret" rel="noopener ugc nofollow" target="_blank"> github 库</a>上获得。直接从存储库中导入数据集的最简单方法是使用<strong class="ks jc"> pycaret.datasets </strong>模块中的<strong class="ks jc"> get_data </strong>函数。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="ccc9" class="na lz jb mw b gy nb nc l nd ne">from <strong class="mw jc">pycaret.datasets</strong> import <strong class="mw jc">get_data</strong><br/>diabetes = <strong class="mw jc">get_data</strong>('diabetes')</span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/48e02230b854434f6e5e497e99fd8548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o1xpZeVNUfzm7yQ6f1IPvw.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">get_data 的输出</p></figure><p id="b93b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">💡PyCaret 可以直接处理<strong class="ks jc"> pandas </strong> dataframe。</p><h1 id="0298" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">2.设置环境</h1><p id="a888" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">PyCaret 中任何机器学习实验的第一步都是通过导入所需的模块并初始化<strong class="ks jc"> setup </strong>()来设置环境。本例中使用的模块是<a class="ae lm" href="https://www.pycaret.org/classification" rel="noopener ugc nofollow" target="_blank"><strong class="ks jc">py caret . class ification</strong></a><strong class="ks jc">。</strong></p><p id="b5e3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">模块导入后，<strong class="ks jc"> setup() </strong>通过定义数据帧(<em class="nh">【糖尿病】</em>)和目标变量(<em class="nh">【类变量】</em>)进行初始化。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="f353" class="na lz jb mw b gy nb nc l nd ne">from <strong class="mw jc">pycaret.classification</strong> import <strong class="mw jc">*<br/></strong>exp1 = <strong class="mw jc">setup</strong>(diabetes, target = 'Class variable')</span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/103c6d1dca5c576ce7caa06f7fd05f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WaVNaMkfoHIrD0lKPHFvJA.png"/></div></div></figure><p id="d62e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所有预处理步骤都在<strong class="ks jc">设置()中应用。</strong>py caret 有超过 20 个特征为机器学习准备数据，它根据<em class="nh">设置</em>功能中定义的参数创建一个转换管道。它会自动编排一个<strong class="ks jc">管道</strong>中的所有依赖项，这样您就不必手动管理测试或不可见数据集上转换的顺序执行。PyCaret 的管道可以轻松地跨环境传输，以便大规模运行或轻松部署到生产中。下面是 PyCaret 第一次发布时提供的预处理特性。</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/a97997b5f8a9577727aa577603e0c021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jo9vPsQhQZmyXUhnrt9akQ.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">PyCaret 的预处理功能</p></figure><p id="5a1c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">💡初始化 setup()时，会自动执行机器学习必需的数据预处理步骤，例如缺失值插补、分类变量编码、标签编码(将是或否转换为 1 或 0)以及训练-测试-分割。<a class="ae lm" href="https://www.pycaret.org/preprocessing" rel="noopener ugc nofollow" target="_blank">点击这里</a>了解更多关于 PyCaret 的预处理能力。</p><h1 id="2ad4" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">3.比较模型</h1><p id="9967" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">这是监督机器学习实验中推荐的第一步(<a class="ae lm" href="https://www.pycaret.org/classification" rel="noopener ugc nofollow" target="_blank">分类</a>或<a class="ae lm" href="https://www.pycaret.org/regression" rel="noopener ugc nofollow" target="_blank">回归</a>)。此函数训练模型库中的所有模型，并使用 k 倍交叉验证(默认为 10 倍)比较常用评估指标。使用的评估指标包括:</p><ul class=""><li id="b227" class="nk nl jb ks b kt ku kw kx kz nm ld nn lh no ll np nq nr ns bi translated"><strong class="ks jc">用于分类:</strong>准确度、AUC、召回率、精确度、F1、Kappa</li><li id="5aa1" class="nk nl jb ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns bi translated"><strong class="ks jc">用于回归:</strong> MAE，MSE，RMSE，R2，RMSLE，MAPE</li></ul><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="41c9" class="na lz jb mw b gy nb nc l nd ne"><strong class="mw jc">compare_models</strong>()</span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/85364ead660c2f52b61a0a75ae25ff47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WaaSiqUkIFMiKbYofBRo7Q.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">compare_models()函数的输出</p></figure><p id="6d7c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">💡默认情况下，使用 10 重交叉验证来评估指标。可以通过改变<strong class="ks jc"> <em class="nh">折叠</em> </strong>参数的值来改变。</p><p id="0fd0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">💡默认情况下，表格按“精确度”(从高到低)值排序。可以通过改变<strong class="ks jc"> <em class="nh">排序</em> </strong>参数的值来改变。</p><h1 id="73c2" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">4.创建模型</h1><p id="b639" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">在 PyCaret 的任何模块中创建一个模型就像编写<strong class="ks jc"> create_model 一样简单。<em class="nh"> </em> </strong>它只有一个参数，即作为字符串输入传递的型号名称。该函数返回一个表，其中包含 k 倍交叉验证的分数和一个训练好的模型对象。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="f70f" class="na lz jb mw b gy nb nc l nd ne">adaboost = <strong class="mw jc">create_model</strong>('ada')</span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/eda09cae381c635c6f696a5650deeb77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1twQHlWEbUbEtVEas0NQDQ.png"/></div></div></figure><p id="7b1e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">变量“adaboost”存储由<strong class="ks jc"> create_model </strong>函数返回的训练模型对象，它是一个 scikit-learn 估计器。被训练对象的原始属性可以通过使用<em class="nh">句点( .)</em>复变。参见下面的例子。</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/83e915834cfd8fd0244d20b5f263c6da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Vlh9B3l6tFwlCNzJBfQEcQ.gif"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">训练模型对象的属性</p></figure><p id="b295" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">💡PyCaret 拥有超过 60 种开源的现成算法。点击这里查看 PyCaret 中可用的评估者/模型的完整列表。</p><h1 id="c31d" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">5.调整模型</h1><p id="bb46" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated"><strong class="ks jc"> tune_model </strong>函数用于自动调整机器学习模型<strong class="ks jc">的超参数。</strong> PyCaret 在预定义的搜索空间内使用<strong class="ks jc">随机网格搜索</strong>。该函数返回一个表，其中包含 k 倍交叉验证的分数和一个训练好的模型对象。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="8bb7" class="na lz jb mw b gy nb nc l nd ne">tuned_adaboost = tune_model('ada')</span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/87b90f488c52fc851c38eec4afc63dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pqsFYecRxZ_ruvwBXZWlQA.png"/></div></div></figure><p id="6a5a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">💡无监督模块<a class="ae lm" href="https://www.pycaret.org/nlp" rel="noopener ugc nofollow" target="_blank"> pycaret.nlp </a>、<a class="ae lm" href="https://www.pycaret.org/clustering" rel="noopener ugc nofollow" target="_blank"> pycaret.clustering </a>和<a class="ae lm" href="https://www.pycaret.org/anomaly" rel="noopener ugc nofollow" target="_blank"> pycaret.anomaly </a>中的<strong class="ks jc"> tune_model </strong>函数可以与有监督模块配合使用。例如，PyCaret 的 NLP 模块可用于调整<em class="nh">主题数量</em>参数，方法是评估监督 ML 模型的目标/成本函数，如“准确度”或“R2”。</p><h1 id="c178" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">6.集合模型</h1><p id="75dd" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated"><strong class="ks jc"> ensemble_model </strong>函数用于集合训练好的模型<strong class="ks jc">。</strong>它只需要一个参数，即一个训练好的模型对象。这个函数返回一个表，其中包含 k 倍交叉验证的分数和一个训练好的模型对象。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="a9e0" class="na lz jb mw b gy nb nc l nd ne"># creating a decision tree model<br/>dt = <strong class="mw jc">create_model</strong>('dt')</span><span id="3c30" class="na lz jb mw b gy ob nc l nd ne"># ensembling a trained dt model<br/>dt_bagged = <strong class="mw jc">ensemble_model</strong>(dt)</span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oc"><img src="../Images/57f2150149b745f1dc358a3a550e8ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uw2WmHc1oFeUfnnz-jYfhA.png"/></div></div></figure><p id="b116" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">💡默认情况下，集合使用“Bagging”方法，可以通过使用 ensemble_model 函数中的<strong class="ks jc"> <em class="nh">方法</em> </strong>参数将其更改为“Boosting”。</p><p id="85cc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">💡PyCaret 还提供了<a class="ae lm" href="https://www.pycaret.org/blend-models" rel="noopener ugc nofollow" target="_blank"> blend_models </a>和<a class="ae lm" href="https://www.pycaret.org/stack-models" rel="noopener ugc nofollow" target="_blank"> stack_models </a>功能来集成多个训练模型。</p><h1 id="6e5b" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">7.绘图模型</h1><p id="d85a" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">可以使用<strong class="ks jc"> plot_model </strong>函数对经过训练的机器学习模型进行性能评估和诊断。它在<strong class="ks jc"> plot_model </strong>函数中将一个训练好的模型对象和绘图类型作为字符串输入。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="f0ba" class="na lz jb mw b gy nb nc l nd ne"># create a model<br/>adaboost = <strong class="mw jc">create_model</strong>('ada')</span><span id="2841" class="na lz jb mw b gy ob nc l nd ne"># AUC plot<br/><strong class="mw jc">plot_model</strong>(adaboost, plot = 'auc')</span><span id="4780" class="na lz jb mw b gy ob nc l nd ne"># Decision Boundary<br/><strong class="mw jc">plot_model</strong>(adaboost, plot = 'boundary')</span><span id="b867" class="na lz jb mw b gy ob nc l nd ne"># Precision Recall Curve<br/><strong class="mw jc">plot_model</strong>(adaboost, plot = 'pr')</span><span id="84df" class="na lz jb mw b gy ob nc l nd ne"># Validation Curve<br/><strong class="mw jc">plot_model</strong>(adaboost, plot = 'vc')</span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi od"><img src="../Images/6d353c173bd2032bb2489d30d12ba21d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnfDw9wwuGxTDS676_hBXg.png"/></div></div></figure><p id="ec0f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https:///www.pycaret.org/plot-model" rel="noopener ugc nofollow" target="_blank">单击此处</a>了解 PyCaret 中不同可视化的更多信息。</p><p id="4007" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">或者，您可以使用<strong class="ks jc"> evaluate_model </strong>函数，通过笔记本内的用户界面查看图<em class="nh">。</em></p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="1024" class="na lz jb mw b gy nb nc l nd ne"><strong class="mw jc">evaluate_model</strong>(adaboost)</span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/2d0d57d9564ad95880ef1abd859048d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TMuREzi-o7_edYCj4yIZfA.gif"/></div></div></figure><p id="d2ba" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">💡<strong class="ks jc">py caret . NLP</strong>模块中的 plot_model 函数可以用来可视化<em class="nh">文本语料库</em>和<em class="nh">语义主题模型</em>。点击这里了解更多信息。</p><h1 id="cf29" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">8.解释模型</h1><p id="567a" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">当数据中的关系是非线性的时，这在现实生活中是常见的情况，我们总是看到基于树的模型比简单的高斯模型做得更好。然而，这是以失去可解释性为代价的，因为基于树的模型不像线性模型那样提供简单的系数。PyCaret 使用<strong class="ks jc"> interpret_model </strong>函数实现<a class="ae lm" href="https://shap.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">SHAP(SHapley Additive exPlanations</a>)。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="0753" class="na lz jb mw b gy nb nc l nd ne"># create a model<br/>xgboost = <strong class="mw jc">create_model</strong>('xgboost')</span><span id="ba81" class="na lz jb mw b gy ob nc l nd ne"># summary plot<br/><strong class="mw jc">interpret_model</strong>(xgboost)</span><span id="a331" class="na lz jb mw b gy ob nc l nd ne"># correlation plot<br/><strong class="mw jc">interpret_model</strong>(xgboost, plot = 'correlation')</span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oe"><img src="../Images/c22d50e9aa3ead5317e6f3717912fcba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ct0UFJA2sxTpSTwSwO1-fQ.png"/></div></div></figure><p id="1850" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">测试数据集中特定数据点(也称为原因参数)的解释可使用“原因”图进行评估。在下面的例子中，我们检查测试数据集中的第一个实例。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="e321" class="na lz jb mw b gy nb nc l nd ne"><strong class="mw jc">interpret_model</strong>(xgboost, plot = 'reason', observation = 0) </span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi of"><img src="../Images/436c01f73c7a3712e29c85a433a53364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hsM128hQ2sDk9TnTHBH9Bw.png"/></div></div></figure><h1 id="074c" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">9.预测模型</h1><p id="ea17" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">到目前为止，我们看到的结果仅基于训练数据集的 k-fold 交叉验证(默认为 70%)。为了在测试/保留数据集上查看模型的预测和性能，使用了<strong class="ks jc"> predict_model </strong>函数。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="c021" class="na lz jb mw b gy nb nc l nd ne"># create a model<br/>rf = <strong class="mw jc">create_model</strong>('rf')</span><span id="e849" class="na lz jb mw b gy ob nc l nd ne"># predict test / hold-out dataset<br/>rf_holdout_pred<strong class="mw jc"> = predict_model</strong>(rf)</span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi og"><img src="../Images/ea5820418d980c508e87c20e0aef6318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e05Sd2KFexSjxORcaxAeFw.png"/></div></div></figure><p id="5a95" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> predict_model </strong>函数也用于预测未知数据集。现在，我们将使用我们用于训练的相同数据集作为新的看不见的数据集的<em class="nh">代理</em>。在实践中，<strong class="ks jc"> predict_model </strong>函数将被迭代使用，每次使用一个新的看不见的数据集。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="f328" class="na lz jb mw b gy nb nc l nd ne">predictions = <strong class="mw jc">predict_model</strong>(rf, data = diabetes)</span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oh"><img src="../Images/61dada86aa96f2265fb927dcb9dab74a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TZwr8fI9cNqluSwnDa4IfA.png"/></div></div></figure><p id="2524" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">💡predict_model 函数还可以预测使用<a class="ae lm" href="https://www.pycaret.org/stack-models" rel="noopener ugc nofollow" target="_blank"> stack_models </a>和<a class="ae lm" href="https://www.pycaret.org/classification/#create-stacknet" rel="noopener ugc nofollow" target="_blank"> create_stacknet </a>函数创建的一系列模型。</p><p id="d589" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">💡predict_model 函数也可以使用<a class="ae lm" href="https://www.pycaret.org/deploy-model" rel="noopener ugc nofollow" target="_blank"> deploy_model </a>函数直接从 AWS S3 上托管的模型进行预测。</p><h1 id="f5c2" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">10.部署模型</h1><p id="ce85" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">利用已定型模型对未知数据集生成预测的一种方法是，在模型已定型的笔记本/ IDE 中使用 predict_model 函数。然而，对未知数据集进行预测是一个迭代过程；根据使用情况，进行预测的频率可以从实时预测到批量预测。PyCaret 的<strong class="ks jc"> deploy_model </strong>函数允许从笔记本环境部署整个管道，包括云上的训练模型。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="39c2" class="na lz jb mw b gy nb nc l nd ne"><strong class="mw jc">deploy_model</strong>(model = rf, model_name = 'rf_aws', platform = 'aws', <br/>             authentication =  {'bucket'  : 'pycaret-test'})</span></pre><h1 id="5aac" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">11.保存模型/保存实验</h1><p id="db92" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">一旦训练完成，包含所有预处理转换和训练的模型对象的整个管道可以保存为二进制 pickle 文件。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="466a" class="na lz jb mw b gy nb nc l nd ne"># creating model<br/>adaboost = <strong class="mw jc">create_model</strong>('ada')</span><span id="5974" class="na lz jb mw b gy ob nc l nd ne"># saving model<strong class="mw jc"><br/>save_model</strong>(adaboost, model_name = 'ada_for_deployment')</span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/28d9bc023e1fef702d6940e04b4ce598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sW7Vn_mPiH-TWaJ3cZgE8Q.png"/></div></div></figure><p id="2684" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您还可以将包含所有中间输出的整个实验保存为一个二进制文件。</p><pre class="ln lo lp lq gt mv mw mx my aw mz bi"><span id="74c3" class="na lz jb mw b gy nb nc l nd ne"><strong class="mw jc">save_experiment</strong>(experiment_name = 'my_first_experiment')</span></pre><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/f707c202acbd06ed2d8ac8619f7ca0d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GFLvTgyzESXgy1SytG45xQ.png"/></div></div></figure><p id="1e45" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">💡您可以使用 PyCaret 所有模块中可用的<strong class="ks jc"> load_model </strong>和<strong class="ks jc"> load_experiment </strong>函数加载已保存的模型和已保存的实验。</p><h1 id="7a40" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">12.下一个教程</h1><p id="9367" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">在下一个教程中，我们将展示如何在 Power BI 中使用经过训练的机器学习模型，以在真实的生产环境中生成批量预测。</p><p id="23fa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">请参见我们的初级笔记本，了解这些模块:</p><p id="ee58" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://www.pycaret.org/reg101" rel="noopener ugc nofollow" target="_blank">回归</a> <br/> <a class="ae lm" href="https://www.pycaret.org/clu101" rel="noopener ugc nofollow" target="_blank">聚类</a> <br/> <a class="ae lm" href="https://www.pycaret.org/anom101" rel="noopener ugc nofollow" target="_blank">异常检测</a> <br/> <a class="ae lm" href="https://www.pycaret.org/nlp101" rel="noopener ugc nofollow" target="_blank">自然语言处理</a> <br/>关联规则挖掘</p><h1 id="615f" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">开发管道中有什么？</h1><p id="ecb1" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">我们正在积极改进 PyCaret。我们未来的开发管道包括一个新的<strong class="ks jc">时间序列预测</strong>模块，与<strong class="ks jc"> TensorFlow </strong>的集成，以及对 PyCaret 可扩展性的重大改进。如果您想分享您的反馈并帮助我们进一步改进，您可以<a class="ae lm" href="https://www.pycaret.org/feedback" rel="noopener ugc nofollow" target="_blank">在网站上填写此表格</a>，或者在我们的<a class="ae lm" href="http://www.github.com/pycaret/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>或<a class="ae lm" href="https://www.linkedin.com/company/pycaret/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>页面上发表评论。</p><h1 id="3743" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">想了解某个特定模块？</h1><p id="52bd" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">从第一个版本 1.0.0 开始，PyCaret 有以下模块可供使用。单击下面的链接查看文档和工作示例。</p><p id="880d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://www.pycaret.org/classification" rel="noopener ugc nofollow" target="_blank">分类</a> <br/> <a class="ae lm" href="https://www.pycaret.org/regression" rel="noopener ugc nofollow" target="_blank">回归<br/> </a> <a class="ae lm" href="https://www.pycaret.org/clustering" rel="noopener ugc nofollow" target="_blank">聚类</a> <br/> <a class="ae lm" href="https://www.pycaret.org/anomaly-detection" rel="noopener ugc nofollow" target="_blank">异常检测<br/></a>T22】自然语言处理 <br/> <a class="ae lm" href="https://www.pycaret.org/association-rules" rel="noopener ugc nofollow" target="_blank">关联规则挖掘</a></p><h1 id="7d08" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">重要链接</h1><p id="66e9" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated"><a class="ae lm" href="https://www.pycaret.org/guide" rel="noopener ugc nofollow" target="_blank">用户指南/文档</a> <br/> <a class="ae lm" href="http://www.github.com/pycaret/pycaret" rel="noopener ugc nofollow" target="_blank"> Github 资源库</a> <br/> <a class="ae lm" href="https://www.pycaret.org/install" rel="noopener ugc nofollow" target="_blank">安装 PyCaret </a> <br/> <a class="ae lm" href="https://www.pycaret.org/tutorial" rel="noopener ugc nofollow" target="_blank">笔记本教程</a> <br/> <a class="ae lm" href="https://www.pycaret.org/contribute" rel="noopener ugc nofollow" target="_blank">贡献于 PyCaret </a></p><p id="9b65" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你喜欢 PyCaret，给我们 github 回购⭐️。</p><p id="ec04" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">想了解更多关于 PyCaret 的信息，请在 LinkedIn 和 Youtube 上关注我们。</p></div></div>    
</body>
</html>