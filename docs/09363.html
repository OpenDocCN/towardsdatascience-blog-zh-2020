<html>
<head>
<title>Addressing The John Smith Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决约翰·史密斯问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/addressingthejohnsmithproblem-1533da4f7db8?source=collection_archive---------39-----------------------#2020-07-04">https://towardsdatascience.com/addressingthejohnsmithproblem-1533da4f7db8?source=collection_archive---------39-----------------------#2020-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6409" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用模糊逻辑识别不匹配的副本</h2></div><p id="39d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特别感谢<a class="ae lb" href="https://eight2late.wordpress.com/2019/10/09/tackling-the-john-smith-problem-deduplicating-data-via-fuzzy-matching-in-r/" rel="noopener ugc nofollow" target="_blank">凯拉什·阿瓦提</a>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/46e5f0279c66ce8a0b2990e3b133e97d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5IJftYexxPv1HafNJogGw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图片由作者重现，灵感来自<a class="ae lb" href="https://www.liberaldictionary.com/wp-content/uploads/2019/01/deduplicate-1518.jpg" rel="noopener ugc nofollow" target="_blank">自由词典</a></p></figure><h1 id="9913" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.介绍</h1><p id="2770" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">许多数据库都有重复的数据。尤其是在需要手动输入数据的情况下。为了清理数据和解决不必要的重复，有必要识别和纠正杂乱的数据。然而，许多重复是不匹配的；这意味着可能存在包含例如拼写错误的重复数据。使用<code class="fe mp mq mr ms b">SQL</code>数据库语言完美地识别这些重复项是具有挑战性的，因为这依赖于<em class="mt">精确的</em>匹配(由于关系数据库理论的原则)。因此，有必要寻找其他方法来识别不匹配的副本，这就是模糊匹配能够被使用的地方。</p><p id="e244" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模糊匹配摆脱了<a class="ae lb" href="https://en.wikipedia.org/wiki/Edit_distance" rel="noopener ugc nofollow" target="_blank">编辑距离</a>的概念，实质上是将一个字符串转换成另一个所需的<em class="mt">最小操作数。最常用的编辑距离度量之一是<a class="ae lb" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> Levenshtein distance </a>，它本质上是，“<em class="mt">将一个单词变为另一个单词所需的单个字符编辑(插入、删除或替换)的最小数量。</em>”。其他度量包括<a class="ae lb" href="https://en.wikipedia.org/wiki/Hamming_distance" rel="noopener ugc nofollow" target="_blank">汉明距离</a>、<a class="ae lb" href="https://en.wikipedia.org/wiki/Jaccard_index" rel="noopener ugc nofollow" target="_blank"> Jaccard 距离</a>、<a class="ae lb" href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance" rel="noopener ugc nofollow" target="_blank"> Jaro-Winkler 距离</a>、最长公共子串距离<a class="ae lb" href="https://en.wikipedia.org/wiki/Longest_common_substring_problem" rel="noopener ugc nofollow" target="_blank">或</a><a class="ae lb" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">余弦距离</a>。出于本文的目的，使用<a class="ae lb" href="https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance#Optimal_string_alignment_distance" rel="noopener ugc nofollow" target="_blank">光学字符串对准距离</a> (OSA)(它是<a class="ae lb" href="https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance#Optimal_string_alignment_distance" rel="noopener ugc nofollow" target="_blank"> Damerau-Levenshtein 距离</a>的变体)。</em></p><p id="b463" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了说明 OSA，给出下面的例子:</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="0a38" class="my lt iq ms b gy mz na l nb nc">bear -&gt; bear    = 0 steps (0 characters changed)<br/>bear -&gt; beat    = 1 step  (1 characters changed)<br/>bear -&gt; meat    = 2 steps (3 characters changed)<br/>bear -&gt; tearing = 4 steps (1 character changed, 3 characters added)<br/>bear -&gt; ear     = 1 step  (1 character removed)</span></pre><p id="a5e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如所见，将一个字符串转换为另一个字符串所需的更改次数就是所采取的步骤数。该逻辑将用于匹配给定数据库中的记录。</p><h1 id="1552" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.建立</h1><h2 id="f737" class="my lt iq bd lu nd ne dn ly nf ng dp mc ko nh ni me ks nj nk mg kw nl nm mi nn bi translated">2.1.加载包</h2><p id="277f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">第一步是加载必要的包。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="d472" class="my lt iq ms b gy mz na l nb nc"># Load required packages<br/>library(tidyverse)  #Various tools<br/>library(readxl)     #Read in Excel's<br/>library(readr)      #Read in data<br/>library(magrittr)   #Great piping tools<br/>library(kableExtra) #Pretty tables<br/>library(stringdist) #For Edit Distance algorithms<br/>library(DBI)        #Testing SQL<br/>library(RSQLite)    #Testing SQL<br/>library(tictoc)     #Check code run-time</span></pre><h2 id="d786" class="my lt iq bd lu nd ne dn ly nf ng dp mc ko nh ni me ks nj nk mg kw nl nm mi nn bi translated">2.2.加载数据</h2><p id="568e" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">下一步是加载数据。<code class="fe mp mq mr ms b">JohnSmiths</code>数据是“虚拟数据”，用于说明模糊匹配的例子。原始数据可在<a class="ae lb" href="https://eight2late.files.wordpress.com/2019/10/many_john_smiths.xlsx" rel="noopener ugc nofollow" target="_blank">八 2Late </a>上找到。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="1160" class="my lt iq ms b gy mz na l nb nc"># Load files from Excel<br/>dat_JohnSmiths &lt;- find_rstudio_root_file() %&gt;% <br/>   paste0("/Data/", "many_john_smiths.xlsx") %&gt;% <br/>   read_excel() %&gt;% <br/>   data.frame()</span></pre><h2 id="cc99" class="my lt iq bd lu nd ne dn ly nf ng dp mc ko nh ni me ks nj nk mg kw nl nm mi nn bi translated">2.3.检查数据</h2><p id="a0e9" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">加载完电子表格后，<code class="fe mp mq mr ms b">JohnSmiths</code>数据如下所示:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi no"><img src="../Images/c7e6866b4fda92b0fb2bcea24e00303a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FIjWGNBwNqz4gxzaUd0ivw.png"/></div></div></figure><p id="f2be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看数据帧后，详细信息如下所示:</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="d21a" class="my lt iq ms b gy mz na l nb nc">&gt;  Name: dat_JohnSmiths<br/>&gt;  Type: data.frame<br/>&gt;  Dims: 10 x 8<br/>&gt;  Size: 4.9 Kb<br/>&gt;  Field Counts:<br/>&gt;    field           distinct count distinct%<br/>&gt;  1 CustomerID      10       10    1.0      <br/>&gt;  2 FirstName        4       10    0.4      <br/>&gt;  3 LastName         2       10    0.2      <br/>&gt;  4 Title            4       10    0.4      <br/>&gt;  5 AddressLine1    10       10    1.0      <br/>&gt;  6 AddressSuburb    5       10    0.5      <br/>&gt;  7 AddressPostcode  6       10    0.6      <br/>&gt;  8 Phone           10       10    1.0</span></pre><h1 id="dc74" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.使用 SQL</h1><p id="be68" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">当使用<code class="fe mp mq mr ms b">SQL</code>检查数据时，使用了以下脚本。注意到它加入了<code class="fe mp mq mr ms b">FirstName</code>、<code class="fe mp mq mr ms b">LastName</code>、<code class="fe mp mq mr ms b">AddressPostcode</code>和<code class="fe mp mq mr ms b">CustomerID</code>字段。查询结果返回所有数据。这意味着它无法确定任何重复。因此，SQL 不能用于此目的。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="d4f1" class="my lt iq ms b gy mz na l nb nc">/* Check for duplicates between the two tables. */<br/>SELECT *<br/>FROM JohnSmiths t1<br/>WHERE EXISTS (<br/>    SELECT 'x'<br/>    FROM JohnSmiths t2<br/>    WHERE t1.FirstName=t2.FirstName<br/>        AND t1.LastName=t2.LastName<br/>        AND t1.AddressPostcode=t2.AddressPostcode<br/>        AND t1.CustomerID=t2.CustomerID<br/>    )</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi no"><img src="../Images/c7e6866b4fda92b0fb2bcea24e00303a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FIjWGNBwNqz4gxzaUd0ivw.png"/></div></div></figure><h1 id="6305" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.使用 R</h1><h2 id="6a1e" class="my lt iq bd lu nd ne dn ly nf ng dp mc ko nh ni me ks nj nk mg kw nl nm mi nn bi translated">4.1.概观</h2><p id="66f6" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">要通过模糊匹配查找重复项，请遵循以下步骤:</p><ol class=""><li id="185d" class="np nq iq kh b ki kj kl km ko nr ks ns kw nt la nu nv nw nx bi translated">将中的关键字段连接成每行的单个文本字符串</li><li id="2bff" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">计算每条记录的字符串长度。</li><li id="d61e" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">创建字符串距离矩阵(使用<code class="fe mp mq mr ms b"><a class="ae lb" href="https://www.rdocumentation.org/packages/stringdist/versions/0.9.5.5" rel="noopener ugc nofollow" target="_blank">stringdist</a></code>包中的<code class="fe mp mq mr ms b"><a class="ae lb" href="https://www.rdocumentation.org/packages/stringdist/versions/0.9.5.5/topics/stringdist" rel="noopener ugc nofollow" target="_blank">stringdistmatrix()</a></code>函数)。</li><li id="2c02" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">将字符串距离矩阵归一化为 0 到 1 之间的值:<br/> 4.1。创建一个最大长度的成对向量。<br/> 4.2。将距离长度除以较长字符串的长度。</li><li id="7b6d" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">创建相似性矩阵</li><li id="f171" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">识别高于相似性阈值的每对记录。</li><li id="b558" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">显示结果记录。</li></ol><h2 id="d2c8" class="my lt iq bd lu nd ne dn ly nf ng dp mc ko nh ni me ks nj nk mg kw nl nm mi nn bi translated">4.2 演练</h2><p id="7f19" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">第一步是将字符串连接在一起。这是使用<code class="fe mp mq mr ms b">paste()</code>功能完成的。产生的向量如下所示(为了方便起见，每个元素都放在一个新行上)。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="67d1" class="my lt iq ms b gy mz na l nb nc"># Create concatenated vector<br/>vec_Strings &lt;- dat_JohnSmiths %&gt;% <br/>    mutate(strings=paste0(FirstName<br/>                         ,LastName<br/>                         ,AddressLine1<br/>                         ,AddressPostcode<br/>                         ,AddressSuburb<br/>                         ,Phone<br/>                         )) %&gt;% <br/>    select(strings) %&gt;% <br/>    pull()</span><span id="3414" class="my lt iq ms b gy od na l nb nc"># Review<br/>vec_Strings %&gt;% cat(sep="\n")</span><span id="f28c" class="my lt iq ms b gy od na l nb nc">&gt;  JohnSmith12 Acadia Rd9671Burnton1234 5678<br/>&gt;  JhonSmith12 Arcadia Road967Bernton1233 5678<br/>&gt;  JSmith12 Acadia Ave867`1Burnton1233 567<br/>&gt;  JohnSmith13 Kynaston Rd9671Burnton34561234<br/>&gt;  JohnSmithNA9671Burnton34561233<br/>&gt;  JohnS12 Kinaston Road9677Bernton34561223<br/>&gt;  JonSmith13 Kinaston Rd9761Barnston36451223<br/>&gt;  JohnSmith12 Aracadia St9761Brenton12345666<br/>&gt;  JohnSmith13 Acacia Ave8961Burnside67231231<br/>&gt;  JohnSmith12 Kingsford Rd9671Burnton89624328</span></pre><p id="30c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，必须使用<code class="fe mp mq mr ms b"><a class="ae lb" href="https://www.rdocumentation.org/packages/stringr/versions/1.4.0" rel="noopener ugc nofollow" target="_blank">stringr</a></code>包中的<code class="fe mp mq mr ms b"><a class="ae lb" href="https://www.rdocumentation.org/packages/stringr/versions/1.4.0/topics/str_length" rel="noopener ugc nofollow" target="_blank">str_length()</a></code>函数计算每条记录的字符串长度。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="2fef" class="my lt iq ms b gy mz na l nb nc"># Create vector of lengths<br/>vec_Lengths &lt;- str_length(vec_Strings)</span><span id="8b78" class="my lt iq ms b gy od na l nb nc"># Review the vector<br/>vec_Lengths %&gt;% print()</span><span id="99d4" class="my lt iq ms b gy od na l nb nc">&gt;   [1] 41 43 39 42 30 40 42 42 42 43</span></pre><p id="9d4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，使用<code class="fe mp mq mr ms b"><a class="ae lb" href="https://www.rdocumentation.org/packages/stringdist/versions/0.9.5.5" rel="noopener ugc nofollow" target="_blank">stringdist</a></code>包中的<code class="fe mp mq mr ms b"><a class="ae lb" href="https://www.rdocumentation.org/packages/stringdist/versions/0.9.5.5/topics/stringdist" rel="noopener ugc nofollow" target="_blank">stringdistmatrix()</a></code>函数计算字符串距离矩阵。注意通过使用超参数<code class="fe mp mq mr ms b">method="osa"</code>使用最佳字符串对齐算法。这个函数将值保存在一个一维数组中，但是在打印时，它会显示距离矩阵的下三角。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="2c1d" class="my lt iq ms b gy mz na l nb nc"># Create distance matrix<br/>vec_Distances &lt;- stringdistmatrix(vec_Strings, method=”osa”)</span><span id="e6db" class="my lt iq ms b gy od na l nb nc"># Review<br/>vec_Distances %&gt;% print()</span><span id="ad41" class="my lt iq ms b gy od na l nb nc">&gt;      1  2  3  4  5  6  7  8  9<br/>&gt;  2   7                        <br/>&gt;  3  10 13                     <br/>&gt;  4  15 21 24                  <br/>&gt;  5  18 25 25 15               <br/>&gt;  6  22 21 28 12 17            <br/>&gt;  7  20 23 26  9 21 14         <br/>&gt;  8  10 13 17 20 22 25 22      <br/>&gt;  9  19 22 19 21 23 29 23 22   <br/>&gt;  10 17 22 25 13 22 19 16 22 24</span></pre><p id="6e24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，需要计算每对记录的最大长度。这可以通过<code class="fe mp mq mr ms b"><a class="ae lb" href="https://www.rdocumentation.org/packages/utils/versions/3.6.2" rel="noopener ugc nofollow" target="_blank">utils</a></code>包中的<code class="fe mp mq mr ms b"><a class="ae lb" href="https://www.rdocumentation.org/packages/utils/versions/3.6.2/topics/combn" rel="noopener ugc nofollow" target="_blank">combn()</a></code>函数来实现。该函数采用以下参数:</p><ol class=""><li id="d4ca" class="np nq iq kh b ki kj kl km ko nr ks ns kw nt la nu nv nw nx bi translated">要迭代的长度向量。</li><li id="99d9" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">要选择的元素数量的数值。值<code class="fe mp mq mr ms b">2</code>表示它将匹配记录对。</li><li id="faed" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">将应用于每对的函数。在这种情况下，选择<code class="fe mp mq mr ms b">max()</code>功能。</li><li id="5ae0" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">一个逻辑值，表示是将结果简化为一个向量还是返回一个列表。</li></ol><p id="3793" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产生的向量如下所示。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="33d1" class="my lt iq ms b gy mz na l nb nc"># Create Pairwise Vector<br/>vec_PairwiseMax &lt;- combn(vec_Lengths, 2, FUN=max, simplify=TRUE)</span><span id="0f1e" class="my lt iq ms b gy od na l nb nc"># Review<br/>vec_PairwiseMax</span><span id="8e61" class="my lt iq ms b gy od na l nb nc">&gt;   [1] 43 41 42 41 41 42 42 42 43 43 43 43 43 43 43 43 43 42 39 40 42 42 42<br/>&gt;  [24] 43 42 42 42 42 42 43 40 42 42 42 43 42 42 42 43 42 42 43 42 43 43</span></pre><p id="fef2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，计算归一化的距离矩阵。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="bf0c" class="my lt iq ms b gy mz na l nb nc"># Calculate normalised values<br/>vec_NormalisedDistances &lt;- vec_Distances/vec_PairwiseMax</span><span id="d70f" class="my lt iq ms b gy od na l nb nc"># Review<br/>vec_NormalisedDistances</span><span id="ab30" class="my lt iq ms b gy od na l nb nc">&gt;          1      2      3      4      5      6      7      8      9<br/>&gt;  2  0.1628                                                        <br/>&gt;  3  0.2439 0.3023                                                 <br/>&gt;  4  0.3571 0.4884 0.5714                                          <br/>&gt;  5  0.4390 0.5814 0.6410 0.3571                                   <br/>&gt;  6  0.5366 0.4884 0.7000 0.2857 0.4250                            <br/>&gt;  7  0.4762 0.5349 0.6190 0.2143 0.5000 0.3333                     <br/>&gt;  8  0.2381 0.3023 0.4048 0.4762 0.5238 0.5952 0.5238              <br/>&gt;  9  0.4524 0.5116 0.4524 0.5000 0.5476 0.6905 0.5476 0.5238       <br/>&gt;  10 0.3953 0.5116 0.5814 0.3023 0.5116 0.4419 0.3721 0.5116 0.5581</span></pre><p id="4403" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，归一化的距离被强制到一个矩阵中。创建后，确保不重复计算两次是很重要的。要做到这一点，右上角的三角形和对角线都是零的。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="b057" class="my lt iq ms b gy mz na l nb nc"># Create Similarity Matrix<br/>mat_SimilarityScore &lt;- round(1-vec_NormalisedDistances, 2) %&gt;% as.matrix()</span><span id="fb50" class="my lt iq ms b gy od na l nb nc"># Make the upper triangle all zero’s. This is to avoid double-counting duplicates.<br/>mat_SimilarityScore[upper.tri(mat_SimilarityScore)] &lt;- 0</span><span id="5e73" class="my lt iq ms b gy od na l nb nc"># Make the diagonals all zero’s. This is to ensure that the same string does not get matched to itself.<br/>mat_SimilarityScore[diag(mat_SimilarityScore)] &lt;- 0</span><span id="69c7" class="my lt iq ms b gy od na l nb nc"># Review<br/>mat_SimilarityScore</span><span id="1cd1" class="my lt iq ms b gy od na l nb nc">&gt;        1    2    3    4    5    6    7    8    9 10<br/>&gt;  1  0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00  0<br/>&gt;  2  0.84 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00  0<br/>&gt;  3  0.76 0.70 0.00 0.00 0.00 0.00 0.00 0.00 0.00  0<br/>&gt;  4  0.64 0.51 0.43 0.00 0.00 0.00 0.00 0.00 0.00  0<br/>&gt;  5  0.56 0.42 0.36 0.64 0.00 0.00 0.00 0.00 0.00  0<br/>&gt;  6  0.46 0.51 0.30 0.71 0.57 0.00 0.00 0.00 0.00  0<br/>&gt;  7  0.52 0.47 0.38 0.79 0.50 0.67 0.00 0.00 0.00  0<br/>&gt;  8  0.76 0.70 0.60 0.52 0.48 0.40 0.48 0.00 0.00  0<br/>&gt;  9  0.55 0.49 0.55 0.50 0.45 0.31 0.45 0.48 0.00  0<br/>&gt;  10 0.60 0.49 0.42 0.70 0.49 0.56 0.63 0.49 0.44  0</span></pre><p id="da8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为参考，相似性矩阵的详细信息打印如下。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="d6c6" class="my lt iq ms b gy mz na l nb nc">&gt;  Name: mat_SimilarityScore<br/>&gt;  Type: matrix<br/>&gt;  Dims: 10 x 10<br/>&gt;  Size: 2.6 Kb</span></pre><p id="4a1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，将识别高于给定阈值的值。为了实现这一点，编写了一个自定义函数。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="894f" class="my lt iq ms b gy mz na l nb nc"># Add function for identifying scores above a given threshold.<br/>tlargest &lt;- function(matrix, threshold, print=FALSE) {<br/>    #' @title Return Matrix Values Above A Threshold<br/>    #' @description Subset a matrix to return values that are above a specified threshold.<br/>    #' @note Will also print the count of how many records were matched. Necessary due to the ambiguity of using a threshold value.<br/>    #' @param matrix matrix. A matrix, which is the matrix to be sub-set.<br/>    #' @param threshold numeric. A single numeric value, corresponding to the threshold, above which values are to be returned.<br/>    #' @return A matrix containing columns:<br/>    #' — 'row' : A numeric value corresponding to the row index of the returned value.<br/>    #' — 'col' : A numeric value corresponding to the column index of the returned value.<br/>    #' — 'val' : A numeric value which is the similarity score between the 'row' and 'col' values.<br/> <br/>    # Validations:<br/>    if (!is.matrix(matrix)) {stop("'matrix' must be a matrix")}<br/>    if (!is.numeric(matrix)) {stop("'matrix' must be numeric")}<br/>    if (!length(threshold)==1) {stop("'threshold' must be atomic")}<br/>    if (!is.numeric(threshold)) {stop("'threshold' must be numeric")}<br/>    if (!between(threshold, 0, 1)) {stop("'threshold' must be between 0 and 1")}<br/> <br/>    # Determine the indices to be returned<br/>    sort &lt;- sort(matrix, decreasing=TRUE)<br/>    order &lt;- order(matrix, decreasing=TRUE)<br/>    order &lt;- order[sort&gt;=threshold]<br/>    <br/>    # Generate the matrix of indices to be returned<br/>    position &lt;- arrayInd(order, dim(matrix), useNames=TRUE)<br/>    position &lt;- set_colnames(position, c("rec1", "rec2"))<br/>    position &lt;- cbind(position, val=matrix[order])<br/>    <br/>    # Print subset number<br/>    if (print==TRUE) {<br/>        cat("Selected threshold : ", threshold, "\n"<br/>           ,"Matching records   : ", nrow(position), "\n"<br/>           ,"Total records      : ", nrow(matrix), "\n"<br/>           ,"Matching percent   : ", nrow(position)/nrow(matrix)<br/>           ,sep=""<br/>           )<br/>    }<br/>    <br/>    # Return<br/>    return(position)<br/>    <br/>}</span></pre><p id="c4fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当应用该函数时，将生成如下所示的矩阵。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="f4fb" class="my lt iq ms b gy mz na l nb nc"># Generate matching records<br/>mat_MatchingRecords &lt;- tlargest(matrix = mat_SimilarityScore<br/>                               ,threshold = 0.7<br/>                               ,print = TRUE<br/>                               )</span><span id="312d" class="my lt iq ms b gy od na l nb nc">&gt;  Selected threshold : 0.7<br/>&gt;  Matching records   : 8<br/>&gt;  Total records      : 10<br/>&gt;  Matching percent   : 0.8</span><span id="6de3" class="my lt iq ms b gy od na l nb nc"><br/># Review<br/>mat_MatchingRecords</span><span id="f15e" class="my lt iq ms b gy od na l nb nc">&gt;       rec1 rec2  val<br/>&gt;  [1,]    2    1 0.84<br/>&gt;  [2,]    7    4 0.79<br/>&gt;  [3,]    3    1 0.76<br/>&gt;  [4,]    8    1 0.76<br/>&gt;  [5,]    6    4 0.71<br/>&gt;  [6,]    3    2 0.70<br/>&gt;  [7,]    8    2 0.70<br/>&gt;  [8,]   10    4 0.70</span></pre><p id="6137" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦识别出匹配的记录，就需要从原始表中提取它们。为此，再次编写一个自定义函数。它获取原始数据帧和相似性矩阵，然后遍历矩阵，从数据帧中提取相关记录。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="b24e" class="my lt iq ms b gy mz na l nb nc">find_MatchingRecords &lt;- function(dataframe, sim_matrix, print=FALSE) {<br/>    #' @title Find Mathching Records<br/>    #' @description Use 'sim_matrix' to find matching records from 'dataframe'.<br/>    #' @note The `sim_matrix` contains the similarity matrix, generated from `stringdistmatrix()` and the `nlargest()` (or `tlargest()`) functions.<br/>    #' @param dataframe dataframe. The dataframe from which the matching records will be extracted.<br/>    #' @param sim_matrix matrix. The matrix containing the attributes for finding the matching records.<br/>    #' @param print logical. Whether or not to print the output as a text string.<br/>    #' @return A data.frame containing the score and the records that have been matched. Also, this is printed to the console.<br/>    <br/>    # Validations<br/>    if (!is.data.frame(dataframe)) {stop("'dataframe' must be a dataframe")}<br/>    if (!is.matrix(sim_matrix)) {stop("'sim_matrix' must be a matrix.")}<br/>    if (!is.double(sim_matrix[[2]])) {stop("'sim_matrix' must be a numeric matrix.")}<br/>    if (c("rec1","rec2") %&gt;% is_in(colnames(sim_matrix)) %&gt;% all() %&gt;% not()) {stop("'sim_matrix' must contain two columns named: 'rec1' and 'rec2'.")}<br/>    <br/>    # Set output<br/>    str_return &lt;- NULL<br/>    dat_return &lt;- data.frame("Score"=NA_real_<br/>                            ,"Index1"=NA_real_<br/>                            ,"Record1"=NA_character_<br/>                            ,"Index2"=NA_real_<br/>                            ,"Record2"=NA_character_<br/>                            ,stringsAsFactors=FALSE<br/>                            )<br/>    <br/>    # Determine number of itterations<br/>    iterations &lt;- sim_matrix %&gt;% nrow()<br/>    <br/>    # Loop through number of itteraions<br/>    for (i in 1:iterations) {<br/>        <br/>        # Extract score<br/>        sim_score &lt;- sim_matrix %&gt;% <br/>            extract(i, 3)<br/>        <br/>        # Extract the first matching index<br/>        rec1_index &lt;- sim_matrix %&gt;%<br/>            extract(i,1)<br/>        <br/>        # Extract first matching record<br/>        rec1_record &lt;- sim_matrix %&gt;% <br/>            extract(i,1) %&gt;% <br/>            extract(dataframe, ., ) %&gt;% <br/>            as.character() %&gt;% <br/>            paste(collapse=" ")<br/>        <br/>        # Extract the second matching index<br/>        rec2_index &lt;- sim_matrix %&gt;% <br/>            extract(i,2)<br/>        <br/>        # Extract second matching record<br/>        rec2_record &lt;- sim_matrix %&gt;% <br/>            extract(i,2) %&gt;% <br/>            extract(dataframe, ., ) %&gt;% <br/>            as.character() %&gt;% <br/>            paste(collapse=" ")<br/>        <br/>        # Build return<br/>        str_return %&lt;&gt;% paste0("\n") %&gt;% <br/>            paste0("Score: ", sim_score, "\n") %&gt;% <br/>            paste0("Record 1: (Index ", rec1_index, ") ", rec1_record, "\n") %&gt;% <br/>            paste0("Record 2: (Index ", rec2_index, ") ", rec2_record, "\n") <br/>        dat_return[i,] &lt;- c(sim_score, rec1_index, rec1_record, rec2_index, rec2_record)<br/>        <br/>    }<br/>    <br/>    # Print str_return<br/>    if (print==TRUE) {<br/>        cat(str_return)<br/>    }<br/>    <br/>    # Return dat_return<br/>    return(dat_return)<br/>    <br/>}</span></pre><p id="db95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，当应用该函数时，数据显示如下。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="7dee" class="my lt iq ms b gy mz na l nb nc"># Generate data<br/>dat_MatchingRecords &lt;- find_MatchingRecords(dataframe = dat_JohnSmiths<br/>                                           ,sim_matrix = mat_MatchingRecords<br/>                                           ,print = TRUE<br/>                                           )</span><span id="cab4" class="my lt iq ms b gy od na l nb nc">&gt;  Score: 0.84<br/>&gt;  Record 1: (Index 2) 2 Jhon Smith Mr 12 Arcadia Road Bernton 967 1233 5678<br/>&gt;  Record 2: (Index 1) 1 John Smith Mr 12 Acadia Rd Burnton 9671 1234 5678<br/>&gt;  <br/>&gt;  Score: 0.79<br/>&gt;  Record 1: (Index 7) 7 Jon Smith Mr. 13 Kinaston Rd Barnston 9761 36451223<br/>&gt;  Record 2: (Index 4) 4 John Smith Mr 13 Kynaston Rd Burnton 9671 34561234<br/>&gt;  <br/>&gt;  Score: 0.76<br/>&gt;  Record 1: (Index 3) 3 J Smith Mr. 12 Acadia Ave Burnton 867`1 1233 567<br/>&gt;  Record 2: (Index 1) 1 John Smith Mr 12 Acadia Rd Burnton 9671 1234 5678<br/>&gt;  <br/>&gt;  Score: 0.76<br/>&gt;  Record 1: (Index 8) 8 John Smith Dr 12 Aracadia St Brenton 9761 12345666<br/>&gt;  Record 2: (Index 1) 1 John Smith Mr 12 Acadia Rd Burnton 9671 1234 5678<br/>&gt;  <br/>&gt;  Score: 0.71<br/>&gt;  Record 1: (Index 6) 6 John S Dr. 12 Kinaston Road Bernton 9677 34561223<br/>&gt;  Record 2: (Index 4) 4 John Smith Mr 13 Kynaston Rd Burnton 9671 34561234<br/>&gt;  <br/>&gt;  Score: 0.7<br/>&gt;  Record 1: (Index 3) 3 J Smith Mr. 12 Acadia Ave Burnton 867`1 1233 567<br/>&gt;  Record 2: (Index 2) 2 Jhon Smith Mr 12 Arcadia Road Bernton 967 1233 5678<br/>&gt;  <br/>&gt;  Score: 0.7<br/>&gt;  Record 1: (Index 8) 8 John Smith Dr 12 Aracadia St Brenton 9761 12345666<br/>&gt;  Record 2: (Index 2) 2 Jhon Smith Mr 12 Arcadia Road Bernton 967 1233 5678<br/>&gt;  <br/>&gt;  Score: 0.7<br/>&gt;  Record 1: (Index 10) 10 John Smith Dr 12 Kingsford Rd Burnton 9671 89624328<br/>&gt;  Record 2: (Index 4) 4 John Smith Mr 13 Kynaston Rd Burnton 9671 34561234</span></pre><p id="0436" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其数据帧如下所示:</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="1a7c" class="my lt iq ms b gy mz na l nb nc"># Review<br/>dat_MatchingRecords %&gt;% <br/>    kable() %&gt;% <br/>    kable_styling(bootstrap_options=c("striped", "bordered", "condensed")<br/>                 ,full_width=FALSE<br/>                 ,position="left"<br/>                 ) %&gt;% <br/>    (function(x){<br/>        x %&gt;% save_kable("Images/JohnSmithsMatching.png")<br/>        x %&gt;% return()<br/>    })</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oe"><img src="../Images/ccdb5314b8e9bcbf684d8376036efb7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xv9Azmx1l1fy69XVxsQeGg.png"/></div></div></figure><p id="dcae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如所见，该方法已经以合理的准确度水平识别了这些重复。</p><h2 id="c6ac" class="my lt iq bd lu nd ne dn ly nf ng dp mc ko nh ni me ks nj nk mg kw nl nm mi nn bi translated">4.3.包裹</h2><p id="2151" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">因此，在识别数据库中的重复项时，使用“模糊匹配”来识别不同记录集之间的相似性是很有用的。</p><p id="6dad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，考虑到本例中提供的数据是虚构的，对真实世界的数据执行相同的过程是有用的。</p><h1 id="6108" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.真实的例子</h1><p id="a337" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">使用从网上搜集的商业地址，同样的方法被应用。</p><h2 id="4780" class="my lt iq bd lu nd ne dn ly nf ng dp mc ko nh ni me ks nj nk mg kw nl nm mi nn bi translated">5.1.预处理</h2><p id="2325" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">数据是从 Excel 电子表格<code class="fe mp mq mr ms b">AddressData.xlsx</code>中加载的。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="eef1" class="my lt iq ms b gy mz na l nb nc"># Load Data<br/>dat_Addresses &lt;- find_rstudio_root_file() %&gt;% <br/>    paste0("/Data/", "AddressData.xlsx") %&gt;% <br/>    read_excel(col_types=c("text")) %&gt;% <br/>    data.frame()</span></pre><p id="8a1b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前 10 条记录如下所示:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi of"><img src="../Images/9a334c98732d23e5067768b4d0ff1afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*Iky4bSUnarqp6ICzdA6fXA.png"/></div></figure><p id="4ce0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据的详细信息显示如下:</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="16c1" class="my lt iq ms b gy mz na l nb nc">&gt;  Name: dat_Addresses<br/>&gt;  Type: data.frame<br/>&gt;  Dims: 19388 x 8<br/>&gt;  Size: 4.2 Mb<br/>&gt;  Field Counts:<br/>&gt;    field        distinct count distinct%<br/>&gt;  1 COMPANY       6320    19388 0.3259748<br/>&gt;  2 ADDRESS       8646    19388 0.4459459<br/>&gt;  3 CITY          2459    19388 0.1268310<br/>&gt;  4 STATE            8    19388 0.0004126<br/>&gt;  5 ZIP           1264    19388 0.0651950<br/>&gt;  6 ISOCNTRYCODE     1    19388 0.0000000</span></pre><p id="1cc0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，对地址执行一些预处理操作，以减小数据的大小。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="7f23" class="my lt iq ms b gy mz na l nb nc"># Mutate data.<br/># Steps:<br/># 1. Remove special characters<br/># 2. Remove numeric values (Street numbers, etc.)<br/># 3. Remove additional white spaces<br/># 4. Capitalise<br/># 5. Select distinct.<br/>dat_AddressesClean &lt;- dat_Addresses %&gt;% <br/>    mutate_all(str_replace_all, "[[:punct:]]", "") %&gt;% <br/>    mutate_at(c("COMPANY", "ADDRESS", "CITY", "STATE"), str_replace_all, "[0-9]", "") %&gt;% <br/>    mutate_all(str_squish) %&gt;% <br/>    mutate_all(str_to_upper) %&gt;% <br/>    distinct() %&gt;% <br/>    arrange(ISOCNTRYCODE, STATE, CITY, ADDRESS)</span><span id="3096" class="my lt iq ms b gy od na l nb nc"># Check result<br/>check_ObjectDetails(dat_AddressesClean) %&gt;% cat()</span><span id="1607" class="my lt iq ms b gy od na l nb nc"># Check result<br/>check_ObjectDetails(dat_AddressesClean) %&gt;% cat()</span><span id="1c53" class="my lt iq ms b gy od na l nb nc">&gt;  Name: dat_AddressesClean<br/>&gt;  Type: data.frame<br/>&gt;  Dims: 9945 x 6<br/>&gt;  Size: 1.5 Mb<br/>&gt;  Field Counts:<br/>&gt;    field        distinct count distinct%<br/>&gt;  1 COMPANY      6279     9945  0.6313725<br/>&gt;  2 ADDRESS      6267     9945  0.6301659<br/>&gt;  3 CITY         2344     9945  0.2356963<br/>&gt;  4 STATE           8     9945  0.0008044<br/>&gt;  5 ZIP          1264     9945  0.1270990<br/>&gt;  6 ISOCNTRYCODE    1     9945  0.0000000</span></pre><p id="7d96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，必须将数据一起粘贴到一个向量中，如下所示。现在数据可以进行模糊匹配了。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="6679" class="my lt iq ms b gy mz na l nb nc"># Create vector<br/>vec_Addresses &lt;- dat_AddressesClean %&gt;% <br/>    unite("vec", sep="") %&gt;% <br/>    pull()</span><span id="0b69" class="my lt iq ms b gy od na l nb nc"># Review<br/>vec_Addresses %&gt;%<br/>    head(10) %&gt;%<br/>    cat(sep="\n")<br/>&gt;  MELBOURNE FACADES PTY LTDANU ELLERY CRESACTONACT2601AU<br/>&gt;  IC FORMWORK SERVICES PTY LTDCLUNIES RDACTONACT2601AU<br/>&gt;  RICHARD CROOKES CONSTRUCTIONS PTYDALEY RDACTONACT2601AU<br/>&gt;  STOWE AUSTRALIA PTY LIMITEDELLERY CRESACTONACT2600AU<br/>&gt;  MELBOURNE FACADES PTY LTDELLERY CRESACTONACT2601AU<br/>&gt;  CONSTRUCTION CONTROL HOLDINGSSULLIVANS CREEK RDACTONACT2601AU<br/>&gt;  QUATTRO BUILDING SERVICES PTY LTDSULLIVANS CREEK RDACTONACT2601AU<br/>&gt;  IC FORMWORK SERVICES PTY LTDMORNINGTON ST AMANDA STAMAROOACT2914AU<br/>&gt;  RENROW STEEL PTY LTDCOPPER CRESBEARDACT2620AU<br/>&gt;  OPTIMUM BRICK BLOCKLAYINGCOPPER CRESBEARDACT2620AU</span></pre><p id="569a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.2 流程</p><p id="890f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对地址数据的处理已经被组合到单个块中，并被相应地处理。必须列出以下关键信息:</p><ul class=""><li id="6e27" class="np nq iq kh b ki kj kl km ko nr ks ns kw nt la og nv nw nx bi translated">初始输入向量是 9964 个元素长，而距离向量是 49635666 个元素长。</li><li id="d14e" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la og nv nw nx bi translated">距离向量是 378.7 Mb 大，而相似性矩阵是 758.7 Mb 大。</li><li id="97de" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la og nv nw nx bi translated">耗时 128.2 秒。请注意，这取决于处理器的计算能力。</li></ul><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="c455" class="my lt iq ms b gy mz na l nb nc"># Start the clock<br/>tic("\n\nTime to Process Data")</span><span id="cfe8" class="my lt iq ms b gy od na l nb nc"># Calculate the lengths<br/>vec_AddLengths &lt;- str_length(vec_Addresses)</span><span id="c6a4" class="my lt iq ms b gy od na l nb nc"># Calculate the distances<br/>vec_AddDistances &lt;- stringdistmatrix(vec_Addresses, method="osa")</span><span id="5c66" class="my lt iq ms b gy od na l nb nc"># Calculate the max lengths<br/>vec_AddPairwiseMax &lt;- combn(vec_AddLengths, 2, max, simplify=TRUE)</span><span id="6a13" class="my lt iq ms b gy od na l nb nc"># Normalise the distances<br/>vec_AddNormalisedDistances &lt;- vec_AddDistances/vec_AddPairwiseMax</span><span id="72a8" class="my lt iq ms b gy od na l nb nc"># Add object details to the output<br/>str_Output &lt;- c("vec_Addresses", "vec_AddLengths", "vec_AddDistances", "vec_AddPairwiseMax", "vec_AddNormalisedDistances") %&gt;% <br/>    check_ObjectDetails() %&gt;% <br/>    paste(sep="\n")</span><span id="49f2" class="my lt iq ms b gy od na l nb nc"># Create the similarity matrix<br/>mat_AddSimilarityScore &lt;- round(1-vec_AddNormalisedDistances, 2) %&gt;% as.matrix()</span><span id="cc62" class="my lt iq ms b gy od na l nb nc"># Add matrix to output<br/>str_Output %&lt;&gt;% paste(check_ObjectDetails(mat_AddSimilarityScore), sep="\n\n")</span><span id="87f0" class="my lt iq ms b gy od na l nb nc"># Tidy the matrix<br/>mat_AddSimilarityScore[upper.tri(mat_AddSimilarityScore)] &lt;- 0<br/>mat_AddSimilarityScore[diag(mat_AddSimilarityScore)] &lt;- 0</span><span id="8a1a" class="my lt iq ms b gy od na l nb nc"># Re-add matrix to output<br/>str_Output %&lt;&gt;% paste(check_ObjectDetails(mat_AddSimilarityScore), sep="\n\n")</span><span id="61c4" class="my lt iq ms b gy od na l nb nc"># Print the output<br/>cat(str_Output)</span><span id="d63b" class="my lt iq ms b gy od na l nb nc"># Stop the clock and print the time taken<br/>toc()</span><span id="6951" class="my lt iq ms b gy od na l nb nc">&gt;  Name: vec_Addresses<br/>&gt;  Type: character<br/>&gt;  Dims: 1 x 9945<br/>&gt;  Size: 1.2 Mb<br/>&gt;  <br/>&gt;  Name: vec_AddLengths<br/>&gt;  Type: integer<br/>&gt;  Dims: 1 x 9945<br/>&gt;  Size: 38.9 Kb<br/>&gt;  <br/>&gt;  Name: vec_AddDistances<br/>&gt;  Type: dist<br/>&gt;  Dims: 1 x 49446540<br/>&gt;  Size: 377.2 Mb<br/>&gt;  <br/>&gt;  Name: vec_AddPairwiseMax<br/>&gt;  Type: array<br/>&gt;  Dims: 1 x 49446540<br/>&gt;  Size: 188.6 Mb<br/>&gt;  <br/>&gt;  Name: vec_AddNormalisedDistances<br/>&gt;  Type: dist<br/>&gt;  Dims: 1 x 49446540<br/>&gt;  Size: 377.2 Mb<br/>&gt;  <br/>&gt;  Name: mat_AddSimilarityScore<br/>&gt;  Type: matrix<br/>&gt;  Dims: 9945 x 9945<br/>&gt;  Size: 755.8 Mb<br/>&gt;  <br/>&gt;  Name: mat_AddSimilarityScore<br/>&gt;  Type: matrix<br/>&gt;  Dims: 9945 x 9945<br/>&gt;  Size: 755.8 Mb<br/>&gt;  <br/>&gt;  Time to Process Data: 258.7 sec elapsed</span></pre><p id="a179" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果，记录现在可以匹配了。请注意，匹配记录的数量是 2389(占总数的 24%)。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="0683" class="my lt iq ms b gy mz na l nb nc"># Find matches<br/>mat_AddMatchingRecords &lt;- tlargest(matrix = mat_AddSimilarityScore<br/>                                  ,threshold = 0.8<br/>                                  ,print = TRUE<br/>                                  )</span><span id="a593" class="my lt iq ms b gy od na l nb nc">&gt;  Selected threshold : 0.8<br/>&gt;  Matching records   : 2185<br/>&gt;  Total records      : 9945<br/>&gt;  Matching percent   : 0.2197</span><span id="52c0" class="my lt iq ms b gy od na l nb nc"># Find records<br/>dat_AddMatchingRecords &lt;- find_MatchingRecords(dataframe = dat_AddressesClean<br/>                                              ,sim_matrix = mat_AddMatchingRecords<br/>                                              )</span></pre><p id="53ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦识别出这些匹配的记录，就可以将它们返回。为简单起见，每个相似性得分的前 10 个匹配项已在下面的块中返回。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="b55f" class="my lt iq ms b gy mz na l nb nc"># View 0.99<br/>dat_AddMatchingRecords %&gt;% <br/>    filter(Score==0.99) %&gt;% <br/>    head(10) %&gt;% <br/>    print_MatchingRecords() %&gt;% <br/>    cat()<br/>&gt;  Score: 0.99<br/>&gt;  Record 1: (Index 685) AUTOMATIC FIRE PROTECTION DESIGN THE NORTHERN RD BERKSHIRE PARK NSW 2765 AU<br/>&gt;  Record 2: (Index 684) AUTOMATIC FIRE PROTECTION DESIGN THE NORTHERN RD BERKSHIRE PARK NSW 2756 AU<br/>&gt;  <br/>&gt;  Score: 0.99<br/>&gt;  Record 1: (Index 1062) EJ CONSTRUCTIONS NSW PTY LIMITED ROBERTSON RD CENTENNTIAL PARK NSW 2021 AU<br/>&gt;  Record 2: (Index 1061) EJ CONSTRUCTIONS NSW PTY LIMITED ROBERTSON RD CENTENNIAL PARK NSW 2021 AU<br/>&gt;  <br/>&gt;  Score: 0.99<br/>&gt;  Record 1: (Index 2050) CPB DRAGADOS SAMSUNG JOINT VENTURE A COMMERCIAL RD KINGSGROVE NSW 2208 AU<br/>&gt;  Record 2: (Index 2049) CPB DRAGADOS SAMSUNG JOINT VENTURE A COMMERCIAL RD KINGSFROVE NSW 2208 AU<br/>&gt;  <br/>&gt;  Score: 0.99<br/>&gt;  Record 1: (Index 4593) CULLEN STEEL FABRICATIONS PTY LTD GATE WHARF HICKSON RD WALSH BAY NSW 2060 AU<br/>&gt;  Record 2: (Index 4592) CULLEN STEEL FABRICATIONS PTY LTD GATE WHARF HICKSON RD WALSH BAY NSW 2065 AU<br/>&gt;  <br/>&gt;  Score: 0.99<br/>&gt;  Record 1: (Index 5677) BM ALLIANCE COAL OPERATIONS PL CY HAY POINT OPERATIONS HAY POINT QLD 4740 AU<br/>&gt;  Record 2: (Index 5676) BM ALLIANCE COAL OPERATIONS PL CY HAY POINT OPERATIONS HAY POINT QLD 4744 AU</span></pre><p id="02d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当选择<code class="fe mp mq mr ms b">threshold=0.99</code>时，算法几乎完全匹配，记录之间只有单个字符的差异。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="030e" class="my lt iq ms b gy mz na l nb nc"># View 0.98<br/>dat_AddMatchingRecords %&gt;% <br/>    filter(Score==0.98) %&gt;% <br/>    head(10) %&gt;% <br/>    print_MatchingRecords() %&gt;% <br/>    cat()<br/>&gt;  Score: 0.98<br/>&gt;  Record 1: (Index 25) KENNARDS HIRE PTY LIMITED OATLEY CT BELCONNEN ACT 2617 AU<br/>&gt;  Record 2: (Index 24) KENNARDS HIRE PTY LIMITED OATLEY CT BELCONNEN ACT 2616 AU<br/>&gt;  <br/>&gt;  Score: 0.98<br/>&gt;  Record 1: (Index 152) ABS FACADE PTY LTD SHEPPARD ST HUME ACT 2620 AU<br/>&gt;  Record 2: (Index 149) ABS FACADE PTY LTD SHEPARD ST HUME ACT 2620 AU<br/>&gt;  <br/>&gt;  Score: 0.98<br/>&gt;  Record 1: (Index 229) CRYSTAL POOLS PTY LTD DAVE MCINNES RD STROMLO ACT 2611 AU<br/>&gt;  Record 2: (Index 228) CRYSTAL POOLS PTY LTD DAVE MCINNES RD STOMLO ACT 2611 AU<br/>&gt;  <br/>&gt;  Score: 0.98<br/>&gt;  Record 1: (Index 410) RICHARD CROOKES CONSTRUCTIONS PTY PRINCESS HWY ARNCLIFFE NSW 2205 AU<br/>&gt;  Record 2: (Index 403) RICHARD CROOKES CONSTRUCTIONS PTY PRINCES HWY ARNCLIFFE NSW 2205 AU<br/>&gt;  <br/>&gt;  Score: 0.98<br/>&gt;  Record 1: (Index 875) ODK CONSTRUCTION PTY LTD PARRAMATTA RD BURWOOD NSW 2134 AU<br/>&gt;  Record 2: (Index 478) ODK CONSTRUCTION PTY LTD PARRAMATTA RD B URWOOD NSW 2134 AU<br/>&gt;  <br/>&gt;  Score: 0.98<br/>&gt;  Record 1: (Index 574) EODO PTY LTD HAVANNAH ST BATHURST NSW 2795 AU<br/>&gt;  Record 2: (Index 570) EODO PTY LTD HAVANNAH ST BATHRUST NSW 2795 AU<br/>&gt;  <br/>&gt;  Score: 0.98<br/>&gt;  Record 1: (Index 749) LIN BETTY BUILDING GROUP PTY LTD A OXFORD ST BONDI JUNCTION NSW 2026 AU<br/>&gt;  Record 2: (Index 748) LIN BETTY BUILDING GROUP PTY LTD A OXFORD ST BONDI JUNCTION NSW 2022 AU<br/>&gt;  <br/>&gt;  Score: 0.98<br/>&gt;  Record 1: (Index 927) LAING O ROURKE AUSTRALIA CARDIGAL LN CAMPERDOWN NSW 2050 AU<br/>&gt;  Record 2: (Index 926) LAING OROURKE AUSTRALIA CARDIGAL LN CAMPERDOWN NSW 2050 AU<br/>&gt;  <br/>&gt;  Score: 0.98<br/>&gt;  Record 1: (Index 1055) CJ SJ O KEEFFE BUILDING PTY LTD LOT NELSON ROAD CATTAI NSW 2756 AU<br/>&gt;  Record 2: (Index 1054) CJ SJ OKEEFFE BUILDING PTY LTD LOT NELSON ROAD CATTAI NSW 2756 AU<br/>&gt;  <br/>&gt;  Score: 0.98<br/>&gt;  Record 1: (Index 1083) METRO CHATSWOOD JHCPBG JV MOWBRAY RD CHATSWOOD NSW 2067 AU<br/>&gt;  Record 2: (Index 1081) METRO CHATSWOOD JHCPBG JV MOWBRAY RD CHATSWOOD NSW 2057 AU</span></pre><p id="c908" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当选择<code class="fe mp mq mr ms b">threshold=0.98</code>时，算法也几乎完全匹配，记录之间也只有单个字符的差异。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="d4b2" class="my lt iq ms b gy mz na l nb nc"># View 0.8<br/>dat_AddMatchingRecords %&gt;% <br/>    filter(Score==0.8) %&gt;% <br/>    head(10) %&gt;% <br/>    print_MatchingRecords() %&gt;% <br/>    cat()<br/>&gt;  Score: 0.8<br/>&gt;  Record 1: (Index 67) IC FORMWORK SERVICES PTY LTD CHALLIS ST DICKSON ACT 2602 AU<br/>&gt;  Record 2: (Index 2) IC FORMWORK SERVICES PTY LTD CLUNIES RD ACTON ACT 2601 AU<br/>&gt;  <br/>&gt;  Score: 0.8<br/>&gt;  Record 1: (Index 43) IC FORMWORK SERVICES PTY LTD CNR OF HOBART PL LONDON CCT CANBERRA ACT 2601 AU<br/>&gt;  Record 2: (Index 36) IC FORMWORK SERVICES PTY LTD CNR CONSTITUTION AVE AND LONDON CCT CANBERRA ACT 2601 AU<br/>&gt;  <br/>&gt;  Score: 0.8<br/>&gt;  Record 1: (Index 141) TS ANDREW TAYLOR SAWMILL CCT HUME ACT 2620 AU<br/>&gt;  Record 2: (Index 139) TS ALEX GARNER SAWMILL CCT HUME ACT 2620 AU<br/>&gt;  <br/>&gt;  Score: 0.8<br/>&gt;  Record 1: (Index 187) ACT INTERIORS HUDDART CT MITCHELL ACT 2911 AU<br/>&gt;  Record 2: (Index 175) ACT INTERIORS BROOKS ST MITCHELL ACT 2911 AU<br/>&gt;  <br/>&gt;  Score: 0.8<br/>&gt;  Record 1: (Index 292) TS DHAWAL NANDA BOURKE RD ALEXANDRIA NSW 2015 AU<br/>&gt;  Record 2: (Index 270) TS GEORGE NAJJAR BOURKE RD ALEXANDRIA NSW 2015 AU<br/>&gt;  <br/>&gt;  Score: 0.8<br/>&gt;  Record 1: (Index 295) SCHAI DARREN BOURKE RD ALEXANDRIA NSW 2015 AU<br/>&gt;  Record 2: (Index 278) SMITH STEVEN BOURKE RD ALEXANDRIA NSW 2015 AU<br/>&gt;  <br/>&gt;  Score: 0.8<br/>&gt;  Record 1: (Index 302) ABS FACADE PTY LTD BOURKE RD ALEXANDRIA NSW 2015 AU<br/>&gt;  Record 2: (Index 281) DELTA PTY LTD BOURKE RD ALEXANDRIA NSW 2015 AU<br/>&gt;  <br/>&gt;  Score: 0.8<br/>&gt;  Record 1: (Index 311) CPB CONTRACTORS PTY LTD BOURKE RD ALEXANDRIA NSW 2015 AU<br/>&gt;  Record 2: (Index 297) FLEXEM CONSTRUCTION PTY LTD BOURKE RD ALEXANDRIA NSW 2015 AU<br/>&gt;  <br/>&gt;  Score: 0.8<br/>&gt;  Record 1: (Index 300) CHAN PETER BOURKE RD ALEXANDRIA NSW 2015 AU<br/>&gt;  Record 2: (Index 299) LOCANO PAULO BOURKE RD ALEXANDRIA NSW 2015 AU<br/>&gt;  <br/>&gt;  Score: 0.8<br/>&gt;  Record 1: (Index 307) PETER CHAN BOURKE RD ALEXANDRIA NSW 2015 AU<br/>&gt;  Record 2: (Index 305) PAULO LOCANO BOURKE RD ALEXANDRIA NSW 2015 AU</span></pre><p id="f477" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当选择<code class="fe mp mq mr ms b">threshold&gt;0.9</code>时，算法也几乎完全匹配，记录之间也只有单个字符的差异。然而，当选择<code class="fe mp mq mr ms b">threshold=0.8</code>时，算法产生了错误匹配。例如:</p><ul class=""><li id="1b01" class="np nq iq kh b ki kj kl km ko nr ks ns kw nt la og nv nw nx bi translated">记录<code class="fe mp mq mr ms b">43</code>和<code class="fe mp mq mr ms b">36</code>实际上可能是匹配的副本，因为它们都是<code class="fe mp mq mr ms b">LONDON CCT</code>上的<code class="fe mp mq mr ms b">IC FORMWORK SERVICES</code>。</li><li id="10ad" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la og nv nw nx bi translated">记录<code class="fe mp mq mr ms b">141</code>和<code class="fe mp mq mr ms b">139</code>匹配了同一郊区同一街道上的不同商家。这是一个错误的匹配。</li><li id="383f" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la og nv nw nx bi translated">记录<code class="fe mp mq mr ms b">187</code>和<code class="fe mp mq mr ms b">175</code>匹配了同一郊区不同街道上的相同企业。这是一个错误的匹配。</li></ul><p id="5c95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，建议在使用小于<code class="fe mp mq mr ms b">0.9</code>的阈值时要谨慎。</p><h1 id="1928" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6.结论</h1><p id="6a41" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">总之，模糊匹配能够以合理的准确度成功地识别重复项。当将具有单个字符差异的字符串匹配在一起时，这些字符串会得到近乎完美的匹配分数(<code class="fe mp mq mr ms b">&gt;0.99</code>)。但是当阈值设置为<code class="fe mp mq mr ms b">~0.8</code>时，那么逻辑就开始匹配同一郊区同一街道的不同商家，或者同一郊区不同街道的同一商家等等。这对于实施来说是一个风险，因此必须仔细选择阈值。</p><p id="7421" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，由于在处理期间创建了相当大的对象，适当的数据分段是适当的，以避免引起计算问题。</p><p id="ff47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还要注意，数据输入验证总是比回顾性数据清理要好。在地址数据由外部方提供的情况下(如 EDI 连接)，应实施此解决方案。如果数据被识别为<code class="fe mp mq mr ms b">&gt;0.99</code>的置信区间，那么自动修改数据是合理的；但是，如果是<code class="fe mp mq mr ms b">~0.8</code>，那么最好将数据标记出来供员工查看。</p><h1 id="ffed" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">7.参考</h1><p id="2e4a" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">Awati 2019 年，“解决约翰·史密斯问题——通过 R 中的模糊匹配消除重复数据”，&lt;<a class="ae lb" href="https://eight2late.wordpress.com/2019/10/09/tackling-the-john-smith-problem-deduplicating-data-via-fuzzy-matching-in-r/" rel="noopener ugc nofollow" target="_blank">https://eight 2 late . WordPress . com/2019/10/09/cracking-the-John-Smith-Problem-de duplication-data-via-fuzzy-matching-in-R/</a>&gt;。</p><p id="3e9e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">维基百科 2019，‘余弦相似度’，【https://en.wikipedia.org/wiki/Cosine_similarity&gt;&lt;<a class="ae lb" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="db69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">维基百科 2019，‘编辑距离’，&lt;<a class="ae lb" href="https://en.wikipedia.org/wiki/Edit_distance" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Edit_distance</a>&gt;。</p><p id="2b3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">维基百科 2019，‘海明距离’，&lt;<a class="ae lb" href="https://en.wikipedia.org/wiki/Hamming_distance" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Hamming_distance</a>&gt;。</p><p id="0d85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">维基百科 2019，‘雅各布索引’，&lt;<a class="ae lb" href="https://en.wikipedia.org/wiki/Jaccard_index" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Jaccard_index</a>&gt;。</p><p id="d565" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">维基百科 2019，“贾罗-温克勒距离”，&lt;<a class="ae lb" href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance</a>&gt;。</p><p id="7ef3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">维基百科 2019，‘莱文斯坦距离’，&lt;<a class="ae lb" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Levenshtein_distance</a>&gt;。</p><p id="23fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">维基百科 2019，'最长公共子串问题'，&lt;<a class="ae lb" href="https://en.wikipedia.org/wiki/Longest_common_substring_problem" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Longest _ common _ substring _ problem</a>&gt;。</p><p id="3f23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">维基百科 2019，'最佳字符串对齐距离'，&lt;<a class="ae lb" href="https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance#Optimal_string_alignment_distance" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/damer au % E2 % 80% 93 levenshtein _ distance # Optimal _ string _ alignment _ distance</a>&gt;。</p><h1 id="6e41" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">8.附言</h1><p id="2be5" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">鸣谢:本报告是在他人的帮助下完成的。致谢发送至:</p><ol class=""><li id="fdf4" class="np nq iq kh b ki kj kl km ko nr ks ns kw nt la nu nv nw nx bi translated">Kailash Awati 因为我使用了他的原始文章(<a class="ae lb" href="https://eight2late.wordpress.com/2019/10/09/tackling-the-john-smith-problem-deduplicating-data-via-fuzzy-matching-in-r/" rel="noopener ugc nofollow" target="_blank">解决 John Smith 问题</a>)作为这篇文章的基础。</li></ol><p id="1f28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">出版物</strong>:该报告也在以下网站发布:</p><ol class=""><li id="a53e" class="np nq iq kh b ki kj kl km ko nr ks ns kw nt la nu nv nw nx bi translated">RPubs:<a class="ae lb" href="http://rpubs.com/chrimaho/AddressingTheJohnSmithProblem" rel="noopener ugc nofollow" target="_blank">RPubs/chrimaho/addressingthehohnsmithproblem</a></li><li id="1aa1" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">GitHub:<a class="ae lb" href="https://github.com/chrimaho/AddressingTheJohnSmithProblem" rel="noopener ugc nofollow" target="_blank">GitHub/chrimaho/addressingthehohnsmithproblem</a></li><li id="b159" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">中:<a class="ae lb" href="https://medium.com/@chrimaho/addressingthejohnsmithproblem-1533da4f7db8?source=friends_link&amp;sk=ae556dc05ee752a9b809092ca152da18" rel="noopener">中/chrimaho/addressingtheohnsmithproject</a></li></ol><p id="f24a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">更改日志</strong>:本出版物于以下日期修改:</p><ol class=""><li id="685f" class="np nq iq kh b ki kj kl km ko nr ks ns kw nt la nu nv nw nx bi translated">2020 年 7 月 4 日:原始出版日期。</li></ol></div></div>    
</body>
</html>