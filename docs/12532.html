<html>
<head>
<title>How to apply a CNN from PyTorch to your images.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将 PyTorch 中的 CNN 应用到您的图像中？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-apply-a-cnn-from-pytorch-to-your-images-18515416bba1?source=collection_archive---------9-----------------------#2020-08-29">https://towardsdatascience.com/how-to-apply-a-cnn-from-pytorch-to-your-images-18515416bba1?source=collection_archive---------9-----------------------#2020-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e522" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您将学习如何在几分钟内将下载的图像上传到 PyTorch。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1bc43087473e7df8db03b2fa07353745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s6WEPH8zPuM1JWAo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@marnhe?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marnhe du ploy</a>拍摄的照片</p></figure><p id="6163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大家好！今天我想谈谈把你的图片上传到你的 PyTorch CNN。</p><p id="0458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我们将讨论以下内容:</p><ul class=""><li id="ba22" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如何正确存储图像，让您可以轻松地将您的数据标记出来。</li><li id="794a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何使用 PyTorch 访问数据并在途中做一些预处理？</li><li id="8c18" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后，我们将使用一个非常简单的 CNN 对我们的图像进行分类。</li></ul><h1 id="3b65" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">首先，如何存储数据？</h1><p id="c0ef" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我将使用<a class="ae ky" href="https://www.kaggle.com/chetankv/dogs-cats-images" rel="noopener ugc nofollow" target="_blank">这个</a>数据集，其中包含了猫和狗的图像。</p><p id="ca89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储图像最简单的方法是为每个类创建一个文件夹，用类的名称命名文件夹。</p><p id="a9f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我举个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/6f20a6ce1e4e3e7898f0687c4f857883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hLVWZZ0pYr-r_zB4Tzr4Pg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c90c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需正确命名文件夹，就可以让 PyTorch 知道向哪个类断言图像。</p><h1 id="6f0a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">现在，让我们进入代码。</h1><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="c02c" class="nm mk it ni b gy nn no l np nq">import matplotlib.pyplot as plt<br/>from torchvision import datasets, transforms<br/>from torch.utils.data import DataLoader<br/>import torch.nn as nn<br/>import torch.nn.functional as F<br/>import torch.optim as optim<br/>import torch</span><span id="9ab0" class="nm mk it ni b gy nr no l np nq">def get_data():<br/>    data_dir = '/your_path/Data/'<br/><br/>    train_set = datasets.ImageFolder(data_dir + '/training_set')<br/>    test_set = datasets.ImageFolder(data_dir + '/test_set')<br/><br/>    return train_set, test_set</span></pre><p id="5b4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的函数从目录中获取数据。您只需指定到您的<strong class="lb iu">训练集</strong>和<strong class="lb iu">测试集</strong>文件夹的路径。PyTorch 随后会使用指定目录中的文件夹名称自动将标签分配给图像。</p><p id="7bdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，您可能想在使用图像之前做一些预处理，所以让我们做吧，此外，让我们马上创建一个<strong class="lb iu">数据加载器</strong>。为此，让我们在上面的代码中添加一些新行。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a138" class="nm mk it ni b gy nn no l np nq">def get_data():<br/>    data_dir = '/your_path/Data/'<br/>   <br/>    <strong class="ni iu">transform</strong> = transforms.Compose([<br/>        #transforms.RandomRotation(20),<br/>        transforms.RandomResizedCrop(128),<br/>        #transforms.RandomHorizontalFlip(),<br/>        transforms.ToTensor()])<br/><br/>    train_set = datasets.ImageFolder(data_dir + '/training_set', <strong class="ni iu">transform=transform</strong>)<br/>    test_set = datasets.ImageFolder(data_dir + '/test_set', <strong class="ni iu">transform=transform</strong>)<br/><br/>    train = <strong class="ni iu">DataLoader</strong>(train_set, batch_size=32, shuffle=True)<br/>    test = <strong class="ni iu">DataLoader</strong>(test_set, batch_size=32, shuffle=True)<br/><br/>    return train, test</span></pre><p id="2d5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在转换过程中，你可能需要对图像进行裁剪、翻转、调整大小、旋转等操作。为此，您可以使用<strong class="lb iu">转换</strong>在一个地方指定您需要的所有东西。然后，您可以使用上传的图像创建<strong class="lb iu">数据加载器</strong>。</p><h1 id="c04f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">这就是 CNN 发挥作用的地方。</h1><p id="6b97" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在，当您准备好数据后，您可能想快速浏览一下。为此，您可以使用这个简单的函数，它将显示前 5 幅图像。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="3d6e" class="nm mk it ni b gy nn no l np nq">def train_imshow():<br/>    classes = ('cat', 'dog') # Defining the classes we have<br/>    dataiter = iter(train)<br/>    images, labels = dataiter.next()<br/>    fig, axes = plt.subplots(figsize=(10, 4), ncols=5)<br/>    for i in range(5):<br/>        ax = axes[i]<br/>        ax.imshow(images[i].permute(1, 2, 0)) <br/>        ax.title.set_text(' '.join('%5s' % classes[labels[i]]))<br/>    plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/8680cea4f96f322feb047865b06a1d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*97yorD_88mkJsG975MeimQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="71c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来定义我们的卷积神经网络:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="11ae" class="nm mk it ni b gy nn no l np nq">class Net(nn.Module):<br/>    def __init__(self):<br/>        super(Net, self).__init__()<br/>        self.conv1 = nn.Conv2d(3, 6, 5)<br/>        self.pool = nn.MaxPool2d(8, 8)<br/>        self.conv2 = nn.Conv2d(6, 16, 5)<br/>        self.fc1 = nn.Linear(16, 100)<br/>        self.fc2 = nn.Linear(100, 50)<br/>        self.fc3 = nn.Linear(50, 2)<br/><br/>    def forward(self, x):<br/>        x = self.pool(F.relu(self.conv1(x)))<br/>        x = self.pool(F.relu(self.conv2(x)))<br/>        x = x.view(-1, 16)<br/>        x = F.relu(self.fc1(x))<br/>        x = F.relu(self.fc2(x))<br/>        x = self.fc3(x)<br/>        return x</span></pre><p id="174a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用了这里定义的网络<a class="ae ky" href="https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html" rel="noopener ugc nofollow" target="_blank">并做了一点修改，现在它可以和我的图片一起工作了。</a></p><p id="21ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以指定标准、优化器、学习率和训练网络。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="8461" class="nm mk it ni b gy nn no l np nq">criterion = nn.CrossEntropyLoss()<br/>optimizer = optim.SGD(net.parameters(), lr=0.01, momentum=0.9)</span><span id="b672" class="nm mk it ni b gy nr no l np nq">if torch.cuda.is_available(): # Checking if we can use GPU<br/>    model = net.cuda()<br/>    criterion = criterion.cuda()<br/><br/><br/>def train_net(n_epoch): # Training our network<br/>    losses = []<br/>    for epoch in range(n_epoch):  # loop over the dataset multiple times<br/>        running_loss = 0.0<br/>        for i, data in enumerate(train, 0):<br/>            # get the inputs; data is a list of [inputs, labels]<br/>            inputs, labels = data<br/><br/>            # zero the parameter gradients<br/>            optimizer.zero_grad()<br/><br/>            # forward + backward + optimize<br/>            outputs = net(inputs)<br/>            loss = criterion(outputs, labels)<br/>            loss.backward()<br/>            optimizer.step()<br/><br/>            # print statistics<br/>            losses.append(loss)<br/>            running_loss += loss.item()<br/>            if i % 100 == 99:  # print every 2000 mini-batches<br/>                print('[%d, %5d] loss: %.10f' %<br/>                      (epoch + 1, i + 1, running_loss / 2000))<br/>                running_loss = 0.0<br/>    plt.plot(losses, label='Training loss')<br/>    plt.show()<br/>    print('Finished Training')</span></pre><p id="9bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以保存和加载您训练过的网络。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="726c" class="nm mk it ni b gy nn no l np nq">PATH = './cat_dog_net.pth'<br/>torch.save(net.state_dict(), PATH)<br/><br/># Loading the trained network<br/>net.load_state_dict(torch.load(PATH))</span></pre><p id="5f81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把测试图像输入网络。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4a7d" class="nm mk it ni b gy nn no l np nq">correct = 0<br/>total = 0<br/>with torch.no_grad():<br/>    for data in test:<br/>        images, labels = data<br/>        outputs = net(images)<br/>        _, predicted = torch.max(outputs.data, 1)<br/>        total += labels.size(0)<br/>        correct += (predicted == labels).sum().item()<br/><br/>print('Accuracy of the network on the %d test images: %d %%' % (len(test),<br/>    100 * correct / total))</span></pre><p id="2a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试集误差为<strong class="lb iu"> 66% </strong>，这还不错，尽管获得尽可能好的精度并不是本文的目标。</p><p id="f51b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/Einnmann/DS_projects/blob/master/cats_and_dogs.py" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以找到完整的代码。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="1551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干得好！现在你已经准备好使用你的图像来练习深度学习了！</p><p id="bd77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>