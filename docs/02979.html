<html>
<head>
<title>The Quick and Easy Way to Plot Error Bars in Python Using Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pandas在Python中快速简单地绘制误差线</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-quick-and-easy-way-to-plot-error-bars-in-python-using-pandas-a4d5cca2695d?source=collection_archive---------8-----------------------#2020-03-22">https://towardsdatascience.com/the-quick-and-easy-way-to-plot-error-bars-in-python-using-pandas-a4d5cca2695d?source=collection_archive---------8-----------------------#2020-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="081a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不需要一行额外的代码！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a5315bcd4ce7d544df6a20255e295f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjHQslV6kmldBnPuAc49gA.png"/></div></div></figure><h1 id="7886" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">为什么你需要学习这个</h1><p id="31f4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在科学研究中，在你的描述性可视化中显示误差线是不可避免的。它们包含了关于数据可变性的信息，是对平均分数的必要补充。然而，科学形象的内在往往比外在更美丽。</p><p id="4986" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">作为<strong class="lo iu">的数据科学家</strong>，我们被教导使用有吸引力的可视化来讲述故事。任何分散观众注意力的东西都应该被删除。这非常有意义，因为经理和客户通常既没有很好地掌握统计数据，也没有太多的时间和精力花在你的可视化上。</p><p id="6480" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">要解释误差线，您需要:</p><ul class=""><li id="fc57" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">对描述性统计的基本理解</li><li id="93b0" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">显示哪种误差线的信息(通常是标准差或标准误差)</li></ul><p id="50c9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这两个假设都与数据故事讲述者的目的相冲突。你希望<strong class="lo iu">任何人</strong>理解结果<strong class="lo iu">而</strong>不必通读八行音符。</p><p id="eea2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">数据故事讲述者将误差线视为障碍，因为它们妨碍了对数据的简单、舒适和统一的解释。另一方面，科学家被训练显示所有必要的信息，并让读者自己解释结果。这两种方法都不优越。在技术报告或数据团队会议中过分简化结果，就像用自发的统计学讲座来烦你的经理和客户一样，都是不利的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/42a77b00b049119518f2be1e0b264093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OU_PWrvjOZW0sVRFlUWsuQ.png"/></div></div></figure><blockquote class="nc"><p id="3448" class="nd ne it bd nf ng nh ni nj nk nl mh dk translated">对于任何愿意证明其数据科学职称中的“科学”的人来说，学习何时以及如何使用误差线是不可避免的！</p></blockquote><p id="8273" class="pw-post-body-paragraph lm ln it lo b lp nm ju lr ls nn jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">当我为我的第一篇科学文章创建可视化时，我尝试了许多不同的方法。让我节省你一些时间，给你介绍一下我找到的又快又简单的方法。按照这篇文章并自己应用该方法，您需要的只是一些统计学、python和pandas库的基础知识。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="f9b6" class="ku kv it bd kw kx ny kz la lb nz ld le jz oa ka lg kc ob kd li kf oc kg lk ll bi translated">C<span class="l od oe of bm og oh oi oj ok di">计算</span></h1><p id="3232" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有两个主要参数适用于误差线。</p><ol class=""><li id="d81b" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ol mt mu mv bi translated">(2x)标准偏差</li><li id="b622" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ol mt mu mv bi translated">标准误差</li></ol><p id="a08f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我强烈建议您熟悉这些参数，这样您就可以做出明智的决定，为您的可视化使用哪个参数。在克劳迪娅·克莱门特的这篇文章中，这些概念以一种完美压缩的方式被解释。</p><p id="7c07" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，我们需要导入我们的库并加载我们的数据。我们将使用来自kaggle 的<a class="ae om" href="https://www.kaggle.com/neuromusic/avocado-prices" rel="noopener ugc nofollow" target="_blank">鳄梨价格数据集。你不需要太了解数据集。我们只想知道常规鳄梨和有机鳄梨(“类型”列)的价格是否不同(“平均价格”列)。</a></p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="ccea" class="os kv it oo b gy ot ou l ov ow"># Imports<br/>import pandas as pd<br/>import numpy as np # for calculating standard deviation and mean<br/>import scipy.stats as sp # for calculating standard error<br/>import matplotlib.pyplot as plt # for improving our visualizations</span><span id="4c66" class="os kv it oo b gy ox ou l ov ow"># Read data<br/>avocado = pd.read_csv("avocado.csv")</span></pre><p id="95db" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">执行我们的计算最简单的方法是使用熊猫<a class="ae om" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu"> df.groupby </strong> </a> <strong class="lo iu">函数。</strong>这个函数有许多有用的应用，但在这种情况下，我们将使用它进行统计参数的聚合计算。下面，你可以看到代码原型。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="59d5" class="os kv it oo b gy ot ou l ov ow">df.groupby("col_to_group_by").agg([func_1, func_2, func_3])</span></pre><blockquote class="nc"><p id="7a8d" class="nd ne it bd nf ng nh ni nj nk nl mh dk translated">我们使用df.groupby.agg来快速简便地计算组比较的统计参数。</p></blockquote><p id="0b79" class="pw-post-body-paragraph lm ln it lo b lp nm ju lr ls nn jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">我们已经有了要分组的数据帧和列，所以我们现在需要找到正确的函数。记住，我们需要平均值，标准差x 2和标准差。这些是我们需要的功能:</p><p id="d2e9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> NumPy </strong></p><ul class=""><li id="c213" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">平均:np .平均</li><li id="f0ea" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">标准差:np.std</li></ul><p id="131c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> SciPy </strong></p><ul class=""><li id="279b" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">标准错误:scipy.stats.sem</li></ul><p id="c5e2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">因为df.groupby.agg函数只接受一个函数列表作为输入，所以我们不能只使用np.std * 2来得到我们的双倍标准差。但是，我们可以只写自己的函数。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="cb67" class="os kv it oo b gy ot ou l ov ow">def double_std(array):<br/> return np.std(array) * 2</span></pre><p id="72c9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，让我们使用原型代码并填充占位符。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="2c7f" class="os kv it oo b gy ot ou l ov ow"># df.groupby("col_to_group_by").agg([func_1, func_2, func_3])<br/>avocado_prices = <br/>avocado.groupby("type").agg([np.mean, double_std, sp.sem])</span></pre><p id="c61b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">不错！现在，让我们只选择“AveragePrice”列，因为我们不需要其余的。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="5482" class="os kv it oo b gy ot ou l ov ow">avocado_prices = avocado_prices["AveragePrice"]</span></pre><p id="af2f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">avocado_prices.head()现在给出了以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/6468384b198ba57d986725b335d48ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*1-Xc4bpZCF87R1PDLcp4_w.png"/></div><p class="oz pa gj gh gi pb pc bd b be z dk translated">表1 — df.groupby.agg输出</p></figure><p id="1aa3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">太好了！现在我们有了所有需要的数据。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="3805" class="ku kv it bd kw kx ny kz la lb nz ld le jz oa ka lg kc ob kd li kf oc kg lk ll bi translated"><strong class="ak">可视化</strong></h1><p id="2c47" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Pandas有一个非常有用的功能，可以让我们快速获得第一次可视化，而无需经历整个matplotlib过程:<a class="ae om" href="https://pandas.pydata.org/pandas-docs/version/0.23.4/generated/pandas.DataFrame.plot.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu"> df.plot </strong> </a></p><p id="9eef" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这基本上是熊猫内部的matplotlib表示。</p><p id="2244" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为了得到没有任何误差线的第一个图，我们只需要<strong class="lo iu">一行代码</strong>:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="a5f2" class="os kv it oo b gy ot ou l ov ow">avocado_prices.plot(kind = "barh", y = "mean", legend = False, title = "Average Avocado Prices")</span></pre><p id="3ff9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/657d25f8e5d992e9df2285298bb3fba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A41JD234QJz-_xPuIZZjhQ.png"/></div></div><p class="oz pa gj gh gi pb pc bd b be z dk translated">图1-没有误差线</p></figure><p id="554d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们可以看到，有机鳄梨的平均价格高于传统鳄梨。但这是真正的差异还是只是随机传播？正如我在副标题中承诺的，<strong class="lo iu">我们不需要一行额外的代码</strong>来使用误差线回答这个问题。我们需要做的就是将我们的统计参数赋给xerr参数。让我们从“double_std”参数开始:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="95a6" class="os kv it oo b gy ot ou l ov ow">avocado_prices.plot(kind = "barh", y = "mean", legend = False, title = "Average Avocado Prices", xerr = "double_std")</span></pre><p id="aad6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2509a213e59a99d33dc80e79b71342d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6XA2F5rXk5DMkj8d9REqVA.png"/></div></div><p class="oz pa gj gh gi pb pc bd b be z dk translated">图2 —标准偏差x 2误差线</p></figure><p id="c6d0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">他们在那里！即使没有深入了解如何解释这些误差线，我们也可以看到价格的可变性相当高，并且每个误差线与另一个误差线相接触。也许这种差异并不像我们从第一个情节中所预期的那样明显和巨大？同样，我不会深入解释标准差和标准误差，因为这是一个实用指南。只是注意这个剧情给我们留下的印象和上一个不一样。</p><p id="3d35" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果我们接下来画出标准误差，会发生什么？</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="6548" class="os kv it oo b gy ot ou l ov ow">avocado_prices.plot(kind = "barh", y = "mean", legend = False, title = "Average Avocado Prices", xerr = "sem")</span></pre><p id="916c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/425e1c1cd8657ec375f25aeff819e96d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqhZzyTYKTOMl-NcKiI9bQ.png"/></div></div><p class="oz pa gj gh gi pb pc bd b be z dk translated">图3 —标准误差线</p></figure><p id="cfcd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">什么？误差线几乎看不见。标准误差对样本大小很敏感，因为它在大样本中比在小样本中低。鳄梨样本有超过250，000次观察，所以结果是合理的。这第三个情节又给人留下了完全不同的印象！</p><blockquote class="nc"><p id="c480" class="nd ne it bd nf ng pd pe pf pg ph mh dk translated">你是否以及如何使用误差线对你的可视化所讲述的“故事”有很大的影响。理解误差线背后的统计数据对于正确使用和解释它们是至关重要的。</p></blockquote><p id="757f" class="pw-post-body-paragraph lm ln it lo b lp nm ju lr ls nn jx lu lv no lx ly lz np mb mc md nq mf mg mh im bi translated">到目前为止，我们从一行代码中得到了<strong class="lo iu">非常好的结果。如果我们花更多的时间来改进我们的可视化，我们可以得到类似图4的东西。</strong></p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="2f3d" class="os kv it oo b gy ot ou l ov ow">ax = avocado_prices.plot(kind = "barh", y = "mean", legend = False, title = "Average Avocado Prices", colors = ["steelblue", "seagreen"]) # no error bars added here</span><span id="3375" class="os kv it oo b gy ox ou l ov ow"># X<br/>ax.set_xlabel("Price ($)")</span><span id="3b00" class="os kv it oo b gy ox ou l ov ow"># Y<br/>ax.set_ylabel("")<br/>ax.set_yticklabels(["Conventional", "Organic"])</span><span id="87a1" class="os kv it oo b gy ox ou l ov ow"># Overall<br/>for key, spine in ax.spines.items():<br/>    spine.set_visible(False)<br/>ax.tick_params(bottom = False, left = False)<br/>ax.errorbar(avocado_prices["mean"], avocado_prices.index, xerr = avocado_prices["double_std"], <br/>            linewidth = 1.5, color = "black", alpha = 0.4, capsize = 4)</span></pre><p id="9cd5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">输出:</strong></p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a5315bcd4ce7d544df6a20255e295f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjHQslV6kmldBnPuAc49gA.png"/></div></div><p class="oz pa gj gh gi pb pc bd b be z dk translated">图4 —最终图</p></figure><p id="7f03" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">用python创建误差线非常简单！使用一些高级的pandas函数，我们可以只用两行代码就从数据帧到有(或没有)误差线的可视化！但是，如果您还没有学习误差线背后的统计数据，您需要先学习一下。您看到了三个图(无误差棒线对虚线标准差对标准差)看起来有多么不同。起初这可能看起来很可怕，但是一旦你学会了，它是你数据科学技能组合中另一个非常有用的工具。</p><p id="4a72" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">感谢阅读！</strong></p></div></div>    
</body>
</html>