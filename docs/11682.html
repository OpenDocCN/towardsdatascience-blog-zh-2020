<html>
<head>
<title>Deep Learning with React Native (iOS only)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native 深度学习(仅限 iOS)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deep-learning-with-react-native-ios-only-8089fed59773?source=collection_archive---------19-----------------------#2020-08-13">https://towardsdatascience.com/deep-learning-with-react-native-ios-only-8089fed59773?source=collection_archive---------19-----------------------#2020-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e1f2f05af187d27312eff31a95f033e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dm0rZczn-IfHwL1o7rabUw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由作者提供)</p></figure><div class=""/><p id="5e20" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">文章原载于</em> <a class="ae le" href="https://dev.to/dittmarconsulting/deep-learning-with-react-native-ios-only-2470" rel="noopener ugc nofollow" target="_blank"> <em class="ld"> dev.to </em> </a></p><h2 id="14a1" class="lf lg ji bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">介绍</h2><p id="7c76" class="pw-post-body-paragraph kf kg ji kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">在本教程中，我将涵盖如何构建移动应用程序和训练深度学习模型的所有步骤，以便您可以通过使用手机的摄像头预测 0 到 9 之间的手写数字。</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi md"><img src="../Images/4131e2f57d87f49cc44801e140d3b611.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/1*Bk4GS5ff5r2uSUfknBfZDw.gif"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">预测手写数字的应用程序(作者图片)</p></figure><p id="1583" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是在我们开始构建移动应用之前，我们需要想出一个高层次的策略。让我们回顾一下思考过程:</p><ul class=""><li id="ebcc" class="mi mj ji kh b ki kj km kn kq mk ku ml ky mm lc mn mo mp mq bi translated">我们是构建一个纯 React-Native ( <strong class="kh jj"> RN </strong>)还是一个<strong class="kh jj"> Expo </strong>应用？</li><li id="560e" class="mi mj ji kh b ki mr km ms kq mt ku mu ky mv lc mn mo mp mq bi translated">我们想用哪个相机库？</li><li id="e5de" class="mi mj ji kh b ki mr km ms kq mt ku mu ky mv lc mn mo mp mq bi translated">我们需要裁剪图像吗？我们需要使用什么样的库？</li><li id="1350" class="mi mj ji kh b ki mr km ms kq mt ku mu ky mv lc mn mo mp mq bi translated">我们如何训练一个深度学习模型？</li><li id="c00c" class="mi mj ji kh b ki mr km ms kq mt ku mu ky mv lc mn mo mp mq bi translated">我们如何对照照片使用那个模型？</li><li id="37a8" class="mi mj ji kh b ki mr km ms kq mt ku mu ky mv lc mn mo mp mq bi translated">我们如何显示结果？</li></ul><blockquote class="mw mx my"><p id="4e17" class="kf kg ld kh b ki kj kk kl km kn ko kp mz kr ks kt na kv kw kx nb kz la lb lc im bi translated">注意:本教程需要一些先决条件和对 RN 和 Javascript 的全面理解。如果你是一个绝对的初学者，我建议在继续学习本教程之前，先在 Youtube、Udemy 或 Egghead 上学习一门好的课程。</p></blockquote><h2 id="719b" class="lf lg ji bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">我们开始吧</h2><p id="26df" class="pw-post-body-paragraph kf kg ji kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">我将把这个教程分成三个部分</p><p id="f13c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae le" href="#1a09" rel="noopener ugc nofollow"> <strong class="kh jj">第一章</strong>:创建 RN 应用</a> <br/> <a class="ae le" href="#c7cf" rel="noopener ugc nofollow"> <strong class="kh jj">第二章</strong>:训练深度学习模型</a> <br/> <a class="ae le" href="#01f8" rel="noopener ugc nofollow"> <strong class="kh jj">第三章</strong>:实现模型，预测并展示结果</a></p><h2 id="1a09" class="lf lg ji bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">第 1 章:创建 RN 应用程序</h2><p id="cec5" class="pw-post-body-paragraph kf kg ji kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">还记得我们思考过程的第一点是创建一个裸应用还是 Expo 样板应用吗？</p><p id="c5e7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">经过一些研究，我决定在本地加载训练好的模型。这是最简单的方法，不需要从云服务器获取模型，但是你也可以这样做。</p><p id="e765" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在本教程中，我们将使用<code class="fe nc nd ne nf b"><a class="ae le" href="http://twitter.com/tensorflow/tfjs-react-native" rel="noopener ugc nofollow" target="_blank">@tensorflow/tfjs-react-native</a></code>中不幸与 Expo 不兼容的<code class="fe nc nd ne nf b">bundleResourceIO</code>。</p><blockquote class="mw mx my"><p id="136a" class="kf kg ld kh b ki kj kk kl km kn ko kp mz kr ks kt na kv kw kx nb kz la lb lc im bi translated">此外，因为我们想使用相机，我们必须使用物理手机，而不是模拟器。为此，你必须有一个苹果开发者帐户来签署你的应用程序，否则你将无法运行该应用程序。</p></blockquote><p id="f590" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们使用以下命令创建应用程序:</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="19e0" class="lf lg ji nf b gy nk nl l nm nn">$ react-native init MyFirstMLApp</span></pre><p id="07c1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">安装过程完成后，请确保您的所有豆荚也已安装！</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="2781" class="lf lg ji nf b gy nk nl l nm nn">$ cd MyFirstMLApp<br/>$ npx pod-install</span></pre><p id="ba37" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们在你的物理 iPhone 上第一次运行这个应用程序。打开 Xcode，找到<code class="fe nc nd ne nf b">MyFirstMLApp.xcworkspace</code>并打开。使用 lightning 线缆将 iPhone 连接到 Mac，然后选择您的手机。首次构建和运行应用程序时，请按播放按钮。你应该会在你的 iPhone 上看到<strong class="kh jj">欢迎反应</strong>屏幕。</p><p id="4a0f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">🏆<strong class="kh jj">牛逼！</strong></p><p id="4edf" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们为这个应用程序添加一些包:</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="94df" class="lf lg ji nf b gy nk nl l nm nn">yarn add <a class="ae le" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-native-community/async-storage <a class="ae le" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-native-community/cameraroll <a class="ae le" href="http://twitter.com/tensorflow/tfjs" rel="noopener ugc nofollow" target="_blank">@tensorflow/tfjs</a> <a class="ae le" href="http://twitter.com/tensorflow/tfjs-react-native" rel="noopener ugc nofollow" target="_blank">@tensorflow/tfjs-react-native</a> expo-camera expo-gl expo-gl-cpp expo-image-manipulator react-native-fs react-native-svg react-native-unimodules victory-native</span></pre><p id="4005" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，安装导航库。</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="c816" class="lf lg ji nf b gy nk nl l nm nn">yarn add react-native-navigation &amp;&amp; npx rnn-link</span></pre><p id="576a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">后一个命令会将导航包添加到 iOS 和 Android 中。但是我们还没有完成。</p><p id="f41a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为我们使用 RN 的裸框架，<a class="ae le" href="https://docs.expo.io/bare/installing-unimodules/" rel="noopener ugc nofollow" target="_blank">单模块</a>需要手动安装。</p><p id="4740" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请点击链接，并按照 iOS 部分所述修改<code class="fe nc nd ne nf b">Podfile</code>。那次跑步之后</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="92af" class="lf lg ji nf b gy nk nl l nm nn">$ npx pod-install</span></pre><p id="a255" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">并构建 Xcode 项目，看看是否所有东西都已正确安装。</p><p id="6f52" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后继续将<a class="ae le" href="https://docs.expo.io/bare/installing-unimodules/" rel="noopener ugc nofollow" target="_blank">单模块</a>的代码添加到<code class="fe nc nd ne nf b">AppDelegate.m</code>中，并再次构建项目。</p><p id="d83e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为我们想用相机拍照，我们还需要给<code class="fe nc nd ne nf b">Info.plist</code>添加几个私钥</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="1985" class="lf lg ji nf b gy nk nl l nm nn">&lt;?xml version=”1.0" encoding=”UTF-8"?&gt;<br/>&lt;!DOCTYPE plist PUBLIC “-//Apple//DTD PLIST 1.0//EN” “<a class="ae le" href="http://www.apple.com/DTDs/PropertyList-1.0.dtd" rel="noopener ugc nofollow" target="_blank">http://www.apple.com/DTDs/PropertyList-1.0.dtd</a>"&gt;<br/>&lt;plist version=”1.0"&gt;<br/>  &lt;dict&gt;<br/>    <br/>    &lt;! — Required for iOS 10 and higher --&gt;<br/>    &lt;key&gt;NSCameraUsageDescription&lt;/key&gt;<br/>    &lt;string&gt;We need to use the camera for taking pictures of the digits&lt;/string&gt;</span><span id="af41" class="lf lg ji nf b gy no nl l nm nn">&lt;! — Required for iOS 11 and higher: include this only if you are planning to use the camera roll --&gt;<br/>    &lt;key&gt;NSPhotoLibraryAddUsageDescription&lt;/key&gt;<br/>    &lt;string&gt;We need to access the photo library to upload the images&lt;/string&gt;</span><span id="fa40" class="lf lg ji nf b gy no nl l nm nn">&lt;! — Include for only if you are planning to use the camera roll --&gt;<br/>    &lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;<br/>    &lt;string&gt;We need to access the photo library to upload the images&lt;/string&gt;</span><span id="d6f9" class="lf lg ji nf b gy no nl l nm nn">&lt;! — Include this only if you are planning to use the microphone for video recording --&gt;<br/>    &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;<br/>    &lt;string&gt;We need to access the microphone&lt;/string&gt;<br/> <br/>    &lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;<br/>    &lt;string&gt;en&lt;/string&gt;</span></pre><p id="53ff" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果 Xcode 构建良好，您可以继续从 Xcode 运行应用程序，或者只使用终端。</p><p id="9975" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你决定从现在开始从命令行运行这个应用程序，像我一样，请将<code class="fe nc nd ne nf b">— device</code>添加到你的<code class="fe nc nd ne nf b">package.json</code>文件的<code class="fe nc nd ne nf b">ios</code>脚本中并运行</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="eee1" class="lf lg ji nf b gy nk nl l nm nn">yarn ios</span></pre><p id="cef8" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一旦应用程序在你的 iPhone 上启动，不要惊讶你再也看不到欢迎页面了。那是因为我们用了<code class="fe nc nd ne nf b">react-native-navigation</code>。但是你应该看到加载屏幕<strong class="kh jj"> MyFirstMLApp </strong></p><p id="4026" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在是时候创建我们的 2 个屏幕，并将这些屏幕的导航添加到我们的项目中。</p><p id="4ce9" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请在我们项目的根目录下创建<code class="fe nc nd ne nf b">src/screens/CameraView</code>和<code class="fe nc nd ne nf b">src/screens/EvaluationView</code>目录。</p><p id="9d65" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<code class="fe nc nd ne nf b">src/screens/CameraView</code>中创建一个<code class="fe nc nd ne nf b">index.js</code>文件并添加以下代码:</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="6de0" class="lf lg ji nf b gy nk nl l nm nn">import React, { useState, useRef, useEffect } from "react";<br/>import {<br/>  SafeAreaView,<br/>  TouchableOpacity,<br/>  View,<br/>  Text,<br/>  StatusBar,<br/>} from "react-native";<br/>import { Navigation } from "react-native-navigation";<br/>import { Camera } from "expo-camera";</span><span id="04f4" class="lf lg ji nf b gy no nl l nm nn">const MASK_DIMENSION = 100;</span><span id="c648" class="lf lg ji nf b gy no nl l nm nn">export const CameraView = (props) =&gt; {<br/>  const [hasPermission, setHasPermission] = useState(null);<br/>  const [showShutterButton, setShowShutterButton] = useState(false);<br/>  const cameraRef = useRef();</span><span id="e2ee" class="lf lg ji nf b gy no nl l nm nn">useEffect(() =&gt; {<br/>    (async () =&gt; {<br/>      const { status } = await Camera.requestPermissionsAsync();<br/>      setHasPermission(status === "granted");<br/>    })();<br/>  }, []);</span><span id="b0b9" class="lf lg ji nf b gy no nl l nm nn">const handlePictureProcessing = async () =&gt; {<br/>    goToEvaluationView();<br/>  };</span><span id="70ca" class="lf lg ji nf b gy no nl l nm nn">const goToEvaluationView = () =&gt; {<br/>    Navigation.push(props.componentId, {<br/>      component: {<br/>        name: "evaluationView",<br/>        options: {<br/>          topBar: {<br/>            title: {<br/>              text: "Evaluating ML result",<br/>              color: "white",<br/>            },<br/>            background: {<br/>              color: "#4d089a",<br/>            },<br/>            backButton: {<br/>              color: "white",<br/>              showTitle: false,<br/>            },<br/>          },<br/>        },<br/>        passProps: {},<br/>      },<br/>    });<br/>  };</span><span id="e3cf" class="lf lg ji nf b gy no nl l nm nn">if (hasPermission === null) {<br/>    return &lt;View /&gt;;<br/>  }</span><span id="eae3" class="lf lg ji nf b gy no nl l nm nn">if (hasPermission === false) {<br/>    return &lt;Text&gt; No access to camera &lt;/Text&gt;;<br/>  }</span><span id="2a4f" class="lf lg ji nf b gy no nl l nm nn">return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;StatusBar barStyle="light-content" /&gt;<br/>      &lt;SafeAreaView style={styles.safeArea}&gt;<br/>        &lt;Camera<br/>          ref={cameraRef}<br/>          type={Camera.Constants.Type.back}<br/>          whiteBalance={Camera.Constants.WhiteBalance.auto}<br/>          onCameraReady={() =&gt; setShowShutterButton(true)}&gt;<br/>          &lt;View style={styles.cameraView}&gt;<br/>            &lt;View style={styles.mask} /&gt;<br/>            {showShutterButton &amp;&amp; (<br/>              &lt;TouchableOpacity<br/>                style={styles.shutterButton}<br/>                onPress={handlePictureProcessing}&gt;<br/>                &lt;Text style={styles.shutterButtonText}&gt;<br/>                  Take a picture<br/>                &lt;/Text&gt;<br/>              &lt;/TouchableOpacity&gt;<br/>            )}<br/>          &lt;/View&gt;<br/>        &lt;/Camera&gt;<br/>      &lt;/SafeAreaView&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>};</span><span id="1a10" class="lf lg ji nf b gy no nl l nm nn">const styles = {<br/>  safeArea: {<br/>    backgroundColor: "#4d089a",<br/>  },<br/>  cameraView: {<br/>    height: "100%",<br/>    justifyContent: "center",<br/>    alignItems: "center",<br/>    backgroundColor: "transparent",<br/>  },<br/>  mask: {<br/>    height: MASK_DIMENSION,<br/>    width: MASK_DIMENSION,<br/>    borderWidth: 3,<br/>    borderColor: "white",<br/>    borderStyle: "dotted",<br/>    borderRadius: 15,<br/>  },<br/>  shutterButton: {<br/>    position: "absolute",<br/>    bottom: 0,<br/>    width: 150,<br/>    height: 40,<br/>    justifyContent: "center",<br/>    alignItems: "center",<br/>    borderWidth: 1,<br/>    borderColor: "white",<br/>    borderRadius: 15,<br/>    marginBottom: 20,<br/>  },<br/>  shutterButtonText: {<br/>    fontSize: 18,<br/>    color: "white",<br/>  },<br/>};</span><span id="b5f2" class="lf lg ji nf b gy no nl l nm nn">CameraView.options = {<br/>  statusBar: {<br/>    backgroundColor: null,<br/>  },<br/>  topBar: {<br/>    title: {<br/>      text: "Take a picture",<br/>      color: "white",<br/>    },<br/>    background: {<br/>      color: "#4d089a",<br/>    },<br/>  },<br/>  tapBar: {<br/>    background: {<br/>      color: "#4d089a",<br/>    },<br/>  },<br/>};</span></pre><p id="89db" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<code class="fe nc nd ne nf b">src/screens/EvaluationView</code>中创建一个<code class="fe nc nd ne nf b">index.js</code>文件并添加以下代码:</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="9460" class="lf lg ji nf b gy nk nl l nm nn">import React from "react";<br/>import { SafeAreaView, View, Text, StatusBar } from "react-native";</span><span id="eadd" class="lf lg ji nf b gy no nl l nm nn">export const EvaluationView = (props) =&gt; {<br/>  return (<br/>    &lt;React.Fragment&gt;<br/>       &lt;StatusBar barStyle="light-content" /&gt;<br/>      &lt;SafeAreaView style={styles.safeArea}&gt;<br/>        &lt;View style={styles.container}&gt;<br/>           &lt;Text style={styles.headerText}&gt;ANALYSIS&lt;/Text&gt;<br/>        &lt;/View&gt;<br/>      &lt;/SafeAreaView&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>};</span><span id="c0ed" class="lf lg ji nf b gy no nl l nm nn">const styles = {<br/>  safeArea: {<br/>    backgroundColor: "#4d089a",<br/>  },<br/>  container: {<br/>    height: "100%",<br/>    alignItems: "center",<br/>    backgroundColor: "white",<br/>  },<br/>  headerText: {<br/>    fontSize: 20,<br/>    fontWeight: "500",<br/>    color: "#4d089a",<br/>    margin: 20,<br/>  },<br/>};</span></pre><p id="9a28" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后用下面的代码覆盖根目录中的<code class="fe nc nd ne nf b">index.js</code>文件:</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="c590" class="lf lg ji nf b gy nk nl l nm nn">import { Navigation } from "react-native-navigation";<br/>import { CameraView } from "./src/screens/CameraView";<br/>import { EvaluationView } from "./src/screens/EvaluationView";</span><span id="83c5" class="lf lg ji nf b gy no nl l nm nn">Navigation.registerComponent("cameraView", () =&gt; CameraView);<br/>Navigation.registerComponent("evaluationView", () =&gt; EvaluationView);</span><span id="ccca" class="lf lg ji nf b gy no nl l nm nn">Navigation.setDefaultOptions({<br/>  statusBar: {<br/>    style: "light",<br/>    backgroundColor: "#4d089a",<br/>  },<br/>  topBar: {<br/>    title: {<br/>      color: "white",<br/>    },<br/>    background: {<br/>      color: "#4d089a",<br/>    },<br/>    backButton: {<br/>      color: "white",<br/>      showTitle: false,<br/>    },<br/>  },<br/>});</span><span id="e260" class="lf lg ji nf b gy no nl l nm nn">Navigation.events().registerAppLaunchedListener(() =&gt; {<br/>  Navigation.setRoot({<br/>    root: {<br/>      stack: {<br/>        children: [<br/>          {<br/>            component: {<br/>              name: "cameraView",<br/>            },<br/>          },<br/>        ],<br/>      },<br/>    },<br/>  });<br/>});</span></pre><p id="d3ff" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，您可以删除<code class="fe nc nd ne nf b">App.js</code>文件，因为不再需要它了。</p><p id="c294" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">重启你的 metro bundler，你应该会看到这个应用程序是这样运行的…</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi md"><img src="../Images/b7d1573c16b3924cb1c0d8949ae2657e.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/1*MnLgHukfbKevE2GqvUJ5fw.gif"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">带有工作导航的应用程序的屏幕录制(图片由作者提供)</p></figure><p id="34a6" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">🏆<strong class="kh jj">恭喜恭喜！</strong></p><p id="c7c1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您已经创建了基本应用程序，该应用程序还不能拍照，但可以从一个屏幕导航到另一个屏幕。</p><h2 id="c7cf" class="lf lg ji bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">第二章:训练深度学习模型</h2><p id="56fe" class="pw-post-body-paragraph kf kg ji kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">最初，我使用的是<a class="ae le" href="https://www.kaggle.com/c/digit-recognizer/data" rel="noopener ugc nofollow" target="_blank">这个来自<strong class="kh jj"> Kaggle </strong> </a> <strong class="kh jj"> </strong>的预训练模型，但是让这个应用程序工作起来的努力是巨大的。</p><p id="12e0" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我不得不创建了一个<strong class="kh jj"> AWS EC2 深度学习 AMI(Amazon Linux 2)30.1 版本实例</strong>并使用 SSH 访问，因为我的 Macbook 不支持 CUDA。(训练模型需要 GPU 支持)<br/>然后我必须从 Kaggle 复制<a class="ae le" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kh jj">Jupyter</strong></a><strong class="kh jj"/>笔记本，运行笔记本在 AWS 实例上训练模型(它运行了 3 个小时)并将模型移回我的项目。<br/>此外，我不得不安装<strong class="kh jj"> OpenGL </strong>来修改图像，并编写了一个非常复杂的脚本来将 base64 字符串整形为张量，以匹配模型<code class="fe nc nd ne nf b">[1, 28, 28, 1]</code>的预期输入。</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/f762076ab58c876e54817a3651829ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/1*tEa0cwfoHxvWm6Sm6jgOFw.gif"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">模型开始在 AWS 上训练(图片由作者提供)</p></figure><p id="7124" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所有这些让我重新思考如何写这篇教程。毕竟，本教程应该是为那些只想玩机器学习模型而没有事先学习<strong class="kh jj"> Python </strong>、<strong class="kh jj"> Jupyter </strong>、<strong class="kh jj"> Tensorflow </strong>和<strong class="kh jj"> Keras </strong>的人准备的。此外，教程的长度将是现在的 5 倍。</p><blockquote class="mw mx my"><p id="70cb" class="kf kg ld kh b ki kj kk kl km kn ko kp mz kr ks kt na kv kw kx nb kz la lb lc im bi translated">注:如果你想学习如何使用<strong class="kh jj">tensor flow</strong>&amp;<strong class="kh jj">Keras</strong>我用<a class="ae le" href="https://www.youtube.com/channel/UC4UJ26WkceqONNF5S26OiVw" rel="noopener ugc nofollow" target="_blank"> <strong class="kh jj"> deeplizard </strong> </a>找到了一个很好的关于深度学习的 Youtube 频道，内容非常丰富，也很符合我们在本教程中想要做的事情。<br/>还有，<a class="ae le" href="https://www.udemy.com/course/complete-machine-learning-and-data-science-zero-to-mastery/learn/lecture/16488468" rel="noopener ugc nofollow" target="_blank"><strong class="kh jj">Udemy</strong></a><strong class="kh jj"/>上的这门课也不错，可惜不是免费的。<em class="ji">😕</em></p></blockquote><p id="748b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">反正为了这个教程，我决定用<a class="ae le" href="https://teachablemachine.withgoogle.com/train/image" rel="noopener ugc nofollow" target="_blank"> <strong class="kh jj">谷歌的可教机器</strong> </a>来训练图像。</p><p id="a610" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个想法是用我们刚刚建立的应用程序拍摄<strong class="kh jj"> 28 x 28 像素</strong>的图像，将图像上传到可教机器，并将训练好的模型下载回我们的项目。</p><blockquote class="mw mx my"><p id="5111" class="kf kg ld kh b ki kj kk kl km kn ko kp mz kr ks kt na kv kw kx nb kz la lb lc im bi translated">以防你问我为什么用 28 x 28 像素的图片？这是我首先使用的模型的原始输入大小。所以我坚持了下来。</p></blockquote><p id="9a0d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这也意味着我们必须裁剪并保存拍摄的图像到相机库中。为了做到这一点，我们需要稍微修改一下我们的代码。</p><p id="cec4" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请在<code class="fe nc nd ne nf b">CameraView</code>文件夹中创建一个<code class="fe nc nd ne nf b">helper.js</code>文件，并粘贴以下代码:</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="54d2" class="lf lg ji nf b gy nk nl l nm nn">import { Dimensions } from "react-native";<br/>import * as ImageManipulator from "expo-image-manipulator";<br/>import CameraRoll from "<a class="ae le" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-native-community/cameraroll";</span><span id="45f1" class="lf lg ji nf b gy no nl l nm nn">const { height: DEVICE_HEIGHT, width: DEVICE_WIDTH } = Dimensions.get("window");</span><span id="adfb" class="lf lg ji nf b gy no nl l nm nn">// got the dimension from the trained data of the *Teachable Machine*; pixel resolution conversion (8x)<br/>export const BITMAP_DIMENSION = 224;</span><span id="94b4" class="lf lg ji nf b gy no nl l nm nn">export const cropPicture = async (imageData, maskDimension) =&gt; {<br/>  try {<br/>    const { uri, width, height } = imageData;<br/>    const cropWidth = maskDimension * (width / DEVICE_WIDTH);<br/>    const cropHeight = maskDimension * (height / DEVICE_HEIGHT);<br/>    const actions = [<br/>      {<br/>        crop: {<br/>          originX: width / 2 - cropWidth / 2,<br/>          originY: height / 2 - cropHeight / 2,<br/>          width: cropWidth,<br/>          height: cropHeight,<br/>        },<br/>      },<br/>      {<br/>        resize: {<br/>          width: BITMAP_DIMENSION,<br/>          height: BITMAP_DIMENSION,<br/>        },<br/>      },<br/>    ];<br/>    const saveOptions = {<br/>      compress: 1,<br/>      format: ImageManipulator.SaveFormat.JPEG,<br/>      base64: false,<br/>    };<br/>    return await ImageManipulator.manipulateAsync(uri, actions, saveOptions);<br/>  } catch (error) {<br/>    console.log("Could not crop &amp; resize photo", error);<br/>  }<br/>};</span><span id="e4ab" class="lf lg ji nf b gy no nl l nm nn">export const saveToCameraRoll = async (uri) =&gt; {<br/>  try {<br/>    return await CameraRoll.save(uri, "photo");<br/>  } catch (error) {<br/>    console.log("Could not save the image", error);<br/>  }<br/>};</span></pre><p id="5ceb" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<code class="fe nc nd ne nf b">src/screens/CameraView/index.js</code>中添加导入该文件</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="6f6b" class="lf lg ji nf b gy nk nl l nm nn">import { cropPicture, saveToCameraRoll } from ‘./helpers’;</span></pre><p id="d29b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">添加<code class="fe nc nd ne nf b">takePicture</code>功能，并修改<code class="fe nc nd ne nf b">handlePictureProcessing</code>功能</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="be93" class="lf lg ji nf b gy nk nl l nm nn">const handlePictureProcessing = async () =&gt; {<br/>  const imageData = await takePicture();<br/>  const croppedData = await cropPicture(imageData, MASK_DIMENSION);<br/>  await saveToCameraRoll(croppedData.uri);<br/>  // we don't want to go to the evaluation view now<br/>  //goToEvaluationView();<br/>};</span><span id="6836" class="lf lg ji nf b gy no nl l nm nn">const takePicture = async () =&gt; {<br/>  const options = {<br/>    quality: 0.1,<br/>    fixOrientation: true,<br/>  };<br/>  try {<br/>    return await cameraRef.current.takePictureAsync(options);<br/>  } catch (error) {<br/>    console.log("Could not take photo", error);<br/>  }<br/>};</span></pre><p id="dfd9" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如你所见，我们注释掉了行<code class="fe nc nd ne nf b">//goToEvaluationView();</code>，这样我们就不会转到另一个屏幕。这意味着您可以连续拍摄任意多张照片。现在，所有照片都将保存在您的照片库中。</p><p id="2c7a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的下一个任务是在一张纸上写出尽可能多的 0 到 9 之间的数字变化。我们使用的数字、颜色和笔的形状越多，预测就越准确。</p><p id="3981" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我很懒，最后每个数字大概有 10 个变化，但是对于一些数字，比如 4 和 8，预测有点偏差。</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/a716392f0218a1e3432fc3260567d082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVMikcy1zDrnxif2UV9dmw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">书写数字形状的变化(图片由作者提供)</p></figure><p id="ef17" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以由你决定让<strong class="kh jj">可教机器</strong>训练多少个数字。</p><p id="9843" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当你完成拍摄图像后，把它们全部空投回你的 Mac，从那里把它们上传到<a class="ae le" href="https://teachablemachine.withgoogle.com/train/image" rel="noopener ugc nofollow" target="_blank"> <strong class="kh jj">可教机器</strong> </a>并开始训练它们。</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nr"><img src="../Images/8cf13493668b673cafb581dac2abdf29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oPs5sYmr8xNV73f8ncbEMg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">训练好的模型截图(图片由作者提供)</p></figure><p id="2e91" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">完成后，你可以用你的应用程序拍摄更多的照片并上传，以测试训练好的模型。</p><p id="897f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你对结果满意，点击<code class="fe nc nd ne nf b">Export Model</code>-&gt;-<code class="fe nc nd ne nf b">Tensorflow.js </code>-&gt;-<code class="fe nc nd ne nf b">Download</code>-&gt;-<code class="fe nc nd ne nf b">Download my model</code>，会下载一个<strong class="kh jj"> ZIP </strong>文件。</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/0537852175dbc0ad7652b0e4c91a22ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*iaOjhH078xGv_M86SyMuHg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">下载模型 poup(图片由作者提供)</p></figure><p id="404f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">解压 zip 文件，在<code class="fe nc nd ne nf b">src</code>目录(<code class="fe nc nd ne nf b">src/model</code>)下创建一个<code class="fe nc nd ne nf b">model</code>文件夹，并将<code class="fe nc nd ne nf b">model.json</code>和<code class="fe nc nd ne nf b">weights.bin</code>复制到该文件夹中。</p><p id="3292" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们还需要告诉 metro 处理新的文件格式:<code class="fe nc nd ne nf b">*.bin</code>。所以请这样修改<code class="fe nc nd ne nf b">metro.config.js</code>:</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="65f8" class="lf lg ji nf b gy nk nl l nm nn">const { getDefaultConfig } = require("metro-config");</span><span id="0822" class="lf lg ji nf b gy no nl l nm nn">module.exports = (async () =&gt; {<br/>  const {<br/>    resolver: { assetExts },<br/>  } = await getDefaultConfig();<br/>  return {<br/>    transformer: {<br/>      getTransformOptions: async () =&gt; ({<br/>        transform: {<br/>          experimentalImportSupport: false,<br/>          inlineRequires: false,<br/>        },<br/>      }),<br/>    },<br/>    resolver: {<br/>      assetExts: [...assetExts, "bin"],<br/>    },<br/>  };<br/>})();</span></pre><p id="60b8" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh jj">太好了！现在我们的模型已经在项目中了，让我们开始使用模型来预测数字。</strong></p><h2 id="01f8" class="lf lg ji bd lh li lj dn lk ll lm dp ln kq lo lp lq ku lr ls lt ky lu lv lw lx bi translated">第三章:实现模型，预测并展示结果</h2><p id="1de9" class="pw-post-body-paragraph kf kg ji kh b ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc im bi translated">首先，我们不想再保存照片到我们的照片库中。(除非你愿意)。</p><p id="85e0" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">于是注释掉了那行<code class="fe nc nd ne nf b">//await saveToCameraRoll(croppedData.uri);</code>。<br/>我们还需要裁剪图像的<code class="fe nc nd ne nf b">base64 string</code>，最后，我们想通过<code class="fe nc nd ne nf b">props</code>将那个<code class="fe nc nd ne nf b">base64 string</code>传递给<code class="fe nc nd ne nf b">EvaluationView</code>。</p><p id="2365" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们像这样再次修改我们的 CameraView <code class="fe nc nd ne nf b">src/screens/CameraView/index.js</code>文件:</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="788d" class="lf lg ji nf b gy nk nl l nm nn">const handlePictureProcessing = async () =&gt; {<br/>  const imageData = await takePicture();<br/>  const croppedData = await cropPicture(imageData, MASK_DIMENSION);<br/>  // await saveToCameraRoll(croppedData.uri);<br/>  goToEvaluationView(croppedData);<br/>};</span><span id="cf31" class="lf lg ji nf b gy no nl l nm nn">const goToEvaluationView = (croppedData) =&gt; {<br/>  Navigation.push(props.componentId, {<br/>    component: {<br/>      name: "evaluationView",<br/>      options: {<br/>        topBar: {<br/>          title: {<br/>            text: "Evaluating ML result",<br/>            color: "white",<br/>          },<br/>          background: {<br/>            color: "#4d089a",<br/>          },<br/>          backButton: {<br/>            color: "white",<br/>            showTitle: false,<br/>          },<br/>        },<br/>      },<br/>      passProps: {<br/>        base64: croppedData.base64 || null,<br/>      },<br/>    },<br/>  });<br/>};</span></pre><p id="f7f9" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">🏆太棒了！</p><p id="9f59" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们在<code class="fe nc nd ne nf b">EvaluationView</code>中显示图像。从<code class="fe nc nd ne nf b">react-native</code>导入<strong class="kh jj">图像</strong>并将<strong class="kh jj">图像</strong>组件添加到<code class="fe nc nd ne nf b">View</code>容器中</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="be8e" class="lf lg ji nf b gy nk nl l nm nn">&lt;View style={styles.container}&gt;<br/>  &lt;Text style={styles.headerText}&gt;ANALYSIS&lt;/Text&gt;<br/>  &lt;Image<br/>    style={styles.imageContainer}<br/>    source={{ uri: `data:image/gif;base64,${props.base64}` }}<br/>    resizeMethod="scale"<br/>  /&gt;<br/>&lt;/View&gt;;</span></pre><p id="a984" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">并在<code class="fe nc nd ne nf b">headerText</code>样式下添加<code class="fe nc nd ne nf b">imageContainer</code>的样式。</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="b23e" class="lf lg ji nf b gy nk nl l nm nn">imageContainer: {<br/> height: 300,<br/> width: 300,<br/>},</span></pre><p id="1b73" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后一步是转到<code class="fe nc nd ne nf b">src/screens/CameraView/helpers.js</code>文件，将<code class="fe nc nd ne nf b">saveOptions</code>更改为<code class="fe nc nd ne nf b">base64: true</code>。</p><p id="beb7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">🏆瞧！</p><p id="ded9" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你应该在<em class="ld">分析</em>文本下方的<code class="fe nc nd ne nf b">EvaluationView</code>中看到拍摄的图像。</p><p id="bb39" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们要显示预测结果。我们需要将<strong class="kh jj">胜利图表</strong>和一些<code class="fe nc nd ne nf b">react-native</code>包一起添加到<code class="fe nc nd ne nf b">EvaluationView</code>中</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="caa0" class="lf lg ji nf b gy nk nl l nm nn">import React from "react";<br/>import {<br/>  Dimensions,<br/>  ActivityIndicator,<br/>  SafeAreaView,<br/>  View,<br/>  Image,<br/>  Text,<br/>  StatusBar,<br/>} from "react-native";<br/>import {<br/>  VictoryChart,<br/>  VictoryAxis,<br/>  VictoryBar,<br/>  VictoryTheme,<br/>} from "victory-native";</span><span id="11be" class="lf lg ji nf b gy no nl l nm nn">const { width: DEVICE_WIDTH } = Dimensions.get("window");</span></pre><p id="0dbc" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了获得设备的【the VictoryChart 需要的),我们使用了<code class="fe nc nd ne nf b">Dimensions</code>库。</p><p id="d81a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后添加<strong class="kh jj">胜利图</strong>容器。因为我们只想在得到预测结果后显示图表，所以我们添加了一个基于<code class="fe nc nd ne nf b">graphData.</code>长度的条件</p><p id="73fd" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">由于我们还没有工作模型，我们必须添加一些假的图表数据来查看图表的<strong class="kh jj">水平条</strong>。</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="ba2e" class="lf lg ji nf b gy nk nl l nm nn">import React from "react";<br/>import {<br/>  Dimensions,<br/>  ActivityIndicator,<br/>  SafeAreaView,<br/>  View,<br/>  Image,<br/>  Text,<br/>  StatusBar,<br/>} from "react-native";<br/>import {<br/>  VictoryChart,<br/>  VictoryAxis,<br/>  VictoryBar,<br/>  VictoryTheme,<br/>} from "victory-native";</span><span id="74ee" class="lf lg ji nf b gy no nl l nm nn">const { width: DEVICE_WIDTH } = Dimensions.get("window");</span><span id="a0d7" class="lf lg ji nf b gy no nl l nm nn">export const EvaluationView = (props) =&gt; {<br/>  const graphData = [<br/>    { number: 0, prediction: 0.04 },<br/>    { number: 1, prediction: 0.02 },<br/>    { number: 2, prediction: 0.02 },<br/>    { number: 3, prediction: 0.1 },<br/>    { number: 4, prediction: 0.85 },<br/>    { number: 5, prediction: 0.04 },<br/>    { number: 6, prediction: 0.2 },<br/>    { number: 7, prediction: 0.12 },<br/>    { number: 8, prediction: 0.0 },<br/>    { number: 9, prediction: 0.0 },<br/>  ];</span><span id="1f3c" class="lf lg ji nf b gy no nl l nm nn">return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;StatusBar barStyle="light-content" /&gt;<br/>      &lt;SafeAreaView style={styles.safeArea}&gt;<br/>        &lt;View style={styles.container}&gt;<br/>          &lt;Text style={styles.headerText}&gt;ANALYSIS&lt;/Text&gt;<br/>          &lt;Image<br/>            style={styles.imageContainer}<br/>            source={{ <br/>              uri: `data:image/gif;base64,${props.base64}` <br/>            }}<br/>            resizeMethod="scale"/&gt;<br/>          &lt;View style={styles.resultContainer}&gt;<br/>            {graphData.length ? (<br/>              &lt;VictoryChart<br/>                width={DEVICE_WIDTH - 20}<br/>                padding={{ <br/>                  top: 30, bottom: 70, left: 50, right: 30 <br/>                }}<br/>                theme={VictoryTheme.material}&gt;<br/>                &lt;VictoryAxis<br/>                  tickValues={[1, 2, 3, 4, 5, 6, 7, 8, 9]}<br/>                  tickFormat={[1, 2, 3, 4, 5, 6, 7, 8, 9]}/&gt;<br/>                 &lt;VictoryAxis <br/>                   dependentAxis <br/>                   tickFormat={(tick) =&gt; tick} /&gt;<br/>                &lt;VictoryBar<br/>                  style={{ data: { fill: "#c43a31" } }}<br/>                  barRatio={0.8}<br/>                  alignment="start"<br/>                  data={graphData}<br/>                  x="number"<br/>                  y="prediction"/&gt;<br/>              &lt;/VictoryChart&gt;<br/>            ) : (<br/>              &lt;ActivityIndicator size="large" color="#4d089a" /&gt;<br/>            )}<br/>          &lt;/View&gt;<br/>        &lt;/View&gt;<br/>      &lt;/SafeAreaView&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>};</span></pre><p id="5345" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你应该有一个这样的屏幕:</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/b1ba237ef887b3980eb798016296b71e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6BKrfC27yldSi5mkPmQq-g.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">聊天显示虚假数据(图片由作者提供)</p></figure><p id="2c97" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">🏆<strong class="kh jj">你是冠军！</strong></p><p id="694a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们正在慢慢进入教程的最后一部分，在这里我们将加载模型，并将拍摄的照片与模型进行比较。</p><p id="5597" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请在<code class="fe nc nd ne nf b">src</code>目录下创建一个<code class="fe nc nd ne nf b">util.js</code>并粘贴以下代码。</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="28ad" class="lf lg ji nf b gy nk nl l nm nn">/* eslint-disable no-bitwise */<br/>/*<br/>Copyright (c) 2011, Daniel Guerrero<br/>All rights reserved.<br/>Redistribution and use in source and binary forms, with or without<br/>modification, are permitted provided that the following conditions are met:<br/>    * Redistributions of source code must retain the above copyright<br/>      notice, this list of conditions and the following disclaimer.<br/>    * Redistributions in binary form must reproduce the above copyright<br/>      notice, this list of conditions and the following disclaimer in the<br/>      documentation and/or other materials provided with the distribution.<br/>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND<br/>ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED<br/>WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE<br/>DISCLAIMED. IN NO EVENT SHALL DANIEL GUERRERO BE LIABLE FOR ANY<br/>DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES<br/>(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<br/>LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<br/>ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT<br/>(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS<br/>SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<br/> */</span><span id="ac53" class="lf lg ji nf b gy no nl l nm nn">/**<br/> * Uses the new array typed in javascript to binary base64 encode/decode<br/> * at the moment just decodes a binary base64 encoded<br/> * into either an ArrayBuffer (decodeArrayBuffer)<br/> * or into an Uint8Array (decode)<br/> *<br/> * References:<br/> * <a class="ae le" href="https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBuffer" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBuffer</a><br/> * <a class="ae le" href="https://developer.mozilla.org/en/JavaScript_typed_arrays/Uint8Array" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en/JavaScript_typed_arrays/Uint8Array</a><br/> */</span><span id="702a" class="lf lg ji nf b gy no nl l nm nn">export const Base64Binary = {<br/>  _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",</span><span id="6a74" class="lf lg ji nf b gy no nl l nm nn">/* will return a  Uint8Array type */<br/>  decodeArrayBuffer: function (input) {<br/>    var bytes = (input.length / 4) * 3;<br/>    var ab = new ArrayBuffer(bytes);<br/>    this.decode(input, ab);</span><span id="7210" class="lf lg ji nf b gy no nl l nm nn">return ab;<br/>  },</span><span id="cb85" class="lf lg ji nf b gy no nl l nm nn">removePaddingChars: function (input) {<br/>    var lkey = this._keyStr.indexOf(input.charAt(input.length - 1));<br/>    if (lkey === 64) {<br/>      return input.substring(0, input.length - 1);<br/>    }<br/>    return input;<br/>  },</span><span id="eadf" class="lf lg ji nf b gy no nl l nm nn">decode: function (input, arrayBuffer) {<br/>    //get last chars to see if are valid<br/>    input = this.removePaddingChars(input);<br/>    input = this.removePaddingChars(input);</span><span id="98af" class="lf lg ji nf b gy no nl l nm nn">var bytes = parseInt((input.length / 4) * 3, 10);</span><span id="e019" class="lf lg ji nf b gy no nl l nm nn">var uarray;<br/>    var chr1, chr2, chr3;<br/>    var enc1, enc2, enc3, enc4;<br/>    var i = 0;<br/>    var j = 0;</span><span id="e3c7" class="lf lg ji nf b gy no nl l nm nn">if (arrayBuffer) {<br/>      uarray = new Uint8Array(arrayBuffer);<br/>    } else {<br/>      uarray = new Uint8Array(bytes);<br/>    }</span><span id="3b09" class="lf lg ji nf b gy no nl l nm nn">input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");</span><span id="cbcf" class="lf lg ji nf b gy no nl l nm nn">for (i = 0; i &lt; bytes; i += 3) {<br/>      //get the 3 octects in 4 ascii chars<br/>      enc1 = this._keyStr.indexOf(input.charAt(j++));<br/>      enc2 = this._keyStr.indexOf(input.charAt(j++));<br/>      enc3 = this._keyStr.indexOf(input.charAt(j++));<br/>      enc4 = this._keyStr.indexOf(input.charAt(j++));</span><span id="977d" class="lf lg ji nf b gy no nl l nm nn">chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4);<br/>      chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2);<br/>      chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4;</span><span id="42e9" class="lf lg ji nf b gy no nl l nm nn">uarray[i] = chr1;<br/>      if (enc3 !== 64) {<br/>        uarray[i + 1] = chr2;<br/>      }<br/>      if (enc4 !== 64) {<br/>        uarray[i + 2] = chr3;<br/>      }<br/>    }</span><span id="34e0" class="lf lg ji nf b gy no nl l nm nn">return uarray;<br/>  },<br/>};</span></pre><blockquote class="mw mx my"><p id="103c" class="kf kg ld kh b ki kj kk kl km kn ko kp mz kr ks kt na kv kw kx nb kz la lb lc im bi translated">出于对开发者的尊重请不要删除版权免责声明<em class="ji">😃</em></p></blockquote><p id="2b38" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在创建另一个<code class="fe nc nd ne nf b">helpers.js</code>文件，但这次是在<code class="fe nc nd ne nf b">EvaluationView</code>目录<code class="fe nc nd ne nf b">src/screens/EvaluationView/helpers.js</code>中，并复制这段代码</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="9654" class="lf lg ji nf b gy nk nl l nm nn">import * as tf from "<a class="ae le" href="http://twitter.com/tensorflow/tfjs" rel="noopener ugc nofollow" target="_blank">@tensorflow/tfjs</a>";<br/>import "<a class="ae le" href="http://twitter.com/tensorflow/tfjs-react-native" rel="noopener ugc nofollow" target="_blank">@tensorflow/tfjs-react-native</a>";<br/>import { bundleResourceIO, decodeJpeg } from "<a class="ae le" href="http://twitter.com/tensorflow/tfjs-react-native" rel="noopener ugc nofollow" target="_blank">@tensorflow/tfjs-react-native</a>";<br/>import { Base64Binary } from "../../util";<br/>import { BITMAP_DIMENSION } from "../CameraView/helpers";</span><span id="fa24" class="lf lg ji nf b gy no nl l nm nn">const modelJson = require("../../model/model.json");<br/>const modelWeights = require("../../model/weights.bin");</span><span id="3067" class="lf lg ji nf b gy no nl l nm nn">// 0: channel from JPEG-encoded image<br/>// 1: gray scale<br/>// 3: RGB image<br/>const TENSORFLOW_CHANNEL = 3;</span><span id="b9ed" class="lf lg ji nf b gy no nl l nm nn">export const getModel = async () =&gt; {<br/>  try {<br/>    // wait until tensorflow is ready<br/>    await tf.ready();<br/>    // load the trained model<br/>    return await tf.loadLayersModel(bundleResourceIO(modelJson, modelWeights));<br/>  } catch (error) {<br/>    console.log("Could not load model", error);<br/>  }<br/>};</span><span id="63bb" class="lf lg ji nf b gy no nl l nm nn">export const convertBase64ToTensor = async (props) =&gt; {<br/>  try {<br/>    const uIntArray = Base64Binary.decode(props.base64);<br/>    // decode a JPEG-encoded image to a 3D Tensor of dtype<br/>    const decodedImage = decodeJpeg(uIntArray, 3);<br/>    // reshape Tensor into a 4D array<br/>    return decodedImage.reshape([<br/>      1,<br/>      BITMAP_DIMENSION,<br/>      BITMAP_DIMENSION,<br/>      TENSORFLOW_CHANNEL,<br/>    ]);<br/>  } catch (error) {<br/>    console.log("Could not convert base64 string to tesor", error);<br/>  }<br/>};</span><span id="2bc8" class="lf lg ji nf b gy no nl l nm nn">export const startPrediction = async (model, tensor) =&gt; {<br/>  try {<br/>    // predict against the model<br/>    const output = await model.predict(tensor);<br/>    // return typed array<br/>    return output.dataSync();<br/>  } catch (error) {<br/>    console.log("Error predicting from tesor image", error);<br/>  }<br/>};</span><span id="16a0" class="lf lg ji nf b gy no nl l nm nn">export const populateData = (typedArray) =&gt; {<br/>  const predictions = Array.from(typedArray);<br/>  return predictions.map((item, index) =&gt; {<br/>    return {<br/>      number: index,<br/>      prediction: item,<br/>    };<br/>  });<br/>};</span></pre><p id="a04c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这些是我们加载模型、将 base64 字符串转换为张量、预测数字和填充胜利图表数据的函数。</p><p id="354e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后但同样重要的是，我们在<code class="fe nc nd ne nf b">src/screens/EvaluationView/index.js</code>的<code class="fe nc nd ne nf b">useEffect()</code>钩子中调用这些函数。</p><p id="5c47" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是该视图的完整代码:</p><pre class="me mf mg mh gt ng nf nh ni aw nj bi"><span id="6807" class="lf lg ji nf b gy nk nl l nm nn">import React, { useState, useEffect } from "react";<br/>import {<br/>  Dimensions,<br/>  ActivityIndicator,<br/>  SafeAreaView,<br/>  View,<br/>  Image,<br/>  Text,<br/>  StatusBar,<br/>} from "react-native";<br/>import {<br/>  VictoryChart,<br/>  VictoryAxis,<br/>  VictoryBar,<br/>  VictoryTheme,<br/>} from "victory-native";<br/>import {<br/>  getModel,<br/>  convertBase64ToTensor,<br/>  startPrediction,<br/>  populateData,<br/>} from "./helpers";</span><span id="8654" class="lf lg ji nf b gy no nl l nm nn">const { width: DEVICE_WIDTH } = Dimensions.get("window");</span><span id="e429" class="lf lg ji nf b gy no nl l nm nn">export const EvaluationView = (props) =&gt; {<br/>  const [graphData, setGraphData] = useState([]);</span><span id="bbd9" class="lf lg ji nf b gy no nl l nm nn">useEffect(() =&gt; {<br/>    const predictDigits = async () =&gt; {<br/>      const model = await getModel();<br/>      const tensor = await convertBase64ToTensor(props);<br/>      const typedArray = await startPrediction(model, tensor);<br/>      setGraphData(populateData(typedArray));<br/>    };<br/>    predictDigits();<br/>  }, [props]);</span><span id="dd29" class="lf lg ji nf b gy no nl l nm nn">return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;StatusBar barStyle="light-content" /&gt;<br/>      &lt;SafeAreaView style={styles.safeArea}&gt;<br/>        &lt;View style={styles.container}&gt;<br/>          &lt;Text style={styles.headerText}&gt;ANALYSIS&lt;/Text&gt;<br/>          &lt;Image<br/>            style={styles.imageContainer}<br/>            source={{ uri: `data:image/gif;base64,${props.base64}` }}<br/>            resizeMethod="scale"<br/>          /&gt;<br/>          &lt;View style={styles.resultContainer}&gt;<br/>            {graphData.length ? (<br/>              &lt;VictoryChart<br/>                width={DEVICE_WIDTH - 20}<br/>                padding={{ top: 30, bottom: 70, left: 50, right: 30 }}<br/>                theme={VictoryTheme.material}<br/>              &gt;<br/>                &lt;VictoryAxis<br/>                  tickValues={[1, 2, 3, 4, 5, 6, 7, 8, 9]}<br/>                  tickFormat={[1, 2, 3, 4, 5, 6, 7, 8, 9]}<br/>                /&gt;<br/>                 &lt;VictoryAxis dependentAxis tickFormat={(tick) =&gt; tick} /&gt;<br/>                &lt;VictoryBar<br/>                  style={{ data: { fill: "#c43a31" } }}<br/>                  barRatio={0.8}<br/>                  alignment="start"<br/>                  data={graphData}<br/>                  x="number"<br/>                  y="prediction"<br/>                /&gt;<br/>              &lt;/VictoryChart&gt;<br/>            ) : (<br/>              &lt;ActivityIndicator size="large" color="#4d089a" /&gt;<br/>            )}<br/>          &lt;/View&gt;<br/>        &lt;/View&gt;<br/>      &lt;/SafeAreaView&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>};</span><span id="5a04" class="lf lg ji nf b gy no nl l nm nn">const styles = {<br/>  safeArea: {<br/>    backgroundColor: "#4d089a",<br/>  },<br/>  container: {<br/>    height: "100%",<br/>    alignItems: "center",<br/>    backgroundColor: "white",<br/>  },<br/>  headerText: {<br/>    fontSize: 20,<br/>    fontWeight: "500",<br/>    color: "#4d089a",<br/>    margin: 20,<br/>  },<br/>  imageContainer: {<br/>    height: 300,<br/>    width: 300,<br/>  },<br/>  resultContainer: {<br/>    flex: 1,<br/>    justifyContent: "center",<br/>    alignItems: "center",<br/>  },<br/>};</span></pre><p id="4135" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh jj">正如我之前提到的，模型会像你训练的模型一样好。</strong></p><blockquote class="mw mx my"><p id="a016" class="kf kg ld kh b ki kj kk kl km kn ko kp mz kr ks kt na kv kw kx nb kz la lb lc im bi translated">在现实世界中，数据工程师会使用数万种不同的手写数字来训练模型。然后将使用另一个集合来调整模型，并使用一个全新的集合来检查模型性能。</p><p id="9ea9" class="kf kg ld kh b ki kj kk kl km kn ko kp mz kr ks kt na kv kw kx nb kz la lb lc im bi translated">在我结束本教程之前，顺便提一下；如果你是一个经验丰富的 React 原生开发者，你现在应该已经意识到，通过一些手动导入，特别是<code class="fe nc nd ne nf b"><em class="ji">react-native-unimodules</em></code>、<code class="fe nc nd ne nf b"><em class="ji">expo-camera</em></code>和权限设置，这个项目也可以在 Android 上开箱即用。<em class="ji">🤓</em></p></blockquote><p id="3644" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我希望你已经学到了一些新东西。</p><p id="1db1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我可以做一些不同的事情，或者如果你喜欢这个教程，请留下评论。毕竟我们都是来学习的，对吧？👨🏼‍🎓</p></div></div>    
</body>
</html>