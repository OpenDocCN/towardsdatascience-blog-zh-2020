<html>
<head>
<title>Custom PySpark Accumulators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">定制 PySpark 累加器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/custom-pyspark-accumulators-310f63ca3c8c?source=collection_archive---------30-----------------------#2020-07-31">https://towardsdatascience.com/custom-pyspark-accumulators-310f63ca3c8c?source=collection_archive---------30-----------------------#2020-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c03f854a08c44d5cc6125c0cd58b11ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xKd0lp-_vI8v_u6-"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">约书亚·索蒂诺在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="69ee" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">pyspark 蓄能器的字典、列表和设置类型</h2></div><p id="3d0f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，Spark 提供支持交换和关联操作的 int/float 累加器。尽管 spark 也提供了一个类<em class="lu"> AccumulatorParam </em>来继承，以支持不同类型的累加器。只需要实现两个方法<em class="lu"> zero </em>和<em class="lu"> addInPlace。zero </em>定义累加器类型的零值，addInPlace 定义累加器类型的两个值如何相加。</p><p id="2ccb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上一篇文章中，我讨论了管理 pyspark 累加器，这也提供了一个很好的累加器概述:</p><div class="is it gp gr iu lv"><a rel="noopener follow" target="_blank" href="/broadcasting-pyspark-accumulators-343104c18c44"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jk gy z fp ma fr fs mb fu fw ji bi translated">广播 PySpark 累加器</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">以及如何管理它们</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ja lv"/></div></div></a></div><p id="496a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我将讨论三种不同类型的自定义累加器:dict、list 和 set。</p><h1 id="7b2f" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">口述积累器</h1><p id="d6a3" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">字典累加器的目标是累加字典。现在，当我们积累字典时，有多种考虑因素:</p><ol class=""><li id="5870" class="nh ni jj la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">现有键:如果键已经存在于累积字典中，我们该怎么办？</li><li id="076f" class="nh ni jj la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">Key 的值类型:如何处理 list 和 set 等键的不同类型的值？</li></ol><h2 id="cafe" class="nv ml jj bd mm nw nx dn mq ny nz dp mu lh oa ob mw ll oc od my lp oe of na og bi translated">现有密钥</h2><p id="6aff" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">我们至少有三种策略:</p><ul class=""><li id="4255" class="nh ni jj la b lb lc le lf lh nj ll nk lp nl lt oh nn no np bi translated">用新值替换该项的值</li><li id="56f5" class="nh ni jj la b lb nq le nr lh ns ll nt lp nu lt oh nn no np bi translated">保持旧值</li><li id="4577" class="nh ni jj la b lb nq le nr lh ns ll nt lp nu lt oh nn no np bi translated">添加到现有值</li></ul><p id="a4a2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，前两个操作是不可交换的，因为它取决于要累加的字典的顺序。如果我们想为一个给定的键保留所有的或者唯一的值，那么我们可以分别用一个列表或者集合来表示值。</p><h2 id="52ac" class="nv ml jj bd mm nw nx dn mq ny nz dp mu lh oa ob mw ll oc od my lp oe of na og bi translated">键的值类型</h2><p id="895e" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">如上所述，值的类型对于跟踪给定键的所有或所有唯一值可能是有用的。在这种情况下，我们需要一个列表或集合。可能有其他场景需要其他类型，但这超出了本文的范围。</p><p id="8fec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以现在我们已经讨论了五种不同风格的录音机。我们没有为每个实现一个类，而是实现了<em class="lu">枚举</em>来跟踪组合方法。</p><h2 id="cbcd" class="nv ml jj bd mm nw nx dn mq ny nz dp mu lh oa ob mw ll oc od my lp oe of na og bi translated">白藓积累法</h2><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="om on l"/></div></figure><ul class=""><li id="4fbe" class="nh ni jj la b lb lc le lf lh nj ll nk lp nl lt oh nn no np bi translated">REPLACE:如果键存在，则用新值替换当前值，否则将键值添加到字典中</li><li id="ab6f" class="nh ni jj la b lb nq le nr lh ns ll nt lp nu lt oh nn no np bi translated">KEEP:如果键存在，则保留旧值，否则将键值添加到字典中</li><li id="51ae" class="nh ni jj la b lb nq le nr lh ns ll nt lp nu lt oh nn no np bi translated">ADD:如果键存在，则向现有值添加新值，否则向字典添加键值</li><li id="e3d4" class="nh ni jj la b lb nq le nr lh ns ll nt lp nu lt oh nn no np bi translated">LIST:如果键存在，将新列表添加到现有列表中，否则将键和列表作为值添加到字典中</li><li id="2b21" class="nh ni jj la b lb nq le nr lh ns ll nt lp nu lt oh nn no np bi translated">SET:如果关键字存在，则将新集合(从新列表转换)与现有集合值(从现有集合转换为值)联合，否则将关键字和列表值添加到字典中</li></ul><h2 id="36f7" class="nv ml jj bd mm nw nx dn mq ny nz dp mu lh oa ob mw ll oc od my lp oe of na og bi translated">__init__ 拯救世界</h2><p id="80ec" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">现在我们知道了不同风格的 DictAccumulator，那么如何使用一个单独的类实现来创建呢？很少宣传的事实是用于<em class="lu"> AccumulatorParam，</em>的<em class="lu"> __init__ </em>方法，但是它不需要被指定，首先，因为它是 python 中的类的构造函数。</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f9be" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用 DictAccumulatorMethod 初始化 DictAccumulator 解决了给它调味的问题。除非指定，否则将使用 REPLACE。在<em class="lu"> addInPlace </em>方法中，我们只是用需要合并到 first ( <em class="lu"> v1 </em>)中的 seconds ( <em class="lu"> v2 </em>)字典中的键和值来调用方法。</p><h2 id="9d8b" class="nv ml jj bd mm nw nx dn mq ny nz dp mu lh oa ob mw ll oc od my lp oe of na og bi translated">单元测试指令累积器</h2><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4907" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先只是设置单元测试。将累加器管理器设置为<a class="ae jg" rel="noopener" target="_blank" href="/broadcasting-pyspark-accumulators-343104c18c44">广播累加器</a>，通过测试设置中的<em class="lu"> get_spark </em>方法和<em class="lu"> input_data </em>、<em class="lu"> rdd </em>产生火花。</p><p id="7042" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">更换</strong></p><p id="bb2e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个单元测试中，我们首先为作为字典的键添加双倍的键值，然后添加相同的键值。相同的密钥值会替换双倍的密钥值。</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ef83" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">保持</strong></p><p id="a6fc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先在下面的测试中，我们将字典添加到累加器中，其中值是键的两倍。然后将字典添加到值与键相同的累加器中。在第二遍之后，键值应该是键值的两倍，因为我们将累加器初始化为 keep。</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="7be4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">增加</strong></p><p id="8e31" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的测试中，我们只是将所有的值添加到定义为“<em class="lu"> count </em>”的键中。<em class="lu">count</em>键的值与 input_data 的<em class="lu"> sum </em>相同。</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="1380" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">列表</strong></p><p id="ba57" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在此测试中，我们将所有奇数和偶数数据组合到其各自的密钥中，该密钥是从数字除以 2 的余数中导出的。每个值都被附加到相应键的列表中。</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4b90" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">设置</strong></p><p id="35ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的测试中，残差被添加到键中。因为它的设置只有值 0 和 1 在列表中(键值)。如果是列表，我们会看到多个 0 和 1。</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="om on l"/></div></figure><h1 id="b378" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">列表累加器</h1><p id="bd44" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">ListAccumulator 的实现相当简单。在这个场景中，我们只添加两个列表，并在<em class="lu"> addInPlace </em>方法中返回它。</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="0ac0" class="nv ml jj bd mm nw nx dn mq ny nz dp mu lh oa ob mw ll oc od my lp oe of na og bi translated"><strong class="ak">单元测试列表累加器</strong></h2><p id="70e1" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">在单元测试中，我只是在加倍后将一个数字列表添加到 ListAccumulator 中。我在驱动程序上创建了相同的数据并进行比较，结果是匹配的。</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="om on l"/></div></figure><h1 id="ea35" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">设定累加器</h1><p id="71d7" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">在 SetAccumulator 实现中，它只是两个集合的并集，作为<em class="lu"> addInPlace </em>方法的返回。</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="141d" class="nv ml jj bd mm nw nx dn mq ny nz dp mu lh oa ob mw ll oc od my lp oe of na og bi translated"><strong class="ak">单元测试设置累加器</strong></h2><p id="aa02" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">测试方法与测试过的带 set 类型的录音机相似。多次添加剩余的列表，最后，我们只得到两个剩余的 0 和 1，而不是 0 和 1。</p><figure class="oi oj ok ol gt iv"><div class="bz fp l di"><div class="om on l"/></div></figure><h1 id="99c9" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">结论</h1><p id="e3a9" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">在这篇文章中，讨论了基于列表和集合的 pyspark 累加器，并围绕实现进行了推理。替换和保留字典的累加器是不可交换的，所以使用它们时要小心。下面是 GitHub 上的实现。</p><div class="is it gp gr iu lv"><a href="https://github.com/SalilJain/PySparkCustomAccumulators" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jk gy z fp ma fr fs mb fu fw ji bi translated">salil Jain/PySparkCustomAccumulators</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">在 GitHub 上创建一个帐户，为 salil Jain/PySparkCustomAccumulators 的开发做出贡献。</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">github.com</p></div></div><div class="me l"><div class="oo l mg mh mi me mj ja lv"/></div></div></a></div></div></div>    
</body>
</html>