<html>
<head>
<title>Dictionary union operators and new string methods in Python 3.9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.9 中的字典联合运算符和新的字符串方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dictionary-union-operators-and-new-string-methods-in-python-3-9-4688b261a417?source=collection_archive---------49-----------------------#2020-07-07">https://towardsdatascience.com/dictionary-union-operators-and-new-string-methods-in-python-3-9-4688b261a417?source=collection_archive---------49-----------------------#2020-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d0f9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">可以简化您的数据处理代码的新功能—它们是什么？它们改进了什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/584dcfff7238f9a0a5e7a3294acba5c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*St-pzsgiQegfuAKkYxVoHw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡南·哈斯马多夫在<a class="ae ky" href="https://unsplash.com/s/photos/9?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a9e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 3.9 已经积累了一份长长的改进列表，其中有一些非常重要的变化，比如一种新型的解析器。与 LL(1)解析器相比，新的<a class="ae ky" href="https://medium.com/@gvanrossum_83706/peg-parsers-7ed72462f97c" rel="noopener"> PEG </a>解析器占用了更多的内存，但是速度更快，应该能够更好地处理某些情况。虽然，根据发布文档，我们可能从 Python 3.10 开始才能看到真正的效果。Python 3.9 还扩展了一些内置和标准库集合类型的使用，作为通用类型，而不必求助于<code class="fe lv lw lx ly b">typing</code>模块。如果您使用类型检查器、linters 或 ide，这尤其有用。</p><p id="7a39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许，在处理文本数据的日常工作中最方便的两个特性是添加到<code class="fe lv lw lx ly b">dict</code>中的联合操作符和新的<code class="fe lv lw lx ly b">string</code>方法。</p><h2 id="23b9" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated"><code class="fe lv lw lx ly b">dict</code>的联合运算符</h2><p id="c9bd" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">dict</code>引入了<a class="ae ky" href="https://www.python.org/dev/peps/pep-0584/" rel="noopener ugc nofollow" target="_blank">合并</a> <code class="fe lv lw lx ly b">|</code>和<a class="ae ky" href="https://www.python.org/dev/peps/pep-0584/" rel="noopener ugc nofollow" target="_blank">更新</a> <code class="fe lv lw lx ly b">|=</code>两个联合运算符。</p><p id="8dd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您想基于您已经拥有的两个字典创建一个新的<code class="fe lv lw lx ly b">dict</code>，您可以执行以下操作:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="78ec" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; d1 = {'a': 1}<br/>&gt;&gt;&gt; d2 = {'b': 2}<br/>&gt;&gt;&gt; d3 = d1 | d2<br/>&gt;&gt;&gt; d3<br/>{'a': 1, 'b': 2}</span></pre><p id="a440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想用这两个字典中的一个来扩充另一个，您可以这样做:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="1a93" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; d1 = {'a': 1}<br/>&gt;&gt;&gt; d2 = {'b': 2}<br/>&gt;&gt;&gt; d1 |= d2<br/>&gt;&gt;&gt; d1<br/>{'a': 1, 'b': 2}</span></pre><p id="058c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Python 中已经有几种合并字典的方法。这可以使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="noopener ugc nofollow" target="_blank">dict.update()</a></code>来完成:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="98ca" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; d1 = {'a': 1}<br/>&gt;&gt;&gt; d2 = {'b': 2}<br/>&gt;&gt;&gt; d1.update(d2)<br/>&gt;&gt;&gt; d1<br/>{'a': 1, 'b': 2}</span></pre><p id="cc69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<code class="fe lv lw lx ly b">dict.update()</code>修改了您正在就地更新的<code class="fe lv lw lx ly b">dict</code>。如果你想有一个新的字典，你必须先复制一个现有的字典:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="d9d5" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; d1 = {'a': 1}<br/>&gt;&gt;&gt; d2 = {'b': 2}<br/>&gt;&gt;&gt; d3 = d1.copy()<br/>&gt;&gt;&gt; d3<br/>{'a': 1}<br/>&gt;&gt;&gt; d3.update(d2)<br/>&gt;&gt;&gt; d3<br/>{'a': 1, 'b': 2}</span></pre><p id="70c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，在 Python 3.9 之前，还有 3 种方法可以实现这一点。合并两个字典也可以通过<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.python.org/dev/peps/pep-0448/" rel="noopener ugc nofollow" target="_blank">{**d1, **d2}</a></code>构造来实现:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="d6a3" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; d1 = {'a': 1}<br/>&gt;&gt;&gt; d2  = {'b': 2}<br/>&gt;&gt;&gt; {**d1, **d2}<br/>{'a': 1, 'b': 2}</span></pre><p id="a00e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您使用的是<code class="fe lv lw lx ly b">dict</code>的子类，例如<code class="fe lv lw lx ly b">defaultdict</code>，这个构造将把新字典的类型解析为<code class="fe lv lw lx ly b">dict</code>:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="ba64" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; d1<br/>defaultdict(None, {0: 'a'})<br/>&gt;&gt;&gt; d2<br/>defaultdict(None, {1: 'b'})<br/>&gt;&gt;&gt; {**d1, **d2}<br/>{0: 'a', 1: 'b'}</span></pre><p id="c15e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工会运营商不会出现这种情况:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="6f41" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; d1<br/>defaultdict(None, {0: 'a'})<br/>&gt;&gt;&gt; d2<br/>defaultdict(None, {1: 'b'})<br/>&gt;&gt;&gt; d1 | d2<br/>defaultdict(None, {0: 'a', 1: 'b'})</span></pre><p id="1f07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种将两个字典合并成一个新字典的方法是<code class="fe lv lw lx ly b"> dict(d1, **d2)</code>:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="0fb8" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; d1 = {'a': 1}<br/>&gt;&gt;&gt; d2  = {'b': 2}<br/>&gt;&gt;&gt; dict(d1, **d2)<br/>{'a': 1, 'b': 2}</span></pre><p id="b6e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这只适用于所有键都是类型<code class="fe lv lw lx ly b">string</code>的字典:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="9d4a" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; d1 = {'a': 1}<br/>&gt;&gt;&gt; d2 = {2: 'b'}<br/>&gt;&gt;&gt; dict(d1, **d2)<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: keyword arguments must be strings</span></pre><p id="1728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三种选择是使用<code class="fe lv lw lx ly b"> <a class="ae ky" href="https://www.python.org/dev/peps/pep-0584/#id15" rel="noopener ugc nofollow" target="_blank">collections.ChainMap</a></code>。这可能比前两种方法更不直接，而且不幸的是，如果您更新链图对象，会修改底层字典:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="b1a5" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; d1 = {'a': 1, 'b': 2}<br/>&gt;&gt;&gt; d2 = {'b': 3}<br/>&gt;&gt;&gt; from collections import ChainMap<br/>&gt;&gt;&gt; d3 = ChainMap(d1, d2)<br/>&gt;&gt;&gt; d3<br/>ChainMap({'a': 1, 'b': 2}, {'b': 3})<br/>&gt;&gt;&gt; d3['b'] = 4<br/>&gt;&gt;&gt; d3<br/>ChainMap({'a': 1, 'b': 4}, {'b': 3})<br/>&gt;&gt;&gt; d1<br/>{'a': 1, 'b': 4}<br/>&gt;&gt;&gt; d2<br/>{'b': 3}</span></pre><p id="ea4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于<code class="fe lv lw lx ly b">dict</code>的新的合并和更新 union 操作符解决了这些问题，看起来没有那么麻烦。但是，它们可能会与按位“或”和其他一些运算符混淆。</p><h2 id="fb56" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">移除前缀和后缀的字符串方法</h2><p id="5ab1" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">正如<a class="ae ky" href="https://www.python.org/dev/peps/pep-0616/" rel="noopener ugc nofollow" target="_blank"> PEP-616 </a>文档所建议的，几乎任何时候你使用<code class="fe lv lw lx ly b">str.startswith()</code>和<code class="fe lv lw lx ly b">str.endswith()</code>方法，你都可以简化代码如下。</p><p id="d084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前，如果您正在规范化一个列表，例如，电影标题，并从无序列表中删除任何额外的标记，如破折号，您可以这样做:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="a3a1" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; normalized_titles = []<br/>&gt;&gt;&gt; my_prefixed_string = '- Shark Bait'<br/>&gt;&gt;&gt; if my_prefixed_string.startswith('- '):<br/>...     normalized_titles.append(my_prefixed_string.replace('- ', ''))<br/>&gt;&gt;&gt; print(normalized_titles)<br/>['Shark Bait']</span></pre><p id="0c9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用<code class="fe lv lw lx ly b">str.replace()</code>可能会产生不必要的副作用，例如，如果破折号是电影标题的一部分，而您实际上更愿意保留它，如下例所示。在 Python 3.9 中，您可以安全地这样做:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="7654" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; normalized_titles = []<br/>&gt;&gt;&gt; my_prefixed_string = '- Niko - The Flight Before Christmas'<br/>&gt;&gt;&gt; if my_prefixed_string.startswith('- '):<br/>...     normalized_titles.append(my_prefixed_string.removeprefix('- '))<br/>&gt;&gt;&gt; print(normalized_titles)<br/>['Niko - The Flight Before Christmas']</span></pre><p id="6303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PEP 文档指出，用户报告期望来自另一对内置方法<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.python.org/3/library/stdtypes.html#str.lstrip" rel="noopener ugc nofollow" target="_blank">str.lstrip</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.python.org/3/library/stdtypes.html#str.rstrip" rel="noopener ugc nofollow" target="_blank">str.rstrip</a></code>的这种行为，并且通常必须实现他们自己的方法来实现这种行为。这些新方法应该以更健壮和有效的方式提供该功能。用户将不必关心空字符串的情况或使用<code class="fe lv lw lx ly b">str.replace()</code>。</p><p id="504e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个典型的用例如下:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="1bac" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; my_affixed_string = '"Some title"'<br/>&gt;&gt;&gt; if my_affixed_string.startswith('"'):<br/>...     my_affixed_string = my_affixed_string[1:]<br/>...<br/>&gt;&gt;&gt; if my_affixed_string.endswith('"'):<br/>...     my_affixed_string = my_affixed_string[:-1]<br/>...<br/>&gt;&gt;&gt; my_affixed_string<br/>'Some title'</span></pre><p id="658c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Python 3.9 中，这可以简化为:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="9301" class="lz ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; my_affixed_string = '"Some title"'<br/>&gt;&gt;&gt; my_affixed_string.removeprefix('"').removesuffix('"')<br/>'Some title'</span></pre><p id="e219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">bytes</code>、<code class="fe lv lw lx ly b">bytearray</code>和<code class="fe lv lw lx ly b">collections.UserString</code>也宣布了这些方法。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="8ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 3.9 还有一系列有趣的模块改进和优化——一定要看看这些改进和优化，找出对您的应用程序最有用的。享受新功能！</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="4142" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对 Python 感兴趣，请随意查看我关于<a class="ae ky" href="https://annaeastori.medium.com/concurrency-and-parallelism-in-python-bbd7af8c6625" rel="noopener">并发性和并行性</a>的文章。</p></div></div>    
</body>
</html>