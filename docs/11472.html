<html>
<head>
<title>Extract annotations from CVAT XML file into mask files in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 将 CVAT XML 文件中的注释提取到掩码文件中</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/extract-annotations-from-cvat-xml-file-into-mask-files-in-python-bb69749c4dc9?source=collection_archive---------14-----------------------#2020-08-09">https://towardsdatascience.com/extract-annotations-from-cvat-xml-file-into-mask-files-in-python-bb69749c4dc9?source=collection_archive---------14-----------------------#2020-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b735" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种从 CVAT XML 中获取掩码文件的方法</h2></div><p id="093c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://github.com/opencv/cvat" rel="noopener ugc nofollow" target="_blank">计算机视觉标注工具(CVAT) </a>是众所周知的图像标注工具。数据贴标机的工作结果可以导入 XML 文件。这个 XML 文件包含关于标记的所有必要信息。然而，对于图像分割任务，必须具有图像文件(JPEG、GIF、PNG 等)形式的遮罩。).换句话说，有了 CVAT XML 文件中的标记坐标，您需要绘制相应的遮罩。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/236492771f2409aec141d55d9efb338f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFMWTJhWrpUXL_XIghMD3g.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图片由 Oleksii Sheremet 用<a class="ae le" href="https://www.adobe.com/ru/products/photoshop.html" rel="noopener ugc nofollow" target="_blank"> Adobe Photoshop </a>制作</p></figure><p id="4195" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果数据标注器处理图像的分辨率高于训练所用的分辨率，那么任务将变得更加复杂。有必要考虑图像压缩因子对 XML 文件中呈现的提示点的数值的影响。</p><p id="421e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有提取注释的代码都是作为 Python 中的脚本实现的。lxml 库用于解析 xml。它是处理 XML 和 HTML 标记的快速灵活的解决方案。<a class="ae le" href="https://lxml.de/" rel="noopener ugc nofollow" target="_blank"> lxml </a>包支持 XPath 和 XSLT，包括一个用于 SAX 的 API 和一个与 C 模块兼容的 API。</p><p id="ef9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://tqdm.github.io/" rel="noopener ugc nofollow" target="_blank"> tqdm </a>包作为进度条来说明大量文件的处理。</p><p id="04e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们仔细看看。导入库:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="3665" class="ma mb it lw b gy mc md l me mf">import os<br/>import cv2<br/>import argparse<br/>import shutil<br/>import numpy as np<br/>from lxml import etree<br/>from tqdm import tqdm</span></pre><p id="8c74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个用于创建新目录和递归删除现有目录内容的有用函数:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="25e8" class="ma mb it lw b gy mc md l me mf">def dir_create(path):<br/>    if (os.path.exists(path)) and (os.listdir(path) != []):<br/>        shutil.rmtree(path)<br/>        os.makedirs(path)</span><span id="bf5b" class="ma mb it lw b gy mg md l me mf">    if not os.path.exists(path):<br/>        os.makedirs(path)</span></pre><p id="10a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正在讨论的脚本的参数是以下数据:具有输入图像的目录、具有 XML 格式的 CVAT 注释的输入文件、用于输出掩码的目录以及图像的比例因子。从命令行解析参数的函数:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="714a" class="ma mb it lw b gy mc md l me mf">def parse_args():<br/>    parser = argparse.ArgumentParser(<br/>        fromfile_prefix_chars='@',<br/>        description='Convert CVAT XML annotations to contours'<br/>    )</span><span id="7fa5" class="ma mb it lw b gy mg md l me mf">parser.add_argument(<br/>        '--image-dir', metavar='DIRECTORY', required=True,<br/>        help='directory with input images'<br/>    )</span><span id="e0bb" class="ma mb it lw b gy mg md l me mf">parser.add_argument(<br/>        '--cvat-xml', metavar='FILE', required=True,<br/>        help='input file with CVAT annotation in xml format'<br/>    )</span><span id="1a44" class="ma mb it lw b gy mg md l me mf">parser.add_argument(<br/>        '--output-dir', metavar='DIRECTORY', required=True,<br/>        help='directory for output masks'<br/>    )</span><span id="ccb6" class="ma mb it lw b gy mg md l me mf">parser.add_argument(<br/>        '--scale-factor', type=float, default=1.0,<br/>        help='choose scale factor for images'<br/>    )</span><span id="d9f6" class="ma mb it lw b gy mg md l me mf">return parser.parse_args()</span></pre><p id="c4b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了理解提取函数是如何工作的，让我们仔细看看 CVAT XML 文件的这一部分:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="651c" class="ma mb it lw b gy mc md l me mf">&lt;image id="7" name="7.jpg" width="4800" height="2831"&gt;<br/>    &lt;polygon label="roofs" occluded="0" points="2388.11,2069.80;2313.80,2089.10;2297.46,2080.21;2285.57,2043.80;2339.07,2031.17;2336.10,2018.54;2428.23,2060.89"&gt;<br/>    &lt;/polygon&gt;<br/>    &lt;polygon label="roofs" occluded="0" points="1431.35,1161.11;1353.11,1179.63;1366.25,1229.79;1398.80,1219.94;1396.11,1210.08;1437.91,1194.26"&gt;<br/>    &lt;/polygon&gt;<br/>    &lt;polygon label="roofs" occluded="0" points="1344.81,1673.28;1270.10,1619.40;1213.00,1697.00"&gt;<br/>    &lt;/polygon&gt;<br/>    &lt;polygon label="roofs" occluded="0" points="1498.35,939.31;1573.30,923.19;1586.74,985.00;1509.10,1002.32"&gt;<br/>    &lt;/polygon&gt;<br/>...</span></pre><p id="eb9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，需要在 XML 文件中找到与当前处理的图像相对应的区域。最简单的方法是通过文件名(例子中的<em class="mh">7.jpg</em>)。接下来，您需要找到标记'<em class="mh">多边形</em>或'<em class="mh">框</em>，并从中提取必要的数据(在本例中，屋顶是基于多边形标记的)。您可以使用以下函数从 CVAT XML 获取标记结果:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="f577" class="ma mb it lw b gy mc md l me mf">def parse_anno_file(cvat_xml, image_name):<br/>    root = etree.parse(cvat_xml).getroot()<br/>    anno = []</span><span id="64c0" class="ma mb it lw b gy mg md l me mf">image_name_attr = ".//image[<a class="ae le" href="http://twitter.com/name" rel="noopener ugc nofollow" target="_blank">@name</a>='{}']".format(image_name)</span><span id="9276" class="ma mb it lw b gy mg md l me mf">for image_tag in root.iterfind(image_name_attr):<br/>        image = {}<br/>        for key, value in image_tag.items():<br/>            image[key] = value<br/>        image['shapes'] = []<br/>        for poly_tag in image_tag.iter('polygon'):<br/>            polygon = {'type': 'polygon'}<br/>            for key, value in poly_tag.items():<br/>                polygon[key] = value<br/>            image['shapes'].append(polygon)<br/>        for box_tag in image_tag.iter('box'):<br/>            box = {'type': 'box'}<br/>            for key, value in box_tag.items():<br/>                box[key] = value<br/>            box['points'] = "{0},{1};{2},{1};{2},{3};{0},{3}".format(<br/>                box['xtl'], box['ytl'], box['xbr'], box['ybr'])<br/>            image['shapes'].append(box)<br/>        image['shapes'].sort(key=lambda x: int(x.get('z_order', 0)))<br/>        anno.append(image)<br/>    return anno</span></pre><p id="0ece" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们需要创建掩码文件。用白色画蒙版多边形的边，用红色画里面的内容(如上图所示)。以下函数允许您这样做:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="0c56" class="ma mb it lw b gy mc md l me mf">def create_mask_file(width, height, bitness, background, shapes, scale_factor):<br/>    mask = np.full((height, width, bitness // 8), background, dtype=np.uint8)<br/>    for shape in shapes:<br/>        points = [tuple(map(float, p.split(','))) for p in shape['points'].split(';')]<br/>        points = np.array([(int(p[0]), int(p[1])) for p in points])<br/>        points = points*scale_factor<br/>        points = points.astype(int)<br/>        mask = cv2.drawContours(mask, [points], -1, color=(255, 255, 255), thickness=5)<br/>        mask = cv2.fillPoly(mask, [points], color=(0, 0, 255))<br/>    return mask</span></pre><p id="da5d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，主要功能是:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="34bf" class="ma mb it lw b gy mc md l me mf">def main():<br/>    args = parse_args()<br/>    dir_create(args.output_dir)<br/>    img_list = [f for f in os.listdir(args.image_dir) if os.path.isfile(os.path.join(args.image_dir, f))]<br/>    mask_bitness = 24<br/>    for img in tqdm(img_list, desc='Writing contours:'):<br/>        img_path = os.path.join(args.image_dir, img)<br/>        anno = parse_anno_file(args.cvat_xml, img)<br/>        background = []<br/>        is_first_image = True<br/>        for image in anno:<br/>            if is_first_image:<br/>                current_image = cv2.imread(img_path)<br/>                height, width, _ = current_image.shape<br/>                background = np.zeros((height, width, 3), np.uint8)<br/>                is_first_image = False<br/>            output_path = os.path.join(args.output_dir, img.split('.')[0] + '.png')<br/>            background = create_mask_file(width,<br/>                                          height,<br/>                                          mask_bitness,<br/>                                          background,<br/>                                          image['shapes'],<br/>                                          args.scale_factor)<br/>        cv2.imwrite(output_path, background)</span></pre><p id="b63c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们对 python 解释器执行 file as 命令时，我们必须添加以下结构:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="850a" class="ma mb it lw b gy mc md l me mf">if __name__ == "__main__":<br/>    main()</span></pre><p id="d3d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仅此而已。要运行该脚本，您应该运行以下命令(如果在标记后不调整图像大小，则默认情况下缩放因子为 1):</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="35d5" class="ma mb it lw b gy mc md l me mf">python script_name.py --image-dir original_images_dir --cvat-xml cvat.xml --output-dir masks_dir --scale-factor 0.4</span></pre><p id="0067" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原始图像示例:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mi"><img src="../Images/7548c563bd4c53b914f26ceeef2a969d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4AkFUThpV6zRTuKuNN4P-g.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图片由 Oleksii Sheremet 使用<a class="ae le" href="https://www.google.com.ua/intl/en/earth/" rel="noopener ugc nofollow" target="_blank"> Google Earth </a>创建</p></figure><p id="b0d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为脚本结果获得的掩码:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mi"><img src="../Images/3469b96fe0baa4e18dcb2c735c50e6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QG-yYW0LEn8Cc_rN-6czgw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图片由 Oleksii Sheremet 使用<a class="ae le" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>库创建</p></figure><p id="a037" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">结论</strong></p><p id="736c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所考虑的方法允许从包含在 CVAT XML 中的数据获得更复杂的掩码文件。根据顶点的数量，可以提取单个多边形或用不同的颜色高亮显示多边形。此外，稍加修改后，所考虑的脚本将允许根据标记轮廓从原始图像中切割多边形截面。</p><p id="6214" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">参考文献</strong></p><p id="3573" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://github.com/opencv/cvat" rel="noopener ugc nofollow" target="_blank">计算机视觉标注工具(CVAT) </a></p><p id="3692" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://lxml.de/" rel="noopener ugc nofollow" target="_blank"> lxml —用 Python 实现 xml 和 HTML</a></p><p id="df7f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a></p><p id="52e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://realpython.com/run-python-scripts/" rel="noopener ugc nofollow" target="_blank">如何运行您的 Python 脚本</a></p></div></div>    
</body>
</html>