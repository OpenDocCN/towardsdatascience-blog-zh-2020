<html>
<head>
<title>NumPy indexing explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NumPy索引解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/numpy-indexing-explained-c376abb2440d?source=collection_archive---------15-----------------------#2020-03-22">https://towardsdatascience.com/numpy-indexing-explained-c376abb2440d?source=collection_archive---------15-----------------------#2020-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7ce2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数字索引及其方法综合指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6ab7cb4f84a005f6ef62499a82cc4f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbwZ-siayjTna3DHUc8gGA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">让-路易·波林在<a class="ae ky" href="https://unsplash.com/s/photos/rubik?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="527f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> NumPy </strong>是在<strong class="lb iu"> Py </strong> thon中处理<strong class="lb iu">Num</strong>Eric数据的通用标准。多维NumPy数组广泛用于Pandas、SciPy、Scikit-Learn、scikit-image，它们是一些主要的数据科学和科学Python包。因此，如果我们使用这些工具<strong class="lb iu">，那么很好地理解NumPy是至关重要的！</strong>因此，要理解它的索引方法，我们将在本帖中讨论。</p><p id="a879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，使用NumPy的一个关键方面或动机是，它能够以一种<em class="lv">向量化</em>的方式操作大量的数字数据，也就是说，避免使用低效的python循环。向量化你的代码的巨大优势是你把所有的循环都推到了C级，这要快得多。</p><p id="545c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们进入文章的主题，即<strong class="lb iu">索引NumPy数组</strong>。如果没有很好地理解NumPy的基本规则，那么使用NumPy进行索引可能会有点困难，而且有悖常理。在这里，我们将深入探讨可以使用的不同索引方法，它们是:</p><blockquote class="lw lx ly"><p id="2527" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">- <a class="ae ky" href="https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#basic-slicing-and-indexing" rel="noopener ugc nofollow" target="_blank">基本切片和索引</a></p><p id="b091" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">- <a class="ae ky" href="https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing" rel="noopener ugc nofollow" target="_blank">高级索引</a>(包括整数和布尔数组索引)</p></blockquote><p id="ef3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在这里</strong> 找到这篇文章的笔记本版本以及所有解释 <a class="ae ky" href="https://github.com/AlexanderNixon/Machine-learning-reads/blob/master/NumPy-indexing-explained.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">。</strong></a></p><h1 id="93a6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基本切片</h1><p id="acba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">NumPy的基本切片是Python的基本切片概念扩展到<em class="lv"> N </em>维的延伸。</p><p id="26d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它基本上允许你使用基本的切片符号，即<strong class="lb iu"> start:stop:step，沿着数组的维度对数组进行<em class="lv">切片</em>。</strong>如果你不太熟悉Python的基本切片符号，你可以查看<a class="ae ky" href="https://stackoverflow.com/a/509295/9698684" rel="noopener ugc nofollow" target="_blank">这个</a>在堆栈溢出中的帖子，这就很清楚了。让我们看一个例子:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="96b2" class="ne md it na b gy nf ng l nh ni">array([['A', 'B', 'C', 'D', 'E'],<br/>       ['F', 'G', 'H', 'I', 'J'],<br/>       ['K', 'L', 'M', 'N', 'O'],<br/>       ['P', 'Q', 'R', 'S', 'T'],<br/>       ['U', 'V', 'W', 'X', 'Y']])</span></pre><p id="934a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我知道<strong class="lb iu"> z </strong>这个示例数组有一个形状为<strong class="lb iu"> (5，5)，</strong>的二维数组。<strong class="lb iu"> </strong>我们可以沿着它的维度(我将使用等价术语<em class="lv">轴</em>)进行切片，例如:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1b28" class="ne md it na b gy nf ng l nh ni">a[:2, 1:4]</span><span id="5547" class="ne md it na b gy nj ng l nh ni">array([['B', 'C', 'D'],<br/>       ['G', 'H', 'I']])</span></pre><p id="306d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止一切顺利。我们基本上已经沿着第一个轴对数组进行了切片，直到从索引0 <em class="lv"> </em>开始的第二行(注意<em class="lv">停止索引</em>不包括在内<em class="lv"> </em>！)，并沿第二条得到第一到第三列。把坐标轴想象成矩阵的维度(<em class="lv"> x，y，z </em>)。其中第三维可以简单地认为是将多个2D阵列堆叠在一起:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/9e33f54a1aae23a8a3dc16a5c7dd9d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*mKoaKq1I7LGg82DhrDmgPA.png"/></div></figure><p id="b8cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在我们知道我们可以使用python的切片符号对n维<em class="lv">数组进行切片。但是，如果您必须使用一个索引列表从给定的轴<strong class="lb iu">中获取值，该怎么办呢？</strong></em></p><p id="3423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是高级索引发挥作用的地方↓</p><h1 id="a4c7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">高级索引</h1><p id="34d2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们举一个直观的例子:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5524" class="ne md it na b gy nf ng l nh ni">a_indexed = a[[4,3,1], [2,4,0]]</span></pre><p id="4ea0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，按照与基本切片相同的逻辑，我们可以得到沿着ndarray的不同轴落入上述索引中的所有值。即<em class="lv">第2、4、0列的第4、3、1行的所有</em>值，所以下面突出显示的相交值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/07833af829ffe037909b2f7e762f7fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EsrYK0W1vyVOtAHvIpoXSQ.png"/></div></figure><p id="7aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是这样吗？让我们检查一下:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f71b" class="ne md it na b gy nf ng l nh ni">print(a_indexed)<br/>array(['W', 'T', 'F'])</span></pre><p id="5c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然不是…(这个例子来自海梅·费尔南德斯的非常有启发性的演讲:)那里发生了什么？为什么我们得到的是一维的结果？</p><p id="4d2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为<em class="lv">高级步进遵循一套不同的规则。</em>考虑这个问题的一个好方法是，当使用基本切片时，我们在一个<strong class="lb iu">网格</strong>上建立索引，该网格由我们在每个维度上获取的切片定义。而使用高级索引可以被认为是指定一组我们想要检索的值的(<em class="lv"> x，y </em> ) <strong class="lb iu">坐标</strong>。</p><p id="7299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上述情况下，使用<code class="fe nm nn no na b">[4,3,1],[2,4,0]</code>进行步进，将分别在<code class="fe nm nn no na b">(4,2)</code>、<code class="fe nm nn no na b">(3,4)</code>和<code class="fe nm nn no na b">(1,0)</code>上进行步进。因此，我们在每个维度中指定的每个索引都将与其他维度中的相应索引相结合。</p><p id="e341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更一般地说，当使用高级索引时，我们必须考虑这两个主要方面(来自<a class="ae ky" href="https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing" rel="noopener ugc nofollow" target="_blank">文档</a>):</p><ul class=""><li id="7c47" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><strong class="lb iu"> <em class="lv">索引数组表示该维度中的多个索引</em> </strong></li></ul><p id="8654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这基本上意味着我们将从一个给定的轴中检索与索引数组中指定的索引一样多的元素。在上面的例子中，我们已经检索了长度为3的索引数组指定的3个元素。</p><ul class=""><li id="e90d" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><strong class="lb iu"> <em class="lv">结果形状与(广播)步进阵列形状</em> </strong>相同</li></ul><p id="efa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解以上内容，我们需要深入了解一下<strong class="lb iu">广播</strong> …</p><p id="ce23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">深入广播很容易导致另一个完整的博客帖子，所以我将试图涵盖非常重要的内容…来自<a class="ae ky" href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="lw lx ly"><p id="0af5" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">广播被定义为一个描述NumPy在算术运算过程中如何处理不同形状的数组的术语。受某些约束，较小的阵列在较大的阵列上“广播”,以便它们具有兼容的形状</p></blockquote><p id="581f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以基本上，当一些涉及不同形状的数组的操作被执行时，NumPy试图在操作发生之前<em class="lv">使它们的形状兼容。</em>让我们来看一些直观的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/6b36941aeccd68b1cb98bedbdf1798be.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*Pap5u8C1UZMuFD75Q-ReCg.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/f050833c7227738bb3cb401e2dddfbc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*kl1EOZl7XpePlhh45RTFQg.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/a060d12c88fed141592c9819df7b26df.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*LYazxQ4adGDDi5ZvhXZCJw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://jakevdp.github.io/PythonDataScienceHandbook/02.05-computation-on-arrays-broadcasting.html" rel="noopener ugc nofollow" target="_blank">图源</a></p></figure><p id="b686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在第一种情况下，一维NumPy数组被添加到一个整数上。因此，在添加发生之前，NumPy将<em class="lv">在较大的数组中广播</em>较小形状的数组，也就是说，它将复制其值，直到其形状与较大数组的形状兼容。</p><p id="5df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何知道两种形状是否兼容？</p><p id="8ce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在文档中找到<a class="ae ky" href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html#general-broadcasting-rules" rel="noopener ugc nofollow" target="_blank">通用广播规则</a>。据说两个维度在下列情况下是相容的</p><ul class=""><li id="294e" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><em class="lv">它们相等，或者说</em></li><li id="175c" class="np nq it lb b lc nz lf oa li ob lm oc lq od lu nu nv nw nx bi translated"><em class="lv">其中一个是1 </em></li></ul></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="2317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，那么所有这些和高级索引有什么关系呢？提醒第二点，高级索引<em class="lv">产生的形状与(广播)索引数组形状相同。</em>这基本上意味着在执行索引操作之前，NumPy将尝试使索引数组中的图形兼容。检查结果形状的一个简单方法是使用<code class="fe nm nn no na b">np.broadcast</code>(在数组可以广播的情况下)。让我们看看与上面相同的例子:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="eb0f" class="ne md it na b gy nf ng l nh ni">a = array([['A', 'B', 'C', 'D', 'E'],<br/>           ['F', 'G', 'H', 'I', 'J'],<br/>           ['K', 'L', 'M', 'N', 'O'],<br/>           ['P', 'Q', 'R', 'S', 'T'],<br/>           ['U', 'V', 'W', 'X', 'Y']])</span></pre><p id="0298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们现在想用以下内容索引数组:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8b0a" class="ne md it na b gy nf ng l nh ni">rows = np.array([0,2,1])<br/>cols = np.array([2])</span></pre><p id="77bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，使用上面的索引，我们将得到一个形状如下的数组:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ec1f" class="ne md it na b gy nf ng l nh ni">ix = np.broadcast(rows, cols)</span><span id="569f" class="ne md it na b gy nj ng l nh ni">print(ix.shape)<br/>(3,)</span></pre><p id="9f50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，上图中第一种情况下的广播正在发生。该阵列将在以下<em class="lv"> (x，y) </em>坐标上进行索引:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c1ca" class="ne md it na b gy nf ng l nh ni">print(*ix)<br/>(0, 2), (2, 2), (1, 2)</span></pre><p id="f60e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此我们得到:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5d80" class="ne md it na b gy nf ng l nh ni">a[rows, cols]<br/>array(['C', 'M', 'H'])</span></pre><p id="0f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中，由于两个数组都被广播，所以上述内容相当于:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2008" class="ne md it na b gy nf ng l nh ni">a[[0, 2, 1], [2, 2, 2]]<br/>array(['C', 'M', 'H'])</span></pre><p id="5258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了索引整数数组，我们只需确保它们的形状可以一起广播，然后让NumPy处理剩下的事情。</p><p id="1346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在我们知道了如何使用整数索引来索引一个数组…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://i.embed.ly/1/image?url=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2FSU8uW4rBMMfR2Y3Dnh%2Fgiphy.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07" rel="noopener ugc nofollow" target="_blank"> giff来自giphy </a></p></figure><p id="5b72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以随之而来的问题是…</p><p id="bb64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如果我想让索引像基本切片</strong>那样运行，该怎么办？也就是说，我们如何获得我们在第一种情况下所期望的，而不是<code class="fe nm nn no na b">array(['W', 'T', 'F'])</code>？</p><p id="a882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到那个例子…我们使用了索引:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="04d3" class="ne md it na b gy nf ng l nh ni">rows = np.array([4,3,1])<br/>cols = np.array([2,4,0])</span></pre><p id="ba4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，正如我们之前所验证的，我们得到了一个一维数组，结果是:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="16ef" class="ne md it na b gy nf ng l nh ni">ix = np.broadcast(rows, cols)</span><span id="6029" class="ne md it na b gy nj ng l nh ni">print(*ix)<br/>(4, 2) (3, 4) (1, 0)</span></pre><p id="a9cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们必须找到一种方法让NumPy明白我们想要检索一个包含所有值的<strong class="lb iu">网格</strong>。如何做到这一点…？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://giphy.com/gifs/reaction-BmmfETghGOPrW" rel="noopener ugc nofollow" target="_blank"> giff来自giphy </a></p></figure><p id="ff8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是……要<strong class="lb iu">用广播！！</strong></p><p id="8fb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到广播正在做的是<em class="lv">拉伸</em>较小的阵列，以便所有阵列形状都兼容，我们可以利用这个想法来获得我们预期的结果。</p><p id="9ab7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以做的是给其中一个数组添加一个轴，这样NumPy <em class="lv">就可以传播较小的数组来适应较大数组的大小(这里是指较小的数组)。这可以通过以下方式实现:</em></p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="633d" class="ne md it na b gy nf ng l nh ni">rows[:,np.newaxis]<br/>array([[4],<br/>       [3],<br/>       [1]])</span></pre><p id="1c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以等效地使用<code class="fe nm nn no na b">rows[:,None]</code>。现在，两个索引数组可以一起广播，并可用于索引数组:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="01d9" class="ne md it na b gy nf ng l nh ni">ix = np.broadcast(rows[:,None], cols)<br/>print(*ix)<br/>(4, 2) (4, 4) (4, 0) (3, 2) (3, 4) (3, 0) (1, 2) (1, 4) (1, 0)</span></pre><p id="8fb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以认为这是生成索引列表的<a class="ae ky" href="https://en.wikipedia.org/wiki/Cartesian_product" rel="noopener ugc nofollow" target="_blank"> <em class="lv">笛卡尔积</em> </a>，以便从数组中检索所有的索引。我们实际上可以用<code class="fe nm nn no na b"><a class="ae ky" href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="noopener ugc nofollow" target="_blank">itertools.product</a></code>来复制这个:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ebf2" class="ne md it na b gy nf ng l nh ni">print(*product(rows, cols))<br/>(4, 2) (4, 4) (4, 0) (3, 2) (3, 4) (3, 0) (1, 2) (1, 4) (1, 0)</span></pre><p id="9fc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，现在通过用<em class="lv">广播</em>索引来索引数组，我们得到:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ef76" class="ne md it na b gy nf ng l nh ni">a[rows[:,None], cols]</span><span id="a17d" class="ne md it na b gy nj ng l nh ni">array([['W', 'Y', 'U'],<br/>       ['R', 'T', 'P'],<br/>       ['H', 'J', 'F']])</span></pre><p id="9398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该广播也可以使用功能<code class="fe nm nn no na b">np.ix_</code> <strong class="lb iu"> : </strong>来实现</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f148" class="ne md it na b gy nf ng l nh ni">a[np.ix_(rows, cols)]</span><span id="be62" class="ne md it na b gy nj ng l nh ni">array([['W', 'Y', 'U'],<br/>       ['R', 'T', 'P'],<br/>       ['H', 'J', 'F']])</span></pre></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="ac37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，正如我们所见，整数索引是一个非常有用的工具，我们只需要了解它是如何工作的。一个非常常见的应用是当我们有一个数组或嵌套的索引列表时，例如:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5da3" class="ne md it na b gy nf ng l nh ni">cols = [[3,4], [0,2], [0,1], [1,2], [3,3]]</span></pre><p id="e13b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想沿着第一轴分别取这些列，所以第一行的第3列和第4列，第二行的第0列和第2列，依此类推。我们如何做到这一点？你为什么不试一试…？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">【giphy的gif</p></figure><p id="b612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，在整数索引中，维度上的索引通过广播规则进行组合。因此，利用广播，我们想要获得一组索引，其组合形状是<em class="lv">可广播的</em>到期望的输出形状。这在本例中非常简单，因为每行都有一个子列表。因此，很明显，我们需要一个包含与第一个轴上索引的行数一样多的值的范围。</p><p id="f6ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以一个显而易见的方法是:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ce9d" class="ne md it na b gy nf ng l nh ni">rows = np.arange(a.shape[0])<br/>a[rows, <!-- -->cols<!-- -->]</span></pre><p id="08c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这将产生:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1121" class="ne md it na b gy nf ng l nh ni">IndexError: shape mismatch: indexing arrays could not be broadcast together with shapes (5,) (5,2)</span></pre><p id="c7d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，错误是显而易见的，索引数组不能一起广播。这是因为沿相应轴的形状不兼容，因为我们有:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="41d3" class="ne md it na b gy nf ng l nh ni">cols (2d array): 5 x 2<br/>rows (1d array):     5 </span></pre><p id="8c16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的草图可以清楚地看出，为了使形状兼容，我们必须向<code class="fe nm nn no na b">rows</code>添加一个新轴，这样两个数组上的第二个轴具有相同的形状，并且行的第一个轴是1，这满足广播的第二个规则:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1bd6" class="ne md it na b gy nf ng l nh ni">cols         (2d array): 5 x 2<br/>rows[:,None] (1d array): 5 x 1</span></pre><p id="a922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们会得到预期的结果:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b103" class="ne md it na b gy nf ng l nh ni">a[rows[:,None], cols]</span><span id="2fd1" class="ne md it na b gy nj ng l nh ni">array([['D', 'E'],<br/>       ['F', 'H'],<br/>       ['K', 'L'],<br/>       ['Q', 'R'],<br/>       ['X', 'X']])</span></pre></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="5c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，对于最后一部分… <strong class="lb iu">是否有可能结合两种类型的索引</strong>？</p><p id="a38d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">警告…！(这最后一部分变得有点复杂，并且您已经浏览了最相关和最有用的内容，所以可以休息一下，或者如果您认为现在已经看够了，就把它留在这里:)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">【GIPHY的gif</p></figure><h1 id="bc4f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结合高级索引和基本切片</h1><p id="3746" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">也可以将基本切片和高级索引结合起来。这将导致整数数组索引以与我们之前看到的相同方式一起广播，并且切片的行为与我们在<em class="lv">基本切片</em>部分看到的一样。然而，在某些情况下，这可能会导致意想不到的结果。</p><p id="8bd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以下面的例子作为参考来更好地解释这一点:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5c69" class="ne md it na b gy nf ng l nh ni">a = np.arange(60).reshape(3,4,5)</span><span id="a302" class="ne md it na b gy nj ng l nh ni">print(a)<br/>array([[[ 0,  1,  2,  3,  4],<br/>        [ 5,  6,  7,  8,  9],<br/>        [10, 11, 12, 13, 14],<br/>        [15, 16, 17, 18, 19]],<br/><br/>       [[20, 21, 22, 23, 24],<br/>        [25, 26, 27, 28, 29],<br/>        [30, 31, 32, 33, 34],<br/>        [35, 36, 37, 38, 39]],<br/><br/>       [[40, 41, 42, 43, 44],<br/>        [45, 46, 47, 48, 49],<br/>        [50, 51, 52, 53, 54],<br/>        [55, 56, 57, 58, 59]]])</span></pre><p id="0439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于组合索引，我们需要考虑以下指导规则:</p><ul class=""><li id="2aeb" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><strong class="lb iu"> <em class="lv">整数数组索引规则仅在引入两个或更多非切片对象时适用</em> </strong></li></ul><p id="3ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着如果我们只使用一个整数数组来索引，比如:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7ccc" class="ne md it na b gy nf ng l nh ni">a_s = a[:2, [0, 1]]</span><span id="f839" class="ne md it na b gy nj ng l nh ni">a_s.shape<br/>(2, 2, 5)</span><span id="0d0e" class="ne md it na b gy nj ng l nh ni">print(a_s)<br/>array([[[ 0,  1,  2,  3,  4],<br/>        [ 5,  6,  7,  8,  9]],<br/><br/>       [[20, 21, 22, 23, 24],<br/>        [25, 26, 27, 28, 29]]])</span></pre><p id="4035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，因为<em class="lv">基本切片</em>规则在这里适用，所以上述规则将等同于<code class="fe nm nn no na b">a[:2,:2]</code>。</p><p id="112e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，一旦我们有了一个以上的索引数组，<em class="lv">高级索引</em>规则将适用:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="77d7" class="ne md it na b gy nf ng l nh ni">a_s = a[:2, [0, 1], [2, 4]]</span><span id="063e" class="ne md it na b gy nj ng l nh ni">a_s.shape<br/>(2, 2)</span><span id="53d5" class="ne md it na b gy nj ng l nh ni">print(a_s)<br/>array([[ 2,  9],<br/>       [22, 29]])</span></pre><p id="2ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，为最后一个轴添加一个索引数组，导致输出的形状取决于两个索引数组的广播形状，即(2，2)。</p><ul class=""><li id="4500" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><strong class="lb iu"> <em class="lv">数组索引引入的结果轴在前面，除非它们是连续的</em> </strong></li></ul><p id="0979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一些例子来更清楚地了解这一点。以下面的索引对为例:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="765b" class="ne md it na b gy nf ng l nh ni">ix1 = np.array([0,1])<br/>ix2 = np.array([1,3])</span></pre><p id="f379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以分别使用<code class="fe nm nn no na b">ix1</code>和<code class="fe nm nn no na b">ix2</code>沿着前两个轴进行索引，并沿着最后一个轴进行完整的切片。在这种情况下，我们将得到2D数组0 <em class="lv"> </em>和<em class="lv"> </em> 1，分别为第1行和第3行，并且对于这两种情况都得到沿着最后一个轴的完整切片:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="51fa" class="ne md it na b gy nf ng l nh ni">a_s = a[ix1, ix2, :]</span><span id="4910" class="ne md it na b gy nj ng l nh ni">a_s.shape<br/>(2, 5)</span><span id="f21e" class="ne md it na b gy nj ng l nh ni">print(a_s)<br/>array([[ 5,  6,  7,  8,  9],<br/>       [35, 36, 37, 38, 39]])</span></pre><p id="256b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们选择了这些元素:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/d33760f40d74368a4068cd326a8d9669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*gRveJyXaNWVN0bD2qkcYBw.png"/></div></figure><p id="e890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如前所述，这里两个<em class="lv">不同方法的规则</em>按预期工作并被组合。沿着最后一个轴的基本切片遵循第一节中提到的<em class="lv">基本切片</em>的规则，所以如果你用一个数组代替索引，你会得到:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cc26" class="ne md it na b gy nf ng l nh ni">ix3 = np.array([1,2])</span><span id="d06a" class="ne md it na b gy nj ng l nh ni">a[ix1, ix2, ix3]<br/>array([ 6, 37])</span></pre><p id="041a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以用以下方式索引:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1db0" class="ne md it na b gy nf ng l nh ni">a_s = a[:, ix1, ix2]</span><span id="d59f" class="ne md it na b gy nj ng l nh ni">a_s.shape<br/>(3, 2)</span><span id="257a" class="ne md it na b gy nj ng l nh ni">print(a_s)<br/>array([[ 1,  8],<br/>       [21, 28],<br/>       [41, 48]])</span></pre><p id="8a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在第一个轴上选择所有2D阵列的完整切片，然后分别选择行0和1以及列1和3，所以:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/4ed29c56ae489880ce381c7b43c5728e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*jc_LCZNe3WmXTF_YgX-Z2Q.png"/></div></figure><p id="ad92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，最后如果我们使用索引数组在第一个和最后一个轴上建立索引，如<code class="fe nm nn no na b">a[ix1, :, ix2]</code>，我们将期望在前两个2D <em class="lv"> - </em>数组上建立索引，在第二个轴(所有行)上取一个完整的切片，分别在第1列和第3列上。所以:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/6af7fbf80ed2cb1b8b5cfde2805611af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*3-OOiLWUrI7tVeMYuVBpUw.png"/></div></figure><p id="1af1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了(4，2) <strong class="lb iu">、</strong>的最终形状，让我们检查一下:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="94a0" class="ne md it na b gy nf ng l nh ni">a_s = a[ix1, :, ix2]</span><span id="c573" class="ne md it na b gy nj ng l nh ni">s_s.shape<br/>(2,4)</span><span id="c3ec" class="ne md it na b gy nj ng l nh ni">print(a_s)<br/>array([[ 1,  6, 11, 16],<br/>       [23, 28, 33, 38]])</span></pre><p id="9f3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么这个案例不一样… <strong class="lb iu">？？</strong></p><p id="3f6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到第二个规则:<em class="lv">由数组索引引入的结果轴在前面，除非它们是连续的。</em>因此，因为这里的索引数组不是连续的，所以使用它们的结果轴将在前面，切片维度在后面。</p><p id="2b69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然用一维数组做索引看起来很奇怪，但是要考虑到也可以用任意维数的数组做索引。假设我们用3d数组在第一个和最后一个轴上索引同一个示例数组，两个数组的形状都是<code class="fe nm nn no na b">(3,4,2)</code>。所以我们知道最终的数组在某个地方也会有形状<code class="fe nm nn no na b">(3,4,2)</code>，因为两个索引数组传播到同一个形状。现在的问题是，<em class="lv">我们在第一个轴和最后一个轴</em>之间取一个完整的切片放在哪里？</p><p id="14f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于不再清楚是否应该放在中间，在这些情况下有一个惯例，即切片维度放在最后<em class="lv">。</em></p><p id="0699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在这种情况下，我们的任务是重新排列数组的维数，以匹配我们的预期输出。在上面的例子中，我们可以交换最后两个轴，得到我们期望的结果:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f103" class="ne md it na b gy nf ng l nh ni">a[ix1, :, ix2].swapaxes(0,1)</span><span id="a5ec" class="ne md it na b gy nj ng l nh ni">array([[ 1, 23],<br/>       [ 6, 28],<br/>       [11, 33],<br/>       [16, 38]])</span></pre><p id="aa36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种情况下基本和移调一样，<code class="fe nm nn no na b">a[ix1, :, ix2].T</code>。</p><p id="71c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，作为最后一节的<strong class="lb iu">收获</strong>，我们在组合两种索引方法时必须小心，因为我们可能不总是得到我们期望的。最安全的方法是牢记组合索引的注意事项，以确保它的行为符合我们的预期。</p><p id="7842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢你花时间阅读这篇文章，希望你喜欢:)</p></div></div>    
</body>
</html>