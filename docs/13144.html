<html>
<head>
<title>Java Development with Microsoft SQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Microsoft SQL Server 进行 Java 开发</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/java-development-with-microsoft-sql-server-ee6efd13f799?source=collection_archive---------34-----------------------#2020-09-09">https://towardsdatascience.com/java-development-with-microsoft-sql-server-ee6efd13f799?source=collection_archive---------34-----------------------#2020-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a04b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 JDBC 从 Java 应用程序调用 Microsoft SQL Server 存储过程</h2></div><h1 id="f9e9" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">介绍</h1><p id="22a2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">企业软件解决方案通常结合了多种技术平台。通过微软的。NET 应用程序，反之亦然，从基于 Java 的应用程序访问 Microsoft SQL Server 是很常见的。在本帖中，我们将探索如何使用<a class="ae lw" href="https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html" rel="noopener ugc nofollow" target="_blank"> JDBC </a> (Java 数据库连接)API 从微软 SQL Server 2017 数据库中调用存储过程，并将数据返回给基于 Java 11 的控制台应用程序。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi lx"><img src="../Images/63e0fd4f296fa303b1fa5357f2f32ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNJ_XPrIyIvo-jdm7pZFqw.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">从 JetBrains 的智能界面查看 post 的 Java 项目</p></figure><p id="05d2" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">该员额的目标包括:</p><ul class=""><li id="20bb" class="ms mt it lc b ld mn lg mo lj mu ln mv lr mw lv mx my mz na bi translated">演示使用静态 SQL 语句和存储过程返回数据的区别。</li><li id="6155" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">演示三种返回数据的 JDBC 语句:<code class="fe ng nh ni nj b">Statement</code>、<code class="fe ng nh ni nj b">PreparedStatement</code>和<code class="fe ng nh ni nj b">CallableStatement</code>。</li><li id="871f" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">演示如何使用输入和输出参数调用存储过程。</li><li id="21e6" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">演示如何使用存储过程从数据库返回单个值和一个结果集。</li></ul><h1 id="4b61" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">为什么是存储过程？</h1><p id="115e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了访问数据，许多企业软件组织要求他们的开发人员在代码中调用存储过程，而不是对数据库执行静态的<a class="ae lw" href="https://en.wikipedia.org/wiki/Transact-SQL" rel="noopener ugc nofollow" target="_blank"> T-SQL </a> (Transact-SQL)语句。存储过程成为<a class="ae lw" href="https://docs.microsoft.com/en-us/sql/relational-databases/stored-procedures/stored-procedures-database-engine?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">首选</a>有几个原因:</p><ul class=""><li id="068a" class="ms mt it lc b ld mn lg mo lj mu ln mv lr mw lv mx my mz na bi translated">优化:存储过程通常由数据库管理员(DBA)或专门从事数据库开发的数据库开发人员编写。他们了解构造查询的最佳方式，以获得最佳性能和最小的数据库服务器负载。可以把它想象成开发人员使用 API 与数据库进行交互。</li><li id="c242" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">安全性:存储过程被认为比静态 SQL 语句更安全。存储过程提供了对查询内容的严格控制，防止对数据库执行恶意或无意的破坏性代码。</li><li id="b75d" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">错误处理:存储过程可以包含处理错误的逻辑，以免错误上升到应用层，甚至最终用户。</li></ul><h1 id="0738" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">AdventureWorks 2017 数据库</h1><p id="b880" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了简洁起见，我将使用一个现有的众所周知的微软 SQL Server 数据库，<a class="ae lw" href="https://github.com/microsoft/sql-server-samples/tree/master/samples/databases/adventure-works" rel="noopener ugc nofollow" target="_blank"> AdventureWorks </a>。AdventureWorks 数据库最初由 Microsoft 针对 SQL Server 2008 发布。尽管在体系结构上有点过时，但该数据库已经预先填充了大量用于演示的数据。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nk"><img src="../Images/2027225e72cd04b5215f07068ff4caf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HaD8nvSa_7riKMjadtj_ng.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated"><code class="fe ng nh ni nj b">HumanResources</code>模式，AdventureWorks 数据库中的五个模式之一</p></figure><p id="3d6e" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">为了演示，我在 AWS 上创建了一个<a class="ae lw" href="https://aws.amazon.com/rds/sqlserver/" rel="noopener ugc nofollow" target="_blank">Amazon RDS for SQL Server 2017 Express Edition</a>实例。部署 SQL Server 有几种选择，包括<a class="ae lw" href="https://aws.amazon.com/rds/sqlserver/" rel="noopener ugc nofollow" target="_blank"> AWS </a>、<a class="ae lw" href="https://azure.microsoft.com/en-us/services/sql-database/" rel="noopener ugc nofollow" target="_blank"> Microsoft Azure </a>、<a class="ae lw" href="https://cloud.google.com/sql-server" rel="noopener ugc nofollow" target="_blank"> Google Cloud </a>，或者安装在本地工作站上。</p><p id="6597" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">有许多方法可以将<a class="ae lw" href="https://docs.microsoft.com/en-us/sql/samples/adventureworks-install-configure?view=sql-server-ver15&amp;tabs=ssms" rel="noopener ugc nofollow" target="_blank"> AdventureWorks </a>数据库部署到 Microsoft SQL Server。为了这篇文章的演示，我使用了<code class="fe ng nh ni nj b">AdventureWorks2017.bak</code> <a class="ae lw" href="https://docs.microsoft.com/en-us/sql/samples/adventureworks-install-configure?view=sql-server-ver15&amp;tabs=ssms" rel="noopener ugc nofollow" target="_blank">备份文件</a>，我把它复制到了亚马逊 S3。然后<a class="ae lw" href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/SQLServer.Procedural.Importing.html" rel="noopener ugc nofollow" target="_blank">我启用并配置了</a>Amazon RDS for SQL Server 的本地备份和恢复特性，以导入并安装备份。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="03c3" class="np kj it nj b gy nq nr l ns nt">DROP DATABASE IF EXISTS AdventureWorks;<br/>GO<br/><br/>EXECUTE msdb.dbo.rds_restore_database<br/>     @restore_db_name='AdventureWorks',<br/>     @s3_arn_to_restore_from='arn:aws:s3:::my-bucket/AdventureWorks2017.bak',<br/>     @type='FULL',<br/>     @with_norecovery=0;<br/><br/>-- get task_id from output (e.g. 1)<br/><br/>EXECUTE msdb.dbo.rds_task_status<br/>     @db_name='AdventureWorks',<br/>     @task_id=1;</span></pre><h1 id="0ef7" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">安装存储过程</h1><p id="a57a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了进行演示，我在 AdventureWorks 数据库中添加了四个存储过程，以便在本文中使用。为了跟进，您需要安装这些存储过程，它们包含在<a class="ae lw" href="https://github.com/garystafford/mssql-sp-java-jdbc-2020" rel="noopener ugc nofollow" target="_blank"> GitHub 项目</a>中。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nu"><img src="../Images/0d66fcc65dc2a61a4a1244735749ffa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_v05qCIZpSnZDGWLnoUelQ.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">JetBrains 的 IntelliJ IDE 数据库选项卡中的新存储过程视图</p></figure><h1 id="4d39" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">数据源、连接和属性</h1><p id="e2bf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用最新的<a class="ae lw" href="https://docs.microsoft.com/en-us/sql/connect/jdbc/download-microsoft-jdbc-driver-for-sql-server?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> Microsoft JDBC 驱动程序 8.4 for SQL Server </a>(版本 8.4.1.jre11)，我们创建一个 SQL Server 数据源<code class="fe ng nh ni nj b">com.microsoft.sqlserver.jdbc.SQLServerDataSource</code>和数据库连接<code class="fe ng nh ni nj b">java.sql.Connection</code>。创建和使用 JDBC 数据源和连接有多种模式。这篇文章不一定关注创建或使用这两者的最佳实践。在这个例子中，应用程序实例化了一个连接类<code class="fe ng nh ni nj b">SqlConnection.java</code>，它又实例化了<code class="fe ng nh ni nj b">java.sql.Connection</code>和<code class="fe ng nh ni nj b">com.microsoft.sqlserver.jdbc.SQLServerDataSource</code>对象。数据源的属性由单例类实例<code class="fe ng nh ni nj b">ProjectProperties.java</code>提供。这个类实例化了从配置属性文件<code class="fe ng nh ni nj b">config.properties</code>中读取值的<code class="fe ng nh ni nj b">java.util.Properties</code>类。启动时，应用程序创建数据库连接，调用每个示例方法，然后关闭连接。</p><h1 id="c0fc" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">例子</h1><p id="d5a6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于每个示例，我将展示存储过程(如果适用的话)，后面是调用该过程或执行静态 SQL 语句的 Java 方法。为了简洁起见，我在本文中省略了数据源和连接代码。同样，本文所有代码的完整副本可以在<a class="ae lw" href="https://github.com/garystafford/mssql-sp-java-jdbc-2020" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得，包括 Java 源代码、SQL 语句、辅助 SQL 脚本和一组基本的<a class="ae lw" href="https://junit.org/junit4/" rel="noopener ugc nofollow" target="_blank"> JUnit </a>测试。使用下面的命令来<code class="fe ng nh ni nj b">git clone</code>项目的本地副本。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="21fb" class="np kj it nj b gy nq nr l ns nt">git clone --branch master --single-branch --depth 1 --no-tags \<br/>    <a class="ae lw" href="https://github.com/garystafford/mssql-sp-java-jdbc-2020.git" rel="noopener ugc nofollow" target="_blank">https://github.com/garystafford/mssql-sp-java-jdbc-2020.git</a></span></pre><p id="7031" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">要运行 JUnit 单元测试，使用项目所基于的<a class="ae lw" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>，使用<code class="fe ng nh ni nj b">./gradlew cleanTest test --warning-mode none</code>命令。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nv"><img src="../Images/15d8d2991b6c44f8d7fedf04d610e158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rUF73dNiN6QB98v5cbjh0Q.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">JUnit 测试的成功运行</p></figure><p id="97ef" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">要使用项目所基于的 Gradle 构建和运行应用程序，请使用<code class="fe ng nh ni nj b">./gradlew run --warning-mode none</code>命令。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nv"><img src="../Images/fb73c140c9026e235a83c07c23344daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6tWpRGTbLiM7YkrZrrDWqg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">Java 控制台应用程序的输出</p></figure><h2 id="60c1" class="np kj it bd kk nw nx dn ko ny nz dp ks lj oa ob ku ln oc od kw lr oe of ky og bi translated">示例 1: SQL 语句</h2><p id="a0fd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在进入存储过程之前，我们将从一个简单的静态 SQL 语句开始。这个例子的方法<code class="fe ng nh ni nj b">getAverageProductWeightST</code>使用了<code class="fe ng nh ni nj b"><a class="ae lw" href="http://docs.oracle.com/javase/1.4.2/docs/api/java/sql/Statement.html" rel="noopener ugc nofollow" target="_blank">java.sql.Statement</a></code>类。根据<a class="ae lw" href="https://docs.oracle.com/javase/tutorial/jdbc/basics/processingsqlstatements.html" rel="noopener ugc nofollow" target="_blank">甲骨文的 JDBC 文档</a>,<code class="fe ng nh ni nj b">Statement</code>对象用于执行静态 SQL 语句并返回其产生的结果。此 SQL 语句计算 AdventureWorks 数据库中所有产品的平均重量。它返回一个单独的<code class="fe ng nh ni nj b">double</code>数值。此示例演示了从 SQL Server 返回数据的最简单方法之一。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="6d5d" class="np kj it nj b gy nq nr l ns nt"><em class="oh">/**<br/> * Statement example, no parameters, returns Integer<br/> *<br/> * </em><strong class="nj iu"><em class="oh">@return </em></strong><em class="oh">Average weight of all products<br/> */<br/></em>public double getAverageProductWeightST() {<br/>    double averageWeight = 0;<br/>    Statement stmt = null;<br/>    ResultSet rs = null;</span><span id="888d" class="np kj it nj b gy oi nr l ns nt">try {<br/>        stmt = <em class="oh">connection</em>.getConnection().createStatement();<br/>        String sql = "WITH Weights_CTE(AverageWeight) AS" +<br/>                "(" +<br/>                "    SELECT [Weight] AS [AverageWeight]" +<br/>                "    FROM [Production].[Product]" +<br/>                "    WHERE [Weight] &gt; 0" +<br/>                "        AND [WeightUnitMeasureCode] = 'LB'" +<br/>                "    UNION" +<br/>                "    SELECT [Weight] * 0.00220462262185 AS [AverageWeight]" +<br/>                "    FROM [Production].[Product]" +<br/>                "    WHERE [Weight] &gt; 0" +<br/>                "        AND [WeightUnitMeasureCode] = 'G')" +<br/>                "SELECT ROUND(AVG([AverageWeight]), 2)" +<br/>                "FROM [Weights_CTE];";<br/>        rs = stmt.executeQuery(sql);<br/>        if (rs.next()) {<br/>            averageWeight = rs.getDouble(1);<br/>        }<br/>    } catch (Exception ex) {<br/>        Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                log(Level.<em class="oh">SEVERE</em>, null, ex);<br/>    } finally {<br/>        if (rs != null) {<br/>            try {<br/>                rs.close();<br/>            } catch (SQLException ex) {<br/>                Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                        log(Level.<em class="oh">WARNING</em>, null, ex);<br/>            }<br/>        }<br/>        if (stmt != null) {<br/>            try {<br/>                stmt.close();<br/>            } catch (SQLException ex) {<br/>                Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                        log(Level.<em class="oh">WARNING</em>, null, ex);<br/>            }<br/>        }<br/>    }<br/>    return averageWeight;<br/>}</span></pre><h2 id="8fec" class="np kj it bd kk nw nx dn ko ny nz dp ks lj oa ob ku ln oc od kw lr oe of ky og bi translated">示例 2:预准备语句</h2><p id="60dd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">接下来，我们将执行与示例 1 几乎相同的静态 SQL 语句。唯一的变化是增加了列名<code class="fe ng nh ni nj b">averageWeight</code>。这允许我们按列名解析结果，与示例 1 中使用列的数字索引相比，代码更容易理解。</p><p id="9fca" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">同样，我们不使用<code class="fe ng nh ni nj b">java.sql.Statement</code>类，而是使用<code class="fe ng nh ni nj b">java.sql.PreparedStatement</code>类。根据<a class="ae lw" href="https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html" rel="noopener ugc nofollow" target="_blank"> Oracle 的文档</a>，一条 SQL 语句被预编译并存储在一个<code class="fe ng nh ni nj b">PreparedStatement</code>对象中。然后，可以使用该对象多次有效地执行该语句。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="18ec" class="np kj it nj b gy nq nr l ns nt"><em class="oh">/**<br/> * PreparedStatement example, no parameters, returns Integer<br/> *<br/> * </em><strong class="nj iu"><em class="oh">@return </em></strong><em class="oh">Average weight of all products<br/> */<br/></em>public double getAverageProductWeightPS() {<br/>    double averageWeight = 0;<br/>    PreparedStatement pstmt = null;<br/>    ResultSet rs = null;</span><span id="4a6d" class="np kj it nj b gy oi nr l ns nt">try {<br/>        String sql = "WITH Weights_CTE(averageWeight) AS" +<br/>                "(" +<br/>                "    SELECT [Weight] AS [AverageWeight]" +<br/>                "    FROM [Production].[Product]" +<br/>                "    WHERE [Weight] &gt; 0" +<br/>                "        AND [WeightUnitMeasureCode] = 'LB'" +<br/>                "    UNION" +<br/>                "    SELECT [Weight] * 0.00220462262185 AS [AverageWeight]" +<br/>                "    FROM [Production].[Product]" +<br/>                "    WHERE [Weight] &gt; 0" +<br/>                "        AND [WeightUnitMeasureCode] = 'G')" +<br/>                "SELECT ROUND(AVG([AverageWeight]), 2) <strong class="nj iu">AS [averageWeight]</strong>" +<br/>                "FROM [Weights_CTE];";<br/>        pstmt = <em class="oh">connection</em>.getConnection().prepareStatement(sql);<br/>        rs = pstmt.executeQuery();<br/>        if (rs.next()) {<br/>            averageWeight = rs.getDouble("averageWeight");<br/>        }<br/>    } catch (Exception ex) {<br/>        Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                log(Level.<em class="oh">SEVERE</em>, null, ex);<br/>    } finally {<br/>        if (rs != null) {<br/>            try {<br/>                rs.close();<br/>            } catch (SQLException ex) {<br/>                Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                        log(Level.<em class="oh">WARNING</em>, null, ex);<br/>            }<br/>        }<br/>        if (pstmt != null) {<br/>            try {<br/>                pstmt.close();<br/>            } catch (SQLException ex) {<br/>                Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                        log(Level.<em class="oh">WARNING</em>, null, ex);<br/>            }<br/>        }<br/>    }<br/>    return averageWeight;<br/>}</span></pre><h2 id="1b58" class="np kj it bd kk nw nx dn ko ny nz dp ks lj oa ob ku ln oc od kw lr oe of ky og bi translated">示例 3:可调用语句</h2><p id="4e4f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在此示例中，平均产品重量查询已被移到存储过程中。该过程在功能上与前两个示例中的静态语句相同。为了调用存储过程，我们使用了<code class="fe ng nh ni nj b">java.sql.CallableStatement</code>类。根据<a class="ae lw" href="https://docs.oracle.com/javase/8/docs/api/java/sql/CallableStatement.html" rel="noopener ugc nofollow" target="_blank">甲骨文的文档</a>，<code class="fe ng nh ni nj b">CallableStatement</code>扩展了<code class="fe ng nh ni nj b">PreparedStatement</code>。它是用于执行 SQL 存储过程的接口。<code class="fe ng nh ni nj b">CallableStatement</code>接受输入和输出参数；然而，这个简单的例子既不使用。与前两个示例一样，该过程返回一个<code class="fe ng nh ni nj b">double</code>数值。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="6d02" class="np kj it nj b gy nq nr l ns nt">CREATE OR<br/>ALTER PROCEDURE [Production].[uspGetAverageProductWeight]<br/>AS<br/>BEGIN<br/>  SET NOCOUNT ON;</span><span id="f01d" class="np kj it nj b gy oi nr l ns nt">WITH<br/>    Weights_CTE(AverageWeight)<br/>    AS<br/>    (<br/>        SELECT [Weight] AS [AverageWeight]<br/>        FROM [Production].[Product]<br/>        WHERE [Weight] &gt; 0<br/>          AND [WeightUnitMeasureCode] = 'LB'<br/>      UNION<br/>        SELECT [Weight] * 0.00220462262185 AS [AverageWeight]<br/>        FROM [Production].[Product]<br/>        WHERE [Weight] &gt; 0<br/>          AND [WeightUnitMeasureCode] = 'G'<br/>    )<br/>  SELECT ROUND(AVG([AverageWeight]), 2)<br/>  FROM [Weights_CTE];<br/>END</span><span id="02f9" class="np kj it nj b gy oi nr l ns nt">GO</span></pre><p id="94ce" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">调用的 Java 方法如下所示。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="cdc5" class="np kj it nj b gy nq nr l ns nt"><em class="oh">/**<br/> * CallableStatement, no parameters, returns Integer<br/> *<br/> * </em><strong class="nj iu"><em class="oh">@return </em></strong><em class="oh">Average weight of all products<br/> */<br/></em>public double getAverageProductWeightCS() {<br/>    CallableStatement cstmt = null;<br/>    double averageWeight = 0;<br/>    ResultSet rs = null;<br/>    try {<br/>        cstmt = <em class="oh">connection</em>.getConnection().prepareCall(<br/>                "{call [Production].[uspGetAverageProductWeight]}");<br/>        cstmt.execute();<br/>        rs = cstmt.getResultSet();<br/>        if (rs.next()) {<br/>            averageWeight = rs.getDouble(1);<br/>        }<br/>    } catch (Exception ex) {<br/>        Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                log(Level.<em class="oh">SEVERE</em>, null, ex);<br/>    } finally {<br/>        if (rs != null) {<br/>            try {<br/>                rs.close();<br/>            } catch (SQLException ex) {<br/>                Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                        log(Level.<em class="oh">SEVERE</em>, null, ex);<br/>            }<br/>        }<br/>        if (cstmt != null) {<br/>            try {<br/>                cstmt.close();<br/>            } catch (SQLException ex) {<br/>                Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                        log(Level.<em class="oh">WARNING</em>, null, ex);<br/>            }<br/>        }<br/>    }<br/>    return averageWeight;<br/>}</span></pre><h2 id="219e" class="np kj it bd kk nw nx dn ko ny nz dp ks lj oa ob ku ln oc od kw lr oe of ky og bi translated">示例 4:使用输出参数调用存储过程</h2><p id="065c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本例中，我们使用了与例 3 几乎相同的存储过程。唯一的区别是包含了一个输出参数。这一次，不是在单个未命名的列中返回带有值的结果集，而是该列有一个名称<code class="fe ng nh ni nj b">averageWeight</code>。现在，我们可以在检索值时通过名称来调用该列。</p><p id="6282" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">示例 3 和示例 4 中的存储过程模式都是常用的。一个过程使用输出参数，一个不使用，两个过程返回相同的值。您可以使用<code class="fe ng nh ni nj b">CallableStatement</code>来选择任何一种类型。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="0643" class="np kj it nj b gy nq nr l ns nt">CREATE OR<br/>ALTER PROCEDURE [Production].[uspGetAverageProductWeightOUT]<em class="oh"><br/></em><strong class="nj iu"><em class="oh">  </em>@averageWeight DECIMAL(8, 2) OUT<br/></strong>AS<br/>BEGIN<br/>  SET NOCOUNT ON;</span><span id="11c1" class="np kj it nj b gy oi nr l ns nt">WITH<br/>    Weights_CTE(AverageWeight)<br/>    AS<br/>    (<br/>        SELECT [Weight] AS [AverageWeight]<br/>        FROM [Production].[Product]<br/>        WHERE [Weight] &gt; 0<br/>          AND [WeightUnitMeasureCode] = 'LB'<br/>      UNION<br/>        SELECT [Weight] * 0.00220462262185 AS [AverageWeight]<br/>        FROM [Production].[Product]<br/>        WHERE [Weight] &gt; 0<br/>          AND [WeightUnitMeasureCode] = 'G'<br/>    )<br/>  SELECT <strong class="nj iu">@averageWeight</strong> = ROUND(AVG([AverageWeight]), 2)<br/>  FROM [Weights_CTE];<br/>END</span><span id="4149" class="np kj it nj b gy oi nr l ns nt">GO</span></pre><p id="c1e4" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">调用的 Java 方法如下所示。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="2f4d" class="np kj it nj b gy nq nr l ns nt"><em class="oh">/**<br/> * CallableStatement example, (1) output parameter, returns Integer<br/> *<br/> * </em><strong class="nj iu"><em class="oh">@return </em></strong><em class="oh">Average weight of all products<br/> */<br/></em>public double getAverageProductWeightOutCS() {<br/>    CallableStatement cstmt = null;<br/>    double averageWeight = 0;</span><span id="7e3d" class="np kj it nj b gy oi nr l ns nt">try {<br/>        cstmt = <em class="oh">connection</em>.getConnection().prepareCall(<br/>                "{call [Production].[uspGetAverageProductWeightOUT](?)}");<br/><strong class="nj iu">        cstmt.registerOutParameter("averageWeight", Types.<em class="oh">DECIMAL</em>);<br/></strong>        cstmt.execute();<br/>        averageWeight = cstmt.getDouble("averageWeight");<br/>    } catch (Exception ex) {<br/>        Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                log(Level.<em class="oh">SEVERE</em>, null, ex);<br/>    } finally {<br/>        if (cstmt != null) {<br/>            try {<br/>                cstmt.close();<br/>            } catch (SQLException ex) {<br/>                Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                        log(Level.<em class="oh">WARNING</em>, null, ex);<br/>            }<br/>        }<br/>    }<br/>    return averageWeight;<br/>}</span></pre><h2 id="00d0" class="np kj it bd kk nw nx dn ko ny nz dp ks lj oa ob ku ln oc od kw lr oe of ky og bi translated">示例 5:使用输入参数调用存储过程</h2><p id="482a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本例中，该过程返回一个类型为<code class="fe ng nh ni nj b"><a class="ae lw" href="http://docs.oracle.com/javase/1.4.2/docs/api/java/sql/ResultSet.html" rel="noopener ugc nofollow" target="_blank">java.sql.ResultSet</a></code>的结果集，其雇员的姓氏以特定的字符序列开头(例如，“M”或“s a”)。使用<code class="fe ng nh ni nj b">CallableStatement</code>将字符序列作为输入参数<code class="fe ng nh ni nj b">lastNameStartsWith</code>传递给存储过程。</p><p id="2fb6" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">进行调用的方法遍历存储过程返回的结果集的行，将多个列连接起来，形成一个字符串形式的雇员全名。然后将每个全名字符串添加到一个有序的字符串集合中，即一个<code class="fe ng nh ni nj b">List&lt;String&gt;</code>对象。列表实例由方法返回。您会注意到，由于使用了<code class="fe ng nh ni nj b">LIKE</code>操作符，这个过程运行的时间会稍长一些。数据库服务器必须对表中的每个姓氏值执行模式匹配，以确定结果集。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="063a" class="np kj it nj b gy nq nr l ns nt">CREATE OR<br/>ALTER PROCEDURE [HumanResources].[uspGetEmployeesByLastName]<br/><strong class="nj iu"><em class="oh">  </em>@lastNameStartsWith VARCHAR(20) = 'A'<br/></strong>AS<br/>BEGIN<br/>  SET NOCOUNT ON;</span><span id="977b" class="np kj it nj b gy oi nr l ns nt">SELECT p.[FirstName], p.[MiddleName], p.[LastName], p.[Suffix], e.[JobTitle], m.[EmailAddress]<br/>  FROM [HumanResources].[Employee] AS e<br/>    LEFT JOIN [Person].[Person] p ON e.[BusinessEntityID] = p.[BusinessEntityID]<br/>    LEFT JOIN [Person].[EmailAddress] m ON e.[BusinessEntityID] = m.[BusinessEntityID]<br/>  WHERE e.[CurrentFlag] = 1<br/>    AND p.[PersonType] = 'EM'<br/><strong class="nj iu">    AND p.[LastName] LIKE @lastNameStartsWith + '%'<br/></strong>  ORDER BY p.[LastName], p.[FirstName], p.[MiddleName]<br/>END</span><span id="656d" class="np kj it nj b gy oi nr l ns nt">GO</span></pre><p id="c862" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">调用的 Java 方法如下所示。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="9136" class="np kj it nj b gy nq nr l ns nt"><em class="oh">/**<br/> * CallableStatement example, (1) input parameter, returns ResultSet<br/> *<br/> * </em><strong class="nj iu"><em class="oh">@param </em></strong><em class="oh">lastNameStartsWith<br/> * </em><strong class="nj iu"><em class="oh">@return </em></strong><em class="oh">List of employee names<br/> */<br/></em>public List&lt;String&gt; getEmployeesByLastNameCS(String lastNameStartsWith) {</span><span id="1bdf" class="np kj it nj b gy oi nr l ns nt">CallableStatement cstmt = null;<br/>    ResultSet rs = null;<br/>    List&lt;String&gt; employeeFullName = new ArrayList&lt;&gt;();</span><span id="31a2" class="np kj it nj b gy oi nr l ns nt">try {<br/>        cstmt = <em class="oh">connection</em>.getConnection().prepareCall(<br/>                "{call [HumanResources].[uspGetEmployeesByLastName](?)}",<br/>                ResultSet.<em class="oh">TYPE_SCROLL_INSENSITIVE</em>,<br/>                ResultSet.<em class="oh">CONCUR_READ_ONLY</em>);</span><span id="9945" class="np kj it nj b gy oi nr l ns nt"><strong class="nj iu">cstmt.setString("lastNameStartsWith", lastNameStartsWith);<br/></strong>        boolean results = cstmt.execute();<br/>        int rowsAffected = 0;</span><span id="5c44" class="np kj it nj b gy oi nr l ns nt">// Protects against lack of SET NOCOUNT in stored procedure<br/>        while (results || rowsAffected != -1) {<br/>            if (results) {<br/>                rs = cstmt.getResultSet();<br/>                break;<br/>            } else {<br/>                rowsAffected = cstmt.getUpdateCount();<br/>            }<br/>            results = cstmt.getMoreResults();<br/>        }<br/>        while (rs.next()) {<br/>            employeeFullName.add(<br/>                    rs.getString("LastName") + ", "<br/>                            + rs.getString("FirstName") + " "<br/>                            + rs.getString("MiddleName"));<br/>        }<br/>    } catch (Exception ex) {<br/>        Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                log(Level.<em class="oh">SEVERE</em>, null, ex);<br/>    } finally {<br/>        if (rs != null) {<br/>            try {<br/>                rs.close();<br/>            } catch (SQLException ex) {<br/>                Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                        log(Level.<em class="oh">WARNING</em>, null, ex);<br/>            }<br/>        }<br/>        if (cstmt != null) {<br/>            try {<br/>                cstmt.close();<br/>            } catch (SQLException ex) {<br/>                Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                        log(Level.<em class="oh">WARNING</em>, null, ex);<br/>            }<br/>        }<br/>    }<br/>    return employeeFullName;<br/>}</span></pre><h2 id="c252" class="np kj it bd kk nw nx dn ko ny nz dp ks lj oa ob ku ln oc od kw lr oe of ky og bi translated">示例 6:将结果集转换为有序的对象集合</h2><p id="0e6b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在最后一个例子中，我们将两个输入参数<code class="fe ng nh ni nj b">productColor</code>和<code class="fe ng nh ni nj b">productSize</code>传递给一个存储过程。存储过程返回包含几列产品信息的结果集。这一次，该示例的方法遍历该过程返回的结果集，并构造一个有序的产品集合，<code class="fe ng nh ni nj b">List&lt;Product&gt;</code>对象。列表中的产品对象是<code class="fe ng nh ni nj b">Product.java</code> <a class="ae lw" href="https://en.wikipedia.org/wiki/Plain_old_Java_object" rel="noopener ugc nofollow" target="_blank"> POJO </a>类的实例。该方法将每个结果集的行级字段值转换为一个<code class="fe ng nh ni nj b">Product</code>属性(例如<code class="fe ng nh ni nj b">Product.Size</code>、<code class="fe ng nh ni nj b">Product.Model</code>)。使用集合是在应用程序中保持结果集中的数据的常用方法。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="42c1" class="np kj it nj b gy nq nr l ns nt">CREATE OR<br/>ALTER PROCEDURE [Production].[uspGetProductsByColorAndSize]<br/><strong class="nj iu">  @productColor VARCHAR(20),<br/>  @productSize INTEGER<br/></strong>AS<br/>BEGIN<br/>  SET NOCOUNT ON;</span><span id="5e7a" class="np kj it nj b gy oi nr l ns nt">SELECT p.[ProductNumber], m.[Name] AS [Model], p.[Name] AS [Product], p.[Color], p.[Size]<br/>  FROM [Production].[ProductModel] AS m<br/>    INNER JOIN<br/>    [Production].[Product] AS p ON m.[ProductModelID] = p.[ProductModelID]<br/>  WHERE (p.[Color] = @productColor)<br/>    AND (p.[Size] = @productSize)<br/>  ORDER BY p.[ProductNumber], [Model], [Product]<br/>END</span><span id="3ae4" class="np kj it nj b gy oi nr l ns nt">GO</span></pre><p id="82fa" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">调用的 Java 方法如下所示。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="c278" class="np kj it nj b gy nq nr l ns nt"><em class="oh">/**<br/> * CallableStatement example, (2) input parameters, returns ResultSet<br/> *<br/> * </em><strong class="nj iu"><em class="oh">@param </em></strong><em class="oh">color<br/> * </em><strong class="nj iu"><em class="oh">@param </em></strong><em class="oh">size<br/> * </em><strong class="nj iu"><em class="oh">@return </em></strong><em class="oh">List of Product objects<br/> */<br/></em>public List&lt;Product&gt; getProductsByColorAndSizeCS(String color, String size) {</span><span id="759b" class="np kj it nj b gy oi nr l ns nt">CallableStatement cstmt = null;<br/>    ResultSet rs = null;<br/><strong class="nj iu">    List&lt;Product&gt; productList = new ArrayList&lt;&gt;();</strong></span><span id="1a49" class="np kj it nj b gy oi nr l ns nt">try {<br/>        cstmt = <em class="oh">connection</em>.getConnection().prepareCall(<br/>                "{call [Production].[uspGetProductsByColorAndSize](?, ?)}",<br/>                ResultSet.<em class="oh">TYPE_SCROLL_INSENSITIVE</em>,<br/>                ResultSet.<em class="oh">CONCUR_READ_ONLY</em>);</span><span id="46e5" class="np kj it nj b gy oi nr l ns nt"><strong class="nj iu">cstmt.setString("productColor", color);<br/>        cstmt.setString("productSize", size);<br/></strong>        boolean results = cstmt.execute();<br/>        int rowsAffected = 0;</span><span id="1051" class="np kj it nj b gy oi nr l ns nt">// Protects against lack of SET NOCOUNT in stored procedure<br/>        while (results || rowsAffected != -1) {<br/>            if (results) {<br/>                rs = cstmt.getResultSet();<br/>                break;<br/>            } else {<br/>                rowsAffected = cstmt.getUpdateCount();<br/>            }<br/>            results = cstmt.getMoreResults();<br/>        }</span><span id="1957" class="np kj it nj b gy oi nr l ns nt">while (rs.next()) {<br/>            Product product = new Product(<br/>                    rs.getString("Product"),<br/>                    rs.getString("ProductNumber"),<br/>                    rs.getString("Color"),<br/>                    rs.getString("Size"),<br/>                    rs.getString("Model"));<br/>            productList.add(product);<br/>        }<br/>    } catch (Exception ex) {<br/>        Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                log(Level.<em class="oh">SEVERE</em>, null, ex);<br/>    } finally {<br/>        if (rs != null) {<br/>            try {<br/>                rs.close();<br/>            } catch (SQLException ex) {<br/>                Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                        log(Level.<em class="oh">WARNING</em>, null, ex);<br/>            }<br/>        }<br/>        if (cstmt != null) {<br/>            try {<br/>                cstmt.close();<br/>            } catch (SQLException ex) {<br/>                Logger.<em class="oh">getLogger</em>(RunExamples.class.getName()).<br/>                        log(Level.<em class="oh">WARNING</em>, null, ex);<br/>            }<br/>        }<br/>    }<br/>    return productList;<br/>}</span></pre><h1 id="c3a2" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">正确的 T-SQL:模式参考和括号</h1><p id="b19c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您会注意到，在所有的 T-SQL 语句中，我引用了模式以及表或存储过程的名称(例如，<code class="fe ng nh ni nj b">{call [Production].[uspGetAverageProductWeightOUT](?)}</code>)。根据微软的说法，用一个模式名和对象名来引用数据库对象是一个很好的习惯，两者之间用句点隔开；这甚至包括默认模式(例如，<code class="fe ng nh ni nj b">dbo</code>)。</p><p id="6ea6" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">您还会注意到我将模式和对象名放在方括号中(例如，<code class="fe ng nh ni nj b">SELECT [ProductNumber] FROM [Production].[ProductModel]</code>)。方括号表示该名称代表一个对象，而不是一个<a class="ae lw" href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/reserved-keywords-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">保留字</a>(例如<code class="fe ng nh ni nj b">CURRENT</code>或<code class="fe ng nh ni nj b">NATIONAL</code>)。默认情况下，SQL Server 添加这些以确保它生成的脚本正确运行。</p><h1 id="ecf0" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">运行示例</h1><p id="3849" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">应用程序将显示被调用方法的名称、方法描述、检索数据所用的时间以及该方法返回的任何结果。</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="33d0" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">下面，我们来看看结果。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nv"><img src="../Images/dc21f638fe4284d7e60ccba4f22a9f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jhsQwzx16D-HgIqTG-vyLA.png"/></div></div></figure><h1 id="ecb6" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">SQL 语句性能</h1><p id="11ec" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这篇文章当然不是关于 SQL 性能的，事实证明了这一点，我只是在一个单一的，非常不充分的<a class="ae lw" href="https://aws.amazon.com/rds/instance-types/" rel="noopener ugc nofollow" target="_blank"> db.t2.micro </a> Amazon RDS 实例类型上使用<a class="ae lw" href="https://aws.amazon.com/rds/sqlserver/" rel="noopener ugc nofollow" target="_blank">Amazon RDS for SQL Server 2017 Express Edition</a>。但是，我添加了一个定时器特性，<code class="fe ng nh ni nj b">ProcessTimer.java</code>类，来捕获每个示例返回数据所花费的时间，以毫秒为单位。<code class="fe ng nh ni nj b">ProcessTimer.java</code>类是项目代码的一部分。使用计时器，您应该可以观察到应用程序的第一次运行和后续运行之间对于几个被调用方法的显著差异。时间差是由几个因素造成的，主要是 SQL 语句的预编译和 SQL Server <a class="ae lw" href="https://www.sqlshack.com/understanding-sql-server-query-plan-cache/" rel="noopener ugc nofollow" target="_blank">计划缓存</a>。</p><p id="2c87" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">通过使用<a class="ae lw" href="https://docs.microsoft.com/en-us/sql/t-sql/database-console-commands/dbcc-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> DBCC </a>(数据库控制台命令)语句<a class="ae lw" href="http://msdn.microsoft.com/en-us/library/ms174283.aspx" rel="noopener ugc nofollow" target="_blank">清除 SQL Server 计划缓存</a> ( <em class="oh">参见下面的 SQL 脚本</em>)可以轻松演示这两个因素的影响。然后连续运行应用程序两次。第二次，预编译和计划缓存将显著加快预处理语句和可调用语句的运行速度，如示例 2–6 所示。在下面显示的两次随机运行中，我们看到查询时间提高了 5 倍。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="38a6" class="np kj it nj b gy nq nr l ns nt">USE AdventureWorks;</span><span id="7612" class="np kj it nj b gy oi nr l ns nt">DBCC FREESYSTEMCACHE('SQL Plans');<br/>GO</span><span id="daed" class="np kj it nj b gy oi nr l ns nt">CHECKPOINT;<br/>GO</span><span id="ec90" class="np kj it nj b gy oi nr l ns nt">-- Impossible to run with Amazon RDS for Microsoft SQL Server on AWS<br/>-- DBCC DROPCLEANBUFFERS;<br/>-- GO</span></pre><p id="c0c3" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">第一次运行结果如下所示。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="14b9" class="np kj it nj b gy nq nr l ns nt">SQL SERVER STATEMENT EXAMPLES<br/>======================================<br/>Method: GetAverageProductWeightST<br/>Description: Statement, no parameters, returns Integer<br/><strong class="nj iu">Duration (ms): 122<br/></strong>Results: Average product weight (lb): 12.43<br/>---<br/>Method: GetAverageProductWeightPS<br/>Description: PreparedStatement, no parameters, returns Integer<br/><strong class="nj iu">Duration (ms): 146<br/></strong>Results: Average product weight (lb): 12.43<br/>---<br/>Method: GetAverageProductWeightCS<br/>Description: CallableStatement, no parameters, returns Integer<br/><strong class="nj iu">Duration (ms): 72<br/></strong>Results: Average product weight (lb): 12.43<br/>---<br/>Method: GetAverageProductWeightOutCS<br/>Description: CallableStatement, (1) output parameter, returns Integer<br/><strong class="nj iu">Duration (ms): 623<br/></strong>Results: Average product weight (lb): 12.43<br/>---<br/>Method: GetEmployeesByLastNameCS<br/>Description: CallableStatement, (1) input parameter, returns ResultSet<br/><strong class="nj iu">Duration (ms): 830<br/></strong>Results: Last names starting with 'Sa': 7<br/>         Last employee found: Sandberg, Mikael Q<br/>---<br/>Method: GetProductsByColorAndSizeCS<br/>Description: CallableStatement, (2) input parameter, returns ResultSet<br/><strong class="nj iu">Duration (ms): 427<br/></strong>Results: Products found (color: 'Red', size: '44'): 7<br/>         First product: Road-650 Red, 44 (BK-R50R-44)<br/>---</span></pre><p id="2bc0" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">第二次运行结果如下所示。</p><pre class="ly lz ma mb gt nl nj nm nn aw no bi"><span id="8425" class="np kj it nj b gy nq nr l ns nt">SQL SERVER STATEMENT EXAMPLES<br/>======================================<br/>Method: GetAverageProductWeightST<br/>Description: Statement, no parameters, returns Integer<br/><strong class="nj iu">Duration (ms): 116<br/></strong>Results: Average product weight (lb): 12.43<br/>---<br/>Method: GetAverageProductWeightPS<br/>Description: PreparedStatement, no parameters, returns Integer<br/><strong class="nj iu">Duration (ms): 89<br/></strong>Results: Average product weight (lb): 12.43<br/>---<br/>Method: GetAverageProductWeightCS<br/>Description: CallableStatement, no parameters, returns Integer<br/><strong class="nj iu">Duration (ms): 80<br/></strong>Results: Average product weight (lb): 12.43<br/>---<br/>Method: GetAverageProductWeightOutCS<br/>Description: CallableStatement, (1) output parameter, returns Integer<br/><strong class="nj iu">Duration (ms): 340<br/></strong>Results: Average product weight (lb): 12.43<br/>---<br/>Method: GetEmployeesByLastNameCS<br/>Description: CallableStatement, (1) input parameter, returns ResultSet<br/><strong class="nj iu">Duration (ms): 139<br/></strong>Results: Last names starting with 'Sa': 7<br/>         Last employee found: Sandberg, Mikael Q<br/>---<br/>Method: GetProductsByColorAndSizeCS<br/>Description: CallableStatement, (2) input parameter, returns ResultSet<br/><strong class="nj iu">Duration (ms): 208<br/></strong>Results: Products found (color: 'Red', size: '44'): 7<br/>         First product: Road-650 Red, 44 (BK-R50R-44)<br/>---</span></pre><h1 id="fe87" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论</h1><p id="f548" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">本文展示了使用 JDBC 和微软 JDBC 驱动程序 8.4 for SQL Server 从 SQL Server 2017 数据库查询和调用存储过程的几种方法。尽管这些示例非常简单，但是同样的模式也可以用于更复杂的存储过程，具有多个输入和输出参数，不仅可以选择数据，还可以插入、更新和删除数据。</p><p id="7081" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">您应该通过阅读<a class="ae lw" href="https://docs.microsoft.com/en-us/sql/connect/jdbc/programming-guide-for-jdbc-sql-driver?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">文档</a>来了解用于 SQL Server 的微软 JDBC 驱动程序的一些限制。但是，对于大多数需要数据库交互的任务，该驱动程序为 SQL Server 提供了足够的功能。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="d206" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">本博客代表我自己的观点，不代表我的雇主亚马逊网络服务公司的观点。</p></div></div>    
</body>
</html>