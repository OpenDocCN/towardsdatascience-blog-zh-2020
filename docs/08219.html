<html>
<head>
<title>Part 3: Time Series Chains</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第 3 部分:时间序列链</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/part-3-time-series-chains-da281450abbf?source=collection_archive---------31-----------------------#2020-06-16">https://towardsdatascience.com/part-3-time-series-chains-da281450abbf?source=collection_archive---------31-----------------------#2020-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="18bf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用 STUMPY 进行时间序列预测的新方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/12e9be33b77c6528b951291b63d207bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZu2mtX-0JoGkTBVxLC9Gw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="https://unsplash.com/@mxhpics?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马克西姆·霍拉维尔</a>提供)</p></figure><h1 id="7861" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">整体大于部分之和</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/b9dc45622efb5d6ddbb94d3e2f91b304.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*NWV2vLKBciK49BAVfzvN4Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="12b2" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated"><a class="ae ky" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank"> STUMPY 是一个强大且可扩展的 Python 库，用于现代时间序列分析</a>，在其核心，有效地计算出一种叫做<em class="mo">矩阵轮廓</em>的东西。这个多部分系列的目标是解释什么是 matrix profile，以及如何开始利用<a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>完成所有现代时间序列数据挖掘任务！</p><p id="cea3" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated"><em class="mo">注:这些教程最初出现在</em> <a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/tutorials.html" rel="noopener ugc nofollow" target="_blank"> <em class="mo"> STUMPY 文档</em> </a> <em class="mo">中。</em></p><p id="0bde" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">第 1 部分:<a class="ae ky" rel="noopener" target="_blank" href="/the-matrix-profile-e4a679269692">矩阵轮廓图</a> <br/>第 2 部分:<a class="ae ky" rel="noopener" target="_blank" href="/stumpy-basics-21844a2d2d92"> STUMPY 基础知识</a> <br/>第 3 部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-3-time-series-chains-da281450abbf">时间序列链</a> <br/>第 4 部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-4-semantic-segmentation-b42c3792833d">语义分割</a> <br/>第 5 部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-5-fast-approximate-matrix-profiles-with-scrump-c6d9c984c560">用 STUMPY 快速近似矩阵轮廓图</a> <br/>第 6 部分:<a class="ae ky" rel="noopener" target="_blank" href="/matrix-profiles-for-streaming-time-series-data-f877ff6f9eef">用于流式时间序列数据的矩阵轮廓图</a> <br/>第 7 部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-7-fast-pattern-searching-with-stumpy-2baf610a8de1">用 STUMPY 快速模式搜索</a> 10: <a class="ae ky" rel="noopener" target="_blank" href="/part-10-discovering-multidimensional-time-series-motifs-45da53b594bb">发现多维时间序列模体</a> <br/>第 11 部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-11-user-guided-motif-search-d3d317caf9ea">用户引导的模体搜索</a> <br/>第 12 部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-12-matrix-profiles-for-machine-learning-2dfd98d7ff3f">机器学习的矩阵轮廓</a></p><h1 id="6361" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用锚定时间序列链预测 Web 查询数据(ATSC)</h1><p id="254e" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">之前，我们学习了什么是<a class="ae ky" href="https://medium.com/@seanmylaw/the-matrix-profile-e4a679269692" rel="noopener">矩阵轮廓</a>，以及如何使用<a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>来<a class="ae ky" href="https://medium.com/@seanmylaw/stumpy-basics-21844a2d2d92" rel="noopener">发现任何时间序列数据中的主题(模式)和不一致(异常)</a>。在这篇博客中，我们将把这些概念更进一步，探索从一个叫做<em class="mo">时间序列链</em>的矩阵剖面中衍生出来的东西。此示例改编自<a class="ae ky" href="http://www.www2015.it/documents/proceedings/proceedings/p721.pdf" rel="noopener ugc nofollow" target="_blank">网络查询量案例研究</a>，并利用了<a class="ae ky" href="https://www.cs.ucr.edu/~eamonn/chains_ICDM.pdf" rel="noopener ugc nofollow" target="_blank">矩阵概况 VII </a>研究论文的主要内容。</p><h1 id="2703" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">入门指南</h1><p id="2b0a" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">让我们导入加载、分析和绘制数据所需的包。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f6d2" class="mz la it mv b gy na nb l nc nd">%matplotlib inline<br/><br/>import pandas as pd<br/>import numpy as np<br/>import stumpy<br/>from scipy.io import loadmat<br/>import matplotlib.pyplot as plt<br/>from matplotlib.patches import Rectangle, FancyArrowPatch<br/>import itertools<br/><br/>plt.rcParams["figure.figsize"] = [20, 6]  # width, height<br/>plt.rcParams['xtick.direction'] = 'out'</span></pre><h1 id="14b7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是时间序列链？</h1><p id="0dd5" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated"><em class="mo">时间序列链</em>可以非正式地认为是随着时间的推移向某个方向演变或漂移的主题。下图说明了<a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/Tutorial_1.ipynb" rel="noopener ugc nofollow" target="_blank">时序主题</a>(左)和时序链(右)之间的区别。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ccb4" class="mz la it mv b gy na nb l nc nd">x = np.random.rand(20)<br/>y = np.random.rand(20)<br/>n = 10<br/>motifs_x = 0.5 * np.ones(n) + np.random.uniform(-0.05, 0.05, n)<br/>motifs_y = 0.5 * np.ones(n) + np.random.uniform(-0.05, 0.05, n)<br/>sin_x = np.linspace(0, np.pi/2, n+1)<br/>sin_y = np.sin(sin_x)/4<br/>chains_x = 0.5 * np.ones(n+1) + 0.02 * np.arange(n+1)<br/>chains_y = 0.5 * np.ones(n+1) + sin_y<br/>fig, axes = plt.subplots(nrows=1, ncols=2)<br/>axes[0].scatter(x, y, color='lightgrey')<br/>axes[0].scatter(motifs_x, motifs_y, color='red')<br/>axes[1].scatter(x, y, color='lightgrey')<br/>axes[1].scatter(chains_x[0], chains_y[0], edgecolor='red', color='white')<br/>axes[1].scatter(chains_x[1:n], chains_y[1:n], color='red')<br/>axes[1].scatter(chains_x[n], chains_y[n], edgecolor='red', color='white', marker='*', s=200)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/98c5a1526305e7b0df576c51d4988f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jlnj49yDZCFD7Yx7.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="bc9a" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">上面，我们将时间序列子序列可视化为高维空间中的点。左边显示的是一个时间序列主题，它可以被认为是一个近似柏拉图式理想的点的集合。相比之下，右边描绘的是一个时间序列链，它可以被认为是空间中的点的演化轨迹。在这里，开放的红色圆圈代表链中的第一个环节，锚。基序和链都具有这样的性质，即每个子序列都相对靠近其最近的邻居。然而，图案组(左)的直径也相对较小。相比之下，链中的点集(右)的直径比每个成员到其最近邻居的距离的平均值大得多，此外，链具有方向性的重要特性。例如，在一个基序的情况下，如果一个额外的成员被添加到基序集中，它的位置也将是接近柏拉图理想的某个地方，但是独立于前面的子序列。相比之下，在链的情况下，链的下一个成员的位置将在最后一个红色圆圈之后的某个地方，可能是开放的红星所在的位置。</p><h1 id="b18a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">一个简化的例子</h1><p id="96a7" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">改编自<a class="ae ky" href="https://www.cs.ucr.edu/~eamonn/chains_ICDM.pdf" rel="noopener ugc nofollow" target="_blank">矩阵图 VII </a>文件，考虑以下时间序列:</p><p id="04b7" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi">47, 32, 1, 22, 2, 58, 3, 36, 4, -5, 5, 40</p><p id="5e13" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">假设子序列长度为 1，两个子序列之间的距离就是它们之间的绝对差。明确地说，我们在这里做这些简单而病态的假设仅仅是为了说明；实际上，我们的目标是更长的子序列长度，并在我们的<a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>应用中使用 z 归一化欧几里德距离。为了捕捉时间序列链的方向性，我们需要将左右最近邻信息存储到左(IL)和右(IR)矩阵轮廓索引中:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="67a8" class="mz la it mv b gy na nb l nc nd">Index  Value  Left Index (IL)  Right Index (IR)<br/>1         47              N/A                12<br/>2         32                1                 8<br/>3          1                2                 5<br/>4         22                2                 8<br/>5          2                3                 7<br/>6         58                1                12<br/>7          3                5                 9<br/>8         36                2                12<br/>9          4                7                11<br/>10        –5                3                11<br/>11         5                9                12<br/>12        40                8               N/A</span></pre><p id="52df" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">在这个垂直/转置表示中，<code class="fe nf ng nh mv b">index</code>列显示了时间序列中每个子序列的位置，<code class="fe nf ng nh mv b">value</code>列包含来自我们上面的时间序列的原始数字，<code class="fe nf ng nh mv b">IL</code>列显示了左矩阵分布指数，<code class="fe nf ng nh mv b">IR</code>是右矩阵分布指数。例如，<code class="fe nf ng nh mv b">IR[2] = 8</code>表示<code class="fe nf ng nh mv b">index = 2</code>(有<code class="fe nf ng nh mv b">value = 32</code>)的右最近邻在<code class="fe nf ng nh mv b">index = 8</code>(有<code class="fe nf ng nh mv b">value = 36</code>)。同样，<code class="fe nf ng nh mv b">IL[3] = 2</code>表示<code class="fe nf ng nh mv b">index = 3</code>(有<code class="fe nf ng nh mv b">value = 1</code>)的左最近邻在<code class="fe nf ng nh mv b">index = 2</code>(有<code class="fe nf ng nh mv b">value = 32</code>)。为了更好地可视化左/右矩阵轮廓索引，我们使用箭头将时间序列中的每个子序列与其左、右最近邻链接起来:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="2332" class="mz la it mv b gy na nb l nc nd">nearest_neighbors = np.array([[1,  47, np.nan,     12],<br/>                              [2,  32,      1,      8],<br/>                              [3,   1,      2,      5],<br/>                              [4,  22,      2,      8],<br/>                              [5,   2,      3,      7],<br/>                              [6,  58,      1,     12],<br/>                              [7,   3,      5,      9],<br/>                              [8,  36,      2,     12],<br/>                              [9,   4,      7,     11],<br/>                              [10, -5,      3,     11],<br/>                              [11,  5,      9,     12],<br/>                              [12, 40,      8, np.nan]])</span><span id="c9ed" class="mz la it mv b gy ni nb l nc nd">colors = [['C1', 'C1'],<br/>          ['C2', 'C5'],<br/>          ['C3', 'C5'],<br/>          ['C4', 'C4'],<br/>          ['C3', 'C2'],<br/>          ['C5', 'C3'],<br/>          ['C3', 'C2'],<br/>          ['C2', 'C1'],<br/>          ['C3', 'C2'],<br/>          ['C6', 'C1'],<br/>          ['C6', 'C2'],<br/>          ['C1', 'C1']]</span><span id="14c3" class="mz la it mv b gy ni nb l nc nd">style="Simple, tail_width=0.5, head_width=6, head_length=8"<br/>kw = dict(arrowstyle=style, connectionstyle="arc3, rad=-.5",)</span><span id="78ac" class="mz la it mv b gy ni nb l nc nd">xs = np.arange(nearest_neighbors.shape[0]) + 1<br/>ys = np.zeros(nearest_neighbors.shape[0])<br/>plt.plot(xs, ys, "-o", markerfacecolor="None", markeredgecolor="None", linestyle="None")</span><span id="f842" class="mz la it mv b gy ni nb l nc nd">x0, x1, y0, y1 = plt.axis()<br/>plot_margin = 5.0<br/>plt.axis((x0 - plot_margin,<br/>          x1 + plot_margin,<br/>          y0 - plot_margin,<br/>          y1 + plot_margin))<br/>plt.axis('off')</span><span id="251f" class="mz la it mv b gy ni nb l nc nd">for x, y, nearest_neighbor, color in zip(xs, ys, nearest_neighbors, colors):<br/>    plt.text(x, y, str(int(nearest_neighbor[1])), color="black", fontsize=20)</span><span id="6424" class="mz la it mv b gy ni nb l nc nd">    # Plot right matrix profile indices<br/>    if not np.isnan(nearest_neighbor[3]):<br/>        arrow = FancyArrowPatch((x, 0.5), (nearest_neighbor[3], 0.5), color=color[0], **kw)<br/>        plt.gca().add_patch(arrow)</span><span id="c7f4" class="mz la it mv b gy ni nb l nc nd">    # Plot left matrix profile indices<br/>    if not np.isnan(nearest_neighbor[2]):<br/>        arrow = FancyArrowPatch((x, 0.0), (nearest_neighbor[2], 0.0), color=color[1], **kw)<br/>        plt.gca().add_patch(arrow)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/799012d63066a5e1a29c5ad6bdbb9460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lVylyNZctLttHYCt.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="26f5" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">从一个数字指向其右最近邻的箭头(显示在时间序列上方的箭头)可以称为向前箭头，从一个数字指向其左最近邻的箭头(显示在时间序列下方的箭头)可以称为向后箭头。根据时间序列链的正式定义(参见<a class="ae ky" href="https://www.cs.ucr.edu/~eamonn/chains_ICDM.pdf" rel="noopener ugc nofollow" target="_blank">矩阵剖面 VII </a>的详细定义和讨论)，链中的每对连续子序列必须由向前箭头和向后箭头连接。敏锐的眼睛会发现，在我们的简化示例中，最长的链是:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="c017" class="mz la it mv b gy na nb l nc nd">nearest_neighbors = np.array([[1,  47, np.nan, np.nan],<br/>                              [2,  32, np.nan, np.nan],<br/>                              [3,   1, np.nan,      5],<br/>                              [4,  22, np.nan, np.nan],<br/>                              [5,   2,      3,      7],<br/>                              [6,  58, np.nan, np.nan],<br/>                              [7,   3,      5,      9],<br/>                              [8,  36, np.nan, np.nan],<br/>                              [9,   4,      7,     11],<br/>                              [10, -5, np.nan, np.nan],<br/>                              [11,  5,      9, np.nan],<br/>                              [12, 40, np.nan, np.nan]])</span><span id="2839" class="mz la it mv b gy ni nb l nc nd">colors = [['C1', 'C1'],<br/>          ['C2', 'C5'],<br/>          ['C3', 'C5'],<br/>          ['C4', 'C4'],<br/>          ['C3', 'C2'],<br/>          ['C5', 'C3'],<br/>          ['C3', 'C2'],<br/>          ['C2', 'C1'],<br/>          ['C3', 'C2'],<br/>          ['C6', 'C1'],<br/>          ['C6', 'C2'],<br/>          ['C1', 'C1']]</span><span id="ffab" class="mz la it mv b gy ni nb l nc nd">style="Simple, tail_width=0.5, head_width=6, head_length=8"<br/>kw = dict(arrowstyle=style, connectionstyle="arc3, rad=-.5",)</span><span id="2d6a" class="mz la it mv b gy ni nb l nc nd">xs = np.arange(nearest_neighbors.shape[0]) + 1<br/>ys = np.zeros(nearest_neighbors.shape[0])<br/>plt.plot(xs, ys, "-o", markerfacecolor="None", markeredgecolor="None", linestyle="None")</span><span id="2a0b" class="mz la it mv b gy ni nb l nc nd">x0, x1, y0, y1 = plt.axis()<br/>plot_margin = 5.0<br/>plt.axis((x0 - plot_margin,<br/>          x1 + plot_margin,<br/>          y0 - plot_margin,<br/>          y1 + plot_margin))<br/>plt.axis('off')</span><span id="fa93" class="mz la it mv b gy ni nb l nc nd">for x, y, nearest_neighbor, color in zip(xs, ys, nearest_neighbors, colors):<br/>    plt.text(x, y, str(int(nearest_neighbor[1])), color="black", fontsize=20)</span><span id="7252" class="mz la it mv b gy ni nb l nc nd">    # Plot right matrix profile indices<br/>    if not np.isnan(nearest_neighbor[3]):<br/>        arrow = FancyArrowPatch((x, 0.5), (nearest_neighbor[3], 0.5), color=color[0], **kw)<br/>        plt.gca().add_patch(arrow)</span><span id="cba1" class="mz la it mv b gy ni nb l nc nd">    # Plot left matrix profile indices<br/>    if not np.isnan(nearest_neighbor[2]):<br/>        arrow = FancyArrowPatch((x, 0.0), (nearest_neighbor[2], 0.0), color=color[1], **kw)<br/>        plt.gca().add_patch(arrow)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/b07e3406aa38ff727913954452ac857f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g3CK46WuZApAILvd.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="b499" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">因此，最长的提取链是 1 ⇌ 2 ⇌ 3 ⇌ 4 ⇌ 5。请注意，我们看到数据逐渐单调增加，但实际上，漂移的增加或减少可能以任意复杂的方式发生，可以通过时间序列链方法检测到。漂移的关键组成部分是时间序列必须包含具有明确方向性的链。</p><p id="9ef1" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">STUMPY 能够计算:</p><ol class=""><li id="ed68" class="nk nl it lu b lv lw ly lz mb nm mf nn mj no mn np nq nr ns bi translated">锚定的时间序列链(ATSC)-从用户指定的锚(即特定的子序列)开始增长链</li><li id="4f18" class="nk nl it lu b lv nt ly nu mb nv mf nw mj nx mn np nq nr ns bi translated">全链集(ALLC)——一组锚定的时间序列链(即每个链以特定的子序列开始)，它们不被另一个更长的链所包含</li><li id="35f6" class="nk nl it lu b lv nt ly nu mb nv mf nw mj nx mn np nq nr ns bi translated">未锚定的时间序列链—时间序列中无条件最长的链(如果存在长度相同的链，则可能有多个链)</li></ol><p id="cc4e" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">那么，这在真实时间序列中意味着什么呢？让我们来看一个来自 web 查询数据的真实例子！</p><h1 id="fd9a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">检索数据</h1><p id="0aef" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">我们将看到一个欠采样且有增长趋势的噪声数据集，这将完美地说明关于时间序列链的想法。该数据包含十年之久的 GoogleTrend 对关键字美国柯尔百货公司(美国零售连锁店)的查询量(从 2004 年到 2014 年每周收集一次)。首先，我们将下载数据，提取数据，并将其插入到 Pandas 数据帧中。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d45d" class="mz la it mv b gy na nb l nc nd">df = pd.read_csv("https://zenodo.org/record/4276348/files/Time_Series_Chains_Kohls_data.csv?download=1")<br/>df.head()</span><span id="776f" class="mz la it mv b gy ni nb l nc nd">     volume<br/>0  0.010417<br/>1  0.010417<br/>2  0.010417<br/>3  0.000000<br/>4  0.000000</span></pre><h1 id="c37f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">可视化数据</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="626a" class="mz la it mv b gy na nb l nc nd">plt.plot(df['volume'], color='black')<br/>plt.xlim(0, df.shape[0]+12)<br/>color = itertools.cycle(['white', 'gainsboro'])<br/>for i, x in enumerate(range(0, df.shape[0], 52)):<br/>    plt.text(x+12, 0.9, str(2004+i), color="black", fontsize=20)<br/>    rect = Rectangle((x, -1), 52, 2.5, facecolor=next(color))<br/>    plt.gca().add_patch(rect)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/22b19207e766a80b97a3319f48dc749a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6lMmBsM1a5yuqU5J.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="e492" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">上面的原始时间序列显示了关键字“美国柯尔百货公司”十年的网络查询量，其中每个交替的白色和灰色垂直带代表从 2004 年到 2014 年的 52 周期间。如图所示，该时间序列有一个显著但不令人惊讶的“年末假日高峰”。回到时间序列链，我们可以看到，随着时间的推移，凸起通常会增加，因此我们可能能够在计算非锚定链时捕捉到这一点。</p><p id="9d7f" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">然而，正如我们在上面学到的，为了计算任何时间序列链，我们还需要左和右矩阵轮廓指数。幸运的是，根据<a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> STUMPY 文档</a>,<code class="fe nf ng nh mv b">stumpy.stump()</code>函数不仅分别返回 NumPy 数组第一和第二列中的(双向)矩阵轮廓和矩阵轮廓索引，而且第三和第四列分别由左矩阵轮廓索引和右矩阵轮廓索引组成。</p><h1 id="986c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">计算左和右矩阵轮廓指数</h1><p id="4100" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">因此，让我们继续计算矩阵轮廓指数，我们将设置窗口大小<code class="fe nf ng nh mv b">m = 20</code>，这是一个“凸起”的大致长度。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="3e32" class="mz la it mv b gy na nb l nc nd">m = 20<br/>mp = stumpy.stump(df['volume'], m=m)</span></pre><h1 id="aca5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">计算非锚定链</h1><p id="b9f7" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">现在，有了左右矩阵轮廓索引，我们准备调用全链集 STUMPY 函数，<code class="fe nf ng nh mv b">stumpy.allc()</code>，它不仅返回全链集，而且作为副产品，它还返回无条件最长链，也称为<em class="mo">非锚定链</em>。后者才是我们真正感兴趣的。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="09f1" class="mz la it mv b gy na nb l nc nd">all_chain_set, unanchored_chain = stumpy.allc(mp[:, 2], mp[:, 3])</span></pre><h1 id="a0d6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">可视化未锚定的链</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="806c" class="mz la it mv b gy na nb l nc nd">plt.plot(df['volume'], linewidth=1, color='black')<br/>for i in range(unanchored_chain.shape[0]):<br/>    y = df['volume'].iloc[unanchored_chain[i]:unanchored_chain[i]+m]<br/>    x = y.index.values<br/>    plt.plot(x, y, linewidth=3)<br/>color = itertools.cycle(['white', 'gainsboro'])<br/>for i, x in enumerate(range(0, df.shape[0], 52)):<br/>    plt.text(x+12, 0.9, str(2004+i), color="black", fontsize=20)<br/>    rect = Rectangle((x, -1), 52, 2.5, facecolor=next(color))<br/>    plt.gca().add_patch(rect)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/cee5c1f39184e2ed5b2536465aea352a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kwhX6YC75Kvtpk6R.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="2e5c" class="mz la it mv b gy na nb l nc nd">plt.axis('off')<br/>for i in range(unanchored_chain.shape[0]):<br/>    data = df['volume'].iloc[unanchored_chain[i]:unanchored_chain[i]+m].reset_index().values<br/>    x = data[:, 0]<br/>    y = data[:, 1]<br/>    plt.axvline(x=x[0]-x.min()+(m+5)*i + 11, alpha=0.3)<br/>    plt.axvline(x=x[0]-x.min()+(m+5)*i + 15, alpha=0.3, linestyle='-.')<br/>    plt.plot(x-x.min()+(m+5)*i, y-y.min(), linewidth=3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/8c7c0609eb5261f247b0ef1710c31ea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9PRCnGJRq6v-CU6v.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="2d12" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">发现的链显示，在十年中，凸起从覆盖感恩节(实线垂直线)和圣诞节(虚线垂直线)之间的平稳凸起过渡到以感恩节为中心的更尖锐的凸起。这似乎反映了“网络星期一”日益增长的重要性，这是感恩节后星期一的营销术语。这个短语是营销公司为了说服消费者网上购物而创造的。这个词在 2005 年 11 月 28 日的一篇题为“网络星期一迅速成为今年最大的网上购物日之一”的新闻稿中首次亮相。请注意，这个日期与我们链中第一次看到锐化峰值的时间一致。</p><p id="bd47" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我们似乎还“遗漏”了链条中的几个环节。然而，请注意，数据是有噪声的和欠采样的，并且“错过的”颠簸失真太大，不符合一般的发展趋势。这个嘈杂的例子实际上说明了时间序列链技术的鲁棒性。如前所述，我们实际上并不需要“完美”的数据来寻找有意义的链。即使一些链接被严重扭曲，被发现的链仍然能够包括所有其他进化的模式。</p><p id="f994" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">最后一个要考虑的是链在预测或预报未来方面的潜在用途。人们可以利用链条中不断发展的链接来预测下一次碰撞的形状。我们建议读者参考<a class="ae ky" href="https://www.cs.ucr.edu/~eamonn/chains_ICDM.pdf" rel="noopener ugc nofollow" target="_blank">矩阵简介 VII </a>以了解关于该主题的进一步讨论。</p><h1 id="338e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="141c" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">就是这样！您刚刚学习了如何使用矩阵剖面指数和利用<code class="fe nf ng nh mv b">stumpy.allc()</code>函数在数据中识别方向趋势(也称为链)的基础知识。</p><h1 id="17b6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">资源</h1><p id="eccf" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated"><a class="ae ky" href="https://www.cs.ucr.edu/~eamonn/chains_ICDM.pdf" rel="noopener ugc nofollow" target="_blank">Matrix Profile VII</a><br/><a class="ae ky" href="https://sites.google.com/site/timeserieschain/" rel="noopener ugc nofollow" target="_blank">Matrix Profile VII 补充资料</a><br/><a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">STUMPY Matrix Profile 文档</a><br/><a class="ae ky" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank">STUMPY Matrix Profile Github 代码库</a></p><h2 id="121f" class="mz la it bd lb nz oa dn lf ob oc dp lj mb od oe ll mf of og ln mj oh oi lp oj bi translated">← <a class="ae ky" rel="noopener" target="_blank" href="/stumpy-basics-21844a2d2d92">第二部分:STUMPY 基础知识</a> | <a class="ae ky" rel="noopener" target="_blank" href="/part-4-semantic-segmentation-b42c3792833d">第四部分:语义切分</a> →</h2></div></div>    
</body>
</html>