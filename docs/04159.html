<html>
<head>
<title>How to Create a Custom Loss Function | Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建自定义损失函数| Keras</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-create-a-custom-loss-function-keras-3a89156ec69b?source=collection_archive---------2-----------------------#2020-04-16">https://towardsdatascience.com/how-to-create-a-custom-loss-function-keras-3a89156ec69b?source=collection_archive---------2-----------------------#2020-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2c58" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对于神经网络</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bc93d959eeeef8b09ea95559448622a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wFbZoz86t2c2nA47f-XZhg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@isaacmsmith?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">艾萨克·史密斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/graph?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="ec30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">损失</strong>功能<strong class="lb iu">是神经网络的重要组成部分之一。<strong class="lb iu">损失</strong>无非是神经网络的一个预测误差。计算损失的方法称为损失函数。</strong></p><p id="cd34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">损耗用于计算神经网络的梯度。并且梯度被用于更新权重。这就是神经网络的训练方式。</p><p id="dde0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Keras 有许多内置的损失函数，我在之前的一篇<a class="ae ky" rel="noopener" target="_blank" href="/understanding-different-loss-functions-for-neural-networks-dd1ed0274718"> <strong class="lb iu">博客</strong> </a>中提到过。这些损失函数对于分类和回归等许多典型的机器学习任务来说已经足够了。</p><p id="e07f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是可能有一些任务我们需要实现一个自定义的损失函数，我将在这篇博客中介绍。</p><p id="267f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始之前，让我们快速回顾一下如何在 Keras 中使用内置损失函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6029" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用内置损失函数</h1><p id="d505" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面是一个使用内置损失函数的简单例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克拉斯损失函数</p></figure><p id="5539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用内置的<strong class="lb iu">分类 _ 交叉熵</strong>损失函数，它主要用于分类任务。我们在<code class="fe nb nc nd ne b">model.compile()</code>方法中传递损失函数的名称。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="98b8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建自定义损失函数</h1><p id="8955" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以简单地如下创建一个定制的损失函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">定制损失函数</p></figure><p id="b2c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建自定义损失函数时，您必须遵循以下规则。</p><ul class=""><li id="abcf" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">损失函数应该只有两个参数，即目标值<code class="fe nb nc nd ne b">(y_true)</code>和预测值<code class="fe nb nc nd ne b">(y_pred)</code>。因为为了测量预测中的误差(损失),我们需要这两个值。这些参数是在拟合数据时从模型本身传递过来的。</li><li id="2512" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">损失函数在计算损失时必须使用<code class="fe nb nc nd ne b">y_pred</code>值，如果您不这样做，那么梯度表达式将不会被定义，您将得到一个错误。</li><li id="0e31" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">然后你可以简单地将这个函数插入到<code class="fe nb nc nd ne b">model.compile()</code>方法中来使用它。</li></ul><h2 id="4365" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">小心数据维度</h2><ul class=""><li id="3e93" class="nf ng it lb b lc mu lf mv li of lm og lq oh lu nk nl nm nn bi translated">参数<code class="fe nb nc nd ne b">y_true</code>和<code class="fe nb nc nd ne b">y_pred</code>的第一维总是与批处理大小相同。<strong class="lb iu">例如- </strong>如果您正在拟合批量为 32 的数据，并且您的神经网络有 5 个输出节点，那么<code class="fe nb nc nd ne b">y_pred</code>的形状将是<code class="fe nb nc nd ne b">(32, 5)</code>。因为会有 32 个输出，每个输出有 5 个值。</li><li id="dd08" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">损失函数应该总是返回一个长度为<code class="fe nb nc nd ne b">batch_size</code>的向量。因为你必须返回每个数据点的损失。<strong class="lb iu">例如- </strong>如果您要拟合批量为 32 的数据，那么您需要从损失函数中返回一个长度为 32 的向量。</li></ul><p id="78db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解，我们来看一个例子。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a967" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">示例|自定义损失函数</h1><p id="28b1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">比方说，你为某个回归任务设计了一个神经网络，它输出一个长度为 2 的向量<code class="fe nb nc nd ne b">[x1, x2]</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设值<code class="fe nb nc nd ne b">x2</code>比<code class="fe nb nc nd ne b">x1</code>更重要，你希望它真正接近目标值。对于这种情况，您可以创建一个定制的<strong class="lb iu"> MSE </strong>(均方差)损失函数，该函数对<code class="fe nb nc nd ne b">x2</code>的预测误差比对<code class="fe nb nc nd ne b">x1</code>的预测误差更不利。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MSE 损失函数</p></figure><p id="45c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我用权重 0.3 和 0.7 乘以损失值，给第二个值，也就是<code class="fe nb nc nd ne b">x2</code>，更多的惩罚。您可以根据自己的需要决定重量。</p><p id="daea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还写下了代码片段中变量的形状。您可以看到最终损失的形状是<code class="fe nb nc nd ne b">(batch_size,)</code>，这意味着每个数据点有一个损失值。</p><p id="3ed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以简单地将这个损失函数插入到你的模型中。</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="02eb" class="nt md it ne b gy om on l oo op">model.compile(loss=custom_mse, optimizer='adam')</span></pre><h2 id="3f44" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">注意</h2><ul class=""><li id="5ae9" class="nf ng it lb b lc mu lf mv li of lm og lq oh lu nk nl nm nn bi translated">我建议您使用 Keras 后端函数，而不是 Numpy 函数，以避免任何意外。Keras 后端函数的工作方式几乎类似于 Numpy 函数。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="216c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">奖金</h1><p id="066a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，您已经知道如何构建自定义损失函数。您也可以以完全相似的方式创建定制的评估指标。这里，我创建了一个平均绝对误差(MAE)指标，并将其插入到<code class="fe nb nc nd ne b">model.compile()</code>方法中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MAE 度量</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d85a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想理解尺寸的概念和形状的概念。你可以阅读下面这篇文章，我会在其中详细解释这些概念。</p><div class="oq or gp gr os ot"><a rel="noopener follow" target="_blank" href="/understanding-axes-and-dimensions-numpy-pandas-606407a5f950"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">了解轴和维度| Numpy |熊猫</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">知道如何沿数据的不同轴应用函数。</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div></div></div>    
</body>
</html>