<html>
<head>
<title>Vector Autoregressive for Forecasting Time Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测时间序列的向量自回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/vector-autoregressive-for-forecasting-time-series-a60e6f168c70?source=collection_archive---------10-----------------------#2020-06-18">https://towardsdatascience.com/vector-autoregressive-for-forecasting-time-series-a60e6f168c70?source=collection_archive---------10-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5b23" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">VAR捕捉发展和相互依赖性</h2><div class=""/><div class=""><h2 id="7551" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">包含多个时间序列的经济计量模型</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/67917bf7c604cdf0c0480d16d235105c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*peraV1u6qAsi-4nx1Mq1Dw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="5d85" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae md" href="https://sarit-maitra.medium.com/membership" rel="noopener">https://sarit-maitra.medium.com/membership</a></p><p id="8891" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> V </span>向量自回归(VAR)时间序列模型在计量经济预测模型中有着广泛的应用；VAR可以捕捉多个时间序列之间的演化和相互依赖关系。VAR中的所有变量都是对称处理的，每个变量都包含一个方程，根据其自身的滞后和模型中所有其他变量的滞后来解释其演变。我们可以称之为交易策略的科学方法。</p><blockquote class="mn"><p id="5a9b" class="mo mp it bd mq mr ms mt mu mv mw mc dk translated">使用科学方法进行交易策略设计的优势在于，如果策略在前一段盈利期后失败，则有可能重新审视最初的假设并重新评估它，从而潜在地产生新的假设，使策略重新盈利。</p></blockquote><p id="d142" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq mz ls lt lu na lw lx ly nb ma mb mc im bi translated">布伦特原油有四个时间序列。美国和欧洲价格，西德克萨斯原油价格和石油输出国组织原油价格。我们将开发一个回归模型，并尝试预测布伦特原油，美国价格给定的所有系列在我们的模型。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/59d0f7f1c84025b970ab6d214c43bb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*89FhvEVnL7qmQDM27UpoSQ.png"/></div></figure><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="7a37" class="ni nj it ne b gy nk nl l nm nn">plt.plot(df['opec'], label="opec")<br/>plt.plot(df['euro'], label="Euro")<br/>plt.plot(df['br_crude'], label="Brent Crude Oil")<br/>plt.plot(df['wti'], label="West Texas")</span><span id="1b00" class="ni nj it ne b gy no nl l nm nn">plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)<br/>plt.title('Opec Oil, Europe Brent Crude, Brent Crude Oil &amp; West Texas Price over Time')<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/3ea6dfa4b4dc94a931b9f7a680544333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7cpGADbUp5Rfe5YsMcqrQ.png"/></div></div></figure><p id="4710" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以看到，所有的序列都遵循一个随机趋势，表现出更强的跨时变化和更大的下降；更重要的是，所有的系列似乎都有某种联系。这两个系列的水平看起来都不稳定。它们似乎有一个共同的趋势，表明它们可能是共同整合的。</p><h2 id="9806" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated">IQR绘制所有变量:</h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="c23a" class="ni nj it ne b gy nk nl l nm nn">plt.title('IQR plot for all variables')<br/>sns.boxplot(x=df)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/19c604ec00d8f04d5908621cdcecd8b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9p0S0IfOvzHDELVY2cDcyQ.png"/></div></div></figure><p id="00fc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以在数据中看到一个小的异常值，可以忽略不计。</p><p id="f594" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">VAR模型描述了平稳变量之间的动态相互关系。因此，时间序列分析的第一步应该是单位根检验，以确定序列是否平稳。</p><h2 id="e6b6" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated">相关性检查:</h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="549c" class="ni nj it ne b gy nk nl l nm nn">pearsoncorr = df.corr(method='pearson')<br/>sns.heatmap(pearsoncorr,<br/>xticklabels=pearsoncorr.columns,<br/>yticklabels=pearsoncorr.columns,<br/>cmap='RdBu_r',<br/>annot=True,<br/>linewidth=0.5)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/a2ecd1e4eae3d6ebbe667ae0dcdbcf4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DnyX7EMfOV1IUlSVzFVfxg.png"/></div></div></figure><p id="418d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">尽管相关性经常用于所有多变量金融时间序列用例，但是相关性可能非常不稳定。此外，ADF或Hurst指数有助于我们从统计上确认该序列是否均值回复。然而，我们无法从这些测试中确定形成线性组合所需的套期保值比率，它们只会告诉我们，对于特定的情况，线性组合是否是稳定的。另一种安排是协整，这可能是两个金融序列之间联系的一个更稳健的措施。</p><h2 id="73a2" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated">增强型迪基-富勒(ADF):</h2><p id="9182" class="pw-post-body-paragraph lh li it lj b lk oi kd lm ln oj kg lp lq ok ls lt lu ol lw lx ly om ma mb mc im bi translated">ADF检验表明，如果一个价格序列具有均值回复，那么下一个价格水平将与当前价格水平成比例。在数学上，ADF是基于测试自回归时间序列样本中单位根的存在的思想。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="a860" class="ni nj it ne b gy nk nl l nm nn">def adfuller_test(series, signif=0.05, name='', verbose=False):<br/>  r = adfuller(series, autolag='AIC')</span><span id="cb1a" class="ni nj it ne b gy no nl l nm nn">  output = {'test_statistic':round(r[0], 4), 'pvalue':<br/>round(r[1], 4), 'n_lags':round(r[2], 4), 'n_obs':r[3]}<br/>  p_value = output['pvalue']<br/>def adjust(val, length= 6): <br/>  return str(val).ljust(length)</span><span id="18ca" class="ni nj it ne b gy no nl l nm nn">print(f'Augmented Dickey-Fuller Test on "{name}"', "\n   ", '-'*47)<br/>print(f'Null Hypothesis: Data has unit root. Non-Stationary.')<br/>print(f'Significance Level = {signif}')<br/>print(f'Test Statistic = {output["test_statistic"]}')<br/>print(f'No. Lags Chosen = {output["n_lags"]}')</span><span id="916e" class="ni nj it ne b gy no nl l nm nn">for key,val in r[4].items():<br/>  print(f' Critical value {adjust(key)} = {round(val, 3)}')</span><span id="5c30" class="ni nj it ne b gy no nl l nm nn">  if p_value &lt;= signif:<br/>    print(f" =&gt; P-Value = {p_value}. Rejecting Null Hypothesis.")<br/>    print(f" =&gt; Series is Stationary.")<br/>  else:<br/>    print(f" =&gt; P-Value = {p_value}. Weak evidence to reject the Null Hypothesis.")<br/>    print(f" =&gt; Series is Non-Stationary.")</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/0de4f92947db13aa873e9fa2e8915c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWbwOAvRNLH3g-f-m9n8Dw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/4e061a592e44d006ae65f2d068919a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCg56acxlMkz0Blap3YaGQ.png"/></div></div></figure><p id="1519" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">没有一个统计数据接近5%的显著水平。因此，我们可以自信地说，级数在水平上是非平稳的。研究了它们的协整关系，在每种情况下(p值&gt; 0.05)，不能在任何合理的显著性水平上拒绝非平稳性的零假设。</p><h2 id="af9e" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated">协整检验:</h2><p id="2010" class="pw-post-body-paragraph lh li it lj b lk oi kd lm ln oj kg lp lq ok ls lt lu ol lw lx ly om ma mb mc im bi translated">协整检验过程中的步骤:</p><ol class=""><li id="86b7" class="op oq it lj b lk ll ln lo lq or lu os ly ot mc ou ov ow ox bi translated">使用单变量单位根检验，比如ADF、PP检验，分别检验每个成分序列的单位根。</li><li id="ab05" class="op oq it lj b lk oy ln oz lq pa lu pb ly pc mc ou ov ow ox bi translated">如果单位根不能被拒绝，那么下一步就是检验成分之间的协整，即检验αYt是否为I(0)。</li></ol><p id="503b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果我们发现时间序列是一个单位根，那么我们就进入协整过程。协整检验主要有三种方法:Johansen方法、Engle-Granger方法和Phillips-Ouliaris方法。我们将使用恩格尔-格兰杰检验。通过使用协整检验，我们将检验wti价格指数和br_crude价格指数之间是否存在协整的长期关系。数学上，我们将考虑协整关系:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/c3646ced24a3c4ff2ad276388a9d7ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*bVv7EQb5KL1A1L-xoG2hJg.png"/></div></figure><p id="00df" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Engle &amp; Granger的两步残差检验程序首先估计一个横截面回归，然后使用具有修正临界值的ADF分布检验该回归的残差。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/6ed1e5b484828d03210541cb031e6095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*EewKa8AaDVf7KWUz7Efn0g.png"/></div></figure><p id="36a4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里记录了每个时间点的观测向量。在这种情况下，可能有一些构成平稳时间序列的向量的线性组合和其他非平稳的线性组合。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/9da28722cae484a12333a8bc34f33d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0QZ4LTKpEJ0gN2BrdbUIQ.png"/></div></div></figure><p id="944b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从上面的模型残差图来看，平均值为0，这可能是一个趋势。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/ac0461b71d1240af0489aaa20ffb2867.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*ovAW8Dyf4fgbbhfoK2U_SQ.png"/></div></figure><p id="67f4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">估计的协整向量非常接近[+1，1]，表明存在简单的无套利关系。让我们用一个常数和一个时间趋势(<em class="ph">“CT”</em>)重新运行测试。我们在5% (-3.79)和10% ( 3.50)水平的临界值的测试统计为-4.231&lt;；p值&lt; 0.05，我们可以拒绝无协整的零假设。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/c5a73aa3d5d27f12c39f5e817d23755a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UafzXmbXSxoclg8gQ_sQsw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/45b8ee14c3eb7cf05e091828bfc95f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*ascMdYjeerl2O0Dbv7pzaQ.png"/></div></figure><p id="47ae" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">残差明显为零，但显示了当前年份(2020年)的结构性突变的证据。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/1952f9a7579d47fcbeb64e004db71093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pl7Is6Cj7ccZ1GonvXMVPQ.png"/></div></div></figure><p id="80bf" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">同样，我们测试了其他可能的配对组合，以获得类似的输出。</p><blockquote class="mn"><p id="4c0d" class="mo mp it bd mq mr ms mt mu mv mw mc dk translated">虽然<em class="pl"> Engle-Granger </em>方法很容易使用，但是它的一个主要缺点是它只能估计变量之间的一个协整关系。</p></blockquote><p id="ed8f" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq mz ls lt lu na lw lx ly nb ma mb mc im bi translated">这里，我们有1个以上的变量，可能有一个以上的线性独立的协整关系。</p><h2 id="863d" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated">p值的重要性:</h2><p id="3f71" class="pw-post-body-paragraph lh li it lj b lk oi kd lm ln oj kg lp lq ok ls lt lu ol lw lx ly om ma mb mc im bi translated">现实生活中商业案例的p值一直是争论的焦点。p值在发表的文章上可能看起来不错，但它从来没有像今天这样被使用过。更多详情请阅读这篇有趣的<a class="ae md" href="http://The P value was never meant to be used the way it's used today." rel="noopener ugc nofollow" target="_blank"> <em class="ph">文章</em> </a>。传统上，<em class="ph"> p- </em>值&lt; 0.05是显著性的标准。</p><h2 id="a823" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated">OLS回归:</h2><p id="51ec" class="pw-post-body-paragraph lh li it lj b lk oi kd lm ln oj kg lp lq ok ls lt lu ol lw lx ly om ma mb mc im bi translated">现在，我们将使用OLS拟合时间序列之间的回归，并可视化残差图。如果残差是平稳的，我们可以有把握地假设，给定的序列确实是协整的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pm"><img src="../Images/180608f285f9bc1f6cd503904cb0ec1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Lvza0PnRvkWeWcFWDGJlg.png"/></div></div></figure><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="93e1" class="ni nj it ne b gy nk nl l nm nn">residuals = results.resid<br/>br_crude_fit = results.fittedvalues</span><span id="630c" class="ni nj it ne b gy no nl l nm nn">fig = plt.figure(1)<br/>ax1 = fig.add_subplot(111)<br/>ax1.plot(br_crude_fit, label='Linear Prediction')<br/>ax1.plot(df['br_crude'], label='Brent Crude-USA')<br/>ax1.set_xlabel('Date')<br/>ax1.legend(loc=0)<br/>ax2 = plt.twinx()<br/>ax2.set_ylabel('Residuals')<br/>ax2.plot(residuals, label='Residuals')<br/>ax2.legend(loc=0)<br/>plt.grid(True)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/ac5a432f4979112ad2c032fd35d02bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JArH-OsPE7lHEimphA07cQ.png"/></div></div></figure><p id="d0b5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">残差的级别(红线)，它看起来比原始序列(蓝线)更像一个平稳序列。在这里，我们可以看到，实际和拟合线是难以区分的。</p><p id="7c0c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在让我们对残差序列进行ADF检验。我们使用DFGLS测试，并指定12个滞后作为DFGLS回归的最大滞后阶数。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi po"><img src="../Images/69dff14cefd8163349a9ed1742b37565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*8aizPIYz032c5ddo0oMetA.png"/></div></figure><p id="bd69" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">滞后的数量表明最佳滞后长度为7。我们的测试统计(–7.059)&lt; Critical Values at 1%, 5% &amp; 10% and null hypothesis of no cointegration can be rejected.</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/5d2cb919a42abebb0cb74cec3e04a685.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*M3BmK9ogcwv-qHRp0hk3YA.png"/></div></figure><h2 id="1430" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated"><em class="pl">breus ch-Godfrey</em>(BD)测试:</h2><p id="a691" class="pw-post-body-paragraph lh li it lj b lk oi kd lm ln oj kg lp lq ok ls lt lu ol lw lx ly om ma mb mc im bi translated">BD比DW更通用，允许我们测试高阶自相关。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pq"><img src="../Images/af904e6224b24f34f22bba5abccd2859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iyDSINYnR6EohQHV4lQRmw.png"/></div></div></figure><p id="797b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">残差的分布看起来像一个钟形，尽管有一些可能导致偏斜的异常值。</p><h2 id="52df" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated"><em class="pl"> Jarque-Bera </em>正态性检验:</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/ea89f5a403844af1f61e73b0a74012e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HTUOyKBHuF05D8rqpKSUaA.png"/></div></div></figure><p id="f0db" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">χ2检验的双尾p值等于零意味着我们接受残差的零假设总体上是正态分布的，即峰度和偏度都是正态分布的。</p><h1 id="8cc4" class="ps nj it bd nq pt pu pv nt pw px py nw ki pz kj nz kl qa km oc ko qb kp of qc bi translated">向量自动回归(VAR):</h1><p id="e2d8" class="pw-post-body-paragraph lh li it lj b lk oi kd lm ln oj kg lp lq ok ls lt lu ol lw lx ly om ma mb mc im bi translated">VAR方法使用AR模型对每个时间序列的下一步进行建模。模型的符号包括将AR(p)模型的阶数指定为VAR函数{VAR(p)}的参数。</p><p id="ccf8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们先来看看这个系列的第一个不同点，然后再试试ADF。通常，如果水平时间序列不是平稳的，第一个差异将是。数据差异或多或少是计算时间序列从一个值到下一个值的变化量。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="115c" class="ni nj it ne b gy nk nl l nm nn">df = df [['br_crude', 'wti', 'opec', 'euro']]<br/>nobs = 5<br/>df_train, df_test = df[0:-nobs], df[-nobs:]</span><span id="5de9" class="ni nj it ne b gy no nl l nm nn">print(df_train.shape)<br/>print(df_test.shape)</span><span id="504a" class="ni nj it ne b gy no nl l nm nn">df_tr_diff = df_train.diff()<br/>df_tr_diff.dropna(inplace=True)<br/>print(df_tr_diff.head())</span><span id="8484" class="ni nj it ne b gy no nl l nm nn">df_tr_diff.plot(figsize=(10,6), linewidth=5, fontsize=20)<br/>plt.show()</span></pre><p id="bb64" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">考虑到时间因素，为时间序列问题创建一个训练和测试集是很棘手的。在这个阶段任何错误的举动都会打乱这个系列的格局。创建测试集时应该考虑日期和时间值。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qd"><img src="../Images/0b248467ab99ea6e88feef7027b92f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m3HkmV_PEXMpq3h6TR8DNg.png"/></div></div></figure><p id="b445" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们对数据帧的第一差重复上述所有步骤。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="44c5" class="ni nj it ne b gy nk nl l nm nn"># ADF Test on each column<br/>for name, column in df_tr_diff.iteritems():<br/>adfuller_test(column, name=column.name)</span></pre><p id="88de" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，我们看到所有的级数在一阶差分后都是平稳的。</p><h2 id="8cb4" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated">风险值模型:</h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="00f1" class="ni nj it ne b gy nk nl l nm nn">var_model = smt.VAR(df_tr_diff)<br/>res = var_model.select_order(maxlags=10)<br/>print(res.summary())</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/33fb18134c8c9f34131146c1fd5a8d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*bMcrCdAcvL-g0MPeYK6yyg.png"/></div></figure><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="b599" class="ni nj it ne b gy nk nl l nm nn">#Fit VAR model<br/>var_model = VAR(endog=df_tr_diff)<br/>var_model_fit = var_model.fit(maxlags=10)</span><span id="d971" class="ni nj it ne b gy no nl l nm nn">#Print a summary of the model results<br/>var_model_fit.summary()</span></pre><p id="840a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们在模型总结中真正想要关注的是br_crude的等式，其中br_crude根据自身的滞后值和其他变量的滞后价格来估计其他价格。t统计值越高，我们就越有可能拒绝H0，两个变量之间也越有可能存在相关性。p值也用于拒绝零假设。p值越低，反对零假设的证据越强。</p><p id="7575" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">估计VAR的方程式并不需要很强的假设；然而，计算脉冲响应函数(IRF)或方差分解确实需要识别限制。一个典型的限制是假设一对变量之间的动态关系，例如，x只滞后地影响y，或者x在长期内不影响y</p><p id="cf10" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们使用脉冲响应图，在不同的水平上，将一个变量的变化对其他变量的影响可视化。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="9e93" class="ni nj it ne b gy nk nl l nm nn"># Impulse Response Analysis<br/>irf = var_model_fit.irf(20)<br/>irf.plot()<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/a6decbcf931d37f17fcaec25f0723fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*weyazc-p-iUPqkJNVW_tqA.png"/></div></figure><p id="bb5a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">给定参数估计和<em class="ph"> Engle Granger </em>测试结果，这里建立了序列之间的联系。可以看出，对冲击的响应在这里被捕获，并且它们几乎在第10个滞后之后消失。</p><h2 id="1c87" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated">预测误差差异分解(FEVD):</h2><p id="4000" class="pw-post-body-paragraph lh li it lj b lk oi kd lm ln oj kg lp lq ok ls lt lu ol lw lx ly om ma mb mc im bi translated">在FEVD曲线图的第一行中显示了对br_crude价格的冲击对其它价格和它们自身的其它价值的影响。在br _原油价格(深黑色柱)的情况下，归因于自身冲击的误差百分比为100%，因为wti系列解释了约40%的回报变化；欧佩克约为60%，欧元系列解释了约70%的变化。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/ebff1497d685396efaec320be79b9ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jdq-_oIfiaA7Ut_T6JfrjA.png"/></div></div></figure><p id="54ff" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="ph">注:上述测试程序的概念取自Brooks(2019)；参见参考部分。</em></p><h2 id="1df7" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated">预测:</h2><p id="49b6" class="pw-post-body-paragraph lh li it lj b lk oi kd lm ln oj kg lp lq ok ls lt lu ol lw lx ly om ma mb mc im bi translated">现在模型已经建立，让我们生成预测并与测试/验证集中的实际数据进行比较。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="a323" class="ni nj it ne b gy nk nl l nm nn"># Get the lag order<br/>lag_order = var_model_fit.k_ar<br/>print(lag_order)</span><span id="3a2c" class="ni nj it ne b gy no nl l nm nn"># Input data for forecasting<br/>input_data = df_tr_diff.values[-lag_order:]<br/>print(input_data)</span><span id="1eb6" class="ni nj it ne b gy no nl l nm nn"># forecasting<br/>pred = var_model_fit.forecast(y=input_data, steps=nobs)<br/>pred = (pd.DataFrame(pred, index=df_test.index, columns= df.columns + '_pred'))<br/>print(pred)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/13c91e61a96ec832e0b990baef594b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*yZWMOFohK_uid8t6ihh3GQ.png"/></div></figure><h2 id="8d32" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated">反转变换:</h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="2429" class="ni nj it ne b gy nk nl l nm nn">def invert_transformation(df_tr_diff, pred):<br/>  forecast = pred.copy()<br/>  columns = df_train.columns</span><span id="19cd" class="ni nj it ne b gy no nl l nm nn">for col in columns:<br/>  forecast[str(col)+'_pred'] = df_train[col].iloc[-1] +  <br/>                               forecast[str(col)+'_pred'].cumsum()<br/>  return forecast</span><span id="a048" class="ni nj it ne b gy no nl l nm nn">output = invert_transformation(df_tr_diff, pred)<br/>output.loc[:, ['br_crude_pred']]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/a9335cc5cd6f73fd462f36ff9af1f048.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*LWyUSKp8Jm0ofq6fCnipoA.png"/></div></figure><h2 id="747d" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated">预测评估:</h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="61c2" class="ni nj it ne b gy nk nl l nm nn"># forecast bias<br/>forecast_errors = [combine['br_crude'][i]- combine['br_crude_pred'][i] for i in range(len(combine['br_crude']))]<br/>bias = sum(forecast_errors) * 1.0/len(combine['br_crude'])<br/>print('Bias: %f' % bias)</span><span id="6a2a" class="ni nj it ne b gy no nl l nm nn"># MAE<br/>mae = mean_absolute_error(combine['br_crude'], combine['br_crude_pred'])<br/>print('MAE: %f' % mae)</span><span id="37f8" class="ni nj it ne b gy no nl l nm nn"># MSE &amp; RMSE<br/>mse = mean_squared_error(combine['br_crude'], combine['br_crude_pred'])<br/>print('MSE: %f' % mse)<br/>rmse = sqrt(mse)<br/>print('RMSE: %f' % rmse)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/c4060aeb6612651e9ffea1b9546cb48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*9CsA369avsaJQywLsW6rzw.png"/></div></figure><h2 id="6a62" class="ni nj it bd nq nr ns dn nt nu nv dp nw lq nx ny nz lu oa ob oc ly od oe of iz bi translated">实际与预测:</h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="9fdf" class="ni nj it ne b gy nk nl l nm nn">combine = pd.concat([df_test['br_crude'], output['br_crude_pred']], axis=1)<br/>combine['accuracy'] = round(combine.apply(lambda row: row.br_crude_pred /<br/>row.br_crude *100, axis = 1),2)</span><span id="2117" class="ni nj it ne b gy no nl l nm nn">combine['accuracy'] = pd.Series(["{0:.2f}%".format(val) for val in combine['accuracy']],index = combine.index)<br/>combine = combine.assign(day_of_week = lambda x: x.index.day_name())<br/>combine = combine.round(decimals=2)<br/>combine = combine.reset_index()<br/>combine</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/1e714b4e4ec00604a9290a8e126a9bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*gUappw_gsU__Sw9-G43veg.png"/></div></figure><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="f697" class="ni nj it ne b gy nk nl l nm nn">fig = go.Figure()<br/>fig.add_trace(go.Scatter(x=combine['Date'], y=combine['br_crude'], name="Actual Crude price"))<br/>fig.add_trace(go.Scatter(x=combine['Date'],y=combine['br_crude_pred'],name="Predicted crude price"))<br/>fig.update_layout(<br/>title="Actual vs Predicted Brent Crude Price",<br/>xaxis_title="Date", yaxis_title="Price", font=dict(family="Courier New, monospace",size=18,color="#7f7f7f"))<br/>fig.update_layout(autosize=False,width=1000,height=400,)<br/>fig.update_layout(legend_orientation="h")<br/>fig.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ql"><img src="../Images/76d76254f2724b732f7fe0c4f80601f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rlPeSOMuqx22-jmUibTyLw.png"/></div></div></figure><h1 id="551c" class="ps nj it bd nq pt pu pv nt pw px py nw ki pz kj nz kl qa km oc ko qb kp of qc bi translated">结论:</h1><p id="5182" class="pw-post-body-paragraph lh li it lj b lk oi kd lm ln oj kg lp lq ok ls lt lu ol lw lx ly om ma mb mc im bi translated">一旦我们有了数据的模型，分析如何评估它的质量是很重要的。第一种选择是使用残差。残差基本上是预测值和实际值之间的平方差。这可能是一个简单的选择来判断我们的模型的准确性。</p><p id="998c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">残差与我们用来创建模型的数据量成比例。因此，不建议使用所有残差的和。一种选择是将残差除以瞬时数量乘以因变量的数量。</p><p id="a340" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="ph">我这里可以到达</em></strong><a class="ae md" href="https://www.linkedin.com/in/saritmaitra/" rel="noopener ugc nofollow" target="_blank"><strong class="lj jd"><em class="ph"/></strong></a>。</p><p id="3690" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="ph">参考文献:</em></p><ol class=""><li id="22d0" class="op oq it lj b lk ll ln lo lq or lu os ly ot mc ou ov ow ox bi translated">汉密尔顿法学博士，1994年。时间序列分析。新泽西，普林斯顿大学出版社。</li><li id="e38e" class="op oq it lj b lk oy ln oz lq pa lu pb ly pc mc ou ov ow ox bi translated">恩格尔，R.F .，格兰杰，C.W.J，1987。协整与误差修正:表示、估计与检验。计量经济学。55, 251–276.</li><li id="8bcc" class="op oq it lj b lk oy ln oz lq pa lu pb ly pc mc ou ov ow ox bi translated">布鲁克斯，C. (2019年)。金融计量经济学导论。剑桥大学出版社。</li></ol></div></div>    
</body>
</html>