<html>
<head>
<title>An Introduction to Making Scientific Publication Plots with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python制作科学出版物图简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-introduction-to-making-scientific-publication-plots-with-python-ea19dfa7f51e?source=collection_archive---------4-----------------------#2020-04-02">https://towardsdatascience.com/an-introduction-to-making-scientific-publication-plots-with-python-ea19dfa7f51e?source=collection_archive---------4-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="66b7" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="http://towardsdatascience.com/tagged/python-science-plotting" rel="noopener" target="_blank"> Python科学绘图</a></h2><div class=""/><div class=""><h2 id="1e13" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">介绍如何使用Python为科学出版物绘制数据</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ee79b4b48e708cf1a15addfe526204ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SuY5vFBe3r1a5dbck7jYAg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@isaacmsmith?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Isaac Smith </a>在<a class="ae lh" href="https://unsplash.com/s/photos/graph?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="26ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">几年来，我一直在使用Python进行科学计算，绘制我所有的图。我的主要动机是:( 1) Python是开源的，以及(MATLAB占用的硬盘空间(尤其是在我的笔记本电脑上，那里的硬盘空间非常宝贵)。此外，永远不必担心保持软件许可证最新也是一个额外的优势。在为我的情节找到“完美”的参数之前，我不得不进行一连串的试错和谷歌搜索，这促使我撰写了这篇文章——既是为外部读者提供信息的工具，也是我为自己记录事情的一种方式。审美是主观的，但我希望本教程可以指出重要的设置和参数，允许您根据个人喜好定制任何数据集。这是我希望成为的系列教程的第一篇文章——我将继续为不同类型的可视化添加章节。如果你还没有Anaconda 的话，我建议你安装它，因为它包含了所有你需要的数据分析和可视化所需的包。</p><h1 id="8e25" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">导入包</strong></h1><p id="b676" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">使用的大多数函数在<code class="fe nb nc nd ne b">matplotlib</code>包中(大多数绘图函数来自<code class="fe nb nc nd ne b">matplotlib.pyplot</code>子包)。此外，我通常导入<code class="fe nb nc nd ne b">numpy</code>用于快速计算，导入<code class="fe nb nc nd ne b">pylab</code>用于从任何内置色图中快速生成颜色。很多时候，当我们导入包时，我们会创建一个简短的别名(<em class="nf">即</em> <code class="fe nb nc nd ne b">mpl</code>代表<code class="fe nb nc nd ne b">matplotlib</code>)，这样我们就可以使用别名来引用它的函数，而不是每次都键入<code class="fe nb nc nd ne b">matplotlib</code>。</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="194c" class="nk mf it ne b gy nl nm l nn no"># Import required packages<br/>import matplotlib as mpl<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>from pylab import cm</span></pre><h1 id="b0ee" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">加载数据</h1><p id="75a2" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">由于科学仪器数据通常相当简单(通常只有一个我们控制的自变量和一个测量的因变量)，我们可以使用<code class="fe nb nc nd ne b">numpy.loadtxt</code>来导入我们的数据。对于更复杂的数据集，我强烈推荐使用<code class="fe nb nc nd ne b">pandas</code>，它有非常复杂的功能来加载和净化可视化数据——在这里可以找到全面的文档<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/reference/io.html" rel="noopener ugc nofollow" target="_blank"/>。对于这个例子，我有一个名为<code class="fe nb nc nd ne b">Absorbance_Data.csv</code>的文件，其中有一些在分光光度计上收集的两个样品的吸光度数据。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/f4b402c5c816487d05773bd9ec41d696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GK0aB19sqrC5eBdMW-ktIg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">两个样品吸光度数据的CSV文件</p></figure><p id="74fb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用以下命令将这些数据加载到我们的脚本中:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="28ac" class="nk mf it ne b gy nl nm l nn no"># Use numpy.loadtxt to import our data</span><span id="9826" class="nk mf it ne b gy nq nm l nn no">wavelength, samp_1_abs, samp_2_abs = np.loadtxt('Absorbance_Data.csv', unpack=True, delimiter=',', skiprows=1)</span></pre><p id="ea0e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将文件和参数一起传递给<code class="fe nb nc nd ne b">numpy.loadtxt</code>函数:</p><p id="3ada" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">unpack</code> —将每一列转置到一个数组中，允许您一次解包多个变量(<code class="fe nb nc nd ne b">wavelength</code>、<code class="fe nb nc nd ne b">samp_1_abs</code>、<code class="fe nb nc nd ne b">samp_2_abs</code>)</p><p id="af60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">delimiter</code> —用于分隔列的分隔符</p><p id="b39e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">skiprows</code> —在文件顶部跳过的行数(因为第一行是列标题，所以我们想跳过它<code class="fe nb nc nd ne b">skiprows=1</code>)</p><h1 id="39c5" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">绘制我们的数据</strong></h1><p id="3370" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">加载吸光度数据后，我们可以使用以下代码快速绘制和检查两个数据集:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="4b5a" class="nk mf it ne b gy nl nm l nn no"># Create figure and add axes object<br/>fig = plt.figure()<br/>ax = fig.add_axes([0, 0, 1, 1])</span><span id="c94c" class="nk mf it ne b gy nq nm l nn no"># Plot and show our data<br/>ax.plot(wavelength, samp_1_abs)<br/>ax.plot(wavelength, samp_2_abs)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nr"><img src="../Images/32f14b637acc9ffac76a5e123b8f34fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ieQhbjP6bjqfOmx0Hp2V1A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用默认matplotlib设置绘制吸光度数据的初始图</p></figure><p id="5b14" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">数据绘制正确，但默认的<code class="fe nb nc nd ne b">matplotlib</code>设置不能给出出版质量的数字。当我们改变下面的一些参数时，我们会得到一个更好看的图。</p><h1 id="10df" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">字体</strong></h1><p id="6da1" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">这是一个我花费了大量时间的场景——为我的情节选择合适的字体。您的系统已经预装了一长串字体，您可以通过以下方式检查哪些字体已经可供<code class="fe nb nc nd ne b">matplotlib</code>使用:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="8ddc" class="nk mf it ne b gy nl nm l nn no">import matplotlib.font_manager as fm</span><span id="805b" class="nk mf it ne b gy nq nm l nn no"># Collect all the font names available to matplotlib<br/>font_names = [f.name for f in fm.fontManager.ttflist]<br/>print(font_names)</span></pre><p id="7945" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想安装一个新的字体到你的电脑，然后用它来绘图，这也是可能的。首先，你必须下载并安装你想要的字体——在这里你可以找到很多选项。安装后，您必须重新构建字体缓存，以便在您制作图形时可用于<code class="fe nb nc nd ne b">matplotlib</code>。我们的做法如下:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="7637" class="nk mf it ne b gy nl nm l nn no">import matplotlib.font_manager as fm</span><span id="7cef" class="nk mf it ne b gy nq nm l nn no"># Rebuild the matplotlib font cache<br/>fm._rebuild()</span></pre><p id="4b17" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您现在检查可用字体列表，您应该会看到刚刚安装的新字体。</p><h1 id="86ee" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">通用绘图参数</strong></h1><p id="b2fd" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我在绘图脚本开始时设置的三个常规参数是:(1)字体，(2)字体大小，和(3)轴线宽度。这些基本上是全局参数，我以后不会编辑它们，所以在开始时设置它们会使一切变得更容易(<em class="nf">即</em>不必为每个标签明确设置字体/大小)。在生成任何图形之前，我们必须添加以下代码，所以我通常在导入包之后立即将它放在脚本的顶部。</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="1f2b" class="nk mf it ne b gy nl nm l nn no"># Edit the font, font size, and axes width</span><span id="633b" class="nk mf it ne b gy nq nm l nn no">mpl.rcParams['font.family'] = 'Avenir'<br/>plt.rcParams['font.size'] = 18<br/>plt.rcParams['axes.linewidth'] = 2</span></pre><h1 id="f736" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">生成一组颜色</h1><p id="42bf" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果你有一套你喜欢用的颜色，你可以跳过这一步。在这种情况下，由于我们只有两个样本，最好手动选择两种高对比度的颜色。但是，如果你想生成一个颜色列表而不需要太多的努力，我们可以使用我们导入的<code class="fe nb nc nd ne b">pylab</code>包从各种<code class="fe nb nc nd ne b">matplotlib</code>内置颜色图中生成一个颜色列表，可以在<a class="ae lh" href="https://matplotlib.org/3.1.1/gallery/color/colormap_reference.html" rel="noopener ugc nofollow" target="_blank">这里找到</a>。当您需要大量颜色时，这变得非常有用，因为您可以通过编程生成它们。</p><p id="7fae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于我们的数据集，我们只对轻松区分我们的轨迹感兴趣，因此我们最好使用定性部分中的一个颜色图(在本例中，我将使用“tab10”)。我们使用以下代码—第一个参数是色彩映射表名称，第二个参数是我们想要生成的颜色数量:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="6b77" class="nk mf it ne b gy nl nm l nn no"># Generate 2 colors from the 'tab10' colormap<br/>colors = cm.get_cmap('tab10', 2)</span></pre><p id="96b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，如果我们要测量单个样品的温度依赖性，并想要绘制不同温度下的光谱，我们可以使用发散色图，如“coolwarm”。最终，您选择的色彩映射表将由您决定，并基于您正在绘制的数据类型。</p><h1 id="463e" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">创建图形和轴</strong></h1><p id="88d2" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们必须创建一个图形，它是一个空白窗口，然后为我们的绘图添加一个axes对象。为了生成该图，我们有以下内容:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="c199" class="nk mf it ne b gy nl nm l nn no"># Create figure object and store it in a variable called 'fig'<br/>fig = plt.figure(figsize=(3, 3))</span></pre><p id="738b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">figsize</code> —我们的图形尺寸(宽度、高度)，以英寸为单位，默认为(6.4，4.8)</p><p id="4c1b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们必须通过指定左下角坐标和相对坐标中的宽度和高度(1是图形窗口的全尺寸)来将axes对象添加到空白图形中。如果我们希望它填充整个图形，我们可以指定<code class="fe nb nc nd ne b">[0, 0, 1, 1]</code>，它将左下角设置为(0，0)，宽度和高度设置为1。</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="2694" class="nk mf it ne b gy nl nm l nn no"># Add axes object to our figure that takes up entire figure<br/>ax = fig.add_axes([0, 0, 1, 1])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/4cd5d9895ac64d7b8b518517b71a1cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*eA3KdphW-IhkqKXVTjDWDw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">轴在(0，0)处的空白图形，宽度和高度为1</p></figure><p id="2680" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用这种轴结构，通过制作多个轴对象来创建嵌板图形和插图，如下所示:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="5ebf" class="nk mf it ne b gy nl nm l nn no"># Add two axes objects to create a paneled figure<br/>ax1 = fig.add_axes([0, 0, 1, 0.4])<br/>ax2 = fig.add_axes([0, 0.6, 1, 0.4])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/d22c38e0c3ab539927e87aea5926c17b.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*wZ27Z4TwjrVOzQ5-MYFEvA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">带有两个面板轴的空白图形，一个位于(0，0)，另一个位于(0，0.6)，宽度为1，高度为0.4</p></figure><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="383e" class="nk mf it ne b gy nl nm l nn no"># Add two axes objects to create an inset figure<br/>ax1 = fig.add_axes([0, 0, 1, 1])<br/>ax2 = fig.add_axes([0.5, 0.5, 0.4, 0.4])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/d2c967a1107f0701954a96b286654308.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*B29l6SBBTgILkq1m21Vsbg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">带插图的空白图形-第一个轴占据整个图形，第二个轴在(0.5，0.5)处，宽度和高度为0.4</p></figure><h1 id="0b49" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">去除棘刺</strong></h1><p id="7499" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果我们不希望我们的地块完全封闭，我们可以删除顶部和右侧的脊柱如下:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="42f0" class="nk mf it ne b gy nl nm l nn no"># Hide the top and right spines of the axis<br/>ax.spines['right'].set_visible(False)<br/>ax.spines['top'].set_visible(False)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/6a3d5a97e24af8c1cff767fc448db9b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*7ZSAdIfrdRY-JuwdxZJZ2g.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">去掉顶部和右侧脊线的空白图形和轴</p></figure><h1 id="d594" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">勾选参数</strong></h1><p id="5ede" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们可以用下面的代码编辑记号的宽度和长度，以匹配我们的轴参数。如果我们有次要分笔成交点，我们还可以编辑这些属性:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="f1d6" class="nk mf it ne b gy nl nm l nn no"># Edit the major and minor ticks of the x and y axes</span><span id="c6c6" class="nk mf it ne b gy nq nm l nn no">ax.xaxis.set_tick_params(which='major', size=10, width=2, direction='in', top='on')</span><span id="9c40" class="nk mf it ne b gy nq nm l nn no">ax.xaxis.set_tick_params(which='minor', size=7, width=2, direction='in', top='on')</span><span id="48b7" class="nk mf it ne b gy nq nm l nn no">ax.yaxis.set_tick_params(which='major', size=10, width=2, direction='in', right='on')</span><span id="0dec" class="nk mf it ne b gy nq nm l nn no">ax.yaxis.set_tick_params(which='minor', size=7, width=2, direction='in', right='on')</span></pre><p id="566f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">which</code> —我们是在编辑<code class="fe nb nc nd ne b">major</code>、<code class="fe nb nc nd ne b">minor</code>还是<code class="fe nb nc nd ne b">both</code>分笔成交点</p><p id="90f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">size</code> —以点为单位的刻度长度</p><p id="2546" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">width</code> —刻度的线宽(我们可以将其设置为与我们的轴线宽相同)</p><p id="ab48" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">direction</code> —分笔成交点是面向<code class="fe nb nc nd ne b">in</code>、<code class="fe nb nc nd ne b">out</code>还是<code class="fe nb nc nd ne b">inout</code>(两者)</p><p id="0e36" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">top</code> / <code class="fe nb nc nd ne b">right</code> —次轴(上/右)上是否有刻度</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/af128e6d3e1c5bed8ab529c8717634c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*iUIelz92wRq1ytj0cffWhg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">带有更新记号参数的空白图形和轴</p></figure><h1 id="5836" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">绘制和调整范围/刻度</strong></h1><p id="a7e6" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们现在可以再次绘制我们的数据，使用我们从色图生成的颜色来区分样本:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="8f7f" class="nk mf it ne b gy nl nm l nn no"># Plot the two sample absorbances, using previously generated colors</span><span id="b5ef" class="nk mf it ne b gy nq nm l nn no">ax.plot(wavelength, samp_1_abs, linewidth=2, color=colors(0), label='Sample 1')</span><span id="b626" class="nk mf it ne b gy nq nm l nn no">ax.plot(wavelength, samp_2_abs, linewidth=2, color=colors(1), label='Sample 2')</span></pre><p id="fb14" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">linewidth</code> —图中线的线宽</p><p id="9dbd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">color</code> —图中线条的颜色</p><p id="948e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">label</code> —跟踪标签(图例参考)</p><p id="7cdc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以使用以下代码行设置x和y轴范围:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="1c5c" class="nk mf it ne b gy nl nm l nn no"># Set the axis limits<br/>ax.set_xlim(370, 930)<br/>ax.set_ylim(-0.2, 2.2)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/8335c92aa801dc2171c2afa162c2dd4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*OHk1sOmBSVu9bRmpZCJcDA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用生成的颜色和手动设置的轴限值绘制样品吸光度图</p></figure><p id="f6b5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们注意到两个轴之间的刻度线似乎不平衡——我们也可以使用一个名为<code class="fe nb nc nd ne b">MultipleLocator</code>的函数进行半自动编辑，该函数将在我们提供的基数的每个倍数处创建刻度线。我们必须编辑主要刻度的<code class="fe nb nc nd ne b">major_locator</code>和次要刻度的<code class="fe nb nc nd ne b">minor_locator</code>。我们将为x轴设置每100纳米的主刻度，每50纳米的次刻度，为y轴设置每0.5纳米的主刻度和每0.25纳米的次刻度。</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="7084" class="nk mf it ne b gy nl nm l nn no"># Edit the major and minor tick locations</span><span id="33b7" class="nk mf it ne b gy nq nm l nn no">ax.xaxis.set_major_locator(mpl.ticker.MultipleLocator(100))<br/>ax.xaxis.set_minor_locator(mpl.ticker.MultipleLocator(50))<br/>ax.yaxis.set_major_locator(mpl.ticker.MultipleLocator(0.5))<br/>ax.yaxis.set_minor_locator(mpl.ticker.MultipleLocator(0.25))</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/ff207f75689e4a13a3ccea33ab7a81bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*0G5wh5TFGQ8t8gWjvTFjYQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">手动调整刻度间隔后的先前吸光度图</p></figure><h1 id="e5e1" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">轴标签</strong></h1><p id="cc27" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们必须向x轴和y轴添加标签，这可以通过下面的代码轻松完成:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="cde6" class="nk mf it ne b gy nl nm l nn no"># Add the x and y-axis labels</span><span id="c37b" class="nk mf it ne b gy nq nm l nn no">ax.set_xlabel('Wavelength (nm)', labelpad=10)<br/>ax.set_ylabel('Absorbance (O.D.)', labelpad=10)</span></pre><p id="38d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">labelpad</code> —刻度标签和轴标签之间的额外填充</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/c0af9f0243a80caced213ce0512f2a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*F3JN9GpLFOzSQYGGmz9OJw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">添加了轴标签的吸光度图</p></figure><p id="1e70" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您想在标签中包含希腊字符，可以使用LaTeX语法来实现。我们通过在字符串前面加上<code class="fe nb nc nd ne b">r</code>并在LaTeX命令后面加上<code class="fe nb nc nd ne b">$$</code>来创建一个原始字符串。然而，这将为希腊字符使用默认的LaTeX字体——如果我们想使用相同的字体作为情节的其余部分(假设字符存在)，我们用<code class="fe nb nc nd ne b">$\mathregular{'Command goes here'}$</code>括起我们的命令。</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="48e6" class="nk mf it ne b gy nl nm l nn no"># Add the x-axis label with λ for wavelength</span><span id="e91a" class="nk mf it ne b gy nq nm l nn no">ax.set_xlabel(r'$\mathregular{\lambda}$ (nm)', labelpad=10)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0874a2526a0153a16883ddcd607d8856.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*hh9KDR6admnZm4W2wYMZtg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用LaTeX排版波长λ，用x轴标记的吸光度图</p></figure><h1 id="2b30" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">副轴刻度</strong></h1><p id="e2bc" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果我们想要在其中一个辅助(顶部/右侧)轴上放置刻度，以显示不同的数据集或缩放比例，我们可以使用寄生轴来实现。此轴对象复制原始绘图的一个轴，允许您更改另一个轴的缩放比例。为了说明这一点，我们可以使用我们的吸光度数据作为例子。当前的x轴是吸收光的波长，但是基于应用，该光的能量可能是更相关的参数。</p><p id="b7e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以在图的顶部创建第二个x轴来显示能量比例。首先，我们必须用<code class="fe nb nc nd ne b">twinx()</code>或<code class="fe nb nc nd ne b">twiny()</code>命令创建一个寄生轴，分别克隆x轴或y轴。在本例中，我们想要y轴数据常量，因此我们将克隆y轴。我们还需要将这个新x轴的刻度参数与旧图的x轴匹配(并从原始x轴参数中删除<code class="fe nb nc nd ne b">top='on'</code>)。</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="0cde" class="nk mf it ne b gy nl nm l nn no"># Create new axes object by cloning the y-axis of the first plot<br/>ax2 = ax.twiny()</span><span id="a5cc" class="nk mf it ne b gy nq nm l nn no"># Edit the tick parameters of the new x-axis<br/>ax2.xaxis.set_tick_params(which='major', size=10, width=2, direction='in')</span><span id="b6a6" class="nk mf it ne b gy nq nm l nn no">ax2.xaxis.set_tick_params(which='minor', size=7, width=2, direction='in')</span></pre><p id="bbfd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了使我们向该轴添加以能量单位表示的记号的工作更容易，我们可以编写一个函数来将能量转换为波长(因为我们将把记号放在波长轴上能量值对应的点上)。我们将输入E视为一个数组，这样我们就可以一次完成所有转换:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="0423" class="nk mf it ne b gy nl nm l nn no"># Function to convert energy (eV) to wavelength (nm)<br/>def E_to_WL(E):<br/>    return [1240/i for i in E]</span></pre><p id="5573" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于这是一个非线性转换，我们不能轻易使用<code class="fe nb nc nd ne b">MultipleLocator</code>函数，我们将使用一个名为<code class="fe nb nc nd ne b">FixedLocator</code>的函数手动添加刻度线。为了使用<code class="fe nb nc nd ne b">FixedLocator</code>,我们提供了一个我们希望有刻度线的所有位置的数组:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="9a58" class="nk mf it ne b gy nl nm l nn no"># Add ticks manually to energy axis</span><span id="cabc" class="nk mf it ne b gy nq nm l nn no">ax2.xaxis.set_major_locator(mpl.ticker.FixedLocator(E_to_WL(np.linspace(1.5, 3.0, 4))))</span><span id="5ce3" class="nk mf it ne b gy nq nm l nn no">ax2.xaxis.set_minor_locator(mpl.ticker.FixedLocator(E_to_WL(np.linspace(1.4, 3.2, 19))))</span></pre><p id="ccbb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为我们手动添加了记号，所以我们也必须手动添加主要记号标签。</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="45f4" class="nk mf it ne b gy nl nm l nn no"># Add tick labels manually to energy axis</span><span id="b44c" class="nk mf it ne b gy nq nm l nn no">ax2.set_xticklabels(['1.5', '2.0', '2.5', '3.0'])</span></pre><p id="9458" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们还想为新的x轴添加一个轴标签，并确保轴限制与原始的x轴相同:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="1b61" class="nk mf it ne b gy nl nm l nn no"># Add energy axis label<br/>ax2.set_xlabel('Energy (eV)', labelpad=10)</span><span id="b46b" class="nk mf it ne b gy nq nm l nn no"># Set energy axis limits<br/>ax2.set_xlim(370, 930)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/eae3d4f121609a995d4a3b9a11279db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*QIoSxREgKFq5lWzjQybW0Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">具有二次非线性能量x轴的吸光度图</p></figure><h1 id="bb8c" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">添加图例</strong></h1><p id="147e" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们必须在我们的图中添加的最后一件事是一个图例，以便读者可以知道哪个轨迹对应于哪个样本。为此，我们可以使用以下代码:</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="24ed" class="nk mf it ne b gy nl nm l nn no"># Add legend to plot<br/>ax.legend(bbox_to_anchor=(1, 1), loc=1, frameon=False, fontsize=16)</span></pre><p id="275b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">bbox_to_anchor</code> —图例边界框的坐标</p><p id="6c77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">loc</code> —使用<code class="fe nb nc nd ne b">bbox_to_anchor</code>值的坐标的边界框的哪一部分(<code class="fe nb nc nd ne b">0</code>为自动，<code class="fe nb nc nd ne b">1</code>为右上角，<code class="fe nb nc nd ne b">2</code>为左上角，<code class="fe nb nc nd ne b">3</code>为左下角，<code class="fe nb nc nd ne b">4</code>为右下角，<code class="fe nb nc nd ne b">5</code>为右侧，<code class="fe nb nc nd ne b">6</code>为中间偏左，<code class="fe nb nc nd ne b">7</code>为中间偏右，<code class="fe nb nc nd ne b">8</code>为中间偏下，<code class="fe nb nc nd ne b">9</code>为中间偏上，<code class="fe nb nc nd ne b">10</code>为中间偏上)</p><p id="2ca2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">frameon</code> —是否在图例周围画一个框</p><p id="692b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">fontsize</code> —图例条目的字体大小(如果不同于通用参数)</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/32c21610ab167b650fc887d35d578cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*3hgnupbwTYNkWsf44a7QAw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">最终吸光度图，带有波长和能量x轴，以及图例</p></figure><h1 id="a171" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">保存你的剧情</strong></h1><p id="07ad" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">最后，保存你的最终图非常简单——我们可以使用函数<code class="fe nb nc nd ne b">plt.savefig</code>来完成。</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="76fc" class="nk mf it ne b gy nl nm l nn no"># Save figure<br/>plt.savefig('Final_Plot.png', dpi=300, transparent=False, bbox_inches='tight')</span></pre><p id="4fb7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">dpi</code> —光栅图像文件格式的分辨率(在这种情况下，我们保存为<code class="fe nb nc nd ne b">.png</code>文件，这意味着我们以每英寸300点的分辨率保存。您可以保存的其他可能的文件格式有<code class="fe nb nc nd ne b">.ps</code>、<code class="fe nb nc nd ne b">.pdf</code>和<code class="fe nb nc nd ne b">.svg</code>，它们都是矢量图形格式，在这种情况下，您不需要指定一个<code class="fe nb nc nd ne b">dpi</code>值)</p><p id="0110" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">transparent</code> —是使图形透明，还是带有白色背景</p><p id="b62e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nb nc nd ne b">bbox_inches</code>-定义图形周围的边界框(<code class="fe nb nc nd ne b">tight</code>确保图形周围没有多余的空白)</p><p id="e437" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要在图形窗口中实际查看我们的最终绘图，我们必须在保存图形后添加一个<code class="fe nb nc nd ne b">plt.show()</code>命令。</p><pre class="ks kt ku kv gt ng ne nh ni aw nj bi"><span id="7971" class="nk mf it ne b gy nl nm l nn no"># Show figure<br/>plt.show()</span></pre><h1 id="82ba" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">结论</strong></h1><p id="9ae6" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">就是这样！我们已经成功地使用Python制作了出版物质量图！这个例子和所有后续的例子都可以在这个<a class="ae lh" href="https://github.com/venkatesannaveen/python-science-tutorial" rel="noopener ugc nofollow" target="_blank"> Github库</a>上免费获得。</p><p id="7798" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢您的阅读，我将继续用新的例子和教程来更新这个系列！你可以在Twitter上关注我，或者在T2的LinkedIn上联系我，获取更多文章和更新。</p></div></div>    
</body>
</html>