<html>
<head>
<title>Support Vector Machine — Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">支持向量机—解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/support-vector-machine-explained-8d75fe8738fd?source=collection_archive---------10-----------------------#2020-02-07">https://towardsdatascience.com/support-vector-machine-explained-8d75fe8738fd?source=collection_archive---------10-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="29f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">详细的理论解释和代码示例</h2></div><p id="1be0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">支持向量机(SVM)是一种监督机器学习算法，主要用于分类任务。它也适用于回归任务。</p><p id="069d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">监督学习算法试图使用特征(自变量)来预测目标(因变量)。根据目标变量的特征，它可以是分类(离散目标变量)或回归(连续目标变量)任务。预测是通过将自变量映射到因变量的映射函数来完成的。SVM 的映射函数是一个<strong class="kk iu">判定边界</strong>，它区分两个或多个类别。如何绘制或确定决策边界是 SVM 算法中最关键的部分。</p><p id="fa95" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在创建决策边界之前，在 n 维空间中绘制每个观察值(或数据点)。“n”是使用的特征数量。例如，如果我们使用“长度”和“宽度”来对不同的“细胞”进行分类，则观察值被绘制在二维空间中，而决策边界是一条线。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi le"><img src="../Images/da8192810ec482975c1d67ee8edeceda.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*mRPaFRxCP67yGqhvCMpJvA.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">二维空间中的 SVM</p></figure><p id="9a0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个非常简单的例子，只是为了说明 SVM 的想法。你在现实生活中遇到这样的任务的可能性极小。在这种情况下，决策边界是一条线。如果我们使用 3 个特征，则判定边界是三维空间中的平面。如果我们使用 3 个以上的特征，决策边界就变成了一个超平面，很难可视化。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/87ad9ab39cfb85b0db5f62248e6a4cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*ajzQdrfBYtYrENIMf8qb1Q.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">支持向量</p></figure><p id="8f19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主要动机是绘制一个决策边界，使支持向量的距离最大化。以到支持向量的距离最大化的方式绘制决策边界。<strong class="kk iu"> </strong>如果决策边界离支持向量太近，会对噪声高度敏感，不能很好地泛化。即使独立变量非常小的变化也可能导致错误分类。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/ae95e26da1f9152d05bd999fd7fb6b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*ZcyhQZpO3FYczlni_jR3Qw.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">决策边界的错误选择</p></figure><p id="316c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据点并不总是线性可分的，如上图所示。在这些情况下，SVM 使用了<strong class="kk iu">核技巧</strong>，它测量高维空间中数据点的相似性(或接近度),以使它们线性可分。下面的图更容易理解。如你所见，二维空间中两个不同的类不能用一条线分开。使用内核技巧可以使它们线性分离:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/5f3bb5909d859511a85ab9455015f9b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*D5jKvmphgJ8xdYujPTBWZw.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated"><a class="ae ls" href="https://jakevdp.github.io/PythonDataScienceHandbook/05.07-support-vector-machines.html" rel="noopener ugc nofollow" target="_blank">图源</a></p></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/27541a08bab2fe472b8871118b3de144.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*PpNDcodi5QOZ2FZi3wUL-A.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated"><a class="ae ls" href="https://jakevdp.github.io/PythonDataScienceHandbook/05.07-support-vector-machines.html" rel="noopener ugc nofollow" target="_blank">图源</a></p></figure><p id="8144" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我详细讲述内核技巧之前，我想提一下 c 参数和 T2 的概念。</p><h1 id="7c3d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">软余量 SVM 和 C 参数</strong></h1><p id="ca22" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">真实数据是有噪声的，并且在大多数情况下不是线性可分的。一个标准的 SVM 试图将所有的正面和负面例子(即两个不同的类)分开，不允许任何点被错误分类。这导致过度拟合模型，或者在某些情况下，无法使用标准 SVM 找到决策边界。过度拟合的 SVM 在训练集上取得了很高的精度，但在新的、以前未见过的样本上表现不佳。为了解决这个问题，1995 年，Cortes 和 Vapnik 提出了“软边界”SVM 的概念，它允许一些例子被错误分类或位于决策边界的错误一侧。软边际 SVM 通常会产生更好通用模型。当确定决策边界时，软裕度 SVM 试图解决具有以下目标的优化问题:</p><ul class=""><li id="6ce2" class="mr ms it kk b kl km ko kp kr mt kv mu kz mv ld mw mx my mz bi translated">增加决策边界到类别(或支持向量)的距离</li><li id="fb1b" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated">最大化训练集中正确分类的点数</li></ul><p id="ae02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个目标之间显然有所取舍。决策边界可能必须非常接近一个特定类，才能正确标记训练集中的所有数据点。然而，在这种情况下，测试数据集的准确性可能会较低，因为决策边界对噪声和独立变量的微小变化过于敏感。另一方面，决策边界可能被放置在尽可能远的每个类，代价是一些错误分类的异常。这种权衡由<strong class="kk iu"> c 参数控制。</strong></p><p id="92ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> C 参数</strong>为每个错误分类的数据点增加一个惩罚。如果 c 很小，则对误分类点的惩罚也很低，因此以更大数量的误分类为代价选择了具有大余量的决策边界。如果 c 很大，SVM 试图最小化由于高惩罚导致的错误分类的例子的数量，这导致了具有较小裕度的决策边界。对于所有错误分类的例子，惩罚是不同的。它与到决策边界的距离成正比。</p><h1 id="7bb2" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">内核函数</strong></h1><p id="8e67" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">核函数是一种相似性度量。输入是原始特征，输出是新特征空间中的相似性度量。这里的相似性是指接近的程度。将数据点实际转换到高维特征空间是一个代价很高的操作。该算法实际上并不将数据点转换到新的高维特征空间。内核化 SVM 根据高维特征空间中的相似性度量来计算决策边界，而不实际进行变换。我想这也是为什么又叫<strong class="kk iu">内核绝招</strong>的原因吧。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/f16fcde25b5c74312ea77ba4a642748f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*csskyAwn88skWHNeQnXWTA.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated"><a class="ae ls" href="https://www.sciencedirect.com/science/article/pii/B9780128113189000272" rel="noopener ugc nofollow" target="_blank">图源</a></p></figure><p id="b0cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">scikit-learn 中可用的核函数有线性、多项式、径向基函数(RBF)和 sigmoid。</p><p id="4dcd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RBF(或高斯 RBF)是一种广泛使用的核函数。它由<strong class="kk iu">伽马</strong>参数定义，该参数基本上控制单个训练点的影响距离。低 gamma 值表示较大的相似性半径，这将导致更多的点被组合在一起。对于高 gamma 值，这些点需要彼此非常接近，才能被视为在同一组(或类)中。因此，gamma 值非常大的模型往往会过度拟合。以下可视化更好地解释了这个概念:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/87fd93ad69cb56976f08aa8dfbcc564d.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*_CTmTq36YUixhA-QrmQ3aA.png"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/10e607d5f49b75963eb044100690ece2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*jK9NgyBwO_Qjpb6dysZi3w.png"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/aa76be5d19f3088ef56e653bb4ce7d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*cigGKvA3tTqK8STuLyor7A.png"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/e938383f2cb5e6dd29ee88922c46e153.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*7M_wHiZiZA6BhxqWQGXwMw.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated"><a class="ae ls" href="https://datatuts.com/svm-parameter-tuning/" rel="noopener ugc nofollow" target="_blank">数字来源</a></p></figure><p id="6f7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着灰度系数的降低，分隔不同类别的区域变得更加一般化。非常大的 gamma 值会导致太特定的类别区域(过度拟合)。</p><h1 id="1fb9" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">伽玛与 C 参数</strong></h1><p id="970b" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">对于线性核，我们只需要优化 c 参数。然而，如果我们想要使用 RBF 核，则需要同时优化 c 和γ参数。如果γ很大，c 的影响可以忽略不计。如果 gamma 很小，c 对模型的影响就像它对线性模型的影响一样。c 和γ的典型值如下。然而，根据应用可能存在特定的最佳值:</p><p id="a78a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">0.0001 &lt; gamma &lt; 10</p><p id="d53a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">0.1 &lt; c &lt; 100</p><blockquote class="nk nl nm"><p id="a929" class="ki kj nn kk b kl km ju kn ko kp jx kq no ks kt ku np kw kx ky nq la lb lc ld im bi translated"><strong class="kk iu">对于 SVM 来说，记住输入数据需要归一化以使要素具有相同的比例和兼容性是非常重要的。</strong></p></blockquote><h1 id="1aa5" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">SVM 的利与弊</strong></h1><p id="0169" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">优点:</p><ul class=""><li id="822d" class="mr ms it kk b kl km ko kp kr mt kv mu kz mv ld mw mx my mz bi translated">在维数大于样本数的情况下有效</li><li id="1b7a" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated">当找到决策边界时，它使用训练点的子集而不是所有点，因此它是内存高效的</li><li id="7dc6" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated">多才多艺，它提供了不同类型的内核函数，也可以创建自定义的内核函数</li></ul><p id="d3e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">缺点:</p><ul class=""><li id="8ead" class="mr ms it kk b kl km ko kp kr mt kv mu kz mv ld mw mx my mz bi translated">需要小心规范化</li><li id="6293" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated">难以理解预测背后的逻辑</li><li id="ed8b" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated">当我们拥有大型数据集时，训练时间会增加，这会对性能产生负面影响</li></ul><h1 id="17be" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">sci kit-学习示例</strong></h1><p id="8f5e" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">我想通过一个简单的案例来展示语法和应该遵循的步骤。让我们从导入我们需要的库开始:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6f911c8167477b459c4c928272331711.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*iySJZ4r8biQ7HDjRm_xt9A.png"/></div></figure><p id="5ae7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Scikit-learn 还提供实践数据集。乳腺癌数据集适合我们的任务:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/9c0b699e96dae8328ed271398983684e.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*LmfukOFNxaacvabQWxs2-Q.png"/></div></figure><p id="4c11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要使用 scikit-learn 的<strong class="kk iu"> train_test_split </strong>函数来拆分用于训练和测试的数据集。然后，我使用线性核创建用于分类的支持向量机对象，并使用训练数据集对其进行训练:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/a382bc5e9ef16b6e1e6c80a8c881b27d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rk5D2mUhd09ArcRrKGxfog.png"/></div></div></figure><p id="a68a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用我们训练的模型，我们可以预测测试数据集中的目标变量，并测量模型的准确性:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/2c5245d94e830ca58a387a12e0ce70fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*indAeiqF48_MUh3LrrctUw.png"/></div></figure><p id="77d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">95%是一个相当不错的准确率，但是对于分类任务，还有另外两个衡量标准:<strong class="kk iu">精度</strong>和<strong class="kk iu">召回</strong>。这些术语非常重要，可以成为另一篇文章的主题。事实上，它们在谷歌的<a class="ae ls" href="https://developers.google.com/machine-learning/crash-course/classification/precision-and-recall" rel="noopener ugc nofollow" target="_blank">机器学习速成班</a>中有明确的解释。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/0d271376faa5d8adc200840af45c0e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*tD1ZduQFkLwxMolVTSOesw.png"/></div></figure><p id="a437" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个简单的线性可分的任务。对于不可线性分离的情况，我们可以使用 SVC 的核参数(即 kernel = 'rbf ')来使用核。我没有指定 c 参数，所以使用了默认值(c=1)。为了找到最佳参数，我们可以使用 scikit-learn 的<strong class="kk iu"> GridSearchCV() </strong>函数。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="8b01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p><h1 id="4bbb" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">我的其他帖子</h1><ul class=""><li id="4af6" class="mr ms it kk b kl mm ko mn kr oh kv oi kz oj ld mw mx my mz bi translated"><a class="ae ls" rel="noopener" target="_blank" href="/decision-tree-and-random-forest-explained-8d20ddabc9dd">决策树和随机森林—解释</a></li><li id="afae" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><a class="ae ls" rel="noopener" target="_blank" href="/naive-bayes-classifier-explained-50f9723571ed">朴素贝叶斯分类器—解释</a></li><li id="6290" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><a class="ae ls" rel="noopener" target="_blank" href="/handling-missing-values-with-pandas-b876bf6f008f">用熊猫处理缺失值</a></li><li id="0043" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><a class="ae ls" rel="noopener" target="_blank" href="/predicting-used-car-prices-with-machine-learning-fea53811b1ab">用机器学习预测二手车价格</a></li><li id="97e0" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><a class="ae ls" rel="noopener" target="_blank" href="/data-cleaning-and-analysis-with-a-bonus-story-36b3ae39564c">数据清理和分析，附带奖励故事</a></li></ul><h1 id="b63a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">参考</h1><ul class=""><li id="ead8" class="mr ms it kk b kl mm ko mn kr oh kv oi kz oj ld mw mx my mz bi translated"><a class="ae ls" href="https://datafreakankur.com/machine-learning-kernel-functions-3d-visualization/" rel="noopener ugc nofollow" target="_blank">https://datafrakankur . com/machine-learning-kernel-functions-3d-visualization/</a></li><li id="0b7b" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><a class="ae ls" href="https://www.sciencedirect.com/science/article/pii/B9780128113189000272" rel="noopener ugc nofollow" target="_blank">https://www . science direct . com/science/article/pii/b 9780128113189000272</a></li><li id="6a69" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><a class="ae ls" href="https://datatuts.com/svm-parameter-tuning/" rel="noopener ugc nofollow" target="_blank">https://datatuts.com/svm-parameter-tuning/</a></li><li id="c280" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><a class="ae ls" href="https://jakevdp.github.io/PythonDataScienceHandbook/05.07-support-vector-machines.html" rel="noopener ugc nofollow" target="_blank">https://jakevdp . github . io/python datascience handbook/05.07-support-vector-machines . html</a></li></ul></div></div>    
</body>
</html>