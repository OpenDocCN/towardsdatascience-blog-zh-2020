<html>
<head>
<title>What I realized after solving 100 leetcode SQL questions…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决 100 个 leetcode SQL 问题后的感悟…</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-questions-summary-df90bfe4c9c?source=collection_archive---------3-----------------------#2020-06-23">https://towardsdatascience.com/sql-questions-summary-df90bfe4c9c?source=collection_archive---------3-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fdba" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">艰难的教训，真正的秘诀</h2><div class=""/><div class=""><h2 id="e021" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">只有三种问题。他们是…</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/cb127ab6386737019a368fcefb18b210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*idn3xxgzC4PSFKkj"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">塞巴斯蒂安·科曼摄影在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="2456" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">简介:</h2><p id="90c7" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">有很多文章教你如何编写查询。知道如何编写一个查询并不是真正困难的部分。难的是总是有多种方法可供选择，并且所有这些方法都需要查询的组合。将问题分类，有助于我们识别模式，并对我们可以使用的查询类型建立更好的直觉。</p><p id="60aa" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">基本上有 3 种类型的 SQL 问题。这三类问题的原始形式非常简单。然而，它们可以通过混合搭配 3 样东西来升级。分别是<em class="nb">时间约束</em>、<em class="nb">计算要求</em>、<em class="nb">比较/排序要求</em>。我将用例子向你说明我的意思。先说清楚最基本的形态。</p><h2 id="2f87" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">所有 SQL 问题都可以归结为以下三种类型:</h2><blockquote class="nc nd ne"><p id="61ba" class="md me nb mf b mg mw kd mi mj mx kg ml nf my mn mo ng mz mq mr nh na mt mu mv im bi translated">类型 1:全选</p><p id="bee5" class="md me nb mf b mg mw kd mi mj mx kg ml nf my mn mo ng mz mq mr nh na mt mu mv im bi translated">类型 2:选择做了 X 的组</p><p id="df4a" class="md me nb mf b mg mw kd mi mj mx kg ml nf my mn mo ng mz mq mr nh na mt mu mv im bi translated">类型 3:选择没有做 X 的组</p></blockquote><p id="65f6" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">正如您将看到的，类型 1 问题基本上是测试我们使用不同类型连接的能力。第二类和第三类问题都在测试我们准确识别满足特定约束的特殊群体的能力。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/bc0e3272c089a90fd2b2b132f65ad9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*eg4laWCtr_JmlyiIZ5W-pw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nj"><img src="../Images/ad0eea58ad2820ebc306970b211d982c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6uZ8lcu5-7_sVM58QU_Jow.png"/></div></div></figure><p id="58f4" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">区分类型 2 和类型 3 是很重要的。类型 2 只需要一个带有<strong class="mf jd"> where </strong>语句的步骤。类型 3 需要两个步骤的方法。首先，我们需要用<strong class="mf jd"> where </strong>语句来标识特殊组。其次，我们需要使用中的<strong class="mf jd"> not 来排除<strong class="mf jd"> where </strong>语句中的那个组。</strong></p><p id="690f" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">原因是，如果我们直接选择所有不是绿色的，那么红色和绿色的样本仍然会被选择。我将在下面提供例子，这将变得更加清楚。正如您将看到的，第三类问题可能会比第二类问题复杂得多。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="cca7" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">类型 1:全选</p><ul class=""><li id="ca0c" class="nr ns it mf b mg mw mj mx lr nt lv nu lz nv mv nw nx ny nz bi translated">简易版:1 种联接</li><li id="4662" class="nr ns it mf b mg oa mj ob lr oc lv od lz oe mv nw nx ny nz bi translated">硬版本:多种不同类型的连接</li></ul><p id="a73a" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">类型 2:选择做了 X/met X 描述的组</p><ul class=""><li id="9792" class="nr ns it mf b mg mw mj mx lr nt lv nu lz nv mv nw nx ny nz bi translated">简单版本:“在哪里”语句</li><li id="2964" class="nr ns it mf b mg oa mj ob lr oc lv od lz oe mv nw nx ny nz bi translated">更难的版本:查找重复，查找唯一，查找连续</li></ul><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="a138" class="li lj it og b gy ok ol l om on">Several friends at a cinema ticket office would like to reserve consecutive available seats.Can you help to query all the consecutive available seats order by the seat_id?</span><span id="ec69" class="li lj it og b gy oo ol l om on">| seat_id | free |  <br/>|---------|------|<br/>| 1       | 1    |<br/>| 2       | 0    |<br/>| 3       | 1    |<br/>| 4       | 1    | <br/>| 5       | 1    |</span></pre><p id="ee56" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">类型 3:选择没有做 X/met X 描述的组</p><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="3e77" class="li lj it og b gy ok ol l om on">Write an SQL query that reports the <strong class="og jd">buyers</strong> who have bought <em class="nb">S8</em> but not <em class="nb">iPhone</em>. </span><span id="e4a4" class="li lj it og b gy oo ol l om on">Product table:<br/>+------------+--------------+------------+<br/>| product_id | product_name | unit_price |<br/>+------------+--------------+------------+<br/>| 1          | S8           | 1000       |<br/>| 2          | G4           | 800        |<br/>| 3          | iPhone       | 1400       |<br/>+------------+--------------+------------+<br/><br/>Sales <!-- -->table:<br/>+------------+----------+------------+----------+-------+<br/>| product_id | buyer_id | sale_date  | quantity | price |<br/>+------------+----------+------------+----------+-------+<br/>| 1          | 1        | 2019-01-21 | 2        | 2000  |<br/>| 1          | 2        | 2019-02-17 | 1        | 800   |<br/>| 2          | 3        | 2019-06-02 | 1        | 800   |<br/>| 3          | 2        | 2019-05-13 | 2        | 2800  |<br/>+------------+----------+------------+----------+-------+</span></pre><p id="ea96" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">请注意，买家 2 同时购买了<em class="nb"> S8 </em>和<em class="nb"> iPhone </em>，它们是两个独立的样品<em class="nb">。</em>因此，这个问题必须分两步解决。首先确定购买了<em class="nb"> iPhone </em>的买家，然后选择不在购买了<em class="nb"> iPhone </em>的买家中的 buyer_id。</p><h2 id="b84a" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">级别 1:时间限制</h2><p id="0a45" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">处理时间格式要求我们熟悉处理时间的查询。然而，在这个阶段，逻辑是大同小异的。当它和其他两个东西结合在一起的时候就变得很难了。它经常与一些计算要求结合在一起。</p><ul class=""><li id="e8cf" class="nr ns it mf b mg mw mj mx lr nt lv nu lz nv mv nw nx ny nz bi translated">简单版:选择一个特殊的时间框架</li></ul><p id="c35f" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">因为我们选择了一个特殊的时间框架，我们正在创建一个特殊的群体。所以这些问题要么是 2 型，要么是 3 型。</p><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="c51b" class="li lj it og b gy ok ol l om on">Write an SQL query that reports the <strong class="og jd">products</strong> that were <strong class="og jd">only</strong> sold in spring 2019. That is, between <strong class="og jd">2019-01-01</strong> and <strong class="og jd">2019-03-31</strong> inclusive.</span></pre><ul class=""><li id="ce41" class="nr ns it mf b mg mw mj mx lr nt lv nu lz nv mv nw nx ny nz bi translated">硬版:选择某件事的第一次或最晚时间。</li></ul><p id="c552" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">当谈到选择第一个或最新的东西时，我把它们归类为第一类问题。原因是我们需要不重复地考虑所有的信息，然后从中选择最好的。</p><p id="ad8a" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">难的是日期信息通常不是主键。因此，需要花费一些努力来确保我们想要的日期与相应的项目相匹配。请参见下面的示例。</p><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="5b99" class="li lj it og b gy ok ol l om on">Write a SQL query that reports the <strong class="og jd">device</strong> that is first logged in for each player.<br/><br/>+-----------+-----------+------------+--------------+<br/>| player_id | device_id | event_date | games_played |<br/>+-----------+-----------+------------+--------------+<br/>| 1         | 2         | 2016-05-28 | 5            |<br/>| 1         | 5         | 2016-05-02 | 6            |<br/>| 2         | 3         | 2017-06-25 | 1            |<br/>| 3         | 1         | 2016-03-02 | 0            |<br/>| 3         | 4         | 2018-07-03 | 5            |<br/>+-----------+-----------+------------+--------------+</span></pre><p id="f51a" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">当我们选择<strong class="mf jd"> min(event_date) </strong>时，该日期是最早的日期，但它不会匹配相应的设备 id，因为 nor event_date 或 device_id 都不是主键。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h2 id="474e" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">第二级:计算要求</h2><p id="001e" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">最常见的计算是计数/总和/平均值/ctr。当第二类或第三类问题涉及计算时，我们经常需要在标记一些样本时使用<strong class="mf jd"> case。对于 1 型题中的计算，多是代入公式。</strong></p><p id="aa27" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">期望的输出可以分为两类。第一个类别的输出是一个数字。第二个类别以表格的形式输出。计算是按用户/日期/会话进行的。</p><ol class=""><li id="753d" class="nr ns it mf b mg mw mj mx lr nt lv nu lz nv mv op nx ny nz bi translated">以数字表示的结果</li></ol><ul class=""><li id="5906" class="nr ns it mf b mg mw mj mx lr nt lv nu lz nv mv nw nx ny nz bi translated">简易版:</li></ul><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="8b77" class="li lj it og b gy ok ol l om on">Type 2: Write an SQL query to find the average for daily percentage of posts that got removed after being reported as spam, <strong class="og jd">rounded to 2 decimal places</strong>.</span><span id="3824" class="li lj it og b gy oo ol l om on">Actions table:<br/>+---------+---------+-------------+--------+--------+<br/>| user_id | post_id | action_date | action | extra  |<br/>+---------+---------+-------------+--------+--------+<br/>| 1       | 1       | 2019-07-01  | view   | null   |<br/>| 1       | 1       | 2019-07-01  | like   | null   |<br/>| 1       | 1       | 2019-07-01  | share  | null   |<br/>| 2       | 2       | 2019-07-04  | view   | null   |<br/>| 2       | 2       | 2019-07-04  | report | spam   |<br/>| 3       | 4       | 2019-07-04  | view   | null   |<br/>| 3       | 4       | 2019-07-04  | report | spam   |<br/>| 4       | 3       | 2019-07-02  | view   | null   |<br/>| 4       | 3       | 2019-07-02  | report | spam   |<br/>| 5       | 2       | 2019-07-03  | view   | null   |<br/>| 5       | 2       | 2019-07-03  | report | racism |<br/>| 5       | 5       | 2019-07-03  | view   | null   |<br/>| 5       | 5       | 2019-07-03  | report | racism |<br/>+---------+---------+-------------+--------+--------+<br/><br/>Removals table:<br/>+---------+-------------+<br/>| post_id | remove_date |<br/>+---------+-------------+<br/>| 2       | 2019-07-20  |<br/>| 3       | 2019-07-18  |<br/>+---------+-------------+<br/><br/>Result table:<br/>+-----------------------+<br/>| average_daily_percent |<br/>+-----------------------+<br/>| 75.00                 |<br/>+-----------------------+</span></pre><p id="cfe9" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">因为这是一个类型 2 的问题，我们首先需要确定一个特殊的组——被删除的帖子。然后，我们将一个组标记为“1 ”,另一个组标记为“0 ”,以执行计算。</p><ul class=""><li id="7211" class="nr ns it mf b mg mw mj mx lr nt lv nu lz nv mv nw nx ny nz bi translated">更难的版本:结合<em class="nb">时间限制。</em></li></ul><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="5349" class="li lj it og b gy ok ol l om on">Type 1: Write an SQL query to find the average number of sessions per user for a period of 30 days ending <strong class="og jd">2019-07-27</strong> inclusively, <strong class="og jd">rounded to 2 decimal places</strong>. The sessions we want to count for a user are those with at least one activity in that time period.</span><span id="3a30" class="li lj it og b gy oo ol l om on">Activity table:<br/>+---------+------------+---------------+---------------+<br/>| user_id | session_id | activity_date | activity_type |<br/>+---------+------------+---------------+---------------+<br/>| 1       | 1          | 2019-07-20    | open_session  |<br/>| 1       | 1          | 2019-07-20    | scroll_down   |<br/>| 1       | 1          | 2019-07-20    | end_session   |<br/>| 2       | 4          | 2019-07-20    | open_session  |<br/>| 2       | 4          | 2019-07-21    | send_message  |<br/>| 2       | 4          | 2019-07-21    | end_session   |<br/>| 3       | 2          | 2019-07-21    | open_session  |<br/>| 3       | 2          | 2019-07-21    | send_message  |<br/>| 3       | 2          | 2019-07-21    | end_session   |<br/>| 3       | 5          | 2019-07-21    | open_session  |<br/>| 3       | 5          | 2019-07-21    | scroll_down   |<br/>| 3       | 5          | 2019-07-21    | end_session   |<br/>| 4       | 3          | 2019-06-25    | open_session  |<br/>| 4       | 3          | 2019-06-25    | end_session   |<br/>+---------+------------+---------------+---------------+<br/><br/>Result table:<br/>+---------------------------+ <br/>| average_sessions_per_user |<br/>+---------------------------+ <br/>| 1.33                      |<br/>+---------------------------+</span></pre><p id="c751" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">这是一个类型 2 <em class="nb">时间约束</em>问题<em class="nb">和计算要求</em>。我们需要选择正确的时间段，然后执行计算</p><p id="8896" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">2.以表格形式输出</p><ul class=""><li id="9326" class="nr ns it mf b mg mw mj mx lr nt lv nu lz nv mv nw nx ny nz bi translated">更简单的版本:</li></ul><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="db65" class="li lj it og b gy ok ol l om on">Type 2: Write an SQL query to find the <!-- -->ctr<!-- --> of each Ad.<strong class="og jd">Round</strong> <!-- -->ctr<!-- --> to 2 decimal points. <strong class="og jd">Order</strong> the result table by <!-- -->ctr<!-- --> in descending order and by <!-- -->ad_id<!-- --> in ascending order in case of a tie.</span><span id="acaf" class="li lj it og b gy oo ol l om on">Ads table:<br/>+-------+---------+---------+<br/>| ad_id | user_id | action  |<br/>+-------+---------+---------+<br/>| 1     | 1       | Clicked |<br/>| 2     | 2       | Clicked |<br/>| 3     | 3       | Viewed  |<br/>| 5     | 5       | Ignored |<br/>| 1     | 7       | Ignored |<br/>| 2     | 7       | Viewed  |<br/>| 3     | 5       | Clicked |<br/>| 1     | 4       | Viewed  |<br/>| 2     | 11      | Viewed  |<br/>| 1     | 2       | Clicked |<br/>+-------+---------+---------+<br/>Result table:<br/>+-------+-------+<br/>| ad_id | ctr   |<br/>+-------+-------+<br/>| 1     | 66.67 |<br/>| 3     | 50.00 |<br/>| 2     | 33.33 |<br/>| 5     | 0.00  |<br/>+-------+-------+</span></pre><p id="ee6b" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">这是一个 2 型问题，因为要计算 CTR。CTR 要求我们在执行任何计算之前，将“点击”作为一组，将“浏览”作为另一组。逻辑上没有什么新东西。我们首先选择这些特殊的组，然后应用计算。</p><p id="3af2" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">然而，对于这个特殊的问题，它强调了一个事实，即我们需要小心将 0 作为计算中的分母。当这种情况发生时，我们通常需要分别处理那个样本，然后再与其他样本结合。</p><ul class=""><li id="170f" class="nr ns it mf b mg mw mj mx lr nt lv nu lz nv mv nw nx ny nz bi translated">更难的版本:多个表或有<em class="nb">时间限制</em>。</li></ul><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="dc8e" class="li lj it og b gy ok ol l om on">Type 1: Write an SQL query to find the number of times each student attended each exams. Order the result table by <!-- -->student_id<!-- --> and <!-- -->subject_name<!-- -->.</span><span id="5f57" class="li lj it og b gy oo ol l om on">Students table:<br/>+------------+--------------+<br/>| student_id | student_name |<br/>+------------+--------------+<br/>| 1          | Alice        |<br/>| 2          | Bob          |<br/>| 13         | John         |<br/>| 6          | Alex         |<br/>+------------+--------------+<br/>Subjects table:<br/>+--------------+<br/>| subject_name |<br/>+--------------+<br/>| Math         |<br/>| Physics      |<br/>| Programming  |<br/>+--------------+<br/>Examinations table:<br/>+------------+--------------+<br/>| student_id | subject_name |<br/>+------------+--------------+<br/>| 1          | Math         |<br/>| 1          | Physics      |<br/>| 1          | Programming  |<br/>| 2          | Programming  |<br/>| 1          | Physics      |<br/>| 1          | Math         |<br/>| 13         | Math         |<br/>| 13         | Programming  |<br/>| 13         | Physics      |<br/>| 2          | Math         |<br/>| 1          | Math         |<br/>+------------+--------------+<br/>Result table:<br/>+------------+--------------+--------------+----------------+<br/>| student_id | student_name | subject_name | attended_exams |<br/>+------------+--------------+--------------+----------------+<br/>| 1          | Alice        | Math         | 3              |<br/>| 1          | Alice        | Physics      | 2              |<br/>| 1          | Alice        | Programming  | 1              |<br/>| 2          | Bob          | Math         | 1              |<br/>| 2          | Bob          | Physics      | 0              |<br/>| 2          | Bob          | Programming  | 1              |<br/>| 6          | Alex         | Math         | 0              |<br/>| 6          | Alex         | Physics      | 0              |<br/>| 6          | Alex         | Programming  | 0              |<br/>| 13         | John         | Math         | 1              |<br/>| 13         | John         | Physics      | 1              |<br/>| 13         | John         | Programming  | 1              |<br/>+------------+--------------+--------------+----------------+</span></pre><p id="1b84" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">这是一个 1 型问题。因此，本质上，它是在测试我们对不同类型的连接的理解。对于上面的问题，我用<strong class="mf jd">交叉连接</strong>和<strong class="mf jd">左连接</strong>来解决。这是一个更难的问题，因为信息分散在 3 个表中。当我们将多个表连接在一起时，很难避免重复并包含所有信息。</p><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="1d49" class="li lj it og b gy ok ol l om on">Type 2: Write an SQL query to compute moving average of how much customer paid in a 7 days window (current day + 6 days before).</span><span id="c40b" class="li lj it og b gy oo ol l om on">Customer table:<br/>+-------------+--------------+--------------+-------------+<br/>| customer_id | name         | visited_on   | amount      |<br/>+-------------+--------------+--------------+-------------+<br/>| 1           | Jhon         | 2019-01-01   | 100         |<br/>| 2           | Daniel       | 2019-01-02   | 110         |<br/>| 3           | Jade         | 2019-01-03   | 120         |<br/>| 4           | Khaled       | 2019-01-04   | 130         |<br/>| 5           | Winston      | 2019-01-05   | 110         | <br/>| 6           | Elvis        | 2019-01-06   | 140         | <br/>| 7           | Anna         | 2019-01-07   | 150         |<br/>| 8           | Maria        | 2019-01-08   | 80          |<br/>| 9           | Jaze         | 2019-01-09   | 110         | <br/>| 1           | Jhon         | 2019-01-10   | 130         | <br/>| 3           | Jade         | 2019-01-10   | 150         | <br/>+-------------+--------------+--------------+-------------+<br/><br/>Result table:<br/>+--------------+--------------+----------------+<br/>| visited_on   | amount       | average_amount |<br/>+--------------+--------------+----------------+<br/>| 2019-01-07   | 860          | 122.86         |<br/>| 2019-01-08   | 840          | 120            |<br/>| 2019-01-09   | 840          | 120            |<br/>| 2019-01-10   | 1000         | 142.86         |<br/>+--------------+--------------+----------------+</span></pre><p id="57a7" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">这是一个有<em class="nb">时间限制</em>的类型 2 问题。因此，我们首先需要根据时间限制来组织表格。然后我们应用函数来计算。困难的部分是我们需要熟悉处理时间的查询。对于这个问题，我使用了<strong class="mf jd"> lag() over(order by) </strong>和<strong class="mf jd">sum(s _ amount)over(order by)</strong></p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h2 id="b82c" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">第 3 级:比较/排名要求</h2><p id="7410" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">说到比较/排名，往往是建立在<em class="nb">计算要求</em>之上的。对于类型 1 的问题，通常是考虑所有的样本，对它们进行排序，并选择最好的一个。对于第二类问题，通常是将样本分组并比较两组。对于 Type-3 的问题，往往是先做一个特殊的组，这就需要排位来这么做。然后我们选择所有具有或不具有该群体特征的东西。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/4d1b4467fc25558d2bb82671a3c9e09d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYWqqQn5FVrvCsSCpGD3rw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi or"><img src="../Images/316be7d51e7046b1de1145bc01b01904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*XKurWTHlLRX5WWoTPjDdpg.png"/></div></figure><p id="8d6f" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">类型 1:查找最高值、第 n 个最高值、第二个最高值</p><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="95d6" class="li lj it og b gy ok ol l om on">Write a SQL query to get the <em class="nb">n</em>th highest salary from the <!-- -->Employee<!-- --> table. If there is no <em class="nb">n</em>th highest salary, then the query should return <!-- -->null<!-- -->.</span><span id="5e6a" class="li lj it og b gy oo ol l om on">+----+--------+<br/>| Id | Salary |<br/>+----+--------+<br/>| 1  | 100    |<br/>| 2  | 200    |<br/>| 3  | 300    |<br/>+----+--------+</span><span id="7f38" class="li lj it og b gy oo ol l om on">+------------------------+<br/>| getNthHighestSalary(2) |<br/>+------------------------+<br/>| 200                    |<br/>+------------------------+</span></pre><p id="cc36" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">这是一个棘手的问题，因为它是一个函数，这在 SQL 中并不常见。然而，基本方法是相同的。这是一个类型 1 的问题，所以我们需要确保没有重复的样本。首先选择<strong class="mf jd"> distinct(salary) </strong>，使用<strong class="mf jd"> order_by </strong>进行排序，然后使用<strong class="mf jd"> offset </strong>和<strong class="mf jd"> fetch </strong>得到第二行。</p><p id="2985" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">第 2 类问题:一组的得分高于/高于/至少…</p><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="998a" class="li lj it og b gy ok ol l om on">Write a SQL query for a report that provides the pairs <!-- -->(actor_id, director_id)<!-- --> where the actor have cooperated with the director at least 3 times.</span><span id="3acf" class="li lj it og b gy oo ol l om on">ActorDirector table:<br/>+-------------+-------------+-------------+<br/>| actor_id    | director_id | timestamp   |<br/>+-------------+-------------+-------------+<br/>| 1           | 1           | 0           |<br/>| 1           | 1           | 1           |<br/>| 1           | 1           | 2           |<br/>| 1           | 2           | 3           |<br/>| 1           | 2           | 4           |<br/>| 2           | 1           | 5           |<br/>| 2           | 1           | 6           |<br/>+-------------+-------------+-------------+<br/><br/>Result table:<br/>+-------------+-------------+<br/>| actor_id    | director_id |<br/>+-------------+-------------+<br/>| 1           | 1           |<br/>+-------------+-------------+</span></pre><p id="19e5" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">我们首先使用<strong class="mf jd">精确地选择我们想要的组，其中</strong>或者有时<strong class="mf jd">首先使用</strong>。然后我们进行比较或者整理。</p><p id="800c" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">类型 3:选择前 3/n 个最高薪金</p><ul class=""><li id="ac12" class="nr ns it mf b mg mw mj mx lr nt lv nu lz nv mv nw nx ny nz bi translated">简易版:</li></ul><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="7dd0" class="li lj it og b gy ok ol l om on">Write a SQL query to find employees who have the highest salary in <strong class="og jd">each of the departments</strong>. For the above tables, your SQL query should return the following rows (order of rows does not matter) </span><span id="47e8" class="li lj it og b gy oo ol l om on">+----+-------+--------+--------------+<br/>| Id | Name  | Salary | DepartmentId |<br/>+----+-------+--------+--------------+<br/>| 1  | Joe   | 70000  | 1            |<br/>| 2  | Jim   | 90000  | 1            |<br/>| 3  | Henry | 80000  | 2            |<br/>| 4  | Sam   | 60000  | 2            |<br/>| 5  | Max   | 90000  | 1            |<br/>+----+-------+--------+--------------+</span><span id="250b" class="li lj it og b gy oo ol l om on">+----+----------+<br/>| Id | Name     |<br/>+----+----------+<br/>| 1  | IT       |<br/>| 2  | Sales    |<br/>+----+----------+</span><span id="ebe3" class="li lj it og b gy oo ol l om on">+------------+----------+--------+<br/>| Department | Employee | Salary |<br/>+------------+----------+--------+<br/>| IT         | Max      | 90000  |<br/>| IT         | Jim      | 90000  |<br/>| Sales      | Henry    | 80000  |<br/>+------------+----------+--------+</span><span id="c2db" class="li lj it og b gy oo ol l om on">Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no "holes" between ranks.</span><span id="5fcf" class="li lj it og b gy oo ol l om on">+----+-------+<br/>| Id | Score |<br/>+----+-------+<br/>| 1  | 3.50  |<br/>| 2  | 3.65  |<br/>| 3  | 4.00  |<br/>| 4  | 3.85  |<br/>| 5  | 4.00  |<br/>| 6  | 3.65  |<br/>+----+-------+</span><span id="dd95" class="li lj it og b gy oo ol l om on">Result:</span><span id="c0e1" class="li lj it og b gy oo ol l om on">+-------+---------+<br/>| score | Rank    |<br/>+-------+---------+<br/>| 4.00  | 1       |<br/>| 4.00  | 1       |<br/>| 3.85  | 2       |<br/>| 3.65  | 3       |<br/>| 3.65  | 3       |<br/>| 3.50  | 4       |<br/>+-------+---------+</span></pre><p id="9465" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">这两个问题有一个共同的特点:你可以有两个或更多的样本共享一个等级。这两个问题很简单，因为你可以使用<strong class="mf jd"> dense_rank() </strong>。它允许相同的排名，从而节省了我们两步走的努力。</p><ul class=""><li id="a52b" class="nr ns it mf b mg mw mj mx lr nt lv nu lz nv mv nw nx ny nz bi translated">更硬的版本:</li></ul><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="076a" class="li lj it og b gy ok ol l om on">Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows (order of rows does not matter).</span><span id="b85e" class="li lj it og b gy oo ol l om on">+----+-------+--------+--------------+<br/>| Id | Name  | Salary | DepartmentId |<br/>+----+-------+--------+--------------+<br/>| 1  | Joe   | 85000  | 1            |<br/>| 2  | Henry | 80000  | 2            |<br/>| 3  | Sam   | 60000  | 2            |<br/>| 4  | Max   | 90000  | 1            |<br/>| 5  | Janet | 69000  | 1            |<br/>| 6  | Randy | 85000  | 1            |<br/>| 7  | Will  | 70000  | 1            |<br/>+----+-------+--------+--------------+</span><span id="d9a2" class="li lj it og b gy oo ol l om on">+----+----------+<br/>| Id | Name     |<br/>+----+----------+<br/>| 1  | IT       |<br/>| 2  | Sales    |<br/>+----+----------+</span><span id="711a" class="li lj it og b gy oo ol l om on">Result:<br/>+------------+----------+--------+<br/>| Department | Employee | Salary |<br/>+------------+----------+--------+<br/>| IT         | Max      | 90000  |<br/>| IT         | Randy    | 85000  |<br/>| IT         | Joe      | 85000  |<br/>| IT         | Will     | 70000  |<br/>| Sales      | Henry    | 80000  |<br/>| Sales      | Sam      | 60000  |<br/>+------------+----------+--------+</span></pre><p id="7c8b" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">这是一个困难的问题，因为我们有一个嵌套的逻辑。这就是我的意思。这是一个类型 3 的问题，所以我们需要使用两步法。首先，我们将每个部门的前 3 名员工组成一个小组。分别是 IT 部门 90000，85000，75000，销售部门 80000，60000。其次，我们选择所有具有其中一种薪水的样本。</p><p id="9e8b" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">为了选择一组我们想要的薪水，我们需要使用第二类逻辑:将两组分开并比较。在这个例子中，我们复制了一个表，这样我们就有两个相同的表并排在一起。从表 1 中，我们选择一个薪水，并将其与表 2 中的所有薪水进行比较。如果有 3 个以上的薪水比我们选择的薪水大，那么那个薪水一定不是前 3 名。</p><h2 id="4b18" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">级别 4:将所有需求和约束混合在一起</h2><p id="f53b" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">这里有两个问题的例子，这三个元素都在一起:<em class="nb">时间约束</em>、<em class="nb">计算要求</em>和<em class="nb">比较</em>。看看能不能分解组件解决！</p><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="901f" class="li lj it og b gy ok ol l om on">Average Calculation + Type-3 Comparision + Time: </span><span id="1ca9" class="li lj it og b gy oo ol l om on">Find the movie name with the <strong class="og jd"><em class="nb">highest average</em></strong> rating in <strong class="og jd">February 2020</strong>.In case of a tie, return lexicographically smaller movie name.</span><span id="ed58" class="li lj it og b gy oo ol l om on">Movies table:<br/>+-------------+--------------+<br/>| movie_id    |  title       |<br/>+-------------+--------------+<br/>| 1           | Avengers     |<br/>| 2           | Frozen 2     |<br/>| 3           | Joker        |<br/>+-------------+--------------+<br/><br/>Users table:<br/>+-------------+--------------+<br/>| user_id     |  name        |<br/>+-------------+--------------+<br/>| 1           | Daniel       |<br/>| 2           | Monica       |<br/>| 3           | Maria        |<br/>| 4           | James        |<br/>+-------------+--------------+<br/><br/>Movie_Rating table:<br/>+-------------+--------------+--------------+-------------+<br/>| movie_id    | user_id      | rating       | created_at  |<br/>+-------------+--------------+--------------+-------------+<br/>| 1           | 1            | 3            | 2020-01-12  |<br/>| 1           | 2            | 4            | 2020-02-11  |<br/>| 1           | 3            | 2            | 2020-02-12  |<br/>| 1           | 4            | 1            | 2020-01-01  |<br/>| 2           | 1            | 5            | 2020-02-17  | <br/>| 2           | 2            | 2            | 2020-02-01  | <br/>| 2           | 3            | 2            | 2020-03-01  |<br/>| 3           | 1            | 3            | 2020-02-22  | <br/>| 3           | 2            | 4            | 2020-02-25  | <br/>+-------------+--------------+--------------+-------------+<br/><br/>Result table:<br/>+--------------+<br/>| results      |<br/>+--------------+<br/>| Daniel       |<br/>| Frozen 2     |<br/>+--------------+</span><span id="af7e" class="li lj it og b gy oo ol l om on">Sum Calculation + Type-2 Comparison + Time: </span><span id="26c1" class="li lj it og b gy oo ol l om on">Write an SQL query that reports the <strong class="og jd">books</strong> that have sold <strong class="og jd">less than 10</strong> copies in the last year, excluding books that have been available for less than 1 month from today. <strong class="og jd">Assume today is 2019-06-23</strong>.</span><span id="509e" class="li lj it og b gy oo ol l om on">Books table:<br/>+---------+--------------------+----------------+<br/>| book_id | name               | available_from |<br/>+---------+--------------------+----------------+<br/>| 1       | "Kalila And Demna" | 2010-01-01     |<br/>| 2       | "28 Letters"       | 2012-05-12     |<br/>| 3       | "The Hobbit"       | 2019-06-10     |<br/>| 4       | "13 Reasons Why"   | 2019-06-01     |<br/>| 5       | "The Hunger Games" | 2008-09-21     |<br/>+---------+--------------------+----------------+<br/><br/>Orders table:<br/>+----------+---------+----------+---------------+<br/>| order_id | book_id | quantity | dispatch_date |<br/>+----------+---------+----------+---------------+<br/>| 1        | 1       | 2        | 2018-07-26    |<br/>| 2        | 1       | 1        | 2018-11-05    |<br/>| 3        | 3       | 8        | 2019-06-11    |<br/>| 4        | 4       | 6        | 2019-06-05    |<br/>| 5        | 4       | 5        | 2019-06-20    |<br/>| 6        | 5       | 9        | 2009-02-02    |<br/>| 7        | 5       | 8        | 2010-04-13    |<br/>+----------+---------+----------+---------------+<br/><br/>Result table:<br/>+-----------+--------------------+<br/>| book_id   | name               |<br/>+-----------+--------------------+<br/>| 1         | "Kalila And Demna" |<br/>| 2         | "28 Letters"       |<br/>| 5         | "The Hunger Games" |<br/>+-----------+--------------------+</span></pre><p id="c35d" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">这就是我如何把复杂的问题分解成组件。希望我的策略有帮助！</p></div></div>    
</body>
</html>