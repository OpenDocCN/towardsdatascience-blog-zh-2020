<html>
<head>
<title>Docker Best Practices for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的 Docker 最佳实践</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/docker-best-practices-for-data-scientists-2ed7f6876dff?source=collection_archive---------12-----------------------#2020-02-07">https://towardsdatascience.com/docker-best-practices-for-data-scientists-2ed7f6876dff?source=collection_archive---------12-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/acbab94ce762c42bb8e93510e382edad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXlrmEqm9BjvdS2qhoLrwQ.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">码头工人…鲸鱼…你懂的。</p></figure><p id="bd13" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">作为一名数据科学家，我每天都与 Docker 打交道。对我来说，创建图像、旋转容器已经变得和编写 Python 脚本一样普通。这个旅程有它的成就也有它的时刻，“我希望我以前就知道”。</p><p id="6db6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本文讨论了在数据科学项目中使用 Docker 时的一些最佳实践。这绝不是一份详尽的清单。但这涵盖了我作为数据科学家遇到的大多数事情。</p><p id="a98b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本文假设读者对 Docker 有基本到中等程度的了解。例如，你应该知道 Docker 是用来做什么的，应该能够轻松地编写 Docker 文件，并理解 Docker 命令，如<code class="fe ld le lf lg b">RUN</code>、<code class="fe ld le lf lg b">CMD</code>等。如果没有，通读这篇来自 Docker 官方网站的文章。你也可以浏览那里收集的文章。</p><h1 id="ab3b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">为什么是 Docker？</h1><p id="e309" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">自从《Docker》发行以来，它风靡了全世界。在 Docker 时代之前，虚拟机曾经填补了这一空白。但是 Docker 提供的不仅仅是虚拟机。</p><h1 id="f5bd" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">docker 的优势</h1><ul class=""><li id="67cf" class="ml mm it kh b ki mg km mh kq mn ku mo ky mp lc mq mr ms mt bi translated">隔离—隔离的环境，无论底层操作系统/基础架构、安装的软件、更新</li><li id="f087" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">轻量级—共享操作系统内核，避免每个容器都有操作系统内核</li><li id="0f74" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">性能——轻量级允许许多容器在同一个操作系统上同时运行</li></ul><h1 id="eeb7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">码头工人入门</h1><p id="ee58" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">Docker 有三个重要的概念。</p><p id="36be" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是一组可运行的库和二进制文件，代表了一个开发/生产/测试环境。您可以通过以下方式下载/创建映像。</p><ul class=""><li id="c6a7" class="ml mm it kh b ki kj km kn kq mz ku na ky nb lc mq mr ms mt bi translated">从图像注册表中提取:例如<code class="fe ld le lf lg b">docker pull alpine</code>。这里发生的是，Docker 将在本地计算机中查找名为<code class="fe ld le lf lg b">alpine</code>的图像，如果没有找到，它将在<a class="ae lh" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Dockerhub </a>中查找</li><li id="b5b9" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">使用 Dockerfile 文件在本地构建映像:例如<code class="fe ld le lf lg b">docker build . -t &lt;image_name&gt;:&lt;image_version&gt;</code>。在这里，您不是在尝试下载/拉取图像，而是在构建您自己的图像。但这并不完全正确，因为一个<code class="fe ld le lf lg b">Dockerfile</code>包含一个以<code class="fe ld le lf lg b">FROM &lt;base-image&gt;</code>开始的行，它寻找一个基础图像作为开始，这个基础图像可能是从 Dockerhub 中提取的。</li></ul><p id="7400" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">容器</strong>——这是一个图像的运行实例。你可以使用语法<code class="fe ld le lf lg b">`docker container run &lt;arguments&gt; &lt;image&gt; &lt;command&gt; </code>建立一个容器，例如从<code class="fe ld le lf lg b">alpine</code>图像使用，<code class="fe ld le lf lg b">docker container run -it alpine /bin/bash</code>命令创建一个容器。</p><p id="ae37" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">卷</strong> —卷用于永久/临时存储数据(如日志、下载的数据)供容器使用。此外，卷可以在多个容器之间共享。您可以通过多种方式使用卷。</p><ul class=""><li id="9d01" class="ml mm it kh b ki kj km kn kq mz ku na ky nb lc mq mr ms mt bi translated">创建卷:您可以使用<code class="fe ld le lf lg b">docker volume create &lt;volume_name&gt;</code>命令创建卷。<em class="nc">请注意，如果该卷被删除，存储在此处的信息/更改将会丢失。</em></li><li id="3278" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">绑定挂载一个卷:您还可以使用<code class="fe ld le lf lg b">-v &lt;source&gt;:&lt;target&gt;</code>语法将现有的卷从主机绑定挂载到您的容器。例如，如果您需要将<code class="fe ld le lf lg b">/my_data</code>卷作为<code class="fe ld le lf lg b">/data</code>卷安装到容器中，您可以执行<code class="fe ld le lf lg b">docker container run -it -v /my_data:/data alpine /bin/bash</code>命令。<em class="nc">您在装载点所做的更改将反映在主机上。</em></li></ul><h1 id="670e" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.创建图像</h1><h2 id="0f37" class="nd lj it bd lk ne nf dn lo ng nh dp ls kq ni nj lw ku nk nl ma ky nm nn me no bi translated">1.保持图像较小，避免缓存</h2><p id="2857" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">构建图像时，您必须做两件常见的事情，</p><ul class=""><li id="9290" class="ml mm it kh b ki kj km kn kq mz ku na ky nb lc mq mr ms mt bi translated">安装 Linux 软件包</li><li id="159c" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">安装 Python 库</li></ul><p id="f6c8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当安装这些包和库时，包管理器将缓存数据，这样如果你想再次安装它们，将使用本地数据。但是这不必要地增加了图像尺寸。docker 图像应该是尽可能轻量级的。</p><p id="4e11" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当安装 Linux 包时，记得通过添加最后一行到您的<code class="fe ld le lf lg b">apt-get install</code>命令来删除任何缓存的数据。</p><pre class="np nq nr ns gt nt lg nu nv aw nw bi"><span id="3f01" class="nd lj it lg b gy nx ny l nz oa">RUN apt-get update &amp;&amp; apt-get install tini &amp;&amp; \<br/> rm -rf /var/lib/apt/lists/*</span></pre><p id="ee3c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">安装 Python 包时，为了避免缓存，请执行以下操作。</p><pre class="np nq nr ns gt nt lg nu nv aw nw bi"><span id="a869" class="nd lj it lg b gy nx ny l nz oa">RUN pip3 install &lt;library-1&gt; &lt;library-2&gt; --no-cache-dir`</span></pre><h2 id="174d" class="nd lj it bd lk ne nf dn lo ng nh dp ls kq ni nj lw ku nk nl ma ky nm nn me no bi translated">2.将 Python 库分离到 requirements.txt 中</h2><p id="eea1" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">您看到的最后一个命令将我们带到了下一点。最好将 Python 库分离到一个<code class="fe ld le lf lg b">requirements.txt</code>文件中，并使用下面的语法使用该文件安装库。</p><p id="74d7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ld le lf lg b">RUN pip3 install -r requirements.txt --no-cache-dir</code></p><p id="2e4e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这很好地区分了 Dockerfile 做“Docker 的事情”和不(明确地)担心“Python 的事情”。此外，如果您有多个 docker 文件(例如用于生产/开发/测试),并且它们都希望安装相同的库，您可以轻松地重用该命令。<code class="fe ld le lf lg b">requirements.txt</code>文件只是一堆库名。</p><pre class="np nq nr ns gt nt lg nu nv aw nw bi"><span id="3f40" class="nd lj it lg b gy nx ny l nz oa">numpy==1.18.0<br/>scikit-learn==0.20.2<br/>pandas==0.25.0</span></pre><h2 id="01dd" class="nd lj it bd lk ne nf dn lo ng nh dp ls kq ni nj lw ku nk nl ma ky nm nn me no bi translated">3.修复库版本</h2><p id="436f" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">注意在<code class="fe ld le lf lg b">requirements.txt</code>中我是如何冻结我想要安装的版本的。这一点非常重要。因为否则，每次构建 Docker 映像时，您可能会安装不同东西的不同版本。<a class="ae lh" href="https://en.wikipedia.org/wiki/Dependency_hell" rel="noopener ugc nofollow" target="_blank">属地地狱</a>是真实的。</p><h1 id="5d0c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">运行容器</h1><h2 id="5628" class="nd lj it bd lk ne nf dn lo ng nh dp ls kq ni nj lw ku nk nl ma ky nm nn me no bi translated">1.拥抱非根用户</h2><p id="8874" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">当您运行容器时，如果您没有指定一个用户来运行，它将假定为<code class="fe ld le lf lg b">root</code>用户。我不想撒谎。我天真的自己曾经喜欢使用<code class="fe ld le lf lg b">sudo </code>或者<code class="fe ld le lf lg b">root</code>来按照我的方式做事(尤其是绕过许可)。但如果我学到了一件事，那就是拥有不必要的特权是一种恶化的催化剂，会导致更多的问题。</p><figure class="np nq nr ns gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a1d1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要以非根用户的身份运行容器，只需</p><ul class=""><li id="94d4" class="ml mm it kh b ki kj km kn kq mz ku na ky nb lc mq mr ms mt bi translated"><code class="fe ld le lf lg b">docker run -it -u &lt;user-id&gt;:&lt;group-id&gt; &lt;image-name&gt; &lt;command&gt;</code></li></ul><p id="2bdc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">或者，如果你想跳到一个已存在的容器中去，</p><ul class=""><li id="926a" class="ml mm it kh b ki kj km kn kq mz ku na ky nb lc mq mr ms mt bi translated"><code class="fe ld le lf lg b">docker exec -it -u &lt;user-id&gt;:&lt;group-id&gt; &lt;container-id&gt; &lt;command&gt;</code></li></ul><p id="479b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，您可以通过将<code class="fe ld le lf lg b">&lt;user-id&gt; </code>指定为<code class="fe ld le lf lg b">$(id -u)</code>并将<code class="fe ld le lf lg b">&lt;group-id&gt;</code>指定为<code class="fe ld le lf lg b">$(id -g)</code>来匹配主机的用户 id 和组 id。</p><blockquote class="od oe of"><p id="d8ea" class="kf kg nc kh b ki kj kk kl km kn ko kp og kr ks kt oh kv kw kx oi kz la lb lc im bi translated">注意不同的操作系统如何分配用户 id 和组 id。例如，您在 MacOS 上的用户 ID /组 ID 可能是 Ubuntu 容器中预先分配/保留的<strong class="kh iu">用户 ID/组 ID。</strong></p></blockquote><h2 id="c477" class="nd lj it bd lk ne nf dn lo ng nh dp ls kq ni nj lw ku nk nl ma ky nm nn me no bi translated">2.创建非特权用户</h2><p id="9fea" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">我们可以以非 root 用户的身份登录我们的主机——远离主机——这太棒了。但是如果你像这样登录，你就是一个没有用户名的用户。因为，显然容器不知道用户 id 来自哪里。每次你想把一个容器或<code class="fe ld le lf lg b">exec</code>变成一个容器时，你需要记住并输入这些用户 id 和组 id。因此，您可以将这个用户/组创建作为<code class="fe ld le lf lg b">Dockerfile</code>的一部分。</p><pre class="np nq nr ns gt nt lg nu nv aw nw bi"><span id="5080" class="nd lj it lg b gy nx ny l nz oa">ARG UID=1000<br/>ARG GID=1000</span></pre><ul class=""><li id="53e4" class="ml mm it kh b ki kj km kn kq mz ku na ky nb lc mq mr ms mt bi translated">首先在<code class="fe ld le lf lg b">Dockerfile</code>上增加<code class="fe ld le lf lg b">ARG UID=1000</code>和<code class="fe ld le lf lg b">ARG GID=1000</code>。<code class="fe ld le lf lg b">UID </code>和<code class="fe ld le lf lg b">GID</code>是容器中的环境变量，您将在<code class="fe ld le lf lg b">docker build</code>阶段向其传递值(默认为 1000)。</li><li id="a1ee" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">然后使用<code class="fe ld le lf lg b">RUN groupadd -g $GID john-group</code>在映像中添加一个组 ID 为<code class="fe ld le lf lg b">GID</code>的 Linux 组。</li><li id="fdc1" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">接下来，使用<code class="fe ld le lf lg b">useradd -N -l -u $UID -g john-group -G sudo john</code>在映像中添加一个用户 ID 为<code class="fe ld le lf lg b">UID</code>的 Linux 用户。您可以看到，我们正在将<code class="fe ld le lf lg b">john</code>添加到<code class="fe ld le lf lg b">sudo</code>组中。但这是可有可无的事情。如果你 100%确定你不需要<code class="fe ld le lf lg b">sudo</code>的许可，你可以省去它。</li></ul><p id="6e4b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后，在映像构建期间，您可以传递这些参数的值，例如，</p><ul class=""><li id="131a" class="ml mm it kh b ki kj km kn kq mz ku na ky nb lc mq mr ms mt bi translated"><code class="fe ld le lf lg b">docker build &lt;build_dir&gt; -t &lt;image&gt;:&lt;image_tag&gt; --build-arg UID=&lt;uid-value&gt; --build-arg GID=&lt;gid-value&gt;</code></li></ul><p id="95e5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">举个例子，</p><ul class=""><li id="f3bf" class="ml mm it kh b ki kj km kn kq mz ku na ky nb lc mq mr ms mt bi translated"><code class="fe ld le lf lg b">docker build . -t docker-tut:latest --build-arg UID=$(id -u) --build-arg GID=$(id -g)</code></li></ul><p id="8904" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">拥有非特权用户有助于您运行不应该拥有 root 权限的进程。例如，当 Python 脚本所做的只是从一个目录(例如数据)读取和向一个目录(例如模型)写入时，为什么要以 root 用户身份运行它呢？还有一个额外的好处，如果您在容器中匹配主机的用户 ID 和组 ID，那么您创建的所有文件都将拥有您的主机用户的所有权。因此，如果您绑定装载这些文件(或创建新文件)，它们看起来仍像是您在主机上创建的。</p><h1 id="b10d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">创建卷</h1><h2 id="d380" class="nd lj it bd lk ne nf dn lo ng nh dp ls kq ni nj lw ku nk nl ma ky nm nn me no bi translated">1.使用卷分离工件</h2><p id="23a6" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">作为一名数据科学家，很明显你将与各种工件(例如数据、模型和代码)打交道。您可以将代码放在一个卷中(如<code class="fe ld le lf lg b">/app</code>)，将数据放在另一个卷中(如<code class="fe ld le lf lg b">/data</code>)。这将为您的 Docker 映像提供一个良好的结构，并消除任何主机级的工件依赖性。</p><p id="6642" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我说的工件依赖是什么意思？假设你在<code class="fe ld le lf lg b">/home/&lt;user&gt;/code/src</code>有代码，在<code class="fe ld le lf lg b">/home/&lt;user&gt;/code/data</code>有数据。如果将<code class="fe ld le lf lg b">/home/&lt;user&gt;/code/src</code>复制/挂载到卷<code class="fe ld le lf lg b">/app</code>并将<code class="fe ld le lf lg b">/home/&lt;user&gt;/code/data</code>复制/挂载到卷<code class="fe ld le lf lg b">/data</code>。如果代码和数据的位置在主机上发生变化，也没有关系。只要您挂载这些工件，它们将总是在 Docker 容器中的相同位置可用。因此，您可以在 Python 脚本中很好地修复这些路径，如下所示。</p><pre class="np nq nr ns gt nt lg nu nv aw nw bi"><span id="0a22" class="nd lj it lg b gy nx ny l nz oa">data_dir = "/data"<br/>model_dir = "/models"<br/>src_dir = "/app"</span></pre><p id="243e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可以使用<code class="fe ld le lf lg b">COPY</code>将必要的代码和数据放入图像</p><pre class="np nq nr ns gt nt lg nu nv aw nw bi"><span id="21a5" class="nd lj it lg b gy nx ny l nz oa">COPY test-data /data<br/>COPY test-code /app</span></pre><p id="066e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意<code class="fe ld le lf lg b">test-data</code>和<code class="fe ld le lf lg b">test-code</code>是主机上的目录。</p><h2 id="e39b" class="nd lj it bd lk ne nf dn lo ng nh dp ls kq ni nj lw ku nk nl ma ky nm nn me no bi translated">2.开发期间绑定安装目录</h2><p id="6d0f" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">关于绑定挂载的一个伟大之处在于，无论你在容器中做什么，都会被反射到主机上。当您正在进行开发并且想要调试您的项目时，这非常有用。让我们通过一个例子来看看这一点。</p><p id="3b71" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">假设您通过运行以下命令创建了 docker 映像:</p><p id="9b96" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ld le lf lg b">docker build &lt;build-dir&gt; &lt;image-name&gt;:&lt;image-version&gt;</code></p><p id="2378" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，您可以使用以下方式从该图像中建立一个容器:</p><p id="f925" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ld le lf lg b">docker run -it &lt;image-name&gt;:&lt;image-version&gt; -v /home/&lt;user&gt;/my_code:/code</code></p><p id="23e1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，您可以在容器中运行代码，同时进行调试，对代码的更改将反映在主机上。这又回到了在容器中使用相同的主机用户 ID 和组 ID 的好处。您所做的所有更改，看起来都来自主机上的用户。</p><h2 id="37b1" class="nd lj it bd lk ne nf dn lo ng nh dp ls kq ni nj lw ku nk nl ma ky nm nn me no bi translated">3.切勿绑定装载主机的关键目录</h2><p id="4286" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">有趣的故事！我曾经将我的机器的主目录挂载到一个 Docker 容器中，并设法更改了主目录的权限。不用说，我后来无法登录到系统，花了好几个小时来解决这个问题。因此，只装载需要的东西。</p><p id="3844" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，假设您有三个想要在开发期间挂载的目录:</p><ul class=""><li id="b14c" class="ml mm it kh b ki kj km kn kq mz ku na ky nb lc mq mr ms mt bi translated"><code class="fe ld le lf lg b">/home/&lt;user&gt;/my_data</code></li><li id="e2b4" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated"><code class="fe ld le lf lg b">/home/&lt;user&gt;/my_code</code></li><li id="28c7" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated"><code class="fe ld le lf lg b">/home/&lt;user&gt;/my_model</code></li></ul><p id="1812" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可能很想用一行代码安装<code class="fe ld le lf lg b">/home/&lt;user&gt;</code>。但是写三行代码来分别挂载这些单独的子目录绝对是值得的，因为这将为您节省几个小时(如果不是几天)的时间。</p><h1 id="7705" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">其他提示</h1><h2 id="98cd" class="nd lj it bd lk ne nf dn lo ng nh dp ls kq ni nj lw ku nk nl ma ky nm nn me no bi translated">1.知道添加和复制的区别</h2><p id="e880" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">你可能知道有两个 Docker 命令叫做<code class="fe ld le lf lg b">ADD</code>和<code class="fe ld le lf lg b">COPY</code>。有什么区别？</p><ul class=""><li id="4172" class="ml mm it kh b ki kj km kn kq mz ku na ky nb lc mq mr ms mt bi translated"><code class="fe ld le lf lg b">ADD</code>可用于从网址下载文件，使用时如，<code class="fe ld le lf lg b">ADD &lt;url&gt;</code></li><li id="e5ce" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated"><code class="fe ld le lf lg b">ADD</code>当给定一个压缩文件(如<code class="fe ld le lf lg b">tar.gz</code>)时，会将文件提取到所提供的位置。</li><li id="0b38" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated"><code class="fe ld le lf lg b">COPY</code>将给定的文件/文件夹复制到容器中的指定位置。</li></ul><h2 id="1ea5" class="nd lj it bd lk ne nf dn lo ng nh dp ls kq ni nj lw ku nk nl ma ky nm nn me no bi translated">2.入口点和 CMD 的区别</h2><p id="1b0f" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">我想到的一个很好的类比是，把<code class="fe ld le lf lg b">ENTRYPOINT</code>想象成一辆汽车，把<code class="fe ld le lf lg b">CMD</code>想象成汽车中的控制装置(例如加速器、刹车、方向盘)。它本身什么都不做，它只是一个容器，你可以在里面做你想做的事情。它只是等待您将任何传入的命令推送到容器中。</p><p id="1c4c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">命令<code class="fe ld le lf lg b">CMD</code>是容器中实际执行的内容。例如,<code class="fe ld le lf lg b">bash</code>会在你的容器中创建一个 shell，这样你就可以像在 Ubuntu 的普通终端上工作一样在容器中工作。</p><h2 id="511f" class="nd lj it bd lk ne nf dn lo ng nh dp ls kq ni nj lw ku nk nl ma ky nm nn me no bi translated">3.将文件复制到现有容器</h2><p id="10f6" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">又来了！我已经创建了这个容器，但忘了将这个文件添加到图像中。建立图像需要很长时间。有没有什么方法可以欺骗我并把它添加到现有的容器中？</p><p id="3645" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">是的，有，你可以使用<code class="fe ld le lf lg b">docker cp</code>命令。简单地做，</p><p id="ff52" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ld le lf lg b">docker cp &lt;src&gt; &lt;container&gt;:&lt;dest&gt;</code></p><p id="a7ce" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下一次你跳进容器时，你会在<code class="fe ld le lf lg b">&lt;dest&gt;</code>看到复制的文件。但是请记住，在构建时实际更改<code class="fe ld le lf lg b">Dockerfile</code>来复制必要的文件。</p><h1 id="9495" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">3.结论</h1><p id="da6a" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">太好了！这是所有的乡亲。我们讨论过，</p><ul class=""><li id="c360" class="ml mm it kh b ki kj km kn kq mz ku na ky nb lc mq mr ms mt bi translated">什么是 Docker 映像/容器/卷？</li><li id="bb34" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">如何写好 Dockerfile 文件</li><li id="21ef" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">如何以非根用户的身份启动容器</li><li id="0c5a" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">如何在 Docker 中进行正确的卷安装</li><li id="923f" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">以及使用<code class="fe ld le lf lg b">docker cp</code>拯救世界等额外提示</li></ul><p id="7b37" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在你应该有信心看着 Docker 的眼睛说“<em class="nc">你吓不倒我</em>”。玩笑归玩笑，知道你在 Docker 上做什么总是值得的。因为如果你不小心的话，你可能会使整个服务器瘫痪，并扰乱在同一台机器上工作的其他人的工作。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="e72a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你喜欢我分享的关于数据科学和机器学习的故事，考虑成为会员吧！</p><div class="oq or gp gr os ot"><a href="https://thushv89.medium.com/membership" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">通过我的推荐链接加入媒体</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">thushv89.medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph jz ot"/></div></div></a></div></div></div>    
</body>
</html>