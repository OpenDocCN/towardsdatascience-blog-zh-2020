<html>
<head>
<title>Implementing K-Nearest Neighbor Classification Algorithms Using DAX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用DAX实现K-最近邻分类算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-k-nearest-neighbor-classification-algorithms-using-dax-a52607b1a825?source=collection_archive---------44-----------------------#2020-06-04">https://towardsdatascience.com/implementing-k-nearest-neighbor-classification-algorithms-using-dax-a52607b1a825?source=collection_archive---------44-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="151e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带DAX的KNN算法</h2></div><p id="9d7f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文将介绍如何使用数据分析表达式(DAX)实现KNN(K近邻)分类。您可以在下图中看到彩色散点图，其中每个散点图代表一种产品。横轴代表销量，纵轴代表利润，剩下的7个白色三角形是待分类的测试数据。接下来，我将使用KNN算法对这些测试数据进行分类。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/8c2012754bd03f07e865abdb563b31da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hrsAS3F7wFUSRkGk"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">作者图片</p></figure><h1 id="d6e4" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">关于本文的数据集:</h1><p id="e059" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">训练数据集(部分):</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/5578c2b362e30beb61a40a428be58262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/0*jlGrbGjLC-PyCBKU"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">作者图片</p></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/7f4677429ee55f2232a870f2d1e7e104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/0*Sw7CzRsscPlsMUJ8"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">作者图片</p></figure><p id="7884" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试数据集:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="cd06" class="my lv it mu b gy mz na l nb nc">TestingDataSet = DataTable("_ID", STRING,  <br/>                "_Sales", INTEGER,<br/>                "_Profit",INTEGER  <br/>               ,{  <br/>                        {" ID501",15,23},  <br/>                        {" ID502",25,7},  <br/>                        {" ID503",45,3},  <br/>                        {" ID504",18,8},  <br/>                        {" ID505",56,9},<br/>                        {" ID506",60,-5},<br/>                        {" ID507",30,21}<br/>                }  <br/>           )</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/0146a2ee8546b471be6f6c57f51828a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/0*F82rbj21jbQCC-Oa"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">作者图片</p></figure><h1 id="0b61" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">让我们开始吧:</h1><p id="2998" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">首先，我们需要计算每个测试点和训练集的数据点之间的距离。我们可以用欧几里德距离公式计算如下:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/14a5f5b9aa64e969aa2e33cad08562d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/0*EPhDcEXvKLgfM0lY"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图片由<a class="ae nf" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><p id="7d9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在此之前，我采用的方法是将测试数据集作为主表，让它与训练数据集生成一个笛卡尔积，这样我们就可以针对每个测试点计算出它与所有训练集数据点之间的距离。另外，我们需要计算所有训练数据中哪些数据点是被划分为测试点的相邻点。这里我取K等于9，将数据集中距离测试点距离最小的前9个训练集数据进行标记，然后过滤掉没有标记的数据点。总之，执行以下代码来生成表:“合并数据集”:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="0dc3" class="my lv it mu b gy mz na l nb nc">MergeDataSet = <br/>VAR VT_1 = <br/>ADDCOLUMNS(<br/>    GENERATEALL('TestingDataSet','TrainingDataSet'),<br/>"DISTANCE",<br/>CEILING(<br/>    SQRT(('TestingDataSet'[_Sales]-'TrainingDataSet'[Sales])^2+<br/>    ('TestingDataSet'[_Profit]-'TrainingDataSet'[Profit])^2),<br/>0.01))<br/></span><span id="6e72" class="my lv it mu b gy ng na l nb nc">VAR VT_2 = <br/>ADDCOLUMNS(VT_1,<br/>    "IsKNN",<br/>    VAR K = 9<br/>    VAR v_id = 'TestingDataSet'[_ID]<br/>    return<br/>    IF(<br/>        rankx(<br/>            filter(VT_1,'TestingDataSet'[_ID] = v_id),<br/>                [DISTANCE],,ASC,Skip)&lt;=K,<br/>    "T","F"))<br/></span><span id="6fa2" class="my lv it mu b gy ng na l nb nc">VAR VT_3 = <br/>FILTER(VT_2,[IsKNN] = "T")<br/></span><span id="ae27" class="my lv it mu b gy ng na l nb nc">RETURN VT_3</span></pre><p id="f653" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果如下所示(部分):</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nh"><img src="../Images/45f049f70f0e4f01f3afe5d5e055f3f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZVh8_5icYX-MJWqk"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">作者图片</p></figure><p id="2f9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经确定了所有的邻居，是时候分析它们了。对于每个测试点，找到其所有邻居的类别中最多的，然后将类别分配给该测试点，根据多数投票完成分类，最终结果在名为“结果集”的表中返回:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="2c9f" class="my lv it mu b gy mz na l nb nc">ResultSet = <br/>VAR VT_4 = <br/>ADDCOLUMNS('MergeDataSet',<br/>    "_Class",<br/>    VAR CLASSNUM_MAX = <br/>    CALCULATE(<br/>        MAXX('MergeDataSet',<br/>            CALCULATE(<br/>                COUNT('MergeDataSet'[Class]),<br/>                    ALLEXCEPT('MergeDataSet',<br/>                        'MergeDataSet'[_Profit],<br/>                        'MergeDataSet'[Class]))),<br/>        ALLEXCEPT('MergeDataSet','MergeDataSet'[_ID]))<br/>    RETURN<br/>    IF( CLASSNUM_MAX = CALCULATE( COUNT('MergeDataSet'[Class]),<br/>                ALLEXCEPT('MergeDataSet', 'MergeDataSet'[_Profit], 'MergeDataSet'[Class])),<br/>        CALCULATE( FIRSTNONBLANK('MergeDataSet'[Class],1),<br/>            ALLEXCEPT('MergeDataSet', 'MergeDataSet'[_ID], 'MergeDataSet'[Class])<br/>        )))<br/></span><span id="7273" class="my lv it mu b gy ng na l nb nc">VAR VT_5 = <br/>CALCULATETABLE( <br/>    GROUPBY(<br/>        FILTER(VT_4,[_Class]&lt;&gt;BLANK()),<br/>        'MergeDataSet'[_ID],<br/>        'MergeDataSet'[_Profit],<br/>        'MergeDataSet'[_Sales],<br/>        [_Class],<br/>        "Distance",<br/>        SUMX(CURRENTGROUP(),'MergeDataSet'[DISTANCE])<br/>))<br/></span><span id="9656" class="my lv it mu b gy ng na l nb nc">RETURN VT_5</span></pre><p id="1959" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">执行的结果如下，“__Class”是K个最近邻的分类结果:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ni"><img src="../Images/e46b2a8cca4de0fc29d24a0504164c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*raBYaFxH1OmsnR5v"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">作者图片</p></figure><p id="094d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能会发现，结果集中有一列没有出现在最后一个公式中:“KNN _结果”(带绿色标记)。这是因为我们还需要考虑一种特殊情况(虽然在这种情况下没有出现):如果测试点有相同数量的A类邻居和B类邻居，那么测试点应该属于哪个类？这里，通过比较所有A类和B类点离测试点的实际距离，然后选择距离值较小的类别。因此，使用以下公式创建一个名为“KNN _结果”的新计算列，以便我们在遇到这种特殊情况时可以通过筛选空行来实现这一点:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="0d20" class="my lv it mu b gy mz na l nb nc">KNN_Result = <br/>VAR Class_ = <br/>CALCULATE(<br/>    MIN('ResultSet'[Distance]),<br/>    ALLEXCEPT('ResultSet','ResultSet'[MergeDataSet__ID]))<br/>RETURN<br/>IF(<br/>class_ = 'ResultSet'[Distance],<br/>'ResultSet'[_Class],<br/>BLANK())</span></pre><p id="e7c5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们使用DAX成功完成了KNN分类，如下所示:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nj"><img src="../Images/b1092411d155c201619293760bf95b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C5UeJhpWSW3-9zUf"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">作者图片</p></figure><p id="2273" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nk">(我相信DAX有能力实现一些简单的机器学习算法，而不是什么都依赖R或者PYTHON。如果你有更好的方法来使用DAX或M实现KNN，我希望得到你的反馈。)</em></p><p id="9286" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nk"> END~ </em></p></div></div>    
</body>
</html>