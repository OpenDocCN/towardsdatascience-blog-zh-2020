<html>
<head>
<title>Pandas equivalent of 10 useful SQL queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫相当于 10 个有用的 SQL 查询</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-equivalent-of-10-useful-sql-queries-f79428e60bd9?source=collection_archive---------0-----------------------#2020-03-29">https://towardsdatascience.com/pandas-equivalent-of-10-useful-sql-queries-f79428e60bd9?source=collection_archive---------0-----------------------#2020-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0a4a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">…或者是面向 SQL 开发人员的熊猫</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/613f85781da84e22f817c48e52666c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*us86x-BqXg7IyoPyPLGKeg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/ro/users/PublicDomainPictures-14/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=214260" rel="noopener ugc nofollow" target="_blank">PublicDomainPictures</a>@<a class="ae ky" href="https://pixabay.com/ro/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=214260" rel="noopener ugc nofollow" target="_blank">Pixabay</a>提供</p></figure><p id="2567" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不知道，pandas 是一个用于数据操作和分析的 python 库。特别是，它提供了数据结构和操作来操作数字表和时间序列。这个名字来源于术语“面板数据”，这是一个计量经济学术语，指的是包含同一个人在多个时间段的观察结果的数据集。</p><p id="2a79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，它是 python 中处理表格的一种方式。在熊猫中，数据表被称为。</p><p id="c368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如标题所示，在本文中，我将向您展示一些最有用的 SQL 查询的 pandas 等价物。这既可以作为那些已经知道 SQL 的人对 pandas 的介绍，也可以作为您可能需要的常见 pandas 操作的备忘单。</p><p id="9daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于下面的例子，我将使用<a class="ae ky" href="https://www.kaggle.com/datasnaek/youtube-new#USvideos.csv" rel="noopener ugc nofollow" target="_blank">这个</a>数据集，它包含了美国 YouTube 视频的趋势数据。它由 40949 行和 16 列组成:video_id、trending_date、title、channel_title、category_id、<br/> publish_time、tags、views、likes、unless、comment_count、<br/> thumbnail_link、comments_disabled、ratings_disabled、<br/> video_error_or_removed、description。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="707f" class="md me it ly b gy mf mg l mh mi">import numpy as np<br/>import pandas as pd</span><span id="513a" class="md me it ly b gy mj mg l mh mi"># Reading the csv file into a DataFrame<br/>df = pd.read_csv('USvideos.csv')</span></pre><p id="ed84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，Pandas 操作不会修改您正在处理的数据框；它们只是返回其他数据框，您需要将这些数据框赋给一个变量，或者如果您想要保存更改，请使用参数 inplace=True。对于下面的大多数例子，我们不改变我们的原始数据框，我们只是显示返回的结果。</p><h1 id="b765" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">1.挑选</h1><p id="0a41" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT col1, col2, ... FROM table</code></p><p id="66c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SELECT 语句用于从表中选择数据列。</p><p id="078b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在 pandas 中做同样的事情，我们只需在数据框上使用数组符号，并在方括号内传递一个包含您想要选择的列名的列表。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="52e9" class="md me it ly b gy mf mg l mh mi">df[['video_id', 'title']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/40032fe37f37066e7e806389f4d241f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*57GBb1XjS3XKdtSwIu0weA.png"/></div></div></figure><p id="ebc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的事情也可以用下面的语法来实现，这样以后翻译 WHERE 语句就更容易了:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="36b6" class="md me it ly b gy mf mg l mh mi">df.loc[:, ['video_id', 'title']]</span></pre><p id="e9e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT DISTINCT col1, col2, ... FROM table</code></p><p id="bb8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SELECT DISTINCT 语句只返回表中唯一的行。</p><p id="d9c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据框中可能存在重复值。如果您只想获得不同的行(删除重复的行),那么调用<code class="fe lv lw lx ly b">.drop_duplicates()</code>方法就很简单。根据该方法的名称判断，您可能认为它从初始数据框中移除了重复行，但它实际上是返回移除了重复行的新数据框。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="54e0" class="md me it ly b gy mf mg l mh mi">df.loc[:, ['channel_title']].drop_duplicates()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/eaf03e610dd220119f3d293301edc94b.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*lvVE6VKMdHsoUACCxHwDGg.png"/></div></figure><p id="902c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT TOP number col1, col2, ... FROM table</code> <br/>或<br/> <code class="fe lv lw lx ly b">SELECT col1, col2, ... FROM table LIMIT number</code></p><p id="9bad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL 中的 TOP 或 LIMIT 关键字用于限制从表顶部返回的行数。对于熊猫来说，用<code class="fe lv lw lx ly b">.head(number)</code>方法很容易做到这一点。Pandas 也有从数据帧末尾开始显示行的<code class="fe lv lw lx ly b">.tail(number)</code>方法。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="338c" class="md me it ly b gy mf mg l mh mi">df.loc[:, ['video_id', 'title']].head(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/d759cd4aee0e8472df313d7d4ce0de03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OaFtqcKkWf2TZ47QPvEF4w.png"/></div></div></figure><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f32b" class="md me it ly b gy mf mg l mh mi">df.loc[:, ['video_id', 'title']].tail(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/e9c321c61933901364b001720ea9290d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAnHFU5s7cSrV1J6wmpERw.png"/></div></div></figure><p id="0e28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL 的 MIN()、MAX()、COUNT()、AVG()和 SUM()函数很容易翻译成 pandas:</p><p id="8e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT MIN(col) FROM table</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="cc28" class="md me it ly b gy mf mg l mh mi">df.loc[:, ['views']].min()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/e0ba81bef7258e18365c127889c9258e.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*I7xjYKVCUBol2Gd54vu4Aw.png"/></div></figure><p id="87c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT MAX(col) FROM table</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="043d" class="md me it ly b gy mf mg l mh mi">df.loc[:, ['views']].max()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/19d29cd6ff7cb1e61d830aaa8746a505.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*1JeR-psnGTn7G_bYP0K_ug.png"/></div></figure><p id="e687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT COUNT(col) FROM table</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="169b" class="md me it ly b gy mf mg l mh mi">df.loc[:, ['views']].count()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/cdcbe47e60a9106bee4b7d1cd5492b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*ecA9cK61jMU5nOiLNvCgcw.png"/></div></figure><p id="29e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT AVG(col) FROM table</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="18d6" class="md me it ly b gy mf mg l mh mi">df.loc[:, ['views']].mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ff980327583c39db0c8ee120c2984b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*jw9-99ArVX-U3dpUzRM4TQ.png"/></div></figure><p id="1f4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT SUM(col) FROM table</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="bb84" class="md me it ly b gy mf mg l mh mi">df.loc[:, ['views']].sum()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/713107d1ff55ca1a7aef1d2512836c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*qmBzitxCKtfDLUJPFrxmjw.png"/></div></figure><p id="d191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们想做这样的事情呢:<br/> <code class="fe lv lw lx ly b">SELECT MAX(likes), MIN(dislikes) FROM table</code>？我们需要采取更多的步骤:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="90a9" class="md me it ly b gy mf mg l mh mi">new_df = df.loc[:, ['likes']].max().rename({'likes': 'MAX(likes)'})<br/>new_df['MIN(dislikes)'] = df.loc[:, ['dislikes']].min().values[0]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/b62fdbc820e58c79018981f5eb67b29d.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*XCugaBLOfI5xs1l-XlsGrA.png"/></div></figure><h1 id="51ae" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">2.在哪里</h1><p id="827f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT col1, col2, ... FROM table WHERE condition</code></p><p id="5573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WHERE 子句用于仅提取满足指定条件的行。</p><p id="911f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回想一下我们到目前为止用于选择列的语法:<br/> <code class="fe lv lw lx ly b">df.loc[:, ['col1', 'col2']]</code> <br/>在<code class="fe lv lw lx ly b">.loc</code>的方括号内有两个参数；到目前为止，我们只使用了第二个选项，它用于指定您想要选择的列。猜猜第一个参数是什么？用于选择行。Pandas 数据帧期望一个行索引或布尔标志的列表，它根据这个列表提取我们需要的行。到目前为止，我们只使用了表示“返回所有行”的符号<code class="fe lv lw lx ly b">:</code>。如果我们只想提取索引从 50 到 80 的行，我们可以在那个地方使用<code class="fe lv lw lx ly b">50:80</code>。</p><p id="7b89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了根据某种条件提取行，我们通常会传递一个由某种(矢量化)布尔运算返回的布尔标志数组。位置为 False 的行不会包含在结果中，只会返回位置为 True 的行。</p><p id="72dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用等式和不等式运算符<strong class="lb iu"> =，&lt;，&lt; =，&gt;，&gt; =，！= </strong>在条件是直截了当的。例如，要仅返回赞数&gt; = 1000000 的行，我们可以使用:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9ca6" class="md me it ly b gy mf mg l mh mi">df.loc[df['likes'] &gt;= 1000000, ['video_id', 'title']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/0b1c9eb06a4a6592667b31a69e4a8593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gQUGxVRlLr4vjxhjUj-Wqw.png"/></div></div></figure><p id="d684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们之所以能做上面(<code class="fe lv lw lx ly b">df['likes'] &gt;= 1000000</code>)的事情，是因为 pandas 已经覆盖了&gt; =操作符的默认行为，因此它将操作符应用于元素，并返回我们需要的形状(行数)的布尔数组。<br/>但是操作符<strong class="lb iu"> and，or，not </strong>不是这样工作的。所以，我们就用<strong class="lb iu"> &amp; </strong>代替<strong class="lb iu"/>，<strong class="lb iu"> | </strong>代替<strong class="lb iu">或</strong>，<strong class="lb iu"> ~ </strong>代替<strong class="lb iu">而不是</strong>。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7d08" class="md me it ly b gy mf mg l mh mi">df.loc[(df['likes'] &gt;= 1000000) &amp; (df['dislikes'] &lt;= 5000), ['video_id', 'title']].drop_duplicates()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/baed8f4f9acb70cc78e2c70d04b51803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_cKSI3TTL5FVqkrk3cfWg.png"/></div></div></figure><p id="1417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT col1, col2, ... FROM table WHERE colN IS NOT NULL</code></p><p id="ea8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 SQL 中，您可以使用<code class="fe lv lw lx ly b">IS NULL</code>或<code class="fe lv lw lx ly b">IS NOT NULL</code>来获取包含/不包含空值的行。</p><p id="134e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何检查熊猫中的空值？我们将使用熊猫包中的<code class="fe lv lw lx ly b">isnull(array-like)</code>功能来实现。注意这不是数据框对象的方法，不要用<code class="fe lv lw lx ly b">df.isnull(...)</code>；而是做<code class="fe lv lw lx ly b">pd.isnull(df['column'])</code>。所以要小心。</p><p id="d7d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的示例返回 description 不为 null 的所有行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/828b0aa620059297e141d73a061c2e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1R03n9dOISEWwr8bgH20qw.png"/></div></div></figure><p id="8392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT col1, col2, ... FROM table WHERE colN LIKE pattern</code></p><p id="51fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LIKE 关键字可以在 WHERE 子句中用来测试列是否匹配某个模式。</p><p id="092d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 pandas 中，我们可以使用 python 的本地<strong class="lb iu"> re </strong>正则表达式模块来完成同样的事情，甚至更多，因为 python 的 re 模块允许测试一组更丰富的模式，而不是 SQL 之类的。</p><p id="1e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个函数<code class="fe lv lw lx ly b">like(x, pattern)</code>，其中 x 是一个类似数组的对象，pattern 是一个包含我们想要测试的模式的字符串。这个函数首先将模式编译成一个正则表达式对象，然后我们可以使用<code class="fe lv lw lx ly b">.fullmatch(val)</code>方法根据我们的模式测试<code class="fe lv lw lx ly b">val</code>的值。为了对 x 向量中的每个元素进行测试，我们将使用 numpy 的<code class="fe lv lw lx ly b">vectorize(func)</code>函数为正则表达式匹配操作创建一个向量等价物。最后，我们将这个矢量化函数应用到我们的 x 输入向量。然后我们需要做的就是在<code class="fe lv lw lx ly b">.loc[]</code>中传递<code class="fe lv lw lx ly b">like(df['column'], pattern)</code>作为第一个参数。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e747" class="md me it ly b gy mf mg l mh mi">import re</span><span id="e913" class="md me it ly b gy mj mg l mh mi">def like(x, pattern):<br/>    r = re.compile(pattern)<br/>    vlike = np.vectorize(lambda val: bool(r.fullmatch(val)))<br/>    return vlike(x)</span></pre><p id="c831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，下面的代码返回所有描述中包含单词“math”的视频。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2976" class="md me it ly b gy mf mg l mh mi">df_notnull = df.loc[~pd.isnull(df['description']), :]<br/>df_notnull.loc[like(df_notnull['description'], '.* math .*'), ['video_id', 'title']].drop_duplicates()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/7fe8e0c6aa143f2b54f0886cc245388c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uIUlF9i8sJltOD6wbLiQbQ.png"/></div></div></figure><h1 id="bbb5" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">3.以...排序</h1><p id="535b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT col1, col2, ... FROM table ORDER BY col1, col2 ASC|DESC</code></p><p id="c77a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个 SQL 关键字用于按升序或降序对结果进行排序。</p><p id="0880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将它翻译成 pandas 很简单，只需在数据帧上调用<code class="fe lv lw lx ly b">.sort_values(by=['col1', ...], ascending=True/False)</code>方法。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d273" class="md me it ly b gy mf mg l mh mi">df.loc[df['likes'] &gt;= 2000000, ['video_id', 'title'] ].sort_values(by=['title'], ascending=True).drop_duplicates()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/2c7f51e3a0d015fa5b8ce23c86befbde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lz6A_mPQWRtOTRUsba3Xyw.png"/></div></div></figure><h1 id="3093" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">4.分组依据</h1><p id="825a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT col1, col2, ... FROM table GROUP BY colN</code></p><p id="207b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GROUP BY 语句对特定列中具有相同值的行进行分组。它通常与聚合函数(最小值、最大值、计数、总和、AVG)一起使用。</p><p id="6230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 pandas 中，简单到调用<code class="fe lv lw lx ly b">.groupby(['col1', ...])</code>方法，然后调用<code class="fe lv lw lx ly b">.min()</code>、<code class="fe lv lw lx ly b">.max()</code>、<code class="fe lv lw lx ly b">.count()</code>、<code class="fe lv lw lx ly b">.sum</code>、<code class="fe lv lw lx ly b">.mean()</code>方法之一。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8905" class="md me it ly b gy mf mg l mh mi">df.loc[:, ['channel_title', 'views', 'likes', 'dislikes'] ].groupby(['channel_title']).sum()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/f5683dcfc5d2185f1dc6ac6ea804a933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*et34Uc5MJsoJcQ4nkBcDGw.png"/></div></div></figure><h1 id="60fa" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">5.拥有</h1><p id="e7f4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe lv lw lx ly b">SELECT col1, col2, ... FROM table GROUP BY colN HAVING condition</code></p><p id="3cea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HAVING 关键字用于根据组级别的条件过滤结果。</p><p id="44d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在熊猫中，我们有<code class="fe lv lw lx ly b">.filter(func)</code>方法，可以在<code class="fe lv lw lx ly b">groupby()</code>调用之后调用。我们需要向该方法传递一个函数，该函数将一个组的数据帧作为参数，并返回一个布尔值，该值决定该组是否包含在结果中。<br/>但是如果我们想在 pandas 中一次做更多的事情，例如，在列上应用聚合函数，并基于组级别的条件过滤结果，我们需要在更多的步骤中这样做。而在 SQL 中，我们只需要一个查询就可以做到。</p><p id="72cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们希望按<em class="nu"> channel_title </em>分组，只允许表中至少有 100 个视频的频道，并对<em class="nu">的浏览量</em>、<em class="nu">喜欢</em>、<em class="nu">不喜欢</em>应用平均函数。</p><p id="3637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 SQL 中，这将是:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6fd9" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">SELECT</strong> channel_title, AVG(views), AVG(likes), AVG(dislikes)<br/><strong class="ly iu">FROM</strong> videos_table<br/><strong class="ly iu">GROUP</strong> <strong class="ly iu">BY</strong> channel_title<br/><strong class="ly iu">HAVING</strong> <strong class="ly iu">COUNT</strong>(video_id) <strong class="ly iu">&gt;=</strong> 100;</span></pre><p id="741a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在熊猫身上:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="55c6" class="md me it ly b gy mf mg l mh mi">g = df.groupby(['channel_title'])<br/>g = g.filter(lambda x: x['video_id'].count() &gt; 100)<br/>g = g.loc[:, ['channel_title', 'views', 'likes', 'dislikes']]<br/>g = g.groupby(['channel_title']).mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/e3eb052d14d0812342ee55b8e0a4b953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GeoZIzPz66WD40xYqqu_Zw.png"/></div></div></figure><h1 id="5e68" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">6.插入</h1><p id="8a0f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe lv lw lx ly b">INSERT INTO table (column1, column2, ...) VALUES (value1, value2, ...)</code></p><p id="7148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个 SQL 语句用于在表中插入新行。</p><p id="5b63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 pandas 中，我们可以使用<code class="fe lv lw lx ly b">.append()</code>方法在现有数据帧的末尾添加一个新的数据帧。我们将使用<code class="fe lv lw lx ly b">ignore_index=True</code>从旧数据帧的最后一行开始继续索引。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1570" class="md me it ly b gy mf mg l mh mi">new_row = pd.DataFrame({'video_id': ['EkZGBdY0vlg'],<br/>                        'channel_title': ['Professor Leonard'],<br/>                        'title': ['Calculus 3 Lecture 13.3: Partial Derivatives']})<br/>df = df.append(new_row, ignore_index=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/49091d3b2dc6b386812ab529b31a63bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*-39hQZyrMaZWF4_qY12LUA.png"/></div></div></figure><h1 id="0abf" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">7.删除</h1><p id="b74a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe lv lw lx ly b">DELETE FROM table WHERE condition</code></p><p id="776c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DELETE 语句用于根据某种条件从表中删除现有的行。</p><p id="d528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 pandas 中，我们可以使用<code class="fe lv lw lx ly b">.drop()</code>方法删除我们传入索引的行。与其他方法不同，这个方法不接受布尔数组作为输入。因此，我们必须将条件的输出转换为索引。我们可以通过<code class="fe lv lw lx ly b">np.where()</code>功能来实现。</p><p id="57ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们删除了所有包含<em class="nu"> channel_title！= '3Blue1Brown' </em>。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f1be" class="md me it ly b gy mf mg l mh mi">df = df.drop(np.where(df['channel_title'] != '3Blue1Brown')[0])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/aeb1622ed636e1ddfe9daeaeb323a321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3ZHw2agyxAN8Z9YX5Q6DA.png"/></div></div></figure><h1 id="43a0" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">8.改变</h1><p id="9240" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe lv lw lx ly b">ALTER TABLE table ADD column</code></p><p id="fa2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此 SQL 语句添加新列。</p><p id="f750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在熊猫身上，我们可以这样做:<code class="fe lv lw lx ly b">df['new_column'] = array-like</code>。</p><p id="3b8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们添加一个新列‘like _ ratio’:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6e53" class="md me it ly b gy mf mg l mh mi">df['like_ratio'] = df['likes'] / (df['likes'] + df['dislikes'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/5eb7cfc44572d164f9367ee48ed1de2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NxD68Ib9_TVF5EHAPEe9wg.png"/></div></div></figure><p id="d63f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ALTER TABLE table DROP COLUMN column</code></p><p id="8ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此 SQL 语句删除一列。</p><p id="1c74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">del df['column']</code>我们在熊猫身上就是这么做的。</p><p id="9d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，删除“comments_disabled”列将是:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a83d" class="md me it ly b gy mf mg l mh mi">del df['comments_disabled']</span></pre><h1 id="6ff8" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">9.更新</h1><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="52ca" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">UPDATE</strong> table_name<br/><strong class="ly iu">SET</strong> column1 <strong class="ly iu">=</strong> value1, column2 <strong class="ly iu">=</strong> value2, ...<br/><strong class="ly iu">WHERE</strong> condition;</span></pre><p id="c808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UPDATE 语句用于根据某些条件改变表中的值。</p><p id="2a93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在 python 中做到这一点，我们可以使用 numpy 的<code class="fe lv lw lx ly b">where()</code>函数。当我们用这个函数将一个布尔数组转换成索引数组时，我们在上面几行也看到了这个函数。这就是这个函数在只有一个参数的情况下所做的事情。这个函数可以接收 3 个相同大小的数组作为参数，第一个是布尔数组。让我们称它们为 c，x，y。它返回一个相同大小的数组，其中填充了以这种方式选择的来自 x 和 y 的元素:如果 c[i]为真，则选择 x[i]否则选择 y[i]。<br/>要修改一个数据框列我们可以这样做:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5fb9" class="md me it ly b gy mf mg l mh mi">df['column'] = np.where(condition, new_values, df['column'])</span></pre><p id="5115" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们将赞数增加 100，其中 channel_title == 'Veritasium '。</p><p id="fdec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是之前的数据:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8bff" class="md me it ly b gy mf mg l mh mi">df.loc[df['channel_title'] == 'Veritasium', ['title', 'likes']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/f5445e2675a6c20822a1a85fea52db29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*kr125jiW-ZIytmja3bYTsw.png"/></div></figure><p id="d631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将 Veritasium 频道的赞数增加 100:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ad54" class="md me it ly b gy mf mg l mh mi">df['likes'] = np.where(df['channel_title'] == 'Veritasium', df['likes']+100, df['likes'])</span></pre><p id="a0aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上述查询后:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/d5fbdc9bb46fe0e58b43c57ad283a6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*y_L-_DEpVcXQgEzaZkitGg.png"/></div></figure><h1 id="cb89" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">10.加入</h1><p id="c1b5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">JOIN 子句用于根据两个或多个表之间的相关列来组合它们中的行。</p><p id="0b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了展示连接的例子，我至少需要两个表，所以我将把目前使用的数据框分成两个更小的表。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="160e" class="md me it ly b gy mf mg l mh mi">df_titles = df.loc[:, ['video_id', 'title']].drop_duplicates()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/cbc150a46fde601581399a3ad11bd68e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9GkoRqPFAI5MrI8M3sVOfg.png"/></div></div></figure><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="dbb9" class="md me it ly b gy mf mg l mh mi">df_stats = df.loc[:, ['video_id', 'views', 'likes', 'dislikes'] ].groupby('video_id').max()<br/># transform video_id from index to column<br/>df_stats = df_stats.reset_index()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/08f7b445a9627d365bba483e7e2861af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*Bux-j3zninYy65H1PWtgIg.png"/></div></figure><p id="7a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 pandas 中进行连接很简单:数据帧有一个<code class="fe lv lw lx ly b">.join()</code>方法，我们可以这样使用:<br/> <code class="fe lv lw lx ly b">df1.join(df2.set_index('key_column'), on='key_column')</code></p><p id="f6bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有更多类型的联接:内部联接、完全联接、左联接和右联接。</p><ul class=""><li id="4d09" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">内部联接:返回在两个表中都有匹配值的行</li><li id="4147" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">完全(外部)联接:返回在任一表中具有匹配值的行</li><li id="d302" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">LEFT JOIN:返回左侧表中的所有行，以及右侧表中匹配的行</li><li id="29e4" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">右连接:返回右表中的所有行，以及左表中匹配的行</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/9d02930f68a209917420abc2829e13ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*_iympZumbDkcfYa7qNS2vw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://www.w3schools.com/sql/sql_join.asp" rel="noopener ugc nofollow" target="_blank"> w3schools </a></p></figure><p id="8f93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在 pandas 中指定您想要的连接类型，您可以使用<code class="fe lv lw lx ly b">.join()</code>方法中的<strong class="lb iu"> how </strong>参数。此参数可以是以下之一:“内部”、“外部”、“左侧”、“右侧”。</p><p id="bad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是“video_id”列上两个数据帧的内部连接示例。其他类型的连接以相同的方式完成，只需相应地更改“how”参数。</p><p id="9c47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL 中的内部联接:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2286" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">SELECT</strong> *<br/><strong class="ly iu">FROM</strong> df_titles<br/><strong class="ly iu">INNER</strong> <strong class="ly iu">JOIN</strong> df_stats<br/><strong class="ly iu">ON</strong> df_titles.<!-- -->video_id<!-- --> <strong class="ly iu">=</strong> df_stats.<!-- -->video_id<!-- -->;</span></pre><p id="6234" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫的内心世界:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a387" class="md me it ly b gy mf mg l mh mi">df_titles.join(df_stats.set_index('video_id'), on='video_id', how='inner')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/e92b43a73c55fccd43b5812a81c4e3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t1CAidxwS0ll-pJFPfPh0Q.png"/></div></div></figure></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><p id="183d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的笔记本可以在<a class="ae ky" href="https://www.kaggle.com/dorianlazar/pandas-equivalent-of-10-useful-sql-queries" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="7ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这些信息对你有用，感谢你的阅读！</p><p id="4714" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章也贴在我自己的网站<a class="ae ky" href="https://www.nablasquared.com/pandas-equivalent-of-10-useful-sql-queries/" rel="noopener ugc nofollow" target="_blank">这里</a>。随便看看吧！</p></div></div>    
</body>
</html>