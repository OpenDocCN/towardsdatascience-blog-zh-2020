<html>
<head>
<title>From .txt file to d3.js visualization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从。txt文件到d3.js可视化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-txt-file-to-d3-js-visualization-7070ef7af837?source=collection_archive---------21-----------------------#2020-02-11">https://towardsdatascience.com/from-txt-file-to-d3-js-visualization-7070ef7af837?source=collection_archive---------21-----------------------#2020-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e627" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用数据科学技术读取、清理非结构化数据，并将其转换为引人入胜的web可视化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5a7444e583a51d260e206b043dccacf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h5TpaLdwZuqEO6VTL8XwXw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@randyfath?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">兰迪·法特</a>在<a class="ae ky" href="https://unsplash.com/s/photos/chess?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">几年前，IBM 指出，作为一名数据科学家，你可能必须经常遵守“80/20法则”——你80%的时间将用于简单地查找、清理和组织数据，只留下20%的时间用于实际执行分析。</p><p id="aee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名数据科学研究生，我的第一门课程只关注最初的80%。有一项任务特别需要清理下面的文本文件，其中包含虚构国际象棋选手的“elo评级”以及虚构国际象棋锦标赛的分数和点数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi me"><img src="../Images/7257a68764263a514314ca292f45cf2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*KAT1uLKQElWdTM7xHp88fw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模拟国际象棋“elo”评分和点数</p></figure><p id="48b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太残忍了！我把这个文件的底部剪了下来，因为它很长，但是总共有64个玩家。</p><p id="e9ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，你可能在想，<strong class="lb iu">我们能用这个</strong>做什么？这里有什么有趣的信息吗？我们将使用以下工作流程进行调查:</p><h1 id="2725" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">工作流程</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/984a6bac66914aadd5e2d882716bdbda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0M4oCOsDG_lr3QRfrUvfgw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从文本文件到d3.js可视化</p></figure><h1 id="9b43" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">将文本文件读入R</h1><p id="f79b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们要做的第一件事是。txt文件并将其拉入R。为此，我们可以使用基本的R函数<code class="fe nd ne nf ng b">paste()</code>和<code class="fe nd ne nf ng b">readLines()</code>:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="e19e" class="nl mg it ng b gy nm nn l no np">library(stringr)<br/>library(knitr)</span><span id="a961" class="nl mg it ng b gy nq nn l no np">chess_data &lt;- paste(readLines("https://raw.githubusercontent.com/zachalexander/data607_cunysps/master/Project1/chess_ratings.txt"), collapse = '\n')</span></pre><p id="d284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您将从链接中看到的，我将文本文件保存在一个新的GitHub存储库中，并访问“Raw”选项，以便提取正确的文件。此外，我已经加载了用于处理文本的<code class="fe nd ne nf ng b">stringr()</code>和<code class="fe nd ne nf ng b">knitr()</code>包。</p><h1 id="f14a" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">使用正则表达式处理文本文件</h1><p id="c70a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">尽管我已经将文本文件放入R中，但是如果我检查我的变量“chess_data”并将其打印到控制台，您将会看到数据根本没有格式化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/4cafefde79a24acba9e62a2c18a3fd73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wQtyXYDu6LZnzRynhRsNA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将原始文本文件放入R中之后——处理之前。</p></figure><p id="5639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，如果您仔细观察，在这个文件中有一些微妙的模式，我们可以用它们通过正则表达式解析出关键信息。如果你需要温习正则表达式，我推荐<a class="ae ky" href="https://stringr.tidyverse.org/articles/regular-expressions.html" rel="noopener ugc nofollow" target="_blank">这个资源。</a></p><p id="116b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，如果能得到玩家的名字就太好了。为此，我们可以结合使用<code class="fe nd ne nf ng b">str_extract_all()</code>函数和定制的正则表达式来隔离这些数据。我们可以看到球员的名字全部用大写字母列出，因此，我们可以通过运行以下语法提取他们:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="4f64" class="nl mg it ng b gy nm nn l no np">player_names &lt;- unlist(str_extract_all(chess_data, '([:upper:]+\\s[:upper:]+(\\s[:upper:]+)?(\\s[:upper:]+)?)'))</span><span id="4708" class="nl mg it ng b gy nq nn l no np"># change to 'proper' case<br/>player_names &lt;- str_to_title(player_names)<br/>head(player_names)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/3e8cab2d56279c2fb592d249e1a7d1c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svGSkLl4HewtGAbhkmk98Q.png"/></div></div></figure><p id="0dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面语法的第二部分，我简单地将所有大写字母的名字转换成“正确的”形式。你可以看到印在上面控制台上的最终产品。我们现在有64个玩家名字的向量！就这么简单！</p><p id="f982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看原始文本文件，我认为将玩家的原籍州、每个玩家的赛前elo评级以及每个玩家的赛后elo评级分离出来会很有趣。下面的正则表达式解决了这个问题:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="7bad" class="nl mg it ng b gy nm nn l no np"># found that each player's state could be extracted through this regular expression combination<br/>location &lt;- unlist(str_extract_all(chess_data, '(\n)\\s\\s\\s[:upper:]+'))<br/>location &lt;- unlist(str_replace_all(location, '^\\s+|\\s+$', ""))</span><span id="e9ce" class="nl mg it ng b gy nq nn l no np"># found that each player's pre-rating could be extracted through this regular expression combination<br/>pre_rating &lt;- unlist(str_extract_all(chess_data, '(R:)\\s{1,}\\d+'))<br/>pre_rating &lt;- unlist(str_replace_all(pre_rating, '(R:)\\s', ""))</span><span id="114f" class="nl mg it ng b gy nq nn l no np"># found that each player's post-rating could be extracted through this regular expression combination (used later in data visualization)<br/>post_rating &lt;- unlist(str_extract_all(chess_data, '(-&gt;)(\\s{1,})?\\d+'))<br/>post_rating &lt;- unlist(str_replace_all(post_rating, '(-&gt;)(\\s)?', ""))</span></pre><p id="1e79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于隔离玩家名字，由于原始文本文件中的某些模式，上面的每一项都可以被隔离。</p><h1 id="eb77" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">玩家结果-其他R函数</h1><p id="173e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这些信息安全地存储在有组织的向量中。让我们评估一下我们现在所处的位置，以及我们希望收集哪些额外的信息来进行分析。下面用<strong class="lb iu">黄色</strong>突出显示的所有数据都已提取，用<strong class="lb iu">绿色</strong>突出显示的所有数据都是从该文本文件中获取的有用值——我们将在下一步中关注这些值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi me"><img src="../Images/e8f45612e6ac3bb8232e2a861ac15af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*qHmjMwp2dLgL0_jNo3zx4A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们目前在工作流程中的位置。</p></figure><p id="3c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，我们可以看到每个玩家在锦标赛中的总点数包含带小数位的数字。为了分离这些值，我们可以根据这个字符序列提取所有值(见下文)。</p><p id="2659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，由于用绿色突出显示的其余数据在每一轮之间用“|”字符格式化，我们可以做一些操作来获取这些分数，继续利用我们的正则表达式。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="da74" class="nl mg it ng b gy nm nn l no np"># found that each player's total points could be extracted through this regular expression combination<br/>total_points &lt;- unlist(str_extract_all(chess_data, '(\\d\\.\\d)'))</span><span id="eb3e" class="nl mg it ng b gy nq nn l no np">results &lt;- unlist(str_extract_all(chess_data, '(\\d\\.\\d\\s{2}(\\|[:upper:]\\s{2}(\\s)?(\\s)?(\\d+)?){1,})'))<br/>results &lt;- unlist(str_replace(results, '\\d\\.\\d\\s{2}\\|', ''))</span></pre><p id="85bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我能够将每个玩家的这些值转换成一个临时数据帧，方法是使用for循环去掉多余的符号，并确保它们与我的初始向量中的玩家匹配。您可以看到下面的for循环过程:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="aee1" class="nl mg it ng b gy nm nn l no np"><em class="nt"># used a for loop here to iterate over V1, using strsplit and the comma to separate out the opponent numbers into the appropriate columns. This also stored N/As in columns where a player didn't play an opponent.</em><br/><strong class="ng iu">for</strong>(i <strong class="ng iu">in</strong> 1:7){<br/>  tempdf[, paste0('game', i)] &lt;- sapply(strsplit(as.character(tempdf$V1),','), "[", i)<br/>}</span></pre><p id="8547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这些数据与我的球员数据结合后，我们得到以下数据帧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/e113f7521e7923b79d27d675cca26da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R2jbFmwjtRGfj04-0C63Ew.png"/></div></div></figure><p id="742c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有所进展了！</p><p id="26f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，在game1、game2…gameN列中找到的数据对应于索引行号。既然我们已经有了这些信息，我想用与每个球员指数相对应的赛前评分来替换这些列中的指数会很有趣。如果我这样做是正确的，我就可以确定每个玩家的“时间表强度”！为此，我再次使用了for循环:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="121b" class="nl mg it ng b gy nm nn l no np"><em class="nt"># while iterating over the game columns, iterate over the player opponent number and match it with the opponent's pre-tournament elo rating. Then replace the opponent number with their elo rating.</em><br/><strong class="ng iu">for</strong>(i <strong class="ng iu">in</strong> 6:12) {<br/>  <strong class="ng iu">for</strong>(j <strong class="ng iu">in</strong> 1:64) {<br/>    value &lt;- chess_ratings_df[,i][j]<br/>    chess_ratings_df[,i][j] &lt;- chess_ratings_df$player_pre_rating[value]<br/>  }<br/>}</span></pre><p id="b549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们走吧！这是我们最后的数据帧，已经清理干净，可以进行分析了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/fa745beffc73a54d4701549e91e721ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7euyFNssvyodq_pqY6uO_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包含棋手信息的最终数据帧，从锦标赛中获得的总点数，以及他们面对的每个对手的预elo评级。</p></figure><h1 id="f233" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">初步分析</h1><p id="26ad" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">给定这个数据框架，我感兴趣的是仅基于对手的赛前评级来确定哪个(哪些)玩家的锦标赛赛程最艰难。此外，从赛前到赛后，谁的elo评分上升幅度最大？</p><p id="0aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了弄清楚这一点，我首先使用了<code class="fe nd ne nf ng b">rowMeans()</code>函数来计算七场锦标赛的对手赛前elo评分的平均值。然后我创建了一个名为<code class="fe nd ne nf ng b">average_opp_rating</code>的新列来存储每个玩家的计算结果。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="9c7f" class="nl mg it ng b gy nm nn l no np">chess_ratings_df$average_opp_rating &lt;- round(rowMeans(chess_ratings_df[,6:12], na.rm = TRUE), digits = 0)</span></pre><p id="0c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还决定再创建几个专栏，以确定玩家赛前评级和赛后评级的差异(最终看谁的elo评级收益/损失最高)。此外，我还创建了一个专栏，讨论前后的评分差异是正还是负。</p><p id="0562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我开发了一个相当全面的数据框架，可以回答我的许多问题。许多人会觉得这是令人满意的，大多数情况下确实如此。然而，如果我们把它可视化不是更有吸引力吗？</p><h1 id="04aa" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">将数据导出到. csv文件</h1><p id="1d82" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">准备好数据帧后，我可以用R中的以下语法将其导出为. csv文件:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="835a" class="nl mg it ng b gy nm nn l no np">filename &lt;- './../.../filepath'<br/>write.csv(final_df, file = filename)</span></pre><p id="c90f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些熟悉d3.js的人来说，有一个内置函数能够读取. csv文件并遍历其中的行。然而，我更喜欢直接与。json文件(只是我个人的喜好)。你可以快速使用免费的在线服务，如csvjson.com的<a class="ae ky" href="https://www.csvjson.com/csv2json" rel="noopener ugc nofollow" target="_blank"/>来转换格式。</p><p id="5f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦准备好了，我就有一个可行的。json文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/ef47e96629093498c7ab9c66e6abba3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*j9CDgGDyfz9FNUXBY49DSQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我的R数据帧先转换成. csv文件，然后转换成. json文件的例子</p></figure><h1 id="5711" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">使d3.js可视化</h1><p id="7963" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">由于时间的原因，我将简单介绍一下制作d3.js可视化的大部分内容。然而，如果你对学习感兴趣，我会推荐这本书——<a class="ae ky" href="https://doc.lagout.org/programmation/JavaScript/Interactive%20Data%20Visualization%20for%20the%20Web_%20An%20Introduction%20to%20Designing%20with%20D3%20%5BMurray%202013-04-05%5D.pdf" rel="noopener ugc nofollow" target="_blank">交互式数据可视化</a>——这真的是开始接触d3和Javascript的好指南！</p><p id="92ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用我的。json文件准备好了，我可以接着做下面的事情:</p><ol class=""><li id="47c0" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">使用<a class="ae ky" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank"> angular-cli </a>创建一个角度2+项目。</li><li id="0e8a" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">创建一个firebase项目，并使用firebase部署我的Angular 2+项目。<a class="ae ky" href="https://medium.com/@treviergits/how-to-deploy-an-angular-7-app-on-firebase-hosting-30341f3bcb22" rel="noopener">这是一个很好的指南。</a></li><li id="dcfc" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">我创建一个组件，安装必要的模块，并开始构建我的可视化！</li></ol><p id="961a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我生成了一个条形图，显示每个玩家的赛前elo评级，然后您可以单击一个按钮来查看他们的elo评级根据赛后评级的变化。您也可以将鼠标指针置于初始栏上，查看赛前评级:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/f7260d0119507ea235dcd28ae4bdf2c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cneaW0xCbD8fdayaeXLtJQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最终d3.js可视化——要查看最终产品，请前往<a class="ae ky" href="https://zach-alexander.com/chess-elo" rel="noopener ugc nofollow" target="_blank">https://zach-alexander.com/chess-elo</a></p></figure><p id="607d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要看到完整的、互动的可视化，你可以去https://www.zach-alexander.com/chess-elo的<a class="ae ky" href="https://zach-alexander.com/chess-elo" rel="noopener ugc nofollow" target="_blank"/>。希望你会发现它很吸引人。您还会注意到，我创建了一个与该数据相关的模拟报纸故事——只是为了好玩！</p><p id="428f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到底，尽管大多数人抱怨“80/20法则”，但我们可以看到它对这样的任务是多么重要。到处都有有用的数据，但前提是你愿意花时间去处理它们！</p></div></div>    
</body>
</html>