<html>
<head>
<title>Decorating Methods defined in a Class With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 修饰类中定义的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/decorating-methods-defined-in-a-class-with-python-4b361589440?source=collection_archive---------11-----------------------#2020-05-13">https://towardsdatascience.com/decorating-methods-defined-in-a-class-with-python-4b361589440?source=collection_archive---------11-----------------------#2020-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dda3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">类中的方法修饰符</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/93a04527f8d16225d06020c4255acea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*43IQyP59-_llE437PJCaZg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来自<a class="ae ku" href="https://unsplash.com/photos/cqAX2wlK-Yw" rel="noopener ugc nofollow" target="_blank"> Roselyn Tirado via Unsplash </a></p></figure><h2 id="f75e" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">装饰方法</h2><p id="bfb8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">Decorators 为 Python 中的函数和方法添加功能提供了一种方便而优雅的方式。装饰器可以通过多种不同的方式实现。decorators 的一个有用用例涉及到将它们与类中定义的方法一起使用。在我们创建的类中修饰方法可以扩展已定义方法的功能。例如，我们可以实现数据完整性检查，或者将方法调用的输出写入文件。我们选择做什么真的取决于我们自己。方法装饰者只是为我们提供了以优雅的方式扩展功能的工具。</p><p id="3969" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">和往常一样，用一个例子可以很好地展示 decorators 和方法的使用。</p><p id="8348" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">在下面的例子中，我创建了一个名为 NumericalOps 的简单类，它需要两个参数，val1 和 val2。在 init 构造函数中，这些参数被设置为对象中的属性。接下来，我在这个类中定义了 2 个方法，即 multiply_together 和 power。</p><p id="6ffe" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">让我们提出一个相当琐碎和做作的场景。我希望对象中设置的两个属性 val1 和 val2 是数字整数。multiply_together 方法只是将两个值相乘，然后返回该操作的值。<em class="mp">重要的是</em>，在 Python 中，可以对一个字符串进行乘法运算，比如用一个整数。当我们创建 NumericalOps 类 x 的实例并传入两个参数 2 和' my_string '时，就演示了这一点，如下例的控制台输出所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/b748a8e01ca888fac308e725565bd1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*Iwf8q0F9Jq3N9Mya-iRHHQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">为了提供数据输入完整性，可以使用装饰器来装饰类中定义的方法。目前，在示例中，装饰器@integer_check 被注释掉了。</p></figure><p id="728e" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">为了提供数据完整性，我将编写一个名为 interger_check 的装饰器。要装饰一个类中的方法，首先使用“@”符号，后跟装饰函数的名称。</p><p id="e6c9" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">装饰器只是一个函数，它将一个函数作为参数，然后返回<em class="mp">和</em>另一个函数。在这里，当我们用 integer_check 修饰 multiply_together 时，integer 函数被调用。multiply_together 方法作为参数传递给 integer_check 函数，并返回 inner。然后调用本地内部函数，它接受我们称为 ref 的对象，并使用<em class="mp"> isinstance </em>函数检查属性。如果传递了一个非整数类型，例如“my_string”，则会引发一个 TypeError 异常，并且会向控制台输出一条消息，告诉用户他们哪里出错了。但是，如果两个参数都是整数，inner 将返回原始方法，并将对象作为参数传递。</p><p id="6a6d" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">这个例子的源代码可以在我的 GitHub 页面上找到，这里的<a class="ae ku" href="https://gist.github.com/StephenFordham/549b6796a98951b891b60eece58deceb" rel="noopener ugc nofollow" target="_blank">和下面的</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mv"><img src="../Images/9a236c05fa93939372ffe9b80b168f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R4IgTUGLbXY6FbFPxWRJow.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="e362" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">对多个方法使用同一个装饰器</h2><p id="164a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">为了增加 decorators 的可用性和实用性，我们可以将它们的实现设计为使用多种方法。</p><p id="4df7" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">同样，这最好用一个例子来说明，所以让我们以上一节中的例子为基础。</p><p id="5ed9" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">让我们提议，我也希望 integer_check 装饰器验证我们在 power 方法中使用的指数也是一个整数。这在逻辑上是有意义的，因为当我们调用 power 方法时，它只是调用 multiply_together 方法，并将该方法的返回值乘以指数。因此，在每种情况下，我都需要确保 val1、val2 和指数都是整数。</p><p id="81e2" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">为了实现这种行为，我对 integer_check 装饰器进行了修改。我只是在装饰器内部定义的局部内部函数中为 expo 参数设置了一个默认参数。现在，如果我们在我们的实例 y 上调用 power 方法，inner 将被返回，然后用我们在内部定义中标记为 ref 的对象和 expo 值进行调用。</p><p id="96b6" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">在条件块中，如果 expo 被传递，我们使用 isinstance 函数检查它的类型，如果它不是整数，则引发错误，或者如果指数和 val1 和 val2 都是整数，则返回带有对象和指数的方法。</p><p id="87f6" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">有用的是，我们仍然可以在 multiply_together 方法上使用 integer_check 装饰器，因为 expo 的缺省值为 None。</p><p id="1ae2" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">现在，我们有了一个装饰器，它可以在我们的类中跨多个方法执行用户输入验证。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nf"><img src="../Images/fe6d8892cb41eaff453f7a2cc4e8b3ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWabU0FTcF90jIkTdfvpAg.png"/></div></div></figure><p id="1b20" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">使用整数作为输入，我们在控制台输出中得到预期的行为。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ng"><img src="../Images/0b5f0173cfe95eefb3430e46c42a190b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aOuq8DpJp_6chIK2D-jQqw.png"/></div></div></figure><p id="6e21" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">对于错误的输入(非整数类型)，我们得到一个有用的指示性错误消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nh"><img src="../Images/4ed1ce3eee1679502d4c234503e1f6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1QtoEe8wB95-OA5Addb2oQ.png"/></div></div></figure><p id="c1f8" class="pw-post-body-paragraph lr ls it lt b lu mk ju lw lx ml jx lz le mm mb mc li mn me mf lm mo mh mi mj im bi translated">这个例子的源代码可以在<a class="ae ku" href="https://gist.github.com/StephenFordham/07550fdd967bc049aa8ec659c36f4633" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="2b19" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">摘要</h2><p id="50cd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">当然，和往常一样，给出的例子相当琐碎和做作。还有其他方法来实现这里看到的行为，不需要装饰者。我在这里的目的是演示装饰器是如何工作的，以及如何将它们整合到您的代码设计中。对于那些感兴趣的人，我还写了另外两个教程，详细介绍了如何使用<a class="ae ku" rel="noopener" target="_blank" href="/how-to-use-decorators-in-python-by-example-b398328163b">装饰器来装饰函数</a> s，以及<a class="ae ku" rel="noopener" target="_blank" href="/using-class-decorators-in-python-2807ef52d273">装饰器本身如何成为一个类</a>。这两篇文章的链接可以通过访问链接找到。</p></div></div>    
</body>
</html>