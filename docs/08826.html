<html>
<head>
<title>Step-up Your RegEx Game in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 升级你的正则表达式游戏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/step-up-your-regex-game-in-python-1ec20c5d65f?source=collection_archive---------13-----------------------#2020-06-25">https://towardsdatascience.com/step-up-your-regex-game-in-python-1ec20c5d65f?source=collection_archive---------13-----------------------#2020-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8635" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python 中使用正则表达式的高级文本操作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/01f46db671b0e9f313a48e92671b5bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o3R9tRL00J1JNpO-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@benwhitephotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">本·怀特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="707b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">正则表达式(RegEx)是最好的工具之一。我可能有偏见，因为我的大部分工作都集中在自然语言处理(NLP)上，但是不管有没有 NLP，我发现自己一次又一次地求助于正则表达式。</p><p id="82c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我绝不是专家，有很多东西我不知道——但是我已经经常使用正则表达式好几年了，所以我对它们足够了解。</p><p id="f517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我想分享一些 regex 方法，我认为它们稍微高级一些，但是非常有用。我们还将包含实际的代码，以便我们能够正确地理解正在发生的事情。我们将涵盖:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="e24b" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">Look-ahead/behind Assertions</strong> - (?&gt;= ) | (?= ) | (?&gt;! ) | (?! )<br/><strong class="mf iu">Modifiers</strong> - (?sm)<br/><strong class="mf iu">Conditionals (If|Else)</strong> - (...)?(?(1)True|False)</span></pre></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="c162" class="mw mk it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">前瞻/后见断言</h1><p id="2d34" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">这些是我用过的最有用的正则表达式方法。</p><p id="d3de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">靠近页面顶部是我的名字，在 HTML 中是我的用户名。看起来是这样的:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="ce23" class="mj mk it mf b gy ml mm l mn mo">&lt;a href="/<strong class="mf iu">@jamescalam</strong>?source=post_page-----22e4e63463af----------------------" class="cg ch au av aw ax ay az ba bb it be ck cl" rel="noopener"&gt;James Briggs&lt;/a&gt;</span></pre><p id="9163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们现在感兴趣的是从页面的 HTML 中提取用户名，我们已经提取了所有的<code class="fe ns nt nu mf b">&lt;a&gt;</code>元素，并将使用 RegEx 来识别和提取用户名。</p><p id="405b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以做一些乱七八糟的事情，像这样:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="c278" class="mj mk it mf b gy ml mm l mn mo">if '&lt;a href"/@' in a:<br/>    username = a.replace('&lt;a href="/', '')<br/>    username = username.split('?source')[0]</span></pre><p id="1c7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是使用后视和前瞻断言，我们会得到更动态、更灵活的逻辑，如下所示:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="ef85" class="mj mk it mf b gy ml mm l mn mo">if bool(re.search(r'<strong class="mf iu">(?=&lt;\/)'@.*(?=\?source)</strong>', a)):<br/>    username = re.search(r'<strong class="mf iu">(?=&gt;\/)'@.*(?=\?source)</strong>', a).group()</span></pre><p id="384e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里将从这个(或任何文章)页面上的<code class="fe ns nt nu mf b">&lt;a&gt;</code>元素中提取任何用户名。但是它看起来很复杂——所以让我们把问题简化一点。</p><h2 id="dd9f" class="mj mk it bd mx nv nw dn nb nx ny dp nf li nz oa nh lm ob oc nj lq od oe nl of bi translated">向后看</h2><p id="f940" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">后视断言告诉我们的 regex to <strong class="lb iu"> assert </strong>任何潜在的匹配都是在<strong class="lb iu">之前</strong>给出给断言的模式。让我们比较有和没有这个断言的正则表达式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/ecaa79defc136e54f269ca5181215cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzfrj5HlqYtZ0i004b3c0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这里，我们<strong class="bd oh">没有</strong>使用回顾断言——因为我们只搜索<strong class="bd oh"> hello world </strong>，我们返回<strong class="bd oh">两个</strong>匹配。截图来自<a class="ae ky" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank"> Regex101 </a>。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/8b53c0407902987aa5f6251e174aa74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g88bM9D3QS3cY8SP7Hmj3g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过为'<strong class="bd oh"> 1: </strong>'添加一个回顾断言(突出显示)，我们只匹配前面有'<strong class="bd oh"> 1: </strong>'的<strong class="bd oh"> hello world </strong>。截图来自<a class="ae ky" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank"> Regex101 </a>。</p></figure><p id="9fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们告诉我们的断言，断言<code class="fe ns nt nu mf b">1: </code>先于<code class="fe ns nt nu mf b">hello world</code>。</p><p id="3e24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们也可以仅将第一个 hello world 与<code class="fe ns nt nu mf b">"1: hello world"</code>匹配，但是这将在我们的匹配中包括<code class="fe ns nt nu mf b">"1: "</code>——无论什么包含在我们的断言中，在匹配的输出中都不包括<strong class="lb iu">。</strong></p><ul class=""><li id="cd98" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated">回顾过去——我们在回顾我们的模式。</li><li id="6357" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><strong class="lb iu">断言</strong> —我们断言这个其他模式的存在，但是我们并不匹配它(例如包含在我们输出的文本中)。</li></ul><h2 id="73da" class="mj mk it bd mx nv nw dn nb nx ny dp nf li nz oa nh lm ob oc nj lq od oe nl of bi translated">向前看</h2><p id="38cd" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我确信，在理解了“看- <strong class="lb iu">后面的</strong>断言之后，一个“看- <strong class="lb iu">前面的</strong>断言的行为是可以预见的。让我们确保我们的 hello world 后面跟着一个<code class="fe ns nt nu mf b"><strong class="lb iu">,</strong></code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/597185eee4d819cd0f75975278a66b8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kk7PLuwPWKfnR4CfRWjkIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过为'<strong class="bd oh">、</strong>'添加一个前瞻断言(突出显示)，我们只匹配后面跟有逗号的<strong class="bd oh"> hello world </strong>。截图来自<a class="ae ky" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank"> Regex101 </a>。</p></figure><h2 id="2b29" class="mj mk it bd mx nv nw dn nb nx ny dp nf li nz oa nh lm ob oc nj lq od oe nl of bi translated">底片</h2><p id="f6ab" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们刚刚讨论的两个断言都是肯定的断言——我们断言我们的匹配模式在我们的断言模式之前/之后。</p><p id="668d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们经常需要断言我们的模式是<strong class="lb iu">而不是</strong>紧挨着另一个。为此，我们分别使用回顾和前瞻断言的否定形式— <code class="fe ns nt nu mf b"><strong class="lb iu">(?&lt;! )</strong></code>和<code class="fe ns nt nu mf b"><strong class="lb iu">(?! )</strong></code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/0aa4a7813e13fc78e6d02fc3c3561570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66RLDnIwgqbWfljEIcLoUg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">负的后视断言(左)和负的前视断言(右)。截图来自<a class="ae ky" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank"> Regex101 </a>。</p></figure><h2 id="dc64" class="mj mk it bd mx nv nw dn nb nx ny dp nf li nz oa nh lm ob oc nj lq od oe nl of bi translated">在实践中</h2><p id="d35e" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">为此，我们将使用安然电子邮件数据集。我们有两列，<code class="fe ns nt nu mf b">file</code>和<code class="fe ns nt nu mf b">message</code>——我们想要的一切都在<code class="fe ns nt nu mf b">message</code>中。如果我们看一下第一个<code class="fe ns nt nu mf b">message</code>列，我们会发现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/21da1bd4f92b484bb549188fa2dfeb10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ckikUAt7vq2F2CcR3zbYFA.png"/></div></div></figure><p id="9d85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望从这些数据中提取出<code class="fe ns nt nu mf b">Message-ID</code>和<code class="fe ns nt nu mf b">Date</code>。</p><p id="ccc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以这样写:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="3316" class="mj mk it mf b gy ml mm l mn mo">def boring_extract(msg):<br/>    msg = msg.splitlines()<br/>    <strong class="mf iu">msg_id </strong>= ''.join(<br/>                 msg[0].replace(<br/>                     'Message-ID: &lt;', ''<br/>                 ).split('.')[:2]<br/>             )<br/>    <strong class="mf iu">time </strong>= msg[1].replace('Date: ', '')[-5:]</span></pre><p id="13fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这看起来很糟糕，并且将需要很长时间来运行——它也根本不是动态的，如果由于某种原因，数据或<code class="fe ns nt nu mf b">Date</code>和<code class="fe ns nt nu mf b">From</code>开关位置中的某个字段丢失了，该怎么办？—代码会被破解。</p><p id="6bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们使用正则表达式的地方，严重依赖于前瞻和后视断言。让我们比较使用和不使用正则表达式的代码:</p><p id="a435" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu mf b"><strong class="lb iu">Message-ID</strong></code></p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="0f87" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">No RegEx</strong><br/>msg = msg.splitlines()<br/>msg_id = msg[0].replace('Message-ID &lt;', '')<br/>msg_id = msg_id[0].split('.')[:2]<br/>msg_id = ''.join(msg_id)</span><span id="3319" class="mj mk it mf b gy ow mm l mn mo"><strong class="mf iu">With RegEx</strong><br/>msg_id = re.search(r'<strong class="mf iu">(?&lt;=Message-ID: &lt;)</strong>\d+.\d+<strong class="mf iu">(?=.)</strong>', msg).group()</span></pre><p id="f6c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu mf b"><strong class="lb iu">Date</strong></code></p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="aeee" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">No Regex</strong><br/>msg = msg.splitlines()<br/>time = msg[1].replace('Date: ', '')[-5:]</span><span id="d061" class="mj mk it mf b gy ow mm l mn mo"><strong class="mf iu">With RegEx</strong><br/>time = re.search(r'<strong class="mf iu">(?&lt;=Date: )</strong>.*<strong class="mf iu">(?= \(\w\w\w\))</strong>', msg).group()</span></pre><p id="5d36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ns nt nu mf b">Message-ID</code>和<code class="fe ns nt nu mf b">Date</code>正则表达式中，我们都以<code class="fe ns nt nu mf b"><strong class="lb iu">(?&lt;= )</strong></code>开始，以<code class="fe ns nt nu mf b"><strong class="lb iu">(?= )</strong></code>结束——分别是积极的后视和前瞻断言。对于上面的例子，我们为<code class="fe ns nt nu mf b">msg_id</code>和<code class="fe ns nt nu mf b">time</code>输出如下:</p><p id="9b77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu mf b"><strong class="lb iu">[Out]:</strong> 18782981.1075855378110</code></p><p id="3a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu mf b"><strong class="lb iu">[Out]:</strong> Mon, 14 May 2001 16:39:00 -0700</code></p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="119e" class="mw mk it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">修饰语</h1><p id="24fc" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">同样，RegEx 的一个非常有用的特性。修饰符允许我们修改正则表达式的行为。</p><p id="777a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，以<strong class="lb iu">单行</strong>修饰符<code class="fe ns nt nu mf b"><strong class="lb iu">s</strong></code>为例——这将把<code class="fe ns nt nu mf b">.*</code>的行为从<strong class="lb iu">不</strong>包括新行<strong class="lb iu">改为包括新行</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/3e3d2d640742271d3d5de9a5f04e1972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qpp3nd3SBQ6rwumBPDy8Uw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不带单行全局修改器(左)和带单行全局修改器(右)—右上角的标志 s 表示我们已经应用了该修改器。截图来自<a class="ae ky" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank"> Regex101 </a>。</p></figure><p id="49b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需添加这个标志就可以改变正则表达式的行为。有一大堆不同的修改器，我们甚至可以合并它们来创建更具体和独特的行为。这些改性剂中最常见的包括:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="79a5" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">Single line [s]</strong> - Allows the <strong class="mf iu">.</strong> metacharacter (which matches everything <strong class="mf iu">except </strong>newlines) to match newlines too</span><span id="b875" class="mj mk it mf b gy ow mm l mn mo"><strong class="mf iu">Multi-line [m]</strong> - <strong class="mf iu">^</strong> and <strong class="mf iu">$</strong> now match the <strong class="mf iu">beginning/end of lines</strong>, rather than default behavior of matching beggining/end of entire string</span><span id="29d2" class="mj mk it mf b gy ow mm l mn mo"><strong class="mf iu">Insensitive [i]</strong> - Upper <strong class="mf iu">and </strong>lower-case characters are matched, e.g. <strong class="mf iu">A = a</strong></span><span id="c5b6" class="mj mk it mf b gy ow mm l mn mo"><strong class="mf iu">Extended [x]</strong> - <strong class="mf iu">Ignores whitespace</strong>. To include spaces, they must be escaped using <strong class="mf iu">\</strong>. Also allows comments inside the regex with <strong class="mf iu">#</strong></span><span id="c854" class="mj mk it mf b gy ow mm l mn mo"><strong class="mf iu">ASCII [a]</strong> - Match to <strong class="mf iu">ASCII-only</strong> characters, rather than the full Unicode character set</span></pre><p id="5b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Python 中，我们可以用两种方式实现这些修饰符。</p><p id="34c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> (1)修饰符标志</strong>在表达式之外实现，作为函数的附加参数，它们应用于整个正则表达式。添加单行修饰符和不敏感修饰符将如下所示:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="9939" class="mj mk it mf b gy ml mm l mn mo">re.match('[a-z]+01.*', text, <strong class="mf iu">re.S|re.I</strong>)</span></pre><p id="badc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们使用按位 OR (|)将多个修饰符串在一起。</p><p id="4784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> (2)行内修饰符</strong>在表达式中使用<code class="fe ns nt nu mf b">(? )</code>语法——其中修饰符标记跟在<code class="fe ns nt nu mf b">?</code>后面。实现单行和不敏感修饰符只需要<code class="fe ns nt nu mf b">(?<strong class="lb iu">si</strong>)</code>，就像这样:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="20b5" class="mj mk it mf b gy ml mm l mn mo">re.match('<strong class="mf iu">(?si)</strong>[a-z]+01.*', text)</span></pre><p id="fed6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据语言的不同，RegEx 实际上可以支持模式子部分中的修改行为——使用内联修饰符<code class="fe ns nt nu mf b">(? )</code>来启动行为，使用<code class="fe ns nt nu mf b">(?- )</code>来关闭修饰符:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/eb1b98e0a72963ce0f6cd4132da99c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bc1dzBD1fp-NTht1rkCIfg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用内联修饰符修改正则表达式的一个子部分——注意这在 Python 中<strong class="bd oh">不会</strong>起作用。</p></figure><p id="f9da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这个负的内联修饰符<strong class="lb iu">在 Python 中不受</strong>支持，一个内联修饰符(放在任何地方)将影响整个模式——而不仅仅是它的一部分。</p><p id="a14d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我从未遇到过这样有用的问题——所以我不认为我们在这方面错过了什么。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="9c05" class="mw mk it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">条件句(If | Else)</h1><p id="e84f" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">RegEx 中的条件语句真的很酷——尽管可能有点特殊。</p><p id="9bee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像 Python 中的<code class="fe ns nt nu mf b">if else</code>语句一样，我们可以在正则表达式中集成相同的逻辑。它的工作原理是说:</p><blockquote class="oz pa pb"><p id="ef62" class="kz la pc lb b lc ld ju le lf lg jx lh pd lj lk ll pe ln lo lp pf lr ls lt lu im bi translated">好吧，我们的模式匹配吗？<code class="fe ns nt nu mf b">(hello)?(?(1)</code></p><p id="27e4" class="kz la pc lb b lc ld ju le lf lg jx lh pd lj lk ll pe ln lo lp pf lr ls lt lu im bi translated">如果是这样——现在我们匹配模式 A，<code class="fe ns nt nu mf b">(?(1) world|</code></p><p id="0892" class="kz la pc lb b lc ld ju le lf lg jx lh pd lj lk ll pe ln lo lp pf lr ls lt lu im bi translated">否则—我们匹配模式 b。<code class="fe ns nt nu mf b">bye)</code></p></blockquote><p id="c256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合在一起，这给了我们<code class="fe ns nt nu mf b">(hello)?(?(1) world| bye)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/9a61dc224e19d1a0513ba94024d9f352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MPjWynFa8Q6o2hO1aS2leA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用条件语句的正则表达式示例。截图来自<a class="ae ky" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank"> Regex101 </a>。</p></figure><p id="4aee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一部分是我们的<strong class="lb iu">捕获组</strong>，<code class="fe ns nt nu mf b"><strong class="lb iu">(hello)</strong></code>——分配给<code class="fe ns nt nu mf b">(1)</code>，因为它是我们的正则表达式中的第一个捕获组。通过添加<code class="fe ns nt nu mf b">?</code>,我们使这个匹配成为可选的(否则，它将只在 true 时匹配)。</p><p id="e462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们问一个<strong class="lb iu">问题</strong>、<code class="fe ns nt nu mf b">?(1)</code>——意思是捕获组<code class="fe ns nt nu mf b">(1)</code>匹配吗？</p><p id="4cdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果匹配，我们的正则表达式将尝试匹配逻辑语句中的第一个参数<code class="fe ns nt nu mf b">world</code>。</p><p id="da1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，如果捕获组<code class="fe ns nt nu mf b">(1)</code>不匹配—我们的正则表达式将尝试匹配语句中的第二个参数<code class="fe ns nt nu mf b">bye</code>。</p><p id="d0b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在 Python 中测试，我们会看到相同的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/821642f845e57e6873f1df61389b261f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YV6_u7XHDGraftQx7pjHmg.png"/></div></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="9def" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文到此为止，在处理文本时，在 RegEx 中使用这三个特性可以给代码带来巨大的变化。它们都是我生活中不可或缺的特征。</p><p id="6207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您从这篇文章中学到了一些东西，并且会像我一样发现这些特性很有用。如果您有任何建议或问题，请随时通过 Twitter 或在下面的评论中联系我们。</p><p id="b3ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="ca83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有兴趣学习更多的正则表达式吗？我写了这篇关于使用正则表达式解析 Python 代码来构建自动文档工具的文章，请随意尝试一下！</p><div class="ph pi gp gr pj pk"><a rel="noopener follow" target="_blank" href="/auto-docs-for-python-b545ce372e2d"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">Python 的自动文档</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">编写代码很无聊，为什么要浪费时间呢？</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py ks pk"/></div></div></a></div></div></div>    
</body>
</html>