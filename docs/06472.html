<html>
<head>
<title>Understanding Hierarchies in Oracle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解 Oracle 中的层次结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-hierarchies-in-oracle-43f85561f3d9?source=collection_archive---------5-----------------------#2020-05-23">https://towardsdatascience.com/understanding-hierarchies-in-oracle-43f85561f3d9?source=collection_archive---------5-----------------------#2020-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="66ad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这篇文章讲述了在 Oracle 数据库中处理分层数据。它通过示例给出了详细的描述，从概念上解释了层次查询，并构建了层次查询以满足业务需求。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/858a6672a35512d4704b6b82e87f74b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GwXKk6s_O45gEOOu"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@edvardr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Edvard Alexander lvaag</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="215d" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">树形结构</h1><p id="0697" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">在现实生活中，有很多情况下，一组特定的数据依赖于另一组数据，而另一组数据又依赖于另一组数据，如此等等。因此，这种数据的逻辑结构形成了树形结构。关系数据库不以分层的方式存储数据。因此，通常很难在关系数据库中浏览这些数据。Oracle 提供了许多分层查询特性，使我们能够处理这样的数据。</p><h1 id="b148" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">从连接方式开始</h1><p id="5955" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">Oracle 的“START WITH CONNECT BY”子句允许非常有效地遍历分层数据。为了理解它的工作原理，我们来看一个示例表，其中包含如下示例数据:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="7ab8" class="mt lb it mp b gy mu mv l mw mx">CREATE TABLE ENTITIES(PARENT_ENTITY VARCHAR2(20 BYTE),CHILD_ENTITY VARCHAR2(20 BYTE),VAL Number);</span></pre><p id="3f3c" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">现在在其中插入一些示例值。</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="11da" class="mt lb it mp b gy mu mv l mw mx">Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (NULL,’a’,100);</span><span id="c27b" class="mt lb it mp b gy nd mv l mw mx">Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (‘a’, ‘af’,50);</span><span id="5f87" class="mt lb it mp b gy nd mv l mw mx">Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (‘a’, ‘ab’,50);</span><span id="8549" class="mt lb it mp b gy nd mv l mw mx">Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (‘a’, ‘ax’,50);</span><span id="f679" class="mt lb it mp b gy nd mv l mw mx">Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (‘ab’, ‘abc’,10);</span><span id="232b" class="mt lb it mp b gy nd mv l mw mx">Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (‘ab’, ‘abd’,10);</span><span id="4059" class="mt lb it mp b gy nd mv l mw mx">Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (‘ab’, ‘abe’,10);</span><span id="90fa" class="mt lb it mp b gy nd mv l mw mx">Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (‘abe’, ‘abes’,1);</span><span id="c54e" class="mt lb it mp b gy nd mv l mw mx"> Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (‘abe’, ‘abet’,1);</span><span id="6491" class="mt lb it mp b gy nd mv l mw mx"> Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (NULL,’b’,100);</span><span id="1118" class="mt lb it mp b gy nd mv l mw mx">Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (‘b’, ‘bg’,50);</span><span id="e508" class="mt lb it mp b gy nd mv l mw mx">Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (‘b’, ‘bh’,50);</span><span id="7fc0" class="mt lb it mp b gy nd mv l mw mx">Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (‘b’, ‘bi’,50);</span><span id="c332" class="mt lb it mp b gy nd mv l mw mx">Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (‘bi’, ‘biq’,10);</span><span id="0084" class="mt lb it mp b gy nd mv l mw mx">Insert into ENTITIES (PARENT_ENTITY, CHILD_ENTITY,VAL) Values (‘bi’, ‘biv’,10);</span><span id="3700" class="mt lb it mp b gy nd mv l mw mx">COMMIT;</span></pre><p id="4f8b" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">数据层次结构如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ne"><img src="../Images/13d305a6c6e39f874b9dd0ec4a0cf92b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZVgBuCIaDARyucZgxMjog.png"/></div></div></figure><p id="1ddb" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">要遍历此类数据，Oracle 中的 SQL 查询可以写成:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="cea9" class="mt lb it mp b gy mu mv l mw mx">SELECT parent_entity,child_entity<br/>FROM entities<br/>START WITH parent_entity is NULL CONNECT BY PRIOR child_entity= parent_entity</span></pre><p id="1acf" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">现在，让我们分析一下这个查询。</p><p id="0722" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated"><strong class="lu iu">开始于:</strong>指定层次的根行，即从哪里开始“行走”。</p><p id="0f09" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated"><strong class="lu iu"> CONNECT BY: </strong>指定层次结构中父行和子行之间的关系。</p><p id="e264" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated"><strong class="lu iu">先验:</strong>一元运算符，用于实现递归条件，即实际行走。</p><p id="82d5" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">上述查询的结果如下:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/dfe02179e2a8054a21947c1b478b51ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*ErWJM01E0XJdTxwsD5UBLg.png"/></div></figure><p id="65f4" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">执行过程如下:</p><p id="9e16" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">a.&gt;开始条件决定了开始点。在我们的例子中，我们将开始条件指定为 parent_entity 为 NULL。因此，它将标记 parent_entity 为 NULL 的那些行。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b9cd0cd8306b37d821ff0c9f458af9ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*-q4Oo1H5HVwVqRzAMloYYg.png"/></div></figure><p id="13e1" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">b.&gt;条件 CONNECT BY PRIOR child _ entity = parent _ entity 将导致子实体值成为父实体，直到遍历整个分支。因此，在我们的例子中，值“a”将成为父值，它将搜索其子值。返回的第一行将是:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/974df958e0088b20fdc8df7150ca2da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*tvs1QsKEOEQmwdRZjmDFLw.png"/></div></figure><p id="a9e2" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">a 的孩子是 ab，af，ax。它现在将 ab 作为父节点并搜索其子节点。因此，到目前为止的结果集将是:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/6f495f6bf67bfacef06c7e6dce5d7e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*ivW2p8uxQak8dB80f7sh4g.png"/></div></figure><p id="1d2f" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">' ab '的孩子是 abc 和 abd 和 abe。它现在将搜索 abc 的子节点。因为</p><p id="9ecb" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">“abc”没有任何子级，它将在结果集中返回它，并将搜索 abd 的子级。它也没有任何子元素，所以它也将在结果集中返回这个。到目前为止的结果集是:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/21bf2d72c88d452240f18befd0354690.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*DAyUO82dOYd5FtriJQvl4w.png"/></div></figure><p id="a23b" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">它现在会寻找“亚伯”的孩子。它有两个孩子:abes 和 abet。它现在将搜索 abes 的子节点，然后搜索 abet。abes 和 abet 都没有孩子。因此，结果集将如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nk"><img src="../Images/cb2aee9a02095806f8bd10be08ef3575.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*NfLvWky3x-hchBVSIFjarQ.png"/></div></div></figure><p id="e18a" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">它现在将搜索 af 的孩子。它没有任何子元素，因此将在结果集中返回。同样，ax 将在结果集中返回。</p><p id="378d" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">这就完成了对步骤 a 中返回的第一行的遍历。现在将对步骤 1 中返回的第二行重复相同的过程。最终结果集将如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/122fc3ba64ccca28d1bc2b8ee7118227.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*bKFd1CKcirXg-sx1EVKmeg.png"/></div></figure><h1 id="7072" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">遍历方向</h1><p id="f8c2" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">层次结构可以双向遍历:自顶向下或自底向上。CONNECT BY 子句中的条件和运算符“PRIOR”的位置决定了遍历的方向。</p><p id="4118" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">下面的查询以自上而下的方向遍历行。</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="1a04" class="mt lb it mp b gy mu mv l mw mx"><strong class="mp iu">SELECT parent_entity,child_entity<br/>FROM entities<br/>START WITH parent_entity is NULL<br/>CONNECT BY PRIOR child_entity= parent_entity</strong></span></pre><p id="ea1e" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">如果我们将 PRIOR 放在条件的右侧，它将自下而上遍历行:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="6a38" class="mt lb it mp b gy mu mv l mw mx">SELECT parent_entity,child_entity<br/>FROM entities<br/>START WITH parent_entity is NULL<br/>CONNECT BY child_entity= PRIOR parent_entity</span></pre><p id="cb78" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">该查询的输出将是:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/b4179a7503d6ae9dc53d07c1c83d8260.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*L1ouU6cfcwRZTupjTDxYqA.png"/></div></figure><p id="4c04" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">这将尝试在 START WITH 条件中找出返回行的父行。由于上述行没有父记录，因此这是返回的结果集。如果您将上述查询更改如下:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="63ea" class="mt lb it mp b gy mu mv l mw mx"><strong class="mp iu">SELECT parent_entity,child_entity<br/>FROM entities<br/>START WITH child_entity =’abet’<br/>CONNECT BY child_entity= PRIOR parent_entity</strong></span></pre><p id="a028" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">结果集将是</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/2fa0029db8e47cdf26398d982f857015.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*oZIKm8RoR9vbvbh5fPK1sQ.png"/></div></figure><p id="2ea0" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">因此，它从 child_entity='abet '处开始自下而上地遍历数据</p><p id="a790" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">通过改变列 child_entity 和 parent_entity 的位置，同时保持在左侧之前，可以获得相同的结果。因此，以下查询也将产生上述结果集:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="78bb" class="mt lb it mp b gy mu mv l mw mx"><strong class="mp iu">SELECT parent_entity,child_entity<br/>FROM entities<br/>START WITH child_entity =’abet’<br/>CONNECT BY PRIOR parent_entity = child_entity</strong></span></pre><h1 id="078f" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">水平</h1><p id="6698" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">LEVEL 是一个 Oracle 伪列，显示层次结构树中特定行的级别或等级。只有当查询中存在 CONNECT BY 子句时，才能使用它。如果我们执行下面的查询:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="40af" class="mt lb it mp b gy mu mv l mw mx">SELECT level, parent_entity,child_entity<br/>FROM entities<br/>START WITH parent_entity is NULL<br/>CONNECT BY PRIOR child_entity= parent_entity</span></pre><p id="e6f5" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">结果将如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi no"><img src="../Images/9375f552155266087a8758899984444c.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*rVfTEv01OVsjEpKVQ5diVw.png"/></div></figure><p id="ef23" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">使用函数 LPAD 和级别，我们可以在结果集中返回一个树状结构，如下所示:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="2132" class="mt lb it mp b gy mu mv l mw mx">SELECT LPAD(child_entity,Length(child_entity) + LEVEL * 10–10,’-’) tree<br/>FROM entities<br/>START WITH parent_entity is NULL<br/>CONNECT BY PRIOR child_entity= parent_entity</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi np"><img src="../Images/47a3a13c4e1f6153ab8273b047f0cb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*Mw_jJaf_mCMuZehrjGohng.png"/></div></figure><h1 id="78d9" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">修剪树枝</h1><p id="7efc" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">可能存在部分检索分层树和修剪分支的业务需求。比方说，在我们的数据中，我们不需要以' ab '开头的分支和以下分支。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nq"><img src="../Images/61105fca4f2a4cbf8fc86caa3b0cf620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MAmY3QqyZGjCfq38jStl1w.png"/></div></div></figure><p id="b9be" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">为此，我们将把查询修改为:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="52d2" class="mt lb it mp b gy mu mv l mw mx"><strong class="mp iu">SELECT parent_entity,child_entity<br/>FROM entities<br/>START WITH parent_entity is NULL <br/>CONNECT BY PRIOR child_entity = parent_entity and child_entity !=’ab’</strong></span></pre><p id="79c5" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">结果将如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e172fca82d1df95e6db73ae28549f93b.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*SJKUzQeIL3QOSbfY9uTPxg.png"/></div></figure><h1 id="6f7f" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">NOCYCLE 和 CONNECT_BY_ISCYCLE</h1><p id="0486" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">如果分层数据包含循环，即如果当前行有一个也是其祖先的子行，则可能会出现这种情况。例如，在实体表上执行下面的 Insert 语句:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="1211" class="mt lb it mp b gy mu mv l mw mx"><strong class="mp iu">insert into entities values(‘abet’,’a’);</strong></span></pre><p id="416e" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">它添加了一行，其中“abet”是“a”的父级。但是，‘a’也是‘abet’的祖先。这将导致一个循环。如果您执行以下查询:</p><p id="7d05" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">它添加了一行，其中“abet”是“a”的父级。但是，‘a’也是‘abet’的祖先。这将导致一个循环。如果您执行以下查询:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="5e48" class="mt lb it mp b gy mu mv l mw mx"><strong class="mp iu">SELECT parent_entity,child_entity<br/>FROM entities<br/>START WITH parent_entity is NULL <br/>CONNECT BY PRIOR child_entity = parent_entity</strong></span></pre><p id="f8ae" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">然后，会弹出以下错误:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/afe30969f00357261ed881280b1ee9b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*sIpAKgnOM48Kltf0F0LFiw.png"/></div></figure><p id="6507" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">若要在数据中存在 CONNECT BY 循环的情况下从查询中返回行，请按如下方式使用 NOCYCLE 参数:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="18c5" class="mt lb it mp b gy mu mv l mw mx"><strong class="mp iu">SELECT parent_entity,child_entity<br/>FROM entities<br/>START WITH parent_entity is NULL <br/>CONNECT BY NOCYCLE PRIOR child_entity = parent_entity</strong></span></pre><p id="beed" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">这不会返回错误。如果我们需要知道循环存在于哪一行，我们可以使用伪列<strong class="lu iu"> CONNECT_BY_ISCYCLE </strong>。如果当前行有一个也是其祖先的子行，则返回 1。否则，它返回 0。因此，如果您运行以下查询:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="fb5a" class="mt lb it mp b gy mu mv l mw mx"><strong class="mp iu">SELECT parent_entity,child_entity,CONNECT_BY_ISCYCLE isloop<br/>FROM entities<br/>START WITH parent_entity is NULL <br/>CONNECT BY NOCYCLE PRIOR child_entity = parent_entity</strong></span></pre><p id="207c" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">输出将是:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/310f67ba1f027434e4029cd0288e890e.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*_H0-g20YhwyNJrvEYwSxHQ.png"/></div></figure><h1 id="27ea" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">系统连接路径</h1><p id="82cf" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">如果要查看从根节点到当前节点的完整路径，可以按如下方式使用 SYS_CONNECT_BY_PATH:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="01b4" class="mt lb it mp b gy mu mv l mw mx"><strong class="mp iu">SELECT parent_entity,child_entity,SYS_CONNECT_BY_PATH(child_entity,’\’) PATH<br/>FROM entities<br/>START WITH parent_entity is NULL <br/>CONNECT BY PRIOR child_entity = parent_entity</strong></span></pre><p id="8cbc" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">输出将是:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/243dca3ab78928220b0824569f57d9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*G-UqmouHJXnK__ULLfUX2A.png"/></div></figure><p id="8ac5" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">对于每一行，它显示了从顶层节点到当前节点的完整路径。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="7107" class="pw-post-body-paragraph ls lt it lu b lv my ju lx ly mz jx ma mb na md me mf nb mh mi mj nc ml mm mn im bi translated">在从数据库中获取信息时，遍历层次结构通常会带来挑战。使用 Oracle 的内置功能可以解决这个问题。希望这篇文章对如何做到这一点有所启发。快乐阅读！</p></div></div>    
</body>
</html>