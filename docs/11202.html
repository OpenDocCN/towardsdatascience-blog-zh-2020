<html>
<head>
<title>Structures in MATLAB/Octave</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MATLAB/Octave 中的结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/structures-in-matlab-octave-96145b0b3f9f?source=collection_archive---------67-----------------------#2020-08-03">https://towardsdatascience.com/structures-in-matlab-octave-96145b0b3f9f?source=collection_archive---------67-----------------------#2020-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/98e4168f22bffd1157bfff2b4ed016f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xv05xGMev3Zq7oiH6g1Bvg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供。图片来源于<a class="ae jd" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/</a>。</p></figure><div class=""/><div class=""><h2 id="472a" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">帮助您的数据保持完整！</h2></div><p id="149d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结构，或<em class="lr">结构</em>，是 MATLAB/Octave 中的一种基本数据类型，可用于将多个属性组织和组合成一个公共数据结构。结构上的属性也称为字段，可以是不同的类型和不同的大小。然后，可以像平常一样访问和操作结构上的每个属性。结构在 MATLAB/Octave 中有多种用途，对于那些更熟悉 Python 的人来说，它非常类似于字典。</p><p id="0bed" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将介绍结构的基础知识，然后分享一些我认为最有用的使用它们的“技巧”。特别是，我涵盖了以下主题:</p><ul class=""><li id="3910" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">动态属性访问和<em class="lr"> filednames() </em>函数</li><li id="2865" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">使用结构数组</li><li id="8162" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">使用结构编写高效代码的注意事项</li></ul><p id="5dc1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有例子的源代码都可以在<a class="ae jd" href="https://github.com/ThinkData-science/CodingTips/tree/master/matlab" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>中找到。需要注意的是，MATLAB 和 Octave 显示结构的方式非常不同，因此根据运行代码的应用程序，您可能会看到一些差异。在本教程中，我用 Octave 运行了所有的例子，以尽可能地使事情变得容易理解。</p><h1 id="465c" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">基础知识</h1><p id="f366" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">MATLAB/Octave 中的结构是动态管理的，所以我们可以随时添加和删除新的属性。创建结构最简单的方法是使用<em class="lr"> struct() </em>命令创建一个空结构，并使用点操作符填充它。这里有一个简单的例子。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="8a81" class="nm mh jg ni b gy nn no l np nq">s = struct(); % create an empty struct<br/>s.val1 = 100; % add a scalar<br/>s.val2 = 0 : 25 : 100; % add a vectorize<br/>s.val3 = randn( 2, 3, 5 ); % add an ND array<br/>s.char1 = 'This is a character string'; % add a character string<br/>s.cell1 = { 100, 300, '5', 'abc' };  % add a cell array<br/>disp( s );</span><span id="66b0" class="nm mh jg ni b gy nr no l np nq">scalar structure containing the fields:</span><span id="76af" class="nm mh jg ni b gy nr no l np nq">val1 =  100<br/>    val2 =</span><span id="c6ac" class="nm mh jg ni b gy nr no l np nq">0    25    50    75   100</span><span id="f1c1" class="nm mh jg ni b gy nr no l np nq">val3 =</span><span id="1e10" class="nm mh jg ni b gy nr no l np nq">ans(:,:,1) =</span><span id="87a2" class="nm mh jg ni b gy nr no l np nq">-0.49715   0.32621  -0.81624<br/>      -0.34628   1.85946   0.29556</span><span id="cbe9" class="nm mh jg ni b gy nr no l np nq">ans(:,:,2) =</span><span id="ae4f" class="nm mh jg ni b gy nr no l np nq">-0.32521   0.44471   2.40743<br/>      -0.97223  -0.24240   0.39241</span><span id="5344" class="nm mh jg ni b gy nr no l np nq">ans(:,:,3) =</span><span id="8a08" class="nm mh jg ni b gy nr no l np nq">-1.63085  -0.34078   0.46239<br/>       0.48026  -0.45361   1.62214</span><span id="38b5" class="nm mh jg ni b gy nr no l np nq">ans(:,:,4) =<br/>                <br/>       0.523431  -0.576770  -0.028377<br/>      -1.035780   0.093593  -2.001485</span><span id="1664" class="nm mh jg ni b gy nr no l np nq">ans(:,:,5) =</span><span id="0bf4" class="nm mh jg ni b gy nr no l np nq">0.30492  -2.05388   0.13755<br/>      -0.98662  -1.36354  -0.43432</span><span id="1f63" class="nm mh jg ni b gy nr no l np nq">char1 = This is a character string<br/>    cell1 =<br/>    {<br/>      [1,1] =  100<br/>      [1,2] =  300<br/>      [1,3] = 5<br/>      [1,4] = abc<br/>    }</span></pre><p id="f799" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以使用相应的字段名称来访问任何新添加的属性。例如，让我们访问“val2”的第 2 个元素。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="42d4" class="nm mh jg ni b gy nn no l np nq">&gt;&gt; disp( s.val2(2) );</span><span id="1ef3" class="nm mh jg ni b gy nr no l np nq">25</span></pre><p id="2e42" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者我们可以访问“单元格 1”的最后一个元素。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="a2f7" class="nm mh jg ni b gy nn no l np nq">&gt;&gt; disp( s.cell1{end} );</span><span id="cdc8" class="nm mh jg ni b gy nr no l np nq">abc</span></pre><p id="da32" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实上，我们现在可以访问和修改所有的属性，就像它们不在结构上一样。让我们给“单元格 1”添加一个新值。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="f454" class="nm mh jg ni b gy nn no l np nq">&gt;&gt; s.cell1{ end+1 } = 'I am new!';<br/>&gt;&gt; disp( s.cell1 );</span><span id="8d42" class="nm mh jg ni b gy nr no l np nq">{<br/>  [1,1] =  100<br/>  [1,2] =  300<br/>  [1,3] = 5<br/>  [1,4] = abc<br/>  [1,5] = I am new!<br/>}</span></pre><p id="19ba" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者让我们从“val2”中删除一些值。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="86e8" class="nm mh jg ni b gy nn no l np nq">&gt;&gt; disp( s.val2 );</span><span id="39fe" class="nm mh jg ni b gy nr no l np nq">0    25    50    75   100</span><span id="7ef8" class="nm mh jg ni b gy nr no l np nq">&gt;&gt; s.val2( 2:3 ) = [];</span><span id="1500" class="nm mh jg ni b gy nr no l np nq">&gt;&gt; disp( s.val2 );</span><span id="0b54" class="nm mh jg ni b gy nr no l np nq">0    75   100</span></pre><p id="5d71" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，使用<em class="lr"> rmfield() </em>函数，我们可以从一个结构中完全删除字段。例如，让我们创建一个名为“s2”的新结构，并删除除“val1”之外的所有字段。其语法是:<em class="lr"> sOut = rmfield( s，{ 'name1 '，' name2 '，etc… } ) </em>，其中如果我们想要覆盖原始结构，则“sOut”可以是“s”，并且单元格数组包含我们想要移除的所有字段的名称。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="9578" class="nm mh jg ni b gy nn no l np nq">&gt;&gt; s2 = rmfield( s, { 'val2', 'val3', 'char1', 'cell1' } );<br/>&gt;&gt; disp( s2 );</span><span id="20ae" class="nm mh jg ni b gy nr no l np nq">scalar structure containing the fields:</span><span id="734d" class="nm mh jg ni b gy nr no l np nq">val1 =  100</span></pre><p id="b93f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是对结构的最基本用法的快速介绍。如果你是一个结构新手，花点时间浏览一下 MATLAB 文档可能是值得的。本文的其余部分将涉及一些更高级的，或者可能不太明显的使用结构的方法。</p><h1 id="35ad" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">动态访问属性和 fieldnames()函数</h1><p id="0962" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">结构的另一个非常有用的特性是你可以构建它们的数组。这些数组的行为与任何其他数组非常相似，但是，在填充它们时还需要额外的注意。特别是，结构数组中的每个元素都必须具有相同的属性。它们可以是空的，但是在将多个结构连接成一个数组之前，所有的属性都必须存在。</p><p id="3590" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从一个简单的例子开始，让我们将“s3”的第二个元素设置为其自身的另一个副本。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="4879" class="nm mh jg ni b gy nn no l np nq">&gt;&gt; s3(2) = s3;<br/>&gt;&gt; disp( s3 );</span><span id="73e3" class="nm mh jg ni b gy nr no l np nq">1x2 struct array containing the fields:</span><span id="d340" class="nm mh jg ni b gy nr no l np nq">noodles<br/>    dexter<br/>    ron<br/>    greg</span></pre><p id="1ae9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以看到有一个 1x2 的结构数组。请注意，这是可行的，因为两个结构具有完全相同的属性。</p><p id="a1ae" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结构数组的行为就像任何其他数组一样，可以使用<em class="lr"> () </em>来访问。例如，让我们将第一个结构上的“面条”字段更新为等于当前值的两倍。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="51b8" class="nm mh jg ni b gy nn no l np nq">&gt;&gt; s3(1).noodles = s3(1).noodles * 2;<br/>&gt;&gt; disp( s3(1).noodles );</span><span id="db2d" class="nm mh jg ni b gy nr no l np nq">62<br/>&gt;&gt; disp( s3(2).noodles );</span><span id="e867" class="nm mh jg ni b gy nr no l np nq">31</span></pre><p id="7cee" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还可以通过将元素设置为空值来从结构中移除元素。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="8aac" class="nm mh jg ni b gy nn no l np nq">&gt;&gt; s3(1) = [];<br/>&gt;&gt; disp( s3 );</span><span id="befb" class="nm mh jg ni b gy nr no l np nq">scalar structure containing the fields:</span><span id="1129" class="nm mh jg ni b gy nr no l np nq">noodles =  31<br/>    dexter =  11<br/>    ron =  46<br/>    greg =  28</span></pre><p id="5534" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，上面的输出显示我们再次拥有了一个标量结构。因为我们已经移除了结构数组的第一个元素。</p><p id="f9fc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，跨结构数组收集值也很方便。例如，假设我们有一个包含带有地理标签的图像的结构数组，我们对查看所有图像的位置感兴趣。我们可以通过捕获方括号<em class="lr"> [] </em>之间的结构输出将这些值收集到一个数组中。</p><p id="4e2d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们用另一个例子来证明这一点。首先，我们将构建 10 个结构，每个结构都有“img”、“lat”和“lon”属性。请注意，在循环中，临时变量用于在将每个结构添加到数组之前完全填充该结构。在这种情况下，这实际上是不必要的，因为我是通过向后循环来预分配结构内存的；但是，一般来说，这是一个很好的做法，因为这将确保在您尝试连接结构之前所有的字段都存在。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="aa21" class="nm mh jg ni b gy nn no l np nq">% - Build a fake array of structs.<br/>for iS=10 : -1 : 1<br/>    tmp = struct();<br/>    tmp.lat = randi( [-89, 90], 1 );<br/>    tmp.lon = randi( [-179, 180], 1 );<br/>    tmp.img = randn( 16, 16, 3 );<br/>    img( iS ) = tmp;<br/>end</span></pre><p id="909f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结构的结果数组将如下所示。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="68e2" class="nm mh jg ni b gy nn no l np nq">&gt;&gt; disp( img );</span><span id="11b5" class="nm mh jg ni b gy nr no l np nq">1x10 struct array containing the fields:</span><span id="332a" class="nm mh jg ni b gy nr no l np nq">lat<br/>    lon<br/>    img</span></pre><p id="1cc7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们可以将结构数组中的所有纬度和经度值收集到单独的数组中。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="0496" class="nm mh jg ni b gy nn no l np nq">% - Collect all of the lat and lon values into separate arrays<br/>lat = [ img(:).lat ];<br/>lon = [ img(:).lon ];</span><span id="5f5d" class="nm mh jg ni b gy nr no l np nq">&gt;&gt; disp( lat );</span><span id="93b7" class="nm mh jg ni b gy nr no l np nq">5   48  -36  -29   45   49  -68  -62   34  -31<br/>&gt;&gt; disp( lon );</span><span id="9612" class="nm mh jg ni b gy nr no l np nq">28   -62    60    80  -130   125   -68     2    33   177</span></pre><p id="9cc5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">方便的是，我们现在可以访问所有的 lat/lon 值，而不必遍历结构。当你想绘制图表或计算统计数据时，这是非常方便的。它还可以节省大量的运行时间，我将在下一节演示这一点。</p><p id="df2c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">令人惊讶的是，当您收集具有不止一个非单例维度的属性时，甚至可以做更奇妙的事情。在这种情况下，技巧是使用<em class="lr"> cat() </em>函数来明确说明数据应该如何分组。例如，我们可以将所有的像素数据从结构中收集到一个大小为 16 x 16 x 3 x 10 的新 ND 数组中，其中第四维对应于每个结构。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="1837" class="nm mh jg ni b gy nn no l np nq">&gt;&gt; pixelData = cat( 4, img(:).img );<br/>&gt;&gt; disp( size( pixelData ) );</span><span id="e5d3" class="nm mh jg ni b gy nr no l np nq">16   16    3   10</span></pre><p id="49e5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在你可以看到我们有一个 4 维数组，它是高乘宽乘通道乘图像。我发现这是一种非常优雅的方法，可以同时访问一个结构中多个元素的数据。这个“技巧”起初对我来说也不是很明显，但现在我经常使用。</p><h1 id="c164" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">性能呢？</h1><p id="52d9" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">尽管结构很棒也很灵活，但当然也有一些代价。在这种情况下，代价是运行时间的增加，这主要是由于数据在内存中的存储方式。好消息是，使用我们刚刚介绍的技巧，您可以解决大多数问题。如果您有兴趣了解更多关于数组顺序和在 MATLAB 中编写高效循环的知识，请务必查看详细讨论该主题的<a class="ae jd" href="https://thinkdata.science/?p=239" rel="noopener ugc nofollow" target="_blank">以前的文章</a>。</p><p id="0e65" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们以前面的图像为例，但是现在我们将创建 50，000 个伪图像结构。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="b954" class="nm mh jg ni b gy nn no l np nq">for iS=50000 : -1 : 1<br/>    tmp = struct();<br/>    tmp.lat = randi( [-89, 90], 1 );<br/>    tmp.lon = randi( [-179, 180], 1 );<br/>    tmp.img = randn( 16, 16, 3 );<br/>    img( iS ) = tmp;<br/>end</span></pre><p id="94bf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们可以编写一些代码来对每个图像执行一个简单的任务。在这种情况下，我们将计算每个图像的平均像素强度，并将其保存在一个 1x10，000 元素的数组中。如果我们直接从结构中访问数据，代码看起来就是这样。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="3bb7" class="nm mh jg ni b gy nn no l np nq">a = tic();</span><span id="d97e" class="nm mh jg ni b gy nr no l np nq">% Loop over each struct<br/>avgPixelInt = nan( 1, numel( img ) );<br/>for iS=1 : numel( img )<br/>  avgPixelInt( iS ) = mean( img( iS ).img(:) );<br/>end</span><span id="154e" class="nm mh jg ni b gy nr no l np nq">t1 = toc( a )</span></pre><p id="4a0e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者，如果我们使用上一节中的<em class="lr"> cat() </em>技巧，我们实际上可以编写相同的代码，而不必遍历数据。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="336b" class="nm mh jg ni b gy nn no l np nq">a = tic();</span><span id="cc9d" class="nm mh jg ni b gy nr no l np nq">% Capture all of the images into an ND array<br/>pixelData = cat( 4, img(:).img );</span><span id="4eba" class="nm mh jg ni b gy nr no l np nq">% Reshape so we can take the mean over the entire image<br/>sz = size( pixelData );<br/>pixelData = reshape( pixelData, [ prod( sz(1:3) ), sz(4) ] );</span><span id="8969" class="nm mh jg ni b gy nr no l np nq">% Calculate the mean for all images at once<br/>avgPixelInt = mean( pixelData, 1 );</span><span id="251a" class="nm mh jg ni b gy nr no l np nq">t2 = toc( a );</span></pre><p id="ecd5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，如果我们运行两组代码，并使用<em class="lr"> tic() </em>和<em class="lr"> toc() </em>对执行进行计时，这就是我们得到的结果。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="1b37" class="nm mh jg ni b gy nn no l np nq">&gt;&gt; t1 = toc( a )</span><span id="3692" class="nm mh jg ni b gy nr no l np nq">t1 =  9.8469</span><span id="9338" class="nm mh jg ni b gy nr no l np nq">&gt;&gt; t2 = toc( a )</span><span id="370b" class="nm mh jg ni b gy nr no l np nq">t2 =  1.9880</span><span id="a702" class="nm mh jg ni b gy nr no l np nq">&gt;&gt; disp( t1/t2 );<br/> 4.9531</span></pre><p id="7c9f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，使用<em class="lr"> cat() </em>技巧使代码运行速度提高了近 5 倍！现在，在这个例子中，节省实际上来自于消除环路；但是，通常情况下，最好不要在循环中访问或设置结构的属性。几乎在所有情况下，由于结构中的数据存储在内存中的方式，这将导致代码变慢。所以，当有疑问时，<em class="lr"> cat() </em>它出来了。</p><h1 id="34fd" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">摘要</h1><p id="fb46" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">这篇文章介绍了 MATLAB/Octave 中的结构，并介绍了一些基本的用法。一些更高级的用法基于使用变量来访问结构上的特定属性。这些技术确实给了程序员很大的能力来以编程方式解析和生成结构。最后，讨论了结构数组的使用，以及一些有助于编写高效代码的技巧。</p><p id="d255" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是一些需要记住的关键事项:</p><ul class=""><li id="d4b0" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">结构可以包含不同类型的数据作为属性</li><li id="0d76" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">可以随时添加或删除结构属性(或字段)</li><li id="aec9" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">结构可以连接成数组；但是，结构数组的每个元素必须包含完全相同的属性</li><li id="b646" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">函数可以用来将所有结构中的特定属性收集到一个数组中</li><li id="d568" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">虽然本文没有讨论，但是结构也可以包含其他结构作为属性</li><li id="435e" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">尽管结构很棒，但是在使用它们的时候你应该小心，以避免编写低效的代码</li></ul><p id="7d1e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编码快乐！</p></div></div>    
</body>
</html>