<html>
<head>
<title>XML Functionalities in Oracle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Oracle中的XML功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/xml-functionalities-in-oracle-4c4574942840?source=collection_archive---------24-----------------------#2020-06-06">https://towardsdatascience.com/xml-functionalities-in-oracle-4c4574942840?source=collection_archive---------24-----------------------#2020-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="41f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">Oracle数据库中XML的实现和支持概述</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/3a1e35194bc820c12d1634f24b268f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kVBPABSC8KSuNVPb"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沙哈达特拉赫曼</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="db89" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">XML:简介</h1><p id="1fe5" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">总是有在不同来源之间交换数据的广泛需求，而不用担心接收者将如何使用它或它将如何显示。XML为我们做了那件事。这是W3C(万维网联盟)的一项倡议，允许信息以人类和机器容易理解的有意义的结构和规则进行编码。</p><p id="fab0" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">XML代表e <strong class="lu iu"> X </strong>可扩展<strong class="lu iu"> M </strong> arkup <strong class="lu iu"> L </strong>语言。XML不是HTML的替代品。</p><blockquote class="mt mu mv"><p id="397e" class="ls lt mw lu b lv mo ju lx ly mp jx ma mx mq md me my mr mh mi mz ms ml mm mn im bi translated">HTML的设计重点是如何“显示”数据，而XML的设计重点是如何“<em class="it">存储</em>”和“<em class="it">传输</em>”数据。</p></blockquote><p id="6def" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">XML本身不做任何事情。</p><p id="87a4" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">让我们看一个样本xml文档:</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="a76d" class="nf lb it nb b gy ng nh l ni nj"><strong class="nb iu">&lt;message&gt;<br/>&lt;to&gt;Tom&lt;/to&gt;<br/>&lt;from&gt;Bill&lt;/from&gt;<br/>&lt;body&gt;Send me your phone number&lt;/body&gt;<br/>&lt;/message&gt;</strong></span></pre><p id="44ac" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">上面的XML文档包含一条消息，其主体包含发送者和接收者信息。但是它本身并不做任何事情。它只是构造和储存信息。必须有人编写软件代码来接收、发送或显示它。</p><p id="aeb9" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">像<strong class="lu iu"> &lt;从&gt; </strong>或者<strong class="lu iu"> &lt;到&gt; </strong>这样的标签不是预定义的。它们是由这个XML文档的作者编写的。</p><h2 id="5a5e" class="nf lb it bd lc nk nl dn lg nm nn dp lk mb no np lm mf nq nr lo mj ns nt lq nu bi translated">从这个意义上说，XML是“可扩展的”。这意味着它没有固定的元素集(不像HTML)。</h2><p id="388a" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">因此，简而言之，我们可以说XML是一种独立于软件和硬件的工具或方法来构造、存储和携带信息。</p><h1 id="215f" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">XML结构</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nv"><img src="../Images/e35e16dafb802d41d76420c6e91cf8de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dzk1uSLjcBWxrb9d"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@stairhopper?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历克斯·霍利约克</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4eba" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">XML文档有一个从“根”元素开始的树形结构。一个例子如下:</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="873e" class="nf lb it nb b gy ng nh l ni nj">&lt;?xml version=”1.0"?&gt;<br/>&lt;Employees&gt;<br/>&lt;Empl id=”1"&gt;<br/>&lt;FirstName&gt;Bill&lt;/FirstName&gt;<br/>&lt;LastName&gt;<br/>Watterson<br/>&lt;/LastName&gt;<br/>&lt;Dept&gt;<br/>Finance<br/>&lt;/Dept&gt;<br/>&lt;/Empl&gt;<br/>&lt;/Employees&gt;<br/>&lt;Employees&gt;<br/>&lt;Empl id=”1"&gt;<br/>&lt;FirstName&gt;<br/>Bill<br/>&lt;/FirstName&gt;<br/>&lt;LastName&gt;<br/>Watterson<br/>&lt;/LastName&gt;<br/>&lt;Dept&gt;<br/>Finance<br/>&lt;/Dept&gt;<br/>&lt;/Empl&gt;<br/>&lt;/Employees&gt;</span></pre><p id="0237" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">第一行是XML声明。它定义了XML版本。下一行声明了这个XML文档的“根”元素。因此，“员工”是这里的根元素。像“雇员”、“名字”、“姓氏”和“部门”这样的其他元素是子元素。在EMPL元素中，有一个值为“1”的字段id。它被称为该元素的属性。属性提供了关于元素的附加信息。属性值总是用引号括起来(单引号或双引号)。语法正确的XML文档称为“格式良好的”XML。</p><p id="3bd2" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">一个<strong class="lu iu">文档类型定义(DTD) </strong>定义了一个XML文档的合法构件。它定义了一个包含合法元素和属性列表的文档结构。DTD文档示例如下:</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="060f" class="nf lb it nb b gy ng nh l ni nj"><strong class="nb iu">&lt;?xml version=”1.0"?&gt; <br/>&lt;!DOCTYPE message [ <br/> &lt;!ELEMENT message (to,from,body)&gt;<br/> &lt;!ELEMENT to (#PCDATA)&gt; <br/> &lt;!ELEMENT from (#PCDATA)&gt; <br/> &lt;!ELEMENT body (#PCDATA)&gt;<br/> ]&gt;</strong></span></pre><p id="268d" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">上面的DTD是这样解释的:<br/> <br/>上面的DTD是这样解释的:</p><p id="b17a" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated"><strong class="lu iu">！DOCTYPE </strong> note定义了这个文档的根元素是message。<br/>T7】！元素 note定义了note元素包含四个元素:“to、from、body”。<br/> <strong class="lu iu">！元素</strong> to将to元素定义为“#PCDATA”类型。<br/>T13】！元素 from将from元素定义为“#PCDATA”类型。<br/>T16】！元素 body将body元素定义为“#PCDATA”类型。</p><p id="4f6f" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">description (#PCDATA)指定已解析的字符数据。解析的数据是XML元素的开始标记和结束标记之间的文本。解析的字符数据是没有子元素的文本。</p><p id="e6cb" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated"><strong class="lu iu"> XML模式定义(XSD) </strong>文档是基于XML的DTD的替代方案。</p><p id="3231" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">“有效的”XML文档是“格式良好的”XML文档，它也符合DTD或XSD的规则。</p><h1 id="a9ae" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">可扩展样式表语言（Extensible Stylesheet Language的缩写）</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nw"><img src="../Images/93385a4c1f26fba1fa336fbae35d2b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dq4_oI8zoeQa9smr"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">乔尔·那仁在Unsplash 上的照片</p></figure><p id="064b" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">如前所述，HTML标签是预定义的。在HTML中<table>定义了一个表格，浏览器已经知道如何显示它。然而，在XML中<table>可以表示任何东西。XML专注于结构化和存储数据。因此，我们需要一种机制来定义这些数据应该如何在浏览器、手机等中显示。XSL(可扩展风格语言)是完成这一任务的语言。它定义了解释XML文档元素的规则。</table></table></p><p id="998f" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">让我们以一个XML文档“CDCatalog.xml”为例，其定义如下:</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="881b" class="nf lb it nb b gy ng nh l ni nj"><strong class="nb iu">&lt;?xml version=”1.0" encoding=”ISO-8859–1"?&gt;<br/>&lt;?xml-stylesheet type=”text/xsl” href=”DisplayCD.xsl”?&gt;<br/>&lt;catalog&gt;<br/> &lt;cd&gt;<br/> &lt;title&gt;Empire Burlesque&lt;/title&gt;<br/> &lt;artist&gt;Bob Dylan&lt;/artist&gt;<br/> &lt;country&gt;USA&lt;/country&gt;<br/> &lt;company&gt;Columbia&lt;/company&gt;<br/> &lt;price&gt;10.90&lt;/price&gt;<br/> &lt;year&gt;1985&lt;/year&gt;<br/> &lt;/cd&gt;<br/> &lt;cd&gt;<br/> &lt;title&gt;Hide your heart&lt;/title&gt;<br/> &lt;artist&gt;Bonnie Tyler&lt;/artist&gt;<br/> &lt;country&gt;UK&lt;/country&gt;<br/> &lt;company&gt;CBS Records&lt;/company&gt;<br/> &lt;price&gt;9.90&lt;/price&gt;<br/> &lt;year&gt;1988&lt;/year&gt;<br/> &lt;/cd&gt;<br/>&lt;/catalog&gt;</strong></span></pre><p id="20a8" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">在第二行中，它引用了一个XSL文档DisplayCD.xsl。该文档可以定义如下:</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="df2a" class="nf lb it nb b gy ng nh l ni nj"><strong class="nb iu">&lt;?xml version=”1.0" encoding=”ISO-8859–1"?&gt;<br/>&lt;xsl:stylesheet version=”1.0" xmlns:xsl=”</strong><a class="ae kz" href="http://www.w3.org/1999/XSL/Transform" rel="noopener ugc nofollow" target="_blank"><strong class="nb iu">http://www.w3.org/1999/XSL/Transform</strong></a><strong class="nb iu">"&gt;<br/>&lt;xsl:template match=”/”&gt;<br/> &lt;html&gt;<br/> &lt;body&gt;<br/> &lt;h2&gt;Title&lt;/h2&gt;<br/>&lt;xsl:for-each select=”catalog/cd”&gt;<br/> &lt;xsl:value-of select=”title”/&gt; &lt;br/&gt;<br/>&lt;/xsl:for-each&gt;<br/> &lt;/body&gt;<br/> &lt;/html&gt;<br/>&lt;/xsl:template&gt;<br/>&lt;/xsl:stylesheet&gt;</strong></span></pre><p id="a113" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">让我们一行一行地理解DisplayCD.xsl。</p><p id="0403" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">第一行<?xml version=”1.0" encoding=”ISO-8859–1"??>，定义了使用的XML版本和编码。</p><p id="e524" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">下一行声明了要使用的XSL版本和名称空间。xmlns:XSL = " http://www . w3 . org/1999/XSL/Transform "指向官方的W3C XSLT名称空间。</p><p id="4560" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">元素定义了一个模板。属性将模板与XML源文档的根相关联。</p><p id="b1a1" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">元素内部的内容定义了一些要写入输出的HTML。</p><p id="077d" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">元素的xsl:value-of &gt; 可以用来提取XML元素的值。上例中的<strong class="lu iu">选择</strong>属性包含一个XPath表达式。XPath表达式的工作方式类似于导航文件系统；正斜杠(/)选择子目录。XSL<strong class="lu iu">&lt;XSL:for-each&gt;</strong>元素可用于选择指定节点集的每个XML元素。</p><p id="ee3f" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">当CDCatalog.xml在web浏览器中打开时，它将显示如下数据，如DisplayCD.xsl中所定义:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/103a0965a298d582b3d59b480e3b09a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*i72q2SbaE2TK4xrJCeQJAg.png"/></div></figure><h1 id="07a8" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">XMLType</h1><p id="fad5" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">Oracle使用一种新的数据类型，XML类型，来帮助处理数据库中的XML数据。若要以XML格式查看现有表的数据，可以编写如下查询:</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="cfb5" class="nf lb it nb b gy ng nh l ni nj"><strong class="nb iu">select XMLTYPE(cursor(select * from dept)) XML_Data from dual</strong></span></pre><p id="e9f7" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">输出如下所示:</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="729b" class="nf lb it nb b gy ng nh l ni nj"><strong class="nb iu">XML_Data<br/>==============</strong></span><span id="6d04" class="nf lb it nb b gy ny nh l ni nj">&lt;?xml version=”1.0"?&gt;<br/>&lt;ROWSET&gt;<br/> &lt;ROW&gt;<br/> &lt;DEPTID&gt;10&lt;/DEPTID&gt;<br/> &lt;DEPTNAME&gt;ACCOUNTING&lt;/DEPTNAME&gt;<br/> &lt;LOC&gt;NEW YORK&lt;/LOC&gt;<br/> &lt;/ROW&gt;<br/> &lt;ROW&gt;<br/> &lt;DEPTID&gt;20&lt;/DEPTID&gt;<br/> &lt;DEPTNAME&gt;RESEARCH&lt;/DEPTNAME&gt;<br/> &lt;LOC&gt;DALLAS&lt;/LOC&gt;<br/> &lt;/ROW&gt;<br/> &lt;ROW&gt;<br/> &lt;DEPTID&gt;30&lt;/DEPTID&gt;<br/> &lt;DEPTNAME&gt;SALES&lt;/DEPTNAME&gt;<br/> &lt;LOC&gt;CHICAGO&lt;/LOC&gt;<br/> &lt;/ROW&gt;<br/> &lt;ROW&gt;<br/> &lt;DEPTID&gt;40&lt;/DEPTID&gt;<br/> &lt;DEPTNAME&gt;OPERATIONS&lt;/DEPTNAME&gt;<br/> &lt;LOC&gt;BOSTON&lt;/LOC&gt;<br/> &lt;/ROW&gt;<br/>&lt;/ROWSET&gt;</span></pre><p id="c489" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">XMLType可以接受引用游标作为参数</p><p id="5e33" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">要将XML文件的内容插入Oracle表，请执行以下步骤:</p><ol class=""><li id="b54c" class="nz oa it lu b lv mo ly mp mb ob mf oc mj od mn oe of og oh bi translated">创建xmltype类型的表，例如创建XMLTYPE的表目录</li><li id="2a13" class="nz oa it lu b lv oi ly oj mb ok mf ol mj om mn oe of og oh bi translated">创建一个包含要加载的XML文件的Oracle目录。(一个<strong class="lu iu"> Oracle目录</strong>是指向<a class="ae kz" href="http://www.orafaq.com/wiki/Oracle_database" rel="noopener ugc nofollow" target="_blank">数据库服务器</a>机器上的<a class="ae kz" href="http://www.orafaq.com/wiki/Operating_system" rel="noopener ugc nofollow" target="_blank">操作系统</a> <a class="ae kz" href="http://www.orafaq.com/wiki/Directory" rel="noopener ugc nofollow" target="_blank">目录</a>的数据库对象，用于读写<a class="ae kz" href="http://www.orafaq.com/wiki/File" rel="noopener ugc nofollow" target="_blank">文件</a>。)例如:</li></ol><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="031b" class="nf lb it nb b gy ng nh l ni nj"><strong class="nb iu">CREATE OR REPLACE DIRECTORY MYXMLDIR AS ‘D:\Gaurav\Trainings\Files’;</strong></span></pre><p id="151a" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">3.执行insert语句，如下所示:</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="3833" class="nf lb it nb b gy ng nh l ni nj"><strong class="nb iu">INSERT INTO catalog VALUES(XMLType(bfilename(‘MYXMLDIR’,’CDCatalog.xml’),nls_charset_id(‘AL32UTF8’)));</strong></span></pre><p id="fcb3" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">传递给<code class="fe on oo op nb b">nls_charset_id</code>的值表示要读取的文件的编码是UTF-8。</p><p id="1e45" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">4.可以使用对象值选择该值，例如</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="7b44" class="nf lb it nb b gy ng nh l ni nj"><strong class="nb iu">select OBJECT_VALUE from catalog</strong></span></pre><h1 id="fb74" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">XMLELEMENT</h1><p id="9345" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">XMLELEMENT是一个返回XML类型的函数。它接受两个参数:第一个参数是标记的名称，第二个参数是值，可以是字符串、XMLTYPE、数字或日期。</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="614d" class="nf lb it nb b gy ng nh l ni nj"><strong class="nb iu">select empno, ename from emp where ename like ‘F%’;</strong></span></pre><p id="e271" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">这将返回姓名中包含字母“S”的雇员的编号和姓名，如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/9d4657905be51e9daa4b5dbeb0eae1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/1*RO3KNTfsDG7YGAlXsFqWOA.png"/></div></figure><p id="3906" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">使用XMLELEMENT，我们可以添加带有用户定义的标记名和值的xmltype作为雇员名，例如</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="7998" class="nf lb it nb b gy ng nh l ni nj"><br/>select empno, xmlelement(name,ename) name<br/>from<br/>emp<br/>where ename like ‘%S%’;</span></pre><p id="f9e5" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">它生成一个XMLType，以标记名和雇员名作为值:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi or"><img src="../Images/b3f10abf7a1ff9d5fae95cef100e5695.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*-V8G59TyIzMMnPDPKus9rg.png"/></div></figure><p id="a672" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">XMLELEMENT可以嵌套，并且可以包含属性:</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="6642" class="nf lb it nb b gy ng nh l ni nj">select empno, xmlelement(<br/>                         emp,<br/>                         xmlattributes (empno, deptno), <br/>                         xmlelement(name, ename),<br/>                         xmlelement(job,job)<br/>                         emp<br/>                         )<br/>                 from<br/>                 emp<br/>                 where ename like '%S%'</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi os"><img src="../Images/9cc1118f6c3822b82c565cc4f699378a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LDn93lZSj6K5jbZ6TjoK9Q.png"/></div></div></figure><h1 id="e121" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">用SQL函数查询XML数据</h1><p id="b06a" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated"><strong class="lu iu">提取和提取值:</strong></p><p id="d8d9" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">EXTRACT函数接受两个参数:一个XMLTYPE元素和一个XPATH字符串，并返回一个XMLTYPE实例，例如</p><p id="5b6d" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">为了选择country =“USA”数据，将在“catalog”表上使用以下查询。</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="31ce" class="nf lb it nb b gy ng nh l ni nj">select extract(OBJECT_VALUE,’/catalog/cd[country =”USA”]’) cd_usa<br/>from<br/>catalog</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ot"><img src="../Images/9f09788e0951f86211b2949d65706c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hj2sQHSGFVHC4tMGXbKVEA.png"/></div></div></figure><p id="908b" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated"><strong class="lu iu"> EXTRACTVALUE </strong>用于提取一个节点下的特定值。例如，如果我们必须在title=“仍然有忧郁”的地方找到艺术家的名字，查询将被写成如下:</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="77f7" class="nf lb it nb b gy ng nh l ni nj">select extractvalue(OBJECT_VALUE,’/catalog/cd[title =”Still got the blues”]//artist/text()’) artist_name<br/>from<br/>catalog</span></pre><p id="3c18" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">输出:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/30061798a9c9d780fe13450dde880826.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*s9wMszyVP_CyZedyOel6vQ.png"/></div></figure><p id="b024" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated"><strong class="lu iu">存在节点:</strong></p><p id="f27f" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">EXISTSNODE检查XPATH表达式的存在性，例如，如果我们想知道标题“仍然有忧郁”是否存在于目录中，我们可以编写如下查询:</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="bb52" class="nf lb it nb b gy ng nh l ni nj">select existsnode(OBJECT_VALUE,’/catalog/cd[title =”Still got the blues”]’) exist_flg<br/>from<br/>catalog</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/001f40193dbb5d77ddb366d537c20ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*WBM5SoS0d8gEVU6xP3Xciw.png"/></div></figure><p id="1c24" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">输出1表示它存在，而0表示它不存在。</p><p id="b9fa" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated"><strong class="lu iu"> XMLAGG: </strong></p><p id="644e" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">XMLAGG用于在单个XML文档中聚合多行。例如，要汇总每个部门的员工，查询可以写成:</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="1b15" class="nf lb it nb b gy ng nh l ni nj">select<br/>xmlelement(<br/>emp,<br/>xmlagg(<br/>xmlelement(dept,<br/> xmlagg(<br/> xmlelement(name,ename) order by ename<br/> )<br/> )<br/> ) <br/> ) <br/> from emp<br/>group by empno</span></pre><p id="613c" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated"><strong class="lu iu">更新XML: </strong></p><p id="cc69" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">UPDATEXML搜索XPATH表达式并更新它。例如</p><pre class="kk kl km kn gt na nb nc nd aw ne bi"><span id="00a4" class="nf lb it nb b gy ng nh l ni nj">UPDATE catalog SET object_value =<br/> UPDATEXML(object_value,<br/> ‘/catalog/cd/title/text()’,’changed’)</span></pre><p id="ac99" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated">这将把表格目录中的所有标题更新为“已更改”。</p><h1 id="f1f3" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">结论:</h1><p id="1a89" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">本文旨在让读者对XML和相关技术有一个基本的了解，并了解Oracle数据库是如何处理XML数据的。有关Oracle XML功能的更多详细信息，请参考以下链接:</p><p id="d96c" class="pw-post-body-paragraph ls lt it lu b lv mo ju lx ly mp jx ma mb mq md me mf mr mh mi mj ms ml mm mn im bi translated"><a class="ae kz" href="http://docs.oracle.com/cd/E11882_01/appdev.112/e23094/toc.htm" rel="noopener ugc nofollow" target="_blank">http://docs . Oracle . com/CD/e 11882 _ 01/app dev . 112/e 23094/TOC . htm</a></p></div></div>    
</body>
</html>