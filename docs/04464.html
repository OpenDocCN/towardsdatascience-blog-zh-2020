<html>
<head>
<title>7 Python Iterators You (Maybe) Didn’t Know About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你(可能)不知道的 7 个 Python 迭代器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/7-python-iterators-you-maybe-didnt-know-about-a8f4c9aea981?source=collection_archive---------33-----------------------#2020-04-21">https://towardsdatascience.com/7-python-iterators-you-maybe-didnt-know-about-a8f4c9aea981?source=collection_archive---------33-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1538" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及为什么你应该关心</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9099f4af02ac19dec43b45dcf1d51aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oUTlIwn6IrJHA2w3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安德鲁·西曼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="72ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你曾经用 Python 编程过，你可能知道迭代器。这些对象包含可计数数量的值。<strong class="lb iu">列表、元组、字典和集合都是可迭代的</strong>，这意味着你可以对它们调用函数<strong class="lb iu"> iter() </strong>来创建遍历它们的值的迭代器。使用函数<strong class="lb iu"> next() </strong>遍历迭代器。For 循环即时从可迭代对象实例化迭代器。</p><p id="ffd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了 Python 结构上的标准迭代器，Python 标准库中还有更高级的迭代器。它们都位于<strong class="lb iu"> itertools </strong>模块中。这里我解释 10 个最有趣的。</p><h1 id="030f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数数</h1><p id="69d3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">简单来说，<strong class="lb iu"> count() </strong>和<strong class="lb iu"> range() </strong>类似，但是无穷无尽。它采用一个<em class="ms">开始</em>和一个可选的<em class="ms">步长</em>参数，并在此之后输出无穷多个值。如果您想要迭代某些值，直到满足特定条件，这是很有用的。与 map 结合使用时，它可以这样使用:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9b75" class="my lw it mu b gy mz na l nb nc">import itertools</span><span id="2feb" class="my lw it mu b gy nd na l nb nc">def sqr(n):<br/>   return n*n</span><span id="8a4a" class="my lw it mu b gy nd na l nb nc">for i in map(sqr, itertools.count(10)):<br/>   if i &gt; 1000:<br/>      break<br/>   print(i)</span></pre><p id="b000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码输出 i &lt; 1000.</p><h1 id="dc04" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">cycle</h1><p id="949c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">As the name implies, <strong class="lb iu"> cycle(p) </strong>循环的所有值，循环次数不限。这个迭代器有用的一个例子是以循环顺序给列表元素分配标签:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0b0f" class="my lw it mu b gy mz na l nb nc">import itertools</span><span id="0b24" class="my lw it mu b gy nd na l nb nc">a = ‘ABCDEFGH’<br/>print(list(zip(a, itertools.cycle(range(2)))))</span></pre><p id="bf49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，输出将具有值[('A '，0)，(' B '，1)，(' C '，0)，…]。</p><h1 id="10c8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">链条</h1><p id="f080" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">将多个可重复项链接在一起。像这样使用它:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="61c8" class="my lw it mu b gy mz na l nb nc">import itertools</span><span id="f167" class="my lw it mu b gy nd na l nb nc">a = ‘ABCD’<br/>b = ‘EFGH’<br/>print(list(itertools.chain(a,b)))</span></pre><p id="5d08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出将是“ABCDEFGH”。</p><h1 id="3dd6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">星图</h1><p id="a4a7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">该函数采用另一个函数和一个 iterable 作为参数，如下所示:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0965" class="my lw it mu b gy mz na l nb nc">itertools.starmap(function, iterable)</span></pre><p id="6f32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms"> starmap </em>与<em class="ms"> map </em>非常相似，除了它也允许输入函数采用多个参数，这些参数已经分组在 iterable 的元组中，如下所示:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1bb9" class="my lw it mu b gy mz na l nb nc">import itertools</span><span id="8448" class="my lw it mu b gy nd na l nb nc">def compute_sqr_sum(x, y):<br/>   return x**2 + y**2</span><span id="f9b0" class="my lw it mu b gy nd na l nb nc">a = [(x,x+1) for x in range(4)]<br/>print(list(itertools.starmap(compute_sqr_sum, a)))</span></pre><p id="d34c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，输出是[1，5，13，25]。</p><h1 id="6eb1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">产品</h1><p id="16d6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">生成参数中可迭代项的笛卡尔乘积。它相当于多个嵌套循环。当你需要计算所有项目组合时，你可以使用它。可选的<em class="ms"> repeat </em>参数允许你计算一个 iterable 与其自身的笛卡尔积。例如，您可能会这样写:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5bed" class="my lw it mu b gy mz na l nb nc">import itertools</span><span id="0f60" class="my lw it mu b gy nd na l nb nc">a = [1, 2, 3]<br/>print(list(itertools.product(a,repeat=2)))</span></pre><p id="d891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出为[(1，1)、(1，2)、(1，3)、(2，1)、(2，2)、(2，3)、(3，1)、(3，2)、(3，3)]。</p><h1 id="96e9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">伊斯利斯</h1><p id="aabf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">从 iterable 中返回特定的切片。这和常规的<em class="ms">切片()</em>很像。然而，slice()创建了使用它的字符串、列表或元组的副本。</p><blockquote class="ne"><p id="fba2" class="nf ng it bd nh ni nj nk nl nm nn lu dk translated">相比之下，<em class="no"> islice(iterable，start，stop，[step]) </em>，除了 iterable 之外，几乎具有完全相同的语法，它返回 iterable，因此速度更快，因为元素是动态生成的。</p></blockquote><p id="8505" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">因此，如果内存效率起作用的话，<em class="ms"> islice </em>是首选方法。<em class="ms"> islice </em>的一个警告是它不能使用负索引(因为它总是从开始迭代 iterable，而 iterable 甚至可能不是有限长度的)。如何使用<em class="ms">的例子是 ice </em>:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2651" class="my lw it mu b gy mz na l nb nc">import itertools</span><span id="8a4d" class="my lw it mu b gy nd na l nb nc">gen = itertools.count()<br/>print(list(itertools.islice(gen, 2, 5)))</span></pre><p id="9c18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出将是[2，3，4]。</p><h1 id="79bb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">积聚</h1><p id="970d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个函数在很多函数式编程语言中也被称为<em class="ms"> fold </em>。它允许您迭代地将一个特定的二元函数应用于一个列表的元素，并将集合放入一个新的列表中。accumulate 的默认函数是运算符 add，用于将 iterable 中的项相加，例如[1，2，3，4]-&gt;[1，2，6，10]。此时，我将向您展示一个使用多个迭代器的稍微复杂一些的示例:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2c1d" class="my lw it mu b gy mz na l nb nc">import itertools<br/>import operator</span><span id="9eb5" class="my lw it mu b gy nd na l nb nc">gen = itertools.count(1)<br/>factorials = itertools.accumulate(itertools.count(1), func=operator.mul)<br/>fac_and_nums = zip(gen, factorials)</span><span id="ede8" class="my lw it mu b gy nd na l nb nc">print(list(itertools.islice(fac_and_nums, 2, 5)))</span></pre><p id="8056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你认为输出会是什么？</p><p id="59c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，使用迭代器时必须小心，因为每次调用<em class="ms"> next() </em>函数时迭代器都会递增。因此，这段代码没有实现作者的意图:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5695" class="my lw it mu b gy mz na l nb nc">import itertools<br/>import operator</span><span id="f0f8" class="my lw it mu b gy nd na l nb nc">gen = itertools.count(1)<br/>factorials = itertools.accumulate(gen, func=operator.mul)<br/>fac_and_nums = zip(gen, factorials)</span><span id="d2d1" class="my lw it mu b gy nd na l nb nc">print(list(itertools.islice(fac_and_nums, 2, 5)))</span></pre><p id="c26f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能找出原因吗？</p><h1 id="ff18" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="24a5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">虽然 Python 绝对不是函数式语言，但是它借用了一些非常有趣的函数式概念。将这些迭代器与 map 之类的函数结合起来，创造了一个全新的机会世界，并允许编写快速有效的对象代码处理序列。</p><p id="7077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">itertools 中还有一些迭代器。所有这些都可能在某种情况下有用。如果你想了解更多，不要害怕看一下官方 Python 文档<a class="ae ky" href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="noopener ugc nofollow" target="_blank"/>！</p></div></div>    
</body>
</html>