<html>
<head>
<title>Powerful Ultimate Binary Search Template and Many LeetCode Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强大的终极二分搜索法模板和许多 LeetCode 问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/powerful-ultimate-binary-search-template-and-many-leetcode-problems-1f850ef95651?source=collection_archive---------10-----------------------#2020-08-03">https://towardsdatascience.com/powerful-ultimate-binary-search-template-and-many-leetcode-problems-1f850ef95651?source=collection_archive---------10-----------------------#2020-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e885" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在几分钟内编写无 python 解决方案的伟大工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2a53bccc02e23917a63b0853c12950a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gwXCNAle8u5kT8gx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@leecampbell" rel="noopener ugc nofollow" target="_blank">李·坎贝尔</a>在<a class="ae ky" href="https://unsplash.com/photos/DtDlVpy-vvQ" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="7b6a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="93ef" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">二分搜索法在概念上很容易理解。基本上，它将搜索空间分成两半，只保留可能有搜索目标的一半，而丢弃可能没有答案的另一半。这样，我们在每一步都将搜索空间缩小一半，直到找到目标。二分搜索法帮助我们将搜索时间从线性 O(n)减少到对数 O(log n)。但是说到实现，要在几分钟内写出一个没有错误的代码是相当困难的。一些最常见的问题包括:</p><ul class=""><li id="9de3" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated">何时退出循环？应该用<code class="fe my mz na nb b">left &lt; right</code>还是<code class="fe my mz na nb b">left &lt;= right</code>作为 while 循环条件？</li><li id="971a" class="mn mo it lt b lu nc lx nd ma ne me nf mi ng mm mu mv mw mx bi translated">如何初始化边界变量<code class="fe my mz na nb b">left</code>和<code class="fe my mz na nb b">right</code>？</li><li id="07e0" class="mn mo it lt b lu nc lx nd ma ne me nf mi ng mm mu mv mw mx bi translated">如何更新边界？如何从<code class="fe my mz na nb b">left = mid</code>、<code class="fe my mz na nb b">left = mid + 1</code>和<code class="fe my mz na nb b">right = mid</code>、<code class="fe my mz na nb b">right = mid — 1</code>中选择合适的组合？</li></ul><p id="e511" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">对二分搜索法的一个相当普遍的误解是，人们通常认为这种技术只能用在简单的场景中，比如“给定一个排序的数组，从中找出一个特定的值”。事实上，它可以应用于更复杂的情况。</p><p id="2cce" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">在 LeetCode 中做了大量的练习后，我制作了一个强大的二分搜索法模板，并通过稍微扭曲这个模板解决了许多难题。我会在这篇文章中与你们分享这个模板。<strong class="lt iu">我不想只是炫耀代码就离开。最重要的是，我想分享逻辑思维:如何将这个通用模板应用于各种问题。希望看完这篇文章后，人们不会再因为听到“神圣的 sh*t！这个问题可以用二分搜索法来解决！我以前怎么没想到呢！”</strong></p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="b424" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">最广义的二分搜索法</h1><p id="e610" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设我们有一个搜索空间。它可以是数组、范围等。通常是按升序排序的。对于大多数任务，我们可以将需求转换为以下通用形式:</p><p id="bd7e" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><strong class="lt iu">最小化 k，s.t .条件(k)为真</strong></p><p id="fd78" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">以下代码是最通用的二分搜索法模板:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b770" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这个模板真正的好处是，对于大多数二分搜索法问题，我们只需要在复制粘贴这个模板后修改三个部分，再也不用担心代码中的死角和 bug 了:</p><ul class=""><li id="c06e" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated">正确初始化边界变量<code class="fe my mz na nb b">left</code>和<code class="fe my mz na nb b">right</code>。只有一个规则:设置边界使<strong class="lt iu">包含所有可能的元素</strong>；</li><li id="1310" class="mn mo it lt b lu nc lx nd ma ne me nf mi ng mm mu mv mw mx bi translated">决定返回值。是<code class="fe my mz na nb b">return left</code>还是<code class="fe my mz na nb b">return left — 1</code>？记住这个:<strong class="lt iu">退出 while 循环后，</strong> <code class="fe my mz na nb b"><strong class="lt iu">left</strong></code> <strong class="lt iu">是满足</strong> <code class="fe my mz na nb b"><strong class="lt iu">condition</strong></code> <strong class="lt iu">函数</strong>的最小 k；</li><li id="a3cc" class="mn mo it lt b lu nc lx nd ma ne me nf mi ng mm mu mv mw mx bi translated">设计<code class="fe my mz na nb b">condition</code>功能。这是最难也是最美的部分。需要大量的练习。</li></ul><p id="a813" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">下面我将向你们展示如何将这个强大的模板应用于许多 LeetCode 问题。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="c912" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">施基肥</h1><div class="ny nz gp gr oa ob"><a href="https://leetcode.com/problems/first-bad-version/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">第一个错误版本- LeetCode</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">你是一名产品经理，目前正带领一个团队开发新产品。不幸的是，最新版本的…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">leetcode.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div><p id="9dcc" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">首先，我们初始化<code class="fe my mz na nb b">left = 1</code>和<code class="fe my mz na nb b">right = n</code>以包含所有可能的值。然后我们注意到我们甚至不需要设计<code class="fe my mz na nb b">condition</code>函数。它已经由<code class="fe my mz na nb b">isBadVersion</code> API 给出了。找到第一个坏版本就相当于找到满足<code class="fe my mz na nb b">isBadVersion(k) is True</code>的最小 k。我们的模板非常适合:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ob"><a href="https://leetcode.com/problems/sqrtx/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">Sqrt(x) - LeetCode</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">实现 int sqrt(int x)。计算并返回 x 的平方根，其中 x 保证为非负整数…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">leetcode.com</p></div></div><div class="ok l"><div class="oq l om on oo ok op ks ob"/></div></div></a></div><p id="20e4" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">相当简单的问题。我们需要搜索满足<code class="fe my mz na nb b">k^2 &lt;= x</code>的最大 k，因此我们可以很容易地得出解决方案:</p><p id="b2f1" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">有一件事我想指出来。记得我说过我们通常寻找满足特定条件的最小 k 值吗？但是在这个问题中，我们寻找的是最大的 k 值。感到困惑？不要这样。实际上，满足<code class="fe my mz na nb b">isBadVersion(k) is False</code>的最大 k 正好等于满足<code class="fe my mz na nb b">isBadVersion(k) is True</code>的最小 k 减一。这就是为什么我之前提到我们需要决定返回哪个值，<code class="fe my mz na nb b">left</code>还是<code class="fe my mz na nb b">left — 1</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ob"><a href="https://leetcode.com/problems/search-insert-position/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">搜索插入位置- LeetCode</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">给定一个排序数组和一个目标值，如果找到目标，则返回索引。如果没有，返回索引…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">leetcode.com</p></div></div><div class="ok l"><div class="or l om on oo ok op ks ob"/></div></div></a></div><p id="18ec" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">非常经典的二分搜索法应用。我们正在寻找满足<code class="fe my mz na nb b">nums[k] ≥ target</code>的最小 k，我们可以复制粘贴我们的模板。注意，不管输入数组<code class="fe my mz na nb b">nums</code>是否有重复，我们的解决方案都是正确的。还要注意，输入<code class="fe my mz na nb b">target</code>可能比<code class="fe my mz na nb b">nums</code>中的所有元素都大，因此需要放在数组的末尾。这就是为什么我们应该初始化<code class="fe my mz na nb b">right = len(nums)</code>而不是<code class="fe my mz na nb b">right = len(nums) — 1</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="8849" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">高级应用</h1><p id="d22d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">上述问题相当容易解决，因为它们已经给了我们要搜索的数组。乍一看，我们就知道应该用二分搜索法来解决这些问题。然而，更常见的情况是搜索空间和搜索目标不那么容易获得。有时我们甚至不会意识到问题应该用二分搜索法来解决——我们可能只是求助于动态编程或 DFS，然后陷入很长一段时间。</p><p id="0649" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">至于“什么时候可以用二分搜索法”这个问题，我的回答是，<strong class="lt iu">如果我们能发现某种单调性，例如，如果</strong> <code class="fe my mz na nb b"><strong class="lt iu">condition(k) is True</strong></code> <strong class="lt iu">那么</strong> <code class="fe my mz na nb b"><strong class="lt iu">condition(k + 1) is True</strong></code> <strong class="lt iu">，那么我们可以考虑二分搜索法</strong>。</p><div class="ny nz gp gr oa ob"><a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">在 D 天内运送包裹的能力- LeetCode</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。第 I 个包裹在…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">leetcode.com</p></div></div><div class="ok l"><div class="os l om on oo ok op ks ob"/></div></div></a></div><p id="9222" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">当我们第一次遇到这个问题时，可能不会想到二分搜索法。我们可能会自动将<code class="fe my mz na nb b">weights</code>视为搜索空间，然后意识到在浪费了大量时间后，我们进入了一个死胡同。事实上，我们正在寻找所有可行容量中最小的一个。我们挖掘出这个问题的单调性:如果我们能在<code class="fe my mz na nb b">D</code>天内用容量<code class="fe my mz na nb b">m</code>成功装运所有包裹，那么我们就一定能把任何大于<code class="fe my mz na nb b">m</code>的容量全部装运。现在我们可以设计一个<code class="fe my mz na nb b">condition</code>函数，姑且称之为<code class="fe my mz na nb b">feasible</code>，给定一个输入<code class="fe my mz na nb b">capacity</code>，它返回是否有可能在<code class="fe my mz na nb b">D</code>天内装运所有包裹。这可能以一种贪婪的方式运行:如果当前的包裹还有空间，我们将这个包裹放在传送带上，否则我们等待第二天放置这个包裹。如果需要的总天数超过了<code class="fe my mz na nb b">D</code>，我们返回<code class="fe my mz na nb b">False</code>，否则我们返回<code class="fe my mz na nb b">True</code>。</p><p id="00ed" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">接下来，我们需要正确初始化我们的边界。显然<code class="fe my mz na nb b">capacity</code>至少应该是<code class="fe my mz na nb b">max(weights)</code>，否则传送带运不出最重的包裹。另一方面，<code class="fe my mz na nb b">capacity</code>不需要比<code class="fe my mz na nb b">sum(weights)</code>多，因为这样我们就可以在一天之内把所有的包裹都发货了。</p><p id="5630" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">现在，我们已经获得了应用二分搜索法模板所需的所有信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ob"><a href="https://leetcode.com/problems/split-array-largest-sum/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">分裂阵列最大和- LeetCode</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">给定一个由非负整数和一个整数组成的数组，你可以把数组分成非空的…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">leetcode.com</p></div></div><div class="ok l"><div class="ot l om on oo ok op ks ob"/></div></div></a></div><p id="ba52" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">如果你仔细观察，你可能会发现这个问题与上面的 LC 1011 有多么相似。类似地，我们可以设计一个<code class="fe my mz na nb b">feasible</code>函数:给定一个输入<code class="fe my mz na nb b">threshold</code>，然后决定是否可以将数组分成几个子数组，使得每个子数组的和小于或等于<code class="fe my mz na nb b">threshold</code>。这样我们就发现了问题的单调性:如果<code class="fe my mz na nb b">feasible(m)</code>是<code class="fe my mz na nb b">True</code>，那么所有大于<code class="fe my mz na nb b">m</code>的输入都能满足<code class="fe my mz na nb b">feasible</code>函数。你可以看到解决方案代码与 LC 1011 完全相同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="64f1" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">但是我们很可能会有疑问:我们的解返回的<code class="fe my mz na nb b">left</code>确实是满足<code class="fe my mz na nb b">feasible</code>的最小值，但是我们怎么知道我们可以把原数组拆分为<strong class="lt iu">实际得到这个子数组和</strong>？比如说<code class="fe my mz na nb b">nums = [7,2,5,10,8]</code>和<code class="fe my mz na nb b">m = 2</code>。我们有 4 种不同的方法来分裂阵列，从而相应地得到 4 个不同的最大子阵列和:<code class="fe my mz na nb b">25:[[7], [2,5,10,8]]</code>、<code class="fe my mz na nb b">23:[[7,2], [5,10,8]]</code>、<code class="fe my mz na nb b">18:[[7,2,5], [10,8]]</code>、<code class="fe my mz na nb b">24:[[7,2,5,10], [8]]</code>。只有 4 个值。但是我们的搜索空间<code class="fe my mz na nb b">[max(nums),sum(nums)]=[10,32]</code>不仅仅只有 4 个值。也就是说，无论我们如何分割输入数组，我们都无法获得搜索空间中的大多数值。</p><p id="dd69" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">假设<code class="fe my mz na nb b">k</code>是满足<code class="fe my mz na nb b">feasible</code>函数的最小值。我们可以用反证法证明我们解决方案的正确性。假设没有子阵列的和等于<code class="fe my mz na nb b">k</code>，即每个子阵列的和小于<code class="fe my mz na nb b">k</code>。<code class="fe my mz na nb b">feasible</code>函数中的变量<code class="fe my mz na nb b">total</code>记录当前负载的总重量。如果我们的假设是正确的，那么<code class="fe my mz na nb b">total</code>将总是小于<code class="fe my mz na nb b">k</code>。因此，<code class="fe my mz na nb b">feasible(k-1)</code>必须是<code class="fe my mz na nb b">True</code>，因为<code class="fe my mz na nb b">total</code>最多等于<code class="fe my mz na nb b">k-1</code>并且永远不会触发 if 子句<code class="fe my mz na nb b">if total &gt; threshold</code>，因此<code class="fe my mz na nb b">feasible(k-1)</code>必须具有与<code class="fe my mz na nb b">feasible(k)</code>相同的输出，即<code class="fe my mz na nb b">True</code>。但是我们已经知道<code class="fe my mz na nb b">k</code>是满足<code class="fe my mz na nb b">feasible</code>函数的最小值，那么<code class="fe my mz na nb b">feasible(k-1)</code>就得是<code class="fe my mz na nb b">False</code>，这是一个矛盾。所以我们的假设是不正确的。现在我们已经证明了我们的算法是正确的。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ob"><a href="https://leetcode.com/problems/koko-eating-bananas/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">科科吃香蕉- LeetCode</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">科科喜欢吃香蕉。有 N 堆香蕉，第 I 堆有成堆的香蕉。警卫已经走了，而且…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">leetcode.com</p></div></div><div class="ok l"><div class="ou l om on oo ok op ks ob"/></div></div></a></div><p id="7853" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">非常类似上面提到的 LC 1011 和 LC 410。让我们设计一个<code class="fe my mz na nb b">feasible</code>函数，给定一个输入<code class="fe my mz na nb b">speed</code>，确定科科是否能以每小时的进食速度<code class="fe my mz na nb b">speed</code>在<code class="fe my mz na nb b">H</code>小时内吃完所有香蕉。显然，搜索空间的下界是 1，上界是<code class="fe my mz na nb b">max(piles)</code>，因为科科每小时只能选择一堆香蕉吃。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ob"><a href="https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">制作 m 束鲜花的最少天数- LeetCode</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">给定一个整数数组 bloomDay，一个整数 m 和一个整数 k。我们需要做 m 个花束。要制作花束，你需要…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">leetcode.com</p></div></div><div class="ok l"><div class="ov l om on oo ok op ks ob"/></div></div></a></div><p id="f9ab" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">既然我们已经解决了上面的三个高级问题，这一个应该很容易做到。这个问题的单调性非常明显:如果我们能在等待<code class="fe my mz na nb b">d</code>天后制作<code class="fe my mz na nb b">m</code>花束，那么如果我们等待超过<code class="fe my mz na nb b">d</code>天，我们肯定也能完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ob"><a href="https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">乘法表中第 k 个最小的数- LeetCode</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">几乎每个人都用过乘法表。但是你能从…中快速找出第 k 个最小的数字吗？</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">leetcode.com</p></div></div><div class="ok l"><div class="ow l om on oo ok op ks ob"/></div></div></a></div><p id="2ba9" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">对于像这样的最小问题，我们首先想到的是堆。通常，我们可以维护一个最小堆，并只弹出堆的顶部 k 次。然而，这在这个问题中是行不通的。我们没有整个乘法表中的每个数字，相反，我们只有表的高度和长度。如果我们要应用堆方法，我们需要显式地计算这些<code class="fe my mz na nb b">m*n</code>值并将它们保存到堆中。这个过程的时间复杂度和空间复杂度都是 O(mn)，效率相当低。这是二分搜索法进来的时候。还记得我们说设计<code class="fe my mz na nb b">condition</code>功能是最难的部分吗？为了找到表中第 k 个最小值，我们可以设计一个<code class="fe my mz na nb b">enough</code>函数，给定一个输入<code class="fe my mz na nb b">num</code>，判断是否至少有 k 个值小于或等于<code class="fe my mz na nb b">num</code>。<strong class="lt iu">满足</strong> <code class="fe my mz na nb b"><strong class="lt iu">enough</strong></code> <strong class="lt iu">函数的最小 num 就是我们要找的答案</strong>。回想一下，二分搜索法的关键是发现单调性。在这个问题中，如果<code class="fe my mz na nb b">num</code>满足<code class="fe my mz na nb b">enough</code>，那么当然任何大于<code class="fe my mz na nb b">num</code>的值都可以满足。这种单调性是我们的二分搜索法算法的基础。</p><p id="5032" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">让我们考虑搜索空间。显然下界应该是 1，上界应该是乘法表中的最大值，也就是<code class="fe my mz na nb b">m * n</code>，那么我们就有了搜索空间<code class="fe my mz na nb b">[1, m * n]</code>。与堆解决方案相比，二分搜索法解决方案的压倒性优势在于，它不需要显式计算表中的所有数字，它只需要从搜索空间中选取一个值，并将<code class="fe my mz na nb b">enough</code>函数应用于该值，以确定我们应该保留搜索空间的左半部分还是右半部分。这样，二分搜索法方案只需要恒定的空间复杂度，比堆方案好得多。</p><p id="93cf" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">接下来让我们考虑如何实现<code class="fe my mz na nb b">enough</code>功能。可以观察到，乘法表中的每一行都只是其索引的倍数。例如，第三行<code class="fe my mz na nb b">[3,6,9,12,15...]</code>中的所有数字都是 3 的倍数。因此，我们可以逐行计数小于或等于输入<code class="fe my mz na nb b">num</code>的条目总数。以下是完整的解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="5b68" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">在上面的 LC 410 中，我们怀疑“二分搜索法的结果实际上是子阵列和吗？”。这里我们有一个类似的疑问:“<strong class="lt iu">二分搜索法的结果真的在乘法表里吗？</strong>”。答案是肯定的，我们也可以用矛盾来证明。将<code class="fe my mz na nb b">num</code>表示为满足<code class="fe my mz na nb b">enough</code>功能的最小输入。我们假设<code class="fe my mz na nb b">num</code>不在表中，也就是说<code class="fe my mz na nb b">num</code>不能被<code class="fe my mz na nb b">[1, m]</code>中的任何一个<code class="fe my mz na nb b">val</code>整除，也就是说<code class="fe my mz na nb b">num % val &gt; 0</code>。因此，将输入从<code class="fe my mz na nb b">num</code>更改为<code class="fe my mz na nb b">num - 1</code>对表达式<code class="fe my mz na nb b">add = min(num // val, n)</code>没有任何影响。所以<code class="fe my mz na nb b">enough(num)</code>也会返回<code class="fe my mz na nb b">True</code>，就像<code class="fe my mz na nb b">enough(num)</code>一样。但是我们已经知道<code class="fe my mz na nb b">num</code>是满足<code class="fe my mz na nb b">enough</code>函数的最小输入，所以<code class="fe my mz na nb b">enough(num - 1)</code>必须是<code class="fe my mz na nb b">False</code>。矛盾！与我们最初的假设相反的是正确的:<code class="fe my mz na nb b">num</code>实际上在表中。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ob"><a href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">找到第 K 个最小的配对距离- LeetCode</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">leetcode.com</p></div></div><div class="ok l"><div class="ox l om on oo ok op ks ob"/></div></div></a></div><p id="f5e3" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">非常类似于上面的 LC 668，两者都是关于寻找第 k 个最小的。就像 LC 668 一样，我们可以设计一个<code class="fe my mz na nb b">enough</code>函数，给定一个输入<code class="fe my mz na nb b">distance</code>，确定是否至少有 k 对的距离小于或等于<code class="fe my mz na nb b">distance</code>。我们可以对输入数组进行排序，并用两个指针(快指针和慢指针，指向一对)对其进行扫描。两个指针都从最左端开始。如果当前指向的指针对的距离小于或等于<code class="fe my mz na nb b">distance</code>，则这些指针之间的所有指针对都是有效的(因为数组已经排序)，我们将快速指针向前移动。否则，我们将慢速指针向前移动。当两个指针都到达最右端时，我们完成扫描，并查看总计数是否超过 k。实现如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="a7e2" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">显然，我们的搜索空间应该是<code class="fe my mz na nb b">[0, max(nums) - min(nums)]</code>。现在我们准备复制粘贴我们的模板:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ob"><a href="https://leetcode.com/problems/ugly-number-iii/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">丑陋的数字 III - LeetCode</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">leetcode.com</p></div></div><div class="ok l"><div class="oy l om on oo ok op ks ob"/></div></div></a></div><p id="0939" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">没什么特别的。仍然在寻找最小的。我们需要设计一个<code class="fe my mz na nb b">enough</code>函数，给定一个输入<code class="fe my mz na nb b">num</code>，确定是否有至少 n 个丑数小于或等于<code class="fe my mz na nb b">num</code>。由于<code class="fe my mz na nb b">a</code>可能是<code class="fe my mz na nb b">b</code>或<code class="fe my mz na nb b">c</code>的倍数，或者反过来，我们需要最大公约数的帮助来避免计算重复数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ob"><a href="https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">给定一个阈值，找出最小的除数</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">给定一个整数数组 num 和一个整数阈值，我们将选择一个正整数除数，并将所有的</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">leetcode.com</p></div></div><div class="ok l"><div class="oz l om on oo ok op ks ob"/></div></div></a></div><p id="a3c1" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">上面介绍了这么多问题，这个应该是小菜一碟。我们甚至不需要费心去设计一个<code class="fe my mz na nb b">condition</code>函数，因为问题已经明确告诉我们需要满足什么条件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="06bb" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">结束</h1><p id="725b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">哇，非常感谢你坚持到最后，真的很感激。从上面的 python 代码中可以看出，它们看起来都非常相似。那是因为我一直在复制粘贴我的模板。没有例外。这是我的模板强大的有力证明。我相信每个人都可以获得这个二分搜索法模板来解决许多问题。我们所需要的只是更多的练习来建立我们发现问题单调性的能力，并设计一个漂亮的<code class="fe my mz na nb b">condition</code>函数。</p><p id="c576" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">希望这有所帮助。</p><p id="c964" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><strong class="lt iu">参考</strong></p><ul class=""><li id="5b22" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/split-array-largest-sum/discuss/89819/C%2B%2B-Fast-Very-clear-explanation-Clean-Code-Solution-with-Greedy-Algorithm-and-Binary-Search" rel="noopener ugc nofollow" target="_blank">【c++/快速/非常清晰的解释/干净的代码】贪婪算法和二分搜索法的解决方案</a></li><li id="a817" class="mn mo it lt b lu nc lx nd ma ne me nf mi ng mm mu mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109082/Approach-the-problem-using-the-%22trial-and-error%22-algorithm" rel="noopener ugc nofollow" target="_blank">使用“试错”算法解决问题</a></li><li id="c5c4" class="mn mo it lt b lu nc lx nd ma ne me nf mi ng mm mu mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/binary-search/discuss/423162/Binary-Search-101-The-Ultimate-Binary-Search-Handbook" rel="noopener ugc nofollow" target="_blank">二分搜索法 101 终极二进制搜索手册——leet code</a></li><li id="9a22" class="mn mo it lt b lu nc lx nd ma ne me nf mi ng mm mu mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template" rel="noopener ugc nofollow" target="_blank">丑女三号二分搜索法配图&amp;二分搜索法模板— LeetCode </a></li></ul></div></div>    
</body>
</html>