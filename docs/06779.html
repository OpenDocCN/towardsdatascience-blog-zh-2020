<html>
<head>
<title>5 SQL tips to make your queries prettier and easier to read</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让您的查询更漂亮、更易读的 5 个 SQL 技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-sql-tips-to-make-your-queries-prettier-and-easier-to-read-d9e3a543514f?source=collection_archive---------9-----------------------#2020-05-27">https://towardsdatascience.com/5-sql-tips-to-make-your-queries-prettier-and-easier-to-read-d9e3a543514f?source=collection_archive---------9-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ddb2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">适当的查询可以让你省心。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/de6c0161ba6cc84096268a75f3aeffc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hwnpmrsnhX7CPBfp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@zamansizturk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿里·耶尔马兹</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="faad" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">如果我的查询已经可以运行了，为什么我还需要把它变得漂亮呢？</strong></h1><p id="483b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">嗯，SQL 查询可以被认为是普通的代码。即使它可以工作，但这可能还不够，肯定可以通过应用一些格式标准来改进。更漂亮的代码易于分析和维护。同样的原则也适用于 SQL 查询。</p><h2 id="5ac9" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">定时和误差</h2><p id="3b49" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您公司的同事必须检查您的工作，他将很难理解您试图用一个格式错误的查询做什么。</p><p id="9f6f" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">使用错误的或没有样式的规则将会导致同行评审的时间变慢，进入生产的时间变慢，更多的错误漏过，并且普遍缺乏评审你的工作的动力。当客户或同事要求您更改几个月前的查询时，糟糕的格式和样式也会产生影响。你完全忘记了那个巨大的查询是关于什么的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/7bfbce32bc985f14b7c3f3524c11bff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zzLAicqzlQy_eCjX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@punttim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tim Gouw </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5065" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">我和我的同事遇到的几乎所有奇怪的<strong class="lt iu">语法错误</strong>都主要是由于糟糕的格式造成的<strong class="lt iu">，因为很难发现错误放置的逗号或丢失的括号——这些是最糟糕的。</strong></p><p id="1123" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">开始吧！</p><h2 id="07ce" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated"><strong class="ak">与套管一致</strong></h2><p id="05fc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">查询的不同部分可以有不同的大小写，但是要一致。看看这个:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="20c0" class="mn la it ng b gy nk nl l nm nn">SELECT firstName, count(*) from Users WHERE last_name = ‘smith’ Group By firstName</span></pre><p id="c692" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">这个查询是<strong class="lt iu">绝对讨厌的</strong>😬。如果我是解析器，我肯定会抛出某种语法错误来修改这个查询。</p><p id="7a55" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">让我们在这里标记一些不好的事情:</p><ol class=""><li id="bdc1" class="no np it lt b lu mz lx na ma nq me nr mi ns mm nt nu nv nw bi translated">一些 SQL 关键字是大写的。有些是小写的。分组依据在标题中。关键字的最佳格式规则是<strong class="lt iu">对所有 SQL 关键字使用相同的大小写</strong>。小写和大写选项都是最常用的选项。</li><li id="619b" class="no np it lt b lu nx lx ny ma nz me oa mi ob mm nt nu nv nw bi translated">不容易区分小写关键字实际上是关键字还是列，因为大小写是混合的。除此之外，看书也很烦。</li><li id="f717" class="no np it lt b lu nx lx ny ma nz me oa mi ob mm nt nu nv nw bi translated">SELECT 中的第一列在 camelCase 中，WHERE 子句中使用的列在 snake_case 中，表名在 PascalCase 中。如果您在表格中遇到这种不一致的情况，一定要敲响警钟，并与您的团队一起决定您应该坚持哪种大小写。</li></ol><p id="abdf" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">经过一些清理后，查询应该如下所示:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="afe9" class="mn la it ng b gy nk nl l nm nn">SELECT first_name, COUNT(*) FROM users WHERE last_name = ‘smith’ GROUP BY first_name</span></pre><h2 id="b6b3" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated"><strong class="ak">使用缩进</strong></h2><p id="1869" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">试着阅读下面的查询，快速浏览一下，区分每个部分:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="28ef" class="mn la it ng b gy nk nl l nm nn">SELECT g.id, COUNT(u.id) FROM users u JOIN groups g on u.group_id = g.id WHERE u.name = 'John' GROUP BY g.id ORDER BY COUNT(u.id) desc</span></pre><p id="eef0" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">现在，用下面的一个来尝试同样的练习:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="70ff" class="mn la it ng b gy nk nl l nm nn">SELECT g.id, COUNT(u.id)<br/>FROM users u JOIN groups g on u.group_id = g.id<br/>WHERE u.name = 'John'<br/>GROUP BY g.id<br/>ORDER BY COUNT(u.id) desc</span></pre><p id="0a5e" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">你能看出区分每个部分有多容易吗？</p><p id="76ab" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">这可能是这个查询的一个小变化，但是想象一下必须处理那些有子查询、多个连接甚至窗口函数的查询。这是不一样的，不是吗？</p><p id="e7b7" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">让我们尝试添加另一个级别的缩进，看看它如何变得更容易:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="e656" class="mn la it ng b gy nk nl l nm nn">SELECT<br/>    g.id<br/>  , COUNT(u.id)<br/>FROM users u<br/>    JOIN groups g on u.group_id = g.id<br/>WHERE u.name = ‘John’<br/>GROUP BY<br/>    g.id<br/>ORDER BY<br/>    COUNT(u.id) desc</span></pre><blockquote class="oc od oe"><p id="be48" class="lr ls of lt b lu mz ju lw lx na jx lz og nb mc md oh nc mg mh oi nd mk ml mm im bi translated">专业提示:我开始在 SELECT 子句中的每个字段前使用逗号。我确保从第二列开始的每一行都以逗号开头，而不是在每一行后面都有一个逗号。在我看来，它更容易阅读，而且你不会有在 FROM 子句前留下逗号的问题，这有时会给你带来难以理解的语法错误，这取决于你的 RDBMS。</p></blockquote><p id="1353" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">对于不同级别的查询，使用 2 个空格还是 4 个空格可能会有一点偏好，但你不能说它看起来不会比一大行 SQL 更干净。或者更糟:同一缩进层次上的一大块 SQL。</p><p id="f4f1" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">相信我，你的同事会感激你的。😄</p><h2 id="a7a6" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated"><strong class="ak">在 group by 和 order by 子句中使用数字</strong></h2><p id="f0d4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">同样，这可能是一种偏好，你可以随意接受或不接受。但是在我的职业生涯中，我遇到了许多新手数据分析师，他们甚至不知道这个东西的存在。</p><p id="abf4" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">而不是:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="707b" class="mn la it ng b gy nk nl l nm nn">SELECT<br/>    first_name<br/>    , last_name<br/>    , COUNT(*)<br/>FROM users<br/>GROUP BY<br/>    first_name<br/>    , last_name<br/>ORDER BY<br/>    COUNT(*) desc</span></pre><p id="66b4" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">您可以:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="1fe8" class="mn la it ng b gy nk nl l nm nn">SELECT<br/>    first_name<br/>    , last_name<br/>    , COUNT(*)<br/>FROM users<br/>GROUP BY 1, 2<br/>ORDER BY 3 desc</span></pre><p id="b3fb" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">这带来了一系列简单的好处:</p><ul class=""><li id="ebd0" class="no np it lt b lu mz lx na ma nq me nr mi ns mm oj nu nv nw bi translated"><strong class="lt iu">您节省了行</strong>:按大量字段分组不仅会在 SELECT 子句中添加更多的行，还会在 GROUP BY 和 ORDER BY 子句中添加更多的行，甚至可能会使查询中的行数翻倍。</li><li id="ac01" class="no np it lt b lu nx lx ny ma nz me oa mi ob mm oj nu nv nw bi translated"><strong class="lt iu">可维护性</strong>:如果您想将列更改为 group by，只需在 select 子句中这样做，不需要记住在其他子句中也要这样做。</li><li id="4d59" class="no np it lt b lu nx lx ny ma nz me oa mi ob mm oj nu nv nw bi translated"><strong class="lt iu">更快:</strong>如果你有把分组字段放在第一位的好习惯，你唯一需要做的就是按 1，2，3，…，n 分组，n 为分组列的数量。</li><li id="dd56" class="no np it lt b lu nx lx ny ma nz me oa mi ob mm oj nu nv nw bi translated"><strong class="lt iu">兼容:</strong>如果你使用类似<a class="ae ky" href="https://www.getdbt.com" rel="noopener ugc nofollow" target="_blank"> dbt </a>的工具，你甚至可以使用 Jinja 来调用{{group_by(n)}}，它会翻译成适当的 group by 子句。</li></ul><h2 id="1924" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated"><strong class="ak">使用常用表表达式</strong></h2><p id="2f6a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">所谓的 cte 是用来简化复杂查询的工具。它们可以被定义为临时视图，因为它们只存在于整个查询的执行过程中。cte 使您能够创建将用于最终目的的子查询。</p><p id="af0f" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">让我们看一个简单的例子:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="d530" class="mn la it ng b gy nk nl l nm nn">WITH employee_by_title_count AS (<br/>    SELECT<br/>        t.name as job_title<br/>        , COUNT(e.id) as amount_of_employees<br/>    FROM employees e<br/>        JOIN job_titles t on e.job_title_id = t.id<br/>    GROUP BY 1<br/>),<br/>salaries_by_title AS (<br/>     SELECT<br/>         name as job_title<br/>         , salary<br/>     FROM job_titles<br/>)<br/>SELECT *<br/>FROM employee_by_title_count e<br/>    JOIN salaries_by_title s ON s.job_title = e.job_title</span></pre><p id="92d4" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">这里你可以看到我们在底层查询中使用了<code class="fe ok ol om ng b">employee_by_title</code>和<code class="fe ok ol om ng b">salaries_by_title</code>来产生最终结果。这比在 SELECT 子句中执行子查询或直接在 FROM 子句中执行子查询更具可读性和可维护性。特别是，如果您打算使用多个 cte，那么创建简单的 cte 要比创建一大块包含不同级别查询的 FROM 子句容易得多。</p><p id="7de6" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">不过，你最好小心点:确保你不会因为做了比应该做的更复杂的事情而显著降低性能。要检查查询性能，如果使用 PostgreSQL，可以使用 EXPLAIN ANALYZE。</p><h2 id="acf3" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">使用别名，有描述性</h2><p id="e965" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">每个专栏的恰当标题至关重要。这是人们在电子表格中看到的第一件事。" W <em class="of">我的帽子列有</em>？"想象一下，如果这个人有一个 csv，其中 3 列名为<code class="fe ok ol om ng b">id</code>，4 列名为<code class="fe ok ol om ng b">count</code>，其他列名为<code class="fe ok ol om ng b">avg</code>、<code class="fe ok ol om ng b">min</code>等等。他可能会发疯的！</p><p id="1fbb" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">让我们看看下面的查询:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="98e4" class="mn la it ng b gy nk nl l nm nn">SELECT<br/>    u.id<br/>    , u.name<br/>    , t.id<br/>    , t.name<br/>    , (SELECT COUNT(*) FROM job_titles where name = t.name)<br/>FROM users u<br/>    JOIN job_title t on u.job_title_id = t.id</span></pre><p id="f7ca" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">该查询的结果可能如下:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="88fb" class="mn la it ng b gy nk nl l nm nn">id, name, id, name, count<br/>1, John Wick, 4, hitman, 5</span></pre><p id="73c6" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">你大概可以看出<em class="of">疾速追杀</em>不是一个职位，所以第二列肯定是用户名。对于职业杀手来说也是如此，你可以肯定地说那是一个头衔。但是什么是<code class="fe ok ol om ng b">count</code>？😅谁也猜不到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/0797e7ad21c5e7b8799384e91a6c983e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lCYQz56geR3vy0Qh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@brucemars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁斯·马尔斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b139" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">现在让我们看看这个:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="8b27" class="mn la it ng b gy nk nl l nm nn">SELECT<br/>    u.id as user_id<br/>    , u.name as user_name<br/>    , t.id as job_title_id<br/>    , t.name as job_title_name<br/>    , (SELECT COUNT(*) FROM job_titles where name = t.name) as count_users_with_job<br/>FROM users u<br/>    JOIN job_title t on u.job_title_id = t.id</span></pre><p id="a7b8" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">这个查询将产生可读性更好、更容易理解的列。收到这份报告的人一眼就能发现有价值的信息，并且会比收到前一份报告的人快乐得多。</p><h1 id="7c42" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="33ed" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我的目的是通过这篇文章让你的生活更轻松。无论您是开发人员、数据分析师、数据科学家，还是您公司中的 SQL 人员，这都会派上用场，减少您工作中的许多麻烦。</p><p id="2e3d" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">记住:<strong class="lt iu">对于 SQL </strong>格式来说，没有单一的最佳标准或布局，但是肯定会有一个你最喜欢的<strong class="lt iu"/>。现在的挑战是找到那个特定的，并确保你和它保持一致。与你的同事讨论他们喜欢什么样的格式规则，并与团队达成<strong class="lt iu">共识</strong>，以确保你们都同意在公司的所有查询中使用相同的规则。</p><p id="4c71" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">我希望你觉得这很有用。下次见！😄</p></div></div>    
</body>
</html>