<html>
<head>
<title>What is Lazy Evaluation in Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的懒求值是什么？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-is-lazy-evaluation-in-python-9efb1d3bfed0?source=collection_archive---------5-----------------------#2020-09-14">https://towardsdatascience.com/what-is-lazy-evaluation-in-python-9efb1d3bfed0?source=collection_archive---------5-----------------------#2020-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c5ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你不知道 Python 为你优化了多少代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d25f97d112644e8cfcf65cca6a1c32bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UdQcLVB0noUConNV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@hollymandarich" rel="noopener ugc nofollow" target="_blank">霍利·曼达里奇</a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="60d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">如果</span>你以前从未听说过<em class="me">惰性求值</em>，<a class="ae ky" href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="noopener ugc nofollow" target="_blank"> <em class="me">惰性求值</em> </a>是一种求值策略，它将表达式的求值延迟到需要它的值时，同时也避免了重复求值(来自维基百科)。这通常被认为是一种优化代码的策略。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/aaec9357dfa0c5cfab6679a504c01ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-7ddWJ7hYQpw8Nbtg9HswA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者:高</p></figure><p id="bd49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把这个理论变成一个例子。例如，你有一个简单的表达式<code class="fe mg mh mi mj b">sum = 1 + 2</code>，Python 会试图理解这个表达式的真正含义并得出结论<code class="fe mg mh mi mj b">sum = 3</code>。这个过程被称为<em class="me">评估</em>，它需要某种计算能力。在这种情况下，<strong class="lb iu">评估立即完成</strong>，因此它有另一个名称:<em class="me">严格评估</em>。</p><p id="e5fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，我们有一个不严格的评价，叫做<em class="me">懒评价。</em>不同的是<strong class="lb iu"> <em class="me">懒求值</em>不会立即对表达式求值，而是只在需要结果时才求值。</strong>有点像一个懒惰的学生，只在作业需要交给老师的时候才去做。</p><p id="1ee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在这里偷懒不一定是坏事，它可以提高你代码的效率，节省大量资源。幸运的是，Python 已经悄悄地将<em class="me">惰性评估</em>应用于许多内置函数，以优化您的代码。我敢肯定，即使没有意识到<em class="me">懒惰评估，您也必须熟悉这些功能。</em></p><p id="1e43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将解释<em class="me">懒惰求值</em>在 Python 中是如何工作的，哪些函数从中受益，以及背后的原因。最后，我将向您展示如何编写自己的<em class="me">惰性</em>函数/类。我们开始吧！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="1d4e" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">范围()</h2><p id="05f0" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">很多时候 Python 还是会立即对 expression 求值。让我们看看这个例子。你觉得需要多长时间？</p><pre class="kj kk kl km gt np mj nq nr aw ns bi"><span id="a7c6" class="mr ms it mj b gy nt nu l nv nw">print([time.sleep(0), time.sleep(1), time.sleep(2)][0])</span></pre><p id="8bc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是 3 秒。这是因为当你创建一个列表时，Python 会立即评估列表中的每一项，即使你只需要第一个元素。</p><p id="58a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从 Python3 开始，在让这样的列表遍历更加内存高效和时间高效方面有了很大的改进，这就是<code class="fe mg mh mi mj b">range()</code>函数。我敢打赌，每个 Python 开发人员一生中都至少使用过一次这个函数。在 Python2 中，<code class="fe mg mh mi mj b">range(5)</code>将返回一个包含 5 个元素的列表。随着列表大小的增加，会使用更多的内存。</p><pre class="kj kk kl km gt np mj nq nr aw ns bi"><span id="3a50" class="mr ms it mj b gy nt nu l nv nw">Python 2.7.16<br/>&gt;&gt;&gt; range(5)<br/>[0, 1, 2, 3, 4]<br/>&gt;&gt;&gt; import sys<br/>&gt;&gt;&gt; sys.getsizeof(range(5))<br/>112<br/>&gt;&gt;&gt; sys.getsizeof(range(500))<br/>4072</span></pre><p id="c4dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而在 Python 3 中，<code class="fe mg mh mi mj b">range(5)</code>返回一个范围类型。这个对象可以被迭代以产生一个数字序列。无论范围有多大，对象总是具有相同的大小。这是因为<code class="fe mg mh mi mj b">range(5)</code>只存储<em class="me">开始</em>、<em class="me">停止、</em>、<em class="me">步骤</em>的值，需要时计算每一项。</p><pre class="kj kk kl km gt np mj nq nr aw ns bi"><span id="7dcf" class="mr ms it mj b gy nt nu l nv nw">Python 3.7.7<br/>&gt;&gt;&gt; range(5)<br/>range(0, 5)<br/>&gt;&gt;&gt; import sys<br/>&gt;&gt;&gt; sys.getsizeof(range(5))<br/>48<br/>&gt;&gt;&gt; sys.getsizeof(range(500))<br/>48</span></pre><p id="a8e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">如果你不熟悉生成器、迭代器及其好处，请继续阅读本节。否则，请随意跳过这一部分。</em></p><p id="1650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">迭代器&gt;生成器</strong></p><p id="13ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，迭代器是一个比生成器更大的概念。迭代器是一个<strong class="lb iu">对象</strong>，它的类有一个<code class="fe mg mh mi mj b">__next__</code>和<code class="fe mg mh mi mj b">__iter__</code>方法。每次你调用迭代器对象时，你会得到序列中的下一个条目，直到迭代器对象用尽并引发<code class="fe mg mh mi mj b">StopIteration</code>。然而，生成器是一个返回迭代器的<strong class="lb iu">函数</strong>。除了使用了<code class="fe mg mh mi mj b">yield</code>而不是<code class="fe mg mh mi mj b">return</code>之外，它看起来就像一个普通的函数。</p><p id="e5fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当执行<code class="fe mg mh mi mj b">yield</code>语句时，程序会暂停当前函数的执行，并将产生的值返回给调用者。这是<em class="me">惰性求值</em>的关键思想，当需要调用者时计算并返回值，下一个值仍然是安静的，在程序中不做任何事情。</p><p id="baab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建生成器，有两种方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建发电机的两种方法</p></figure><p id="4b90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，让我们用<code class="fe mg mh mi mj b">range()</code>来改进第一个例子。在我们得出最终结果之前，还有另一个“陷阱”。下面的例子有两个功能:<code class="fe mg mh mi mj b">use_generator()</code>和<code class="fe mg mh mi mj b">use_list()</code>。除了<code class="fe mg mh mi mj b">use_generator()</code>在<code class="fe mg mh mi mj b">islice()</code>功能中使用<code class="fe mg mh mi mj b">()</code>，而<code class="fe mg mh mi mj b">use_list()</code>使用<code class="fe mg mh mi mj b">[]</code>之外，它们看起来几乎一样。然而，这种微小的差异会对运行时间产生巨大的影响。</p><p id="df2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种行为的答案已经存在于函数名中。<code class="fe mg mh mi mj b">(time.sleep(x) for x in range(3))</code>是一个生成器，而<code class="fe mg mh mi mj b">[time.sleep(x) for x in range(3)]</code>是一个列表，尽管它使用了<code class="fe mg mh mi mj b">range()</code>。因此，使用 list 的函数比另一个函数花费更多的时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你理解了这部分，那么恭喜你，你已经对<em class="me">懒评</em>了解了 50%。</p><h2 id="eaf8" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">Zip()</h2><p id="106d" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">一个非常相似的用例是<code class="fe mg mh mi mj b">zip()</code>，它合并两个可重复项来产生一个元组序列。在 Python2 中，<code class="fe mg mh mi mj b">zip(*iterables)</code>将返回元组列表。</p><pre class="kj kk kl km gt np mj nq nr aw ns bi"><span id="7843" class="mr ms it mj b gy nt nu l nv nw">Python 2.7.16<br/>&gt;&gt;&gt; type(zip([1,2],[3,4]))<br/>&lt;type 'list'&gt;<br/>&gt;&gt;&gt; import sys<br/>&gt;&gt;&gt; sys.getsizeof(zip([1,2],[3,4]))<br/>88<br/>&gt;&gt;&gt; sys.getsizeof(zip([i for i in range(500)],[i for i in range(500)]))<br/>4072</span></pre><p id="9198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而从 Python3 开始，已经改进为返回一个类似于<code class="fe mg mh mi mj b">range</code>对象的<code class="fe mg mh mi mj b">zip</code>对象，可以迭代。</p><pre class="kj kk kl km gt np mj nq nr aw ns bi"><span id="e618" class="mr ms it mj b gy nt nu l nv nw">Python 3.7.7 <br/>&gt;&gt;&gt; type(zip([1,2],[3,4]))<br/>&lt;class 'zip'&gt;<br/>&gt;&gt;&gt; import sys<br/>&gt;&gt;&gt; sys.getsizeof(zip([1,2],[3,4]))<br/>72<br/>&gt;&gt;&gt; sys.getsizeof(zip([i for i in range(500)],[i for i in range(500)]))<br/>72</span></pre><p id="ff71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因我就不再重复了，因为它和<code class="fe mg mh mi mj b">range()</code>的思路一样。但是如果你想了解<code class="fe mg mh mi mj b">zip</code>的其他方面，可以随意看我的另一篇文章。</p><div class="nz oa gp gr ob oc"><a rel="noopener follow" target="_blank" href="/understand-zip-a-hidden-gem-in-python-9488a255f45d"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">理解 zip()—Python 中隐藏的瑰宝</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">有效地合并未知数量的列表</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div><h2 id="4f82" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">打开()</h2><p id="e76d" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这是另一个内置功能，我们可能每天都在使用它，并认为它是理所当然的。当我们打开一个文件时，我们通常会:</p><pre class="kj kk kl km gt np mj nq nr aw ns bi"><span id="0763" class="mr ms it mj b gy nt nu l nv nw">with open("file.csv", "r") as f:<br/>    for line in f:<br/>      print(line)</span></pre><p id="4ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi mj b">with open(...)</code>不读取整个文件并将其存储在内存中，而是返回一个可以迭代的 file 对象。正因为如此，它能够有效地读取巨大的文件，而不伤害内存。</p><h2 id="877a" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">λ表达式</h2><p id="cb17" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">几周前，我收到了一位读者关于 Lambda 表达式的问题，这实际上引发了我写这篇文章。他的问题是:</p><blockquote class="or"><p id="fbd2" class="os ot it bd ou ov ow ox oy oz pa lu dk translated">为什么像 x = map(lambda x: x*2，[1，2，3，4，5])这样的 lambda map 对象不占用任何空间？但是如果你做了 list(x)，它会打印所有的值并占用内存空间？</p></blockquote><p id="0ed4" class="pw-post-body-paragraph kz la it lb b lc pb ju le lf pc jx lh li pd lk ll lm pe lo lp lq pf ls lt lu im bi translated">我希望到目前为止，你应该对这里发生的事情有所了解。<code class="fe mg mh mi mj b">map</code>对象也是一个可以迭代的惰性对象。在每个循环中只对 1 个项目进行计算<code class="fe mg mh mi mj b">x*2</code>。做<code class="fe mg mh mi mj b">list(x)</code>的时候，基本上是一次性计算完所有的值。如果只是想迭代<code class="fe mg mh mi mj b">map</code>对象，就不用做<code class="fe mg mh mi mj b">list(x)</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">lambda 表达式中的惰性求值</p></figure><h2 id="f8d1" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">如何写一个懒惰的评价函数/类？</h2><p id="37d4" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在文章的最后一部分，我想把我们带到下一个层次，在这里我们编写自己的<em class="me">懒惰评估</em>函数/类。这有助于我们扩展内置功能之外的功能。</p><p id="a83b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所理解的，惰性求值的一个关键部分无非是一个生成器。因此，我们可以简单地把函数写成一个生成器。</p><p id="5bc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="me">懒惰功能—生成器</em> </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">惰性函数:生成器</p></figure><p id="c4db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="me">懒惰属性—装饰者</em> </strong></p><p id="219e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自定义惰性计算的另一个常见用例是类属性的初始化。当我们初始化一个类时，某些属性可能需要很长时间来计算。在下面的例子中，属性<code class="fe mg mh mi mj b">cities</code>花费了更长的时间，因为它需要调用一个 API 来获取城市名称列表。因此，如果我们对于一些国家对象实际上不需要这个值，那将是浪费时间。</p><p id="29d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个博客中的一个好的解决方案是为这样的<em class="me">懒惰</em>属性创建一个装饰器，这样昂贵的操作只有在需要这个属性的时候才会被执行。从控制台输出可以看到，<code class="fe mg mh mi mj b">cities property is called</code>是在我们打印出<code class="fe mg mh mi mj b">china.cities</code>之后打印出来的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">惰性属性:装饰者</p></figure><p id="dee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能启发你对代码优化有一个新的看法。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="493e" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">参考:</h2><div class="nz oa gp gr ob oc"><a href="https://stevenloria.com/lazy-properties/" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">Python 中延迟求值的属性模式</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">惰性求值是一种有用的模式，在许多情况下可以提高代码的效率。这方面的一个例子是…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">stevenloria.com</p></div></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://sanjayasubedi.com.np/python/python-tips-lazy-evaluation-in-python/" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">Python 技巧:Python 中的惰性求值</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">虽然小数据集可能适合您的主内存，但不是所有的数据集都适合。有时您无法读取整个数据集…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">sanjayasubedi.com.np</p></div></div><div class="ol l"><div class="pg l on oo op ol oq ks oc"/></div></div></a></div></div></div>    
</body>
</html>