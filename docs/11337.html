<html>
<head>
<title>What’s New in Python 2020 — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 2020 的新特性—第 1 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/whats-new-in-python-2020-part-1-c101939c8800?source=collection_archive---------18-----------------------#2020-08-06">https://towardsdatascience.com/whats-new-in-python-2020-part-1-c101939c8800?source=collection_archive---------18-----------------------#2020-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d55f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python 过去(3.7)、现在(3.8)、未来(3.9)的幽灵正在 2020 年拜访你。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/945cbac90edee3cddb7e51f19c0a4057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gqpwhigkx0DvM5rh"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯里德在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0591" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自从很久以前切换到 Python 3(*咳咳* —我<em class="ls">希望</em>那是很久以前的事了！)，语言层面的特性变化相对较小。然而，在每个版本中，从事 Python 工作的天才们都在不断添加我不能缺少的东西。</p><p id="9cf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着 Python 3.8 于 2019 年 10 月发布，我发现自己在使用该语言的一些功能，当我第一次读到它们时，让我说“随便吧”。</p><ul class=""><li id="010e" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">3.5-类型注释</li><li id="c60b" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">3.6 — asyncio</li><li id="13d3" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">3.7 —数据类</li><li id="eab9" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">3.8 —赋值表达式又名海象运算符</li></ul><p id="6ad9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 3.9 中，字典联合操作符和泛型类型提示。尽量减少感叹号，但这是令人兴奋的事情！</p><p id="ffeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上所述，我一直在专业地使用代码库，并在我的项目中寻找乐趣。</p><blockquote class="mh mi mj"><p id="44a8" class="kw kx ls ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">快速演讲:如果您还在使用旧版本的 Python 工作或项目，不要害怕升级！您的旧代码仍然可以工作，而且您将获得 Python 新特性的好处！</p><p id="882f" class="kw kx ls ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">声明:如果你还在使用 Python 2.7，这是不正确的。但在这种情况下，你不是那种会接受好建议的人。😎</p></blockquote><p id="ae00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面我将(快速)回顾一些我最喜欢的特性，希望你会发现它们每天都在你的编码中使用。</p><p id="37f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们是:类型注释、数据类、字典联合操作符、walrus 操作符。</p><p id="3b9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一部分:输入注释，walrus 操作符。</p><h1 id="921e" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">打字— 3.5 以上</h1><p id="a32d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">从 Python 3 开始，打字就已经成为一项功能。因为我们是开发者，而不是历史学家，所以现在(2020 年)将会有类型注释和类型提示。</p><p id="8a44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python 不需要给变量赋值类型。这可能是我如此热爱这门语言的部分原因。清晰易读的语法。用 24 种不同的方法中的一种来编码解决方案并仍然得到相同结果的能力。</p><p id="2376" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是后来…应用程序增长了。或者你得看看你几个月或几年没碰过的代码。或者，最糟糕的是，你还得理解别人写的代码！<em class="ls">*战栗* </em></p><p id="504a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后你意识到输入变量对解释器没有好处。这是给你的。</p><p id="db51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">键入有助于您在编写代码时以及以后理解代码。TypeScript 如此受欢迎是有原因的，即使 JavaScript 完全能够编译成没有类型的工作代码。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="1ba7" class="np mo iq nl b gy nq nr l ns nt">from typing import List<br/>​<br/>def print_cats(cats: List[str]) -&gt; None:<br/>    for cat in cats:<br/>        print(f"{cat} has a name with {len(cat)} letters.")<br/>​<br/>        <br/>class Cat(object):<br/>    def __init__(self, name: str, age: int, **attrs):<br/>        self.cattributes = {<br/>            "name": name,<br/>            "age": age,<br/>            **attrs<br/>        }<br/>​<br/>cats = "this still works w/o type annotation!"<br/>cats: List[str] = ["Meowie", "Fluffy", "Deathspawn"]<br/># not a list of strings, but Python will not check<br/>cats2: List[str] = [Cat("Meowie", 2), Cat("Deathspawn", 8)]<br/>​<br/>print_cats(cats) # succeeds<br/>print_cats(cats2) # fails</span></pre><p id="8844" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将返回:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="2358" class="np mo iq nl b gy nq nr l ns nt">Meowie has a name with 6 letters.<br/>Fluffy has a name with 6 letters.<br/>Deathspawn has a name with 10 letters.<br/>--------------------------------------------<br/>...<br/>TypeError: object of type 'Cat' has no len()</span></pre><p id="6184" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，类型注释并没有拯救我们，那么为什么要使用它们呢？因为当创建变量<code class="fe nu nv nw nl b">cats</code>并用<code class="fe nu nv nw nl b">List[str]</code>键入它时，显而易见，分配的数据应该与该结构匹配。所以当一个函数稍后消耗<code class="fe nu nv nw nl b">cats</code>时，它变得(更加)明显，你传递的数据正是它所期望的。</p><p id="6890" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为，对于具有复杂类型的可维护代码来说，这变得更加有用——必要。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="b4e4" class="np mo iq nl b gy nq nr l ns nt">from typing import List<br/>​<br/>​<br/>class Cat(object):<br/>    def __init__(self, name: str, age: int, **attrs):<br/>        self.cattributes = {<br/>            "name": name,<br/>            "age": age,<br/>            **attrs<br/>        }<br/>​<br/># creating a type variable<br/>Cats: type = List[Cat]<br/>​<br/>​<br/>def print_cats(cats: Cats) -&gt; None:<br/>    for cat in cats:<br/>        name: str = cat.cattributes.get("name")<br/>        print(f"{name} has a name with {len(name)} letters.")<br/>        <br/>cats = [Cat("Meowie", 2), Cat("Deathspawn", 8)]<br/>​<br/>print_cats(cats)</span></pre><p id="8c2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="36ee" class="np mo iq nl b gy nq nr l ns nt">Meowie has a name with 6 letters.<br/>Deathspawn has a name with 10 letters.</span></pre><p id="bf3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在函数/方法的定义中输入参数被称为<em class="ls">类型提示</em>。类型甚至不必是 Python 数据类型或来自<code class="fe nu nv nw nl b">typing</code>模块。一个简单的，虽然有点尴尬的文本提示是完全合法的:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="d449" class="np mo iq nl b gy nq nr l ns nt">import pandas as pd<br/>​<br/>cols = ["name", "age", "gender"]<br/>data = [["Meowie", 2, "female"],<br/>       ["Fluffy", 5, "male"],<br/>       ["Deathspawn", 8, "rather not say"]]<br/>df: pd.DataFrame = pd.DataFrame() # not very descriptive<br/>df: "name (string), age (integer), gender (string)" = \<br/>    pd.DataFrame(data, columns=cols)</span></pre><p id="153d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似这样的东西在包含大量复杂类型变量的数据处理管道中可能会很有用，并且您的脑袋开始发晕，试图让它们保持直线。在变量 mouseover 上有类型提示的 ide 也会显示那个提示，而不是<code class="fe nu nv nw nl b">pandas.DataFrame</code>，如果它有 Python 支持的话。</p><p id="b357" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">奖励:</strong>在 Python 4 中，前向引用将被允许开箱即用。这意味着您可以注释尚未定义的类型。我们现在仍然可以通过将<code class="fe nu nv nw nl b">from __future__ import annotations</code>放在文件的顶部来利用这一优点，然后做如下事情:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="4c91" class="np mo iq nl b gy nq nr l ns nt">from __future__ import annotations<br/>​<br/>class Food:<br/>    """ Look at the type hint. Food is legal even without the <br/>    class defined yet.<br/>    """<br/>    def __init__(self, ingred_1: Food, ingred_2: Food) -&gt; None:<br/>        self.ingred_1 = ingred_1<br/>        self.ingred_2 = ingred_2</span></pre><h1 id="d1b1" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">原生类型注释— 3.9(很快将成为我的最爱)</h1><p id="fefe" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">这将是真正的快速，因为我把打字部分拖了出来。</p><p id="e3c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.python.org/dev/peps/pep-0585/" rel="noopener ugc nofollow" target="_blank">内置的泛型类型</a>将是 3.9 中的东西，所以从<code class="fe nu nv nw nl b">typing</code>导入来添加参数到泛型数据类型将不再是必要的。从 3.7 开始，<code class="fe nu nv nw nl b">from __futures__ import annotations</code>就提供了这一功能，但这是因为它阻止了类型引用在运行时被求值。</p><p id="ef70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这让我对从 3.8 升级感到兴奋。现在我将<code class="fe nu nv nw nl b">typing</code>导入到每个模块中，或者从我保存在代码旁边的类型定义模块中导入。</p><p id="1975" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例(信用:<a class="ae kv" href="https://www.python.org/dev/peps/pep-0585/" rel="noopener ugc nofollow" target="_blank"> PEP 585 </a>):</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="a756" class="np mo iq nl b gy nq nr l ns nt">&gt;&gt;&gt; l = list[str]()<br/>[]<br/>&gt;&gt;&gt; list is list[str]<br/>False<br/>&gt;&gt;&gt; list == list[str]<br/>False<br/>&gt;&gt;&gt; list[str] == list[str]<br/>True<br/>&gt;&gt;&gt; list[str] == list[int]<br/>False<br/>&gt;&gt;&gt; isinstance([1, 2, 3], list[str])<br/>TypeError: isinstance() arg 2 cannot be a parameterized generic<br/>&gt;&gt;&gt; issubclass(list, list[str])<br/>TypeError: issubclass() arg 2 cannot be a parameterized generic<br/>&gt;&gt;&gt; isinstance(list[str], types.GenericAlias)<br/>True</span><span id="8353" class="np mo iq nl b gy nx nr l ns nt">def find(haystack: dict[str, list[int]]) -&gt; int:<br/>    ...</span></pre><h1 id="dacf" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">海象运营商——3.8(我的最爱)</h1><p id="f57f" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">海象有眼睛<code class="fe nu nv nw nl b">:</code>然后是长牙<code class="fe nu nv nw nl b">=</code>。</p><p id="ed50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nl b">:=</code>是一个<em class="ls">赋值表达式</em>，在 Python 3.8 中新增。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="15a6" class="np mo iq nl b gy nq nr l ns nt">complicated = {<br/>    "data": {<br/>        "list": [1,2,3],<br/>        "other": "stuff"<br/>    }<br/>}<br/>​<br/>if (nums := complicated.get('data').get('list')):<br/>    print(nums)</span></pre><p id="2064" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="9b40" class="np mo iq nl b gy nq nr l ns nt">1<br/>2<br/>3</span></pre><p id="6a1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有海象，这将是更多的代码行。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="4a01" class="np mo iq nl b gy nq nr l ns nt">...<br/>​<br/>nums = complicated.get('data').get('list')<br/>if nums:<br/>    print(nums)</span></pre><p id="cb84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不是世界末日，但是因为控制流语句在编程中经常被使用，一旦你开始使用 walrus 操作符，你就不会停止。</p><p id="fa6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自<a class="ae kv" href="https://www.python.org/dev/peps/pep-0572/#id9" rel="noopener ugc nofollow" target="_blank"> PEP 572 </a>:</p><blockquote class="mh mi mj"><p id="f076" class="kw kx ls ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">这种命名表达式的值与合并表达式的值是相同的，但有一个额外的副作用，即目标被赋予该值</p></blockquote><p id="d6a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，用一个表达式杀死两个语句。</p><p id="8f09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我复制/粘贴 PEP 指南时，这里有几个我认为很好的例子。迫不及待地想在列表理解中尝试一下 walrus 运算符。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="3c94" class="np mo iq nl b gy nq nr l ns nt"># Handle a matched regex<br/>if (match := pattern.search(data)) is not None:<br/>    # Do something with match<br/>​<br/># A loop that can't be trivially rewritten using 2-arg iter()<br/>while chunk := file.read(8192):<br/>   process(chunk)<br/>​<br/># Reuse a value that's expensive to compute<br/>[y := f(x), y**2, y**3]<br/>​<br/># Share a subexpression between a comprehension filter clause and its output<br/>filtered_data = [y for x in data if (y := f(x)) is not None]</span></pre><h1 id="d74a" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="70bc" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">最近对 Python 语言的补充提供了一些相当不错的特性供练习。我希望我对打字和海象操作符的看法对你有用。</p><p id="de2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/@nball/whats-new-in-python-2020-part-2-1d9abb0f0e7c" rel="noopener">第 2 部分</a>中，我们将看看内置库的数据类，同时也看看需要考虑的一些原因<code class="fe nu nv nw nl b">pydantic</code>。我们还将介绍 dictionary union 操作符，这是 Python 3.9 语法中的一项新内容。</p></div></div>    
</body>
</html>