<html>
<head>
<title>Data wrangling and supervised learning in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的数据争论和监督学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-wrangling-and-supervised-learning-in-python-predicting-ebola-outbreaks-in-sierra-leone-325657f7fa2e?source=collection_archive---------47-----------------------#2020-07-22">https://towardsdatascience.com/data-wrangling-and-supervised-learning-in-python-predicting-ebola-outbreaks-in-sierra-leone-325657f7fa2e?source=collection_archive---------47-----------------------#2020-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5107" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">预测塞拉利昂的埃博拉疫情</strong></h2></div></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><p id="657e" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu"> <em class="ll">这篇文章是由</em> </strong> <a class="ae lm" href="https://www.linkedin.com/in/nicol%C3%A1s-d%C3%ADaz-amigo-3602ab121/" rel="noopener ugc nofollow" target="_blank"> <strong class="kr iu"> <em class="ll">尼古拉斯·迪亚兹</em> </strong> </a> <strong class="kr iu"> <em class="ll">、MPP’20 在哈佛肯尼迪学院的一个项目基础上加上</em> </strong> <a class="ae lm" href="https://www.linkedin.com/in/tzeniyeoh/" rel="noopener ugc nofollow" target="_blank"> <strong class="kr iu"> <em class="ll">杨子倪</em></strong></a><a class="ae lm" href="https://www.linkedin.com/in/abdulla-saif-51072119a/" rel="noopener ugc nofollow" target="_blank"><strong class="kr iu"><em class="ll">阿卜杜拉·赛义夫</em></strong><strong class="kr iu"><em class="ll"/></strong>T51】</a></p><p id="7166" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="ll">在这里</em>  <em class="ll">有一个 GitHub，里面有这个项目的 Jupyter 笔记本。</em></p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><p id="b853" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">监督学习是世界上使用最广泛的机器学习形式之一。本文将指导您完成构建模型所需的一些最基本的步骤:导入数据、查看数据、以一致的格式输入数据、使用数据样本来训练和测试算法以及优化算法参数。</p><p id="2e8a" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">代码用 Python 显示，Python 是一种通用的编程语言。</p><p id="9a95" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们选择的挑战是预测 2014-2016 年塞拉利昂爆发期间埃博拉在各地区的传播。</p><h1 id="8e32" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated"><strong class="ak">问题动机和目标</strong></h1><p id="45f2" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">西非埃博拉病毒疫情(2014 年至 2016 年)造成 11 325 人死亡和重大社会经济破坏，其中大多数死亡发生在沿海国家塞拉利昂。在疫情期间，国家当局有足够的资源来隔离和治疗所有报告的病例，并阻止病毒的进一步传播。然而，事件总数的意外地方差异造成某些地区的应对能力不足(《世卫组织情况报告》，2014 年)。</p><p id="dbd1" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在当前和未来的埃博拉紧急情况下，需要一个补充工具来指导跨地区的资源分配和提高应对效力。</p><h1 id="fce6" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated"><strong class="ak">数据清理</strong></h1><h2 id="e83b" class="mk lo it bd lp ml mm dn lt mn mo dp lx ky mp mq lz lc mr ms mb lg mt mu md mv bi translated"><strong class="ak">导入适当的库</strong></h2><p id="622f" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">首先，我们<code class="fe mw mx my mz b">import </code>将在整个项目中使用的库。<code class="fe mw mx my mz b">Pandas </code>是 Python 中主要的数据帧操作库，<code class="fe mw mx my mz b">Sklearn </code>是运行机器学习模型的直观方式。对于<code class="fe mw mx my mz b">Pandas</code>，我们将使用<code class="fe mw mx my mz b">set_option </code>更改默认设置，以获得更舒适的大桌子显示。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="41c2" class="mk lo it mz b gy ni nj l nk nl">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="8bb2" class="mk lo it mz b gy nm nj l nk nl">pd.set_option('display.max_rows', 500)<br/>pd.set_option('display.max_columns', 500)<br/>pd.set_option('display.width', 1000</span><span id="644b" class="mk lo it mz b gy nm nj l nk nl">from sklearn.metrics import mean_squared_error,median_absolute_error,r2_score,mean_absolute_error, accuracy_score, roc_curve, roc_auc_score, confusion_matrix</span><span id="a0a7" class="mk lo it mz b gy nm nj l nk nl">from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV</span><span id="454c" class="mk lo it mz b gy nm nj l nk nl">from sklearn.feature_selection import SelectKBest, chi2, f_classif<br/>from sklearn.pipeline import Pipeline</span><span id="c3b4" class="mk lo it mz b gy nm nj l nk nl">from sklearn.ensemble import RandomForestRegressor</span></pre><h2 id="19fb" class="mk lo it bd lp ml mm dn lt mn mo dp lx ky mp mq lz lc mr ms mb lg mt mu md mv bi translated">检查和理解数据</h2><p id="7ec0" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">一旦我们导入了库，我们就用 Pandas 的<code class="fe mw mx my mz b">read_csv()</code>方法加载数据。许多有用的方法允许快速检查数据帧:<code class="fe mw mx my mz b">shape</code>、<code class="fe mw mx my mz b">head()</code>、<code class="fe mw mx my mz b"> tail()</code>和<code class="fe mw mx my mz b">info</code>。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="e0e1" class="mk lo it mz b gy ni nj l nk nl">df = pd.read_csv('sl_ebola.csv')<br/>df.shape</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5efa31f3f44f777f29c99b415d13f20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/0*J06Epw91xUFWqVF-"/></div></figure><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="b364" class="mk lo it mz b gy ni nj l nk nl">df.head(14)</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/0566a111f8b651ad96159ecc78b6ce41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oni683AppMXHDzA9"/></div></div></figure><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="d585" class="mk lo it mz b gy ni nj l nk nl">df.tail()</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/313d606fe523e6e7b3281798df1d11ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*164j9rVRPC4VP2RJ"/></div></div></figure><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="3a73" class="mk lo it mz b gy ni nj l nk nl">df.info</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/32dfd751fe5fc5ca646db08e2ed3cdaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*gf4paiquaP4J96A3"/></div></figure><p id="063a" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">看着上面的变量，我们有兴趣更深入地挖掘一些列。将<code class="fe mw mx my mz b">value_counts()</code>应用到特定的列将返回每个类有多少个实例。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="e0e4" class="mk lo it mz b gy ni nj l nk nl">print(df.Country.value_counts(), '\n')<br/>print(df.District.value_counts(), '\n')<br/>print(df['Ebola measure'].value_counts(), '\n')</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi ny"><img src="../Images/29643713258f1255c2d98f267bd340c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hjCHkD_bjxQSTx5L"/></div></div></figure><p id="f8b5" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们可以确认我们所有的行都来自塞拉利昂，并且所有地区都有相同数量的实例，这是我们所期望的。</p><h2 id="6946" class="mk lo it bd lp ml mm dn lt mn mo dp lx ky mp mq lz lc mr ms mb lg mt mu md mv bi translated">删除因缺少值或不相关而无用的列</h2><p id="634b" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">现在，前面的<code class="fe mw mx my mz b">info </code>方法揭示了我们的一些列包含了大部分缺失的值。我们可以通过在我们的数据框架中使用<code class="fe mw mx my mz b">drop()</code>方法来消除这些。<code class="fe mw mx my mz b">inplace </code>设置为<code class="fe mw mx my mz b">True </code>意味着它将修改我们的起始数据帧，我们不必重新定义它。我们可以使用<code class="fe mw mx my mz b">head()</code>方法来查看一切是否正常。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="2d7a" class="mk lo it mz b gy ni nj l nk nl">df.drop(columns=['Age group', 'Gender', 'Data as of', 'Outbreak identifier', 'Country', 'Indicator type'], inplace = True)</span><span id="3858" class="mk lo it mz b gy nm nj l nk nl">df.head()</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nz"><img src="../Images/0cc73eb8170f759181975fe4d1cb1ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mcw3Mzq3UhAANYYi"/></div></div></figure><h2 id="aeb9" class="mk lo it bd lp ml mm dn lt mn mo dp lx ky mp mq lz lc mr ms mb lg mt mu md mv bi translated">删除不相关的无用行</h2><p id="366f" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">我们还需要删除不会用于我们分析的行(例如，当它们是一个聚合时)。我们可以通过使用条件选择(<code class="fe mw mx my mz b">!=</code>表示不同于)并将其保存到一个新的 dataframe 名称<code class="fe mw mx my mz b">df2</code>来实现。我们在这一点上重新定义了数据帧，因为这样我们就不必在出错时从头开始。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="8fe3" class="mk lo it mz b gy ni nj l nk nl">df2 = df[df.District != 'Aggregate']</span></pre><h2 id="8c51" class="mk lo it bd lp ml mm dn lt mn mo dp lx ky mp mq lz lc mr ms mb lg mt mu md mv bi translated">使用数据透视表操作重塑我们的数据框架</h2><p id="5abb" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">我们目前构建数据的方式还不能用于分析。现在，每个地区、每个星期、两个数据源中的每一个以及两个病例定义(确诊和可能)中的每一个都有单独的行。</p><p id="c1bd" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了运行我们的模型，我们希望确保每一行都代表每个地区每周的数字。我们可以通过结合<code class="fe mw mx my mz b">pivot_tables </code>和一些快速的数据帧操作来实现。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="d83d" class="mk lo it mz b gy ni nj l nk nl">df3 = pd.pivot_table(df2, values=['Numeric'], index=['District', 'Epi week', 'Ebola data source'], columns=['Case definition'], aggfunc=np.sum)</span><span id="6218" class="mk lo it mz b gy nm nj l nk nl">df3.head()</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oa"><img src="../Images/bfb37ec0c61394810d0f2fb6ffb39df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s7V_SwbJw2ib7ATI"/></div></div></figure><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="4e1f" class="mk lo it mz b gy ni nj l nk nl">df4 = pd.DataFrame(df3.to_records())</span><span id="228a" class="mk lo it mz b gy nm nj l nk nl">df4.rename({'(\'Numeric\', \'Confirmed\')' :  'Confirmed_cases', '(\'Numeric\', \'Probable\')' :  'Probable_cases', }, axis = 1, inplace = True)</span><span id="7dd8" class="mk lo it mz b gy nm nj l nk nl">df4.head(10)</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi ob"><img src="../Images/d7e2765baa99b15c9e91615a8547d91e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*amha_Yd6wFMmf2WS"/></div></div></figure><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="beab" class="mk lo it mz b gy ni nj l nk nl">df5 = pd.pivot_table(df4, values=['Confirmed_cases', 'Probable_cases'], index=['District', 'Epi week'], columns=['Ebola data source'], aggfunc=np.sum)</span><span id="cd48" class="mk lo it mz b gy nm nj l nk nl">df6 = pd.DataFrame(df5.to_records())</span><span id="f816" class="mk lo it mz b gy nm nj l nk nl">df6.rename({'(\'Confirmed_cases\', \'Patient database\')' :  'patient_database_confirmed', '(\'Confirmed_cases\', \'Situation report\')' :  'situation_report_confirmed', '(\'Probable_cases\', \'Patient database\')' :  'patient_database_probable', '(\'Probable_cases\', \'Situation report\')' :  'situation_report_probable', }, axis = 1, inplace = True)</span><span id="4869" class="mk lo it mz b gy nm nj l nk nl">df6.head()</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oc"><img src="../Images/59f0a870f5a07c9eeebd0ebd668615e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aSeyHhG0njJ-BofL"/></div></div></figure><p id="efc6" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">瞧啊。这就是我们想要的。</p><p id="2359" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">让我们看看折叠所有信息后，我们有多少行。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="9bc1" class="mk lo it mz b gy ni nj l nk nl">df6.shape</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div class="gh gi od"><img src="../Images/9c1bdf21d4b23396637df299136e471f.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/0*ruIYRQcCciD0-vNt"/></div></figure><h2 id="6d80" class="mk lo it bd lp ml mm dn lt mn mo dp lx ky mp mq lz lc mr ms mb lg mt mu md mv bi translated">导出到 CSV</h2><p id="df39" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">此时，我们应该导出我们的结果，并在 dataframe 中使用<code class="fe mw mx my mz b">to_csv()</code>方法给它们命名。通过这种方式，我们可以与他人共享我们重新调整的表格。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="b2de" class="mk lo it mz b gy ni nj l nk nl">df6.to_csv('sl_ebola_pivoted.csv')</span></pre><h1 id="4b3b" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">数据连接和特征工程</h1><p id="4868" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">我们在这里没有显示代码，但下一步是将确认的埃博拉病例数据集与世界卫生组织和世界银行提供的许多不同的人口统计指标相结合。</p><p id="71b8" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们还根据地理界限(哪个地区与哪个地区接壤)并通过在边界和报告病例之间建立“互动”创造了新的特征(或变量)。例如，最近几周在邻近的州有多少病例。</p><h1 id="c9a6" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated"><strong class="ak">运行机器学习模型进行回归</strong></h1><h2 id="e928" class="mk lo it bd lp ml mm dn lt mn mo dp lx ky mp mq lz lc mr ms mb lg mt mu md mv bi translated">探索回归的代码</h2><p id="7192" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">我们现在准备开始构建我们的机器学习模型。此时，启动一个新的 Jupyter 笔记本并导入数据是一个好主意。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="049f" class="mk lo it mz b gy ni nj l nk nl">df = pd.read_csv('ebola3.csv', index_col=0)<br/>df.head(2)</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oe"><img src="../Images/3048c633ba426a3bba9107eb15252ddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PLM-3ezfm__q2ySQ"/></div></div></figure><h2 id="1c84" class="mk lo it bd lp ml mm dn lt mn mo dp lx ky mp mq lz lc mr ms mb lg mt mu md mv bi translated">坚持</h2><p id="04a1" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">接下来，为了测试我们的模型的预测性，我们将“抽出”几个星期，这样我们的模型就不会在这些星期中进行训练。最后，我们将比较我们的模型对这三周的预测和实际发生的情况。这被称为“维持验证”,是一种确保我们不只是过度拟合的方法——也就是说，我们的模型基本上是在“记忆”数据集。</p><p id="3a3c" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们的三周是爆发的开始、顶点和结束。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="9cf1" class="mk lo it mz b gy ni nj l nk nl">selected_weeks = ['2014-09-06', '2014-10-27','2014-12-29']<br/>df_holdout = df[df.Datetime.isin(selected_weeks)]<br/>df2 = df[~df.Datetime.isin(selected_weeks)]</span><span id="5fb8" class="mk lo it mz b gy nm nj l nk nl">print(df.shape)<br/>print(df_holdout.shape)<br/>print(df2.shape)</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div class="gh gi of"><img src="../Images/7b6d3c61971e35e8478f40f93ddea7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:316/0*knRAaLGzD9LPHLCX"/></div></figure><h2 id="eb5b" class="mk lo it bd lp ml mm dn lt mn mo dp lx ky mp mq lz lc mr ms mb lg mt mu md mv bi translated">丢弃无关变量</h2><p id="6949" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">我们将做更多的列删除，然后我们将分割我们的<code class="fe mw mx my mz b">X</code>(预测值)和<code class="fe mw mx my mz b">y</code>(目标变量)。出于本练习的目的，我们将重点关注来自“情况报告”来源的确诊病例。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="e47b" class="mk lo it mz b gy ni nj l nk nl">df2.drop(columns = ['X', 'District', 'patient_database_confirmed', 'Year', 'Week', 'Day', ‘Epi.week’, 'case_occured_PDC', 'case_occured_SRC'], inplace = True)</span><span id="1321" class="mk lo it mz b gy nm nj l nk nl">X = df2.drop(columns = ['any_cases', 'Datetime', 'situation_report_confirmed'])<br/>y = df2.situation_report_confirmed</span></pre><h2 id="0ffb" class="mk lo it bd lp ml mm dn lt mn mo dp lx ky mp mq lz lc mr ms mb lg mt mu md mv bi translated">拆分数据的另一部分</h2><p id="4577" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">除了在我们的维持集中分离三个星期，我们还做了一个<code class="fe mw mx my mz b">train_test_split() </code>来分离 20%的数据集。这是为了获得一些关于我们模型性能的样本外统计数据。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="86ea" class="mk lo it mz b gy ni nj l nk nl">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)</span></pre><h2 id="f09b" class="mk lo it bd lp ml mm dn lt mn mo dp lx ky mp mq lz lc mr ms mb lg mt mu md mv bi translated">随机森林回归量</h2><p id="4648" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">我们现在利用我们导入的一种称为随机森林的算法，这是一种集成学习器，即多个决策树的聚合，可用于回归和分类。我们用我们想要的规格为我们的模型创建一个变量，然后我们用我们的火车组<code class="fe mw mx my mz b">fit()</code>它。我们可以使用我们导入的指标之一(<code class="fe mw mx my mz b">mean_squared_error</code>)来看看它的表现。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="790c" class="mk lo it mz b gy ni nj l nk nl">random_forest = RandomForestRegressor(n_estimators = 100)<br/>random_forest.fit(X_train, y_train)<br/>mean_squared_error(y_test, random_forest.predict(X_test))</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div class="gh gi og"><img src="../Images/89e669a61085dd64347d570de69092cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*LpFmNpOt1EyQ1BZE"/></div></figure><h2 id="60e4" class="mk lo it bd lp ml mm dn lt mn mo dp lx ky mp mq lz lc mr ms mb lg mt mu md mv bi translated">对最佳参数进行网格搜索</h2><p id="65ca" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">现在，监督学习算法有许多参数可供选择。例如，在随机森林家族中，我们可以使用<code class="fe mw mx my mz b">max_depth </code>来确定我们的树能长多高(也就是说，我们的决策节点能有多复杂)。先验地，对于树在我们的模型中应该有多高，没有正确或错误的答案。这取决于我们数据的性质。最好的选择是通过交叉验证。</p><p id="7cca" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在下面的代码中，我们使用<code class="fe mw mx my mz b">sklearn </code>的<code class="fe mw mx my mz b">GridSearchCV() </code>函数告诉 random forest 遍历许多不同的选项，并通过交叉验证返回得分最高的选项。然后，我们用这些最佳参数创建一个新的算法实例。最后，我们看到它的新得分。</p><p id="acbe" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了好玩，这次让我们使用不同的度量(<code class="fe mw mx my mz b">neg_mean_absolute_error</code>)来测试我们的算法做得如何。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="9d5d" class="mk lo it mz b gy ni nj l nk nl">gsc = GridSearchCV(estimator=RandomForestRegressor(),param_grid={<br/>    'max_depth': range(3,7),<br/>    'n_estimators': (10, 50, 100, 1000),<br/>    }, cv=5, scoring='neg_mean_squared_error', verbose=0, n_jobs=-1)</span><span id="bee2" class="mk lo it mz b gy nm nj l nk nl"><br/>grid_result = gsc.fit(X, y)<br/>best_params = grid_result.best_params_</span><span id="4274" class="mk lo it mz b gy nm nj l nk nl">rfr = RandomForestRegressor(max_depth=best_params["max_depth"], n_estimators=best_params["n_estimators"], random_state=False, verbose=False)</span><span id="b74e" class="mk lo it mz b gy nm nj l nk nl"># Perform K-Fold CV<br/>scores = cross_val_score(rfr, X, y, cv=10, scoring='neg_mean_absolute_error')</span><span id="b048" class="mk lo it mz b gy nm nj l nk nl">np.mean(scores)</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oh"><img src="../Images/46c28425214c8ff6e0eec764afcd79b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sDgH9Tl7fZ1W1rB-"/></div></div></figure><h2 id="bc24" class="mk lo it bd lp ml mm dn lt mn mo dp lx ky mp mq lz lc mr ms mb lg mt mu md mv bi translated">分析我们坚持的结果</h2><p id="34fb" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">现在，我们可以返回到我们的维持集，并尝试基于我们的随机森林回归器和最佳参数来生成预测。按照与训练数据相同的方式将数据帧划分为<code class="fe mw mx my mz b">X</code>和<code class="fe mw mx my mz b">y</code>后，我们可以使用<code class="fe mw mx my mz b">predict </code>方法为维持集中的每一行生成预测。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="efad" class="mk lo it mz b gy ni nj l nk nl">X_holdout = df_holdout.drop(columns = ['any_cases', 'Datetime', 'situation_report_confirmed', 'X', 'District', 'Epi.week', 'patient_database_confirmed', 'Year', 'Week', 'Day', 'case_occured_PDC', 'case_occured_SRC'])</span><span id="02e9" class="mk lo it mz b gy nm nj l nk nl">y_holdout = df_holdout.situation_report_confirmed</span><span id="e523" class="mk lo it mz b gy nm nj l nk nl">df_holdout['prediction'] = random_forest.predict(X_holdout)</span></pre><p id="fad6" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们现在可以在一个单独的数据框架中可视化这些结果，并将它们与实际数字进行比较。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="c120" class="mk lo it mz b gy ni nj l nk nl">results = df_holdout[['District', 'Datetime', 'situation_report_confirmed', 'prediction']]</span><span id="8f9a" class="mk lo it mz b gy nm nj l nk nl">results.head(20)</span></pre><figure class="na nb nc nd gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oi"><img src="../Images/a92ec3fcf6424e071b95913c2a1116b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*46eikY2ybOYTw41Z"/></div></div></figure><h1 id="12f3" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated"><em class="oj">最终模型描述</em></h1><p id="2a2e" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">我们的最终模型考虑了塞拉利昂每个地区的一系列变量，每个地区过去病例数的信息，以及与周边地区的互动，以预测任何给定的一周是否会爆发埃博拉疫情，如果会，预计会有多少患者。</p><p id="0d4f" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">将我们的模型结果可视化的一种方法是在危机期间拿出三周的数据，然后测试我们的预测与实际发生的情况相比如何。我们选择危机开始时的一周，高峰时的一周，以及蔓延放缓时的一周。</p><figure class="na nb nc nd gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi ok"><img src="../Images/08098deda0093b5b31b45b996ac5ce06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*llsKIJuwmn29JlVt"/></div></div></figure><p id="68e3" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">从上面的可视化可以看出，我们的模型并没有产生完美的结果。在第三周的情况下，一些被给予低优先的北部地区最终出现了一些最高集中的病例。另一方面，图 1 中的中间一周准确地预测，病例最集中的地区将是塞拉利昂西北部。</p><h1 id="d04a" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated"><strong class="ak">总是想到潜在的偏见</strong></h1><p id="5e4e" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">当使用数据科学为政策和运营决策提供信息时，考虑到由于不完善的数据而引入偏差的可能性总是很重要的。</p><p id="9428" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在我们的案例中，2013—2016 年疫情期间的埃博拉病例漏报已经得到广泛认可。根据工作人员的观察，世卫组织声称“报告的病例和死亡人数大大低估了疫情的严重程度”。根据一项估计，实际病例数超过报告病例数 2.5 倍。</p><p id="0257" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">由于我们的模型是根据报告的埃博拉病例数训练的，我们的预测平均来说会低估实际的埃博拉病例数。此外，漏报的程度可能与地区特征相关，而地区特征对于公平性的考虑也很重要。例如，较贫困地区的监测系统可能较差，导致未报告的病例数量较高。</p><p id="0351" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">因此，实际和预测的埃博拉病例数之间的差距在较贫困地区会更大，这可能导致资源分配不公平地对较贫困地区不利。如果没有进一步的信息来说明漏报是如何因地区而异的，我们就无法用有偏差的数据做出无偏差的预测。因此，如果我们的模型被采用，我们建议同时投资于监测系统，以产生更高质量的结果数据。</p><h1 id="d649" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated"><strong class="ak">技术限制</strong></h1><p id="7912" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">我们目前方法的最大问题是，模型是根据疫情发生的整个时期做出预测的。换句话说，该模型可以查看数据和感染高峰，并知道预计数字何时增长和下降。在现实生活中，如果我们将这个模型应用于新的疾病爆发，那么我们将只有我们所在的那个星期的数据，但显然我们无法预测未来。如果疫情遵循类似的一般增长模式，这不会是一个问题，但不太可能是这样的情况。</p><h1 id="4f33" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated"><strong class="ak">结论</strong></h1><p id="d059" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">准备用于分析的数据是任何监督学习项目中最关键的一步。在这篇文章中，我们学习了一些有效帮助你成功的基本代码，以及模型训练、评估和优化工作流程的基本要素。</p></div></div>    
</body>
</html>