<html>
<head>
<title>How to build a Deep Learning model in 10 lines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 10 行构建深度学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-deep-learning-model-in-10-lines-4f4c351d5da?source=collection_archive---------13-----------------------#2020-05-03">https://towardsdatascience.com/how-to-build-a-deep-learning-model-in-10-lines-4f4c351d5da?source=collection_archive---------13-----------------------#2020-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="6dbe" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">快速沉浸在深度学习中的指南</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/0d418fe3c62b671b011ce0906fbad548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zlhFWTEVAdqFNJWyr29lA.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">Alex Kotliarskyi 在<a class="ae le" href="https://unsplash.com/s/photos/%22deep-learning%22?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4978" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">本文将通过一个案例研究向读者介绍神经网络的基础知识，该案例研究仅使用 10 行 Python 代码创建并训练了一个神经网络，该网络通过 3 个基本步骤识别手写数字:</p><p id="fba7" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lh iu"> 1-加载并预处理数据</strong></p><p id="725f" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lh iu"> 2-定义模型</strong></p><p id="54e8" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lh iu"> 3-训练模型</strong></p><p id="ada1" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为此，我们将使用目前深度学习社区中最流行的库<a class="ae le" href="https://www.tensorflow.org/guide/keras/overview" rel="noopener ugc nofollow" target="_blank"> TensorFlow Keras API </a>。让我们去吧！</p><h1 id="1ab2" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">手写数字</h1><p id="5173" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">作为一个案例研究，我们将创建一个允许我们识别手写数字的模型，例如下列数字:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mi"><img src="../Images/d0883dd8588ea842a38e94d6bd0d55ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YfNvcLKz77IsEf0Ve-5a1A.png"/></div></div></figure><p id="7259" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">目标是创建一个数学模型，给定一幅图像，该模型识别它所代表的数字。例如，如果我们向模型输入第一张图片，我们会期望它回答这是一张 5。下一个是 0，下一个是 4，以此类推。</p><h2 id="7462" class="mj jr it bd js mk ml dn jw mm mn dp ka lq mo mp ke lu mq mr ki ly ms mt km mu bi translated">分类问题</h2><p id="d15a" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">实际上，我们正在处理一个分类问题，给定一幅图像，模型将其分类在 0 到 9 之间。但有时，甚至我们会发现自己有某些疑问，例如，第一个图像代表 5 还是 3？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mv"><img src="../Images/8174958424a600fcc0044d98276ef9aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7OyTo4R47ejKnIsOR_cSg.png"/></div></div></figure><p id="8da5" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为此，我们将创建的神经网络返回一个具有 10 个位置的向量，指示 10 个可能数字中每一个的可能性:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mw"><img src="../Images/0a8549f476c5cc7874279f63c3984044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ea5-_WSqMBFUEfvR12K5RA.png"/></div></div></figure><h2 id="a837" class="mj jr it bd js mk ml dn jw mm mn dp ka lq mo mp ke lu mq mr ki ly ms mt km mu bi translated">只有 10 行代码</h2><p id="98a5" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">是的，只需 10 行 python 代码，您就可以创建并训练一个对手写数字进行分类的神经网络模型:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="7afe" class="mj jr it my b gy nc nd l ne nf"><strong class="my iu">1:</strong> import tensorflow as tf<br/><strong class="my iu">2:</strong> from tensorflow.keras.utils import to_categorical</span><span id="cc34" class="mj jr it my b gy ng nd l ne nf"><strong class="my iu">3:</strong>(x_train, y_train), _ = tf.keras.datasets.mnist.load_data()</span><span id="a28c" class="mj jr it my b gy ng nd l ne nf"><strong class="my iu">4:</strong> x_train = x_train.reshape(60000, 784).astype('float32')/255<br/><strong class="my iu">5:</strong> y_train = to_categorical(y_train, num_classes=10)</span><span id="4614" class="mj jr it my b gy ng nd l ne nf"><strong class="my iu">6: </strong>model = tf.keras.Sequential()<br/><strong class="my iu">7: </strong>model.add(tf.keras.layers.Dense(10, activation='sigmoid', <br/>            input_shape=(784,)))<br/><strong class="my iu">8: </strong>model.add(tf.keras.layers.Dense(10, activation='softmax'))</span><span id="9577" class="mj jr it my b gy ng nd l ne nf"><strong class="my iu">9: </strong>model.compile(loss="categorical_crossentropy", optimizer="sgd", <br/>                 metrics = ['accuracy'])</span><span id="db51" class="mj jr it my b gy ng nd l ne nf"><strong class="my iu">10: </strong>model.fit(x_train, y_train, epochs=10, verbose=0)</span></pre><p id="a243" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们使用了 TensorFlow  <strong class="lh iu">的<a class="ae le" href="https://www.tensorflow.org/guide/keras" rel="noopener ugc nofollow" target="_blank"> API Keras。</a></strong>它是推荐给初学者的库，因为它的学习曲线与其他库相比非常平滑，并且目前它是实现神经网络的流行中间件之一。Keras 由来自谷歌的工程师<a class="ae le" href="https://twitter.com/fchollet" rel="noopener ugc nofollow" target="_blank">Fran ois Chollet</a>开发和维护，目前收录在 Tensorflow 库中。</p><h2 id="7f34" class="mj jr it bd js mk ml dn jw mm mn dp ka lq mo mp ke lu mq mr ki ly ms mt km mu bi translated">环境设置</h2><p id="3bad" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">如果你想执行这篇文章中描述的代码，我建议使用谷歌提供的<a class="ae le" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"><em class="nh"/></a><em class="nh"/>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ni"><img src="../Images/2b97dd5add10eb94f375b6b0e779e423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Qz-WyYk8en5sKOGRCs3OQ.png"/></div></div></figure><p id="8bc8" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是谷歌的一个研究项目，旨在帮助传播机器学习教育和研究。这是一个 Jupyter 笔记本环境，不需要任何配置，完全在云中运行，允许使用不同的深度学习库，如<a class="ae le" rel="noopener" target="_blank" href="/tensorflow-vs-pytorch-the-battle-continues-9dcd34bb47d4"> TensorFlow 和 PyTorch </a>。Colab 区别于其他免费云服务的最重要的特点是；Colab 提供 GPU(或 TPU)并且完全免费。关于这项服务的详细信息可以在<a class="ae le" href="https://research.google.com/colaboratory/faq.html" rel="noopener ugc nofollow" target="_blank"> faq 页面</a>找到。</p><p id="95cb" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">默认情况下，Colab 笔记本运行在 CPU 上。你可以切换你的笔记本电脑运行与 GPU(或 TPU)。为了访问一个 GPU，我们需要选择标签运行时间<em class="nh"> </em>，然后选择“更改运行时间类型”，如下图所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/6950191e4361cdecdef6df22881b25b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qqv4LTQXeWg86J6mk4LkRA.png"/></div></div></figure><p id="c437" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当弹出窗口出现时，选择 GPU。确保“硬件加速器”设置为 GPU(默认为 CPU)。</p><p id="706f" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，确保您已连接到运行时(在菜单功能区中“已连接”旁边有一个绿色复选标记):</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi gj"><img src="../Images/0aca5d06a9b73163d529bcf26f240160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-FenNbZU0j9te-4J.png"/></div></div></figure><p id="cbff" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在你可以运行这篇文章中的代码了。我建议将这篇文章的代码复制粘贴到一个 colab 笔记本上，以便在你阅读这篇文章的同时看到执行过程。</p><p id="9fb2" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">准备好了吗？我们开始吧！</p><blockquote class="nk nl nm"><p id="2e3e" class="lf lg nh lh b li lj lk ll lm ln lo lp nn lr ls lt no lv lw lx np lz ma mb mc im bi translated"><a class="ae le" href="https://colab.research.google.com/github/jorditorresBCN/Medium/blob/master/How-to-DL-model-10lines.ipynb" rel="noopener ugc nofollow" target="_blank">该帖子的代码可从 GitHub 获得</a></p></blockquote><h1 id="de66" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">1.加载和预处理数据</h1><p id="d670" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">首先，我们需要导入一些 Python 库，以便在 TensorFlow 中对我们的神经网络进行编程:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="6918" class="mj jr it my b gy nc nd l ne nf">import tensorflow as tf<br/>from tensorflow.keras.utils import to_categorical</span></pre><p id="c7f1" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下一步是加载将用于训练我们的神经网络的数据。我们将使用 MNIST 数据集，该数据集可以从<em class="nh"/><a class="ae le" href="http://yann.lecun.com/exdb/mnist" rel="noopener ugc nofollow" target="_blank"><em class="nh">MNIST 数据库</em>页面</a>下载。该数据集包含 60，000 个手工制作的数字图像来训练模型，对于首次进入模式识别技术来说是理想的，无需花费大量时间预处理和格式化数据，这在数据分析中是非常重要和昂贵的步骤，并且在处理图像时具有特殊的复杂性。</p><p id="372b" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在 TensorFlow 中，这可以通过下面这行代码来实现(第 3 行):</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="0cf4" class="mj jr it my b gy nc nd l ne nf">(x_train, y_train), _ = tf.keras.datasets.mnist.load_data()</span></pre><p id="03f3" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lh iu">可选步骤:</strong>如果需要，您可以使用以下代码验证加载的数据:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="d7d6" class="mj jr it my b gy nc nd l ne nf">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="5e74" class="mj jr it my b gy ng nd l ne nf">fig = plt.figure(figsize=(25, 4))<br/>for idx in np.arange(20):<br/>   ax = fig.add_subplot(2, 20/2, idx+1, xticks=[], yticks=[])<br/>   ax.imshow(x_train[idx], cmap=plt.cm.binary)<br/>   ax.set_title(str(y_train[idx]))</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/0dc7880da6e80e99f2e7833871d229d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YpqS1cQukiO6_J0WjJJOqQ.png"/></div></div></figure><p id="2b11" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个黑白图像(包含灰度级的图像)的数据集已经归一化为 20×20 像素，同时保留了它们的纵横比。随后，将图像居中，计算这些图像的质心并移动图像，以便将该点定位在 28×28 视场的中心。</p><p id="e31b" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这些 28×28 像素的 MNIST 图像被表示为一个数字数组，其值的范围从类型<code class="fe nr ns nt my b">uint8</code>的[0，255]开始。但是通常将神经网络的输入值调整到一定的范围。在这篇文章的例子中，输入值应该在区间[0，1]内换算成类型为<code class="fe nr ns nt my b">float32</code>的值。</p><p id="03bf" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">另一方面，为了便于将数据输入到我们的神经网络中，我们必须将输入(图像)从二维(2D)转换为一维(1D)向量。也就是说，28×28 个数字的矩阵可以由 784 个数字(逐行连接)的向量(数组)表示，这种格式接受密集连接的神经网络作为输入，就像我们将在本文中看到的那样。</p><p id="28f1" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以用下面的代码行(第 4 行)实现这些转换:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="cf94" class="mj jr it my b gy nc nd l ne nf">x_train = x_train.reshape(60000, 784).astype('float32')/255</span></pre><p id="e534" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">此外，数据集对每张图像都有一个标签，表明它代表什么数字(在<code class="fe nr ns nt my b">y_train)</code>下载)。在我们的例子中，0 到 9 之间的数字表示图像代表哪个数字，也就是说，它与哪个类相关联。</p><p id="e004" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如前所述，我们需要用 10 个位置的向量来表示每个标签，其中对应于表示图像的数字的位置包含 1，其余的包含 0。这个将标签转换成与不同标签的数量一样多的零的向量，并将 1 放入对应于标签的索引中的过程被称为<em class="nh">一键编码</em>。例如，数字 7 将被编码为:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/6b73714558c13ec67d39c420b7b967c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*kgWTSp9lamh_68kcFkdv4Q.png"/></div></figure><p id="149e" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以用下面的代码行(第 5 行)实现这种转换:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="7197" class="mj jr it my b gy nc nd l ne nf">y_train = to_categorical(y_train, num_classes=10)</span></pre><h1 id="4bf6" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">2.定义模型</h1><p id="d2d5" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">为了用 Keras 的 API 定义模型，我们只需要这些代码行(第 6–8 行):</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="bb8d" class="mj jr it my b gy nc nd l ne nf">model = tf.keras.Sequential()<br/>model.add(tf.keras.layers.Dense(10,activation='sigmoid',<br/>          input_shape=(784,)))<br/>model.add(tf.keras.layers.Dense(10,activation='softmax'))</span></pre><p id="5560" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然而，在解释这些代码行之前，让我先介绍一些基本的神经网络概念。</p><h2 id="598e" class="mj jr it bd js mk ml dn jw mm mn dp ka lq mo mp ke lu mq mr ki ly ms mt km mu bi translated">普通的人工神经元</h2><p id="50bf" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">为了展示基本神经元是怎样的，让我们假设一个简单的例子，其中我们在二维平面中有一组点，并且每个点已经被标记为“正方形”或“圆形”:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/8adcbfa817ac155ee916a6c0eae82c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/0*VPNgPB1yDS6RfUx-.png"/></div></figure><p id="3c1d" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">给定一个新的点“<em class="nh"> X </em>”，我们想知道它对应什么标号:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/3cae736b76402ac9d1afe7738352571c.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/0*bDSXxfg47kKobZA9.png"/></div></figure><p id="34d1" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一种常见的方法是画一条线将两个组分开，并使用这条线作为分类器:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/3cefcabf4e6bc1cead5ad81d9f529352.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/0*SIaP-5qFnygmZM8M.png"/></div></figure><p id="d764" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这种情况下，输入数据将由(<em class="nh"> x1，x2 </em>)形式的向量表示，这些向量表示它们在这个二维空间中的坐标，我们的函数将返回‘0’或‘1’(在线的上方或下方)，以知道它应该被分类为“正方形”还是“圆形”。它可以定义为:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/e3e244fd3d25becba1d452d7b7ce74f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oJecu_f9HYy9pG8X.png"/></div></div></figure><p id="8eae" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">更一般地说，我们可以将这条线表示为:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/83fa3f5017ebdd7d26cd2be7b94a8d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zoXItV2NRidFEQpL.png"/></div></div></figure><p id="a22b" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了对输入元素 X(在我们的例子中是二维的)进行分类，我们必须学习一个与输入向量维数相同的权重向量 W，即向量(<em class="nh"> w1，w2 </em>)和一个<em class="nh"> b </em>偏差。</p><p id="f5b4" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有了这些计算值，我们现在可以构建一个人工神经元来对新元素<em class="nh"> X </em>进行分类。基本上，神经元将计算出的权重的向量<em class="nh"> W </em>应用于输入元素<em class="nh"> X </em>的每个维度中的值，并在最后添加偏差<em class="nh"> b. </em>，其结果将通过非线性“激活”函数来产生结果“0”或“1”。我们刚刚定义的这种人工神经元的功能可以用更正式的方式来表达，例如:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/90730ab34ecb729215d5bd3a3ba0ea92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NmOk-uBP_Eafw58U.png"/></div></div></figure><p id="f2d9" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们将需要一个函数，它对变量<em class="nh"> z </em>进行转换，使其变成‘0’或‘1’。虽然有几个函数(“激活函数”)，但在本例中，我们将使用一个称为<em class="nh"> sigmoid </em>函数的函数，该函数针对任何输入值返回 0 到 1 之间的实际输出值:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/85214ebdf0652ce5a99869d6968f9bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*roujnMSJ0sZKmX9D.png"/></div></div></figure><p id="4af3" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果我们分析前面的公式，我们可以看到它总是倾向于给出接近 0 或 1 的值。如果输入 z 相当大且为正，则在负<em class="nh"> z </em>处的“e”为零，因此<em class="nh"> y </em>取值为 1。如果<em class="nh"> z </em>具有大的负值，那么对于“e”的大正数，公式的分母将是一个大的数字，因此<em class="nh"> y </em>的值将接近 0。从图形上看，sigmoid 函数呈现如下形式:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/36014fac0f665699320b24e78074cfa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/0*rlX75JArHWvxFuJV.png"/></div></figure><p id="5474" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">到目前为止，我们已经介绍了如何定义人工神经元，这是神经网络可以拥有的最简单的架构。具体来说，这种架构在本主题的文献中被命名为感知器(也称为<em class="nh">线性阈值单元</em> (LTU))，由 Frank Rosenblatt 于 1957 年发明，并在视觉上概括为以下方案:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2245e8de2df0f869f77365f389a01511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/0*9cj29vgikzZ3LL_U.png"/></div></figure><h2 id="8219" class="mj jr it bd js mk ml dn jw mm mn dp ka lq mo mp ke lu mq mr ki ly ms mt km mu bi translated">多层感知器</h2><p id="6753" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">但是在继续讨论这个例子之前，我们将简要介绍当神经网络是由我们刚刚介绍过的感知器构造而成时，它们通常采用的形式。</p><p id="3520" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在该领域的文献中，当我们发现神经网络具有一个<em class="nh">输入层</em>，一个或多个由感知器组成的层，称为<em class="nh">隐藏层</em>，以及具有几个感知器的最后一层，称为<em class="nh">输出层</em>时，我们称之为多层感知器(MLP)。一般来说，当基于神经网络的模型由多个隐藏层组成时，我们称之为<em class="nh">深度学习</em>。在视觉上，它可以用以下方案来表示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi od"><img src="../Images/72d219d12a06da2e1b3056064ffaab99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMOR--wdUmwP9DcExQqDSw.png"/></div></div></figure><p id="a178" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">MLP 通常用于分类，特别是当类别是排他性的时，如在数字图像分类的情况下(从 0 到 9 的类别)。在这种情况下，由于一个名为 softmax 的函数，输出图层返回属于每个类的概率。视觉上，我们可以用以下方式表示它:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/771cc5e6d1511521471f2e4799906745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1dBrDQZ2jyUZL_Dkd8hRQ.png"/></div></div></figure><p id="d876" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如我们提到的，除了<em class="nh"> sigmoid </em>之外，还有几个激活函数，每个都有不同的属性。其中一个是我们刚刚提到的<em class="nh"> softmax </em>激活函数，它将有助于提供一个简单的神经网络的例子来分类两个以上的类。目前，我们可以把<em class="nh"> softmax </em>函数看作是<em class="nh"> sigmoid </em>函数的推广，它允许我们对两个以上的类进行分类。</p><h2 id="49fe" class="mj jr it bd js mk ml dn jw mm mn dp ka lq mo mp ke lu mq mr ki ly ms mt km mu bi translated">Softmax 激活功能</h2><p id="c756" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">我们将以这样的方式来解决这个问题:给定一个输入图像，我们将获得它是 10 个可能数字中的每一个的概率。这样，我们将有一个模型，例如，可以预测图像中的 5，但只有 70%的把握是 5。由于这幅图中数字上半部分的笔画，看起来它有 20%的几率变成 3，甚至有一定的概率变成其他数字。虽然在这种特殊情况下，我们会认为我们的模型的预测是 5，因为它是概率最高的一个，但这种使用概率分布的方法可以让我们更好地了解我们对预测的信心程度。这在这种情况下很好，因为数字是手工制作的，当然在很多情况下，我们不能 100%确定地识别数字。</p><p id="f1ad" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，对于这个分类示例，我们将为每个输入示例获得一个输出向量，该输出向量具有在一组互斥标签上的概率分布。也就是说，10 个概率的向量(每个概率对应于一个数字)以及所有这 10 个概率的总和导致值 1(概率将在 0 和 1 之间表示)。</p><p id="b823" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如我们已经提出的，这是通过在我们的神经网络中使用具有<em class="nh"> softmax </em>激活函数的输出层来实现的，其中该<em class="nh"> softmax </em>层中的每个神经元取决于该层中所有其他神经元的输出，因为所有这些神经元的输出之和必须为 1。</p><p id="69c5" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是<em class="nh"> softmax </em>激活功能是如何工作的呢？<em class="nh"> softmax </em>函数基于计算某一图像属于特定类别的“证据”,然后将这些证据转换为它属于每个可能类别的概率。</p><p id="9b3b" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一种测量某一图像属于特定类别的证据的方法是对属于该类别的每个像素的证据进行加权求和。为了解释这个想法，我将使用一个可视化的例子。</p><p id="4542" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">假设我们已经学习了数字 0 的模型。目前，我们可以把模型看作是“某种东西”,它包含了知道一个数是否属于某一类的信息。在这种情况下，对于数字 0，假设我们有一个如下所示的模型:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/5f0baa2700488a5228930babb57118fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*UOgrkhXe_it9aT0Ub0lDYg.png"/></div></figure><p id="4294" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这种情况下，具有 28×28 像素的矩阵，其中红色像素表示负权重(即，减少其所属的证据)，而蓝色像素表示正权重(其证据是更大的增加)。白色代表中性值。</p><p id="4bff" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">假设我们在上面画了一个零。一般来说，零点的轨迹会落在蓝色区域(请记住，我们讨论的是归一化为 20×20 像素的图像，后来以 28×28 的图像为中心)。很明显，如果我们的笔画越过红色区域，很可能我们写的不是零；因此，使用基于如果我们通过蓝色区域则相加，如果我们通过红色区域则相减的度量标准似乎是合理的。</p><p id="cac4" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了确认它是一个好的度量，现在让我们想象我们画了一个三；很明显，我们用于零的前一个模型中心的红色区域会影响前面提到的指标，因为，正如我们在下图的左部看到的，当我们写 3 时，我们忽略了:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/0caa4a4068b932db3875c7837fd027d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66ohLYutXT2_nqTDIeb24w.png"/></div></div></figure><p id="7bd3" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但另一方面，如果参考模型是对应于数字 3 的模型，如上图右侧所示，我们可以看到，一般来说，代表数字 3 的不同可能走线大多位于蓝色区域。</p><p id="afb6" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我希望读者看到这个直观的例子后，已经直觉地知道上面提到的权重的近似值是如何让我们估计出它是多少的。</p><p id="d7b2" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦属于 10 个类别中的每一个的证据被计算出来，这些必须被转换成概率，其所有成分的总和加 1。为此，softmax 使用计算证据的指数值，然后将它们归一化，使总和等于 1，形成概率分布。属于类别<em class="nh"> i </em>的概率为:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oh"><img src="../Images/bcb0de50b88978af4316c08c39e06a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xy0EMrRLzGAYDnw5k1E5Cg.png"/></div></div></figure><p id="b424" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">直观地说，使用指数得到的效果是，多一个单位的证据具有乘数效应，少一个单位的证据具有反效应。关于这个函数有趣的事情是，一个好的预测在向量中有一个接近 1 的值，而其余的值接近 0。在弱预测中，将有几个可能的标签，它们将具有或多或少相同的概率。</p><h2 id="375c" class="mj jr it bd js mk ml dn jw mm mn dp ka lq mo mp ke lu mq mr ki ly ms mt km mu bi translated">Keras 中的顺序类</h2><p id="ab80" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">Keras 中的主要数据结构是<em class="nh">序列</em>类，它允许创建一个基本的神经网络。Keras <a class="ae le" href="https://keras.io/getting-started/functional-api-guide/" rel="noopener ugc nofollow" target="_blank">还提供了一个 API </a>，允许以图形的形式实现更复杂的模型，可以有多个输入，多个输出，中间有任意连接，但这超出了本文的范围。</p><p id="9902" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Keras 库的<a class="ae le" href="https://keras.io/models/sequential/" rel="noopener ugc nofollow" target="_blank"> <em class="nh">序列</em>类</a>是 Keras 提供的序列神经网络模型的包装器，可以通过以下方式创建:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="998e" class="mj jr it my b gy nc nd l ne nf">model = tf.keras.Sequential()<br/>model.add(tf.keras.layers.Dense(10,activation='sigmoid',<br/>          input_shape=(784,)))<br/>model.add(tf.keras.layers.Dense(10,activation='softmax'))</span></pre><p id="edfe" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这种情况下，Keras 中的模型被视为一系列层，每一层都逐渐“提取”输入数据以获得所需的输出。在 Keras 中，我们可以找到所有需要的层类型，这些层可以通过<code class="fe nr ns nt my b">add()</code>方法轻松添加到模型中。</p><p id="b598" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这里，神经网络已经被定义为密集连接(或完全连接)的两层序列，意味着每层中的所有神经元都连接到下一层中的所有神经元。视觉上，我们可以用以下方式表示它:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/c7b1fad769b32d57d270739af6d4c574.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*GiOAs1dZ0wmklAeBWNV6Jw.png"/></div></figure><p id="d197" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在前面的代码中，我们在第一层的<em class="nh"> input_shape </em>参数中明确表达了输入数据是什么样的:一个张量，表示我们有 784 个模型特征。</p><p id="8445" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Keras 库的一个非常有趣的特点是，它会在第一个张量之后自动推导出层间张量的形状。这意味着程序员只需要为其中的第一个建立这些信息。此外，对于每一层，我们指出它所具有的节点数量以及我们将在其中应用的激活函数(在本例中，<em class="nh"> sigmoid </em>)。</p><p id="812f" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">本例中的第二层是由 10 个神经元组成的<em class="nh"> softmax </em>层，这意味着它将返回代表 10 个可能数字的 10 个概率值的矩阵(通常，分类网络的输出层将具有与类一样多的神经元，除了在二元分类中，只需要一个神经元)。每个值将是当前数字的图像属于它们中的每一个的概率。</p><p id="c2e4" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lh iu">可选步骤:</strong>Keras 提供的一个非常有用的方法是<code class="fe nr ns nt my b">summary()</code>:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="14e8" class="mj jr it my b gy nc nd l ne nf">model.summary()</span><span id="0a9a" class="mj jr it my b gy ng nd l ne nf">_________________________________________________________________<br/>Layer (type) Output Shape Param #<br/>=================================================================<br/>dense_1 (Dense) (None, 10) 7850<br/>_________________________________________________________________<br/>dense_2 (Dense) (None, 10) 110<br/>=================================================================<br/>Total params: 7,960<br/>Trainable params: 7,960<br/>Non-trainable params: 0</span></pre><p id="7b9f" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于我们的简单示例，我们看到它指示需要 7960 个参数(列<em class="nh"> Param # </em>)，这对应于第一层的 7850 个参数和第二层的 110 个参数。</p><p id="043c" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在第一层中，对于每个神经元<em class="nh"> i </em>(在 0 和 9 之间)，我们需要 784 个参数作为权重<em class="nh"> wij </em>，因此需要 10×784 个参数来存储 10 个神经元的权重。此外还有 10 个附加参数，分别对应于 10 个<em class="nh"> bj </em>偏置。在第二层中，作为<em class="nh"> softmax </em>函数，需要将所有 10 个神经元与前一层的 10 个神经元连接。因此，需要 10×10 个<em class="nh"> wi </em>参数，另外还需要 10 个<em class="nh"> bj </em>偏置对应于每个节点。</p><p id="9086" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以为<code class="fe nr ns nt my b">dense </code> <a class="ae le" href="https://keras.io/layers/core/#dense" rel="noopener ugc nofollow" target="_blank">层</a>指出的参数细节可以在 Keras 手册中找到。在我们的例子中，最相关的出现在例子中。第一个参数表示层中神经元的数量；下面是我们将在其中使用的激活函数。在<a class="ae le" rel="noopener" target="_blank" href="/learning-process-of-a-deep-neural-network-5a9768d7a651">这篇文章</a>中，我们将更详细地讨论除了这里介绍的两个激活功能之外的其他可能的激活功能:<em class="nh"> sigmoid </em>和<em class="nh"> softmax </em>。</p><h1 id="ec25" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">3.训练模型</h1><p id="1599" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">我们差不多完成了，我们只需要解释最后两行代码:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="a34c" class="mj jr it my b gy nc nd l ne nf">model.compile(loss="categorical_crossentropy", optimizer="sgd", <br/>                 metrics = ['accuracy'])</span><span id="f62f" class="mj jr it my b gy ng nd l ne nf">model.fit(x_train, y_train, epochs=10, verbose=0)</span></pre><h2 id="d4bf" class="mj jr it bd js mk ml dn jw mm mn dp ka lq mo mp ke lu mq mr ki ly ms mt km mu bi translated">学习过程</h2><p id="c7ef" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">神经网络如何学习神经元的权重<em class="nh"> W </em>和偏差<em class="nh"> b </em>的方式是对所有已知标记输入示例的迭代过程，将通过模型估计的其标记值与每个元素的标记的期望值进行比较。在每次迭代之后，以这样的方式调整参数值，使得图像的估计值和实际值之间的不一致(误差)变得更小。下面的方案希望以一种通用的方式直观地总结一个感知器的学习过程:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/12d4b5988cfc7348246e7dac474d042c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MGYlwHZ0GSlfqgMu.png"/></div></div></figure><h2 id="5590" class="mj jr it bd js mk ml dn jw mm mn dp ka lq mo mp ke lu mq mr ki ly ms mt km mu bi translated">学习过程的配置</h2><p id="5804" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">我们可以用<code class="fe nr ns nt my b">compile()</code>方法配置这个学习过程，使用它我们可以通过方法参数指定一些属性。</p><p id="e71e" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">第一个参数是<em class="nh">损失函数</em>，我们将使用它来评估训练数据的计算输出和期望输出之间的误差程度。另一方面，我们指定一个<em class="nh">优化器</em>，这是我们必须指定的优化算法，允许神经网络根据输入数据和定义的损失函数计算参数的权重。</p><p id="4773" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，我们必须指出我们将用来监控神经网络学习过程的度量标准。在第一个例子中，我们将只考虑<em class="nh">准确度</em>(被正确分类的图像的比例)。例如，在我们的例子中我们可以在<em class="nh"> compile() </em>方法中指定以下参数来测试它:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="b669" class="mj jr it my b gy nc nd l ne nf">model.compile(loss="categorical_crossentropy", <br/>              optimizer="sgd", <br/>              metrics = ['accuracy'])</span></pre><p id="f188" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本例中，我们指定损失函数为<em class="nh">分类 _ 交叉熵</em>，使用的优化器为<em class="nh">随机梯度下降(sgd) </em>，度量标准为<em class="nh">准确度</em>，我们将使用它来评估正确猜测的百分比</p><p id="968a" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在一篇新文章中，读者可以了解学习过程的更多细节。</p><h2 id="1635" class="mj jr it bd js mk ml dn jw mm mn dp ka lq mo mp ke lu mq mr ki ly ms mt km mu bi translated">模特培训</h2><p id="e9f5" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">一旦我们的模型被定义，学习方法被配置，它就可以被训练了。为此，我们可以通过调用模型的<em class="nh"> fit() </em>方法，将模型训练或“调整”为可用的训练数据:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="52c0" class="mj jr it my b gy nc nd l ne nf">model.fit(x_train, y_train, epochs=10, verbose=0)</span></pre><p id="a551" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在前两个参数中，我们已经以 Numpy 数组的形式指出了用于训练模型的数据。<em class="nh"> batch_size </em>参数表示我们将在每次更新模型参数时使用的数据数量，而<em class="nh"> epochs </em>表示我们将在学习过程中使用所有数据的次数。</p><p id="f70e" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这种方法通过我们提到的迭代训练算法找到网络的参数值。大致来说，在该算法的每次迭代中，该算法从<em class="nh"> x_train </em>中获取训练数据，将它们通过神经网络(具有它们的参数在该时刻的值)，将获得的结果与预期的结果(在<em class="nh"> y_train </em>中指示)进行比较，并计算<em class="nh">损失</em>以指导模型参数的调整过程。 其直观地包括应用上面在<em class="nh"> compile() </em>方法中指定的优化器，以减少损失的方式计算每次迭代中每个模型参数(权重和偏差)的新值。</p><p id="3a32" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如我们将看到的，这种方法可能需要更长时间，Keras 允许我们使用<em class="nh">冗长的</em>参数(默认情况下等于 1)来查看其进度，此外还指示每个<em class="nh">时期</em>花费的估计时间:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="ccae" class="mj jr it my b gy nc nd l ne nf">Epoch 1/5<br/>60000/60000 [========] — 1s 15us/step — loss: 2.1822 — acc: 0.2916<br/>Epoch 2/5<br/>60000/60000 [========] — 1s 12us/step — loss: 1.9180 — acc: 0.5283<br/>Epoch 3/5<br/>60000/60000 [========] — 1s 13us/step — loss: 1.6978 — acc: 0.5937<br/>Epoch 4/5<br/>60000/60000 [========] — 1s 14us/step — loss: 1.5102 — acc: 0.6537<br/>Epoch 5/5<br/>60000/60000 [========] — 1s 13us/step — loss: 1.3526 — acc: 0.7034<br/>10000/10000 [========] — 0s 22us/step</span></pre><h1 id="338b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用模型</h1><p id="6bde" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">为了使用该模型，我们可以使用以下代码下载另一组图像(不同于训练图像):</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="9617" class="mj jr it my b gy nc nd l ne nf">_, (x_test_, y_test_)= tf.keras.datasets.mnist.load_data()<br/>x_test = x_test_.reshape(10000, 784).astype('float32')/255<br/>y_test = to_categorical(y_test_, num_classes=10)</span></pre><h2 id="f087" class="mj jr it bd js mk ml dn jw mm mn dp ka lq mo mp ke lu mq mr ki ly ms mt km mu bi translated">可选步骤:模型评估</h2><p id="e29a" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">此时，神经网络已经完成训练，现在可以使用<code class="fe nr ns nt my b">evaluation()</code>方法评估其在新测试数据下的行为。此方法返回两个值:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="c495" class="mj jr it my b gy nc nd l ne nf">test_loss, test_acc = model.evaluate(x_test, y_test)</span></pre><p id="5111" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这些值表明我们的模型在处理从未见过的新数据时表现得如何。当我们执行了<em class="nh"> mnist.load_data() </em>时，这些数据已经存储在<em class="nh"> x_test </em>和<em class="nh"> y_test </em>中，我们将它们作为参数传递给方法。在本帖的范围内，我们将只关注其中之一，准确性:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="e4ae" class="mj jr it my b gy nc nd l ne nf">print(‘Test accuracy:’, test_acc)<br/>Test accuracy: 0.9018</span></pre><p id="daf8" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">准确性告诉我们，我们在这篇文章中创建的模型，应用于该模型从未见过的数据，正确分类了 90%。</p><h2 id="6f2a" class="mj jr it bd js mk ml dn jw mm mn dp ka lq mo mp ke lu mq mr ki ly ms mt km mu bi translated">生成预测</h2><p id="856e" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">最后，读者需要知道我们如何使用上一节中训练的模型进行预测。在我们的例子中，它包括预测哪个数字代表一幅图像。为了做到这一点，Keras 提供了<code class="fe nr ns nt my b">predict()</code>方法。</p><p id="3262" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们选择一个图像(并绘制它)来预测数字:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="16c1" class="mj jr it my b gy nc nd l ne nf">image = 5</span><span id="cb2d" class="mj jr it my b gy ng nd l ne nf">_ = plt.imshow(x_test_[image], cmap=plt.cm.binary)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/a7369ed07ecc7e0a504b195a230d7d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*uu4hm65260Cueh29dzPvLA.png"/></div></figure><p id="fffa" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了预测这个数字，我们可以使用下面的代码:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="7d60" class="mj jr it my b gy nc nd l ne nf">import numpy as np<strong class="my iu"><br/></strong><br/>prediction = model.predict(x_test_)<br/>print("Model prediction: ", np.argmax(prediction[image]) )</span></pre><p id="a20a" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">仅此而已！</p><h1 id="d309" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">下一步？</h1><p id="c4c1" class="pw-post-body-paragraph lf lg it lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc im bi translated">现在你已经准备好学习如何编程一个更高级的神经网络(本文中的<a class="ae le" rel="noopener" target="_blank" href="/convolutional-neural-networks-for-beginners-using-keras-and-tensorflow-2-c578f7b3bf25"/>):卷积神经网络。准备好了吗？</p><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/convolutional-neural-networks-for-beginners-using-keras-and-tensorflow-2-c578f7b3bf25"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">卷积神经网络初学者使用 Keras 和 TensorFlow 2</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">边做边学:包含 GitHub 代码的实用指南</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ky oo"/></div></div></a></div><blockquote class="nk nl nm"><p id="15d7" class="lf lg nh lh b li lj lk ll lm ln lo lp nn lr ls lt no lv lw lx np lz ma mb mc im bi translated"><a class="ae le" href="https://colab.research.google.com/github/jorditorresBCN/Medium/blob/master/How-to-DL-model-10lines.ipynb" rel="noopener ugc nofollow" target="_blank">GitHub</a>上有这个帖子的代码</p></blockquote><p id="5ec7" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="nh">于 2020 年 5 月 02 日</em><a class="ae le" href="https://torres.ai/como-construir-un-modelo-deep-learning-en-10-lineas/" rel="noopener ugc nofollow" target="_blank"><em class="nh">https://Torres . ai</em></a><em class="nh">以西班牙语原文发表。</em></p></div></div>    
</body>
</html>