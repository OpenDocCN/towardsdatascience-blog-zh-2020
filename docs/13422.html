<html>
<head>
<title>Data filtering in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫中的数据过滤</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/filtering-data-frames-in-pandas-b570b1f834b9?source=collection_archive---------0-----------------------#2020-09-15">https://towardsdatascience.com/filtering-data-frames-in-pandas-b570b1f834b9?source=collection_archive---------0-----------------------#2020-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="035a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">清理数据集的完整指南—第 3 部分</h2></div><p id="8cd1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从数据框中过滤数据是清理数据时最常见的操作之一。Pandas 提供了多种根据行和列的位置和标签选择数据的方法。此外，Pandas 还允许您获得基于列类型的数据子集，并使用布尔索引过滤行。</p><p id="eb28" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将介绍从 Pandas 数据框中选择数据子集的最常见操作:(1)按标签选择单个列，(2)按标签选择多个列，(3)按数据类型选择列，(4)按标签选择单个行，(5)按标签选择多个行，(6)按位置选择单个行，(7)按位置选择多个行，(8)同时选择行和列，(9)选择标量值，以及(10)使用布尔选择来选择行。</p><p id="910c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们将提供多个编码示例！现在，让我们开始吧:)❤️</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/f8476b1328cf4c87863eeaf60901edec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o1Nnec9FmQtsnvvZ"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">法国人 Daphné Be 在<a class="ae lu" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="fb32" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数据集</h1><p id="e9a8" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在本文中，我们使用一个小数据集进行学习。在现实世界中，使用的数据集会大得多；然而，用于过滤数据的程序保持不变。</p><p id="ebb9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据框包含一家公司的 10 名员工的信息:(1) id，(2)姓名，(3)姓氏，(4)部门，(5)电话，(6)工资，以及(7)合同类型。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/84bcba81aaa5c1785e8241f70e03e67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*P9eHzyL_vpUDhAJFctYHCw.png"/></div></figure></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="3506" class="lv lw it bd lx ly nc ma mb mc nd me mf jz ne ka mh kc nf kd mj kf ng kg ml mm bi translated">1.按标签选择单个列</h1><p id="ae92" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">要在 Pandas 中选择<strong class="kk iu">单列</strong>，我们可以同时使用<strong class="kk iu">。操作员</strong>和<strong class="kk iu">操作员</strong>。</p><blockquote class="nh"><p id="254d" class="ni nj it bd nk nl nm nn no np nq ld dk translated">按标签选择单个列</p><p id="8dd7" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→df[字符串]</p></blockquote><p id="b33e" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">以下代码使用两种方法(点符号和方括号)访问 salary 列。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/d4eb4a36e66c5876ad24167af574ff82.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*7ST9z6NkL4WLaKjlo1hOcg.png"/></div></figure><p id="21d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上图所示，当<strong class="kk iu">检索单个列</strong>时，结果是一个<strong class="kk iu">系列</strong>对象。为了在只选择一列时获得一个<strong class="kk iu"> DataFrame </strong>对象，我们需要传入一个只有一项的列表，而不仅仅是一个字符串。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/0928bdcd3d7443478f96bf1ec492e29a.png" data-original-src="https://miro.medium.com/v2/resize:fit:176/format:webp/1*ysk70faKk-NUSQoQ1ezqLQ.png"/></div></figure><p id="dd9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，重要的是要记住，当列名包含空格时，我们不能使用点符号来访问数据框的特定列。如果我们这样做，就会引发一个<strong class="kk iu">语法错误</strong>。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="32cb" class="lv lw it bd lx ly nc ma mb mc nd me mf jz ne ka mh kc nf kd mj kf ng kg ml mm bi translated">2.按标签选择多列</h1><p id="cfa5" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们可以通过传入一个列名如下的列表来选择一个数据帧的多个列。</p><blockquote class="nh"><p id="cb3d" class="ni nj it bd nk nl nm nn no np nq ld dk translated">按标签选择多列</p><p id="f328" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→df[字符串列表]</p></blockquote><figure class="ny nz oa ob oc lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi od"><img src="../Images/3daa90d78a37c1fc9a1e8ca4bafbf07c.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*ikDjsfM3iUbrdvA2wDvvgQ.png"/></div></figure><p id="83fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所示，结果是一个<strong class="kk iu"> DataFrame </strong>对象，只包含列表中提供的列。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="210e" class="lv lw it bd lx ly nc ma mb mc nd me mf jz ne ka mh kc nf kd mj kf ng kg ml mm bi translated">3.按数据类型选择列</h1><p id="5a83" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们可以用<a class="ae lu" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.select_dtypes.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">熊猫。data frame . select _ dtypes(include = None，exclude=None) </strong> </a>方法根据列的数据类型选择列。该方法在参数<strong class="kk iu">中接受列表或单一数据类型，包括</strong>和<strong class="kk iu">排除</strong>。请记住，必须至少提供其中一个参数(包括或排除),并且它们不能包含重叠的元素。</p><blockquote class="nh"><p id="c6fc" class="ni nj it bd nk nl nm nn no np nq ld dk translated">按数据类型选择列</p><p id="39f3" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→ df.select_dtypes(包含=无，排除=无)</p></blockquote><p id="d815" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">在下面的例子中，我们通过将<strong class="kk iu"> np.number </strong>对象传递给<strong class="kk iu"> include </strong>参数来选择数据帧的数字列(整数和浮点数)<strong class="kk iu"> </strong>。或者，我们可以通过提供字符串'<strong class="kk iu"> number' </strong>作为输入来获得相同的结果。</p><p id="2d74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，<strong class="kk iu"> select_dtypes()方法</strong>返回一个<strong class="kk iu"> DataFrame </strong>对象，其中包含了<strong class="kk iu"> include 参数</strong>中的 dtypes，并排除了<strong class="kk iu"> exclude </strong> <strong class="kk iu">参数</strong>中的 dtypes。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d830f2f027070f5344e0d59a05687b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:174/format:webp/1*-Spb6Fq2_6QQNsns6k7GSQ.png"/></div></figure><p id="ef04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，<strong class="kk iu"> select_dtypes()方法</strong>可以接受字符串和 numpy 对象作为输入。下表显示了在 Pandas 中引用数据类型的最常见方式。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi of"><img src="../Images/d49a957cd8fa8b68e7b35515b7e49d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*dQcz1_d1YwfnGMej2ghkXg.png"/></div></figure><p id="0134" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提醒一下，我们可以使用<a class="ae lu" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.info.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> pandas 来检查列的数据类型。data frame . info</strong></a><strong class="kk iu"/>方法或者用<a class="ae lu" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dtypes.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">熊猫。DataFrame.dtypes </strong> </a>属性。前者打印数据框的简明摘要，包括列名及其数据类型，而后者返回一个包含每列数据类型的<strong class="kk iu">系列</strong>。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi og"><img src="../Images/872f9b4694fbadc5023773aa8b14fff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*3MZM8VGb4g9AOUTYiaIUDw.png"/></div></figure><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/94ddd0dd7fde632e61192f7a9c5cbd4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/1*ABNlNaIa_XSfZ_OukLKUrw.png"/></div></figure></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="d70b" class="lv lw it bd lx ly nc ma mb mc nd me mf jz ne ka mh kc nf kd mj kf ng kg ml mm bi translated">4.按标签选择单行</h1><p id="b2b7" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu">数据框</strong>和<strong class="kk iu">系列</strong>不一定有数字索引。默认情况下，索引是指示行位置的整数；但是，它也可以是字母数字字符串。在我们当前的例子中，索引是雇员的 id 号。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cd75" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要通过 id 号选择单个行，我们可以使用<strong class="kk iu">。loc[]索引器</strong>提供一个<strong class="kk iu">单字符串</strong>(索引名)作为输入。</p><blockquote class="nh"><p id="b611" class="ni nj it bd nk nl nm nn no np nq ld dk translated">按标签选择单行</p><p id="c85a" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→ df.loc[string]</p></blockquote><p id="04da" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">下面的代码显示了如何选择 id 号为 478 的雇员。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/cfedf35693ba8a75d24344bb34422979.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*nwKJEKTNAna_kKv0Td5Ufw.png"/></div></figure><p id="b21f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上图所示，当单个行被选中时，<strong class="kk iu">。loc[]索引器</strong>返回一个<strong class="kk iu">系列对象</strong>。然而，我们也可以通过向<strong class="kk iu">传递一个单元素列表来获得一个单行<strong class="kk iu">数据帧</strong>。loc[] </strong>方法如下。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/cef15eb8fe2c4bd95c79f5e54679ffd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*fneHdZlWC465MYYlb8fOig.png"/></div></figure></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="2577" class="lv lw it bd lx ly nc ma mb mc nd me mf jz ne ka mh kc nf kd mj kf ng kg ml mm bi translated">5.按标签选择多行</h1><p id="86a4" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们可以用<strong class="kk iu">选择<strong class="kk iu">多行</strong>。loc[]索引器</strong>。除了单个标签之外，索引器还接受标签列表或标签切片作为输入<strong class="kk iu">。</strong></p><blockquote class="nh"><p id="16f2" class="ni nj it bd nk nl nm nn no np nq ld dk translated">按标签选择多行</p><p id="71f4" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→df . loc[字符串列表]</p><p id="3e7c" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→df . loc[字符串切片]</p></blockquote><p id="faa1" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">接下来，我们获取包含 id 号为 478 和 222 的雇员的数据帧的子集，如下所示。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/954d8689ab982ce8c98ccdfa57334c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*3UzJ0rJMD_sF24VaWVENUA.png"/></div></figure><p id="4a5a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，<strong class="kk iu">的结束索引。loc[]方法</strong>总是包含在内，意味着选择包括最后一个标签。</p><h1 id="5c42" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6.按位置选择单行</h1><p id="b8dd" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu">。iloc[]索引器</strong>用于按位置索引数据帧。属性选择一行。iloc[]属性，我们将行位置(单个整数)传递给索引器。</p><blockquote class="nh"><p id="a07e" class="ni nj it bd nk nl nm nn no np nq ld dk translated">按位置选择单行</p><p id="1829" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→df . iloc[整数]</p></blockquote><p id="b2b1" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">在下面的代码块中，我们选择索引为 0 的行。在这种情况下，返回数据帧的第一行，因为在 Pandas 中，索引从 0 开始。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/7080eb9473c14c9b300d16db847911e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*2O74q8JFJLzNpUsHY6B05g.png"/></div></figure><p id="b067" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，<strong class="kk iu">。iloc[]索引器</strong>也支持<strong class="kk iu">负整数</strong>(从-1 开始)作为相对于数据帧结尾的位置。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/2a94ee9734786ddd1b15b4abd19834f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*axS5CadhRwsGDgrf3Wf9Sg.png"/></div></figure><p id="e4e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上图，当单个行被选中时，<strong class="kk iu">。iloc[]索引器</strong>返回一个将列名作为索引的<strong class="kk iu">系列</strong>对象。然而，正如我们对<strong class="kk iu">所做的那样。loc[]索引器</strong>，我们也可以通过以下方式将单整数列表传递给索引器来获得一个<strong class="kk iu">数据帧</strong>。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi om"><img src="../Images/d253c120c928e2ed4104899579412c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*c75ru5mQZXPdMpIjJxRzdg.png"/></div></figure><p id="1a51" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，请记住，当试图访问一个超出界限的索引时，会引发一个<strong class="kk iu"> IndexError </strong>。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="a572" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">7.按位置选择多行</h1><p id="55c7" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">为了按位置提取多行，我们向<strong class="kk iu">传递一个 list 或 slice 对象。iloc[] </strong>索引器。</p><blockquote class="nh"><p id="ee75" class="ni nj it bd nk nl nm nn no np nq ld dk translated">按位置选择多行</p><p id="8e05" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→df . iloc[整数列表]</p><p id="6b1c" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→df . iloc[整数切片]</p></blockquote><p id="b416" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">以下代码块显示了如何使用整数列表选择数据帧的前五行。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi on"><img src="../Images/612de99316de9d7691df969d81658d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*5HVSSF7Cb8DHrpC1ravK7A.png"/></div></figure><p id="a27c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，我们可以使用切片符号获得相同的结果。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/8607e45f3d4ab060775056230d9d81aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*Zno_w4jN1E2uyGJK0V3pAA.png"/></div></figure><p id="97ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上图<strong class="kk iu">，</strong> Python 切片规则(半开区间)适用于<strong class="kk iu">。iloc[]属性</strong>，表示包含第一个索引，但不包含结束索引。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="e6ca" class="lv lw it bd lx ly nc ma mb mc nd me mf jz ne ka mh kc nf kd mj kf ng kg ml mm bi translated">8.同时选择行和列</h1><p id="dcaf" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">到目前为止，我们已经学习了如何使用<strong class="kk iu">通过标签或位置选择数据框中的行。loc[] </strong>和<strong class="kk iu">。iloc[]索引器</strong>。但是，这两个索引器不仅能够选择行，还能够同时选择行和列。</p><p id="4951" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们必须提供由逗号分隔的行和列标签/位置，如下所示:</p><blockquote class="nh"><p id="9157" class="ni nj it bd nk nl nm nn no np nq ld dk translated">同时选择行和列</p><p id="9c66" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→df . loc[行标签，列标签]</p><p id="4a68" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→df . iloc[行 _ 位置，列 _ 位置]</p></blockquote><p id="f006" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">其中<strong class="kk iu"> row_labels </strong>和<strong class="kk iu"> column_labels </strong>可以是单个字符串、字符串列表或字符串片段。同样，<strong class="kk iu"> row_positions </strong>和<strong class="kk iu"> column_positions </strong>可以是单个整数、整数列表或整数片段。</p><p id="6cef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下示例显示了如何使用<strong class="kk iu">一次提取行和列。loc[] </strong>和<strong class="kk iu">。iloc[] </strong>索引器。</p><ul class=""><li id="b0be" class="op oq it kk b kl km ko kp kr or kv os kz ot ld ou ov ow ox bi translated"><strong class="kk iu">选择标量值</strong></li></ul><p id="95e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们以下面的方式按职位和标签选择 id 号为 478 的雇员的工资。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6e30" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，两个索引器的输出都是整数。</p><ul class=""><li id="cbbd" class="op oq it kk b kl km ko kp kr or kv os kz ot ld ou ov ow ox bi translated"><strong class="kk iu">选择一行多列</strong></li></ul><p id="e135" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们选择 id 号为 478 的雇员的名字、姓氏和薪水，方法是将单个值作为第一个参数，将一个值列表作为第二个参数，结果得到一个 Series 对象。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/7704948f89ea76f5e8b9887bd62246de.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*B-nLZ68MpSTyUhvBggh0WQ.png"/></div></figure><ul class=""><li id="caf2" class="op oq it kk b kl km ko kp kr or kv os kz ot ld ou ov ow ox bi translated"><strong class="kk iu">选择不连续的行和列</strong></li></ul><p id="28d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要选择多个行和列，我们需要向两个索引器传递两个值列表。下面的代码显示了如何提取 id 号为 478 和 222 的雇员的姓名和薪水。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/40000c32bb5320448efe8effbed5a612.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*HXN_eyrRQEF9ti78f1gFpw.png"/></div></figure><p id="5e6f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与以前不同，两个索引器的输出都是 DataFrame 对象。</p><ul class=""><li id="742e" class="op oq it kk b kl km ko kp kr or kv os kz ot ld ou ov ow ox bi translated"><strong class="kk iu">选择连续的行和列</strong></li></ul><p id="9b1d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过使用切片符号提取数据帧的连续行和列。下面的代码片段显示了如何选择 id 号为 128、478、257 和 299 的雇员的姓名和薪水。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/80782dfceefa7c044b674a8052e12081.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*tqGkFb7ZRkwNsWxEzhnfAg.png"/></div></figure><p id="bef5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所示，我们仅使用切片符号来提取数据帧的行，因为我们想要选择的 id 号是连续的(索引从 0 到 3)。</p><p id="5d83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一定要记住<strong class="kk iu">。loc[]索引器</strong>使用<strong class="kk iu">闭合区间</strong>，提取开始标签和停止标签。反之，<strong class="kk iu">。iloc[]步进器</strong>采用了<strong class="kk iu">半开区间</strong>，因此停止步进处的值不包括在内。</p><h1 id="48e0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> 9。使用选择标量值。在[]和。iat[] </strong>索引器</h1><p id="5227" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">如上所述，我们可以通过向<strong class="kk iu">传递由逗号分隔的两个字符串/整数来选择一个标量值。loc[] </strong>和<strong class="kk iu">。</strong><strong class="kk iu">iloc【索引器】。</strong>此外，Pandas 提供了两个优化的函数来从数据框对象中提取标量值:<strong class="kk iu">。在[] </strong>和<strong class="kk iu">。iat[]运算符</strong>。前者通过标签提取单个值，而后者通过位置访问单个值。</p><blockquote class="nh"><p id="8187" class="ni nj it bd nk nl nm nn no np nq ld dk translated">通过标签和位置选择标量值</p><p id="37a6" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→df . at[字符串，字符串]</p><p id="289c" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→df . IAT[整数，整数]</p></blockquote><p id="20f0" class="pw-post-body-paragraph ki kj it kk b kl nr ju kn ko ns jx kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">下面的代码显示了如何使用<strong class="kk iu">通过标签和职位选择 id 号为 478 的雇员的工资。在[] </strong>和<strong class="kk iu">。iat[]索引器</strong>。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e0d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<strong class="kk iu"> %timeit 神奇函数</strong>来计算这两条 Python 语句的执行时间。如下图所示，<strong class="kk iu">。在[] </strong>和<strong class="kk iu">。iat[]运算符</strong>比<strong class="kk iu">快得多。loc[] </strong>和<strong class="kk iu">。iloc[]索引器</strong>。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/39be336f87a27d8975c0aefe3a081078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*yVL0J1EveeTdGcwmElBvQA.png"/></div></figure><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/ced4f155a2e379fd330870919638fc5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*lKJJc-7bmNfHuLg-oaFLig.png"/></div></figure><p id="d534" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，重要的是要记住<strong class="kk iu">。在[] </strong>和<strong class="kk iu">。iat[] </strong>索引器只能用于访问单个值，在尝试选择数据帧的多个元素时会引发类型错误。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="090c" class="lv lw it bd lx ly nc ma mb mc nd me mf jz ne ka mh kc nf kd mj kf ng kg ml mm bi translated">10.使用布尔选择选择行</h1><p id="1380" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">到目前为止，我们已经通过标签和位置过滤了数据框中的行和列。或者，我们也可以使用布尔索引在 Pandas 中选择一个子集。布尔选择包括通过为每行提供一个布尔值(真或假)来选择数据框的行。</p><p id="ab1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在大多数情况下，这个布尔值数组是通过对单个或多个列的值应用一个条件来计算的，该条件的计算结果为 True 或 False，具体取决于这些值是否满足该条件。但是，也可以使用其他序列、Numpy 数组、列表或 Pandas 系列来手动创建一个布尔数组。</p><p id="5e23" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，将布尔值序列放在方括号[]中，返回与真值相关联的行。</p><blockquote class="nh"><p id="b5aa" class="ni nj it bd nk nl nm nn no np nq ld dk translated">使用布尔选择选择行</p><p id="72e3" class="ni nj it bd nk nl nm nn no np nq ld dk translated">→df[布尔序列]</p></blockquote><h2 id="0660" class="pc lw it bd lx pd pe dn mb pf pg dp mf kr ph pi mh kv pj pk mj kz pl pm ml pn bi translated">根据单个列的值进行布尔选择</h2><p id="2b52" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">根据单个列的值过滤数据框的最常见方法是使用比较运算符。</p><p id="d7f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比较运算符计算两个操作数(a 和 b)之间的关系，并根据是否满足条件返回 True 或 False。下表包含 Python 中可用的比较运算符。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi po"><img src="../Images/8cd96a39a1c0c0b1ec76ee8390ccaa5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*H9m-yjLwZ5-M16qld4fvOA.png"/></div></figure><p id="cbff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些比较运算符可用于数据框的单个列，以获得一系列布尔值。例如，我们通过使用大于运算符来确定雇员的工资是否大于 45000 欧元，如下所示。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/238052f9c7dde822bc5826e03402bbd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*dKlfNAaNvnlx2h_jUXdQ1Q.png"/></div></figure><p id="3542" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出是一系列布尔值，其中高于 45000 的工资为真，低于或等于 45000 的工资为假。正如您可能注意到的，这一系列的布尔值与原始数据帧具有相同的索引(id 号)。</p><p id="b480" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个序列可以传递给索引运算符[]，以便只返回结果为真的行。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi pq"><img src="../Images/e81f027f8aad099ec70b995059bef0b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*JB15p4TTp9akNC6Hq5c64g.png"/></div></div></figure><p id="2d82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所示，我们获得了一个数据框对象，其中只包含工资高于 45000 欧元的雇员。</p><h2 id="4aa4" class="pc lw it bd lx pd pr dn mb pf ps dp mf kr pt pi mh kv pu pk mj kz pv pm ml pn bi translated">根据多列的值进行布尔选择</h2><p id="5704" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">之前，我们已经根据单个条件过滤了数据帧。然而，我们也可以使用逻辑运算符将多个布尔表达式组合在一起。在 Python 中，有三种逻辑运算符:and、or 和 not。但是，这些关键字在 Pandas 中不能用于组合多个布尔条件。相反，使用以下运算符。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi pw"><img src="../Images/5fd561587c827d8e539d8af8ce88368d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nd09QyjA8OvZbSYK6znykQ.png"/></div></div></figure><p id="1880" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码显示了如何选择工资高于 45000 并且有永久合同的雇员，该永久合同用逻辑运算符&amp;组合了两个布尔表达式。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi px"><img src="../Images/0839374cd1c6d8592ef3dc08cd4e333b.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*sovMtfHtxToHJCdRdJagsA.png"/></div></figure><p id="db0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能知道，在 Python 中，比较运算符的优先级高于逻辑运算符。但是，它不适用于熊猫，在熊猫中，逻辑运算符的优先级高于比较运算符。因此，我们需要用括号将每个布尔表达式括起来，以避免错误。</p><h2 id="225a" class="pc lw it bd lx pd pr dn mb pf ps dp mf kr pt pi mh kv pu pk mj kz pv pm ml pn bi translated">使用熊猫方法的布尔选择</h2><p id="8f55" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">Pandas 提供了大量的内置函数，这些函数返回一系列的布尔表达式，对于结合了比较和逻辑操作符的更复杂的布尔表达式来说，这是一种很有吸引力的替代方法。</p><ul class=""><li id="7d88" class="op oq it kk b kl km ko kp kr or kv os kz ot ld ou ov ow ox bi translated"><strong class="kk iu">isin 方法</strong></li></ul><p id="cca0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae lu" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.isin.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">熊猫。Series.isin </strong> </a> <strong class="kk iu"> </strong>方法接受一系列值，并在序列中与列表中的值匹配的位置返回 True。</p><p id="e298" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个方法允许我们检查一个列中是否存在一个或多个元素，而不需要使用逻辑运算符 or。下面的代码显示了如何使用逻辑运算符 or 和 isin 方法来选择具有永久或临时合同的雇员。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi py"><img src="../Images/b6f28affde031f88574e786e74a1a495.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*O06EpTUub3osrQi--_y3Aw.png"/></div></div></figure><p id="1118" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，isin 方法对于检查同一列中的多个 or 条件非常方便。此外，它更快！</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/9ad193f96b3eda59f71648ccf258393c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*NL6Vz63SvHyqhQsOIljCYw.png"/></div></figure><ul class=""><li id="15f7" class="op oq it kk b kl km ko kp kr or kv os kz ot ld ou ov ow ox bi translated"><strong class="kk iu">间法</strong></li></ul><p id="2128" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> </strong> <a class="ae lu" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.between.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">熊猫。Series.between </strong></a></p><p id="122d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下代码选择工资高于或等于 30000 欧元且低于或等于 80000 欧元的雇员。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/18b329ae5eff7b4df71a8ddc1cade826.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*Q59VPTu4tLbDESOWoa8Bmg.png"/></div></figure><p id="2edd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所观察到的，两个边界(30000 和 80000)都包括在内。为了排除它们，我们必须以下面的方式传递参数<strong class="kk iu"> inclusive=False </strong>。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/d6934cfb24c7c7f834f9e12b366964a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*WXNNuAwQh7id4L4f8yIBpw.png"/></div></figure><p id="74cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能已经注意到，上面的代码相当于编写两个布尔表达式，并使用逻辑运算符 and 对它们求值。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><ul class=""><li id="8cd9" class="op oq it kk b kl km ko kp kr or kv os kz ot ld ou ov ow ox bi translated"><strong class="kk iu">串音方法</strong></li></ul><p id="6a05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们还可以对字符串方法使用布尔索引，只要它们返回一个布尔序列。</p><p id="c8e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比如说，<a class="ae lu" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.contains.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">熊猫。Series.str.contains </strong></a></p><p id="41b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码显示了如何选择所有包含 57 的电话号码。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/07400998dfcd79e5827ad782a02a249e.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*7mZYVDnFvBxCy2YRkkDtmA.png"/></div></figure><p id="dc59" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当<strong class="kk iu"> contains </strong>方法计算一个子串是否包含在一个序列的每个元素中时，<a class="ae lu" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.startswith.html#pandas.Series.str.startswith" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">方法计算。series . str . starts with</strong></a><strong class="kk iu"/>函数检查字符串开头是否存在子字符串。同样，<a class="ae lu" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.endswith.html#pandas.Series.str.endswith" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">熊猫。series . str . ends with</strong></a><strong class="kk iu"/>测试一个子串是否出现在一个字符串的末尾。</p><p id="11c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下代码显示了如何选择姓名以“A”开头的雇员。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/a5e13d5e502e5d1a476702eca1e11246.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*H9prc9tulxt3DZEp_qz2Tg.png"/></div></figure><h1 id="4121" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="e867" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在本文中，我们介绍了从 Pandas 数据框中选择数据子集的最常见操作。此外，我们还提供了多个使用示例。现在！在清理自己的数据时，是时候将这些技术付诸实践了！✋</p><p id="ac8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了数据过滤，数据清理过程还涉及许多其他操作。如果您仍然有兴趣了解更多关于数据清理的知识，可以看看这些文章。</p><div class="qe qf gp gr qg qh"><a rel="noopener follow" target="_blank" href="/data-normalization-with-pandas-and-scikit-learn-7c1cc6ed6475"><div class="qi ab fo"><div class="qj ab qk cl cj ql"><h2 class="bd iu gy z fp qm fr fs qn fu fw is bi translated">使用 Pandas 和 Scikit 实现数据标准化-学习</h2><div class="qo l"><h3 class="bd b gy z fp qm fr fs qn fu fw dk translated">清洁数据集的完整指南—第 1 部分</h3></div><div class="qp l"><p class="bd b dl z fp qm fr fs qn fu fw dk translated">towardsdatascience.com</p></div></div><div class="qq l"><div class="qr l qs qt qu qq qv lo qh"/></div></div></a></div><div class="qe qf gp gr qg qh"><a href="https://medium.com/swlh/identify-outliers-with-pandas-statsmodels-and-seaborn-2766103bf67c" rel="noopener follow" target="_blank"><div class="qi ab fo"><div class="qj ab qk cl cj ql"><h2 class="bd iu gy z fp qm fr fs qn fu fw is bi translated">识别熊猫、Statsmodels 和 Seaborn 的异常值</h2><div class="qo l"><h3 class="bd b gy z fp qm fr fs qn fu fw dk translated">清理数据集的完整指南—第 2 部分</h3></div><div class="qp l"><p class="bd b dl z fp qm fr fs qn fu fw dk translated">medium.com</p></div></div><div class="qq l"><div class="qw l qs qt qu qq qv lo qh"/></div></div></a></div><p id="1b4e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读👐</p><p id="382a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">阿曼达·❤️</p></div></div>    
</body>
</html>