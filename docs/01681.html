<html>
<head>
<title>Magic Methods in Python, by example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">举例说明Python中的神奇方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/magic-methods-in-python-by-example-16b6826cae5c?source=collection_archive---------4-----------------------#2020-02-16">https://towardsdatascience.com/magic-methods-in-python-by-example-16b6826cae5c?source=collection_archive---------4-----------------------#2020-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="2b5f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">在我们的类设计中使用魔法方法</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/74bb9cc214c56371305ae9804a1bf6ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*_6eOmuPeLX1yq0iPjAf0nQ.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">图片由<a class="ae la" href="https://unsplash.com/@cristian1" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·埃斯科瓦尔</a>通过Unsplash提供</p></figure><h2 id="b13a" class="lb jr it bd js lc ld dn jw le lf dp ka lg lh li ke lj lk ll ki lm ln lo km lp bi translated">使用魔法改变内置行为</h2><p id="b4cd" class="pw-post-body-paragraph lq lr it ls b lt lu lv lw lx ly lz ma lg mb mc md lj me mf mg lm mh mi mj mk im bi translated">魔术方法是特殊的方法，你可以定义它来给你的类添加“魔术”。它们总是被双下划线包围，例如__init__和__str__ magic方法。神奇的方法可以通过让我们访问Python的内置语法特性来丰富我们的类设计。</p><p id="91b1" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">Python让我们的类从内置类继承。内置的继承子类共享所有相同的属性，包括内置的方法。我们可以利用核心的内置功能，但是通过使用<em class="mq">魔法方法</em>来定制选择的操作。</p><p id="8345" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">在本教程中，我将把这两个想法结合在一起，展示我们如何从内置列表类<em class="mq">和</em>中继承，并在我们的类设计中使用神奇的方法。我将修改控制列表索引的三个神奇方法。通过结合这些特性，我们可以构建一个简单易用的类，并且我们可以给我们想要的方法添加行为。所有Python开发人员都熟悉内置行为；反过来，这使得我们的继承类易于学习。</p><p id="e684" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">最后，将演示两个更广泛的例子，说明如何在广播操作中使用魔法方法以及如何改变实例的状态。所有附带的代码都可以通过<a class="ae la" href="https://gist.github.com/StephenFordham" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获得。</p><h2 id="e0cf" class="lb jr it bd js lc ld dn jw le lf dp ka lg lh li ke lj lk ll ki lm ln lo km lp bi translated">示例1:列表索引</h2><p id="0c7e" class="pw-post-body-paragraph lq lr it ls b lt lu lv lw lx ly lz ma lg mb mc md lj me mf mg lm mh mi mj mk im bi translated">可以操纵神奇的方法来修改列表索引。MyCustomList类继承自内置列表类型。这意味着通过MyCustomList类创建的任何对象都将像列表一样工作，除非我们选择有选择地自定义方法。</p><p id="a024" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">getitem、setitem和delitem是在我们访问列表索引时调用的神奇方法。这些神奇方法的行为是可以修改的。</p><p id="3b25" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">在下面的例子中，我们放弃了从第0个索引开始的列表索引的想法。如果用户试图使用第零个索引访问列表中的元素，将会引发ValueError异常，程序将会终止。如果用户输入一个大于一的列表索引，这些方法会将索引减一，然后用这个索引调用父类列表。</p><p id="c0b3" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">要展示如何使用MyCustomList类中定义的这些方法，请参见Python交互式提示中的以下内容。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/3facb69cc55fabeacca3cc9ce31f4709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNUm4e_Naioj1xRdCkLQZw.png"/></div></div></figure><p id="1684" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">该示例显示了如何调用getitem、setitem和delitem。魔术方法可以被隐式调用。对于__getitem__，要访问第一个索引，只需在方括号中写下对象的名称，后跟索引位置。</p><p id="bedd" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">最有趣的是，当我们请求索引位置1的元素时，返回的是整数值1，尽管1是第<em class="mq">个第0个</em>元素。我们这里有一个列表，它从1开始索引。事实上，它弥补了我们第一次学习列表索引时的困惑。</p><p id="c6a8" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">现在，让我们将列表中的整数值1改为100。为此，我们需要调用setitem。为此，我们只需写下对象的名称，后跟方括号和赋值。<em class="mq">再次</em>，为了改变列表中的第一个元素，我们使用索引位置1。当我们再次输出列表时，我们可以清楚地看到第一个元素从1变成了100。</p><p id="fbb7" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">最后，要从列表中删除一个元素，可以定义__delitem__。当我们使用解析为__delitem__方法调用的del python关键字时，调用__delitem__ magic方法。为了进一步构建我们的列表索引示例，让我们删除索引中的第一个元素，即整数值100。当我们调用del时，后面是对象和我们要删除的元素的索引位置，在这个例子中，是列表100中的第一个元素，我们现在可以看到100实际上已经被删除了！</p><p id="b345" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">神奇的方法提供了修改默认行为的机会。最重要的是，不需要学习新的方法名或新的接口，因此可以直观地实现这些方法。下表给出了使用MyCustomList中实现的这些神奇方法的指南。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi my"><img src="../Images/ce7f9f89cdeff1746453e8deaafc7353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8e5tqZVVW-kAouRbyUdmpA.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">如何调用神奇的方法，getitem，setitem和delitem</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/6f131245513586d3225c13c592e6fc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*NY-TL0XE5G6ercodzDphEA.png"/></div></figure><h2 id="42a8" class="lb jr it bd js lc ld dn jw le lf dp ka lg lh li ke lj lk ll ki lm ln lo km lp bi translated">示例2:mul魔术方法</h2><p id="40a0" class="pw-post-body-paragraph lq lr it ls b lt lu lv lw lx ly lz ma lg mb mc md lj me mf mg lm mh mi mj mk im bi translated">我们也可以在我们的类设计中使用乘法运算符。因为我们继承了内置的List类，所以我们可以将两个MyCustomList对象压缩在一起(因为它们的行为类似于list对象)并遍历zip对象。在迭代过程中，我们可以用广播的方式将每个列表中的元素乘以另一个列表中相应的元素(参见下面的__mul__ magic method代码片段)。这种广播行为类似于在数据分析包(如Pandas和Numpy)中发现的行为。</p><p id="a0db" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">该示例显示，我们可以使用*符号将两个MyCustomList对象放在一起。如果我们在一个名为list_three的变量中捕获返回值，并打印list_three，就会输出一个新的列表。这个列表是另外两个列表中的元素相乘的结果。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi na"><img src="../Images/d8e9a5be114dd5b66b76aa979e3b52f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rXTuFZVLveH4Rnv-jQHLsA.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">__mul__是MyCustomList类中的一个方法。在这里，它是孤立显示的。</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nb"><img src="../Images/6612c633236b79053b4f7683424272bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUyXmvLdH1p3P8Ae2KLIag.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">乘法运算符*解析为__mul__ magic方法调用，我们可以对其进行定制以返回我们想要的行为。</p></figure><p id="f1a3" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">本例中使用的类MyCustomList的完整源代码如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="8415" class="lb jr it bd js lc ld dn jw le lf dp ka lg lh li ke lj lk ll ki lm ln lo km lp bi translated">示例奖励:call魔术方法</h2><p id="0bcf" class="pw-post-body-paragraph lq lr it ls b lt lu lv lw lx ly lz ma lg mb mc md lj me mf mg lm mh mi mj mk im bi translated">最后，我将说明如何调用Python中的__call__ magic方法。<code class="fe nc nd ne nf b">__call__</code>在需要经常改变状态的类中特别有用。“调用”实例可以是改变对象状态的一种直观而优雅的方式。</p><p id="8cf3" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">考虑所示的例子。这里，类MyClass有一个init构造函数，它期望传递三个参数。这三个参数可以在init方法签名中传递，并作为属性分配给对象。</p><p id="1e94" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">当我们想要改变一个实例的状态，而不需要实际创建一个新的实例时，call magic方法非常有用。</p><p id="7747" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">当实例第一次初始化时，我传入整数1、2和3，它们在实例中分别被赋值为属性var_1、var_2和var_3。当我使用print语句显示实例obj的输出时，通过使用__dict__属性，我可以看到var_1被赋值为1，var_2被赋值为2，var_3被赋值为3。</p><p id="2262" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">现在，让我们假设我想要更改这个实例的var_1和var_2属性值，同时保持var_3属性与最初构造实例时一样。</p><p id="592c" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">做到这一点很简单。我定义了一个调用魔术方法，它允许重新定义var_1和var_2属性。魔术方法可以隐式调用，这意味着我只需调用obj(200，300)，调用方法就会被调用。当然，也可以显式调用call方法，例如obj。__call__(200，300)，但第一种方法似乎更直观。最后，出于演示的目的，我打印了实例的id以明确显示我们操作了同一个对象。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ng"><img src="../Images/5c03be33612a219abe7f8868243bd2fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sWwnr6N3KqmU3qE3eHnQJA.png"/></div></div></figure><p id="95eb" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">调用方法可以用两种方式定义。参数可以直接传递给调用方法签名。或者，可以使用*vars参数，它捕获传递的所有参数，并将它们存储在一个元组中，可以像上面所示的那样进行解包。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f836348a6154dfdbb768761a28bc64df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*SgRq0gRhHVTmECVGFfUEmQ.png"/></div></figure><p id="7ee3" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">这个例子的源代码可以在下面找到。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="c72e" class="lb jr it bd js lc ld dn jw le lf dp ka lg lh li ke lj lk ll ki lm ln lo km lp bi translated">摘要</h2><p id="de9b" class="pw-post-body-paragraph lq lr it ls b lt lu lv lw lx ly lz ma lg mb mc md lj me mf mg lm mh mi mj mk im bi translated">神奇的方法可以让我们访问核心语法特性，从而丰富我们的类设计。在第一个例子中，我们拥有两个世界的精华。我们可以从内置的list类继承，并修改该类中的特定方法来定制行为。getitem、setitem和delitem都被修改了，但是通过继承，我们仍然能够利用列表的内置init和repr()方法。</p><p id="cf93" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">我们可以非常容易地与其他开发人员交流对象的使用。在提供的例子中，我们需要告诉开发人员的是，我们的类像一个列表，只是有一点不同，这里我们放弃了第零个索引的想法。不需要学习新的方法名或新的接口。</p><p id="c1a6" class="pw-post-body-paragraph lq lr it ls b lt ml lv lw lx mm lz ma lg mn mc md lj mo mf mg lm mp mi mj mk im bi translated">此外，还演示了调用魔术的方法。调用实例可以是改变对象状态的一种直观而优雅的方式。</p></div></div>    
</body>
</html>