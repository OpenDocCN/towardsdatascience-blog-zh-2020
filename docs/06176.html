<html>
<head>
<title>Automated Machine Learning for Gradient Boosting Machines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">梯度推进机器的自动机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/automated-machine-learning-for-gradient-boosting-machines-48cd38ad9649?source=collection_archive---------80-----------------------#2020-05-18">https://towardsdatascience.com/automated-machine-learning-for-gradient-boosting-machines-48cd38ad9649?source=collection_archive---------80-----------------------#2020-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7be1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何利用NNI提升梯度增强机器的超参数调节水平</h2></div><p id="ab34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像XGBoost和LightGBM这样的梯度推进机器是当今最受欢迎的机器学习算法之一，经常出现在Kaggle竞赛的获胜者中。尽管它们开箱即用，但通过调整算法的参数可以获得一些性能提升。此外，参数数量太多，无法直观设置或依靠快速试错法。AutoML前来救援。</p><p id="a504" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">AutoML——自动化机器学习——旨在使机器学习自动化。在这里，我们主要关注超参数优化的AutoML。我们将研究三种不同的算法，每种算法都有不同的优势:Metis、贝叶斯优化超带(BOHB)和基于群体的训练(PBT)。据我所知，最后一个还没有适应梯度增压机。正如我们将看到的，PBT和GBM的结合有一些有趣的含义。</p><p id="2f21" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以在GitHub上找到完整代码:<a class="ae lb" href="https://github.com/NKDataConv/AutoML_Gradient_Boosting_Machines" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/NKDataConv/AutoML _ Gradient _ Boosting _ Machines</a>。我们将使用工具NNI中的AutoML算法。你可以在这里找到安装NNI <a class="ae lb" href="https://nni.readthedocs.io/en/latest/installation.html" rel="noopener ugc nofollow" target="_blank">的说明</a>。此外，我们将需要LightGBMs，你可以在这里找到安装指南<a class="ae lb" href="https://lightgbm.readthedocs.io/en/latest/Installation-Guide.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="099b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从Metis开始，了解如何为NNI调整算法培训。</p><h2 id="526f" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">墨提斯</h2><p id="9bfd" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">梅蒂斯的想法很简单。Metis建立了一个参数与性能的模型。在一些初始随机试验后，该模型可以推断出有希望的参数配置。尝试这些，并根据存档的性能更新模型。Metis背景中的模型是高斯过程，并且利用贝叶斯优化进行更新。</p><p id="24dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使您的算法适应Metis，您需要做的就是添加两个描述实验的文件，并将两种方法集成到您现有的代码中。让我们先看看方法:<em class="ma"> nni.get_next_parameter() </em>给出下一个要尝试的参数配置。其次，<em class="ma">nni . report _ final _ result()</em>将存档的绩效进行反馈。</p><p id="714b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的代码片段中，您可以看到这两种方法是如何与训练过程的其余部分一起发挥作用的。完整代码可在<a class="ae lb" href="https://github.com/NKDataConv/AutoML_Gradient_Boosting_Machines" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="879a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第二行中，生成了一些默认参数。还包括一些AutoML没有调优的参数。</p><p id="7c9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还会注意到，数据被分成四部分:训练集、测试集和两个验证集。现在，你可能想知道，为什么要有两个验证集。也许这不是绝对必要的。尽管如此，我认为这是一个好主意。关于这一点，让我直言不讳。训练集是针对机器学习算法本身的。在训练过程之后，在验证集上测量性能。通常，您执行一些迭代训练和验证。在此过程中，您需要手动检查验证集的性能。在训练和验证之间经过足够的周期后，验证数据集上的过度拟合可能会发生。这就是为什么我们应该拿出一套测试设备的原因。有了AutoML，训练和验证之间循环变得更加复杂，而且要进行多次。因此，拥有一个测试集比以往任何时候都更重要。该测试集仅在AutoML的整个过程完成后使用。</p><p id="d7da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在来看两个验证集。第一个用于确定提前停止。提前停止是一个非常强大的想法。与梯度提升机器相结合，它确保当验证数据集的性能不再提高时，不再添加更多的树。但这本身就是对验证数据的优化。请记住，我们从验证数据集转移到测试数据集，因为验证数据已经发生了优化，我们不想过度适应。这同样适用于这里。我们通过提前停止优化第一个验证集。然后，我们转向超参数优化。这就是我们使用第二个验证数据集的地方。总结:将验证一分为二的优势在于，超参数优化不会发生在早期停止后产生良好结果的参数上。相反，它针对参数进行了优化，在训练过程(包括提前停止另一部分数据)之后，这些参数会产生良好的结果。</p><p id="b937" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的一件非常重要的事情是报告回来的最终分数的性质。它不一定是可微的。在这里，是准确性。但是分数可以是任何东西，甚至是你自己定义的损失。基于这种损失，超参数被优化。通常，对于机器学习中的优化，损失必须是可微的，以找到最小值。这里的情况不是这样。这在陈述问题和性能测量方面提供了很大的自由度。我们可以在这里陈述我们真正关心的东西(而不是关注数学性质)。</p><p id="f576" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们回到代码。需要一个额外的文件<em class="ma"> search_space.json </em>来描述参数搜索空间，从该空间对超参数进行采样。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="dd06" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个JSON文件。参数的名称是关键，括号中是获取新值的策略(此处仅使用随机整数和均匀分布)。更多策略可用，见<a class="ae lb" href="https://nni.readthedocs.io/en/latest/Tutorial/SearchSpaceSpec.html" rel="noopener ugc nofollow" target="_blank">此处</a>。)</p><p id="fec1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个文件<em class="ma"> config.yml </em>描述了AutoML配置。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="c75c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是YAML的档案。要注意的最重要的事情是获得正确的优化模式。当我们在这里优化精度时，我们希望将其最大化。如果你要使用像均方差这样的损失，你可以将它设置为<em class="ma">最小化</em>。</p><p id="1da6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，可以从相应文件夹中的命令行启动实验:</p><p id="d97c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ma">nni CTL create—config config . yml</em></p><p id="65fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，您可以在NNI UI上观察结果。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/9f2f415f7ed7bcc801b3320ff3c4812b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CAvaMRQdfWgQIGUz1Bgwqg.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">用于超参数调整的NNI用户界面</p></figure><h2 id="789b" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">BOHB</h2><p id="8569" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">这种算法也做贝叶斯优化，但有另一个很酷的功能。这种特性称为连续减半。总的想法是，对整个数据集的训练在计算上是昂贵的。所以你开始只训练几轮助推。在这些提升回合之后，你比较表现，并且只继续最成功的回合。他们再次接受几轮训练，并再次比较他们的表现。这一直持续到只剩下一个配置。这是最成功的配置。该过程可以分别节省资源和时间，因此，对于需要花费太多时间进行多次训练的大型复杂数据集来说，这是一种很好的方法。</p><p id="518c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要做一些小的改变来适应BOHB。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="e5bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先要注意的是参数<em class="ma"> TRIAL_BUDGET </em>。这个是BOHB自己设置的，不需要包含在<em class="ma"> search_space.json </em>中。<em class="ma"> TRIAL_BUDGET </em>负责保持第一次试验规模较小，并在以后的试验中延长试验时间。这个想法是有10个助推轮的倍数。在<em class="ma"> TRIAL_BUDGET = 1 </em>的情况下，将有10轮助推。用<em class="ma"> TRIAL_BUDGET = 2 </em>，会有20轮助推，以此类推。这有一个缺点，参数<em class="ma"> boosting_rounds </em>将不再包含在超参数优化中。</p><p id="0e04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个要注意的是方法<em class="ma">nni . report _ intermediate _ result</em>。这不是绝对必要的，但是在UI中提供了一些很好的可视化效果。<br/>最后，for循环在第一次迭代和所有其他迭代之间存在差异。这是为了在第一次迭代中启动助推器(分别是模型)。在进一步的迭代中，模型将加载参数<em class="ma"> init_model </em>和已经训练好的模型作为参数。</p><p id="ef80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他两个文件基本保持不变。</p><h2 id="3ad3" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">聚对苯二甲酸丁二醇酯（polybutylene terephthalate的缩写）</h2><p id="dd2a" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">现在让我们看看PBT。这个想法类似于进化算法。PBT总是训练一群算法。最有希望的那些将其超参数配置复制到群体中最没有希望的那些。通过应对，超参数出现微小变化。在一定的机会下，最没有希望的配置被新采样的配置替换。从一个算法到另一个算法的超参数的处理有很大的意义。在整个AutoML训练结束时，我们不会以某个超参数配置结束。相反，它是算法被训练的不同超参数的历史。我们还有一个训练有素的模特。利用PBT，可以在开始时以较大的学习速率训练算法，在结束时以较低的学习速率训练算法。或者也许它有一些优势，开始时树的深度较低，结束时树的深度较高。有了PBT，这一切都成为可能。而且是自动进行的。</p><p id="54d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与其他算法相比的一个缺点如下:通常你会在训练和验证集上找到一个好的超参数配置。然后你在你的测试集上测试它，如果你满意，在整个数据集上再次训练它。尚不清楚这对于PBT是否有意义。由于PBT返回训练好的算法，因此在整个数据集上复制超参数配置的历史可能没有意义。</p><p id="e8a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们再次看看执行情况。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="6b46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为PBT的一个附加参数，我们有检查点目录。它们是在一次迭代结束时从群体中保存模型并在下一次迭代开始时再次加载它们所必需的。PBT和NNI会自动将来自不同群体的模型保存在专门的文件夹中。</p><p id="09aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你可以开始你自己的AutoML实验了。我建议从梅蒂斯开始。如果您的数据量很大，而时间又很紧，那么就转到BOHB吧。如果你可以在训练过程中忽略一些数据，尝试PBT。如果你让我知道你的自动化实验进展如何，我会很高兴。</p></div></div>    
</body>
</html>