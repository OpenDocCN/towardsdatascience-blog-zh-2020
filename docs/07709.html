<html>
<head>
<title>Understanding DBSCAN Algorithm and Implementation from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始理解DBSCAN算法和实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-dbscan-algorithm-and-implementation-from-scratch-c256289479c5?source=collection_archive---------17-----------------------#2020-06-09">https://towardsdatascience.com/understanding-dbscan-algorithm-and-implementation-from-scratch-c256289479c5?source=collection_archive---------17-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0937" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">DBSCAN算法分步，Python实现，可视化。</h2></div><h1 id="e8f9" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated"><strong class="ak">什么是DBSCAN </strong></h1><p id="b258" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">DBSCAN(带噪声的基于密度的应用空间聚类)是一种常用的无监督聚类算法，于1996年提出。与众所周知的K-mean不同，DBSCAN不需要指定聚类数。它可以根据您输入的数据和参数自动检测集群的数量。更重要的是，DBSCAN可以发现k-means不能发现的任意形状的聚类。例如，被不同群集包围的群集。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/e004e6a6beedbbba836e7843edf0c18c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KqWII7sFp1JL0EXwJGpqFw.png"/></div></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">DBSCAN vs K-means，<a class="ae mm" href="https://github.com/NSHipster/DBSCAN" rel="noopener ugc nofollow" target="_blank">信用</a></p></figure><p id="b1f3" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">此外，DBSCAN可以处理噪声和异常值。所有离群值将被识别和标记，而不被分类到任何聚类中。因此，DBSCAN也可以用于异常检测(异常值检测)</p><p id="53e8" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">在我们查看preusdecode之前，我们需要先了解一些基本概念和术语。Eps、Minpits、直接密度可达、密度可达、密度连通、核心点和边界点</p><p id="4c8f" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">首先，我们需要为DBSCAN、Eps和MinPts设置两个参数。</p><p id="df7b" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated"><strong class="lc iu"> Eps:小区最大半径</strong></p><p id="86ee" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated"><strong class="lc iu"> MinPts:该点的Eps邻域中的最小点数</strong></p><p id="8894" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">并且有<strong class="lc iu">直接密度可达</strong>的概念:一个点p是从一个点q直接密度可达w.r.t. Eps，MinPts，如果NEps (q): {p属于D | dist(p，q) ≤ Eps}并且|N Eps (q)| ≥ MinPts。我们来看一个Minpts = 5，Eps = 1的例子。让我们看一个例子来理解密度可达和密度连通。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ms"><img src="../Images/a440af521bcff7f8e51a3d843b3e9b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*of9pB-lKzq2WYGJR0MptEQ.png"/></div></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">密度可达示例</p></figure><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mt"><img src="../Images/4912d047733f61b5644b1a19f57ff2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*glKWP2UK1uJRk1-IjSRIIg.png"/></div></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">密度相关示例</p></figure><p id="f4e4" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">最后，如果一个点在Eps中有超过指定数量的点(MinPts ),那么这个点就是核心点。这些是在聚类a内部的点。并且边界点在Eps内具有比MinPts少的点，但是在核心点的邻域内。我们还可以定义离群点(噪声点)，即既不是核心点也不是边界点的点。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mu"><img src="../Images/3fe90815f61191738130d2f84be1b6ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbTih3J6rYNmVuV9hN17bQ.png"/></div></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">核心点、边界点、异常点示例</p></figure><p id="8d7a" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated"><strong class="lc iu">现在，我们来看看DBSCAN算法实际上是如何工作的。这是前解码。</strong></p><ol class=""><li id="702b" class="mv mw it lc b ld mn lg mo lj mx ln my lr mz lv na nb nc nd bi translated">任意选择一个点p</li><li id="fce5" class="mv mw it lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">基于Eps和MinPts检索从p密度可达的所有点</li><li id="0154" class="mv mw it lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">如果p是一个核心点，就形成了一个集群</li><li id="408d" class="mv mw it lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">如果p是一个边界点，则没有从p密度可达的点，DBSCAN访问数据库的下一个点</li><li id="1e7f" class="mv mw it lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">继续该过程，直到处理完所有点</li></ol><p id="9f68" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated"><em class="nj">如果使用空间索引，DBSCAN的计算复杂度为O(nlogn)，其中n是数据库对象的数量。否则，复杂度为O(n ) </em></p><h1 id="60c3" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">例子</h1><p id="f4eb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">考虑以下9个二维数据点:</p><p id="0f87" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">x1(0，0)，x2(1，0)，x3(1，1)，x4(2，2)，x5(3，1)，x6(3，0)，x7(0，1)，x8(3，2)，x9(6，3)</p><p id="9d63" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">使用欧几里德距离，Eps =1，MinPts = 3。找到所有的核心点、边界点和噪声点，并使用DBCSAN算法显示最终的聚类。让我们一步步展示结果。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nk"><img src="../Images/6a4ccd706dd80ad0cf40bcf73df7c520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2BbKf8SGTdUBF-oEJ1wLVQ.png"/></div></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">数据可视化示例</p></figure><p id="41e0" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated"><strong class="lc iu">首先，计算N(p)，Eps-点p的邻域</strong></p><p id="c137" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">N(x1) = {x1，x2，x7}</p><p id="0f8c" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">N(x2) = {x2，x1，x3}</p><p id="c92d" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">N(x3) = {x3，x2，x7}</p><p id="4aba" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">N(x4) = {x4，x8}</p><p id="9590" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">N(x5) = {x5，x6，x8}</p><p id="9095" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">N(x6) = {x6，x5}</p><p id="e8e9" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">N(x7) = {x7，x1，x3}</p><p id="3def" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">N(x8) = {x8，x4，x5}</p><p id="7731" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">N(x9) = {x9}</p><p id="f66c" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">如果N(p)的大小至少为MinPts，则称p为核心点。这里给定的MinPts是3，因此N(p)的大小至少是3。<strong class="lc iu">因此核心点是:{x1，x2，x3，x5，x7，x8} </strong></p><p id="1cbe" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">然后根据边界点的定义:给定一个点p，若p不是核心点但N(p)包含至少一个核心点，则称p为边界点。N(x4) = {x4，x8}，N(x6) = {x6，x5}。这里x8和x5是核心点，所以<strong class="lc iu"> x4和x6都是边界点</strong>。显然，左边的点，<strong class="lc iu"> x9是一个噪声点。</strong></p><p id="05d2" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated"><strong class="lc iu">现在，让我们按照preusdecode生成集群。</strong></p><ol class=""><li id="174c" class="mv mw it lc b ld mn lg mo lj mx ln my lr mz lv na nb nc nd bi translated">任意选择一个点p，现在我们选择x1</li><li id="c5e9" class="mv mw it lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">检索从x1: {x2，x3，x7}密度可达的所有点</li><li id="b64c" class="mv mw it lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">这里x1是一个核心点，形成一个集群。因此，我们有Cluster_1: {x1，x2，x3，x7}</li><li id="1a44" class="mv mw it lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">接下来，我们选择x5，检索从x5密度可达的所有点:{x8，x4，x6}</li><li id="a4a4" class="mv mw it lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">这里x5是一个核心点，形成一个集群。因此，我们有了Cluster_2: {x5，x4，x8，x6}</li><li id="e4d2" class="mv mw it lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">接下来，我们选择x9，x9是一个噪声点，噪声点不属于任何聚类。</li><li id="790a" class="mv mw it lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">因此，算法到此为止。</li></ol><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nl"><img src="../Images/4751564856dfc5bf4bb816973d1643de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53hcLmFE6e-a8NxFNkPlxQ.png"/></div></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">最终DBSCAN集群结果</p></figure><h1 id="299e" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">Python实现</h1><p id="cc55" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面是一些示例代码，用于从头开始构建FP-tree，并在Python 3中找到所有的频率项集。我还添加了点的可视化，并用蓝色标记所有异常值。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="fe57" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated"><strong class="lc iu">感谢您的阅读，我期待听到您的问题和想法。如果你想了解更多关于数据科学和云计算的知识，可以在</strong><a class="ae mm" href="https://www.linkedin.com/in/andrewngai9255/" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">Linkedin</strong></a><strong class="lc iu">上找我。</strong></p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nv"><img src="../Images/e1ded9d7dfb0df91e5f492416136e0e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aZnhs3GhiyAqNk1Y"/></div></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">照片由<a class="ae mm" href="https://unsplash.com/@alfonsmc10?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alfons Morales </a>在<a class="ae mm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="2537" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated"><em class="nj">参考</em></p><p id="18f3" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated"><em class="nj">https://github.com/NSHipster/DBSCAN</em></p><p id="85db" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated"><em class="nj">https://en.wikipedia.org/wiki/DBSCAN</em></p></div></div>    
</body>
</html>