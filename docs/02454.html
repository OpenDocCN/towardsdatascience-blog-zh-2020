<html>
<head>
<title>Build a Super Simple GAN in PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 PyTorch 中构建一个超级简单的 GAN</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-super-simple-gan-in-pytorch-54ba349920e4?source=collection_archive---------1-----------------------#2020-03-09">https://towardsdatascience.com/build-a-super-simple-gan-in-pytorch-54ba349920e4?source=collection_archive---------1-----------------------#2020-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="461c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">GANs 看起来很可怕，但是它的思想和基本实现非常简单，就像 50 行代码一样简单。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c2d7e44a2b9b8da99cf035c90626798b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*Bll7Kb6PevAJOb6eset5yQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://teespring.com/ganpple?tsmac=store&amp;tsmic=deepproducts&amp;pid=226&amp;cid=5860" rel="noopener ugc nofollow" target="_blank">在<a class="ae ku" href="https://usdawatercolors.nal.usda.gov/pom/home.xhtml" rel="noopener ugc nofollow" target="_blank">美国农业部果树水彩画集</a>上接受训练的甘</a>的植物学绘画。</p></figure><h1 id="ab4a" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">介绍</h1><p id="05f1" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">生成敌对网络(GANs)是一个模型框架，其中两个模型一起训练:一个学习从与训练集相同的分布中生成合成数据，另一个学习从生成的数据中区分真实数据。当我第一次了解它们的时候，我记得当时对如何构建联合训练有点不知所措。我还没有看到专注于构建一个简单的 GAN 的教程，所以我将在这里尝试这样做。没有图像生成，没有花哨的油炸 conv 网。我们将训练一个能够学习用大约 50 行 Python 代码生成偶数的模型。这个项目的所有代码都可以在 github 库<a class="ae ku" href="https://github.com/nbertagnolli/pytorch-simple-gan" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="d426" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">什么是甘？</h1><p id="b6ec" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">GANs 由两个训练一致的模型组成。第一个模型是生成器，它接收一些随机输入，并试图输出一些看起来像我们的训练数据的东西。第二个模型是鉴别器，它接收训练数据和生成的数据，并试图将假生成的数据与真实的训练数据区分开。这个框架的有趣之处在于，这些模型是一起训练的。随着鉴别器在识别假图像方面变得更好，这种学习被传递给生成器，并且生成器在生成假图像方面变得更好。用一个比喻来说，生产者对于鉴别者就像伪造者对于 FBI 调查员一样。一个试图伪造数据，另一个试图区分伪造和真实交易。</p><p id="936c" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">这个框架在过去几年里产生了大量超级有趣的结果，从把马翻译成斑马，到制作深度赝品，再到想象全新的图像。在本教程中，我们不会做任何有趣的事情，但这应该给你所有的背景知识，你需要从零开始，成功地实现自己的 GAN:)。让我们开始吧。</p><h1 id="d636" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">问题定义</h1><p id="5d0a" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">假设我们有一个 0 到 128 之间所有偶数的数据集。这是一个更大的数据分布的子集，整数，具有一些特定的属性，就像人脸是所有生物图像的子集一样。我们的生成器将接受相同范围内的整数形式的随机噪声，并学习只产生偶数。</p><p id="c0b5" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">在进入实际模型之前，让我们先建立数据集。我们将把每个整数表示为无符号的 7 位二进制表示。所以数字 56 是 0111000。我们这样做是因为:</p><ol class=""><li id="f05e" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">将二进制向量传递给机器学习算法是非常自然的，在这种情况下，是神经网络。</li><li id="9304" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">通过查看最低位，很容易看出模型是否生成偶数。如果是 1，数字是奇数，如果是 0，数字是偶数。</li></ol><p id="a0d8" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">首先，让我们写一个函数，将任意正整数转换成二进制形式的列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">将正整数转换为二进制列表</p></figure><p id="a71c" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">有了这个，我们就可以创建一个函数，它会动态地为我们生成随机的训练数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">生成 GAN 训练数据的功能。</p></figure><p id="7d1a" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">这个函数将产生两个输出，第一个是一个列表，表示这个数据是偶数，来自我们的真实分布。第二个输出是二进制列表形式的随机偶数。这就是我们开始构建和训练模型所需的全部内容！</p><h1 id="1619" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">构建生成器和鉴别器</h1><h2 id="e6a1" class="ne kw it bd kx nf ng dn lb nh ni dp lf lw nj nk lh ma nl nm lj me nn no ll np bi translated">发电机</h2><p id="51c6" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">构建生成器和鉴别器非常简单！让我们从发电机开始。我们需要一些能够映射随机七位二进制输入到七位二进制输入是偶数。这里最简单的可能是一个七层神经元。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">发电机架构</p></figure><p id="3ed0" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">如果我们要构建一个 GAN 来处理一些更复杂的事情，比如图像，我们可能会使用从正态分布中生成的随机噪声来训练它，并逐渐对它进行上采样和整形，直到它与我们试图复制的数据大小相同。由于我们的示例非常简单，所以具有逻辑(sigmoid)激活的单个线性层应该足以将 7 个位置的 1 和 0 映射到其他 7 个位置的 1 和 0。</p><h2 id="2759" class="ne kw it bd kx nf ng dn lb nh ni dp lf lw nj nk lh ma nl nm lj me nn no ll np bi translated">鉴别器</h2><p id="03c9" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">鉴别器不比发生器复杂。这里我们需要一个模型来接受一个七位数的二进制输入和输出，无论它是否来自我们的真实数据分布(是偶数)或不是(是奇数或不是数字)。为了实现这一点，我们使用具有逻辑激活(Sigmoid)的单神经元模型(逻辑回归)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4979" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">就这样，我们已经建立了两个模型，我们将一起训练。现在是甘训练中最棘手的部分。我们需要将这些模型连接起来，以正确传播梯度。</p><h1 id="0d3d" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">训练模型</h1><p id="2a26" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">训练 gan 一开始看起来有点混乱，因为我们需要用每一点输入来更新两个模型，并且我们需要小心我们是如何做的。因此，为了分解它，我们在每个训练步骤向我们的模型传递两批数据。一批是随机噪声，这将导致生成器创建一些生成的数据，第二批仅由来自真实分布的数据组成。在整个培训描述中，我将引用下面最终培训代码要点中的行号，而不是 Github 存储库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">最终培训代码</p></figure><h2 id="6aab" class="ne kw it bd kx nf ng dn lb nh ni dp lf lw nj nk lh ma nl nm lj me nn no ll np bi translated">训练发电机</h2><p id="7696" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">让我们从训练发电机开始。这包括:</p><ol class=""><li id="de8a" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">制造随机噪音。(第 27 行)</li><li id="5f7c" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">通过将噪声传递给生成器来生成新的“假”数据(第 28 行)</li><li id="8f60" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">从鉴别器获得对“假”数据的预测(第 38 行)</li><li id="0040" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">使用标签计算鉴频器输出的损失，就好像数据是“真实的”而不是假的。(第 39 行)</li><li id="f6b5" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">仅通过生成器反向传播错误。(第 40–41 行)</li></ol><p id="b7d2" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">请注意，在第四步中，我们如何使用真标签而不是假标签来计算损失。这是因为我们正在训练发电机。发生器应该试图欺骗鉴别器，因此当鉴别器出错并说产生的输出是真实的(预测 1)时，梯度应该小，当鉴别器正确动作并预测产生输出(预测 0)时，梯度应该大。这就是为什么我们在这一步只通过生成器传播梯度，因为我们颠倒了标签。如果我们像这样训练整个模型，要么生成器会学到错误的东西，要么鉴别器会。</p><h2 id="83c2" class="ne kw it bd kx nf ng dn lb nh ni dp lf lw nj nk lh ma nl nm lj me nn no ll np bi translated">训练鉴别器</h2><p id="e9c6" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">现在是时候更新我们的鉴别器中的权重了。我们分几步完成:</p><ol class=""><li id="fbfa" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">传入一批来自真实数据集中的数据，这些数据带有一个全 1 标签的向量。(第 44–46 行)</li><li id="9c70" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">将我们生成的数据传入鉴别器，带有分离的权重和零标签。(第 49–50 行)</li><li id="8bc0" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">平均第一步和第二步的损失。(第 51 行)</li><li id="763d" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">通过鉴别器反向传播梯度。(第 52–53 行)</li></ol><p id="e73b" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">鉴别器正在努力学习区分真实数据和“假”生成的数据。训练鉴别器时的标签需要代表这一点，即当我们的数据来自真实数据集时为 1，当它由我们的生成器生成时为 0。我们在上面的步骤(1)和(2)中传递这两个批次，然后平均这两个批次的损耗。重要的是要注意，当传入生成的数据时，我们希望分离梯度。我们这样做是因为我们不是在训练生成器，我们只是在关注鉴别器。一旦所有这些都完成了，我们只在鉴别器中反向传播梯度，我们就完成了。</p><h2 id="afbb" class="ne kw it bd kx nf ng dn lb nh ni dp lf lw nj nk lh ma nl nm lj me nn no ll np bi translated">包扎</h2><p id="7480" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">就是这样！我们已经建立了完整的 GAN。在训练循环中，每一步都进行梯度归零，这样我们就可以开始了。如果我们在不同的训练步骤中查看生成器的输出，我们可以看到它收敛到只创建偶数，这正是我们想要的！</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="2494" class="ne kw it nr b gy nv nw l nx ny">0   : [47, 3, 35, 1, 16, 56, 39, 16, 3, 1]<br/>50  : [2, 35, 34, 34, 38, 2, 34, 43, 3, 43]<br/>100 : [42, 43, 106, 38, 35, 42, 35, 42, 43, 106]<br/>200 : [108, 106, 106, 42, 106, 42, 106, 106, 42, 96]</span></pre><p id="d76f" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">在步骤 0，我们的样本中有 7/10 是奇数，而在步骤 200，我们的样本中有 10/10 是偶数！这是一个成功的生成器，它只用了大约 50 行真正的 Python 代码！</p><h1 id="5c57" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">接下来呢？</h1><p id="c190" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">正如您可能已经猜到的，还有其他一些技巧来训练生成非平凡输出的 GAN。如果您想让该模型在图像等真实数据上工作，可以立即尝试以下方法:</p><ol class=""><li id="4a52" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">生成器可能需要更深一点，并将噪声放大到真实数据的大小。您可以使用转置卷积或上采样层来实现这一点。</li><li id="e294" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">将发生器的噪声输入更改为高斯型</li><li id="4587" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">增加鉴别器的深度，使其预测能力更强。</li><li id="1b7a" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">训练更长的时间，并监测损失。</li></ol><p id="6a8e" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">作为一个好的下一步，尝试并实现<a class="ae ku" href="https://arxiv.org/abs/1511.06434" rel="noopener ugc nofollow" target="_blank"> DCGAN </a>架构。这个代码会帮你完成 90%的任务。一旦你这样做了，并制作了一些像介绍中那样有趣的图像，试着通过调整超参数来改进它们。在训练真正的甘人时，可以在<a class="ae ku" href="https://github.com/soumith/ganhacks" rel="noopener ugc nofollow" target="_blank">这里</a>找到一份不错的清单。</p></div></div>    
</body>
</html>