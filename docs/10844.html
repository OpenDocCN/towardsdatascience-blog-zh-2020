<html>
<head>
<title>TIQ Part 4 — Being Time intelligent in Power BI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TIQ 第四部分——在电力商业智能中保持时间智能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tiq-part-4-being-time-intelligent-in-power-bi-88171980b141?source=collection_archive---------49-----------------------#2020-07-28">https://towardsdatascience.com/tiq-part-4-being-time-intelligent-in-power-bi-88171980b141?source=collection_archive---------49-----------------------#2020-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0db2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在 TIQ 系列的最后一部分，学习什么是时间智能，以及各种 DAX 时间智能函数之间的明显区别</h2></div><p id="bb5f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le"> TIQ 代表时间智商。由于“常规”智能通常被作为智商来衡量，而时间智能是数据建模中最重要的主题之一，我决定开始一个博客系列，将介绍一些基本概念、特定解决方案的利弊和要避免的潜在陷阱，一切都是为了增加你的整体 TIQ，并使你的模型在时间分析方面更加健壮、可伸缩和灵活</em> </strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/162459bbbbeb5866a9f5a81f8de0f2b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*ndqh2zYBqta-SVxDrf8BTw.jpeg"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">乔恩·泰森在 Unsplash 上拍摄的照片</p></figure><p id="55cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">亲爱的读者，我们即将结束这个系列。在详细解释了为什么可以、但不应该使用 Power BI 中的<a class="ae lr" rel="noopener" target="_blank" href="/tiq-part-1-how-to-destroy-your-power-bi-model-with-auto-date-time-8fec32b22aff">自动日期/时间特性之后，接着强调了数据模型中日期维度</a>的<a class="ae lr" rel="noopener" target="_blank" href="/tiq-part-2-your-majesty-date-dimension-b4d54db84be9">重要性，在上一篇文章中，我已经为</a><a class="ae lr" rel="noopener" target="_blank" href="/tiq-part-3-ultimate-guide-to-date-dimension-creation-98b951ffa68c">创建适当的日期维度</a>提供了各种解决方案。</p><p id="78b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，现在是时候总结一些最常用的时间相关计算的例子以及它们之间的一些明显差异了。</p><h2 id="3fe2" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">什么是时间智能？</h2><p id="0a5e" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">用最简单的方式，时间智能表示某种与日期相关的计算。不要把它和“时间”这个词混为一谈，当有人谈论“时间智能”的时候，不要期望把小时/分钟/秒/毫秒看作是最底层的粒度。</p><p id="c434" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更合适的术语应该是“日期智能”，但是由于“时间智能”已经被普遍接受，所以让我们坚持这个命名约定。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/3991fbb19c8bb518413f6b72e581ad46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6x7EIcnfSw4smYmuCZlk7g.jpeg"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">安德里克·朗菲尔德在 Unsplash 上拍摄的照片</p></figure><p id="a0f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">DAX 中所有<a class="ae lr" href="https://docs.microsoft.com/en-us/dax/time-intelligence-functions-dax" rel="noopener ugc nofollow" target="_blank">时间智能函数</a>的主要特征是，无论如何，它们都需要对日期或日期/时间数据类型的列进行操作。<em class="le">这意味着这些函数的输入参数之一需要是日期或日期/时间列</em>。</p><p id="782d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，所有这些都会将您选择的日期转换为一些新的日期(无论是过去还是未来)。</p><p id="ad09" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后但同样重要的是，时间智能函数支持将一天作为最低级别的粒度，这意味着您不能在小时/分钟/秒等计算中使用它们。</p><h2 id="694e" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">正确使用时间智能功能的检查表</h2><ul class=""><li id="dbf6" class="mv mw it kk b kl ml ko mm kr mx kv my kz mz ld na nb nc nd bi translated">正如在本系列的前几篇文章中所强调的，您应该创建一个单独的日期维度，遵循所有必要的规则(连续日期、唯一值、非空值等)。)</li><li id="754e" class="mv mw it kk b kl ne ko nf kr ng kv nh kz ni ld na nb nc nd bi translated">在数据类型为日期或日期/时间的列上创建日期维度和事实表之间的关系，而不是在代理键整数列上创建关系，除非您将日期维度标记为日期表(在这种情况下，在整数代理键上创建关系也是可以的)<em class="le">感谢 Derek van Leeuwen，MSc 发现了之前不精确的解释</em></li><li id="d9a2" class="mv mw it kk b kl ne ko nf kr ng kv nh kz ni ld na nb nc nd bi translated">不要在时间智能函数中使用事实数据表中的日期或日期/时间列(例如，不要使用示例 Contoso 数据库中事实在线销售表中的订单日期列)</li><li id="4aae" class="mv mw it kk b kl ne ko nf kr ng kv nh kz ni ld na nb nc nd bi translated">始终在日期维度中创建全年值。这意味着，即使事实表中的最后一个订单是在 2013 年 9 月，日期维度也应该包括整个 2013 年，最后一个值是 12 月 31 日</li><li id="3e8e" class="mv mw it kk b kl ne ko nf kr ng kv nh kz ni ld na nb nc nd bi translated">如前一章所述，坚持将一天作为最低级别的粒度</li></ul><h2 id="57fb" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">最常见的时间智能功能</h2><p id="9ee1" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">有几十种时间智能功能，但其中一些比另一些使用得更频繁。例如，几乎所有使用数字的 Power BI 报告都需要进行某种比较，以确定趋势。或者，显示累积值也是最重要的业务需求之一。</p><p id="c790" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些功能乍看起来很简单，但同时也相当强大。让我们来看看这个简单的例子，计算所选年份的运行总数。</p><p id="6bb6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 Contoso 数据库中，我创建了一个计算销售额的度量值:</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="1e25" class="ls lt it nk b gy no np l nq nr">Sales Amt = SUM('Online Sales'[SalesAmount])</span></pre><p id="e169" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们创建用于计算运行总数的度量:</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="6873" class="ls lt it nk b gy no np l nq nr">Sales Amt YTD = CALCULATE('Online Sales'[Sales Amt],<br/>DATESYTD(Dates[Date])<br/>)</span></pre><p id="7116" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我将这些度量值拖到报表中并选择 2009 年 1 月到 8 月的月份时，您可以立即注意到月份级别上的数字差异:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ns"><img src="../Images/8df799d6dfa26629d28ae3076483f549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a62kysNVPzsn6tzKmZOBmQ.png"/></div></div></figure><p id="88a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很简单，但让我解释一下在<em class="le">销售金额本年迄今</em>衡量计算的背景下发生了什么，因为这对于理解这里的整个逻辑非常重要。</p><h2 id="5665" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">超越基础</h2><p id="4648" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">回想一下我上面提到的<em class="le">时移概念</em>——这里，我们选择了 2009 年 1 月 1 日到 2009 年 8 月 31 日的日期。YTD 计算发生的情况是，过滤器上下文被更改为包括从 2009 年<strong class="kk iu">1 月 1 日</strong>到所选月份最后一天之间的日期，不管我们选择的是哪个月份！</p><p id="59b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看下面的例子会更清楚，我选择了 2009 年 3 月到 2009 年 8 月的几个月:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ns"><img src="../Images/a93d647cb84f25cabc4a577dc709782a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LhKzzttF4ReQFfY4wMBFXA.png"/></div></div></figure><p id="c168" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仔细看看标有红色的数值。无论我们选择三月来显示我们的数字，<em class="le"> DATESYTD() </em>函数都会重置我们的过滤器，并包含年初的值。我们在表格中看不到它们，但它们包含在三月份的总数中，因为您可以很容易地与第一个截图进行比较。无论我们如何更改切片器中的选择，YTD 的总数保持不变。</p><p id="6634" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最喜欢 DAX 的一点是，你可以用多种不同的方式实现相同的目标。这也代表运行总计计算，因为除了<em class="le"> DATESYTD() </em>，您还可以使用<em class="le"> TOTALYTD() </em>函数。<em class="le"> TOTALQTD() </em>和<em class="le"> TOTALMTD() </em>的工作方式与<em class="le"> </em>相同，但粒度不同(分别为季度和月份)。</p><h2 id="3735" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">细节决定成败…</h2><p id="19a7" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">您还应该注意特定函数之间的细微差别，因为在一种情况下，它们可以给你完全相同的结果，但在其他一些情况下，它们的表现完全不同。</p><p id="6dfa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果您想要执行年度间的比较，您可以同时使用<em class="le">sameperiodlastyre()</em>和<em class="le"> DATEADD() </em>函数，以及以下度量…</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="22e7" class="ls lt it nk b gy no np l nq nr">Sales Amount PY = CALCULATE(SUM('Online Sales'[SalesAmount]),<br/>DATEADD(Dates[Date],-1,YEAR)<br/>)</span><span id="4e43" class="ls lt it nk b gy nt np l nq nr">Sales Amount PY Alt = CALCULATE('Online Sales'[Sales Amt], <br/>SAMEPERIODLASTYEAR(Dates[Date])<br/>)</span></pre><p id="b15e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">…将返回相同的结果:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ns"><img src="../Images/06e6d4bf6948e0da953b97923d288094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thx3rrStVU3s14cYZB7cfA.png"/></div></div></figure><p id="082b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唯一的区别是<em class="le"> DATEADD() </em>为您提供了更大的灵活性，因为您可以根据自己的需要以及日期层次结构的不同级别(季度、月、日)来改变时间间隔，而<em class="le"> SAMEPERIODLASTYEAR() </em>仅绑定到上一年。<em class="le"> PARALLELPERIOD() </em>也非常相似，但仍然有很大的不同，就像我们为日期移动设置静态间隔一样:</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="65fd" class="ls lt it nk b gy no np l nq nr">Sales Amount PP = CALCULATE('Online Sales'[Sales Amt],<br/>PARALLELPERIOD(Dates[Date],-12,MONTH)<br/>)</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ns"><img src="../Images/cdb6972ce617d227c4f0dc7446631798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DbMxtbvmGdMeBkbLCETwNA.png"/></div></div></figure><p id="f297" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，当我们将上次创建的度量值更改为…</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="fd37" class="ls lt it nk b gy no np l nq nr">Sales Amount PP = CALCULATE('Online Sales'[Sales Amt],<br/>PARALLELPERIOD(Dates[Date],-1,YEAR)<br/>)</span></pre><p id="db01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">…您可能认为-1 年相当于-12 个月…</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ns"><img src="../Images/1993956ae2ae627f3d2168d36894b563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hYrN9_IkSejAm1ABuotwVw.png"/></div></div></figure><p id="e2ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，事实并非如此，因为 PARALLELPERIOD 将返回上一年的总销售额(切片器选择已被忽略):</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ns"><img src="../Images/1872c3635cebc66f6b6d50b55d8c4f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*82648FPIR9cU1ZdrqoHADQ.png"/></div></div></figure><p id="b7da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不想说:用<em class="le"> DATEADD() </em>不要用<em class="le"> PARALLELPERIOD() </em>。或者，避免使用<em class="le"> SAMEPERIODLASTYEAR() </em>，而是使用<em class="le"> DATEADD() </em>。所有这些函数在您的计算中都有它们的位置— <strong class="kk iu">这里的关键接管是:当您选择时间智能函数来执行特定的时间计算时要小心！正如你已经看到的，在某些情况下，它们会返回相同的结果，但实际上，它们的行为完全不同。</strong></p><h2 id="3c58" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">结论</h2><p id="1422" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">时间智能是 Power BI(以及一般的商业智能)中最重要的概念之一。因此，正如我大胆尝试的那样，在几篇博文中涵盖所有内容几乎是不可能的。但是，我真心希望现在一些基本的概念和思路更加清晰。</p><p id="6602" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我打赌你的 TIQ(时间智商)比你开始这个有趣的 TIQ 之旅时要高。</p><p id="8a4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读！</p></div></div>    
</body>
</html>