<html>
<head>
<title>Flink Checkpointing and Recovery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flink 检查点和恢复</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/flink-checkpointing-and-recovery-7e59e76c2d45?source=collection_archive---------48-----------------------#2020-06-29">https://towardsdatascience.com/flink-checkpointing-and-recovery-7e59e76c2d45?source=collection_archive---------48-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8669eac86c04bab9090f5b82018baa51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZ0lxkVVmhMZkMbU0vxTnA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/stream_barriers.svg" rel="noopener ugc nofollow" target="_blank">图片来源于 Apache Flink </a></p></figure><div class=""/><div class=""><h2 id="5546" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">如何使用检查点和允许延迟建立容错的流管道</h2></div><p id="aed4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://flink.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Flink </a>是一个流行的实时数据处理框架。由于它以容错方式以极高的吞吐量进行低延迟处理，因此越来越受欢迎。</p><p id="02fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然 Flink 提供了很好的文档，但我花了一些时间来理解各种机制，这些机制共同使 Flink 检查点和恢复工作端到端地进行。在本文中，我将解释创建容错 Flink 作业需要在不同操作员级别执行的关键步骤。Flink 基本运算符是源、进程和接收器。流程操作符可以有多种风格。</p><p id="4e6d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，让我们开始了解您需要做些什么来启用检查点并让所有操作者都知道检查点。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="fc13" class="mb mc jj bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">Flink 环境配置(检查指向)</h2><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">检查点的 Flink 作业配置</p></figure><h2 id="e11a" class="mb mc jj bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">源操作符检查点</h2><p id="e933" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">源操作符是从源中获取数据的操作符。我编写了一个简单的基于 SQL 连续查询的源操作符，并跟踪时间戳，直到数据被查询。该信息将作为 flink 检查点流程的一部分进行存储。flink 在作业操作员级别保存源的状态。<strong class="la jk"><em class="nf">check pointed function</em></strong>接口或者<strong class="la jk"><em class="nf">list check pointed</em></strong>接口应该由源函数实现如下:</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ca62" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据配置，Flink 作业操作员将每 30 秒调用一次<strong class="la jk"><em class="nf">snapshot state</em></strong>方法。方法应该返回要保存在状态后端中的值</p><p id="0be0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="nf"> restoreState </em> </strong>方法在操作员重启时调用，该方法是处理程序方法，用于设置检查点期间最后存储的时间戳(状态)</p><h2 id="e9c7" class="mb mc jj bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">过程功能检查点</h2><p id="0735" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">Flink 支持通过<strong class="la jk"><em class="nf">KeyedProcessFunction</em></strong>保存每个按键的状态。<strong class="la jk"><em class="nf">process window function</em></strong>也可以在事件时间处理的情况下，按键保存窗口的状态</p><p id="6ce4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于<strong class="la jk"><em class="nf">KeyedProcessFunction</em></strong>，<strong class="la jk"> <em class="nf"> ValueState </em> </strong>需要按键存储如下:</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a651" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="nf"> ValueState </em> </strong>只是其中一个例子。还有其他拯救国家的方法。<strong class="la jk"><em class="nf">ProcessWindowFunction</em></strong>自动保存窗口状态，无需设置变量。</p><h2 id="a601" class="mb mc jj bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">接收器函数检查点</h2><p id="8cec" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">接收器函数检查点的工作方式类似于源函数检查点，状态保存在作业操作符级别。我已经为 Postgres DB 实现了 Sink 函数。考虑到性能和效率，可以有多种方法来使宿功能容错和鲁棒。我采用了一种简单的方法，并会在今后加以改进。</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="66ff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过在<strong class="la jk"> <em class="nf"> snapshotState </em> </strong>方法中提交语句，我确保所有未决数据都被刷新并作为检查点触发器的一部分提交。</p><h2 id="18a0" class="mb mc jj bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">准备就绪</h2><p id="2c42" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">最后，您需要运行您的作业，您可以在处理之间尝试取消它，并通过提供如下检查点位置来尝试重新运行它。你需要自己通过最近的关卡，注意<strong class="la jk"> -s </strong>参数。</p><pre class="mu mv mw mx gt ng nh ni nj aw nk bi"><span id="3488" class="mb mc jj nh b gy nl nm l nn no">.\flink.bat run -m localhost:8081 <strong class="nh jk">-s D:\flink-checkpoints\1d96f28886b693452ab1c88ab72a35c8\chk-10</strong> -c &lt;Job class Name&gt; &lt;Path to Jar file&gt;</span></pre><h2 id="62c3" class="mb mc jj bd md me mf dn mg mh mi dp mj lh mk ml mm ll mn mo mp lp mq mr ms mt bi translated">结论</h2><p id="6c0d" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这是检查点和故障恢复的基本方法，可能需要根据每个用例进行更多的改进。请随时向我提供您的反馈。快乐阅读！！</p><p id="d43b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码库的存储库链接:</p><div class="is it gp gr iu np"><a href="https://github.com/swagy-tarun/flink-demos" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd jk gy z fp nu fr fs nv fu fw ji bi translated">斯瓦吉-塔伦/弗林克-德莫斯</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">GitHub 是超过 5000 万开发人员的家园，他们一起工作来托管和审查代码、管理项目和构建…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ja np"/></div></div></a></div></div></div>    
</body>
</html>