<html>
<head>
<title>8 Advanced Python Logging Features that You Shouldn’t Miss</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不应错过的 8 个高级 Python 日志功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/8-advanced-python-logging-features-that-you-shouldnt-miss-a68a5ef1b62d?source=collection_archive---------2-----------------------#2020-07-28">https://towardsdatascience.com/8-advanced-python-logging-features-that-you-shouldnt-miss-a68a5ef1b62d?source=collection_archive---------2-----------------------#2020-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="83f8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在不影响性能的情况下理解你的程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fe8a952b0c9b24526ad24869776ed4cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jk0pHsfq4cnxQJ_S"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@bady" rel="noopener ugc nofollow" target="_blank">巴迪·阿巴斯</a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="25d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">日志是软件开发中非常重要的一个单元。它帮助开发人员更好地理解程序的执行，并对缺陷和意外失败进行推理。日志消息可以存储诸如程序的当前状态或程序运行的位置等信息。如果出现错误，开发人员可以快速找到导致问题的代码行，并采取相应的措施。</p><p id="a083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 提供了一个非常强大和灵活的内置日志模块，具有许多高级特性。在本文中，我想分享 8 个高级特性，它们将有助于我们开发软件。</p><h2 id="129c" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">记录 101</h2><p id="c774" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在查看更多高级功能之前，让我们确保对<code class="fe nc nd ne nf b">logging</code>模块有一个基本的了解。</p><p id="bcff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ng">记录器</em> </strong></p><p id="555e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建来生成日志的实例被称为<strong class="lb iu">记录器</strong>。它是通过<code class="fe nc nd ne nf b">logger = logging.getLogger(__name__)</code>实例化的。最佳实践是使用<code class="fe nc nd ne nf b">__name__</code>作为记录器名称，包括包名和模块名。该名称将出现在日志消息中，这有助于开发人员快速找到生成日志的位置。</p><p id="d267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ng">格式化程序&amp;处理程序</em> </strong></p><p id="e158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个记录器都有许多可以修改的配置。稍后将讨论更高级的配置，但最常见的是<strong class="lb iu">格式化器</strong>和<strong class="lb iu">处理器</strong>。</p><p id="e0bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">格式化程序指定日志消息的结构。每个日志消息都是一个<code class="fe nc nd ne nf b">LogRecord</code>对象，带有<a class="ae ky" href="https://docs.python.org/3/library/logging.html#logrecord-attributes" rel="noopener ugc nofollow" target="_blank">多个属性</a>(模块名是其中之一)。当我们定义一个格式化程序时，我们可以决定日志消息应该如何使用这些属性，并且可能使用定制的属性。默认格式化程序如下所示:</p><pre class="kj kk kl km gt nh nf ni nj aw nk bi"><span id="024f" class="me mf it nf b gy nl nm l nn no">severity:logger name:message<br/># e.g: WARNING:root:Program starts!</span></pre><p id="7f97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具有更多属性的自定义格式化程序如下所示:</p><pre class="kj kk kl km gt nh nf ni nj aw nk bi"><span id="1a83" class="me mf it nf b gy nl nm l nn no">"%(asctime)s - [%(levelname)s] -  %(name)s - (%(filename)s).%(funcName)s(%(lineno)d) - %(message)s"</span><span id="a35e" class="me mf it nf b gy np nm l nn no"># 2020-07-26 23:37:15,374 - [INFO] -  __main__ - (main.py).main(18) - Program starts!</span></pre><p id="39c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理程序指定日志消息的目的地。日志消息可以发送到多个目的地。日志模块实际上提供了相当多的<a class="ae ky" href="https://docs.python.org/3/library/logging.handlers.html#module-logging.handlers" rel="noopener ugc nofollow" target="_blank">标准处理程序</a>。最流行的是将日志发送到文件的 FileHandler 和将日志发送到流的 StreamHandler，例如<code class="fe nc nd ne nf b">sys.stderr</code>或<code class="fe nc nd ne nf b">sys.stdout</code>。记录器实例支持 0 个或多个处理程序。如果没有定义处理程序，那么它会将日志发送到<code class="fe nc nd ne nf b">sys.stderr</code>。如果定义了多个处理程序，则目标取决于日志消息的级别和处理程序的级别。</p><p id="3584" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我有一个带有级别警告的 FileHandler 和一个带有级别信息的 StreamHandler。如果我写了一个错误日志消息，那么该消息将被发送到 <code class="fe nc nd ne nf b"><em class="ng">sys.stdout</em></code> <em class="ng">和日志文件中。</em></p><p id="aee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ng">例如:</em> </strong></p><p id="c38f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们创建了一个<code class="fe nc nd ne nf b">main.py</code>、<code class="fe nc nd ne nf b">package1.py</code>和<code class="fe nc nd ne nf b">app_logger.py</code>。<code class="fe nc nd ne nf b">app_logger.py</code>包含一个函数<code class="fe nc nd ne nf b">get_logger</code>，它返回一个记录器实例。logger 实例带有一个自定义格式化程序和两个处理程序:带有信息级别的 StreamHandler 和带有警告级别的 FileHandler。重要的是将基本级别设置为 INFO 或 DEBUG <strong class="lb iu">(默认日志级别为 WARNING) </strong>，否则低于 WARNING 级别的日志将被过滤掉。<code class="fe nc nd ne nf b">main.py</code>和<code class="fe nc nd ne nf b">package1.py</code>都使用<code class="fe nc nd ne nf b">get_logger</code>来创建它们自己的记录器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/b87bce7dd5b62623159d13ee023e8fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*kxG7CD7XGkCAeq0LktwyeA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图<a class="nr ns ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----a68a5ef1b62d--------------------------------" rel="noopener" target="_blank">高</a></p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本-日志记录. py</p></figure><p id="fb6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">警告日志被发送到控制台输出(sys.stdout)和日志文件，但信息日志仅被发送到控制台输出。如果你能完全理解这个例子中发生了什么以及为什么，那么我们就可以继续开发更高级的特性了。</p><h2 id="3ebe" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">1.使用 LoggerAdapter 创建用户定义的日志记录属性</h2><p id="7420" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">正如我前面提到的，LogRecord 有许多属性，开发人员可以选择最重要的属性，并将它们放入格式化程序中。除此之外，日志模块还提供了向日志记录添加用户定义属性的可能性。</p><p id="345f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是使用<code class="fe nc nd ne nf b">LoggerAdapter</code>。当您创建一个适配器时，您将 logger 实例和您的属性(在字典中)传递给它。这个类提供了与<code class="fe nc nd ne nf b">Logger</code>相同的接口，所以你仍然可以调用像<code class="fe nc nd ne nf b">logger.info</code>这样的方法。</p><p id="e0b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ng">具有固定值的新属性</em> </strong></p><p id="8468" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望在日志消息中有一种固定值属性，比如应用程序名，那么您可以使用默认的<code class="fe nc nd ne nf b">LoggerAdapter</code>类，并在创建日志记录器时获取属性值。不要忘记在格式化程序中添加这个属性，你可以自由选择它的位置。在下面的代码中，我添加了属性<code class="fe nc nd ne nf b">app</code>，这个值是在我创建记录器时定义的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">日志适配器固定值. py</p></figure><p id="4023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ng">带动态值的新属性</em> </strong></p><p id="c9e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在其他情况下，您可能需要动态属性，例如，一种动态 ID。然后你可以扩展基本的<code class="fe nc nd ne nf b">LoggerAdapter</code>并创建你自己的。方法是将额外的属性附加到日志消息的地方。在下面的代码中，我添加了一个动态属性<code class="fe nc nd ne nf b">id</code>，它可以在每个日志消息中有所不同。在这种情况下，您不需要在格式化程序中添加属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">日志适配器动态值. py</p></figure><h2 id="7540" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">2.使用过滤器创建用户定义的日志记录属性</h2><p id="7fb1" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">添加动态用户定义属性的另一种方法是使用自定义过滤器。过滤器提供了额外的逻辑来确定输出哪些日志消息。这是在检查基本日志级别之后，但在将日志消息传递给处理程序之前的一个步骤。除了确定日志消息是否应该向前移动，我们还可以在方法<code class="fe nc nd ne nf b">filter()</code>中插入新的属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/aa4c4a759a4eeb8c6095446306d82d1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AtLrZeLSggfKpikG.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图来自<a class="ae ky" href="https://docs.python.org/3/howto/logging.html#logging-basic-tutorial" rel="noopener ugc nofollow" target="_blank"> Python 官方文档</a></p></figure><p id="bf99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们在<code class="fe nc nd ne nf b">filter()</code>中添加了一个新的属性<code class="fe nc nd ne nf b">color</code>，它的值是根据日志消息的级别名确定的。在这种情况下，属性名应该再次添加到格式化程序中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">日志过滤器动态属性. py</p></figure><h2 id="c492" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">3.带有日志模块的多线程</h2><p id="ebe2" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">日志模块实际上是以线程安全的方式实现的，所以我们不需要额外的努力。下面的代码显示 MainThread 和 WorkThread 共享同一个 logger 实例，没有竞争条件问题。格式化程序还有一个内置属性<code class="fe nc nd ne nf b">threadName</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">记录多线程. py</p></figure><p id="e6ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在幕后，日志模块几乎在任何地方都使用<code class="fe nc nd ne nf b">threading.RLock()</code>。<code class="fe nc nd ne nf b">RLock</code>与<code class="fe nc nd ne nf b">Lock</code>的区别在于:</p><ol class=""><li id="9546" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated"><code class="fe nc nd ne nf b">Lock</code>只能获得一次，发布后才能获得。另一方面，<code class="fe nc nd ne nf b">RLock</code>可以在释放前多次获取，但应该释放相同的次数。</li><li id="02a3" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe nc nd ne nf b">Lock</code>可以被任何线程释放，但是<code class="fe nc nd ne nf b">RLock</code>只能被获取它的同一个线程释放。</li></ol><p id="db43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何从类<code class="fe nc nd ne nf b">Handler</code>扩展的处理程序都有一个方法<code class="fe nc nd ne nf b">handle()</code>来发出记录。这是<code class="fe nc nd ne nf b">Handler.handle()</code>的一个代码块。如您所见，处理程序将在发出记录之前和之后获取和释放锁。<code class="fe nc nd ne nf b">emit()</code>方法可以在不同的处理程序中不同地实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">handle.py</p></figure><h2 id="5431" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">4.带有日志模块的多处理—队列处理器</h2><p id="06e2" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">尽管日志模块是线程安全的，但它不是进程安全的。如果您希望多个进程写入同一个日志文件，那么您必须手动处理对您的文件的访问。根据<a class="ae ky" href="https://docs.python.org/3/howto/logging-cookbook.html#logging-to-a-single-file-from-multiple-processes" rel="noopener ugc nofollow" target="_blank">测井指南</a>，有几个选项。</p><p id="173a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ng"> QueueHandler +【消费者】流程</em> </strong></p><p id="f6ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种选择是使用<code class="fe nc nd ne nf b">QueueHandler</code>。这个想法是创建一个<code class="fe nc nd ne nf b">multiprocessing.Queue</code>实例，并在多个进程之间共享它。在下面的示例中，我们有两个“生产者”进程将日志发送到队列，还有一个“消费者”进程从队列中读取日志并将它们写入日志文件。</p><p id="5f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">队列中的日志可能有不同的级别，因此在<code class="fe nc nd ne nf b">log_processor</code>中，我们使用<code class="fe nc nd ne nf b">logger.log(record.levelno, record.msg)</code>而不是<code class="fe nc nd ne nf b">logger.info()</code>或<code class="fe nc nd ne nf b">logger.warning()</code>。最后，我们发出信号让<code class="fe nc nd ne nf b">log_processor</code>停下来。在多个进程或<a class="ae ky" rel="noopener" target="_blank" href="/dive-into-queue-module-in-python-its-more-than-fifo-ce86c40944ef">线程之间共享一个队列实例并不是什么新鲜事</a>，但是日志模块可以帮助我们处理这种情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">日志队列处理程序. py</p></figure><p id="ff63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">T27】queue handler+queue listenerT29】</strong></p><p id="ee2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nc nd ne nf b">logging.handlers</code>模块中，有一个特殊的类叫做<code class="fe nc nd ne nf b"><a class="ae ky" href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.QueueListener" rel="noopener ugc nofollow" target="_blank">QueueListener</a></code>。该类创建一个侦听器实例，该实例具有一个日志消息队列和一个处理日志记录的处理程序列表。<code class="fe nc nd ne nf b">QueueListener</code>可以用更少的代码替换我们在前一个例子中创建的<code class="fe nc nd ne nf b">listener</code>流程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">日志队列 listener.py</p></figure><p id="e7f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ng"> SocketHandler </em> </strong></p><p id="a639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Cookbook 提供的另一个解决方案是<a class="ae ky" href="https://docs.python.org/3/howto/logging-cookbook.html#network-logging" rel="noopener ugc nofollow" target="_blank">将来自多个进程的日志发送到一个</a>T4，并有一个单独的进程实现一个套接字服务器，该服务器读取日志并发送到目的地。该文档有一个相当详细的实现。</p><p id="2d7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些解决方案基本上都遵循相同的原则:将日志从不同的进程发送到一个集中的位置，要么是队列，要么是远程服务器。另一端的接收器负责将日志记录写入目的地。</p><h2 id="02a8" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">5.默认情况下不发出任何库日志— NullHandler</h2><p id="03fe" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">到目前为止，我们已经提到了许多由日志模块实现的处理程序。另一个有用的内置处理程序是<code class="fe nc nd ne nf b"><a class="ae ky" href="https://docs.python.org/3/howto/logging.html#configuring-logging-for-a-library" rel="noopener ugc nofollow" target="_blank">NullHandler</a></code>。NullHandler 的实现基本上什么都没有。然而，它帮助开发人员区分库日志和应用程序日志。</p><p id="91cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<code class="fe nc nd ne nf b">NullHandler</code>的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">nullhandler.py</p></figure><p id="b70a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ng">为什么我们需要区分库日志和应用日志？</em> </strong></p><p id="4cd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据测井模块的<a class="ae ky" href="https://wiki.python.org/moin/LoggingPackage" rel="noopener ugc nofollow" target="_blank">作者 Vinay Sajip:</a></p><blockquote class="ok ol om"><p id="c0d6" class="kz la ng lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated">默认情况下，使用<code class="fe nc nd ne nf b">logging</code>的第三方库不应该输出日志输出，因为使用它的应用程序的开发人员/用户可能不希望这样。</p></blockquote><p id="757d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最佳实践是默认情况下不发出库日志，让库的用户决定他们是否希望在应用程序中接收和处理日志。</p><p id="fe45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个库开发者，我们只需要在<code class="fe nc nd ne nf b">__init__.py</code>里面一行代码就可以添加<code class="fe nc nd ne nf b">NullHandler</code>。在子包和子模块中，记录器照常保存。当我们通过<code class="fe nc nd ne nf b">pip install</code>在我们的应用程序中安装这个包时，默认情况下我们不会看到库中的日志。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">记录 nullhandler example.py</p></figure><p id="b79b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使这些日志可见的方法是向应用程序中的库记录器添加处理程序。</p><pre class="kj kk kl km gt nh nf ni nj aw nk bi"><span id="7081" class="me mf it nf b gy nl nm l nn no"># your application <br/>logging.getLogger("package").addHandler(logging.StreamHandler())</span></pre><p id="5147" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果库不使用<code class="fe nc nd ne nf b">NullHandler</code>，但是你想禁用库日志，那么你可以设置<code class="fe nc nd ne nf b">logging.getLogger("package").propagate = False</code>。如果<a class="ae ky" href="https://docs.python.org/3/library/logging.html#logging.Logger.propagate" rel="noopener ugc nofollow" target="_blank"> propagate </a>设置为 False，那么日志将不会传递给处理程序。</p><h2 id="6d31" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">6.旋转日志文件—旋转文件处理程序，timedrotating 文件处理程序</h2><p id="26e0" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated"><code class="fe nc nd ne nf b">RotatingFileHandler</code>支持日志文件轮换，这使得处理程序能够根据日志文件的最大大小来轮换日志文件。这里需要定义 2 个参数:<strong class="lb iu"> maxBytes </strong>和<strong class="lb iu"> backupCount </strong>。<strong class="lb iu"> maxBytes </strong>告诉处理程序何时旋转日志。<strong class="lb iu"> backupCount </strong>是日志文件的数量，每个扩展日志文件都有一个后缀“. 1”，文件名末尾有“. 2”。如果当前日志消息将使日志文件超过最大大小，那么处理程序将关闭当前文件并打开下一个文件。</p><p id="442c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常类似于<a class="ae ky" href="https://docs.python.org/3/howto/logging-cookbook.html#using-file-rotation" rel="noopener ugc nofollow" target="_blank">食谱</a>的例子。您应该得到 6 个日志文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">日志文件 rotation.py</p></figure><p id="c4e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个文件循环处理程序是<code class="fe nc nd ne nf b">TimeRotatingFileHandler</code>，它允许开发人员基于运行时间创建循环日志。时间条件包括:秒、分、小时、日、w0-w6(0 =星期一)和午夜(午夜翻转)。</p><p id="5b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以下示例中，我们每秒轮换 5 个备份文件的日志文件。每个备份文件都有一个时间戳作为后缀。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间文件 rotation.py</p></figure><h2 id="3930" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">7.记录期间的异常</h2><p id="81e4" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在许多情况下，我们在处理异常时使用<code class="fe nc nd ne nf b">logger.error()</code>或<code class="fe nc nd ne nf b">logger.exception()</code>。但是如果记录器本身引发了一个异常，程序会发生什么呢？嗯，看情况。</p><p id="e2ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记录器错误在处理程序调用<code class="fe nc nd ne nf b">emit()</code>时被处理，这意味着任何与格式化或写入相关的异常都被处理程序捕获，而不是被引发。更具体地说，<code class="fe nc nd ne nf b">handleError()</code>方法将把引用通告打印给<code class="fe nc nd ne nf b">stderr</code>，程序将继续。如果你有一个从<code class="fe nc nd ne nf b">Handler</code>类扩展的自定义处理程序，你可以实现你自己的<code class="fe nc nd ne nf b">handleError()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，第二条日志消息的参数太多。所以在控制台输出中，我们收到了 trackback，程序仍然可以继续。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5ec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果异常发生在<code class="fe nc nd ne nf b">emit()</code>之外，那么可能会引发异常，程序将会停止。例如，在下面的代码中，我们在<code class="fe nc nd ne nf b">logger.info()</code>中添加了一个额外的属性<code class="fe nc nd ne nf b">id</code>，而没有在 LoggerAdapter 中处理它。此错误未得到处理，导致程序停止。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">日志记录异常引发. py</p></figure><h2 id="11a6" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">8.3 种不同的方法来配置您的记录器</h2><p id="2e4d" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我想分享的最后一点是关于配置你的日志。有 3 种方法可以配置记录器。</p><p id="4362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ng">使用代码</em> </strong></p><p id="0767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最直接的选择是使用代码来配置您的日志记录器，就像我们在本文中看到的所有例子一样。但是这种方法的缺点是任何修改都需要改变源代码。</p><p id="4c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ng">使用</em> </strong> <code class="fe nc nd ne nf b"><strong class="lb iu"><em class="ng">dictConfig</em></strong></code></p><p id="5577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种选择是在字典中编写配置，并使用<code class="fe nc nd ne nf b">logging.config.dictConfig</code>来读取它。您还可以将字典保存到 JSON 文件中，并从那里读取。优点是它可以作为外部配置加载，但由于其结构，它可能容易出错。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">日志配置 json.py</p></figure><p id="4f9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ng">使用</em> </strong> <code class="fe nc nd ne nf b"><strong class="lb iu"><em class="ng">fileConfig</em></strong></code></p><p id="317c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，第三个选项是使用<code class="fe nc nd ne nf b">logging.config.fileConfig</code>。配置被写入一个单独的<code class="fe nc nd ne nf b">.ini</code>文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">日志配置文件. py</p></figure><p id="b344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以通过配置服务器在运行时更新配置。食谱展示了一个客户端和服务器端的例子。通过套接字连接更新配置，在客户端，我们使用<code class="fe nc nd ne nf b">c = logging.config.listen(PORT) c.start()</code>接收最新的配置。</p><p id="12eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这些日志提示和技巧可以帮助您在不影响性能的情况下，围绕您的应用程序建立一个良好的日志框架。如果你有什么要分享的，请在下面留下你的评论！</p><h2 id="5ad7" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">参考:</h2><div class="oq or gp gr os ot"><a href="https://docs.python.org/3/howto/logging-cookbook.html#" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">日志记录指南- Python 3.8.5 文档</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">这个页面包含了许多与日志记录相关的方法，这些方法在过去很有用。多次呼叫…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="oq or gp gr os ot"><a href="https://docs.python.org/3/library/logging.html" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">日志记录-Python-Python 3 . 8 . 5 文档的日志记录工具</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">源代码:Lib/logging/__init__。py 这个模块定义了实现灵活事件记录的函数和类…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="oq or gp gr os ot"><a href="https://docs.python-guide.org/writing/logging/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">日志 Python 的搭便车指南</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">自版本 2.3 以来，该模块一直是 Python 标准库的一部分。它在 PEP 282 中有简洁的描述。的…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">docs.python-guide.org</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div></div></div>    
</body>
</html>