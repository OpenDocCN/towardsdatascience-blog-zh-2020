<html>
<head>
<title>Time Based Cross Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于时间的交叉验证</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-based-cross-validation-d259b13d42b8?source=collection_archive---------3-----------------------#2020-01-20">https://towardsdatascience.com/time-based-cross-validation-d259b13d42b8?source=collection_archive---------3-----------------------#2020-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/638b0d80ff00ad6c457032f9fa6ad6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*23WsqANJv5IS4ar-LGU2sw.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">柯蒂斯·麦克牛顿在<a class="ae jd" href="https://unsplash.com/s/photos/time-based-validation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="33bf" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated"><strong class="ak">当我们的数据不是时间序列，但仍然有一个非常重要的时间维度时，会发生什么？这是一个用于基于时间的交叉验证的</strong> Python解决方案，具有所有必需的输入和一个匹配scikit-learn方法的输出。</h2></div><p id="6fbf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">训练和评估机器学习模型通常需要一个训练集和一个测试集。在大多数情况下，训练和测试拆分是随机进行的，取20%的数据作为测试数据，模型看不到，其余的用于训练。</p><p id="a361" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在处理与时间相关且动态变化的环境时，环境的特征会随着时间的推移而变化，因此最好使用基于时间的分割来提供统计上稳健的模型评估，并最好地模拟真实场景。为此，我们应该使用基于时间的交叉验证，这是一种来自时间序列领域的方法，它形成了一种“滑动窗口”训练方法。</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/54d794ff5ff2272a2e6d2aa839bb32d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*AXRu72CV1hdjLfODFGbMWQ.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">基于时间的交叉验证方法</p></figure><p id="130a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种方法在时间序列领域是众所周知的，其中我们有一个信号，它是在连续的等间隔时间点上获得的序列。</p><p id="4b41" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，当我们的数据不是时间序列，但仍然有一个非常重要的时间维度时，会发生什么呢？</p><h1 id="ec7c" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated"><strong class="ak">需要基于时间的交叉验证的问题示例</strong></h1><p id="60d5" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">我们想预测订单的交货时间。每条记录都是一个订单，由一组特征来表示，以创建数据表。我们知道<strong class="kx jh">每个订单发生的时间</strong>，并且<strong class="kx jh">几个</strong>订单可以在同一天下达。关于这个问题的详细解释可以在我之前的<a class="ae jd" rel="noopener" target="_blank" href="/delivery-date-estimation-5aff1a0ff8dc">博客</a>中找到。在这种情况下，我们的目的是根据上个月的订单训练一个新模型，然后应用它来预测下周订单的交货时间。<br/>为了最好地模拟真实世界，我们应该使用一个月的数据来训练我们的模型，然后用下一周的新数据来测试它们。为了创建稳健和通用的模型，我们应该使用几个时间分割点，并应用基于时间的交叉验证。我们的最终测试结果将是所有测试窗口的加权平均值。</p><p id="b30b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mt">我们需要注意3个重要方面:</em></p><p id="de68" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1.<strong class="kx jh">基于时间的训练\测试分割</strong> -在每次分割中，测试指标必须高于之前。</p><p id="eeec" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.我们希望选择我们的<strong class="kx jh">训练\测试集大小</strong>，以便模拟真实世界的场景，在这些场景中，我们将在一段时间内训练一个模型，然后在接下来的时间内应用它。例如，根据上个月的数据训练模型，并应用它来预测未来一周的数据。</p><p id="414a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.<strong class="kx jh">枣事</strong>。就我们的意图而言，每个集合中记录的数量并不重要。重要的是以天为单位的窗口大小。我们希望分割数据，以便每个窗口都包含X天的数据。</p><h1 id="a725" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">其他部分解决方案</h1><p id="e5d9" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">Scikit-learn有<a class="ae jd" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.TimeSeriesSplit.html" rel="noopener ugc nofollow" target="_blank">时间序列分割</a>方法，但是它有几个缺点。假设我们的数据是按时间排序的，这种方法以一种“滑动窗口”的方式将它分成训练集\测试集，但是它不允许我们选择集的大小，我们只能选择我们想要多少个分裂。Scikit-learn TimeSeriesSplit还假设每个日期有一个观察值，因此没有解决上面的2和3。</p><p id="7f48" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一个解决方案是Germayne建议的，并在他的博客<a class="ae jd" href="https://medium.com/eatpredlove/time-series-cross-validation-a-walk-forward-approach-in-python-8534dd1db51a" rel="noopener">中提出。他很好地解释了整个方法以及与Scikit-learn方法的区别。这个解决方案的输入之一是训练集大小(称为初始)和测试集大小(称为范围)，但是它创建包含固定数量的<strong class="kx jh">记录</strong>的集。出于我们的目的，我们应该创建包含固定天数<strong class="kx jh">的集合</strong>。这个解决方案没有解决第3点。</a></p><h1 id="ba47" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">建议的解决方案</h1><p id="db42" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">因此，我为基于时间的训练和测试分割编写了自己的解决方案，它不仅允许我们选择相关的集合大小，还解决了根据天数(而不是根据记录)考虑窗口大小的重要方面。</p><p id="6656" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mt">返回的CV splits像任何其他scikit-learn交叉验证器一样工作，并且可以与它们的任何方法一起使用。</em></p><p id="6bbb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，您的数据框必须有一列包含每条记录的日期，因为此解决方案利用了数据的日期。</p><h2 id="feac" class="mu lx jg bd ly mv mw dn mc mx my dp mg le mz na mi li nb nc mk lm nd ne mm nf bi translated">参数:</h2><ul class=""><li id="8acc" class="ng nh jg kx b ky mo lb mp le ni li nj lm nk lq nl nm nn no bi translated">train_period: int，default=30 <br/>包含在每个训练集中的时间单位数。</li><li id="265b" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">test_period: int，default=7 <br/>每个测试集中包含的时间单位数。</li><li id="3d25" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">freq: string，default='days' <br/>输入参数的频率。可能的值有:天、月、年、周、小时、分钟、秒。</li></ul><h2 id="e978" class="mu lx jg bd ly mv mw dn mc mx my dp mg le mz na mi li nb nc mk lm nd ne mm nf bi translated">方法:</h2><p id="185e" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated"><strong class="kx jh">get _ n _ splits</strong>(self)<br/>返回交叉验证器中的拆分迭代次数</p><p id="0d8f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> split </strong> (self，data，validation_split_date=None，date_column='record_date '，gap=0) <br/>返回类似于sklearn交叉验证器的元组列表(train_index，test_index)。</p><ul class=""><li id="ed7f" class="ng nh jg kx b ky kz lb lc le nu li nv lm nw lq nl nm nn no bi translated">数据:pandas DataFrame <br/>您的数据包含一个指示记录日期的列</li><li id="27ab" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">validation _ split _ date:datetime . date<br/>执行拆分的第一个日期。这是第一个测试集开始的日期。</li><li id="c3ae" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">date_column:字符串<br/>每条记录的日期</li><li id="faa2" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">gap: int <br/>如果测试集没有紧跟在训练集之后，则训练集和测试集之间有*gap*天的间隔</li></ul><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="0ca0" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">示例-如何使用</h1><figure class="ls lt lu lv gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="4e92" class="lw lx jg bd ly lz ma mb mc md me mf mg km mh kn mi kp mj kq mk ks ml kt mm mn bi translated">关闭</h1><p id="39c0" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">建议的解决方案对我过去遇到的各种问题非常有效。请让我知道它是如何为你工作的，如果你认为可以做更多的调整来改进这个类。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="034d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">特别感谢Noga Gershon与我分享了她应对相关挑战的经验。<br/>感谢Noga和Idan Richman-Goshen提供的出色的技术反馈以及对本文的校对和评论。</p></div></div>    
</body>
</html>