<html>
<head>
<title>A Complete Pandas Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完整的熊猫指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-complete-pandas-guide-2dc53c77a002?source=collection_archive---------12-----------------------#2020-04-09">https://towardsdatascience.com/a-complete-pandas-guide-2dc53c77a002?source=collection_archive---------12-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0060" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建强大的数据分析流程</h2></div><p id="a5d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据科学项目中最耗时的部分是数据清理和准备。Pandas 是一个非常强大和通用的 Python 数据分析库，可以加速项目的预处理步骤。在这篇文章中，我将通过许多例子来介绍 Pandas 的许多功能，这些例子可以帮助您构建一个健壮而高效的数据分析过程。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi le"><img src="../Images/fff169d501924f466ae4a81a63daa24f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*0YmNoT8x6-Z-BG7gV1FVmg.jpeg"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">在<a class="ae lq" href="https://unsplash.com/s/photos/complete-guide?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae lq" href="https://unsplash.com/@threeedil?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> threeedil </a>拍摄的照片</p></figure><p id="a235" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些主题按如下顺序排列:</p><ol class=""><li id="9173" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld lw lx ly lz bi translated"><strong class="kk iu">输入数据</strong></li><li id="b03b" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld lw lx ly lz bi translated"><strong class="kk iu">数据概述</strong></li><li id="0cee" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld lw lx ly lz bi translated"><strong class="kk iu">处理缺失值</strong></li><li id="6507" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld lw lx ly lz bi translated"><strong class="kk iu">组合数据帧</strong></li><li id="0df9" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld lw lx ly lz bi translated"><strong class="kk iu">选择数据帧上的数据</strong></li><li id="9e1e" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld lw lx ly lz bi translated"><strong class="kk iu">重塑数据帧</strong></li><li id="7bbf" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld lw lx ly lz bi translated"><strong class="kk iu">其他熊猫功能</strong></li></ol><blockquote class="mf mg mh"><p id="25a3" class="ki kj mi kk b kl km ju kn ko kp jx kq mj ks kt ku mk kw kx ky ml la lb lc ld im bi translated">Pandas 的基本数据结构是<strong class="kk iu"> DataFrame </strong>，它以表格的形式表示数据，带有标记的行和列。</p></blockquote><p id="45e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一如既往，我们从进口熊猫开始。</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="a22b" class="mr ms it mn b gy mt mu l mv mw">import numpy as np<br/>import pandas as pd</span></pre><h1 id="dfa1" class="mx ms it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated"><strong class="ak"> 1。输入数据</strong></h1><p id="c3df" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated"><strong class="kk iu">从文件中读取</strong></p><p id="94db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在大多数情况下，我们从文件中读取数据并转换成数据帧。Pandas 提供了从许多不同的文件类型中读取数据的功能。最常用的是<strong class="kk iu"> read_csv </strong>。其他类型也有，比如 read_excel，read_json，read_html 等等。让我们来看一个使用<strong class="kk iu"> read_csv </strong>的例子:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="315b" class="mr ms it mn b gy mt mu l mv mw">df = pd.read_csv("Churn_Modelling.csv")<br/>df.head()</span></pre><p id="a81d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要指定文件的位置。在文件位于同一个工作目录或文件夹中时，你可以只写文件名。df.head()显示前 5 行。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/b310679955bef426102626e65a5665e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Harq9dBAxtiF0rjd7E68Iw.png"/></div></div></figure><p id="28d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们只需要数据帧的一部分，而不想读取全部，我们可以用<strong class="kk iu"> usecols </strong>参数指定列:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="18b4" class="mr ms it mn b gy mt mu l mv mw">cols = ['CustomerId','CreditScore','NumOfProducts']<br/>df = pd.read_csv("Churn_Modelling.csv", usecols=cols)<br/>df.head()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/791e04b09c902a71a52cf83484975e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*PqYBZWOqP5AWUBsuTBD_KQ.png"/></div></figure><p id="fc32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以使用<strong class="kk iu"> nrows </strong>参数选择要读取多少行。这在处理非常大的文件时非常有用:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="98b0" class="mr ms it mn b gy mt mu l mv mw">df.shape<br/>(10000, 3)</span><span id="215e" class="mr ms it mn b gy nz mu l mv mw">df = pd.read_csv("Churn_Modelling.csv", usecols=cols, nrows=500)<br/>df.shape<br/>(500, 3)</span></pre><p id="cf17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原始数据帧有 10000 行，通过将 nrows 设置为 500，我们只读取前 500 行。</p><p id="6b5f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae lq" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html" rel="noopener ugc nofollow" target="_blank"> read_csv </a>函数还有许多其他参数，这使它变得强大而方便。</p><p id="5011" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">创建数据帧</strong></p><p id="023f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在现实生活中，我们通常从文件中读取数据，而不是创建数据帧。Pandas 提供了<a class="ae lq" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html" rel="noopener ugc nofollow" target="_blank">函数</a>来通过从各种文件类型中读取数据来创建数据帧。在这篇文章中，我将使用字典来创建一个示例数据帧。</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="c751" class="mr ms it mn b gy mt mu l mv mw">df = pd.DataFrame({'a':np.random.rand(10),<br/>                 'b':np.random.randint(10, size=10),<br/>                 'c':[True,True,True,False,False,np.nan,np.nan,<br/>                      False,True,True],<br/>                 'b':['London','Paris','New York','Istanbul',<br/>                      'Liverpool','Berlin',np.nan,'Madrid',<br/>                      'Rome',np.nan],<br/>                 'd':[3,4,5,1,5,2,2,np.nan,np.nan,0],<br/>                 'e':[1,4,5,3,3,3,3,8,8,4]})<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a528ce5d5bb3dbe5ea3902df5e57c371.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*ddotCsWWSHgmTFdNHF1ZHQ.png"/></div></figure></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="56b4" class="mx ms it bd my mz oi nb nc nd oj nf ng jz ok ka ni kc ol kd nk kf om kg nm nn bi translated"><strong class="ak"> 2。数据概述</strong></h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi on"><img src="../Images/ebe11b58dc5a71a330cf200961d1886c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3e0uy8kc_cDxU0CEZhGBA.jpeg"/></div></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">照片由<a class="ae lq" href="https://unsplash.com/@markuswinkler?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·温克勒</a>在<a class="ae lq" href="https://unsplash.com/s/photos/complete-guide?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1b7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Pandas <strong class="kk iu"> describe </strong>函数为数值(int 或 float)列提供汇总统计。它计算值的数量，并显示平均值、标准差、最小值和最大值以及 25%、50%和 75%的分位数。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a528ce5d5bb3dbe5ea3902df5e57c371.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*ddotCsWWSHgmTFdNHF1ZHQ.png"/></div></figure><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="1bcb" class="mr ms it mn b gy mt mu l mv mw">df.describe()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/b0d3bc8a9bb64372813698f5550bdcbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*s5HPXLlLrvdICiL8JHDzzw.png"/></div></figure><p id="d2c5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然所有的列都有相同的行数，但是 d 列的计数不同，因为 describe 函数不计算 NaN(缺失)值。</p><p id="4d4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> value_counts() </strong>以出现次数显示列中的值:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="cb26" class="mr ms it mn b gy mt mu l mv mw">df.c.value_counts()<br/>True     5<br/>False    3<br/>Name: c, dtype: int64</span></pre><p id="50d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">value_counts()不计算 NaN(缺失)值。</p><p id="b43d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还应该检查数据类型，并在我们的分析中考虑它们。有些功能只能在某些数据类型上执行。我们可以使用<strong class="kk iu"> dtypes </strong>轻松检查数据类型:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="5c40" class="mr ms it mn b gy mt mu l mv mw">df.dtypes<br/>a    float64<br/>b     object<br/>c     object<br/>d    float64<br/>e      int64<br/>dtype: object</span></pre><p id="d990" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“d”和“e”列都有整数，但“d”列的数据类型是 float。原因是列 d 中的 NaN 值。NaN 值被认为是浮点型的，因此该列中的整数值被向上转换为浮点数据类型。</p><p id="7c63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Pandas 1.0.1 允许使用 NaN 作为整数数据类型。我们只需要显式地将 dtype 表示为<strong class="kk iu"> pd。Int64Dtype(): </strong></p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="08f7" class="mr ms it mn b gy mt mu l mv mw">pd.Series([1, 2, 3, np.nan], dtype=pd.Int64Dtype())<br/>0      1<br/>1      2<br/>2      3<br/>3    NaN<br/>dtype: Int64</span></pre><p id="e397" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果 pd。不使用 Int64Dtype()，整数值被强制转换为浮点数:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="a982" class="mr ms it mn b gy mt mu l mv mw">pd.Series([1, 2, 3, np.nan])<br/>0    1.0<br/>1    2.0<br/>2    3.0<br/>3    NaN<br/>dtype: float64</span></pre></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="aeb5" class="mx ms it bd my mz oi nb nc nd oj nf ng jz ok ka ni kc ol kd nk kf om kg nm nn bi translated"><strong class="ak"> 3。处理缺失值</strong></h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi op"><img src="../Images/de9cb7fb2db560a887b47836373e77be.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*0q_ZNlNbEEGsCd3CDXmQ4A.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">照片由<a class="ae lq" href="https://unsplash.com/@fahrulazmi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">法鲁尔·阿兹米</a>在<a class="ae lq" href="https://unsplash.com/s/photos/select?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="239b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">处理缺失值是数据清理和准备过程中必不可少的一部分，因为现实生活中几乎所有的数据都带有一些缺失值。</p><p id="8c64" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们先创建一个缺少值的数据帧。</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="dbfb" class="mr ms it mn b gy mt mu l mv mw">df = pd.DataFrame({<br/>'column_a':[1, 2, 4, 4, np.nan, np.nan, 6],     <br/>'column_b':[1.2, 1.4, np.nan, 6.2 ,None, 1.1, 4.3],<br/>'column_c':['a', '?', 'c', 'd', '--', np.nan, 'd'],<br/>'column_d':[True, True, np.nan, None, False, True, False]<br/>})</span><span id="c458" class="mr ms it mn b gy nz mu l mv mw">df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/3443d427ba9c0041c178e97560a28c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*zR7YylXP09X8vgDy_yMOww.png"/></div></figure><p id="c1b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">np.nan、None 和 NaT(对于 datetime64[ns]类型)是熊猫的标准缺失值。</p><blockquote class="mf mg mh"><p id="a6b9" class="ki kj mi kk b kl km ju kn ko kp jx kq mj ks kt ku mk kw kx ky ml la lb lc ld im bi translated"><strong class="kk iu">注意:</strong>Pandas 1.0 中引入的一种新的缺失数据类型(&lt; NA &gt;)，它是一种整数类型的缺失值表示。</p></blockquote><p id="7aa3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">np.nan 是一个浮点数，所以如果你在一列整数中使用它们，它们将被转换成浮点数据类型，正如你在我们创建的数据帧的“column_a”中看到的。但是，<na>可以和整数一起使用，不会导致向上转换。让我们使用<na>向 dataframe 再添加一列，可以通过显式请求 dtype Int64Dtype()来使用它。</na></na></p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="b121" class="mr ms it mn b gy mt mu l mv mw">new_column = pd.Series([1, 2, np.nan, 4, np.nan, 5], dtype=pd.Int64Dtype())</span><span id="3b43" class="mr ms it mn b gy nz mu l mv mw">df['column_e'] = new_column<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi or"><img src="../Images/b42658c384b0e4bb021de2658c0fe7a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*7VasCPojjoHjYMqa_BbsSw.png"/></div></figure><p id="c623" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">熊猫提供了<strong class="kk iu"> isnull() </strong>、<strong class="kk iu"> isna() </strong>函数来检测缺失值。他们俩做着同样的事情。</p><p id="ccec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> df.isna() </strong>返回带有布尔值的 dataframe，该值表示缺少的值。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi os"><img src="../Images/9df28e77403e02dd8b5f0ce1a12f8b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*2PMQ4QqdqAQldfl7xsYAyw.png"/></div></figure><p id="7730" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也可以选择使用与 isna()正好相反的<strong class="kk iu"> notna() </strong>。</p><p id="c0d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> df.isna()。any() </strong>为每一列返回一个布尔值。如果该列中至少有一个值缺失，则结果为真。</p><p id="f416" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> df.isna()。sum() </strong>返回每列中缺失值的数量。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ot"><img src="../Images/589473285970259ec2dd5e9adb7f8b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/format:webp/1*pXaz3Ups_ez3Qr9aM3jbKA.png"/></div></div></figure><p id="a875" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并非所有缺失的值都是简洁明了的 np.nan 或 None 格式。比如，“？”数据帧 c 列中的“---”字符没有给我们任何有价值的信息或见解，因此本质上它们是缺失值。但是，这些字符无法被熊猫检测为缺失值。</p><p id="0f5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们知道哪种字符用作数据集中的缺失值，我们可以在使用<strong class="kk iu"> na_values </strong>参数创建数据帧时处理它们:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="8a5e" class="mr ms it mn b gy mt mu l mv mw">missing_values = ['?', '--']<br/>df_test = pd.read_csv('filepath.csv', na_values = missing_values)</span></pre><p id="c091" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种选择是在创建数据帧后使用 pandas <strong class="kk iu"> replace() </strong>函数来处理这些值:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="fe17" class="mr ms it mn b gy mt mu l mv mw">df.replace(['?','--'],np.nan, inplace=True)<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/c9bf7c056672bc924ef4b03533d79c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*UZNFNNp37dn2GnHFYkc8eA.png"/></div></figure><p id="35e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经用 NaN 值替换了非信息单元格。<strong class="kk iu">就地</strong>参数保存数据帧中的变化。inplace 的默认值为 False，因此如果将其设置为 True，将不会保存更改。</p><p id="6f99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有处理缺失值的最佳方法。根据数据集和任务的特征，我们可以选择:</p><ul class=""><li id="8217" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld ov lx ly lz bi translated">删除缺少的值</li><li id="2067" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld ov lx ly lz bi translated">替换丢失的值</li></ul><p id="695c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">丢弃缺失值</strong></p><p id="dbc5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<strong class="kk iu"> dropna() </strong>函数删除缺少值的行或列。<strong class="kk iu">如何使用</strong>参数将条件设置为下降。</p><ul class=""><li id="3a02" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld ov lx ly lz bi translated">how='any ':如果有任何缺少的值，则删除</li><li id="1b2a" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld ov lx ly lz bi translated">how='all ':如果所有值都丢失，则删除</li></ul><p id="727b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，使用<strong class="kk iu"> thresh </strong>参数，我们可以为丢失的值设置一个阈值，以便删除一行/一列。</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="8751" class="mr ms it mn b gy mt mu l mv mw">df.dropna(axis=0, how='all', inplace=True)<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/8ab3062794295a6ee817df201b936890.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*fJquRET_dfsBpnFXrrJ5AQ.png"/></div></figure><p id="5cc2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">轴</strong>参数用于选择行(0)或列(1)。</p><p id="2b12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的 dataframe 没有一行充满缺失值，因此设置 how='all '不会删除任何行。缺省值是' any '，所以如果我们想使用 how='any '，就不需要指定它:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/e846f73dde914522adcfbbfb0f3576e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*qzTKAU_92wGD0d-YWVEV_w.png"/></div></figure><blockquote class="mf mg mh"><p id="95e4" class="ki kj mi kk b kl km ju kn ko kp jx kq mj ks kt ku mk kw kx ky ml la lb lc ld im bi translated"><strong class="kk iu">注意:</strong> <strong class="kk iu">原位</strong>参数用于保存对原始数据帧的更改。默认值为 false，因此如果我们不将其设置为 True，我们所做的更改将不会保存在原始数据帧中。</p></blockquote><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/48b55013b8e8d62af3daf3fdd1e7b5a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*I1vL2_y5TuQ0GdPHUVDujw.png"/></div></figure><p id="a5d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将 thresh 参数设置为至少缺少 3 个值的 3 个丢弃行。</p><p id="acfb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据是宝贵的资产，所以我们不应该轻易放弃它。此外，机器学习模型几乎总是倾向于在更多数据的情况下表现更好。因此，根据具体情况，我们可能更喜欢替换丢失的值，而不是丢弃。</p><p id="e279" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">替换缺失值</strong></p><p id="05bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> fillna() </strong>熊猫函数方便处理缺失值。使用 fillna()，缺失值可以由特殊值或聚合值(如平均值、中值)替换。此外，缺失的值可以用它之前或之后的值替换，这对时间序列数据集非常有用。</p><ul class=""><li id="ab04" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld ov lx ly lz bi translated">用标量替换丢失的值:</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi os"><img src="../Images/ede7e7f9220cd7083d963e8bf35d5d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*c1x0xFqRjhDx5emslFKAOw.png"/></div></figure><ul class=""><li id="c0b2" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld ov lx ly lz bi translated">fillna()也可以用于特定的列:</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/92b3791d410062a4e8d5c50bcca20cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*3NzQuBXlbabjZmfSJfKkNA.png"/></div></figure><ul class=""><li id="c98c" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld ov lx ly lz bi translated">使用<strong class="kk iu">方法</strong>参数，缺失的值可以用它们之前或之后的值替换。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/bdd568075e420a220451b880e937b570.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*02FYcnhr_zsOuHMWxY38Ug.png"/></div></figure><p id="c869" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> ffill </strong>代表“向前填充”用前一行中的值替换缺失的值。您也可以选择<strong class="kk iu"> bfill </strong>代表“反向填充”。</p><p id="ff2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一列或一行中有许多连续的缺失值，您可能希望<strong class="kk iu">限制</strong>向前或向后填充的缺失值的数量。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/3eebac569aeed43e7b0ca3bf41613895.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*qrHT8HTzuyZKPvTcrp9FQw.png"/></div></figure><p id="6300" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">极限参数设置为 1，因此只有一个缺失值被向前填充。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="b953" class="mx ms it bd my mz oi nb nc nd oj nf ng jz ok ka ni kc ol kd nk kf om kg nm nn bi translated"><strong class="ak"> 4。组合数据帧</strong></h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi pb"><img src="../Images/bd560dff6262977c3d4457a696c76851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1NAHctnixJtBxHwAIJVbIQ.jpeg"/></div></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">Denys Nevozhai 在<a class="ae lq" href="https://unsplash.com/s/photos/look-for?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="6c6d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据科学项目通常需要我们从不同的来源收集数据。因此，作为数据准备的一部分，我们可能需要组合数据框架。在这一部分，我将讨论以下主题:</p><ul class=""><li id="9e20" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld ov lx ly lz bi translated">串联</li><li id="523e" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld ov lx ly lz bi translated">合并</li></ul><h1 id="9940" class="mx ms it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated"><strong class="ak">串联</strong></h1><p id="2dcb" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">让我们首先创建两个数据帧:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="76e7" class="mr ms it mn b gy mt mu l mv mw">df1 = pd.DataFrame({<br/>'column_a':[1,2,3,4],<br/>'column_b':['a','b','c','d'],<br/>'column_c':[True,True,False,True]<br/>})</span><span id="6ffa" class="mr ms it mn b gy nz mu l mv mw">df2 = pd.DataFrame({<br/>'column_a':[1,2,9,10],<br/>'column_b':['a','k','l','m'],<br/>'column_c':[False,False,False,True]<br/>})</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/808ec669a53411e5331830d91d686420.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*oA6P9E92uQA-aLo8aNpyDg.png"/></div></figure><p id="f05f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">组合或连接数据帧的一种方法是<strong class="kk iu"> concat() </strong>函数。通过改变<strong class="kk iu">轴</strong>参数，它可用于沿行或列连接数据帧。axis 参数的默认值为 0，表示沿行组合。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/9cb9e5c0685b5875df50d002e5460195.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*mAjjNdeOtMR0M3KB2Dou5g.png"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/5feda063f6631a48537951c26b0eed23.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*Qwd5GPAUdJuZonweDkaNTg.png"/></div></figure><p id="4a6b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您在上面的第一张图中所看到的，保留了各个数据帧的索引。为了改变它并重新索引组合数据帧，<strong class="kk iu"> ignore_index </strong>参数设置为真。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/a869ffa233ed46409df26a28ca012915.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*F7j3mzbD_-PooJGAC0Q_Iw.png"/></div></figure><p id="20a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">concat()函数的<strong class="kk iu"> join </strong>参数决定了如何组合数据帧。默认值为“outer ”,返回两个数据帧中的所有索引。如果选择了' inner '选项，则只返回具有共享索引的行。我将改变 df2 的索引，以便您可以看到“内部”和“外部”的区别。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/2a9dde4647ac1d94b067dbc678015163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*1hC9mWD8Tgm3z1vsi4aWig.png"/></div></figure><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="ca1a" class="mr ms it mn b gy mt mu l mv mw">df = pd.concat([df1,df2], axis=1, join='inner')<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/edf6bed606aa72450f4810c1d8dc0770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*8Beaf6Btqgq7xeY66af45A.png"/></div></figure><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="2433" class="mr ms it mn b gy mt mu l mv mw">df = pd.concat([df1,df2], axis=1, join='outer')<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/fbbc71e19a6201d5026a57f5e248cda3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*Tx179J-vWOQPPiEltFvykA.png"/></div></figure><p id="28d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Pandas 还提供了标记数据帧的方法，以便我们知道哪个部分来自哪个数据帧。我们只是使用<strong class="kk iu">键</strong>参数按顺序传递组合数据帧列表。</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="c0f8" class="mr ms it mn b gy mt mu l mv mw">df = pd.concat([df1, df2], keys=['df1', 'df2'])<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/a8d475fda0c7d43e756fcdd07838eab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*K8IWKpGv3aMUrzl68BR54w.png"/></div></figure><p id="ee6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还使得方便地访问数据帧的不同部分变得更加容易:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/618b8a2d3c59dcd8b37818ecc53f4854.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*-s3I5GV5Tban0rASDeMqgg.png"/></div></figure><blockquote class="mf mg mh"><p id="38d0" class="ki kj mi kk b kl km ju kn ko kp jx kq mj ks kt ku mk kw kx ky ml la lb lc ld im bi translated">关于 concat()函数的一个重要注意事项是，它制作了数据的副本。为了防止进行不必要的复印，需要将<strong class="kk iu">复印</strong>参数设置为假。默认值为 True。</p></blockquote><p id="5d81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> append() </strong>函数也用于组合数据帧。它可以被看作是 concat()函数的一个特例(axis=0，join='outer ')，所以我不会详细讨论它，而只是给出一个例子来展示语法。</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="07e7" class="mr ms it mn b gy mt mu l mv mw">df = df1.append(df2)<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/e4aa24c87230e640df6008539a64942d.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*-4gM4pn1jWEOrZvbeXL2Xw.png"/></div></figure><h1 id="2cb2" class="mx ms it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated"><strong class="ak">合并</strong></h1><p id="4e60" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">组合数据帧的另一个广泛使用的函数是<strong class="kk iu"> merge() </strong>。Concat()函数只是将数据帧一个接一个地相加或并排相加。它更像是附加数据帧。Merge()根据共享列中的值组合数据帧。与 concat()函数相比，Merge()函数提供了更多的灵活性。看到例子就清楚了。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/6480fec787bd07b5aa29196996114ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*2-xDkq5sRdLjvFSzjO_mfA.png"/></div></figure><p id="5cd4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参数上的<strong class="kk iu">选择用于合并的列或索引级别。</strong></p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="d3bc" class="mr ms it mn b gy mt mu l mv mw">df_merge = pd.merge(df1, df2, on='column_a')<br/>df_merge</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/ac4d8d639ec34860cfb1446e365b22fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*b3T41Qnhtd7xmYIPXxxVVg.png"/></div></figure><p id="4b3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">列名不必相同。我们关注的是列中的值。假设两个数据帧在一个列中有共同的值，您希望使用该列来合并这些数据帧，但是列名不同。在这种情况下，可以使用<strong class="kk iu"> left_on </strong>和<strong class="kk iu"> right_on </strong>参数代替<strong class="kk iu"> on </strong>参数。为了显示差异，我将在 df2 中更改列名，然后使用 merge:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="a8df" class="mr ms it mn b gy mt mu l mv mw">df2.rename(columns={'column_a':'new_column_a'}, inplace=True)<br/>df2</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/2737bfeb17a7dcf429014ad529402b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*B1uRDoI2O9A6LbP0ZlbmmA.png"/></div></figure><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="e943" class="mr ms it mn b gy mt mu l mv mw">df_merge = pd.merge(df1, df2, left_on='column_a', right_on='new_column_a')</span><span id="14d9" class="mr ms it mn b gy nz mu l mv mw">df_merge</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/e51beef820ea43df6c2ccf58ab623e7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*BL6_t2y9yxH-AwrfFRTu1w.png"/></div></figure><p id="2cd5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管 column_a 和 new_column_a 中的返回值是相同的，但由于具有不同的名称，合并的数据帧包括这两个列。</p><p id="2e8b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以将多个值传递给参数上的<strong class="kk iu">。返回的数据帧仅包括在所有传递给</strong>参数上的<strong class="kk iu">的列中具有相同值的行。</strong></p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="b420" class="mr ms it mn b gy mt mu l mv mw">df2.rename(columns={'new_column_a':'column_a'}, inplace=True)</span><span id="ce73" class="mr ms it mn b gy nz mu l mv mw">df_merge = pd.merge(df1, df2, on=['column_a','column_b'])<br/>df_merge</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi po"><img src="../Images/61a4b9db9cf7cc915e4c12366fccc68f.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*qN51IZjSFPdXxgsvuQoicA.png"/></div></figure><p id="0255" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">df1 和 df2 是根据 column_a 中的公共值合并的，是时候介绍一下<strong class="kk iu">how</strong>merge()的参数了。顾名思义，表示你想怎么组合。how 的可能值为“内部”、“外部”、“左侧”、“右侧”。</p><ul class=""><li id="cc4b" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld ov lx ly lz bi translated">inner:只有在参数<strong class="kk iu">指定的列中有相同值的行(<strong class="kk iu"> how </strong>参数的默认值)</strong></li><li id="87ec" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld ov lx ly lz bi translated">外部:所有行</li><li id="4a19" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld ov lx ly lz bi translated">左侧:左侧数据帧中的所有行</li><li id="23cf" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld ov lx ly lz bi translated">右侧:右侧数据帧中的所有行</li></ul><p id="2038" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“如何”的概念在下图中更加清晰。如果您熟悉 SQL，其逻辑与 SQL 连接相同。</p><p id="ae09" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的数字更清楚地代表了参数的概念。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/44613d54474588b78568830df2fcfb9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*4Sbt6Sq68ZxtObXVqGbKGA.png"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/27646185311f851971083540e8e24e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*j_tIJstL4yKclFp34gMndA.png"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/e9cb3895c696af3fa7714973c8ba9279.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*ytPsYL8xAM5G4dBRaiwa7w.png"/></div></figure><p id="5efe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">outer '，' left '和' right '选项包括不在其中一个数据帧中的数据。缺少的部分自动用<strong class="kk iu"> NaN </strong>值填充。NaN 是熊猫缺失价值观的典型代表。</p><p id="2f19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">how 的默认值是“inner ”,因此您不必在函数中显式编写。“Inner”只返回 column_a 中具有公共值的行。</p><p id="6f4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当 how 参数选择' outer '时，合并的数据帧包括两个数据帧中 column_a 的所有值。但是，公共值(column_a = 1 和 column_a = 2)不会重复。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi pr"><img src="../Images/0c7edd571135846ea8bb4a6693bbe253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Swpx9ckTDoXt4YlvpD_8dQ.png"/></div></div></figure><p id="eff5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当 how 参数选择' left '时，合并数据帧包括左侧数据帧中所有行。如果 column_a(传递给 on 参数的列)中的值不在右数据帧中，则右数据帧中的列将填充 NaN 值。很少使用“right”选项，因为您只能在 merge 函数中更改数据帧的顺序(而不是(df1，df2)使用(df2，df1))。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/c7b966a1348c9c13ff51a23c135e88de.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*bbW0IKKREHp6j6K1qi6-Jw.png"/></div></figure><p id="a07d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能已经注意到，两个数据帧中相同的列名会添加一个后缀。区分哪一列来自哪一个数据帧是很有用的。您可以使用<strong class="kk iu">后缀</strong>参数指定要添加的后缀。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/4c4e7c8830217e968ac1f0e1bd4a2010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*-oQ688MaYB8KZOHPX5iGsw.png"/></div></figure></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="ea13" class="mx ms it bd my mz oi nb nc nd oj nf ng jz ok ka ni kc ol kd nk kf om kg nm nn bi translated"><strong class="ak"> 5。选择数据帧上的数据</strong></h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi pu"><img src="../Images/534815ac0b9bcd2cf5e5685b11d3824d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRqwQdoS8wQSTs_f1SHFKA.jpeg"/></div></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">照片由<a class="ae lq" href="https://unsplash.com/@bpyndus?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Bodie Pyndus </a>在<a class="ae lq" href="https://unsplash.com/s/photos/select?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="07bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> iloc </strong>和<strong class="kk iu"> loc </strong>允许选择数据帧的一部分。</p><ul class=""><li id="6fb8" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld ov lx ly lz bi translated">iloc:按职位选择</li><li id="c7d1" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld ov lx ly lz bi translated">loc:按标签选择</li></ul><p id="d162" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看一些例子，因为一如既往，熟能生巧。在本节的示例中，我将使用以下数据帧:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="ab gu cl pv"><img src="../Images/2f619db737b5c4072a1a15e9238dd639.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hQCxq_1a3lEIR49N2wgccw.png"/></div></figure><h1 id="5d5f" class="mx ms it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated"><strong class="ak"> iloc </strong></h1><p id="0ef3" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">选择第二行:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="ee9e" class="mr ms it mn b gy mt mu l mv mw">df.iloc[1] <br/>a    0.571258<br/>b       Paris<br/>c        True<br/>d           4<br/>e           4<br/>Name: 1, dtype: object</span></pre><p id="1734" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">选择第一行，第二列(即第一行中的第二个值):</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="a81e" class="mr ms it mn b gy mt mu l mv mw">df.iloc[0,1] <br/>'London'</span></pre><p id="e930" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有行，第三列(与选择第二列相同，但我只想展示':'的用法):</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="d154" class="mr ms it mn b gy mt mu l mv mw">df.iloc[:,2]<br/>0     True<br/>1     True<br/>2     True<br/>3    False<br/>4    False<br/>5     True<br/>7    False<br/>8     True<br/>9     True<br/>Name: c, dtype: bool</span></pre><p id="baf5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">前两行，第二列:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="f32b" class="mr ms it mn b gy mt mu l mv mw">df.iloc[:2,1]<br/>0    London<br/>1     Paris<br/>Name: b, dtype: object</span></pre><h1 id="ac26" class="mx ms it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated"><strong class="ak"> loc </strong></h1><p id="b736" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">最多 2 行，列“b”:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="1db3" class="mr ms it mn b gy mt mu l mv mw">df.loc[:2,'b']<br/>0      London<br/>1       Paris<br/>2    New York<br/>Name: b, dtype: object</span></pre><p id="ad6f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最多 2 行和最多“b”列:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="a8a1" class="mr ms it mn b gy mt mu l mv mw">df.loc[:2, :'b']</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/b3ba162244e91476e1c6e730a593f9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/0*pGfnhEcdeoLKki1N.png"/></div></figure><p id="83a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第“2”行和第“b”列:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="24bd" class="mr ms it mn b gy mt mu l mv mw">df.loc[2, :'b']<br/>a     0.16649<br/>b    New York<br/>Name: 2, dtype: object</span></pre><blockquote class="mf mg mh"><p id="656f" class="ki kj mi kk b kl km ju kn ko kp jx kq mj ks kt ku mk kw kx ky ml la lb lc ld im bi translated">您可能想知道为什么我们在 loc 和 iloc 中对行使用相同的值。原因是数字指数。Loc 按位置选择，但行的位置与索引相同。</p></blockquote><p id="d2f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建一个带有非数字索引的新数据帧，这样我们就可以看到不同之处:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="51bb" class="mr ms it mn b gy mt mu l mv mw">index = ['aa','bb','cc','dd','ee']<br/>df2 = pd.DataFrame({'a':np.random.rand(5),<br/>                 'b':np.random.randint(10, size=5)},<br/>                   index = index)<br/>df2</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi px"><img src="../Images/df850ca520ec4d9a41fbf8cb0f25f2d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:230/format:webp/0*WCkqP4E_Sjwn1VtL.png"/></div></figure><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="662e" class="mr ms it mn b gy mt mu l mv mw">df2.loc['bb','b']<br/>1</span><span id="9ef9" class="mr ms it mn b gy nz mu l mv mw">df2.loc[:'cc','a']<br/>aa    0.892290<br/>bb    0.174937<br/>cc    0.600939<br/>Name: a, dtype: float64</span></pre></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="654a" class="mx ms it bd my mz oi nb nc nd oj nf ng jz ok ka ni kc ol kd nk kf om kg nm nn bi translated"><strong class="ak"> 6。重塑数据帧</strong></h1><p id="4278" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">有多种方法可以重塑数据帧。我们可以选择最适合手头任务的一个。重塑数据帧的函数:</p><ul class=""><li id="1c1f" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld ov lx ly lz bi translated"><strong class="kk iu">融化</strong></li><li id="a313" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld ov lx ly lz bi translated"><strong class="kk iu">堆叠和拆分</strong></li></ul><h1 id="8946" class="mx ms it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">熔化</h1><p id="7886" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">Melt 用于将宽数据帧转换为窄数据帧。我所说的宽是指具有大量列的数据帧。一些数据帧的结构是连续的测量值或变量用列来表示。在某些情况下，将这些列表示为行可能更适合我们的任务。</p><p id="a56c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑以下数据帧:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="5fbc" class="mr ms it mn b gy mt mu l mv mw">df1 = pd.DataFrame({'city':['A','B','C'],<br/>                   'day1':[22,25,28],<br/>                   'day2':[10,14,13],<br/>                   'day3':[25,22,26],<br/>                   'day4':[18,15,17],<br/>                   'day5':[12,14,18]})</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi py"><img src="../Images/6ad3e29a4763c0080487639f0c370410.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/0*Jw0D3fk9KxesAn16.png"/></div></figure><p id="6c29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有三个不同的城市，在不同的日子进行测量。我们决定用一列中的行来表示这些日子。还会有一列显示测量结果。我们可以通过使用<strong class="kk iu">融化</strong>功能轻松实现这一点:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="8892" class="mr ms it mn b gy mt mu l mv mw">df1.melt(id_vars=['city'])</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/c31ea708ac5ca7ac055588589065e52d.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/0*Jx4tu8-H9SjNxTkp.png"/></div></figure><p id="be4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，变量和值列的名称是给定的。我们可以使用 melt 函数的参数<strong class="kk iu"> var_name </strong>和<strong class="kk iu"> value_name </strong>来指定新的列名。如果我们按城市列对数据进行排序，效果会更好:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="22c7" class="mr ms it mn b gy mt mu l mv mw">df1.melt(id_vars=['city'], var_name = 'date', value_name = 'temperature').sort_values(by='city').reset_index(drop=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/a08c1815adc8b1860d200e28a64e59e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/0*5a3aHgIkabKyll9a.png"/></div></figure><h1 id="ba80" class="mx ms it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">堆叠和取消堆叠</h1><p id="3af3" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">堆栈函数增加了数据帧的索引级别。我所说的提高水平是指:</p><ul class=""><li id="f5bf" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld ov lx ly lz bi translated">如果 dataframe 有一个简单的列索引，stack 返回一个系列，其索引由原始 dataframe 的行列对组成。</li><li id="3995" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld ov lx ly lz bi translated">如果数据帧有多级索引，stack 增加索引级别。</li></ul><p id="0b66" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用例子解释更好。考虑以下数据帧:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi qb"><img src="../Images/f3b1a41addfde64541884771cc0cc93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/0*jO4Nm1sqLz-nXWUD.png"/></div></div></figure><p id="8bee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">df1 有 3 行 6 列，具有简单的整数列索引。如果将 stack 函数应用于 df1，它将返回 3 x 6 = 18 行的序列。序列的索引将是[(0，'城市')，(0，'第 1 天')，…，(2，'第 5 天')]。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/04715d58a82ff095f8a7aeac568f1c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/0*1jI80MeuY2R4-LPp.png"/></div></figure><p id="6e6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们也检查一下形状和指数:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="2c0e" class="mr ms it mn b gy mt mu l mv mw">df1.shape<br/>(3,6)<br/>df1.stack().shape<br/>(18,)<br/>df1.stack().index[0] #multilevel index<br/>(0, 'city')</span></pre><p id="44c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">栈和非栈功能更常用于具有多级索引的数据帧。让我们创建一个具有多级索引的数据框架:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="f83b" class="mr ms it mn b gy mt mu l mv mw">tuples = [('A',1),('A',2),('A',3),('B',1),('A',2)]</span><span id="4e4e" class="mr ms it mn b gy nz mu l mv mw">index = pd.MultiIndex.from_tuples(tuples, names=['first','second'])</span><span id="4e35" class="mr ms it mn b gy nz mu l mv mw">df2 = pd.DataFrame(np.random.randint(10, size=(5,2)), <br/>                   index=index, columns=['column_x', 'column_y'])</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/7c56240820a565427471e2650d70ce64.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/0*dwCRq4RT5zxr8ZgV.png"/></div></figure><p id="bfe8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们对该数据帧应用堆栈功能，索引级别将会增加:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="9bfc" class="mr ms it mn b gy mt mu l mv mw">df_stacked = df2.stack().to_frame()<br/>df_stacked</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/aa29be768d6f3c7ad86d0c3f70e44457.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/0*8AIPeL1HiNYuPUHZ.png"/></div></figure><p id="e4fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，列名(column_x 和 column_y)是多级索引的一部分。因此得到的数据帧有一列和一个 3 级多索引。</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="ab16" class="mr ms it mn b gy mt mu l mv mw">len(df_stacked.index.levels)<br/>3</span><span id="420d" class="mr ms it mn b gy nz mu l mv mw">len(df2.index.levels)<br/>2</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/6708f4a5919cd7b92f5764487feb03b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/0*b0bcj0g7Wl_J_xuD.png"/></div></figure><p id="60a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">拆堆</strong>与<strong class="kk iu">堆堆</strong>正好相反。如果我们对堆叠的数据帧应用拆分，我们将得到原始的数据帧:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/b82b7c558769da7db9168e8cbdf63a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/0*UYO_t-GTACw6xTqJ.png"/></div></figure><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="32c1" class="mr ms it mn b gy mt mu l mv mw">df_stacked.unstack().index<br/>MultiIndex(levels=[['A', 'B'], [1, 2, 3]],<br/>           codes=[[0, 0, 0, 1, 1], [0, 1, 2, 0, 1]],<br/>           names=['first', 'second'])</span><span id="cada" class="mr ms it mn b gy nz mu l mv mw">df2.index<br/>MultiIndex(levels=[['A', 'B'], [1, 2, 3]],<br/>           codes=[[0, 0, 0, 1, 1], [0, 1, 2, 0, 1]],<br/>           names=['first', 'second'])</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/00fc31e4aa8bf9eb36a961addefe3c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/0*LMrepFBDs7oXtVU5.png"/></div></figure></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="2b93" class="mx ms it bd my mz oi nb nc nd oj nf ng jz ok ka ni kc ol kd nk kf om kg nm nn bi translated">7.熊猫的其他功能</h1><p id="19e8" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">本部分涵盖的功能:</p><ul class=""><li id="3018" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld ov lx ly lz bi translated">激增</li><li id="4cd3" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld ov lx ly lz bi translated">努尼克岛</li><li id="8c83" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld ov lx ly lz bi translated">检查</li><li id="12b6" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld ov lx ly lz bi translated">在哪里</li><li id="b035" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld ov lx ly lz bi translated">推断对象</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi qh"><img src="../Images/38cc2001251e237f8a95146e4e117653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5qaDGbhSlNmQwpfnEqxGCw.jpeg"/></div></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">安德烈·费塔多在<a class="ae lq" href="https://unsplash.com/s/photos/select?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="993f" class="mx ms it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">激增</h1><p id="f6bf" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">假设您的数据集在单个观测值(行)中包含一个要素的多个条目，但您希望在单独的行中对它们进行分析。</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="b9ba" class="mr ms it mn b gy mt mu l mv mw">df = pd.DataFrame({'ID':['a','b','c'],<br/>                  'measurement':[4,6,[2,3,8]],<br/>                  'day':1})<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/d968a3c3c9d4b4f5d8dc8c4f66e06eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/0*izkNECAoxY4tECH3.png"/></div></figure><p id="6e26" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望在单独的行上看到第“1”天“c”的测量值，使用<strong class="kk iu"> explode </strong>很容易做到这一点:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="07b2" class="mr ms it mn b gy mt mu l mv mw">df.explode('measurement').reset_index(drop=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/86bca3975ed492eebf985a0c762e9423.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/0*W1JUNJ0DGA1gioUy.png"/></div></figure><p id="d9ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最好也重置索引:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/eef4ca93d3502725758e22ec5dec590d.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/0*Ta35u8H0xd2rhcPI.png"/></div></figure><p id="cc11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以在两列上使用爆炸作为一个链:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="65ff" class="mr ms it mn b gy mt mu l mv mw">df2 = pd.DataFrame({'ID':['a','b','c'],<br/>                   'measurement_1':[4,6,[2,3,8]],<br/>                   'measurement_2':[1,[7,9],1],<br/>                   'day':1})<br/>df2</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi qk"><img src="../Images/604dc0f63680333e832836b3dce3ccc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/0*0JI-1MoMXNbLgeF8.png"/></div></div></figure><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="643b" class="mr ms it mn b gy mt mu l mv mw">df2.explode('measurement_1').reset_index(drop=True).explode('measurement_2').reset_index(drop=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ql"><img src="../Images/19304f828e40971e9c3458f6bfeeaf14.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/0*lv2mhuNaXLwRm1ci.png"/></div></figure><p id="0e04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">确保在第一次分解后使用 reset_index，否则会得到如下意外结果:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="50c6" class="mr ms it mn b gy mt mu l mv mw">df2.explode('measurement_1').explode('measurement_2').reset_index(drop=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qm"><img src="../Images/4b24fcb2485358f4ac12c22e8598cfce.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/0*kyEgMM9DoTCdCdU-.png"/></div></figure><h1 id="aad8" class="mx ms it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">努尼克岛</h1><p id="867d" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">Nunique 计算列或行中唯一条目的数量。它在分类特征中非常有用，尤其是在我们事先不知道类别数量的情况下。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi qn"><img src="../Images/7db27dc925148cb04e672581acf85dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BBIM3pDmRBfXEeFr.jpeg"/></div></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">由<a class="ae lq" href="https://unsplash.com/@kylejglenn?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯尔·格伦</a>在<a class="ae lq" href="https://unsplash.com/s/photos/unique?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7cd4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有以下数据帧:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/fd85cae8fa99a3e4f9536bc468c59ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/0*ndU98vZHbqLT0PaR.png"/></div></figure><p id="c92c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要查找列中唯一值的数量:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="af33" class="mr ms it mn b gy mt mu l mv mw">df.name.nunique()<br/>5</span></pre><p id="13dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用稍微复杂一点的语法使用<strong class="kk iu"> value_counts </strong>获得相同的结果:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="a3ea" class="mr ms it mn b gy mt mu l mv mw">df.name.value_counts().shape[0]<br/>5</span></pre><p id="e5b9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，<strong class="kk iu"> nunique </strong>允许我们同时对所有的列或行执行这个操作:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="0b41" class="mr ms it mn b gy mt mu l mv mw">df.nunique()  #columns<br/>ID              8 <br/>name            5 <br/>measurement1    7 <br/>measurement2    5 <br/>measurement3    6</span><span id="b6b2" class="mr ms it mn b gy nz mu l mv mw">dtype: int64df.nunique(axis=1) #rows<br/>0    3 <br/>1    4 <br/>2    4 <br/>3    5 <br/>4    5 <br/>5    3 <br/>6    4 <br/>7    4 <br/>dtype: int64</span></pre><h1 id="41d4" class="mx ms it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">检查</h1><p id="48a3" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">它可用于根据其他行、列对上的值在数据帧中查找值。这个函数最好通过一个例子来解释。假设我们有以下数据帧:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qp"><img src="../Images/c531562c0d79b38887736290f253ca30.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*RpR5aeB9EJWvaqt_.png"/></div></figure><p id="3668" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于每一天，我们有 4 个人的测量值和一个包含这 4 个人的名字的列。我们希望创建一个新列，在“选择”列中显示该人的测量值:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="2120" class="mr ms it mn b gy mt mu l mv mw">df['Person_point'] = df.lookup(df.index, df['Person'])<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qq"><img src="../Images/1a5f9af4e855d670d89fa47f40b9901f.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/0*qntlo-NsQXYsOObu.png"/></div></figure><p id="aeeb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不必对所有数据点都进行这种操作。只要行标签和列标签具有相同的大小，我们就可以使用特定的范围:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="bc92" class="mr ms it mn b gy mt mu l mv mw">df.lookup(df.index[:5], df['Person'][:5])<br/>array([4, 7, 9, 8, 1])</span></pre><h1 id="2176" class="mx ms it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">在哪里</h1><p id="3c17" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">“Where”用于根据条件替换行或列中的值。您还可以指定要替换的值。默认值为 NaN。让我们复习一个例子，这样就清楚了。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qq"><img src="../Images/c1636f93a5ed13e3a76c9b3044488063.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/0*2OIQxLCzcE-NFzZ5.png"/></div></figure><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="ff93" class="mr ms it mn b gy mt mu l mv mw">df['Person_point'].where(df['Person_point'] &gt; 5)</span><span id="b5a9" class="mr ms it mn b gy nz mu l mv mw">0    NaN <br/>1    7.0 <br/>2    9.0 <br/>3    8.0 <br/>4    NaN <br/>5    6.0 <br/>6    NaN <br/>7    9.0 <br/>Name: Person_point, dtype: float64</span></pre><p id="f0bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以指定替换值:</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="07bf" class="mr ms it mn b gy mt mu l mv mw">df['Person_point'].where(df['Person_point'] &gt; 5, 'Not_qualified', inplace=True)</span><span id="07e9" class="mr ms it mn b gy nz mu l mv mw">df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/4e07db29e0f00cb0809673ff59c7d741.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/0*bubmA-dEPgfAy_eP.png"/></div></figure><h1 id="3b94" class="mx ms it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">推断对象</h1><p id="d0bf" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">Pandas 支持广泛的数据类型，其中之一是<strong class="kk iu">对象</strong>。对象包含文本或混合(数字和非数字)值。但是，如果有不同的选项可用，则不建议使用对象数据类型。使用更具体的数据类型可以更快地执行某些操作。例如，我们更喜欢用整数或浮点数据类型来表示数值。</p><p id="e69c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> infer_objects </strong>尝试为对象列推断更好的数据类型。我们来看一个例子。</p><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="5729" class="mr ms it mn b gy mt mu l mv mw">df = pd.DataFrame({'A': ['a', 1, 2, 3],<br/>                   'B':['b',2.1,1.5,2],<br/>                   'C':['c',True,False,False],<br/>                   'D':['a','b','c','d']})<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi qs"><img src="../Images/c058492ffec201104069ecf8f7be6585.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/0*dkFgBwOJs0sPVPy0.png"/></div></figure><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="4430" class="mr ms it mn b gy mt mu l mv mw">df = df[1:]df.dtypes<br/>A    object <br/>B    object <br/>C    object <br/>D    object <br/>dtype: object</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi qt"><img src="../Images/af8e1370185a173ab36d25890e0168ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/0*Gp_MWLR2pvqzDyhh.png"/></div></div></figure><pre class="lf lg lh li gt mm mn mo mp aw mq bi"><span id="f167" class="mr ms it mn b gy mt mu l mv mw">df.infer_objects().dtypesdf.dtypes<br/>A      int64 <br/>B    float64 <br/>C       bool <br/>D     object <br/>dtype: object</span></pre></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="37c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>