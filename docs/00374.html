<html>
<head>
<title>Proper multithreading — let’s remind ourselves what it is once again</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适当的多线程——让我们再次提醒自己它是什么</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/proper-multithreading-have-perfect-multithreading-in-your-program-4cbbf8270af3?source=collection_archive---------27-----------------------#2020-01-11">https://towardsdatascience.com/proper-multithreading-have-perfect-multithreading-in-your-program-4cbbf8270af3?source=collection_archive---------27-----------------------#2020-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/27f9a68d9052561d241f5d08fa735b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9TGg2k1wJPQVcLhp9hM_Yg.jpeg"/></div></div></figure><div class=""/><p id="cc66" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这听起来很理想，但是如何才能拥有真正的多线程，并使用适当的锁来保护您的程序，使它可以平稳运行，而不用担心是否会出现死锁或竞争情况呢？只是一些锁、信号量和大量的思考时间。</p><p id="9084" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我是说，还能怎样？要求它自己做多线程安全是疯狂的。我们可以从如何锁定程序和防止死锁开始。</p><h1 id="4806" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是适当的多线程以及如何做？</h1><p id="4e43" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">为了使程序工作时不出现死锁和数据丢失，必须达到某个特定的程序流。<strong class="kd jf">当您同时从多个线程访问共享资源时，可能会发生死锁或竞争情况</strong>。当你用多线程运行一个程序时，很难调试到底什么时候发生了什么，以及哪个线程比其他线程更优先访问共享资源。这就是锁发挥作用的地方，我们用它来防止同样的死锁。</p><p id="1c15" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有一点要提的是<strong class="kd jf">上下文切换</strong>，其中<strong class="kd jf"> </strong>是计算机的 CPU(中央处理器)在保证任务不冲突的情况下，从一个任务(或进程)切换到另一个任务(或进程)所遵循的程序。如果计算机要提供用户友好的多任务处理，有效的环境切换是至关重要的。</p><p id="420d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们更详细地讨论锁。</p><h2 id="d6d6" class="mc la je bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">锁</h2><p id="7b70" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">有几种不同的锁:</p><blockquote class="mo mp mq"><p id="7fd6" class="kb kc mr kd b ke kf kg kh ki kj kk kl ms kn ko kp mt kr ks kt mu kv kw kx ky im bi translated">M <!-- -->执行程序和条件变量</p></blockquote><h1 id="fdfe" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">互斥体</h1><p id="208a" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">代表<strong class="kd jf">互斥</strong>并保护正在被多个线程使用的共享资源。<strong class="kd jf">共享资源</strong>需要受到保护，以确保正在写入/读取的数据得到正确处理。</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mv"><img src="../Images/f60c8ad7a5be0a6049a23292a8e839b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SGI5olE-ua0rDgK8.png"/></div></div></figure><p id="3376" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简单地说，可以有一个全局变量，并且可以被多个线程访问。你锁定它是因为一个线程可以写，其他线程可以读，但这需要以一定的顺序发生。</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi na"><img src="../Images/cc5a74526e2351b0d187b5da1fbc672f.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/0*nqWiDlNZOVTphGQq.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">这就是互斥体简化的工作方式</p></figure><h2 id="1d4d" class="mc la je bd lb md me dn lf mf mg dp lj km mh mi ln kq mj mk lr ku ml mm lv mn bi translated">例子</h2><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/1e4c509e7ec617883acf78b1a8c5798d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hcVps_z3aFTwD-UA6yesQ.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">C 语言中的互斥示例</p></figure><p id="686f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有许多与互斥控件相关的函数，你可以在这里的<a class="ae no" href="http://www.cplusplus.com/reference/mutex/mutex/" rel="noopener ugc nofollow" target="_blank">中查看所有的函数。锁的大多数功能在所有语言中都是相似的。</a></p><h1 id="46c6" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">条件变量</h1><p id="31ea" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">条件变量允许任意数量的线程等待另一个线程发出条件信号，然后它们可以开始工作。</p><p id="0550" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当它的一个<em class="mr">等待函数</em>被调用时，它使用一个 unique_lock(通过互斥锁)来锁定线程。该线程保持阻塞状态，直到被另一个线程唤醒，该线程在同一个 condition_variable 对象上调用<em class="mr">通知函数</em>。</p><p id="5eb3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它沿着互斥体工作，你可以在这里查看所有的特性<a class="ae no" href="https://en.cppreference.com/w/cpp/thread/condition_variable" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="bae3" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="6ac3" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这是一个简短的概述，并提醒您使用互斥锁和条件变量来锁定程序，以便实现完美的多线程。</p></div></div>    
</body>
</html>