<html>
<head>
<title>Apple Music activity analyser — getting started with the package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">apple Music activity analyser——软件包使用入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/apple-music-activity-analyser-part-2-3a62c6284eb0?source=collection_archive---------68-----------------------#2020-07-28">https://towardsdatascience.com/apple-music-activity-analyser-part-2-3a62c6284eb0?source=collection_archive---------68-----------------------#2020-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/57bd2733cd9c4d953d092c95d908f0e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mEHalRC2L-79spUKBs2uJA.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">丹尼尔·科尔派在<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="fa10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在另一篇文章中(<a class="ae kc" href="https://medium.com/@mozart38/apple-music-activity-analyser-part-1-dd02173f095f" rel="noopener">见此</a>)，我们看了看我对自己的数据所做的分析。现在是我向您展示如何使用 apple_music_analyser 软件包的时候了，这样您就可以对自己的数据进行类似的数据分析了！</p><p id="cab1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">注意:您应该向 Apple 请求您的数据，请参见 Apple 的数据和隐私页面。</em></p><p id="fc34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">另一个注意事项(编辑自 2020 年 10 月 12 日):一个</em> <a class="ae kc" href="https://www.acoullandreau.com/dashboard/#" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> web 界面</em> </a> <em class="lb">现在可供您浏览您的数据！而且你可以在这里</em>  <em class="lb">阅读一下</em> <a class="ae kc" href="https://medium.com/@mozart38/apple-music-dashboard-an-introduction-4a99295217f9" rel="noopener"> <em class="lb">。</em></a></p><h1 id="c4e8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">安装软件包</h1><p id="4d73" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">首先，安装软件包</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="00ef" class="mo ld iq mk b gy mp mq l mr ms">pip install apple-music-analyser</span></pre><p id="eb5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有依赖项都是自动安装的。有一个文件夹文档和一个文件夹示例，可以包含对你有用的内容！可以从<a class="ae kc" href="https://github.com/acoullandreau/apple_music_analyser" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>看一下。</p><h1 id="0b25" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">导入和数据输入</h1><p id="6e4d" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">当然可以用自己的数据！但是如果您愿意，您可以使用软件包附带的测试数据(用于测试)。拿过来<a class="ae kc" href="https://github.com/acoullandreau/apple_music_analyser/blob/master/apple_music_analyser/tests/test_df.zip" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="e081" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一步，我们导入所有我们需要的模块。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="c003" class="mo ld iq mk b gy mp mq l mr ms"># import to parse an archive, save and load a pickle file<br/>from apple_music_analyser.Utility import Utility<br/> <br/># import to actually parse and process the data<br/>from apple_music_analyser.VisualizationDataframe import VisualizationDataframe<br/> <br/># import to filter the df<br/>from apple_music_analyser.Query import QueryFactory<br/> <br/># import to build visualizations<br/>from apple_music_analyser.DataVisualization import SunburstVisualization, RankingListVisualization, HeatMapVisualization, PieChartVisualization, BarChartVisualization</span></pre><p id="d98f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二步，我们只提取我们想要构建可视化的文件。假设苹果提供给你的档案在一个名为 data 的文件夹里。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="60f2" class="mo ld iq mk b gy mp mq l mr ms">path_to_archive = 'data/Apple_Media_Services.zip'<br/>input_df = Utility.get_df_from_archive(path_to_archive)</span></pre><p id="86e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果您使用 test_df.zip，请注意归档文件的结构与 Apple 归档文件的结构略有不同。正因为如此，我们需要向<em class="lb"> get_df_from_archive </em>方法传递一个额外的参数，其中包含归档的结构。像这样:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="7cce" class="mo ld iq mk b gy mp mq l mr ms">path_to_archive = 'data/test_df.zip'</span><span id="5512" class="mo ld iq mk b gy mt mq l mr ms">target_files = {<br/> 'identifier_infos_path' : 'test_df/Apple Music Activity/Identifier Information.json.zip',<br/> 'library_tracks_path' : 'test_df/Apple Music Activity/Apple Music Library Tracks.json.zip',<br/> 'library_activity_path': 'test_df/Apple Music Activity/Apple Music Library Activity.json.zip',<br/> 'likes_dislikes_path' : 'test_df/Apple Music Activity/Apple Music Likes and Dislikes.csv',<br/> 'play_activity_path': 'test_df/Apple Music Activity/Apple Music Play Activity.csv'<br/> }</span><span id="7966" class="mo ld iq mk b gy mt mq l mr ms">input_df = Utility.get_df_from_archive(path_to_archive, target_files)</span></pre><p id="12f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！<em class="lb"> input_df </em>是一个如下结构的字典:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6498" class="mo ld iq mk b gy mp mq l mr ms">{  <br/>"identifier_infos_df" : identifier_infos_df,<br/>"library_tracks_df" : library_tracks_df,<br/>"library_activity_df" : library_activity_df,<br/>"likes_dislikes_df" : likes_dislikes_df,<br/>"play_activity_df" : play_activity_df    <br/>}</span></pre><h1 id="1694" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">可视化数据帧结构</h1><p id="bea4" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">这个包定义了一个名为 VisualizationDataframe 的类来构建我们稍后将用于分析和可视化的所有对象。因此，让我们使用之前得到的<em class="lb"> input_df </em>对象实例化这个类。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="9f51" class="mo ld iq mk b gy mp mq l mr ms">viz_df_instance = VisualizationDataframe(input_df)</span></pre><p id="aae3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，基本上这个库就这样了:)现在你有了一个干净的、经过解析和处理的数据结构，还有一些你想用于分析的对象(见下面的更多细节)。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="0d9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们暂停一下。实例化 VisualizationDataframe 类的这一步可能需要几秒钟的时间，这取决于数据的大小(对于我的数万行数据来说，只需要不到 30 秒的时间)。您可能不希望每次查看数据时都进行清理、解析和处理，除非归档中的文件发生了变化！所以这里来了两个方便的函数:<strong class="kf ir">保存和加载</strong>泡菜。</p><p id="7ba9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以将 VisualizationDataframe 类的实例保存为 pickle 文件，并在以后需要再次分析/可视化数据时加载它。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="52e9" class="mo ld iq mk b gy mp mq l mr ms"># we want to save viz_df_instance, but we could decide to save only the visualization dataframe, or any other object really....<br/> Utility.save_to_pickle(viz_df_instance, 'visualization_structure.pkl')<br/> <br/> # we want to load the file that was saved<br/> saved_visualization_structure = Utility.load_from_pickle('visualization_structure.pkl')</span></pre></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="472f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，假设我们在内存中有 viz_df_instance，要么是因为我们刚刚实例化了它，要么是因为我们从 pickle 文件中加载了它。让我们访问它的一些属性！</p><p id="5926" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我认为最有用的是我称之为<strong class="kf ir">可视化数据框架</strong>。这个 pandas 数据帧包含每个播放活动的一行，尽可能多的关于每个曲目的信息，例如它的等级、所有与之相关的流派、它是否在库中、它是否被部分播放等等。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="782b" class="mo ld iq mk b gy mp mq l mr ms"># this returns the df_visualization property of the instance<br/>df_viz = viz_df_instance.get_df_viz()</span></pre><p id="e1e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个熊猫数据帧，所以你可以像操作任何熊猫数据帧一样操作它(获得它的形状，过滤一些值等等)！</p><p id="f8fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能想要访问其他对象，这些对象位于实例的<strong class="kf ir"> track_summary_objects </strong>中:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="5bc3" class="mo ld iq mk b gy mp mq l mr ms"># the list of genres<br/>genres_list = viz_df_instance.track_summary_objects.genres_list<br/> <br/># the list of titles for each artist<br/>artist_titles = viz_df_instance.track_summary_objects.artist_tracks_titles</span></pre><p id="3ef9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和计数字典(每年和流派，或年份和艺术家的歌曲计数):</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="debb" class="mo ld iq mk b gy mp mq l mr ms"># build a dictionary of counts per genre for each year<br/>genre_counts_dict = viz_df_instance.track_summary_objects.build_ranking_dict_per_year(df_viz, 'Genres')<br/> <br/># or the same dictionary but with a count per artist<br/> artist_counts_dict  = viz_df_instance.track_summary_objects.build_ranking_dict_per_year(df_viz, 'Artist')</span></pre><h1 id="993b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用查询模块</h1><p id="30aa" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">现在，假设您不想查看整个数据帧。而且假设你和熊猫在一起不是超级舒服。别担心！查询模块就是来帮你的！</p><p id="f563" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，您用您的查询参数构建一个字典，并创建查询模块的一个实例，这将为您提供一个经过<strong class="kf ir">过滤的数据框架</strong>。让我们看一个例子:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="97a4" class="mo ld iq mk b gy mp mq l mr ms"># we define the conditions of the filter<br/># so we want only songs played in 2017, 2018, 2019, that have a rating of 'LOVE' and were listened to completely<br/>query_params = {<br/> 'year':[2017, 2018, 2019],<br/> 'rating':['LOVE'],<br/> 'skippe':False<br/>}</span><span id="de2a" class="mo ld iq mk b gy mt mq l mr ms"># we get the visualization dataframe<br/>df_viz = viz_df_instance.get_df_viz()</span><span id="4c13" class="mo ld iq mk b gy mt mq l mr ms"># define the query<br/>query_instance = QueryFactory().create_query(df_viz, query_params)</span><span id="5672" class="mo ld iq mk b gy mt mq l mr ms"># get the filtered df<br/>filtered_df = query_instance.get_filtered_df()</span></pre><p id="294b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">query_parameters 字典接受以下结构:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="63b2" class="mo ld iq mk b gy mp mq l mr ms">params_dict = {<br/>   'year':list of int,<br/>   'genre':list of str,<br/>   'artist':list of str,<br/>   'title':list of str,<br/>   'rating':list of str,<br/>   'origin':list of str,<br/>   'offline':bool,<br/>   'library':bool,<br/>   'skipped':bool<br/>}</span></pre><p id="1b43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个过滤后的数据帧又是一个熊猫数据帧，你可以像往常一样操作熊猫。</p><h1 id="faf6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">玩可视化</h1><p id="dee6" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">现在有趣的来了！我不会在这里一一列举所有可能的例子，我邀请您执行来自<a class="ae kc" href="https://github.com/acoullandreau/apple_music_analyser" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>的示例脚本，您将立即看到可视化效果。</p><p id="0323" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我将向你们展示我最喜欢的两个可视化效果，因为我认为它们最有意义:旭日和热图。</p><p id="4e14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">重要提示</strong>:我们这里要使用的包中的模块是使用 Plotly 构建的，实际上只是一个<strong class="kf ir">包装器</strong>来快速获得<strong class="kf ir">简单的可视化效果</strong>，而不是 Plotly 的替代品。这个模块的每个类都有一个属性<em class="lb"> figure </em>，你会想和它交互，就像你想用 Plotly 来获得更好的可视化效果一样！</p><h2 id="2f2a" class="mo ld iq bd le nb nc dn li nd ne dp lm ko nf ng lq ks nh ni lu kw nj nk ly nl bi translated">旭日</h2><p id="dd68" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">这是表示排名的一种很好的方式。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/212837a31ac94d371867a32a09375bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUK1brY2NwaIVK-LcafFeA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">流派的旭日可视化</p></figure><p id="9ef4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有四种类型的数据，你将能够使用这种可视化排名:流派，艺术家，标题和曲目来源。</p><p id="0c36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为 sunburst 实际上提供了排名信息，我们要传递给这个类的不是数据帧，而是一个使用这个数据帧构建的排名字典:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a64d" class="mo ld iq mk b gy mp mq l mr ms"># we get the ranking dictionary<br/>ranking_dict =  viz_df_instance.track_summary_objects.build_ranking_dict_per_year(df_viz, 'Genres')</span></pre><p id="b9ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以将“流派”替换为“标题”、“艺术家”或“曲目来源”。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="713d" class="mo ld iq mk b gy mp mq l mr ms"># we create an instance of the SunburstVisualization class<br/># the second argument is the title we want to use for the plot, you can set it to whatever you want!<br/>sunburst = SunburstVisualization(ranking_dict, 'Genre')</span><span id="2117" class="mo ld iq mk b gy mt mq l mr ms"># we render the plot - note that the graph will appear in your browser automatically<br/>sunburst.render_sunburst_plot()</span></pre><h2 id="9030" class="mo ld iq bd le nb nc dn li nd ne dp lm ko nf ng lq ks nh ni lu kw nj nk ly nl bi translated">热图</h2><p id="0223" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">热图是我非常喜欢的可视化工具，因为它有助于突出活跃的日子。基本上，有两种类型的热图:</p><ul class=""><li id="dd08" class="nn no iq kf b kg kh kk kl ko np ks nq kw nr la ns nt nu nv bi translated">x 轴是月份，y 轴是日期，</li></ul><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/a42e8a5dd224c2364d67f7d93c3e600b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HaXu3wL4Ij84hYEfA1V7Hg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">一年中每月的热图</p></figure><ul class=""><li id="3c53" class="nn no iq kf b kg kh kk kl ko np ks nq kw nr la ns nt nu nv bi translated">另一个在 x 轴上画出星期几，在 y 轴上画出一天中的小时。</li></ul><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/265563bd39c2e4a7e8d5a673e38f5fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CFCjgtF1zFwGbLzDk0AlLQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">一年中一周内每天的热图</p></figure><p id="5cd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一种情况下，我们将能够计算出哪一天我们听音乐更多。第二种是白天的时候。</p><p id="c2c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">注意:如果组合 month/DOM 或 DOW/HOD 在输入数据帧中出现多次，将在每个单元格中累加收听时间。</em></p><p id="1507" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以绘制多个支线剧情，这意味着您可以比较年份(通过绘制第一种类型的热图每年的一个支线剧情)，或比较月份。</p><p id="e28b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本例中，我们绘制两张热图:</p><ul class=""><li id="e249" class="nn no iq kf b kg kh kk kl ko np ks nq kw nr la ns nt nu nv bi translated">案例 1-在两个不同的支线图上，在 x 轴上绘制 2018 年和 2019 年的月份，在 y 轴上绘制月份的日期</li><li id="9506" class="nn no iq kf b kg ny kk nz ko oa ks ob kw oc la ns nt nu nv bi translated">案例 2-在 x 轴上绘制 2019 年 2 月的星期几，在 y 轴上绘制一天中的小时</li></ul><p id="de21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">案例 1 </strong></p><p id="7f22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用一个查询字典定义我们想要绘制热图的年份(我们实际上需要每年的 filtered_df)。</p><p id="f9b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建一个 HeatMapVisualization 的实例，其中 visualization dataframe 没有被过滤(后面你会明白为什么)，还有两个子图，一个对应一年(2018，2019)。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="5b0d" class="mo ld iq mk b gy mp mq l mr ms">query_params = {<br/>     'year':[2018, 2019]<br/>}<br/>heat_map = HeatMapVisualization(df_viz, 2)</span></pre><p id="bb0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们想要绘制的每一年，我们将得到一个只包含该年元素的 filtered_df(这就是为什么我们传递整个数据帧来实例化 HeatMapVisualization)</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1e42" class="mo ld iq mk b gy mp mq l mr ms">for year in query_params['year']:<br/> <br/>   # we create a query parameters dictionary with a single year, and     all the other parameters that we had in the query_params dict    defined above<br/>   year_query_params = query_params<br/>   year_query_params['year'] = [year]<br/>   <br/>   # we get a filtered df<br/>   query_instance = QueryFactory().create_query(df_viz, year_query_params)</span><span id="9ffd" class="mo ld iq mk b gy mt mq l mr ms">   # get the filtered df<br/>   filtered_df = query_instance.get_filtered_df()<br/>   <br/>   # we replace the dataframe initially passed by the year filtered df<br/>   heat_map.df = filtered_df<br/>   <br/>   # we render a single trace, in this case for month on x-axis, and day of the month (DOM) on y-axis<br/>   heat_map.render_heat_map('DOM', str(year))</span></pre><p id="03bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后我们渲染情节</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="91d9" class="mo ld iq mk b gy mp mq l mr ms"># we render the whole figure that will contain 2 subplots, one per year, and on each the data just for that year</span><span id="a54c" class="mo ld iq mk b gy mt mq l mr ms">heat_map.figure.show()</span></pre><p id="ea8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">情节会是这样的:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/a8cfe195be58b514376e5f21b3b9a647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ufHiU28JQoc2cnvY9RibEw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">2018 年和 2019 年每月每天的热图</p></figure><p id="fe05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">案例二</strong></p><p id="e9e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用 2019 年 2 月筛选的数据帧创建一个热图实例。快速说明我们为什么这样执行过滤，仅仅是因为目前没有办法使用查询模块来查询月份…但是如果有足够多的人评论说拥有它会很棒，我可能会添加它！</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1fde" class="mo ld iq mk b gy mp mq l mr ms"># first we get a filtered dataframe on February 2019<br/>df_viz_feb_2019 = df_viz[(df_viz['Play_Year']==2019)&amp;(df_viz['Play_Month']==2)]</span><span id="0364" class="mo ld iq mk b gy mt mq l mr ms"># we create the HeatMap instance<br/>heat_map = HeatMapVisualization(df_viz_feb_2019)</span></pre><p id="c474" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们构建并呈现“DOW”(星期几)类型的绘图，图例为 2020。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="c954" class="mo ld iq mk b gy mp mq l mr ms"># generate the plot, the second argument is used as a legend<br/>heat_map.render_heat_map('DOW', 'Feb 2019')</span><span id="a3c0" class="mo ld iq mk b gy mt mq l mr ms"># display the plot rendered<br/>heat_map.figure.show()</span></pre><p id="1f31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">情节会是这样的:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/fb96b926d27a94b8e57ed9e933e915c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vc9h4QF2IZ07vabF_GSIEQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">2019 年 2 月一周每天的热图</p></figure><h1 id="325f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">最后一件事</h1><p id="4f2c" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我希望这个介绍给了你一个使用这个包的好的起点！它的目的实际上是尽可能地抽象，以便您将大部分时间花在数据分析上。</p><p id="1413" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我构建了一个全面的文档，其中包含了关于这个包的结构的更多细节，还有几个包含很多例子的文件。请随意在 GitHub 库上查看它们！</p><p id="7214" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我很乐意协助，如果你有任何问题，并知道你对这个项目的想法，请联系！</p></div></div>    
</body>
</html>