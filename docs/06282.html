<html>
<head>
<title>Geometric transformations in Computer Vision: an intuitive explanation with Python examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机视觉中的几何变换:Python 示例的直观解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/geometric-transformations-in-computer-vision-an-intuitive-explanation-with-python-examples-b0b6f06e1844?source=collection_archive---------21-----------------------#2020-05-20">https://towardsdatascience.com/geometric-transformations-in-computer-vision-an-intuitive-explanation-with-python-examples-b0b6f06e1844?source=collection_archive---------21-----------------------#2020-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ea9d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">旋转，平移和缩放转换解码。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3b0cedc696ffd19890b7d16b73a659e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mr3rIw-d-flNTchm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">佩顿·塔特尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f6fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几何变换是任何图像处理流水线中最常见的变换操作之一。在今天的帖子中，我们将看看其中的三种变换:<a class="ae ky" href="https://en.wikipedia.org/wiki/Rotation" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">旋转</strong> </a> <strong class="lb iu">，</strong> <a class="ae ky" href="https://en.wikipedia.org/wiki/Translation_(geometry)" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">平移</strong> </a> <strong class="lb iu">和</strong> <a class="ae ky" href="https://en.wikipedia.org/wiki/Image_scaling" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">缩放</strong> </a> <strong class="lb iu"> </strong>，然后<strong class="lb iu"> </strong>仅使用 Numpy 从头开始构建它们。图 1 显示了我们想要实现的视觉效果。所以，<a class="ae ky" href="https://translate.google.com/#view=home&amp;op=translate&amp;sl=de&amp;tl=en&amp;text=los%20geht's" rel="noopener ugc nofollow" target="_blank"> <em class="lv">洛戈特！</em> </a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/78b5db4709b67e760850cb318be31a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1yzQfcAyG6zr27U3E0XE0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 1 我们的目标是将图像 a 顺时针旋转 45 度，以创建图像 b .来自带有 CC 许可证的<a class="ae ky" href="http://cocodataset.org/#home" rel="noopener ugc nofollow" target="_blank"> COCO 数据集</a>的参考图像</p></figure><h1 id="8f90" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">OpenCV 方式</h1><p id="b9cc" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">如果你使用任何图像库，如 OpenCV 或<a class="ae ky" href="https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.transform" rel="noopener ugc nofollow" target="_blank"> PIL </a>内置函数，实现上述功能是非常简单的。使用 OpenCV，我们可以用两行代码来完成，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 OpenCV 旋转图像</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/b12b39e925d6f47a3f40b9680cf6d070.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*4Ivq9yM1w7RrcMz2Emi5rQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 2 固定边界的旋转</p></figure><p id="5f29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到的结果如图 2 所示。请注意，OpenCV 不会自动扩展图像的边界。为了确保我们看到整个旋转的图像，我们需要做另外两件事。首先，计算目标图像的大小，其次，由于新图像的中心不同于原始中心，我们需要考虑旋转矩阵中中心值的差异。有了这些补充，我们就是黄金！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/dfd1b86117a3fe2dcc37c13b96e449a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*5gKFXfWwywG_efeyNKaaiQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用动态边界旋转</p></figure><p id="0c47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次旋转包括了我们预期的整个图像！让我们来分析一下这些函数调用背后到底发生了什么。</p><h1 id="8847" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">旋转矩阵</h1><p id="6ee6" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们使用上面的<a class="ae ky" href="https://docs.opencv.org/2.4/modules/imgproc/doc/geometric_transformations.html#getrotationmatrix2d" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">getrotationmatrix 2d()</strong></a><strong class="lb iu"/>方法(片段 1 第 5 行)来创建一个旋转矩阵，我们稍后使用它来扭曲原始图像(片段 1 第 6 行)。这个函数以图像中心、旋转角度和缩放因子作为参数，并给出一个旋转矩阵。<strong class="lb iu">这个</strong> <a class="ae ky" href="https://en.wikipedia.org/wiki/Rotation_matrix" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">旋转矩阵</strong> </a> <strong class="lb iu">到底是什么？嗯，它源于线性代数。让我们考虑一个任意的 2D 点[x，y]，那么旋转运算可以用下面的矩阵运算来表示。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/62ded4cfc3eac2133ce82763b9d4750d.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*aRMtgHoFIIM2UDrEnSRnzQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">2D 旋转变换</p></figure><p id="9549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中，R 是旋转矩阵</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d0d7cc33a0f04385ae61b75f591b4e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*hI-STyaLV9JoFe0ed2yLwA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">旋转矩阵 R</p></figure><p id="1c58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更简单地说，旋转矩阵给出了“函数 f”<strong class="lb iu"><em class="lv">x’，y’= f(x，y) </em> </strong>将输入点映射到其旋转的对应点。矩阵 R 由两个列向量组成，表示我们的初始基向量在转换后的最终位置(如果你像我一样是一个 3blue1brown 的粉丝，这将立即敲响警钟！).</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d4d8b6b8d9d74421f8bb8fbf3b7c71b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*8oFOoawtCHeglebMnN9ryA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点旋转示例</p></figure><p id="9960" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用单位圆把事情说得更清楚些。</p><p id="cf04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个单位圆中，考虑头部在 B = [1，0]的两个向量<strong class="lb iu"> u </strong>和头部在 D [0，1]的两个向量<strong class="lb iu"> w </strong>。然后，这些向量围绕中心 A(=原点= [0，0])旋转某个角度θ<em class="lv">、</em>(<em class="lv">=φ</em>)，之后它们分别落在 C 点和 E 点。</p><p id="65b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过变换后，向量 v 可以用其分别以 F 和 H 为头的正交投影向量来表示。使用基本的三角学并记住向量 v 和 a 具有单位长度，可以容易地看出，以 F 为头的向量的长度是<strong class="lb iu"> b = <em class="lv"> cos(theta) </em> </strong>，以 H 为尾的向量的长度是<strong class="lb iu"> d= sin(theta) </strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/017bbeed049c169640056204822d3d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*GZARSvw2NkWhuFnd-jgx7Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">导出向量 v 的正交分量</p></figure><p id="3afc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向量 v 因此可以表示为列向量<strong class="lb iu"><em class="lv">【cos(theta)sin(theta)】</em></strong><em class="lv">。</em>同样，我们可以证明，向量 a 可以表示为列向量<strong class="lb iu"><em class="lv">[-sin(theta)cos(theta)】</em></strong>。<strong class="lb iu">负号表示方向。</strong></p><p id="5297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这些列向量放在一起，我们得到了旋转矩阵 r。<strong class="lb iu">为了简化矩阵乘法，通常在旋转矩阵中添加第三个轴。</strong>直觉上，这将是旋转 3D 结构的旋转轴。该轴上的所有点在变换后将保持不变，因此该附加轴对剩余的变换没有净影响。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/a1c4d8eb3ff2b728ec6d416a799678d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*B6j3ZjxK5yjhFwHQKDvG_A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">旋转变换</p></figure><p id="2ea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，平移操作可以由下面所示的平移矩阵来表示，其中<strong class="lb iu"> <em class="lv"> tx </em> </strong>和<strong class="lb iu"> <em class="lv"> ty </em> </strong>是 X 和 Y 方向上的平移量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8e20af2ddd85018de41970ed6cbbd819.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*vm1KHobdgqhfO-ACL9LtfQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">平移变换</p></figure><p id="98bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有我们的缩放矩阵，其中<strong class="lb iu"><em class="lv">Sx</em></strong>ans<strong class="lb iu"><em class="lv">Sy</em></strong>是我们在 x 和 y 方向的缩放因子</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/1dd284e491be935bdb2832b4c30ad502.png" data-original-src="https://miro.medium.com/v2/resize:fit:288/format:webp/1*sEfi0HYhzNKtpO0kZxHILw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缩放变换</p></figure><blockquote class="nf ng nh"><p id="8a15" class="kz la lv lb b lc ld ju le lf lg jx lh ni lj lk ll nj ln lo lp nk lr ls lt lu im bi translated">注意:通常，旋转和平移被组合成如下所示的单个变换矩阵。这与绕原点旋转θ然后平移<strong class="lb iu"> <em class="it"> tx </em> </strong>和<strong class="lb iu"> <em class="it"> ty </em> </strong>的效果相同</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/131f5a8c13b55d648a660e0758ccd6b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*Fh6ya5UV9xmAlFp8gII79Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">旋转和平移操作打包到一个矩阵中</p></figure><blockquote class="nf ng nh"><p id="fb22" class="kz la lv lb b lc ld ju le lf lg jx lh ni lj lk ll nj ln lo lp nk lr ls lt lu im bi translated">试试吧！取上面任意一个矩阵，给它们一些值乘以任意一个点<em class="it">【x，y】</em>看看变换后的点值是不是你所期望的！</p></blockquote><p id="456b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有了表达几何变换的所有必要成分。请记住几件重要的事情:</p><ol class=""><li id="8b59" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">矩阵乘法是不可交换的也就是说，如果你将两个矩阵 A 和 B 相乘，A.B！因此，我们变换的顺序很重要。旋转一个点然后平移和先平移那个点然后旋转相同的因子是不一样的！</li><li id="2bb2" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><strong class="lb iu">变换表达式的矩阵乘法是从右向左进行的。</strong></li><li id="a722" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">注意你的坐标轴，因为方向很重要。像 OpenCV 这样的大部分图像框架都是考虑左上角的原点。这不是我们写方程的经典的“第一象限”，而是“第四象限”。实质上，y 轴的方向是反向的。我们可以将它直接放入旋转矩阵中，或者在计算过程中添加一个负号(我做第二个是为了保持转换操作与文献一致)。</li><li id="d10d" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><strong class="lb iu">旋转一般是围绕图像中心进行的。</strong></li></ol><p id="f0ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，现在让我们回到我们的原始图像，看看我们需要做什么来得到想要的转换图像。操作的确切顺序如下:</p><ol class=""><li id="2a29" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">平移图像，使图像的中心为原点。这是因为我们希望通过图像的中心而不是左上角来旋转图像，左上角通常是图像中的原点像素/坐标。让我们把这些翻译因子设为<strong class="lb iu">【tx1，tx2】。</strong></li><li id="c946" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">将图像旋转我们想要的角度<strong class="lb iu">θ。</strong></li><li id="ffe8" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">将图像平移回其原始中心。让我们把这个概括为<strong class="lb iu">【tx2，ty2】。</strong></li><li id="48cf" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">计算新的中心，并利用这些新的和旧的中心之间的差异来平移图像。还要考虑新图像的大小。(我们已经为 OpenCV 计算完成了这一步)。设这些平移因子为<strong class="lb iu">【CX _ shift，cy_shift】。</strong></li></ol><p id="f2f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用矩阵的方式，我们可以将上述四个步骤表达如下。从右到左，我们将中心平移到原点(右数第一个矩阵)，绕中心旋转并平移回中心(中心矩阵)，最后调整新维度的中心(左数第一个矩阵)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/0d5413ab747888b4f3925e47c0963274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlHuugtPeuMBPORK842Rtg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的转换矩阵</p></figure><p id="f2e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里没有使用缩放变换，但是如果你也想缩放你的图像，只需要把缩放变换加到上面的等式中(在正确的地方！).简化上述内容并替换<strong class="lb iu">a = cos(θ)</strong>，<strong class="lb iu">b = sin(θ)</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/f6cfbd25985d5a8f542183e902d51105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*lK05VRx57zff-ePnVdI2sw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简化变换矩阵</p></figure><p id="07be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们最终的旋转矩阵，我们将在下一节中使用 Numpy 来旋转我们的图像。</p><h1 id="6698" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">数字之路</h1><p id="2101" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">调用 OpenCV 方法既快速又简单，但是一点也不好玩！因此，我们将把我们讨论的所有内容放入代码中，并使用 Numpy 旋转图像！</p><p id="a8b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这个脚本有点太长，无法粘贴到这里，请点击下面的链接查看完整代码。</p><div class="oc od gp gr oe of"><a href="https://github.com/borarak/imutils/blob/master/geometric/rotate.py" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">博拉克/伊穆蒂尔斯</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">成像实用程序脚本。在 GitHub 上创建一个帐户，为 borarak/imutils 的发展做出贡献。</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div><p id="4d4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这之后，我们可以使用自己的函数旋转和平移图像！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="fa73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天就到这里，希望你喜欢。一如既往的感谢阅读！</p></div></div>    
</body>
</html>