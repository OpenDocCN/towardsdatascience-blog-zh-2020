<html>
<head>
<title>3 Approaches To Building A Recommendation System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建推荐系统的 3 种方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-approaches-to-build-a-recommendation-system-ce6a7a404576?source=collection_archive---------5-----------------------#2020-09-17">https://towardsdatascience.com/3-approaches-to-build-a-recommendation-system-ce6a7a404576?source=collection_archive---------5-----------------------#2020-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9955" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python 推荐系统入门</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7ba5eda5934aaf6323ce3c83f41018a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OwJq2qKpJ3zgT4MU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@slidebean?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Slidebean </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="4651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毫无疑问，推荐系统是在各种平台上增强用户体验的最明显的方式之一，也是将机器学习引入公司的一种方式。因此，许多公司一直在采用“<em class="lv">为你推荐</em>”的口号，这一口号已被亚马逊、网飞和 Youtube 等公司推广开来，它们通过实施自己版本的推荐来满足客户需求。</p><p id="e724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在讨论各种实现方法之前，我们首先将推荐系统定义为一种在将信息呈现给人类用户之前从信息流中丢弃冗余或无用信息的方法，或者更具体地说，它是一种信息过滤系统的子类，旨在预测用户对某个项目的“评级”或“偏好”(来源:<a class="ae ky" href="https://en.wikipedia.org/wiki/Recommender_system#:~:text=A%20recommender%20system%2C%20or%20a,would%20give%20to%20an%20item." rel="noopener ugc nofollow" target="_blank">维基百科</a>)。</p><p id="0c8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些知识，我们可以开始研究解决这个问题的一些方法了——关于这篇文章中生成的完整代码，请访问 my <a class="ae ky" href="https://github.com/kurtispykes/recommender_system/blob/master/notebooks/02_kpy_ideas.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Github </strong> </a> <strong class="lb iu">。</strong></p><div class="lw lx gp gr ly lz"><a href="https://github.com/kurtispykes/recommender_system/blob/master/notebooks/02_kpy_ideas.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">kurtispykes/推荐系统</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">permalink dissolve GitHub 是超过 5000 万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">github.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ks lz"/></div></div></a></div><p id="c269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的演示中，我们将使用<a class="ae ky" href="https://grouplens.org/datasets/movielens/100k/" rel="noopener ugc nofollow" target="_blank"> MovieLens 100k 数据集</a>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="cd65" class="mv mw it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">协同过滤</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/413880309fe6bbca92cbf317137c0f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o3WMrfmhy2664Ajq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·施诺布里奇在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="cf5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协同过滤是推荐引擎最流行的实现之一，它基于这样的假设，即过去达成一致的人将来也会达成一致，因此他们会像过去一样喜欢相似种类的项目。</p><p id="d1bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协同过滤的一个例子可以是，一个朋友和我过去喜欢相同范围的书，并且他/她接着喜欢我没有读过的书，但是因为我们过去同意并且他/她喜欢我没有读过的新书，所以很可能我也会喜欢那本书，所以那本书会被推荐给我。该逻辑描述了所谓的基于用户的协同过滤。</p><p id="ca86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从前面的例子来看，不是仅仅关注我的朋友喜欢什么，我们可以决定关注以前喜欢的项目的范围，并确保基于过去喜欢的项目之间的相似性向我推荐新的项目，其中相似性是通过使用项目的评级来计算的——“喜欢这个项目的用户也喜欢”。这种算法背后的逻辑被称为基于<em class="lv">项目的</em>协同过滤。</p><p id="6001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，这两种方法都属于协作过滤的范畴，即基于记忆的方法。让我们看一个 Python 中基于内存的方法的例子。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="2ca7" class="mv mw it nq b gy nu nv l nw nx">import numpy as np<br/>import pandas as pd<br/>from sklearn.metrics import mean_squared_error, pairwise</span><span id="2a81" class="mv mw it nq b gy ny nv l nw nx"># creating n x m matrix where n is user_id and m is item_id <br/>user_ratings = pd.pivot_table(rating, index="user_id", columns="item_id", values="rating").fillna(0)</span><span id="0fb6" class="mv mw it nq b gy ny nv l nw nx"># user and item counts <br/>n_users = len(user_ratings.index)<br/>n_items = len(user_ratings.columns)</span><span id="efdd" class="mv mw it nq b gy ny nv l nw nx"><strong class="nq iu">print</strong>(f"Users: {n_users}\nItems: {n_items}")<br/>user_ratings.head()</span><span id="020f" class="mv mw it nq b gy ny nv l nw nx">Users: 943<br/>Items: 1682</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/53b3663d4ad5f1888c06f090fe6e1a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aAZH3YqCETKzKTSZjRy1Sw.png"/></div></div></figure><p id="4e0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了所需格式的数据，我将随机生成一个训练和测试集，我们可以用它来测试我们的方法做得有多好。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="79b4" class="mv mw it nq b gy nu nv l nw nx"># <a class="ae ky" href="https://www.ethanrosenthal.com/2015/11/02/intro-to-collaborative-filtering/" rel="noopener ugc nofollow" target="_blank">https://www.ethanrosenthal.com/2015/11/02/intro-to-collaborative-filtering/</a> </span><span id="0aef" class="mv mw it nq b gy ny nv l nw nx">def train_test_split(data: np.array, n_users: int, n_items:int): <br/>    # create a empty array of shape n x m for test<br/>    test = np.zeros((n_users, n_items))<br/>    train = data.copy()<br/>    <br/>    # for each user, we generate a random sample of 5 from movies they've watched<br/>    for user in range(n_users):<br/>        random_sample = np.random.choice(data[user, :].nonzero()[0], <br/>                                         size=5, <br/>                                         replace=False)<br/>        # set the train to zero to represent no rating and the test will be the original rating<br/>        train[user, random_sample] = 0. <br/>        test[user, random_sample] = data[user, random_sample]<br/>        <br/>    return train, test</span><span id="1bba" class="mv mw it nq b gy ny nv l nw nx">train, test = train_test_split(data=user_ratings.to_numpy(), n_users=n_users, n_items=n_items)</span></pre><p id="09f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建协同过滤系统的第一步是计算用户(基于用户)或项目(基于项目)之间的相似性。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="72a4" class="mv mw it nq b gy nu nv l nw nx">user_similarity = pairwise.cosine_similarity(train + 1e-9)<br/>item_similarity = pairwise.cosine_similarity(train.T + 1e-9)</span><span id="a7da" class="mv mw it nq b gy ny nv l nw nx"><strong class="nq iu">print</strong>(user_similarity.shape, item_similarity.shape)</span><span id="2721" class="mv mw it nq b gy ny nv l nw nx">(943, 943) (1682, 1682)</span></pre><p id="aa4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是预测数据中未包含的评级。一旦我们做出了预测，我们就可以将我们的结果与实际测试数据进行比较，以评估我们模型的质量——评估指标超出了本教程的范围。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="1ae0" class="mv mw it nq b gy nu nv l nw nx"># predict user ratings not included in data<br/>user_preds = user_similarity.dot(train) / np.array([np.abs(user_similarity).sum(axis=1)]).T</span><span id="9250" class="mv mw it nq b gy ny nv l nw nx"># # get the nonzero elements<br/>nonzero_test = test[test.nonzero()]<br/>nonzero_user_preds = user_preds[test.nonzero()]</span><span id="e8fe" class="mv mw it nq b gy ny nv l nw nx">user_rating_preds = mean_squared_error(nonzero_test, nonzero_user_preds)<br/><strong class="nq iu">print</strong>(f"UBCF Mean Squared Error: {user_rating_preds}")</span><span id="6807" class="mv mw it nq b gy ny nv l nw nx">UBCF Mean Squared Error: 8.250006012927786</span></pre><p id="5ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码是一个基于用户的协同过滤的例子。我们还可以进行基于项目的协同过滤。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="ab73" class="mv mw it nq b gy nu nv l nw nx"># predict item ratings not included in data<br/>item_preds = train.dot(item_similarity) / np.array([np.abs(item_similarity).sum(axis=1)])</span><span id="c37e" class="mv mw it nq b gy ny nv l nw nx"># get the nonzero elements<br/>nonzero_item_preds = item_preds[test.nonzero()]</span><span id="af56" class="mv mw it nq b gy ny nv l nw nx">item_rating_preds = mean_squared_error(nonzero_test, nonzero_item_preds)<br/><strong class="nq iu">print</strong>(f"IBCF Mean Squared Error: {item_rating_preds}")</span><span id="4548" class="mv mw it nq b gy ny nv l nw nx">IBCF Mean Squared Error: 11.361431844412557</span></pre><p id="0769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的算法不是很好，但希望你能明白其中的要点！</p><p id="e660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在知道基于协作的方法可能被分类为基于<em class="lv">内存的</em>，我们已经在上面看到了它的 Python 实现。我们可以对协同过滤方法进行分类的另一种方式是基于模型的方法。</p><p id="efcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种方法中，使用不同的数据挖掘、机器学习算法来开发模型，以预测用户对未评级项目的评级(来源:<a class="ae ky" href="https://en.wikipedia.org/wiki/Collaborative_filtering#Model-based" rel="noopener ugc nofollow" target="_blank">维基百科</a>)。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="eabf" class="mv mw it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">基于内容的过滤</h2><p id="bcb9" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">另一种向用户推荐有用信息的流行方式是通过基于内容的过滤。这种技术基于项目的描述和用户偏好的简档。它最适合于这样的情况:已知一个项目的信息，但不知道用户的很多信息。因此，基于内容的过滤方法将推荐视为用户特定的分类问题。</p><p id="a70d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于内容的过滤的一个例子可以通过使用电影推荐场景来解释。想象一下，我们已经建立了一个相当新的网站，我们目前没有太多的用户信息，但我们确实有关于我们积压的电影的细节。我们要做的是获取电影的元数据/特征，如类型、演员、导演、电影长度等，并使用它们作为输入来预测用户是否喜欢一部电影。</p><p id="ccb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的场景也暗示了我们有一个偏好的用户配置文件。这些数据可以通过用户询问来收集，这意味着用户可以设置他或她的过滤偏好，或者通过记录用户行为作为一种隐含的方法来收集。</p><blockquote class="of og oh"><p id="f591" class="kz la lv lb b lc ld ju le lf lg jx lh oi lj lk ll oj ln lo lp ok lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:您也可以使用混合方法来获得最佳数据收集策略。</p></blockquote><p id="4487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何在 Python 中做到这一点…</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="6d47" class="mv mw it nq b gy nu nv l nw nx"># merge data so we know the features of each movie<br/>movies = pd.merge(item, rating, right_on="item_id", left_on="movie_id")</span><span id="df95" class="mv mw it nq b gy ny nv l nw nx"># create a pivot table<br/>movies_pivot = pd.pivot_table(movies, index="user_id", columns="movie_title", values="rating")</span><span id="30e4" class="mv mw it nq b gy ny nv l nw nx"># Transpose only so it fit's in the screen<br/>movies_pivot.T.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/aca9fe944c4d80ddda093bc4e6b94582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2qFC6ZpsSESSongAQPn4g.png"/></div></div></figure><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b17a" class="mv mw it nq b gy nu nv l nw nx"># avg ratings and rating counts<br/>avg_rating = movies.groupby("movie_title")["rating"].mean()<br/>num_ratings = movies.groupby("movie_title")["rating"].count()</span><span id="0239" class="mv mw it nq b gy ny nv l nw nx"># getting counts and average ratings<br/>ratings_counts = pd.DataFrame({"avg_rating": avg_rating,<br/>                               "num_of_ratings": num_ratings})</span><span id="2483" class="mv mw it nq b gy ny nv l nw nx"># joining the new values to movie data<br/>full_movie_data = pd.merge(movies, ratings_counts, left_on="movie_title", right_index=True)</span><span id="c056" class="mv mw it nq b gy ny nv l nw nx"># <a class="ae ky" rel="noopener" target="_blank" href="/recommender-system-in-python-part-2-content-based-system-693a0e4bb306">https://towardsdatascience.com/recommender-system-in-python-part-2-content-based-system-693a0e4bb306</a></span><span id="8d6d" class="mv mw it nq b gy ny nv l nw nx">def get_similar_movies(full_movie_data: pd.DataFrame,<br/>                       movie_matrix: pd.DataFrame,<br/>                       movie_title: str,<br/>                       min_num_of_ratings: int = 100,<br/>                       n_recommendations: int = 5<br/>                       ):<br/>    """<br/>    Get similar movies based on correlation with other movies <br/>    """<br/>    # get most correlated movies<br/>    similar_movies = movie_matrix.corrwith(movie_matrix[movie_title])<br/>    # converting to a dataframe and dropping NaN's<br/>    similar_corr_df = pd.DataFrame({"correlation":similar_movies})<br/>    similar_corr_df.dropna(inplace=True)<br/>    <br/>    # store the oringinal dataframe<br/>    orig = full_movie_data.copy()<br/>    <br/>    # merge with correlated dataframe but only keep specified columns<br/>    corr_with_movie = pd.merge(left=similar_corr_df,<br/>                               right=orig, <br/>                               on="movie_title")[<br/>        ["movie_title", "correlation", "avg_rating", "num_of_ratings"]].drop_duplicates().reset_index(drop=True)<br/>    <br/>    # filter movies with less than min_num_of_ratings<br/>    result = corr_with_movie[corr_with_movie['num_of_ratings'] &gt; min_num_of_ratings].sort_values(<br/>                                                                                     by='correlation',<br/>                                                                                     ascending=False)<br/>    return result.iloc[1:, :].head()</span><span id="5d1c" class="mv mw it nq b gy ny nv l nw nx"># test function on Toy Story<br/>get_similar_movies(full_movie_data, movies_pivot, "Toy Story (1995)")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/c55e9769fa08fe8bb2dcb90407ecf12b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9pQEwKSvgNm-KVlqyTza-A.png"/></div></div></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="a51b" class="mv mw it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">混合推荐系统</h2><p id="f3c4" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">混合系统在现实世界中更为常见，因为组合来自不同方法的组件可以克服各种传统缺点；在这个例子中，我们更具体地讨论来自协作过滤和基于内容的过滤的混合组件。</p><p id="c3c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由郑 KY，帕克 DH，李 JH (2004) [1]的论文陈述“为了有效，推荐系统必须很好地处理两个基本问题。第一，稀疏评级问题；与需要预测的评级数量相比，已经获得的评级数量非常小。因此，从少量示例中有效生成是重要的。当用户数量很少时，这个问题在系统的启动阶段尤其严重。第二，第一流的问题；除非用户以前对某个项目进行过评级，否则无法推荐该项目。</p><blockquote class="on"><p id="48d7" class="oo op it bd oq or os ot ou ov ow lu dk translated">这种方法可以显著改善推荐系统的预测。</p></blockquote><p id="a837" class="pw-post-body-paragraph kz la it lb b lc ox ju le lf oy jx lh li oz lk ll lm pa lo lp lq pb ls lt lu im bi translated">作为给读者的任务，建立你自己的混合推荐系统！(完成后与我分享)</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="6b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]荣凯。，朴 DH。李·JH。(2004) <em class="lv">混合协同过滤和基于内容过滤的改进推荐系统</em>。载于:Bubak M .、van Albada G.D .、Sloot P.M.A .、Dongarra J .(编辑)计算科学-ICCS，2004 年。ICCS 2004。计算机科学讲义，第 3036 卷。斯普林格，柏林，海德堡。【https://doi.org/10.1007/978-3-540-24685-5_37 T4】</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="2b1e" class="mv mw it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">包裹</h2><p id="2abb" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">在这篇文章中，我们介绍了三种实用的推荐系统方法，以及如何使用 Python 实现其中的两种(协同过滤和基于内容的推荐)。我知道我没有深入研究算法背后的理论或性能指标来评估它们，但如果你想更深入地了解这些专长，那么我强烈推荐 Youtube 上的<a class="ae ky" href="https://www.youtube.com/watch?v=giIXNoiqO_U&amp;list=PL-6SiIrhTAi6x4Oq28s7yy94ubLzVXabj" rel="noopener ugc nofollow" target="_blank">吴恩达推荐系统</a>播放列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="f7e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续 LinkedIn 上的对话…</p><div class="lw lx gp gr ly lz"><a href="https://www.linkedin.com/in/kurtispykes/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">Kurtis Pykes -人工智能作家-走向数据科学| LinkedIn</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">在世界上最大的职业社区 LinkedIn 上查看 Kurtis Pykes 的个人资料。Kurtis 有两个工作列在他们的…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">www.linkedin.com</p></div></div><div class="mi l"><div class="pe l mk ml mm mi mn ks lz"/></div></div></a></div></div></div>    
</body>
</html>