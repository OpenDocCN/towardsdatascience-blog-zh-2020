<html>
<head>
<title>Mastering Pandas Groupby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握熊猫小组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mastering-pandas-groupby-efc6600d093?source=collection_archive---------25-----------------------#2020-04-02">https://towardsdatascience.com/mastering-pandas-groupby-efc6600d093?source=collection_archive---------25-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2abd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解 Groupby 方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/194170f7d2b3960380c38c9021f79b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6CLy9bPFV7srVtkbEmcHWQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/photo/crowd-reflection-color-toy-1679618/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="6482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas 是一个 python 库，提供数据转换和统计分析工具。pandas 中的“groupby”方法允许我们对大量数据进行分组，并对这些组执行操作。在本帖中，我们将讨论如何在熊猫中使用“分组”方法。出于我们的目的，我们将使用<em class="lv">全球冠状病毒数据集</em>，它可以在<a class="ae ky" href="https://www.kaggle.com/de5d5fe61fcaa6ad7a66/coronavirus-dataset-update-0206" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="1fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><p id="f932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将名为“2019-nCoV-cases-JHU.csv”的文件读入一个熊猫数据框:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="88a0" class="mb mc it lx b gy md me l mf mg">import pandas as pd <br/>df = pd.read_csv("2019-nCoV-cases-JHU.csv")</span></pre><p id="5fe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们打印前五行数据:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9c97" class="mb mc it lx b gy md me l mf mg">print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/feb7c82d9d214fcedf047e53a27e10cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gnuC81pbeO9TZtw0EBl2qQ.png"/></div></div></figure><p id="82a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，让我们将数据限制为仅包括美国的记录:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="46aa" class="mb mc it lx b gy md me l mf mg">df = df[df['Region'] == 'US'] #filter to only include US data<br/>df.reset_index(inplace = True) #reset index<br/>del df['index'] # remove old index<br/>print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/32b7e49f7c298beb46c29cc57151b5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZEvBoszz7sV80lny6NO_g.png"/></div></div></figure><p id="0912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可能不需要考虑“省”的“未分配位置(来自钻石公主)”值，所以我们也把它去掉:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="1d8d" class="mb mc it lx b gy md me l mf mg">df = df[df['Province'] != 'Unassigned Location (From Diamond Princess)']<br/>print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/c92c585b9b98af2efab130e843594b1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3STBHKSBzWsBO565Cete8Q.png"/></div></div></figure><p id="73ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们通过提取“省”列中字符串值的最后两个字符来创建一个“州”列:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="41a3" class="mb mc it lx b gy md me l mf mg">df['State'] = df['Province'].str[-2:]</span></pre><p id="6194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以做一些类似的事情来创建一个“县”列。让我们提取“省”列中字符串值的所有字符，不包括最后 4 个字符:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="e65c" class="mb mc it lx b gy md me l mf mg">df['County'] = df['Province'].str[:-4]<br/>print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/d22db5fbe4ad726fb98bb1148378421e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SsSYZ4Yo-83aF9FS-Cb2g.png"/></div></div></figure><p id="589e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们将日期列转换成熊猫的“日期时间”:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="6dc7" class="mb mc it lx b gy md me l mf mg">df['Date'] = pd.to_datetime(df['Date'], format ='%m/%d/%Y %H:%M')</span></pre><p id="f7a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在处于执行一些有趣的“分组”操作的有利位置。让我们在州级生成一些对应于数字列值的统计数据，如死亡、确诊病例和恢复。</p><p id="865d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，让我们首先在州级执行“分组”:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="02e6" class="mb mc it lx b gy md me l mf mg">gb = df.groupby('State')</span></pre><p id="4f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们创建了一个“groupby”对象。接下来我们可以做的是拉一个特定的组。我们可以使用“get_group”方法来实现这一点。让我们得到对应于 CA 的组，并将索引设置为日期:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="5d06" class="mb mc it lx b gy md me l mf mg">df_ca = gb.get_group('CA').set_index('Date')<br/>print(df_ca.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/a84a986700de100d4b56146d14b279a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bn9Xkt6E9TdP8dgiAjPBsw.png"/></div></div></figure><p id="ba53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以迭代“groupby”对象，并为每个州创建一个包含一列的数据框:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="8527" class="mb mc it lx b gy md me l mf mg">deaths = pd.DataFrame()<br/>for name, group in df.groupby('State'):<br/>    if deaths.empty:<br/>        deaths = group.set_index('Date')[["Deaths"]].rename(columns={"Deaths": name})<br/>    else:<br/>        deaths = deaths.join(group.set_index('Date')[["Deaths"]].rename(columns={"Deaths": name}))</span></pre><p id="eed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们打印包含分组死亡统计数据的结果数据框:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="20b8" class="mb mc it lx b gy md me l mf mg">print(deaths.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/b9b043a570fd881756786c162cc4e6fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Kw1_6xBFpXjIOSbKkr3dg.png"/></div></div></figure><p id="b6d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，该数据包含有限数量的状态。我们还可以使用 describe 方法来获得关于新数据的基本统计信息:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="1315" class="mb mc it lx b gy md me l mf mg">death_stats = deaths.describe()<br/>death_stats = death_stats.astype(int)<br/>print(death_stats)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/8db1920543e2edc40cbc63326c0f81da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2R70rwvtsmEu2rkCmGXM-A.png"/></div></div></figure><p id="66ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，计数对应于行数。我们还有死亡人数的平均值、标准差、百分位数、最小值和最大值。请注意，该数据中的最新记录对应于 2020 年 3 月 3 日，这是在病例大规模爆发之前。我们可以定义一个函数，为给定的数字列自动生成这些统计信息:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="b57a" class="mb mc it lx b gy md me l mf mg">def get_statistics(column_name):<br/>    column_df = pd.DataFrame()<br/>    <br/>    for name, group in df.groupby('State'):<br/>        if column_df.empty:<br/>            column_df = group.set_index('Date')[[column_name]].rename(columns={column_name: name})<br/>        else:<br/>            column_df = column_df.join(group.set_index('Date')[[column_name]].rename(columns={column_name: name}))<br/><br/>    column_df.fillna(0, inplace = True)    <br/>    <br/>    column_stats = column_df.describe()<br/>    column_stats = column_stats.astype(int)<br/>    print(column_stats)</span></pre><p id="6993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用“已确认”列作为输入来调用这个函数:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="4f40" class="mb mc it lx b gy md me l mf mg">get_statistics("Confirmed")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/4eedd8ae5195c2b26c3f94786b7679a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZS1z-ZtMTE4MwEU5BqCc1g.png"/></div></div></figure><p id="aab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且恢复了:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="0a54" class="mb mc it lx b gy md me l mf mg">get_statistics("Recovered")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/e7b4216e998ef19cd2a72817a46e822d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FGtUodHmGQBizen_1q-Ong.png"/></div></div></figure><p id="fccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以将索引设置为天数。让我们创建一个日列，并使用日编号作为索引为“已确认”列生成分组统计信息:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="4550" class="mb mc it lx b gy md me l mf mg">df['Day'] = df['Date'].dt.day</span><span id="f7d6" class="mb mc it lx b gy mq me l mf mg">def get_statistics_day(column_name):<br/>    column_df = pd.DataFrame()<br/>    <br/>    for name, group in df.groupby('State'):<br/>        if column_df.empty:<br/>            column_df = group.set_index('Day')[[column_name]].rename(columns={column_name: name})<br/>        else:<br/>            column_df = column_df.join(group.set_index('Day')[[column_name]].rename(columns={column_name: name}))<br/><br/>    column_df.fillna(0, inplace = True)    <br/>    <br/>    column_stats = column_df.describe()<br/>    column_stats = column_stats.astype(int)<br/>    print(column_stats)</span><span id="ce72" class="mb mc it lx b gy mq me l mf mg">get_statistics_day("Confirmed")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/a810b62ae3158baf82a3e9ad9f8477c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7_d8195XsBli_g0nntAiA.png"/></div></div></figure><p id="987c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是对应于各州每日确诊病例的统计数据。我就讲到这里，但我鼓励您继续研究代码和数据。例如，您可以尝试在县一级生成这些统计数据。您只需将“groupby('State ')”更改为“groupby('County ')”。</p><h2 id="d564" class="mb mc it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">结论</h2><p id="d14f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">总之，在这篇文章中，我们讨论了如何使用熊猫的“分组”方法。我们对冠状病毒引起的美国确诊病例、康复和死亡进行了分组统计。我们使用日期时间值和天数值作为索引来生成这些统计数据。我希望你觉得这篇文章有用/有趣。这篇文章的代码可以在 GitHub 上找到。感谢您的阅读！</p></div></div>    
</body>
</html>