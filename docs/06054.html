<html>
<head>
<title>Your Ultimate Data Manipulation &amp; Cleaning Cheat Sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您的终极数据操作和清理备忘单</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/your-ultimate-data-manipulation-cleaning-cheat-sheet-731f3b14a0be?source=collection_archive---------24-----------------------#2020-05-17">https://towardsdatascience.com/your-ultimate-data-manipulation-cleaning-cheat-sheet-731f3b14a0be?source=collection_archive---------24-----------------------#2020-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8fab04080cb3a364ce7740482c43b0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StMmr5FS0oU0w8km41uraQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">资料来源:Unsplash。</p></figure><div class=""/><div class=""><h2 id="a374" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">解析日期、输入、异常检测等等</h2></div><p id="5c85" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">数据科学项目的大部分由数据清理和操作组成。这些数据清理任务中的大多数可以分为六个方面:</p><ul class=""><li id="86c8" class="lt lu ji kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated"><strong class="kz jj">输入缺失值。</strong>标准统计常数估算，KNN估算。</li><li id="357c" class="lt lu ji kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><strong class="kz jj">异常值/异常检测。</strong>隔离森林，一类SVM，局部离群因子离群检测算法。</li><li id="8b1a" class="lt lu ji kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><strong class="kz jj"> X变量清洗方法。</strong>应用自定义函数，删除重复项，替换值。</li><li id="c20d" class="lt lu ji kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><strong class="kz jj"> Y变量清洗方法。</strong>标签编码，字典映射，一键编码。</li><li id="f9c0" class="lt lu ji kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><strong class="kz jj">连接数据帧</strong>。连接、合并和连接。</li><li id="2034" class="lt lu ji kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><strong class="kz jj">解析日期。</strong>自动格式检测字符串到日期时间的转换，日期时间对象到数字。</li></ul><blockquote class="mh mi mj"><p id="0ff9" class="kx ky mk kz b la lb kj lc ld le km lf ml lh li lj mm ll lm ln mn lp lq lr ls im bi translated">除非另有明确说明，否则图片由作者创作。</p></blockquote></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="369b" class="mv mw ji bd mx my mz na nb nc nd ne nf ko ng kp nh kr ni ks nj ku nk kv nl nm bi translated">输入缺失值</h1><p id="7e1a" class="pw-post-body-paragraph kx ky ji kz b la nn kj lc ld no km lf lg np li lj lk nq lm ln lo nr lq lr ls im bi translated">缺失值经常困扰着数据，如果它们不太多，它们可以被估算(填充)。</p><p id="7d6f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">简单的输入方法</strong>是统计常数测量，如用每列的统计测量值填充<code class="fe ns nt nu nv b">NaN</code>(缺失值)的平均值或中值。参数<code class="fe ns nt nu nv b">strategy</code>可以替换为‘均值’，‘中值’，‘最频繁’(模式)，或‘常数’(带参数<code class="fe ns nt nu nv b">fill_value</code>的手动值)。</p><pre class="nw nx ny nz gt oa nv ob oc aw od bi"><span id="24ca" class="oe mw ji nv b gy of og l oh oi">from sklearn.impute import SimpleImputer<br/>imputer = SimpleImputer(strategy='mean')<br/>data = imputer.fit_transform(data)</span></pre><p id="a573" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj"> KNN输入</strong>是输入缺失值的最流行和最复杂的方法，其中KNN算法在多维空间中寻找与缺失值相似的其他数据点。</p><pre class="nw nx ny nz gt oa nv ob oc aw od bi"><span id="ed59" class="oe mw ji nv b gy of og l oh oi">from sklearn.impute import KNNImputer<br/>imputer = KNNImputer()<br/>data = imputer.fit_transform(data)</span></pre><p id="210e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在使用KNN和其他基于距离的算法之前，需要对数据进行<a class="ae oj" href="https://medium.com/analytics-vidhya/your-ultimate-data-mining-machine-learning-cheat-sheet-9fce3fa16" rel="noopener">缩放或归一化</a>以消除缩放差异(例如，一列代表孩子数量，另一列代表年薪——这些值不能从表面上看)。使用KNN估算遵循以下过程:</p><ol class=""><li id="15f3" class="lt lu ji kz b la lb ld le lg lv lk lw lo lx ls ok lz ma mb bi translated">缩放/标准化数据。</li><li id="b02e" class="lt lu ji kz b la mc ld md lg me lk mf lo mg ls ok lz ma mb bi translated">KNN-用于填充缺失值的估算。</li><li id="af77" class="lt lu ji kz b la mc ld md lg me lk mf lo mg ls ok lz ma mb bi translated">反向缩放/归一化数据。</li></ol></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="084e" class="mv mw ji bd mx my mz na nb nc nd ne nf ko ng kp nh kr ni ks nj ku nk kv nl nm bi translated">异常值/异常检测</h1><p id="b1df" class="pw-post-body-paragraph kx ky ji kz b la nn kj lc ld no km lf lg np li lj lk nq lm ln lo nr lq lr ls im bi translated"><strong class="kz jj">隔离森林</strong>是返回样本异常分值的算法。该算法通过随机选择一个要素、随机选择一个分割值来创建路径，从而隔离观察值，路径长度表示其正态性。较短的路径代表异常-当随机树的森林共同为特定样本产生较短的路径长度时，它们极有可能是异常。</p><pre class="nw nx ny nz gt oa nv ob oc aw od bi"><span id="86fe" class="oe mw ji nv b gy of og l oh oi">from sklearn.ensemble import IsolationForest<br/>identifier = IsolationForest().fit(X)<br/>identifier.predict(X)</span></pre><p id="fbaa" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">异常检测器的预测输出是从-1到1的分数数组，正分数表示异常的可能性较高。</p><p id="9f7a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">一类SVM </strong>是另一种用于检测异常值的无监督方法，适用于像隔离森林这样的异常检测方法会产生太多差异的高维分布。</p><pre class="nw nx ny nz gt oa nv ob oc aw od bi"><span id="76b0" class="oe mw ji nv b gy of og l oh oi">from sklearn.svm import OneClassSVM<br/>identifier = OneClassSVM().fit(X)<br/>identifier.predict(X)</span></pre><p id="eab6" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">局部异常值因子</strong>是三种常用异常值标识符中的第三种。每个样本的异常值(局部异常值因子)衡量给定样本相对于其相邻样本的局部密度偏差。基于K-最近邻，密度显著低于其邻的样本被认为是异常值。</p><p id="c5bf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">因为这种算法是基于距离的，所以在使用之前需要对数据进行缩放或归一化。该算法可被视为隔离森林的非线性高方差替代方案。</p><pre class="nw nx ny nz gt oa nv ob oc aw od bi"><span id="1dec" class="oe mw ji nv b gy of og l oh oi">from sklearn.neighbors import LocalOutlierFactor<br/>model = LocalOutlierFactor().fit(X)<br/>model.predict(X)</span></pre><p id="1953" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">对于所有三种异常算法，消除所有异常是数据科学家的选择。确保异常不仅仅是数据集群本身——确保异常的数量不会过多。PCA可视化可以证实这一点。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="640e" class="mv mw ji bd mx my mz na nb nc nd ne nf ko ng kp nh kr ni ks nj ku nk kv nl nm bi translated">x变量清洁方法</h1><p id="19ea" class="pw-post-body-paragraph kx ky ji kz b la nn kj lc ld no km lf lg np li lj lk nq lm ln lo nr lq lr ls im bi translated"><strong class="kz jj">对列应用函数</strong>经常需要对其进行清理。在内置函数无法完成清理的情况下，您可能需要编写自己的函数或传入外部内置函数。例如，假设2下面的列<code class="fe ns nt nu nv b">b</code>的所有值都是无效的。然后，要应用的函数可以充当过滤器，为没有通过过滤器的列元素返回<code class="fe ns nt nu nv b">NaN</code>值:</p><pre class="nw nx ny nz gt oa nv ob oc aw od bi"><span id="1119" class="oe mw ji nv b gy of og l oh oi">def filter_b(value):<br/>     if value &lt; 2:<br/>          return np.nan<br/>     else:<br/>          return value</span></pre><p id="2832" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">然后，通过使用熊猫的<code class="fe ns nt nu nv b">.apply()</code>函数应用过滤器，可以创建一个新的已清理列‘cleaned _ b’:</p><pre class="nw nx ny nz gt oa nv ob oc aw od bi"><span id="0a1b" class="oe mw ji nv b gy of og l oh oi">data['cleaned_b'] = data['b'].apply(filter_b)</span></pre><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/a1992d845c748fee445ef7c3ee5b6938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQi98DBVIoEr3wp9EpMwrQ.png"/></div></div></figure><p id="7f94" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">另一个常见的用例是转换数据类型。例如，将字符串列转换成数字列可以通过使用Python内置函数<code class="fe ns nt nu nv b">float</code>的<code class="fe ns nt nu nv b">data[‘target’].apply(float)</code>来完成。</p><p id="37e2" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">删除重复</strong>是数据清理中的常见任务。这可以用<code class="fe ns nt nu nv b">data.drop_duplicates()</code>来完成，它删除具有完全相同值的行。使用时要小心-当要素数量较少时，重复行可能不是数据收集中的错误。但是，对于大型数据集和大多数连续变量，重复项不是错误的可能性很小。</p><p id="a8cf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">数据点采样</strong>在数据集过大(或出于其他目的)且数据点需要随机采样时很常见。这可以用<code class="fe ns nt nu nv b">data.sample(number_of_samples)</code>来完成。</p><p id="3f72" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">重命名列</strong>是通过<code class="fe ns nt nu nv b">.rename</code>完成的，这里传递的参数是一个字典，其中键是原始列名，值是重命名的值。例如，<code class="fe ns nt nu nv b">data.rename({‘a’:1, ‘b’:3})</code>会将列<code class="fe ns nt nu nv b">‘a’</code>重命名为1，将列<code class="fe ns nt nu nv b">‘b’</code>重命名为3。</p><p id="a072" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">替换数据中的值</strong>可以通过<code class="fe ns nt nu nv b">data.replace()</code>来完成，它接受两个参数<code class="fe ns nt nu nv b">to_replace</code>和<code class="fe ns nt nu nv b">value</code>，这两个参数代表数据帧中将被其他值替换的值。这对于下一节输入缺失值很有帮助，可以用<code class="fe ns nt nu nv b">np.nan</code>替换某些变量，这样输入算法就可以识别它们。</p><p id="f86e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">更方便的专门用于数据操作的熊猫函数可以在这里找到:</p><div class="is it gp gr iu om"><a rel="noopener follow" target="_blank" href="/7-pandas-functions-to-reduce-your-data-manipulation-stress-25981e44cc7d"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jj gy z fp or fr fs os fu fw jh bi translated">7熊猫功能减轻您的数据操作压力</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">熊猫没有白毛是有原因的</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">towardsdatascience.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ja om"/></div></div></a></div></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="8ce2" class="mv mw ji bd mx my mz na nb nc nd ne nf ko ng kp nh kr ni ks nj ku nk kv nl nm bi translated">y变量清洗方法</h1><p id="00eb" class="pw-post-body-paragraph kx ky ji kz b la nn kj lc ld no km lf lg np li lj lk nq lm ln lo nr lq lr ls im bi translated"><strong class="kz jj">分类<em class="mk"> y </em>变量需要标签编码</strong>。例如，如果数据有两个类别“猫”和“狗”，它们需要映射到0和1，因为机器学习算法纯粹基于数学运算。</p><p id="2fb2" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">一种简单的方法是使用<code class="fe ns nt nu nv b">.map()</code>函数，它采用一个字典，其中键是原始类名，值是它们要被替换的元素。</p><pre class="nw nx ny nz gt oa nv ob oc aw od bi"><span id="110f" class="oe mw ji nv b gy of og l oh oi">data['target'] = data['target'].map({'cat':0, 'dog':1})</span></pre><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/36d484da10801da36328ff7741e69cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PGrqcDZOU3qjTDES7pvglQ.png"/></div></div></figure><p id="a43b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">然而，如果有太多的类不能用字典手动映射，<code class="fe ns nt nu nv b">sklearn</code>有一个自动化的方法:</p><pre class="nw nx ny nz gt oa nv ob oc aw od bi"><span id="bf7b" class="oe mw ji nv b gy of og l oh oi">from sklearn.preprocessing import LabelEncoder<br/>encoder = LabelEncoder().fit(data['target'])<br/>data['target'] = encoder.transform(data['target'])</span></pre><p id="26cf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">使用这种标签编码方法的好处是可以使用<code class="fe ns nt nu nv b">encoder.inverse_transform(array)</code>对数据进行逆转换——也就是从数值到原始类的转换。</p><p id="5c13" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">当标签编码对数据进行量化测量时，在具有多个类别的特定场景中，一键编码</strong>优于标签编码。类别“狗”、“猫”和“鱼”之间的标签编码为0、1和2，假设不知何故“鱼”比“狗”大或者“狗”比“猫”小。</p><p id="7844" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在one-hot编码中，每个<em class="mk">y</em>-值是一个向量，其长度为不同类的数量，其中“1”表示向量中的唯一索引，其余值标有“0”。例如，可以将向量<code class="fe ns nt nu nv b">[1, 0, 0]</code>、【猫】分配给<code class="fe ns nt nu nv b">[0, 1, 0]</code>、【鱼】分配给<code class="fe ns nt nu nv b">[0, 0, 1]</code>。</p><p id="1b13" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><code class="fe ns nt nu nv b">pandas</code>有一个内置函数<code class="fe ns nt nu nv b">get_dummies</code>，它自动接受一个序列或另一个数组形式，并输出一位热码编码数据帧。比如下面这个命令<code class="fe ns nt nu nv b">pd.get_dummies(data[‘target’]</code>。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/52731fc63fddfa55e3f8e5d02932f553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LgaqUIwEKz8xj-lbC4puiA.png"/></div></div></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="904f" class="mv mw ji bd mx my mz na nb nc nd ne nf ko ng kp nh kr ni ks nj ku nk kv nl nm bi translated">连接数据框架</h1><p id="48bd" class="pw-post-body-paragraph kx ky ji kz b la nn kj lc ld no km lf lg np li lj lk nq lm ln lo nr lq lr ls im bi translated"><strong class="kz jj">串联</strong>是数据帧的自顶向下连接。例如，<code class="fe ns nt nu nv b">pd.concat([df1, df2])</code>将产生一个主数据帧，其中<code class="fe ns nt nu nv b">df2</code>堆叠在<code class="fe ns nt nu nv b">df1</code>下方。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pd"><img src="../Images/fdb4e4131f4350ded63e4897a2bf7834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eS9yZVeq31U59TY5hFcTEg.png"/></div></div></figure><p id="5be2" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">合并</strong>是一个从左到右的过程，横向合并两个数据帧，而不是用<code class="fe ns nt nu nv b">concat()</code>纵向合并。例如，<code class="fe ns nt nu nv b">pd.merge(left_df, right_df, on='ID')</code>将基于<code class="fe ns nt nu nv b">‘ID’</code>列合并左数据帧和右数据帧。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/706121c66d7b82077f415adc9af033c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-d1BRjI1NcQJ-NXhtCbf-A.png"/></div></div></figure><p id="789a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">加入</strong>允许更专业的合并。默认情况下，合并是一个<em class="mk">内部连接</em>，它只适合关键字在两个数据框中的行。其他类型的连接包括<em class="mk">左外部连接</em>，其中包括左数据帧中的所有关键字，只有当其关键字存在于左数据帧中时，才包括右数据帧中的行。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pf"><img src="../Images/0d68d2c2ef9c9ad3a37b34fcf56ab86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSy1FjAaVRxyESDqN41Ggw.png"/></div></div></figure><p id="7067" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">可在<code class="fe ns nt nu nv b">merge</code>内的参数<code class="fe ns nt nu nv b">how=”outer”</code>或<code class="fe ns nt nu nv b">“right”</code>中概述选择的连接类型:</p><pre class="nw nx ny nz gt oa nv ob oc aw od bi"><span id="2aab" class="oe mw ji nv b gy of og l oh oi">pd.merge(left = left_df, right = right_df, how = 'outer', on = 'id')</span></pre></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="4e47" class="mv mw ji bd mx my mz na nb nc nd ne nf ko ng kp nh kr ni ks nj ku nk kv nl nm bi translated">解析日期</h1><p id="ab59" class="pw-post-body-paragraph kx ky ji kz b la nn kj lc ld no km lf lg np li lj lk nq lm ln lo nr lq lr ls im bi translated">日期可能是最难处理的数据对象，但对数据来说也是必不可少的。时间是现实生活中最重要的变量，重要的是不要让处理时间的困难影响到你的数据。</p><p id="2512" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">将字符串转换成日期</strong>是很常见的——数据集几乎从不带有可以方便访问的<code class="fe ns nt nu nv b">datetime</code>对象。把字符串转换成日期最好的库是<code class="fe ns nt nu nv b">dateutil</code>，可以自动推断日、月、年的位置，需要用其他库指定。</p><pre class="nw nx ny nz gt oa nv ob oc aw od bi"><span id="d486" class="oe mw ji nv b gy of og l oh oi">from dateutil import parser</span></pre><p id="634d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><code class="fe ns nt nu nv b">dateutil</code>可以适应多种日期，其中每个命令都产生相同的结果(<code class="fe ns nt nu nv b">datetime.datetime(2040, 7, 3, 0, 0)</code>):</p><ul class=""><li id="a84f" class="lt lu ji kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated"><code class="fe ns nt nu nv b">parser.parse(‘7/3/40’)</code></li><li id="a264" class="lt lu ji kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><code class="fe ns nt nu nv b">parser.parse(‘7–3–2040’)</code></li><li id="1d94" class="lt lu ji kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><code class="fe ns nt nu nv b">parser.parse(‘7.3.40’)</code></li><li id="352d" class="lt lu ji kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><code class="fe ns nt nu nv b">parser.parse(‘July 3rd, 2040’)</code></li><li id="8a38" class="lt lu ji kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><code class="fe ns nt nu nv b">parser.parse(‘July 3 2040’)</code></li><li id="d253" class="lt lu ji kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><code class="fe ns nt nu nv b">parser.parse(‘2040 July 3’)</code></li><li id="4051" class="lt lu ji kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><code class="fe ns nt nu nv b">parser.parse(‘3 July 2040’)</code></li></ul><p id="a7f9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">对一个列使用<code class="fe ns nt nu nv b">.apply(parser.parse)</code>可以将几乎任何形式的字符串转换成一个<code class="fe ns nt nu nv b">datetime</code>对象，在这里可以提取它的属性。</p><p id="b796" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">将日期转换成数字</strong>很重要，因为虽然时间对于模型来说是必不可少的，但它不能处理日期时间对象。相反，时间可以表示为整数，其中每个日期表示自数据中最早的日期以来经过的天数。在下面的示例中，2016年3月8日是数据集中最早的日期(这需要找到并替换)。</p><pre class="nw nx ny nz gt oa nv ob oc aw od bi"><span id="c032" class="oe mw ji nv b gy of og l oh oi">import datetime<br/>def convert_date_to_num(date):<br/>     return (date - datetime.datetime(5,8,16)).days</span><span id="27c6" class="oe mw ji nv b gy pg og l oh oi">data['number date'] = data['date'].apply(convert_date_to_num)</span></pre><p id="1143" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">使用<code class="fe ns nt nu nv b">.apply()</code>将该函数应用于日期列(假设日期列的元素是<code class="fe ns nt nu nv b">datetime</code>对象)。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="7ba1" class="mv mw ji bd mx my mz na nb nc nd ne nf ko ng kp nh kr ni ks nj ku nk kv nl nm bi translated">感谢阅读！</h1><p id="3c69" class="pw-post-body-paragraph kx ky ji kz b la nn kj lc ld no km lf lg np li lj lk nq lm ln lo nr lq lr ls im bi translated">如果你觉得有帮助的话，一定要把这个页面加入书签，以便于参考。如果您喜欢，您可能还会喜欢其他数据科学备忘单:</p><div class="is it gp gr iu om"><a href="https://medium.com/@andre_ye/your-ultimate-data-science-statistics-mathematics-cheat-sheet-d688a48ad3db" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jj gy z fp or fr fs os fu fw jh bi translated">你的终极数据科学统计和数学小抄</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">机器学习指标、统计指标等</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="ph l ox oy oz ov pa ja om"/></div></div></a></div><div class="is it gp gr iu om"><a href="https://medium.com/analytics-vidhya/your-ultimate-data-mining-machine-learning-cheat-sheet-9fce3fa16" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jj gy z fp or fr fs os fu fw jh bi translated">您的终极数据挖掘和机器学习备忘单</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">特性重要性、分解、转换等</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="pi l ox oy oz ov pa ja om"/></div></div></a></div><div class="is it gp gr iu om"><a href="https://medium.com/analytics-vidhya/your-ultimate-python-visualization-cheat-sheet-663318470db" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jj gy z fp or fr fs os fu fw jh bi translated">您的最终Python可视化备忘单</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">这个备忘单包含了你最常需要的一个情节的要素，以一种清晰和有组织的方式，用…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="pj l ox oy oz ov pa ja om"/></div></div></a></div></div></div>    
</body>
</html>