<html>
<head>
<title>Isolation Forest from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始隔离森林</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/isolation-forest-from-scratch-e7e5978e6f4c?source=collection_archive---------20-----------------------#2020-05-22">https://towardsdatascience.com/isolation-forest-from-scratch-e7e5978e6f4c?source=collection_archive---------20-----------------------#2020-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4a05" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从零开始实现隔离森林，以便进一步理解算法</h2></div><p id="ad2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，我一直在阅读隔离森林及其在异常值/异常检测方面的表现。在仔细阅读了算法之后(并且没有找到任何我喜欢的香草教程)。为了更好地掌握算法，我决定用最简单的方式从头开始编码。</p><p id="10c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章的目的是在阅读后，你可以深入了解隔离森林，它的优点，缺点，参数，你可以随时使用它，只要你考虑与算法的知识。</p><p id="78a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个博客/实现，我使用了这篇关于<a class="ae lb" href="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/icdm08b.pdf?q=isolation-forest" rel="noopener ugc nofollow" target="_blank">隔离森林的论文作为伪代码</a>，这篇<a class="ae lb" href="https://arxiv.org/abs/1811.02141" rel="noopener ugc nofollow" target="_blank">扩展的隔离森林论文作为可视化</a>(与另一篇<a class="ae lb" rel="noopener" target="_blank" href="/outlier-detection-with-extended-isolation-forest-1e248a3fe97b">博客文章</a>相对应)，并使用了这个 youtube 教程示例<a class="ae lb" href="https://github.com/SebastianMantey/Random-Forest-from-Scratch" rel="noopener ugc nofollow" target="_blank">来自<a class="ae lb" href="https://www.youtube.com/channel/UCCtkE-r-0Mvp7PwAvxzSdvw" rel="noopener ugc nofollow" target="_blank"> Sebastian Mantey </a>的随机森林实现</a></p><h1 id="279b" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">一点理论背景</h1><p id="783c" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在开始写代码之前，我认为需要一点理论。</p><h2 id="cf63" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">什么是隔离林？</h2><ul class=""><li id="02f1" class="ml mm iq kh b ki lu kl lv ko mn ks mo kw mp la mq mr ms mt bi translated">隔离林用于异常值/异常检测</li><li id="dd73" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">隔离森林是一种无监督学习技术(不需要标签)</li><li id="0ecf" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">使用二进制决策树 bagging(类似监督学习中的随机森林)</li></ul><h2 id="54c9" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">假设</h2><p id="ffc5" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">该方法将异常与正常情况隔离开来，为此，对异常进行了以下假设:</p><ul class=""><li id="9553" class="ml mm iq kh b ki kj kl km ko mz ks na kw nb la mq mr ms mt bi translated">它们是由较少实例组成的少数</li><li id="8807" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">它们具有不同于普通实例的属性值</li></ul><p id="4d4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，异常是“少数和不同的。”</p><p id="9c9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于前两个假设，异常很容易被隔离，这使得它们更接近树根。</p><h2 id="e8c8" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">简要描述</h2><p id="86c9" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">隔离林为给定数据集构建一个二叉树集合。异常，由于它们的性质，它们在树中有比正常情况下最短的路径。</p><p id="f614" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">隔离森林使用非常少的树快速收敛，子采样使我们能够在计算高效的同时获得良好的结果。</p><h1 id="60a5" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">代码</h1><p id="31d1" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">总体编码策略如下。首先对一棵树进行编码，然后进行树的森林(集合)，最后测量某个实例在每棵树中走了多远，并确定它是否是离群值。</p><p id="cbd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从树开始</p><h2 id="a4a4" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">隔离树:对树进行编码</h2><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nc"><img src="../Images/5371ea3ab94a686eee0d5ce01a2ff323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0DoCG-bGGjt2qWHubfM-g.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">[1]中的隔离树伪代码</p></figure><p id="7b48" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输入将是数据样本、当前树高和最大深度。</p><p id="1f03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于输出，我们将有一个构建好的树。</p><p id="40d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更容易理解，我正在使用熊猫数据框，即使它在性能方面不是最佳的，也能让普通用户更容易理解。</p><ul class=""><li id="9204" class="ml mm iq kh b ki kj kl km ko mz ks na kw nb la mq mr ms mt bi translated">选择数据的特征(列)</li></ul><pre class="nd ne nf ng gt ns nt nu nv aw nw bi"><span id="a81e" class="lz ld iq nt b gy nx ny l nz oa">def select_feature(data): <br/>    return random.choice(data.columns)</span></pre><ul class=""><li id="59ce" class="ml mm iq kh b ki kj kl km ko mz ks na kw nb la mq mr ms mt bi translated">在范围内选择一个随机值</li></ul><pre class="nd ne nf ng gt ns nt nu nv aw nw bi"><span id="ab92" class="lz ld iq nt b gy nx ny l nz oa">def select_value(data,feat):<br/>    mini = data[feat].min()<br/>    maxi = data[feat].max()<br/>    return (maxi-mini)*np.random.random()+mini</span></pre><ul class=""><li id="c67d" class="ml mm iq kh b ki kj kl km ko mz ks na kw nb la mq mr ms mt bi translated">分割数据</li></ul><pre class="nd ne nf ng gt ns nt nu nv aw nw bi"><span id="24de" class="lz ld iq nt b gy nx ny l nz oa">def split_data(data, split_column, split_value):</span><span id="e97d" class="lz ld iq nt b gy ob ny l nz oa">    data_below = data[data[split_column] &lt;= split_value]<br/>    data_above = data[data[split_column] &gt;  split_value]<br/>    <br/>    return data_below, data_above</span></pre><ul class=""><li id="1c5d" class="ml mm iq kh b ki kj kl km ko mz ks na kw nb la mq mr ms mt bi translated">一起:隔离树。</li></ul><p id="34b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其思想如下:选择一个特征、该特征的值以及分割数据。如果分支中只有一个数据点，或者树已经达到最大深度:停止。</p><pre class="nd ne nf ng gt ns nt nu nv aw nw bi"><span id="a069" class="lz ld iq nt b gy nx ny l nz oa">def isolation_tree(data,counter=0, max_depth=50,random_subspace=False):<br/>    <br/>    # End Loop if max depth or isolated<br/>    if (counter == max_depth) or data.shape[0]&lt;=1:<br/>        classification = classify_data(data)<br/>        return classification<br/>    <br/>    else:<br/>        # Counter<br/>        counter +=1<br/>        <br/>        # Select feature<br/>        split_column = select_feature(data)<br/>        <br/>        # Select value<br/>        split_value = select_value(data,split_column)</span><span id="26e5" class="lz ld iq nt b gy ob ny l nz oa">        # Split data<br/>        data_below, data_above = split_data(data,split_column,split_value)<br/>        <br/>        # instantiate sub-tree      <br/>        question = "{} &lt;= {}".format(split_column, split_value)<br/>        sub_tree = {question: []}<br/>        <br/>        # Recursive part<br/>        below_answer = isolation_tree(data_below, counter,max_depth=max_depth)<br/>        above_answer = isolation_tree(data_above, counter,max_depth=max_depth)<br/>        <br/>        if below_answer == above_answer:<br/>            sub_tree = below_answer<br/>        else:<br/>            sub_tree[question].append(below_answer)<br/>            sub_tree[question].append(above_answer)<br/>        <br/>        return sub_tree</span></pre><h2 id="8ab2" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">隔离森林</h2><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oc"><img src="../Images/c249711de8369ef9eb71b08957356349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utTl6fVXm-_sj6ItYVyhUw.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">[1]中的隔离林伪代码</p></figure><p id="80dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有了自己的树，我们就要把它们变成一片森林。伪代码如下:</p><p id="40b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定一个输入数据、一些树和一个采样大小(每棵树有多少数据),我们根据需要拟合尽可能多的树并返回一个森林。</p><p id="4d40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际代码:</p><pre class="nd ne nf ng gt ns nt nu nv aw nw bi"><span id="a3ec" class="lz ld iq nt b gy nx ny l nz oa">def isolation_forest(df,n_trees=5, max_depth=5, subspace=256):<br/>    forest = []</span><span id="0e37" class="lz ld iq nt b gy ob ny l nz oa">for i in range(n_trees):<br/>        # Sample the subspace<br/>        if subspace&lt;=1:<br/>            df = df.sample(frac=subspace)<br/>        else:<br/>            df = df.sample(subspace)</span><span id="bf7a" class="lz ld iq nt b gy ob ny l nz oa">        # Fit tree<br/>        tree = isolation_tree(df,max_depth=max_depth)<br/>        <br/>        # Save tree to forest<br/>        forest.append(tree)<br/>    <br/>    return forest</span></pre><h2 id="7c7b" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">路径长度</h2><p id="0a63" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在构建了隔离林之后，我们必须评估实例，为此我们定义了路径长度</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div class="gh gi od"><img src="../Images/0c0307eb524ce69d451a290789e9e0d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*7Tvc6gF-OMFtq2AHPwD6MA.png"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">来自[1]的路径长度伪代码</p></figure><p id="0e54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定一个实例和一个隔离树，我们计算每个实例在被隔离或达到最大深度之前要经过多少个节点。</p><p id="1509" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">伪代码摘自<a class="ae lb" href="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/icdm08b.pdf?q=isolation-forest" rel="noopener ugc nofollow" target="_blank">隔离林</a>论文。</p><pre class="nd ne nf ng gt ns nt nu nv aw nw bi"><span id="a6a2" class="lz ld iq nt b gy nx ny l nz oa">def pathLength(example,iTree,path=0,trace=False):</span><span id="cfe5" class="lz ld iq nt b gy ob ny l nz oa">    # Initialize question and counter<br/>    path=path+1<br/>    question = list(iTree.keys())[0]<br/>    feature_name, comparison_operator, value = question.split()<br/>    <br/>    <br/>    # ask question<br/>    if example[feature_name].values &lt;= float(value):<br/>        answer = iTree[question][0]<br/>    else:<br/>        answer = iTree[question][1]<br/>          <br/>    # base case<br/>    if not isinstance(answer, dict):<br/>        return path<br/>    <br/>    # recursive part<br/>    else:<br/>        residual_tree = answer<br/>        return pathLength(example, residual_tree,path=path)</span><span id="84d2" class="lz ld iq nt b gy ob ny l nz oa">return path</span></pre><p id="fd00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是根据以前存储数据的方式来计算一个实例经过了多少个节点。</p><h2 id="100f" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">估价</h2><p id="c682" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们四处看看</p><pre class="nd ne nf ng gt ns nt nu nv aw nw bi"><span id="8f60" class="lz ld iq nt b gy nx ny l nz oa">mean = [0, 0]<br/>cov = [[1, 0], [0, 1]]  # diagonal covariance<br/>Nobjs = 2000<br/>x, y = np.random.multivariate_normal(mean, cov, Nobjs).T<br/>#Add manual outlier<br/>x[0]=3.3<br/>y[0]=3.3<br/>X=np.array([x,y]).T<br/>X = pd.DataFrame(X,columns=['feat1','feat2'])<br/>plt.figure(figsize=(7,7))<br/>plt.plot(x,y,'bo');</span></pre><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/bf7d67c79b7cdb857651359f20d206d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*cg7u10qdyYRXiwLd804_qw.png"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">数据样本</p></figure><p id="a789" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将用我们的数据进行训练和评估。</p><pre class="nd ne nf ng gt ns nt nu nv aw nw bi"><span id="5fbf" class="lz ld iq nt b gy nx ny l nz oa">iForest = isolation_forest(X,n_trees=20, max_depth=100, subspace=256)</span><span id="0295" class="lz ld iq nt b gy ob ny l nz oa"># Evaluate one instance<br/>def evaluate_instance(instance,forest):<br/>    paths = []<br/>    for tree in forest:<br/>        paths.append(pathLength(instance,tree))<br/>    return paths</span></pre><p id="aa47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们选择数据的一个正常实例(随机选择)和一个异常值(记得我们在开始时硬编码了一个异常值作为第一行)。我们看它在树上落下多远，然后画出结果。</p><pre class="nd ne nf ng gt ns nt nu nv aw nw bi"><span id="51e7" class="lz ld iq nt b gy nx ny l nz oa">outlier = evaluate_instance(X.head(1),iForest)<br/>normal  = evaluate_instance(X.sample(1),iForest)</span></pre><p id="3f56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">蓝色表示随机正态样本，红色表示异常值。</p><pre class="nd ne nf ng gt ns nt nu nv aw nw bi"><span id="bb17" class="lz ld iq nt b gy nx ny l nz oa">np.mean(outlier)<br/># 4.85<br/>np.mean(normal)<br/># 12.55</span></pre><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi of"><img src="../Images/f89b89d7c268680f08d35272424afe92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLSgutFZCNrc3B2g5_qB8w.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">异常值和正常样本的每棵树的树深度</p></figure><p id="6d1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，在正常样本和异常值之间，在每个树中实例的深度方面存在视觉和统计差异。</p><p id="40b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从<a class="ae lb" href="https://arxiv.org/abs/1811.02141" rel="noopener ugc nofollow" target="_blank">扩展隔离森林的论文中，</a>有另一种放射状的可视化形式，提供了对离群值的清晰直觉</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi og"><img src="../Images/1e7a60c73440375a3eb6a0ad6ac4dcc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOjTT68az8NoIVq9Egg69Q.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">如果节点深度(a)和径向深度(b)由[2]形成，则为正常与异常值</p></figure><p id="c6ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">评估森林的更正式的方法是使用实例(x)的异常分数:</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/3612e51c94b51632112afe5a2fb284e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*Q1ah7Bmn7w649IDN8RBabg.png"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">异常分数</p></figure><p id="cfa0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中 H(i)是谐波数，可以通过 ln(i) + 0.5772156649(欧拉常数)来估算。由于 c(n)是给定 n 的 h(x)的平均值，我们用它来归一化 h(x)。</p><pre class="nd ne nf ng gt ns nt nu nv aw nw bi"><span id="43ef" class="lz ld iq nt b gy nx ny l nz oa">def c_factor(n) :<br/>    """<br/>    Average path length of unsuccesful search in a binary search     tree given n points<br/>    <br/>    Parameters<br/>    ----------<br/>    n : int<br/>        Number of data points for the BST.<br/>    Returns<br/>    -------<br/>    float<br/>        Average path length of unsuccesful search in a BST<br/>        <br/>    """<br/>    return 2.0*(np.log(n-1)+0.5772156649) - (2.0*(n-1.)/(n*1.0))</span><span id="ece2" class="lz ld iq nt b gy ob ny l nz oa">def anomaly_score(data_point,forest,n):<br/>    '''<br/>    Anomaly Score<br/>    <br/>    Returns<br/>    -------<br/>    0.5 -- sample does not have any distinct anomaly<br/>    0 -- Normal Instance<br/>    1 -- An anomaly<br/>    '''<br/>    # Mean depth for an instance<br/>    E = np.mean(evaluate_instance(data_point,forest))<br/>    <br/>    c = c_factor(n)<br/>    <br/>    return 2**-(E/c)</span></pre><p id="0963" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这种方法，我们可以得到异常值的数学定义，但我相信，到此为止，您已经可以直观地了解算法是如何工作的，参数是什么，以及在哪些情况下它可能会成功。</p><p id="8565" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请随意发表任何评论或给我发短信，告诉我你的建议或其他任何事情。</p><h1 id="3a6b" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">参考</h1><p id="e996" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这个博客已经完成如下</p><ul class=""><li id="5b88" class="ml mm iq kh b ki kj kl km ko mz ks na kw nb la mq mr ms mt bi translated">[1] <a class="ae lb" href="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/icdm08b.pdf?q=isolation-forest" rel="noopener ugc nofollow" target="_blank">隔离林论文为伪代码</a>出自费托尼刘、廷和</li><li id="ab16" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">[2] <a class="ae lb" href="https://arxiv.org/abs/1811.02141" rel="noopener ugc nofollow" target="_blank">扩展隔离森林</a>用于可视化(与另一篇<a class="ae lb" rel="noopener" target="_blank" href="/outlier-detection-with-extended-isolation-forest-1e248a3fe97b">博文</a>相对应)</li><li id="f6be" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">[3] Youtube <a class="ae lb" href="https://github.com/SebastianMantey/Random-Forest-from-Scratch" rel="noopener ugc nofollow" target="_blank">随机森林实现</a>来自<a class="ae lb" href="https://www.youtube.com/channel/UCCtkE-r-0Mvp7PwAvxzSdvw" rel="noopener ugc nofollow" target="_blank"> Sebastian Mantey </a></li></ul><p id="3d27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的代码、笔记本和图片可以在这个资源库中看到</p><div class="oi oj gp gr ok ol"><a href="https://github.com/cmougan/IsolationForest" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">cmougan/IsolationForest</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">隔离林存储库。通过在 GitHub 上创建帐户，为 cmougan/IsolationForest 的发展做出贡献。</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz nm ol"/></div></div></a></div></div></div>    
</body>
</html>