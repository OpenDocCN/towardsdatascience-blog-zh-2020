<html>
<head>
<title>Check the quality of your code with Pylint</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Pylint检查你的代码质量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/check-the-quality-of-your-code-with-pylint-f5d829bb441d?source=collection_archive---------8-----------------------#2020-03-25">https://towardsdatascience.com/check-the-quality-of-your-code-with-pylint-f5d829bb441d?source=collection_archive---------8-----------------------#2020-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="db26" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">PEP 8指南的10条规则将使你的代码更容易阅读</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5b486426d3fc8872ecf3e6492abefd45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DkseXaR5gzUVQI9u.JPG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">罗纳河上的星夜——文森特·梵高</p></figure><p id="3883" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Pylint </strong>是<strong class="la iu"> Python </strong>编程语言的质量检查器，遵循<strong class="la iu"> PEP 8 </strong>推荐的风格。本文提供了用<strong class="la iu"> Python </strong>编写清晰代码的指南，主要目标是提高代码的可读性和一致性。代码被阅读的次数要比被编写的次数多得多，这就是为什么遵守约定是如此重要，这将帮助我们或其他人更容易地理解可用的代码。在本文中，我们解释了<strong class="la iu"> PEP 8 </strong>的<strong class="la iu"> 10条规则</strong>，它们可以让你的<strong class="la iu"> Python </strong>代码更容易被其他人阅读，以及我们如何用<strong class="la iu"> Pylint </strong>检查它们。我们开始吧！💪</p><h1 id="a2d0" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">安装Pylint</h1><p id="1d9c" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated"><strong class="la iu"> Pylint </strong>是第三方库，在<strong class="la iu"> Python </strong>中默认不可用。由于Pylint不是<strong class="la iu"> Python标准库</strong>的一部分，我们需要单独安装它。这可以通过使用<strong class="la iu"> pip </strong>组件轻松实现。<strong class="la iu"> Pip </strong>是<strong class="la iu"> Python </strong>的标准包管理器，允许安装和管理不包含在Python标准库中的包。要检查是否安装了<strong class="la iu"> pip </strong>，您可以在Windows终端中执行以下命令:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="32d5" class="mw lv it ms b gy mx my l mz na"><strong class="ms iu">pip --version</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/1bd28bff947b655b0e69004aec050a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gpc7hze-cSwLcUynIi5Kwg.png"/></div></div></figure><p id="ed3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上图所示，<strong class="la iu">版本10.0.1 </strong>在我们的系统中已经有了。现在，我们可以安装<strong class="la iu"> pylint </strong>，在命令行运行:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="2247" class="mw lv it ms b gy mx my l mz na"><strong class="ms iu">pip install pylint</strong></span></pre><p id="9114" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还安装了<strong class="la iu"> pylint </strong>所需的所有依赖项。注意<strong class="la iu"> pip </strong>下载了最新版本的包。</p><h1 id="f829" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">使用Pylint </strong></h1><p id="ccfe" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">一旦我们安装了<strong class="la iu"> pylint </strong>，我们可以通过运行命令<strong class="la iu"> pylint </strong>和文件名<strong class="la iu">来轻松使用它，如下所示:</strong></p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="8aaa" class="mw lv it ms b gy mx my l mz na"><strong class="ms iu">pylint filename.py</strong></span></pre><p id="c9d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在！我们已经准备好看到一些代码示例💪。在本文中，我们将详细解释用<strong class="la iu"> Python </strong>编码时的10个编码约定。此外，我们将证明<strong class="la iu"> pylint </strong>如何检测它们。</p><h1 id="500e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">编码约定(PEP 8)</h1><p id="ac0a" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">PEP 8 是一个风格指南，它定义了你的<strong class="la iu"> python </strong>代码应该如何被格式化以最大化它的可读性。在这篇文章中，我们将只涉及一些关键点；因此，如果你想更详细地研究这个话题，我建议你看一下指南。</p><div class="nc nd gp gr ne nf"><a href="https://www.python.org/dev/peps/pep-0008/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">PEP 8风格的Python代码指南</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">Python编程语言的官方主页</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">www.python.org</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks nf"/></div></div></a></div><h1 id="66df" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">1.多行语句</h1><p id="2bbc" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在Python中，我们在排比句(<strong class="la iu"> () </strong>)、中括号(<strong class="la iu"> [] </strong>)、大括号(<strong class="la iu"> {} </strong>)内部使用<strong class="la iu">隐式延伸线</strong>。<strong class="la iu">隐式</strong>意味着我们不写行继续符(<strong class="la iu"> \ </strong>)来表示我们将一个语句扩展到多行。</p><p id="49f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当使用隐式延续行时，被包裹的元素应该垂直对齐，或者使用<strong class="la iu">悬挂缩进</strong>。在Python的上下文中，<strong class="la iu">悬挂缩进</strong>意味着带括号的语句的左括号是该行的最后一个非空白字符，随后的行缩进直到右括号。</p><h2 id="934d" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">不良做法</h2><p id="6d72" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">括号内的参数没有垂直对齐，或者使用悬挂缩进。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="2f77" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">Pylint输出</h2><p id="47d2" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Pylint检测到一个错误的缩进。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/01fdc758ca15f6efa3bf6e81f9be2429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*HDMkvkJxNT5KLnPxomzFuA.png"/></div></figure><h2 id="6802" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">良好实践</h2><p id="e962" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">括号内的参数垂直对齐。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e04b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">括号内的参数使用悬挂缩进对齐。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="d8c3" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak"> 2。操作员</strong></h1><p id="1361" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">始终用一个空格将这些运算符括起来:</p><ul class=""><li id="d513" class="oi oj it la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated"><strong class="la iu">赋值</strong> (=)</li><li id="0af2" class="oi oj it la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated"><strong class="la iu">扩充赋值</strong> (+=，-=，等等)</li><li id="926d" class="oi oj it la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated"><strong class="la iu">比较运算符</strong> ( &lt;，&gt;，&lt; =，&gt; =，==，！=)</li><li id="5adc" class="oi oj it la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated"><strong class="la iu">逻辑运算符</strong>(与、或、非)</li><li id="d2bf" class="oi oj it la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated"><strong class="la iu">隶属运算符</strong>(在，不在)</li><li id="981a" class="oi oj it la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated"><strong class="la iu">身份运算符</strong>(是，非是)</li></ul><h2 id="4e61" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">不良做法</h2><p id="96e9" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">运算符没有被空格包围。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2266" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以很容易地禁用<strong class="la iu"> pylint </strong>中的警告，在代码顶部添加一个注释，如上所示(<strong class="la iu"> #pylint: disable=C0114 </strong>)</p><p id="512e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> C0114 </strong>警告表示模块<strong class="la iu">文件串</strong>丢失。docstring是作为模块、函数、类或方法定义中的第一条语句出现的字符串。根据<strong class="la iu"> PEP 257(包含docstring约定的指南)</strong>，所有模块的开头都应该有一个docstring，描述该模块做什么。</p><p id="9de5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，为了简单起见，我们不打算在每个模块的顶部添加一个docstring。但是，强烈建议在实践中编写doctrings。和以前一样，如果你想了解更多关于如何在<strong class="la iu"> Python </strong>中使用doctrings，我推荐你仔细看看<strong class="la iu"> PEP 257 </strong>指南。</p><div class="nc nd gp gr ne nf"><a href="https://www.python.org/dev/peps/pep-0257/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">PEP 257 -文档字符串约定</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">这个PEP的目的是标准化文档字符串的高层结构:它们应该包含什么，以及如何表达…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">www.python.org</p></div></div><div class="no l"><div class="ow l nq nr ns no nt ks nf"/></div></div></a></div><h2 id="4a92" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">Pylint输出</h2><p id="ebeb" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如下所示，pylint检测到比较运算符</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/0fd139433764fc78fed73a1a670e8745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*gyuONsaJ65neK2OWQRqtRg.png"/></div></figure><p id="7564" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，pylint没有检测到if语句中的成员资格操作符也应该被空格包围。Pylint并不完美！😢</p><h2 id="446c" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated"><strong class="ak">良好实践</strong></h2><p id="83ce" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">运算符两边各有一个空格。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="b342" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak"> 3。逗号、分号或冒号后面的空格(但不是在前面！)</strong></h1><p id="6f18" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在逗号、分号或冒号之后，我们必须使用空格。然而，<strong class="la iu"> PEP 8 </strong>建议在即将到来之前避开它们。</p><h2 id="aed1" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">不良做法</h2><p id="1474" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在下面的代码中，我们可以观察到以下不良做法:</p><ol class=""><li id="0165" class="oi oj it la b lb lc le lf lh ok ll ol lp om lt oy oo op oq bi translated">分隔列表中每个元素的逗号后面缺少空格。</li><li id="134e" class="oi oj it la b lb or le os lh ot ll ou lp ov lt oy oo op oq bi translated">字典中分隔每个键值对的冒号(:)后面缺少空格。</li><li id="fbd4" class="oi oj it la b lb or le os lh ot ll ou lp ov lt oy oo op oq bi translated">在分隔元组中每个元素的逗号之前有一个空格。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="ebdf" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">Pylint输出</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/3beffdb447038760e8e1d19a21ae10e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*JJ8Gn4KSd2bZvORVTSTTrw.png"/></div></div></figure><p id="700e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上所示，<strong class="la iu"> pylint </strong>检测到在分隔列表元素(数字)的每个逗号后面需要一个空格。另外，<strong class="la iu"> pylint </strong>检测到元组(坐标)中逗号前有一个空格。但是，它无法检测到分隔每个键-值对的冒号后面缺少的空格。</p><p id="3284" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想澄清的是，PEP8指南并没有提到逗号、冒号或分号后需要空格。然而，这是一种普遍的做法，被大多数样式检查器检测为<strong class="la iu"> pylint </strong>。</p><h2 id="00ce" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">良好实践</h2><p id="cbd6" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">每个逗号、冒号和分号后面有空格，但前面没有。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="1c69" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">4.圆括号、方括号或大括号中的空格。</h1><h2 id="83b7" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">不良做法</h2><p id="33ab" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在圆括号、方括号或大括号中会立即使用空格。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="99b2" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">Pylint输出</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/421acd07feb3990152fe980e9215f6f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*1w3KU8qJTuK9RkSWUWWEkg.png"/></div></figure><p id="f959" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Pylint </strong>检测圆括号、中括号或大括号前后不允许有空格。</p><h2 id="527f" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">良好实践</h2><p id="263f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">圆括号、中括号或大括号内没有直接使用空格。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="47ba" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">5.关键字和默认参数</h1><h2 id="0ba5" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">关键字参数</h2><p id="e2db" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated"><strong class="la iu">参数</strong>是在调用<strong class="la iu">函数</strong>时传递给它的值。Python函数接受两种类型的参数:(1) <strong class="la iu">位置参数</strong>，以及(2) <strong class="la iu">关键字参数</strong>。使用<strong class="la iu">位置参数</strong>调用函数时，参数必须以正确的顺序包含。相反，<strong class="la iu">关键字参数</strong>可以以任意顺序提供，因为这些参数前面有一个标识符(<strong class="la iu">关键字=值</strong>)。根据<strong class="la iu"> PEP8 </strong>，当使用<strong class="la iu">关键字参数</strong>调用函数时，我们不必在=符号周围使用空格。</p><h2 id="c37d" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated"><strong class="ak">默认参数</strong></h2><p id="1540" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated"><strong class="la iu">函数参数</strong>可以有<strong class="la iu">默认值</strong>。如果在调用函数时没有提供参数，参数将采用默认值。和以前一样，在定义<strong class="la iu">默认参数</strong>时，等号两边不使用空格。</p><h2 id="0014" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">不良做法</h2><p id="264d" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">当使用<strong class="la iu">关键字</strong>和<strong class="la iu">默认</strong>参数时，在=符号周围使用空格。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="0dc3" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">Pylint输出</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/680b6bf5e484172a72fea8d9938ab791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*loytZyxJcluPLuRbrgsGjQ.png"/></div></div></figure><p id="cf3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Pylint </strong>检测关键字参数周围不允许有空格。</p><h2 id="be13" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">良好实践</h2><p id="9b2b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">等号两边不使用空格。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="215f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">6.捕捉异常</h1><p id="c2f0" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Python中的错误消息可以分为两种:<strong class="la iu">语法错误</strong>和<strong class="la iu">异常</strong>。<strong class="la iu">语法错误</strong>Python无法解释代码时出现，说明程序语法有问题。另一方面，<strong class="la iu">异常</strong>发生在代码执行过程中发生意外的事情时。</p><p id="ddde" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的代码块中，Python提供了一条消息，表明我们在尝试将字符串转换为十六进制数时遇到了<strong class="la iu">类型错误</strong>，因为<strong class="la iu">十六进制函数</strong>需要一个整数作为输入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9351" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了在Python中处理异常，我们使用了<strong class="la iu"> try </strong>和<strong class="la iu"> except </strong>语句。<strong class="la iu"> try子句</strong>包含可以引发异常的操作，<strong class="la iu"> except子句</strong>包含处理异常的代码。<strong class="la iu"> try子句</strong>逐个语句执行。但是，如果出现异常，则停止执行<strong class="la iu"> try语句</strong>，然后执行除语句之外的<strong class="la iu">。</strong></p><h2 id="719c" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">不良做法</h2><p id="b0e2" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">这里，except块中的代码在try块执行期间发生任何类型的异常时都会被执行。根据<strong class="la iu"> PEP8 </strong>指南，不建议使用除 <strong class="la iu">子句</strong>之外的裸<strong class="la iu">，因为它们会捕捉所有异常，包括<strong class="la iu"> SystemExit </strong>和<strong class="la iu"> KeyboardInterrupt </strong>异常，使得用Control-C中断程序更加困难</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="422d" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">Pylint输出</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/fda7b802415e857bc8bb633b4eb596ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*fGElFQuyIWCee6YFsn8wWA.png"/></div></figure><p id="d99c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Pylint </strong>检测到使用了除条款之外的空白<strong class="la iu">。</strong></p><h2 id="2155" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">良好实践</h2><p id="9da5" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们应该在except块中指定要处理的错误，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e691" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，程序捕捉到了<strong class="la iu">类型错误</strong>异常，但没有捕捉到其他异常。</p><h1 id="5354" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">7.布尔变量</h1><h2 id="dbdd" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">不良做法</h2><p id="f0d4" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在<strong class="la iu"> if语句</strong>中，使用<strong class="la iu">=</strong>或<strong class="la iu"> is </strong>比较<strong class="la iu">布尔</strong>变量与<strong class="la iu">真</strong>或<strong class="la iu">假</strong>是不正确的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="b65a" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">Pylint输出</h2><p id="3b09" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Pylint检测到与<strong class="la iu"> True </strong>的比较应该只是表达式(<strong class="la iu"> is_raining </strong>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/fd5ecbd7ca404fbece4d85c0592f64c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGJ0P_pkFcfuNBoAX31FSQ.png"/></div></div></figure><h2 id="248b" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">良好实践</h2><p id="7247" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们必须在<strong class="la iu"> if语句</strong>中直接使用<strong class="la iu">布尔</strong>变量，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="db96" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">8.检查前缀和后缀</h1><h2 id="5dea" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">不良做法</h2><p id="d35f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">使用字符串切片来检查前缀或后缀是一种不好的做法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="e416" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">Pylint输出</h2><p id="7207" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">然而，<strong class="la iu"> pylint </strong>并没有检测到这个风格问题，虽然它包含在<strong class="la iu"> PEP 8 guide </strong>中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/1b0f71e1d8b57d26f62fec3665592179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*PgN8uthxQKZ3qlyHVP9dUg.png"/></div></figure><h2 id="0260" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">良好实践</h2><p id="3463" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">根据样式指南<strong class="la iu"> PEP8 </strong>，我们必须使用<strong class="la iu"> str.startswith() </strong>和<strong class="la iu"> str.endswith() </strong>来检查前缀或后缀。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d896" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> str.startswith(prefix，start，end) </strong>函数检查字符串是否以给定的前缀开头。如果字符串以指定的前缀开始，函数返回<strong class="la iu">True</strong>；否则，返回<strong class="la iu">假</strong>。<strong class="la iu">开始</strong>和<strong class="la iu">结束</strong>是可选参数，指定检查开始和结束的索引。</p><p id="754e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果字符串(<strong class="la iu"> str </strong>)以指定后缀结尾，函数将返回<strong class="la iu"> True </strong>。如果不是，则返回<strong class="la iu">假</strong>。与之前一样，该函数有两个可选参数<strong class="la iu"> start </strong>和<strong class="la iu"> end </strong>来指定测试开始和结束的索引。</p><h1 id="841a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak"> 9。进口</strong></h1><p id="5eba" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">一个<strong class="la iu">模块</strong>是由Python代码组成的文件。如果您正在处理大型项目，将您的代码组织到多个文件中，并在必要时将它们导入到其他Python文件中是有意义的。要导入一个Python模块，我们只需输入语句<strong class="la iu"> import </strong>，后跟文件名。除了导入我们自己的模块，我们还可以导入python标准库中以及第三方库中可用的内置模块。根据<strong class="la iu"> PEP8 </strong>准则，导入写在Python脚本的顶部，每一个都在一个单独的行上。此外，进口应按以下顺序分组:</p><ol class=""><li id="f938" class="oi oj it la b lb lc le lf lh ok ll ol lp om lt oy oo op oq bi translated">标准库导入</li><li id="5ab9" class="oi oj it la b lb or le os lh ot ll ou lp ov lt oy oo op oq bi translated">第三方进口</li><li id="dac3" class="oi oj it la b lb or le os lh ot ll ou lp ov lt oy oo op oq bi translated">本地脚本导入</li></ol><h2 id="74d9" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">不良做法</h2><p id="408a" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">导入没有写在单独的行中，也没有按正确的顺序分组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="b14c" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">Pylint输出</h2><p id="431f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Pylint 检测到模块pandas和matplotlib没有写在单独的行上。此外，<strong class="la iu"> Pylint </strong>检测到Python标准库模块(csv)应该放在第三方导入(pandas和matplotlib)之前。正如我们在下面所看到的，Pylint也认识到所有的导入都是未使用的，因为为了简单起见，我们没有添加更多的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/81fb0c59d577456f5b754b70571f3b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZNDqrJcMZ_ojIsH1ZScvPg.png"/></div></div></figure><h2 id="e9f5" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">良好实践</h2><p id="e14c" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">导入写在单独的行中，并按正确的顺序分组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="f4f2" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">10.λ表达式</h1><p id="6467" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Lambda表达式是匿名短期函数，语法如下:</p><blockquote class="pg ph pi"><p id="f1d8" class="ky kz pj la b lb lc ju ld le lf jx lg pk li lj lk pl lm ln lo pm lq lr ls lt im bi translated"><strong class="la iu"><em class="it">λ自变量:表达式</em> </strong></p></blockquote><p id="ed7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些函数可以有多个<strong class="la iu">参数</strong>，返回由<strong class="la iu">表达式</strong> <em class="pj">提供的值。</em>我们不仅可以在Python中找到它们；其他编程语言也支持lambda函数。</p><p id="776b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据<strong class="la iu"> PEP8指南</strong>，不建议将<strong class="la iu"> lambda函数</strong>直接分配给标识符。在这种情况下，建议使用<strong class="la iu">常规函数</strong>(用<strong class="la iu"> def </strong>关键字定义)。</p><h2 id="c44a" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">不良做法</h2><p id="c674" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">lambda表达式直接分配给标识符(乘法)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="1ec6" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">Pylint输出</h2><p id="c0b1" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated"><strong class="la iu"> Pylint </strong>没有检测到这个问题，尽管它包含在<strong class="la iu"> PEP 8 guide </strong>中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/e6563e82f17e265523a13df4c0bb98ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*B7UA6CvPucWFMIug_QstrA.png"/></div></figure><h2 id="a356" class="mw lv it bd lw nu nv dn ma nw nx dp me lh ny nz mg ll oa ob mi lp oc od mk oe bi translated">良好实践</h2><p id="3c25" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们用关键字<strong class="la iu"> def </strong>创建函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8911" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pylint并不完美，但它确实有助于提高代码质量！请记住，代码被阅读的次数要比被编写的次数多得多，这就是为什么坚持有助于他人理解您的代码的约定如此重要。此外，清晰的代码显示了专业性😉。这就是为什么我鼓励你使用像Pylint这样的质量检查器(还有很多！)来检查你的代码。看起来会更清晰，更专业👌</p></div></div>    
</body>
</html>