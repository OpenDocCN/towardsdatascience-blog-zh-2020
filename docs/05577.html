<html>
<head>
<title>How to Assign Labels with Sklearn One Hot Encoder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Sklearn One Hot编码器分配标签</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-assign-labels-with-sklearn-one-hot-encoder-e59a5f17df4f?source=collection_archive---------19-----------------------#2020-05-10">https://towardsdatascience.com/how-to-assign-labels-with-sklearn-one-hot-encoder-e59a5f17df4f?source=collection_archive---------19-----------------------#2020-05-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/7a80c997dc715a1c0168db765b21a8a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-GUUQ6OuD7M93kWWtAQ9Bg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://stock.adobe.com/ca/images/abstract-cyberspace-digital-world-and-future-technology-speed-power-and-a-breakthrough-to-success-3d-illustration-of-clusters-of-information-with-a-binary-code-element/311368290" rel="noopener ugc nofollow" target="_blank">图片</a>由<a class="ae jg" href="https://stock.adobe.com/ca/contributor/207151695/siarhei?load_type=author&amp;prev_url=detail" rel="noopener ugc nofollow" target="_blank"> Siarhei </a>拍摄</p></figure><div class=""/><div class=""><h2 id="c323" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">一个优雅的方式来改善sklearn一个热编码器，再也不用考虑新的列标签分配。</h2></div><p id="eeb5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大多数机器学习算法不能处理现成的分类数据。在预测建模中使用分类变量之前，通常将标签编码器或一个热编码器应用于分类变量。</p><p id="3a6a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python中的Sklearn库是大多数机器学习从业者的必去之地。它提供了出色的通用功能，允许我们用一行代码执行复杂的操作。同时，它的一些功能过于笼统，可能难以使用。</p><h1 id="2a53" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">一个热编码</h1><p id="bd16" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">一种热编码是将分类变量转换为N个二进制列的过程，其中N是原始列中唯一值的数量。例如，在我最近对新冠肺炎期间股价行为的研究中</p><div class="is it gp gr iu mr"><a rel="noopener follow" target="_blank" href="/covid-19-rampage-on-the-stock-market-machine-learning-comes-to-explain-3332707954af"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd jk gy z fp mw fr fs mx fu fw ji bi translated">新冠肺炎在股票市场上横冲直撞。机器学习来解释。</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">使用机器学习来识别新冠肺炎期间受打击最大的股票中的共同因素。</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">towardsdatascience.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf ja mr"/></div></div></a></div><p id="765b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我用<strong class="la jk">一个热门编码</strong>来分解行业分类</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ng"><img src="../Images/edb9d9b7d27abc442ba4b559e6852794.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*-TFFsuLIxXLxRCvWIdZa3g.png"/></div></div></figure><p id="f91a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">转换成二进制列表示，如下所示:</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nl"><img src="../Images/61e45f39696109e7fedd1bf944f417ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c9jfUQlQdbuZduNLPl8nkQ.png"/></div></div></figure><h1 id="fe90" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">履行</h1><p id="7694" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">使用默认的sklearn包可以完成一个热转换:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="403f" class="nr lv jj nn b gy ns nt l nu nv">sklearn.preprocessing.<strong class="nn jk">OneHotEncoder</strong></span><span id="1a8f" class="nr lv jj nn b gy nw nt l nu nv"># df = some DataFrame</span><span id="21cb" class="nr lv jj nn b gy nw nt l nu nv">encoder = OneHotEncoder()<br/>encoder.fit_transform(df)</span></pre><p id="20ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上述实现的代码输出如下所示:</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/3e81c85e11ac5dfd292b7cc2e5f3a66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*YP5hG-kMGGIAmBsGnkgl9A.png"/></div></figure><p id="9d8f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它是正确的，但是它不提供标签，这使得很难知道新列背后的含义。没有这些知识，分析预测模型的输出将是不可能的。在<a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank">文档</a>中提供了一些关于标签分配的指导，但这仍然是一个挑战。因此，需要一种更好的解决方案。</p><h1 id="0acc" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">自定义One Hot编码器</h1><p id="d9f2" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">向<strong class="la jk"> One Hot Encoder </strong>输出添加标签同时保持“一行”实现的一种优雅方式是创建一个包装器类，该类在<strong class="la jk"> transform() </strong>操作期间“在盒子内部”分配标签。代码如下:</p><figure class="nh ni nj nk gt iv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="98b1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用这个包装器，输出如下所示:</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/1fc7709958263a1439563e6a6858ecb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBVFKVgppeYVzxgg-Zk0YA.png"/></div></div></figure><p id="4d99" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我现在将分解它的实现，并详细解释它是如何工作的。</p><h1 id="bd9f" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">初始化</h1><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="dc78" class="nr lv jj nn b gy ns nt l nu nv">from sklearn.preprocessing import OneHotEncoder as SklearnOneHotEncoder</span><span id="3f9f" class="nr lv jj nn b gy nw nt l nu nv">class OneHotEncoder(SklearnOneHotEncoder):<br/>    def __init__(self<strong class="nn jk">, </strong>**kwargs):<br/>        super(OneHotEncoder<strong class="nn jk">, </strong>self).__init__(**kwargs)<br/>        self.fit_flag = False</span></pre><p id="ebb1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该类继承自sk learn . preprocessing . onehotencoder，这意味着所有原始功能都被保留。我还添加了<strong class="la jk"> self.fit_flag </strong>属性来跟踪编码器是否合适。</p><h1 id="eed4" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">合适的</h1><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="a9de" class="nr lv jj nn b gy ns nt l nu nv">def fit(self<strong class="nn jk">, </strong>X<strong class="nn jk">, </strong>**kwargs):<br/>    out = super().fit(X)<br/>    self.fit_flag = True<br/>    return out</span></pre><p id="75cd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> fit() </strong>法本质上是原来的<strong class="la jk"> fit() </strong>法。我用的是<strong class="la jk">超级()。fit(X) </strong>从<strong class="la jk">sk learn . preprocessing . onehotencoder</strong>中访问原始方法，然后在返回输出之前将<strong class="la jk"> self.fit_flag </strong>更新为<strong class="la jk"> True </strong>。</p><h1 id="ab44" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">改变</h1><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="2b3b" class="nr lv jj nn b gy ns nt l nu nv">def transform(self<strong class="nn jk">, </strong>X<strong class="nn jk">, </strong>**kwargs):<br/>    sparse_matrix = super(OneHotEncoder<strong class="nn jk">, </strong>self).transform(X)<br/>    new_columns = self.get_new_columns(X=X)<br/>    d_out = pd.DataFrame(sparse_matrix.toarray()<strong class="nn jk">, </strong>columns=new_columns<strong class="nn jk">, </strong>index=X.index)<br/>    return d_out</span><span id="9d32" class="nr lv jj nn b gy nw nt l nu nv">def get_new_columns(self<strong class="nn jk">, </strong>X):<br/>    new_columns = []<br/>    for i<strong class="nn jk">, </strong>column in enumerate(X.columns):<br/>        j = <strong class="nn jk">0<br/>        </strong>while j &lt; len(self.categories_[i]):<br/>            new_columns.append(f'{column}_&lt;{self.categories_[i][j]}&gt;')<br/>            j += <strong class="nn jk">1<br/>    </strong>return new_columns</span></pre><p id="99f2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Transform方法更加复杂，因为这是我实现标签分配的地方。首先创建<strong class="la jk"> sparse_matrix </strong>变量，存储原始<strong class="la jk"> transform() </strong>方法的输出。然后我调用我编写的<strong class="la jk"> get_new_column() </strong>方法来访问OneHotEncoder的内部属性以检索类名。</p><p id="f3b9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">get_new_columns ()方法本质上是一个两级嵌套迭代器。在第一级，我迭代原始数据帧中的列。在第二层，我迭代self.categories_[i]中的值，其中<strong class="la jk"> self.categories_ </strong>属于原始的OneHotEncoder，而“<strong class="la jk"> i </strong>”是被转换的表中的列的序号索引。在每一步，我都将列名附加到一个列表中，一旦迭代完成，这个列表就会返回。最终，<strong class="la jk"> new_columns </strong>变量<strong class="la jk"> </strong>的长度为<strong class="la jk"> </strong>相当于<strong class="la jk"> sparse_matrix </strong>转换为数组<strong class="la jk">后的水平维度。</strong></p><p id="e1a8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最后一步中，我使用内置功能将<strong class="la jk"> sparse_matrix </strong>转换为一个数组，然后使用由<strong class="la jk"> get_new_columns() </strong>方法返回的列名创建一个DataFrame。</p><h1 id="5658" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">拟合变换</h1><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="3a19" class="nr lv jj nn b gy ns nt l nu nv">def fit_transform(self<strong class="nn jk">, </strong>X<strong class="nn jk">, </strong>**kwargs):<br/>    self.fit(X)<br/>    return self.transform(X)</span></pre><p id="364f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一个方法包括顺序执行我修改过的<strong class="la jk"> fit() </strong>和<strong class="la jk"> transform() </strong>方法，返回一个带有指定列名的热数据帧。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/1fc7709958263a1439563e6a6858ecb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBVFKVgppeYVzxgg-Zk0YA.png"/></div></div></figure><h1 id="a5a6" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">结论</h1><p id="c648" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我希望这个教程对你有用。请随意抓取上面的代码片段，并在您自己的应用程序中使用它。</p><p id="6497" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编码快乐！</p></div></div>    
</body>
</html>