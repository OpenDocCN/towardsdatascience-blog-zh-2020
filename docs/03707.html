<html>
<head>
<title>LSTM for Stock Price Prediction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于股票价格预测的LSTM</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lstm-for-google-stock-price-prediction-e35f5cc84165?source=collection_archive---------5-----------------------#2020-04-07">https://towardsdatascience.com/lstm-for-google-stock-price-prediction-e35f5cc84165?source=collection_archive---------5-----------------------#2020-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d35a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为谷歌股价预测创建基于LSTM的递归神经网络的技术演练</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d6e5122aded459b1068a58e7d968e63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*puLlJudJvHOysoMWVUg8Dw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来自unsplash的Img通过<a class="ae ku" href="https://unsplash.com/photos/69ppqHiG9Xo" rel="noopener ugc nofollow" target="_blank">链接</a></p></figure><p id="5e3e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在本文中，我将一步一步地介绍如何建立一个基于LSTM的递归神经网络(RNN)来预测谷歌股票价格。它分为如下7个部分。</p><ol class=""><li id="9b7c" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">问题陈述</li><li id="5b1b" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">数据处理</li><li id="0b7d" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">模型结构</li><li id="efcc" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">模型编译</li><li id="9e8b" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">模型拟合</li><li id="c15b" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">模型预测法</li><li id="b6b7" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">结果可视化</li></ol><p id="9205" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们开始旅程吧🏃‍♀️🏃‍♂️.</p><ol class=""><li id="04b8" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><strong class="kx iu">问题陈述</strong></li></ol><p id="a75c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们得到了2012年1月至2016年12月的谷歌股价。任务是预测2017年1月的股价趋势。<em class="mf">注意，</em> <strong class="kx iu"> <em class="mf">基于布朗运动，股票价格的未来变化独立于过去</em>。因此，预测准确的股票价格是不可能的，但预测和捕捉上涨和下跌趋势是可能的。</strong></p><p id="b286" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">2.<strong class="kx iu">数据处理</strong></p><p id="9a2a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">2.1导入数据</p><p id="bb5d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">训练/测试数据保存在中。分别为<em class="mf"> csv </em>文件。我们将用<strong class="kx iu"> <em class="mf">开盘</em> </strong>价格进行预测。图1显示了训练集的一个片段及其散点图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/d9ee395216e4fe4bce99ef5821597a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*3aUkO5IuGLGBRmLgWjX9fQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图1训练集及其散点图</p></figure><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="eaf9" class="mm mn it mi b gy mo mp l mq mr">train = pd.read_csv(‘Google_Stock_Price_Train.csv’)</span><span id="5566" class="mm mn it mi b gy ms mp l mq mr">#keras only takes numpy array<br/>training_set = dataset_train.iloc[:, 1: 2].values</span></pre><p id="6635" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意<em class="mf"> dataset_train.iloc[:，</em><strong class="kx iu"><em class="mf">1:2</em></strong><em class="mf">]中的索引范围。值</em>，因为我们需要使它成为<strong class="kx iu"> NumPy数组，</strong>不是单个向量，也不是用于训练的<strong class="kx iu">数据帧</strong>。</p><p id="2790" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">2.2特征缩放</p><p id="ddf5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下一步是在(0，1)之间缩放股票价格，以避免密集的计算。常见的方法有<strong class="kx iu">标准化</strong>和<strong class="kx iu">正常化</strong>如图2所示。建议进行归一化，尤其是在输出层使用<em class="mf"> Sigmoid </em>函数处理RNN时。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/749b7f396c965dbd208e7510f2e53d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*B6PWE8REIu2gpWJKL0Oq_Q.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图2特征缩放方法(作者创建的Img)</p></figure><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="b62c" class="mm mn it mi b gy mo mp l mq mr">from sklearn.preprocessing import MinMaxScaler<br/>sc = MinMaxScaler(feature_range = (0, 1))</span><span id="eaf7" class="mm mn it mi b gy ms mp l mq mr">training_set_scaled = sc.fit_transform(training_set)</span></pre><p id="9058" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">2.3数据结构创建</p><blockquote class="mu"><p id="178d" class="mv mw it bd mx my mz na nb nc nd lq dk translated">创建<strong class="ak">滑动窗口很重要</strong>！</p></blockquote><p id="b27a" class="pw-post-body-paragraph kv kw it kx b ky ne ju la lb nf jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">需要一个特殊的数据结构来覆盖60个时间戳，基于此，RNN将预测第61个价格。这里，基于实验，过去时间戳的数量被设置为60。因此，<em class="mf"> X_train </em>是一个嵌套列表，它包含60个时间戳价格的列表。<em class="mf"> y_train </em>是第二天的股票价格列表，对应<em class="mf"> X_train </em>中的各个列表。具体来说，</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="2f44" class="mm mn it mi b gy mo mp l mq mr">X_train = []<br/>y_train = []<br/>for i in range(60, len(training_set_scaled)):<br/>    X_train.append(training_set_scaled[i-60: i, 0])<br/>    y_train.append(training_set_scaled[i, 0])<br/>    X_train, y_train = np.array(X_train), np.array(y_train)</span></pre><p id="d7f3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">图3显示了<em class="mf"> X_train </em>和<em class="mf"> y_train </em>的片段。<em class="mf"> X_train </em>中每一行60个价格用于预测<em class="mf"> y_train </em>中对应的第二天股票价格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/7fcbbb1ce171dd83f034ba9dff2a1cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*spEaQMCDsLllDNkcziFTVg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图3 <em class="nk"> X_train </em>和<em class="nk"> y_train </em>数据</p></figure><p id="0fa4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">2.4数据重塑</p><p id="83c7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如上所述，我们用<strong class="kx iu"> <em class="mf">开盘</em> </strong>价格进行预测。也就是说，我们只有一个指标或特征。但是我们可以按照同样的数据处理方法添加更多的指标。为此，我们需要为指标的<strong class="kx iu">数量添加一个新的维度。具体来说，</strong></p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="61b0" class="mm mn it mi b gy mo mp l mq mr">X_train = np.reshape(X_train, newshape = (X_train.shape[0], X_train.shape[1], 1))</span></pre><p id="264b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="mf">new shape</em>in(批量大小、时间戳数量、指示器数量)。<em class="mf">(批量大小，时间戳个数)是X_train </em>的形状。这里我们只有一个指标。</p><p id="7529" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">太好了。✌✌.，我们把训练器材准备好了</p><p id="60e3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">3.<strong class="kx iu">模型构建</strong></p><p id="4aa8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">基本上，我们正在使用LSTM </strong>构建一个用于连续值预测的神经网络回归器。首先，初始化模型。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="c4e3" class="mm mn it mi b gy mo mp l mq mr">regressor = Sequential()</span></pre><p id="31d6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，添加第一个LSTM图层，接着添加<strong class="kx iu">删除</strong>图层。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="295d" class="mm mn it mi b gy mo mp l mq mr">regressor.add(LSTM(units = 50, return_sequences = True, input_shape = (X_train.shape[1], 1)))</span><span id="fb1a" class="mm mn it mi b gy ms mp l mq mr">regressor.add(Dropout(rate = 0.2))</span></pre><p id="e4d1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意对于LSTM层，<em class="mf">单位</em>是该层中LSTM神经元的数量。50个神经元将赋予模型高维度，足以捕捉向上和向下的趋势。<em class="mf"> return_sequences </em>为真，因为我们需要在当前图层之后添加另一个LSTM图层。<em class="mf"> input_shape </em>对应的是时间戳的个数和指示器的个数。对于退出，50个神经元中的20%将在训练的每次迭代中被随机忽略。</p><p id="6804" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">按照上述相同的方法，添加第二，第三和第四LSTM层。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="7d57" class="mm mn it mi b gy mo mp l mq mr">##add 2nd lstm layer<br/>regressor.add(LSTM(units = 50, return_sequences = True))<br/>regressor.add(Dropout(rate = 0.2))</span><span id="2358" class="mm mn it mi b gy ms mp l mq mr">##add 3rd lstm layer<br/>regressor.add(LSTM(units = 50, return_sequences = True))<br/>regressor.add(Dropout(rate = 0.2))</span><span id="3c05" class="mm mn it mi b gy ms mp l mq mr">##add 4th lstm layer<br/>regressor.add(LSTM(units = 50, return_sequences = False))<br/>regressor.add(Dropout(rate = 0.2))</span></pre><p id="5158" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意最后一个LSTM层，<em class="mf"> return_sequences </em>是<strong class="kx iu"> <em class="mf"> False </em> </strong>由于我们不会添加更多的LSTM层。</p><p id="a1a6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，添加输出层。输出维度是1，因为我们每次预测1个价格。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="2ae5" class="mm mn it mi b gy mo mp l mq mr">regressor.add(Dense(units = 1))</span></pre><p id="9d02" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">太好了！我们已经创建了一个基于LSTM的RNN模型🧨🧨.</p><p id="0650" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">4.<strong class="kx iu">模型编译</strong></p><p id="8690" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，让我们通过选择一个<em class="mf"> SGD </em>算法和一个损失函数来编译RNN。对于优化器，我们使用<em class="mf"> Adam </em>，这是一个安全的选择。损失函数是实际值和预测值之间的均方误差。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="6f0f" class="mm mn it mi b gy mo mp l mq mr">regressor.compile(optimizer = ‘adam’, loss = ‘mean_squared_error’)</span></pre><p id="799f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">5.<strong class="kx iu">模型拟合</strong></p><p id="20f5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，让我们适合我们的RNN。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="3d98" class="mm mn it mi b gy mo mp l mq mr">regressor.fit(x = X_train, y = y_train, batch_size = 32, epochs = 100)</span></pre><p id="b61f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">RNN权重每32个股票价格更新一次，批量为32个。如果模型的损失没有收敛，请随意尝试更多的批次和时期。</p><p id="9f6b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">太好了，现在让我们开始训练。最后，我们发现从损失<strong class="kx iu"> <em class="mf"> 0.062 </em> </strong>开始，我们在时期50得到损失<strong class="kx iu"><em class="mf">0.0026</em></strong><em class="mf"/>，到时期100损失<strong class="kx iu"><em class="mf">0.0015</em></strong><em class="mf"/>🎉🎉。</p><p id="387c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">6.<strong class="kx iu">模型预测</strong></p><p id="9213" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">6.1导入测试数据</p><p id="24d3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用第2.1节中的相同方法，读取测试数据。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="ee0e" class="mm mn it mi b gy mo mp l mq mr">dataset_test = pd.read_csv(‘Google_Stock_Price_Test.csv’)</span><span id="9799" class="mm mn it mi b gy ms mp l mq mr">real_stock_price = dataset_test.iloc[:, 1: 2].values</span></pre><p id="f033" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">6.2数据处理</p><p id="f9cd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，我们需要连接用于预测的训练和测试数据集，因为我们使用前60天的股票价格来预测第二天的价格。换句话说，我们需要测试数据集中第一个日期之前60天的价格。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="e633" class="mm mn it mi b gy mo mp l mq mr">dataset_total = pd.concat((dataset_train[‘Open’],dataset_test[‘Open’]), axis = 0)</span></pre><p id="3aa6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，为预测创建输入，从测试数据集中第一个日期之前60天的日期开始索引。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="2301" class="mm mn it mi b gy mo mp l mq mr">inputs = <br/>dataset_total[len(dataset_total)-len(dataset_test)- 60: ].values</span></pre><p id="944a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第三，改变输入的形状，使其只有一列。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="aebb" class="mm mn it mi b gy mo mp l mq mr">inputs = inputs.reshape(-1, 1)</span></pre><p id="f39d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第四，使用由训练集设置的标度，对测试输入进行标度。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="1ac9" class="mm mn it mi b gy mo mp l mq mr">inputs = sc.transform(inputs)</span></pre><p id="0894" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，创建测试数据结构，如第2.3节所述。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="f220" class="mm mn it mi b gy mo mp l mq mr">X_test = []<br/>for i in range(60, len(inputs)): <br/>    X_test.append(inputs[i-60: i, 0])<br/>    X_test = np.array(X_test)<br/>    #make numpy array as 3D , adding num of indicator<br/>    X_test = np.reshape(X_test, newshape = (X_test.shape[0],  <br/>                        X_test.shape[1], 1))</span></pre><p id="01ec" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">6.3模型预测</p><p id="5904" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，<em class="mf"> X_test </em>准备好预测了。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="7c9f" class="mm mn it mi b gy mo mp l mq mr">predicted_stock_price = regressor.predict(X_test)</span></pre><p id="609c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">别忘了，我们预测的是缩放后的值，所以我们需要反转预测。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="8cbc" class="mm mn it mi b gy mo mp l mq mr">predicted_stock_price = sc.inverse_transform(predicted_stock_price)</span></pre><p id="3f5c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">7.<strong class="kx iu">结果可视化</strong></p><p id="7f48" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在最后一步中，让我们创建一个可视化图来轻松地检查预测。</p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="58cb" class="mm mn it mi b gy mo mp l mq mr">plt.plot(real_stock_price, color = ‘red’, label = ‘Real price’)<br/>plt.plot(predicted_stock_price, color = ‘blue’, label = ‘Predicted price’)<br/>plt.title(‘Google price prediction’)<br/>plt.xlabel(‘Time’)<br/>plt.ylabel(‘Price’)<br/>plt.legend()<br/>plt.show()</span></pre><p id="27ed" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如图4和图5所示，预测滞后于真实值，因为模型不能对非线性变化做出快速反应。但另一方面，模型对平滑变化反应良好。<strong class="kx iu">因此，我们得出结论，在包含峰值的预测部分，模型滞后于实际价格，但在包含平稳变化的部分，模型设法遵循向上和向下的趋势</strong> ✨✨.</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/2cefd56f978d8c9035a77b9c8e5c8e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*S-eJvPx_43IoHnswYsAKMQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图4实际价格与预测价格</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/0c9d53ab332fcf09b9f563f2b0edb61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*LyoAVWmA46Zpgu8w8ACbdw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图5大时间尺度上的预测</p></figure><p id="1eb1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">太好了！这就是所有的旅程！如果需要源代码，请访问我的</strong><a class="ae ku" href="https://github.com/luke4u/Time_Series_Forecasting" rel="noopener ugc nofollow" target="_blank"><strong class="kx iu">Github</strong></a><strong class="kx iu">页面🤞🤞。</strong></p></div></div>    
</body>
</html>