<html>
<head>
<title>K-Means in Marketing Analysis: Clustering 210 US DMAs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">营销分析中的 K-Means:聚类 210 个美国 DMA</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/k-means-in-marketing-analysis-clustering-210-us-dmas-deb9e60e3fe5?source=collection_archive---------30-----------------------#2020-03-22">https://towardsdatascience.com/k-means-in-marketing-analysis-clustering-210-us-dmas-deb9e60e3fe5?source=collection_archive---------30-----------------------#2020-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f77e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从头到尾的 K-Means 聚类分析</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bd793975f07b9ec4202b0cf1acf220b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yM46m-adUMqoIfl8gkAufQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">佩德罗·拉斯特拉在<a class="ae ky" href="https://unsplash.com/s/photos/chicago?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我可以将机器学习技术应用于日常营销问题时，这让我非常兴奋。给你一些背景，我在一家大型广告公司工作，我的一些客户是美国的顶级广告商，他们的产品和服务覆盖整个国家，他们有很多营销预算要花(每年大约 9 位数！).所以我们的工作就是帮助他们聪明高效地花钱！</p><p id="93a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">挑战之一是为所有当地市场制定战略，即 DMA(<strong class="lb iu">DMA</strong>代表“<strong class="lb iu">指定市场区域</strong>”，也可能被称为媒体市场)。美国有 210 个 DMA，你当然可以按地区划分，或者简单地按西部、东部和中部划分。然而，考虑到大区域内的人口统计和经济差异，我们可能希望使用一些更数据驱动的方式来查看所有这些 DMA。因此，今天我将使用聚类来获得几个市场聚类，每个聚类中具有最大的相似性。</p><p id="2ab5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在深入细节之前，我想给你看一下我在探索机器学习时最喜欢的图表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/50f5fdd0402d4e7ac2200d739c419b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDeVZYSC06oeGTwgGY2y6Q.png"/></div></div></figure><p id="d991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">聚类属于<strong class="lb iu">无监督学习</strong>的分支，该分支在没有预先存在标签的数据集中寻找以前未检测到的模式。聚类背后的主要思想是，您希望以一种方式将对象分组到相似的类中，即同一组的成员之间的相似性高，而不同组的相似性低。</p><p id="e1cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最流行和最广泛使用的算法是<strong class="lb iu"> K-Means 聚类算法。</strong>k-means 聚类算法是一种迭代算法，在未标记的数据集中达到预定数量的聚类，基本工作方式如下:</p><ol class=""><li id="413a" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">选择𝑘初始种子</li><li id="337b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">将每个观察值分配给具有最近平均值(最小平方欧几里得距离)的聚类</li><li id="1b3b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">为分配给每个聚类的观测值重新计算聚类质心</li><li id="79d1" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">继续迭代，直到质心没有变化</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/b3fa8308a4fab01285cbe6f1bb773325.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*te0cLb3k-bDR34-VO15WjA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">k 表示聚类示例(k = 7)</p></figure><p id="53e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于 k-means 聚类算法来说，两个假设非常重要:</p><ol class=""><li id="261d" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">要计算“聚类中心”，需要计算属于该聚类的所有点的(算术)平均值。在每次新的迭代开始时，重新计算每个聚类中心</li><li id="076a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">在重新计算聚类中心之后，如果给定点现在比其当前聚类的中心更靠近不同的聚类中心，则该点被重新分配给最近的中心</li></ol></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="f641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将用一个营销支出数据集来演示它在 Python 中是如何工作的，这个数据集是我从一家研究公司 Kantar 收集的，它是过去两年中排名前 30 位的科技公司的数据。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9a00" class="mx my it mt b gy mz na l nb nc">market.head(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/a419fc094d77eb6b68748df94ad10719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lvv1bOz8ev20kDpPw80O8w.jpeg"/></div></div></figure><p id="d3b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据字典</strong></p><ul class=""><li id="e6d4" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu ne mc md me bi translated">市场:指定市场区域(DMA)是指人们可以接收相同电视和广播电台节目的区域，也可能包括其他类型的媒体，包括报纸和互联网内容</li><li id="1fcb" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ne mc md me bi translated">媒体:10 种常见媒体类型，包括电视、广播、户外、数字等。</li><li id="657c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ne mc md me bi translated">观众人口:12 岁以上的电视/广播观众人口</li><li id="78e0" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ne mc md me bi translated">公司/品牌:在该市场做广告的公司/品牌数量</li><li id="27bd" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ne mc md me bi translated">IsTop31:电信行业对市场重要性的主观分类。0 表示不是前 31 名市场，1 表示前 31 名市场</li><li id="7f5d" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ne mc md me bi translated">Spend_K:以千美元计的媒体支出(000)</li></ul><p id="181e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">预处理分类值</strong></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8bde" class="mx my it mt b gy mz na l nb nc">#Change MARKETS to categorical <br/>market['DMA_Code']=market['DMA_Code'].astype('category')</span><span id="3fe0" class="mx my it mt b gy nf na l nb nc">#One Hot Encoding for Media and Industry</span><span id="8bfe" class="mx my it mt b gy nf na l nb nc">from sklearn.preprocessing import LabelBinarizer</span><span id="53dc" class="mx my it mt b gy nf na l nb nc">def labelcoder(data, column):<br/>    onehot = data.copy()<br/>    lb=LabelBinarizer()<br/>    lb_results = lb.fit_transform(onehot[column])<br/>    lb_results_df = pd.DataFrame(lb_results, columns=lb.classes_)<br/>    return lb_results_df</span><span id="6036" class="mx my it mt b gy nf na l nb nc">media_features = labelcoder(market, 'MEDIA')<br/>industry_features = labelcoder(market, 'INDUSTRY')<br/>division_features = labelcoder(market, 'Division_Name')</span><span id="7230" class="mx my it mt b gy nf na l nb nc">#Put them all together<br/>market_df = pd.concat([market['DMA_Code'],scaled_features, media_features, industry_features, division_features], axis=1)</span></pre><p id="acd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">标准化数字特征</strong></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="34aa" class="mx my it mt b gy mz na l nb nc">num_features = market[['Audience Population','BRAND','Company','IsTop31','Spend_K']]</span><span id="954e" class="mx my it mt b gy nf na l nb nc">from sklearn.preprocessing import MinMaxScaler<br/>#Scale the numerical features<br/>scaler = MinMaxScaler()<br/>scaled = scaler.fit_transform(num_features)<br/>scaled_features = pd.DataFrame(scaled, columns = num_features.columns)</span></pre><h2 id="ce87" class="mx my it bd ng nh ni dn nj nk nl dp nm li nn no np lm nq nr ns lq nt nu nv nw bi translated"><strong class="ak">设置 K-Means </strong></h2><p id="7f8d" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated"><strong class="lb iu">用肘法求最优 K</strong></p><p id="b40c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一步非常重要，因为我们不仅想要任意数量的聚类，还想要找到尽可能多地分隔数据点而不引入整体复杂性的 K 的数量。常用的度量是<strong class="lb iu">惯性——样本到其最近聚类中心的平方距离之和</strong></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0bcb" class="mx my it mt b gy mz na l nb nc">import matplotlib.pyplot as plt<br/>from sklearn.cluster import KMeans</span><span id="2eeb" class="mx my it mt b gy nf na l nb nc">sum_of_squared_distances = []</span><span id="ce76" class="mx my it mt b gy nf na l nb nc">K = range(1,20)<br/>for k in K:<br/>    km = KMeans(n_clusters=k) <br/>    km = km.fit(market_df)<br/>    sum_of_squared_distances.append(km.inertia_)</span><span id="e9d3" class="mx my it mt b gy nf na l nb nc"><br/>plt.plot(K, sum_of_squared_distances, 'bx-')<br/>plt.xlabel('k')<br/>plt.ylabel('Sum of Squared Distances to the Nearest Cluster')<br/>plt.title('Elbow Method For Optimal k')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/14eb183d3caecac2c0ce03e307b6d2ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*vJHcDhgTuDOdnehtWW-kow.png"/></div></figure><p id="9ecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图所示，收益递减达到 k = 3。在 k =3 之后，度量以慢得多的速度变得更好。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e40b" class="mx my it mt b gy mz na l nb nc">#Fit the model with k = 3<br/>k_means = KMeans(n_clusters=3, random_state=0).fit(market_df)<br/>cluster_preds = k_means.predict(market_df)<br/>k_means.get_params</span></pre><p id="0244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">使用 Calinski Harabasz 评分(方差比)评估聚类适合度</strong></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7ce2" class="mx my it mt b gy mz na l nb nc">from sklearn.metrics.cluster import calinski_harabasz_score </span><span id="d6ce" class="mx my it mt b gy nf na l nb nc">calinski_harabasz_score(market_df, cluster_preds)</span><span id="a424" class="mx my it mt b gy nf na l nb nc">39451.77110587817</span></pre><h2 id="6745" class="mx my it bd ng nh ni dn nj nk nl dp nm li nn no np lm nq nr ns lq nt nu nv nw bi translated">解释</h2><p id="e406" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">理解 k-means 聚类结果不像解释监督学习结果那样容易，因为我们本质上是在寻找数据的“底层”模式，并且经常需要领域知识。</p><p id="d801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们可以查看描述性统计数据来了解这些分类。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6317" class="mx my it mt b gy mz na l nb nc">n_clusters = 3<br/>k_means_cluster_stats = pd.DataFrame()</span><span id="aca5" class="mx my it mt b gy nf na l nb nc">for i in range(n_clusters):<br/>    k_means_cluster_stats['Cluster ' + str(i+1)] = market_df[k_means.labels_ == i].mean(axis=0)<br/>      <br/>k_means_cluster_stats = k_means_cluster_stats.T</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/3933daa23e9bb57ac6fc4a1581a40cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*05CD5nk41EYsAwdCIHQmoQ.jpeg"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/755821fef602f2adccb54e4dfc963458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWtw8jT_E5BxYxrbg70Eeg.png"/></div></div></figure><p id="85bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看出，集群 2 拥有最大的平均受众群体和最高的平均支出水平，这可能表明这一组市场是排名前 30 位的科技公司的主要关注点或领域。</p><ul class=""><li id="c864" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu ne mc md me bi translated">集群 0 和集群 2 混合了不同的部门，而集群 1 只有西部市场</li><li id="425c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ne mc md me bi translated">集群 0 的本地支出中值最高，数字支出的百分比也很高</li><li id="3cfb" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ne mc md me bi translated">第 1 组主要是户外活动，数字消费相对较低</li><li id="0bb1" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ne mc md me bi translated">群组 2 的广告电视支出最高</li></ul><p id="a135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的关注，希望这对您的集群项目有所帮助！</p><p id="e0d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的代码可以在我的 github <a class="ae ky" href="https://github.com/bonniema/Competitive_Spend_Classifier" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>