<html>
<head>
<title>CLAHE and Thresholding in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的分类和阈值处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/clahe-and-thresholding-in-python-3bf690303e40?source=collection_archive---------5-----------------------#2020-07-03">https://towardsdatascience.com/clahe-and-thresholding-in-python-3bf690303e40?source=collection_archive---------5-----------------------#2020-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ece0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python 中使用 OpenCV 的对比度受限的自适应直方图均衡化和阈值化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b039ebcbcc2bfa10593fcff497cf77a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7u1LqkZg7h515SkC0E2Ptw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@philinit?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">菲利普·莱昂</a>在<a class="ae ky" href="https://unsplash.com/s/photos/contrast?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="8dce" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="4282" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们来谈谈直方图均衡化和图像阈值。直方图均衡化是我们用于图像预处理的工具之一，它使图像阈值化或分割任务变得更容易。</p><p id="9bf5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们需要直方图均衡化的原因是，当我们收集褪色的图像或低对比度的图像时，我们可以拉伸直方图以跨越整个范围。</p><p id="afbc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看一个例子，图像是用电子显微镜采集的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/1563a5980f2457a4fa90205f28c7f3d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*Dj5RpaN8IfVnb1CfREgyxQ.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试图像</p></figure><p id="1dbc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在上面的图像中，我们可以看到分离，但它并不清楚。因此，让我们看看直方图，并使用均衡来拉伸直方图，以设定阈值。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1708" class="my la it mu b gy mz na l nb nc">import cv2<br/>import numpy as np<br/>from matplotlib import pyplot as plt </span><span id="c7af" class="my la it mu b gy nd na l nb nc">img = cv2.imread("test.jpg", 0)<br/>equ = cv2.equalizeHist(img)</span></pre><p id="f198" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，我将我的图像读取为灰度，并将其赋给变量<code class="fe ne nf ng mu b">img</code>。为了执行直方图均衡化，我们可以运行<code class="fe ne nf ng mu b">cv2.equalizeHist(img)</code>。</p><p id="1c59" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看看测试图像的直方图。你可以看到它向右侧倾斜。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="18b8" class="my la it mu b gy mz na l nb nc">plt.hist(img.flat, bins=100, range=(0, 255))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/8fc128575ab96e66893d9a78b33aa20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*n_ggmK6Xe3f-Lru61FzIXA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">均衡前</p></figure><p id="0068" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看看均衡图像的直方图。你可以看到直方图一直延伸到 255。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9c45" class="my la it mu b gy mz na l nb nc">plt.hist(equ.flat, bins=100, range=(0, 255))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/e9e5e73c1cefbaa74e7d8c8de302c4ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*SBNi01euwIu-nkd4YrpTQw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">均衡后</p></figure><p id="954e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面是直方图均衡化图像的结果，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/5c13055da5cd6c0253733b138385feb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cq1S75U3STDYD2sOQICf4A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">均衡图像</p></figure><p id="f19c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如你所看到的，上面的图像中有很多噪声，因为它考虑了图像的全局对比度，而不仅仅是局部对比度。因此，执行全局均衡可能无法很好地处理您的图像，在这种情况下，我们可以使用<strong class="lt iu">自适应直方图均衡</strong>或称为<strong class="lt iu"> CLAHE(对比度限制自适应直方图均衡)</strong>。</p><h2 id="77c2" class="my la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated">对比度限制自适应直方图均衡化(CLAHE)</h2><p id="bed9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对比度受限的 AHE ( <strong class="lt iu"> CLAHE </strong>)是自适应直方图均衡化的变体，其中对比度放大是受限的，以便减少噪声放大的问题。简而言之，CLAHE 以高精度和对比度限制在小块或小块中进行直方图均衡化。</p><p id="cdfb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们知道了 CLAHE 是什么，让我们看看如何设置它。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="05d8" class="my la it mu b gy mz na l nb nc">clahe = cv2.createCLAHE(clipLimit =2.0, tileGridSize=(8,8))<br/>cl_img = clahe.apply(img)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/69395bf0b3a5a9bfb46e79042e934508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSIUQ5A2VAvRHFhLA8__JA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CLAHE 图像</p></figure><p id="840c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如你从上面的图片中看到的，CLAHE 给出了比普通均衡图像更好的结果。但它仍然有很多噪声，让我们看看如何阈值工作，以获得更好的结果。</p><blockquote class="nv nw nx"><p id="8f82" class="lr ls ny lt b lu mn ju lw lx mo jx lz nz mp mc md oa mq mg mh ob mr mk ml mm im bi translated"><strong class="lt iu">为了获得更好的图像效果，使用</strong> <code class="fe ne nf ng mu b"><strong class="lt iu">.tiff</strong></code> <strong class="lt iu">文件格式，而不是</strong> <code class="fe ne nf ng mu b"><strong class="lt iu">.jpeg</strong></code> <strong class="lt iu">文件格式</strong></p></blockquote><p id="bc1a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在开始阈值处理之前，我们需要看看 CLAHE 图像的直方图。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="fb04" class="my la it mu b gy mz na l nb nc">plt.hist(cl_img.flat, bins=100, range=(100, 255))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/088da2d035cc6616888c64ce6ed0df84.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*97mJenI78XpU7IymMOI97w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CLAHE 图像直方图</p></figure><p id="7e23" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">从上面的直方图可以看出，在 160–200 之间有一个倾角，我们可以确定一个接近的数字来分隔这两个峰值。在我们决定一个接近的数字后，我们可以用它来做阈值(我选择了 190)</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="20a6" class="my la it mu b gy mz na l nb nc">ret, thresh1 = cv2.threshold(cl_img, 190, 150, cv2.THRESH_BINARY)<br/>ret, thresh2 = cv2.threshold(cl_img, 190, 255, cv2.THRESH_BINARY_INV)</span></pre><p id="e0cd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">忽略第一个参数<code class="fe ne nf ng mu b">ret</code>，我们可以得到阈值图像的变量<code class="fe ne nf ng mu b">thresh1</code>和<code class="fe ne nf ng mu b">thresh2</code>。在上面的代码部分中，第一个参数是图像，其次是我们选择的阈值，第三，我们需要给所有被阈值化的像素赋予一个值，最后，我们需要给出一个方法。我给了<code class="fe ne nf ng mu b">THRESH_BINARY</code>和<code class="fe ne nf ng mu b">THRESH_BINARY_INV</code>来分开变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/434781cde4b80b88f109efa9a22f8ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFQ5KKSWS14PVwQfMN-X2w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">左阈值 2 和右阈值 1</p></figure><p id="cf94" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在第一阈值图像(<code class="fe ne nf ng mu b">thresh1</code>)中，灰度值为 150，第二阈值图像(<code class="fe ne nf ng mu b">thresh2</code>)的灰度值为 255。这只是基于直方图的阈值处理。</p><p id="45e8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在上面的例子中，我们通过参考直方图发现值 190 是最佳值。但是使用 OTSU 有一种更简单的方法来找到最佳值。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="736c" class="my la it mu b gy mz na l nb nc">ret, thresh3 = cv2.threshold(cl_img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span></pre><p id="3263" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用 OTSU，我们可以自动分割它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/93bbd5c4bdffcce04fde5b846e3aee6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jX58SARjQjTnJi4sfIPAQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阈值 3 — OTSU</p></figure><p id="c429" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果使用二进制阈值，OTSU 是找到最佳值的最佳方法。如果有必要，你甚至可以使用 K-means。</p><p id="a158" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">文章到此为止。如果你的图像有噪声，不要忘记先去噪。然后你可以做所有这些练习。</p><h1 id="a88d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="488a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">总结一下，CLAHE 在大多数情况下都很有效。然后，您可以使用直方图将图像分为这两个阶段，但如果您不想绘制直方图来识别分离，则可以使用 OTSU。</p><h2 id="1ba0" class="my la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated">资源</h2><div class="of og gp gr oh oi"><a href="https://www.youtube.com/channel/UC34rW-HtPJulxr5wp2Xa04w" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">Sreeni 为显微镜专家开发的 Python</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">本频道将带您了解学习 Python 编码的整个过程；从基础到高级…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">www.youtube.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div></div></div>    
</body>
</html>