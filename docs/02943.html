<html>
<head>
<title>Data Structures in C++ — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的数据结构—第 1 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-structures-in-c-part-1-b64613b0138d?source=collection_archive---------1-----------------------#2020-03-21">https://towardsdatascience.com/data-structures-in-c-part-1-b64613b0138d?source=collection_archive---------1-----------------------#2020-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="68b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在 C++中实现通用数据结构</h2></div><p id="d989" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">C++是支持创建类的 C 编程语言的扩展，因此被称为“<em class="le"> C with classes </em>”。它用于创建高性能应用程序，并为我们提供对计算资源的高级控制。在本文中，我将向您展示我在上一篇文章<a class="ae lf" rel="noopener" target="_blank" href="/8-common-data-structures-every-programmer-must-know-171acf6a1a42">每个程序员都必须知道的 8 种常见数据结构</a>中讨论的 4 种数据结构的 C++实现。</p><div class="lg lh gp gr li lj"><a rel="noopener follow" target="_blank" href="/8-common-data-structures-every-programmer-must-know-171acf6a1a42"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">每个程序员都必须知道的 8 种常见数据结构</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">数据结构是一种在计算机中组织和存储数据的专门方法，以这种方式我们可以执行…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">towardsdatascience.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx ly lj"/></div></div></a></div><p id="403f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们深入研究代码。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/5749be8dc9db4f357682eca64e9e7c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_MO-0EKkLiMlEPbGrqUyog.jpeg"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">由<a class="ae lf" href="https://unsplash.com/@maxcodes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">麦克斯韦·纳尔逊</a>在<a class="ae lf" href="https://unsplash.com/s/photos/c%2B%2B-programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="84bc" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">1.数组</h1><p id="adef" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">一个<strong class="kk iu">数组</strong>是一个固定大小的结构，可以保存相同数据类型的项目。数组是有索引的，这意味着随机访问是可能的。在许多编程语言中，数组通常以本机数据结构的形式出现。然而，不要把<code class="fe nl nm nn no b">array</code>和像 python 这样的语言中的<code class="fe nl nm nn no b">list</code>这样的数据结构混淆。让我们看看数组是用 C++表示的；</p><pre class="ma mb mc md gt np no nq nr aw ns bi"><span id="e951" class="nt mp it no b gy nu nv l nw nx">// simple declaration<br/>int array[] = {1, 2, 3, 4, 5 };<br/>// in pointer form (refers to an object stored in heap)<br/>int * array = new int[5];<!-- --> </span></pre><p id="3bf3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们已经习惯了更友好的<code class="fe nl nm nn no b">vector&lt;T&gt;</code>数据结构，我们可以将数据推送到这种结构，而不用担心数据的大小。让我们看看如何实现一个我们自己的<code class="fe nl nm nn no b">list</code>数据结构，它可以自己调整大小。</p><pre class="ma mb mc md gt np no nq nr aw ns bi"><span id="6595" class="nt mp it no b gy nu nv l nw nx">using namespace std;<br/><br/>class DynamicArray<br/>{<br/>private:<br/>    int size_;<br/>    int max_;<br/>    int *arrayholder_;<br/><br/>public:<br/>    DynamicArray()<br/>    {<br/>        this-&gt;size_ = 0;<br/>        this-&gt;max_ = 5;<br/>        this-&gt;arrayholder_ = new int[5];<br/>    }<br/><br/>    ~DynamicArray()<br/>    {<br/>        delete[] this-&gt;arrayholder_;<br/>    }<br/><br/>    int size()<br/>    {<br/>        return this-&gt;size_;<br/>    }<br/><br/>    int&amp; operator[](int i) <br/>    {<br/>        assert(i &lt; this-&gt;size_);<br/>        return this-&gt;arrayholder_[i];<br/>    }<br/><br/>    void add(int n)<br/>    {<br/>        if (this-&gt;max_ &lt; this-&gt;size_ + 1)<br/>        {<br/>            this-&gt;max_ *= 2;<br/>            int *tmp_ = new int[this-&gt;max_];<br/><br/>            for (size_t i = 0; i &lt; this-&gt;size_; i++)<br/>            {<br/>                tmp_[i] = this-&gt;arrayholder_[i];<br/>                <br/>            }<br/>            delete[] this-&gt;arrayholder_;<br/>            this-&gt;arrayholder_ = tmp_;<br/>            this-&gt;arrayholder_[this-&gt;size_] = n;<br/>            this-&gt;size_ += 1;<br/>        }<br/>        else <br/>        {<br/>            this-&gt;arrayholder_[this-&gt;size_] = n;<br/>            this-&gt;size_ += 1;<br/>        }<br/>    }<br/>};<br/><br/>int main(int argc, char **argv)<br/>{<br/>    DynamicArray darray;<br/>    vector&lt;int&gt; varray;<br/><br/>    for (size_t i = 0; i &lt;= 15; i++)<br/>    {<br/>        darray.add(i);<br/>    }<br/>    return 0;<br/>}</span></pre><p id="ab7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到上面的<code class="fe nl nm nn no b">DynamicArray</code>的初始大小为 5。同样在<code class="fe nl nm nn no b">add</code>函数中，我们可以看到，如果我们已经达到了最大容量，数组大小将被加倍和复制。这就是<code class="fe nl nm nn no b">vector&lt;T&gt;</code>数据结构在现实中的工作方式。通常，基数在 30 左右。知道这一点可能会在面试中有所帮助。</p><p id="86ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一点需要注意的是，我们同时使用了<strong class="kk iu">构造函数</strong>和<strong class="kk iu">析构函数</strong>。这是因为我们有一个指针指向随着数组扩展而分配的内存。必须释放这些分配的内存以避免溢出。这个实现的美妙之处在于用户不需要知道任何关于丑陋指针的事情。重载<code class="fe nl nm nn no b">operator[]</code>允许像本地数组一样进行索引访问。有了这些知识，让我们继续下一个数据结构，<strong class="kk iu">链表</strong>。</p><h1 id="3281" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">2.链接列表</h1><p id="f25c" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated"><strong class="kk iu">链表</strong>是一个顺序结构，由一系列相互链接的线性项目组成。您只需要知道遍历这个数据结构的链的一端。在大小频繁变化的情况下，使用数组可能没有优势，除非随机访问数据(除非实现收缩操作，否则扩展会导致更长的复制时间并使用更多内存)。因此，链表可以被认为是一种支持频繁大小变化和顺序访问的数据结构。</p><p id="253c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一下我们的实现。</p><pre class="ma mb mc md gt np no nq nr aw ns bi"><span id="14e1" class="nt mp it no b gy nu nv l nw nx">using namespace std;<br/><br/>template &lt;typename T&gt;<br/>class Node<br/>{<br/>    public:<br/>    T value;<br/>    Node *next;<br/>    Node *previous;<br/><br/>    Node(T value)<br/>    {<br/>        this-&gt;value = value;<br/>    }<br/>};<br/><br/>template &lt;typename T&gt;<br/>class LinkedList<br/>{<br/>    private:<br/>    int size_;<br/>    Node&lt;T&gt; *head_ = NULL;<br/>    Node&lt;T&gt; *tail_ = NULL;<br/>    Node&lt;T&gt; *itr_ = NULL;<br/><br/>    public:<br/>    LinkedList()<br/>    {<br/>        this-&gt;size_ = 0;<br/>    }<br/><br/>    void append(T value)<br/>    {<br/>        if (this-&gt;head_ == NULL)<br/>        {<br/>            this-&gt;head_ = new Node&lt;T&gt;(value);<br/>            this-&gt;tail_ = this-&gt;head_;<br/>        }<br/>        else<br/>        {<br/>            this-&gt;tail_-&gt;next = new Node&lt;T&gt;(value);<br/>            this-&gt;tail_-&gt;next-&gt;previous = this-&gt;tail_;<br/>            this-&gt;tail_ = this-&gt;tail_-&gt;next;<br/>        }<br/>        this-&gt;size_ += 1;<br/>    }<br/><br/>    void prepend(T value)<br/>    {<br/>        if (this-&gt;head_ == NULL)<br/>        {<br/>            this-&gt;head_ = new Node&lt;T&gt;(value);<br/>            this-&gt;tail_ = this-&gt;head_;<br/>        }<br/>        else<br/>        {<br/>            this-&gt;head_-&gt;previous = new Node&lt;T&gt;(value);<br/>            this-&gt;head_-&gt;previous-&gt;next = this-&gt;head_;<br/>            this-&gt;head_ = this-&gt;head_-&gt;previous;<br/>        }<br/>        this-&gt;size_ += 1;<br/>    }<br/><br/>    Node&lt;T&gt; * iterate()<br/>    {<br/>        if (this-&gt;itr_ == NULL) <br/>        {<br/>            this-&gt;itr_ = this-&gt;head_;<br/>        } <br/>        else <br/>        {<br/>            this-&gt;itr_ = this-&gt;itr_-&gt;next;<br/>        }<br/>        return this-&gt;itr_;<br/>    }<br/><br/>    T ptr()<br/>    {<br/>        return this-&gt;itr_-&gt;value;<br/>    }<br/><br/>    void resetIterator()<br/>    {<br/>        this-&gt;tail_ = NULL;<br/>    }<br/>};<br/><br/><br/>int main(int argc, char **argv)<br/>{<br/>    LinkedList&lt;int&gt; llist;<br/>    llist.append(10);<br/>    llist.append(12);<br/>    llist.append(14);<br/>    llist.append(16);<br/>    llist.prepend(5);<br/>    llist.prepend(4);<br/>    llist.prepend(3);<br/>    llist.prepend(2);<br/>    llist.prepend(1);<br/><br/>    cout &lt;&lt; "Printing Linked List" &lt;&lt; endl;<br/><br/>    while(llist.iterate() != NULL)<br/>    {<br/>        cout &lt;&lt; llist.ptr() &lt;&lt; "\t";<br/>    }<br/>    cout &lt;&lt; endl;<br/><br/>    return 0;<br/>}</span></pre><p id="0f32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们使用了一个叫做<strong class="kk iu">节点</strong>的支持结构。该<strong class="kk iu">节点</strong>将携带指向<strong class="kk iu">下一个</strong>项目和<strong class="kk iu">上一个</strong>项目的指针。通常有下一个项目<strong class="kk iu">就足够了。但是同时拥有<strong class="kk iu"> next </strong>和<strong class="kk iu"> previous </strong>可以提高 append 和 prepend 的性能，因为我们可以对两端进行访问。<strong class="kk iu"> <em class="le">追加</em> </strong>意味着我们将更新<strong class="kk iu"> <em class="le"> tail </em> </strong>指针的下一个元素，然后更新 tail 作为添加的项。反之，<strong class="kk iu"> <em class="le">前置</em> </strong>会创建一个新元素，并将其<strong class="kk iu">下一个</strong>项设置为当前<strong class="kk iu"> <em class="le">头</em> </strong>。请注意，我没有包括内存清理操作，因为我们不处理显式删除，并使代码更简单。但是，必须将它们放在单独的析构函数中，以避免内存泄漏。此外，我们使用一个简单的迭代器来打印项目。</strong></p><h1 id="83f1" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">3.大量</h1><p id="65c6" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">一个<strong class="kk iu">堆栈</strong>是一个<strong class="kk iu"> LIFO </strong>(后进先出——最后放置的元素可以首先访问)结构。尽管该数据结构具有不同的行为，但这可以被认为是仅具有<strong class="kk iu">头</strong>或对<strong class="kk iu">顶</strong>元素的访问的链表的派生。</p><pre class="ma mb mc md gt np no nq nr aw ns bi"><span id="e46b" class="nt mp it no b gy nu nv l nw nx">#include &lt;iostream&gt;<br/><br/>using namespace std;<br/><br/>template &lt;typename T&gt;<br/>class Node<br/>{<br/>public:<br/>    T value;<br/>    Node *next;<br/><br/>    Node(T value)<br/>    {<br/>        this-&gt;value = value;<br/>    }<br/>};<br/><br/>template &lt;typename T&gt;<br/>class Stack<br/>{<br/>private:<br/>    int size_;<br/>    Node&lt;T&gt; *top_ = NULL;<br/>    Node&lt;T&gt; *itr_ = NULL;<br/><br/>public:<br/>    Stack()<br/>    {<br/>        this-&gt;size_ = 0;<br/>    }<br/><br/>    void push(T value)<br/>    {<br/>        if (this-&gt;top_ == NULL)<br/>        {<br/>            this-&gt;top_ = new Node&lt;T&gt;(value);<br/>        }<br/>        else<br/>        {<br/>            Node&lt;T&gt; *tmp = new Node&lt;T&gt;(value);<br/>            tmp-&gt;next = this-&gt;top_;<br/>            this-&gt;top_ = tmp;<br/>        }<br/>        this-&gt;size_ += 1;<br/>    }<br/><br/>    Node&lt;T&gt; *pop()<br/>    {<br/>        Node&lt;T&gt; *tmp = this-&gt;top_;<br/><br/>        this-&gt;top_ = this-&gt;top_-&gt;next;<br/>        this-&gt;size_ -= 1;</span><span id="663e" class="nt mp it no b gy ny nv l nw nx">        return tmp;<br/>    }<br/><br/>    Node&lt;T&gt; *peek()<br/>    {<br/>        return this-&gt;top_;<br/>    }<br/><br/>    int size()<br/>    {<br/>        return this-&gt;size_;<br/>    }<br/><br/>    Node&lt;T&gt; *iterate()<br/>    {<br/>        if (this-&gt;itr_ == NULL)<br/>        {<br/>            this-&gt;itr_ = this-&gt;top_;<br/>        }<br/>        else<br/>        {<br/>            this-&gt;itr_ = this-&gt;itr_-&gt;next;<br/>        }<br/>        return this-&gt;itr_;<br/>    }<br/><br/>    T ptr()<br/>    {<br/>        return this-&gt;itr_-&gt;value;<br/>    }<br/><br/>    void resetIterator()<br/>    {<br/>        this-&gt;itr_ = NULL;<br/>    }<br/>};<br/><br/>int main(int argc, char **argv)<br/>{<br/>    Stack&lt;int&gt; stk1;<br/>    stk1.push(10);<br/>    stk1.push(12);<br/>    stk1.push(14);<br/>    stk1.push(16);<br/>    stk1.push(5);<br/>    stk1.push(4);<br/>    stk1.push(3);<br/>    stk1.push(2);<br/>    stk1.push(1);<br/><br/>    cout &lt;&lt; "Printing Stack" &lt;&lt; endl;<br/><br/>    while (stk1.iterate() != NULL)<br/>    {<br/>        cout &lt;&lt; stk1.ptr() &lt;&lt; "\t";<br/>    }<br/>    cout &lt;&lt; endl;</span><span id="c569" class="nt mp it no b gy ny nv l nw nx">    return 0;<br/>}</span></pre><p id="fb7b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，<strong class="kk iu">节点</strong>只有对<strong class="kk iu">下一个</strong>项目的引用。添加一个条目会更新数据结构的顶部。此外，移除和取回也是从顶部进行的。为此，我们分别使用<code class="fe nl nm nn no b">pop()</code>和<code class="fe nl nm nn no b">top()</code>方法。</p><h1 id="0aeb" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">4.行列</h1><p id="5cd1" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">一个<strong class="kk iu">队列</strong>是一个<strong class="kk iu"> FIFO </strong>(先进先出——放在最前面的元素可以最先被访问)结构。这可以被认为是堆栈的相反情况。简单来说，它是一个链表，我们从一端添加，从另一端读取。这模拟了车道上的真实世界。这里我们可以把一个<strong class="kk iu">节点</strong>结构想成如下。</p><pre class="ma mb mc md gt np no nq nr aw ns bi"><span id="5d40" class="nt mp it no b gy nu nv l nw nx">template &lt;typename T&gt;<br/>class Node<br/>{<br/>    public:<br/>    T value;<br/>    Node *next;<br/>    Node *previous;<br/><br/>    Node(T value)<br/>    {<br/>        this-&gt;value = value;<br/>    }<br/>};</span></pre><p id="06cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主要的数据结构是:</p><pre class="ma mb mc md gt np no nq nr aw ns bi"><span id="4968" class="nt mp it no b gy nu nv l nw nx">template &lt;typename T&gt;<br/>class Queue<br/>{<br/>    private:<br/>    int size_;<br/>    Node&lt;T&gt; *head_ = NULL;<br/>    Node&lt;T&gt; *tail_ = NULL;<br/><br/>    public:<br/>    Queue()<br/>    {<br/>        this-&gt;size_ = 0;<br/>    }<br/><br/>    void enqueue(T value)<br/>    {<br/>        if (this-&gt;head_ == NULL)<br/>        {<br/>            this-&gt;head_ = new Node&lt;T&gt;(value);<br/>            this-&gt;tail_ = this-&gt;head_;<br/>        }<br/>        else<br/>        {<br/>            this-&gt;tail_-&gt;next = new Node&lt;T&gt;(value);<br/>            this-&gt;tail_-&gt;next-&gt;previous = this-&gt;tail_;<br/>            this-&gt;tail_ = this-&gt;tail_-&gt;next;<br/>        }<br/>        this-&gt;size_ += 1;<br/>    }<br/><br/>    Node&lt;T&gt; dequeue()<br/>    {<br/>        Node&lt;T&gt; *tmp = this-&gt;tail_;<br/><br/>        this-&gt;tail_ = this-&gt;tail-&gt;previous;<br/>        this-&gt;tail_-&gt;next = NULL;</span><span id="33b6" class="nt mp it no b gy ny nv l nw nx">        this-&gt;size_ -= 1;</span><span id="a7b6" class="nt mp it no b gy ny nv l nw nx">        return tmp;<br/>    }<br/>};</span></pre><h1 id="14a1" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">最后的想法</h1><p id="1c01" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">我们已经使用 C++编程语言实现了 4 种常见的数据结构。我将在以后的文章中介绍其余的实现。</p><p id="6250" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望你们都觉得这些数组、链表、栈和队列的 C++实现很有用。你可以通过下面的链接查看我的其他关于数据结构的文章。</p><div class="lg lh gp gr li lj"><a rel="noopener follow" target="_blank" href="/8-useful-tree-data-structures-worth-knowing-8532c7231e8c"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">值得了解的 8 种有用的树数据结构</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">8 种不同树形数据结构的概述</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">towardsdatascience.com</p></div></div><div class="ls l"><div class="nz l lu lv lw ls lx ly lj"/></div></div></a></div><div class="lg lh gp gr li lj"><a rel="noopener follow" target="_blank" href="/self-balancing-binary-search-trees-101-fc4f51199e1d"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">自平衡二分搜索法树 101</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">自平衡二分搜索法树简介</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">towardsdatascience.com</p></div></div><div class="ls l"><div class="oa l lu lv lw ls lx ly lj"/></div></div></a></div><p id="ea7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读！如果你觉得这篇文章有用，请在你的网络中分享。</p><p id="5afa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干杯！</p></div></div>    
</body>
</html>