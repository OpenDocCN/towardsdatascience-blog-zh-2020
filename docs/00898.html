<html>
<head>
<title>Data Science with Julia: Linear Algebra</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia 的数据科学:线性代数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-with-julia-linear-algebra-ee612c20e84c?source=collection_archive---------11-----------------------#2020-01-26">https://towardsdatascience.com/data-science-with-julia-linear-algebra-ee612c20e84c?source=collection_archive---------11-----------------------#2020-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c800ca10954a5f182f160283731dbc44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEQAcWONKmjjnztVHLDsWg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="90af" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">Julia 中的线性代数—提示:它甚至比 Numpy 更简单</h2></div><p id="d931" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">说到数据科学，没有那么多编程语言可以选择。你可以用 Python 或者 R，或者最近用 Julia。如果你不知道 Julia 是什么，请参考我以前的一篇文章:</p><div class="is it gp gr iu lp"><a rel="noopener follow" target="_blank" href="/introducing-julia-an-alternative-to-python-and-r-for-data-science-dcbf98346253"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd jf gy z fp lu fr fs lv fu fw jd bi translated">Julia 简介:数据科学中 Python 和 R 的替代方案</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">迎接面向科学计算、数据科学和机器学习的 21 世纪编程语言。</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md ja lp"/></div></div></a></div><p id="bdca" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你不想读完整本书(这也很酷)，这里有一句总结:</p><blockquote class="me"><p id="0a7e" class="mf mg je bd mh mi mj mk ml mm mn lo dk translated">Julia 是一种编程语言，写起来像 Python，但运行起来像 c。</p></blockquote><p id="c850" class="pw-post-body-paragraph kt ku je kv b kw mo kf ky kz mp ki lb lc mq le lf lg mr li lj lk ms lm ln lo im bi translated">由于这些原因，我想给你，我的读者朋友，一本使用 Julia 编程语言的线性代数入门书。现在，这不是线性代数的完整课程<strong class="kv jf"/>，因为不可能在 5 分钟内教完(如果你不是你知道谁)，但是这篇文章将涵盖如何处理线性代数数据结构——向量和矩阵——以及如何用它们做很酷的事情。</p><p id="1905" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所以，是的，这篇文章假设你至少知道一些关于这个主题的东西，并且熟悉线性代数运算，比如说<strong class="kv jf"> Numpy </strong>，但是渴望看到 Julia 提供的东西。</p><p id="808e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">事不宜迟，我们开始吧！我假设你已经在 Jupyter 这样的环境中安装并运行了 Julia(如果你不参考上面的文章)。您只需要导入一个库，并且您可能会猜到是哪个库:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/c46e2d71852f0c719366197256b316c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*z9zeSyzi6t2kJ-1kuoTSKQ.png"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="b670" class="nf ng je bd nh ni nj nk nl nm nn no np kk nq kl nr kn ns ko nt kq nu kr nv nw bi translated">声明向量和矩阵</h1><p id="2922" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">如果我们不知道如何声明基本向量和矩阵，谈论特征分解和欧几里德范数是没有意义的。不过这很简单，我要说比用 Python 要简单一点(不确定 R)。</p><h2 id="ee11" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">单行矩阵</h2><p id="3cd3" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">要创建一个行向量，您需要用方括号将元素括起来，并且不要在元素之间放置逗号(如果放置逗号，您将得不到向量):</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/d872441fe557883c77af40a74864fee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*7dtW_D7lRMRsVa27edVXzQ.png"/></div></figure><h2 id="7a1e" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">列向量</h2><p id="eb07" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">以类似的方式，要生成列向量，您还需要在末尾加上一个单引号，其他事情都与行向量相同:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi op"><img src="../Images/a461ce2160718fdcd1e3d6e8a4a87082.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*h5PDKjL7XAKfWO9vmEtsXg.png"/></div></figure><h2 id="deaf" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">[数]矩阵</h2><p id="6d27" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">创建矩阵的语法非常相似——您将逐行声明它，将分号(；)来指示元素应该在新的一行上:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/708fed70959f91d0ce62843db3eecbfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*pqznIDZUT4New03pBXzGIw.png"/></div></figure><h2 id="3297" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">零点矩阵</h2><p id="07b1" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">创建一个由零组成的<strong class="kv jf"> n*m </strong>矩阵的语法与 Python 中的非常相似，只是没有 Numpy 前缀:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/c43f6507eca67f9c6df313c8c04a0687.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*AyYx18JwhuXzqldECFGzJg.png"/></div></figure><h2 id="5e08" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">一的矩阵</h2><p id="fb94" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">这同样适用于一的 n*m 矩阵:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi os"><img src="../Images/fc9438f9b160599a8912705f7ab88c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*xs1UvMxvT2Sp-H8zXW85Og.png"/></div></figure><h2 id="dc69" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">对角矩阵</h2><p id="d2d6" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">如果你想做一个对角线矩阵，也就是不在对角线上的元素为 0 的矩阵，你可以通过<code class="fe ot ou ov ow b">Diagonal()</code>和传入对角线上元素值的数组来实现:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/4abf20c9109ca1f4ce3316c013ee2a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*cKMdeY0wieOppaXUkm-QAA.png"/></div></figure><h2 id="0ecb" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">单位矩阵</h2><p id="a191" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">以类似的方式，您可以创建一个<strong class="kv jf"> n*n </strong>单位矩阵:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/ceabd79a5fb96ca53f9bbfebcf84dfd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*_Luymq5cuOEEYxd_FhKwBw.png"/></div></figure><h2 id="c28e" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">随机数矩阵</h2><p id="bb8b" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">要创建一个包含均匀分布元素的<strong class="kv jf"> n*m </strong>矩阵，可以使用<code class="fe ot ou ov ow b">rand()</code>方法:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/986369c384cb72e36f8a763e6a36bc43.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*_MJ7yn5mhzzSTdpg0BwzVw.png"/></div></figure><h2 id="e115" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">随机数矩阵(正态)</h2><p id="d995" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">或者使用<code class="fe ot ou ov ow b">randn()</code>从标准正态分布(mean = 0，var = 1)中抽取元素:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/ac5f87bf85eae3700c5219519ef811bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*N0SXbL8KuWi2lijlq6PhUQ.png"/></div></figure><p id="5a56" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，我们已经做了很多，但仍然没有涉及任何线性代数运算，这将在下一节中介绍。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="f03a" class="nf ng je bd nh ni nj nk nl nm nn no np kk nq kl nr kn ns ko nt kq nu kr nv nw bi translated">线性代数运算</h1><p id="f1ca" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">在这一节中，我们将讨论矩阵乘法、逆矩阵、行列式、特征分解等等。我们开始吧！</p><h2 id="9db5" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">移项</h2><p id="8dfe" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">要计算矩阵转置，您可以使用方便的<code class="fe ot ou ov ow b">transpose()</code>函数:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/2d03638b764fe6d2fd4214c82097d5e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*Iuky6mRUc8wONU7M0U0sEg.png"/></div></figure><h2 id="cbf9" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">重塑</h2><p id="b44d" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">一个数组也可以被重新整形——这里我创建了一个包含 1 到 10 元素的数组，并将它们重新整形为一个 2 行 5 列的矩阵:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/c0fa45cb7cc682710f909aba591dd6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*00d0ImppE1p7-O3veUVEaA.png"/></div></figure><h2 id="e467" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">变平</h2><p id="1c1b" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">您可以轻松地将<strong class="kv jf"> n*m </strong>矩阵展平为一个列向量——这在以后涉及数据科学时会有很多用例:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/38627cffb38e8bfe7f1683fdf1a350d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*rNJZ3djdjjWCNO4CRlN1Sg.png"/></div></figure><h2 id="3ac9" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">点积</h2><p id="8a1f" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">我相信你能猜到一种计算点积的方法的名字:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/fa6b84f3b8394ea25a6b3fe074d9689b.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*XEuUn3Xr1FyJ_MDuJ24veQ.png"/></div></figure><h2 id="f4b7" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">矩阵乘法</h2><p id="4d0c" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">要执行矩阵乘法，您可以使用乘法符号，而在 Python 中，您使用了<strong class="kv jf"> @ </strong>符号:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/c4a644224666ac5f24bf5dbe5dea6269.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*lHICwtQw2HbDqBguvy9XMw.png"/></div></figure><h2 id="cb1d" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">逐元素乘法</h2><p id="a97f" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">要逐元素相乘，使用<strong class="kv jf">。* </strong>符号:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/f1572b64da5d8eb867383006261f419c.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/format:webp/1*BWOFWsHjS00yeHgPSLOzuw.png"/></div></figure><h2 id="f078" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">矩阵求逆</h2><p id="07d6" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">要计算矩阵的逆矩阵，使用<code class="fe ot ou ov ow b">inv()</code>方法:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/2c7010540d41586e3e76271ec4ef5cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*W44mikMk5okKxbyOIoWaPg.png"/></div></figure><h2 id="ae3f" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">决定因素</h2><p id="022d" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">用<code class="fe ot ou ov ow b">det()</code>法计算行列式:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/c8990d011906ed402559e49643dd10fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:204/format:webp/1*kT8gTMkwmg-4QIOIk_ALPg.png"/></div></figure><h2 id="cd88" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">特征分解</h2><p id="17bf" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">您也可以执行矩阵的特征分解。它会返回特征值和特征向量，所以如果你想存储它们，你需要两个变量:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/5b3ba2e4c3cc3deff95dd78b2e1a124d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*gfoQiiGsmUST0Prw1rhCKg.png"/></div></figure><h2 id="7b08" class="oc ng je bd nh od oe dn nl of og dp np lc oh oi nr lg oj ok nt lk ol om nv on bi translated">向量范数</h2><p id="5939" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">最后，要计算简单的欧几里德范数，您可以使用<code class="fe ot ou ov ow b">norm()</code>方法:</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/35889c579f721a7eab0ff80734bb7ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*1Rd_KgAKgPcZV0WyDhn1PA.png"/></div></figure><p id="685f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我认为这就足够了，甚至可能有点多。我希望这对你来说不是一个大问题。对我来说，在 Julia 中线性代数感觉很自然，甚至比在 Python 中更自然。让我们希望这种说法在未来处理真实数据集时仍然成立。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="094b" class="nf ng je bd nh ni nj nk nl nm nn no np kk nq kl nr kn ns ko nt kq nu kr nv nw bi translated">下一步是什么</h1><p id="49d3" class="pw-post-body-paragraph kt ku je kv b kw nx kf ky kz ny ki lb lc nz le lf lg oa li lj lk ob lm ln lo im bi translated">在进入一些“具体的”数据科学之前，具体的意思是 EDA、数据可视化和机器学习，我想确保基础知识得到适当的覆盖。主要原因是——<strong class="kv jf">你需要知道你正在使用的语言</strong>。在网上寻找答案很酷，但不酷的是不断怀疑自己，因为你不确定自己是否做对了。</p><p id="5b16" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这就是为什么您可以期待另外三篇与本文类似的文章，涵盖:</p><ul class=""><li id="36fd" class="pk pl je kv b kw kx kz la lc pm lg pn lk po lo pp pq pr ps bi translated">结石</li><li id="e213" class="pk pl je kv b kw pt kz pu lc pv lg pw lk px lo pp pq pr ps bi translated">统计/概率</li><li id="a469" class="pk pl je kv b kw pt kz pu lc pv lg pw lk px lo pp pq pr ps bi translated">基本数据框架</li></ul><p id="7982" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">只有这样，我们才能向应用数据科学迈进一步。感谢阅读，我希望你喜欢它。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="67b4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">喜欢这篇文章吗？成为 <a class="ae pz" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="py">中等会员</em> </a> <em class="py">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="is it gp gr iu lp"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd jf gy z fp lu fr fs lv fu fw jd bi translated">通过我的推荐链接加入 Medium-Dario rade ci</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">medium.com</p></div></div><div class="ly l"><div class="qa l ma mb mc ly md ja lp"/></div></div></a></div></div></div>    
</body>
</html>