<html>
<head>
<title>Python *args and **kwargs — Data Science Edition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python *args 和* * kwargs 数据科学版</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-args-and-kwargs-data-science-edition-978e16c7c2fc?source=collection_archive---------21-----------------------#2020-06-14">https://towardsdatascience.com/python-args-and-kwargs-data-science-edition-978e16c7c2fc?source=collection_archive---------21-----------------------#2020-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5f85" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用参数和关键字参数使您的代码更加优雅</h2></div><p id="b779" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您在查看函数定义后偶然发现了*args 和**kwargs，并且想知道它们到底是什么，那么您就在正确的地方。今天，我们将浏览这两者，并展示它们在一般机器学习任务中的用例。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/f688182caadd23f08c6934c45f8ca212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6Qz8oZl2VrcyfDLG"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">照片由<a class="ae lu" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="ed4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">*args 和*kwargs 都允许将多个参数(因此是 args)和关键字参数(因此是 kwargs)传递给一个函数。我们稍后将对此进行更详细的探讨。</p><p id="6dab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理想的读者是熟悉 Python 编程语言基础并对数据科学感兴趣的人。第二部分是可选的，因为文章的前三分之二只围绕编程语言本身。</p><p id="b117" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章的结构如下:</p><ol class=""><li id="12d9" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">*参数</li><li id="b500" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">* *克瓦查</li><li id="8695" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">在机器学习任务中的实际应用</li><li id="6b84" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">结论</li></ol><p id="6e73" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说到这里，让我们从第一个概念开始——* args。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f4c2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">*参数</h1><p id="f2e0" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">假设您想要声明一个对数字求和的函数。默认情况下，这个函数有一个问题—它只接受固定数量的参数。当然，你可以只使用一个类型为<strong class="kk iu"> list </strong>的参数来解决这个问题，这是一个可行的替代方法。让我们探索一下。</p><p id="8db5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是对数字求和的常规函数，需要一个 list 类型的参数:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="f905" class="ns mr it no b gy nt nu l nv nw">def sum_numbers(numbers):<br/>   the_sum = 0<br/>   for number in numbers:<br/>       the_sum += number<br/> return the_sum</span></pre><p id="897d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用它来计算总和:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="5134" class="ns mr it no b gy nt nu l nv nw">numbers = [1, 2, 3, 4, 5]<br/>sum_numbers(numbers)</span><span id="0a7c" class="ns mr it no b gy nx nu l nv nw"><strong class="no iu">&gt;&gt;&gt; 15</strong></span></pre><p id="0a89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果你不想使用列表呢？*救援参数:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="6164" class="ns mr it no b gy nt nu l nv nw">def sum_numbers(*args):<br/>   the_sum = 0<br/>   for number in args:<br/>       the_sum += number<br/>   return the_sum</span><span id="d39c" class="ns mr it no b gy nx nu l nv nw">sum_numbers(1, 2, 3)<br/><strong class="no iu">&gt;&gt;&gt; 6</strong></span><span id="7680" class="ns mr it no b gy nx nu l nv nw">sum_numbers(1, 2, 3, 4, 5)<br/><strong class="no iu">&gt;&gt;&gt; 15</strong></span></pre><p id="5b2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的，我听到了——这不是最好的用例，因为我们可以用列表来代替。但是我们还有几个例子——第一个是<strong class="kk iu">打开</strong>。</p><h2 id="f2cc" class="ns mr it bd ms ny nz dn mw oa ob dp na kr oc od nc kv oe of ne kz og oh ng oi bi translated">列表解包</h2><p id="72dd" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">解包的思想是解包任何可迭代的对象。单星号*用于解包任何 iterable，双星号**仅用于<strong class="kk iu">字典</strong>。你很快就会明白它的要点。</p><p id="0655" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有以下列表:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="23f1" class="ns mr it no b gy nt nu l nv nw">num_arr = [1, 2, 3, 4, 5]</span></pre><p id="cab5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解包的过程很简单，并且已经包含在我们漂亮的<strong class="kk iu"> sum_numbers() </strong>函数中:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="3cf5" class="ns mr it no b gy nt nu l nv nw">print(*num_arr)</span><span id="2c8d" class="ns mr it no b gy nx nu l nv nw"><strong class="no iu">&gt;&gt;&gt; 1 2 3 4 5</strong></span></pre><p id="0605" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一分钟左右，我们将讨论字典解包——现在，让我们用列表连接来包装这一部分。</p><h2 id="3164" class="ns mr it bd ms ny nz dn mw oa ob dp na kr oc od nc kv oe of ne kz og oh ng oi bi translated">列表连接</h2><p id="73e9" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">*args 的另一个有用的方面是列表连接。假设我们有两个列表:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="13b4" class="ns mr it no b gy nt nu l nv nw">nums1 = [1, 2, 3]<br/>nums2 = [4, 5, 6]</span></pre><p id="358a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们如何将它们连接成一个列表呢？如果您的答案是沿着遍历这两个列表并将值存储到第三个列表的路线，那么您没有错(本质上)，但是有一个更容易和更优雅的选择。看一下下面的代码:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="f24c" class="ns mr it no b gy nt nu l nv nw">nums = [*nums1, *nums2]<br/>nums</span><span id="afd9" class="ns mr it no b gy nx nu l nv nw"><strong class="no iu">&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]</strong></span></pre><p id="4464" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是它的简单之处。让我们继续讨论**kwargs，它更适用于您的日常数据科学任务。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2326" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">* *克瓦查</h1><p id="6cda" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">如前所述，**kwargs 用于打开字典。事不宜迟，让我们看看如何使用它们。</p><p id="c35d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这个简单的例子，假设您想要将 3 个数字相乘，但是这些数字来自于某个外部源，并且被存储为<strong class="kk iu">键-值对</strong>。键总是相同的(很明显)，但是值会改变。</p><p id="46f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是你超级复杂的后端代码:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="d856" class="ns mr it no b gy nt nu l nv nw">def multiply(a, b, c):<br/>    return a * b * c</span></pre><p id="b6e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是你得到的数据:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="cc14" class="ns mr it no b gy nt nu l nv nw">d = {‘a’: 3, ‘b’: 2, ‘c’: 5}</span></pre><p id="8dc7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，人们可以采取一种天真的方法，做这样的事情:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="5ef3" class="ns mr it no b gy nt nu l nv nw">multiply(a=d[‘a’], b=d[‘b’], c=d[‘c’])</span><span id="003b" class="ns mr it no b gy nx nu l nv nw"><strong class="no iu">&gt;&gt;&gt; 30</strong></span></pre><p id="953b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是一如既往，有一个更简单的解决方案。让我们花点时间来欣赏下面这段代码的美妙之处:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="943a" class="ns mr it no b gy nt nu l nv nw">multiply(**d)</span><span id="bdad" class="ns mr it no b gy nx nu l nv nw"><strong class="no iu">&gt;&gt;&gt; 30</strong></span></pre><p id="95a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是简单、干净和优雅的——正如 Python 的初衷。我敢肯定，一些关于数据科学任务的潜在用例的想法已经浮现在您的脑海中，但在进入正题之前，让我们快速浏览一下字典串联。</p><h2 id="b5e8" class="ns mr it bd ms ny nz dn mw oa ob dp na kr oc od nc kv oe of ne kz og oh ng oi bi translated">词典拼接</h2><p id="0607" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">这个想法基本上和列表一样。下面我们有两本字典:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="7973" class="ns mr it no b gy nt nu l nv nw">d1 = {‘a’: 1, ‘b’: 2}<br/>d2 = {‘c’: 3, ‘d’: 4}</span></pre><p id="85c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要将它们连接成一个字典，我们所要做的就是:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="599f" class="ns mr it no b gy nt nu l nv nw">d = {**d1, **d2}<br/>d</span><span id="ad3d" class="ns mr it no b gy nx nu l nv nw"><strong class="no iu">&gt;&gt;&gt; {'a': 1, 'b': 2, 'c': 3, 'd': 4}</strong></span></pre><p id="a08b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你应该知道的唯一问题是<strong class="kk iu">密钥复制</strong>。如果在两个或更多字典中有相同的关键字，则在连接时使用梯形的值。</p><p id="f77c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在是你一直在等待的部分——日常机器学习任务中的一个具体例子。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d2a5" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">在机器学习任务中的实际应用</h1><p id="b16e" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">按照承诺，我们将使用**kwargs 来模拟模型训练的过程。让我们想象以下场景——你已经收集并准备好数据，现在想要做一些回归任务——让我们用<strong class="kk iu">随机森林</strong>算法来说。</p><p id="a708" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是您的导入和初始化:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="6a07" class="ns mr it no b gy nt nu l nv nw">from sklearn.ensemble import RandomForestRegressor</span><span id="bf3e" class="ns mr it no b gy nx nu l nv nw">rf = RandomForestRegressor()</span></pre><p id="ce83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于您不知道超参数的最佳值，您决定进行网格搜索。我们在这里不会这样做，但是在执行之后，您将在<strong class="kk iu"> best_params_ </strong>属性中拥有最佳参数。下面的字典模仿它:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="3d2f" class="ns mr it no b gy nt nu l nv nw">best_params = {<br/>   ‘bootstrap’: True,<br/>   ‘criterion’: ‘mse’,<br/>   ‘max_depth’: 100,<br/>   ‘min_samples_leaf’: 2,<br/>   ‘n_estimators’: 400<br/>}</span></pre><p id="62d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里最简单的方法是在另一个随机森林初始化中重写参数名和值。</p><p id="2b0f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们比这聪明。我们知道**kwargs 以及如何使用它们来解包字典，因此我们可以执行以下操作:</p><pre class="lf lg lh li gt nn no np nq aw nr bi"><span id="beab" class="ns mr it no b gy nt nu l nv nw">rf = RandomForestRegressor(**best_params)</span></pre><p id="64f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你看到那有多优雅了吗？</p><p id="d00e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不仅如此，您还减少了在其他项目中可能出现错误的机会，以防您只是复制粘贴代码而忘记更改值。</p><p id="3cbe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">故事到此结束——至少今天是这样。我们已经讲了很多，所以让我们快速回顾一下。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3a77" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="3c84" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">作为一名数据科学家，知道自己选择的编程语言能提供什么是一个不错的奖励。本文涵盖的例子并不具有开创性，但是我们确信它们将帮助您减少代码量，或者使代码看起来更优雅——或者两者兼而有之。</p><p id="091c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢你花几分钟时间阅读，直到最后。和往常一样，请在下面的评论区留下你的想法。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="3df8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">喜欢这篇文章吗？成为 <a class="ae lu" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="oj">中等会员</em> </a> <em class="oj">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="ok ol gp gr om on"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">通过我的推荐链接加入 Medium-Dario rade ci</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">medium.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb lo on"/></div></div></a></div></div></div>    
</body>
</html>