<html>
<head>
<title>Python in 2021 — Timeline and upcoming features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021 年的 Python 时间表和即将推出的功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-in-2021-timeline-and-upcoming-features-c8369abbcc52?source=collection_archive---------13-----------------------#2020-07-19">https://towardsdatascience.com/python-in-2021-timeline-and-upcoming-features-c8369abbcc52?source=collection_archive---------13-----------------------#2020-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1d3aa983a07e00b396381e9032aceac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X4boERBxE25LWvm9"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Gabriela Gomez 在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="5db3" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">Python 3.10 的一些新特性的预览</h2></div><p id="edc9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们目前生活在<strong class="la jk"> Python 3.8 </strong>的<em class="lu">稳定时代</em>，Python 的最新稳定版本<a class="ae jg" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> 3.8.4 </a>于上周发布。<strong class="la jk"> Python 3.9 </strong>已经处于测试开发阶段，一个<a class="ae jg" href="https://www.python.org/downloads/mac-osx/" rel="noopener ugc nofollow" target="_blank">测试版</a> (3.9.0b4)于 2020 年 7 月 3 日预发布，第五个测试版预发布定于明天<strong class="la jk"/>。3.9 的第一个稳定版本预计在 2020 年 10 月发布。Python 3.10 的开发也于 2020 年 5 月启动，第一个测试版预计于 2021 年 5 月发布。</p><p id="331f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显然，对于 Python 爱好者来说，<em class="lu">有趣的时代就在前方</em>。浏览三个版本(3.8、3.9 和 3.10)的发布时间表促使我在有趣的 Python 开发即将到来的时间表中编辑<strong class="la jk">关键日期</strong>。</p><blockquote class="lv lw lx"><p id="6461" class="ky kz lu la b lb lc kk ld le lf kn lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">“我妈妈总是说生活就像一盒巧克力。你永远不知道你会得到什么。”——《阿甘正传》</p></blockquote><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mb"><img src="../Images/e6cd8e4a981eff6f9b92003f0539e78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UKTLDr1YD10Qyc5W11H2xw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Python 开发周期中的关键日期(未按比例)来源:<a class="ae jg" href="https://www.python.org/dev/peps/" rel="noopener ugc nofollow" target="_blank">https://www.python.org/dev/peps/</a></p></figure><p id="0dd9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，在开发周期中会有 4–5 个测试版，在第一个测试版发布之后的版本中不会引入新的特性。对于 3.8，beta-1 于 2019 年 6 月发布，对于 3.9，beta-1 于 2020 年 5 月发布。虽然<strong class="la jk">未来 Python 3.10 </strong>刚刚启动，官方网站已经提供了一些<a class="ae jg" href="https://docs.python.org/3.10/whatsnew/3.10.html" rel="noopener ugc nofollow" target="_blank">的亮点</a>。</p><p id="3630" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章旨在提供一个时间表的简要概述和一个<strong class="la jk">即将到来的</strong>新 Python 版本的<strong class="la jk">突出特性</strong>的预览，改编自 Python 网站的官方示例。请注意，我们可以期待在 3.10 版本中有更多的新功能，我会随时更新下面的列表。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="6589" class="mn mo jj bd mp mq mr ms mt mu mv mw mx kp my kq mz ks na kt nb kv nc kw nd ne bi translated">突出 Python 3.10 中的功能</h1><h2 id="8b76" class="nf mo jj bd mp ng nh dn mt ni nj dp mx lh nk nl mz ll nm nn nb lp no np nd nq bi translated">1)二进制表示中 1 的频率</h2><p id="2614" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">将引入一个新方法<code class="fe nw nx ny nz b">bit_count()</code>，该方法将返回整数的二进制表示中存在的<strong class="la jk">个一。结果将是<strong class="la jk">独立于整数的符号</strong>。这个功能的一个用例是在信息论中，对于两个等长的字符串，您可以找到两个字符串不同的地方的总数。这种差异被称为汉明距离(参见<a class="ae jg" href="https://en.wikipedia.org/wiki/Hamming_distance" rel="noopener ugc nofollow" target="_blank"> Wiki </a>)。阅读<a class="ae jg" href="https://bugs.python.org/issue29882" rel="noopener ugc nofollow" target="_blank">这里的</a>了解 Python 中这一功能的历史。</strong></p><p id="6229" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个方法简单地将<code class="fe nw nx ny nz b">str</code>类型的<code class="fe nw nx ny nz b">count</code>方法称为<code class="fe nw nx ny nz b">str.count('1')</code>。下面的例子解释了这一点</p><pre class="mc md me mf gt oa nz ob oc aw od bi"><span id="aba2" class="nf mo jj nz b gy oe of l og oh"># Positive integer <br/>&gt;&gt;&gt; num = 108</span><span id="e715" class="nf mo jj nz b gy oi of l og oh"># Let's first get the binary representation of num<br/>&gt;&gt;&gt; bin(num)<br/>'0b1101100'</span><span id="9771" class="nf mo jj nz b gy oi of l og oh"><strong class="nz jk">&gt;&gt;&gt; </strong>num.bit_count()<br/>4</span><span id="a84f" class="nf mo jj nz b gy oi of l og oh"># Negative integer<br/>&gt;&gt;&gt; num = -108</span><span id="5f55" class="nf mo jj nz b gy oi of l og oh">&gt;&gt;&gt; bin(num)<br/>'-0b1101100'</span><span id="f62f" class="nf mo jj nz b gy oi of l og oh"><strong class="nz jk">&gt;&gt;&gt; </strong>num.bit_count()<br/>4</span><span id="5764" class="nf mo jj nz b gy oi of l og oh"># Under the hood<br/>&gt;&gt;&gt; bin(num).count('1')</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="ce70" class="nf mo jj bd mp ng nh dn mt ni nj dp mx lh nk nl mz ll nm nn nb lp no np nd nq bi translated">2)拉链会“更严格”</h2><p id="d1ae" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">一个新的可选关键字参数<code class="fe nw nx ny nz b">strict</code>将被添加到<code class="fe nw nx ny nz b">zip</code>函数中。如果你通过了<code class="fe nw nx ny nz b">strict=True</code>，你正在压缩的<strong class="la jk">的长度必须相等，</strong>否则<code class="fe nw nx ny nz b">ValueError</code>将被抛出。在 Python 3.9 之前，如果您压缩两个长度不等的列表，您将得到长度等于较小列表的输出。</p><p id="3d81" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的例子中可以看到，在 Python 3.10 之前，<code class="fe nw nx ny nz b">zip()</code>函数忽略了第一个列表中不匹配的<code class="fe nw nx ny nz b">'D'</code>。相比之下，Python 3.10 会抛出一个<code class="fe nw nx ny nz b">ValueError</code>。鉴于压缩相同数量的项目的直观性，我喜欢这个功能，因为它可以唤醒你重新检查你的输入。在<a class="ae jg" href="https://www.python.org/dev/peps/pep-0618/" rel="noopener ugc nofollow" target="_blank"> PEP 618 </a>阅读更多关于这个问题的内容。</p><p id="badc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">Python 3.10 之前</strong></p><pre class="mc md me mf gt oa nz ob oc aw od bi"><span id="41ff" class="nf mo jj nz b gy oe of l og oh">&gt;&gt;&gt; list(zip(['A', 'B', 'C', 'D'], ['Apple', 'Ball', 'Cat']))<br/>[('A', 'Apple'), ('B', 'Ball'), ('C', 'Cat')]</span></pre><p id="3665" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">在 Python 3.10 中</strong></p><pre class="mc md me mf gt oa nz ob oc aw od bi"><span id="3be8" class="nf mo jj nz b gy oe of l og oh">&gt;&gt;&gt; list(zip(['A', 'B', 'C', 'D'], ['Apple', 'Ball', 'Cat'],<br/>             strict=True))<br/>Traceback (most recent call last):<br/>  <em class="lu">...</em><br/>ValueError: zip() argument 1 is longer than argument 2</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="3948" class="nf mo jj bd mp ng nh dn mt ni nj dp mx lh nk nl mz ll nm nn nb lp no np nd nq bi translated">3)字典的只读视图</h2><p id="5708" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">字典的三个关键方法，<code class="fe nw nx ny nz b">keys()</code>、<code class="fe nw nx ny nz b">values()</code>和<code class="fe nw nx ny nz b">items()</code>，返回类似集合的对象，分别对应于字典的键、值和项的<em class="lu">动态视图</em>。您在这些视图中所做的任何更改也将<strong class="la jk">反映到</strong>原始词典中。</p><p id="8892" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在 Python 3.10 中，上述三种方法返回的所有视图都有一个名为<code class="fe nw nx ny nz b">mapping</code>的附加属性<strong class="la jk">，该属性将返回映射的一个只读代理</strong>。这个只读代理将包装视图引用的原始字典。下面的例子说明了这一点:</p><p id="418f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们定义一个字典，并将它的键和值存储在不同的变量中</p><pre class="mc md me mf gt oa nz ob oc aw od bi"><span id="e05e" class="nf mo jj nz b gy oe of l og oh">&gt;&gt;&gt; fruits = {'Mangos': 12, 'Figs': 100, 'Guavas': 3, 'Kiwis': 70}<br/>&gt;&gt;&gt; keys = fruits.keys()<br/>&gt;&gt;&gt; values = fruits.values()</span><span id="3203" class="nf mo jj nz b gy oi of l og oh">&gt;&gt;&gt; list(keys)<br/>['Mangos', 'Figs', 'Guavas', 'Kiwis']</span></pre><p id="dfc6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们使用<code class="fe nw nx ny nz b">del</code>语句从这个字典中删除两个元素。如果您现在打印键和值，您将看到它只返回剩余的项。原始字典中的变化现在反映在视图中(这里的<code class="fe nw nx ny nz b">keys</code>和<code class="fe nw nx ny nz b">values</code>)。</p><pre class="mc md me mf gt oa nz ob oc aw od bi"><span id="5fe8" class="nf mo jj nz b gy oe of l og oh">&gt;&gt;&gt; del fruits['Figs']<br/>&gt;&gt;&gt; del fruits['Guavas']</span><span id="724f" class="nf mo jj nz b gy oi of l og oh">&gt;&gt;&gt; print (list(keys), list(values))<br/>['Mangos', 'Kiwis'] [12, 70]</span></pre><p id="82e1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，有了<code class="fe nw nx ny nz b">mapping</code>，你仍然可以得到原始字典的只读代理。酷！不是吗？</p><pre class="mc md me mf gt oa nz ob oc aw od bi"><span id="ebf8" class="nf mo jj nz b gy oe of l og oh"><em class="lu"># returns a read-only proxy of the </em><strong class="nz jk"><em class="lu">original dictionary</em></strong><br/>&gt;&gt;&gt; values.mapping<br/>mappingproxy({'Mangos': 12, 'Figs': 100, 'Guavas': 3, 'Kiwis': 70})</span><span id="2336" class="nf mo jj nz b gy oi of l og oh">&gt;&gt;&gt;<strong class="nz jk"> </strong>values.mapping['Guavas']<br/>3</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h2 id="a6f6" class="nf mo jj bd mp ng nh dn mt ni nj dp mx lh nk nl mz ll nm nn nb lp no np nd nq bi translated">4)移除一些向后兼容性</h2><p id="59df" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">从 Python 3.10 起将<strong class="la jk">取消对<a class="ae jg" href="https://docs.python.org/3.9/library/collections.abc.html#collections-abstract-base-classes" rel="noopener ugc nofollow" target="_blank">集合</a>模块的抽象基类(ABCs)的别名支持。因此，现在是停止忽略相应的反对警告并调整代码的好时机。</strong></p><p id="6786" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">到 Python 3 . 9 . 0 B4(2020 年 7 月 3 日发布)</strong></p><p id="3137" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">直接从<code class="fe nw nx ny nz b">collections</code>模块导入任何<a class="ae jg" href="https://docs.python.org/3.9/library/collections.abc.html#collections-abstract-base-classes" rel="noopener ugc nofollow" target="_blank">这些</a>ABC 将导致到目前为止的<code class="fe nw nx ny nz b">DeprecationWarning</code></p><pre class="mc md me mf gt oa nz ob oc aw od bi"><span id="31db" class="nf mo jj nz b gy oe of l og oh">&gt;&gt;&gt; from collections import ABC_Name</span><span id="85a5" class="nf mo jj nz b gy oi of l og oh">DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated since Python 3.3,and in 3.9 it will stop working</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="d626" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这让我想到了这篇文章的结尾。因为 Python 3.10 将会公布更多的发布亮点，所以我会将它们添加到本文中。敬请期待<strong class="la jk"> <em class="lu">让我们一起期待 Python 3.10 </em> </strong>。你可以在这里关注当前版本和即将发布版本的发布时间表:<a class="ae jg" href="https://www.python.org/dev/peps/pep-0569/#release-schedule" rel="noopener ugc nofollow" target="_blank"> 3.8 </a>、<a class="ae jg" href="https://www.python.org/dev/peps/pep-0596/#id4" rel="noopener ugc nofollow" target="_blank"> 3.9 </a>、<a class="ae jg" href="https://www.python.org/dev/peps/pep-0619/#id4" rel="noopener ugc nofollow" target="_blank"> 3.10 </a>。如果您也想了解 Matplotlib 和 Scikit-learn 的最新特性，请阅读我最近发表的关于 Matplotlib 3 新特性和 Scikit-learn 新特性的文章。</p></div></div>    
</body>
</html>