<html>
<head>
<title>12 Amazing Pandas &amp; NumPy Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">12 只神奇的熊猫和数字功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/12-amazing-pandas-numpy-functions-22e5671a45b8?source=collection_archive---------3-----------------------#2020-03-07">https://towardsdatascience.com/12-amazing-pandas-numpy-functions-22e5671a45b8?source=collection_archive---------3-----------------------#2020-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b51c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过在您的分析中使用这些函数，让您的日常生活更加轻松</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7b1305e7604ec5f48e973c107b1ce382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vuQ4fs_zYLoqVoIw_YS3sA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">礼貌:<a class="ae kv" href="https://pixabay.com/photos/code-programming-python-1084923/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/photos/code-programming-python-1084923/</a></p></figure><p id="3fdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都知道熊猫和熊猫很神奇，它们在我们的日常分析中起着至关重要的作用。如果没有熊猫和 NumPy，我们将被遗弃在这个巨大的数据分析和科学世界中。今天，我将分享 12 个令人惊奇的熊猫和 NumPy 函数，它们将使你的生活和分析比以前容易得多。<em class="ls">最后，您可以在 Jupyter 笔记本上找到本文中使用的代码。</em></p><p id="3a03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">让我们从 NumPy 开始:</strong></p><p id="ec18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">NumPy 是使用 Python 进行科学计算的基础包。除其他外，它包含:</p><ul class=""><li id="b3d3" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">一个强大的 N 维数组对象</li><li id="2904" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">复杂的(广播)功能</li><li id="4872" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">集成 C/C++和 Fortran 代码的工具</li><li id="7a74" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">有用的线性代数、傅立叶变换和随机数功能</li></ul><p id="c0f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了其明显的科学用途，NumPy 还可以用作通用数据的高效多维容器。可以定义任意的数据类型。这使得 NumPy 可以无缝、快速地与各种数据库集成。</p><ol class=""><li id="7a3f" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr mh lz ma mb bi translated"><strong class="ky ir"> argpartition() </strong></li></ol><p id="a84b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">NumPy 有这个神奇的功能，可以找到 N 个最大值索引。输出将是 N 个最大值的索引，然后我们可以根据需要对这些值进行排序。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="ad31" class="mn mo iq mj b gy mp mq l mr ms">x = np.array([12, 10, 12, 0, 6, 8, 9, 1, 16, 4, 6, 0])</span><span id="13ee" class="mn mo iq mj b gy mt mq l mr ms">index_val = np.argpartition(x, -4)[-4:]<br/>index_val<br/>array([1, 8, 2, 0], dtype=int64)</span><span id="7ef2" class="mn mo iq mj b gy mt mq l mr ms">np.sort(x[index_val])<br/>array([10, 12, 12, 16])</span></pre><p id="508d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<strong class="ky ir"> allclose() </strong></p><p id="3a3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Allclose()用于匹配两个数组并获得布尔值形式的输出。如果两个数组中的项在容差范围内不相等，它将返回 False。这是检查两个数组是否相似的好方法，而这实际上很难手工实现。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="833e" class="mn mo iq mj b gy mp mq l mr ms">array1 = np.array([0.12,0.17,0.24,0.29])<br/>array2 = np.array([0.13,0.19,0.26,0.31])</span><span id="6c18" class="mn mo iq mj b gy mt mq l mr ms"># with a tolerance of 0.1, it should return False:<br/>np.allclose(array1,array2,0.1)<br/>False</span><span id="3c3e" class="mn mo iq mj b gy mt mq l mr ms"># with a tolerance of 0.2, it should return True:<br/>np.allclose(array1,array2,0.2)<br/>True</span></pre><p id="5dea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<strong class="ky ir">剪辑()</strong></p><p id="6415" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Clip()用于将数组中的值保持在一个区间内。有时，我们需要将值保持在一个上限和下限内。出于上述目的，我们可以利用 NumPy 的 clip()。给定一个区间，区间外的值被剪切到区间边缘。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="379b" class="mn mo iq mj b gy mp mq l mr ms">x = np.array([3, 17, 14, 23, 2, 2, 6, 8, 1, 2, 16, 0])</span><span id="702e" class="mn mo iq mj b gy mt mq l mr ms">np.clip(x,2,5)<br/>array([3, 5, 5, 5, 2, 2, 5, 5, 2, 2, 5, 2])</span></pre><p id="112e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.<strong class="ky ir">提取()</strong></p><p id="e956" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Extract()顾名思义，用于根据特定的条件从数组中提取特定的元素。使用 extract()，我们还可以使用类似于<strong class="ky ir">和</strong>和<strong class="ky ir">或</strong>的条件。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="7933" class="mn mo iq mj b gy mp mq l mr ms"># Random integers<br/>array = np.random.randint(20, size=12)<br/>array<br/>array([ 0,  1,  8, 19, 16, 18, 10, 11,  2, 13, 14,  3])</span><span id="c92b" class="mn mo iq mj b gy mt mq l mr ms">#  Divide by 2 and check if remainder is 1<br/>cond = np.mod(array, 2)==1<br/>cond<br/>array([False,  True, False,  True, False, False, False,  True, False, True, False,  True])</span><span id="16ae" class="mn mo iq mj b gy mt mq l mr ms"># Use extract to get the values<br/>np.extract(cond, array)<br/>array([ 1, 19, 11, 13,  3])</span><span id="35e0" class="mn mo iq mj b gy mt mq l mr ms"># Apply condition on extract directly<br/>np.extract(((array &lt; 3) | (array &gt; 15)), array)<br/>array([ 0,  1, 19, 16, 18,  2])</span></pre><p id="bb34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">5.<strong class="ky ir"> where() </strong></p><p id="562d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中()用于从满足特定条件的数组中返回元素。它返回符合特定条件的值的索引位置。这几乎类似于我们在 SQL 中使用的 where 条件，我将在下面的例子中演示它。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="26b9" class="mn mo iq mj b gy mp mq l mr ms">y = np.array([1,5,6,8,1,7,3,6,9])</span><span id="4b2f" class="mn mo iq mj b gy mt mq l mr ms"># Where y is greater than 5, returns index position<br/>np.where(y&gt;5)<br/>array([2, 3, 5, 7, 8], dtype=int64),)</span><span id="db6c" class="mn mo iq mj b gy mt mq l mr ms"># First will replace the values that match the condition, <br/># second will replace the values that does not<br/>np.where(y&gt;5, "Hit", "Miss")<br/>array(['Miss', 'Miss', 'Hit', 'Hit', 'Miss', 'Hit', 'Miss', 'Hit', 'Hit'],dtype='&lt;U4')</span></pre><p id="8ae2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">6.<strong class="ky ir">百分位()</strong></p><p id="8f3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Percentile()用于计算沿指定轴的数组元素的第 n 个百分位数。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="4a42" class="mn mo iq mj b gy mp mq l mr ms">a = np.array([1,5,6,8,1,7,3,6,9])</span><span id="da3f" class="mn mo iq mj b gy mt mq l mr ms">print("50th Percentile of a, axis = 0 : ",  <br/>      np.percentile(a, 50, axis =0))<br/>50th Percentile of a, axis = 0 :  6.0</span><span id="a624" class="mn mo iq mj b gy mt mq l mr ms">b = np.array([[10, 7, 4], [3, 2, 1]])</span><span id="dac5" class="mn mo iq mj b gy mt mq l mr ms">print("30th Percentile of b, axis = 0 : ",  <br/>      np.percentile(b, 30, axis =0))<br/>30th Percentile of b, axis = 0 :  [5.1 3.5 1.9]</span></pre><p id="4dfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我知道你以前是否用过它们，它对你有多大帮助。让我们继续看神奇的熊猫。</p><p id="1144" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">熊猫:</strong></p><p id="7844" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">pandas 是一个 Python 包，提供了快速、灵活、富于表现力的数据结构，旨在使结构化(表格、多维、潜在异构)和时间序列数据的处理变得既简单又直观。</p><p id="2687" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">pandas 非常适合许多不同类型的数据:</p><ul class=""><li id="381c" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">具有不同类型列的表格数据，如在 SQL 表或 Excel 电子表格中</li><li id="8f85" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">有序和无序(不一定是固定频率)时间序列数据。</li><li id="acdf" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">带有行和列标签的任意矩阵数据(同类或异类)</li><li id="f859" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">任何其他形式的观察/统计数据集。这些数据实际上根本不需要标记就可以放入 pandas 数据结构中。</li></ul><p id="878c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是熊猫擅长的几件事:</p><ul class=""><li id="7ef4" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">轻松处理浮点和非浮点数据中的缺失数据(表示为 NaN)</li><li id="4f7a" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">大小可变性:可以在数据帧和高维对象中插入和删除列</li><li id="06cf" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">自动和明确的数据对齐:对象可以明确地与一组标签对齐，或者用户可以简单地忽略标签，让系列、数据框等。在计算中自动调整数据</li><li id="807f" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">强大、灵活的分组功能，可对数据集执行拆分-应用-组合操作，用于聚合和转换数据</li><li id="8917" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">使将其他 Python 和 NumPy 数据结构中粗糙的、不同索引的数据转换成 DataFrame 对象变得容易</li><li id="9d08" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">大型数据集的智能基于标签的切片、花式索引和子集化</li><li id="f1a5" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">直观的合并和连接数据集</li><li id="f7d7" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">数据集的灵活整形和旋转</li><li id="e160" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">轴的分层标签(每个刻度可能有多个标签)</li><li id="a260" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">强大的 IO 工具，用于从平面文件(CSV 和带分隔符文件)、Excel 文件、数据库加载数据，以及从超快速 HDF5 格式保存/加载数据</li><li id="e7a5" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">特定于时间序列的功能:日期范围生成和频率转换、移动窗口统计、日期移动和滞后。</li></ul><ol class=""><li id="2cd7" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr mh lz ma mb bi translated"><strong class="ky ir"> read_csv(nrows=n) </strong></li></ol><p id="f6af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能已经知道 read_csv 函数的用法。但是，我们中的大多数人仍然会犯一个错误。csv 文件，即使它不是必需的。让我们考虑这样一种情况，我们不知道一个 10gb 的. csv 文件中存在的列和数据，整个读取。csv 文件在这里不会是一个聪明的决定，因为它会不必要的使用我们的内存，并会花费大量的时间。我们可以只从。csv 文件，然后根据我们的需要进一步进行。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="a58e" class="mn mo iq mj b gy mp mq l mr ms">import io<br/>import requests</span><span id="efba" class="mn mo iq mj b gy mt mq l mr ms"># I am using this online data set just to make things easier for you guys<br/>url = "<a class="ae kv" href="https://raw.github.com/vincentarelbundock/Rdatasets/master/csv/datasets/AirPassengers.csv" rel="noopener ugc nofollow" target="_blank">https://raw.github.com/vincentarelbundock/Rdatasets/master/csv/datasets/AirPassengers.csv</a>"<br/>s = requests.get(url).content</span><span id="237b" class="mn mo iq mj b gy mt mq l mr ms"># read only first 10 rows<br/>df = pd.read_csv(io.StringIO(s.decode('utf-8')),nrows=10 , index_col=0)</span></pre><p id="993a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<strong class="ky ir">地图()</strong></p><p id="3b84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">map()函数用于根据输入的对应关系映射系列的值。用于将一个数列中的每一个值替换为另一个值，该值可以是从一个函数、一个字典或一个数列中导出的。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="be7b" class="mn mo iq mj b gy mp mq l mr ms"># create a dataframe<br/>dframe = pd.DataFrame(np.random.randn(4, 3), columns=list('bde'), index=['India', 'USA', 'China', 'Russia'])</span><span id="64dd" class="mn mo iq mj b gy mt mq l mr ms">#compute a formatted string from each floating point value in frame<br/>changefn = lambda x: '%.2f' % x</span><span id="b33d" class="mn mo iq mj b gy mt mq l mr ms"># Make changes element-wise<br/>dframe['d'].map(changefn)</span></pre><p id="ba3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<strong class="ky ir"> apply() </strong></p><p id="2209" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">apply()允许用户传递一个函数，并将其应用于 Pandas 系列的每个值。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="5b65" class="mn mo iq mj b gy mp mq l mr ms"># max minus mix lambda fn<br/>fn = lambda x: x.max() - x.min()</span><span id="639b" class="mn mo iq mj b gy mt mq l mr ms"># Apply this on dframe that we've just created above<br/>dframe.apply(fn)</span></pre><p id="4a39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.<strong class="ky ir"> isin() </strong></p><p id="8158" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">isin()用于过滤数据帧。isin()有助于选择在特定列中具有特定(或多个)值的行。这是我遇到的最有用的功能。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="d62c" class="mn mo iq mj b gy mp mq l mr ms"># Using the dataframe we created for read_csv<br/>filter1 = df["value"].isin([112]) <br/>filter2 = df["time"].isin([1949.000000])</span><span id="d001" class="mn mo iq mj b gy mt mq l mr ms">df [filter1 &amp; filter2]</span></pre><p id="9bc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">5.<strong class="ky ir">复制()</strong></p><p id="0b8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">copy()</em>用于创建一个熊猫对象的副本。当您将一个数据框分配给另一个数据框时，当您在另一个数据框中进行更改时，其值也会发生变化。为了防止上述问题，我们可以使用 copy()。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="6997" class="mn mo iq mj b gy mp mq l mr ms"># creating sample series <br/>data = pd.Series(['India', 'Pakistan', 'China', 'Mongolia'])</span><span id="da32" class="mn mo iq mj b gy mt mq l mr ms"># Assigning issue that we face<br/>data1= data<br/># Change a value<br/>data1[0]='USA'<br/># Also changes value in old dataframe<br/>data</span><span id="a27a" class="mn mo iq mj b gy mt mq l mr ms"># To prevent that, we use<br/># creating copy of series <br/>new = data.copy()</span><span id="46ba" class="mn mo iq mj b gy mt mq l mr ms"># assigning new values <br/>new[1]='Changed value'</span><span id="c412" class="mn mo iq mj b gy mt mq l mr ms"># printing data <br/>print(new) <br/>print(data)</span></pre><p id="8776" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">6.<strong class="ky ir"> select_dtypes() </strong></p><p id="465b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">select_dtypes()函数根据列 dtypes 返回数据框列的子集。此函数的参数可以设置为包括所有具有某种特定数据类型的列，也可以设置为排除所有具有某种特定数据类型的列。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="a4b9" class="mn mo iq mj b gy mp mq l mr ms"># We'll use the same dataframe that we used for read_csv<br/>framex =  df.select_dtypes(include="float64")</span><span id="41a3" class="mn mo iq mj b gy mt mq l mr ms"># Returns only time column</span></pre><p id="e109" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">奖励:</strong></p><p id="2a33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> pivot_table() </strong></p><p id="308b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">熊猫最神奇最有用的功能就是 pivot_table。如果您对使用 groupby 犹豫不决，并且希望扩展它的功能，那么您可以使用 pivot_table。如果您知道 excel 中的数据透视表是如何工作的，那么这对您来说可能是小菜一碟。数据透视表中的级别将存储在结果数据帧的索引和列上的多索引对象(分层索引)中。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="e9ca" class="mn mo iq mj b gy mp mq l mr ms"># Create a sample dataframe<br/>school = pd.DataFrame({'A': ['Jay', 'Usher', 'Nicky', 'Romero', 'Will'], <br/>      'B': ['Masters', 'Graduate', 'Graduate', 'Masters', 'Graduate'], <br/>      'C': [26, 22, 20, 23, 24]})<br/></span><span id="3086" class="mn mo iq mj b gy mt mq l mr ms"># Lets create a pivot table to segregate students based on age and course<br/>table = pd.pivot_table(school, values ='A', index =['B', 'C'], <br/>                         columns =['B'], aggfunc = np.sum, fill_value="Not Available") <br/>  <br/>table</span></pre><p id="c985" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你们遇到或使用过其他神奇的功能，请在下面的评论中告诉我。我很想知道更多关于他们的事情。</p><blockquote class="mu mv mw"><p id="6550" class="kw kx ls ky b kz la jr lb lc ld ju le mx lg lh li my lk ll lm mz lo lp lq lr ij bi translated"><strong class="ky ir"> Jupyter 笔记本(使用代码):</strong><a class="ae kv" href="https://github.com/kunaldhariwal/Medium-12-Amazing-Pandas-NumPy-Functions" rel="noopener ugc nofollow" target="_blank">https://github . com/kunaldhariwal/Medium-12-Amazing-Pandas-NumPy-Functions</a></p><p id="5257" class="kw kx ls ky b kz la jr lb lc ld ju le mx lg lh li my lk ll lm mz lo lp lq lr ij bi translated"><strong class="ky ir"><em class="iq">LinkedIn</em></strong><em class="iq">:</em><a class="ae kv" href="https://bit.ly/2u4YPoF" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://bit.ly/2u4YPoF</em></a></p></blockquote><p id="d129" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这有助于增强你的知识基础:)</p><p id="c86a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多信息请关注我！</p><p id="e23b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读和宝贵时间！</p></div></div>    
</body>
</html>