<html>
<head>
<title>Pandas query method saves double handling of variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pandas查询方法节省了对变量的双重处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-query-method-saves-double-handling-of-variables-9293d703b804?source=collection_archive---------17-----------------------#2020-01-12">https://towardsdatascience.com/pandas-query-method-saves-double-handling-of-variables-9293d703b804?source=collection_archive---------17-----------------------#2020-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9ef5" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">最后更新时间:2020年1月</h2><div class=""/><div class=""><h2 id="7e0f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用。query()可以使我们在选择数据时不必在一行代码中多次键入数据帧的变量名。</h2></div><p id="7bd0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在pandas DataFrame对象中检索具有特定条件的行的标准方法需要“双重处理”；不是特别优雅。</p><p id="1006" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例如，我们想要检索列<em class="ln"> A </em>大于1的行，这是使用<em class="ln">的标准方法。loc </em>属性。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="99e0" class="lx ly it lt b gy lz ma l mb mc"><em class="ln">## Setup ##</em></span><span id="1ac1" class="lx ly it lt b gy md ma l mb mc"><em class="ln"># Import pandas<br/></em><strong class="lt jd">import </strong>pandas <strong class="lt jd">as </strong>pd</span><span id="0f5a" class="lx ly it lt b gy md ma l mb mc"><em class="ln"># Create dataframe from dict<br/></em># Specify the type in the suffix of each column name<br/>my_df = pd.DataFrame({<strong class="lt jd">"A_int"</strong>: [1, 2, -3],<br/>                      <strong class="lt jd">"B_float"</strong>: [7.5, 1.9, 8.4],<br/>                      <strong class="lt jd">"C_str"</strong>: [<strong class="lt jd">'eight'</strong>, <strong class="lt jd">'nine'</strong>, <strong class="lt jd">'Ten'</strong>],<br/>                      <strong class="lt jd">"D_str"</strong>: [<strong class="lt jd">'Mar 2017'</strong>, <strong class="lt jd">'May 2018'</strong>, <strong class="lt jd">'Jun 2016'</strong>]}<br/>                    )</span><span id="0a2a" class="lx ly it lt b gy md ma l mb mc"><em class="ln"># Convert to datetime column<br/></em>my_df[<strong class="lt jd">'D_date'</strong>] = pd.to_datetime(my_df[<strong class="lt jd">'D_str'</strong>])</span><span id="ba64" class="lx ly it lt b gy md ma l mb mc">"""<br/>&gt;&gt;&gt; my_df<br/>   A_int  B_float  C_str     D_str     D_date<br/>0      1      7.5  eight  Mar 2017 2017-03-01<br/>1      2      1.9   nine  May 2018 2018-05-01<br/>2     -3      8.4    Ten  Jun 2016 2016-06-01<br/>"""</span><span id="f22f" class="lx ly it lt b gy md ma l mb mc">## Show loc example 1 ##</span><span id="6374" class="lx ly it lt b gy md ma l mb mc">ex_1_loc = my_df.loc[my_df[<strong class="lt jd">'A_int'</strong>] &gt; 0, :]</span><span id="4e9f" class="lx ly it lt b gy md ma l mb mc">"""<br/>&gt;&gt;&gt; ex_1_loc<br/>   A_int  B_float  C_str     D_str     D_date<br/>0      1      7.5  eight  Mar 2017 2017-03-01<br/>1      2      1.9   nine  May 2018 2018-05-01<br/>"""</span></pre><p id="1017" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里，我们获得了布尔行序列，其中对于给定的行，A列大于0。<em class="ln">。loc </em>用于取出设置为True的行。注意，变量<em class="ln"> my_df </em>在一行代码中使用了两次。<br/>幸好这个变量名不是很长。我发现这种对变量的“双重处理”在语法上类似于R中的基本方法，特别是在嵌套和完全不必要的时候。</p><p id="7c1a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一些其他语言可以以更易读的格式执行这种过滤:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="efc6" class="lx ly it lt b gy lz ma l mb mc">## SQL EXAMPLE ##<br/>SELECT *<br/>FROM my_df<br/>WHERE A &gt; 0</span><span id="b937" class="lx ly it lt b gy md ma l mb mc">## R-TIDYVERSE EXAMPLE ##<br/>library(tidyverse)<br/>my_df %&gt;%<br/>  dplyr::filter(A &gt; 0)</span></pre><p id="f189" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对于python，我们可以用pandas的“查询”方法更简单地做到这一点(类似于上面的SQL / R-Tidyverse结构)。<em class="ln">查询</em>只返回符合给定条件的行，所有列都保留在数据帧中。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="fdfc" class="lx ly it lt b gy lz ma l mb mc">#ex_1_loc = my_df.loc[my_df[<strong class="lt jd">'A_int'</strong>] &gt; 0, :]<br/>ex_1_query = my_df.query("A &gt; 0")<br/># Or use @ when referencing a variable<br/>pivot_val = 0<br/>ex_1a_query = my_df.query("A &gt; @pivot_val")</span></pre><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi me"><img src="../Images/bd8b4391e86e2435934f751b83ba712e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5UEjMJDpF6Vxmg7Ks1bHVw.jpeg"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">标准的熊猫方法经常会让我们看到双重图像src:<a class="ae mq" href="https://pixabay.com/photos/panda-family-pandas-cute-bamboo-3811734/" rel="noopener ugc nofollow" target="_blank">https://pix abay . com/photos/panda-family-pandas-cute-bamboo-3811734/</a></p></figure><p id="f4eb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们再看六个例子，在这些例子中，query是对<em class="ln">的适当替代。锁定</em>方法</p><h2 id="82b8" class="lx ly it bd mr ms mt dn mu mv mw dp mx la my mz na le nb nc nd li ne nf ng iz bi translated">2.对外部列表进行筛选</h2><p id="542b" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">给定一个外部列表，获取数据帧中某一列与该列表中的一个元素匹配的行</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="1ddd" class="lx ly it lt b gy lz ma l mb mc"><em class="ln"># Create a list of legitimate entries<br/></em>legit_entries = [<strong class="lt jd">'eight'</strong>, <strong class="lt jd">'nine'</strong>, <strong class="lt jd">'ten'</strong>]</span><span id="c055" class="lx ly it lt b gy md ma l mb mc"><em class="ln"># Filter column 'C_str' by the array<br/></em>ex_2_loc = my_df.loc[my_df[<strong class="lt jd">'C_str'</strong>].isin(legit_entries), :]<br/>ex_2_query = my_df.query(<strong class="lt jd">"C_str in @legit_entries"</strong>)</span><span id="d40b" class="lx ly it lt b gy md ma l mb mc">"""<br/>   A_int  B_float  C_str     D_str     D_date<br/>0      1      7.5  eight  Mar 2017 2017-03-01<br/>1      2      1.9   nine  May 2018 2018-05-01<br/>"""</span></pre><h2 id="b659" class="lx ly it bd mr ms mt dn mu mv mw dp mx la my mz na le nb nc nd li ne nf ng iz bi translated">3.列比较</h2><p id="b7b7" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">比较两列—这需要在<em class="ln">中进行三重处理。锁定</em>示例。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ad52" class="lx ly it lt b gy lz ma l mb mc"><em class="ln"># Return rows where 'A_int' is greater than 'B_float'<br/></em>ex_3_loc = my_df.loc[my_df[<strong class="lt jd">'A_int'</strong>] &gt; my_df[<strong class="lt jd">'B_float'</strong>], :]<br/>ex_3_query = my_df.query(<strong class="lt jd">"A_int &gt; B_float"</strong>)</span><span id="5e84" class="lx ly it lt b gy md ma l mb mc">"""<br/>   A_int  B_float C_str     D_str     D_date<br/>1      2      1.9  nine  May 2018 2018-05-01<br/>"""</span></pre><h2 id="3c11" class="lx ly it bd mr ms mt dn mu mv mw dp mx la my mz na le nb nc nd li ne nf ng iz bi translated">4.多条件过滤</h2><p id="a61c" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">在可能的多个列上使用多个条件进行筛选。<em class="ln"> &amp; </em>和<em class="ln"> | </em>位运算符都是允许的。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="1e61" class="lx ly it lt b gy lz ma l mb mc"><em class="ln"># Return rows where 'A_int' is greater than zero<br/># And where C_str is in the legit_entries array<br/></em>ex_4_loc = my_df.loc[(my_df[<strong class="lt jd">"A_int"</strong>] &gt; 0) &amp;<br/>                     (my_df[<strong class="lt jd">'C_str'</strong>].isin(legit_entries)), :]<br/>ex_4_query = my_df.query(<strong class="lt jd">"A_int &gt; 0 &amp; C_str in @legit_entries"</strong>)</span><span id="e364" class="lx ly it lt b gy md ma l mb mc">"""<br/>   A_int  B_float  C_str     D_str     D_date<br/>0      1      7.5  eight  Mar 2017 2017-03-01<br/>1      2      1.9   nine  May 2018 2018-05-01<br/>"""</span></pre><h2 id="88aa" class="lx ly it bd mr ms mt dn mu mv mw dp mx la my mz na le nb nc nd li ne nf ng iz bi translated">5.时间戳</h2><p id="827b" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">查询识别日期，并可以将它们与字符串进行比较。查询引号内的所有字符串都必须用引号括起来。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="5ee0" class="lx ly it lt b gy lz ma l mb mc"><em class="ln"># Return rows where D_date is after Jan 2018<br/></em>ex_5_loc = my_df.loc[my_df[<strong class="lt jd">'D_date'</strong>] &gt; <strong class="lt jd">'Jan 2018'</strong>, :]<br/>ex_5_query = my_df.query(<strong class="lt jd">"D_date &gt; 'Jan 2018'"</strong>)</span><span id="a973" class="lx ly it lt b gy md ma l mb mc">"""<br/>   A_int  B_float C_str     D_str     D_date<br/>1      2      1.9  nine  May 2018 2018-05-01<br/>"""</span></pre><h2 id="03d4" class="lx ly it bd mr ms mt dn mu mv mw dp mx la my mz na le nb nc nd li ne nf ng iz bi translated">6.比较前的列转换</h2><p id="538c" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">您可以在比较之前对给定的列执行函数。<br/>注意dataframe的输出仍然包含原来格式的<em class="ln"> C_str </em>列？</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="b2b9" class="lx ly it lt b gy lz ma l mb mc"><em class="ln"># First convert C_str to lowercase, than compare entries<br/></em>ex_6_loc = my_df.loc[my_df[<strong class="lt jd">'C_str'</strong>].str.lower().isin(legit_entries),<br/>                     :]<br/>ex_6_query = my_df.query(<strong class="lt jd">"C_str.str.lower() in @legit_entries"</strong>)</span><span id="6be7" class="lx ly it lt b gy md ma l mb mc">"""<br/>   A_int  B_float  C_str     D_str     D_date<br/>0      1      7.5  eight  Mar 2017 2017-03-01<br/>1      2      1.9   nine  May 2018 2018-05-01<br/>2     -3      8.4    Ten  Jun 2016 2016-06-01<br/>"""</span></pre><p id="18c5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">7。包含空格<br/> 的列名最初禁止使用pandas查询，这个问题在0.25.2中已经解决。<br/>用反斜杠引用该列。列中的其他特殊字符可能不起作用。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="9317" class="lx ly it lt b gy lz ma l mb mc"><em class="ln"># Return rows where 'E rogue column str' column contains the word 'this'<br/></em>my_df[<strong class="lt jd">'E rogue_column_str'</strong>] = [<strong class="lt jd">'this'</strong>, <strong class="lt jd">'and'</strong>, <strong class="lt jd">'that'</strong>]</span><span id="a002" class="lx ly it lt b gy md ma l mb mc">"""<br/>&gt;&gt;&gt;my_df<br/>   A_int  B_float  C_str     D_str     D_date E rogue_column_str<br/>0      1      7.5  eight  Mar 2017 2017-03-01               this<br/>1      2      1.9   nine  May 2018 2018-05-01                and<br/>2     -3      8.4    Ten  Jun 2016 2016-06-01               that<br/>"""</span><span id="ad0f" class="lx ly it lt b gy md ma l mb mc">ex_7_loc = my_df.loc[my_df[<strong class="lt jd">"E rogue_column_str"</strong>] == <strong class="lt jd">'this'</strong>, :]<br/>ex_7_query = my_df.query(<strong class="lt jd">"`E rogue_column_str` == 'this'"</strong>))</span><span id="d3b1" class="lx ly it lt b gy md ma l mb mc">"""<br/>   A_int  B_float  C_str     D_str     D_date E rogue_column_str<br/>0      1      7.5  eight  Mar 2017 2017-03-01               this<br/>"""</span></pre><h1 id="95a2" class="nm ly it bd mr nn no np mu nq nr ns mx ki nt kj na kl nu km nd ko nv kp ng nw bi translated">克服“项目”贬值</h1><p id="3169" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">在熊猫的最新版本(在撰写本文时为0.25.3)中，<em class="ln">。item() </em>方法已被弃用。结合查询功能，<em class="ln"> item </em>是一个非常有用的工具，可以在假设只返回一行的情况下从给定的列中获取单个值。这将把列从类型<em class="ln"> pd转换成。系列</em>的数据类型，如int、str、float等。如果返回多行，方法将引发ValueError。</p><p id="07df" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以使用squeeze方法作为替代方法，只需对代码做一些小的修改。与item类似，当筛选后的系列只有一行长时，squeeze会将pandas系列从系列类型转换为数据类型。但是，如果序列中存在多个值，则不会引发value error<strong class="kt jd">而只是返回同一个序列。我们可以通过检查返回值是否仍然是series类型来利用这一点。</strong></p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="94a8" class="lx ly it lt b gy lz ma l mb mc"><em class="ln"># Previous code<br/></em><strong class="lt jd">try</strong>:<br/>    single_value = ex_3_query[<strong class="lt jd">'B_float'</strong>].item()<br/>    print(single_value)<br/><strong class="lt jd">except </strong>ValueError:<br/>    print(<strong class="lt jd">"Error, expected to return only one value, got %d" </strong>%<br/>          len(ex_3_query[<strong class="lt jd">'B_float'</strong>]))</span><span id="682d" class="lx ly it lt b gy md ma l mb mc"><em class="ln"># New code<br/></em>single_value = ex_3_query[<strong class="lt jd">'B_float'</strong>].squeeze()<br/><strong class="lt jd">if </strong>isinstance(single_value, pd.Series):<br/>    print(<strong class="lt jd">"Error, expected to return only one value, got %d" </strong>%<br/>          len(ex_3_query[<strong class="lt jd">'B_float'</strong>]))<br/><strong class="lt jd">else</strong>:<br/>    print(single_value)</span></pre><p id="48b6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">引用:<br/> <a class="ae mq" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.query.html" rel="noopener ugc nofollow" target="_blank">熊猫查询API </a></p></div></div>    
</body>
</html>