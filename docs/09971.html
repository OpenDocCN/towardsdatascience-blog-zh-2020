<html>
<head>
<title>Reinforced Pac-man</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强化吃豆人</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reinforced-pac-man-8e51409f4fc?source=collection_archive---------23-----------------------#2020-07-14">https://towardsdatascience.com/reinforced-pac-man-8e51409f4fc?source=collection_archive---------23-----------------------#2020-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="64f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">趣味语境下的 AI 深度解析。</h2></div><p id="fe77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">逃避 2020 年的严酷现实有多种形式。对一些人来说，2020 年已经充斥着阅读、听播客或深夜狂欢最新的网飞系列。对我来说，没有什么比建立一个人工智能代理来胜过阿朵的鬼谁是死心塌地吃它更好的背离现实了。是的，你猜对了，我说的是吃豆人，我说的是 AI。我们开始吧！</p><h1 id="8ea4" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated"><strong class="ak">游戏设置</strong></h1><p id="238f" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">游戏将在包含我们的角色和物品的平铺游戏板上进行。在这种情况下，时间以离散的方式工作，而不是连续的，因此，下面的讨论将涉及时间步长(例如第<strong class="kk iu"> k </strong>个时间步长)。在这个世界里，存在着:</p><ul class=""><li id="a2f1" class="mb mc it kk b kl km ko kp kr md kv me kz mf ld mg mh mi mj bi translated">吃豆人——主角</li><li id="fc69" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated">恩奇和克莱德——对立方</li><li id="fe79" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated">颗粒——我们饥饿朋友的食物来源</li><li id="d429" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated">能量球——能让吃豆人的对手变得可食用的物体。</li></ul><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/928e496a54a920d6e824119e5b5081e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hCdywjP_Sg1zTyc_BbbpSg.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">图 1:吃豆人游戏板(图片由作者提供)。</p></figure><p id="f046" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些角色和他们周围的世界之间的互动被封装在一个完整的游戏棋盘表示中，也就是所谓的状态。每个状态代表特定时间点的世界，吃豆人或幽灵的任何动作都会导致状态的改变。Pac-man 或 ghosts 可用的动作是基于移动的动作，指示实体是向上、向下、向左还是向右移动。此外，像任何好的游戏一样，存在一个与传统游戏略有不同的积分系统。</p><ul class=""><li id="e9a6" class="mb mc it kk b kl km ko kp kr md kv me kz mf ld mg mh mi mj bi translated">每吞噬一个小球，分数增加 10。</li><li id="144c" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated">状态每改变一次，就会招致 1 的生存惩罚。这是专门为了防止人工智能代理发现自己处于一种永远逃避墨奇和克莱德的模式中，从而不可能完成游戏。</li><li id="6f9f" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated">如果 AI 代理能够完成游戏，那么将会增加 500。可观的增长激励代理人完成游戏。</li><li id="d4a6" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated">类似地，死刑是用来阻止代理人被幽灵吃掉而退出游戏。</li><li id="6e62" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated">吞噬一颗能量丸后吃掉任一个幽灵，会得到 200 的奖励。</li></ul><p id="b3e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个版本的吃豆人中，Inky 和 Clyde 并不特别聪明，并以随机行为遍历游戏棋盘。虽然这确实让吃豆人更容易赢得游戏，但目的是双重的:</p><ol class=""><li id="4d74" class="mb mc it kk b kl km ko kp kr md kv me kz mf ld nf mh mi mj bi translated">吃豆人的主要动机是不被因基或克莱德吃掉而赢得游戏。</li><li id="85a2" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld nf mh mi mj bi translated">随着时间的推移，吃豆人必须学会如何在活着的时候最大限度地增加点数。</li></ol><p id="dae8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的解决方案将在不运行单一搜索算法的情况下处理这两个目标。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="1310" class="le lf it bd lg lh nn lj lk ll no ln lo jz np ka lq kc nq kd ls kf nr kg lu lv bi translated"><strong class="ak">马尔可夫决策过程</strong></h1><p id="9b38" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">马尔可夫决策过程(MDP)是一种对存在一组状态和动作的场景进行建模的正式方式。提交一个动作会以某种特定的概率导致不同的状态。也就是说，在给定先前状态<strong class="kk iu"> s </strong>和所选动作<strong class="kk iu"> a </strong>的情况下，存在描述到达状态<strong class="kk iu">s’</strong>的概率的转移函数。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b6395e88efc7c4a2796dff13b1691d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*EwsxO3j1BYAtmfPNc4GxYQ.png"/></div></figure><p id="4d53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个状态也有与之相关联的奖励，因此有奖励功能。奖励值取决于先前的状态、动作和结果状态。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/5ffd6772d99d7d49f785c3d2700d80a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*DbW216hKGaMnxhJkhscWXQ.png"/></div></figure><p id="8daf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了能够描述这个过程的开始和结束，还有一个开始和结束状态。不需要总是有终止状态，但这是对不同上下文的构造。</p><p id="d282" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顾名思义，MDP 具有马尔可夫性质，即未来状态的条件概率严格依赖于当前状态。在这个结构中，这可以写成:</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nt"><img src="../Images/e745dfe8f77b9362103b044de0507f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Evm8qLz46KGCOJHLN3gxUw.png"/></div></div></figure><p id="ab03" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这类流程的目标是找到最佳策略。策略是 AI 代理在任何给定状态下遵循的一组指令。这是通过一种称为值迭代的迭代方法来完成的。该算法是搜索问题的一个非常好的解决方案，因为它保证收敛到一个最优策略。该算法取决于贝尔曼方程的计算:</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/2e7b4b691e875c3e7b45e18092f91386.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*k7mLyduIRYtIvXAImnOdHg.png"/></div></figure><p id="3a8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对上述等式的解释比看起来要简单得多。正在计算的是在第<strong class="kk iu"> (k+1) </strong>时间步的状态值<strong class="kk iu"> s </strong>。状态的值是与到新状态的转变相关联的奖励，<strong class="kk iu">s’</strong>，以及将从新状态接收的随之而来的奖励。然而，由于这些奖励是未来的奖励，它们现在对吃豆人来说价值较低，因此它使用了一个贴现因子<strong class="kk iu"> 𝛾 </strong>来表示收益递减。因为新状态<strong class="kk iu">s’</strong>是不确定的，所以该等式取每个可能的新状态的平均值，并基于转移概率对它们进行加权。最后，在每一个可能的行动中取最大值的原因是，存在一种乐观的观点，即不是通过最坏的结果，而是通过最好的结果来定义一个国家的价值。</p><h1 id="647f" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated"><strong class="ak">数值迭代算法</strong></h1><p id="80f5" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">该算法源于上述解释，给出如下:</p><ol class=""><li id="7af8" class="mb mc it kk b kl km ko kp kr md kv me kz mf ld nf mh mi mj bi translated">从所有值为 0 的状态开始。</li><li id="3d8b" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld nf mh mi mj bi translated">使用贝尔曼方程迭代并更新每个状态。</li><li id="ccf5" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld nf mh mi mj bi translated">重复直到收敛。</li></ol><p id="0b7b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着时间的推移，行动的最优选择将收敛到确定每个国家的最优政策。</p><h1 id="7ebc" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated"><strong class="ak"> MDPs 和 Pac-man </strong></h1><p id="b6c1" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">所以你可能会问自己，这和吃豆人有什么关系？吃豆人游戏的设置类似于 MDP。在任何给定的时间点，存在封装游戏的状态，Pac-man 可以选择采取的行动，以及当代理到达新的状态时以点数形式的奖励。然而，上述迭代寻找最优策略的构造并不是真正的学习，而是一种模拟场景和寻找最佳计划的方法。从这个意义上来说，它与搜索算法并没有太大的不同，我也不会违背自己不进行搜索的承诺。所以，建筑需要多一点…</p><h1 id="79b5" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated"><strong class="ak">Q-学习</strong></h1><p id="77cd" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">上面所描述的被称为“离线”解决方案，它在给定一个转移函数和奖励的情况下制定一个最优策略。通常，准确定义是不可能的或非常困难的，因此，代理需要了解真实的分布，而不是不切实际地提供它。因此，需要一种“在线”解决方案，除了它所处的状态和它可以采取的行动之外，它一无所知。</p><p id="acdc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与上面的值迭代相反，优化 Q 函数是对所述问题的解决方案。为什么？价值迭代的等式是期望的成本和回报对等状态。另一方面，Q 函数是当你处于一个状态 s 并应用一个动作 a 时的预期成本和回报。通过这样做，当代理探索每个状态下可用的动作时，下一次将理解随之而来的回报。该实现采用其值符合贝尔曼方程的新样本，并将先前的 Q 值推向新的经验值。这在数学上描述如下:</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/fd89028db9c53a34684fa9cce01abda5.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*ahwX7Ksq84PO0-gTCMTn-w.png"/></div></figure><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/e8b4a721437789794d687a0e3156e688.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*53kyNci60axJXBcqF6As8Q.png"/></div></figure><p id="7d92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在实现中，⍺是学习率，并且该值可以被解释为模型对新样本的存在有多敏感。学习速率越高，新信息的价值就越大，因为当观察到新样本时，新信息的价值会发生相当大的变化。</p><p id="0452" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这种方法在足够高的重复次数后确实能很好地逼近转移概率，但一个明显的问题是在勘探和开采之间的选择。如果主角在状态 s 决定了一个动作 a，并实现了一个积极的回报，那么什么会阻止 Pac-man 在稍后的时间点重复同样的动作。在目前的结构中，什么都没有。这就是引入勘探率的原因。它迫使吃豆人在每次ϵ的时候选择一个随机的移动。最初，<strong class="kk iu"> ϵ=1 </strong>，这意味着吃豆人将总是随机选择一个动作，因为它对游戏板一无所知，因此它将允许吃豆人做出相当数量的好和坏的决定。随着时间的推移，<strong class="kk iu"> ϵ </strong>将收敛到 0，以反映周围游戏知识的增长和探索新动作的需求的缺乏。重要的是要警惕ϵ收敛过快或过慢的影响。收敛太快将导致 Pac-man 在特定状态下不采取足够的行动，结果，估计的转移函数将是不准确的。另一方面，收敛太慢将导致次优决策，即使在多次学习迭代后也是如此，这是随机决策的结果。</p><h1 id="ed38" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated"><strong class="ak"> Q-Learning 和 Pac-man </strong></h1><p id="8b2f" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">在一个典型的固定状态场景中，每个状态都有一个固定的奖励，并且终端状态也是固定的，上述结构将足以遍历棋盘并随着时间优化奖励。然而，吃豆人是一个更有活力的游戏。总共有 3 种终端情况:</p><ul class=""><li id="24ec" class="mb mc it kk b kl km ko kp kr md kv me kz mf ld mg mh mi mj bi translated">因基的好意，游戏结束</li><li id="f8d6" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated">克莱德的好意，游戏结束了</li><li id="1f6c" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated">吞噬最后一颗子弹</li></ul><p id="dadc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，一旦吃豆人吃了一个小球或能量球，并意识到这种行为的回报，它就不能再吞噬同样的小球或能量球。这些事实给了吃豆人一个更加动态的本质，因此要求我们将游戏的这些“特征”编码到学习模型中。这样做还可以降低从基于状态的学习模型到基于特征的学习模型的模型复杂度。</p><p id="718b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用于简化游戏的功能:</p><ul class=""><li id="7815" class="mb mc it kk b kl km ko kp kr md kv me kz mf ld mg mh mi mj bi translated">一步之遥的幽灵数量(该特征赋予附近有 1 或 2 个敌人的状态以重要性)</li><li id="418b" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated">吃食物(强调吃食物行为的特征)</li><li id="3ef2" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated">最接近的食物(赋予最接近的颗粒重要性的特征)</li><li id="f101" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated">偏差(包含其他可能情况的偏差术语)</li></ul><p id="c109" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这样做的时候，近似 Q 学习是近似的，并且将所有可能的情况总结为 4 个特征。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/d7bb730138a5ea4eed3e2e220d904d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*7HqoJ3PDnsbMriV9IhE8Ig.png"/></div></figure><p id="7e8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，对算法进行适当的修改，以学习每个特征的每个<strong class="kk iu"> β </strong>权重。重量代表了吃豆人对每个功能的重视程度。结果，我们对算法进行了适当的修改，使得每个特征的重要性<strong class="kk iu"> β </strong>被学习。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f08166fa0f087c3586342431c0f41113.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*tFfmH6JZVMaWhzJXlfW-zA.png"/></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="b312" class="le lf it bd lg lh nn lj lk ll no ln lo jz np ka lq kc nq kd ls kf nr kg lu lv bi translated">结果呢</h1><p id="4a69" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">最后，我们现在有了一个主角，他穿越周围的世界，建立直觉来躲避对手，同时最大化其一生的回报。</p><p id="4ede" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们用 1000 次迭代和以下参数训练这个模型:</p><ul class=""><li id="0f6b" class="mb mc it kk b kl km ko kp kr md kv me kz mf ld mg mh mi mj bi translated"><strong class="kk iu"> 𝛾 = 0.7 </strong></li><li id="e485" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld mg mh mi mj bi translated"><strong class="kk iu"> ⍺ = 0.1 </strong></li></ul><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="7760" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">认可和改进</h1><p id="de48" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">我希望我们的黄种朋友的上述示范对你和对我一样令人满意。如果没有加州大学伯克利分校的 Pac-man 游戏引擎，这一切都是不可能的，该引擎已经被修改为与 Python 3 兼容。构建和解释我的解决方案的过程是非常宝贵的，尽管还有很多后续步骤。其中包括:</p><ol class=""><li id="0f72" class="mb mc it kk b kl km ko kp kr md kv me kz mf ld nf mh mi mj bi translated">通过为每个幽灵引入传统的目标逻辑使 Pac-man 变得困难。</li><li id="eaef" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld nf mh mi mj bi translated">从 Q-learning 开始，下一个增加的复杂性层可能是深度 Q-Learning 模型。</li><li id="968e" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld nf mh mi mj bi translated">使用包来优化实现(Github 源代码将很快推出)。</li><li id="49b7" class="mb mc it kk b kl mk ko ml kr mm kv mn kz mo ld nf mh mi mj bi translated">能量球被吞噬而鬼魂可以食用的情况很少发生，因此吃豆人不知道如何瞄准鬼魂。</li></ol><p id="7253" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望读者已经被我的第一篇博客吸引住了，并且能够理解强化学习的整体思想和细节。请留下您的评论和反馈。谢谢大家！</p></div></div>    
</body>
</html>