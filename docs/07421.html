<html>
<head>
<title>Airflow — sharing data between tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">气流—在任务之间共享数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/airflow-sharing-data-between-tasks-7bbaa27eeb1?source=collection_archive---------6-----------------------#2020-06-05">https://towardsdatascience.com/airflow-sharing-data-between-tasks-7bbaa27eeb1?source=collection_archive---------6-----------------------#2020-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/49f666a09f3305bfaf7f686874a32980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igE2hF6VXMdRHsMSWD--tQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><h2 id="4f0b" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">如果你在网上寻找气流教程，大多数都会给你很好的介绍什么是气流。他们将从概念上谈论ETL，DAG是什么，构建第一个DAG并向您展示如何执行它。经常被忽略的是DAG的任务应该如何交换数据。</h2><p id="264c" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated"><em class="lt">本文假设你至少对什么是气流及其工作原理有一个基本的了解。</em></p><p id="40c8" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">如果你在网上寻找气流教程，大多数都会给你很好的介绍什么是气流。他们将从概念上谈论ETL，DAG是什么，构建第一个DAG并向您展示如何执行它。</p><p id="7fc2" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">经常被忽略的是这些任务应该如何交换数据。</p><p id="8ba0" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">在构建任务时要记住的一点是，任务必须是幂等的。简化一下我们的例子，这意味着如果使用相似的输入参数执行成功，那么无论您调用它们多少次，它们都会产生相同的结果。当与任务输入/输出相结合时，这可能并不总是显而易见的。</p><p id="ff46" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">当考虑数据交换时，我们可以区分以下任务:</p><ul class=""><li id="35c2" class="lz ma iq la b lb lu lf lv kl mb kp mc kt md ls me mf mg mh bi translated">根本不需要共享数据</li><li id="7aab" class="lz ma iq la b lb mi lf mj kl mk kp ml kt mm ls me mf mg mh bi translated">只分享一小块信息</li><li id="0132" class="lz ma iq la b lb mi lf mj kl mk kp ml kt mm ls me mf mg mh bi translated">运算符本身存储作为其执行结果的数据</li><li id="b48b" class="lz ma iq la b lb mi lf mj kl mk kp ml kt mm ls me mf mg mh bi translated">可以以存储结果的方式编写的运算符</li><li id="6fc8" class="lz ma iq la b lb mi lf mj kl mk kp ml kt mm ls me mf mg mh bi translated">使用气流挂钩保存或读取结果的自定义操作员</li></ul><p id="818d" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><strong class="la ir">不需要数据共享</strong></p><p id="6e1a" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">这种任务关系的简单例子是在第一个任务中在数据库中创建一个表，并在下一个任务中填充该表。</p><p id="5bba" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">这里最重要的是执行顺序。我们需要确保表存在，以便我们可以写入它。在我们的例子中，我们只需要确保第一个任务在第二个任务的上游，我们就可以开始了:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="a087" class="kc kd iq ms b gy mw mx l my mz">create_table.set_upstream(populate_table)</span></pre><p id="46e0" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">或者用我最喜欢的语法:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="1677" class="kc kd iq ms b gy mw mx l my mz">create_table &gt;&gt; populate_table</span></pre><p id="04da" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><strong class="la ir">共享小块数据</strong></p><p id="6918" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">在这里，达格的XComs开始发挥作用。它们易于使用，并允许在运行DAG的任何任务之间共享数据。它们被永久地保存在Airflow的元数据数据库中，但是我考虑在单个DAG之外使用它们作为反模式。</p><p id="5779" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">我听说过人们使用XCom在任务间共享大数据集的情况，这肯定是可能的，但由于一些原因应该避免。</p><p id="d714" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">首先，它破坏了元数据数据库，打破了气流是什么的概念——一个应该最低限度地参与执行和数据存储的编排器。</p><p id="83be" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">第二，不是所有的东西都可以储存。基本上，XCom数据是泡菜，泡菜也有其局限性。</p><p id="6f9d" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">此外，有时XComs可能包含敏感数据，在决定将其存储在Airflow的数据库中之前，您应该三思而行。</p><p id="a92e" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">应该记住的是，如果任务返回结果，那么这些结果将可用于下一个任务的“拉取”。不幸的是，您知道它们是否返回结果的唯一方法是深入研究Operator的源代码(我强烈推荐这种方法，因为它将极大地提高您对气流如何工作的理解)。</p><p id="a52b" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">我不知道使用XCom共享的数据的最大大小应该是多少，但是我想说，如果它能加速DAGs的开发，那么几MB是可以的。或者换句话说，如果你的任务的结果没有内置的结果“存储”,你会觉得懒惰🙂要编写单独的操作符，您可以考虑将其推送到XCom。</p><p id="2654" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><strong class="la ir">具有“本地”结果存储的操作员</strong></p><p id="272d" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">很容易知道operator是否会存储它的执行结果，因为它是传递给operator类的参数之一。这里的示例是“BigQueryExecuteQueryOperator ”,其中查询输出被保存到另一个表中:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="c40e" class="kc kd iq ms b gy mw mx l my mz">execute_query = BigQueryExecuteQueryOperator(<br/>    task_id="execute_query_save",<br/>    sql="SELECT * FROM MY_DATASET.TABLE_IN",<br/>    use_legacy_sql=False,<br/>    destination_dataset_table="MY_DATASET.TABLE_OUT")</span></pre><p id="d0a9" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">为了使用结果，流水线中的下一个任务必须到达TABLE_OUT。</p><p id="3ec7" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><strong class="la ir">可以被“强制”存储数据的操作员</strong></p><p id="47a3" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">假设我们的操作符没有等效的“destination_dataset_table”参数。</p><p id="af66" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">当然，您可以通过继承“BigQueryExecuteQueryOperator”来编写自己的操作符，但有时更简单的选择是编写您的查询，以便将结果存储在某个地方。类似于:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="53bb" class="kc kd iq ms b gy mw mx l my mz">INSERT INTO TABLE_OUT<br/>SELECT &lt;columns&gt; FROM TABLE_IN</span></pre><p id="f2b9" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><strong class="la ir">自定义操作员读/写</strong></p><p id="60c0" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">如果你运气不好，剩下的就是使用气流的钩子来完成这项工作。该选项既可用于写入任务的结果数据，也可用于在下一个必须使用它的任务中读取数据。是的，这意味着您必须编写一个自定义任务，例如如下所示:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="58b2" class="kc kd iq ms b gy mw mx l my mz">def load_data(ds, **kwargs):<br/>    conn = PostgresHook(postgres_conn_id=src_conn_id).get_conn()</span><span id="a7be" class="kc kd iq ms b gy na mx l my mz">    # Notice: cursor had to be named to make loading in batches work      (so called "server cursor")<br/>    cursor = conn.cursor('serverCursor')<br/>    cursor.execute(kwargs['query'])</span><span id="1c5d" class="kc kd iq ms b gy na mx l my mz">    while True:<br/>        records = cursor.fetchmany(size=10000)<br/>        if not records:<br/>            break<br/>        <em class="lt">[ ... do something with records ...]</em></span><span id="27ac" class="kc kd iq ms b gy na mx l my mz">    cursor.close()<br/>    conn.close()</span></pre><p id="156a" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">并使用例如“PythonOperator”来执行它:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d81f" class="kc kd iq ms b gy mw mx l my mz">load_and_transform = PythonOperator(task_id='load_and_transform',<br/>    python_callable=load_data,<br/>    op_kwargs={'query': 'SELECT * FROM TABLE_IN'},<br/>    provide_context=True,<br/>    dag=your_dag)</span></pre><p id="bc10" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">我希望这些简单的技巧能帮助你写出更可靠的任务。</p><p id="13ce" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><em class="lt">旁注:如果你正在寻找在任务间传递数据时更友好的工具，可以看看与Airflow有很多相似之处的impfect . io，并尝试修复Airflow的错误。请记住，使用它并不是完全免费的。</em></p></div></div>    
</body>
</html>