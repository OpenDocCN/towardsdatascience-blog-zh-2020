<html>
<head>
<title>Analyze Big Data on your Laptop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析笔记本电脑上的大数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/medium-data-on-your-laptop-in-2020-e986468a577f?source=collection_archive---------45-----------------------#2020-06-04">https://towardsdatascience.com/medium-data-on-your-laptop-in-2020-e986468a577f?source=collection_archive---------45-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="02df" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理大于内存的数据的技术。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9acbf130c92dade6b70649a699a57090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qs6dn0e_q0wSvVIp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@filisantillan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Filiberto Santillán </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="c096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大数据自2005年左右就已经存在了。当时，如果你想操纵大数据，Hadoop是热门的新玩具。然而，最有可能的是，您必须建立自己的内部集群，花几周或几个月的时间配置所有东西，然后才能真正<em class="lv">对数据进行处理。</em></p><p id="bf17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，情况不同了，就像所有与技术相关的事情一样，对大数据工具的访问已经民主化。</p><p id="7d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，有三件事发生了变化:</p><ol class=""><li id="58ad" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">内存成本一直在下降，这意味着如今数据科学笔记本电脑上24GB或32GB的内存非常普遍。</li><li id="19b8" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">所有大数据基础设施在诸如AWS或GCP这样的云平台上都可以轻松使用。</li><li id="8fcf" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">尽管大数据在过去被Java或Scala所主宰，但在几个成熟的专用库的帮助下，python已经成为这个世界上的一流公民。</li></ol><p id="8955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本大数据系列的第一章中，我们将看到2020年大数据项目有哪些<strong class="lb iu">本地</strong>选项，以及您应该根据您的用例选择哪一个。</p><p id="f927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，您可以在笔记本电脑上做任何需要做的事情，尤其是当您处理的是<em class="lv">介质</em>数据(几十GB)时。好处是您可以立即开始。这种情况与两种情况相关:</p><h1 id="72ce" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">1.您可以缩小数据</h1><p id="ac5f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">事实上，处理大数据最简单的方法是……将其转换成较小的数据，并在本地进行处理。</p><h2 id="cd1e" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">亚取样</h2><p id="8308" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">作为第一个例子，假设您有数十亿个点跟踪道路上用户的驾驶速度，并且您想知道速度分布是什么样子，或者基于驾驶模式构建保险索赔的预测模型。在这种情况下，一种明智的方法是对数据进行子采样，假设您可以使其小到足以容纳您的内存，但又大到足以具有统计代表性。因此，如果您的数据库中有100，000个用户，每个用户每秒钟都有一个数据点，他们在路上，您可以对您的数据进行子采样，对于10K用户的随机子集和数据库中的特定月份，每10秒钟只获取一个数据点。</p><p id="55cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看数字是什么样子的。假设您有:</p><ul class=""><li id="c213" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu nt mc md me bi translated">100，000名用户，每名用户每秒钟可获得1个数据点</li><li id="95ce" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">假设每个数据点包含5或6个字段(某种ID，2个位置字段和2个速度向量字段)，每个数据点总计约200字节</li><li id="b105" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">每个用户平均每天驾驶1小时，总计每天3600个数据点，每月100K个数据点</li><li id="e176" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">数据的总大小:(100K用户)x(每月100K数据点)x(每个数据点200字节)=每月200GB</li></ul><p id="efe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">200GB显然不是您通常会在笔记本电脑上处理的东西，但是采用前面的方法(对于10K随机选择的用户，每10秒1个数据点)会将它降低到2GB！</p><p id="c9ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然它可能不会给你一个尽可能精确的图片，但对于最初的探索，甚至是一个模型的MVP来说，它肯定是绰绰有余的。</p><h2 id="08c7" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">组块</h2><p id="7ca8" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">有时，您希望应用于数据的处理或分析自然会被分成多个独立的步骤。例如，您可能想要生成月度报告，或者您想要按州或城市计算一些统计数据。</p><p id="ac0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，只下载当前分析阶段(正在分析的当前月份或当前地理位置)所需的数据，对其执行分析，然后继续下一次迭代，每次都交换内存中的数据，而不是增加分配的内存大小，这是很有意义的。</p><p id="26e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要您不介意等待整个流程按顺序完成运行，或者如果您只需要更新它而不是每次从头开始重新运行它，这种迭代方法是很有趣的。</p><p id="34e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您使用子采样还是分块，大数据都存储在某个地方的数据仓库中，您可以对其进行查询，但您永远不会将它完全放在您的笔记本电脑上。</p><h2 id="06e5" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">向下铸造</h2><p id="99e4" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">向下转换是将64字节浮点列转换为32字节浮点列的过程，假设您不介意精度上的小损失。您还可以向下转换64字节的长整数，特别是当您有像年或年龄这样的东西时，它们真的不需要那么多空间！</p><p id="d59c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，pandas最近引入了<code class="fe nu nv nw nx b">category</code> dtype，对于分类数据非常有用，代替了默认的<code class="fe nu nv nw nx b">object</code>(或字符串)dtype。不同之处在于，新的<code class="fe nu nv nw nx b">category</code> dtype只为分类变量的每个<strong class="lb iu">唯一值</strong>保留空间，而默认的<code class="fe nu nv nw nx b">object</code> dtype为每个值保留空间。</p><p id="fe35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe nu nv nw nx b">astype</code>函数，您可以在读取数据后向下转换您的列，但是最好您可以使用<code class="fe nu nv nw nx b">dtype</code>参数在<code class="fe nu nv nw nx b">read_csv</code>函数调用中指定您的列的类型。</p><h1 id="b275" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">2.您可以使用库来处理大于内存的数据</h1><p id="9249" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">假设子采样或分块不能满足您的需求。让我们以由100只股票组成的ETF(交易所交易基金)为例，你必须找到该ETF的确切波动率，给定这100只股票中每只股票的每日收盘价。上面的选项(子采样、分块或向下转换)都不令人满意，因为在这种情况下，您希望尽可能精确。</p><p id="154f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是使用一个可以处理核外计算的库，这意味着它可以计算统计数据或处理存储在硬盘上的数据，根据需要将数据移入和移出内存。</p><h2 id="bf70" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">对于统计计算，使用Vaex</h2><p id="dc02" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">👉<strong class="lb iu">读取数据</strong></p><p id="3858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在计算大量表格数据的统计数据时，Vaex的速度非常快。Vaex的另一个非常好的特性是能够在数据框上创建虚拟列，也称为表达式。它们不会占用任何内存空间，Vaex会根据需要动态使用它们。</p><p id="8b63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要安装vaex，假设您已经安装了python，只需运行:<code class="fe nu nv nw nx b">pip install vaex</code>，但是<strong class="lb iu">确保您是以admin </strong>身份运行的。</p><p id="471c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Vaex与HDF5配合得非常好，因此如果您从一个大的CSV文件或一堆CSV文件开始，您首先要做的是将它们转换为一个HDF5文件。下面是执行此操作的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="63e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们简单地使用<code class="fe nu nv nw nx b">import glob</code>并将第一行替换为:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="d3ba" class="nh ml it nx b gy oe of l og oh">for i, chunk in enumerate([pd.read_csv(file) for file in glob.glob('folder/path')]):</span></pre><p id="3702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你可以用<code class="fe nu nv nw nx b">df = vaex.open('bigfile.hdf5')</code>连接你的数据。</p><p id="50fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👉<strong class="lb iu">用Vaex计算统计</strong></p><p id="7d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从那里，计算统计数据就像:<code class="fe nu nv nw nx b">df.&lt;statname&gt;(&lt;expression&gt;, [binby=], [limits=])</code>一样简单。</p><p id="e43d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几个例子:</p><ul class=""><li id="6597" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu nt mc md me bi translated">计算数据帧中<code class="fe nu nv nw nx b">A</code>列的平均值:<code class="fe nu nv nw nx b">df.mean(df.A)</code>或等效的<code class="fe nu nv nw nx b">df.mean(df.A, limits='minmax')</code>。</li><li id="c1d6" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">只计算0到10之间的平均值:<code class="fe nu nv nw nx b">df.mean(df.A, limits=[0, 10])</code>。</li><li id="2ddb" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">同时做上面两个例子:<code class="fe nu nv nw nx b">df.mean(df.A, ['minmax', [0, 10]])</code>。</li><li id="00d3" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">计算仅包括中间99%值的平均值(即排除左侧的0.5%和右侧的0.5%):<code class="fe nu nv nw nx b">df.mean(df.A, limits='99%')</code>。</li><li id="7918" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">我们也可以用字符串名来指代列:<code class="fe nu nv nw nx b">df.mean('A')</code>。</li><li id="cedf" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">或者我们可以即时构建表达式:<code class="fe nu nv nw nx b">df.mean('A + 10*B')</code>。</li><li id="e5e7" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">我们可以使用参数<code class="fe nu nv nw nx b">binby</code>按bin计算统计量，参数应该是一个表达式列表:<code class="fe nu nv nw nx b">df.mean('A', binby=['B'])</code>。</li><li id="7bae" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">当使用宁滨时，您可以通过使用shape参数来控制箱的数量，shape参数是维度值的列表，例如，<code class="fe nu nv nw nx b">df.mean('A', binby=['B'], shape=4)</code>将使用4个箱返回B的每个箱的平均值A。如果使用多个表达式进行绑定，您可以通过提供单个形状值来获得正方形网格，也可以提供一个形状值列表(每个宁滨表达式一个形状值)。</li><li id="bd29" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">我们可以将Vaex表达式传递给<code class="fe nu nv nw nx b">numpy</code>函数，它将返回一个新的Vaex表达式，例如<code class="fe nu nv nw nx b">df.newA = np.clip(np.log(df.A), 0, 1)</code>。这里我们也在数据帧中存储新的表达式。</li></ul><p id="b20b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是您可以计算的可用统计信息列表:<code class="fe nu nv nw nx b">count</code>、<code class="fe nu nv nw nx b">mean</code>、<code class="fe nu nv nw nx b">std</code>、<code class="fe nu nv nw nx b">var</code>、<code class="fe nu nv nw nx b">cov</code>、<code class="fe nu nv nw nx b">correlation</code>、<code class="fe nu nv nw nx b">median_approx</code>、<code class="fe nu nv nw nx b">mode</code>、<code class="fe nu nv nw nx b">min</code>、<code class="fe nu nv nw nx b">max</code>、<code class="fe nu nv nw nx b">minmax</code>、<code class="fe nu nv nw nx b">mutual_information</code>。API文档可以在这里找到<a class="ae ky" href="https://vaex.readthedocs.io/en/latest/api.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="28af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用方括号([]): <code class="fe nu nv nw nx b">df_negative = df[df.x &lt; 0]</code>过滤数据帧，然后我们可以在过滤后的数据帧上执行上面的任何计算(或下面的绘图)。</p><p id="91c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👉<strong class="lb iu">用Vaex操作数据</strong></p><p id="3e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> a .加入数据</em></p><p id="0e78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用Vaex做左、右和内连接。语法很简单:<code class="fe nu nv nw nx b">dfA.join(dfB, left_on='a', right_on='b', how='left|right|inner')</code></p><p id="db01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> b .分组和汇总</em></p><p id="5d4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个来自Vaex教程的例子，展示了分组/聚合功能，包括控制计算列的名称:<code class="fe nu nv nw nx b">df.groupby(by='x', agg={'mean_y': vaex.agg.mean('y'), 'max_z': vaex.agg.max('z')}</code>。</p><p id="4473" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到聚合函数在<code class="fe nu nv nw nx b">vaex.agg</code>模块内部。可用的功能有:<code class="fe nu nv nw nx b">count</code>、<code class="fe nu nv nw nx b">first</code>、<code class="fe nu nv nw nx b">max</code>、<code class="fe nu nv nw nx b">min</code>、<code class="fe nu nv nw nx b">sum</code>、<code class="fe nu nv nw nx b">mean</code>、<code class="fe nu nv nw nx b">std</code>、<code class="fe nu nv nw nx b">var</code>、<code class="fe nu nv nw nx b">nunique</code>。</p><p id="c2d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👉<strong class="lb iu">用Vaex绘图</strong></p><p id="a3dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Vaex提供了一个简单的API来绘制大量数据的统计数据。两个主要的函数是<code class="fe nu nv nw nx b">plot1d</code>和<code class="fe nu nv nw nx b">plot2d</code>，它们被从一个dataframe对象中调用。例如:</p><ul class=""><li id="a2a4" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu nt mc md me bi translated">用x的值来画E的平均值:<code class="fe nu nv nw nx b">df.plot1d(df.x, what='mean(E)', limits='99%')</code>。请注意，这些限制适用于X轴，并且有一个值为64的默认<code class="fe nu nv nw nx b">shape</code>参数(即默认情况下，X值将被分成64个箱)。</li><li id="7b4b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">或者，我们可以使用<code class="fe nu nv nw nx b">vaex.stat.&lt;statistic&gt;</code>语法来利用制表符结束。上面的例子可以改写为:<code class="fe nu nv nw nx b">df.plot1d(df.x, what=vaex.stat.mean(df.E), limits='99%')</code>。</li><li id="8505" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">如果您已经计算了想要绘制的统计数据，您应该传递<code class="fe nu nv nw nx b">grid</code>参数(带有结果表达式)而不是<code class="fe nu nv nw nx b">what</code>。</li><li id="2cb9" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu nt mc md me bi translated">对于2d绘图:<code class="fe nu nv nw nx b">df.plot(df.x, df.y, what=vaex.stat.mean(df.E)**2, limits='99%')</code>，它将输出如下内容:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/1e1bfb1a3359bb458738afa0882d5d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*8l3h3ELqBY6SW8q9.png"/></div></figure><p id="f392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👉<strong class="lb iu">使用Vaex进行高级绘图</strong></p><p id="8181" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以通过传递轴的表达式对列表(默认情况下显示为列)和/或“what”列表(默认情况下显示为行)来输出多个图。</p><p id="0b7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe nu nv nw nx b">df.plot([['x', 'y'], ['x', 'z']], what=[vaex.stat.count(), vaex.stat.mean(df.E)])</code>将输出一个网格2x2的图。</p><p id="2c9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可能希望显示不同数据子集的图。在这种情况下，前面提到的过滤数据的方法(使用括号并将结果赋给变量)将是低效的，更好的方法是使用<code class="fe nu nv nw nx b">selection</code>参数。因为默认情况下选择会在同一个图表上过量绘制，所以我们可以使用<code class="fe nu nv nw nx b">visual</code>参数进行定制。例如，要将选择显示为列，将不同的表达式显示为行:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="0433" class="nh ml it nx b gy oe of l og oh">df.plot([['x', 'y'], ['x', 'z']], what=vaex.stat.count(), selection=[None, df.E &gt; 0], visual=dict(column='selection'))</span></pre><p id="2e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👉<strong class="lb iu">带Vaex的超级琴弦</strong></p><p id="a37a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Vaex可以对字符串列应用一系列操作。这些操作可以通过使用<code class="fe nu nv nw nx b">df.string_column.str.&lt;operation&gt;</code>语法来调用。操作列表可以在这里找到<a class="ae ky" href="https://vaex.readthedocs.io/en/latest/api.html#string-operations" rel="noopener ugc nofollow" target="_blank">。一些最有用的是<code class="fe nu nv nw nx b">contains</code>(用于子串检测)和<code class="fe nu nv nw nx b">match</code>(用于正则表达式匹配)，连接字符串列的<code class="fe nu nv nw nx b">cat</code>，以及不言自明的<code class="fe nu nv nw nx b">startswith</code> / <code class="fe nu nv nw nx b">endswith</code>。</a></p><h2 id="663e" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">如果您打算以后使用云集群，请使用Dask</h2><p id="6ad8" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">Dask是python世界中著名的大数据处理库。我要直截了当地说，如果你只处理<strong class="lb iu">中等数据</strong>，也就是说，你的数据集是以千兆字节为单位的，Vaex每次都会在性能方面击败Dask。</p><p id="a550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，Vaex被设计为在单台计算机上工作。目前没有多节点内置功能。另一方面，Dask使用统一的API提供单节点和多节点功能。如果在迁移到云之前，您只想在本地进行一些测试或试验，那么这是一个巨大的优势。</p><p id="e354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dask的另一个特性是它试图模仿python数据科学家熟悉的许多库:当然是pandas，还有scikit-learn和其他库。这使得学习曲线几乎不存在。例如，在Dask中读取CSV文件非常简单:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="31f6" class="nh ml it nx b gy oe of l og oh">import dask.dataframe as dd df = dd.read_csv(filepath, blocksize=25e6) #25MB chunks</span></pre><p id="8146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的机器上有n个内核，您可以调整块大小(也取决于您的总可用RAM)来优化运行时，尝试读取n个块中的数据。Dask可以轻松地从各种来源(本地或远程)读取各种格式(CSV、parquet、hdf5等)的数据。).</p><p id="a37d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在某些方面是一个优势，但从长远来看，它也可能是一个约束，因为scikit-learn中的一些设计选择并不是最好的。</p><p id="01fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的另一个警告是Dask的<code class="fe nu nv nw nx b">apply</code>方法要求用户指定输出的类型和名称。这不是一个巨大的烦恼，只是一些需要注意的事情。</p><p id="da0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我非常喜欢<a class="ae ky" href="https://distributed.dask.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> Dask Distributed </a>，这是一个用于python分布式计算的轻量级库。在云中设置非常容易，我在这里写了一个关于<a class="ae ky" href="https://medium.com/@klahrichi/hyperparameter-tuning-with-dask-distributed-and-mlflow-ca6a4a275a2e" rel="noopener">的主题。</a></p><p id="fbca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">下期保持联系！我将探索面向大数据的云技术:Spark、Bigquery、Dataflow等等。</em></p></div></div>    
</body>
</html>