<html>
<head>
<title>Automate Kaggle Competition with the help of Google Colab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">借助Google Colab自动化Kaggle竞赛</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/automate-kaggle-competition-with-the-help-of-google-colab-4c43a6960115?source=collection_archive---------26-----------------------#2020-01-07">https://towardsdatascience.com/automate-kaggle-competition-with-the-help-of-google-colab-4c43a6960115?source=collection_archive---------26-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0869" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何有效使用colab笔记本，创建Kaggle管道</h2></div><p id="3e59" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我开始研究Kaggle问题时，我在Kaggle笔记本上工作压力很大。在Spyder和Jupyter笔记本上工作过之后，我对在Kaggle上工作感到不舒服。在找出一些实用程序的过程中，比如增加RAM、通过API加载数据、使用GPU等，我发现Colab解决方案更容易获得(也许这是Google的事情！).我在Colab中找到了一些简单的技巧，使使用Colab更容易，并创建了一个Kaggle ML管道来自动化这个过程。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi le"><img src="../Images/59b9bbf076b95e56141530bfb18c1eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*qX60UncOT7xXa53Otpz-iw.jpeg"/></div></figure><p id="ad0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae lm" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> Google Colab </strong> </a>是一个<strong class="kk iu">免费的</strong> Jupyter/IPython笔记本环境，不需要设置，完全在云中运行。</p><h2 id="7d97" class="ln lo it bd lp lq lr dn ls lt lu dp lv kr lw lx ly kv lz ma mb kz mc md me mf bi translated">如何充分利用Colab？</h2><p id="b263" class="pw-post-body-paragraph ki kj it kk b kl mg ju kn ko mh jx kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在创建一个新的Python笔记本后，确保将运行时类型更改为GPU，您将分配到约12.72 GB RAM和英伟达特斯拉P4或英伟达特斯拉K80或英伟达特斯拉P100 GPU约7.1 GB作为GPU。通过运行以下命令，可以将内存分配增加到大约25.51 GB RAM，将GPU增加到大约16 GB。</p><pre class="lf lg lh li gt ml mm mn mo aw mp bi"><span id="250d" class="ln lo it mm b gy mq mr l ms mt">d=[]<br/>while(1):<br/>  d.append('1')</span></pre><p id="b84e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的命令试图扩展(由于‘append’命令)RAM，并在此过程中崩溃。在上次内存分配崩溃后，点击“获取更多内存”。然后，您可以通过运行以下命令来检查分配的GPU。</p><pre class="lf lg lh li gt ml mm mn mo aw mp bi"><span id="9be2" class="ln lo it mm b gy mq mr l ms mt">!nvidia-smi</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="d962" class="nb lo it bd lp nc nd ne ls nf ng nh lv jz ni ka ly kc nj kd mb kf nk kg me nl bi translated">Kaggle管道:</h1><p id="173b" class="pw-post-body-paragraph ki kj it kk b kl mg ju kn ko mh jx kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我正在考虑<a class="ae lm" href="https://www.kaggle.com/c/ieee-fraud-detection" rel="noopener ugc nofollow" target="_blank"> Kaggle IEEE-CIS欺诈检测竞赛</a>，我现在将一步一步地分解colab中一个典型的Kaggle机器学习管道。</p><h2 id="872c" class="ln lo it bd lp lq lr dn ls lt lu dp lv kr lw lx ly kv lz ma mb kz mc md me mf bi translated">1.从API调用下载数据集:</h2><p id="7564" class="pw-post-body-paragraph ki kj it kk b kl mg ju kn ko mh jx kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">首先下载您的API令牌，方法是转到您的Kaggle我的帐户(<a class="ae lm" href="https://www.kaggle.com/*Your-Username*/account)" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/*Your-Username*/account)</a>，转到“API”部分，然后单击“创建新的API令牌”。您现在将下载一个名为“kaggle.json”的文件。你必须把这个文件上传到你的笔记本上。</p><pre class="lf lg lh li gt ml mm mn mo aw mp bi"><span id="f301" class="ln lo it mm b gy mq mr l ms mt">from google.colab import files<br/>uploaded = files.upload()</span></pre><p id="ed77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用下面给出的代码来下载和解压缩数据集。</p><pre class="lf lg lh li gt ml mm mn mo aw mp bi"><span id="fbee" class="ln lo it mm b gy mq mr l ms mt">!mkdir -p ~/.kaggle<br/>!cp kaggle.json ~/.kaggle/<br/>!chmod 600 ~/.kaggle/kaggle.json<br/>!kaggle competitions download --force ieee-fraud-detection<br/>#Unzip the downloaded files<br/>!unzip sample_submission.csv.zip<br/>!unzip test_identity.csv.zip<br/>!unzip test_transaction.csv.zip<br/>!unzip train_identity.csv.zip<br/>!unzip train_transaction.csv.zip</span></pre><p id="dc8d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您可以以最有效的方式访问大小约为1.2 GB的数据集。</p><h2 id="cfe8" class="ln lo it bd lp lq lr dn ls lt lu dp lv kr lw lx ly kv lz ma mb kz mc md me mf bi translated">2.预处理和数据争论:</h2><p id="9873" class="pw-post-body-paragraph ki kj it kk b kl mg ju kn ko mh jx kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">使用熊猫，读取这种规模的数据集有时需要几分钟。为了有效地使用提供的RAM和GPU，我们可以使用dask包在不到一秒的时间内读取这些大数据集！！</p><pre class="lf lg lh li gt ml mm mn mo aw mp bi"><span id="f906" class="ln lo it mm b gy mq mr l ms mt">import dask.dataframe as dd<br/>train_identity = dd.read_csv('train_identity.csv')<br/>train_transaction = dd.read_csv('train_transaction.csv')<br/>test_identity = dd.read_csv('test_identity.csv')<br/>test_transaction = dd.read_csv('test_transaction.csv')<br/>sub = dd.read_csv('sample_submission.csv')<br/># let's combine the data and work with the whole dataset<br/>train = dd.merge(train_transaction, train_identity, on='TransactionID', how='left')<br/>test = dd.merge(test_transaction, test_identity, on='TransactionID', how='left')</span></pre><p id="6a76" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说到数据争论，我接着改变了必要的数据类型，并训练和测试数据分割。这可以根据他们的风格和舒适度来做。你可以通过<a class="ae lm" href="https://colab.research.google.com/drive/1QK2Iw1At-sZuQbaBkOWAJZZKUhOVSyJ5" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> colab </strong> </a>为我进行数据角力的步骤。</p><h2 id="e977" class="ln lo it bd lp lq lr dn ls lt lu dp lv kr lw lx ly kv lz ma mb kz mc md me mf bi translated">3.特征工程和特征选择:</h2><p id="0abf" class="pw-post-body-paragraph ki kj it kk b kl mg ju kn ko mh jx kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">这可以根据数据集的类型来完成，自由地创建新的特征并使用特征选择技术，如递归特征消除、BORUTA、基于树的特征选择等。我在“SelectFromModel”的帮助下使用了“sklearn feature_selection ”,并使用“XGBClassifier”来进行特征选择。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="dc1f" class="ln lo it bd lp lq lr dn ls lt lu dp lv kr lw lx ly kv lz ma mb kz mc md me mf bi translated">4.模型构建:</h2><p id="2dff" class="pw-post-body-paragraph ki kj it kk b kl mg ju kn ko mh jx kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我使用XGboost来拟合数据，使用gridsearchCV或randomsearchCV或贝叶斯优化等超参数技术来选择参数，这些超参数优化技术的详细版本将包含在以后的博客中。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3a24" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 5。提交文件:</strong></p><p id="0c49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在对测试数据进行验证之后，可以将Kaggle的进一步“提交数据”预测添加到管道中，以确保在预测之后下载文件。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8e30" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请从这个<a class="ae lm" href="https://colab.research.google.com/drive/1QK2Iw1At-sZuQbaBkOWAJZZKUhOVSyJ5" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> colab </strong> </a>检查详细的Kaggle管道，我在提交文件上收到了大约0.93的分数，运行管道的最短时间为大约5分钟。然后，我们可以通过更改参数网格和使用不同的模型(如LightGBM、Catboost、Adaboost等)来改进模型，从而实现自动化。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/bf410b8a97f4247ff73a7e0e998feabe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ee1dK7N68vg5UBzHXZBeTg.png"/></div></div></figure><h2 id="35fe" class="ln lo it bd lp lq lr dn ls lt lu dp lv kr lw lx ly kv lz ma mb kz mc md me mf bi translated">专业提示:</h2><p id="4ca0" class="pw-post-body-paragraph ki kj it kk b kl mg ju kn ko mh jx kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">除此之外，如果您担心colab可能会断开连接，您可以通过在浏览器中单击Ctrl+ Shift + i，运行下面的一小段Javascript代码。</p><pre class="lf lg lh li gt ml mm mn mo aw mp bi"><span id="b13b" class="ln lo it mm b gy mq mr l ms mt"><strong class="mm iu">function</strong> <strong class="mm iu">ClickConnect</strong>(){<br/>console.log("Working"); <br/>document.querySelector("colab-toolbar-button#connect").click() <br/>}<strong class="mm iu">setInterval</strong>(ClickConnect,60000)</span></pre><p id="8eb5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">结论:</strong></p><p id="2e94" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">处理Kaggle竞赛中提供的大型数据集可能是一个耗时的过程。如果我们可以有效地利用google colab笔记本来创建管道，那么我们就可以利用dask等并行计算库，并有效地使用GPU来加速和自动化数据建模过程。</p><h1 id="4031" class="nb lo it bd lp nc nt ne ls nf nu nh lv jz nv ka ly kc nw kd mb kf nx kg me nl bi translated">参考资料:</h1><ul class=""><li id="b8f2" class="ny nz it kk b kl mg ko mh kr oa kv ob kz oc ld od oe of og bi translated"><a class="ae lm" href="https://arxiv.org/abs/1603.02754" rel="noopener ugc nofollow" target="_blank"> XGBoost </a></li><li id="326d" class="ny nz it kk b kl oh ko oi kr oj kv ok kz ol ld od oe of og bi translated"><a class="ae lm" href="https://www.kaggle.com/c/ieee-fraud-detection" rel="noopener ugc nofollow" target="_blank"> Kaggle IEEE-CIS欺诈检测竞赛</a></li></ul></div></div>    
</body>
</html>