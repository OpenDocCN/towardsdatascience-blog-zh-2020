<html>
<head>
<title>I Used Machine Learning to Organize Dating Profiles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我用机器学习来组织约会档案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sorting-dating-profiles-with-machine-learning-and-python-51db7a074a25?source=collection_archive---------20-----------------------#2020-03-26">https://towardsdatascience.com/sorting-dating-profiles-with-machine-learning-and-python-51db7a074a25?source=collection_archive---------20-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="61ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在约会档案中寻找相关性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9848747694102873123927bba0016e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9u2C0OsPfmeqRVIw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jonah Pettrich 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a9bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">答</span>在无休止地浏览数百个约会档案，却找不到一个匹配的之后，人们可能会开始怀疑这些档案怎么会出现在他们的手机上。所有这些简介都不是他们要找的类型。他们已经刷了几个小时甚至几天，没有发现任何成功。他们可能会问:</p><blockquote class="me mf mg"><p id="1f6a" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">“为什么这些约会应用程序向我显示我知道我不会与之匹配的人？”</p></blockquote><p id="ced2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于许多厌倦了在应该匹配的时候向左滑动的人来说，用来显示约会档案的约会算法可能看起来很糟糕。每个约会网站和应用程序都可能利用他们自己的秘密约会算法来优化用户之间的匹配。但是有时候感觉就像是在没有任何解释的情况下向其他人展示随机的用户。我们怎样才能更多地了解并解决这个问题？通过使用一个叫做<strong class="lb iu"> <em class="mh">的小东西，机器学习</em> </strong>。</p><p id="192a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用机器学习来加快约会应用程序中用户之间的匹配过程。通过机器学习，简档可以潜在地与其他相似的简档聚集在一起。这将减少相互不兼容的配置文件的数量。从这些聚类中，用户可以找到更像他们的其他用户。机器学习聚类过程已在下面的文章中介绍过:</p><div class="ml mm gp gr mn mo"><a rel="noopener follow" target="_blank" href="/dating-algorithms-using-machine-learning-and-ai-814b68ecd75e"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd iu gy z fp mt fr fs mu fu fw is bi translated">我用机器学习和人工智能做了一个约会算法</h2><div class="mv l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">towardsdatascience.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb ks mo"/></div></div></a></div><p id="5bce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道我们是如何实现交友档案的聚类的，请花点时间阅读一下。</p><blockquote class="me mf mg"><p id="cfc4" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated"><a class="ae ky" href="https://marco-santos.medium.com/membership" rel="noopener">在这里注册一个中级会员，可以无限制地访问和支持像我这样的内容！在你的支持下，我赚了一小部分会费。谢谢！</a></p></blockquote></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="17c6" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">聚类配置文件数据</h1><p id="94ec" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">使用上面文章中的数据，我们能够在一个方便的Pandas数据框架中成功地获得聚类的日期分布图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/dde0129b5d0c470421313dbcc7a90610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_2nr7r221ehsdIGHYzHtA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">聚类约会简档数据的屏幕截图</p></figure><p id="0257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此数据框架中，每行都有一个配置文件，在对数据集应用<a class="ae ky" href="https://www.datanovia.com/en/lessons/agglomerative-hierarchical-clustering/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="mh">分层凝聚聚类</em> </strong> </a>后，我们可以看到它们所属的聚类组。每个配置文件属于一个特定的群集号或组。然而，这些团体可以使用一些改进。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="119f" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">对集群配置文件进行排序</h1><p id="9d1f" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">有了聚类的配置文件数据，我们可以通过根据它们彼此的相似程度对每个配置文件进行排序来进一步细化结果。这个过程可能比你想象的更快更容易。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对聚类数据集进行排序所需的所有代码</p></figure><h2 id="1f3b" class="oj nk it bd nl ok ol dn np om on dp nt li oo op nv lm oq or nx lq os ot nz ou bi translated">代码分解</h2><p id="3083" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">让我们从<code class="fe ov ow ox oy b">random</code>开始将代码分解成简单的步骤，在整个代码中使用它只是为了选择要选择的集群和用户。这样做是为了让我们的代码适用于数据集中的任何用户。一旦我们有了随机选择的聚类，我们就可以缩小整个数据集的范围，只包括那些具有所选聚类的行。</p><h2 id="7835" class="oj nk it bd nl ok ol dn np om on dp nt li oo op nv lm oq or nx lq os ot nz ou bi translated">…向量化…</h2><p id="06fc" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">缩小所选集群组的范围后，下一步是对该组中的bios进行矢量化。<strong class="lb iu"> <em class="mh">我们使用的矢量器与我们创建初始聚类数据帧时使用的矢量器相同— </em> </strong> <code class="fe ov ow ox oy b">CountVectorizer()</code>。(<em class="mh">在我们对第一个数据集进行矢量化时，之前已经实例化了矢量器变量，这可以在上面的文章</em>中观察到)。</p><pre class="kj kk kl km gt oz oy pa pb aw pc bi"><span id="7961" class="oj nk it oy b gy pd pe l pf pg"># Fitting the vectorizer to the Bios<br/>cluster_x = vectorizer.fit_transform(group['Bios'])</span><span id="6dbd" class="oj nk it oy b gy ph pe l pf pg"># Creating a new DF that contains the vectorized words<br/>cluster_v = pd.DataFrame(cluster_x.toarray(), <br/>                         index=group.index,   <br/>                         columns=vectorizer.get_feature_names())</span></pre><p id="5ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过对Bios进行矢量化，我们创建了一个包含每个Bios中的单词的二进制矩阵。</p><p id="9198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们将把这个矢量化的数据帧连接到所选的组/集群数据帧。</p><pre class="kj kk kl km gt oz oy pa pb aw pc bi"><span id="5ab5" class="oj nk it oy b gy pd pe l pf pg"># Joining the vector DF and the original DF<br/>group = group.join(cluster_v)</span><span id="f538" class="oj nk it oy b gy ph pe l pf pg"># Dropping the Bios because it is no longer needed<br/>group.drop('Bios', axis=1, inplace=True)</span></pre><p id="9371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将两个数据框连接在一起后，我们剩下矢量化的bios和分类列:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/300668abec68160b6ccfe506f1b977cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELgxAFs7CZVcXkKCdLrorQ.png"/></div></div></figure><p id="c17f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里我们可以开始寻找彼此最相似的用户。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="34a2" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">在约会简档中寻找相关性</h1><p id="94ea" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">一旦我们创建了一个填充了二进制值和数字的数据框架，我们就可以开始寻找年代测定曲线之间的相关性。每个约会档案都有一个独特的索引号，我们可以从中借鉴。</p><p id="e785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一开始，我们总共有6600份约会资料。在聚类并将数据帧缩小到所选的聚类之后，年代测定概况的数量可以在100到1000的范围内。在整个过程中，约会档案的指数保持不变。现在，我们可以使用每个索引号来引用每个约会档案。</p><p id="7ffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个索引号代表一个独特的约会档案，我们可以找到相似或相关的用户每个档案。这是通过运行一行代码来创建一个相关矩阵来实现的。</p><pre class="kj kk kl km gt oz oy pa pb aw pc bi"><span id="b9d0" class="oj nk it oy b gy pd pe l pf pg">corr_group = group.T.corr()</span></pre><p id="4156" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的第一件事是<em class="mh">转置</em>数据帧，以便切换列和索引。这样做是为了使我们使用的关联方法适用于索引而不是列。一旦我们转置了DF，我们就可以应用<code class="fe ov ow ox oy b">.corr()</code>方法，这将在指数之间创建一个相关矩阵。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/d00af7288d83e7dceb68ccee55c7e34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZU4KLlaQPNNR4dv8eDgZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">指数的相关矩阵(测年曲线)</p></figure><p id="f555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该相关矩阵包含使用<a class="ae ky" href="https://statistics.laerd.com/statistical-guides/pearson-correlation-coefficient-statistical-guide.php" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="mh">皮尔逊相关法</em> </strong> </a>计算的数值。接近1的值彼此正相关，这就是为什么你会看到1.0000的指数与他们自己的指数相关。</p><p id="f4f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里，您可以看到我们在使用这个关联矩阵寻找相似用户时的发展方向。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="041f" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">寻找十大相似的约会档案</h1><p id="3d5f" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">现在我们有了一个包含每个索引/日期剖面的相关分数的相关矩阵，我们可以开始根据它们的相似性对剖面进行排序。</p><pre class="kj kk kl km gt oz oy pa pb aw pc bi"><span id="fc04" class="oj nk it oy b gy pd pe l pf pg">random_user = random.choice(corr_group.index)</span><span id="b3be" class="oj nk it oy b gy ph pe l pf pg">print("Top 10 most similar users to User #", random_user, '\n')</span><span id="d2bc" class="oj nk it oy b gy ph pe l pf pg">top_10_sim = corr_group[[random_user]].sort_values(by=<br/>             [random_user],axis=0, ascending=False)[1:11]</span><span id="027d" class="oj nk it oy b gy ph pe l pf pg">print(top_10_sim)</span><span id="b287" class="oj nk it oy b gy ph pe l pf pg">print("\nThe most similar user to User #", random_user, "is User #", top_10_sim.index[0])</span></pre><p id="6ba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面代码块中的第一行从关联矩阵中选择一个随机的约会配置文件或用户。从这里，我们可以选择包含所选用户的列，并对该列中的用户进行排序，这样它将只返回前10个最相关的用户(不包括所选索引本身)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/f64e745ccd47dea8fb57c7203c0fa734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*AKuuOIksgOoGjyI7rlOPtA.png"/></div></figure><p id="2bbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功！—当我们运行上面的代码时，我们会得到一个用户列表，按照他们各自的相关性分数排序。我们可以看到与我们随机选择的用户最相似的前10名用户。这可以用另一个集群组和另一个配置文件或用户再次运行。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="f211" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">结束语</h1><p id="cc85" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">如果这是一个约会应用程序，用户将能够看到与自己最相似的前10名用户。这将有望减少刷卡时间，减少挫折感，并增加我们假设的约会应用程序用户之间的匹配。假设的约会应用程序的算法将实现无监督的机器学习聚类，以创建约会档案组。在这些组中，算法将根据它们的相关分数对简档进行分类。最后，它将能够向用户展示与自己最相似的约会资料。</p><p id="c3b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">潜在的下一步将是尝试将新数据纳入我们的机器学习匹配器。也许让一个新用户输入他们自己的自定义数据，看看他们会如何匹配这些虚假的约会资料。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="b5cc" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">资源</h1><div class="ml mm gp gr mn mo"><a href="https://github.com/marcosan93/AI-Matchmaker" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd iu gy z fp mt fr fs mu fu fw is bi translated">Marcos an 93/人工智能媒婆</h2><div class="pl l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">利用人工智能和机器学习来匹配约会档案与另一个原始概念和想法数据收集…</h3></div><div class="mv l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">github.com</p></div></div><div class="mw l"><div class="pm l my mz na mw nb ks mo"/></div></div></a></div><div class="ml mm gp gr mn mo"><a rel="noopener follow" target="_blank" href="/dating-algorithms-using-machine-learning-and-ai-814b68ecd75e"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd iu gy z fp mt fr fs mu fu fw is bi translated">我用机器学习和人工智能做了一个约会算法</h2><div class="mv l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">towardsdatascience.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb ks mo"/></div></div></a></div></div></div>    
</body>
</html>