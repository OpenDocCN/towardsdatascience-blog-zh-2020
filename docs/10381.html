<html>
<head>
<title>An Introduction to Genetic Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遗传算法导论</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-introduction-to-genetic-algorithms-c07a81032547?source=collection_archive---------31-----------------------#2020-07-21">https://towardsdatascience.com/an-introduction-to-genetic-algorithms-c07a81032547?source=collection_archive---------31-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5ec1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">包括 Python 中的一个例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cd88b73f2a65c0840f8d1d900eccd80f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fnueYPFPXdP4Bg2Y"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Johannes Plenio 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d6ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遗传算法(GAs)是进化计算(EC)的一部分，进化计算是人工智能(AI)的一个快速发展的领域。它受到基于查尔斯·达尔文自然选择理论的生物进化过程的启发，在这一过程中，更健康的个体更有可能将他们的基因传递给下一代。我们作为人类，也是数千年进化的结果。</p><h1 id="2044" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">遗传算法的历史</h1><p id="bfd2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">遗传算法是由霍兰德和他的合作者在 20 世纪 60 年代和 70 年代开发的。</p><ul class=""><li id="edd9" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">早在 1962 年，霍兰德在适应性系统方面的工作就为后来的发展奠定了基础。</li><li id="d903" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">到了 1975 年，出版了《自然和人工系统中的<em class="ng">适应</em>》一书，由霍兰德和他的学生及同事合作完成。</li></ul><p id="27d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遗传算法在 20 世纪 80 年代后期开始流行，被广泛应用于用其他技术不容易解决的问题。</p><p id="3ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1992 年，John Koza 已经使用遗传算法来进化程序以执行某些任务。他称自己的方法为“<em class="ng">遗传编程</em>”(GP)。</p><h1 id="b7be" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">现实世界中的进化是什么？</h1><p id="2bff" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">几千年来，人类一直扮演着基因选择的角色，通过培育具有所需特征的后代。我们所有的驯养动物和粮食作物都是结果。下面让我们回顾一下自然界中的基因术语。</p><ul class=""><li id="d726" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">生物的每个细胞都包含<strong class="lb iu">染色体</strong>——DNA 链<em class="ng">。</em></li><li id="04e7" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">每条染色体包含一组<strong class="lb iu">基因</strong>——DNA 块</li><li id="f03c" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">每个基因决定了生物体的某些方面(比如眼睛的颜色)</li><li id="58ff" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">一组基因有时被称为<strong class="lb iu">基因型</strong></li><li id="fc2c" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">一些方面的集合(比如眼睛的颜色)有时被称为<strong class="lb iu">表现型</strong></li><li id="8a24" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">生殖(<strong class="lb iu">交叉</strong>)包括来自父母的基因重组，然后是复制中的少量<strong class="lb iu">突变</strong>(错误)</li><li id="d920" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">一个有机体的适应度是指它在死亡前能繁殖多少</li><li id="0e4f" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">基于“适者生存”的进化</li></ul><h1 id="d4e8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">计算机科学中的遗传算法是什么？</h1><p id="7cbb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">遗传算法被归类为全局搜索试探法。遗传算法是一种在计算中使用的搜索技术，用于找到优化和搜索问题的真实或近似解决方案。它使用受生物进化启发的技术，如遗传、突变、选择和交叉。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/bef51d9965409471a19cd98d4cecdad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*ie_uxsUrKyV2fwAPncoK1g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">遗传算法的五个步骤</p></figure><p id="67a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看看遗传算法背后的基本过程如下。</p><p id="1ad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">初始化群体:</strong>遗传算法从初始化候选解的<strong class="lb iu">群体</strong>开始。这通常是随机进行的，以提供整个搜索空间的均匀覆盖。一个候选的解决方案是 C <strong class="lb iu">染色体</strong>，其特征在于一组被称为<strong class="lb iu">基因</strong>的参数。</p><p id="f503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">评估:</strong>接下来，通过给群体中的每个个体分配一个适应值来评估群体。在这一阶段，我们通常希望记录当前最适合的解决方案，以及群体的平均适合度。</p><p id="480d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在评估之后，该算法根据设置的终止条件决定是否应该终止搜索。这通常是因为算法已经达到了固定的世代数或者已经找到了合适的解决方案。</p><p id="8d0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当最终满足终止条件时，算法将跳出循环，通常将其最终搜索结果返回给用户。</p><p id="17ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">选择:i </strong>如果不满足终止条件，群体经历选择阶段，在该阶段中，基于个体的适应度分数从群体中选择个体，适应度越高，个体被选择的机会越大。</p><p id="a02d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两对被选中的个体称为<strong class="lb iu">父母。</strong></p><p id="66f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">交叉:</strong>下一步是对被选中的个体进行交叉和变异。这个阶段是为下一代创造新个体的阶段。</p><p id="cc74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">突变:</strong>此时，新群体回到评估步骤，该过程再次开始。我们称这个循环的每个周期为一代。</p><h1 id="4a7d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用 Python 语言实现遗传算法的实例</h1><p id="f007" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，让我们看看如何使用遗传算法破解密码。想象一下，一个朋友让你解决下面这个挑战:“<em class="ng">你必须在我的电脑里找到我设置为密码的三个字母的单词</em>”。</p><p id="adef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，我们将从长度为 3 的密码开始，密码中的每个数字都是一个字母。密码的一个例子是:<code class="fe ni nj nk nl b">nkA</code>。我们将从随机生成的初始字母序列开始，然后一次随机更改一个字母，直到单词是“Anh”。</p><p id="a287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，我们猜测任何由三个字母组成的随机生成的单词，如“<code class="fe ni nj nk nl b">Ink, aNj, cDh</code>”。单词<code class="fe ni nj nk nl b">Ink</code>和<code class="fe ni nj nk nl b">cDh</code>与密码<code class="fe ni nj nk nl b">Anh</code>只有一个相同的字母。我们说他们的得分是 1。单词<code class="fe ni nj nk nl b">aNj</code>的分数为 0，因为它没有任何与密码匹配的字母。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/26aafe7608dc7b11ffb8503ade5fc7e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vuM0nRX2mB9gXByLPUv_Og.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基因、染色体和种群</p></figure><p id="8e00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们还没有找到解决办法，我们可以通过梳理一些我们已经有的词来产生新一代的词。比如他们是“<code class="fe ni nj nk nl b">Inh, aDj</code>”。从这两个新词来看，<code class="fe ni nj nk nl b">Inh</code>这个词得分为 2，非常接近密码。我们说第二代比第一代更好，因为它更接近解决方案。</p><p id="26f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以形成第三代，其中单词<code class="fe ni nj nk nl b">Inh</code>可以产生单词<code class="fe ni nj nk nl b">Anh</code>，其中<code class="fe ni nj nk nl b">I</code>被随机突变为<code class="fe ni nj nk nl b">A</code>。这个例子很容易理解遗传算法。</p><h2 id="c271" class="nn lw it bd lx no np dn mb nq nr dp mf li ns nt mh lm nu nv mj lq nw nx ml ny bi translated">这个算法的伪代码</h2><pre class="kj kk kl km gt nz nl oa ob aw oc bi"><span id="5a43" class="nn lw it nl b gy od oe l of og">_letters = [a..zA..Z]<br/>target = "Anh"<br/>guess = get 3 random letters from _letters while guess != target:<br/>     index = get random value from [0..length of target] <br/>     guess[index] = get 1 random letter from _letters</span></pre><h2 id="d5a4" class="nn lw it bd lx no np dn mb nq nr dp mf li ns nt mh lm nu nv mj lq nw nx ml ny bi translated">Python 中的示例实现</h2><p id="c91c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，我们将用 Python 语言实现这个例子。密码中的每个数字将被视为一个<code class="fe ni nj nk nl b">Gene</code>。我们需要一组基因来建立猜测。在这个例子中，这是一组通用的字母。</p><pre class="kj kk kl km gt nz nl oa ob aw oc bi"><span id="9950" class="nn lw it nl b gy od oe l of og">geneSet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></pre><p id="4be2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还需要一个目标密码来猜测。</p><pre class="kj kk kl km gt nz nl oa ob aw oc bi"><span id="10b6" class="nn lw it nl b gy od oe l of og">target = "Anh"</span></pre><p id="c7e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，该算法需要一种从基因集中生成随机字符串的方法。</p><pre class="kj kk kl km gt nz nl oa ob aw oc bi"><span id="27d2" class="nn lw it nl b gy od oe l of og">import random</span><span id="fee5" class="nn lw it nl b gy oh oe l of og">def generate_parent(length):<br/>    genes = []<br/>    while len(genes) &lt; length:<br/>        sampleSize = min(length - len(genes), len(geneSet))<br/>        genes.extend(random.sample(geneSet, sampleSize))<br/>    return ''.join(genes)</span></pre><p id="23c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遗传算法提供的适应值是引擎得到的唯一的<strong class="lb iu"> </strong>反馈来引导它找到解决方案。在这个项目中，适合度值是猜测中与密码相同位置的字母相匹配的字母总数。</p><pre class="kj kk kl km gt nz nl oa ob aw oc bi"><span id="cf64" class="nn lw it nl b gy od oe l of og">def get_fitness(guess):<br/>    return sum(1 for expected, actual in zip(target, guess)<br/>               if expected == actual)</span></pre><p id="f2d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，引擎需要一种方法，通过改变当前的猜测来产生新的猜测。</p><pre class="kj kk kl km gt nz nl oa ob aw oc bi"><span id="0b23" class="nn lw it nl b gy od oe l of og">def mutate(parent):<br/>    index = random.randrange(0, len(parent))<br/>    childGenes = list(parent)<br/>    newGene, alternate = random.sample(geneSet, 2)<br/>    childGenes[index] = alternate \<br/>        if newGene == childGenes[index] \<br/>        else newGene<br/>    return ''.join(childGenes)</span></pre><p id="044f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要显示功能来显示信息。正常情况下，显示功能还会输出健身值和经过的时间。</p><pre class="kj kk kl km gt nz nl oa ob aw oc bi"><span id="f0a8" class="nn lw it nl b gy od oe l of og">import datetime</span><span id="fed2" class="nn lw it nl b gy oh oe l of og">def display(guess):<br/>    timeDiff = datetime.datetime.now() - startTime<br/>    fitness = get_fitness(guess)<br/>    print("{0}\t{1}\t{2}".format(guess, fitness, str(timeDiff)))</span></pre><p id="68b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将尝试使用上面的函数运行这个解决方案，如下所示。</p><pre class="kj kk kl km gt nz nl oa ob aw oc bi"><span id="82e5" class="nn lw it nl b gy od oe l of og">random.seed()<br/>geneSet = " abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"<br/>target = "Anh"<br/>startTime = datetime.datetime.now()<br/>bestParent = generate_parent(len(target))<br/>bestFitness = get_fitness(bestParent)<br/>display(bestParent)<br/>while True:<br/>    child = mutate(bestParent)<br/>    childFitness = get_fitness(child)</span><span id="5254" class="nn lw it nl b gy oh oe l of og">    if bestFitness &gt;= childFitness:<br/>        continue<br/>    display(child)<br/>    if childFitness &gt;= len(bestParent):<br/>        break<br/>    bestFitness = childFitness<br/>    bestParent = child</span></pre><p id="ef14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码，我们会看到下面的输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/e3285970ad84b9c244c98457c75fbe28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u58aMaQZKEmyu335hY98rg.png"/></div></div></figure><p id="dbd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遗传算法很容易理解。对吗？</p><h1 id="f167" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><p id="f8ad" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">[1] <a class="ae ky" href="https://dl.acm.org/doi/10.1145/321127.321128" rel="noopener ugc nofollow" target="_blank">自适应系统的逻辑理论概要</a></p><p id="b965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2] <a class="ae ky" href="https://mitpress.mit.edu/books/adaptation-natural-and-artificial-systems" rel="noopener ugc nofollow" target="_blank">自然和人工系统中的适应</a></p><p id="ab82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3] <a class="ae ky" href="https://mitpress.mit.edu/books/genetic-programming" rel="noopener ugc nofollow" target="_blank">遗传编程:通过自然选择的方式对计算机进行编程</a></p></div></div>    
</body>
</html>