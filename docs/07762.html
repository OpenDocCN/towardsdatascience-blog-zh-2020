<html>
<head>
<title>Extensive EDA and Prediction on Customers Subscription(on an Application) Analysis.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广泛的EDA和对客户订阅(应用程序)的预测分析。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/extensive-eda-and-prediction-on-customers-subscription-on-an-application-analysis-2d7b0daff6aa?source=collection_archive---------70-----------------------#2020-06-09">https://towardsdatascience.com/extensive-eda-and-prediction-on-customers-subscription-on-an-application-analysis-2d7b0daff6aa?source=collection_archive---------70-----------------------#2020-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="63ae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">本文解释了应用于预测客户是否订阅应用程序的高级功能的各种数据科学方面。</h2></div><p id="a376" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个数据集，其中包含有关用户的详细信息，并显示特定用户是否注册了该应用程序的高级版本。我们将使用这个数据集来确定数据集中隐藏的各种见解，并使用这个数据集来建立一些机器学习模型。</p><p id="2fdd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从导入数据集开始这个过程。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0f36" class="lk ll iq lg b gy lm ln l lo lp">import pandas as pd<br/>df=pd.read_csv("customer application subscription.csv")<br/>df.head()</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lq"><img src="../Images/a8781348e213ad480a9c90bc78ad3c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FHjCZf9yF5jhDcNgaL3Mg.png"/></div></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">数据集的前五条记录</p></figure><p id="c487" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在加载数据集之后，我们现在要写一些行来了解数据集的总体情况。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1bd1" class="lk ll iq lg b gy lm ln l lo lp">print("\t\t\tDataset Statistics")<br/>print("Number of variables:-",len(df.columns))<br/>print("Number of observations:-",df.shape[0])<br/>print("Missing Values:-",df.isna().sum().sum())<br/>print("Missing Values %:-",round(df.isna().sum().sum()/df.shape[0]*100,3))<br/>print("Duplicate rows:-",df[df.duplicated(keep="first")].shape[0])<br/>print("Duplicate rows%:-",round(df[df.duplicated(keep="first")].shape[0]/df.shape[0]*100,3))<br/>print("Variable types:-")<br/>a=pd.crosstab(df.dtypes,columns="Count")<br/>for i in pd.crosstab(df.dtypes,columns="Count").index:<br/>    print("\t",str(i).split()[0],a.loc[i][0])</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/283c7ffd4a4ac618c906d12c58a011c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*h8Fh7PMnez5cjsRPHQUz6Q.png"/></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">关于数据集的信息。</p></figure><p id="21a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们查看数据集，我们会发现缺失值只出现在<strong class="kh ir">登记日期</strong>列<strong class="kh ir"> </strong>的<strong class="kh ir">中。</strong>因为在50000个条目中只有0.03%的重复行，所以我们不会删除它们，因为这不是必需的。</p><p id="be18" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们将把<strong class="kh ir"> first_open </strong>列转换成datetime格式，因为它是object类型。<strong class="kh ir"> first_open </strong>列指定首次登录app的日期和时间。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="51cf" class="lk ll iq lg b gy lm ln l lo lp">df["first_open"]=pd.to_datetime(df["first_open"])<br/>df['first_open_date'] = [d.date() for d in df['first_open']]<br/>df['first_open_time'] = [d.time() for d in df['first_open']]<br/>df=df.drop("first_open",axis=1)</span></pre><p id="5985" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们已经从<strong class="kh ir"> first_open </strong>列中获取了日期和时间，所以我们可以看到在日期内首次使用app的趋势。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="09e8" class="lk ll iq lg b gy lm ln l lo lp">a=pd.crosstab(index=df["first_open_date"],columns="count")<br/>from datetime import datetime, timedelta<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>sns.set_style('darkgrid')<br/>import numpy as np<br/>%matplotlib inline<br/>x =  np.arange(datetime(2012,11,23), datetime(2013,7,10), timedelta(days=1)).astype(datetime)<br/>y = a["count"]<br/>y_mean = [a["count"].mean()]*len(x)<br/>fig,ax = plt.subplots(figsize=(17,12))<br/>ax.set_xlabel("Month",fontsize=20)<br/>ax.set_ylabel("Count",fontsize=20)<br/>ax.tick_params(labelsize=15, labelrotation = 20, color ="k")<br/>data_line = ax.plot(x,y, label='Data')<br/>mean_line = ax.plot(x,y_mean, label='Mean', linestyle='--')<br/>legend = ax.legend(loc='upper right')<br/>plt.show()</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi md"><img src="../Images/3ed83fcaa056df28dd3fd74e632d9d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPysDR17aUVBeMYSRCsqsw.png"/></div></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">首次使用该应用程序的趋势</p></figure><p id="b684" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们从图表中看到的，应用程序的使用波动很大。这可以得出结论，原因可能直接涉及到应用程序，如应用程序的推广等。而不是外部因素，因为它不会有太大的影响。</p><p id="b5d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们将从<strong class="kh ir"> dayofweek </strong>专栏中看到一些见解。我们不会关注<strong class="kh ir"> first_open_time </strong>，因为从那里找不到任何见解。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ec9d" class="lk ll iq lg b gy lm ln l lo lp">import seaborn as sns<br/>sns.set_style('darkgrid')<br/>ct=pd.crosstab(df["dayofweek"],columns="Count")<br/>stacked = ct.stack().reset_index().rename(columns={0:'value'})<br/>g=sns.barplot(x=stacked.dayofweek, y=stacked.value)<br/>plt.title("Count of On which day user logon")</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/4bc72ffb487f70b4aaf169851bb04fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*q_B-076bRGll4vlxltEMbg.png"/></div></figure><p id="0494" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，在dayofweek中，唯一值解释了以下内容:</p><ul class=""><li id="40a7" class="mf mg iq kh b ki kj kl km ko mh ks mi kw mj la mk ml mm mn bi translated">1:星期一</li><li id="9c49" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">2:星期二</li><li id="eebf" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">3:星期三</li><li id="c434" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">4:周四</li><li id="da76" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">5:星期五</li><li id="5ca7" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">6:星期六</li><li id="ce5f" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">0:周日</li></ul><p id="5198" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该图解释了应用程序的最小使用量在星期二，最大使用量在星期四。</p><p id="f70f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们分析一下<strong class="kh ir">小时</strong>列</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0cd8" class="lk ll iq lg b gy lm ln l lo lp">ct=pd.crosstab(df["hour"],columns="Count")<br/>plt.figure(figsize=(12,12))<br/>plt.tick_params(labelsize=15, labelrotation = 90, color ="k")<br/>stacked = ct.stack().reset_index().rename(columns={0:'value'})<br/>g=sns.barplot(x=stacked.hour, y=stacked.value)</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mt"><img src="../Images/09e7c5be403251f18c76b4004e9f39a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hr4Gb7wBvyiY1IyHusz4BQ.png"/></div></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">超过24小时的应用程序使用情况</p></figure><p id="61b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在这张图表中看到的，用户在上午9点左右使用应用较少，而在下午3点左右使用最多。</p><p id="a31c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再来看<strong class="kh ir">年龄</strong>一栏。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6dc4" class="lk ll iq lg b gy lm ln l lo lp">df["age"].describe()</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/a35892873c976b8f69947e98c4929f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*zlwEmqPJPKI2pQ7NwK5UUg.png"/></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">基本概念<strong class="bd mv">年龄</strong>栏目</p></figure><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="adf5" class="lk ll iq lg b gy lm ln l lo lp">plt.hist(df["age"],edgecolor="black",bins=7)<br/>plt.show()</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/06f98ce6367a4b0d4a738d084e189ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*GLKR34QnPc2T3eXAdlhMnw.png"/></div><p class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mv">年龄直方图</strong>列</p></figure><p id="a058" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这表明75%的用户年龄在37岁以下。这意味着制造商和公司应该迎合需求，把37岁以下的人作为目标受众。</p><p id="7914" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他列有:- <strong class="kh ir"> screen_list </strong>:描述客户看到的屏幕，<strong class="kh ir"> numscreens </strong>:用户观看的屏幕数量，<strong class="kh ir"> minigame </strong>:如果客户玩了应用程序中包含的迷你游戏，则1 else 0，<strong class="kh ir"> used_premium_feature </strong>:如果用户使用了应用程序的高级功能，则1 else 0，<strong class="kh ir"> enrolled </strong>:如果用户购买了高级功能，则1 else 0，<strong class="kh ir"/></p><p id="d307" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在将分析上面的列</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4c5c" class="lk ll iq lg b gy lm ln l lo lp">groupedvalues=df.groupby('dayofweek')["numscreens","minigame","used_premium_feature","enrolled","liked"].sum().reset_index()<br/>attributes=list(groupedvalues.columns)[1:]<br/>att=attributes[1:]<br/>for i in att:<br/>    print(i)<br/>    sns.countplot(df[i])<br/>    plt.show()</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mx"><img src="../Images/5e0c6bc1b4bc620635308302af597691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftgZ_SEH3jD0QZ04ir2YdA.png"/></div></div></figure><p id="0299" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于<strong class="kh ir"> dayofweek </strong>列，让我们看看其他列的行为:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0100" class="lk ll iq lg b gy lm ln l lo lp">for i in attributes:<br/>    print(i)<br/>    sns.barplot(x="dayofweek",y=i,data=groupedvalues)<br/>    plt.show()</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi my"><img src="../Images/736fbaa541274669ba7d59a2310b5f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yE0MhPsvZAPsiFHSM9vyFA.png"/></div></div><p class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mv">星期几</strong>对比其他栏目</p></figure><p id="e69e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于<strong class="kh ir">小时</strong>列，让我们看看其他列的行为</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8112" class="lk ll iq lg b gy lm ln l lo lp">for i in attributes:<br/>    print(i)<br/>    plt.figure(figsize=(12,12))<br/>    plt.tick_params(labelsize=15, labelrotation = 90, color ="k")<br/>    sns.barplot(x="hour",y=i,data=groupedvalues2)<br/>    plt.show()</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mz"><img src="../Images/5d0b10b24eb65172390967e866c6a35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mBxIyn9ZyZzvqwiGb6Q7wg.png"/></div></div></figure><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi na"><img src="../Images/4b1467f32fd04de6933a34e29849e391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I3mQPMZcJjW0LxqmNYjzTw.png"/></div></div><p class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mv">小时</strong> vs其他栏目</p></figure><p id="47a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这些图表，我们可以肯定地分析用户在白天的不活动性，因为大多数用户不得不执行其他任务，而不是使用这个应用程序。这可以进一步意味着可以在应用程序上执行的所有促销活动可以在下午完成，因为大多数用户在这个时间是活跃的。</p><p id="324f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们根据年龄来分析应用程序的使用情况。由于在50000条记录中有许多独特的年龄，我们将使用基于“年龄组”的可视化其他列的方法。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d2c8" class="lk ll iq lg b gy lm ln l lo lp">groupedvalues3=df.groupby(pd.cut(df['age'], np.arange(15, 106, 10)))["numscreens","minigame","used_premium_feature","enrolled","liked"].sum().reset_index()<br/>for i in attributes:<br/>    print(i)<br/>    plt.figure(figsize=(12,12))<br/>    plt.tick_params(labelrotation = 45)<br/>    sns.barplot(x="age",y=i,data=groupedvalues3)<br/>    plt.show()</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nb"><img src="../Images/a6baf3afe7e429e7175bdac61ad56f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zNTfT8vb1uSgzmawB6bMpg.png"/></div></div></figure><figure class="lb lc ld le gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nc"><img src="../Images/e21ad3a1aa000fbd671a1e93a6a0189a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lAEi46IP8yqtP3ysyKRn3A.png"/></div></div><p class="ly lz gj gh gi ma mb bd b be z dk translated"><strong class="bd mv">年龄组</strong> vs其他栏目</p></figure><p id="3e34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这些图表中，我们可以分析出，尽管75%的观众年龄在37岁以下，但最活跃的年龄组在15-35岁之间。</p><p id="0608" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们执行了EDA，我们将继续进行特性选择。</p><p id="1d39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">寻找各种特征之间的相关性:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="079e" class="lk ll iq lg b gy lm ln l lo lp">for i in df.index:<br/>    x = df.at[i , 'hour']<br/>    y = x[0:3]<br/>    df.at[i , 'hour'] = y<br/>df["hour"]=df["hour"].astype('int64')<br/>import seaborn as sns<br/>df2 = df.drop(['user',  'enrolled_date'], axis = 1)<br/>sns.heatmap(df2.corr(), annot = True)</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/cffd7502618165b7a652e663a43abb53.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*Tkke4YlDCpYLB73nJ7JVDQ.png"/></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">各种特征之间的相关性</p></figure><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="930f" class="lk ll iq lg b gy lm ln l lo lp">df3 = df2.drop(['enrolled'], axis = 1)<br/>plt.figure(figsize=(8,8))<br/>sns.barplot(x=df3.corrwith(df2.enrolled).index,y=df3.corrwith(df2.enrolled))<br/>plt.tick_params(labelsize=15, labelrotation = 45)</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/295289c06da95c989b742ff07296bb55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*YGxN8bjALz-a3UC25e-zEg.png"/></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">关于<strong class="bd mv">登记的</strong>列的各种特征之间的相关性</p></figure><p id="b242" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上图显示小时、年龄、迷你游戏(负相关)、numscreens、迷你游戏(正相关)可以考虑建模。</p><p id="2018" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在所有这些分析之后，我们将返回我们的数据框架，以便找到用户注册应用程序所花费的总时间。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="28f1" class="lk ll iq lg b gy lm ln l lo lp">df=pd.read_csv('data.csv')<br/>df["first_open"]=pd.to_datetime(df["first_open"])<br/>df["enrolled_date"]=pd.to_datetime(df["enrolled_date"])<br/>df['time_to_enrolled']=(df.enrolled_date - df.first_open).astype('timedelta64[h]')<br/>import matplotlib.pyplot as plt<br/>plt.figure(figsize=(6,6))<br/>plt.hist(df['time_to_enrolled'].dropna(), range = (0,100))<br/>plt.show()</span></pre><figure class="lb lc ld le gt lr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/3f031a975853b015529d952159c8ddf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*t4xGs9we5EdI4D_ou5e8jg.png"/></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">注册高级功能所需时间的直观表示。</p></figure><p id="3c28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在此直方图中看到的，50小时前的详细信息是好的，因为其他信息是异常值，会影响模型，因此我们认为客户已注册为0。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b79f" class="lk ll iq lg b gy lm ln l lo lp">df.loc[df.time_to_enrolled &gt; 50, 'enrolled'] = 0</span></pre><p id="181c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">屏幕列表</strong>可能是一个非常有用的列，因为它可以用于建模目的。但是这个列是一个字符串。因此，为了使用它，我们需要对这个列进行编码，这将花费很多时间，因为它必须处理大约50000个字符串。</p><p id="86be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在继续之前，我们需要另一个包，即“mlxtend”包。为了安装它，请在cmd/Anaconda提示符下使用以下命令行:-</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="79d9" class="lk ll iq lg b gy lm ln l lo lp">pip install mlxtend</span></pre><p id="c3db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这之后写下下面几行:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8436" class="lk ll iq lg b gy lm ln l lo lp">for i in range(len(df["screen_list"])):<br/>    df["screen_list"][i]=df["screen_list"][i].split(',')<br/>from mlxtend.preprocessing import TransactionEncoder <br/>transactionEncoder = TransactionEncoder()<br/>txnn=transactionEncoder.fit(df["screen_list"]).transform(df["screen_list"])<br/>dfnn=pd.DataFrame(txnn,columns=transactionEncoder.columns_)<br/>df=df.join(dfnn, how="outer")<br/>from sklearn.preprocessing import LabelEncoder<br/>le=LabelEncoder()<br/>l=list(transactionEncoder.columns_)<br/>for i in l:<br/>    try:<br/>        df[i]=le.fit_transform(df[i])<br/>    except:<br/>        pass</span></pre><p id="aa00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由此，我们将转换数据集，并仅选择模型所需的那些特征，如上所述。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="56fb" class="lk ll iq lg b gy lm ln l lo lp">a1=df[["hour","age","numscreens","used_premium_feature","minigame"]]<br/>for i in df.index:<br/>    x = a1.at[i , 'hour']<br/>    y = x[0:3]<br/>    a1.at[i , 'hour'] = y<br/>a1["hour"]=a1["hour"].astype('int64')<br/>a2=df[transactionEncoder.columns_]<br/>a1=a1.join(a2, how="outer")<br/>X=a1<br/>Y=df["enrolled"]<br/>from sklearn.model_selection import train_test_split<br/>xtrain,xtest,ytrain,ytest=train_test_split(X,Y,test_size=0.3,random_state=42)</span></pre><p id="662b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们的数据要通过模型。让我们尝试通过各种ML模型来传递我们的模型。</p><ol class=""><li id="4b42" class="mf mg iq kh b ki kj kl km ko mh ks mi kw mj la nf ml mm mn bi translated">逻辑回归:</li></ol><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c7e7" class="lk ll iq lg b gy lm ln l lo lp">from sklearn.linear_model import LogisticRegression<br/>le=LogisticRegression(random_state = 42, penalty = 'l1')<br/>le.fit(xtrain,ytrain)<br/>le.score(xtest,ytest)</span></pre><p id="a9b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行代码后，我们得到以下分数:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5c81" class="lk ll iq lg b gy lm ln l lo lp">0.868</span></pre><p id="4c12" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从这个数据集中得到了一个令人印象深刻的分数。让我们从训练集中检查是否存在过度拟合的情况。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e6df" class="lk ll iq lg b gy lm ln l lo lp">le.score(xtrain,ytrain)</span></pre><p id="7888" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行代码后，我们得到以下分数:-</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="23dd" class="lk ll iq lg b gy lm ln l lo lp">0.8619428571428571</span></pre><p id="0e29" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">似乎不存在过度拟合的情况</p><p id="85db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.决策树分类器<br/>我们将使用GridSearchCV进行超参数调优</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="17e3" class="lk ll iq lg b gy lm ln l lo lp">from sklearn.tree import DecisionTreeClassifier<br/>from sklearn import metrics<br/>from sklearn.model_selection import GridSearchCV<br/>tuned_parameters = [{'criterion': ['gini','entropy'],<br/>'max_depth': range(2,10)}]<br/>clf_tree = DecisionTreeClassifier()<br/>clf = GridSearchCV(clf_tree,<br/>tuned_parameters,<br/>cv=10,<br/>scoring='roc_auc')<br/>clf.fit(xtrain, ytrain )</span></pre><p id="fb3b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要查找参数:-</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="eae5" class="lk ll iq lg b gy lm ln l lo lp">clf.best_params_</span></pre><p id="c09b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们得到的。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9732" class="lk ll iq lg b gy lm ln l lo lp">{'criterion': 'entropy', 'max_depth': 7}</span></pre><p id="ce76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们会用它来找到分数。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1fe0" class="lk ll iq lg b gy lm ln l lo lp">clf_tree2 = DecisionTreeClassifier(criterion = 'entropy',<br/>max_depth = 7 )<br/>clf_tree2.fit( xtrain, ytrain )<br/>tree_predict2 = clf_tree2.predict( xtest )<br/>metrics.roc_auc_score( ytest, tree_predict2 )<br/></span></pre><p id="9e77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">收到以下分数:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5d9d" class="lk ll iq lg b gy lm ln l lo lp">0.8662688484194627</span></pre><p id="213c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们也可以使用其他ML模型。这是我的第一篇文章，非常感谢您的宝贵反馈。谢谢，祝编码愉快！</p><p id="85d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">笔记本链接:-<a class="ae ng" href="https://github.com/luv8860/Projects/blob/master/Customer%20application%20subscription.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/luv 8860/Projects/blob/master/Customer % 20 application % 20 subscription . ipynb</a></p><p id="6203" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据集链接:-</p><p id="171c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae ng" href="https://github.com/luv8860/Projects/blob/master/customer%20application%20subscription.csv" rel="noopener ugc nofollow" target="_blank">https://github . com/luv 8860/Projects/blob/master/customer % 20 application % 20 subscription . CSV</a></p></div></div>    
</body>
</html>