<html>
<head>
<title>Creating High Resolution Satellite Images with Mapbox and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Mapbox 和 Python 制作高分辨率卫星影像</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-high-resolution-satellite-images-with-mapbox-and-python-750b3ac83dd7?source=collection_archive---------17-----------------------#2020-05-27">https://towardsdatascience.com/creating-high-resolution-satellite-images-with-mapbox-and-python-750b3ac83dd7?source=collection_archive---------17-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f906" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">超高分辨率卫星和高程图像</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6e33e1922098ecae798921b79f0aefe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BzaxmZjEVpTFtKJeex_ayg.jpeg"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a3ffaa97f95dbb6b2fa5b7b76872c219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v06zEu4FhBq8ezOSk5jIUw.jpeg"/></div></div></figure><p id="86ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于我的一些个人项目，我想获得地球上特定点的超高分辨率卫星和高程图像。当我试图用谷歌搜索一些现有数据时，没有足够灵活的东西。我最终偶然发现了 Mapbox API，它允许我使用 URL 请求来获取任何位置和缩放级别的图像。除此之外，它还可以选择返回编码为 PNG 图像的高分辨率高程数据(参见上面的第二幅图像)。</p><h1 id="071c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">获取地图框 API 密钥</h1><p id="e327" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">第一步是访问<a class="ae mn" href="https://docs.mapbox.com/api/" rel="noopener ugc nofollow" target="_blank">https://docs.mapbox.com/api/</a>注册并获得 API 密钥。这里我就不赘述了，因为这非常简单，但我们想要的只是看起来像这样的密钥:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/42fcf12afc57123cab0b34ce79a57416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKC_oelsKlAXbQqrlVnE3A.png"/></div></div></figure><p id="a998" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们有了密钥，它将允许我们解析 Mapbox API，并获得一些漂亮的图像 tilesets 回来！请记住，有很多免费的访问，所以您不需要担心 API 的限制，除非您将它部署给更广泛的受众。</p><h2 id="3325" class="mp lr it bd ls mq mr dn lw ms mt dp ma ld mu mv mc lh mw mx me ll my mz mg na bi translated">关于 Tilesets 的一个注记</h2><p id="3405" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我遇到的最大问题之一是理解 tilesets。基本上，我假设我可以在 API 中使用纬度/经度值，但是全局成像的工作方式是每个缩放级别有一组“tilesets”。缩放级别是从 0 到 15，其中 0 表示整个世界的图片，15 表示您可以看到自己的房子。瓦片集被索引为矩阵(x/y ),该矩阵基本上表示切片的地球图像。在缩放 0 时，在 x=y=1 时只有一个图块，因为它只是一个大图像。想象一下，我们放大到级别 1，实际上需要 4 张图片来覆盖地图。这意味着我们有四种组合(0，0)，(0，1)，(1，0)，(1，1)。正如你可以想象的那样，变焦越深，需要的瓷砖就越多。</p><p id="15d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将向您展示为给定的 lat/lng 组合获得一组瓷砖所需的代码，因此您不必担心它！经典的 python 有一个包来包所有的东西。</p><h1 id="bcfa" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">安装 Python 包和文件夹设置</h1><p id="9b4d" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">按照传统，我们必须安装非标准软件包。为了弄清楚 lat/lng 到 tileset 之间的转换，我们使用了<strong class="kw iu"> mercantile </strong>软件包(相当肯定是墨卡托和 tile 的组合)。我们还将安装<strong class="kw iu"> pillow </strong>，这是一个广泛用于 python 的图像处理库。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="369a" class="mp lr it nc b gy ng nh l ni nj">pip install mercantile<br/>pip install pillow</span></pre><p id="fc1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还将建立一些目录来存储卫星和高程图像的临时图像。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="90c6" class="mp lr it nc b gy ng nh l ni nj">mkdir ./satellite_images<br/>mkdir ./elevation_images<br/>mkdir ./composite_images</span></pre><p id="74a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">合成图像目录是我们的最终图像将去的地方。</p><h1 id="6fb5" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">从 Lat/Lng 转换为 Tilesets</h1><p id="535f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">首先要做的是确定我们要扫描的位置。我住在多伦多附近，所以我想看看超高分辨率的海滨是什么样子！我设置了坐标(只要谷歌一下位置，在地图上点击右键，选择“这里有什么？”以获得坐标)</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5fbd" class="mp lr it nc b gy ng nh l ni nj">lat_lng = [43.640918, -79.371478]</span></pre><p id="e335" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我需要决定我想要查看的扫描范围。我用一个纬度/液化天然气三角洲因子来表示它，并应用它来找到我感兴趣的区域的左上角和右下角的选择。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="d71d" class="mp lr it nc b gy ng nh l ni nj">delta=0.05<br/>tl = [lat_lng[0]+delta, lat_lng[1]-delta]<br/>br = [lat_lng[0]-delta, lat_lng[1]+delta]<br/>z = 15 <strong class="nc iu"># Set the resolution (max at 15)</strong></span></pre><h1 id="293b" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">提取图像</h1><p id="16e6" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">下一步是从特定的 API URLs 中提取图像数据。Mapbox 有两个我们感兴趣的端点。一个提供高细节卫星图像，另一个提供编码高程映射。端点需要相同的输入，因此我总结如下:</p><h2 id="6fc3" class="mp lr it bd ls mq mr dn lw ms mt dp ma ld mu mv mc lh mw mx me ll my mz mg na bi translated">Mapbox API URLs</h2><p id="111c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><a class="ae mn" href="https://api.mapbox.com/v4/mapbox.terrain-rgb/" rel="noopener ugc nofollow" target="_blank"><em class="nk"/><strong class="kw iu"><em class="nk">mapbox . terrain-RGB</em></strong><em class="nk">/</em></a><em class="nk">{ z }/{ x }/{ y }</em><a class="ae mn" href="http://twitter.com/2x" rel="noopener ugc nofollow" target="_blank"><em class="nk">@ 2x</em></a><em class="nk">。pngraw？access _ token = {您的密钥} </em></p><p id="c50f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mn" href="https://api.mapbox.com/v4/mapbox.satellite" rel="noopener ugc nofollow" target="_blank"><em class="nk"/><strong class="kw iu"><em class="nk">mapbox . satellite</em></strong></a><em class="nk">/{ z }/{ x }/{ y }</em><a class="ae mn" href="http://twitter.com/2x" rel="noopener ugc nofollow" target="_blank"><em class="nk">@ 2x</em></a><em class="nk">。pngraw？access _ token = {您的密钥} </em></p><ul class=""><li id="5637" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp nq nr ns nt bi translated"><a class="ae mn" href="https://api.mapbox.com/v4/mapbox.terrain-rgb/" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu"><em class="nk">map box . terrain-RGB</em></strong></a><strong class="kw iu"><em class="nk">:</em></strong>这是高程数据的端点</li><li id="cf3d" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated"><a class="ae mn" href="https://api.mapbox.com/v4/mapbox.terrain-rgb/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> <em class="nk">地图框。</em> </strong> </a> <a class="ae mn" href="https://api.mapbox.com/v4/mapbox.satellite" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> <em class="nk">卫星</em></strong></a><strong class="kw iu"><em class="nk">:</em></strong>这是卫星数据的终点</li><li id="51b9" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated"><strong class="kw iu"> {z}: </strong>这是我们想要选择的缩放级别(0-15)</li><li id="f5e2" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated"><strong class="kw iu"> {x}: </strong>我们在给定缩放级别下请求的 x 平铺</li><li id="a0bd" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated"><strong class="kw iu"> {y}: </strong>我们在给定缩放级别下请求的 y 平铺</li><li id="ba43" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated"><strong class="kw iu">{您的密钥}: </strong>您向 Mapbox API 注册时请求的 API 密钥(看起来像<strong class="kw iu"><em class="nk">PK . kjsalfjaeii 9789 F7 ah</em></strong><em class="nk">……)</em></li><li id="0cda" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated"><strong class="kw iu"> @2x.pngraw: </strong>这表示我们希望图像是双倍分辨率(512x512)的原始 PNG 文件</li></ul><p id="14ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你进入你的浏览器，用一组有效的输入导航到 URL，你应该看到一个漂亮的图像返回。这就是我们要用 python 实现的自动化。</p><p id="984f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们需要使用前几节中定义的 x/y/z 来收集图像数组。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="0eb8" class="mp lr it nc b gy ng nh l ni nj">import requests <strong class="nc iu"># The requests package allows use to call URLS</strong><br/>import shutil   <strong class="nc iu"># shutil will be used to copy the image to the local</strong></span><span id="4e19" class="mp lr it nc b gy nz nh l ni nj"><strong class="nc iu"># Loop over the tile ranges</strong><br/>for i,x in enumerate(range(x_tile_range[0],x_tile_range[1]+1)):<br/>  for j,y in enumerate(range(y_tile_range[0],y_tile_range[1]+1))</span><span id="5496" class="mp lr it nc b gy nz nh l ni nj">   <strong class="nc iu"># Call the URL to get the image back</strong><br/>   r = requests.get('https://api.mapbox.com/v4/mapbox.terrain-<br/>      rgb/'+str(z)+'/'+str(x)+'/'+str(y)+'<a class="ae mn" href="http://twitter.com/2x" rel="noopener ugc nofollow" target="_blank">@2x</a>.pngraw?<br/>      access_token=pk.eyJ1I....', stream=True)</span><span id="5c95" class="mp lr it nc b gy nz nh l ni nj">   <strong class="nc iu"># Next we will write the raw content to an image</strong><br/>   with open(‘./elevation_images/’ + str(i) + ‘.’ + str(j) + ‘.png’,<br/>      ‘wb’) as f:<br/>       r.raw.decode_content = True<br/>       shutil.copyfileobj(r.raw, f) <br/></span><span id="e479" class="mp lr it nc b gy nz nh l ni nj">   <strong class="nc iu"># Do the same for the satellite data<br/></strong>   r =requests.get('https://api.mapbox.com/v4/mapbox.satellite/'+<br/>      str(z)+'/'+str(x)+'/'+str(y)+'<a class="ae mn" href="http://twitter.com/2x" rel="noopener ugc nofollow" target="_blank">@2x</a>.pngraw?<br/>      access_token=pk.eyJ1I....', stream=True)</span><span id="35a7" class="mp lr it nc b gy nz nh l ni nj">   with open(‘./satellite_images/’ + str(i) + ‘.’ + str(j) + ‘.png’,<br/>      ‘wb’) as f:<br/>       r.raw.decode_content = True<br/>       shutil.copyfileobj(r.raw, f)</span></pre><p id="360b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这一点上，我们有一组图像在它们的文件夹中，并以<strong class="kw iu"><em class="nk">【x.y.png】</em></strong>的格式命名，这将使我们在稍后合成最终图像时更容易循环。</p><h1 id="71ee" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">合成最终图像</h1><p id="ee64" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们的小项目快结束了。我们现在想做的是将所有较小的图像合成一个分辨率极高的大图像。为此，我们将使用 Pillow (python 包)创建一个新的 png。</p><p id="54c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们制作一个新的空白图像，设置成我们想要的最终尺寸。然后，我们将只是粘贴在有意义的偏移较小的图像。下面是一张 GIF 图片，直观地展示了代码的作用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/acec3cc63898a358601a8ce7d1cb35dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*9ZtSQw_jLTCQbu8YI12tNw.gif"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">显示各个图像如何构成的动画。</p></figure><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="ef11" class="mp lr it nc b gy ng nh l ni nj"><strong class="nc iu"># Import the image, math and os libraries<br/></strong>import PIL<br/>import mathfrom os import listdir<br/>from os.path import isfile, join</span><span id="76c9" class="mp lr it nc b gy nz nh l ni nj"><strong class="nc iu"># Loop over the elevation and satellite image set</strong><br/>for img_name in [‘elevation’,’satellite’]:</span><span id="0799" class="mp lr it nc b gy nz nh l ni nj">   <strong class="nc iu"># Make a list of the image names  </strong> <br/>   image_files = [‘./’+img_name+’_images/’ + f for f in<br/>      listdir(‘./’+img_name+’_images/’)]</span><span id="3685" class="mp lr it nc b gy nz nh l ni nj"><strong class="nc iu">    # Open the image set using pillow<br/></strong>    images = [PIL.Image.open(x) for x in image_files]</span><span id="d015" class="mp lr it nc b gy nz nh l ni nj"><strong class="nc iu">   # Calculate the number of image tiles in each direction</strong><br/>   edge_length_x = x_tile_range[1] — x_tile_range[0]<br/>   edge_length_y = y_tile_range[1] — y_tile_range[0]<br/>   edge_length_x = max(1,edge_length_x)<br/>   edge_length_y = max(1,edge_length_y)</span><span id="268b" class="mp lr it nc b gy nz nh l ni nj">   <strong class="nc iu"># Find the final composed image dimensions</strong>  <br/>   width, height = images[0].size<br/>   total_width = width*edge_length_x<br/>   total_height = height*edge_length_y</span><span id="8c19" class="mp lr it nc b gy nz nh l ni nj"><strong class="nc iu">   # Create a new blank image we will fill in</strong><br/>   composite = PIL.Image.new(‘RGB’, (total_width, total_height))</span><span id="9a9d" class="mp lr it nc b gy nz nh l ni nj">   <strong class="nc iu"># Loop over the x and y ranges</strong><br/>   y_offset = 0<br/>   for i in range(0,edge_length_x):<br/>     x_offset = 0<br/>     for j in range(0,edge_length_y):</span><span id="2aeb" class="mp lr it nc b gy nz nh l ni nj">        <strong class="nc iu"># Open up the image file and paste it into the composed<br/>           image at the given offset position</strong><br/>        tmp_img = PIL.Image.open(‘./’+img_name+’_images/’ + str(i) +<br/>           ‘.’ + str(j) + ‘.png’)<br/>        composite.paste(tmp_img, (y_offset,x_offset))<br/>        x_offset += width <strong class="nc iu"># Update the width</strong></span><span id="ecba" class="mp lr it nc b gy nz nh l ni nj">     y_offset += height <strong class="nc iu"># Update the height</strong></span><span id="4efd" class="mp lr it nc b gy nz nh l ni nj"><strong class="nc iu"># Save the final image</strong><br/>composite.save(‘./composite_images/’+img_name+’.png’)</span></pre><p id="80cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">瞧。你现在应该有两张非常非常大并且分辨率惊人的图像。为了给你一个规模的感觉，看看下面的图片，显示了从上面放大的 GIF 版本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/9256652b461d24d1572d2c1cb9aec364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*ZKTyb2_6DBgio1BycsmgjQ.png"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">上图的放大图显示了我们惊人的分辨率(图片大约 50Mb)。</p></figure><p id="5517" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">男人看起来脆脆的！下面是高程数据的 GIF 图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/233b2cd300e578e3f62048bcf0d75eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*vRNBB74clqixDRZE2RBvSg.gif"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">高程数据合成的动画。</p></figure><p id="b4db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这一点上，你可以做你需要的最终图像。这整件事有两个好处。</p><ol class=""><li id="ddab" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp og nr ns nt bi translated">这些图像分辨率极高</li><li id="355e" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp og nr ns nt bi translated">你可以很容易地选择任何你感兴趣的矩形地图</li></ol><p id="721e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于我自己的项目，我真的想要解码的高程数据。Mapbox 实际上告诉你如何解码像素，以获得低至 0.1 米的高程，但我只是在下面放了一个 python 脚本。</p><h1 id="6803" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">解码高程数据</h1><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5b27" class="mp lr it nc b gy ng nh l ni nj"><strong class="nc iu"># Load the elevation image and convert it to RGBA</strong><br/>elevation_raw = PIL.Image.open(‘./composite_images/elevation.png’)<br/>rgb_elevation = elevation_raw.convert(‘RGBA’)</span><span id="bd89" class="mp lr it nc b gy nz nh l ni nj"><strong class="nc iu"># Loop over the image and save the data in a list</strong><br/>elevation_data = []<br/>for h in range(rgb_elevation.height):<br/>   for w in range(rgb_elevation.width):</span><span id="874d" class="mp lr it nc b gy nz nh l ni nj">      <strong class="nc iu"># Extract the pixel values</strong><br/>      R, G, B, A = rgb_elevation.getpixel((w, h))</span><span id="b329" class="mp lr it nc b gy nz nh l ni nj">      <strong class="nc iu"># Use Mapbox conversion from pixel to meters</strong><br/>      height = -10000 + ((R * 256 * 256 + G * 256 + B) * 0.1)</span><span id="29b4" class="mp lr it nc b gy nz nh l ni nj">      <strong class="nc iu"># Append to our elevation data list</strong><br/>      elevation_data.append(height)</span><span id="3021" class="mp lr it nc b gy nz nh l ni nj"><strong class="nc iu"># Save to a json file</strong><br/>import json<br/>with open(‘./elevation.json’, ‘w’) as outfile:<br/>   json.dump(elevation_data, outfile)</span></pre><p id="3d73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">全部完成！现在你可以用它对原始图像进行分析或切片。(还可以做等高线，3D 可视化或者一堆东西！)</p><h1 id="0f17" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">参考和链接</h1><div class="oh oi gp gr oj ok"><a href="https://www.kaggle.com/kapastor/high-resolution-mapping-with-mapbox-and-three-js" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">使用 Mapbox 和 Three.js 进行高分辨率制图</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">使用 Kaggle 笔记本探索和运行机器学习代码|使用来自非数据源的数据</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">www.kaggle.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div></div></div>    
</body>
</html>