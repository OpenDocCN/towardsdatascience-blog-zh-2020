<html>
<head>
<title>Regression-based decision trees: Predicting Average Daily Rates for Hotels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于回归的决策树:预测酒店的平均每日房价</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/regression-based-decision-trees-predicting-average-daily-rates-for-hotels-857567d5168e?source=collection_archive---------65-----------------------#2020-07-21">https://towardsdatascience.com/regression-based-decision-trees-predicting-average-daily-rates-for-hotels-857567d5168e?source=collection_archive---------65-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="196f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">决策树的目的是通过树形图的方式可视化模型的特征，并推断每个特征在影响输出变量中的重要性(或缺乏重要性)。</h2></div><p id="f27d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">决策树结构包括:</p><ul class=""><li id="cd0d" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="kk iu">节点:</strong>每棵决策树由所谓的<strong class="kk iu">根节点</strong>和<strong class="kk iu">决策节点</strong>组成。</li><li id="b6be" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">分支:</strong>表示跨节点做出的每个决策的结果。</li></ul><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/feeba44412de8633a7fb24a8c1852bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fWGZE_JFEBWy7YDqMipCQ.png"/></div></div><p class="me mf gj gh gi mg mh bd b be z dk translated">来源:图片来自<a class="ae mi" href="https://pixabay.com/vectors/evergreen-forest-landscape-2025158/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>。</p></figure><p id="3c48" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，基于回归的决策树被公式化以预测给定特定客户属性的酒店的 ADR(平均每日房价)。</p><h1 id="8de9" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">背景</h1><p id="5556" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">本研究侧重于酒店预订分析。谈到酒店预订，<strong class="kk iu">平均每日房价(ADR) </strong>是一个特别重要的指标。这反映了特定客户在整个逗留期间每天支付的平均费用。</p><p id="b0ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该分析基于 2016 年 Antonio、Almeida 和 Nunes 的原始研究。</p><p id="40a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">衡量 ADR 可以让酒店更准确地识别最有利可图的客户，并相应地调整营销策略。</p><p id="5d92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">形成该神经网络输入的所选特征如下:</p><ol class=""><li id="1848" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld ng lk ll lm bi translated">取消</li><li id="eaea" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ng lk ll lm bi translated">原产国</li><li id="7671" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ng lk ll lm bi translated">细分市场</li><li id="3bc1" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ng lk ll lm bi translated">存款类型</li><li id="fdc1" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ng lk ll lm bi translated">客户类型</li><li id="038e" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ng lk ll lm bi translated">所需的停车位</li><li id="6902" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ng lk ll lm bi translated">到达日期:年</li><li id="0cc4" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ng lk ll lm bi translated">抵达日期:月</li><li id="a365" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ng lk ll lm bi translated">到达日期:周数</li><li id="16bc" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld ng lk ll lm bi translated">到达日期:当月的某一天</li></ol><h1 id="aba8" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">数据操作</h1><p id="24a0" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">定义了区间(或连续随机变量)。举两个例子:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="598d" class="nm mk it ni b gy nn no l np nq">leadtime = train_df['LeadTime']<br/>adr = train_df['ADR']</span></pre><p id="b22c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用'''类别代码' ' '定义具有分类成分的变量。</p><p id="929f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为另外两个例子:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="6097" class="nm mk it ni b gy nn no l np nq">deposittypecat=train_df.DepositType.astype("category").cat.codes<br/>deposittypecat=pd.Series(deposittypecat)<br/>customertypecat=train_df.CustomerType.astype("category").cat.codes<br/>customertypecat=pd.Series(customertypecat)</span></pre><p id="9fd9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">numpy 列堆栈是为独立变量(连续变量和分类变量)制定的:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="e0a6" class="nm mk it ni b gy nn no l np nq">x1 = np.column_stack((IsCanceled,countrycat,marketsegmentcat,deposittypecat,customertypecat,rcps,arrivaldateyear,arrivaldatemonthcat,arrivaldateweekno,arrivaldatedayofmonth))<br/>x1 = sm.add_constant(x1, prepend=True)</span></pre><p id="8bd6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，数据被分成训练集和验证集:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="f85b" class="nm mk it ni b gy nn no l np nq">X_train, X_val, y_train, y_val = train_test_split(x1, y1)</span></pre><h1 id="3a8b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">决策树公式</h1><p id="6000" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">使用<strong class="kk iu"> sklearn </strong>导入决策树回归器:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="6cd0" class="nm mk it ni b gy nn no l np nq">from sklearn.tree import DecisionTreeRegressor</span></pre><p id="942c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">决策树被拟合。使用<strong class="kk iu"> max_depth </strong>，确定树的大小。在这种情况下，它被设置为 4。当将预测精度与测试数据(我们将在下面详细讨论)进行比较时，我发现使用四棵树时均方根误差最小。使用较少的树会有大量信息丢失的风险，而过多的树会增加过度拟合的风险。</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="b9e1" class="nm mk it ni b gy nn no l np nq">&gt;&gt;&gt; tree_reg = DecisionTreeRegressor(max_depth=4)<br/>&gt;&gt;&gt; tree_reg.fit(X_train, y_train)</span><span id="c08d" class="nm mk it ni b gy nr no l np nq">DecisionTreeRegressor(ccp_alpha=0.0, criterion='mse', max_depth=4,<br/>                      max_features=None, max_leaf_nodes=None,<br/>                      min_impurity_decrease=0.0, min_impurity_split=None,<br/>                      min_samples_leaf=1, min_samples_split=2,<br/>                      min_weight_fraction_leaf=0.0, presort='deprecated',<br/>                      random_state=None, splitter='best')</span></pre><p id="3b48" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是使用验证数据时生成的预测:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="7ab9" class="nm mk it ni b gy nn no l np nq">&gt;&gt;&gt; predictions = tree_reg.predict(X_val)<br/>&gt;&gt;&gt; predictions<br/>array([ 96.25317435, 184.46591454,  70.97877619, ...,  56.187318  ,<br/>        53.58241309,  70.97877619])</span></pre><p id="0279" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了可视化决策树，可以使用一个名为<strong class="kk iu"> graphviz </strong>的库。</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="3e9e" class="nm mk it ni b gy nn no l np nq">&gt;&gt;&gt; from sklearn.tree import export_graphviz<br/>&gt;&gt;&gt; export_graphviz(tree_reg,out_file="tree.dot")</span></pre><p id="9f92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可通过终端生成树形视图的 PDF，如下所示:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="5149" class="nm mk it ni b gy nn no l np nq">dot -Tpdf tree.dot -o tree.pdf</span></pre><p id="c5dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，可以导入树图像:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="3a51" class="nm mk it ni b gy nn no l np nq">&gt;&gt;&gt; import graphviz<br/>&gt;&gt;&gt; with open("tree.dot") as f:<br/>&gt;&gt;&gt;     dot_graph = f.read()</span><span id="56dc" class="nm mk it ni b gy nr no l np nq">&gt;&gt;&gt; graphviz.Source(dot_graph)</span></pre><p id="999f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是决策树的示例:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ns"><img src="../Images/994659536ce4d7caabdf062eaa90ba6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vzekx_8yAMTLcOX1.png"/></div></div><p class="me mf gj gh gi mg mh bd b be z dk translated">来源:Jupyter 笔记本输出</p></figure><p id="c9dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在<strong class="kk iu">平均绝对误差</strong>和<strong class="kk iu">均方根误差</strong>的基础上评估模型预测在验证数据上的表现。</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="7316" class="nm mk it ni b gy nn no l np nq">&gt;&gt;&gt; mean_absolute_error(y_val, predictions)<br/>27.39342405758301</span><span id="3ca3" class="nm mk it ni b gy nr no l np nq">&gt;&gt;&gt; mean_squared_error(y_val, predictions)<br/>1531.417860233403</span><span id="f47f" class="nm mk it ni b gy nr no l np nq">&gt;&gt;&gt; math.sqrt(mean_squared_error(y_val, predictions))<br/>39.13333438685493</span></pre><h1 id="0710" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">测试数据</h1><p id="537e" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">为了确定模型是否能够在未知数据集上保持其准确性，我们现在将测试模型预测在 H2 数据集上是否也显示出类似的准确性。</p><p id="bcd5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，分类变量和连续变量是这样定义的，并且其值也有适当的定义:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="d8b9" class="nm mk it ni b gy nn no l np nq">atest = np.column_stack((t_IsCanceled,t_countrycat,t_marketsegmentcat,t_deposittypecat,t_customertypecat,t_rcps,t_arrivaldateyear,t_arrivaldatemonthcat,t_arrivaldateweekno,t_arrivaldatedayofmonth))<br/>atest = sm.add_constant(atest, prepend=True)<br/>btest = t_adr<br/>btest=btest.values</span></pre><p id="ea19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，决策树用于对测试数据的特征进行预测。</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="15e3" class="nm mk it ni b gy nn no l np nq">&gt;&gt;&gt; bpred = tree_reg.predict(atest)<br/>&gt;&gt;&gt; bpred<br/>array([141.51432277, 141.51432277, 141.51432277, ..., 184.46591454,<br/>       184.46591454, 184.46591454])</span></pre><p id="4da8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们评估一下<strong class="kk iu">平均绝对误差</strong>和<strong class="kk iu">均方根误差</strong>。</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="c27f" class="nm mk it ni b gy nn no l np nq">&gt;&gt;&gt; mean_absolute_error(btest, bpred)<br/>41.71191007286715</span><span id="de9f" class="nm mk it ni b gy nr no l np nq">&gt;&gt;&gt; print('mse (sklearn): ', mean_squared_error(btest,bpred))<br/>mse (sklearn):  3115.6311827256595</span><span id="2c42" class="nm mk it ni b gy nr no l np nq">&gt;&gt;&gt; math.sqrt(mean_squared_error(btest, bpred))<br/>55.817839287504306</span></pre><p id="903a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">MAE 和 RMSE 比在验证数据中测试时要高一些。鉴于这个数据集是不可见的，这与预期相符。然而，就最大化精度而言，具有 ELU 激活函数的基于回归的神经网络显示出较低的误差，MAE 在<strong class="kk iu"> 33.56 </strong>而 RMSE 在<strong class="kk iu"> 47.55 </strong>。</p><p id="568f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你感兴趣，关于这个例子的基于回归的神经网络的文章在这里<a class="ae mi" rel="noopener" target="_blank" href="/regression-based-neural-networks-with-tensorflow-v2-0-predicting-average-daily-rates-e20fffa7ac9a">是</a>。</p><h1 id="4329" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="1829" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">在本例中，我们看到了如何:</p><ul class=""><li id="9703" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">构建决策树</li><li id="3460" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">正确配置决策树</li><li id="2e76" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">评估验证和测试集的模型准确性</li></ul><p id="3e00" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本例的数据集和笔记本可在<a class="ae mi" href="https://github.com/MGCodesandStats/hotel-modelling" rel="noopener ugc nofollow" target="_blank"> MGCodesandStats GitHub 存储库</a>获得，以及关于该主题的进一步研究。</p><p id="8339" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nt">免责声明:本文是在“原样”的基础上编写的，没有任何担保。本文旨在提供数据科学概念的概述，不应以任何方式解释为专业建议。</em></p></div></div>    
</body>
</html>