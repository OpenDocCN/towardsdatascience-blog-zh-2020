<html>
<head>
<title>Creating benchmark models the scikit-learn way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以 scikit-learn 方式创建基准模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-benchmark-models-the-scikit-learn-way-af227f6ea977?source=collection_archive---------16-----------------------#2020-02-08">https://towardsdatascience.com/creating-benchmark-models-the-scikit-learn-way-af227f6ea977?source=collection_archive---------16-----------------------#2020-02-08</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><figure class="iu iv gp gr iw ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi it"><img src="../Images/7d1d7545d5aa06027930717c1a4811bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bzf775zcidXXXJrEFouPOQ.jpeg"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">来源:<a class="ae ji" href="https://pixabay.com/photos/work-typing-computer-notebook-731198/" rel="noopener ugc nofollow" target="_blank"> pixabay </a></p></figure><div class=""/><div class=""><h2 id="4896" class="pw-subtitle-paragraph km jk jl bd b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dk translated">了解如何为分类和回归问题创建一系列基准模型</h2></div><p id="1d32" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">我真正喜欢<code class="fe ki kj kk kl b">scikit-learn</code>的是我经常偶然发现一些我以前没有意识到的功能。我最近的“发现”是<code class="fe ki kj kk kl b">DummyClassifier</code>。虚拟估计器不从特征中学习任何模式，它使用简单的试探法(从目标中推断)来计算预测。</p><p id="18c8" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">我们可以使用那个简单的估计量作为我们更高级模型的一个简单的健全性检查。为了通过检查，所考虑的模型应该产生比简单基准更好的性能。</p><p id="b1e1" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">在这篇短文中，我将展示如何使用<code class="fe ki kj kk kl b">DummyClassifier</code>,并解释可用的启发式方法。</p><h1 id="5875" class="ma mb jl bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">设置</h1><p id="011e" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">我们需要导入所需的库:</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a975" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">在本文中，我编写了一个简单的函数，打印一些选择的评估指标来评估模型的性能。除了准确性之外，我还包括了在类不平衡的情况下有助于评估性能的指标(这个列表并不详尽)。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="5a40" class="ma mb jl bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">加载数据</h1><p id="5eb1" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">对于本文，我使用著名的 Iris 数据集。为了进一步简化问题，我将多类问题转化为二元分类，同时引入类不平衡。这个练习的目的是预测给定的植物是属于杂色类还是“其他”(Setosa 或 Virginica)。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="95c4" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">改造后班级比例为 2:1。</p><p id="437b" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">训练模型前的最后一步是使用<code class="fe ki kj kk kl b">train_test_split</code>函数将数据分成训练集和测试集:</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ae6a" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">因为我们有意引入了阶级不平衡</p><h1 id="fbb5" class="ma mb jl bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">探索<code class="fe ki kj kk kl b">DummyClassifier</code>的变种</h1><p id="fc57" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated"><code class="fe ki kj kk kl b">DummyClassifier</code>估计器提供了一些可能的规则(称为策略)，我们可以用它们来确定基准类预测。下面我将简要描述它们，并给出相应的代码片段来展示实现。</p><h2 id="bc60" class="nd mb jl bd mc ne nf dn mg ng nh dp mk ln ni nj mm lr nk nl mo lv nm nn mq no bi translated">“持续”战略</h2><p id="9504" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">可以说是虚拟分类器的最简单的变体。这个想法是用一个值代替所有的标签。这种变体的一个可能的用例是，当我们想要根据 F1 分数来评估一个潜在的评估者时，F1 分数是精确度和召回率的调和平均值。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9115" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">我使用少数类(Versicolour)来创建天真的预测。同样值得一提的是，这些特性在确定预测值时不起任何作用，它们只是为了匹配<code class="fe ki kj kk kl b">scikit-learn</code>的 fit + predict 风格。在下面的总结中，我们看到我们实现了完美的回忆，F1 得分为 0.5。</p><pre class="mx my mz na gt np kl nq nr aw ns bi"><span id="6a5b" class="nd mb jl kl b gy nt nu l nv nw">{'accuracy': 0.3333333333333333,<br/> 'recall': 1.0,<br/> 'precision': 0.3333333333333333,<br/> 'f1_score': 0.5}</span></pre><h2 id="2e97" class="nd mb jl bd mc ne nf dn mg ng nh dp mk ln ni nj mm lr nk nl mo lv nm nn mq no bi translated">“统一”战略</h2><p id="cd3b" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">在这个变体中，从可用的类中随机地(一致地)生成天真的预测。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5e44" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">运行代码会产生以下摘要:</p><pre class="mx my mz na gt np kl nq nr aw ns bi"><span id="bc34" class="nd mb jl kl b gy nt nu l nv nw">{'accuracy': 0.4,<br/> 'recall': 0.4,<br/> 'precision': 0.25,<br/> 'f1_score': 0.3076923076923077}</span></pre><p id="4126" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">此外，我们使用<code class="fe ki kj kk kl b">Counter</code>检查预测标签的分布:</p><pre class="mx my mz na gt np kl nq nr aw ns bi"><span id="cc1a" class="nd mb jl kl b gy nt nu l nv nw">Counter({0: 14, 1: 16})</span></pre><p id="6664" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">正如均匀绘制所预期的，目标的分布是随机的，并不反映标签的真实分布。</p><h2 id="248f" class="nd mb jl bd mc ne nf dn mg ng nh dp mk ln ni nj mm lr nk nl mo lv nm nn mq no bi translated">“分层”战略</h2><p id="1f7b" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">为了解决前面提到的缺点，我们可以使用<code class="fe ki kj kk kl b">stratified</code>规则。预测是随机生成的，但是保留了来自训练集的类的分布。正如在分层的<code class="fe ki kj kk kl b">train_test_split</code>中一样。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a259" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">运行代码会产生以下摘要:</p><pre class="mx my mz na gt np kl nq nr aw ns bi"><span id="6303" class="nd mb jl kl b gy nt nu l nv nw">{'accuracy': 0.6333333333333333,<br/> 'recall': 0.3,<br/> 'precision': 0.42857142857142855,<br/> 'f1_score': 0.3529411764705882}</span></pre><p id="47a2" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">我们再一次查看每一类的观察次数:</p><pre class="mx my mz na gt np kl nq nr aw ns bi"><span id="4c8d" class="nd mb jl kl b gy nt nu l nv nw">Counter({0: 23, 1: 7})</span></pre><p id="850d" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">使用<code class="fe ki kj kk kl b">`stratified`</code>策略会产生类似于我们在观察值中看到的分布。</p><h2 id="bca4" class="nd mb jl bd mc ne nf dn mg ng nh dp mk ln ni nj mm lr nk nl mo lv nm nn mq no bi translated">“最频繁”策略</h2><p id="38df" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">策略的名称很容易理解——预测值是标签中最常见的值。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="28bb" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">运行代码会产生以下摘要:</p><pre class="mx my mz na gt np kl nq nr aw ns bi"><span id="32f4" class="nd mb jl kl b gy nt nu l nv nw">{'accuracy': 0.6666666666666666,<br/> 'recall': 0.0,<br/> 'precision': 0.0,<br/> 'f1_score': 0.0}</span></pre><p id="9bfc" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">运行代码时，我们收到以下警告:<code class="fe ki kj kk kl b">UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 due to no predicted samples.</code>原因是我们选择的策略。由于多数类用于所有预测，因此没有少数类的观测值，并且无法计算精度和召回率等指标。</p><h2 id="7f52" class="nd mb jl bd mc ne nf dn mg ng nh dp mk ln ni nj mm lr nk nl mo lv nm nn mq no bi translated">“优先”策略</h2><p id="4696" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">与<code class="fe ki kj kk kl b">‘most_frequent’</code>策略非常相似的策略。伪分类器总是预测最大化类先验的类。区别在于拟合分类器的<code class="fe ki kj kk kl b">predict_proba</code>方法。在<code class="fe ki kj kk kl b">‘prior’</code>策略的情况下，它返回类别先验(类别概率由训练集中标签的比率决定)。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b2f1" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated"><code class="fe ki kj kk kl b">‘prior’</code>和<code class="fe ki kj kk kl b">‘most_frequent’</code>策略的结果是相同的，所以为了简洁起见，我不再展示它们。</p><p id="017b" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">值得一提的是，对于所有策略，<code class="fe ki kj kk kl b">predict</code>方法完全忽略了输入数据，用作预测的值是在拟合阶段确定的(或在使用<code class="fe ki kj kk kl b">‘constant’</code>策略时由我们提供)。</p><h1 id="cc9d" class="ma mb jl bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">训练一个实际的评估者</h1><p id="bc80" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">在尝试了创建基准模型的多种策略之后，是时候训练一个简单的分类器并评估它是否优于基准了。为此，我使用带有默认设置的决策树分类器(除了为再现性指定的<code class="fe ki kj kk kl b">random_state</code>)。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6609" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">通过检查下面的总结，我们可以清楚地表明决策树优于所有的基准。</p><pre class="mx my mz na gt np kl nq nr aw ns bi"><span id="3078" class="nd mb jl kl b gy nt nu l nv nw">{'accuracy': 0.9473684210526315,<br/> 'recall': 0.9230769230769231,<br/> 'precision': 0.9230769230769231,<br/> 'f1_score': 0.9230769230769231}</span></pre><h1 id="0d5a" class="ma mb jl bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">DummyRegressor</h1><p id="9cc4" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">我已经展示了如何使用<code class="fe ki kj kk kl b">scikit-learn</code>的<code class="fe ki kj kk kl b">DummyClassifier</code>来评估分类任务的基准模型。自然，回归问题存在一个类比估计量——<code class="fe ki kj kk kl b">DummyRegressor</code>。我就不赘述了，因为用法和<code class="fe ki kj kk kl b">DummyClassifier</code>很像。为了完整起见，我只提到可用的策略:</p><ul class=""><li id="092f" class="nx ny jl lg b lh li lk ll ln nz lr oa lv ob lz oc od oe of bi translated"><code class="fe ki kj kk kl b">'mean’</code> —估计器使用目标(来自训练集)的平均值作为预测</li><li id="d0eb" class="nx ny jl lg b lh og lk oh ln oi lr oj lv ok lz oc od oe of bi translated"><code class="fe ki kj kk kl b">'median’</code> —估计器使用目标(训练集)的中值作为预测</li><li id="0f4a" class="nx ny jl lg b lh og lk oh ln oi lr oj lv ok lz oc od oe of bi translated"><code class="fe ki kj kk kl b">'constant’</code> —估计器使用常数值作为预测值</li><li id="b975" class="nx ny jl lg b lh og lk oh ln oi lr oj lv ok lz oc od oe of bi translated"><code class="fe ki kj kk kl b">'quantile’</code> —估计器使用目标(训练集)的指定分位数作为预测</li></ul><p id="c6ed" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">与<code class="fe ki kj kk kl b">DummyClassifier</code>类似，<code class="fe ki kj kk kl b">predict</code>方法忽略计算预测的输入数据。</p><h1 id="fad9" class="ma mb jl bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">结论</h1><p id="7b02" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">在本文中，我展示了如何使用简单的试探法使用<code class="fe ki kj kk kl b">scikit-learn</code>中可用的估计器来创建基准模型。我们可以使用这样的模型进行健全性检查，看看我们的评估者是否比天真的基线表现得更好。如果不是，我们应该调查是什么导致了这个问题(也许这些特性没有帮助或者类的不平衡影响了结果)。</p><p id="1109" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">您可以在我的<a class="ae ji" href="https://github.com/erykml/medium_articles/blob/master/Machine%20Learning/dummy_classifier_intro.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到本文使用的代码。一如既往，我们欢迎任何建设性的反馈。你可以在推特上或者评论里联系我。</p></div><div class="ab cl ol om hz on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="io ip iq ir is"><p id="0594" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">我最近出版了一本关于使用 Python 解决金融领域实际任务的书。如果你有兴趣，我贴了一篇文章介绍这本书的内容。你可以在亚马逊或者 Packt 的网站上买到这本书。</p></div></div>    
</body>
</html>