<html>
<head>
<title>Analytical Functions in Oracle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Oracle 中的分析功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/analytical-functions-in-oracle-4ac48e022370?source=collection_archive---------9-----------------------#2020-06-07">https://towardsdatascience.com/analytical-functions-in-oracle-4ac48e022370?source=collection_archive---------9-----------------------#2020-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d4d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak"> <em class="ki">本文通过概念构建练习</em> </strong>帮助理解分析函数的工作和用法</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/ea5c78612b17a8c7e6fe73b432bd9577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t-zVYW_oq2RQXix3"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">斯蒂芬·菲利普斯-Hostreviews.co.uk 在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片<a class="ae kz" href="https://unsplash.com/@hostreviews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="cf2e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="lw">分析函数用于对多行数据进行“分析”,并返回当前行的结果。</em> </strong>例如，分析函数可用于找出运行总数、对行进行排序、对前一行或即将到来的行进行汇总等。虽然通过使用标准聚合函数和使用连接和子查询的原生 SQL 可以实现相同的功能，但是分析函数使它更加简单和快速。Oracle 在 Oracle 8.1.6 中引入了 26 个分析功能。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="56e1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们将使用下面的脚本来创建样本数据:</p><pre class="kk kl km kn gt me mf mg mh aw mi bi"><span id="c2c8" class="mj mk it mf b gy ml mm l mn mo">CREATE TABLE DEPT<br/>(<br/> DEPTNO NUMBER(2),<br/> DNAME VARCHAR2(14 CHAR),<br/> LOC VARCHAR2(13 CHAR)<br/>);</span><span id="f967" class="mj mk it mf b gy mp mm l mn mo">Insert into DEPT<br/> (DEPTNO, DNAME, LOC)<br/> Values<br/> (10, ‘ACCOUNTING’, ‘NEW YORK’);<br/>Insert into DEPT<br/> (DEPTNO, DNAME, LOC)<br/> Values<br/> (20, ‘RESEARCH’, ‘DALLAS’);<br/>Insert into DEPT<br/> (DEPTNO, DNAME, LOC)<br/> Values<br/> (30, ‘SALES’, ‘CHICAGO’);<br/>Insert into DEPT<br/> (DEPTNO, DNAME, LOC)<br/> Values<br/> (40, ‘OPERATIONS’, ‘BOSTON’);<br/>COMMIT;</span><span id="4156" class="mj mk it mf b gy mp mm l mn mo">CREATE TABLE EMP<br/>(<br/> EMPNO NUMBER(4) NOT NULL,<br/> ENAME VARCHAR2(10 CHAR),<br/> JOB VARCHAR2(9 CHAR),<br/> MGR NUMBER(4),<br/> HIREDATE DATE,<br/> SAL NUMBER(7,2),<br/> COMM NUMBER(7,2),<br/> DEPTNO NUMBER(2)<br/>)</span><span id="607f" class="mj mk it mf b gy mp mm l mn mo">Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7369, ‘SMITH’, ‘CLERK’, 7902, TO_DATE(‘12/17/1980 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 800, NULL, 20);<br/>Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7499, ‘ALLEN’, ‘SALESMAN’, 7698, TO_DATE(‘02/20/1981 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 1600, 300, 30);<br/>Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7521, ‘WARD’, ‘SALESMAN’, 7698, TO_DATE(‘02/22/1981 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 1250, 500, 30);<br/>Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7566, ‘JONES’, ‘MANAGER’, 7839, TO_DATE(‘04/02/1981 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 2975, NULL, 20);<br/>Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7654, ‘MARTIN’, ‘SALESMAN’, 7698, TO_DATE(‘09/28/1981 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 1250, 1400, 30);<br/>Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7698, ‘BLAKE’, ‘MANAGER’, 7839, TO_DATE(‘05/01/1981 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 2850, NULL, 30);<br/>Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7782, ‘CLARK’, ‘MANAGER’, 7839, TO_DATE(‘06/09/1981 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 2450, NULL, 10);<br/>Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7788, ‘SCOTT’, ‘ANALYST’, 7566, TO_DATE(‘12/09/1982 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 3000, NULL, 20);<br/>Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7839, ‘KING’, ‘PRESIDENT’, NULL, TO_DATE(‘11/17/1981 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 5000, NULL, 10);<br/>Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7844, ‘TURNER’, ‘SALESMAN’, 7698, TO_DATE(‘09/08/1981 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 1500, 0, 30);<br/>Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7876, ‘ADAMS’, ‘CLERK’, 7788, TO_DATE(‘01/12/1983 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 1100, NULL, 20);<br/>Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7900, ‘JAMES’, ‘CLERK’, 7698, TO_DATE(‘12/03/1981 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 950, NULL, 30);<br/>Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7902, ‘FORD’, ‘ANALYST’, 7566, TO_DATE(‘12/03/1981 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 3000, NULL, 20);<br/>Insert into EMP<br/> (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)<br/> Values<br/> (7934, ‘MILLER’, ‘CLERK’, 7782, TO_DATE(‘01/23/1982 00:00:00’, ‘MM/DD/YYYY HH24:MI:SS’), <br/> 1300, NULL, 10);<br/>COMMIT;</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="8ade" class="mq mk it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">分析函数和聚合函数的区别</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nh"><img src="../Images/62a4c32f006760b690a83108315c201e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aAqdu3A610ermsyK"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">威尔·弗朗西斯在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><blockquote class="ni nj nk"><p id="8d73" class="la lb lw lc b ld le ju lf lg lh jx li nl lk ll lm nm lo lp lq nn ls lt lu lv im bi translated">聚合函数对行进行分组，并返回整个结果集的输出。但是，分析函数会返回聚合输出，但不会对结果集进行分组。它们返回结果集中每一行的值。</p></blockquote><p id="c00f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">例如，如果我们必须从 employee 表中找出部门编号的计数，我们将使用聚合函数编写以下查询:</p><pre class="kk kl km kn gt me mf mg mh aw mi bi"><span id="e415" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">SELECT deptno,COUNT(*) dept_cnt<br/>FROM emp<br/>GROUP BY deptno;</strong></span></pre><p id="78ea" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">结果如下:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a9955b7ae8ffacaf4744ccbcd7a9b943.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*CxctI9mvm6VMpJ698Vd2zQ.png"/></div></figure><p id="1583" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，对于每一行(即每个部门)，我们得到计数。</p><p id="9572" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用分析函数，查询将被写成:</p><pre class="kk kl km kn gt me mf mg mh aw mi bi"><span id="2059" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">SELECT deptno, <br/>COUNT(*) OVER (PARTITION BY <br/>deptno) DEPT_COUNT<br/>FROM emp</strong></span></pre><p id="fcc0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">输出如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi np"><img src="../Images/f55abe0b3a39fe8f0386a9fe4ae100d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*r5bjr3-wCL5qwTrS64ONbg.png"/></div></figure><p id="1902" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，结果是 emp 表中的每一行。</p><p id="7a4d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，在使用聚合函数时，我们不能包含任何非分组依据列，但是在使用分析函数时，您可以这样做。例如，下面的查询将返回一个错误:</p><pre class="kk kl km kn gt me mf mg mh aw mi bi"><span id="df53" class="mj mk it mf b gy ml mm l mn mo">SELECT empno,deptno,COUNT(*) dept_cnt<br/>FROM emp<br/>GROUP BY deptno;</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/4c4277263bb11268c405de6293f11883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*whWM_TpllH8lTheHxdUE-g.png"/></div></figure><p id="afd7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是使用解析函数，就不会面临这种错误。</p><pre class="kk kl km kn gt me mf mg mh aw mi bi"><span id="b9df" class="mj mk it mf b gy ml mm l mn mo">SELECT empno,deptno, <br/>COUNT(*) OVER (PARTITION BY <br/>deptno) DEPT_COUNT<br/>FROM emp</span></pre><p id="7858" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">输出将是:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e7028c591a0614177fc48f04a89377fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*uRTLtiBviP-VzEOr0HPjug.png"/></div></figure><h1 id="d8c1" class="mq mk it bd mr ms ns mu mv mw nt my mz jz nu ka nb kc nv kd nd kf nw kg nf ng bi translated">语法:</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nx"><img src="../Images/f9d4e095fc26738763b78e4192566359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oNHYCObxmhFuuDRN"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@the_roaming_platypus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> timJ </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cdb2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">分析函数的一般语法是:</p><p id="1810" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="lw">函数(arg1，…，argn) OVER(【分区由&lt; … &gt;)【排序由&lt; …)。&gt;][&lt;window _ clause&gt;])</em></strong></p><p id="5dab" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们一部分一部分的解剖吧。</p><p id="a430" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">结束:</strong></p><p id="585c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">分析函数的范围是在 OVER 子句中定义的。对于所有分析功能，OVER 是强制的。如果您在 OVER 之后没有给出任何参数，它将假定范围为 ALL。因此，以下查询将计算整个表中部门的数量:</p><pre class="kk kl km kn gt me mf mg mh aw mi bi"><span id="4559" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">SELECT deptno, <br/>COUNT(*) OVER() DEPT_COUNT<br/>FROM emp</strong></span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/147bc5665d82bafd94f8f3baa5bd879e.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*ILiZEGaNCBvUo_pg34p1rw.png"/></div></figure><p id="e175" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">分区依据:</strong></p><p id="cbb7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">正如聚合函数使用 GROUP BY 对行进行分组一样，分析函数使用 PARTITION BY。例如，如果我们希望找出每个部门的最高工资和每个工作类型的最高工资，我们可以编写如下查询:</p><pre class="kk kl km kn gt me mf mg mh aw mi bi"><span id="7424" class="mj mk it mf b gy ml mm l mn mo">SELECT <br/>ename,<br/>sal,<br/>job,<br/>deptno,<br/>max(sal) over (partition by deptno) max_sal_deptno , <br/>max(sal) over (partition by job) max_sal_job<br/>FROM emp</span></pre><p id="bd66" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这里，我们按 deptno 进行了分区，以找出最高工资，并将其显示在 max_sal_deptno 列中。类似地，我们按职务进行了划分，以找出最高工资，并将其显示在 max_sal_job 列中</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c9d1e1bfe278df5d0eadfdc6eba3de1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*AvlHcL3eZN_-kxUnkqYyYA.png"/></div></figure><p id="f65f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们分析 emp 表的数据，很容易发现 10 部门的最高工资是 5000，20 部门是 3000，30 部门是 2850。</p><p id="190e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">同样，对于工作类型的职员，最高工资是 1300，总裁是 500，经理是 2975，分析师是 3000，销售员是 1600。</p><p id="c981" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">排序依据:</strong></p><p id="333a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">它用于指定所选分区中记录的顺序。这不同于 WHERE 之后的主查询的 ORDER BY 子句。</p><p id="81c9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">窗口条款:</strong></p><p id="ec84" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">partition 子句不是限制分析函数范围的唯一方法。我们可以使用“ROWS BETWEEN”或“RANGE BETWEEN”子句来定义一个额外的范围。这在“窗口”一节中有明确的解释</p><h1 id="683d" class="mq mk it bd mr ms ns mu mv mw nt my mz jz nu ka nb kc nv kd nd kf nw kg nf ng bi translated">一些常用分析函数的工作和用法:</h1><p id="0f11" class="pw-post-body-paragraph la lb it lc b ld oa ju lf lg ob jx li lj oc ll lm ln od lp lq lr oe lt lu lv im bi translated">一些常用的分析函数如下:</p><p id="094e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> a .行数:</strong></p><p id="4b1e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">ROW_NUMBER 为一组记录提供一个连续的序列号。这里，ORDER BY 子句在枚举行时起着至关重要的作用。例如，如果您想返回每个部门中第二个被雇用的员工，您可以编写如下查询:</p><pre class="kk kl km kn gt me mf mg mh aw mi bi"><span id="482b" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">select<br/>ename, deptno,hiredate<br/>from<br/>(<br/>SELECT <br/>ename,<br/>hiredate,<br/>deptno,<br/>row_number() over (partition by deptno order by hiredate) rn <br/>FROM emp<br/>) where rn=2</strong></span></pre><p id="1a4f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">输出是:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi of"><img src="../Images/1b9f8a167f3eb26ec20a9723e4c0c064.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*gST_cEp9sbEVnNPre4znug.png"/></div></figure><p id="9ac0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，我们按 deptno 对行进行了分区，并按 hiredate 进行了排序。函数的作用是:为所有的行分配一个序列号，从 1 开始，代表所有按 hiredate 排序的部门。对于新部门，编号将从 1 重新开始。内部查询执行此操作。内部查询的输出如下所示。(最后需要的行用红色标记)</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi og"><img src="../Images/75ed946e6a254d3a915f32aa05d27103.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*3NSsjUE_QjOXNOGp5MGOvQ.png"/></div></figure><p id="47dc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">外部查询现在选择 rn=2 的那些行，以给出我们想要的结果。</p><p id="d2d8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> b. </strong> <strong class="lc iu">等级:</strong></p><p id="5a20" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">等级分析函数还为一组以特定方式排序的行提供一个序列号，如 ROW_NUMBER。但是，不同之处在于:ROW_NUMBER 为每一行赋予一个唯一的编号，即使这些行是重复的。但是 RANK 对重复行给出相同的编号。</p><p id="0c40" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，在我们的 emp 表中，如果两个雇员有相同的雇佣日期，那么 RANK 函数将为每个重复的行给出相同的数字。查看以下查询的结果:</p><pre class="kk kl km kn gt me mf mg mh aw mi bi"><span id="252a" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">SELECT <br/>ename,<br/>hiredate,<br/>deptno,<br/>row_number() over (order by hiredate) rn, <br/>rank() over( order by hiredate) rank_num<br/> FROM emp</strong></span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/2ccf3b46190d6add9bd2e3eb74d6d6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*-cVUZi1uRdlEGSgO83aWUg.png"/></div></figure><p id="225b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">由于 JAMES 和 FORD 的雇佣日期相同，ROW_NUMBER 为他们指定了不同的编号，而 RANK 为他们指定了相同的编号。</p><p id="5898" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> c. </strong> <strong class="lc iu">密 _ 秩</strong></p><p id="7e15" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">DENSE_RANK 的工作方式与 RANK 类似。唯一的区别是，在分配给重复行时，它不会跳过数字。检查以下查询的结果，了解 RANK 和 DENSE_RANK 函数之间的区别:</p><pre class="kk kl km kn gt me mf mg mh aw mi bi"><span id="ac0c" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">SELECT <br/>ename,<br/>hiredate,<br/>deptno,<br/>rank() over(order by hiredate) rank_num,<br/>dense_rank() over( order by hiredate) dense_rank_num<br/>FROM emp</strong></span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/8a2ae4a6eca67248d689bfa7ee26a948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*qmv73iNfG2cp8O257NrKAA.png"/></div></figure><p id="6534" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">詹姆斯和福特的雇佣日期相同。因此，对于等级和密集等级，两行都被分配编号 10。但是在等级的情况下，米勒的下一行被分配 12，而在密集等级的情况下被分配 11。</p><p id="3491" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">d .</strong>T6】超前和滞后</p><p id="a894" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">LEAD 允许我们对下一行(当前行之后的行)应用任何计算。LEAD 函数的一般语法是:</p><blockquote class="ni nj nk"><p id="9c29" class="la lb lw lc b ld le ju lf lg lh jx li nl lk ll lm nm lo lp lq nn ls lt lu lv im bi translated"><strong class="lc iu"> LEAD( &lt;表达式&gt;，&lt;偏移&gt;，&lt;默认&gt; ) over( &lt;解析子句&gt; ) </strong></p></blockquote><p id="05b3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在哪里</p><p id="d61f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> &lt;表达式&gt; </strong>是应用于前导行的表达式</p><p id="816e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> &lt;偏移量&gt; </strong>是相对于当前行的第一行的数量(可以是 1，2…..)</p><p id="1ce0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> &lt;默认&gt; </strong>是当&lt;偏移量&gt;指向分区范围外的行时返回的值</p><blockquote class="ni nj nk"><p id="77ae" class="la lb lw lc b ld le ju lf lg lh jx li nl lk ll lm nm lo lp lq nn ls lt lu lv im bi translated"><strong class="lc iu"> LAG 的语法完全一样。LAG 中的&lt;偏移量&gt;指向相对于当前行的前几行。</strong></p></blockquote><p id="cfb3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">假设我们必须找出部门 10 先前较低的薪水和下一个较高的薪水，查询将是:</p><pre class="kk kl km kn gt me mf mg mh aw mi bi"><span id="4b3c" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">SELECT <br/>ename,<br/>sal,<br/>lead(sal,1,0) over(partition by deptno order by sal desc) next_low_sal,<br/>lag(sal,1,0) over(partition by deptno order by sal desc) prev_high_sal<br/>FROM emp<br/> where deptno=10</strong></span></pre><p id="5543" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">结果是:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/cc2a3ffb2fea1078dfda7282b676ff4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*EMvLE8BAwPFfIWYjwCO7Yg.png"/></div></figure><p id="ddeb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">e .</strong>T20】第一个值和最后一个值</p><p id="0a4d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在由 partition 和 order by 子句定义的记录集下，如果我们必须选取第一条记录，可以使用 FIRST_VALUE 函数。同样，在由 partition 和 order by 子句定义的记录集下，如果我们必须挑选最后一条记录，可以使用 LAST_VALUE 函数。比方说，如果我们必须找出部门 10 的每个雇员的第一次雇用和当前雇用日期之间的天数，则查询可以写成如下形式:</p><pre class="kk kl km kn gt me mf mg mh aw mi bi"><span id="7c3a" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">SELECT <br/>ename,<br/>sal,<br/>hiredate-first_value(hiredate) over(order by hiredate) no_of_days<br/>FROM emp<br/>where deptno=10</strong></span></pre><p id="02d1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">结果是:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/9bc1adeeff0266cc21927642ebf1a756.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*OGZCg6RcwygjBs9QnDfqNw.png"/></div></figure><h1 id="856b" class="mq mk it bd mr ms ns mu mv mw nt my mz jz nu ka nb kc nv kd nd kf nw kg nf ng bi translated">窗口条款</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ol"><img src="../Images/b0b74746bccbca70f0d748d4321090ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yVyRJBckuUmap-Mc"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@mooo3721?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> R 莫</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="78e8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">partition 子句不是限制分析函数范围的唯一方法。我们可以使用“ROWS BETWEEN”或“RANGE BETWEEN”子句来定义一个额外的范围。</p><p id="b392" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><window_clause>的一般语法是&lt; start_expr &gt;和&lt;end _ expr&gt;T29】之间的<br/>T28【行或范围】</window_clause></p><p id="32b5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> &lt; start_expr &gt; </strong>可以是以下任意一个<br/>无界 PECEDING <br/>当前行<br/> &lt; sql_expr &gt;之前或之后。</p><p id="07b1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> &lt; end_expr &gt; </strong>可以是以下任意一个<br/>无界跟随或<br/>当前行或<br/> &lt; sql_expr &gt;之前或之后。</p><p id="3484" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们编写一个查询，给出前几行相对于当前行的最高工资。</p><pre class="kk kl km kn gt me mf mg mh aw mi bi"><span id="7deb" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">SELECT <br/>ename,<br/>hiredate,<br/>sal,<br/>max(sal) over(order by hiredate,ename <br/> ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING) max_before_sal<br/>FROM emp</strong></span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi om"><img src="../Images/a8e87930c1677b54b0ff4dc0363ff752.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*J2yborgVIPQF3mvIP_6Uvw.png"/></div></figure><p id="804d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，对于每一行，返回当前行之前的最高工资。这里的 ORDER BY 子句不用于排序，而是用于指定窗口。无界在前是最低的可能界限，即第一行。</p><p id="9ca4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">检索当前行之前或之后的行，n 在前或 n 在后，其中 n 是相对于当前行的位置。在我们的例子中，n 是 1。</p><p id="3bb5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">范围与行非常相似，但范围中的间隔不是行数。它们代表一定范围的值，可以是数字或日期值。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="4ed8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Oracle 的分析功能是非常强大的工具，可以在多个维度上汇总和分析数据。执行速度也比普通的聚合函数快得多。对于 Oracle 开发人员来说，了解这些功能无疑是额外的收获。</p></div></div>    
</body>
</html>