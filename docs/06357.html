<html>
<head>
<title>How to pick the RIGHT model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何挑选合适的型号</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-simple-way-to-pick-the-right-model-d362272b453d?source=collection_archive---------32-----------------------#2020-05-21">https://towardsdatascience.com/a-simple-way-to-pick-the-right-model-d362272b453d?source=collection_archive---------32-----------------------#2020-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="96bc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从精确度分布来看，IQR和箱线图是选择最佳模型的一种方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87c2ea17db2dad77fd56c961335d691c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pP1pLzS-rC3AqiAv4mH7A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/466ENaLuhLY" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="a236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数据科学中，发现自己有几个表现几乎相同的模型/方法并不少见。当这种情况发生时，您如何知道选择哪个模型呢？在本文中，我将介绍一种选择最佳模型的方法，即真实模型。</p><p id="6990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用乳腺癌威斯康星州数据集，可在这里:【https://www.kaggle.com/uciml/breast-cancer-wisconsin-data】T2。它包含569个观察值和32个描述性变量。因变量诊断是二元的。如果癌症是恶性的，它等于1，如果癌症是良性的，它等于0。让我们从导入所需的包和数据开始。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7ecb" class="ma mb it lw b gy mc md l me mf">library(ggplot2)<br/>library(randomForest)<br/>library (e1071)<br/>library(devtools)<br/>library(ggbiplot)</span><span id="4fdf" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Import data<br/></strong>df = read.csv("data.csv")</span></pre><p id="a53f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，快速地，让我们清理数据(有些列是空的或无用的)，将诊断变量转换为[0，1]变量，而不是字符串。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b07e" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Y as factor<br/></strong>df$diagnosis =  ifelse(df$diagnosis=="M", gsub("M", 1,                                                            df$diagnosis), gsub("B", 0, df$diagnosis))<strong class="lw iu"><br/></strong>df$diagnosis = as.factor(df$diagnosis)</span><span id="bcec" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Remove useless columns<br/></strong>df = df[,c(-33,-1)]</span></pre><p id="60e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因变量的分布:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/a5e2a4f0a4b298b2fb3d5978571ebddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*Fm3GDh1bH22sbkK-LF43rw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">诊断分布</p></figure><p id="d028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些课程看起来并不不平衡。我们现在可以进入下一步了。下面，我将创建一个“for循环”。在循环的每次迭代中，我会将数据分成两组，训练和验证。之后，我将使用随机森林、SVM和逻辑回归来训练和预测三个独立的模型。通过将所有这些放入一个“for循环”并每次改变种子，它将允许我每次收集三个模型在每次迭代中的精度性能。更改set.seed()会更改训练和验证之间数据的随机重新分配。</p><p id="67ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实质上是同时在三个模型上进行交叉验证。这也是有益的，因为它允许我每次都在相同的数据集上比较模型。对于每次迭代，每个模型都在相同的数据上进行训练和验证。这意味着我们可以在每个拟合模型之间进行公平和一致的比较。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="e704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是三个模型在200次迭代中的平均精确度:</p><ol class=""><li id="d624" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">随机森林:96.7%</li><li id="c924" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">SVM: 95.1%</li><li id="0135" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">逻辑回归分析:97.1%</li></ol><p id="a123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">逻辑回归似乎是该数据集的最佳算法。然而，要选择正确的模式，我们不能止步于此。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="1aed" class="ma mb it bd nf ng nh dn ni nj nk dp nl li nm nn no lm np nq nr lq ns nt nu nv bi translated">选择正确的模型</h2><p id="9fba" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">查看上面的结果，我们看到逻辑回归胜出，但其准确性与其他模型准确性的差异并不显著。为了知道我们是否真的有最好的模型，我们需要查看准确性度量的分布。这类似于<strong class="lb iu">边际解释vs条件解释</strong>的思想:无论数据如何，模型平均来说是好的还是总是表现良好。</p><p id="39b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很有用，因为它让我们知道模型是否总是精确的，或者它们的性能是否是可变的。根据具体情况，我们可能需要最佳平均模型或最小变量模型。拥有准确的分布信息只会有助于做出一致的选择！</p><p id="e5d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是如何使用密度函数获得存储在result_matrix中的分布图:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f6f7" class="ma mb it lw b gy mc md l me mf">a=density(result_matrix[,1])</span><span id="1326" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Getting the plot<br/></strong>plot(a, xlim=c(0.92, 1), ylim=c(0, 60), col='blue', lwd=2, main='Accuracy distribution of all models',<br/>     xlab='Accuracy')<br/>lines(density(result_matrix[,2]), col='red', lwd=2)<br/>lines(density(result_matrix[,3]), col='green', lwd=2)<br/>legend(x=0.975, y=59,legend = c("Random Forest", "SVM", "Logistic Regression"), col = c("blue","red", 'green'), lty = c(1,1))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/b1376c5417b976c36d635635cc4f9e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-IQmZ3nYnPA9SoPpGt36Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">三种模型的精度分布</p></figure><p id="6e66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，逻辑回归似乎确实比随机森林好得多，即使两种精度分布都非常对称地分布在它们的平均值附近(逻辑回归似乎稍微瘦一些)。事实上，这两种分布看起来都很正常。然而，SVM分布似乎更易变，传播范围更大，几乎第二次达到约95%的准确性。</p><p id="72d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以获得箱线图和分位数间范围，这将让我们看到我们是否有异常值(使用箱线图)，以及在我们的准确度值中第一和第三分位数之间的范围有多窄(使用IQR)。下面是如何做到这一点:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2465" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Boxplots<br/></strong>boxplot(result_matrix, use.cols = TRUE, <br/>       main='Boxplot by algorithm', <br/>       ylab='Accuracy', xaxt = "n", col=c('blue', 'red', 'green'))<br/>axis(1, at=1:3, labels=c('Random Forests', 'SVM', 'Logistic           Regression'))</span><span id="a002" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#IQR<br/></strong>IQR(result_matrix[,1])<br/>IQR(result_matrix[,2])<br/>IQR(result_matrix[,3])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/fe88bc3ffa2c764ffef04fe935dd5cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*--bcRfM8VQK3esQ5J0Z8Eg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">三种模型的箱线图</p></figure><p id="1190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是三种算法的iqr:</p><ol class=""><li id="e276" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">随机森林:1.05</li><li id="65cb" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">SVM: 1.4</li><li id="2a9d" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">逻辑回归:1.05</li></ol><p id="ce80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着对于随机森林和逻辑回归，50%的值(在第一个和第三个分位数之间)在1.05%的精确度范围内。对于SVM来说，IQR更宽一些，为1.4%。</p><p id="4fa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看箱线图，我们看到的是，对于所有三种方法，我们只有很少的异常值(1或2)。逻辑回归只有1，而随机森林有2。</p><p id="8ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我相信我们可以客观地说，逻辑回归算法是在我们的情况下使用的最佳算法，我们有数据来证明这一点。</p><p id="e9cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>