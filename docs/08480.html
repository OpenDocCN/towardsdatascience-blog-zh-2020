<html>
<head>
<title>Indexing and Slicing of 1D, 2D, and 3D Arrays in Numpy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Numpy中1D、2D和3D阵列的索引和切片</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/indexing-and-slicing-of-1d-2d-and-3d-arrays-in-numpy-e731afff0bbe?source=collection_archive---------11-----------------------#2020-06-20">https://towardsdatascience.com/indexing-and-slicing-of-1d-2d-and-3d-arrays-in-numpy-e731afff0bbe?source=collection_archive---------11-----------------------#2020-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9556" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">本文展示了Numpy数组从基本到高级的索引和切片。</h2></div><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">来源:作者</p></figure><p id="a016" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">数组索引和切片是数据分析和许多不同类型的数学运算的重要部分。我们并不总是使用整个数组、矩阵或数据帧。当我们处理数组的子集时，数组索引和切片是最重要的。本文将从基础知识开始，最终将解释1D、2D和3D阵列的切片和索引的一些先进技术。即使您以前已经使用过数组切片和索引，您也可以在本文中找到一些可以学习的东西。</p><p id="3e63" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu"> 1D阵列切片标引</strong></p><p id="b2d9" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在笔记本中导入Numpy，并生成一维数组。在这里，我使用的是Jupyter笔记本。您可以使用您选择的任何其他笔记本电脑。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="1ebd" class="lu lv it lq b gy lw lx l ly lz">import numpy as np</span><span id="8e8c" class="lu lv it lq b gy ma lx l ly lz">x = np.array([2,5,1,9,0,3,8,11,-4,-3,-8,6,10])</span></pre><p id="8a2e" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">基础标引</strong></p><p id="c666" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们做一些简单的切片。提醒一下，数组是零索引的，所以计数从零开始。x[0]将返回数组的第一个元素，x[1]将返回数组的第二个元素。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="6947" class="lu lv it lq b gy lw lx l ly lz">x[0]</span><span id="b900" class="lu lv it lq b gy ma lx l ly lz">#output: 2</span><span id="535c" class="lu lv it lq b gy ma lx l ly lz">x[3]</span><span id="a9f1" class="lu lv it lq b gy ma lx l ly lz">#output: 9</span><span id="23ae" class="lu lv it lq b gy ma lx l ly lz">x[4]</span><span id="a2cf" class="lu lv it lq b gy ma lx l ly lz">#output: 0</span></pre><p id="4e63" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">基础切片</strong></p><p id="a136" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在转到一维数组的切片操作，</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="48d1" class="lu lv it lq b gy lw lx l ly lz">x[1:7]</span><span id="0538" class="lu lv it lq b gy ma lx l ly lz">#output: array([5, 1, 9, 0, 3, 8])</span></pre><p id="8d27" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里1是下限，7是上限。输出数组从索引1的元素开始，到索引7之前结束。换句话说，它包括索引1中的元素，但不包括索引7中的元素。</p><p id="fcc0" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">间隔切片</strong></p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="e220" class="lu lv it lq b gy lw lx l ly lz">x[2::3]</span><span id="dda1" class="lu lv it lq b gy ma lx l ly lz">#output: array([ 1, 3, -4, 6])</span></pre><p id="d437" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这种情况下，2是起始索引，3是间隔。所以返回的数组从索引二处的元素开始。之后，它会占据数组的每三个元素，直到结束。</p><p id="9dbd" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">说吧，我们不需要等到最后。我们只想输出到-4。在这种情况下，我们可以进一步对其进行切片。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="a66a" class="lu lv it lq b gy lw lx l ly lz">x[2::3][0:3]<br/>#output: array([ 1, 3, -4])</span></pre><p id="5710" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">默认开始和结束</strong></p><p id="1caa" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">接下来，我将展示一个最常用的语法。x[0:4]用于返回前四个元素，对吗？相反，x[:4]可以用来做同样的事情。因为如果我们不定义任何下限，默认情况下它会从头开始。同样，如果我们不提到任何上限，它会一直输出到最后。当我们没有提到上限和下限时，我们得到整个数组作为输出。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="472e" class="lu lv it lq b gy lw lx l ly lz">x[:4]</span><span id="0df7" class="lu lv it lq b gy ma lx l ly lz">#output: array([2, 5, 1, 9])</span><span id="0d21" class="lu lv it lq b gy ma lx l ly lz">x[3:]</span><span id="a08b" class="lu lv it lq b gy ma lx l ly lz">#output: array([ 9, 0, 3, 8, 11, -4, -3, -8, 6, 10])</span><span id="934c" class="lu lv it lq b gy ma lx l ly lz">x[:]<br/>#output: array([2,5,1,9,0,3,8,11,-4,-3,-8,6,10])</span></pre><p id="19fb" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">带区间及上下限值切片</strong></p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="9700" class="lu lv it lq b gy lw lx l ly lz">x[1:7:2]</span><span id="10f5" class="lu lv it lq b gy ma lx l ly lz">#output: array([5, 9, 3])</span></pre><p id="e82c" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在x[1:7:2]中，1是下限，7是上限，间隔中为2。输出从索引1处的元素开始，到索引7处结束，但不是输出中间的每个元素，而是每隔一个元素输出一次。因为间隔是2。</p><p id="c299" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">从有间隔的结束开始</strong></p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="18c6" class="lu lv it lq b gy lw lx l ly lz">x[-7::2]</span><span id="31d1" class="lu lv it lq b gy ma lx l ly lz">#output: array([ 8, -4, -8, 10])</span></pre><p id="61ae" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里，-7表示从末尾开始的第七个元素，2表示间隔。输出从底部的第七个元素开始，向上移动直到结束。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="105c" class="lu lv it lq b gy lw lx l ly lz">x[-7::-2]</span><span id="3cc6" class="lu lv it lq b gy ma lx l ly lz">#output: array([8, 0, 1, 2])</span></pre><p id="6298" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu"> 2D阵列切片标引</strong></p><p id="ba8f" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在我们将使用一个二维数组进行同样的练习。我为这个视频做了一个6×7的矩阵。因为它足够大，可以显示一些有意义的操作。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="0245" class="lu lv it lq b gy lw lx l ly lz">y = np.arange(42).reshape(6,7)</span><span id="4250" class="lu lv it lq b gy ma lx l ly lz">#array y comes out to be:<br/>array([[ 0,  1,  2,  3,  4,  5,  6],        <br/>       [ 7,  8,  9, 10, 11, 12, 13],        <br/>       [14, 15, 16, 17, 18, 19, 20],        <br/>       [21, 22, 23, 24, 25, 26, 27],        <br/>       [28, 29, 30, 31, 32, 33, 34],        <br/>       [35, 36, 37, 38, 39, 40, 41]])</span></pre><p id="5787" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">输出行</strong></p><p id="36c9" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最简单的方法是从二维数组中返回行。只需通过行数进行索引。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="df36" class="lu lv it lq b gy lw lx l ly lz">y[0]<br/>#output: array([0, 1, 2, 3, 4, 5, 6])</span><span id="37fa" class="lu lv it lq b gy ma lx l ly lz">y[3]<br/>#output: array([ 7,  8,  9, 10, 11, 12, 13])</span></pre><p id="6a4d" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">输出列</strong></p><p id="2f13" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">返回列可能有点棘手。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="24f6" class="lu lv it lq b gy lw lx l ly lz">y[:, 0]<br/>#output: array([ 0,  7, 14, 21, 28, 35])</span><span id="a7aa" class="lu lv it lq b gy ma lx l ly lz">y[:, 3]<br/>#output: array([ 3, 10, 17, 24, 31, 38])</span></pre><p id="6acc" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">只输出一个元素</strong></p><p id="6ec0" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们看看如何从矩阵中返回一个数字。从这个矩阵中返回数字17。从查找行开始。这是在第三行，这意味着该行的索引是2，因为计数从0开始。接下来看看列索引。17号在第四列。所以，列索引是3。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="1c3b" class="lu lv it lq b gy lw lx l ly lz">y[2, 3]<br/>#output: 17</span></pre><p id="d162" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">返回第二列的前三个元素，作为图中的粗体数字</strong></p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/29b075d1c0f58ad370d2b21499a03c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*zSv2ZB4OK0ByrrMjRtUrEw.png"/></div></figure><p id="3995" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所有元素都在第1、2和3行。行索引是0:3。下一步是计算列索引。所有三个元素都在第二列。也就是列索引1。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="0813" class="lu lv it lq b gy lw lx l ly lz">y[0:3, 1]<br/>#output: array([ 1,  8, 15])</span></pre><p id="e629" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">将下面矩阵中前两列的部分元素输出为下面的粗体数字</strong></p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi me"><img src="../Images/43709515a687a0a347ee87eb11bd2adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*4iknqqQ-TzOZELYiM_ql6Q.png"/></div></figure><p id="81a0" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所有元素都在第1、2和3行。行索引是1:4。相应的列索引是0和1。因此，列索引可以表示为0:2</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="4a31" class="lu lv it lq b gy lw lx l ly lz">y[1:4, 0:2]</span><span id="4ab8" class="lu lv it lq b gy ma lx l ly lz">#output:<br/>array([[ 7,  8],<br/>       [14, 15],<br/>       [21, 22]])</span></pre><p id="79ff" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">从矩阵</strong>中输出这个三乘三子阵列(矩阵中的红色粗体元素)</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/4ddf4fb8262265074baeac2548807418.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*1eMzAj7Bo2Kc_E-jqfhw5g.png"/></div></figure><p id="f6ca" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">解决这个问题的方法和之前的理论是一样的。数字的行索引是2、3和4。所以我们可以把它切成2:5。列索引也是2、3和4。一片列也可以被2:5所占据。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="fecb" class="lu lv it lq b gy lw lx l ly lz">y[2:5, 2:5]</span><span id="4548" class="lu lv it lq b gy ma lx l ly lz">#output<br/>array([[16, 17, 18],<br/>       [23, 24, 25],<br/>       [30, 31, 32]])</span></pre><p id="a00d" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">从第一行开始每隔一行打印一次</strong></p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/52eb68c695c5660ed8e2e69932961704.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*M_sekvbxe9plr2ln1j_IUA.png"/></div></figure><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="8785" class="lu lv it lq b gy lw lx l ly lz">y[0::2]</span><span id="de61" class="lu lv it lq b gy ma lx l ly lz">#output:<br/>array([[ 0,  1,  2,  3,  4,  5,  6],<br/>       [14, 15, 16, 17, 18, 19, 20],<br/>       [28, 29, 30, 31, 32, 33, 34]])</span></pre><p id="6690" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里，0是下限，2是区间。输出数组将从索引0开始，以2为间隔一直持续到结尾。</p><p id="824e" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">从第一列开始每隔一列打印。</strong></p><p id="4eeb" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在下面的代码中，':'意味着选择所有的索引。这里':'是选择所有的行。作为列输入，我们把0::2。我已经在上面提到了它的功能。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="24dd" class="lu lv it lq b gy lw lx l ly lz">y[:, 0::2]</span><span id="3086" class="lu lv it lq b gy ma lx l ly lz">#output:<br/>array([[ 0,  2,  4,  6],<br/>       [ 7,  9, 11, 13],<br/>       [14, 16, 18, 20],<br/>       [21, 23, 25, 27],<br/>       [28, 30, 32, 34],<br/>       [35, 37, 39, 41]])</span></pre><p id="390a" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这是做同样事情的另一种方法。在下面的代码中，0是下限，7是上限，2是区间。下面的代码片段将输出与上面相同的矩阵。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="c6da" class="lu lv it lq b gy lw lx l ly lz">y[:, 0:7:2]</span></pre><h2 id="006d" class="lu lv it bd mh mi mj dn mk ml mm dp mn lc mo mp mq lg mr ms mt lk mu mv mw mx bi translated">3D数组切片和索引</h2><p id="771f" class="pw-post-body-paragraph kt ku it kv b kw my ju ky kz mz jx lb lc na le lf lg nb li lj lk nc lm ln lo im bi translated">用下面这段代码做一个三维数组。在这里，它将从0到44的数字排列成三个形状为3×5的二维数组。输出将如下所示。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="91b3" class="lu lv it lq b gy lw lx l ly lz">x = np.arange(45).reshape(3,3,5)</span><span id="9af9" class="lu lv it lq b gy ma lx l ly lz">#output:<br/>array([[[ 0,  1,  2,  3,  4],<br/>        [ 5,  6,  7,  8,  9],<br/>        [10, 11, 12, 13, 14]],</span><span id="915e" class="lu lv it lq b gy ma lx l ly lz">[[15, 16, 17, 18, 19],<br/>        [20, 21, 22, 23, 24],<br/>        [25, 26, 27, 28, 29]],</span><span id="6dc8" class="lu lv it lq b gy ma lx l ly lz">[[30, 31, 32, 33, 34],<br/>        [35, 36, 37, 38, 39],<br/>        [40, 41, 42, 43, 44]]])</span></pre><p id="dceb" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">选择二维数组</strong></p><p id="b511" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们可以通过简单的索引来访问其中的每个二维数组，如下所示:</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="8af6" class="lu lv it lq b gy lw lx l ly lz">x[0]</span><span id="51f2" class="lu lv it lq b gy ma lx l ly lz">#output:<br/>array([[ 0,  1,  2,  3,  4],<br/>       [ 5,  6,  7,  8,  9],<br/>       [10, 11, 12, 13, 14]])</span><span id="4b3c" class="lu lv it lq b gy ma lx l ly lz">x[1]</span><span id="7c13" class="lu lv it lq b gy ma lx l ly lz">#output:<br/>array([[15, 16, 17, 18, 19],<br/>       [20, 21, 22, 23, 24],<br/>       [25, 26, 27, 28, 29]])</span></pre><p id="4d92" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">打印第一个二维数组的第二行</strong></p><p id="db43" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">选择第一个二维数组，就像我们之前用代码x[0]展示的那样。然后加上这个来选择第二行:x[0][1]</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="41a1" class="lu lv it lq b gy lw lx l ly lz">x[0][1]</span><span id="b728" class="lu lv it lq b gy ma lx l ly lz">#output:<br/>array([5, 6, 7, 8, 9])</span></pre><p id="6bdb" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">从数组中获取22号元素</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/1dfd6e023e2e5dcc44176055280192fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*MoFskRAGIc98c9lumgkbUg.png"/></div></figure><p id="0008" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我将分几步解决这个问题。</p><p id="a85b" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">选择元素22所在的二维数组。这是第二个二维数组。所以用x[1]来选择。</p><p id="4adf" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">接下来，看看行索引在哪里。我们的目标元素位于所选二维数组的第二行。行索引为1。我们可以选择代码为x[1][1]的行。</p><p id="cad1" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最后，列索引是2，因为从上图可以看出它是第三个元素。组合:</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="10a7" class="lu lv it lq b gy lw lx l ly lz">x[1][1][2]</span><span id="6018" class="lu lv it lq b gy ma lx l ly lz">#output: 22</span></pre><p id="7263" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">返回最后两个二维数组的第一行</strong></p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/64289c8466ddb186f58ca0f41e58aac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*hED29kJDGW4U4jc-HeqmrA.png"/></div></figure><p id="836c" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">首先，选择这些行所属的二维数组。一行在第二个二维数组中，另一行在第三个二维数组中。我们可以用x[1:]选择这两个。因为这两行都是其对应的二维数组的第一行，所以行索引为零。</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="e28d" class="lu lv it lq b gy lw lx l ly lz">x[1:, 0]</span><span id="7901" class="lu lv it lq b gy ma lx l ly lz">#output: <br/>array([[15, 16, 17, 18, 19],<br/>       [30, 31, 32, 33, 34]])</span></pre><p id="d700" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv iu">切割列和行，打印最后两个二维数组的前两行的一部分，如图中红色粗体的数字</strong></p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/ff2ebdaabdabb1914397c89fa54eebd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*84hk9VKBYdefpjdtvAACXg.png"/></div></figure><p id="fbdc" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">和前面的问题一样，所有的目标元素都在第二个和第三个二维数组中。所以，我们可以像以前一样用x[1:]选择它们。所有元素都在两个二维数组的第一行和第二行。行索引应该表示为0:2。列索引是1:4，因为元素在第一、第二和第三列中。将所有这些结合在一起:</p><pre class="ki kj kk kl gt lp lq lr ls aw lt bi"><span id="5584" class="lu lv it lq b gy lw lx l ly lz">x[1:, 0:2, 1:4]</span><span id="d7bf" class="lu lv it lq b gy ma lx l ly lz">#output:<br/>array([[[16, 17, 18],<br/>        [21, 22, 23]],</span><span id="52bb" class="lu lv it lq b gy ma lx l ly lz">[[31, 32, 33],<br/>        [36, 37, 38]]])</span></pre><p id="908c" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我想制作一个视频，记录1D、2D和3D数组的切片和索引，使矩阵或多维数组索引更容易。我希望这有所帮助。</p><p id="b0cf" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一些推荐的阅读材料:</p><p id="d139" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><a class="ae ng" rel="noopener" target="_blank" href="/factors-that-can-contribute-to-the-faulty-statistical-inference-a7ebedd5a343">可能导致错误统计推断的因素</a></p><p id="86f2" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><a class="ae ng" href="https://medium.com/swlh/data-analysis-with-pivot-table-in-pandas-ac0b944cd7bc" rel="noopener">熊猫数据透视表数据分析</a></p><p id="7fa4" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><a class="ae ng" rel="noopener" target="_blank" href="/lambda-map-filter-and-sorted-efficient-programming-with-python-15d45bc1912a">λ、映射、过滤和排序Python中的高效编程</a></p><p id="944a" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><a class="ae ng" rel="noopener" target="_blank" href="/import-csv-files-as-pandas-dataframe-with-skiprows-skipfooter-usecols-index-col-and-header-fbf67a2f92a">使用skiprows、skipfooter、使用cols、index_col和header选项将CSV文件导入为Pandas data frame</a></p></div></div>    
</body>
</html>