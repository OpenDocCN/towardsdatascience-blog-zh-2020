<html>
<head>
<title>An efficient way to install and load R packages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种安装和加载R包的有效方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-efficient-way-to-install-and-load-r-packages-bc53247f058d?source=collection_archive---------25-----------------------#2020-01-31">https://towardsdatascience.com/an-efficient-way-to-install-and-load-r-packages-bc53247f058d?source=collection_archive---------25-----------------------#2020-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cac728e88e246fe59075fb5e54e9caee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6wKnVe1op_A5stKw"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@purzlbaum?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克劳迪奥·施瓦茨</a>拍摄</p></figure><h1 id="825b" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">什么是R包，如何使用？</h1><p id="b3c3" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi mc translated">与其他程序一样，r默认只提供基本功能。因此，您经常需要安装一些“扩展”来执行您想要的分析。这些扩展是由R用户开发和发布的函数和数据集的集合，称为<strong class="lg iu">包</strong>。它们通过添加新的功能来扩展现有的base R功能。r是开源的，所以每个人都可以编写代码并将其发布为一个包，每个人都可以安装一个包并开始使用包中内置的函数或数据集，所有这些都是免费的。</p><p id="a73d" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated">为了使用一个包，需要通过运行<code class="fe mq mr ms mt b">install.packages("name_of_package")</code>将它安装在你的计算机上(不要忘记在包的名字周围加上<code class="fe mq mr ms mt b">""</code>，否则，R会寻找以那个名字保存的对象！).安装软件包后，您必须加载软件包，只有在加载后，您才能使用它包含的所有函数和数据集。要加载一个包，运行<code class="fe mq mr ms mt b">library(name_of_package)</code>(这一次包名两边的<code class="fe mq mr ms mt b">""</code>是可选的，但是如果你愿意，仍然可以使用)。</p><h1 id="17cc" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">安装和加载R包的低效方法</h1><p id="5d6c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">根据你使用R的时间长短，你可能会使用有限数量的软件包，或者相反，使用大量的软件包。随着你使用越来越多的软件包，你很快就会开始有(太多)多行代码来安装和加载它们。</p><p id="7060" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated">下面是我博士论文中的代码预览，展示了当我开始研究R时，R包的安装和加载是什么样子的(为了缩短代码，只显示了一小部分):</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="64ce" class="nc kh it mt b gy nd ne l nf ng"># Installation of required packages<br/>install.packages("tidyverse")<br/>install.packages("ggplot2")<br/>install.packages("readxl")<br/>install.packages("dplyr")<br/>install.packages("tidyr")<br/>install.packages("ggfortify")<br/>install.packages("DT")<br/>install.packages("reshape2")<br/>install.packages("knitr")<br/>install.packages("lubridate")</span><span id="5b60" class="nc kh it mt b gy nh ne l nf ng"># Load packages<br/>library("tidyverse")<br/>library("ggplot2")<br/>library("readxl")<br/>library("dplyr")<br/>library("tidyr")<br/>library("ggfortify")<br/>library("DT")<br/>library("reshape2")<br/>library("knitr")<br/>library("lubridate")</span></pre><p id="c9dd" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated">你可以猜到，随着我需要越来越多的分析包，代码变得越来越长。此外，我倾向于重新安装所有的软件包，因为我在4台不同的计算机上工作，我不记得哪个软件包已经安装在哪个机器上了。每次打开我的脚本或R Markdown文档时重新安装所有的包都是浪费时间。</p><h1 id="c97b" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">更有效的方法</h1><p id="664f" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">后来有一天，我的一个同事跟我分享了他的一些代码。我很高兴他这样做了，因为他向我介绍了一种更有效的安装和加载R包的方法。他允许我分享这个技巧，所以下面是我现在用来执行安装和加载R包任务的代码:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="35c5" class="nc kh it mt b gy nd ne l nf ng"># Package names<br/>packages &lt;- c("ggplot2", "readxl", "dplyr", "tidyr", "ggfortify", "DT", "reshape2", "knitr", "lubridate", "pwr", "psy", "car", "doBy", "imputeMissings", "RcmdrMisc", "questionr", "vcd", "multcomp", "KappaGUI", "rcompanion", "FactoMineR", "factoextra", "corrplot", "ltm", "goeveg", "corrplot", "FSA", "MASS", "scales", "nlme", "psych", "ordinal", "lmtest", "ggpubr", "dslabs", "stringr", "assist", "ggstatsplot", "forcats", "styler", "remedy", "snakecaser", "addinslist", "esquisse", "here", "summarytools", "magrittr", "tidyverse", "funModeling", "pander", "cluster", "abind")</span><span id="e738" class="nc kh it mt b gy nh ne l nf ng"># Install packages not yet installed<br/>installed_packages &lt;- packages %in% rownames(installed.packages())<br/>if (any(installed_packages == FALSE)) {<br/>  install.packages(packages[!installed_packages])<br/>}</span><span id="0958" class="nc kh it mt b gy nh ne l nf ng"># Packages loading<br/>invisible(lapply(packages, library, character.only = TRUE))</span></pre><p id="fa94" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated">这段安装和加载R包的代码在几个方面更有效:</p><ol class=""><li id="0a8d" class="ni nj it lg b lh ml ll mm lp nk lt nl lx nm mb nn no np nq bi translated">函数<code class="fe mq mr ms mt b">install.packages()</code>接受一个向量作为参数，所以过去每个包的一行代码现在变成了包含所有包的一行代码</li><li id="ae0a" class="ni nj it lg b lh nr ll ns lp nt lt nu lx nv mb nn no np nq bi translated">在代码的第二部分，它检查一个包是否已经安装，然后只安装缺少的包</li><li id="95fb" class="ni nj it lg b lh nr ll ns lp nt lt nu lx nv mb nn no np nq bi translated">关于包的加载(代码的最后一部分)，使用<code class="fe mq mr ms mt b">lapply()</code>函数一次性调用所有包的<code class="fe mq mr ms mt b">library()</code>函数，这使得代码更加简洁。</li><li id="6025" class="ni nj it lg b lh nr ll ns lp nt lt nu lx nv mb nn no np nq bi translated">加载包时的输出很少有用。<code class="fe mq mr ms mt b">invisible()</code>功能删除该输出。</li></ol><p id="7a15" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated">从那天起，每当我需要使用一个新的包时，我简单地把它添加到代码顶部的向量<code class="fe mq mr ms mt b">packages</code>，它位于我的脚本和R Markdown文档的顶部。无论我在哪台计算机上工作，运行整个代码都将只安装缺失的包并加载所有的包。这大大减少了安装和加载我的R包的运行时间。</p><h1 id="cc36" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">最有效的方法</h1><h1 id="df14" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><code class="fe mq mr ms mt b">{pacman}</code>包装</h1><p id="0f9b" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这篇文章发表后，有读者通知我关于<code class="fe mq mr ms mt b">{pacman}</code>包的事情。在阅读了文档并亲自试用之后，我了解到<code class="fe mq mr ms mt b">{pacman}</code>中的函数<code class="fe mq mr ms mt b">p_load()</code>会检查是否安装了某个包，如果没有，它会尝试安装该包，然后加载它。它还可以同时应用于多个包，所有这一切都以一种非常简洁的方式进行:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="6ef2" class="nc kh it mt b gy nd ne l nf ng">install.packages("pacman")</span><span id="f85b" class="nc kh it mt b gy nh ne l nf ng">pacman::p_load(ggplot2, tidyr, dplyr)</span></pre><p id="95ff" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated">在<a class="ae kf" href="https://cran.r-project.org/web/packages/pacman/index.html" rel="noopener ugc nofollow" target="_blank">曲柄</a>上找到更多关于此包装的信息。</p><h1 id="aa4b" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><code class="fe mq mr ms mt b">{librarian}</code>包装</h1><p id="7158" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">与<code class="fe mq mr ms mt b">{pacman}</code>一样，<code class="fe mq mr ms mt b">{librarian}</code>包中的<code class="fe mq mr ms mt b">shelf()</code>函数自动安装、更新和加载尚未安装在单个函数中的R包。该功能接受来自CRAN、GitHub和Bioconductor的软件包(仅当安装了Bioconductor的<code class="fe mq mr ms mt b">Biobase</code>软件包时)。该函数还接受多个包条目，以逗号分隔的未加引号的名称列表的形式提供(因此包名周围没有<code class="fe mq mr ms mt b">""</code>)。</p><p id="e7e8" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated">最后但同样重要的是，<code class="fe mq mr ms mt b">{librarian}</code>包允许在每个R会话开始时自动加载包(感谢<code class="fe mq mr ms mt b">lib_startup()</code>函数)，并通过关键字或正则表达式在CRAN上搜索新包(感谢<code class="fe mq mr ms mt b">browse_cran()</code>函数)。</p><p id="2d80" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated">下面是一个如何安装缺失的包并用<code class="fe mq mr ms mt b">shelf()</code>函数加载它们的例子:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="09ce" class="nc kh it mt b gy nd ne l nf ng"># From CRAN:<br/>install.packages("librarian")</span><span id="0d62" class="nc kh it mt b gy nh ne l nf ng">librarian::shelf(ggplot2, DesiQuintans/desiderata, pander)</span></pre><p id="2516" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated">对于CRAN包，提供不带<code class="fe mq mr ms mt b">""</code>的普通包名，对于GitHub包，提供用<code class="fe mq mr ms mt b">/</code>分隔的用户名和包名(即<code class="fe mq mr ms mt b">desiderata</code>包所示的<code class="fe mq mr ms mt b">UserName/RepoName</code>)。</p><p id="f95b" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated">在<a class="ae kf" href="https://cran.r-project.org/web/packages/librarian/index.html" rel="noopener ugc nofollow" target="_blank"> CRAN </a>上找到更多关于这个包的信息。</p><p id="2160" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated">感谢阅读。我希望这篇文章能帮助你以更有效的方式安装和加载R包。</p><p id="5a54" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated">和往常一样，如果您有与本文主题相关的问题或建议，请将其添加为评论，以便其他读者可以从讨论中受益。</p><p id="6d59" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated">特别感谢Danilo和James告诉我关于 <code class="fe mq mr ms mt b"><em class="nw">{pacman}</em></code> <em class="nw">和</em> <code class="fe mq mr ms mt b"><em class="nw">{librarian}</em></code> <em class="nw">包的信息。</em></p><p id="c457" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated"><strong class="lg iu">相关文章:</strong></p><ul class=""><li id="6f2f" class="ni nj it lg b lh ml ll mm lp nk lt nl lx nm mb nx no np nq bi translated">我的数据符合正态分布吗？关于最广泛使用的分布以及如何检验R中的正态性的注释</li><li id="c5ed" class="ni nj it lg b lh nr ll ns lp nt lt nu lx nv mb nx no np nq bi translated"><a class="ae kf" href="https://www.statsandr.com/blog/fisher-s-exact-test-in-r-independence-test-for-a-small-sample/" rel="noopener ugc nofollow" target="_blank">R中的Fisher精确检验:小样本的独立性检验</a></li><li id="5c5d" class="ni nj it lg b lh nr ll ns lp nt lt nu lx nv mb nx no np nq bi translated"><a class="ae kf" href="https://www.statsandr.com/blog/chi-square-test-of-independence-in-r/" rel="noopener ugc nofollow" target="_blank">R中独立性的卡方检验</a></li><li id="306d" class="ni nj it lg b lh nr ll ns lp nt lt nu lx nv mb nx no np nq bi translated"><a class="ae kf" href="https://www.statsandr.com/blog/how-to-create-a-timeline-of-your-cv-in-r/" rel="noopener ugc nofollow" target="_blank">如何在简历中创建简历时间线</a></li></ul></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="f6e2" class="pw-post-body-paragraph le lf it lg b lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb im bi translated"><em class="nw">原载于2020年1月31日</em><a class="ae kf" href="https://statsandr.com/blog/an-efficient-way-to-install-and-load-r-packages/" rel="noopener ugc nofollow" target="_blank"><em class="nw">https://statsandr.com</em></a><em class="nw">。</em></p></div></div>    
</body>
</html>