<html>
<head>
<title>Map, Filter And Reduce In Pure Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纯 Python 中的映射、过滤和归约</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/accelerate-your-python-list-handling-with-map-filter-and-reduce-d70941b19e52?source=collection_archive---------29-----------------------#2020-08-21">https://towardsdatascience.com/accelerate-your-python-list-handling-with-map-filter-and-reduce-d70941b19e52?source=collection_archive---------29-----------------------#2020-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="99f4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">map、filter 和 reduce 的概念改变了游戏规则。这些方法的使用远远超出了 Python 的范畴，是未来的一项基本技能。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e9d84c2d9e5511b5d1f77ed822a36e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DreeF8a4h2pvxRly39HjAA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">映射、过滤和缩小(图片由作者提供)</p></figure><h1 id="2b8b" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated"><strong class="ak">基础知识</strong></h1><p id="1324" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Map、filter 和 reduce 是帮助您处理各种集合的功能。它们是 Spark 和其他各种数据操作和存储框架等现代技术的核心。但是在使用 vanilla Python 时，它们也是非常强大的助手。</p><h1 id="194e" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">地图</h1><p id="affa" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Map 是一个函数，它将一个集合(如列表['bacon '，' toast '，' egg'])和一个函数(如 upper())作为输入。然后，它将通过这个函数移动集合中的每个元素，并生成一个具有相同元素计数的新集合。让我们看一个例子</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="fa71" class="mr kz it mn b gy ms mt l mu mv">map_obj = map(str.upper,['bacon','toast','egg'])<br/>print(list(map_obj))<br/>&gt;&gt;['BACON', 'TOAST', 'EGG']</span></pre><p id="40a3" class="pw-post-body-paragraph lq lr it ls b lt mw ju lv lw mx jx ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">我们在这里所做的是使用 map(some_function，some_iterable)函数结合 upper 函数(该函数将字符串中的每个字符大写)。正如我们所看到的，我们为输入列表中的每个元素生成了输出列表中的另一个元素。我们在输出中得到的元素总是和我们将要输入的一样多！这里我们发送 3 个输入，接收 3 个输出，这就是为什么我们称它为 N 对 N 函数。让我们看看如何使用它。</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="3f95" class="mr kz it mn b gy ms mt l mu mv">def count_letters(x):<br/>    return len(list(x))</span><span id="e7f5" class="mr kz it mn b gy nb mt l mu mv">map_obj = <strong class="mn iu">map</strong>(count_letters,['bacon','toast','egg'])<br/>print(list(map_obj))<br/>&gt;&gt;[6, 5, 3]</span></pre><p id="3c66" class="pw-post-body-paragraph lq lr it ls b lt mw ju lv lw mx jx ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">在这个例子中，我们定义了自己的函数 count_letters()。集合通过函数传递，在输出中，我们有每个字符串的字母数！让我们用一个 lambda 表达式让它更性感一点。</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="c678" class="mr kz it mn b gy ms mt l mu mv">map_obj = <strong class="mn iu">map</strong>(lambda x:len(list(x)),['bacon','toast','egg'])<br/>print(list(map_obj))<br/>&gt;&gt;[6, 5, 3]</span></pre><p id="e7e1" class="pw-post-body-paragraph lq lr it ls b lt mw ju lv lw mx jx ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">lambda 表达式基本上只是一种定义函数的简写符号。如果你不熟悉它们，你可以在这里查看它们是如何工作的<a class="ae nc" href="https://realpython.com/python-lambda/" rel="noopener ugc nofollow" target="_blank"/>。然而，通过下面的例子应该很容易理解它们是如何工作的。</p><h1 id="d700" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">过滤器</h1><p id="8629" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">与映射相反，映射是一个 N 到 N 的函数。Filter 是一个 N 到 M 的函数，其中 N≥M。这意味着它减少了集合中的元素数量。换句话说，它过滤它们！与 map 一样，符号也是 filter(some_function，some_collection)。让我们用一个例子来验证这一点。</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="e842" class="mr kz it mn b gy ms mt l mu mv">def has_the_letter_a_in_it(x):<br/>    return 'a' in x</span><span id="2cf6" class="mr kz it mn b gy nb mt l mu mv"># Let's first check out what happens with map<br/>map_obj = <strong class="mn iu">map</strong>(has_the_letter_a_in_it,['bacon','toast','egg'])<br/>print(list(map_obj))<br/>&gt;&gt;[True,True,False]</span><span id="5040" class="mr kz it mn b gy nb mt l mu mv"># What happens with filter?<br/>map_obj = <strong class="mn iu">filter</strong>(has_the_letter_a_in_it,['bacon','toast','egg'])<br/>print(list(map_obj))<br/>&gt;&gt;['bacon', 'toast']</span></pre><p id="6f85" class="pw-post-body-paragraph lq lr it ls b lt mw ju lv lw mx jx ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">正如我们所看到的，它减少了列表中的元素数量。它通过计算函数 has_the_letter_a_in_it()的返回值来实现，并且只返回表达式返回<strong class="ls iu"> True 的值。</strong></p><p id="7945" class="pw-post-body-paragraph lq lr it ls b lt mw ju lv lw mx jx ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">再一次，使用我们最喜欢的 lambda 看起来更性感！</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="8373" class="mr kz it mn b gy ms mt l mu mv">map_obj = <strong class="mn iu">filter</strong>(lambda x: 'a' in x, ['bacon','toast','egg'])<br/>print(list(map_obj))<br/>&gt;&gt;['bacon', 'toast']</span></pre><h1 id="6e42" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">减少</h1><p id="e112" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们见见最后的敌人，也可能是<strong class="ls iu"> 3 中最复杂的一个。</strong>不过不用担心，其实挺简单的。这是一个 N 对 1 的关系，意味着无论我们向它注入多少数据，我们都只能得到一个结果。它这样做的方式是通过应用我们要传递给它的函数链。在 3 个中，它是我们必须从 functools 导入的唯一一个。与其他两个相比，最常见的是使用三个参数 reduce(some_function、some_collection、some_starting_value)，起始值是可选的，但提供一个起始值通常是个好主意。让我们看一看。</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="26d1" class="mr kz it mn b gy ms mt l mu mv">from functools import reduce</span><span id="16a1" class="mr kz it mn b gy nb mt l mu mv">map_obj = <strong class="mn iu">reduce</strong>(lambda x,y: x+" loves "+y, ['bacon','toast','egg'],"Everyone")<br/>print(map_obj)<br/>&gt;&gt;'Everyone loves bacon loves toast loves egg'</span></pre><p id="f6cf" class="pw-post-body-paragraph lq lr it ls b lt mw ju lv lw mx jx ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">正如我们看到的，我们必须使用一个 lambda 函数，它一次接受两个参数，即 x，y，然后通过链表将它们链接起来。让我们想象它是如何遍历列表的</p><ol class=""><li id="8e0c" class="nd ne it ls b lt mw lw mx lz nf md ng mh nh ml ni nj nk nl bi translated">x=“人人”，y=“腊肉”:返回“人人都爱腊肉”</li><li id="0e4f" class="nd ne it ls b lt nm lw nn lz no md np mh nq ml ni nj nk nl bi translated">x= "人人爱培根"，y= "吐司":返回"人人爱培根爱吐司"</li><li id="15ff" class="nd ne it ls b lt nm lw nn lz no md np mh nq ml ni nj nk nl bi translated">x= "人人爱培根爱吐司"，y= "鸡蛋" :返回"人人爱培根爱吐司爱鸡蛋"</li></ol><p id="1199" class="pw-post-body-paragraph lq lr it ls b lt mw ju lv lw mx jx ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">所以我们有了最后一个元素<strong class="ls iu">“人人都爱培根爱吐司爱鸡蛋”。</strong>这些是更轻松地通过处理流程的基本概念。这里值得一提的是，你不能在每一种编程语言中假设 reduce 函数将按顺序处理元素，例如，在某些语言中，它可能是“‘人人都爱鸡蛋爱吐司爱培根’”。</p><h1 id="adb0" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated"><strong class="ak">联合收割机</strong></h1><p id="7bc0" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了确保我们理解了这些概念，让我们一起使用它们并构建一个更复杂的示例。</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="8cbd" class="mr kz it mn b gy ms mt l mu mv">from functools import reduce</span><span id="0095" class="mr kz it mn b gy nb mt l mu mv">vals = [0,1,2,3,4,5,6,7,8,9]<br/># Let's add 1 to each element &gt;&gt; [1,2,3,4,5,6,7,8,9,10]<br/>map_obj = <strong class="mn iu">map</strong>(lambda x: x+1,vals)<br/># Let's only take the uneven ones &gt;&gt; [1, 3, 5, 7, 9]<br/>map_obj = <strong class="mn iu">filter</strong>(lambda x: x%2 == 1,map_obj)<br/># Let's reduce them by summing them up, ((((0+1)+3)+5)+7)+9=25<br/>map_obj = <strong class="mn iu">reduce</strong>(lambda x,y: x+y,map_obj,0)<br/>print(map_obj)<br/>&gt;&gt; 25</span></pre><p id="a9e3" class="pw-post-body-paragraph lq lr it ls b lt mw ju lv lw mx jx ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">正如我们所看到的，我们可以使用这三者的组合来构建非常强大的东西。让我们转到最后一个例子来说明这在实践中的用途。为此，我们加载了数据集的一个小子集，并将打印出人口超过 1000 万的首都城市！</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="618e" class="mr kz it mn b gy ms mt l mu mv">from functools import reduce</span><span id="2b5c" class="mr kz it mn b gy nb mt l mu mv">#Let's define some data<br/>data=[['Tokyo', 35676000.0, 'primary'], ['New York', 19354922.0, 'nan'], ['Mexico City', 19028000.0, 'primary'], ['Mumbai', 18978000.0, 'admin'], ['São Paulo', 18845000.0, 'admin'], ['Delhi', 15926000.0, 'admin'], ['Shanghai', 14987000.0, 'admin'], ['Kolkata', 14787000.0, 'admin'], ['Los Angeles', 12815475.0, 'nan'], ['Dhaka', 12797394.0, 'primary'], ['Buenos Aires', 12795000.0, 'primary'], ['Karachi', 12130000.0, 'admin'], ['Cairo', 11893000.0, 'primary'], ['Rio de Janeiro', 11748000.0, 'admin'], ['Ōsaka', 11294000.0, 'admin'], ['Beijing', 11106000.0, 'primary'], ['Manila', 11100000.0, 'primary'], ['Moscow', 10452000.0, 'primary'], ['Istanbul', 10061000.0, 'admin'], ['Paris', 9904000.0, 'primary']]</span><span id="f5e7" class="mr kz it mn b gy nb mt l mu mv">map_obj = <strong class="mn iu">filter</strong>(lambda x: x[2]=='primary' and x[1]&gt;10000000,data)<br/>map_obj = <strong class="mn iu">map</strong>(lambda x: x[0], map_obj)<br/>map_obj = <strong class="mn iu">reduce</strong>(lambda x,y: x+", "+y, map_obj, 'Cities:')<br/>print(map_obj)<br/>&gt;&gt; Cities:, Tokyo, Mexico City, Dhaka, Buenos Aires, Cairo, Beijing, Manila, Moscow</span></pre><p id="de3f" class="pw-post-body-paragraph lq lr it ls b lt mw ju lv lw mx jx ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">如果你喜欢这篇文章，我会很高兴在 Twitter 或 LinkedIn 上联系你。</p><p id="7b25" class="pw-post-body-paragraph lq lr it ls b lt mw ju lv lw mx jx ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">一定要看看我的<a class="ae nc" href="https://www.youtube.com/channel/UCHD5o0P16usdF00-ZQVcFog?view_as=subscriber" rel="noopener ugc nofollow" target="_blank"> YouTube </a>频道，我每周都会在那里发布新视频。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div></div>    
</body>
</html>