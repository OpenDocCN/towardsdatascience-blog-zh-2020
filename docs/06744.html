<html>
<head>
<title>Minimizing Sales Emails in My Inbox with Natural Language Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过自然语言处理减少收件箱中的销售邮件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/minimizing-sales-emails-in-my-inbox-with-natural-language-processing-38296b562da7?source=collection_archive---------61-----------------------#2020-05-26">https://towardsdatascience.com/minimizing-sales-emails-in-my-inbox-with-natural-language-processing-38296b562da7?source=collection_archive---------61-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7524" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每天我打开收件箱都会看到几十封我不认识的人发来的未读邮件，要求<em class="ko">给我15分钟时间，让他们帮我解决这个或那个问题。</em></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/1ec573b7f5ca63fe7b7c867c53410a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*M2BQfjjudcfEUAqx90KQHw.png"/></div></figure><p id="e389" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2011年，亚伦·罗斯(Aaron Ross)的书《可预测的收入》(forecast Revenue)推广了这一概念，向B2B潜在客户发送冰冷的电子邮件，要求会面，这已经成为全球B2B SaaS公司的主要增长策略。事实上，秘密已经泄露，每个人(显然还有他们的母亲)都在发送潜在客户邮件来招揽生意。(例如，参见<a class="ae kx" href="https://blog.hubspot.com/sales/sales-email-templates-guaranteed-to-get-a-response" rel="noopener ugc nofollow" target="_blank"> 30个保证建立关系的销售潜在客户电子邮件模板</a>。)而且理由很充分——这很有效！</p><p id="90b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，当每个B2B公司向世界各地的每个潜在客户发送电子邮件时，会发生什么？我们的收件箱变得更加嘈杂，让我们更难专注于重要的电子邮件。</p><blockquote class="ky"><p id="1f35" class="kz la it bd lb lc ld le lf lg lh kn dk translated">可预测的收入带来了什么？</p></blockquote><p id="705c" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">即使是强大的电子邮件服务，如Gmail和Outlook，也不会将这些SDR电子邮件归类为垃圾邮件。这是可以理解的，因为特别提款权不是在兜售伟哥、要求资金转移等等。Gmail的“推广”过滤器呢？没有帮助。销售代表经常通过<a class="ae kx" href="https://support.outreach.io/hc/en-us/articles/205022548-Connect-Outreach-with-Gmail" rel="noopener ugc nofollow" target="_blank">销售支持技术</a>使用他们公司的Gmail或Outlook电子签名发送电子邮件，例如Outreach，这似乎绕过了常见的“简讯”过滤器。</p><p id="7d9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果不加控制，SDR电子邮件将继续入侵收件箱，降低相关内容的关注度。</p><h2 id="7638" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">回收收件箱</h2><p id="46ed" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">为了应对这一困境— <em class="ko">,但实际上是作为开发我的NLP、Docker和微服务技能的借口,</em> —我设计、编码并部署了一个SDR电子邮件检测器，可通过API端点访问。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/9ffead2077a70dd62c713c81895b9d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*F5_IBLylY8-rzp5j8v8VCA.png"/></div></figure><p id="ef21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该系统通过OAuth连接到用户的Gmail，确定收到的电子邮件是否是<code class="fe mm mn mo mp b">from_SDR</code>，并将这些电子邮件移动到一个特殊的文件夹中“稍后阅读”如果电子邮件不是<code class="fe mm mn mo mp b">from_SDR</code>，那么它会将分类邮件留在主收件箱中。</p><h1 id="e214" class="mq lo it bd lp mr ms mt ls mu mv mw lv mx my mz ly na nb nc mb nd ne nf me ng bi translated">构建SDR电子邮件检测器</h1><p id="38c5" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">垃圾邮件检测与我的项目最为相似。这里有许多方法，从使用“单词包”计数矢量化的简单朴素贝叶斯方法到使用双向递归神经网络进行单词嵌入的复杂深度学习模型。尽管我尝试了上述所有方法，但本文将重点关注使用TF-IDF矢量化的线性SVM实现。</p><h2 id="59b4" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">获取培训数据</h2><p id="3e38" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">无论采用哪种方法，应用机器学习最重要的部分是(1)获得良好的数据，以及(2)为训练和测试准备数据。</p><p id="23e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">获取训练数据相对简单。我在收件箱里过滤了与销售相关的关键词，查看了数千封电子邮件。如果邮件来自销售开发代表(SDR)，我会在邮件中添加标签<code class="fe mm mn mo mp b">SDR</code>。大约八个小时后，我在收件箱里标记了1000封SDR邮件:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/bf75647fd0ee9010ba994d6e183f491f.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*T7W8yIIvB4WyN_tEJprvCw.png"/></div></figure><p id="f2f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我从收件箱里取出了4000封非SDR电子邮件。我故意对非SDR电子邮件进行过采样，以再现现实世界中发生的类别不平衡，同时注意到需要有足够的<code class="fe mm mn mo mp b">SDR</code>信号(例如，我的数据的20%)，以便我的分类器学习一些有意义的东西。</p><p id="c36c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我启动了Google Colab笔记本电脑，将电子邮件下载到熊猫数据框中。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4da0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mm mn mo mp b">service</code>对象创建一个到Gmail API和目标收件箱的连接。(注意，您需要<a class="ae kx" href="https://support.google.com/googleapi/answer/6158862?hl=en" rel="noopener ugc nofollow" target="_blank">设置一个谷歌云平台账户</a>来注册一个应用程序并获得一个<code class="fe mm mn mo mp b">client_secret.json</code>。)</p><p id="960c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我编写了一个函数来获取大量与查询匹配的消息:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9283" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的函数返回了一个邮件id数组，该数组必须从Gmail API中迭代获取。为此，我编写了以下函数，该函数调用每条消息并解析正文、发件人、主题、日期/时间和其他有趣的字段。假设能够查询标签(例如，<code class="fe mm mn mo mp b">label:SDR</code>来检索我收件箱中的所有SDR电子邮件)，我提前知道电子邮件数组是<code class="fe mm mn mo mp b">y_true=1</code>还是<code class="fe mm mn mo mp b">y_true=0</code>，这是我的函数用来标记Dataframe中每一行的参数:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="224b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是还有一个函数需要定义，这是迄今为止最棘手的:<code class="fe mm mn mo mp b">get_email_data(message_id)</code>。这一重要功能将Gmail编码的回复转换成可以解析并保存到数据帧中的文本。这绝不是完美的，因为我来<a class="ae kx" href="http://blog.magiksys.net/parsing-email-using-python-content" rel="noopener ugc nofollow" target="_blank">是为了了解</a>的电子邮件有多复杂多样。您将注意到正确解析电子邮件所需的嵌套逻辑和多部分遍历，因为如果电子邮件包含附件、HTML、明文和其他边缘情况，它们的编码会有所不同。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="96d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我导入了<code class="fe mm mn mo mp b">pickle</code>来保存我的数据帧，这帮助我节省了API调用和重新获取相同数据的时间:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a75e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基础工作完成后，我决定做一些功能工程，如果收件箱用户从未给发件人发送过邮件，就添加一个等于1的<code class="fe mm mn mo mp b">cold_contact</code>标志:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b093" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我还试验了其他特性(比如sender/return_path不匹配，以及统计之前90天、60天、30天内发送的电子邮件数量等等)，但是我将省去您查看这些代码的麻烦，因为它们并没有显著提高我的模型的性能。</p><p id="ee97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是我的数据框架中的一些示例行和列:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/b4788f1781cbc1848e715896296b5d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqccii3XWXiQPNaOjvo3tg.png"/></div></div></figure><h2 id="d914" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">使用自然语言处理训练SDR电子邮件检测器</h2><p id="08e0" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">有了电子邮件数据，我必须将电子邮件处理成一种便于分类的格式。如上所述，有许多方法可以做到这一点，我选择使用术语频率-逆文档频率矢量化来表示每封电子邮件的正文。</p><p id="dcbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">引用<a class="ae kx" href="http://www.tfidf.com/" rel="noopener ugc nofollow" target="_blank">单页教程</a>的话:</p><blockquote class="np nq nr"><p id="6423" class="jq jr ko js b jt ju jv jw jx jy jz ka ns kc kd ke nt kg kh ki nu kk kl km kn im bi translated">通常，tf-idf权重由两项组成:第一项计算归一化项频率(tf)，aka。单词在文档中出现的次数，除以该文档中的总单词数；第二项是逆文档频率(IDF ),计算为语料库中文档数量的对数除以特定术语出现的文档数量。<br/>。。。<br/>考虑包含100个单词的文档，其中单词cat出现3次。cat的频率项(即tf)则为(3 / 100) = 0.03。现在，假设我们有1000万个文档，其中1000个文档中出现了单词cat。然后，逆文档频率(即idf)计算为log(10，000，000 / 1，000) = 4。因此，tf-idf重量是这些量的乘积:0.03 * 4 = 0.12。</p></blockquote><p id="d255" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将每封电子邮件想象成矩阵中的一行，其中电子邮件的每个单词是一个特征(例如，一列)，其值由上面的公式给出。<a class="ae kx" href="https://aiaspirant.com/bag-of-words/" rel="noopener ugc nofollow" target="_blank">例如</a>:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nv"><img src="../Images/d8a70004ddca600061bd8fa7f378d0ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J1QlNAIuuFQb0Vmx.png"/></div></div></figure><p id="b43f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题来了:我要存储(即内存问题)和分析(即CPU时间)数百万字/列的数据吗？不。诀窍是预处理电子邮件，这样我就能得到更少、更高的信号词。</p><h2 id="cdba" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">预处理电子邮件文本</h2><p id="555b" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated"><a class="ae kx" rel="noopener" target="_blank" href="/setting-up-text-preprocessing-pipeline-using-scikit-learn-and-spacy-e09b9b76758f"> Jay Patel提供了关于如何将原始文本转换为机器学习算法可以矢量化和消费的形式的深度报道和示例。我跟随他的领导，编写了这些函数来删除HTML、标点符号和低信号词:</a></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="bb4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您会注意到上面代码中的<code class="fe mm mn mo mp b">lemmatizer</code>。这个概念超出了这篇文章的范围，但是值得一提的是，<a class="ae kx" href="https://en.wikipedia.org/wiki/Lemmatisation" rel="noopener ugc nofollow" target="_blank">lemma tion</a>是减少书面文本维数的另一种方法，以便<em class="ko">运行</em>、<em class="ko">运行</em>、<em class="ko">运行</em>、<em class="ko">运行</em>、<em class="ko">运行</em>等。，都简单地用一个词来表示:<em class="ko">跑</em>。</p><p id="6c06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了将上面的功能付诸实践，我使用了Sam T 在这篇<a class="ae kx" rel="noopener" target="_blank" href="/custom-transformers-and-ml-data-pipelines-with-python-20ea2a7adb65">文章中描述的ColumnTransformers。在这里，我定义了一个转换器，它接受一个带有“body”列的数据帧，并使用上面确定的清理函数处理每一行:</a></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="680f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重要的是，这个转换器使用<code class="fe mm mn mo mp b">remainder='passthrough'</code>来保存和传播管道中的其他数据帧列。清理邮件正文变得轻而易举。我只需要运行功能<code class="fe mm mn mo mp b">clean_text_CT_passthrough.transform(some_dataframe)</code>。</p><p id="b172" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是更好的是，我可以使用SKLearn管道和ColumnTransformers链接多个预处理步骤。例如，在此代码片段中，我重新调整了dataframe的单个列，使其与TF-IDF矢量化计算的值范围成比例:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2e89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，在一个版本中，我尝试添加了一个功能，可以计算每封电子邮件中的字数。虽然文本矢量化是在0 →1的数量级上，但字数在0 → 1，500的范围内，并且在没有重新调整的情况下，该模型由于过分强调字数特征而失败。与其他列一样，上面的函数将字数重新调整到0 → 1的范围。</p><p id="96d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我执行了单词矢量化，并将这些列组合成一个单独的向量，以便进行分类。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f916" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">得到的对象<code class="fe mm mn mo mp b">classification_pipe</code>有<code class="fe mm mn mo mp b">.fit</code>、<code class="fe mm mn mo mp b">.predict</code>和其他你期望从SKLearn分类器中得到的函数。这些是可用的，因为我在第8–9行定义了一个分类器，并在第24行将其添加到管道中。</p><h2 id="ffc1" class="ln lo it bd lp lq lr dn ls lt lu dp lv kb lw lx ly kf lz ma mb kj mc md me mf bi translated">把所有的放在一起</h2><p id="248e" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我从存储的pickle中加载了电子邮件数据，并将身体重铸为<code class="fe mm mn mo mp b">string</code>。接下来，我创建了一个训练/测试数据分割，将<code class="fe mm mn mo mp b">stratify=y_df.y_true</code>传递给<code class="fe mm mn mo mp b">train_test_split</code>函数，这样我的分割将使用类似的类不平衡作为我的目标变量进行采样。然后，我使用训练数据调用了<code class="fe mm mn mo mp b">classification_pipe.fit</code>函数。最后，我使用F1分数和其他指标评估了我的模型的性能:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1c87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是优化文本预处理、TF-IDF矢量器和SVM参数后我的模型的结果:</p><blockquote class="np nq nr"><p id="5e90" class="jq jr ko js b jt ju jv jw jx jy jz ka ns kc kd ke nt kg kh ki nu kk kl km kn im bi translated">F1得分:98.34% <br/> AP: 95.06% <br/>精度:97.09% <br/>召回率:97.40%</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nw"><img src="../Images/8dc11fb0ffb881cd5b4b70aff073f577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*570DJVMZAtg0e0TF0WfQNQ.png"/></div></div></figure><p id="199b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管总有进一步优化的空间，但鉴于F1的高分(98.34)和我起步时的显著进步(83.44)，我觉得这是一个很好的停止点。</p><h1 id="3602" class="mq lo it bd lp mr ms mt ls mu mv mw lv mx my mz ly na nb nc mb nd ne nf me ng bi translated">后续步骤:部署模型</h1><p id="fac2" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">为了构建本文开头描述的系统，我的Gmail小程序应该通过API调用这个模型。这是本系列下一篇文章<a class="ae kx" rel="noopener" target="_blank" href="/dockerize-deploy-and-call-my-sdr-email-detector-model-via-api-68e238b7ecff">的重点。在那里，我将我的模型容器化，部署到AWS ECR，并使用Chalice构建一个web可访问的API端点。</a></p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="2f84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了避免上面冗长的代码片段，我把大部分的<code class="fe mm mn mo mp b">import</code>语句放在了<a class="ae kx" href="https://gist.github.com/silverfoxf7/8c21dc2fb428869f1a07fd836bbb5261" rel="noopener ugc nofollow" target="_blank">这个要点</a>中。如果您运行这里描述的代码，请务必检查并包含这些内容。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="7f64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让这个帖子成为可能，要感谢的人太多了。以下是几个对我的冒险有重大指导意义的例子:<a class="oe of ep" href="https://medium.com/u/65d58216b9a9?source=post_page-----38296b562da7--------------------------------" rel="noopener" target="_blank"> Sie Huai Gan </a>(关于<a class="ae kx" rel="noopener" target="_blank" href="/email-spam-detection-1-2-b0e06a5c0472"> Niaves Bayes </a>和<a class="ae kx" rel="noopener" target="_blank" href="/spam-filtering-system-with-deep-learning-b8070b28f9e0">深度学习垃圾邮件分类器</a>)，<a class="ae kx" href="https://www.linkedin.com/in/paulblankley" rel="noopener ugc nofollow" target="_blank"> Paul Blankley </a>(关于评估指标)，<a class="oe of ep" href="https://medium.com/u/6c2ddb3a3ac5?source=post_page-----38296b562da7--------------------------------" rel="noopener" target="_blank"> Mikko Ohtamaa </a>(关于<a class="ae kx" href="https://gist.github.com/miohtama/5389146" rel="noopener ugc nofollow" target="_blank">电子邮件解析</a>)，<a class="ae kx" href="https://github.com/aspineux" rel="noopener ugc nofollow" target="_blank"> Alain Spineux </a> ( <a class="ae kx" href="http://blog.magiksys.net/parsing-email-using-python-content" rel="noopener ugc nofollow" target="_blank">解释电子邮件部分</a>)，<a class="oe of ep" href="https://medium.com/u/93115235d099?source=post_page-----38296b562da7--------------------------------" rel="noopener" target="_blank">Zac Stewart</a>(<a class="oe of ep" href="https://medium.com/u/93115235d099?source=post_page-----38296b562da7--------------------------------" rel="noopener" target="_blank"> Mathieu Blondel(在</a><a class="ae kx" href="https://scikit-learn.org/stable/auto_examples/model_selection/grid_search_text_feature_extraction.html" rel="noopener ugc nofollow" target="_blank">上使用管道、转换器和GridSearchCV </a>)，<a class="oe of ep" href="https://medium.com/u/37a762d5c9bc?source=post_page-----38296b562da7--------------------------------" rel="noopener" target="_blank"> Sam T </a>(在<a class="ae kx" rel="noopener" target="_blank" href="/custom-transformers-and-ml-data-pipelines-with-python-20ea2a7adb65">管道上使用自定义转换器</a>)，<a class="ae kx" href="https://stackoverflow.com/questions/39121104/how-to-add-another-feature-length-of-text-to-current-bag-of-words-classificati" rel="noopener ugc nofollow" target="_blank"> Ken Syme </a>(在ColumnTransformer中组合文本和表格数据)，<a class="oe of ep" href="https://medium.com/u/8dc22d6b3ace?source=post_page-----38296b562da7--------------------------------" rel="noopener" target="_blank"> Jay M. Patel </a>(在NLP的文本预处理上)，<a class="oe of ep" href="https://medium.com/u/ddb7af95566?source=post_page-----38296b562da7--------------------------------" rel="noopener" target="_blank"> Ryan Cranfill </a>(在<a class="ae kx" href="https://ryan-cranfill.github.io/sentiment-pipeline-sklearn-3/" rel="noopener ugc nofollow" target="_blank">管道中添加自定义函数预处理文本</a> <a class="oe of ep" href="https://medium.com/u/bb3e9cd0147a?source=post_page-----38296b562da7--------------------------------" rel="noopener" target="_blank"> Michelle Fullwood </a>(关于<a class="ae kx" href="https://michelleful.github.io/code-blog/2015/06/20/pipelines/" rel="noopener ugc nofollow" target="_blank">管道和特征联合</a>)，以及<a class="oe of ep" href="https://medium.com/u/881e4b12cc5d?source=post_page-----38296b562da7--------------------------------" rel="noopener" target="_blank"> Benjamin Bengfort </a>，<a class="oe of ep" href="https://medium.com/u/2f4ae5984d27?source=post_page-----38296b562da7--------------------------------" rel="noopener" target="_blank"> Rebecca Bilbro </a>，<a class="oe of ep" href="https://medium.com/u/95b168d0e792?source=post_page-----38296b562da7--------------------------------" rel="noopener" target="_blank"> Tony Ojeda </a>(关于<a class="ae kx" href="https://www.oreilly.com/library/view/applied-text-analysis/9781491963036/ch04.html" rel="noopener ugc nofollow" target="_blank">通过管道进行文本矢量化</a>)。 感谢大家花时间分享你们的知识！</p></div></div>    
</body>
</html>