<html>
<head>
<title>Clustering Using Convex Hulls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用凸包的聚类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/clustering-using-convex-hulls-fddafeaa963c?source=collection_archive---------17-----------------------#2020-08-15">https://towardsdatascience.com/clustering-using-convex-hulls-fddafeaa963c?source=collection_archive---------17-----------------------#2020-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b403" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在数据聚类中使用凸包</h2></div><p id="0634" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近在<a class="ae le" href="https://www.sciencedirect.com/science/journal/01678655" rel="noopener ugc nofollow" target="_blank">模式识别快报</a>偶然看到哈坎·切维卡普的文章《利用局部仿射/凸包 进行高维数据聚类》。提出了一种利用局部仿射/凸包对高维数据进行聚类的新算法。他们使用凸包进行聚类的方法启发了我。我想尝试使用凸包实现我自己的简单聚类方法。因此，在本文中，我将向您介绍我使用凸包实现聚类方法的过程。在我们进入编码之前，让我们看看什么是凸包。</p><h1 id="cb9c" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">凸包</h1><p id="5337" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">根据<a class="ae le" href="https://en.wikipedia.org/wiki/Convex_hull" rel="noopener ugc nofollow" target="_blank">维基百科</a>，凸包定义如下。</p><blockquote class="mc"><p id="b9de" class="md me it bd mf mg mh mi mj mk ml ld dk translated">在几何学中，一个形状的凸包或凸包络或凸闭包是包含它的最小凸集。</p></blockquote><figure class="mn mo mp mq mr ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mm"><img src="../Images/7a82e2d9536323fdfa4c331ef0d8e194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rk8DDgeMACxJSXtdFs0ysg.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图一。一组钉子的凸包(图片由作者提供)</p></figure><p id="3bdb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们考虑一个简单类比的例子。如图 1 所示，假设有几个钉子被钉在木板的中间。你拿一根橡皮筋，把它拉长包住钉子，然后放开它。它将适合最外面的指甲(显示为蓝色)，并采取最小化其长度的形状。被橡皮筋围起来的区域叫做这组钉子的<strong class="kk iu">凸包</strong>。</p><p id="4f4e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个二维空间中的凸包(如图 1 所示)将是一个<em class="nd">凸多边形</em>，其所有内角都小于 180°。如果是在 3 维或者更高维的空间，那么凸包会是一个<em class="nd">多面体</em>。</p><p id="dde1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有几种算法可以确定给定点集的凸包。一些著名的算法是<a class="ae le" href="https://en.wikipedia.org/wiki/Gift_wrapping_algorithm" rel="noopener ugc nofollow" target="_blank">礼品包装算法</a>和<a class="ae le" href="https://en.wikipedia.org/wiki/Graham_scan" rel="noopener ugc nofollow" target="_blank">格雷厄姆扫描算法</a>。</p><p id="40fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于凸包包围了一组点，所以它可以充当聚类边界，允许我们确定聚类中的点。因此，我们可以利用凸包和执行聚类。让我们进入代码。</p><h1 id="dba7" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">简单的例子</h1><p id="a754" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在这个例子中，我将使用 Python。在开始之前，我们需要以下 Python 库。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="176a" class="nn lg it nj b gy no np l nq nr">sklearn<br/>numpy<br/>matplotlib<br/>mpl_toolkits<br/>itertools<br/>scipy<br/>quadprog</span></pre><h2 id="f9e3" class="nn lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lr kv ny nz lt kz oa ob lv oc bi translated">资料组</h2><p id="5c25" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">为了创建我们的样本数据集，我将使用<strong class="kk iu"> sci-kit learn </strong>库的<strong class="kk iu"> make blobs </strong>函数。我将制作 3 个集群。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="534e" class="nn lg it nj b gy no np l nq nr">import numpy as np<br/>from sklearn.datasets import make_blobs</span><span id="feee" class="nn lg it nj b gy od np l nq nr">centers = [[0, 1, 0], [1.5, 1.5, 1], [1, 1, 1]]<br/>stds = [0.13, 0.12, 0.12]</span><span id="d364" class="nn lg it nj b gy od np l nq nr">X, labels_true = make_blobs(n_samples=1000, centers=centers, cluster_std=stds, random_state=0)<br/>point_indices = np.arange(1000)</span></pre><p id="11da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于这是一个三维点数据集，我将绘制一个 3D 图来显示我们的地面真实集群。图 2 显示了带有彩色聚类的数据集的散点图。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="18f6" class="nn lg it nj b gy no np l nq nr">import matplotlib.pyplot as plt<br/>from mpl_toolkits.mplot3d import Axes3D</span><span id="ab78" class="nn lg it nj b gy od np l nq nr">x = X[:,0]<br/>y = X[:,1] <br/>z = X[:,2]<br/><br/># Creating figure <br/>fig = plt.figure(figsize = (15, 10)) <br/>ax = plt.axes(projection ="3d") <br/>    <br/># Add gridlines  <br/>ax.grid(b = True, color ='grey',  <br/>        linestyle ='-.', linewidth = 0.3,  <br/>        alpha = 0.2)  <br/>  <br/>mycolours = ["red", "green", "blue"]</span><span id="d680" class="nn lg it nj b gy od np l nq nr"># Creating color map <br/>col = [mycolours[i] for i in labels_true]</span><span id="8ddc" class="nn lg it nj b gy od np l nq nr"># Creating plot <br/>sctt = ax.scatter3D(x, y, z, c = col, marker ='o')</span><span id="1614" class="nn lg it nj b gy od np l nq nr">plt.title("3D scatter plot of the data\n") <br/>ax.set_xlabel('X-axis', fontweight ='bold')  <br/>ax.set_ylabel('Y-axis', fontweight ='bold')  <br/>ax.set_zlabel('Z-axis', fontweight ='bold')<br/>  <br/># show plot <br/>plt.draw()</span></pre><figure class="ne nf ng nh gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oe"><img src="../Images/00e0d00c1b2f23482db81f742a73eab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*woTl_QjdCRfv2odzEyZwCg.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图二。数据集的初始散点图(图片由作者提供)</p></figure><h2 id="f421" class="nn lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lr kv ny nz lt kz oa ob lv oc bi translated">获得初始聚类</h2><p id="a8e5" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">首先，我们需要将数据集分成两部分。一部分将被用作种子，以使用 K-means 获得初始聚类。另一部分中的点将被分配给基于初始聚类的聚类。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="d051" class="nn lg it nj b gy no np l nq nr">from sklearn.model_selection import train_test_split</span><span id="2ef4" class="nn lg it nj b gy od np l nq nr">X_seeds, X_rest, y_seeds, y_rest, id_seeds, id_rest = train_test_split(X, labels_true, point_indices, test_size=0.33, random_state=42)</span></pre><p id="75e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们对种子点执行 K 均值聚类。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="0c42" class="nn lg it nj b gy no np l nq nr">from sklearn.cluster import KMeans</span><span id="db2f" class="nn lg it nj b gy od np l nq nr">kmeans = KMeans(n_clusters=3, random_state=9).fit(X_seeds)<br/>initial_result = kmeans.labels_</span></pre><p id="1215" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于生成的标签可能与地面真实标签不同，我们必须映射这两组标签。为此，我们可以使用下面的函数。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="806a" class="nn lg it nj b gy no np l nq nr">from itertools import permutations</span><span id="bbc4" class="nn lg it nj b gy od np l nq nr"># Source: <a class="ae le" href="https://stackoverflow.com/questions/11683785/how-can-i-match-up-cluster-labels-to-my-ground-truth-labels-in-matlab" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/11683785/how-can-i-match-up-cluster-labels-to-my-ground-truth-labels-in-matlab</a></span><span id="492f" class="nn lg it nj b gy od np l nq nr">def remap_labels(pred_labels, true_labels):</span><span id="0637" class="nn lg it nj b gy od np l nq nr">    pred_labels, true_labels = np.array(pred_labels), np.array(true_labels)<br/>    assert pred_labels.ndim == 1 == true_labels.ndim<br/>    assert len(pred_labels) == len(true_labels)<br/>    cluster_names = np.unique(pred_labels)<br/>    accuracy = 0</span><span id="3729" class="nn lg it nj b gy od np l nq nr">    perms = np.array(list(permutations(np.unique(true_labels))))</span><span id="0949" class="nn lg it nj b gy od np l nq nr">    remapped_labels = true_labels</span><span id="4424" class="nn lg it nj b gy od np l nq nr">    for perm in perms:</span><span id="0827" class="nn lg it nj b gy od np l nq nr">        flipped_labels = np.zeros(len(true_labels))<br/>        for label_index, label in enumerate(cluster_names):<br/>            flipped_labels[pred_labels == label] = perm[label_index]</span><span id="c002" class="nn lg it nj b gy od np l nq nr">        testAcc = np.sum(flipped_labels == true_labels) / len(true_labels)</span><span id="d1e4" class="nn lg it nj b gy od np l nq nr">        if testAcc &gt; accuracy:<br/>            accuracy = testAcc<br/>            remapped_labels = flipped_labels</span><span id="afa8" class="nn lg it nj b gy od np l nq nr">    return accuracy, remapped_labels</span></pre><p id="cf15" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从上面的函数中得到精度和映射的初始标签。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="f3e0" class="nn lg it nj b gy no np l nq nr">intial_accuracy, remapped_initial_result = remap_labels(initial_result, y_seeds)</span></pre><p id="5311" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图 3 表示种子点的初始聚类。</p><figure class="ne nf ng nh gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oe"><img src="../Images/8f856a85e791e8d02b9383d5f3dcf98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uaQEBEUnxfWc6P57P0OzUQ.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图三。使用 K-means 对种子点进行初始聚类(图片由作者提供)</p></figure><h2 id="57b9" class="nn lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lr kv ny nz lt kz oa ob lv oc bi translated">得到初始聚类的凸包</h2><p id="4b86" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">一旦我们获得了初始聚类，我们就可以得到每个聚类的凸包。首先，我们必须获得聚类中每个数据点的索引。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="ef22" class="nn lg it nj b gy no np l nq nr"># Get the idices of the data points belonging to each cluster<br/>indices = {}</span><span id="bf04" class="nn lg it nj b gy od np l nq nr">for i in range(len(id_seeds)):<br/>    if int(remapped_initial_result[i]) not in indices:<br/>        indices[int(remapped_initial_result[i])] = [i]<br/>    else:<br/>        indices[int(remapped_initial_result[i])].append(i)</span></pre><p id="26a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以从每个集群中获得凸包。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="5198" class="nn lg it nj b gy no np l nq nr">from scipy.spatial import ConvexHull</span><span id="af7c" class="nn lg it nj b gy od np l nq nr"># Get convex hulls for each cluster<br/>hulls = {}</span><span id="9699" class="nn lg it nj b gy od np l nq nr">for i in indices:<br/>    hull = ConvexHull(X_seeds[indices[i]])<br/>    hulls[i] = hull</span></pre><p id="b660" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图 4 表示代表 3 个聚类中的每一个的凸包。</p><figure class="ne nf ng nh gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oe"><img src="../Images/f64730017fde56f9d0731d6526367f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_GsDEJwOqqbuGxeViZU8Qw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图 4。每个聚类的凸包(图片由作者提供)</p></figure><h2 id="8d1e" class="nn lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lr kv ny nz lt kz oa ob lv oc bi translated">将剩余的点分配给最近的凸包簇</h2><p id="0173" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">现在我们有了初始聚类的凸包，我们可以将剩余的点分配给最近的凸包的聚类。首先，我们必须将数据点投影到一个凸包上。为此，我们可以使用下面的函数。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="f5c3" class="nn lg it nj b gy no np l nq nr">from quadprog import solve_qp</span><span id="12f5" class="nn lg it nj b gy od np l nq nr"># Source: <a class="ae le" href="https://stackoverflow.com/questions/42248202/find-the-projection-of-a-point-on-the-convex-hull-with-scipy" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/42248202/find-the-projection-of-a-point-on-the-convex-hull-with-scipy</a></span><span id="0941" class="nn lg it nj b gy od np l nq nr">def proj2hull(z, equations):</span><span id="dc58" class="nn lg it nj b gy od np l nq nr">    G = np.eye(len(z), dtype=float)<br/>    a = np.array(z, dtype=float)<br/>    C = np.array(-equations[:, :-1], dtype=float)<br/>    b = np.array(equations[:, -1], dtype=float)</span><span id="6c9c" class="nn lg it nj b gy od np l nq nr">    x, f, xu, itr, lag, act = solve_qp(G, a, C.T, b, meq=0, factorized=True)</span><span id="cd66" class="nn lg it nj b gy od np l nq nr">    return x</span></pre><p id="97d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">寻找凸壳上的点的投影的问题可以使用二次规划来解决。上述功能利用了<code class="fe of og oh nj b">quadprog</code>模块。您可以使用<code class="fe of og oh nj b"><a class="ae le" href="https://anaconda.org/omnia/quadprog" rel="noopener ugc nofollow" target="_blank">conda</a></code>或<code class="fe of og oh nj b"><a class="ae le" href="https://pypi.org/project/quadprog/" rel="noopener ugc nofollow" target="_blank">pip</a></code>安装<code class="fe of og oh nj b">quadprog</code>模块。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="1f2d" class="nn lg it nj b gy no np l nq nr">conda install -c omnia quadprog<br/>OR<br/>pip install quadprog</span></pre><p id="f355" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于如何用二次规划解决这个问题，我就不赘述了。如果你有兴趣，你可以阅读更多来自<a class="ae le" href="https://stackoverflow.com/questions/42248202/find-the-projection-of-a-point-on-the-convex-hull-with-scipy" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae le" href="https://math.stackexchange.com/questions/2146961/find-a-point-on-the-convex-hull-of-a-given-set-of-points-which-is-closest-to-a-g/2153051#2153051" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="ne nf ng nh gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oi"><img src="../Images/47e95b089e9cc8b17bce7d4259159509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4RGFsuR9XYdgNX3cji-UA.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图五。从一个点到它在凸包上的投影的距离(图片由作者提供)</p></figure><p id="8e6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦获得了凸包上的投影，就可以计算从该点到凸包的距离，如图 5 所示。基于这个距离，现在让我们将剩余的数据点分配给最近的凸包的簇。</p><p id="203e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将考虑从数据点到它在凸包上的投影的欧几里德距离。那么该数据点将被分配到具有距离该数据点最短距离的凸包的聚类中。如果一个点位于凸包内，那么距离将为 0。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="2646" class="nn lg it nj b gy no np l nq nr">prediction = []</span><span id="1331" class="nn lg it nj b gy od np l nq nr">for z1 in X_rest:</span><span id="7233" class="nn lg it nj b gy od np l nq nr">    min_cluster_distance = 100000<br/>    min_distance_point = ""<br/>    min_cluster_distance_hull = ""<br/>    <br/>    for i in indices:</span><span id="eddb" class="nn lg it nj b gy od np l nq nr">        p = proj2hull(z1, hulls[i].equations)</span><span id="f47e" class="nn lg it nj b gy od np l nq nr">        dist = np.linalg.norm(z1-p)</span><span id="6343" class="nn lg it nj b gy od np l nq nr">        if dist &lt; min_cluster_distance:</span><span id="0a33" class="nn lg it nj b gy od np l nq nr">            min_cluster_distance = dist<br/>            min_distance_point = p<br/>            min_cluster_distance_hull = i</span><span id="4595" class="nn lg it nj b gy od np l nq nr">    prediction.append(min_cluster_distance_hull)</span><span id="ffac" class="nn lg it nj b gy od np l nq nr">prediction = np.array(prediction)</span></pre><p id="39dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图 6 显示了最终的聚类结果。</p><figure class="ne nf ng nh gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oe"><img src="../Images/94f90c1f0cf11f215e54eeed65e338e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*THA9SlnZEM5pl7xnnlsFrw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图六。凸包的最终结果(图片由作者提供)</p></figure><h2 id="5a63" class="nn lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lr kv ny nz lt kz oa ob lv oc bi translated">评估最终结果</h2><p id="4145" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">让我们评估一下我们的结果，看看它有多准确。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="ae3b" class="nn lg it nj b gy no np l nq nr">from sklearn.metrics import accuracy_score</span><span id="2457" class="nn lg it nj b gy od np l nq nr">Y_pred = np.concatenate((remapped_initial_result, prediction))<br/>Y_real = np.concatenate((y_seeds, y_rest))<br/>print(accuracy_score(Y_real, Y_pred))</span></pre><p id="9a78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我得到了 1.0 (100%)的准确率！棒极了，激动人心，对吧？😊</p><p id="3cbe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果想了解更多关于评估聚类结果的内容，可以查看我之前的文章<a class="ae le" rel="noopener" target="_blank" href="/evaluating-clustering-results-f13552ee7603">评估聚类结果</a>。</p><div class="oj ok gp gr ol om"><a rel="noopener follow" target="_blank" href="/evaluating-clustering-results-f13552ee7603"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">评估聚类结果</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">用于评估聚类结果的标准</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">towardsdatascience.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa mx om"/></div></div></a></div><p id="1d7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我使用了一个非常简单的数据集。您可以在更复杂的数据集上尝试这种方法，看看会发生什么。</p><h2 id="4a8b" class="nn lg it bd lh ns nt dn ll nu nv dp lp kr nw nx lr kv ny nz lt kz oa ob lv oc bi translated">高维数据</h2><p id="b72e" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我还尝试使用我的聚类外壳方法对一个具有 8 维数据点的数据集进行聚类。你可以找到显示代码和结果的<a class="ae le" href="https://gist.github.com/Vini2/0dc28a1d8b7d78cf30b3d633cd62c271" rel="noopener ugc nofollow" target="_blank"> jupyter 笔记本</a>。最终结果如下。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="4a74" class="nn lg it nj b gy no np l nq nr">Accuracy of K-means method: 0.866<br/>Accuracy of Convex Hull method: 0.867</span></pre><p id="6928" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的凸包方法相对于 K-means 有一点改进。</p><h1 id="52f0" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">最后的想法</h1><p id="5824" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">HakanCevikalp 的题为<a class="ae le" href="https://doi.org/10.1016/j.patrec.2019.10.007" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">通过使用局部仿射/凸包</strong> </a>进行高维数据聚类的文章表明，他们提出的基于凸包的方法避免了“<em class="nd">孔洞伪影</em>”问题(高维空间中的稀疏和不规则分布会使最近邻距离不可靠)，并且与其他最先进的子空间聚类方法相比，提高了高维数据集的准确性。</p><div class="oj ok gp gr ol om"><a href="https://www.sciencedirect.com/science/article/pii/S0167865519302806?via%3Dihub" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">利用局部仿射/凸包的高维数据聚类</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">我们提出了一种新的算法，使用局部仿射/凸包的高维数据聚类。*建议的…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">www.sciencedirect.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa mx om"/></div></div></a></div><p id="77ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以找到包含本文所用代码的<a class="ae le" href="https://gist.github.com/Vini2/2d35132f70ee18298fdea142b5530a52" rel="noopener ugc nofollow" target="_blank"> jupyter 笔记本</a>。</p><figure class="ne nf ng nh gt ms"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="3be7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望这篇文章是有趣和有用的。</p><p id="636f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干杯！😃</p></div></div>    
</body>
</html>