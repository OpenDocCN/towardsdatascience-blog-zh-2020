<html>
<head>
<title>Coding a custom imputer in scikit-learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在scikit-learn中编写自定义输入程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/coding-a-custom-imputer-in-scikit-learn-31bd68e541de?source=collection_archive---------26-----------------------#2020-05-21">https://towardsdatascience.com/coding-a-custom-imputer-in-scikit-learn-31bd68e541de?source=collection_archive---------26-----------------------#2020-05-21</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><figure class="iu iv gp gr iw ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi it"><img src="../Images/6f02931c12639379d19ba5fc0158f030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHi3uRC0ZGbJgwDhYj-yQw.jpeg"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">Gabriel Crismariu 在<a class="ae ji" href="https://unsplash.com/s/photos/puzzle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="c635" class="pw-subtitle-paragraph ki jk jl bd b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dk translated">了解如何创建自定义估算器，包括用于更高级用例的groupby聚合</h2></div><p id="002b" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">处理缺失数据是大多数机器学习项目的固有部分。一个典型的方法是使用<code class="fe lw lx ly lz b">scikit-learn</code>的<code class="fe lw lx ly lz b">SimpleImputer</code>(或者来自<code class="fe lw lx ly lz b">sklearn.impute</code>模块的另一个估算器)。然而，通常最简单的方法可能不是最好的，我们可以通过使用更复杂的方法获得一些额外的性能。</p><p id="53a4" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">这就是为什么在这篇文章中，我想演示如何编写一个自定义的基于<code class="fe lw lx ly lz b">scikit-learn</code>的估算器。为了使案例更有趣，估算者将根据各组的平均值/中位数来填充缺失值。</p><h1 id="ad08" class="ma mb jl bd mc md me mf mg mh mi mj mk kr ml ks mm ku mn kv mo kx mp ky mq mr bi translated"><strong class="ak">为什么要把自定义的imputer写成类？</strong></h1><p id="d74d" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">在直接进入编码之前，我想详细说明一下为什么编写一个定制的估算类(从<code class="fe lw lx ly lz b">scikit-learn</code>继承)值得你花时间的几个潜在原因:</p><ul class=""><li id="1eef" class="mx my jl lc b ld le lg lh lj mz ln na lr nb lv nc nd ne nf bi translated">它可以帮助你发展编程技能——在编写继承自<code class="fe lw lx ly lz b">scikit-learn</code>的估算器时，你可以了解一些贡献者已经使用的最佳实践。此外，通过继承，您可以使用一些已经准备好的方法。这样，您的代码将会更好/更干净，并且对于一些不可预见的问题可能会更健壮。</li><li id="e94d" class="mx my jl lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">您的自定义类可以随着时间的推移进一步开发，并可能与其他用户共享(甚至可能集成到<code class="fe lw lx ly lz b">scikit-learn</code>！)</li><li id="6d94" class="mx my jl lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">更实际的是，通过使用<code class="fe lw lx ly lz b">scikit-learn</code>框架创建估算器，你可以使它们与<code class="fe lw lx ly lz b">scikit-learn</code>的<code class="fe lw lx ly lz b">Pipelines</code>兼容，这使得项目的流程更加清晰，更容易复制/生产。另一个实际问题是<code class="fe lw lx ly lz b">fit</code>和<code class="fe lw lx ly lz b">transform</code>方法之间的明确区别，因此您不会意外引入<strong class="lc jm">数据泄漏</strong>——包括在确定用于输入的值的过程中的测试数据。</li></ul><h1 id="c78b" class="ma mb jl bd mc md me mf mg mh mi mj mk kr ml ks mm ku mn kv mo kx mp ky mq mr bi translated">实现自定义估算器</h1><p id="e7ec" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">在这一节中，我们将使用Python实现自定义估算器。</p><h2 id="6057" class="nl mb jl bd mc nm nn dn mg no np dp mk lj nq nr mm ln ns nt mo lr nu nv mq nw bi translated">设置</h2><p id="a3e0" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">首先，我们加载所有需要的库:</p><figure class="nx ny nz oa gt ix"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="b773" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">为了写这篇文章，我使用了<code class="fe lw lx ly lz b">scikit-learn</code>版本0.22.2。</p><h2 id="3f22" class="nl mb jl bd mc nm nn dn mg no np dp mk lj nq nr mm ln ns nt mo lr nu nv mq nw bi translated">生成样本数据</h2><p id="6a3f" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">在这篇文章中，我们将使用一个玩具数据集。我们假设收集来自两个不同人群(样本<code class="fe lw lx ly lz b">A</code>和<code class="fe lw lx ly lz b">B</code>)的人的身高，因此数据会有一些变化。此外，第一个样品还有一个区别特征，称为<code class="fe lw lx ly lz b">variant</code>(值为<code class="fe lw lx ly lz b">a</code>和<code class="fe lw lx ly lz b">b</code>)。这个命名结构背后是什么并不重要，目标是有两个不同级别的可能聚合。然后，我们根据<code class="fe lw lx ly lz b">sample_name</code>用不同的比例和位置参数值从正态分布中采样高度(使用<code class="fe lw lx ly lz b">numpy.random.normal</code>)。</p><figure class="nx ny nz oa gt ix"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="f952" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">通过使用<code class="fe lw lx ly lz b">sample(frac=1)</code>，我们基本上重组了<code class="fe lw lx ly lz b">DataFrame</code>，所以我们的数据集看起来不那么人工。下面你可以看到创建的<code class="fe lw lx ly lz b">DataFrame</code>的预览。</p><figure class="nx ny nz oa gt ix gh gi paragraph-image"><div class="gh gi od"><img src="../Images/e7ce782b7796510d6b3701c8a631b243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*yx2bDtpzxcfAXHf6ToKv-g.png"/></div><p class="je jf gj gh gi jg jh bd b be z dk translated">生成数据的预览</p></figure><p id="447e" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">然后，我们使用以下代码用NaN值替换10个随机高度:</p><figure class="nx ny nz oa gt ix"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="434f" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">现在，<code class="fe lw lx ly lz b">DataFrame</code>已准备好插补。</p><h2 id="0523" class="nl mb jl bd mc nm nn dn mg no np dp mk lj nq nr mm ln ns nt mo lr nu nv mq nw bi translated">对估算器进行编码</h2><p id="aad1" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">是时候对估算器进行编码了。您可以在下面找到该类的定义:</p><figure class="nx ny nz oa gt ix"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="39b3" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">如前所述，通过使用从<code class="fe lw lx ly lz b">sklearn.base</code>类(<code class="fe lw lx ly lz b">BaseEstimator</code>，<code class="fe lw lx ly lz b">TransformerMixin</code>)的继承，我们完成了很多工作，同时自定义的估算器类与<code class="fe lw lx ly lz b">scikit-learn</code>的<code class="fe lw lx ly lz b">Pipelines</code>兼容。</p><p id="d80d" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">那么后台到底发生了什么呢？通过从<code class="fe lw lx ly lz b">BaseEstimator</code>继承，我们自动得到<code class="fe lw lx ly lz b">get_params</code>和<code class="fe lw lx ly lz b">set_params</code>方法(所有的<code class="fe lw lx ly lz b">scikit-learn</code>估算器都需要这些)。然后，从<code class="fe lw lx ly lz b">TransformerMixin</code>继承提供了<code class="fe lw lx ly lz b">fit_transform</code>方法。</p><blockquote class="oe of og"><p id="3f28" class="la lb oh lc b ld le km lf lg lh kp li oi lk ll lm oj lo lp lq ok ls lt lu lv io bi translated"><strong class="lc jm">注意:</strong>还有其他种类的Mixin类可供继承。我们是否需要这样做取决于我们想要编码的估计器的类型。例如，<code class="fe lw lx ly lz b">ClassifierMixin</code>和<code class="fe lw lx ly lz b">RegressorMixin</code>让我们可以使用<code class="fe lw lx ly lz b">score</code>方法来评估估计器的性能。</p></blockquote><p id="68f1" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在<code class="fe lw lx ly lz b">__init__</code>方法中，我们存储了输入参数:</p><ul class=""><li id="08d9" class="mx my jl lc b ld le lg lh lj mz ln na lr nb lv nc nd ne nf bi translated"><code class="fe lw lx ly lz b">group_cols</code> —要聚合的列的列表，</li><li id="ccbd" class="mx my jl lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe lw lx ly lz b">target</code> —插补的目标列(缺失值所在的列)，</li><li id="235f" class="mx my jl lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe lw lx ly lz b">metric</code> —我们希望用于插补的指标，可以是组的平均值或中值。</li></ul><p id="1074" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">此外，我们包含了一组断言来确保我们传入了正确的输入。</p><p id="b078" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在<code class="fe lw lx ly lz b">fit</code>方法中，我们计算<code class="fe lw lx ly lz b">impute_map_</code>，它是一个<code class="fe lw lx ly lz b">DataFrame</code>，其聚合指标用于输入。我们还检查用于聚合的列中是否没有缺失值。还有一点非常重要，那就是<code class="fe lw lx ly lz b">fit</code>方法应该总是返回<code class="fe lw lx ly lz b">self</code>！</p><p id="f5d6" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">最后，在<code class="fe lw lx ly lz b">transform</code>方法中，我们用适当的值替换每个组中缺失的值(由<code class="fe lw lx ly lz b">impute_map_</code>的行指示)。作为额外的预防措施，我们使用<code class="fe lw lx ly lz b">check_is_fitted</code>来确保在使用<code class="fe lw lx ly lz b">transform</code>方法之前我们已经拟合了估算对象。在实际转换数据之前，我们使用<code class="fe lw lx ly lz b">copy</code>方法制作了一个副本，以确保不会修改原始的源数据。关于这个话题的更多信息，你可以参考我之前的一篇<a class="ae ji" rel="noopener" target="_blank" href="/explaining-the-settingwithcopywarning-in-pandas-ebc19d799d25">文章</a>。</p><p id="457e" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在<code class="fe lw lx ly lz b">fit</code>和<code class="fe lw lx ly lz b">transform</code>方法中，我们还在方法定义中指定了<code class="fe lw lx ly lz b">y=None</code>，即使<code class="fe lw lx ly lz b">GroupImputer</code>类不会使用数据集的<code class="fe lw lx ly lz b">y</code>值(也称为目标，不要与表示插补目标的<code class="fe lw lx ly lz b">target</code>参数混淆)。包含它的原因是为了确保与其他<code class="fe lw lx ly lz b">scikit-learn</code>类的兼容性。</p><p id="c79a" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">是时候看看自定义估算器的运行了！</p><figure class="nx ny nz oa gt ix"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="7e59" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">运行代码会打印出以下内容:</p><pre class="nx ny nz oa gt ol lz om on aw oo bi"><span id="0f79" class="nl mb jl lz b gy op oq l or os">df contains 10 missing values.<br/>df_imp contains 0 missing values.</span></pre><p id="4c5c" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">与<code class="fe lw lx ly lz b">scikit-learn</code>中的所有估算器一样，我们首先创建对象的实例并指定参数。然后，我们使用<code class="fe lw lx ly lz b">fit_transform</code>方法创建新对象，用通过<code class="fe lw lx ly lz b">sample_name</code>和<code class="fe lw lx ly lz b">variant</code>计算的平均值替换<code class="fe lw lx ly lz b">height</code>列中缺失的值。</p><p id="1726" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">为了创建<code class="fe lw lx ly lz b">df_imp</code>，我们实际上需要手动将转换的输出转换为<code class="fe lw lx ly lz b">pd.DataFrame</code>，因为原始输出是一个<code class="fe lw lx ly lz b">numpy</code>数组。<code class="fe lw lx ly lz b">scikit-learn</code>中的所有估算器/变压器都是这种情况。</p><p id="45e8" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们可以看到，估算器按照预期工作，并替换了我们的玩具<code class="fe lw lx ly lz b">DataFrame</code>中所有缺失的值。</p><h1 id="7ff0" class="ma mb jl bd mc md me mf mg mh mi mj mk kr ml ks mm ku mn kv mo kx mp ky mq mr bi translated">结论</h1><p id="6412" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">在本文中，我展示了如何通过继承<code class="fe lw lx ly lz b">scikit-learn</code>中的一些基类来快速创建一个自定义估算器。这样，编码更快，我们也确保估算器与整个<code class="fe lw lx ly lz b">scikit-learn</code>框架兼容。</p><p id="78c6" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在进行机器学习项目时，创建自定义估算器/转换器肯定会派上用场。此外，我们总是可以为其他项目重用创建的类，因为我们首先试图使它尽可能灵活。</p><p id="a01b" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">您可以在我的<a class="ae ji" href="https://github.com/erykml/medium_articles/blob/master/Machine%20Learning/custom_imputer.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到本文使用的代码。一如既往，我们欢迎任何建设性的反馈。你可以在推特上或者评论里联系我。</p><h1 id="a4ce" class="ma mb jl bd mc md me mf mg mh mi mj mk kr ml ks mm ku mn kv mo kx mp ky mq mr bi translated">参考</h1><p id="136d" class="pw-post-body-paragraph la lb jl lc b ld ms km lf lg mt kp li lj mu ll lm ln mv lp lq lr mw lt lu lv io bi translated">[1]<a class="ae ji" href="https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/impute/_base.py" rel="noopener ugc nofollow" target="_blank">https://github . com/sci kit-learn/sci kit-learn/blob/master/sk learn/impute/_ base . py</a></p><p id="4314" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">[2]<a class="ae ji" href="https://scikit-learn.org/stable/modules/generated/sklearn.base.BaseEstimator.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/generated/sk learn . base . base estimator . html</a></p><p id="3787" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">[3]<a class="ae ji" href="https://scikit-learn.org/stable/modules/generated/sklearn.base.TransformerMixin.html#sklearn.base.TransformerMixin" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/generated/sk learn . base . transformer mixin . html # sk learn . base . transformer mixin</a></p></div></div>    
</body>
</html>