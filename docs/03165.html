<html>
<head>
<title>Data Modeling for a Music Streaming App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">音乐流应用程序的数据建模</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-modeling-for-a-music-streaming-app-db46a4595e4e?source=collection_archive---------11-----------------------#2020-03-26">https://towardsdatascience.com/data-modeling-for-a-music-streaming-app-db46a4595e4e?source=collection_archive---------11-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7c23" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Udacity数据工程师纳米学位</h2><div class=""/><div class=""><h2 id="c6d4" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">创建一个Postgres数据库，其中的表用于优化歌曲播放分析的查询</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ece9f78695038bb5fce0ecfc1b6572e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UHUL1MgJzpVVVbSu"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">潘卡杰·帕特尔在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="cf35" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">介绍</h1><p id="0446" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我已经加入了Udacity数据工程师Nanodegree。该计划由许多现实世界的项目组成。在这个项目中，我在一家名为“Sparkify”的虚构数据流公司担任数据工程师。这是一家初创公司，希望分析他们在新的音乐流媒体应用程序上收集的歌曲和用户活动数据。分析团队对了解用户在听什么歌特别感兴趣。目前，他们没有一种简单的方法来查询他们的数据，这些数据位于应用程序上用户活动的JSON日志目录中，以及应用程序中歌曲的JSON元数据目录中。</p><p id="8a51" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">他们想要一个数据工程师来创建一个Postgres数据库，其表旨在优化歌曲播放分析的查询，并让我参与这个项目。我的角色是为这个分析创建一个数据库模式和ETL管道。我已经通过运行Sparkify的分析团队给我的查询测试了我的数据库和ETL管道，并将我的结果与他们的预期结果进行了比较。</p><h1 id="f067" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">项目描述</h1><p id="2c7f" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在这个项目中，我应用了我在Postgres数据建模方面学到的知识，并使用Python构建了一个ETL管道。我为特定分析焦点的星型模式定义了事实表和维度表，并使用Python和SQL编写了一个ETL管道，将数据从两个本地目录中的文件传输到Postgres的这些表中。</p><h1 id="7156" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">歌曲数据集</h1><p id="697c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">第一个数据集是来自<a class="ae lh" href="https://labrosa.ee.columbia.edu/millionsong/" rel="noopener ugc nofollow" target="_blank">百万首歌曲数据集</a>的真实数据子集。每个文件都是JSON格式的，包含关于一首歌和这首歌的艺术家的元数据。这些文件按每首歌曲曲目ID的前三个字母进行分区。例如，以下是该数据集中两个文件的文件路径。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="090e" class="ng lj it nc b gy nh ni l nj nk">song_data/A/B/C/TRABCEI128F424C983.json<br/>song_data/A/A/B/TRAABJL12903CDCF1A.json</span></pre><p id="f30b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">下面是一个歌曲文件TRAABJL12903CDCF1A.json的示例。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="f38d" class="ng lj it nc b gy nh ni l nj nk">{"num_songs": 1, "artist_id": "ARJIE2Y1187B994AB7", "artist_latitude": null, "artist_longitude": null, "artist_location": "", "artist_name": "Line Renaud", "song_id": "SOUPIRU12A6D4FA1E1", "title": "Der Kleine Dompfaff", "duration": 152.92036, "year": 0}</span></pre><h1 id="4b2e" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">日志数据集</h1><p id="721f" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">第二个数据集由这个<a class="ae lh" href="https://github.com/Interana/eventsim" rel="noopener ugc nofollow" target="_blank">事件模拟器</a>基于上面数据集中的歌曲生成的JSON格式的日志文件组成。这些根据指定的配置模拟音乐流媒体应用程序的活动日志。</p><p id="ce36" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">您将使用的数据集中的日志文件按年份和月份进行分区。例如，以下是该数据集中两个文件的文件路径。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="8c7e" class="ng lj it nc b gy nh ni l nj nk">log_data/2018/11/2018-11-12-events.json<br/>log_data/2018/11/2018-11-13-events.json</span></pre><p id="81cc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">下面是日志文件2018–11–12-events . JSON中数据的示例。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nl"><img src="../Images/bf60b2793b356fd81856216b3dc83ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bpyN8MgP8nmjeZCQE-xhIA.png"/></div></div></figure><p id="4d27" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果您想查看log_data文件中的JSON数据，您需要创建一个pandas数据帧来读取数据。记得先导入JSON和pandas库。</p><p id="956d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe nm nn no nc b">df = pd.read_json(filepath, lines=True)</code></p><p id="8c91" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">例如，<code class="fe nm nn no nc b">df = pd.read_json('data/log_data/2018/11/2018-11-01-events.json', lines=True)</code>将读取数据文件2018-11-01-events.json。</p><p id="2f76" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果你需要复习JSON文件格式，<a class="ae lh" href="https://www.youtube.com/watch?v=iiADhChRriM" rel="noopener ugc nofollow" target="_blank">这里有一个有用的视频</a>。</p><h1 id="c066" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">歌曲分析的图式</h1><p id="c1f5" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">使用歌曲和日志数据集，我创建了一个针对歌曲播放分析查询优化的星型模式。这包括以下表格。</p><h2 id="30e9" class="ng lj it bd lk np nq dn lo nr ns dp ls mj nt nu lu mn nv nw lw mr nx ny ly iz bi translated">事实表</h2><p id="1916" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><strong class="mc jd">歌曲播放</strong> —日志数据中与歌曲播放相关的记录，即带有页面<code class="fe nm nn no nc b">NextSong<br/></code>的记录<em class="nz">歌曲播放标识、开始时间、用户标识、级别、歌曲标识、艺术家标识、会话标识、位置、用户代理</em></p><h2 id="eeba" class="ng lj it bd lk np nq dn lo nr ns dp ls mj nt nu lu mn nv nw lw mr nx ny ly iz bi translated">维度表</h2><p id="1e69" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><strong class="mc jd">用户</strong> —应用中的用户<br/> <em class="nz">用户标识、名字、姓氏、性别、级别</em></p><p id="201f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">歌曲</strong> —音乐数据库中的歌曲<br/> <em class="nz">歌曲id、标题、艺术家id、年份、时长</em></p><p id="b694" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">艺术家</strong> —音乐数据库中的艺术家<br/> <em class="nz">艺术家_id、姓名、地点、纬度、经度</em></p><p id="7c3d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">时间</strong>—<strong class="mc jd">歌曲播放</strong>中记录的时间戳分解成具体的单位<br/>s<em class="nz">start _ time、hour、day、week、month、year、weekday </em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/cc8d570164d7a02af7dde4528ca7d923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6jMfH2z4ULP7z0QKN-4ag.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">火花数据库的ER图</p></figure><p id="4909" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在处理关系数据库系统时，像列中的<code class="fe nm nn no nc b">Primary key</code>和<code class="fe nm nn no nc b">NOT NULL</code>这样的条件很重要。同样，作为一名数据工程师，必须根据业务需求指定主键列，并且不能为空。例如，<em class="nz">用户标识</em>和<em class="nz">开始时间</em>应该被认为不为空。</p><h1 id="7be4" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">项目模板</h1><p id="1200" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">除了数据文件之外，项目工作环境还包括六个文件:</p><ol class=""><li id="7ae5" class="ob oc it mc b md mw mg mx mj od mn oe mr of mv og oh oi oj bi translated"><code class="fe nm nn no nc b"><a class="ae lh" href="https://github.com/joshuayeung/Data-Modeling-for-a-Music-Streaming-App/blob/master/test.ipynb" rel="noopener ugc nofollow" target="_blank">test.ipynb</a></code>显示每个表格的前几行以检查数据库。</li><li id="cbe5" class="ob oc it mc b md ok mg ol mj om mn on mr oo mv og oh oi oj bi translated"><code class="fe nm nn no nc b"><a class="ae lh" href="https://github.com/joshuayeung/Data-Modeling-for-a-Music-Streaming-App/blob/master/create_tables.py" rel="noopener ugc nofollow" target="_blank">create_tables.py</a></code>放下并创建表格。每次运行ETL脚本之前，我都会运行这个文件来重置我的表。</li><li id="affa" class="ob oc it mc b md ok mg ol mj om mn on mr oo mv og oh oi oj bi translated"><code class="fe nm nn no nc b"><a class="ae lh" href="https://github.com/joshuayeung/Data-Modeling-for-a-Music-Streaming-App/blob/master/etl.ipynb" rel="noopener ugc nofollow" target="_blank">etl.ipynb</a></code>读取并处理来自<code class="fe nm nn no nc b">song_data</code>和<code class="fe nm nn no nc b">log_data</code>的单个文件，并将数据加载到表格中。这个笔记本包含了对每个表的ETL过程的详细解释。</li><li id="ced0" class="ob oc it mc b md ok mg ol mj om mn on mr oo mv og oh oi oj bi translated"><code class="fe nm nn no nc b"><a class="ae lh" href="https://github.com/joshuayeung/Data-Modeling-for-a-Music-Streaming-App/blob/master/etl.py" rel="noopener ugc nofollow" target="_blank">etl.py</a></code>从<code class="fe nm nn no nc b">song_data</code>和<code class="fe nm nn no nc b">log_data</code>读取并处理文件，加载到表格中。</li><li id="2266" class="ob oc it mc b md ok mg ol mj om mn on mr oo mv og oh oi oj bi translated"><code class="fe nm nn no nc b"><a class="ae lh" href="https://github.com/joshuayeung/Data-Modeling-for-a-Music-Streaming-App/blob/master/sql_queries.py" rel="noopener ugc nofollow" target="_blank">sql_queries.py</a></code>包含所有的SQL查询，并被导入到上面的最后三个文件中。</li></ol><h1 id="1f38" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">创建表格</h1><p id="52aa" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">为了创建我需要的所有表，我完成了以下四个步骤:</p><ol class=""><li id="6116" class="ob oc it mc b md mw mg mx mj od mn oe mr of mv og oh oi oj bi translated">在<code class="fe nm nn no nc b"><a class="ae lh" href="https://github.com/joshuayeung/Data-Modeling-for-a-Music-Streaming-App/blob/master/sql_queries.py" rel="noopener ugc nofollow" target="_blank">sql_queries.py</a></code>中编写<code class="fe nm nn no nc b">CREATE</code>语句，根据上面定义的模式创建每个表。</li><li id="f6dd" class="ob oc it mc b md ok mg ol mj om mn on mr oo mv og oh oi oj bi translated">在<code class="fe nm nn no nc b"><a class="ae lh" href="https://github.com/joshuayeung/Data-Modeling-for-a-Music-Streaming-App/blob/master/sql_queries.py" rel="noopener ugc nofollow" target="_blank">sql_queries.py</a></code>中编写<code class="fe nm nn no nc b">DROP</code>语句来删除每个表(如果存在的话)。</li><li id="ba7a" class="ob oc it mc b md ok mg ol mj om mn on mr oo mv og oh oi oj bi translated">运行<code class="fe nm nn no nc b"><a class="ae lh" href="https://github.com/joshuayeung/Data-Modeling-for-a-Music-Streaming-App/blob/master/create_tables.py" rel="noopener ugc nofollow" target="_blank">create_tables.py</a></code>创建数据库和表格。</li><li id="225a" class="ob oc it mc b md ok mg ol mj om mn on mr oo mv og oh oi oj bi translated">运行<code class="fe nm nn no nc b"><a class="ae lh" href="https://github.com/joshuayeung/Data-Modeling-for-a-Music-Streaming-App/blob/master/test.ipynb" rel="noopener ugc nofollow" target="_blank">test.ipynb</a></code>确认用正确的列创建表格。运行本笔记本后，确保点击“重启内核”关闭与数据库的连接。</li></ol><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="op oq l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">创建歌曲播放表的CREATE语句</p></figure><p id="b923" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在create_tables.py中，有一个函数<code class="fe nm nn no nc b">create_tables</code>来执行<code class="fe nm nn no nc b">create_table_queries</code>列表中列出的所有查询。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="a1cf" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">您可以看到这些表是用test.ipynb中定义的列创建的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi or"><img src="../Images/a42f4c928e4336db3469aa7f42d24411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*8S28Vn_nxg-dvfHY9tjD7g.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">确认创建了具有正确列的表。</p></figure><h1 id="9f6a" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">构建ETL管道</h1><p id="0e6b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">是时候为每个表开发ETL过程了。在etl.py中，有一个函数叫做<code class="fe nm nn no nc b">process_data</code>。您可以传递处理数据所需的文件路径和处理函数。它获取所有与扩展名匹配的文件。json)从目录。然后它使用传入的函数遍历文件和进程。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="op oq l"/></div></figure><h1 id="5fe9" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">流程<code class="fe nm nn no nc b">song_data</code></h1><p id="b3c9" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">首先，让我们处理<code class="fe nm nn no nc b">song_data</code>并创建<code class="fe nm nn no nc b">songs</code>和<code class="fe nm nn no nc b">artists</code>维度表。我构建了<code class="fe nm nn no nc b">process_song_file</code>函数来执行以下任务:</p><ul class=""><li id="7341" class="ob oc it mc b md mw mg mx mj od mn oe mr of mv os oh oi oj bi translated">首先，在<code class="fe nm nn no nc b">data/song_data</code>中获取所有song JSON文件的列表</li><li id="0dc0" class="ob oc it mc b md ok mg ol mj om mn on mr oo mv os oh oi oj bi translated">阅读歌曲文件</li><li id="2623" class="ob oc it mc b md ok mg ol mj om mn on mr oo mv os oh oi oj bi translated">提取歌曲表的数据并将数据插入歌曲表</li><li id="4d25" class="ob oc it mc b md ok mg ol mj om mn on mr oo mv os oh oi oj bi translated">提取艺术家表的数据并将数据插入艺术家表</li></ul><h2 id="74a5" class="ng lj it bd lk np nq dn lo nr ns dp ls mj nt nu lu mn nv nw lw mr nx ny ly iz bi translated">提取歌曲表的数据</h2><p id="43da" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">要提取歌曲表的数据，需要完成以下任务:</p><ul class=""><li id="498d" class="ob oc it mc b md mw mg mx mj od mn oe mr of mv os oh oi oj bi translated">选择歌曲ID、标题、艺术家ID、年份和持续时间的列</li><li id="0402" class="ob oc it mc b md ok mg ol mj om mn on mr oo mv os oh oi oj bi translated">使用<code class="fe nm nn no nc b">df.values</code>从数据框中选择数值</li><li id="4f4c" class="ob oc it mc b md ok mg ol mj om mn on mr oo mv os oh oi oj bi translated">索引以选择数据帧中的第一条(唯一的)记录</li><li id="c423" class="ob oc it mc b md ok mg ol mj om mn on mr oo mv os oh oi oj bi translated">将数组转换为列表，并将其设置为<code class="fe nm nn no nc b">song_data</code></li></ul><h2 id="661c" class="ng lj it bd lk np nq dn lo nr ns dp ls mj nt nu lu mn nv nw lw mr nx ny ly iz bi translated">将记录插入歌曲表</h2><p id="fb36" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在<code class="fe nm nn no nc b">sql_queries.py</code>中编写<code class="fe nm nn no nc b">song_table_insert</code>查询，并将这首歌曲的记录插入到<code class="fe nm nn no nc b">songs</code>表中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="op oq l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">sql _ queries.py中的song_table_insert查询</p></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="op oq l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">将歌曲记录插入歌曲表的代码</p></figure><h2 id="68e7" class="ng lj it bd lk np nq dn lo nr ns dp ls mj nt nu lu mn nv nw lw mr nx ny ly iz bi translated">提取艺术家表的数据并将记录插入艺术家表</h2><p id="62ae" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">艺术家表的数据提取类似于歌曲表的数据提取，但是这次我选择了艺术家ID、姓名、位置、纬度和经度列。</p><h1 id="beca" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">流程<code class="fe nm nn no nc b">log_data</code></h1><p id="e128" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">其次，我对第二个数据集<code class="fe nm nn no nc b">log_data</code>执行了ETL，创建了<code class="fe nm nn no nc b">time</code>和<code class="fe nm nn no nc b">users</code>维度表，以及<code class="fe nm nn no nc b">songplays</code>事实表。</p><h2 id="266a" class="ng lj it bd lk np nq dn lo nr ns dp ls mj nt nu lu mn nv nw lw mr nx ny ly iz bi translated">提取时间表的数据并将记录插入时间表</h2><p id="4887" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我已经通过<code class="fe nm nn no nc b">NextSong</code>动作过滤了记录</p><p id="2c7d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe nm nn no nc b">df = df[df['page']=='NextSong']</code></p><p id="1675" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">并将<code class="fe nm nn no nc b">ts</code>时间戳列转换为日期时间。</p><p id="473f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe nm nn no nc b">t = pd.to_datetime(df['ts'], unit='ms')</code></p><blockquote class="ot ou ov"><p id="425f" class="ma mb nz mc b md mw kd mf mg mx kg mi ow my ml mm ox mz mp mq oy na mt mu mv im bi translated">注意:当前时间戳以毫秒为单位</p></blockquote><p id="5c02" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我使用pandas的<code class="fe nm nn no nc b">dt</code>属性轻松访问类似日期时间的属性，例如来自<code class="fe nm nn no nc b">ts</code>列的小时、日、星期、月、年和工作日，并将<code class="fe nm nn no nc b">time_data</code>设置为按顺序包含这些值的列表。我还为这些列指定了标签，并设置为<code class="fe nm nn no nc b">column_labels</code>。我创建了一个数据帧，<code class="fe nm nn no nc b">time_df,</code>，包含这个文件的时间数据，方法是将<code class="fe nm nn no nc b">column_labels</code>和<code class="fe nm nn no nc b">time_data</code>组合成一个字典，并将其转换成一个数据帧。最后，我将日志文件中时间戳的记录插入到<code class="fe nm nn no nc b">time</code>表中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="ef81" class="ng lj it bd lk np nq dn lo nr ns dp ls mj nt nu lu mn nv nw lw mr nx ny ly iz bi translated">提取用户表的数据并将记录插入用户表</h2><p id="8526" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">用户表的数据提取很容易，只需选择用户ID、名字、姓氏、性别和级别的列并设置为<code class="fe nm nn no nc b">user_df</code>，然后将该日志文件中的用户记录插入到<code class="fe nm nn no nc b">users</code>表中。</p><h2 id="eff9" class="ng lj it bd lk np nq dn lo nr ns dp ls mj nt nu lu mn nv nw lw mr nx ny ly iz bi translated">一些笔记</h2><p id="9ea5" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">需要为每个表修改INSERT语句，以便在适当的时候处理现有记录。作为一名数据工程师，我需要仔细考虑当新数据被插入表中时，表将如何处理现有记录。</p><p id="78e2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">例如，对用户表使用<code class="fe nm nn no nc b">on conflict update</code>，因为级别可以从免费变为付费。</p><h2 id="71c8" class="ng lj it bd lk np nq dn lo nr ns dp ls mj nt nu lu mn nv nw lw mr nx ny ly iz bi translated">提取数据和歌曲播放表</h2><p id="5ee7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这个有点复杂，因为<code class="fe nm nn no nc b">songs</code>表、<code class="fe nm nn no nc b">artists</code>表和原始日志文件中的信息都是<code class="fe nm nn no nc b">songplays</code>表所需要的。因为日志文件没有为歌曲或艺术家指定ID，所以我需要通过查询<code class="fe nm nn no nc b">songs</code>和<code class="fe nm nn no nc b">artists</code>表来获得歌曲ID和艺术家ID，以便根据歌曲标题、艺术家姓名和歌曲的持续时间找到匹配项。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="op oq l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用歌曲标题、艺术家姓名和歌曲持续时间来查询歌曲ID和艺术家ID的SELECT语句。</p></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="4cde" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">由于这是一个更大的数据集的子集，解决方案数据集将只有一行，其值包含事实表中<code class="fe nm nn no nc b">songid</code>和<code class="fe nm nn no nc b">artistid</code>的ID。这是<code class="fe nm nn no nc b">sql_queries.py</code>中的查询将返回的唯一两个非空值。对于这两个变量，其余的行将没有值。</p><h1 id="9fcf" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">结论</h1><p id="0509" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">就是这样。我创建了一个Postgres数据库，其中的表是为优化歌曲播放分析的查询而设计的。分析团队现在可以轻松地查询他们的数据，并分析了解用户正在听什么歌曲。</p><p id="77f8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">更多细节可以访问我的<a class="ae lh" href="https://github.com/joshuayeung/Data-Modeling-for-a-Music-Streaming-App" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p></div></div>    
</body>
</html>