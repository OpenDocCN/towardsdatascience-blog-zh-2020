<html>
<head>
<title>Fit multiple propensity models and choose the best performing one for implementing a profit optimisation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拟合多个倾向模型，并选择最佳表现的一个来实现利润优化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-h2o-and-dalex-to-estimate-the-likelihood-to-purchase-a-financial-product-a53f891f0d1?source=collection_archive---------7-----------------------#2020-05-02">https://towardsdatascience.com/using-h2o-and-dalex-to-estimate-the-likelihood-to-purchase-a-financial-product-a53f891f0d1?source=collection_archive---------7-----------------------#2020-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f680" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用h2o和DALEX评估购买金融产品可能性的案例研究</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/60db3d61081045d5af07ee9884a2371c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8MzZoO24JZEL5mG1gXnc2g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹·梅耶斯在<a class="ae ky" href="https://unsplash.com/@dmey503?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在当今时代，利用数据来理解客户行为驱动因素的企业拥有真正的竞争优势。通过有效地分析客户层面的数据，组织可以显著提高其在市场中的表现，并将精力集中在那些更有可能参与的客户身上。</p><p id="b4bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从数据中梳理这种洞察力的一种经过试验和测试的方法是<a class="ae ky" href="https://en.wikipedia.org/wiki/Predictive_modelling" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">倾向建模</strong> </a>，它结合了以下信息:a <strong class="lb iu">客户的人口统计数据</strong>(年龄、种族、宗教、性别、家庭规模、种族、收入、教育水平)<strong class="lb iu">心理图</strong>(社会阶层、生活方式和个性特征)<strong class="lb iu">参与度</strong>(打开的电子邮件、点击的电子邮件、移动应用程序上的搜索、网页停留时间等)。)、<strong class="lb iu">用户体验</strong>(客户服务电话和电子邮件等待时间、退款次数、平均运送时间)<strong class="lb iu">用户行为</strong>(不同时间尺度上的购买价值、最近一次购买后的天数、报价和转换之间的时间等)。)来估计某个客户档案执行某类行为(例如购买产品)的可能性。</p><p id="b23d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你了解了某个客户与某个品牌互动、购买某个产品或注册某项服务的可能性，你就可以利用这些信息来创造情景，比如最小化<strong class="lb iu">营销支出</strong>，最大化<strong class="lb iu">收购目标</strong>，以及优化<strong class="lb iu">电子邮件发送频率</strong>或<strong class="lb iu">折扣深度</strong>。</p><h1 id="1ade" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">项目结构</h1><p id="dd26" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这个项目中，我正在分析一家银行向现有客户销售定期a存款的直接营销活动的结果，以确定哪种类型的特征更有可能让客户做出反应。营销活动基于电话，有时需要与同一个人进行多次联系。</p><p id="bdc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我将进行<strong class="lb iu">广泛的数据探索</strong>，并使用结果和见解为分析准备数据。</p><p id="e485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我正在<strong class="lb iu">估算模型的数量</strong>，并使用<strong class="lb iu">模型不可知的方法</strong>评估它们的性能和对数据的拟合，这使得<strong class="lb iu">能够比较传统的“玻璃箱”模型和“黑箱”模型</strong>。</p><p id="48bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我将<strong class="lb iu">拟合一个最终模型</strong>，该模型结合了探索性分析的结果和模型选择的洞察力，并使用该模型<strong class="lb iu">进行收入优化</strong>。</p><h1 id="0ad0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数据</h1><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7fcd" class="mx lw it mt b gy my mz l na nb">library(tidyverse)<br/>library(data.table)<br/>library(skimr)<br/>library(correlationfunnel)<br/>library(GGally)<br/>library(ggmosaic)<br/>library(knitr)<br/>library(h2o)<br/>library(DALEX)<br/>library(knitr)<br/>library(tictoc)</span></pre><p id="abf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据是来自<a class="ae ky" href="https://archive.ics.uci.edu/ml/datasets" rel="noopener ugc nofollow" target="_blank"> UCI机器学习库</a>的<a class="ae ky" href="https://archive.ics.uci.edu/ml/datasets/Bank+Marketing" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">葡萄牙银行营销</strong> </a>集，描述了一家葡萄牙银行机构开展的旨在向其客户销售定期存款/存单的直接营销活动。营销活动基于2008年5月至2010年11月期间对潜在买家的电话访问。</p><p id="481c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我正在使用的数据<a class="ae ky" href="https://github.com/DiegoUsaiUK/Propensity_Modelling/tree/master/01_data/bank-direct-marketing.csv" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">(bank-direct-marketing . CSV</strong></a><strong class="lb iu">)</strong>是<a class="ae ky" href="https://archive.ics.uci.edu/ml/machine-learning-databases/00222/bank-additional.zip" rel="noopener ugc nofollow" target="_blank">bank-additional-full . CSV</a>的修改版本，包含41，188个带有21个不同变量的示例(10个连续变量，10个分类变量加上目标变量)。具体来说，目标<strong class="lb iu">订阅</strong>是一个<strong class="lb iu">二进制响应变量</strong>，表示客户是否订阅(‘是’或数值1)定期存款(‘否’或数值0)，这使得这成为一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Binary_classification" rel="noopener ugc nofollow" target="_blank"> <em class="nc">二进制分类问题</em> </a>。</p><p id="d098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些数据需要一些操作才能变成可用的格式，详情可以在我的网页上找到:<a class="ae ky" href="https://diegousai.io/2020/01/propensity-modelling-data-preparation" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">倾向建模——数据准备和探索性数据分析</strong>。</a>在这里，我简单地在我的GitHub repo上为这个项目 加载我托管的预清理数据<a class="ae ky" href="https://github.com/DiegoUsaiUK/Propensity_Modelling" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"/></a></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8ae5" class="mx lw it mt b gy my mz l na nb">data_clean &lt;- <br/>  readRDS(file = "https://raw.githubusercontent.com/DiegoUsaiUK/Propensity_Modelling/master/01_data/data_clean.rds")</span></pre><h1 id="fd70" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">探索性数据分析</h1><p id="060e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">虽然是任何数据科学项目不可或缺的一部分，并且对分析的完全成功至关重要，但<a class="ae ky" href="https://en.wikipedia.org/wiki/Exploratory_data_analysis" rel="noopener ugc nofollow" target="_blank">探索性数据分析(EDA) </a>可能是一个极其耗费人力和时间的过程。近年来，旨在加速这一过程的方法和库大量涌现，在这个项目中，我将对其中一个“街区上的新孩子”(<a class="ae ky" href="https://business-science.github.io/correlationfunnel/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">correlation funnel</strong></a>)进行采样，并将其结果与更传统的EDA相结合。</p><h1 id="a628" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">相关通道</h1><p id="4eb0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">通过3个简单的步骤<code class="fe nd ne nf mt b">correlationfunnel</code>可以生成一个图表，按照与目标变量绝对相关性的降序排列预测值。漏斗顶部的特征预计在模型中具有更强的预测能力。</p><p id="39cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法提供了一种快速确定所有变量的预期预测能力等级的方法，并给出了任何模型中哪些预测因子应该具有强/弱特征的早期指示。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c736" class="mx lw it mt b gy my mz l na nb">data_clean %&gt;%  <br/>      <br/>  binarize(n_bins = 4, # bin number for converting features<br/>           thresh_infreq = 0.01 # thresh. for assign categ.             <br/>                                # features into "Other"<br/>          ) %&gt;%</span><span id="d6c9" class="mx lw it mt b gy ng mz l na nb">      # correlate target variable to features <br/>  correlate(target = subscribed__1) %&gt;% </span><span id="0110" class="mx lw it mt b gy ng mz l na nb">      # correlation funnel visualisation<br/>  plot_correlation_funnel()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/5ed62920cf8cc13efe01cad0307bc7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Xln_nzbmJlgBrusmTJ7UQ.png"/></div></div></figure><p id="fad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">放大前5个特征，我们可以看到，在以下情况下，某些特征与目标变量(订购定期存款产品)的相关性更大:</p><ul class=""><li id="3f32" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">与客户最后一次电话联系的时间是319秒或更长</li><li id="b3dc" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">客户最后一次联系后经过的<code class="fe nd ne nf mt b">days</code>数量大于6</li><li id="894a" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe nd ne nf mt b">previous</code>营销活动的结果是<code class="fe nd ne nf mt b">success</code></li><li id="9c30" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">就业人数为509.9万或更多</li><li id="45f7" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">3个月欧元银行同业拆放利率的值为1.344或更高</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/71b42400ff4bd1576541da24b5ca3e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfBunWdvmw5PQiwDm_fE5A.png"/></div></div></figure><p id="6172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，漏斗底部的变量，如<strong class="lb iu">星期几</strong>、<strong class="lb iu">住房</strong>和<strong class="lb iu">贷款</strong>。与目标变量相比，变化非常小(即:它们非常接近响应的零相关点)。因此，我不认为这些特性会影响响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/51094410e6e10de834b4c150116331cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HzF1HQ-xtPMEgn56arXzvA.png"/></div></div></figure><h1 id="e966" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">功能探索</h1><p id="1f1b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这种视觉相关性分析结果的指导下，我将在下一节中继续探索目标和每个预测因素之间的关系。为此，我将寻求优秀的<strong class="lb iu"> GGally </strong>库的帮助，用<code class="fe nd ne nf mt b">Ggpairs</code>可视化相关矩阵的修改版本，用<strong class="lb iu"> ggmosaic </strong>包绘制<code class="fe nd ne nf mt b">mosaic charts</code>，这是检查两个或更多分类变量之间关系的好方法。</p><h2 id="341e" class="mx lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">目标变量</h2><p id="893e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，<strong class="lb iu">目标变量</strong> : <code class="fe nd ne nf mt b">subscribed</code>显示出<strong class="lb iu">强烈的阶级不平衡</strong>，在<strong class="lb iu">无类别</strong>中有近89%到<strong class="lb iu">有类别</strong>中有11%。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/ae3ddfa35af203e0467c0dc74322e90b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGxE4aash7thsPUbL8sX7Q.png"/></div></div></figure><p id="f8fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在建模阶段通过在<strong class="lb iu"> h2o </strong>中启用<strong class="lb iu">重新采样</strong>来解决<strong class="lb iu">类不平衡</strong>。这将通过“收缩”主要类别(“否”或“0”)来重新平衡数据集，并确保模型充分检测哪些变量在驱动“是”和“否”响应。</p><h2 id="7535" class="mx lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">预言者</h2><p id="0642" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们继续看一些数字特征:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/b24cd796dba94515d7343c000e14ba7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zl0K_PGhkOrpQQvClsgXVA.png"/></div></div></figure><p id="6eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管关联漏斗分析显示<strong class="lb iu">持续时间</strong>具有最强的预期预测能力，但它在通话前是未知的(显然在通话后是已知的),并且几乎不提供可操作的洞察力或预测价值。因此，它应该从任何现实的预测模型中被丢弃，并且不会在这个分析中被使用。</p><p id="a4ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">年龄</strong>的密度图与目标变量相比具有非常相似的方差，并且以相同的区域为中心。基于这些原因，应该不会对<strong class="lb iu">认购</strong>产生太大影响。</p><p id="b42f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管本质上是连续的，<strong class="lb iu"> pdays </strong>和<strong class="lb iu"> previous </strong>实际上是分类特征，并且都是强烈右偏的。由于这些原因，需要将它们离散成组。这两个变量也适度相关，表明它们可能捕捉到相同的行为。</p><p id="9b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我将<strong class="lb iu">银行客户数据</strong>与<em class="nc">马赛克图表</em>可视化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/8f3b1a32b2f7fa16f5621e24b133c8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tzOcWWQvITq4AI7BfLG7Gw.png"/></div></div></figure><p id="ec4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<em class="nc">相关渠道</em>的调查结果，<strong class="lb iu">工作</strong>、<strong class="lb iu">教育</strong>、<strong class="lb iu">婚姻</strong>和<strong class="lb iu">默认</strong>都显示出与目标变量相比的良好变化水平，表明它们会影响响应。相比之下，<strong class="lb iu">住房</strong>和<strong class="lb iu">贷款</strong>位于漏斗的最底部，预计对目标几乎没有影响，因为按“已认购”响应划分时变化很小。</p><p id="e0eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">默认</strong>只有3个“是”级别的观察值，这些观察值将被滚动到最不频繁的级别，因为它们不足以做出正确的推断。<strong class="lb iu">住房</strong>和<strong class="lb iu">贷款</strong>变量的“未知”级别有少量观察值，将被归入第二小类别。最后，工作、教育也将从最不常见水平的分组中受益。</p><p id="80eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续讨论<strong class="lb iu">其他活动属性</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/ebed33022e721690c9a4653d43eab1c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BwUzz7PL6T6O7FKUTo2hpg.png"/></div></div></figure><p id="17f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在原则上是连续的，<strong class="lb iu">战役</strong>在本质上是更明确的，并且是强烈右倾的，将需要被离散成组。然而，我们已经从早期的相关性分析中了解到，在任何模型中，这都不是一个强有力的变异驱动因素。</p><p id="5e23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<strong class="lb iu"> poutcome </strong>是期望具有强预测能力的属性之一。级别的不均匀分布表明将最不常见的级别(<strong class="lb iu">成功</strong>或<code class="fe nd ne nf mt b">scs</code>)归入另一个类别。然而，联系以前购买过定期存款的客户是具有最高预测能力的特征之一，需要保留不分组。</p><p id="c173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我在看<strong class="lb iu">最后一条联系信息</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/a08ddfc693fc10efc257063f723b6744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zq_crIFduyolmgmqg3Yi8g.png"/></div></div></figure><p id="754f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">联系</strong>和<strong class="lb iu">月份</strong>应影响响应变量，因为它们与目标相比都有较好的变化水平。<strong class="lb iu">月</strong>也将受益于最不常见级别的分组。</p><p id="bf14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，<strong class="lb iu">星期几</strong>似乎不会影响响应，因为水平之间没有足够的变化。</p><p id="bc16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，<strong class="lb iu">社会和经济属性</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/2907b5b85ea0870124f82c33bb686cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zw6WefOZmO9qfzqdAZ9bXQ.png"/></div></div></figure><p id="15bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与目标变量相比，所有的<em class="nc">社会和经济属性</em>都显示出良好的变化水平，这表明它们都应该对响应产生影响。它们都显示出<strong class="lb iu">高度的多模态</strong>，并且在密度图中不具有均匀的分布，并且将需要被分箱。</p><p id="384c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样值得注意的是，除了<em class="nc">消费者信心指数</em>之外，所有其他社会和经济属性彼此之间都有很强的相关性，这表明只有一个属性可以被包括在模型中，因为它们都在“拾取”相似的经济趋势。</p><h1 id="dc70" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">探索性数据分析总结</h1><ul class=""><li id="ad7d" class="ni nj it lb b lc mn lf mo li oh lm oi lq oj lu nn no np nq bi translated">使用<strong class="lb iu">相关通道</strong>进行的相关性分析有助于确定所有变量的预期预测能力等级</li><li id="06a8" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">期限</strong>与目标变量的相关性最强，而一些银行客户数据如<strong class="lb iu">住房</strong>和<strong class="lb iu">贷款</strong>的相关性最弱</li><li id="069f" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">但是，<strong class="lb iu">持续时间</strong>将<strong class="lb iu">而不是</strong>用于分析，因为它在调用前是未知的。因此，它提供的可操作的洞察力或预测价值非常少，应该从任何现实的预测模型中丢弃</li><li id="79b0" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">目标变量<strong class="lb iu"> subscribed </strong>显示了强烈的类别不平衡，其中近89%的<strong class="lb iu">没有变动</strong>，这需要在建模分析开始之前解决</li><li id="b245" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">大多数预测者将受益于最不常见水平的分组</li><li id="882c" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">进一步的特征探索揭示了大多数<strong class="lb iu">社会和经济背景属性</strong>彼此之间有很强的相关性，这表明在最终模型中只能考虑其中的一部分</li></ul><h1 id="362e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最终数据处理和转换</h1><p id="2e00" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">根据探索性数据分析的结果，我将最不常见的级别组合到“其他”类别中，将除<code class="fe nd ne nf mt b">age</code>之外的所有变量设置为无序因子(<strong class="lb iu"> h2o </strong>不支持有序分类变量)，并缩短一些分类变量的级别名称，以方便可视化。你可以在我的网页上找到所有细节和完整代码:<a class="ae ky" href="https://diegousai.io/2020/01/propensity-modelling-data-preparation" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">倾向建模——数据准备和探索性数据分析</strong>。</a></p><p id="739c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我简单地在我的GitHub repo  上加载最终的数据集托管<a class="ae ky" href="https://github.com/DiegoUsaiUK/Propensity_Modelling" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">:</strong></a></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8a5b" class="mx lw it mt b gy my mz l na nb">data_final &lt;- <br/>  readRDS(file = "https://raw.githubusercontent.com/DiegoUsaiUK/Propensity_Modelling/master/01_data/data_final.rds")</span></pre><h1 id="6061" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">建模策略</h1><p id="e526" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了坚持合理的项目运行时间，我选择了<strong class="lb iu"> h2o </strong>作为我的建模平台，因为它提供了许多优势:</p><ul class=""><li id="91c4" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">它非常容易使用，你可以立刻<strong class="lb iu">评估几个机器学习模型</strong></li><li id="64db" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">它<strong class="lb iu">不需要通过“二进制化”字符/因子变量来预处理它们</strong>(这是在“内部”完成的)，这进一步减少了数据格式化时间</li><li id="87de" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">它有一个功能，即<strong class="lb iu">处理在数据探索阶段突出显示的类不平衡</strong>——我只是在模型规范中设置了<code class="fe nd ne nf mt b">balance_classes</code> = TRUE，稍后会详细介绍</li><li id="b530" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">可以启用交叉验证</strong>，而不需要从训练集中“分割”出一个单独的<code class="fe nd ne nf mt b">validation frame</code></li><li id="8b25" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">超参数微调</strong>(也称为网格搜索)可以与多种策略一起实施，以确保运行时间在不影响性能的情况下得到限制</li></ul><h1 id="4688" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用h2o构建模型</h1><p id="e4e1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我开始用<code class="fe nd ne nf mt b">rsample</code>创建一个随机的训练和验证集，并将它们保存为<code class="fe nd ne nf mt b">train_tbl</code>和<code class="fe nd ne nf mt b">test_tbl</code>。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="83c8" class="mx lw it mt b gy my mz l na nb">set.seed(seed = 1975) </span><span id="089c" class="mx lw it mt b gy ng mz l na nb">train_test_split &lt;-<br/>  rsample::initial_split(<br/>    data = data_final,     <br/>    prop = 0.80   <br/>  ) </span><span id="cd12" class="mx lw it mt b gy ng mz l na nb">train_tbl &lt;- train_test_split %&gt;% rsample::training() <br/>test_tbl  &lt;- train_test_split %&gt;% rsample::testing()</span></pre><p id="cf30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我启动一个<strong class="lb iu"> h2o集群</strong>。我将内存集群的大小指定为“16G”，以帮助加快速度，并关闭进度条。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="cf34" class="mx lw it mt b gy my mz l na nb"># initialize h2o session and switch off progress bar<br/>h2o.no_progress() <br/>h2o.init(max_mem_size = "16G")</span></pre><p id="7d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我整理出响应和预测变量集。对于要执行的分类，我需要<strong class="lb iu">确保响应变量是因子</strong>(否则h2o将执行回归)。这是在数据清理和格式化阶段解决的。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="23c5" class="mx lw it mt b gy my mz l na nb"># response variable<br/>y &lt;- "subscribed"</span><span id="0cff" class="mx lw it mt b gy ng mz l na nb"># predictors set: remove response variable<br/>x &lt;- setdiff(names(train_tbl %&gt;% as.h2o()), y)</span></pre><h1 id="1add" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">拟合模型</h1><p id="86fe" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于这个项目，我正在估算一个<strong class="lb iu">广义线性模型</strong>(又名弹性网)、一个<strong class="lb iu">随机森林</strong>(其中<strong class="lb iu"> h2o </strong>指的是<em class="nc">分布式随机森林</em>)和一个<strong class="lb iu">梯度推进机</strong>(或GBM)。</p><p id="6b2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现对<code class="fe nd ne nf mt b">tree-based</code>模型(DRF和GBM)的网格搜索，我需要建立一个随机网格来<strong class="lb iu">搜索<code class="fe nd ne nf mt b">h2o.grid()</code>函数的最优超参数</strong>。为此，我从定义要传递给<code class="fe nd ne nf mt b">hyper_params</code>参数的<strong class="lb iu">搜索参数</strong>开始:</p><ul class=""><li id="8141" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><code class="fe nd ne nf mt b">sample_rate</code>用于设置每棵树的行采样率</li><li id="76c9" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe nd ne nf mt b">col_sample_rate_per_tree</code>定义了每棵树的列抽样</li><li id="4390" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe nd ne nf mt b">max_depth</code>指定最大树深</li><li id="1c75" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe nd ne nf mt b">min_rows</code>确定每片叶子的最小观察次数</li><li id="5274" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe nd ne nf mt b">mtries</code>(仅DRF)表示在树的每个节点上随机选择的列</li><li id="fd9d" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe nd ne nf mt b">learn_rate</code>(仅适用于GBM)指定建立模型时模型学习的速率</li></ul><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9f99" class="mx lw it mt b gy my mz l na nb"># DRF hyperparameters<br/>hyper_params_drf &lt;- <br/>  list(<br/>     mtries                   = seq(2, 5, by = 1), <br/>     sample_rate              = c(0.65, 0.8, 0.95),<br/>     col_sample_rate_per_tree = c(0.5, 0.9, 1.0),<br/>     max_depth                = seq(1, 30, by = 3),<br/>     min_rows                 = c(1, 2, 5, 10)<br/>   )</span><span id="c9e2" class="mx lw it mt b gy ng mz l na nb"># GBM hyperparameters<br/>hyper_params_gbm &lt;- <br/>  list(<br/>    learn_rate               = c(0.01, 0.1),<br/>    sample_rate              = c(0.65, 0.8, 0.95),<br/>    col_sample_rate_per_tree = c(0.5, 0.9, 1.0),<br/>    max_depth                = seq(1, 30, by = 3),<br/>    min_rows                 = c(1, 2, 5, 10)<br/>    )</span></pre><p id="78a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还为<code class="fe nd ne nf mt b">search_criteria</code>参数设置了第二个列表，这有助于管理模型的估计运行时间:</p><ul class=""><li id="557b" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">将<code class="fe nd ne nf mt b">strategy</code>参数设置为<strong class="lb iu"> RandomDiscrete </strong>，以便搜索从网格搜索参数中随机选择一个组合</li><li id="9abb" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">将<code class="fe nd ne nf mt b">stopping_metric</code>设置为AUC，作为提前停止的误差度量——当度量停止改善时，模型将停止构建新的树</li><li id="6afe" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">使用<code class="fe nd ne nf mt b">stopping_rounds</code>,我将指定考虑提前停止前的训练轮数</li><li id="5e5a" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">我使用<code class="fe nd ne nf mt b">stopping_tolerance</code>来设置继续训练过程所需的最小改进</li><li id="a47b" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe nd ne nf mt b">max_runtime_secs</code>将每个型号的搜索时间限制为<strong class="lb iu">一小时</strong></li></ul><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="cda3" class="mx lw it mt b gy my mz l na nb">search_criteria_all &lt;- <br/>   list(<br/>      strategy           = "RandomDiscrete",<br/>      stopping_metric    = "AUC",    <br/>      stopping_rounds    = 10,<br/>      stopping_tolerance = 0.0001,<br/>      max_runtime_secs   = 60 * 60<br/>   )</span></pre><p id="56f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我可以建立模型的公式。请注意，所有模型都有两个共同的参数:</p><ul class=""><li id="7790" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><code class="fe nd ne nf mt b">nfolds</code>参数，使<strong class="lb iu">交叉验证</strong>能够在不需要validation_frame的情况下执行——例如，如果设置为5，它将执行5重交叉验证</li><li id="feab" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">将<code class="fe nd ne nf mt b">balance_classes</code>参数设置为<em class="nc">真</em>，以解决探索性分析期间突出显示的目标变量的不平衡。启用后，h2o将对多数类进行欠采样或对少数类进行过采样。</li></ul><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0d70" class="mx lw it mt b gy my mz l na nb"># elastic net model <br/>glm_model &lt;- <br/>  h2o.glm(<br/>    x               = x,<br/>    y               = y, <br/>    training_frame  = train_tbl %&gt;% as.h2o(),<br/>    balance_classes = TRUE,<br/>    nfolds          = 10,<br/>    family          = "binomial",<br/>    seed            = 1975<br/>    )</span><span id="3277" class="mx lw it mt b gy ng mz l na nb"># random forest model<br/>drf_model_grid &lt;- <br/>  h2o.grid(<br/>    algorithm       = "randomForest", <br/>    x               = x, <br/>    y               = y,<br/>    training_frame  = train_tbl %&gt;% as.h2o(),<br/>    balance_classes = TRUE, <br/>    nfolds          = 10,<br/>    ntrees          = 1000,<br/>    grid_id         = "drf_grid",<br/>    hyper_params    = hyper_params_drf,<br/>    search_criteria = search_criteria_all,<br/>    seed            = 1975<br/>    )</span><span id="1d71" class="mx lw it mt b gy ng mz l na nb"># gradient boosting machine model<br/>gbm_model_grid &lt;- <br/>  h2o.grid(<br/>    algorithm       = "gbm",<br/>    x               = x, <br/>    y               = y,<br/>    training_frame  = train_tbl %&gt;% as.h2o(),<br/>    balance_classes = TRUE, <br/>    nfolds          = 10,<br/>    ntrees          = 1000,<br/>    grid_id         = "gbm_grid",<br/>    hyper_params    = hyper_params_gbm,<br/>    search_criteria = search_criteria_all,<br/>    seed            = 1975<br/>    )</span></pre><p id="8dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通过<em class="nc"> AUC </em>分数对基于树的模型进行排序，并从网格中检索主要模型</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e30b" class="mx lw it mt b gy my mz l na nb"># Get the DRM grid results, sorted by AUC <br/>drf_grid_perf &lt;- <br/>  h2o.getGrid(grid_id     = "drf_grid",<br/>               sort_by    = "AUC",<br/>               decreasing = TRUE)</span><span id="a4fb" class="mx lw it mt b gy ng mz l na nb"># Fetch the top DRF model, chosen by validation AUC<br/>drf_model &lt;- <br/>  h2o.getModel(drf_grid_perf@model_ids[[1]])</span><span id="236e" class="mx lw it mt b gy ng mz l na nb"># Get the GBM grid results, sorted by AUC <br/>gbm_grid_perf &lt;- <br/>  h2o.getGrid(grid_id     = "gbm_grid",<br/>               sort_by    = "AUC",<br/>               decreasing = TRUE)</span><span id="bce8" class="mx lw it mt b gy ng mz l na nb"># Fetch the top GBM model, chosen by validation AUC<br/>gbm_model &lt;- <br/>  h2o.getModel(gbm_grid_perf@model_ids[[1]])</span></pre><h1 id="8c9d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">性能评价</h1><p id="fe22" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有许多库(比如<em class="nc"> IML </em>、<em class="nc"> PDP </em>、<em class="nc"> VIP </em>和<em class="nc"> DALEX </em>等等，但更受欢迎)帮助<strong class="lb iu">机器学习可解释性</strong>、<strong class="lb iu">特性解释</strong>和<strong class="lb iu">一般性能评估</strong>，它们在最近几年都变得越来越受欢迎。</p><p id="e8c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有多种方法来解释机器学习结果(即<em class="nc">局部可解释的模型不可知解释</em>、<em class="nc">部分依赖图</em>、<em class="nc">基于排列的变量重要性</em>)，但在这个项目中，我检查了<code class="fe nd ne nf mt b">DALEX</code>包，该包侧重于<strong class="lb iu">模型不可知的可解释性</strong>，并提供了一种跨具有不同结构的多个模型比较性能的便捷方式。</p><p id="17cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf mt b">DALEX</code>使用的模型不可知方法的一个关键<strong class="lb iu">优势</strong>是<strong class="lb iu">可以在相同的尺度上</strong>比较传统“玻璃箱”模型和黑箱模型<strong class="lb iu">的贡献。然而，由于是基于排列的，它的主要缺点之一<strong class="lb iu">是</strong>不能很好地适应大量的预测变量和大型数据集。</strong></p><h1 id="0117" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">DALEX程序</h1><p id="7867" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">目前<code class="fe nd ne nf mt b">DALEX</code>不支持一些更新的ML包，如<strong class="lb iu"> h2o </strong>或<strong class="lb iu"> xgboost </strong>。为了使它与这样的对象兼容，我遵循了Bradley Boehmke在他杰出的研究<a class="ae ky" href="https://uc-r.github.io/dalex" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">中阐述的程序，用DALEX </strong> </a>建模可解释性，从中我获得了很多灵感并借鉴了一些代码。</p><p id="fe56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，数据集需要采用特定的格式:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0d7b" class="mx lw it mt b gy my mz l na nb"># convert feature variables to a data frame<br/>x_valid &lt;- <br/>     test_tbl %&gt;% select(-subscribed) %&gt;% as_tibble()</span><span id="b7f2" class="mx lw it mt b gy ng mz l na nb"># change response variable to a numeric binary vector<br/>y_valid &lt;-   <br/>     as.vector(as.numeric(as.character(test_tbl$subscribed)))</span></pre><p id="d83a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我创建一个predict函数，返回一个数值向量，该向量提取二进制分类问题的响应概率。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="95ae" class="mx lw it mt b gy my mz l na nb"># create custom predict function<br/>pred &lt;- function(model, newdata)  {<br/>  results &lt;- as.data.frame(h2o.predict(model, <br/>                                        newdata %&gt;% as.h2o()))<br/>  return(results[[3L]])<br/>  }</span></pre><p id="b64c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我可以用<code class="fe nd ne nf mt b">explain()</code>函数将我的机器学习模型转换成DALEK“解释器”，它充当参数的“容器”。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ce61" class="mx lw it mt b gy my mz l na nb"># generalised linear model explainer<br/>explainer_glm &lt;- explain(<br/>  model            = glm_model, <br/>  type             = "classification",<br/>  data             = x_valid,<br/>  y                = y_valid,<br/>  predict_function = pred,<br/>  label            = "h2o_glm"<br/>  )</span><span id="5595" class="mx lw it mt b gy ng mz l na nb"># random forest model explainer<br/>explainer_drf &lt;- explain(<br/>  model            = drf_model, <br/>  type             = "classification",<br/>  data             = x_valid,<br/>  y                = y_valid,<br/>  predict_function = pred,<br/>  label            = "h2o_drf"<br/>  )</span><span id="e6e8" class="mx lw it mt b gy ng mz l na nb"># gradient boosting machine explainer<br/>explainer_gbm &lt;- explain(<br/>  model            = gbm_model, <br/>  type             = "classification",<br/>  data             = x_valid,<br/>  y                = y_valid,<br/>  predict_function = pred,<br/>  label            = "h2o_gbm"<br/>  )</span></pre><h1 id="b672" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">评估模型</h1><p id="ddfc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，我准备将<strong class="lb iu">解释器对象</strong>传递给几个DALEX函数，这些函数将帮助评估和比较不同模型的性能。考虑到性能指标可能反映模型预测性能的不同方面，在评估模型时评估和比较几个指标<strong class="lb iu">非常重要</strong>使用DALEX您可以做到这一点！</p><p id="5f11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了评估和比较我的模型的性能，我从<em class="nc"> Przemyslaw Biecek </em>和<em class="nc"> Tomasz Burzykowski </em>在他们的书<a class="ae ky" href="https://pbiecek.github.io/ema/introduction.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">解释性模型分析</strong> </a>中使用的框架中获得了灵感，该框架是围绕关键问题构建的:</p><ul class=""><li id="64ae" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">1 —模型是否合适？</li><li id="1837" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">2 —这些模型如何相互比较？</li><li id="121c" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">3-哪些变量在模型中很重要？</li><li id="762e" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">4 —单个变量如何影响平均预测？</li></ul><h1 id="a161" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1 —模型是否合适？</h1><h2 id="8821" class="mx lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">通用模型拟合</h2><p id="a632" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了初步了解我的模型与数据的吻合程度，我可以使用简单明了的<code class="fe nd ne nf mt b">model_performance()</code>函数，它计算选定的模型性能度量。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ce68" class="mx lw it mt b gy my mz l na nb">model_performance(explainer_glm)<br/>## Measures for:  classification<br/>## recall   : 0 <br/>## precision: NaN <br/>## f1       : NaN <br/>## accuracy : 0.8914653 <br/>## auc      : 0.7500738<br/>## <br/>## Residuals:<br/>##          0%         10%         20%         30%         40%         50% <br/>## -0.48867133 -0.16735197 -0.09713539 -0.07193152 -0.06273300 -0.05418778 <br/>##         60%         70%         80%         90%        100% <br/>## -0.04661088 -0.03971492 -0.03265955  0.63246516  0.98072521</span><span id="fc5a" class="mx lw it mt b gy ng mz l na nb">model_performance(explainer_drf)<br/>## Measures for:  classification<br/>## recall   : 0.1700224 <br/>## precision: 0.76 <br/>## f1       : 0.2778793 <br/>## accuracy : 0.9040913 <br/>## auc      : 0.7993824<br/>## <br/>## Residuals:<br/>##          0%         10%         20%         30%         40%         50% <br/>## -0.87841486 -0.13473277 -0.07933048 -0.06305297 -0.05556507 -0.04869549 <br/>##         60%         70%         80%         90%        100% <br/>## -0.04172427 -0.03453394 -0.02891645  0.33089059  0.98046626</span><span id="6a93" class="mx lw it mt b gy ng mz l na nb">model_performance(explainer_gbm)<br/>## Measures for:  classification<br/>## recall   : 0.2192394 <br/>## precision: 0.7340824 <br/>## f1       : 0.33764 <br/>## accuracy : 0.9066408 <br/>## auc      : 0.7988382<br/>## <br/>## Residuals:<br/>##          0%         10%         20%         30%         40%         50% <br/>## -0.83600975 -0.14609749 -0.08115376 -0.06542395 -0.05572322 -0.04789869 <br/>##         60%         70%         80%         90%        100% <br/>## -0.04068165 -0.03371074 -0.02750033  0.29004942  0.98274727</span></pre><p id="b91c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于所有模型可用的指标(<strong class="lb iu">准确性</strong>和<strong class="lb iu"> AUC </strong>)，我可以看到<strong class="lb iu">弹性网</strong>和<strong class="lb iu">梯度提升</strong>的表现大致相当，而<strong class="lb iu">随机森林</strong>紧随其后。AUC的范围在. 78-.80之间，而准确性的范围稍窄，为. 89-.90</p><h2 id="68e6" class="mx lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">残留诊断</h2><p id="e82d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如前一段所示，<code class="fe nd ne nf mt b">model_performance()</code>还生成残差分位数，可以绘制这些分位数来比较模型间的绝对残差。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d07a" class="mx lw it mt b gy my mz l na nb"># compute and assign residuals to an object<br/>resids_glm &lt;- model_performance(explainer_glm)<br/>resids_drf &lt;- model_performance(explainer_drf)<br/>resids_gbm &lt;- model_performance(explainer_gbm)</span><span id="cce4" class="mx lw it mt b gy ng mz l na nb"># compare residuals plots<br/>p1 &lt;- plot(resids_glm, resids_drf, resids_gbm) +<br/>        theme_minimal() +<br/>        theme(legend.position = 'bottom',<br/>              plot.title = element_text(hjust = 0.5)) + <br/>        labs(y = '')<br/>p2 &lt;- plot(resids_glm, resids_drf, resids_gbm, geom = "boxplot") +<br/>        theme_minimal() +<br/>        theme(legend.position = 'bottom',<br/>              plot.title = element_text(hjust = 0.5)) </span><span id="bedf" class="mx lw it mt b gy ng mz l na nb">gridExtra::grid.arrange(p2, p1, nrow = 1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/2f47a300ff05c6e5103c453be48eecc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pN8FaDbUG5SJP_bx-DWmg.png"/></div></div></figure><p id="0e55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于中值绝对残差，DRF和GBM模型的表现似乎不相上下。查看右侧的残差分布，您可以看到这两个模型的中值残差最低，GLM的尾部残差数量较多。这也反映在左侧的箱线图中，其中基于树的模型都实现了最低的中值绝对残差值。</p><h1 id="19e7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2 —这些模型如何相互比较？</h1><h2 id="b401" class="mx lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">ROC和AUC</h2><p id="e8fa" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">接收器工作特性(ROC) </strong> </a>曲线是一种图形化方法，允许可视化针对随机猜测的分类模型性能，这由图上的条纹线表示。该曲线在y轴上绘制了真阳性率(TPR ),在x轴上绘制了假阳性率(FPR)。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5ebc" class="mx lw it mt b gy my mz l na nb">eva_glm &lt;- DALEX::model_performance(explainer_glm)<br/>eva_dfr &lt;- DALEX::model_performance(explainer_drf)<br/>eva_gbm &lt;- DALEX::model_performance(explainer_gbm)</span><span id="09b3" class="mx lw it mt b gy ng mz l na nb">plot(eva_glm, eva_dfr, eva_gbm, geom = "roc") +<br/>  ggtitle("ROC Curves - All Models",  <br/>          "AUC_glm = 0.750  AUC_drf = 0.799  AUC_gbm = 0.798") +<br/>  theme_minimal() +<br/>  theme(plot.title = element_text(hjust = 0.5))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/5774b8380176fcec4e75fb2a6ee98778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qlLDRQrin45a_CntCxNMmw.png"/></div></div></figure><p id="1bfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从ROC曲线可以看出两个方面:</p><ul class=""><li id="92b1" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">直接阅读:所有模型的表现都比随机猜测要好</li><li id="f84f" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">比较读数</strong>:<a class="ae ky" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">AUC(曲线下面积)</strong> </a>总结了ROC曲线，可用于直接比较模型性能——完美的分类器AUC = 1。</li></ul><p id="8f89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有模型的表现都比随机猜测好得多，AUC达到0.75-. 80，其中DRF的得分最高，为0.799。</p><h1 id="4e39" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3-哪些变量在模型中很重要？</h1><h2 id="57c0" class="mx lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">可变重要性图</h2><p id="9a7d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">每种ML算法都有自己的方式来评估每个变量的重要性:例如，线性模型参考它们的系数，而基于树的模型则考虑杂质，这使得很难跨模型比较变量的重要性。</p><p id="2373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DALEX通过置换计算可变重要性度量，这是模型不可知论，并允许在不同结构的模型之间进行直接比较。然而，当可变重要性分数基于排列时，我们应该记住，当特征数量增加时<strong class="lb iu">计算速度会变慢</strong>。</p><p id="83ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我再次将每个模型的“解释器”传递给<code class="fe nd ne nf mt b">feature_importance()</code>函数，并将<code class="fe nd ne nf mt b">n_sample</code>设置为8000，以使用几乎所有可用的观察值。尽管不算过分，总执行时间是<strong class="lb iu">将近30分钟</strong>，但这是基于相对较小的数据集和变量数量。不要忘记，计算速度可以通过减少<code class="fe nd ne nf mt b">n_sample</code>来提高，这对较大的数据集尤其重要。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0c0d" class="mx lw it mt b gy my mz l na nb"># measure execution time<br/>tictoc::tic()</span><span id="6ad3" class="mx lw it mt b gy ng mz l na nb"># compute permutation-based variable importance<br/>vip_glm &lt;- <br/>     feature_importance(explainer_glm, <br/>                        n_sample      = 8000,<br/>                        loss_function = loss_root_mean_square) </span><span id="7478" class="mx lw it mt b gy ng mz l na nb">vip_drf &lt;- <br/>     feature_importance(explainer_drf, <br/>                        n_sample      = 8000, <br/>                        loss_function = loss_root_mean_square)</span><span id="6e35" class="mx lw it mt b gy ng mz l na nb">vip_gbm &lt;- <br/>     feature_importance(explainer_gbm, <br/>                        n_sample      = 8000, <br/>                        loss_function = loss_root_mean_square)<br/></span><span id="4bd2" class="mx lw it mt b gy ng mz l na nb"># show total execution time<br/>tictoc::toc()</span><span id="27b1" class="mx lw it mt b gy ng mz l na nb">## 1803.65 sec elapsed</span></pre><p id="07a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我只需将<strong class="lb iu"> vip </strong>对象传递给一个绘图函数:正如自动生成的x轴标签(<strong class="lb iu"> Drop-out loss </strong>)所暗示的，变量重要性如何计算背后的主要直觉在于，如果移除所选解释变量的贡献，模型拟合度会降低多少。分段越大，从模型中删除该变量时的损失就越大。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ff95" class="mx lw it mt b gy my mz l na nb"># plotting top 10 feature only for clarity of reading<br/>plot(vip_glm, vip_drf, vip_gbm, max_vars = 10) +<br/>  ggtitle("Permutation variable importance", <br/>          "Average variable importance based on 8,000 <br/>                                permutations") +<br/>  theme_minimal() +<br/>  theme(plot.title = element_text(hjust = 0.5))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/d34298675646eeeb876c35a23c3bee3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*egLxRKC8aPOKxGneuql3nw.png"/></div></div></figure><p id="ea15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢这个情节，因为它汇集了丰富的信息。</p><p id="c8a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，你可以注意到，尽管相对权重略有不同，但前5个特征对每个模型来说都是共同的，其中<code class="fe nd ne nf mt b">nr_employed</code>(经济中使用的<strong class="lb iu"/>)是所有这些特征中唯一最重要的预测因素。这种一致性令人放心，因为它告诉我们，所有模型都在数据中选取相同的结构和交互，并向我们保证这些特征具有强大的预测能力。</p><p id="5b35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以注意到x轴左边缘的<strong class="lb iu">不同起点</strong>，这反映了三个模型之间RMSE损失的差异:在这种情况下,<strong class="lb iu">弹性网</strong>模型具有最高的RMSE，这表明在残差诊断中较早看到的较高数量的尾部残差可能不利于RMSE评分。</p><h1 id="a3b6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4 —单个变量如何影响平均预测？</h1><h2 id="9e9c" class="mx lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">部分依赖曲线</h2><p id="e48f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我们确定了每个变量的相对预测能力后，我们可能想要调查它们与所有三个模型的预测反应之间的关系有何不同。<strong class="lb iu">部分相关(PD)图</strong>，有时也称为<em class="nc"> PD曲线</em>，提供了一种很好的方法来检查每个模型如何响应特定的预测值。</p><p id="68f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以从最重要的特性<code class="fe nd ne nf mt b">nr_employed</code>开始:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8c24" class="mx lw it mt b gy my mz l na nb"># compute PDP for a given variable<br/>pdp_glm  &lt;- model_profile(explainer_glm, <br/>                          variable = "nr_employed", <br/>                          type     = "partial")<br/>pdp_drf  &lt;- model_profile(explainer_drf, <br/>                          variable = "nr_employed", <br/>                          type     = "partial")<br/>pdp_gbm  &lt;- model_profile(explainer_gbm, <br/>                          variable = "nr_employed", <br/>                          type     = "partial")</span><span id="acb1" class="mx lw it mt b gy ng mz l na nb">plot(pdp_glm$agr_profiles, <br/>     pdp_drf$agr_profiles, <br/>     pdp_gbm$agr_profiles) +<br/>  ggtitle("Contrastive Partial Dependence Profiles", "") +<br/>  theme_minimal() +<br/>  theme(plot.title = element_text(hjust = 0.5))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/144906707309a09786f58eb915f1cf3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTPGgItDXuaXPGDfGjHppQ.png"/></div></div></figure><p id="3292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管平均预测权重不同，但所有三个模型都发现，当经济中的就业水平达到509.9万(<code class="fe nd ne nf mt b">nInf_5099.1</code>)时，银行客户更有可能签署定期存款。<strong class="lb iu">弹性网</strong>和<strong class="lb iu">随机森林</strong>都在我们在<code class="fe nd ne nf mt b">correlationfunnel</code>分析中观察到的<code class="fe nd ne nf mt b">nr_employed</code>(对<strong class="lb iu">随机森林</strong>不太明显)的3个不同级别中发现了完全相同的预测能力层级，其中<strong class="lb iu"> GBM </strong>稍微有点失调。</p><p id="8d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看<code class="fe nd ne nf mt b">age</code>，一个预测器，如果你还记得EDA，它预计不会对目标变量产生影响:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/9f5975542b48c1487dd29ea9f8711e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HBpwDSKsMRsGpkbI2cAaQ.png"/></div></div></figure><p id="6a3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们注意到的一件事是，平均预测(x轴)的变化范围在年龄谱(y轴)上相对较浅，证实了探索性分析的发现，即该变量的预测能力较低。此外，<strong class="lb iu"> GBM </strong>和<strong class="lb iu">随机森林</strong>都以非线性方式使用<code class="fe nd ne nf mt b">age</code>，而<strong class="lb iu">弹性网</strong>模型无法捕捉这种非线性动态。</p><p id="0bd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部分依赖图也可以作为一种诊断工具:查看<code class="fe nd ne nf mt b">poutcome</code>(<code class="fe nd ne nf mt b">previous</code>营销活动的结果)可以发现<strong class="lb iu"> GBM </strong>和<strong class="lb iu"> random forest </strong>在前一个活动的结果成功(<code class="fe nd ne nf mt b">scs</code>)时正确地获得了更高的签约概率。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/c4959925a4f7a6543dd2bb7c9a585f6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*giUMKJfEvoCWdJp55G70mQ.png"/></div></div></figure><p id="3b0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<strong class="lb iu">弹性网</strong>模型未能做到这一点，这可能是一个严重的缺陷，因为在以前的活动中，成功与目标变量有非常强的正相关性。</p><p id="12bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将以<code class="fe nd ne nf mt b">month</code>特性结束，因为它提供了一个很好的例子，在这种情况下，您可能希望用行业知识和一些常识来覆盖模型的结果。具体来说，<strong class="lb iu"> GBM </strong>模型似乎表明<strong class="lb iu">3月</strong>、<strong class="lb iu">10月</strong>和<strong class="lb iu">12月</strong>是成功几率更大的时期。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/b2b9e77e14c264b2df1cfa8cd85b5369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SuBc8-TGaYYdNY6L45swuA.png"/></div></div></figure><p id="359c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我以前对类似金融产品的分析经验，我不建议银行机构在圣诞节前几周增加直接营销活动，因为这是一年中消费者注意力从这类购买转移的时期。</p><h1 id="615a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最终模型</h1><p id="728d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">总而言之,<strong class="lb iu">随机森林</strong>是我最终选择的模型:它看起来是三个中更平衡的，并且没有显示出像<code class="fe nd ne nf mt b">month</code>和<code class="fe nd ne nf mt b">poutcome</code>这样的变量所看到的一些“奇怪之处”。</p><p id="0def" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我可以通过结合探索性分析的结果、模型评估的洞察力以及大量行业特定/常识考虑因素，进一步完善我的模型并降低其复杂性。</p><p id="6a83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别是我的<strong class="lb iu">最终型号</strong>:</p><ul class=""><li id="e356" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">排除了许多预测能力较低的特征(<code class="fe nd ne nf mt b">age</code>、<code class="fe nd ne nf mt b">housing</code>、<code class="fe nd ne nf mt b">loan</code>、<code class="fe nd ne nf mt b">campaign</code>、<code class="fe nd ne nf mt b">cons_price_idx</code>)</li><li id="901b" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">删除了<code class="fe nd ne nf mt b">previous</code>，它在PD图中显示其2个级别之间的差异很小——它也与<code class="fe nd ne nf mt b">pdays</code>适度相关，表明它们可能捕捉到相同的行为</li><li id="c37b" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">也下降了<code class="fe nd ne nf mt b">emp_var_rate</code>，因为它与<code class="fe nd ne nf mt b">nr_employed</code>有很强的相关性，也因为从概念上讲，它们控制着非常相似的经济行为</li></ul><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1a8f" class="mx lw it mt b gy my mz l na nb"># response variable remains unaltered<br/>y &lt;- "subscribed"</span><span id="6a08" class="mx lw it mt b gy ng mz l na nb"># predictors set: remove response variable and 7 predictors<br/>x_final &lt;- <br/>     setdiff(names(train_tbl %&gt;% <br/>                   select(-c(age, housing, loan, <br/>                             campaign, previous, <br/>                             cons_price_idx, emp_var_rate)) %&gt;% <br/>                           as.h2o()), y)</span></pre><p id="6238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于最终的模型，我使用了与原始随机森林相同的规范</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1ac6" class="mx lw it mt b gy my mz l na nb"># random forest model<br/>drf_final &lt;- <br/>  h2o.grid(<br/>     algorithm       = "randomForest", <br/>     x               = x_final, <br/>     y               = y,<br/>     training_frame  = train_tbl %&gt;% as.h2o(),<br/>     balance_classes = TRUE, <br/>     nfolds          = 10,<br/>     ntrees          = 1000,<br/>     grid_id         = "drf_grid_final",<br/>     hyper_params    = hyper_params_drf,<br/>     search_criteria = search_criteria_all,<br/>     seed            = 1975<br/>   )</span></pre><p id="ee99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们通过AUC分数对模型进行排序，并检索先导模型</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ed7b" class="mx lw it mt b gy my mz l na nb"># Get the grid results, sorted by AUC <br/>drf_grid_perf_final &lt;- <br/>  h2o.getGrid(grid_id = "drf_grid_final",<br/>               sort_by = "AUC",<br/>               decreasing = TRUE)</span><span id="271e" class="mx lw it mt b gy ng mz l na nb"># Fetch the top DRF model, chosen by validation AUC<br/>drf_final &lt;- <br/>  h2o.getModel(drf_grid_perf_final@model_ids[[1]])</span></pre><h1 id="285f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最终模型评估</h1><p id="1bf1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了简单起见，我用同名包中的<code class="fe nd ne nf mt b">vip()</code>函数可视化变量重要性图，该函数返回每个变量的排名贡献。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5f6a" class="mx lw it mt b gy my mz l na nb">vip::vip(drf_final, num_features = 12) +<br/>  ggtitle("Variable Importance", "") + <br/>  theme_minimal() +<br/>  theme(plot.title = element_text(hjust = 0.5))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/a9384ec8d95d1107b274849d47de79f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4D3Fr91c37y6Wn-zTfhAnw.png"/></div></div></figure><p id="6cd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">移除<code class="fe nd ne nf mt b">emp_var_rate</code>使得<code class="fe nd ne nf mt b">education</code>进入了前10名。可以理解的是，变量层次和相对预测能力有所调整和变化，但令人欣慰的是，看到其他9个变量在前一个模型的前10名中。</p><p id="d511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我将该模型的性能与原始的<strong class="lb iu">随机森林</strong>模型进行比较。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3605" class="mx lw it mt b gy my mz l na nb">drf_final %&gt;% <br/>  h2o.performance(newdata = test_tbl %&gt;% as.h2o()) %&gt;% h2o.auc()</span><span id="d919" class="mx lw it mt b gy ng mz l na nb">## [1] 0.7926509</span><span id="05e7" class="mx lw it mt b gy ng mz l na nb">drf_model %&gt;% <br/>  h2o.performance(newdata = test_tbl %&gt;% as.h2o()) %&gt;% h2o.auc()</span><span id="9fe3" class="mx lw it mt b gy ng mz l na nb">## [1] 0.7993973</span></pre><p id="830e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AUC只变化了百分之几，这告诉我这个模型保持了它的预测能力。</p><h1 id="d5c0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关于部分相关图的一个重要观察</h1><p id="cdad" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">由于已经熟悉逻辑回归中的优势比，我开始了解同样的直觉是否可以扩展到黑盒分类模型。在我的研究过程中，一个关于<a class="ae ky" href="https://stats.stackexchange.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">交叉验证</strong> </a>的非常有趣的帖子脱颖而出，它在来自决策树的<a class="ae ky" href="https://stats.stackexchange.com/questions/93202/odds-ratio-from-decision-tree-and-random-forest" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">比值比和随机森林的</strong> </a>之间画出了一条平行线。</p><p id="32a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，这告诉我们，部分依赖图可以以类似于优势比的方式来定义客户档案的哪些特征影响他/她执行某种类型行为的倾向。</p><p id="dbbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe nd ne nf mt b">job</code>、<code class="fe nd ne nf mt b">month</code>和<code class="fe nd ne nf mt b">contact</code>等特征将提供关于<strong class="lb iu">谁</strong>、<strong class="lb iu">何时</strong>和<strong class="lb iu">如何</strong>瞄准的上下文:</p><ul class=""><li id="d8c8" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">查看<code class="fe nd ne nf mt b">job</code>会告诉我们，担任<em class="nc">管理员</em>角色的客户比担任<em class="nc">个体户</em>角色的客户订阅的可能性大约高25%。</li><li id="8a55" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">在10月<em class="nc">日<code class="fe nd ne nf mt b">month</code>和10月</em>日<code class="fe nd ne nf mt b">month</code>与潜在客户取得联系，会比在5月<em class="nc">日</em>取得积极成果的几率增加一倍以上。</li><li id="300e" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe nd ne nf mt b">contacting</code>与通过<em class="nc">电话</em>通话相比，您的客户通过<em class="nc">手机</em>进行订购的机会增加了近四分之一。</li></ul><p id="e6c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">请注意，所有最终模型预测值的</strong>部分相关图可以在我的网页上找到:在我的网页上:<a class="ae ky" href="https://diegousai.io/2020/02/propensity-modelling-estimate-compare-models/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">倾向建模——估计几个模型，并使用模型不可知方法比较它们的性能</strong>。</a></p><p id="8daf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这样的洞察力，你就可以帮助制定整体营销和沟通计划，把重点放在更有可能订阅定期存款的客户身上。</p><p id="e715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这些都是基于模型级别的解释器，它们反映了一个整体的、聚合的视图。如果您有兴趣了解模型如何对单次观察做出预测(即哪些因素会影响在单个客户级别参与<strong class="lb iu">的可能性)，您可以求助于利用“本地模型”概念的<a class="ae ky" href="https://www.oreilly.com/content/introduction-to-local-interpretable-model-agnostic-explanations-lime/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">本地可解释模型不可知解释(LIME) </strong> </a>方法。我将在以后的文章中探讨LIME方法。</strong></p><h1 id="6214" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模型估计和评估综述</h1><p id="44ad" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于这个项目的分析部分，我选择<strong class="lb iu"> h2o </strong>作为我的建模平台。h2o不仅非常易于使用，而且具有许多内置功能，有助于加快数据准备:它处理<strong class="lb iu">类不平衡</strong>而不需要预先建模重采样，自动__“二进制化”字符/因子__变量，并实现<strong class="lb iu">交叉验证</strong>而不需要从训练集中“分割”出单独的<code class="fe nd ne nf mt b">validation frame</code>。</p><p id="9ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在建立了一个随机网格来让<strong class="lb iu">搜索最佳超参数</strong>之后，我估计了模型的数量(一个<em class="nc">逻辑回归</em>、一个<em class="nc">随机森林</em>和一个<em class="nc">梯度提升机器</em>)，并使用<strong class="lb iu"> DALEX </strong>库<strong class="lb iu">通过一系列指标来评估和比较它们的性能</strong>。该库采用了<strong class="lb iu">模型不可知的方法</strong>，使得<strong class="lb iu">能够在相同的规模上比较传统的“玻璃盒子”模型和“黑盒”模型</strong>。</p><p id="fa96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最终选择的模型是<strong class="lb iu">随机森林</strong>，我通过结合探索性分析的结果、从模型评估中收集的洞察力以及大量行业特定/常识考虑因素，进一步完善了该模型。这确保了降低模型的复杂性，而不影响预测能力。</p><h1 id="0bb8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">优化预期利润</h1><p id="21be" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我有了我的最终模型，拼图的最后一块是最终的“那又怎样？”这个问题让所有人都有了正确的认识。对客户签署定期存款的概率的估计可用于创建许多优化的场景，从最小化您的<strong class="lb iu">营销支出</strong>，最大化您的<strong class="lb iu">总体收购目标</strong>，到推动一定数量的<strong class="lb iu">交叉销售机会</strong>。</p><p id="c025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我这样做之前，有几个<strong class="lb iu">内务任务</strong>需要“设置工作场景”和几个重要的概念要介绍:</p><ul class=""><li id="e544" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">阈值和F1分数</li><li id="0c97" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">精确度和召回率</li></ul><h1 id="be53" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">阈值和F1分数</h1><p id="9423" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">该模型试图回答的问题是"<em class="nc">该客户是否在直接营销活动后注册了定期存款？</em>”而截止值(也称为阈值)是将预测分为<code class="fe nd ne nf mt b">Yes</code>和<code class="fe nd ne nf mt b">No</code>的值。</p><p id="b186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明这一点，我首先通过将<code class="fe nd ne nf mt b">test_tbl</code>数据集传递给<code class="fe nd ne nf mt b">h2o.performance</code>函数来计算一些预测。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c8ce" class="mx lw it mt b gy my mz l na nb">perf_drf_final &lt;- <br/>    h2o.performance(drf_final, newdata = test_tbl %&gt;% as.h2o()) </span><span id="ae17" class="mx lw it mt b gy ng mz l na nb">perf_drf_final@metrics$max_criteria_and_metric_scores</span><span id="f69f" class="mx lw it mt b gy ng mz l na nb">## Maximum Metrics: Maximum metrics at their respective thresholds<br/>##                         metric threshold       value idx<br/>## 1                       max f1  0.189521    0.508408 216<br/>## 2                       max f2  0.108236    0.560213 263<br/>## 3                 max f0point5  0.342855    0.507884 143<br/>## 4                 max accuracy  0.483760    0.903848  87<br/>## 5                max precision  0.770798    0.854167  22<br/>## 6                   max recall  0.006315    1.000000 399<br/>## 7              max specificity  0.930294    0.999864   0<br/>## 8             max absolute_mcc  0.189521    0.444547 216<br/>## 9   max min_per_class_accuracy  0.071639    0.721231 300<br/>## 10 max mean_per_class_accuracy  0.108236    0.755047 263<br/>## 11                     max tns  0.930294 7342.000000   0<br/>## 12                     max fns  0.930294  894.000000   0<br/>## 13                     max fps  0.006315 7343.000000 399<br/>## 14                     max tps  0.006315  894.000000 399<br/>## 15                     max tnr  0.930294    0.999864   0<br/>## 16                     max fnr  0.930294    1.000000   0<br/>## 17                     max fpr  0.006315    1.000000 399<br/>## 18                     max tpr  0.006315    1.000000 399</span></pre><p id="cd33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与许多其他机器学习建模平台一样，<strong class="lb iu"> h2o </strong>使用与最大<a class="ae ky" href="https://en.wikipedia.org/wiki/F1_score" rel="noopener ugc nofollow" target="_blank"> F1分数</a>相关联的阈值，它只不过是精确度和召回率之间的加权平均值。在这种情况下，阈值@ Max F1为<strong class="lb iu"> 0.190 </strong>。</p><p id="cf5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我使用<code class="fe nd ne nf mt b">h2o.predict</code>函数通过测试集进行预测。预测输出有三列:实际模型预测(<code class="fe nd ne nf mt b">predict</code>)，以及与该预测相关联的概率(<code class="fe nd ne nf mt b">p0</code>和<code class="fe nd ne nf mt b">p1</code>，分别对应于<code class="fe nd ne nf mt b">No</code>和<code class="fe nd ne nf mt b">Yes</code>)。如您所见，与当前截止相关的<code class="fe nd ne nf mt b">p1</code>概率大约为<strong class="lb iu"> 0.0646 </strong>。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="afda" class="mx lw it mt b gy my mz l na nb">drf_predict &lt;- <br/>    h2o.predict(drf_final, <br/>                newdata = test_tbl %&gt;% as.h2o())</span><span id="ea4d" class="mx lw it mt b gy ng mz l na nb"># I converte to a tibble for ease of use<br/>as_tibble(drf_predict) %&gt;%<br/>  arrange(p0) %&gt;% <br/>  slice(3088:3093) %&gt;%<br/>  kable()</span><span id="3acc" class="mx lw it mt b gy ng mz l na nb"><br/>predict              p0              p1<br/>      1       0.9352865       0.0647135   <br/>      1       0.9352865       0.0647135   <br/>      1       0.9352865       0.0647135   <br/>      0       0.9354453       0.0645547   <br/>      0       0.9354453       0.0645547   <br/>      0       0.9354453       0.0645547</span></pre><p id="9020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<em class="nc"> F1分数</em>只是识别截止值的一种方式。根据我们的目标，我们也可以决定使用一个阈值，例如，最大化精度或召回率。</p><p id="4796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在商业设置中，预先选择的阈值@ Max F1不一定是最佳选择:输入<strong class="lb iu">精度并调用</strong>！</p><h1 id="fa59" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">精确度和召回率</h1><p id="90a2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu"> Precision </strong>显示模型对误报的敏感程度(即预测客户在<em class="nc">订购</em>而他/她实际上没有),而<strong class="lb iu"> Recall </strong>查看模型对误报的敏感程度(即预测客户在<em class="nc">没有订购</em>而他/她实际上打算这样做)。</p><p id="a1da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些指标<strong class="lb iu">与商业环境</strong>非常相关，因为组织对准确预测哪些客户真正有可能<code class="fe nd ne nf mt b">subscribe</code> <strong class="lb iu">(高精度)</strong>特别感兴趣，以便他们可以针对这些客户制定广告策略和其他激励措施。与此同时，他们希望尽量减少对被错误归类为<code class="fe nd ne nf mt b">subscribing</code> <strong class="lb iu">(高召回)</strong>的客户的努力，这些客户反而不太可能注册。</p><p id="34a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，从下面的图表中可以看出，当精度变高时，召回率变低，反之亦然。这通常被称为<strong class="lb iu">精确-召回权衡</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/8079c4ab99b01fb376f1dbf4a24b8062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7iKkB1yIkv0ZMyPqEudHVg.png"/></div></div></figure><p id="630a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了充分理解这种动态及其含义，让我们先来看看<strong class="lb iu">截止零点</strong>和<strong class="lb iu">截止一点</strong>点，然后看看当您开始在两个位置之间移动阈值时会发生什么:</p><ul class=""><li id="98f0" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">在<strong class="lb iu">阈值为零</strong> ( <em class="nc">最低精度，最高召回</em>)时，模型将每个客户分类为<code class="fe nd ne nf mt b">subscribed = Yes</code>。在这种情况下，你会通过直接营销活动<strong class="lb iu">联系每一个客户</strong>，但是浪费了宝贵的资源，因为还包括了那些不太可能订阅的客户。很明显，这不是一个最佳策略，因为你会招致更高的总体采购成本。</li><li id="768b" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">相反，在<strong class="lb iu">阈值一</strong> ( <em class="nc">最高精度，最低召回</em>)模型告诉你没有人可能订阅，所以你应该<strong class="lb iu">不联系任何人</strong>。这将为你节省大量的营销成本，但如果你通过直接营销将定期存款通知了那些已经订阅的客户，你将错过他们带来的额外收入。再说一次，这不是最优策略。</li></ul><p id="6e71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当移动到一个更高的阈值时，该模型在将谁归类为<code class="fe nd ne nf mt b">subscribed = Yes</code>时变得更加“挑剔”。因此，你在联系谁的问题上变得更加保守(<strong class="lb iu">精确度更高</strong>)并降低了你的采购成本，但同时你也增加了无法接触到潜在订户的机会(<strong class="lb iu">召回率更低</strong>)，错失了潜在的收入。</p><p id="e6d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的关键问题是<strong class="lb iu">你停在哪里？</strong>有没有“甜蜜点”，如果有，你如何找到它？嗯，那完全取决于你想达到的目标。在下一部分，我将运行一个迷你优化，目标是<strong class="lb iu">最大化利润</strong>。</p><h1 id="1880" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">寻找最佳阈值</h1><p id="1776" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于这个小优化，我实施了一个<strong class="lb iu">简单的利润最大化</strong>，基于与获得新客户相关的一般成本和从所述获得中获得的利益。这可以发展到包括更复杂的场景，但这超出了本练习的范围。</p><p id="274d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解使用哪个临界值是最佳的，我们需要模拟与每个临界点相关的成本效益。这是一个源自<strong class="lb iu">期望值框架</strong>的概念，参见<a class="ae ky" href="https://www.goodreads.com/book/show/17912916-data-science-for-business" rel="noopener ugc nofollow" target="_blank"> <em class="nc">商业数据科学</em> </a></p><p id="e8d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我需要两件东西:</p><ul class=""><li id="22f1" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><strong class="lb iu">每个阈值的预期比率</strong> —这些可以从混淆矩阵中检索</li><li id="0f55" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">每个客户的成本/收益</strong> —我需要根据假设来模拟这些</li></ul><h1 id="35c2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">预期利率</h1><p id="a5a5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">使用<code class="fe nd ne nf mt b">h2o.metric</code>可以方便地检索所有分界点的预期比率</strong>。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="087c" class="mx lw it mt b gy my mz l na nb"># Get expected rates by cutoff<br/>expected_rates &lt;- <br/>  h2o.metric(perf_drf_final) %&gt;%<br/>    as.tibble() %&gt;%<br/>    select(threshold, tpr, fpr, fnr, tnr)</span></pre><h1 id="e3e2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">成本/收益信息</h1><p id="3275" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">成本效益矩阵</strong>是对四种潜在结果的成本和效益的商业评估。为了创建这样一个矩阵，我必须对一个组织在开展<strong class="lb iu">广告主导的采购活动</strong>时应该考虑的<strong class="lb iu">费用和优势</strong>做出一些假设。</p><p id="332b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设出售定期存款的成本为每位客户30英镑。这包括执行直接营销活动(培训呼叫中心代表，为主动呼叫留出时间，等等。)和激励措施，如为另一种金融产品提供折扣，或加入提供福利和津贴的会员计划。银行组织在两种情况下会产生这种类型的成本:当他们正确预测客户将会订阅时(<strong class="lb iu">真肯定</strong>，TP)，以及当他们错误预测客户将会订阅时(<strong class="lb iu">假肯定</strong>，FP)。</p><p id="efe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还假设向现有客户出售定期存款的收入为每位客户80美元。当模型预测客户会订阅并且他们确实订阅时，组织将保证这一收入流(<strong class="lb iu">真正</strong>，TP)。</p><p id="1449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，还有<strong class="lb iu">真否定</strong> (TN)场景，我们正确预测客户不会订阅。在这种情况下，我们不会花任何钱，但也不会获得任何收入。</p><p id="53d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是成本情景的简要回顾:</p><ul class=""><li id="4fa1" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><strong class="lb iu">真正</strong> (TP) — predict会订阅，他们确实这么做了:COST:-30；第80版</li><li id="f622" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">误报</strong> (FP) — predict会订阅，而实际不会:COST:-30；版本0</li><li id="96e3" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">真负</strong> (TN) — predict不会订阅，他们实际上也没有:COST:0；版本0</li><li id="8405" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">假阴性</strong> (FN) — predict不会订阅，但他们确实订阅了:COST:0；版本0</li></ul><p id="7b1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了一个函数，使用<em class="nc">阳性案例</em> (p1)的概率以及与<em class="nc">真阳性</em> (cb_tp)和<em class="nc">假阳性</em> (cb_fp)相关联的成本/收益来计算预期成本。这里不需要包括<em class="nc">真阴性</em>或<em class="nc">假阴性</em>，因为它们都是零。</p><p id="49b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还包括之前创建的<strong class="lb iu"> expected_rates </strong>数据帧，其中包含每个阈值的预期速率(400个阈值，范围从0到1)。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d4de" class="mx lw it mt b gy my mz l na nb"># Function to calculate expected profit<br/>expected_profit_func &lt;- function(p1, cb_tp, cb_fp) {<br/>  <br/>    tibble(<br/>        p1    = p1,<br/>        cb_tp = cb_tp,<br/>        cb_fp = cb_fp<br/>        ) %&gt;%<br/>    <br/>        # add expected rates<br/>        mutate(expected_rates = list(expected_rates)) %&gt;%<br/>        unnest() %&gt;%<br/>    <br/>        # calculate the expected profit<br/>        mutate(<br/>            expected_profit =   p1    * (tpr * cb_tp) + <br/>                             (1 - p1) * (fpr * cb_fp)<br/>        ) %&gt;%<br/>        select(threshold, expected_profit)<br/>}</span></pre><h1 id="9926" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">多客户优化</h1><p id="7e62" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在为了理解多客户动态是如何工作的，我创建了一个<strong class="lb iu">假设的10个客户群</strong>来测试我的功能。这是一个<strong class="lb iu">简化的</strong>视图，因为我将<strong class="lb iu">相同的成本和收入结构应用于所有客户</strong>，但是成本/收益框架可以针对单个客户进行定制，以反映他们单独的产品和服务水平设置，并且可以轻松调整流程，以针对不同的KPI进行优化(如<em class="nc">净利润</em>、<em class="nc"> CLV </em>、<em class="nc">订阅数量</em>等)。)</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c669" class="mx lw it mt b gy my mz l na nb"># Ten Hypothetical Customers <br/>ten_cust &lt;- tribble(<br/>    ~"cust",   ~"p1",  ~"cb_tp",  ~"cb_fp",<br/>    'ID1001',   0.1,    80 - 30,     -30,<br/>    'ID1002',   0.2,    80 - 30,     -30,<br/>    'ID1003',   0.3,    80 - 30,     -30,<br/>    'ID1004',   0.4,    80 - 30,     -30,<br/>    'ID1005',   0.5,    80 - 30,     -30,<br/>    'ID1006',   0.6,    80 - 30,     -30,<br/>    'ID1007',   0.7,    80 - 30,     -30,<br/>    'ID1008',   0.8,    80 - 30,     -30,<br/>    'ID1009',   0.9,    80 - 30,     -30,<br/>    'ID1010',   1.0,    80 - 30,     -30<br/>)</span></pre><p id="11e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用<code class="fe nd ne nf mt b">purrr</code>将<code class="fe nd ne nf mt b">expected_profit_func()</code>映射到每个客户，返回一个按阈值计算的每个客户预期成本的数据框架。这个操作创建了一个嵌套tibble，我必须通过<code class="fe nd ne nf mt b">unnest()</code>将数据帧扩展到一个级别。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="473c" class="mx lw it mt b gy my mz l na nb"># calculate expected cost for each at each threshold<br/>expected_profit_ten_cust &lt;- <br/>  ten_cust %&gt;%<br/>    # pmap to map expected_profit_func() to each item<br/>    mutate(expected_profit = pmap(.l = list(p1, cb_tp, cb_fp), <br/>                                  .f = expected_profit_func)) %&gt;%<br/>    unnest() %&gt;%<br/>    select(cust, p1, threshold, expected_profit)</span></pre><p id="ee24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我可以想象每个客户的预期成本曲线。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d995" class="mx lw it mt b gy my mz l na nb"># Visualising Expected Cost <br/>expected_profit_ten_cust %&gt;%<br/>    ggplot(aes(threshold, expected_profit, <br/>               colour = factor(cust)), <br/>               group = cust) +<br/>    geom_line(size = 1) +<br/>    theme_minimal()  +<br/>    tidyquant::scale_color_tq() +<br/>    labs(title = "Expected Profit Curves",<br/>         colour = "Customer No." ) +<br/>    theme(plot.title = element_text(hjust = 0.5))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/223a14eca9fb58d82c2b235a6a60e904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3c2WIw4AmCnrgdstkq33iw.png"/></div></div></figure><p id="3925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我可以合计预期成本，可视化最终曲线，并突出显示最佳阈值。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="651d" class="mx lw it mt b gy my mz l na nb"># Aggregate expected cost by threshold <br/>total_expected_profit_ten_cust &lt;- expected_profit_ten_cust %&gt;%<br/>    group_by(threshold) %&gt;%<br/>    summarise(expected_profit_total = sum(expected_profit)) </span><span id="fee1" class="mx lw it mt b gy ng mz l na nb"># Get maximum optimal threshold <br/>max_expected_profit &lt;- total_expected_profit_ten_cust %&gt;%<br/>    filter(expected_profit_total == max(expected_profit_total))</span><span id="328a" class="mx lw it mt b gy ng mz l na nb"># Visualize the total expected profit curve<br/>total_expected_profit_ten_cust %&gt;%<br/>    ggplot(aes(threshold, expected_profit_total)) +<br/>    geom_line(size = 1) +<br/>    geom_vline(xintercept = max_expected_profit$threshold) +<br/>    theme_minimal() +<br/>    labs(title = "Expected Profit Curve - Total Expected Profit",<br/>         caption  = paste0('threshold @ max = ', <br/>                          max_expected_profit$threshold %&gt;% round(3))) +<br/>    theme(plot.title = element_text(hjust = 0.5))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/57bd777b3a9203375bbcce734d15ba38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8l220GqHoB-VFqlrym1iQ.png"/></div></div></figure><p id="42a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有一些重要的商业含义。根据我们的<em class="nc">假设的10个客户群</em>，选择优化的阈值<code class="fe nd ne nf mt b">0.092</code>将产生近<strong class="lb iu"> 164 </strong>的总利润，相比之下，与自动选择的<code class="fe nd ne nf mt b">0.190</code>截止点相关的总利润近<strong class="lb iu"> 147 </strong>。</p><p id="f28e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将导致<strong class="lb iu">的额外预期利润，接近每位客户</strong>1.7英镑。假设我们有大约<strong class="lb iu"> 500，000 </strong>的客户群，转换到优化型号可以产生额外的<strong class="lb iu">850，000</strong>的预期利润！</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4ce6" class="mx lw it mt b gy my mz l na nb">total_expected_profit_ten_cust %&gt;% <br/>  slice(184, 121) %&gt;%<br/>  round(3) %&gt;%<br/>  mutate(diff = expected_profit_total - lag(expected_profit_total)) %&gt;% <br/>  kable()</span><span id="26b7" class="mx lw it mt b gy ng mz l na nb">threshold     expected_profit_total        diff <br/>    0.190                   146.821          NA <br/>    0.092                   163.753      16.932</span></pre><p id="f041" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显而易见，根据企业的规模，潜在利润增长的幅度可能是显著的。</p><h1 id="e4ea" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结束语</h1><p id="200b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这个项目中，我使用了一个<strong class="lb iu">公开可用的数据集</strong>来估计银行现有客户在直接营销活动后购买金融产品的可能性。</p><p id="3a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在对数据进行彻底的探索和清理之后，我<strong class="lb iu">估计了几个模型</strong>和<strong class="lb iu">使用<strong class="lb iu"> DALEX </strong>库比较了它们的性能和对数据的拟合</strong>，该库侧重于<strong class="lb iu">模型不可知的可解释性</strong>。其关键<strong class="lb iu">优势之一</strong>是能够在相同的尺度上比较传统“玻璃箱”模型和黑箱模型<strong class="lb iu">的贡献。然而，由于是基于排列的，它的一个主要缺点</strong>是它不能很好地扩展到大量的预测器和更大的数据集。</p><p id="00ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我用我的<strong class="lb iu">最终模型</strong>实现了一个<strong class="lb iu">多客户利润优化</strong>，它揭示了一个潜在的额外预期利润<strong class="lb iu">每个客户近1.7</strong>(或者<strong class="lb iu"> 85万</strong>如果你有50万客户群)。此外，我还讨论了关键概念，如<strong class="lb iu">阈值和F1分数</strong>以及<strong class="lb iu">精确-召回权衡</strong>，并解释了为什么决定采用哪个截止值非常重要。</p><blockquote class="ok"><p id="5c60" class="ol om it bd on oo op oq or os ot lu dk translated">在探索和清理数据、拟合和比较多个模型并选择最佳模型之后，坚持使用默认阈值@ Max F1将达不到最终的“那又怎样？”这使得所有的艰苦工作都有了前景。</p></blockquote><p id="70b2" class="pw-post-body-paragraph kz la it lb b lc ou ju le lf ov jx lh li ow lk ll lm ox lo lp lq oy ls lt lu im bi translated"><strong class="lb iu">最后一件事</strong>:完成后不要忘记关闭h2o实例！</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="de70" class="mx lw it mt b gy my mz l na nb">h2o.shutdown(prompt = FALSE)</span><span id="ddf6" class="mx lw it mt b gy ng mz l na nb">## [1] TRUE</span></pre><h1 id="23a0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">代码库</h1><p id="6b34" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">完整的R代码和所有相关文件可以在我的GitHub profile @ <a class="ae ky" href="https://github.com/DiegoUsaiUK/Propensity_Modelling" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">倾向建模</strong> </a>中找到</p><h1 id="86a3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ul class=""><li id="ba6b" class="ni nj it lb b lc mn lf mo li oh lm oi lq oj lu nn no np nq bi translated">关于使用数据集的原始论文，请参见:<a class="ae ky" href="http://repositorium.sdum.uminho.pt/bitstream/1822/30994/1/dss-v3.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">一种预测银行电话营销成功的数据驱动方法。决策支持系统</strong> </a>，s .莫罗，p .科尔特斯和p .丽塔。</li><li id="8de6" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">加快<strong class="lb iu">探索性数据分析</strong>参见:<a class="ae ky" href="https://business-science.github.io/correlationfunnel/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> correlationfunnel包晕影</strong> </a></li><li id="9aa6" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">对于技术上严格但实用的机器学习可解释性<strong class="lb iu">请参见布拉德利·伯姆克的<a class="ae ky" href="https://uc-r.github.io/dalex" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">模型可解释性与DALEX </strong> </a></strong></li><li id="18d5" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">要深入了解用于检查完全训练的机器学习模型并在模型不可知的框架中比较其性能的工具和技术，请参见:P. Biecek，T. Burzykowski</li><li id="3ad3" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">关于销售预测和产品延期交货<strong class="lb iu">优化</strong>的高级教程，请参见马特·丹乔的<a class="ae ky" href="https://www.business-science.io/business/2017/10/16/sales_backorder_prediction.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">预测销售分析:使用机器学习来预测和优化产品延期交货</strong> </a></li><li id="f421" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">期望值框架</strong>见:<a class="ae ky" href="https://www.goodreads.com/book/show/17912916-data-science-for-business" rel="noopener ugc nofollow" target="_blank"> <em class="nc">商业数据科学</em> </a></li></ul></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="03d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nc">原载于2020年5月1日</em><a class="ae ky" href="https://diegousai.io/2020/05/propensity-modelling-abridged" rel="noopener ugc nofollow" target="_blank"><em class="nc">https://diegousai . io</em></a><em class="nc">。</em></p></div></div>    
</body>
</html>