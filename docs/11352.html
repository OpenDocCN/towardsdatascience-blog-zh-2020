<html>
<head>
<title>Data Verification —Data Lake &amp; Database Migration Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据验证—数据湖和数据库迁移项目</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-verification-data-lake-database-migration-projects-391f5a5554d9?source=collection_archive---------33-----------------------#2020-08-06">https://towardsdatascience.com/data-verification-data-lake-database-migration-projects-391f5a5554d9?source=collection_archive---------33-----------------------#2020-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bcd0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Spark 进行高速低成本数据验证的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3287d9b44568c5c42ad0b6b25cad4f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L08BxhdVH-9zwgKqbQg_gg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/mohamed_hassan-5229782/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4576720" rel="noopener ugc nofollow" target="_blank">穆罕默德·哈桑</a>拍摄，来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4576720" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a></p></figure><p id="15a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的 25 年里，我参与了大量的数据库迁移和数据湖项目。数据迁移/数据湖接收后，客户的一个非常常见的验收标准是执行数据验证。根据经验，我可以很容易地说，任何给定项目的大部分时间都花在了数据验证上。在处理异构数据库时尤其如此。花费在数据验证上的时间经常超过实际执行迁移或接收所花费的时间。如果您需要执行多次迁移和摄取迭代，问题会成倍增长。</p><p id="81fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的几年里，我的主要目标是开发一种不仅速度快而且成本低的解决方案。以下是我多年来开发的框架的发展阶段。</p><h2 id="6db1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">采样后进行人工验证</h2><p id="f042" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我早期，一种非常常见的数据验证方法是抽样。在此方法中，从源和目标中选择了一组样本行。质量保证工程师对样本集进行了目视扫描/比较。该过程大部分是手动的，因此效率低下且容易出错。此外，它只验证了一小部分行样本。</p><h2 id="5eed" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">采样后自动验证</h2><p id="b1c4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在这个方法中，从源和目标中选择一组样本行，然后是执行数据验证的 SQL/PERL 脚本。该过程是自动化的，非常高效，但有时仍然很慢，这取决于样本大小。该方法还验证了一个小样本行。</p><h2 id="0a4c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">整个数据集的自动验证</h2><p id="0ff1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">客户开始要求逐行逐列地进行数据验证。这意味着数据采样不再是一个选项。需要一种能够执行完整数据验证的解决方案。我们制定了如下计划:</p><ul class=""><li id="00da" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">从源和目标中根据主键选择相同行的串联列</li><li id="bdce" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">创建行的校验和并进行比较。校验和匹配确保行完全相同。</li><li id="4551" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">如果发现不一致，则将违规行写入失败表</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/650b7a82f378e3785bf9ab25360ee007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uu77tT9F5NQNy1k2kFiGeA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(<em class="ni">图片作者</em>)</p></figure><p id="eb72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始处理大型数据集之前，上述解决方案对我们来说工作得相当好。与此同时，大数据开始变得强大。尽管上述解决方案具有内置的并行处理能力，但我们经常开始缺少时间，错过最后期限。</p><p id="eaa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们计算出当前项目的数据验证每一次迭代需要超过 30 天时，问题变得极其严重和可怕。一个失败的开始，因为我们最终会错过所有的最后期限。</p><p id="aa63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个更好的解决方案…快速</p><h2 id="b356" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">分布式计算拯救世界</h2><p id="b943" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">幸运的是，我们已经进入了大数据时代。作为早期采用者，我们已经在几个项目中采用了 Hadoop。Spark 和云计算的应用即将出现。除了数据迁移，我们还遇到了几个数据湖项目。因此，我们希望创建一个框架，既能适用于这两种使用情形，又能兼容内部部署或云基础架构。我们是这样做的:</p><ul class=""><li id="c2ea" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><strong class="lb iu">数据接收:</strong>除了从源到目的地迁移/接收数据，我们还选择在 HDFS(本地 Hadoop)或 S3 (AWS cloud)上以<strong class="lb iu"> <em class="nj"> Parquet </em> </strong> <em class="nj"> </em>格式转储源和目的地数据的额外副本。如果您使用 AWS DMS 并使用—S3-settings“data format”:“parquet”创建一个 S3 端点，这一步非常简单</li><li id="e367" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><strong class="lb iu">基础架构:</strong>针对内部部署的——Spark 集群(Hadoop ),针对 AWS 云的——EMR 的——HDFS 上的 PySpark，HDFS 上的 PySpark。由于数据验证计划不是真正的关键任务，我们选择使用 4-5 个 Spot 实例来降低成本。对我们来说效果很好。我已经发布了 EMR 实例的详细信息，如下所示:</li></ul><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="73ae" class="lv lw it nl b gy np nq l nr ns">--instance-groups '[{"InstanceCount":5,"BidPrice":"OnDemandPrice",<br/>"EbsConfiguration":{"EbsBlockDeviceConfigs":[{"VolumeSpecification":{"SizeInGB":32,"VolumeType":"gp2"},"VolumesPerInstance":2}]},<br/>"InstanceGroupType":"CORE","InstanceType":"c4.8xlarge","Name":"Core - 2"},{"InstanceCount":1,<br/>"EbsConfiguration":{"EbsBlockDeviceConfigs":[{"VolumeSpecification":{"SizeInGB":32,"VolumeType":"gp2"},"VolumesPerInstance":2}]},<br/>"InstanceGroupType":"MASTER","InstanceType":"m5.xlarge","Name":"Master - 1"}]'</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/fcff0ce99bf3423a7e319151b6569385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fq4H5dme5-dT65cYFr4kIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(<em class="ni">作者图片</em>)</p></figure><ul class=""><li id="ecf9" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><strong class="lb iu">火花码:</strong>漂亮<em class="nj">简单</em>却非常<em class="nj">有效</em>。为每个表创建两个 pyspark 数据帧，并执行两次减法，如下所示:</li></ul><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="eb85" class="lv lw it nl b gy np nq l nr ns">dfsourcesubdfdest = dfsource.subtract(dfdest)<br/>dfdestsubdfsource = dfdest.subtract(dfsource)</span></pre><ul class=""><li id="1f4d" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><strong class="lb iu">以前的方法与新方法的比较:</strong>假设比较 5 亿行，以前的方法需要 36 个小时才能完成。如果表有数十亿行(在我们的例子中经常如此)，那么您就完了。使用新方法，将数据转储到存储器只需一个多小时，进行火花比较大约需要 20 分钟。相当整洁…😄</li></ul><p id="bcdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能帮助你进行快速而低成本的数据验证。尽管我还没有发布完整的代码集和命令，但是如果您需要更多的细节，请随时联系我。</p><p id="8763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章是有帮助的。<strong class="lb iu">三角洲湖</strong>作为大数据 Hadoop、Spark &amp; Kafka 课程的一部分，由<a class="ae ky" href="http://www.datafence.com" rel="noopener ugc nofollow" target="_blank"> Datafence 云学院</a>提供。课程是周末自己在网上教的。</p></div></div>    
</body>
</html>