<html>
<head>
<title>Stock Price Prediction Based on Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于深度学习的股票价格预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stock-price-prediction-based-on-deep-learning-3842ef697da0?source=collection_archive---------2-----------------------#2020-06-24">https://towardsdatascience.com/stock-price-prediction-based-on-deep-learning-3842ef697da0?source=collection_archive---------2-----------------------#2020-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d19e029e9144c4d1f29149c629059523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0LWDebOEFD4aAayW7rIKw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@jamie452?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰米街</a>在<a class="ae jg" href="/s/photos/stock-exchange?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><div class=""/><div class=""><h2 id="7610" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">机器学习如何用于投资？</h2></div><p id="bde8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">众所周知，如果人们能够破解<em class="lu">咒语</em>成功预测股票价格，股票市场就是一个可以发财的地方。尽管在大多数情况下不可能准确预测股票价格。所以，问题来了，如果人类可以估计并考虑所有因素来预测股票的走势或未来价值，为什么机器不能？或者，换句话说，我们如何让机器预测一只股票的价值？长期以来，全世界的科学家、分析师和研究人员一直在试图设计一种方法来回答这些问题。</p><p id="9896" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我将尝试展示一种所谓的<strong class="la jk">算法交易</strong>方法。这是一个完全基于研究目的的方法。请不要基于这种算法进行投资。那么，我们开始吧。</p><h2 id="6803" class="lv lw jj bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">整个想法</h2><p id="e2cc" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">股票价格可能取决于当前世界和股票市场中的几个因素。我们将尝试考虑两个主要因素的组合:</p><ol class=""><li id="2475" class="mt mu jj la b lb lc le lf lh mv ll mw lp mx lt my mz na nb bi translated">其他公司股价的影响和相关性，即其他公司股价的涨跌如何影响特定目标公司的股价</li><li id="2f72" class="mt mu jj la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">目标公司过去的业绩和记录</li></ol><p id="796a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我看过几个博客，大多关注其中一个因素，主要是第二个因素。我认为，如果我们能设法将这两个因素都考虑进去，我们就能使我们的预测器更加可靠。</p><p id="4f31" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我尝试使用三种深度学习模型的组合来实现这一点。首先，基于神经网络的回归模型考虑了其他公司对目标公司的影响。其次，一个递归神经网络模型来研究目标公司的过去行为并相应地给出结果。为此，我使用了 LSTM 层。最后，一个人工神经网络，接受他们的预测，并帮助达成一个坚定和稳健的结论。</p><h2 id="bb14" class="lv lw jj bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">资料组</h2><p id="3e59" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">在本文中，我们将使用标准普尔 500 公司数据库，尽管我只使用了 200 家公司的详细信息。我用网络清理从维基百科页面收集了 S&amp;P 名单。我用这个作为一个来源，因为它是实时更新的。我在一些博客里看到过这个方法，所以我也用过。这似乎是一个可靠的来源。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="cd79" class="lv lw jj nm b gy nq nr l ns nt">import bs4 as bs<br/>import pickle<br/>import requests</span><span id="0249" class="lv lw jj nm b gy nu nr l ns nt">def save_tickers():<br/> resp=requests.get('<a class="ae jg" href="https://en.wikipedia.org/wiki/List_of_S%26P_500_companies'" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/List_of_S%26P_500_companies'</a>)<br/> soup=bs.BeautifulSoup(resp.text)<br/> table=soup.find('table',{'class':'wikitable sortable'})<br/> tickers=[]<br/> for row in table.findAll('tr')[1:]:<br/>  ticker=row.findAll('td')[0].text[:-1]<br/>  tickers.append(ticker)</span><span id="7a11" class="lv lw jj nm b gy nu nr l ns nt">with open("tickers.pickle",'wb') as f:<br/>  pickle.dump(tickers, f)</span><span id="dab4" class="lv lw jj nm b gy nu nr l ns nt">return tickers</span><span id="9c5d" class="lv lw jj nm b gy nu nr l ns nt">save_tickers()</span></pre><p id="7afd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个代码将帮助你放弃 500 强公司的股票。</p><p id="ef50" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我用熊猫网络数据阅读器从雅虎收集了他们的详细信息。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="cae7" class="lv lw jj nm b gy nq nr l ns nt">import bs4 as bs<br/>import pickle<br/>import requests<br/>import datetime as dt<br/>import os<br/>import pandas as pd<br/>import pandas_datareader.data as web</span><span id="5d12" class="lv lw jj nm b gy nu nr l ns nt">def fetch_data():<br/> with open("tickers.pickle",'rb') as f:<br/>   tickers=pickle.load(f)</span><span id="99de" class="lv lw jj nm b gy nu nr l ns nt">if not os.path.exists('stock_details'):<br/>  os.makedirs('stock_details')<br/> count=200</span><span id="5ae7" class="lv lw jj nm b gy nu nr l ns nt">start= dt.datetime(2010,1,1)<br/> end=dt.datetime(2020,6,22)<br/> count=0<br/> for ticker in tickers:<br/>  if count==200:<br/>   break<br/>  count+=1<br/>  print(ticker)<br/>  <br/>  try:<br/>    df=web.DataReader(ticker, 'yahoo', start, end)<br/>    df.to_csv('stock_details/{}.csv'.format(ticker))<br/>  except:<br/>    print("Error")<br/>    continue</span><span id="4cc4" class="lv lw jj nm b gy nu nr l ns nt">fetch_data()</span></pre><p id="5030" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码将有助于使用 web 阅读器从 Yahoo 收集数据。我保留了 200 个，因为我只想使用 200 个公司详细信息。在这 200 家公司中，我们将有一个目标公司和 199 家公司，这将有助于达成对我们的目标公司的预测。</p><p id="f0ab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该代码将生成一个“stock_details”文件夹，其中包含从 2010 年 1 月 1 日到 2020 年 6 月 22 日的 200 份公司详细信息。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nv"><img src="../Images/ad30927de0339eb7ec11c9bd45f1bf64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gFUBfaIiBHhzIBK_mXBzUA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">文件</p></figure><p id="7233" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个细节文件都将被保存在它的股票代码中。我选择了亚马逊作为我的目标股票。因此，我将尝试预测亚马逊的股票价格。它的股票代码是 AMZN。</p><p id="f5c5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，让我们来看看细节文件的结构。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/c4f443e917d0f902ed70f5d13c4e51e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9ps7g2sCIoewG3rt1Qvzg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">结构</p></figure><p id="5e15" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是结构。它将“日期”作为索引特征。“高”表示一天中的最高值。“低”表示最低。“开盘”是开盘价，“收盘”是当天的收盘价格。现在，有时公司会规定接近值。因此，最终值是“调整收盘”值，如果股票价格不受管制，它与“收盘”值相同。“交易量”是指该日该公司的股票交易量。</p><p id="1733" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将把每只股票的这种“可调接近”价值视为每只股票对我们目标股票的贡献特征。因此，我们将把每只股票的 Adj Close 重命名为相应的股票代码，并将其包含在我们的特性集中。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="fa8c" class="lv lw jj nm b gy nq nr l ns nt">import os<br/>import pandas as pd<br/>import pickle</span><span id="8dda" class="lv lw jj nm b gy nu nr l ns nt">def compile():<br/> with open("tickers.pickle",'rb') as f:<br/>   tickers=pickle.load(f)</span><span id="0a0a" class="lv lw jj nm b gy nu nr l ns nt">main_df=pd.DataFrame()</span><span id="1a77" class="lv lw jj nm b gy nu nr l ns nt">for count,ticker in enumerate(tickers):<br/>  if 'AMZN' in ticker:<br/>   continue<br/>  if not os.path.exists('stock_details/{}.csv'.format(ticker)):<br/>   continue<br/>  df=pd.read_csv('stock_details/{}.csv'.format(ticker))<br/>  df.set_index('Date',inplace=True)</span><span id="1fa3" class="lv lw jj nm b gy nu nr l ns nt">df.rename(columns={'Adj Close': ticker}, inplace=True)<br/>  df.drop(['Open','High','Low',"Close",'Volume'],axis=1,inplace=True)</span><span id="5f4a" class="lv lw jj nm b gy nu nr l ns nt">if main_df.empty:<br/>   main_df=df<br/>  else:<br/>   main_df=main_df.join(df,how='outer')</span><span id="85d6" class="lv lw jj nm b gy nu nr l ns nt">print(main_df.head())<br/> main_df.to_csv('Dataset_temp.csv')</span><span id="f2ec" class="lv lw jj nm b gy nu nr l ns nt">compile()</span></pre><p id="1e65" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个代码片段将帮助我们选择除了我们的目标股票 AMZN 之外的每只股票的调整后收盘列，将该列重命名为 ticker，并将其合并到我们的功能集中。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/20412be4567d2738469c59772a7cfebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zq3Wu-KaMljhRW9rR27aGg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">特征文件的结构</p></figure><p id="021b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它会产生一个这样的特性集。日期是索引，与日期相对应的是每个收报机的“Adj Close”值。现在，我们将看到最初有几个空列。这是因为这些公司在 2010 年还没有开始参与股市。这将给我们一个包含 199 个公司值和日期的 200 列的特性集。</p><p id="7adb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们关注我们的目标股票 AMZN 股票。如果我们开始可视化目标股票的每个给定列值，我们将获得这些值。</p><div class="nh ni nj nk gt ab cb"><figure class="ny iv nz oa ob oc od paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/466790960ce117f7fba739fe28a88f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*s2Pevn4AilYQeIYXu4ctjA.png"/></div></figure><figure class="ny iv nz oa ob oc od paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/e90700df8c011c830bfa4d11d36c81c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*DDW5NuFYTlnqsZo7TxUR7Q.png"/></div></figure><figure class="ny iv nz oa ob oc od paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/c90841a383c957437b89574b1dd2e18d.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*kd-0J78r3CpthUqWGF_WiQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk oe di of og translated">分别调整近、低和高可视化</p></figure></div><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b7a229f22c6342d9b445455e6f4a4dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*2tpLcQjA8qen6S7Pkx9LOg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">卷</p></figure><p id="6237" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们用蜡烛线符号来想象我们的股票。我用的是熊猫 0.24.2 版本。可能存在一个问题，因为在当前版本中，此模块已被折旧。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="325e" class="lv lw jj nm b gy nq nr l ns nt">import datetime as dt<br/>import matplotlib.pyplot as plt<br/>from matplotlib import style<br/>from mpl_finance import candlestick_ohlc<br/>import matplotlib.dates as mdates<br/>import pandas as pd<br/>df=pd.read_csv('stock_details/AMZN.csv',index_col=0,parse_dates=True)<br/>df_ohlc= df['Adj Close'].resample('10D').ohlc()<br/>df_volume=df['Volume'].resample('10D').sum()<br/>df_ohlc.reset_index(inplace=True)<br/>df_ohlc['Date']=df_ohlc['Date'].map(mdates.date2num)</span><span id="dc51" class="lv lw jj nm b gy nu nr l ns nt">ax1=plt.subplot2grid((6,1), (0,0), rowspan=5, colspan=1)<br/>ax2=plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1 , sharex=ax1)<br/>ax1.xaxis_date()</span><span id="b395" class="lv lw jj nm b gy nu nr l ns nt">candlestick_ohlc(ax1,df_ohlc.values, width=2, colorup='g')<br/>ax2.fill_between(df_volume.index.map(mdates.date2num),df_volume.values,0)</span><span id="f53e" class="lv lw jj nm b gy nu nr l ns nt">plt.show()</span></pre><p id="b815" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码将为我们提供烛台符号。</p><div class="nh ni nj nk gt ab cb"><figure class="ny iv oi oa ob oc od paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/20b1e8b2af9bf29cd0d5a9876cf538b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*d5O1eFeMv_lkf2AEWliwjw.png"/></div></figure><figure class="ny iv oj oa ob oc od paragraph-image"><img src="../Images/384177a71e4071d124949ebed5e0a05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*MWu9QWf8L8GPxT9Re9VSvw.png"/><p class="jc jd gj gh gi je jf bd b be z dk ok di ol og translated">亚马逊股票的蜡烛棒符号</p></figure></div><p id="762e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们设计一些特征来帮助我们预测我们的目标。</p><p id="4fb8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将计算 50 移动平均线。这个特性被很多交易者用来做预测。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="2b72" class="lv lw jj nm b gy nq nr l ns nt">df['Moving_av']= df['Adj Close'].rolling(window=50,min_periods=0).mean()</span></pre><p id="864c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个片段将帮助我们生成移动平均线。实际上，它是第 I 个指数的“Adj Close”值的 i-50 到 I 值的平均值。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/59e13285603f0712d2c13306d6d24247.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*5vrRKmyXxMpy5B7de5C1hw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">移动平均图</p></figure><p id="8ca0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们将尝试获得另外两个特征，即我们股票的成交量增长率和调整后收盘价增长率</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="d41b" class="lv lw jj nm b gy nq nr l ns nt">i=1<br/>rate_increase_in_vol=[0]<br/>rate_increase_in_adj_close=[0]</span><span id="0c16" class="lv lw jj nm b gy nu nr l ns nt">while i&lt;len(df):<br/>    rate_increase_in_vol.append(df.iloc[i]['Volume']-df.iloc[i-1]['Volume'])<br/>    rate_increase_in_adj_close.append(df.iloc[i]['Adj Close']-df.iloc[i-1]['Adj Close'])<br/>    i+=1<br/>    <br/>df['Increase_in_vol']=rate_increase_in_vol<br/>df['Increase_in_adj_close']=rate_increase_in_adj_close</span></pre><p id="5925" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个片段将帮助我们获得这些特性。</p><div class="nh ni nj nk gt ab cb"><figure class="ny iv on oa ob oc od paragraph-image"><img src="../Images/fc2a48d9788800b41720c56e928d4470.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*2HWtFwd03mtCKyYIpum2jg.png"/></figure><figure class="ny iv oo oa ob oc od paragraph-image"><img src="../Images/eb6d116d3d7a7ef1a165c7b7705eb14c.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*m5DwVVyO2pIxWl04GVS4bw.png"/><p class="jc jd gj gh gi je jf bd b be z dk op di oq og translated">调整后收盘增长率和成交量增长率</p></figure></div><p id="570d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们的目标股票的特征文件已经准备好了。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/01743d179fa17e0028dcf555b3de70c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMWVlTQAAWLm0fBUv3TQJA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">目标库存的特征文件结构</p></figure><p id="d353" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们将这两个特性文件合并成主特性集。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="d578" class="lv lw jj nm b gy nq nr l ns nt">Index(['High', 'Low', 'Open', 'Close', 'Volume', 'Adj Close', 'Moving_av',<br/>       'Increase_in_vol', 'Increase_in_adj_close', 'MMM',<br/>       ...<br/>       'FITB', 'FE', 'FRC', 'FISV', 'FLT', 'FLIR', 'FLS', 'FMC', 'F', 'Date'],<br/>      dtype='object', length=207)</span></pre><p id="3f99" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是我们主要特性集的列。</p><p id="b4ad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它有 207 列，其中 200 列来自其他公司列表，7 列来自我们的目标股票特性集，锚定在日期列上。所以，我们有 207 列。</p><h2 id="8886" class="lv lw jj bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">回归</h2><p id="ef39" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">在这一部分，我们将研究其他股票对我们的目标股票的影响。我们将尝试预测亚马逊股票的最高价、最低价、开盘价和收盘价。</p><p id="6e43" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，让我们分析我们的数据。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/5a5e282cc79f03d0dcd37acfc494e7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spuAAEWkuOLh2OzukYbjZw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">回归相关图。</p></figure><p id="2644" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们可以看到我们已经发现了一些相关性。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/ab94bbbad113f343b23b8a913c384669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGRslJbey9M7LRX_3XmEmg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">回归直方图。</p></figure><p id="9290" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，从我们的图来看，很明显，我们的数据集中会有一些相关性。因此，接下来，我们从训练数据集中删除开盘、收盘、盘高和盘低值，并将它们用作目标标签或值集。我们还删除了数量和日期，因为它们没有相关性。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="b91e" class="lv lw jj nm b gy nq nr l ns nt">from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)</span></pre><p id="dc0a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们把我们的组分成训练组和测试组。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="60f6" class="lv lw jj nm b gy nq nr l ns nt">from tensorflow.keras.callbacks import ModelCheckpoint<br/>from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import Dense, Activation, Flatten<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.ensemble import RandomForestRegressor<br/>from sklearn.metrics import mean_absolute_error <br/>from sklearn.metrics import accuracy_score</span><span id="c967" class="lv lw jj nm b gy nu nr l ns nt">def model():<br/>    mod=Sequential()<br/>    mod.add(Dense(32, kernel_initializer='normal',input_dim = 200, activation='relu'))<br/>    mod.add(Dense(64, kernel_initializer='normal',activation='relu'))<br/>    mod.add(Dense(128, kernel_initializer='normal',activation='relu'))<br/>    mod.add(Dense(256, kernel_initializer='normal',activation='relu'))<br/>    mod.add(Dense(4, kernel_initializer='normal',activation='linear'))<br/>    <br/>    mod.compile(loss='mean_absolute_error', optimizer='adam', metrics=['accuracy','mean_absolute_error'])<br/>    mod.summary()<br/>    <br/>    return mod</span></pre><p id="7316" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们将用于回归的模型。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/507b938d9b553574015886889cef0e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*GPq8ybLWMEZ_Q-JQdYXN5Q.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">回归的模型摘要</p></figure><p id="71f8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以使用以下代码片段运行它:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="d259" class="lv lw jj nm b gy nq nr l ns nt">from tensorflow.keras.wrappers.scikit_learn import KerasRegressor<br/>regressor = KerasRegressor(build_fn=model, batch_size=16,epochs=2000)<br/>import tensorflow as tf<br/>callback=tf.keras.callbacks.ModelCheckpoint(filepath='Regressor_model.h5',<br/>                                           monitor='mean_absolute_error',<br/>                                           verbose=0,<br/>                                           save_best_only=True,<br/>                                           save_weights_only=False,<br/>                                           mode='auto')<br/>results=regressor.fit(X_train,y_train,callbacks=[callback])</span></pre><p id="6f64" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我使用了 Keras 回归器。保存了最佳权重并使用了 2000 个纪元。平均绝对误差是我们的损失函数。删除列后，我们的输入为 200。我们将为每个输入获得四个值，高、低、开、闭。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="8404" class="lv lw jj nm b gy nq nr l ns nt">y_pred= regressor.predict(X_test)<br/>import numpy as np<br/>y_pred_mod=[]<br/>y_test_mod=[]</span><span id="c17c" class="lv lw jj nm b gy nu nr l ns nt">for i in range(0,4):<br/>    j=0<br/>    y_pred_temp=[]<br/>    y_test_temp=[]<br/>    <br/>    while(j&lt;len(y_test)):<br/>        y_pred_temp.append(y_pred[j][i])<br/>        y_test_temp.append(y_test[j][i])<br/>        j+=1<br/>        <br/>    <br/>    y_pred_mod.append(np.array(y_pred_temp))<br/>    y_test_mod.append(np.array(y_test_temp))</span></pre><p id="d1d4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这给了我们测试集的预测值。这个代码片段有助于以解析的格式获取它们。</p><div class="nh ni nj nk gt ab cb"><figure class="ny iv ov oa ob oc od paragraph-image"><img src="../Images/6707eeea4370becff5eadb2d485d958c.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*aghe2PScYkFnH7fOND7PMA.png"/></figure><figure class="ny iv ov oa ob oc od paragraph-image"><img src="../Images/d0c86221e366bfa0c1fe2c829d6fc2bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*aMkb0BkgzcXvFw_fBL6T_w.png"/></figure></div><div class="ab cb"><figure class="ny iv ov oa ob oc od paragraph-image"><img src="../Images/41260d7400f604b340c423f85775bae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*4YqBv7YaMGw-r9cKi8E79g.png"/></figure><figure class="ny iv ov oa ob oc od paragraph-image"><img src="../Images/c799eae5c7d9f0ee7f217e4013495070.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*ID8OnNkbKq5xKVp5fXPySA.png"/><p class="jc jd gj gh gi je jf bd b be z dk ow di ox og translated">分别为高、低、开、闭的回归结果。</p></figure></div><p id="4393" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以看到我们的模型表现得相当好，考虑到大多数点位于回归线上，很少有异常值。</p><p id="b867" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们完成了回归部分。接下来，我们将移动到 RNN 部分。</p><h2 id="5895" class="lv lw jj bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">递归神经网络</h2><p id="5ee2" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">我们将使用 RNN 来分析我们的目标股票。所以我们将只使用目标库存特征文件。现在，这里我们将使用 LSTM 层的工作 RNN 原则，但工作在一个门控的方法。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/14525301676c762abeb7169508a1b333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*Sg964-VhOI3uHcviNrelFA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://colah.github.io/about.html" rel="noopener ugc nofollow" target="_blank"> Colah </a></p></figure><p id="26e6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">LSTM 有助于 RNN 长时间保持记忆，解决渐变消失和爆炸问题。这里就不详细说了。详情<a class="ae jg" href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="noopener ugc nofollow" target="_blank">你可以在这里</a>找到。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/cfac74b15bac9e52dd1a04b6993c7dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*zdVJAHAwSqwMQicEUEPheg.png"/></div></figure><p id="f6d7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们 LSTM 的数据集。</p><p id="c651" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们需要预测高，低，开放，关闭。因此，现在，我们将删除“日期”,因为它没有相关性。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="4a5a" class="lv lw jj nm b gy nq nr l ns nt">High         Low        Open       Close    Volume   Adj Close  \<br/>0  137.279999  134.520004  137.089996  134.520004   4523000  134.520004   <br/>1  136.610001  133.139999  136.250000  133.899994   7599900  133.899994   <br/>2  135.479996  131.809998  133.429993  134.690002   8851900  134.690002   <br/>3  134.729996  131.649994  134.600006  132.250000   7178800  132.250000   <br/>4  132.320007  128.800003  132.009995  130.000000  11030200  130.000000   </span><span id="9932" class="lv lw jj nm b gy nu nr l ns nt">    Moving_av  Increase_in_vol  Increase_in_adj_close  <br/>0  134.520004              0.0               0.000000  <br/>1  134.209999        3076900.0              -0.620010  <br/>2  134.370000        1252000.0               0.790009  <br/>3  133.840000       -1673100.0              -2.440002</span></pre><p id="6516" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们的输入将是这个数据帧的值。因此，我们的输入将有 9 列，相应地，我们的输出将有 4 列，高，低，开放，关闭我们的目标股票。</p><p id="204c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要为 LSTM 模型创建训练和测试集。</p><p id="82ab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们将把长度为 2636 条记录的数据分成两部分。我们将使用 0–2200 条记录作为训练集，2200–2636 条记录作为测试集。我们从我们的训练集中选择包含 4 个目标列的目标集。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="4224" class="lv lw jj nm b gy nq nr l ns nt">df_train=df_main[:2200]<br/>df_target=df_train[['High','Low','Open','Close']]</span></pre><p id="cec0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们缩放数据以使我们的模型易于收敛，因为我们的数据集中有大量不同的值。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="1a1d" class="lv lw jj nm b gy nq nr l ns nt">sc = MinMaxScaler(feature_range = (0, 1))<br/>target_set=df_target.values<br/>train_set=df_train.values<br/>training_set_scaled = sc.fit_transform(train_set)<br/>target_set_scaled = sc.fit_transform(target_set)</span></pre><p id="ff5b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，我们就获得了 LSTM 模型的定标数据。</p><p id="1b76" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">LSTM 模型接受系列数据并产生输出。我们的 LSTM 是多对多的 RNN 模式。所以，我们需要为此产生一系列数据。为此，我们从第 50 个索引开始，并移动到训练集的长度。我们在列表中添加了 0–49，即 50 个值。我们已经为我们所有的功能创建了这样的列表。</p><p id="a7c4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们的输入有(n x 50 x 9)维数据用于我们的训练集。我们有 9 个特性，每个特性都是 50 天的特性值列表。n 是从给定数据集获得的此类序列的数量。现在，我们的目标集是第 51 天目标列的值。</p><p id="a9db" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们通过使用，</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="8dc6" class="lv lw jj nm b gy nq nr l ns nt">X_train = []<br/>y_train = []<br/>for i in range(50,len(train_set)):<br/>    X_train.append(training_set_scaled[i-50:i,:])<br/>    y_train.append(target_set_scaled[i,:])<br/>    <br/>X_train, y_train = np.array(X_train), np.array(y_train)</span></pre><p id="5e07" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们观察火车和目标组的形状。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="6897" class="lv lw jj nm b gy nq nr l ns nt">print(X_train.shape)</span><span id="219b" class="lv lw jj nm b gy nu nr l ns nt">(2150, 50, 9)</span><span id="5af6" class="lv lw jj nm b gy nu nr l ns nt">print(y_train.shape)</span><span id="a751" class="lv lw jj nm b gy nu nr l ns nt">(2150, 4)</span></pre><p id="e1cd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们设计我们的模型。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="0fb7" class="lv lw jj nm b gy nq nr l ns nt">from sklearn.metrics import accuracy_score<br/>from tensorflow.keras.layers import BatchNormalization<br/>import datetime as dt<br/>from sklearn import model_selection<br/>from sklearn.metrics import confusion_matrix<br/>from sklearn.preprocessing import StandardScaler<br/>from sklearn.model_selection import train_test_split<br/>import numpy as np<br/>import pandas as pd<br/>from sklearn.preprocessing import MinMaxScaler<br/>from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import Dense<br/>from tensorflow.keras.layers import LSTM<br/>from tensorflow.keras.layers import Dropout</span><span id="122f" class="lv lw jj nm b gy nu nr l ns nt">def model():<br/>    mod=Sequential()<br/>    mod.add(LSTM(units = 64, return_sequences = True, input_shape = (X_train.shape[1], 9)))<br/>    mod.add(Dropout(0.2))<br/>    mod.add(BatchNormalization())<br/>    mod.add(LSTM(units = 64, return_sequences = True))<br/>    mod.add(Dropout(0.1))<br/>    mod.add(BatchNormalization())<br/>   <br/>    mod.add((LSTM(units = 64)))<br/>    mod.add(Dropout(0.1))<br/>    mod.add(BatchNormalization())<br/>    mod.add((Dense(units = 16, activation='tanh')))<br/>    mod.add(BatchNormalization())<br/>    mod.add((Dense(units = 4, activation='tanh')))<br/>    mod.compile(loss='mean_squared_error', optimizer='adam', metrics=['accuracy','mean_squared_error'])<br/>    mod.summary()<br/>    <br/>    return mod</span></pre><p id="7dd7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们的 LSTM 模型。我在这里用过 Keras 层。损失函数是均方误差。我们已经使用了亚当优化。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/9d8c30b9cbbeeb2b461d09e5a5696721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*NwOeY3LCMlPOONw5vxXQ-Q.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">LSTM 模型形状</p></figure><p id="9e2e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了训练我们的模型，我们将使用这个片段。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="8513" class="lv lw jj nm b gy nq nr l ns nt">import tensorflow as tf<br/>callback=tf.keras.callbacks.ModelCheckpoint(filepath='./RNN_model.h5',<br/>                                           monitor='mean_squared_error',<br/>                                           verbose=0,<br/>                                           save_best_only=True,<br/>                                           save_weights_only=False,<br/>                                           mode='auto',<br/>                                           save_freq='epoch')<br/>RNN_model.fit(X_train, y_train, epochs = 2000, batch_size = 32,callbacks=[callback])</span></pre><p id="a73c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的模型现在已经训练好了。</p><p id="ac1d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们专注于测试部分。</p><p id="8c4d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的测试值有 2200 到 2636 条记录。因此，我们通过选择股票的开盘价、收盘价、最高价、最低价这四列来获得目标值。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="816d" class="lv lw jj nm b gy nq nr l ns nt">df_test=df_main[2200:]<br/>df_target_test=df_test[['High','Low','Open','Close']]<br/>target_set_test=df_target_test.values<br/>test_set=df_test.values</span></pre><p id="7de2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了进行测试，我们还需要转换我们的测试特征数据集，并为该数据集形成一系列 50 个特征值，就像我们在训练集的情况下所做的那样。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="6d41" class="lv lw jj nm b gy nq nr l ns nt">predicted_stock_price = RNN_model.predict(X_test)<br/>predicted_stock_price = sc.inverse_transform(predicted_stock_price)<br/>print(predicted_stock_price)</span></pre><p id="76ef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个代码片段有助于获得我们想要的预测结果。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="04b7" class="lv lw jj nm b gy nq nr l ns nt">array([[1690.364 , 1610.5382, 1643.4277, 1643.8912],<br/>       [1687.384 , 1607.5323, 1640.3225, 1640.7366],<br/>       [1688.7346, 1608.965 , 1641.6777, 1642.0984],<br/>       ...,<br/>       [2567.6138, 2510.703 , 2522.8406, 2538.787 ],<br/>       [2576.5056, 2519.5195, 2531.803 , 2547.9304],<br/>       [2578.5886, 2521.65  , 2533.9177, 2550.0896]], dtype=float32)</span></pre><p id="cbc5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果就是这样获得的。</p><p id="b930" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们用目标列的实际值相应地绘制它们，我们将获得下面的图。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/e909bb348a7356f64d9ec1b759fc21e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*icvQQJBISqgBrQCVvlmQGA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">LSTM 取得了成果</p></figure><p id="ffa1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们观察，有 4 行，这是因为我们有 4 列作为目标。我们可以看到模型在大部分地方获得了曲线模式。</p><p id="e0c9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们分别绘制它们，我们将获得如下 4 幅图。</p><div class="nh ni nj nk gt ab cb"><figure class="ny iv ov oa ob oc od paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/c859ba385c8b082a44a0fc383d27798d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*wTpJ6Fmn6FZ1bTG6AVRaug.png"/></div></figure><figure class="ny iv ov oa ob oc od paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/71fc43fdb8eec6a350b8b50d5f1abe2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*j_Y0RSe7zWam0MXQODK3Pw.png"/></div></figure></div><div class="ab cb"><figure class="ny iv ov oa ob oc od paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/1440fa4acdf655cbbb96bcf2a8dc9ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*CBffFFMnYLnz96S-86y1Fg.png"/></div></figure><figure class="ny iv ov oa ob oc od paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/38f903c887f192f14cf7c1336ee2ca1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*UF-NIR96Vriqz3-VS9Vkrw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk ow di ox og translated">RNN 的高、低、开和关</p></figure></div><p id="9c1d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们使用 LSTM，基于股票的过去价值来结束对单个目标股票的研究。现在，我们转到封面或结论部分。</p><h2 id="14be" class="lv lw jj bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">覆盖人工神经网络</h2><p id="0727" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">现在，这是结论部分。我们使用两个排他性模型研究了可能影响公司股票的两个不同领域，得出了两个不同的结果。现在，我们将尝试合并两个结果。我们将通过合并获得的结果并在整个过程中训练我们的人工神经网络来做到这一点。</p><p id="31c0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于上面讨论的两个模型，我们有 4 个目标列。对于最后的结论，我们将尝试只预测两列，我们的目标股票的高点和低点。</p><p id="3343" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，为此，我们使用这两种模型来预测我们的完整数据集。回归模型产生 2636 个预测值。</p><p id="e3f4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码片段和结果如下:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="cd5b" class="lv lw jj nm b gy nq nr l ns nt">saved_model_regressor=tf.keras.models.load_model('Regressor_model.h5')<br/>Regressor_prediction=saved_model_regressor(X)<br/>import numpy as np<br/>y_pred_mod=[]</span><span id="5b95" class="lv lw jj nm b gy nu nr l ns nt">for i in range(0,4):<br/>    j=0<br/>    y_pred_temp=[]<br/>   <br/>    <br/>    while(j&lt;len(Regressor_prediction)):<br/>        y_pred_temp.append(Regressor_prediction[j][i])<br/>        <br/>        j+=1<br/>        <br/>    <br/>    y_pred_mod.append(np.array(y_pred_temp))<br/>Y_pred=pd.DataFrame(list(zip(y_pred_mod[0],y_pred_mod[1],y_pred_mod[2],y_pred_mod[3])),columns=['High_regress','Low_regress','Open_regress','Close_regress'])</span></pre><p id="b9b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是片段。它创建一个长度为 2636 的数据帧，包含四个预测值列。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="e158" class="lv lw jj nm b gy nq nr l ns nt">Y_pred.head()</span></pre><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/c4bd1694baeaa638ebb51f89ee61f425.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*fgm3OQohcarBW-uALFbJMQ.png"/></div></figure><p id="7931" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将其保存为 CSV 格式以备将来使用。</p><p id="ef65" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，类似地，我们为 LSTM 网络做这个。我们为前 50 个值获取一个值，因为前 50 个值是我们的第一个测试集。因此，除法是 0–49 获得第一个值，1–50 获得第二个值，依此类推。我们从 RNN 总共获得了 2586 个值。</p><p id="6f56" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">片段:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="3b81" class="lv lw jj nm b gy nq nr l ns nt">saved_model_RNN=tf.keras.models.load_model('RNN_model.h5')<br/>RNN_prediction=saved_model_RNN.predict(X_test)<br/>import numpy as np<br/>y_pred_mod=[]</span><span id="aa15" class="lv lw jj nm b gy nu nr l ns nt">for i in range(0,4):<br/>    j=0<br/>    y_pred_temp=[]<br/>   <br/>    <br/>    while(j&lt;len(RNN_prediction)):<br/>        y_pred_temp.append(RNN_prediction[j][i])<br/>        <br/>        j+=1<br/>        <br/>    <br/>    y_pred_mod.append(np.array(y_pred_temp))<br/>Y_pred=pd.DataFrame(list(zip(y_pred_mod[0],y_pred_mod[1],y_pred_mod[2],y_pred_mod[3])),columns=['High_RNN','Low_RNN','Open_RNN','Close_RNN'])</span></pre><p id="b5ad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该代码片段使用目标值的 RNN 预测生成一个数据帧。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/086f078e2bacf4007d841cd6fe216efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*_kFUcpbUUvwOuVDWD5zxSw.png"/></div></figure><p id="b194" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们对两个模型的预测都准备好了。我们需要从回归预测中删除 0–50 指数，因为这些值没有 RNN 预测。我们现在准备合并结果。</p><p id="2b37" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在合并结果之后，我们获得了具有 8 列的 2586 个值的数据帧。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="f602" class="lv lw jj nm b gy nq nr l ns nt">df<strong class="nm jk">=</strong>pd.concat([df1,df2],axis<strong class="nm jk">=</strong>1)</span><span id="6f0c" class="lv lw jj nm b gy nu nr l ns nt">df.head()</span></pre><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/598a0348fbe7da6aa1521bb1fe3c1d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*e-mWmjgo6nZqEX2ESeWFOg.png"/></div></figure><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/def348ac1db32ee3fdf716263fe8939d.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*4G-nbRCiQ2xINZqcyLwVHw.png"/></div></figure><p id="cf93" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是连接的结果。</p><p id="d81f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">整个事情将成为我们的人工神经网络模型的特征集。那么，我们的目标是什么？我们的目标集合将由原始数据集中亚马逊目标股票的原始高值和低值组成。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="ab8e" class="lv lw jj nm b gy nq nr l ns nt">df1=pd.read_csv("dataset_target_2.csv")<br/>target_high=[]<br/>target_low=[]<br/>i=50<br/>while i&lt;len(df1):<br/>    target_high.append(df1.iloc[i]['High'])<br/>    target_low.append(df1.iloc[i]['Low'])<br/>    i+=1<br/>df['Target_high']=target_high<br/>df['Target_low']=target_low</span><span id="6d89" class="lv lw jj nm b gy nu nr l ns nt">df.to_csv('feature.csv',index=False)</span></pre><p id="7f5e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个代码片段有助于合并我们特性集中的所有列。有 10 列。来自两个模型的 8 个特征列和目标股票的高低值作为目标值。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/0ea9a4139268254fbeea06b4b5ea26db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*fwu1bkQ61Td_GUOwEGDl3A.png"/></div></figure><p id="3906" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的新特性集如下所示。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/85c824aad177ad6ba00dc40ab73aa49b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXrPxFQAHCa6BCuva5z0Ow.png"/></div></div></figure><p id="6b91" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们的特征直方图。这里，我们也从图中得到了很好的相关性。现在让我们设计和训练我们的人工神经网络模型。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="6f38" class="lv lw jj nm b gy nq nr l ns nt">X_Df=df_main[['High_regress','Low_regress','Open_regress','Close_regress','High_RNN','Low_RNN','Open_RNN','Close_RNN']].values<br/>y_Df=df_main[['Target_high','Target_low']].values<br/>from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X_Df, y_Df, test_size=0.3)</span></pre><p id="0589" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们看看我们的模型设计。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="9bdc" class="lv lw jj nm b gy nq nr l ns nt">from tensorflow.keras.callbacks import ModelCheckpoint<br/>from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import Dense, Activation, Flatten<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.ensemble import RandomForestRegressor<br/>from sklearn.metrics import mean_absolute_error <br/>from sklearn.metrics import accuracy_score</span><span id="5f29" class="lv lw jj nm b gy nu nr l ns nt">def model():<br/>    mod=Sequential()<br/>    mod.add(Dense(32, kernel_initializer='normal',input_dim = 8, activation='relu'))<br/>    mod.add(Dense(64, kernel_initializer='normal',activation='relu'))<br/>    mod.add(Dense(128, kernel_initializer='normal',activation='relu'))<br/>    mod.add(Dense(2, kernel_initializer='normal',activation='linear'))<br/>    <br/>    mod.compile(loss='mean_absolute_error', optimizer='adam', metrics=['accuracy','mean_absolute_error'])<br/>    mod.summary()<br/>    <br/>    return mod</span></pre><p id="07fa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们的人工神经网络模型。正如我们看到的，我们模型的输入维度是 8。这是因为我们输入了 8 个特征列，其中 4 列来自每个模型的输出。输出层有两个节点，分别用于目标股票的高低栏。</p><p id="4c88" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用损失函数作为平均绝对误差，优化器作为亚当的优化器。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/cb71c27b91520d67780f0add229de05f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*bDGsdFNYueD3PILRsZnIlw.png"/></div></figure><p id="4147" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用下面的代码片段运行模型:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="218e" class="lv lw jj nm b gy nq nr l ns nt">import tensorflow as tf<br/>model_ANN=model()<br/>callback=tf.keras.callbacks.ModelCheckpoint(filepath='ANN_model.h5',<br/>                                           monitor='mean_absolute_error',<br/>                                           verbose=0,<br/>                                           save_best_only=True,<br/>                                           save_weights_only=False,<br/>                                           mode='auto')<br/>results=model_ANN.fit(X_train,y_train, epochs = 2000, batch_size = 32,callbacks=[callback])</span></pre><p id="acb7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们训练模型之后，我们将使用预测的模型来预测我们的测试集并检查性能。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="3104" class="lv lw jj nm b gy nq nr l ns nt">y_pred=model_ANN.predict(X_test)<br/>import numpy as np<br/>y_pred_mod=[]<br/>y_test_mod=[]</span><span id="88a0" class="lv lw jj nm b gy nu nr l ns nt">for i in range(0,2):<br/>    j=0<br/>    y_pred_temp=[]<br/>    y_test_temp=[]<br/>    <br/>    while(j&lt;len(y_test)):<br/>        y_pred_temp.append(y_pred[j][i])<br/>        y_test_temp.append(y_test[j][i])<br/>        j+=1<br/>        <br/>    <br/>    y_pred_mod.append(np.array(y_pred_temp))<br/>    y_test_mod.append(np.array(y_test_temp))<br/>df_res=pd.DataFrame(list(zip(y_pred_mod[0],y_pred_mod[1],y_test_mod[0],y_test_mod[1])),columns=['Pred_high','Pred_low','Actual_high','Actual_low'])</span></pre><p id="82dd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的预测器为每个特征记录预测两个值。因此，这个代码片段有助于获得两列的预测值和测试值，并将它们表示为 Dataframe。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/0bb6b728620a4697a228df9c5fe77faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*f21UG3-lMMGEHHj7Z2CucA.png"/></div></figure><p id="7955" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们绘图并检查。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="d260" class="lv lw jj nm b gy nq nr l ns nt">import matplotlib.pyplot as plt</span><span id="0d71" class="lv lw jj nm b gy nu nr l ns nt">ax1=plt.subplot2grid((4,1), (0,0), rowspan=5, colspan=1)</span><span id="85ef" class="lv lw jj nm b gy nu nr l ns nt">ax1.plot(df_res_2.index, df_res_2['Pred_high'], label="Pred_high")<br/>ax1.plot(df_res_2.index, df_res_2['Actual_high'], label="Actual_high")</span><span id="77de" class="lv lw jj nm b gy nu nr l ns nt">plt.legend(loc="upper left")<br/>plt.xticks(rotation=90)</span><span id="9913" class="lv lw jj nm b gy nu nr l ns nt">plt.show()</span></pre><p id="d129" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个片段有助于查看预测的和实际的变化。</p><div class="nh ni nj nk gt ab cb"><figure class="ny iv ov oa ob oc od paragraph-image"><img src="../Images/d4445c31e94cf52ec70ff78cfbb72534.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*0tHUiNHa8gHxQeSJZX47Fw.png"/></figure><figure class="ny iv ov oa ob oc od paragraph-image"><img src="../Images/021323a3310d95cd74df32e6d2ad95bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*aV2bstV4fBszmCNlqNkIEQ.png"/><p class="jc jd gj gh gi je jf bd b be z dk ow di ox og translated">我们目标设定变化的高低。</p></figure></div><p id="3662" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想检查我们的模特表演。我们可以通过使用下面的代码片段来做到这一点:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="29b0" class="lv lw jj nm b gy nq nr l ns nt">fig, ax = plt.subplots()<br/>ax.scatter(y_test_mod[0], y_pred_mod[0])<br/>ax.plot([y_test_mod[0].min(),y_test_mod[0].max()], [y_test_mod[0].min(), y_test_mod[0].max()], 'k--', lw=4)<br/>ax.set_xlabel('Measured')<br/>ax.set_ylabel('Predicted')<br/>plt.show()</span></pre><p id="2f18" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将获得:</p><div class="nh ni nj nk gt ab cb"><figure class="ny iv ov oa ob oc od paragraph-image"><img src="../Images/945b5c0786e27b5b124920e0122680af.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*oBXTsVf4JV70NWGfYywd2Q.png"/></figure><figure class="ny iv ov oa ob oc od paragraph-image"><img src="../Images/9eb8fa23721ab44f00f24309a1210823.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*xwxKxmv6t-IomIpGMSi0_A.png"/><p class="jc jd gj gh gi je jf bd b be z dk ow di ox og translated">我们模型的低柱和高柱。</p></figure></div><p id="a901" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些线性图表明，我们的模型预测值和实际值之间存在线性关系。</p><p id="20cc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们的复合模型在预测我们的目标亚马逊股票的高低列值方面做得相当好。因此，我们在这里结束了我们的整个目的。</p><h2 id="fadc" class="lv lw jj bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">结论</h2><p id="f3fb" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">在本文中，我们看到了如何基于复合神经网络构建算法交易模型。希望这篇文章能有所帮助。</p><p id="d356" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">整个 Github 代码是:<a class="ae jg" href="https://github.com/abr-98/Stock_prediction_hybrid_model" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="3ab7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请在这里找到关于这个主题的进一步任务:<a class="ae jg" href="https://medium.com/@myac.abhijit/stock-price-prediction-a-modified-approach-8d63ea6726a7" rel="noopener"/>。</p></div></div>    
</body>
</html>