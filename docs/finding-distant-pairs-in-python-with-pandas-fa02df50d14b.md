# 在 Python 中寻找大熊猫的远亲

> 原文：<https://towardsdatascience.com/finding-distant-pairs-in-python-with-pandas-fa02df50d14b?source=collection_archive---------44----------------------->

![](img/3f1e4d56aa158502d6828c1ff9ae43f4.png)

作者通过 [Flickr](https://www.flickr.com/photos/cmmorrow/13233889483/in/dateposted/) 拍摄的照片

计算机科学和数据科学中偶尔会遇到的一个问题是，需要在一组唯一的数字中找到一对彼此相距最远的数字。这些数字对被称为距离对，或最大距离对。

谢天谢地，有了 Python 和 Pandas，我们可以相对容易地在一组唯一值中找到距离较远的一对。让我们从导入 NumPy 和 Pandas 开始，它们将用于生成和操作我们的数据。

```
import numpy as np
import pandas as pd
```

接下来，我们将随机生成 7 个介于 100000 和 999999 之间的整数作为`one_dim`。

```
np.random.seed(123)
one_dim = np.random.randint(100000, 999999, size=7)
one_dim*array([873630, 377869, 128030, 117730, 292476, 294278, 770737])*
```

`np.random.seed(123)`语句保证随机数生成器将产生可再现的值。变量`one_dim`是一个 NumPy 数组，其中有 7 个随机整数，代表一组一维值，用于检查最大距离对。

使用以下步骤可以找到距离远的对:

1.  取集合与其自身的笛卡尔积，并对每一对应用距离算法。
2.  求笛卡尔积距离集中的最大值。
3.  确定原始集合中哪些对产生最大距离。

集合与其自身的笛卡儿积可以表示为熊猫数据帧，其中数据帧的索引和列标题是集合中的值。

```
df = pd.DataFrame(index=test, columns=test)
df+------+------+------+------+------+------+------+------+
|      |**873630**|**377869**|**128030**|**117730**|**292476**|**294278**|**770737**|
+------+------+------+------+------+------+------+------+
|**873630**| NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
|**377869**| NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
|**128030**| NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
|**117730**| NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
|**292476**| NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
|**294278**| NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
|**770737**| NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
+------+------+------+------+------+------+------+------+
```

这将创建一个 n x n 数据帧，其中 n 是集合中值的数量。因为这个数据帧是在没有数据的情况下创建的，所以所有的值都是空的(NaN)。

下一步是应用距离算法`abs(a - b)`，其中`a`和`b`都是原始集合中的值。将此算法应用于数据帧中的每个单元格相当于计算原始集合中每个值之间的距离。

我们通过使用 DataFrame 对象的`apply()`方法来实现这一点，其中的参数是一个可调用的函数。由于距离算法很简单，一个λ函数就足够了。使用`apply()`总是比使用嵌套的`for`循环更快，因为`apply()`是一个同时应用于一列或一行中每个值的矢量化操作。本质上，`apply()`是一个 O(n)时间操作，其中 n 与行数成比例，嵌套的`for`循环是一个 O(n)时间操作。

```
diff = df.apply(lambda col: abs(col.name - col.index))
diff+------+------+------+------+------+------+------+------+
|      |**873630**|**377869**|**128030**|**117730**|**292476**|**294278**|**770737**|
+------+------+------+------+------+------+------+------+
|**873630**|0     |495761|745600|755900|581154|579352|102893|
|**377869**|495761|0     |249839|260139|85393 |83591 |392868|
|**128030**|745600|249839|0     |10300 |164446|166248|642707|
|**117730**|755900|260139|10300 |0     |174746|176548|653007|
|**292476**|581154|85393 |164446|174746|0     |1802  |478261|
|**294278**|579352|83591 |166248|176548|1802  |0     |476459|
|**770737**|102893|392868|642707|653007|478261|476459|0     |
+------+------+------+------+------+------+------+------+
```

这做了什么？`apply()`方法对每一列执行 lambda 函数，并从列的索引(向量)中减去列的名称(标量值)。

这用原始组中每对之间的绝对值距离填充数据帧。注意对角线上的所有值都是 0，因为一个数减去它自己就是 0。这也表明数据帧被分成两部分，每一部分是另一部分的镜像三角形。这意味着最大距离在数据帧中出现两次，每个三角形一次。

下一步是找到最大距离。这是通过调用 DataFrame 的`max()`方法来完成的，首先在每一列上，然后在结果序列的每个值上。

```
max = diff.max().max()*755900*
```

现在我们知道了最大距离，最后一步是确定一维集合中的哪两对形成最大距离。因为数据帧的索引和列标题是一维集合中的值，所以数据帧可以被过滤为最大距离值。

因为最大距离值在数据帧中出现两次，所以过滤数据帧将产生 2 x 2 数据帧，其中索引和列标题中的值都是距离对。

```
filtered = (
    diff[diff == max]
    .dropna(how='all')
    .dropna(how='all', axis=1)
)
filtered+------+------+------+
|      |**873630**|**117730**|
+------+------+------+
|**873630**| NaN  |755900|
|**117730**|755900| NaN  |
+------+------+------+
```

最后，获取距离对就像获取过滤后的数据帧的索引一样简单。

```
pairs = filtered.index.to_list()
pairs*[873630, 117730]*
```

这很有效，是一个非常有效的解决方案，但是只适用于一维值的集合。如果我们想将这种方法应用于一组二维值呢？事实证明这并没有什么不同，只需要小小的改动。让我们从生成一组新的二维值开始。

```
two_dim = np.random.randint(100, size=(7, 2))
two_dim*array([[83, 57],
       [86, 97],
       [96, 47],
       [73, 32],
       [46, 96],
       [25, 83],
       [78, 36]])*
```

与一维情况相比，第一个不同之处在于数据帧索引必须是一维的。我们可以通过创建一个表示我们的二维值集的参考数据帧来解决这个问题，并在笛卡尔积中使用这个参考数据帧的索引。

```
ref = pd.DataFrame.from_records(two_dim, columns=('x', 'y'))
ref+----+----+----+
|    | **x**  | **y**  |
+----+----+----+
| **0**  | 83 | 57 |
| **1**  | 86 | 97 |
| **2**  | 96 | 47 |
| **3**  | 73 | 32 |
| **4**  | 46 | 96 |
| **5**  | 25 | 83 |
| **6**  | 78 | 36 |
+----+----+----+
```

接下来，我们将使用参考数据帧的索引创建笛卡尔乘积数据帧。

```
df2 = pd.DataFrame(index=ref.index, columns=ref.index)
df2+------+------+------+------+------+------+------+------+
|      |**0** |**1**     |**2** |**3** |**4** |**5**     |**6**     |
+------+------+------+------+------+------+------+------+
|**0** | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
|**1** | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
|**2** | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
|**3** | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
|**4** | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
|**5** | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
|**6** | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
+------+------+------+------+------+------+------+------+
```

与一维情况相比的第二个不同之处是，lambda 函数需要换成二维距离算法。这只是勾股定理。

```
diff2 = df2.apply(
    lambda col: np.sqrt(
        abs(ref.iloc[col.name]['x'] - ref.iloc[col.index]['x']) ** 2 +
        abs(ref.iloc[col.name]['y'] - ref.iloc[col.index]['y']) ** 2
    )
)
diff2+------+------+------+------+------+------+------+------+
|      |**0** |**1**     |**2** |**3** |**4** |**5**     |**6**     |
+------+------+------+------+------+------+------+------+
|**0** |0.0000|40.112|16.401|26.926|53.759|63.561|21.587|
|**1** |40.112|0.0000|50.990|66.287|40.012|62.586|61.522|
|**2** |16.401|50.990|0.0000|27.459|70.007|79.605|21.095|
|**3** |26.926|66.287|27.459|0.0000|69.462|70.036|6.4031|
|**4** |53.759|40.012|70.007|69.462|0.0000|24.698|68.000|
|**5** |63.561|62.586|79.605|70.036|24.698|0.0000|70.838|
|**6** |21.587|61.522|21.095|6.4031|68.000|70.838|0.0000|
+------+------+------+------+------+------+------+------+
```

这需要一些解释。这里的 lambda 函数就是勾股定理:c = √(abs(a) + abs(b))，但是参考数据帧中的 x 和 y 值是通过它们的索引值——`ref.iloc[col.name]['x']`(标量值)和`ref.iloc[col.index]['x']`(向量)取的。

接下来，我们将得到最大值，和以前一样。

```
max = diff2.max().max()
max*79.605*
```

获得距离对的工作方式相同，但是笛卡尔乘积数据帧的索引值需要换成参考数据帧中相应的 x 和 y 值。

```
filtered2 = (
    diff2[diff2 == max]
    .dropna(how='all')
    .dropna(how='all', axis=1)
)
filtered2+------+------+------+
|      |**2**     |**5**     |
+------+------+------+
|**2**     | NaN  |79.605|
|**5**     |79.605| NaN  |
+------+------+------+
```

最后，得到距离较远的一对。

```
pairs = [ref.iloc[idx].to_list() for idx in filtered2.index]
pairs*[[96, 47], [25, 83]]*
```

就是这样！