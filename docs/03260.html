<html>
<head>
<title>Create a Supervised Model in 30 Hours Or Less</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在30小时或更短时间内创建一个监督模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-a-supervised-model-in-30-hours-or-less-a0eb0ace0900?source=collection_archive---------24-----------------------#2020-03-28">https://towardsdatascience.com/create-a-supervised-model-in-30-hours-or-less-a0eb0ace0900?source=collection_archive---------24-----------------------#2020-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8bcf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建机器学习模型的8个步骤</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3f6f335a7eb927e1c2bbde005cb19fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6jMZ31ZNi5EVAYm_C7HSw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@agkdesign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚历山大·奈特</a>在<a class="ae kv" href="https://unsplash.com/s/photos/friendly-robot?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h2 id="7121" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">TL；速度三角形定位法(dead reckoning)</h2><ol class=""><li id="ebbf" class="ls lt iq lu b lv lw lx ly lf lz lj ma ln mb mc md me mf mg bi translated">加载用于进行预测的数据</li><li id="b030" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc md me mf mg bi translated">调查数据</li><li id="5675" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc md me mf mg bi translated">选择模型的功能</li><li id="96fe" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc md me mf mg bi translated">将数据拆分到<em class="mm">训练</em>和<em class="mm">验证</em>集合</li><li id="8c08" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc md me mf mg bi translated">预处理数据</li><li id="df43" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc md me mf mg bi translated">训练模型</li><li id="159e" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc md me mf mg bi translated">使用验证集测试模型</li><li id="fcd2" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc md me mf mg bi translated">重复步骤2到7，直到您对模型的准确性感到满意</li></ol></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="8d5a" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">这个帖子是在以色列最大的高级女性工程师和计算机科学家社区<a class="ae kv" href="https://extend-tech.com/baot" rel="noopener ugc nofollow" target="_blank"><strong class="lu ir"/></a>的<strong class="lu ir"> #30_hours </strong>计划期间创建的。在30小时计划中，参与者投资30小时(超过4个月)在一个新的领域加深他们的知识，通过与专业导师一起建立一个个人或小组项目。</p><h1 id="0f72" class="nj kx iq bd ky nk nl nm lb nn no np le jw nq jx li jz nr ka lm kc ns kd lq nt bi translated">加载数据</h1><p id="5cec" class="pw-post-body-paragraph mu mv iq lu b lv lw jr mx lx ly ju mz lf nu nb nc lj nv ne nf ln nw nh ni mc ij bi translated">在现实世界的场景中，您可能需要从收集数据开始。我们将跳过这一步，在本文中使用<a class="ae kv" href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/overview" rel="noopener ugc nofollow" target="_blank"> Kaggle房价数据集</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/432a64ea82c0f9961e438671453ee7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dV9Q5bjuF_RAvSisQ27m3g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">房屋数据的部分数据框架</p></figure><p id="850e" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">在这个数据集中，我们既有房子的数据——比如房子的状态、位置和出售时间的数据——也有房子的售价。</p><p id="167f" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">我们可以使用<a class="ae kv" href="https://ml-cheatsheet.readthedocs.io/en/latest/glossary.html#glossary-supervised-learning" rel="noopener ugc nofollow" target="_blank">监督学习</a>训练一个模型，将给定的输入(称为<a class="ae kv" href="https://ml-cheatsheet.readthedocs.io/en/latest/glossary.html#glossary-feature" rel="noopener ugc nofollow" target="_blank">特征</a>，如房屋状况和位置)映射到给定的输出(称为<a class="ae kv" href="https://ml-cheatsheet.readthedocs.io/en/latest/glossary.html#glossary-label" rel="noopener ugc nofollow" target="_blank">标签</a>，如销售价格)。</p><p id="3ec0" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">首先，让我们使用pandas来读取csv文件。标签由<code class="fe ny nz oa ob b">y</code>表示:</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="e432" class="kw kx iq ob b gy og oh l oi oj">import pandas as pd</span><span id="5a84" class="kw kx iq ob b gy ok oh l oi oj">houses_df = pd.read_csv(PATH_TO_TRAIN_DATA)<br/>LABEL = 'SalePrice'  # let's make this a constant for future usage<br/>y = houses_df[LABEL]</span></pre><p id="162f" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">接下来，我们将了解哪些特征可以帮助我们预测房屋的价格。</p><h1 id="d335" class="nj kx iq bd ky nk nl nm lb nn no np le jw nq jx li jz nr ka lm kc ns kd lq nt bi translated">调查数据</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol om l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">那需要一段时间！</p></figure><p id="01f1" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">在选择特性之前，我们需要了解我们的数据是什么样的。让我们从数据列开始:</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="76dc" class="kw kx iq ob b gy og oh l oi oj">print(houses_df.columns)</span><span id="ec85" class="kw kx iq ob b gy ok oh l oi oj">"""<br/>Output:<br/>Index(['Id', 'MSSubClass', 'MSZoning', 'LotFrontage', 'LotArea', 'Street', …, 'YrSold', 'SaleType', 'SaleCondition', 'SalePrice'], <br/> dtype='object')<br/>"""</span></pre><p id="076e" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">我们有80列可以帮助我们预测销售价格。让我们仔细看看每一列。我们将使用两种方法来调查我们的数据:</p><ul class=""><li id="279f" class="ls lt iq lu b lv mw lx my lf on lj oo ln op mc oq me mf mg bi translated"><a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.value_counts.html" rel="noopener ugc nofollow" target="_blank"> value counts() </a>获取唯一值的计数(包括<code class="fe ny nz oa ob b">NA</code>值，因为我们想知道我们的列包含多少个空值)</li><li id="caed" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc oq me mf mg bi translated"><a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.describe.html" rel="noopener ugc nofollow" target="_blank"> describe() </a>根据数据类型生成描述性统计</li></ul><p id="9215" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">在下面的示例中，我们可以看到“Street”有两个唯一的值，并且几乎都是“Pave”。我们还可以看到大多数“小巷”值都不见了。由于这些数据列没有变化，我们无法了解不同街道或小巷的价格差异。</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="899e" class="kw kx iq ob b gy og oh l oi oj">for col in houses_df.columns:<br/>  print(f'_____Column: {col}_____')<br/>  # normalize=True - use relative frequencies of the unique values<br/>  # dropna=False - include NA values<br/>  print(houses_df[col].value_counts(normalize=True, dropna=False))<br/>  print(houses_df[col].describe())</span><span id="df21" class="kw kx iq ob b gy ok oh l oi oj">"""<br/>Output:<br/>_____Column: Street_____<br/># value_counts:<br/>Pave    <strong class="ob ir">0.99589</strong><br/>Grvl    0.00411<br/>Name: Street, dtype: float64</span><span id="fbbf" class="kw kx iq ob b gy ok oh l oi oj"># describe:<br/>count     1460<br/>unique       2<br/>top       Pave<br/>freq      1454<br/>Name: Street, dtype: object</span><span id="7974" class="kw kx iq ob b gy ok oh l oi oj">_____Column: Alley_____<br/># value_counts:<br/><strong class="ob ir">NaN</strong>     0.937671<br/>Grvl    0.034247<br/>Pave    0.028082<br/>Name: Alley, dtype: float64</span><span id="2602" class="kw kx iq ob b gy ok oh l oi oj"># describe:<br/>count       91<br/>unique       2<br/>top       Grvl<br/>freq        50<br/>Name: Alley, dtype: object<br/>"""</span></pre><p id="379f" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">为了简化调查数据的过程，您可以使用Kaggle 上为该数据集提供的<a class="ae kv" href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data" rel="noopener ugc nofollow" target="_blank">可视化来获得每个数据列的更多信息。你也可以在这里</a>看看我的代码示例<a class="ae kv" href="https://github.com/MirYeh/learning-process/blob/master/ml/supervised%20learning/house_prices/data_investigation.py#LC18" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/afc288a3b5d30eabf96067d6564cd367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wTZAJgBuq9DIodJsVnzDQA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">点击数据选项卡，向下滚动并选择train.csv查看可视化|来源:Kaggle</p></figure><h1 id="c9c0" class="nj kx iq bd ky nk nl nm lb nn no np le jw nq jx li jz nr ka lm kc ns kd lq nt bi translated">选择模型的特征</h1><p id="28e9" class="pw-post-body-paragraph mu mv iq lu b lv lw jr mx lx ly ju mz lf nu nb nc lj nv ne nf ln nw nh ni mc ij bi translated">我们希望只选择有助于预测房屋价格的特征，以便<strong class="lu ir">降低计算成本并提高模型的性能</strong>—这个过程称为<a class="ae kv" href="https://ml-cheatsheet.readthedocs.io/en/latest/glossary.html#glossary-feature-selection" rel="noopener ugc nofollow" target="_blank">特征选择</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os om l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">选择，选择..！</p></figure><p id="8748" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">对于这个例子，我们将简化这个过程，但是你可以阅读更多关于<a class="ae kv" rel="noopener" target="_blank" href="/feature-selection-identifying-the-best-input-features-2ba9c95b5cab">特征选择和如何识别相关特征</a>的内容。</p><p id="b518" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">下面是一个简化的特征选择示例。特征由<code class="fe ny nz oa ob b">X</code>表示:</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="3056" class="kw kx iq ob b gy og oh l oi oj">include_features = ['MSSubClass', 'MSZoning', 'LotFrontage', ..., 'MoSold', 'YrSold']<br/>X = houses_df[include_features]</span></pre><h1 id="f046" class="nj kx iq bd ky nk nl nm lb nn no np le jw nq jx li jz nr ka lm kc ns kd lq nt bi translated">拆分数据</h1><p id="144d" class="pw-post-body-paragraph mu mv iq lu b lv lw jr mx lx ly ju mz lf nu nb nc lj nv ne nf ln nw nh ni mc ij bi translated">模型的工作是<strong class="lu ir">在数据</strong>中寻找模式，以便预测标签——模式来自模型训练的数据。为了对模型的准确性进行公正的评估，我们需要根据它没有训练过的数据来验证它。</p><p id="c67b" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">为此，我们将数据分成(至少)3个部分:</p><ul class=""><li id="6b56" class="ls lt iq lu b lv mw lx my lf on lj oo ln op mc oq me mf mg bi translated">训练集-用于训练模型的数据</li><li id="50ee" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc oq me mf mg bi translated">验证集—在调整模型的<a class="ae kv" href="https://ml-cheatsheet.readthedocs.io/en/latest/glossary.html#glossary-hyperparameters" rel="noopener ugc nofollow" target="_blank">超参数</a>(模型的属性)并选择性能良好的模型时用于评估模型的数据—该集仅用于调整模型的超参数，其数据不应用于训练模型！</li><li id="206c" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc oq me mf mg bi translated">测试集——用于评估最终模型的数据——它在模型训练期间对模型没有影响，因此是无偏的</li></ul><p id="0765" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">因为我们使用的是Kaggle竞争数据集，所以我们已经在一个不同的文件(test.csv)下提供了一个测试集。我们只需要将训练集分成训练和验证。<br/>我们使用<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank"> train_test_split </a>将数据分成两部分。<br/>稍后，我们将看到验证集如何帮助我们调整模型。</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="b1d3" class="kw kx iq ob b gy og oh l oi oj">from sklearn.model_selection import train_test_split</span><span id="ef40" class="kw kx iq ob b gy ok oh l oi oj">X_train, X_valid, y_train, y_valid = train_test_split(X, y, train_size=0.8, test_size=0.2, random_state=1)</span></pre><p id="0d8d" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated"><strong class="lu ir"> random_state </strong>值被设置为某个常数，以避免训练模型时的随机性。</p><h1 id="69dd" class="nj kx iq bd ky nk nl nm lb nn no np le jw nq jx li jz nr ka lm kc ns kd lq nt bi translated">预处理数据</h1><p id="b556" class="pw-post-body-paragraph mu mv iq lu b lv lw jr mx lx ly ju mz lf nu nb nc lj nv ne nf ln nw nh ni mc ij bi translated">我们使用Python中的机器学习库<a class="ae kv" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>来创建模型。Scikit-learn(或sklearn)期望数据是<strong class="lu ir">数字的和有意义的</strong>。真实世界的数据可能有缺失值，或者可能包含非数字值(分类值、图像等)，因此与scikit-learn不兼容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ot om l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对对对。</p></figure><p id="ebc0" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">在我们可以训练模型之前，我们需要准备数据，以便我们可以将它馈送给scikit-learn。这一步叫做——你猜对了——预处理！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/798f33c2932aaf4b400a36b8a7628e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*-6td5qnvcgNcvpe4FBBKnQ.gif"/></div></figure><h2 id="cd1f" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">我们如何处理丢失的值？</h2><ul class=""><li id="0b8a" class="ls lt iq lu b lv lw lx ly lf lz lj ma ln mb mc oq me mf mg bi translated">最简单的方法是删除缺少数据的要素/条目。这会导致可能对更准确的预测有价值的数据丢失，因此不建议这样做</li><li id="541e" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc oq me mf mg bi translated"><strong class="lu ir">输入现有数据中的缺失值</strong>，例如，输入特征的平均值。分类特征没有“平均值”——我们可以使用“最频繁”策略来填充缺失值(我们使用的是<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html" rel="noopener ugc nofollow" target="_blank"> SimpleImputer </a>):</li></ul><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="e02e" class="kw kx iq ob b gy og oh l oi oj">from sklearn.impute import SimpleImputer</span><span id="8c0f" class="kw kx iq ob b gy ok oh l oi oj"># allowed_strategies = ["mean", "median", "most_frequent", "constant"]<br/>numerical_imputer = SimpleImputer(strategy='mean')<br/>categorical_imputer = SimpleImputer(strategy='most_frequent')</span></pre><h2 id="25c1" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">我们如何处理分类数据？</h2><p id="ac01" class="pw-post-body-paragraph mu mv iq lu b lv lw jr mx lx ly ju mz lf nu nb nc lj nv ne nf ln nw nh ni mc ij bi translated">我们希望<strong class="lu ir">将分类数据编码成数字数据</strong>。我们可以使用不同的编码器。例如，我们可以使用带有<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html" rel="noopener ugc nofollow" target="_blank">标签编码</a>的类别排序。如果类别没有排序，我们可以使用<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank">一键编码</a>，它为每个类别创建一个新的特性，并用布尔值填充它。阅读更多关于<a class="ae kv" rel="noopener" target="_blank" href="/the-complete-beginners-guide-to-data-cleaning-and-preprocessing-2070b7d4c6d">清洁和预处理数据</a>的信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/a9d3448a506c278037f04bdb940bea3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w5eTU2MpWx8B_Fj8Cqej2g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">标签编码(左)和一键编码(右)|来源:Kaggle</p></figure><p id="9cd3" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">为分类值创建一个编码器—在本例中，我们将使用OneHotEncoder，但选择可以而且应该根据您的数据而有所不同:</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="6084" class="kw kx iq ob b gy og oh l oi oj">from sklearn.preprocessing import OneHotEncoder</span><span id="df12" class="kw kx iq ob b gy ok oh l oi oj">one_hot_encoder = OneHotEncoder(handle_unknown='ignore')</span></pre><p id="973b" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">您可以更进一步，<a class="ae kv" href="https://medium.com/analytics-vidhya/feature-preprocessing-for-numerical-data-the-most-important-step-e9ed76151298" rel="noopener">预处理数字数据</a>来创建<strong class="lu ir">一个更加精确的模型！</strong></p><h1 id="1197" class="nj kx iq bd ky nk nl nm lb nn no np le jw nq jx li jz nr ka lm kc ns kd lq nt bi translated">拟合模型</h1><p id="4832" class="pw-post-body-paragraph mu mv iq lu b lv lw jr mx lx ly ju mz lf nu nb nc lj nv ne nf ln nw nh ni mc ij bi translated">差不多到了适合模型的时候了！</p><p id="00a9" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">我们看到了如何估算缺失值和编码分类值。让我们在一个<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank">管道</a>中定义这些步骤，使我们的代码更干净，更容易调试。</p><p id="fbd3" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">我们为数据中的每个列类型定义了一个管道，在我们的例子中，我们需要处理数字和分类数据:</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="ed3a" class="kw kx iq ob b gy og oh l oi oj">from sklearn.pipeline import Pipeline<br/><br/># impute and scale<br/>numerical_transformer = Pipeline(steps=[<br/>  ('imputer', numerical_imputer),<br/>  ('scaler', StandardScaler())<br/>])</span><span id="6bcc" class="kw kx iq ob b gy ok oh l oi oj"># impute and encode<br/>categorical_transformer = Pipeline(steps=[<br/>  ('imputer', categorical_imputer),<br/>  ('onehot', one_hot_encoder)<br/>])</span></pre><p id="d497" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">很好，我们现在为每种列类型都提供了一个管道。让我们为数据列捆绑这些预处理步骤:</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="e489" class="kw kx iq ob b gy og oh l oi oj">from sklearn.compose import ColumnTransformer</span><span id="86f4" class="kw kx iq ob b gy ok oh l oi oj"># get columns from X_train<br/>numerical_cols = get_numerical_columns(X_train)<br/>categorical_cols = get_categorical_columns(X_train)</span><span id="a4dc" class="kw kx iq ob b gy ok oh l oi oj">preprocessor = ColumnTransformer(<br/>  transformers=[<br/>    ('num', numerical_transformer, numerical_cols),<br/>    ('cat', categorical_transformer, categorical_cols),<br/>])</span></pre><p id="3935" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">注意，在这个例子中，我们通过数字/分类数据捆绑了预处理步骤——实际上，您可能希望使用与数据列最匹配的步骤。在研究数据时，您应该看到<strong class="lu ir">哪些预处理步骤最适合不同的列</strong>，而不是使用“一刀切”的方法。</p><p id="3e78" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">现在我们已经为训练集定义了预处理，我们可以用它来训练我们的模型了！</p><h2 id="95a8" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">但是等等…</h2><p id="178a" class="pw-post-body-paragraph mu mv iq lu b lv lw jr mx lx ly ju mz lf nu nb nc lj nv ne nf ln nw nh ni mc ij bi translated">您可能会问自己——我们不应该预处理所有的数据，而不仅仅是训练集吗？</p><p id="d58d" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">答案肯定是否定的！如果我们基于所有数据进行预处理，我们将深入了解我们正在验证的数据，从而导致<strong class="lu ir">假阳性评估！</strong>包括来自列车组外部的信息被称为<a class="ae kv" href="https://machinelearningmastery.com/data-leakage-machine-learning/" rel="noopener ugc nofollow" target="_blank">数据泄漏</a>。</p><p id="5c21" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">现在让我们使用管道来拟合模型！</p><p id="3113" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">受监督的模型可以是<a class="ae kv" href="https://ml-cheatsheet.readthedocs.io/en/latest/glossary.html#glossary-classification" rel="noopener ugc nofollow" target="_blank">分类</a>模型，它输出一个离散的结果，如预测一封电子邮件是否是垃圾邮件，也可以是<a class="ae kv" href="https://ml-cheatsheet.readthedocs.io/en/latest/glossary.html#glossary-regression" rel="noopener ugc nofollow" target="_blank">回归</a>模型，它输出一个连续的结果，如预测房价。阅读更多关于<a class="ae kv" rel="noopener" target="_blank" href="/all-machine-learning-models-explained-in-6-minutes-9fe30ff6776a">常见ML型号</a>的信息。</p><p id="54c0" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">我们将使用<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html" rel="noopener ugc nofollow" target="_blank">随机森林回归模型</a>——决策树的集合。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/9266e2cb0af102fca1c3b5e7ed02d1ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kM-GxdmJWi2cAazL.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">决策树示例|来源:Kaggle</p></figure><p id="adb9" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">定义预处理和拟合随机森林回归模型的管道:</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="1097" class="kw kx iq ob b gy og oh l oi oj">from sklearn.ensemble import RandomForestRegressor</span><span id="9099" class="kw kx iq ob b gy ok oh l oi oj">model = RandomForestRegressor(n_estimators=ESTIMATORS_VALUE, random_state=1)</span><span id="bacd" class="kw kx iq ob b gy ok oh l oi oj">pipeline = Pipeline(steps=[<br/>  ('preprocessor', preprocessor),<br/>  ('model', model)<br/>])</span></pre><h2 id="3570" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">还记得验证集吗？</h2><p id="39c6" class="pw-post-body-paragraph mu mv iq lu b lv lw jr mx lx ly ju mz lf nu nb nc lj nv ne nf ln nw nh ni mc ij bi translated">这是我们最终使用验证集的地方。<br/> <code class="fe ny nz oa ob b">n_estimators</code> <strong class="lu ir"> </strong>是RandomForestRegressor模型的数值型<strong class="lu ir">超参数</strong>。我们可以使用不同的<code class="fe ny nz oa ob b">n_estimators</code>值根据验证集创建和评估我们的模型，最终选择最接近验证数据上实际标签的预测值——这样做会导致我们的模型被验证集调整，这就是为什么我们需要一个测试集，<strong class="lu ir">一个模型没有见过或已经被</strong>调整过的数据集。<code class="fe ny nz oa ob b">n_estimators</code>也用于控制示例模型中的<a class="ae kv" href="https://machinelearningmastery.com/overfitting-and-underfitting-with-machine-learning-algorithms/" rel="noopener ugc nofollow" target="_blank">欠拟合和过拟合</a>。</p><p id="1ada" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">现在，我们可以使用之前定义的所有步骤，使用该管道来拟合我们的模型:</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="009e" class="kw kx iq ob b gy og oh l oi oj">pipeline.fit(X_train, y_train)</span></pre><p id="67c9" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">啊啊啊……我们终于有一个合身的模型了！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox om l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">啊哈。</p></figure><h1 id="04da" class="nj kx iq bd ky nk nl nm lb nn no np le jw nq jx li jz nr ka lm kc ns kd lq nt bi translated">测试模型</h1><p id="abcd" class="pw-post-body-paragraph mu mv iq lu b lv lw jr mx lx ly ju mz lf nu nb nc lj nv ne nf ln nw nh ni mc ij bi translated">模型能在没见过的数据上成功预测房价吗？让我们使用<a class="ae kv" href="https://deepai.org/machine-learning-glossary-and-terms/loss-function" rel="noopener ugc nofollow" target="_blank">损失函数</a>来测试这个模型——这个函数可以帮助我们计算原始标签和预测标签之间差异的“成本”，从而帮助我们估计这个模型有多精确。</p><p id="fd05" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">我们可以使用的一个<a class="ae kv" rel="noopener" target="_blank" href="/common-loss-functions-in-machine-learning-46af0ffc4d23">常见损失函数</a>是<strong class="lu ir"> MAE </strong> ( <a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_absolute_error.html" rel="noopener ugc nofollow" target="_blank">平均绝对误差</a>)，它计算原始标签和预测标签之间的绝对差异——较低的MAE分数意味着对验证数据的预测更好。</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="2659" class="kw kx iq ob b gy og oh l oi oj">from sklearn.metrics import mean_absolute_error</span><span id="dbd4" class="kw kx iq ob b gy ok oh l oi oj">predictions = pipeline.predict(X_valid)<br/>mae_score = mean_absolute_error(y_valid, predictions)</span></pre><p id="6fd6" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">你可以玩不同的超参数值，特征，模型和预处理步骤，看看模型的分数如何变化。</p><h1 id="f1b0" class="nj kx iq bd ky nk nl nm lb nn no np le jw nq jx li jz nr ka lm kc ns kd lq nt bi translated">下一步是什么？</h1><p id="f252" class="pw-post-body-paragraph mu mv iq lu b lv lw jr mx lx ly ju mz lf nu nb nc lj nv ne nf ln nw nh ni mc ij bi translated">现在你已经有了一个满意的模型，你可以将预测保存到一个. csv文件，上传到Kaggle，然后<strong class="lu ir">继续下一个挑战！</strong></p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="b1f4" class="kw kx iq ob b gy og oh l oi oj">output = pd.DataFrame({'Id': house_df.Id, label: LABEL})<br/>default_filename = f'submission-{mae_score}'<br/>output.to_csv(f'{filename}.csv', index=False)</span></pre><p id="b841" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">你可以在这篇文章的末尾找到完整代码的链接。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy om l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">你做到了！</p></figure><h1 id="56ac" class="nj kx iq bd ky nk nl nm lb nn no np le jw nq jx li jz nr ka lm kc ns kd lq nt bi translated">总结我们所学的内容</h1><ul class=""><li id="5bc4" class="ls lt iq lu b lv lw lx ly lf lz lj ma ln mb mc oq me mf mg bi translated">基本术语(参见<a class="ae kv" href="https://ml-cheatsheet.readthedocs.io/en/latest/glossary.html" rel="noopener ugc nofollow" target="_blank">备忘单</a>)</li><li id="3738" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc oq me mf mg bi translated">如何用熊猫调查数据(见<a class="ae kv" href="https://www.dataschool.io/python-pandas-tips-and-tricks/amp/" rel="noopener ugc nofollow" target="_blank"> 100个熊猫小窍门</a></li><li id="4bb3" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc oq me mf mg bi translated">为什么我们需要至少3组数据</li><li id="9fa8" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc oq me mf mg bi translated">如何用skicit-learn对数据进行预处理</li><li id="7c1b" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc oq me mf mg bi translated"><em class="mm">分类模型</em>与<em class="mm">回归模型</em>有何不同</li><li id="6e37" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc oq me mf mg bi translated">如何使用skicit-learn创建<em class="mm">管道</em></li><li id="7d14" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc oq me mf mg bi translated">什么是<em class="mm">平均绝对误差</em>以及我们如何使用它来测试模型</li></ul><p id="8e90" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">如果这篇博文对你有帮助，请随意与你的朋友分享！</p><p id="7698" class="pw-post-body-paragraph mu mv iq lu b lv mw jr mx lx my ju mz lf na nb nc lj nd ne nf ln ng nh ni mc ij bi translated">完整代码见<a class="ae kv" href="https://github.com/MirYeh/learning-process/tree/master/ml/supervised%20learning/house_prices" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div></div>    
</body>
</html>