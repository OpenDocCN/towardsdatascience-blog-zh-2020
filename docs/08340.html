<html>
<head>
<title>Market-basket analysis and prediction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">市场篮子分析和预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/market-basket-analysis-using-associative-data-mining-and-apriori-algorithm-bddd07c6a71a?source=collection_archive---------7-----------------------#2020-06-18">https://towardsdatascience.com/market-basket-analysis-using-associative-data-mining-and-apriori-algorithm-bddd07c6a71a?source=collection_archive---------7-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3b3d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用关联数据挖掘和Apriori算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f6f315768676b0b52e9671b84645a353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mGnNS_Jp0BuIn6a3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">布鲁克·卡吉尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="6ae6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">简介</strong></h1><p id="5c5b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最近，我们都越来越多地从在线电子商务网站购物，这可能是因为世界上大多数地方都实行了封锁。你一定注意到了一个名为'<strong class="lt iu"> <em class="mn">的追加销售功能，在大多数网站上经常一起购买</em> </strong>'，例如亚马逊，它会预测所有商品的价格，以及你刚刚添加到购物车中的商品。客户可以选择将该功能下显示的所有商品添加到购物车中，或者选择所需的商品。亚马逊通过他们所谓的“商品对商品的协同过滤”来实现这一点，它根据顾客的商品搜索历史来运行推荐算法，以改善购物体验。对于线下零售商来说，情况也差不多。让我们考虑面包和果酱的基本例子。如果零售商发现面包的销量有所增加，他可以通过在果酱价格上打折来进一步向上销售，这样一来，更多的顾客势必会一起购买。</p><p id="7532" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这个分析顾客购物趋势的全过程被称为“<strong class="lt iu"> <em class="mn">购物篮分析</em> </strong>”。这是一种分析技术，基于这样一种想法，如果我们购买一件商品，那么我们必然会购买或不购买一组(或单个)商品。例如，如果顾客正在购买面包，那么他/她购买果酱的机会就更大。这由以下等式表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/acc8a33797babe5f7cc646b28add2dd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*5nCVwZ2SwDzkRomEJbk3Dw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">关联挖掘规则</p></figure><p id="f56b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这个等式被称为关联挖掘规则。这可以被认为是一种如果-那么的关系。如果商品A被一个顾客购买，那么商品B在同一交易中被同一用户购买的机会被发现。这里A称为前因，B称为后果。先行项是在购物篮中找到的主要项目，而结果项是与先行项/一组先行项一起找到的项目。衡量关联性的指标包括:</p><p id="1aaa" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">支持:</strong>告诉我们经常一起买的物品组合。它给出了包含A和b的交易部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/683fbe569d9be32e10f48794289f87fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*bLMnQexTSm-uPGB1Xo7RZA.png"/></div></figure><p id="ee77" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们可以使用支持过滤掉不经常出现的项目集。</p><p id="3f60" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">置信度:它告诉我们A和B一起被购买的频率，因为A被购买的次数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/d1bb37db3e81f97f241444ab7e88677f.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*Vum4PHvhzDYKgZJkJHP5Jg.png"/></div></figure><p id="8563" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> Lift: </strong>表示一个规则对A和B一起被买的随机性的强度。它基本上衡量了任何关联规则的强弱(下面我们会讲到关联规则)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/90cf07f6d6812635567dad1ca05bd393.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*ilIJ4PAdTGQ7P4u_rVY78A.png"/></div></figure><p id="b0e9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">升力越大，规则的力量就越大。如果A -&gt; B的升力是3，那么这意味着如果我们买A，买B的机会是3倍。</p><p id="9560" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">因此，这个过程是为每个项目集制定规则，以找出其关联的度量标准，从而决定是否将它包括在分析中。但是考虑具有数百万用户和事务大型数据集，从而产生大量的项目集。因此，为所有这些制定规则将是一项艰巨的任务。这就是Apriori算法的用武之地。</p><p id="ae99" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> Apriori算法</strong>使用频繁购买的项目集生成关联规则。它建立在频繁购买项目集的子集也是频繁购买项目集的思想上。如果频繁购买的项目集的支持值高于最小阈值支持值，则判定频繁购买的项目集。</p><p id="0edf" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">为了演示该算法的工作原理，考虑以下事务:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/27e92b35a948cadd7a1124eb9aa22f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*vGOoN7qYUe7pOk8nuS-Nqw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">交易详细信息</p></figure><p id="0c26" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">总共有5种商品A、B、C、D和E，在每笔交易中以不同的组合一起购买。让我们将项目集的最小阈值支持值固定为2。</p><p id="94bd" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">迭代1: </strong>形成具有1个项目的项目集，并计算它们的支持度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/0cafb13320e88d76b3a1d7cf4fb47bcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*G4h7fXaTn4hygqXb_KoWyw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迭代1</p></figure><p id="c3d6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">从每个项目集的支持度值可以看出，D的支持度为1，小于阈值。因此，我们将忽略该项目集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/9712a5dddbdf77fbd804e8f55ce61f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*KHGdkF4c-jaukxpkB3eZcw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迭代1最终版</p></figure><p id="df43" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">迭代-2: </strong>接下来，我们创建所有可能的包含2个项目的项目集。表F1中的所有项目都用于此。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/7d0697b0a1c073b1f73ea3ab3d47fbc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WrOFZv9mFjwDXZrBKlNQeA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迭代2</p></figure><p id="bf1d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在此迭代中，支持度小于2的项目集再次被忽略，{A，B}。</p><p id="930a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">迭代-3: </strong>列出了所有包含3个项目的可能项目集。然后，我们将把这些项目集分成它们的子集，并省略那些支持值小于阈值(即2)的项目集。这个过程叫做<strong class="lt iu">修剪</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/fb0fbe2e70bdb0a7c54f1aad10785b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*He-7HIS4MRQT8Wv-Tp1aag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迭代3和修剪</p></figure><p id="8f84" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们将省略{A，B，C}和{A，B，E},因为它们都包含迭代2中省略的{A，B}。这个剪枝部分是Apriori算法的关键部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/c42b4d58f3bf06e2c0e530ace1eefd91.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*DBjxQ1ny3-k3nQFTzCKsTA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迭代3最终版</p></figure><p id="ef16" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">迭代-4 </strong>:使用F3，我们将创建包含4个项目的项目集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8d2fbceb17f525ebc413e0c7f6239732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*OeNes_ORmSJu91thApJ-4A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迭代4</p></figure><p id="bec0" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们可以看到，只有4个项目的项目集的支持度小于2。所以我们在这里停止迭代，最终的项目集是F3。</p><p id="77c8" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">如果I={A，C，E}那么子集是{A，C}，{A，E}，{C，E}，{A}，{C}，{E}。</p><p id="928f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">如果I={B，C，E}，则子集为{B，C}，{B，E}，{C，E}，{B}，{C}，{E}。</p><p id="4d9c" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">规则</strong>:为了过滤掉相关的项目集，我们将创建某些规则，并将其应用于子集。假设最小置信度值为60%。</p><p id="b508" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">对于I的每个子集S，我们制定规则</p><p id="e9f0" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> S →(I-S) </strong>(表示如果S那么I减去S)如果</p><p id="b5d2" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">支持度(I)/支持度(S) ≥最小置信值</strong>即60%。</p><p id="1763" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">考虑{A，C，E}</p><p id="a662" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">规则1 </strong> : {A，C} →({A，C，E}- {A，C})也就是{A，C} → {E}</p><p id="6c99" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">信心=支持{A，C，E }/支持{A，C} = 2/3 = 66.6% &gt; 60%</p><p id="9d59" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">所以选择了规则1，即{A，C} → {E}。</p><p id="f6e5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">规则二</strong> : {A，E} →({A，C，E}- {A，E})也就是{A，E} → {C}</p><p id="9047" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">信心=支持{A，C，E }/支持{A，E} = 2/2 = 100% &gt; 60%</p><p id="b0d5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">所以选择了规则2，即{A，E} → {C}。</p><p id="cd84" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">规则三</strong> : {C，E} →({A，C，E}- {C，E})哪个是{C，E} → {A}</p><p id="b276" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">信心=支持{A，C，E }/支持{C，E} = 2/3 = 66.6% &gt; 60%</p><p id="96e9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">所以选择了规则3，即{C，E} → {A}。</p><p id="0ab5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">规则4 </strong> : {A} →({A，C，E}- {A})也就是{A} → {C，E}</p><p id="dfd7" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">信心=支持{A，C，E }/支持{A} = 2/3 = 66.6% &gt; 60%</p><p id="ce81" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">所以选择了规则4，即{A} → {C，E}。</p><p id="1fbc" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">规则5 </strong> : {C} →({A，C，E}- {C})也就是{C} → {A，E}</p><p id="ccb3" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">置信度=支持{A，C，E }/支持{C} = 2/4 = 50% &lt; 60%</p><p id="7423" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">So rule 5 i.e., {C} → {A,E} is rejected.</p><p id="f613" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">规则6 </strong> : {E} →({A，C，E}- {E})即{E} → {A，C}</p><p id="d8f7" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">信心=支持{A，C，E }/支持{E} = 2/4 = 50% &lt; 60%</p><p id="98a8" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">So rule 6 i.e., {E} → {A,C} is rejected.</p><p id="08e0" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">Same steps can be done to {B,C,E}. Lift is not being used as the size of the input data-set is small and there is no need of further filtering. But in the case of larger data set further filtering is done by imposing a minimum lift value for the rules. The values of all three of the association metrics can be tweaked as per requirement.</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="fe5a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">Lets consider an actual data-set and see how the analysis is done.</p><p id="c906" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">The link to the data-set being used is given below</p><div class="nl nm gp gr nn no"><a href="https://drive.google.com/file/d/1vE3xyM-hbZMB5RS8c3H13Ll1PnFXJ7Ui/view?usp=sharing" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">transaction_data.csv</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Edit description</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">drive.google.com</p></div></div></div></a></div><p id="d830" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">We are going to sue python and pandas. We are also going to use Mlxtend lib as it contains inbuilt functions for Apriori algorithm and Associaction rules.</p><p id="30b4" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">Load the necessary libraries:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="c1d3" class="oc la it ny b gy od oe l of og">import pandas as pd<br/>from mlxtend.frequent_patterns import apriori<br/>from mlxtend.frequent_patterns import association_rules<br/>import matplotlib.pyplot as plt<br/>from matplotlib import style<br/>import numpy as np</span></pre><p id="a06c" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">Ingest the data into a pandas data-frame and try to know about the features.</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="3984" class="oc la it ny b gy od oe l of og">read_df = pd.read_csv(‘transaction_data.csv’)<br/>df = read_df.copy()<br/>df.info()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/521b8e8726b962fafd7571b0236106b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*4NnhhVttkC8YQo0AQ3q0vA.png"/></div></figure><p id="a11e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">Further description of the features are as follows:</p><p id="a397" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">UserId — Unique identifier of a user.</p><p id="9604" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">TransactionId — Unique identifier of a transaction. If the same TransactionId is present in multiple rows, then all those products are bought together in the same transaction.</p><p id="2a52" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">TransactionTime — Time at which the transaction is performed</p><p id="8f51" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">ItemCode — Unique identifier of the product purchased</p><p id="c274" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">ItemDescription — Simple description of the product purchased</p><p id="d07b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">NumberOfItemsPurchased — Quantity of the product purchased in the transaction</p><p id="2868" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">CostPerItem — Price per each unit of the product</p><p id="2282" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">Country — Country from which the purchase is made.</p><p id="17f3" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">EDA and data cleaning is done as follows:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6792" class="oc la it ny b gy od oe l of og">df = df[df.UserId&gt;0] # usedid &lt;=0 : 25%<br/>df = df[df.ItemCode&gt;0]<br/>df = df[df.NumberOfItemsPurchased&gt;0]<br/>df = df[df.CostPerItem&gt;0]<br/>df = df[df.ItemDescription.notna()]<br/>df = df[df.TransactionTime.str[-4:] != ‘2028’]</span></pre><p id="5bd6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">The following data-frame is obtained:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a6df79949039d70eb7c07cd53446ef92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fcku0lWvrWRBdCNUF2Iy8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">First five rows of the data-frame</p></figure><p id="b116" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> EDA: </strong></p><p id="22d1" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">现在让我们做一些探索性的数据分析。让我们来看看在一年的每一段时间里完成的交易数量。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="d8fb" class="oc la it ny b gy od oe l of og">df.TransactionTime = pd.to_datetime(df.TransactionTime)<br/>df[‘month_year’]= pd.to_datetime(df.TransactionTime).dt.to_period(‘M’)<br/>df.sort_values(by = [‘month_year’], inplace = True)<br/>Ser = df.groupby(‘month_year’).TransactionId.nunique()<br/>x = np.arange(0,len(Ser),1)<br/>style.use(‘ggplot’)<br/>fig = plt.figure(figsize = (10,10))<br/>ax1 = fig.add_subplot(111)<br/>ax1.plot(x, Ser, color = ‘k’)<br/>ax1.fill_between(x, Ser, color = ‘r’, alpha = 0.5)<br/>ax1.set_xticks(x)<br/>ax1.set_xticklabels(Ser.index)<br/>plt.xlabel(‘Time period’)<br/>plt.ylabel(‘No. of transactions’)</span></pre><p id="a22f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">基本上，我们创建一个名为month_year的列，将数据点划分到它们发生的月份。然后，我们取每个月发生的唯一事务的数量，并使用matplotlib绘制它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/6e56161b4fcca6d68d92ad557c6ff685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SS5O5oKBVTpXz4Jj5I3A1Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每月完成的交易</p></figure><p id="6ab5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们可以看到，随着时间的推移，在线零售商的购买量越来越多，在2019年1月达到了峰值。</p><p id="3499" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">让我们来看看每笔交易中购买的商品数量。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8517" class="oc la it ny b gy od oe l of og">Ser = df.groupby(‘TransactionId’).ItemDescription.nunique()<br/>Ser.describe()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/d0eacebd6120b86130d9fd6cb1f5dd5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*ZdwATkmhTBVJb3NpJCC4pg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Ser的描述</p></figure><p id="c4d5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">正如我们所见，项目的最小数量是1，最大数量是540。因此，我们需要绘制直方图，如下所示:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="5e50" class="oc la it ny b gy od oe l of og">bins = [0,50,100,150,200,250,300,350,400,450,500,550]<br/>fig = plt.figure(figsize = (10,10))<br/>plt.hist(Ser, bins, histtype = 'bar', rwidth = 0.5)<br/>plt.xlabel('No. of items')<br/>plt.ylabel('No. of transactions')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/6f24165e85801655d662b20004294989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJE8yVxBV4X-38AX721fRQ.png"/></div></div></figure><p id="924e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">哎呀！我们可以看到，大多数交易包括0–100之间的项目，也有一些是100–200之间的项目。上面显示的最大项目交易可能是一个异常值，或者是一个大规模购买的客户。所以我们需要重新调整直方图。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e853" class="oc la it ny b gy od oe l of og">bins = [0,10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200]<br/>fig = plt.figure(figsize = (10,10))<br/>ax1 = fig.add_subplot(111)<br/>ax1.hist(Ser, bins, histtype = 'bar', rwidth = 0.5)<br/>ax1.set_xticks(bins)<br/>plt.xlabel('No. of items')<br/>plt.ylabel('No. of transactions')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/6a3e63e484f9482884a15eeb2f334a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9WJXpwfGhQhfPgwhZX8vSg.png"/></div></div></figure><p id="3bd9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">正如我们所见，大多数交易包括不到10个项目。</p><p id="f7b1" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">让我们找出市场上最畅销的商品。这可以有多种解释，如带来最大收入的项目、在最大交易数中发现的项目等。我们将考虑能带来最大收益的项目。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9339" class="oc la it ny b gy od oe l of og">df[‘total_cost_item’] = df.NumberOfItemsPurchased*df.CostPerItem<br/>Ser = df.groupby(‘ItemDescription’).total_cost_item.sum()<br/>Ser.sort_values(ascending = False, inplace = True)<br/>Ser = Ser[:10]<br/>fig = plt.figure(figsize = (10,10))<br/>ax = fig.add_subplot(111)<br/>ax.barh(Ser.index, Ser, height = 0.5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/b7d2472ea69343c4105f1eadc970f720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGCO00U2FUoLxhDBW__cVg.png"/></div></div></figure><p id="0649" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">从上图显示的前10项商品中，我们可以看到“retrospot lamp”商品的销售价值最高。</p><p id="21b0" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">发现唯一TransactionId的编号为18334，唯一ItemDescription的编号为3871。</p><p id="e1d3" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">既然我们在所有的预处理之后有了数据，让我们用TransactionId作为索引，用ItemDescriptions作为列，用在每个项目的每个交易中购买的项目总数作为数据点来排列它。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="50db" class="oc la it ny b gy od oe l of og">df_set = df.groupby(['TransactionId', 'ItemDescription']).NumberOfItemsPurchased.sum().unstack().reset_index().fillna(0).set_index('TransactionId')</span></pre><p id="d03d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">获得以下数据帧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/85108acbada00f53b6756228c4ca3446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVBNsrydSSsWe9f1I4h6pg.png"/></div></div></figure><p id="5c01" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们需要确保任何正值被编码为1，所有负值(如果有的话)被编码为零。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="a2f9" class="oc la it ny b gy od oe l of og">def encode(x):<br/> if x &lt;= 0:<br/> return 0<br/> else:<br/> return 1<br/>df_set = df_set.applymap(encode)<br/>df_set</span></pre><p id="87a9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">当数据框架准备好了，我们可以应用Apriori算法得到频繁购买的项目集。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="bb1b" class="oc la it ny b gy od oe l of og">frequent_itemsets = apriori(df_set, min_support = 0.015, use_colnames = True)</span></pre><p id="9b23" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这里，最小阈值支持值被设置为1.5%。我们得到以下项目集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/a037ce1870bb2c272abb51cfa545236e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*FL74ycTs7ogb3m0uVqh7_A.png"/></div></figure><p id="701c" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">然后，我们按照支持值的降序排列项目集，这就给出了</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="b8a6" class="oc la it ny b gy od oe l of og">frequent_itemsets = apriori(df_set, min_support = 0.015, use_colnames = True)<br/>top_items = frequent_itemsets.sort_values('support', ascending = False)[:20]<br/>for i in range(len(top_items.itemsets)):<br/>    top_items.itemsets.iloc[i] = str(list(top_items.itemsets.iloc[i]))<br/>fig = plt.figure(figsize = (10,10))<br/>ax = fig.add_subplot(111)<br/>ax.bar(top_items.itemsets, top_items.support)<br/>for label in ax.xaxis.get_ticklabels():<br/>    label.set_rotation(90)<br/>plt.xlabel('Item')<br/>plt.ylabel('Support')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/6a9922305502c94891db3bdca73347f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*T9_CbzgHBb3Oto8tnHxraQ.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/3c4916d657000ae88ed7f045d6151ce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*jL8nECKAATKxsQPgSbg64w.png"/></div></figure><p id="4fe8" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">然后，我们将关联规则应用到这些由Apriori算法形成的项目集上。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8281" class="oc la it ny b gy od oe l of og">rules = association_rules(frequent_itemsets, metric = 'confidence', min_threshold = 0.2)</span></pre><p id="b269" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这里使用的度量是置信度，其最小阈值设置为0.2。</p><p id="5c14" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">获得下面的数据帧</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/4a9fe7e52e36de309cbe946206462148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MGnd3kWcMzLy68TbnPtvIA.png"/></div></div></figure><p id="188a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">所有具有相应结果的前因都列出了它们各自的支持度、项目集的总支持度以及所有其他度量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/94656f5874d23e1b22f7a0573a571987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vupqsBGOcsExx0__IMU48g.png"/></div></div></figure><p id="f4b7" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">规则数据框架的总结让我们获得了以下启示:</p><ol class=""><li id="d9f9" class="ou ov it lt b lu mo lx mp ma ow me ox mi oy mm oz pa pb pc bi translated">总共有187条规则。</li><li id="6b59" class="ou ov it lt b lu pd lx pe ma pf me pg mi ph mm oz pa pb pc bi translated">各种指标的摘要。</li></ol><p id="ff54" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">让我们来看看可信度最高的规则</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="fe81" class="oc la it ny b gy od oe l of og">top_rules = rules.sort_values(‘confidence’, ascending = False)[:10]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/a1a0fbb9afdd54497076e2fd49718a36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hn5KsKskGXy7L9QWcmH6Iw.png"/></div></div></figure><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="eb07" class="oc la it ny b gy od oe l of og">fig = plt.figure(figsize = (10,10))<br/>ax = fig.add_subplot(111)<br/>ax.scatter(top_rules.support, top_rules.confidence, top_rules.lift)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/e339eeeba8db57f773afa5ef0ff2b3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gOwR6k7W2xcZ87NF-4VSiw.png"/></div></div></figure><p id="0a45" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在图表中绘制规则:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="f3ca" class="oc la it ny b gy od oe l of og">import networkx as nx<br/>G1 = nx.DiGraph()<br/>color_map = []<br/>N = 50<br/>colors = np.random.rand(N)<br/>strs = ['r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9']<br/>for i in range(10):<br/>    G1.add_nodes_from('r'+str(i))<br/>    for a in top_rules.iloc[i]['antecedents']:<br/>        G1.add_nodes_from([a])<br/>        G1.add_edge(a, 'r'+str(i), color = colors[i], weight = 2)<br/>    for c in top_rules.iloc[i]['consequents']:<br/>        G1.add_nodes_from([c])<br/>        G1.add_edge('r'+str(i), c, color = colors[i], weight = 2)<br/>for node in G1:<br/>    found_a_string = False<br/>    for item in strs:<br/>        if node == item:<br/>            found_a_string = True<br/>    if found_a_string:<br/>        color_map.append('red')<br/>    else:<br/>        color_map.append('black')<br/>edges = G1.edges()<br/>colors = [G1[u][v]['color'] for u,v in edges]<br/>weights = [G1[u][v]['weight'] for u,v in edges]<br/>pos = nx.spring_layout(G1, k = 16, scale = 1)<br/>fig = plt.figure(figsize = (20,20))<br/>nx.draw(G1, pos, edges = edges, node_color = color_map, edge_color = colors, width = weights, font_size = 16, with_labels = False)<br/>for p in pos:<br/>    pos[p][1] += 0.07<br/>nx.draw_networkx_labels(G1, pos)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/e0b5c298a51ac442b20332a6b82c576c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8GlKZZ8g8vOFuPsH9PZyAg.png"/></div></div></figure><p id="46ee" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">所有这些绘图和进一步的分析在R中比在python中更容易完成，因为R中有更多兼容的数据挖掘和关联规则库。</p><p id="9ac6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">可以使用提升值和置信度值(因为它们度量关联规则强度)对所获得的项目集进行进一步过滤。</p><p id="3711" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这里发现升力和置信度的平均值分别为9.388和0.429。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="3891" class="oc la it ny b gy od oe l of og">rules[(rules.lift &gt;= 9.388) &amp; (rules.confidence &gt;= 0.429)]</span></pre><p id="b12e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">项目集被过滤，使得只有那些提升值和置信度值高于平均值的项目集被包括在内。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/a21ada5878e94f9e4cc6c18bb19059fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cq7emkGWX9MECbUzvY08XQ.png"/></div></div></figure><p id="2e8a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">通过这种方式，可以找到所有需要的项目集。可以通过增加支持度和提升度的阈值来进一步微调项目集以找到更可能的项目集。我们可以将找到的项目集存储在一个csv文件中以备将来使用。</p><p id="412e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">总结</strong>:</p><p id="8fdf" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们看了基本的关联挖掘规则及其应用。然后利用Apriori算法解决了频繁购买项目集的生成问题。将关联规则应用于这些生成的项目集的过程被查看。我们还学习了如何在相对大规模的数据集上使用Pandas和Mlxtend在Python中完成整个过程。</p><p id="595f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">参考文献</strong>:</p><div class="nl nm gp gr nn no"><a href="https://www.edureka.co/blog/apriori-algorithm/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">Apriori算法:知道如何找到频繁项集| Edureka</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">有没有发生过这样的情况，你出去买东西，结果却买了很多超出你计划的东西？这是一个…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">www.edureka.co</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr ks no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="http://pbpython.com/market-basket-analysis.html" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">Python中的购物篮分析简介</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">python分析师可以使用多种数据分析工具，但要知道使用哪种工具可能很困难…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">pbpython.com</p></div></div><div class="pm l"><div class="ps l po pp pq pm pr ks no"/></div></div></a></div></div></div>    
</body>
</html>