<html>
<head>
<title>Logging in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中登录</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/logging-in-python-12e0c0528dd6?source=collection_archive---------16-----------------------#2020-03-01">https://towardsdatascience.com/logging-in-python-12e0c0528dd6?source=collection_archive---------16-----------------------#2020-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a75c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习用Python记录用于代码故障排除的消息</h2></div><p id="ae52" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将探索</p><ul class=""><li id="18c1" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">什么是日志记录？</li><li id="b81e" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">为什么需要？</li><li id="e48a" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">如何记录格式化的消息？</li><li id="1dcd" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">我们如何记录python类和函数的消息？</li><li id="c275" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">如何将日志消息写入文件？</li><li id="1626" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">如何记录堆栈跟踪？</li></ul><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/257f36611c6265bfef6918a13b484d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*rH1Peqyia_3GlWrphantyQ.png"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">Max陈在<a class="ae me" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f50b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您已经在Python中创建了类和函数，并且得到了不希望的结果，或者代码已经部署到生产环境中，并且已经开始给出不希望的结果。</p><p id="b497" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="mf">你如何调试代码来找出并解决根本原因？</em> </strong></p><p id="83d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">日志记录是在代码执行时记录代码流的过程，同时捕获执行期间发生的任何其他事件，如内存不足(OOM)问题或硬盘问题</strong>。日志记录通常在文件中完成，以后可以检索这些文件进行分析或故障排除。</p><p id="000c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用日志，我们可以捕获代码的类和函数中的关键信息。</p><p id="2cab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">日志有助于</strong></p><ul class=""><li id="9cc4" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="kk iu">调试代码以确定开发期间和部署后的源代码流程</strong></li><li id="bb81" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">针对由内存不足等代码导致的异常事件发出警报。</strong></li><li id="eae5" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">查找访问代码的用户或系统</strong></li></ul><p id="88d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="mf">您应该捕获哪些内容作为日志的一部分，以帮助进行故障排除？</em> </strong></p><p id="8466" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">日志应该非常详细，包含描述性消息，包括</p><ul class=""><li id="bd81" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="kk iu">访问细节</strong>:访问模型的用户或设备</li><li id="7f89" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">代码版本</strong>:正在使用的型号的当前版本</li><li id="5495" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">时间戳</strong>:捕获所有关键事件的时间戳，如何时读取输入数据、何时进行预测等。</li><li id="b743" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">结果</strong>:代码中计算变量的结果</li><li id="9f68" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">伴随堆栈跟踪出现的异常</strong></li><li id="4095" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">代码流</strong>:执行过程中调用的不同类和函数</li></ul><p id="b753" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="mf">如何用Python实现日志记录？</em> </strong></p><p id="a01c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> Python提供了一个“日志”库，将消息</strong>写入文件或任何其他输出流，如标准输出。</p><p id="13e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">按严重程度排序的不同日志记录级别</strong></p><ol class=""><li id="f013" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mg lk ll lm bi translated"><strong class="kk iu">调试</strong>:仅在诊断问题时使用</li><li id="21a8" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld mg lk ll lm bi translated"><strong class="kk iu"> INFO </strong>:仅供参考，用于诊断问题时理解代码流程</li><li id="ac55" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld mg lk ll lm bi translated"><strong class="kk iu">警告</strong>:当意外情况发生，但代码仍在运行</li><li id="cc89" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld mg lk ll lm bi translated"><strong class="kk iu">错误</strong>:代码无法执行某些功能</li><li id="e833" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld mg lk ll lm bi translated"><strong class="kk iu"> CRITICAL </strong>:程序无法继续运行时的严重错误</li></ol><p id="3eb7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用日志记录和不同严重性选项的简单代码</p><pre class="lt lu lv lw gt mh mi mj mk aw ml bi"><span id="a87d" class="mm mn it mi b gy mo mp l mq mr"><strong class="mi iu">import logging<br/>logging.debug('This is a debug message')<br/>logging.info('This is an info message')<br/>logging.warning('This is a warning message')<br/>logging.error('This is an error message')<br/>logging.critical('This is a critical message')</strong></span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/1f25db4534768acbb2e2cc1c7d436bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*_3cFovTvDiSAUchaWXR7xA.png"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">控制台中的输出</p></figure><p id="5e5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的日志消息结构是严重性级别像<strong class="kk iu"> <em class="mf">警告、</em> </strong>后跟默认日志模块<strong class="kk iu"> <em class="mf">根、</em> </strong>后跟<strong class="kk iu"> <em class="mf">消息。</em>T19】</strong></p><p id="74fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">我们看到没有显示调试和信息消息。默认情况下，日志模块仅显示严重级别为警告及以上</strong>的消息</p><p id="b6b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您正在调试代码，并且想要显示严重级别为Debug和Info的消息，该怎么办？T25】</p><p id="60d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<strong class="kk iu"><em class="mf">basic config()</em></strong>来设置测井系统的基本配置。</p><pre class="lt lu lv lw gt mh mi mj mk aw ml bi"><span id="d5cf" class="mm mn it mi b gy mo mp l mq mr"><strong class="mi iu">import logging</strong></span><span id="347f" class="mm mn it mi b gy mt mp l mq mr"><strong class="mi iu">logging.basicConfig(level=logging.debug)</strong></span><span id="c743" class="mm mn it mi b gy mt mp l mq mr"><strong class="mi iu">logging.debug('This is a debug message')<br/>logging.info('This is an info message')<br/>logging.warning('This is a warning message')<br/>logging.error('This is an error message')<br/>logging.critical('This is a critical message')</strong></span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/e3efafff86cc2dcdd3494512db776431.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*_KTn8WOwxITbr1qlTxaXew.png"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">控制台中的输出</p></figure><p id="7ee4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"><em class="mf"/></strong>如果已经配置了根记录器，则不会考虑新的设置。我不得不重新启动我的内核，让上面的代码正常工作，因为第一次调用任何日志记录函数时，它会在内部配置根日志记录器。</p><p id="fa58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">公共基础配置()参数</strong></p><p id="2ea2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">文件名</strong>:指定我们要写入日志消息的文件名</p><p id="9e51" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> filemode </strong>:指定文件需要打开的模式，如‘w’表示写入，‘a’表示追加。默认文件模式是“a”</p><p id="ff1e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">格式</strong>:指定<a class="ae me" href="https://docs.python.org/3.8/library/logging.html?highlight=logrecord#logrecord-attributes" rel="noopener ugc nofollow" target="_blank">日志记录</a>中属性可用的格式字符串</p><p id="a459" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> datefmt </strong>:指定我们想要的日志消息的日期格式。格式应该被<strong class="kk iu"><em class="mf">time . strftime()</em></strong>接受</p><p id="0178" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">级别</strong>:您想要为root logger设置的严重性级别</p><h2 id="aae9" class="mm mn it bd mv mw mx dn my mz na dp nb kr nc nd ne kv nf ng nh kz ni nj nk nl bi translated">以附加模式将日志消息写入log.txt文件，严重级别为DEBUG</h2><pre class="lt lu lv lw gt mh mi mj mk aw ml bi"><span id="d748" class="mm mn it mi b gy mo mp l mq mr"><strong class="mi iu">import logging<br/>logging.basicConfig(filename='log.txt', filemode='a', level=logging.DEBUG)</strong></span><span id="f271" class="mm mn it mi b gy mt mp l mq mr"><strong class="mi iu">logging.debug('This is a debug message')<br/>logging.info('This is an info message')<br/>logging.warning('This is a warning message')<br/>logging.error('This is an error message')<br/>logging.critical('This is a critical message')</strong></span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8bd522423084aaffc4f700c749d0566c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*kM8ZzcXlO4PODWtllrf8YQ.png"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">包含日志消息的log.txt日志文件</p></figure><h2 id="802d" class="mm mn it bd mv mw mx dn my mz na dp nb kr nc nd ne kv nf ng nh kz ni nj nk nl bi translated">以附加模式将格式化的日志消息写入log.txt文件，严重级别为DEBUG</h2><pre class="lt lu lv lw gt mh mi mj mk aw ml bi"><span id="48de" class="mm mn it mi b gy mo mp l mq mr"><strong class="mi iu">import logging<br/>logging.basicConfig(filename='log.txt', filemode='a', <br/>                    format='%(asctime)s %(msecs)d- %(process)d <br/>                    -%(levelname)s - %(message)s', <br/>                    datefmt='%d-%b-%y %H:%M:%S %p' ,<br/>                    level=logging.DEBUG)</strong></span><span id="353b" class="mm mn it mi b gy mt mp l mq mr"><strong class="mi iu">logging.debug('This is a debug message')<br/>logging.info('This is an info message')<br/>logging.warning('This is a warning message')<br/>logging.error('This is an error message')<br/>logging.critical('This is a critical message')</strong></span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/07f8582730c03eec77b7524571d30748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4YwSIrN9nvuMY7eqoxchA.png"/></div></div><p class="ma mb gj gh gi mc md bd b be z dk translated">带有格式化日志消息的log.txt日志文件</p></figure><h2 id="e79c" class="mm mn it bd mv mw mx dn my mz na dp nb kr nc nd ne kv nf ng nh kz ni nj nk nl bi translated">在类和函数中记录消息</h2><p id="c426" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">下面的代码片段将演示类和函数的登录。</p><p id="85ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用divide()创建一个TestLog类；它接受两个参数并返回除法。如果在划分中有错误，我们希望在日志文件中有堆栈跟踪</p><pre class="lt lu lv lw gt mh mi mj mk aw ml bi"><span id="9644" class="mm mn it mi b gy mo mp l mq mr"><strong class="mi iu">import logging<br/>class TestLog:<br/>    def __init__(self):<br/>       logging.info('init method')<br/>    def divide(self, x, y):<br/>        try:<br/>            </strong>l<strong class="mi iu">ogging.info(" Dividing...")<br/>            return x/y<br/>        except Exception as e:<br/>            logging.error(" Error in divide", exc_info=True)</strong></span></pre><p id="ddeb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建TestLog类的实例并调用divide()</p><pre class="lt lu lv lw gt mh mi mj mk aw ml bi"><span id="522a" class="mm mn it mi b gy mo mp l mq mr"><strong class="mi iu">import logging</strong></span><span id="2fe3" class="mm mn it mi b gy mt mp l mq mr"><strong class="mi iu">logging.basicConfig(filename='app.txt', filemode='a',level=logging.DEBUG, format='%(asctime)s %(msecs)d- %(process)d-%(levelname)s - %(message)s')</strong></span><span id="fde4" class="mm mn it mi b gy mt mp l mq mr"><strong class="mi iu">logging.info('Started')<br/>x=10<br/>y=2<br/>t= TestLog()<br/>num_1= t.divide(x,y)</strong></span><span id="4f97" class="mm mn it mi b gy mt mp l mq mr"><strong class="mi iu">logging.info(" Result of dividing %d by %d is %d", x, y,num_1)</strong></span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nx"><img src="../Images/3248a02cf2a03dc7c230232bb4c67c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBhSAmnkjAXxaDjDodWwjg.png"/></div></div><p class="ma mb gj gh gi mc md bd b be z dk translated">在app.txt中记录消息</p></figure><h2 id="13f2" class="mm mn it bd mv mw mx dn my mz na dp nb kr nc nd ne kv nf ng nh kz ni nj nk nl bi translated">记录堆栈跟踪</h2><p id="92d5" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">为了显示堆栈跟踪，我们需要像在TestLog类中一样，在异常处理的<strong class="kk iu"> except </strong>块中将<strong class="kk iu"> exc_info设置为True </strong></p><pre class="lt lu lv lw gt mh mi mj mk aw ml bi"><span id="3836" class="mm mn it mi b gy mo mp l mq mr"><strong class="mi iu">logging.info('Started')<br/>x=10<br/>y=0<br/>t= TestLog()<br/>num_1= t.divide(x,y)<br/>logging.info(" Result of dividing %d by %d is %d", x, y,num_1)</strong></span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi ny"><img src="../Images/b3234539067865ae0785f9f33b69f780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQDOh4rO61lnLC2slaTQHw.png"/></div></div><p class="ma mb gj gh gi mc md bd b be z dk translated">堆栈跟踪</p></figure><h2 id="427b" class="mm mn it bd mv mw mx dn my mz na dp nb kr nc nd ne kv nf ng nh kz ni nj nk nl bi translated">结论:</h2><p id="38e7" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">日志记录有助于在开发期间或生产部署之后对应用程序进行故障排除。可以使用多种格式将日志记录写入文件或标准输出，我们还可以捕获堆栈跟踪。</p><h2 id="c3de" class="mm mn it bd mv mw mx dn my mz na dp nb kr nc nd ne kv nf ng nh kz ni nj nk nl bi translated">参考资料:</h2><div class="nz oa gp gr ob oc"><a href="https://docs.python.org/3.8/howto/logging.html#logging-basic-tutorial" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">日志记录方法— Python 3.8.2文档</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">日志记录是跟踪某些软件运行时发生的事件的一种方式。该软件的开发人员添加了日志调用…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">docs.python.org</p></div></div></div></a></div><p id="c436" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">【https://docs.python.org/3/howto/logging-cookbook.html T4】</p></div></div>    
</body>
</html>