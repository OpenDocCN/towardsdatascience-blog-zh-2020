<html>
<head>
<title>Six Spark Exercises to Rule Them All</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">六个星火练习来统治他们</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/six-spark-exercises-to-rule-them-all-242445b24565?source=collection_archive---------0-----------------------#2020-04-07">https://towardsdatascience.com/six-spark-exercises-to-rule-them-all-242445b24565?source=collection_archive---------0-----------------------#2020-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3e8b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一些具有挑战性的Spark SQL问题，易于在许多现实世界的问题上提升和转移(带解决方案)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b6010cb77097561fb5a5162975756e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgtbulxsryIQyAysL35-xw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@xangriffin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Xan Griffin </a>在<a class="ae ky" href="https://unsplash.com/s/photos/victory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Spark SQL非常容易使用，句号。你可能已经知道这也是<strong class="lb iu">很难掌握的</strong> <strong class="lb iu">。</strong></p><p id="5069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要精通Spark，必须具备三项基本技能:</p><ol class=""><li id="c8a0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">操作和理解数据的能力<strong class="lb iu"/></li><li id="8c18" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">关于<strong class="lb iu">如何根据程序员的需求弯曲工具</strong>的知识</li><li id="a60b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在影响Spark工作执行的因素中寻找平衡的艺术<strong class="lb iu"/></li></ol><p id="911f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我精心制作了以下六个练习，这些练习类似于Spark开发人员在构建他们的管道时每天面临的一些典型情况:这些将有助于评估上述技能。</p><p id="0b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在文章末尾找到建议的解决方案！</p><h1 id="014c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">数据集</h1><p id="363b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们简单描述一下我们将要使用的数据集:i <strong class="lb iu"> t由来自商店数据库的三个表组成，分别是产品、销售和卖家。您可以通过下面的链接下载拼花文件中的数据。请注意，要100%利用这些练习，你需要阅读提供的文件！(.zip、~6GB、</strong> <a class="ae ky" href="https://gist.github.com/aialenti/cfd4e213ebf2ef6e20b195c8fb45382c" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">如果无法下载数据，可以点击这里</strong> </a> <strong class="lb iu"> ) </strong>找到生成器脚本</p><div class="ng nh gp gr ni nj"><a href="https://drive.google.com/file/d/1kCXnIeoPT6p9kS_ANJ0mmpxlfDwK1yio/view?usp=sharing" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">datasettocomplettethesixsparkexercises . zip</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">包含做六个练习的三个表的数据集</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">drive.google.com</p></div></div></div></a></div><p id="4a81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了如何连接这些表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/d590b753ad0051191db3e9c81118e882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wA4xJu3LMcm_vR5pFJkLpA.png"/></div></div></figure><h2 id="bd87" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated"><strong class="ak">销售表</strong></h2><p id="b389" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">该表中的每一行都是一个订单，每个订单只能包含一种产品。每行存储以下字段:</p><ul class=""><li id="e91d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu of mb mc md bi translated"><code class="fe og oh oi oj b">order_id</code>:订单编号<strong class="lb iu"/></li><li id="2b7d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><code class="fe og oh oi oj b">product_id</code>:订单中销售的单个产品。<strong class="lb iu">所有订单只有一种产品</strong></li><li id="92b2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><code class="fe og oh oi oj b">seller_id</code>:销售产品的销售员工ID</li><li id="fade" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><code class="fe og oh oi oj b">num_pieces_sold</code>:订单中特定产品的<strong class="lb iu">销售数量</strong></li><li id="9e1b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><code class="fe og oh oi oj b">bill_raw_text</code>:一个字符串，表示与订单关联的账单的<strong class="lb iu">原始文本</strong></li><li id="a799" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><code class="fe og oh oi oj b">date</code> : <strong class="lb iu">订单的日期</strong>。</li></ul><p id="63a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是表格的一个示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="1cd3" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">产品表</h2><p id="e324" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">每行代表一种<strong class="lb iu">独特的产品</strong>。这些字段是:</p><ul class=""><li id="8688" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu of mb mc md bi translated"><code class="fe og oh oi oj b">product_id</code>:产品ID</li><li id="f7b6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><code class="fe og oh oi oj b">product_name</code>:产品名称</li><li id="ea5f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><code class="fe og oh oi oj b">price</code>:产品价格</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="9a2d" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">卖方表</h2><p id="94f2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">该表包含所有卖家的列表:</p><ul class=""><li id="8a70" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu of mb mc md bi translated"><code class="fe og oh oi oj b">seller_id</code>:卖家ID</li><li id="c7c9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><code class="fe og oh oi oj b">seller_name</code>:卖家名称</li><li id="b9a1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><code class="fe og oh oi oj b">daily_target</code>:卖家完成其配额所需的商品数量(<strong class="lb iu">与产品类型</strong>无关)。例如，如果每日目标是100，000，员工需要销售100，000件产品，他可以通过销售100，000件product_0以及30，000件product_1和70，000件product_2来达到定额</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h1 id="3e71" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">练习</h1><p id="b9f2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">利用下面的练习的最好方法是<strong class="lb iu">下载数据并实现一个工作代码来解决提出的问题</strong>，最好是在分布式环境中<strong class="lb iu"> </strong>！我建议在阅读本页末尾的解决方案之前先这样做！</p><p id="1e04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:我构建数据集是为了允许在单台机器上工作:<strong class="lb iu">在编写代码时，想象一下数据集大100倍会发生什么。</strong></p><p id="04c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使你知道如何解决这些问题，我的建议是不要跳过热身问题！(如果你知道火花，他们需要几秒钟)。</p><p id="f416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果要用Python做这个练习，需要以下包:</p><pre class="kj kk kl km gt om oj on oo aw op bi"><span id="16f0" class="nt mk it oj b gy oq or l os ot"># Pyspark<br/>pip install pyspark</span><span id="bb41" class="nt mk it oj b gy ou or l os ot"># Pyspark stubs<br/>pip install pyspark-stubs</span></pre><h2 id="b459" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">热身#1</h2><pre class="kj kk kl km gt om oj on oo aw op bi"><span id="99ef" class="nt mk it oj b gy oq or l os ot">Find out how many orders, how many products and how many sellers are in the data.</span><span id="d6db" class="nt mk it oj b gy ou or l os ot">How many products have been sold at least once? Which is the product contained in more orders?</span><span id="08a7" class="nt mk it oj b gy ou or l os ot">===========</span><span id="9662" class="nt mk it oj b gy ou or l os ot"><strong class="oj iu">Create the Spark session using the following code</strong></span><span id="3d0c" class="nt mk it oj b gy ou or l os ot">spark = SparkSession.builder \<br/>    .master("local") \<br/>    .config("spark.sql.autoBroadcastJoinThreshold", -1) \<br/>    .config("spark.executor.memory", "500mb") \<br/>    .appName("Exercise1") \<br/>    .getOrCreate()</span></pre><h2 id="be19" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">热身#2</h2><pre class="kj kk kl km gt om oj on oo aw op bi"><span id="0fe3" class="nt mk it oj b gy oq or l os ot">How many distinct products have been sold in each day?</span><span id="c04b" class="nt mk it oj b gy ou or l os ot">===========</span><span id="7768" class="nt mk it oj b gy ou or l os ot"><strong class="oj iu">Create the Spark session using the following code</strong></span><span id="96e4" class="nt mk it oj b gy ou or l os ot">spark = SparkSession.builder \<br/>    .master("local") \<br/>    .config("spark.sql.autoBroadcastJoinThreshold", -1) \<br/>    .config("spark.executor.memory", "500mb") \<br/>    .appName("Exercise1") \<br/>    .getOrCreate()</span></pre><h2 id="e8ce" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">练习#1</h2><pre class="kj kk kl km gt om oj on oo aw op bi"><span id="c6e1" class="nt mk it oj b gy oq or l os ot">What is the average revenue of the orders?</span><span id="e171" class="nt mk it oj b gy ou or l os ot">===========</span><span id="1eac" class="nt mk it oj b gy ou or l os ot"><strong class="oj iu">Create the Spark session using the following code</strong></span><span id="0b9a" class="nt mk it oj b gy ou or l os ot">spark = SparkSession.builder \<br/>    .master("local") \<br/>    .config("spark.sql.autoBroadcastJoinThreshold", -1) \<br/>    .config("spark.executor.memory", "500mb") \<br/>    .appName("Exercise1") \<br/>    .getOrCreate()</span></pre><h2 id="02f8" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">练习#2</h2><pre class="kj kk kl km gt om oj on oo aw op bi"><span id="6a49" class="nt mk it oj b gy oq or l os ot">For each seller, what is the average % contribution of an order to the seller's daily quota?</span><span id="1bf3" class="nt mk it oj b gy ou or l os ot"><strong class="oj iu"># Example<br/></strong>If Seller_0 with `quota=250` has 3 orders:</span><span id="c920" class="nt mk it oj b gy ou or l os ot">Order 1: 10 products sold<br/>Order 2: 8 products sold<br/>Order 3: 7 products sold</span><span id="397b" class="nt mk it oj b gy ou or l os ot">The average % contribution of orders to the seller's quota would be:<br/>Order 1: 10/105 = 0.04<br/>Order 2: 8/105 = 0.032<br/>Order 3: 7/105 = 0.028</span><span id="ab71" class="nt mk it oj b gy ou or l os ot">Average % Contribution = (0.04+0.032+0.028)/3 = 0.03333</span><span id="5334" class="nt mk it oj b gy ou or l os ot">===========</span><span id="94f6" class="nt mk it oj b gy ou or l os ot"><strong class="oj iu">Create the Spark session using the following code</strong></span><span id="6216" class="nt mk it oj b gy ou or l os ot">spark = SparkSession.builder \<br/>    .master("local") \<br/>    .config("spark.sql.autoBroadcastJoinThreshold", -1) \<br/>    .config("spark.executor.memory", "500mb") \<br/>    .appName("Exercise1") \<br/>    .getOrCreate()</span></pre><h2 id="2cde" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">练习#3</h2><pre class="kj kk kl km gt om oj on oo aw op bi"><span id="7d90" class="nt mk it oj b gy oq or l os ot">Who are the <strong class="oj iu">second most selling and the least selling</strong> persons (sellers) for each product?<em class="ov"> </em>Who are those for product with `product_id = 0`</span><span id="f101" class="nt mk it oj b gy ou or l os ot">===========</span><span id="4cb0" class="nt mk it oj b gy ou or l os ot"><strong class="oj iu">Create the Spark session using the following code</strong></span><span id="6bcb" class="nt mk it oj b gy ou or l os ot">spark = SparkSession.builder \<br/>    .master("local") \<br/>    .config("spark.sql.autoBroadcastJoinThreshold", -1) \<br/>    .config("spark.executor.memory", "3gb") \<br/>    .appName("Exercise1") \<br/>    .getOrCreate()</span></pre><h2 id="2b1f" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">练习#4</h2><pre class="kj kk kl km gt om oj on oo aw op bi"><span id="ac31" class="nt mk it oj b gy oq or l os ot">Create a new column called "hashed_bill" defined as follows:</span><span id="daf2" class="nt mk it oj b gy ou or l os ot">- <strong class="oj iu">if the order_id is even</strong>: apply MD5 hashing iteratively to the bill_raw_text field, once for each 'A' (capital 'A') present in the text. E.g. if the bill text is 'nbAAnllA', you would apply hashing three times iteratively (<strong class="oj iu"><em class="ov">only if the order number is even</em></strong>)</span><span id="177a" class="nt mk it oj b gy ou or l os ot">- <strong class="oj iu">if the order_id is odd</strong>: apply SHA256 hashing to the bill text</span><span id="5f39" class="nt mk it oj b gy ou or l os ot">Finally, check if there are any duplicate on the new column</span><span id="fae0" class="nt mk it oj b gy ou or l os ot">===========</span><span id="7598" class="nt mk it oj b gy ou or l os ot"><strong class="oj iu">Create the Spark session using the following code</strong></span><span id="5310" class="nt mk it oj b gy ou or l os ot">spark = SparkSession.builder \<br/>    .master("local") \<br/>    .config("spark.sql.autoBroadcastJoinThreshold", -1) \<br/>    .config("spark.executor.memory", "3gb") \<br/>    .appName("Exercise1") \<br/>    .getOrCreate()</span></pre></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><h1 id="2add" class="mj mk it bd ml mm pd mo mp mq pe ms mt jz pf ka mv kc pg kd mx kf ph kg mz na bi translated">解决方法</h1><p id="49d4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们深入研究解决方案。首先，你应该注意到<strong class="lb iu">热身问题对解决练习</strong>很方便:</p><h2 id="f196" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">热身#1</h2><p id="083f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这个练习的答案很简单。首先，我们只需要<code class="fe og oh oi oj b">count</code>每个数据集中有多少行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="98d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到以下输出:</p><pre class="kj kk kl km gt om oj on oo aw op bi"><span id="88c4" class="nt mk it oj b gy oq or l os ot">Number of Orders: 20000040<br/>Number of sellers: 10<br/>Number of products: 75000000</span></pre><p id="e3b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们的数据集中有<strong class="lb iu"> 75，000，000个产品</strong>和2 <strong class="lb iu"> 0，000，040个订单</strong>:由于每个订单只能有一个产品，其中一些从未售出。让我们找出有多少产品至少出现一次，哪个产品包含在更多订单中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="9678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个查询计算sales表中有多少不同的产品，而第二个块提取sales表中计数最高的<code class="fe og oh oi oj b">product_id</code>。</p><p id="1679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示:</p><pre class="kj kk kl km gt om oj on oo aw op bi"><span id="8b0c" class="nt mk it oj b gy oq or l os ot">Number of products sold at least once<br/>+--------------------------+<br/>|count(DISTINCT product_id)|<br/>+--------------------------+<br/>|                    993429|<br/>+--------------------------+</span><span id="c2e3" class="nt mk it oj b gy ou or l os ot">Product present in more orders<br/>+----------+--------+<br/>|product_id|     cnt|<br/>+----------+--------+<br/>|         0|19000000|<br/>+----------+--------+</span></pre><p id="c82a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细看看第二个结果:20 M中的19，000，000个订单正在销售带有<code class="fe og oh oi oj b">product_id = 0</code> : <strong class="lb iu">的产品这是一个我们以后应该使用的强大信息！</strong></p><h2 id="2c64" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">热身#2</h2><p id="1b75" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">对Spark有所了解，这应该很简单:我们只需要找出<em class="ov">“在每一天卖出了多少不同的产品”</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="6dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里不多说了，输出如下:</p><pre class="kj kk kl km gt om oj on oo aw op bi"><span id="f19a" class="nt mk it oj b gy oq or l os ot">+----------+----------------------+<br/>|      date|distinct_products_sold|<br/>+----------+----------------------+<br/>|2020-07-06|                100765|<br/>|2020-07-09|                100501|<br/>|2020-07-01|                100337|<br/>|2020-07-03|                100017|<br/>|2020-07-02|                 99807|<br/>|2020-07-05|                 99796|<br/>|2020-07-04|                 99791|<br/>|2020-07-07|                 99756|<br/>|2020-07-08|                 99662|<br/>|2020-07-10|                 98973|<br/>+----------+----------------------+</span></pre><h2 id="1858" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">练习#1</h2><p id="d160" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们解决难题吧！第一个练习是简单地询问"<em class="ov">订单的平均收入是多少？</em></p><p id="85bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">理论上，这很简单:我们首先需要计算每个订单的收入，然后得到平均值</strong>。记得那个<code class="fe og oh oi oj b">revenue = price * quantity</code>。零用易:<code class="fe og oh oi oj b">product_price</code>在<code class="fe og oh oi oj b">products</code>表中，金额在<code class="fe og oh oi oj b">sales</code>表中。</p><p id="fed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种方法是简单地连接两个表，创建一个新列，然后求平均值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="a1f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是正确的，并且它可能工作得相当好(<strong class="lb iu">特别是如果您正在本地环境中工作</strong>)。但是让我们看一下执行计划DAG:在某个时候，我们将有一个重新分区(在<code class="fe og oh oi oj b">product_id</code>字段上)和一个连接:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/0570c3f7653224f37720663f7ffad579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUB7HwLCK-DxIbrHYs9mQQ.png"/></div></div></figure><p id="5904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看当Spark执行join时会发生什么(在Spark UI上的<strong class="lb iu">):</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/08e0ebb6e3bf5cdae7f31518b2107764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RhPA6pwBUH6VK1MsGz4_uA.png"/></div></div></figure><p id="183d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哎呀！一项任务比其他任务花费更多的时间！</p><p id="1bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这是一个典型的倾斜连接的例子，其中一个任务需要很长时间来执行，因为连接只倾斜在很少的键上</strong>(在这个例子中是<code class="fe og oh oi oj b">product_id = 0</code>)。<a class="ae ky" rel="noopener" target="_blank" href="/the-art-of-joining-in-spark-dcbd33d693c">我在我的媒体文章《星火加盟的艺术》中提到过星火加盟，如果你想了解更多，可以去那里看看！</a></p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/the-art-of-joining-in-spark-dcbd33d693c"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">火花中加入的艺术</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">Spark中加速连接的实用技巧</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ks nj"/></div></div></a></div><p id="88b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，如果您在本地系统上运行Spark，这不是一个大问题。在分布式环境中(有更多的数据)，这个连接可能会花费<strong class="lb iu">难以置信的时间来完成</strong>(也许根本不会完成！).</p><p id="1aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一种叫做“密钥加盐”的技术来解决这个问题。我不会详细描述，因为我已经在上面链接的文章中涉及了这个主题。总结一下，我们要做的是:</p><ol class=""><li id="d9c3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">为最常见的产品</strong>复制维度表中的条目，例如，将复制product_0，创建id:<code class="fe og oh oi oj b">product_0–1</code>、<code class="fe og oh oi oj b">product_0–2</code>、<code class="fe og oh oi oj b">product_0–3</code>等。</li><li id="7ff1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">在销售表上，我们将把“</strong> <code class="fe og oh oi oj b"><strong class="lb iu">product_0</strong></code> <strong class="lb iu">”替换为随机复制的</strong>(例如，其中一些将替换为<code class="fe og oh oi oj b">product_0–1</code>，其他替换为<code class="fe og oh oi oj b">product_0–2</code>，等等。)<strong class="lb iu">使用新的“salted”键将消除连接的倾斜:</strong></li></ol><p id="a8aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里要注意的重要一点是<strong class="lb iu">我们并没有对所有的产品加盐，只是对那些驱动偏斜度的产品加盐</strong>(在这个例子中，我们得到了100个最频繁出现的产品)。<strong class="lb iu">对整个数据集加盐会有问题，因为行数会根据“加盐因子”线性增长</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="f640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看我们执行上述操作时的各个阶段:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/cabd666b41b1fc442e904ee25664a23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ulRkMrdkCipNiUEILgrlQ.png"/></div></div></figure><p id="1453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询的结果应该如下所示</p><pre class="kj kk kl km gt om oj on oo aw op bi"><span id="30a9" class="nt mk it oj b gy oq or l os ot">+------------------------------+<br/>|avg((price * num_pieces_sold))|<br/>+------------------------------+<br/>|            1246.1338560822878|<br/>+------------------------------+</span></pre><p id="c677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本地环境中使用这种技术可能会导致执行时间的增加；然而，在现实世界中，这个技巧可以决定完成还是不完成连接。</p><h2 id="a9b2" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">练习#2</h2><p id="7355" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">第二个问题是:<em class="ov">“对于每个卖家，订单对卖家每日配额的平均贡献百分比是多少？".</em></p><p id="f0ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这与第一个练习</strong>类似:我们可以将我们的表与sellers表连接起来，我们计算特定订单的配额命中率，然后计算平均值，按<code class="fe og oh oi oj b">seller_id</code>分组。</p><p id="b7e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，这可能会产生一个偏斜的连接，因为即使是卖家也不是均匀分布的。不过，在这种情况下，解决方案要简单得多！因为卖家的表格很小，<strong class="lb iu">我们可以广播它，使得操作快得多</strong>！</p><p id="3585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">“广播”仅仅意味着将表的副本发送给每个执行者，允许“本地化”任务</strong>。我们需要小心地使用这个操作符:当我们广播一个表时，<strong class="lb iu">我们需要确保这个表不会变得太大而不能在将来广播</strong>，否则我们将会在以后出现内存不足的错误(随着广播数据集变得越来越大)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="0d6e" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">练习#3</h2><p id="9627" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">问题:<em class="ov">“每种产品的</em> <strong class="lb iu"> <em class="ov">销量第二多和销量最少的</em> </strong> <em class="ov">人员(卖家)是谁？那些带有</em> <code class="fe og oh oi oj b"><em class="ov">product_id = 0</em></code> <em class="ov">的产品是谁。</em></p><p id="894f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来像窗口函数！让我们来分析一下这个问题:对于每种产品，我们需要<strong class="lb iu">销量第二多和销量最少的员工(销售人员)</strong>:我们可能需要两个排名，一个是销售图表中的第二名，另一个是最后一名。我们还需要处理一些边缘情况:</p><ul class=""><li id="62fd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu of mb mc md bi translated"><strong class="lb iu">如果一个产品只被一个卖家</strong>卖出，我们会把它放入一个特殊的类别(类别:<code class="fe og oh oi oj b">Only seller or multiple sellers with the same quantity</code>)。</li><li id="402b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><strong class="lb iu">如果一个产品由多个卖家出售，但所有卖家都出售了相同的数量</strong>，我们将把他们放在同一个类别中，就好像他们只是该产品的一个卖家一样(类别:<code class="fe og oh oi oj b">Only seller or multiple sellers with the same quantity</code>)。</li><li id="12d2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu of mb mc md bi translated"><strong class="lb iu">如果“最少销售”也是“第二次销售”</strong>，我们将仅将其计为“第二次销售”</li></ul><p id="6afb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们起草一个策略:</p><ol class=""><li id="9432" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">我们得到每对产品和卖家的销售总额。</strong></li><li id="80af" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">我们增加了两个新的排名列</strong>:一个按<strong class="lb iu">降序排列产品的销售额，另一个按升序排列。</strong></li><li id="b6da" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">我们将获得的数据集分成三份</strong>:我们要处理的每个案例一份(第二大销售、最少销售、单一销售)。</li><li id="4136" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">在计算“最少销售”时，我们排除了只有一个销售人员的产品，以及销售最少的员工也是第二多销售人员的产品</strong></li><li id="2d91" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们把碎片重新组合在一起。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="954c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题第二部分的结果如下:</p><pre class="kj kk kl km gt om oj on oo aw op bi"><span id="19f9" class="nt mk it oj b gy oq or l os ot">+----------+---------+--------------------+<br/>|product_id|seller_id|                type|<br/>+----------+---------+--------------------+<br/>|         0|        0|Only seller or mu...|<br/>+----------+---------+--------------------+</span></pre><h2 id="ad8c" class="nt mk it bd ml nu nv dn mp nw nx dp mt li ny nz mv lm oa ob mx lq oc od mz oe bi translated">练习#4</h2><p id="1df8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">对于这个最后的练习，<strong class="lb iu">我们只需要应用一个奇特的算法</strong>。我们可以通过<strong class="lb iu">UDF(用户定义函数)</strong>来实现。UDF是一个<strong class="lb iu">自定义函数，可以在数据帧列</strong>上调用；作为一条经验法则，我们通常应该尽量避免UDF，因为Spark并不能真正优化它们:UDF代码通常比非UDF代码运行得慢。<strong class="lb iu">不幸的是，我们不能仅使用Spark SQL函数</strong>来应用所描述的算法。</p><p id="6d9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="dd58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要定义UDF函数 : <code class="fe og oh oi oj b">def algo(order_id, bill_text)</code>。<code class="fe og oh oi oj b">algo</code>功能接收<code class="fe og oh oi oj b">order_id</code>和<code class="fe og oh oi oj b">bill_text</code>作为输入。</p><p id="af7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UDF函数实现算法:</p><ol class=""><li id="a4f2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">检查<code class="fe og oh oi oj b">order_id</code>是偶数还是奇数。</li><li id="e7f4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果<code class="fe og oh oi oj b">order_id</code>是偶数，计算钞票文本中大写字母“A”的数量，并迭代应用MD5</li><li id="f663" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果<code class="fe og oh oi oj b">order_id</code>是奇数，应用SHA256</li><li id="6640" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">返回哈希后的字符串</li></ol><p id="8814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，这个函数需要通过<code class="fe og oh oi oj b">algo_udf = spark.udf.register(“algo”, algo)</code>行注册到Spark会话中。第一个参数是Spark上下文中的函数名，而第二个参数是将要执行的实际函数。</p><p id="d169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在下面一行应用UDF:</p><pre class="kj kk kl km gt om oj on oo aw op bi"><span id="407d" class="nt mk it oj b gy oq or l os ot">sales_table.withColumn("hashed_bill", algo_udf(col("order_id"), col("bill_raw_text")))</span></pre><p id="6c11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，该函数将两列作为输入，并将对每一行执行(即每对<code class="fe og oh oi oj b">order_id</code>和<code class="fe og oh oi oj b">bill_raw_text</code>)。</p><p id="e6f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在最终的数据集中，所有的散列应该是不同的，所以查询应该返回一个空的数据集</strong></p><h1 id="dfeb" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">拿走</h1><p id="0777" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如果你完成了所有的练习，恭喜你！这些内容涵盖了关于Spark SQL开发的一些非常重要的主题:</p><ol class=""><li id="f0bd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">连接偏斜</strong>:这通常是Spark管道中的主要痛点；有时很难解决，因为在这些操作中涉及的所有因素之间找到平衡并不容易。</li><li id="32ec" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">窗口函数</strong>:超级有用，唯一要记住的就是先定义开窗。</li><li id="9a31" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">虽然UDF非常有用，但是我们在开始开发这样的函数之前应该三思，因为它们的执行可能会降低我们代码的速度。</li></ol><p id="9073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，上面的练习可以用许多不同的方法来解决，我很乐意接受建议！我希望你喜欢！<strong class="lb iu">让我知道你的想法</strong>，如果你愿意，<strong class="lb iu">看看这些其他的文章！</strong></p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/effortless-hyperparameters-tuning-with-apache-spark-20ff93019ef2"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">使用Apache Spark轻松调整超参数</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">如何在Spark上运行随机搜索而不用编写Spark代码？</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pr l pm pn po pk pp ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/clustering-pollock-1ec24c9cf447"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">聚类波洛克</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">杰森·布拉克绘画的聚类分析——如何利用k-means进行色彩分组</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="ps l pm pn po pk pp ks nj"/></div></div></a></div></div></div>    
</body>
</html>