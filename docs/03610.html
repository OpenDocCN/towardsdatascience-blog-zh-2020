<html>
<head>
<title>Climbing B-tree Indexes in Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Postgres中攀爬B树索引</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/climbing-b-tree-indexes-in-postgres-b67a7e596db?source=collection_archive---------27-----------------------#2020-04-05">https://towardsdatascience.com/climbing-b-tree-indexes-in-postgres-b67a7e596db?source=collection_archive---------27-----------------------#2020-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="341f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解并应用Postgres中的定位索引进行排序和匹配</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9327801583cd70041d2bb2a059b60f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84IQacfAgDPAou-h70Y-3A.png"/></div></div></figure><p id="0c08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的查询很慢，所以您决定通过添加索引来加快速度。它是什么类型的指数？可能是B树。</p><p id="17cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Postgres有几种索引类型，但是B树是最常见的。它们有利于分类和匹配；一旦你理解了它们在引擎盖下的样子，原因就显而易见了。</p><p id="faba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将深入探究Postgres中B树实现的内部机制，然后做一些SQL示例来展示它们的效果。我已经提供了查询，所以你可以自己运行相同的实验。</p><p id="4a84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章假设你已经对索引是什么和做什么有了一个大致的概念。如果不是，通常提供的抽象是教科书中的术语表。你可以在词汇表中按字母顺序查找，然后跳到它所在的页面，而不是阅读书中的每一行来找到一个单词/主题。我们很快就会看到现实稍微复杂一些。</p><h1 id="db66" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">什么是B树？</h1><p id="e3bd" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">b树代表平衡树。</p><p id="54f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它不是一个<a class="ae lq" href="https://en.wikipedia.org/wiki/Binary_tree" rel="noopener ugc nofollow" target="_blank">二叉树</a>，它允许每个父节点最多2个子节点，并且是为内存搜索而设计的。</p><p id="dc9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">来自<a class="ae lq" href="https://en.wikipedia.org/wiki/B-tree" rel="noopener ugc nofollow" target="_blank">维基百科</a>，</p><blockquote class="mo mp mq"><p id="0062" class="ku kv mr kw b kx ky ju kz la lb jx lc ms le lf lg mt li lj lk mu lm ln lo lp im bi translated">在<a class="ae lq" href="https://en.wikipedia.org/wiki/Computer_science" rel="noopener ugc nofollow" target="_blank">计算机科学</a>中，<strong class="kw iu"> B树</strong>是一种自平衡<a class="ae lq" href="https://en.wikipedia.org/wiki/Tree_data_structure" rel="noopener ugc nofollow" target="_blank">树数据结构</a>，它维护分类数据并允许在<a class="ae lq" href="https://en.wikipedia.org/wiki/Logarithmic_time" rel="noopener ugc nofollow" target="_blank">对数时间</a>内进行搜索、顺序访问、插入和删除。B树概括了<a class="ae lq" href="https://en.wikipedia.org/wiki/Binary_search_tree" rel="noopener ugc nofollow" target="_blank">二叉查找树</a>，允许节点有两个以上的子节点。<a class="ae lq" href="https://en.wikipedia.org/wiki/B-tree#cite_note-Comer-2" rel="noopener ugc nofollow" target="_blank">【2】</a>与其他<a class="ae lq" href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" rel="noopener ugc nofollow" target="_blank">自平衡二分搜索法树</a>不同，B树非常适合读写相对较大数据块的存储系统，比如磁盘。常用于<a class="ae lq" href="https://en.wikipedia.org/wiki/Database" rel="noopener ugc nofollow" target="_blank">数据库</a>和<a class="ae lq" href="https://en.wikipedia.org/wiki/File_system" rel="noopener ugc nofollow" target="_blank">文件系统</a>。</p></blockquote><p id="618d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个非常好的非技术性介绍。要获得真正的技术解释，请参见由Lehman和Yao撰写的论文，Postgres的实现就是基于该论文。</p><h2 id="7fd3" class="mv ls it bd lt mw mx dn lx my mz dp mb ld na nb md lh nc nd mf ll ne nf mh ng bi translated">B树的结构</h2><p id="0541" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">b树是“平衡的”，因为从根到任何叶节点的距离都是相同的。叶节点是没有子节点的节点。根节点是位于顶部的节点。</p><p id="1c5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个节点有键。在我们下面的根节点中，[10，15，20]是键。键映射到数据库中的值，但也映射到子节点中的绑定键。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9327801583cd70041d2bb2a059b60f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84IQacfAgDPAou-h70Y-3A.png"/></div></div></figure><p id="d80d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个子节点[2，9]的值小于10，因此指针位于10的左侧。</p><p id="77ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二个子节点[12]的值介于10和15之间，因此指针从那里开始。</p><p id="e221" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第三个子节点[22]大于20，因此指针位于20的右侧。</p><p id="c15e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我们想查找键12，我们将12与根节点中的值进行比较，看到它在10和15之间。所以我们使用10和15之间的指针来查找包含12的节点。</p><p id="f1b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是对Postgres实现的抽象，但是你可以想象为什么这比遍历表中的每个数字并检查它是否等于12要快。</p><p id="48de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么B树可以在O(logN)时间内进行搜索、插入和删除。</p><p id="0116" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mr"> B树每个节点也有最小和最大数量的键。在插入和删除时连接和拆分节点，以保持节点在范围内。</em></p><h1 id="ff3d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">数字、文本和日期的b树</h1><p id="09eb" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们将通过三个例子来研究B树的巨大影响力:数字、文本和日期。</p><h2 id="b56b" class="mv ls it bd lt mw mx dn lx my mz dp mb ld na nb md lh nc nd mf ll ne nf mh ng bi translated">设置</h2><p id="dfd6" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">为每种数据类型创建一个表。每个表有两列，但我们只索引其中一列。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="60e3" class="mv ls it ni b gy nm nn l no np">create table numbers(<br/>  val integer,<br/>  val_indexed integer<br/>);<br/>CREATE INDEX numbers_indexed ON numbers using btree (val_indexed);</span><span id="2264" class="mv ls it ni b gy nq nn l no np"><br/>create table strings(<br/>  val varchar,<br/>  val_indexed varchar<br/>);<br/>CREATE INDEX strings_indexed ON strings using btree (val_indexed);</span><span id="0c0c" class="mv ls it ni b gy nq nn l no np"><br/>create table dates(<br/>  val varchar,<br/>  val_indexed varchar<br/>);<br/>CREATE INDEX dates_indexed ON dates using btree (val_indexed);</span></pre><h2 id="5146" class="mv ls it bd lt mw mx dn lx my mz dp mb ld na nb md lh nc nd mf ll ne nf mh ng bi translated">数字</h2><p id="d236" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们来生成1到~1M之间的1M个随机整数。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="120e" class="mv ls it ni b gy nm nn l no np"><strong class="ni iu">insert</strong> <strong class="ni iu">into</strong> numbers<br/><strong class="ni iu">select<br/>  </strong>(<strong class="ni iu">random</strong>()*1000000 +1)::<strong class="ni iu">int</strong>,<br/>  (<strong class="ni iu">random</strong>()*1000000 +1)::<strong class="ni iu">int<br/>from</strong> (<strong class="ni iu">SELECT</strong> * <strong class="ni iu">FROM</strong> <strong class="ni iu">generate_series</strong>(1,1000000)) ser;</span></pre><p id="ccda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将重复运行下面的查询，记录查询时间，然后再添加额外的100万条记录。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="386e" class="mv ls it ni b gy nm nn l no np"><strong class="ni iu">select</strong> * <strong class="ni iu">from</strong> numbers <strong class="ni iu">order</strong> <strong class="ni iu">by</strong> val <strong class="ni iu">desc</strong>;<br/><strong class="ni iu">select</strong> * <strong class="ni iu">from</strong> numbers <strong class="ni iu">order</strong> <strong class="ni iu">by</strong> val_indexed <strong class="ni iu">desc</strong>;</span></pre><p id="9903" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们看到的是，在对索引列和非索引列进行排序时，查询时间存在巨大差异。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/6d82dd2a3531497ceded06fb58ae0181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhdC5kbA9vcUKoD1WwxMNw.png"/></div></div></figure><p id="6d73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">500万条记录对于Postgres来说微不足道，但我们已经可以看到效率上的巨大差异。</p><p id="8b6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么不同？让我们使用Postgres中的<code class="fe ns nt nu ni b">explain</code>函数来深入研究一下。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0058" class="mv ls it ni b gy nm nn l no np">explain select * from numbers order by val desc;<br/>explain select * from numbers order by val_indexed desc;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/e19e1c22ed9b016053279235f3e0d8df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fa8UDjUFL0MTnc7DV0JEOQ.png"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">无索引的</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/99b58a90388f31987bcb068b9be1d12b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZtV9KGis5uWRTmH6cJLyVQ.png"/></div></div><p class="nw nx gj gh gi ny nz bd b be z dk translated">编入索引的</p></figure><p id="2328" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们看到非索引搜索使用顺序扫描，而索引搜索使用索引扫描。给定上面讨论的B树结构，很容易理解为什么搜索索引会比搜索表快得多。</p><h2 id="5fcc" class="mv ls it bd lt mw mx dn lx my mz dp mb ld na nb md lh nc nd mf ll ne nf mh ng bi translated">文本</h2><p id="c7a5" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们用字符串做同样的比较。不过这次我们将一次增加100k行。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a383" class="mv ls it ni b gy nm nn l no np"><strong class="ni iu">insert</strong> <strong class="ni iu">into</strong> strings<br/><strong class="ni iu">SELECT<br/>  md5</strong>(<strong class="ni iu">random</strong>()::<strong class="ni iu">text</strong>),<br/>  <strong class="ni iu">md5</strong>(<strong class="ni iu">random</strong>()::<strong class="ni iu">text</strong>)<br/><strong class="ni iu">from</strong> (<br/>  <strong class="ni iu">SELECT</strong> * <strong class="ni iu">FROM</strong> <strong class="ni iu">generate_series</strong>(1,100000) <strong class="ni iu">AS</strong> id<br/>) <strong class="ni iu">AS</strong> ser;</span></pre><p id="20e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在对这些行进行排序。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="c226" class="mv ls it ni b gy nm nn l no np"><strong class="ni iu">select</strong> * <strong class="ni iu">from</strong> strings <strong class="ni iu">order</strong> <strong class="ni iu">by</strong> val <strong class="ni iu">desc</strong>;<br/><strong class="ni iu">select</strong> * <strong class="ni iu">from</strong> strings <strong class="ni iu">order</strong> <strong class="ni iu">by</strong> val_indexed <strong class="ni iu">desc</strong>;</span></pre><p id="4320" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们看到了什么？与索引搜索击败非索引搜索的模式完全相同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/c462813100077a0c29b2bb3f77ad67ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VjIxfipHff3Ga2IsxUaRg.png"/></div></div></figure><p id="fd3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">偷看<code class="fe ns nt nu ni b">explain</code>，我们看到的是同样的原因。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a213" class="mv ls it ni b gy nm nn l no np">explain select * from strings order by val desc;<br/>explain select * from strings order by val_indexed desc;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/99baa511386cb09d477ed6edd46cd4bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1Z0uL1wJOm5lhNXel0HBQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/fed9c0a320c2bd5ebead12e099aaff12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XYKhopbg3NVCKnOKFmXe6w.png"/></div></div></figure><h2 id="c7db" class="mv ls it bd lt mw mx dn lx my mz dp mb ld na nb md lh nc nd mf ll ne nf mh ng bi translated">日期</h2><p id="783f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们用日期再做一次。同样，我们一次只生成100k行。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a02b" class="mv ls it ni b gy nm nn l no np">with cte as (<br/>select <br/>  timestamp '1900-01-10 20:00:00' +<br/>  random() * (<br/>    timestamp '2000-01-20 20:00:00'-timestamp '1900-01-10 10:00:00'<br/>  ) rdate<br/>  from (SELECT * FROM generate_series(1,100000) AS id) ser<br/>)<br/>insert into dates<br/>select <br/>  rdate,<br/>  rdate<br/>from cte;</span></pre><p id="af0d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查询日期并记录查询时间。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="d1b7" class="mv ls it ni b gy nm nn l no np">select * from dates order by val desc;<br/>select * from dates order by val_indexed desc;</span></pre><p id="e7e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">比较一下区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/1b85123ab1b009944a9e4c7f12dde651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYmYrYqyTad4ZcYWYcwTxw.png"/></div></div></figure><p id="6e39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经可以猜到<code class="fe ns nt nu ni b">explain</code>将会展示什么，但还是让我们来看看吧。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="7fed" class="mv ls it ni b gy nm nn l no np">explain select * from dates order by val desc;<br/>explain select * from dates order by val_indexed desc;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/7561b17d1906d689c712eba2d57f3d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54CpEWOb35eU2YjslWidCw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/59581bc0646788b8a2138b27b8073a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*paHliZhlw6iPzJs0aWre0Q.png"/></div></div></figure><p id="8064" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，通过索引扫描对行进行排序比顺序扫描快几个数量级。</p><h1 id="04a5" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="4032" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我的目的是让您对索引的结构有一个大致的了解，这样您就可以直观地理解为什么它们会缩短查询时间。</p><p id="405a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们讨论了一些例子，在这些例子中，添加一个索引会产生昼夜差异。</p><p id="7edd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只讨论了对行进行排序，但是调查查询时间并查看其他类型的查询(如<code class="fe ns nt nu ni b">where</code>或<code class="fe ns nt nu ni b">exists</code>)会很有趣。</p></div></div>    
</body>
</html>