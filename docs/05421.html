<html>
<head>
<title>How to clean and combine Dataframe columns of lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何清理和组合列表的数据框列</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-clean-and-combine-dataframe-columns-of-lists-ebd3542559b6?source=collection_archive---------23-----------------------#2020-05-07">https://towardsdatascience.com/how-to-clean-and-combine-dataframe-columns-of-lists-ebd3542559b6?source=collection_archive---------23-----------------------#2020-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d9fdb5c7cae2bfc51421b0898249d067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_aP90sVOTx4_AGNhx6mJA.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">Joshua Rodriguez 在<a class="ae kc" href="https://unsplash.com/s/photos/columns-of-lists?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a9eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Metis数据科学训练营的第二个项目中，我发现自己不得不处理熊猫数据框中的列表。我在谷歌搜索中没有找到这些信息，所以我把它放在这里作为有用的参考/起点。</p><h1 id="f43c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一.问题</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/609845dac075a9e3a08dc59b6b38ee14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hm7kDFRPsX8egE7XwfrfPg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">相关属性的列，充满列表</p></figure><p id="f432" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我需要完成几件事:</p><ul class=""><li id="8498" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">包含其他列表栏中所有项目的合并栏，但没有重复项目。因此，第1列中有[A，B]而第2列中有[B，C]的条目将导致[A，B，C]的合并条目。</li><li id="1c60" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">将所有NaN值更改为空列表。</li><li id="cb34" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">从列表中的所有项目生成虚拟列的列表(按照下面的列)。</li></ul><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/eb04c6c66ee9430ec83a81c261ccf7cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*scxusiI-lvvVQ4iUxP6LgQ.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">流派:包含分类特征列表的列</p></figure><h1 id="20d1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">二。方法</h1><p id="6194" class="pw-post-body-paragraph kd ke iq kf b kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">我编写了下面的助手函数，我将一个一个地介绍它们。</p><h2 id="aeb6" class="my lc iq bd ld mz na dn lh nb nc dp ll ko nd ne lp ks nf ng lt kw nh ni lx nj bi translated">a)基于列表列创建数据帧</h2><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ol class=""><li id="052b" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la nm mk ml mm bi translated">数据帧本质上是一系列系列。所以给定一个列，我<strong class="kf ir">对每个列表项</strong>应用pandas系列转换。然后，我将这一系列序列分配给一个新的数据帧。</li><li id="5445" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la nm mk ml mm bi translated">我用基于原始列名和列表索引的编号系统替换了默认的列名，格式为<column-name> _ <list-index>。</list-index></column-name></li></ol><p id="c83e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将它应用到上面的流派专栏，我得到了以下结果:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/6fe549b6aeac0a2134e6614fec239b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sTjIJeUZYFkRpMcMwu87sA.png"/></div></div></figure><h2 id="ae67" class="my lc iq bd ld mz na dn lh nb nc dp ll ko nd ne lp ks nf ng lt kw nh ni lx nj bi translated">b)列表中各列的虚拟变量</h2><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ol class=""><li id="0ca8" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la nm mk ml mm bi translated">我可以使用前面的helper函数来获得列表条目的数据帧(让我们称之为list_df)。</li><li id="553f" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la nm mk ml mm bi translated">使用pandas的<strong class="kf ir"> get_dummies() </strong>，我获得list_df的所有列的虚拟数据帧，然后<strong class="kf ir">将它们加在一起。</strong>这给了我一个整合的虚拟数据框架。</li></ol><p id="8b70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将此应用于“流派”列会得到以下结果:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/aad1e10257cd527287bfcc2afd8f2228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gF36GMUFWETK3AA-lY-sTg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">仅显示了前几个流派虚拟列</p></figure><h2 id="f94b" class="my lc iq bd ld mz na dn lh nb nc dp ll ko nd ne lp ks nf ng lt kw nh ni lx nj bi translated">c)合并列表的列</h2><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ol class=""><li id="b34d" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la nm mk ml mm bi translated">这里的逻辑类似于创建虚拟列的逻辑。我没有使用add()，而是将所有的数据帧连接在一起成为一个大的数据帧。</li><li id="c2d3" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la nm mk ml mm bi translated">我<strong class="kf ir">将大数据帧转换成一个列表</strong>，所以它现在是一个列表的列表。这对于接下来的几个步骤很重要。</li><li id="a3f7" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la nm mk ml mm bi translated">我<strong class="kf ir">使用list comprehension来只包含列表列表中每个列表中与我们期望的类型</strong>相匹配的条目。在这种情况下，由于所需的类型是一个字符串，这也消除了我所有的NaN值。<em class="np">如果一开始只有NaN个值，我们最终得到的是一个空列表。完美！</em></li><li id="0a67" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la nm mk ml mm bi translated">最后，我<strong class="kf ir">将set()和list() </strong>映射到list列表中。集合论的神奇之处在于，当应用set()时，所有重复项都会自动丢弃。</li><li id="719a" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la nm mk ml mm bi translated">注意，结果仍然是列表的列表。我有另一个如下所示的帮助函数，根据父数据帧的索引将它分配给数据帧列，并将其命名为:</li></ol><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="26f2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">三。结果</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/aea717ab4e694d36e2cab628e6366b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q9fnXqdAzSwzpm9xSPSgEg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">请注意附加的关联列，以及代替NaN的空列表</p></figure><p id="d72c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们做到了！有可能的方法可以进一步收紧，所以请在你的评论中让我知道。</p></div></div>    
</body>
</html>