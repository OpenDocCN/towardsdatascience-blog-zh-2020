<html>
<head>
<title>Scaling up real-time inference with online regression and more</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用在线回归等功能扩展实时推理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/scaling-up-real-time-inference-with-online-regression-and-more-902a939c171c?source=collection_archive---------53-----------------------#2020-05-19">https://towardsdatascience.com/scaling-up-real-time-inference-with-online-regression-and-more-902a939c171c?source=collection_archive---------53-----------------------#2020-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="be26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据数据做出正确的决策意味着成功或失败。这就是为什么谷歌的<a class="ae ko" href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36500.pdf" rel="noopener ugc nofollow" target="_blank">团队试图实现“更多、更好、更快的实验”，也是为什么他们和许多其他公司投资开发内部实验平台(</a><a class="ae ko" href="https://exp-platform.com/" rel="noopener ugc nofollow" target="_blank">微软的 ExP </a>、<a class="ae ko" href="https://netflixtechblog.com/its-all-a-bout-testing-the-netflix-experimentation-platform-4e1ca458c15" rel="noopener ugc nofollow" target="_blank">网飞的闪亮</a>、<a class="ae ko" href="https://eng.uber.com/xp/" rel="noopener ugc nofollow" target="_blank">优步的 XP </a>、<a class="ae ko" href="https://arxiv.org/abs/1710.08217" rel="noopener ugc nofollow" target="_blank"> Booking.com 的 ET </a>，不胜枚举)。基础是 A/B 测试，现在这种测试被大规模实时地广泛进行。</p><p id="9d0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些天来，我们的胃口已经超出了 A/B 测试。科学家们面临着挑战，要在越来越复杂的情况下运用更先进的技术来改进决策。作为一个个人例子，我帮助将微软的 CUPED 引入 Booking.com 的 ET 以增强实验能力。这有助于更好地做出决策，但我并没有快速或廉价地做出决策。它是每天使用整个数据集计算的，随着数据的增长，成本会越来越高。另一个例子是<a class="ae ko" href="https://netflixtechblog.com/reimagining-experimentation-analysis-at-netflix-71356393af21" rel="noopener ugc nofollow" target="_blank">网飞的 XP </a>允许数据科学家部署任意的统计函数。同样的规模挑战也适用，因此他们有一个专门的数学工程团队来编写高性能代码并减少代价高昂的瓶颈(例如，分位数自举和 OLS 回归)。</p><p id="6a49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">巧合的是，这篇文章讨论了回归(CUPED 也基于此)对决策的价值，如何将结果扩展到大量数据并实时显示，以及一个简单的基础如何为实时统计方法的宝库铺平道路。下面是我们将涉及的技术部分的总结。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/a32e39cf465de55d625b06090c70b890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2dIrIJ8qJ3iaDSSgou0HEg.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">实时回归方法概述</p></figure><p id="9b2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">附注:我正在分享这个问题统计方面的一个解决方案。首先，虽然我找不到它们，但其他解决方案可能已经存在了(我的意思是，网飞团队说它是可用的)。如果你知道并且有能力，我很乐意在评论中与你分享！另一件事是，这并没有涵盖问题的工程方面。为了大规模成功实施，您需要将了解这里发生的事情的数据科学家与知道如何适当地传输和存储数据的工程师配对。</p><h1 id="5940" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">回归</h1><p id="227e" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">普通最小二乘回归(从现在开始我就称之为“回归”)是建模连续数据最广泛使用的方法之一。它在机器学习中被大量使用，但这不是我们在这里的目的。我们在这里用它进行统计推断。如果你不太熟悉这种使用方式，它应该会让你兴奋地了解到回归涵盖了许多有用的统计技术测试，从简单的<em class="lf"> t </em>测试到结构方程建模。最后会有更多的介绍。基本上，在你的推理工具包中加入回归可以极大地扩展你做出正确决策的范围。</p><p id="da57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">警告:我在故意推销回归的价值。然而，这种价值来自于对数据和结果的假设，这些假设对未经培训的用户构成了严重的风险。如果你对使用基于回归的方法进行推断感兴趣，一定要和一个了解风险的统计学家讨论。如果你不这样做，你最终可能会做出更糟糕的决定！</em></p><p id="8401" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是，如何扩展回归并不像使用简单的技术那样显而易见。这当然是它没有被大规模利用的一个原因。因此，让我们开始研究如何扩展我们的回归工具包，以便大规模、实时地工作！</p><h1 id="7d0c" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">让它发挥作用的洞察力</h1><h2 id="796e" class="mj lh it bd li mk ml dn lm mm mn dp lq kb mo mp lu kf mq mr ly kj ms mt mc mu bi translated">压缩是关键</h2><p id="5288" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">有效处理大规模数据通常涉及数据压缩。例如<em class="lf">t</em>——测试不需要每个数据点。他们只需要跟踪几个数字:组均值、方差和样本量(<a class="ae ko" href="https://drsimonj.svbtle.com/big-data-solutions-a-b-t-test" rel="noopener ugc nofollow" target="_blank">个人演示贴</a>)。类似地，分位数自举可以用分桶数据来完成(<a class="ae ko" href="https://netflixtechblog.com/data-compression-for-large-scale-streaming-experimentation-c20bfab8b9ce" rel="noopener ugc nofollow" target="_blank">网飞邮报</a>)。如果您可以使用可以实时更新的压缩数据集，那么您就成功了！</p><p id="980f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实证明我们可以利用这个来回归。无论您的总数据有多大，回归只需要一些汇总统计数据，这些统计数据可以随着新数据的到来而更新。</p><h2 id="a12f" class="mj lh it bd li mk ml dn lm mm mn dp lq kb mo mp lu kf mq mr ly kj ms mt mc mu bi translated">回归只需要协方差和 n</h2><p id="0ab2" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated"><strong class="js iu">所有一个回归需要的是</strong> <a class="ae ko" href="https://en.wikipedia.org/wiki/Covariance_matrix" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">协方差矩阵</strong> </a> <strong class="js iu">和样本大小。</strong></p><p id="b2f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">拥有 25 个指标和 1 亿个数据点。见鬼，10 亿个数据点？！没问题。你只需要 326 个数字。指标的 25x25 协方差矩阵(嗯，它的各种变换)，它是对称的，因此有 325 个唯一的数字，一个数字代表样本大小。</p><p id="248d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们知道了这一点，这篇文章的其余部分将介绍如何实现实时回归，然后讨论这种方法可能带来的其他好处。</p><h1 id="271a" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">让它工作</h1><h2 id="6fa7" class="mj lh it bd li mk ml dn lm mm mn dp lq kb mo mp lu kf mq mr ly kj ms mt mc mu bi translated">用于回归的实时数据压缩</h2><p id="ae05" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated"><em class="lf">注意:我将使用 r 来演示这项技术。你可以在这里</em> <a class="ae ko" href="https://github.com/drsimonj/OnlineRegression" rel="noopener ugc nofollow" target="_blank"> <em class="lf">找到我的 GitHub 上的完整代码</em> </a> <em class="lf">。</em></p><p id="d16a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要协方差矩阵，但是随着数据的流入，使用中间对象更容易:<em class="lf">偏差叉积矩阵。</em>“偏差”指的是“与平均值的差异”,“叉积”是数值相乘的总和。因此，当一个新单元(例如，用户)的数据出现时，我们更新三样东西:样本大小、度量平均值(用于计算偏差)和偏差叉积矩阵。这里有一个总结:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mv"><img src="../Images/1ab0cb74b8549f885a1b6078b9dc2b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*05fCD9QxiwyNChLua8KaZg.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">当新实验单元的数据到达时，如何更新压缩数据</p></figure><p id="d8e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于那些渴望代码的人来说，我写了一个 R 函数<code class="fe mw mx my mz b">update_compression()</code>,当新单元的数据到达时，它会这样做。你可以在 GitHub repo 中找到它。除了一个矩阵转置(如果你愿意可以避免)，这都是基本的数学。</p><p id="acd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们通过一个简单的数据集来看看它的实际应用:</p><pre class="kq kr ks kt gt na mz nb nc aw nd bi"><span id="18e1" class="mj lh it mz b gy ne nf l ng nh"># A simple data set of 10 observations<br/>xs</span><span id="7828" class="mj lh it mz b gy ni nf l ng nh">#&gt;              x1       x2        x3<br/>#&gt;  [1,] 0.1366358 5.719901 11.807291<br/>#&gt;  [2,] 2.0323437 4.750903  6.992279<br/>#&gt;  [3,] 1.2030423 5.903466  8.910174<br/>#&gt;  [4,] 1.9078714 5.649198  7.488551<br/>#&gt;  [5,] 2.6487667 7.465745 11.340035<br/>#&gt;  [6,] 4.5719305 7.744037 10.077654<br/>#&gt;  [7,] 0.7048246 4.347754  7.146864<br/>#&gt;  [8,] 2.5375564 6.234913  9.964397<br/>#&gt;  [9,] 1.2603890 4.258484  7.630200<br/>#&gt; [10,] 1.4273975 7.329029 12.639481</span></pre><p id="a40b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设第一个单元(第一行)到达，我们运行我们的函数。结果是:</p><pre class="kq kr ks kt gt na mz nb nc aw nd bi"><span id="a644" class="mj lh it mz b gy ne nf l ng nh"><em class="lf"># Compress first row of data</em><br/>compressed_d &lt;- update_compression(xs[1,])<br/>compressed_d</span><span id="8042" class="mj lh it mz b gy ni nf l ng nh">#&gt; $n<br/>#&gt; [1] 1<br/>#&gt; <br/>#&gt; $means<br/>#&gt;         x1         x2         x3 <br/>#&gt;  0.1366358  5.7199010 11.8072912 <br/>#&gt; <br/>#&gt; $dcrossp<br/>#&gt;      [,1] [,2] [,3]<br/>#&gt; [1,]    0    0    0<br/>#&gt; [2,]    0    0    0<br/>#&gt; [3,]    0    0    0</span></pre><p id="6b76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这表明我们的样本大小为 1，每个指标的平均值就是数据点本身。叉积都是 0，只有 1 个数据点。</p><p id="4751" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在每一行都按顺序显示。最后的结果是什么？</p><pre class="kq kr ks kt gt na mz nb nc aw nd bi"><span id="2365" class="mj lh it mz b gy ne nf l ng nh"># Iteratively update the compression with remaining data<strong class="mz iu"><br/>for</strong> (i <strong class="mz iu">in</strong> 2:<!-- -->nrow(xs)<!-- -->) {<br/>  compressed_d &lt;- update_compression(xs[i,], compressed_d)<br/>}</span><span id="b4c1" class="mj lh it mz b gy ni nf l ng nh">compressed_d</span><span id="29c4" class="mj lh it mz b gy ni nf l ng nh">#&gt; $n<br/>#&gt; [1] 10<br/>#&gt; <br/>#&gt; $means<br/>#&gt;       x1       x2       x3 <br/>#&gt; 1.843076 5.940343 9.399693 <br/>#&gt; <br/>#&gt; $dcrossp<br/>#&gt;           [,1]      [,2]      [,3]<br/>#&gt; [1,] 13.747618  8.726897  1.679592<br/>#&gt; [2,]  8.726897 14.509862 18.319109<br/>#&gt; [3,]  1.679592 18.319109 38.730283</span></pre><p id="bad6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">样本量为 10。滴答！手段呢？</p><pre class="kq kr ks kt gt na mz nb nc aw nd bi"><span id="e812" class="mj lh it mz b gy ne nf l ng nh">apply(xs, 2, mean)</span><span id="3754" class="mj lh it mz b gy ni nf l ng nh">#&gt;       x1       x2       x3 <br/>#&gt; 1.843076 5.940343 9.399693</span></pre><p id="b565" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">滴答！</p><p id="bd1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以及偏差叉积矩阵？我在回购协议中留下了一些<a class="ae ko" href="https://github.com/drsimonj/OnlineRegression/blob/master/notebook.Rmd#L112-L119" rel="noopener ugc nofollow" target="_blank">更简单的检查方法。如果你知道你的矩阵代数，我们可以这样验证它:</a></p><pre class="kq kr ks kt gt na mz nb nc aw nd bi"><span id="1f14" class="mj lh it mz b gy ne nf l ng nh">xs_d &lt;- sweep(xs, 2, apply(xs, 2, mean)) # all deviation scores<br/>t(xs_d) %*% xs_d</span><span id="45dc" class="mj lh it mz b gy ni nf l ng nh">#&gt;           x1        x2        x3<br/>#&gt; x1 13.747618  8.726897  1.679592<br/>#&gt; x2  8.726897 14.509862 18.319109<br/>#&gt; x3  1.679592 18.319109 38.730283</span></pre><p id="7266" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完美！</p><p id="9d07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以在单位进入我们的实验时更新高度压缩的数据。这是让事情实时、大规模运转的关键。</p><h2 id="f878" class="mj lh it bd li mk ml dn lm mm mn dp lq kb mo mp lu kf mq mr ly kj ms mt mc mu bi translated">从压缩数据回归</h2><p id="d7d8" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">我们现在需要的是根据请求从压缩数据中获得回归结果。下面是如何发生这种情况的总结。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nj"><img src="../Images/091063c136dd338283f33f917100d454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gCqfmOb0t9aoCzBZWhfSlw.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">从压缩数据(离差叉积矩阵和样本大小)到最终回归结果的进展总结</p></figure><p id="be33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我为此写了另一个 R 函数，<code class="fe mw mx my mz b">compressed_regression()</code>，你也可以在这里的 repo】中找到它。请注意，这比数据压缩更复杂。你需要非常了解矩阵形式的回归，这样才容易理解。存在矩阵运算(例如，<code class="fe mw mx my mz b">%*%</code>的乘法运算、<code class="fe mw mx my mz b">t()</code>的变换运算和<code class="fe mw mx my mz b">solve()</code>的求逆运算)以及从 t 分布中获取 p 值的需求(使用<code class="fe mw mx my mz b">pt()</code>)。不过，对于数据科学家和工程师来说，实现这些应该不是问题。</p><p id="5b7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无论如何，让我们来测试一下。假设我们有之前的压缩数据，并想在 x2 和 x3 上回归 x1:</p><pre class="kq kr ks kt gt na mz nb nc aw nd bi"><span id="6c88" class="mj lh it mz b gy ne nf l ng nh">compressed_regression(<br/>  compressed_d$dcrossp,<br/>  compressed_d$n<br/>)</span><span id="a084" class="mj lh it mz b gy ni nf l ng nh">#&gt;   coefficient standard_error   t_value     p_value<br/>#&gt; 1   1.3571198      0.2666634  5.089261 0.001416338<br/>#&gt; 2  -0.5985403      0.1632186 -3.667107 0.007994773</span></pre><p id="8c5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这与 R 的内置回归模型相比如何？</p><pre class="kq kr ks kt gt na mz nb nc aw nd bi"><span id="76e7" class="mj lh it mz b gy ne nf l ng nh">summary(lm(x1 ~ x2 + x3))$coefficients[-1,]</span><span id="3d97" class="mj lh it mz b gy ni nf l ng nh">#&gt;      Estimate Std. Error   t value    Pr(&gt;|t|)<br/>#&gt; x2  1.3571198  0.2666634  5.089261 0.001416338<br/>#&gt; x3 -0.5985403  0.1632186 -3.667107 0.007994773</span></pre><p id="6394" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完美！对于实现来说，这就差不多了。</p><p id="5a27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">注意:我的方法要求在计算中使用截距，但计算不准确。为什么？计算它需要额外的工作，但我从未见过截距在推理/假设测试(相对于预测)中有用。如果您想试着弄清楚它，您将想要开始修改代码</em> <a class="ae ko" href="https://github.com/drsimonj/OnlineRegression/blob/master/notebook.Rmd#L180-L181" rel="noopener ugc nofollow" target="_blank"> <em class="lf">在这里</em> </a> <em class="lf">添加占位符值。</em></p><h1 id="952b" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">回归和超越！</h1><p id="7ade" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">随着实时回归成为一种选择，它还打开了什么？下图显示了一些统计技术，这些技术可以从这里讨论的完全相同的压缩数据中进行。我不打算解释它们或它们的用途，但我相信有统计学背景的读者会很兴奋。不过，如果你有问题，请提出来，因为这些答案可能会成为一篇好的后续文章。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a68cdad0b607d0bc025b913b213329ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*nByPCohFoU0qTAv0MHdocA.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">只是一些统计技术，可以使用我们的压缩数据</p></figure><p id="5887" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于推理和数据探索，大规模使用这些方法是非常令人兴奋的事情！如果你想探索一些更复杂的方法，我可以推荐用接受协方差矩阵作为输入的<a class="ae ko" href="http://lavaan.ugent.be/tutorial/cov.html" rel="noopener ugc nofollow" target="_blank"> lavaan 包</a>在 R 中进行测试。</p><p id="f9ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯，我就知道这么多了。感谢阅读，我希望这对你有用。如果你有问题，有改进的想法，或者你想更进一步，请评论！</p></div></div>    
</body>
</html>