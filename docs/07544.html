<html>
<head>
<title>3 ways to create a Machine Learning model with Keras and TensorFlow 2.0 (Sequential, Functional, and Model Subclassing)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Keras和TensorFlow 2.0创建机器学习模型的3种方法(顺序、函数和模型子类化)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-ways-to-create-a-machine-learning-model-with-keras-and-tensorflow-2-0-de09323af4d3?source=collection_archive---------13-----------------------#2020-06-07">https://towardsdatascience.com/3-ways-to-create-a-machine-learning-model-with-keras-and-tensorflow-2-0-de09323af4d3?source=collection_archive---------13-----------------------#2020-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e731" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为初学者构建机器学习模型的分步教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9b757560f1f4540ad6aafbf69ff39ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXrGNFfiUVg9vWfArfem7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Keras和TensorFlow 2.0创建机器学习模型的3种方法</p></figure><p id="45df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我之前的文章<a class="ae lu" rel="noopener" target="_blank" href="/the-googles-7-steps-of-machine-learning-in-practice-a-tensorflow-example-for-structured-data-96ccbb707d77"> Google机器学习实践的7个步骤:结构化数据的TensorFlow示例</a>中，我提到了用Keras和TensorFlow 2.0实现机器学习模型的3种不同方法</p><ul class=""><li id="2a8c" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><strong class="la iu">顺序模型</strong>是在TensorFlow 2.0中启动和运行Keras的最简单方法</li><li id="eb86" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu">功能API </strong>用于更复杂的模型，尤其是具有多个输入或输出的模型。</li><li id="ce76" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu">模型子类化</strong>是完全可定制的，使我们能够实现我们自己定制的模型前向传递</li></ul><p id="ce10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将学习如何用三种不同的方法建立一个机器学习模型，以及如何为我们的项目选择正确的方法。</p><h1 id="2503" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">环境设置、源代码和数据集准备</h1><p id="aea5" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">为了运行本教程，您需要安装</p><blockquote class="ng"><p id="d743" class="nh ni it bd nj nk nl nm nn no np lt dk translated">TensorFlow 2，numpy，pandas，sklean，matplotlib</p></blockquote><p id="6695" class="pw-post-body-paragraph ky kz it la b lb nq ju ld le nr jx lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">它们都可以直接安装在vis PyPI上，我强烈建议创建一个新的虚拟环境。最佳实践是避免使用<strong class="la iu"> <em class="nv"> base(root) </em> </strong>，因为这可能会破坏您的系统。</p><p id="a7e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有关创建Python虚拟环境的教程，您可以在这里查看:</p><div class="nw nx gp gr ny nz"><a rel="noopener follow" target="_blank" href="/create-virtual-environment-using-virtualenv-and-add-it-to-jupyter-notebook-6e1bf4e03415"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">使用“virtualenv”创建虚拟环境，并将其添加到Jupyter笔记本中</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">你是机器学习工程师，正在使用Python和Jupyter Notebook吗？在这篇文章中，你会看到为什么…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">towardsdatascience.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a href="https://medium.com/analytics-vidhya/create-virtual-environment-using-conda-and-add-it-to-jupyter-notebook-d319a81dfd1" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">使用“conda”创建虚拟环境，并将其添加到Jupyter笔记本中</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">你正在使用anaconda和使用Jupyter Notebook和Python吗？在这篇文章中，你将看到如何创建虚拟的…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">medium.com</p></div></div><div class="oi l"><div class="oo l ok ol om oi on ks nz"/></div></div></a></div><h2 id="74f6" class="op mk it bd ml oq or dn mp os ot dp mt lh ou ov mv ll ow ox mx lp oy oz mz pa bi translated">源代码</h2><p id="8b92" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">这是一个循序渐进的教程，所有的说明都在这篇文章中。我已经把笔记本开源了，请查看最后的Github链接。</p><h2 id="3d28" class="op mk it bd ml oq or dn mp os ot dp mt lh ou ov mv ll ow ox mx lp oy oz mz pa bi translated">数据集准备</h2><p id="337d" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">本教程使用<a class="ae lu" href="https://en.wikipedia.org/wiki/Iris_flower_data_set" rel="noopener ugc nofollow" target="_blank">安德森鸢尾花(iris) </a>数据集进行演示。该数据集包含五个属性下的一组150条记录:<em class="nv">萼片长度</em>、<em class="nv">萼片宽度</em>、<em class="nv">花瓣长度</em>、<em class="nv">花瓣宽度、</em>和<em class="nv">类</em>(从sklearn数据集称为<em class="nv">目标</em>)。</p><p id="6546" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，让我们导入库并从<strong class="la iu"> <em class="nv"> scikit-learn </em> </strong>库中获取虹膜数据集。你也可以从<a class="ae lu" href="https://archive.ics.uci.edu/ml/datasets/iris" rel="noopener ugc nofollow" target="_blank"> UCI虹膜数据集</a>下载。</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="7a8a" class="op mk it pc b gy pg ph l pi pj">import tensorflow as tf<br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from sklearn.datasets import load_iris<br/>from sklearn.model_selection import train_test_split</span><span id="6d19" class="op mk it pc b gy pk ph l pi pj"><strong class="pc iu">iris = load_iris()</strong></span></pre><p id="9558" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了研究数据，让我们将数据加载到一个数据帧中</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="409b" class="op mk it pc b gy pg ph l pi pj"># Load data into a DataFrame<br/><strong class="pc iu">df = pd.DataFrame(iris.data, columns=iris.feature_names)<br/></strong># Convert datatype to float<br/><strong class="pc iu">df = df.astype(float)<br/></strong># append "target" and name it "label"<br/><strong class="pc iu">df['label'] = iris.target<br/></strong># Use string label instead<br/><strong class="pc iu">df['label'] = df.label.replace(dict(enumerate(iris.target_names)))</strong></span></pre><p id="2fcb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并且<code class="fe pl pm pn pc b">df</code>应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/5a9a8875ff94f622c7223d52e3ee25c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QpW3Y-gxcxy9xfbPub0TSw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行<code class="fe pl pm pn pc b">df.head()</code>预览虹膜数据</p></figure><p id="58d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们注意到<strong class="la iu"> <em class="nv">标签</em> </strong>列是一个分类特征，需要将其转换成一个热编码。否则，我们的机器学习算法将无法直接将其作为输入。</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="065d" class="op mk it pc b gy pg ph l pi pj"># label -&gt; one-hot encoding<br/><strong class="pc iu">label = pd.get_dummies(df['label'])<br/>label.columns = ['label_' + str(x) for x in label.columns]</strong><br/><strong class="pc iu">df = pd.concat([df, label], axis=1)</strong></span><span id="ba3f" class="op mk it pc b gy pk ph l pi pj"># drop old label<br/>df.drop(['label'], axis=1, inplace=True)</span></pre><p id="499d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，<code class="fe pl pm pn pc b">df</code>应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/fdd8e015a05a0cc6a0b011e083332c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HoEIxzGmPbm-PaNFTxpoyA.png"/></div></div></figure><p id="b24b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，让我们创建<code class="fe pl pm pn pc b">X</code>和<code class="fe pl pm pn pc b">y</code>。Keras和TensorFlow 2.0只接受Numpy数组作为输入，所以我们必须将DataFrame转换回Numpy数组。</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="904a" class="op mk it pc b gy pg ph l pi pj"># Creating X and y</span><span id="2720" class="op mk it pc b gy pk ph l pi pj"><strong class="pc iu">X = df[['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)']]</strong><br/># Convert DataFrame into np array<br/><strong class="pc iu">X = np.asarray(X)</strong></span><span id="8442" class="op mk it pc b gy pk ph l pi pj"><strong class="pc iu">y = df[['label_setosa', 'label_versicolor', 'label_virginica']]<br/></strong># Convert DataFrame into np array<br/><strong class="pc iu">y = np.asarray(y)</strong></span></pre><p id="d3cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，让我们使用来自<strong class="la iu"> sklearn </strong>库的<code class="fe pl pm pn pc b"><strong class="la iu">train_test_split()</strong></code> <strong class="la iu"> </strong>将数据集拆分成训练集(75%)和测试集(25%)。</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="0d64" class="op mk it pc b gy pg ph l pi pj">X_train, X_test, y_train, y_test<strong class="pc iu"> = train_test_split(<br/>  X,<br/>  Y,<br/>  test_size=0.25<br/>)</strong></span></pre><p id="a35b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了！我们的数据已经准备好建立一个机器学习模型。</p><h1 id="5a0e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">1.顺序模型</h1><p id="9f3a" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">顺序模型是层的线性堆叠。创建顺序模型有两种方法</p><ul class=""><li id="887c" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">将层列表传递给构造函数</li><li id="417b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">只需通过<code class="fe pl pm pn pc b">.add()</code>方法添加图层:</li></ul><p id="2db1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们继续建立一个具有3个密集层的神经网络。</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="bc07" class="op mk it pc b gy pg ph l pi pj">from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import Dense</span><span id="0400" class="op mk it pc b gy pk ph l pi pj"># Passing a list of layers to the constructor<br/>model = Sequential(<strong class="pc iu">[<br/>    Dense(5, activation='relu', input_shape=(4,)),<br/>    Dense(10, activation='relu'),<br/>    Dense(3, activation='softmax'),<br/>]</strong>)</span><span id="cd5c" class="op mk it pc b gy pk ph l pi pj">model.summary()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/838882cf359f166ba4b210f5cd62d56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UgA9ZPnCZQ-ayjlNx_6WYw.png"/></div></div></figure><p id="3aba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过<code class="fe pl pm pn pc b">.add()</code>方法，以上与以下相同</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="7743" class="op mk it pc b gy pg ph l pi pj"># Adding layer via add() method<br/>model = Sequential()<br/>model.<strong class="pc iu">add(Dense(5, activation='relu', input_shape=(4,)))</strong><br/>model.<strong class="pc iu">add(Dense(10, activation='relu'))</strong><br/>model.<strong class="pc iu">add(Dense(3, activation='softmax'))</strong></span><span id="65f4" class="op mk it pc b gy pk ph l pi pj">model.summary()</span></pre><p id="07ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顺序模型需要知道它应该期望什么样的输入形状。因此，顺序模型中的第一层需要接收关于其输入形状的信息，这通常通过指定<code class="fe pl pm pn pc b">input_shape</code>参数来完成。</p><h2 id="fcad" class="op mk it bd ml oq or dn mp os ot dp mt lh ou ov mv ll ow ox mx lp oy oz mz pa bi translated"><strong class="ak"> 1.1训练一个序列模型</strong></h2><p id="b14f" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">为了训练一个序列模型，我们首先必须使用<code class="fe pl pm pn pc b">model.compile()</code>配置我们的模型，参数如下:</p><ul class=""><li id="bdb9" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">使用优化器RMSProps ( <code class="fe pl pm pn pc b">rmsprop</code>)</li><li id="7146" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">对于我们的<strong class="la iu"> <em class="nv">多类分类</em> </strong>问题，使用分类交叉熵损失函数(<code class="fe pl pm pn pc b">categorical_crossentropy</code></li><li id="cf1d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">为简单起见，使用<code class="fe pl pm pn pc b">accuracy</code>作为我们在训练和测试期间评估模型的评估指标。</li></ul><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="89fd" class="op mk it pc b gy pg ph l pi pj">model.compile(<br/>    <strong class="pc iu">optimizer='rmsprop',</strong><br/>    <strong class="pc iu">loss='categorical_crossentropy',</strong><br/>    <strong class="pc iu">metrics=['accuracy']</strong><br/>)</span></pre><p id="4e80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们可以调用<code class="fe pl pm pn pc b">model.fit()</code>来训练我们的模型</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="499a" class="op mk it pc b gy pg ph l pi pj">history = <strong class="pc iu">model.fit</strong>(X_train, y_train,<br/>                    batch_size= 64,<br/>                    epochs= 30,<br/>                    validation_split=0.2<br/>                   )</span></pre><p id="5d93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一切顺利，我们应该得到如下输出</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="d809" class="op mk it pc b gy pg ph l pi pj">Train on 89 samples, validate on 23 samples<br/>Epoch 1/30<br/>89/89 [==============================] - 1s 13ms/sample - loss: 1.4717 - accuracy: 0.3258 - val_loss: 1.1884 - val_accuracy: 0.3478<br/>Epoch 2/30<br/>89/89 [==============================] - 0s 465us/sample - loss: 1.4152 - accuracy: 0.3258 - val_loss: 1.1683 - val_accuracy: 0.3478<br/>Epoch 3/30<br/>89/89 [==============================] - 0s 463us/sample - loss: 1.3836 - accuracy: 0.3258 - val_loss: 1.1503 - val_accuracy: 0.3478<br/>......<br/>......<br/>Epoch 30/30<br/>89/89 [==============================] - 0s 488us/sample - loss: 1.0734 - accuracy: 0.3258 - val_loss: 1.0290 - val_accuracy: 0.3478</span></pre><h2 id="c563" class="op mk it bd ml oq or dn mp os ot dp mt lh ou ov mv ll ow ox mx lp oy oz mz pa bi translated">1.2模型评估</h2><p id="0f3f" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">一旦训练完成，就该看看模型是否适合模型评估了。模型评估通常包括</p><ol class=""><li id="c30b" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt pr mb mc md bi translated">绘制<strong class="la iu">损失</strong>和<strong class="la iu">准确度</strong>指标的进度</li><li id="cf35" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt pr mb mc md bi translated">用从未用于训练的数据来测试我们的模型。这就是我们之前搁置的测试数据集<code class="fe pl pm pn pc b">X_test</code>发挥作用的地方。</li></ol><p id="5d42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个函数<code class="fe pl pm pn pc b">plot_metric()</code>来绘制指标。</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="2aea" class="op mk it pc b gy pg ph l pi pj">%matplotlib inline<br/>%config InlineBackend.figure_format = 'svg'<br/>def plot_metric(history, metric):<br/>    train_metrics = history.history[metric]<br/>    val_metrics = history.history['val_'+metric]<br/>    epochs = range(1, len(train_metrics) + 1)<br/>    plt.plot(epochs, train_metrics, 'bo--')<br/>    plt.plot(epochs, val_metrics, 'ro-')<br/>    plt.title('Training and validation '+ metric)<br/>    plt.xlabel("Epochs")<br/>    plt.ylabel(metric)<br/>    plt.legend(["train_"+metric, 'val_'+metric])<br/>    plt.show()</span></pre><p id="53f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过运行<code class="fe pl pm pn pc b">plot_metric(history, 'loss')</code>来绘制损失进度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/79756e3af781c88c74209f1c77e6429b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ykXYmY5xRcR0EPK8F9j-5Q.png"/></div></div></figure><p id="e144" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过运行<code class="fe pl pm pn pc b">plot_metric(history, 'accuracy')</code>绘制精度进度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/e2377eb47c6a7affe8ea1a913e8a1d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uKTU37LVCiamry-N8ikYZQ.png"/></div></div></figure><p id="e28a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据测试数据集测试我们的模型</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="d31a" class="op mk it pc b gy pg ph l pi pj">model.<strong class="pc iu">evaluate</strong>(x = <strong class="pc iu">X_test</strong>,y = <strong class="pc iu">y_test</strong>)</span></pre><p id="0350" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该得到一个具有损耗和精度的输出，如下所示:</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="eed3" class="op mk it pc b gy pg ph l pi pj">38/1 [===] - 0s 139us/sample - <strong class="pc iu">loss: 0.9356</strong> - <strong class="pc iu">accuracy: 0.7105</strong></span><span id="30d0" class="op mk it pc b gy pk ph l pi pj">[0.9538187102267617, 0.7105263]</span></pre><h2 id="b2c9" class="op mk it bd ml oq or dn mp os ot dp mt lh ou ov mv ll ow ox mx lp oy oz mz pa bi translated">1.3何时使用顺序模型</h2><p id="5e78" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">顺序模型适用于<strong class="la iu">简单的层堆叠</strong>，其中每层都有<strong class="la iu">一个输入和一个输出</strong>。</p><p id="db61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个顺序模型是<strong class="la iu">不合适</strong>当[1]:</p><ul class=""><li id="56ac" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">您的模型有多个输入或多个输出</li><li id="341d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">您的任何图层都有多个输入或多个输出</li><li id="08c6" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">您需要进行图层共享</li><li id="b9d2" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">您需要非线性拓扑(例如，剩余连接、多分支模型)</li></ul><h1 id="2a32" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">2.功能API</h1><p id="a6dd" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">Keras functional API提供了一种更加灵活的定义模型的方式。特别是，它允许我们定义多个输入或输出模型以及共享层的模型。</p><p id="d28e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用函数式API创建相同的神经网络</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="caf9" class="op mk it pc b gy pg ph l pi pj">from tensorflow.keras.models import Model<br/>from tensorflow.keras.layers import Input, Dense</span><span id="e372" class="op mk it pc b gy pk ph l pi pj"># This returns a tensor<br/><strong class="pc iu">inputs = Input(shape=(4,))</strong></span><span id="6ecd" class="op mk it pc b gy pk ph l pi pj"># A layer instance is callable on a tensor, and returns a tensor<br/><strong class="pc iu">x = Dense(5, activation='relu')(inputs)<br/>x = Dense(10, activation='relu')(x)<br/>outputs = Dense(3, activation='softmax')(x)</strong></span><span id="3283" class="op mk it pc b gy pk ph l pi pj"># This creates a model that includes<br/># the Input layer and three Dense layers<br/><strong class="pc iu">model = Model(inputs=inputs, outputs=outputs)</strong></span><span id="0ccd" class="op mk it pc b gy pk ph l pi pj">model.summary()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/393b6c6034cf077479b0da80b003b6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PH_Kio_7knvwToxGxlYLZA.png"/></div></div></figure><p id="b917" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在函数式API中:</p><ul class=""><li id="c370" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">每一层实例都是<strong class="la iu"> <em class="nv">上一个可调用的张量</em> </strong>，而<strong class="la iu"> <em class="nv">则返回一个张量</em> </strong></li><li id="acf2" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe pl pm pn pc b">Input()</code>用于定义以输入形状为自变量的输入层<code class="fe pl pm pn pc b"><strong class="la iu">shape=(4,)</strong></code></li><li id="2459" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">在<code class="fe pl pm pn pc b">Model()</code>中我们只需要引用<code class="fe pl pm pn pc b">inputs</code>和<code class="fe pl pm pn pc b">outputs</code>张量</li></ul><h2 id="05a1" class="op mk it bd ml oq or dn mp os ot dp mt lh ou ov mv ll ow ox mx lp oy oz mz pa bi translated"><strong class="ak"> 2.1训练一个功能API模型</strong></h2><p id="5280" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">功能API模型可以像顺序模型一样被训练。</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="f7c8" class="op mk it pc b gy pg ph l pi pj"># First configure model using model.compile()<br/>model.compile(<br/>    optimizer='rmsprop',<br/>    loss='categorical_crossentropy',<br/>    metrics=['accuracy']<br/>)</span><span id="3ca8" class="op mk it pc b gy pk ph l pi pj"># Then, train the model with fit()<br/>history = model.fit(X_train, y_train,<br/>                    batch_size= 64,<br/>                    epochs= 30,<br/>                    validation_split=0.2<br/>                   )</span></pre><p id="3695" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一切顺利，我们应该得到如下输出</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="2959" class="op mk it pc b gy pg ph l pi pj">Train on 89 samples, validate on 23 samples<br/>Epoch 1/30<br/>89/89 [==============================] - 1s 10ms/sample - loss: 1.5887 - accuracy: 0.3596 - val_loss: 2.0215 - val_accuracy: 0.1739<br/>Epoch 2/30<br/>89/89 [==============================] - 0s 475us/sample - loss: 1.4872 - accuracy: 0.3596 - val_loss: 1.9218 - val_accuracy: 0.1739<br/>Epoch 3/30<br/>89/89 [==============================] - 0s 470us/sample - loss: 1.4204 - accuracy: 0.3596 - val_loss: 1.8256 - val_accuracy: 0.1739<br/>Epoch 4/30<br/>89/89 [==============================] - 0s 486us/sample - loss: 1.3627 - accuracy: 0.3596 - val_loss: 1.7535 - val_accuracy: 0.1739<br/>......<br/>......<br/>Epoch 30/30<br/>89/89 [==============================] - 0s 477us/sample - loss: 0.8373 - accuracy: 0.4719 - val_loss: 0.9029 - val_accuracy: 0.3043</span></pre><h2 id="bd19" class="op mk it bd ml oq or dn mp os ot dp mt lh ou ov mv ll ow ox mx lp oy oz mz pa bi translated">2.2模型评估</h2><p id="27c5" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">这个模型可以像我们在序列模型中所做的那样进行评估</p><p id="5e7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过运行<code class="fe pl pm pn pc b">plot_metric(history, 'loss')</code>绘制损失进度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/b01f0f25b6d738b33c549d3ad8bfa1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L3jAA96TKn3hD7C1QZwcHA.png"/></div></div></figure><p id="ab2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过运行<code class="fe pl pm pn pc b">plot_metric(history, 'accuracy')</code>绘制精度进度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/b786e1ead0bb183a6c9eec185b349ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vWxYGZWAMERhmpGN5Nv6VA.png"/></div></div></figure><p id="acad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据测试数据集测试我们的模型</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="3776" class="op mk it pc b gy pg ph l pi pj">model.<strong class="pc iu">evaluate</strong>(x = <strong class="pc iu">X_test</strong>,y = <strong class="pc iu">y_test</strong>)</span></pre><p id="f002" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该得到一个具有损耗和精度的输出，如下所示:</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="de45" class="op mk it pc b gy pg ph l pi pj">38/1 [===] - 0s 139us/sample - <strong class="pc iu">loss: 0.7776</strong> - <strong class="pc iu">accuracy: 0.6053</strong></span><span id="3d5f" class="op mk it pc b gy pk ph l pi pj">[0.8011450893000552, 0.6052632]</span></pre><h2 id="6cfc" class="op mk it bd ml oq or dn mp os ot dp mt lh ou ov mv ll ow ox mx lp oy oz mz pa bi translated">2.3多输入多输出模型</h2><p id="ed6e" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">具有多输入或多输出的模型是函数式API的良好用例。这里，我展示了3种不同的场景:</p><ul class=""><li id="4b29" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">具有2个输入和1个输出的模型</li><li id="62f0" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">具有1个输入和2个输出的模型</li><li id="7654" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">具有两个输入和两个输出的模型</li></ul><p id="0a59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">对于有2个输入和1个输出的模型。</strong>假设我们有用于鸢尾花分类的图像数据和结构化数据。我们想建立一个机器学习模型，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/35180a7a3cebf483760240a75f0f6a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g53L2TfbdLDzFTJTlCYsxg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">2输入1输出神经网络</p></figure><p id="a617" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数式API使得构建它变得很容易</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="558d" class="op mk it pc b gy pg ph l pi pj">from tensorflow.keras.layers import concatenate</span><span id="537b" class="op mk it pc b gy pk ph l pi pj"># 2 inputs, one structure data, the other image data<br/><strong class="pc iu">input_structure = Input(shape=(4,), name='input_structure')<br/>input_image = Input(shape=(256,), name='input_image')</strong></span><span id="97a4" class="op mk it pc b gy pk ph l pi pj"># middle layers<br/>x_1 = Dense(10, activation='relu')(input_structure)<br/>x_2 = Dense(100, activation='relu')(input_image)</span><span id="4aac" class="op mk it pc b gy pk ph l pi pj"><strong class="pc iu">c = concatenate([x_1, x_2])</strong></span><span id="8ded" class="op mk it pc b gy pk ph l pi pj">outputs = Dense(3, activation='sigmoid', name='outputs')(c)</span><span id="0201" class="op mk it pc b gy pk ph l pi pj">model = Model(<strong class="pc iu">inputs=[input_structure, input_image], outputs=outputs</strong>)</span><span id="22af" class="op mk it pc b gy pk ph l pi pj">model.summary()</span></pre><p id="e8e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了获得2个不同的输入，我们需要使用<code class="fe pl pm pn pc b"><strong class="la iu">concatenate([x_1, x_2])</strong></code>将它们连接起来。要定义一个有多个输入的模型，我们只需要指定一个输入列表<code class="fe pl pm pn pc b"><strong class="la iu">inputs=[input_structure, input_image]</strong></code>。</p><p id="4789" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果全部运行成功，我们应该得到如下摘要:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/d150ef756c003644448c1b48f7631b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kiZ9KYhTbte3ZilYBI6IQ.png"/></div></div></figure><p id="88de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">对于有1个输入和2个输出的模型。</strong>假设我们只有图像数据，任务是识别给定图像是否是花，如果是，是什么类型的鸢尾花？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/5dfc5f3a1823c0da44abd5b545ca0af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3iqPWQZDykNNWnQgD_knZg.png"/></div></div></figure><p id="67a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并用功能API来构建它</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="ce69" class="op mk it pc b gy pg ph l pi pj">from tensorflow.keras.layers import concatenate</span><span id="1292" class="op mk it pc b gy pk ph l pi pj"># only one input<br/><strong class="pc iu">input_image = Input(shape=(256,), name='input_image')</strong></span><span id="ca36" class="op mk it pc b gy pk ph l pi pj"># middle layer<br/>x = Dense(300, activation='relu')(input_image)</span><span id="adf7" class="op mk it pc b gy pk ph l pi pj"># output layser<br/>output_1 = Dense(1, activation='sigmoid', name='output_1')(x)<br/>output_2 = Dense(3, activation='softmax', name='output_2')(x)</span><span id="f406" class="op mk it pc b gy pk ph l pi pj">model = Model(inputs=input_image, <strong class="pc iu">outputs=[output_1, output_2]</strong>)</span><span id="3a03" class="op mk it pc b gy pk ph l pi pj">model.summary()</span></pre><p id="8cf5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了定义一个有多个输出的模型，我们只需要指定一个输出列表<code class="fe pl pm pn pc b"><strong class="la iu">outputs=[output_1, output_2]</strong></code> <strong class="la iu">。</strong></p><p id="8065" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一切顺利，我们应该会得到如下摘要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/8f62d7dc5d19913203b8c55ae8724e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JKJ_soAVEGNtu8vFvb6WkA.png"/></div></div></figure><p id="69a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">对于有2个输入和2个输出的模型。</strong>假设我们有结构化数据和图像数据。任务是识别图像中是否有鸢尾花，以及它是什么类型的鸢尾花。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/5068c5bbc1d525f6a894bdc0ed8f0063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LS3KVWlIbARPtYEt_oro-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">2个输入和2个输出</p></figure><p id="04ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了函数式API，构建它相当容易</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="593c" class="op mk it pc b gy pg ph l pi pj">from tensorflow.keras.layers import concatenate</span><span id="c908" class="op mk it pc b gy pk ph l pi pj"># 2 inputs, one structured data, the other image data<br/><strong class="pc iu">input_structured = Input(shape=(4,), name='input_structured')<br/>input_image = Input(shape=(256,), name='input_image')</strong></span><span id="171d" class="op mk it pc b gy pk ph l pi pj"># middle layers<br/>x_1 = Dense(10, activation='relu')(input_structure)<br/>x_2 = Dense(300, activation='relu')(input_image)</span><span id="fdb3" class="op mk it pc b gy pk ph l pi pj"><strong class="pc iu">c = concatenate([x_1, x_2])</strong></span><span id="70d4" class="op mk it pc b gy pk ph l pi pj"># output layser<br/><strong class="pc iu">output_1 = Dense(1, activation='sigmoid', name='output_1')(c)<br/>output_2 = Dense(3, activation='softmax', name='output_2')(c)</strong></span><span id="2381" class="op mk it pc b gy pk ph l pi pj">model = Model(<strong class="pc iu">inputs=[input_structured, input_image], outputs=[output_1, output_2]</strong>)</span><span id="c1c5" class="op mk it pc b gy pk ph l pi pj">model.summary()</span></pre><p id="e59c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要定义一个有多个输入和多个输出的模型，我们只需要使用<code class="fe pl pm pn pc b"><strong class="la iu">concatenate([x_1, x_2])</strong></code>连接输入，并指定输入和输出列表来建模<code class="fe pl pm pn pc b">Model(<strong class="la iu">inputs=[input_structured, input_image], outputs=[output_1, output_2]</strong>)</code>。</p><p id="5d81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一切顺利，我们应该会得到如下摘要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/cdfa5409ddcbe3bddf6990f66546a357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzPte0loKgfnL3wtTmfGOQ.png"/></div></div></figure><h2 id="b8f8" class="op mk it bd ml oq or dn mp os ot dp mt lh ou ov mv ll ow ox mx lp oy oz mz pa bi translated">2.4功能API中的共享层</h2><p id="e32c" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">函数式API的另一个好用途是使用共享层的模型。让我们来看看共享图层。</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="a639" class="op mk it pc b gy pg ph l pi pj">inputs = Input(shape=(4,))</span><span id="9f32" class="op mk it pc b gy pk ph l pi pj"># a layer instance is callable on a tensor, and returns a tensor<br/><strong class="pc iu">shared_layer = Dense(4, activation='relu')</strong></span><span id="7b38" class="op mk it pc b gy pk ph l pi pj"># Now we apply the layer three times<br/>x = <strong class="pc iu">shared_layer</strong>(inputs)<br/>x = <strong class="pc iu">shared_layer</strong>(x)<br/>x = <strong class="pc iu">shared_layer</strong>(x)<br/>x = <strong class="pc iu">shared_layer</strong>(x)</span><span id="cf3e" class="op mk it pc b gy pk ph l pi pj">predictions = Dense(3, activation='softmax')(x)</span><span id="0975" class="op mk it pc b gy pk ph l pi pj">model = Model(inputs=inputs, outputs=predictions)</span><span id="b487" class="op mk it pc b gy pk ph l pi pj">model.summary()</span></pre><p id="d9f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个层实例在张量上是可调用的，并返回一个张量，这就是我们如何创建一个共享层。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/1032026351b66df22e7e16a669838f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-R4kld4p85ZKKFR-MXRR0A.png"/></div></div></figure><h1 id="60ea" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">3.模型子类化</h1><p id="0c58" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">最后一种用Keras和TensorFlow 2.0实现机器学习模型的方法叫做<strong class="la iu">模型子类化</strong>。这种构建模型的方式为您提供了对模型的构造和操作的低级控制。</p><p id="7c40" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看如何使用它来建立我们的虹膜流量分类器。</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="fd52" class="op mk it pc b gy pg ph l pi pj">from tensorflow.keras.models import Model<br/>from tensorflow.keras.layers import Dense</span><span id="b9b5" class="op mk it pc b gy pk ph l pi pj">class <strong class="pc iu">CustomModel(Model)</strong>:<br/>    <br/>    def __init__(self, **kwargs):<br/>        super(CustomModel, self).__init__(**kwargs)<br/>        <strong class="pc iu">self.dense1 = Dense(5, activation='relu', )<br/>        self.dense2 = Dense(10, activation='relu')<br/>        self.dense3 = Dense(3, activation='softmax')</strong><br/>        <br/>    def call(self, <strong class="pc iu">inputs</strong>):<br/>        <strong class="pc iu">x = self.dense1(inputs)<br/>        x = self.dense2(x)<br/>        return self.dense3(x)</strong></span><span id="b9e5" class="op mk it pc b gy pk ph l pi pj">my_custom_model = CustomModel(name='my_custom_model')</span></pre><p id="cb94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个模型类<code class="fe pl pm pn pc b">CustomModel</code>与我们使用顺序模型和函数式API制作的模型相同。事实上，顺序模型和函数API都继承自<code class="fe pl pm pn pc b">Model</code>类。</p><p id="4678" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，<code class="fe pl pm pn pc b">CustomModel</code>继承自模型类。当模型子类化时要记住的基本结构是，我们在初始化器<code class="fe pl pm pn pc b">__init__()</code>中创建层，并在<code class="fe pl pm pn pc b">call()</code>方法中定义向前传递。</p><h2 id="e378" class="op mk it bd ml oq or dn mp os ot dp mt lh ou ov mv ll ow ox mx lp oy oz mz pa bi translated">3.1训练模型子类化模型</h2><p id="c079" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">可以像顺序模型和函数API一样训练模型子类模型。</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="cbc8" class="op mk it pc b gy pg ph l pi pj">my_custom_model.compile(optimizer='rmsprop',<br/>              loss='categorical_crossentropy',<br/>              metrics=['accuracy'])</span><span id="ea9d" class="op mk it pc b gy pk ph l pi pj">history = my_custom_model.fit(X_train, y_train,<br/>                    batch_size= 64,<br/>                    epochs= 30,<br/>                    validation_split=0.2)</span></pre><p id="4dec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一切运行顺利，您应该得到如下输出:</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="5d0e" class="op mk it pc b gy pg ph l pi pj">Train on 89 samples, validate on 23 samples<br/>Epoch 1/30<br/>89/89 [==============================] - 1s 13ms/sample - loss: 1.5281 - accuracy: 0.3596 - val_loss: 1.6140 - val_accuracy: 0.1739<br/>Epoch 2/30<br/>89/89 [==============================] - 0s 571us/sample - loss: 1.3818 - accuracy: 0.3596 - val_loss: 1.4869 - val_accuracy: 0.1739<br/>Epoch 3/30<br/>89/89 [==============================] - 0s 711us/sample - loss: 1.3231 - accuracy: 0.3596 - val_loss: 1.4209 - val_accuracy: 0.1739<br/>Epoch 4/30<br/>89/89 [==============================] - 0s 598us/sample - loss: 1.2934 - accuracy: 0.3596 - val_loss: 1.3799 - val_accuracy: 0.1739<br/>......<br/>......<br/>Epoch 30/30<br/>89/89 [==============================] - 0s 555us/sample - loss: 1.1350 - accuracy: 0.4831 - val_loss: 1.1362 - val_accuracy: 0.6087</span></pre><p id="5e92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也可以调用<code class="fe pl pm pn pc b">my_custom_model.summary()</code>来显示它的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/669d66f10d8644f3c5f9af86a9a4ffc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dtuiPfEnMbWTbAZQCXg75A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模型子类化摘要的输出</p></figure><h2 id="156c" class="op mk it bd ml oq or dn mp os ot dp mt lh ou ov mv ll ow ox mx lp oy oz mz pa bi translated">3.2模型评估</h2><p id="aee5" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">这个模型可以像我们在顺序模型和函数式API中那样进行评估。</p><p id="2e21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过运行<code class="fe pl pm pn pc b">plot_metric(history, 'loss')</code>来绘制损失进度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qe"><img src="../Images/0736bc2114cf4eb4c7cd2bf34a0cc892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXiZRK1oEAlSzBoCe3WsCQ.png"/></div></div></figure><p id="5d30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过运行<code class="fe pl pm pn pc b">plot_metric(history, 'accuracy')</code>绘制精度进度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qf"><img src="../Images/66c9b502471ec2a180fd27b0aab63b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*teO6rx5aB29IdMSCn8NIGg.png"/></div></div></figure><p id="a3ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据测试数据集测试我们的模型</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="d69a" class="op mk it pc b gy pg ph l pi pj">my_custom_model.<strong class="pc iu">evaluate</strong>(x = <strong class="pc iu">X_test</strong>,y = <strong class="pc iu">y_test</strong>)</span></pre><p id="41ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该得到一个具有损耗和精度的输出，如下所示:</p><pre class="kj kk kl km gt pb pc pd pe aw pf bi"><span id="7b47" class="op mk it pc b gy pg ph l pi pj">38/1 [===] - 0s 139us/sample - <strong class="pc iu">loss: 1.1417</strong> - <strong class="pc iu">accuracy: 0.4737</strong></span><span id="b5cd" class="op mk it pc b gy pk ph l pi pj">[1.1410379598015232, 0.47368422]</span></pre><h2 id="f8bf" class="op mk it bd ml oq or dn mp os ot dp mt lh ou ov mv ll ow ox mx lp oy oz mz pa bi translated">3.3什么时候使用模型子类化？</h2><p id="5efb" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">模型子类化为我们提供了对模型的构造和操作的低级控制。然而，它的灵活性给bug带来了更多的机会，而且比顺序模型和函数式API更难利用。模型子类化主要由研究人员用来实现奇异的架构或定制的层/模型，这是使用顺序模型和功能API不可能实现的。</p><p id="a454" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，尽管模型子类化使我们能够做任何事情，我还是建议只在你真正需要的时候才使用这种方法。</p><h1 id="ff52" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">就这样，接下来呢？</h1><p id="707d" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">本文是快速介绍，主要是给大家展示用Keras和TensorFlow 2实现一个机器学习模型的三种不同方式。我已经尽量避免了很多机器学习的概念和配置，让这个教程对于初学者来说尽可能的简单。</p><p id="f45b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请在我的Github 上查看<a class="ae lu" href="https://github.com/BindiChen/machine-learning" rel="noopener ugc nofollow" target="_blank">笔记本的源代码。</a></p><p id="ea27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在实际项目中，使用Keras和TensorFlow 2构建模型时，需要考虑更多的配置。例如，优化器、损失函数、评估指标、批量、验证分割等。另外，本教程只使用了<code class="fe pl pm pn pc b">Dense()</code>层，还没有提到任何关于深度学习的内容。</p><p id="0f70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是什么？既然有几个人问我超参数调优的问题，那我们下次就用网格搜索，随机搜索，超带算法做个教程吧。</p><p id="673e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你对机器学习的实用方面感兴趣，请继续关注。</p><h1 id="d292" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">参考</h1><ul class=""><li id="9d86" class="lv lw it la b lb nb le nc lh qg ll qh lp qi lt ma mb mc md bi translated">[1] <a class="ae lu" href="https://keras.io/guides/sequential_model/#when-to-use-a-sequential-model" rel="noopener ugc nofollow" target="_blank"> Keras官方文档:何时使用顺序模型</a></li><li id="3d43" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">[2] <a class="ae lu" href="https://keras.io/guides/functional_api/" rel="noopener ugc nofollow" target="_blank"> Keras官方文档:功能API </a></li></ul></div></div>    
</body>
</html>