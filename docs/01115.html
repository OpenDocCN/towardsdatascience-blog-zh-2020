<html>
<head>
<title>Dynamic Time Warping</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态时间扭曲</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dynamic-time-warping-3933f25fcdd?source=collection_archive---------0-----------------------#2020-02-01">https://towardsdatascience.com/dynamic-time-warping-3933f25fcdd?source=collection_archive---------0-----------------------#2020-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4460" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解释和代码实现</h2></div><p id="538b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">听起来像时间旅行或某种未来技术，然而，它不是。动态时间弯曲用于比较两个不同长度的数组或时间序列之间的相似性或计算它们之间的距离。</p><p id="7c1c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们想计算两个等长数组的距离:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="970c" class="ln lo it lj b gy lp lq l lr ls">a = [1, 2, 3]<br/>b = [3, 2, 2]</span></pre><p id="2b39" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">怎么做呢？一个显而易见的方法是以一对一的方式匹配<code class="fe lt lu lv lj b">a</code>和<code class="fe lt lu lv lj b">b</code>，并对每个分量的总距离求和。这听起来很容易，但是如果<code class="fe lt lu lv lj b">a</code>和<code class="fe lt lu lv lj b">b</code>的长度不同呢？</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6e85" class="ln lo it lj b gy lp lq l lr ls">a = [1, 2, 3]<br/>b = [2, 2, 2, 3, 4]</span></pre><p id="3b7b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如何将它们搭配起来？哪个应该映射到哪个？为了解决这个问题，出现了动态时间扭曲。正如它的名字所表明的，扭曲系列，使他们能够匹配。</p><h1 id="f666" class="lw lo it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用例</h1><p id="c2a2" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在深入研究这个算法之前，你可能会问它有用吗？我们真的需要比较两个不等长时间序列之间的距离吗？</p><p id="63db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的，在很多情况下，DTW 都扮演着关键角色。</p><h2 id="e327" class="ln lo it bd lx ms mt dn mb mu mv dp mf kr mw mx mh kv my mz mj kz na nb ml nc bi translated">声音模式识别</h2><p id="c980" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">一个用例是检测同类的声音模式。假设我们想通过分析一个人的声音轨迹来识别他的声音，在一个场景中，我们能够收集他说<code class="fe lt lu lv lj b">Hello</code>的声音轨迹。然而，人们以不同的方式说同一个词，如果他像<code class="fe lt lu lv lj b">Heeeeeeelloooooo</code>一样以慢得多的速度说你好，我们将需要一种算法来匹配不同长度的声音轨道，并能够识别它们来自同一个人。</p><figure class="le lf lg lh gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nd"><img src="../Images/f6a25feadbb47464be881ab5e42e222c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gi1TtOqFCsb2M_U7iAUAag.png"/></div></div></figure><h2 id="57a7" class="ln lo it bd lx ms mt dn mb mu mv dp mf kr mw mx mh kv my mz mj kz na nb ml nc bi translated">股票市场</h2><p id="778e" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在股票市场中，人们总是希望能够预测未来，然而使用通用机器学习算法可能是穷尽的，因为大多数预测任务需要测试和训练集具有相同维度的特征。然而，如果你曾经在股票市场投机，你会知道，即使是同一种股票形态，在价格线和指标上也会有非常不同的长度反映。</p><figure class="le lf lg lh gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nl"><img src="../Images/09a62d1639611bf218bb3a48890f22d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QUO4Tqm_z-8ydMBGgqmPg.png"/></div></div></figure><h1 id="6df2" class="lw lo it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">定义和理念</h1><p id="c8e1" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">维基上对 DTW 的简明解释，</p><blockquote class="nm"><p id="bdc9" class="nn no it bd np nq nr ns nt nu nv ld dk translated">在时间序列分析中，动态时间弯曲(DTW)是用于测量两个时间序列之间相似性的算法之一，这两个时间序列的速度可能不同。DTW 已被应用于视频、音频和图形数据的时间序列——事实上，任何可以转化为线性序列的数据都可以用 DTW 进行分析。</p></blockquote><p id="7340" class="pw-post-body-paragraph ki kj it kk b kl nw ju kn ko nx jx kq kr ny kt ku kv nz kx ky kz oa lb lc ld im bi translated"><em class="ob">比较不同长度的数组的想法是建立一对多和多对一的匹配，从而使两者之间的总距离最小化。</em></p><p id="0d22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有两个不同长度的数组红色和蓝色:</p><figure class="le lf lg lh gt ne gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d9c167255bd7234aa014888b46366832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*uFicSZjqkNBfsyrsJw7J9g.jpeg"/></div></figure><p id="41a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，这两个系列遵循相同的模式，但蓝色曲线比红色曲线长。如果我们应用一对一的匹配，显示在顶部，映射没有完全同步，蓝色曲线的尾部被遗漏了。</p><p id="e99e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">DTW 通过开发一对多匹配克服了这个问题，这样具有相同模式的波谷和波峰就完美匹配，两条曲线都没有遗漏(如底部顶部所示)。</p><h1 id="fbef" class="lw lo it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">规则</h1><p id="53b7" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">一般来说，DTW 是一种计算两个给定序列(如时间序列)之间最佳匹配的方法，具有一定的限制和规则(来自 wiki):</p><ul class=""><li id="dd2d" class="od oe it kk b kl km ko kp kr of kv og kz oh ld oi oj ok ol bi translated">第一个序列的每个索引必须与另一个序列的一个或多个索引匹配，反之亦然</li><li id="9fd3" class="od oe it kk b kl om ko on kr oo kv op kz oq ld oi oj ok ol bi translated">第一个序列的第一个索引必须与另一个序列的第一个索引匹配(但不必是唯一的匹配)</li><li id="a2b5" class="od oe it kk b kl om ko on kr oo kv op kz oq ld oi oj ok ol bi translated">第一个序列的最后一个索引必须与另一个序列的最后一个索引相匹配(但它不必是唯一的匹配)</li><li id="9943" class="od oe it kk b kl om ko on kr oo kv op kz oq ld oi oj ok ol bi translated">来自第一序列的索引到来自另一序列的索引的映射必须是单调递增的，反之亦然，即如果<code class="fe lt lu lv lj b">j &gt; i</code>是来自第一序列的索引，则在另一序列中不能有两个索引<code class="fe lt lu lv lj b">l &gt; k</code>，使得索引<code class="fe lt lu lv lj b">i</code>与索引<code class="fe lt lu lv lj b">l</code>匹配，索引<code class="fe lt lu lv lj b">j</code>与索引<code class="fe lt lu lv lj b">k</code>匹配，反之亦然</li></ul><p id="6db6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最佳匹配由满足所有限制和规则并且具有最小成本的匹配来表示，其中成本被计算为每个匹配的索引对的值之间的绝对差的和。</p><p id="9a7f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总结起来就是<em class="ob">头尾一定要位置匹配，不能交叉匹配，不能遗漏。</em></p><h1 id="4632" class="lw lo it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">履行</h1><p id="d834" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">该算法的实现看起来非常简洁:</p><figure class="le lf lg lh gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi or"><img src="../Images/15ce736fbb8fe192acd6630fae14a222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fGr2Mj7fEB7tEyqAzcp2LA.png"/></div></div></figure><p id="97b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中<code class="fe lt lu lv lj b">DTW[i, j]</code>是具有最佳对准的<code class="fe lt lu lv lj b">s[1:i]</code>和<code class="fe lt lu lv lj b">t[1:j]</code>之间的距离。</p><p id="d728" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关键在于:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="755b" class="ln lo it lj b gy lp lq l lr ls">DTW[i, j] := cost + minimum(DTW[i-1, j  ],<br/>                            DTW[i  , j-1],<br/>                            DTW[i-1, j-1])</span></pre><p id="5df2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也就是说，长度为<code class="fe lt lu lv lj b">i and j</code>的两个数组之间的成本等于<em class="ob">尾部之间的距离+长度为</em> <code class="fe lt lu lv lj b"><em class="ob">i-1, j</em></code> <em class="ob">、</em> <code class="fe lt lu lv lj b"><em class="ob">i, j-1</em></code> <em class="ob">和</em> <code class="fe lt lu lv lj b"><em class="ob">i-1, j-1</em></code> <em class="ob">的数组中的最小成本。</em></p><p id="bad6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用 python 来说就是:</p><figure class="le lf lg lh gt ne"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="e7de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例:</p><figure class="le lf lg lh gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ou"><img src="../Images/2acf7b3b0cc761e5a969904dbefe8257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eogOkXkOUzi6Cq7U9BgiLg.png"/></div></div></figure><p id="65bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lt lu lv lj b">a and b</code>之间的距离将是矩阵的最后一个元素，即 2。</p><h2 id="b3cb" class="ln lo it bd lx ms mt dn mb mu mv dp mf kr mw mx mh kv my mz mj kz na nb ml nc bi translated">添加窗口约束</h2><p id="79f9" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">上述算法的一个问题是，我们允许一个数组中的一个元素匹配另一个数组中无限数量的元素(只要尾部最终能够匹配)，这将导致映射过度，例如，下面的数组:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="80d7" class="ln lo it lj b gy lp lq l lr ls">a = [1, 2, 3]<br/>b = [1, 2, 2, 2, 2, 2, 2, 2, ..., 5]</span></pre><p id="8ce2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了最小化距离，数组<code class="fe lt lu lv lj b">a</code>中的元素 2 将匹配数组<code class="fe lt lu lv lj b">b</code>中的所有元素 2，这导致数组<code class="fe lt lu lv lj b">b</code>严重弯曲。为了避免这种情况，我们可以添加一个窗口约束来限制可以匹配的元素数量:</p><figure class="le lf lg lh gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ov"><img src="../Images/8c18ef413666dca6bec0256f2934fe43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_xypte7FHDWJuuBexEvHg.png"/></div></div></figure><p id="c7dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关键的区别在于，现在每个元素都被限制为匹配范围<code class="fe lt lu lv lj b">i — w</code>和<code class="fe lt lu lv lj b">i + w</code>中的元素。<code class="fe lt lu lv lj b">w := max(w, abs(n-m))</code>保证所有指标能够匹配。</p><p id="4d0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现和示例如下:</p><figure class="le lf lg lh gt ne"><div class="bz fp l di"><div class="os ot l"/></div></figure><figure class="le lf lg lh gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ow"><img src="../Images/45adcb38f2182d69af77f7cbebd508b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2K6C-3QrRmbbhpe-jt9UQA.png"/></div></div></figure><h1 id="5a4c" class="lw lo it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">应用包</h1><p id="e1f3" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">Pypi 上还有一些贡献包可以直接使用。这里我用<a class="ae ox" href="https://pypi.org/project/fastdtw/" rel="noopener ugc nofollow" target="_blank"> fastdtw </a>演示一个例子:</p><figure class="le lf lg lh gt ne"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="af56" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它给出了两个列表的距离和索引映射(这个例子可以扩展到一个多维数组)。</p><p id="796b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，您可以在这里查看实现<a class="ae ox" href="https://github.com/MJeremy2017/Machine-Learning-Models/tree/master/Dynamic-Time-Warping" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="d5c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">参考</strong>:</p><p id="27a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[1]<a class="ae ox" href="https://databricks.com/blog/2019/04/30/understanding-dynamic-time-warping.html" rel="noopener ugc nofollow" target="_blank">https://databricks . com/blog/2019/04/30/understanding-dynamic-time-warping . html</a></p><p id="eabe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae ox" href="https://en.wikipedia.org/wiki/Dynamic_time_warping" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Dynamic_time_warping</a></p></div></div>    
</body>
</html>