<html>
<head>
<title>Neural Fictitious Self-Play in Practice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实践中的神经虚拟自我游戏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/neural-fictitious-self-play-in-practice-132836b69bf5?source=collection_archive---------47-----------------------#2020-03-02">https://towardsdatascience.com/neural-fictitious-self-play-in-practice-132836b69bf5?source=collection_archive---------47-----------------------#2020-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="19b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Leduc Hold'em 扑克游戏中神经元虚拟自我游戏的具体实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/869d3ab2637b5e4db2e6863f2bc40d3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y875Y5VN8nDVubR-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基南·康斯坦斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="96a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">更新</strong>:学习和练习强化学习的最好方式是去<a class="ae ky" href="http://rl-lab.com/" rel="noopener ugc nofollow" target="_blank">http://rl-lab.com</a></p><p id="872e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文描述了在 Leduc Hold'em 扑克游戏中基于 Eric Steinberger<a class="ae ky" href="https://github.com/EricSteinberger" rel="noopener ugc nofollow" target="_blank">的代码实现的神经虚拟自我游戏(NFSP)。完整的源代码可以在他的</a><a class="ae ky" href="https://github.com/EricSteinberger/Neural-Fictitous-Self-Play" rel="noopener ugc nofollow" target="_blank"> Github 库</a>中找到。</p><p id="de88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是新手，最好先从这些文章开始:<br/> <a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-fictitious-play-12a8bc4ed1bb">虚构游戏简介</a> <br/> <a class="ae ky" rel="noopener" target="_blank" href="/fictitious-self-play-30b76e30ec6a?source=your_stories_page---------------------------">虚构自我游戏</a> <br/> <a class="ae ky" rel="noopener" target="_blank" href="/neural-fictitious-self-play-800612b4a53f">神经虚构自我游戏</a></p><p id="6fdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">免责声明</strong>:本文的目的不是解释实现代码中的每一个细节，而是强调代码实现和学术解决方案之间的主轴和映射。</p><p id="6bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现涉及分布式计算，这增加了代码的复杂性。然而在本文中，我们将关注算法本身，我们将绕过分布式计算方面。<br/>为此，我们将与下面的理论算法并行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/14d081c001690efd1d7d9f1ff5444d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UcUTo-ilH3S6WbNz.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://arxiv.org/pdf/1603.01121.pdf" rel="noopener ugc nofollow" target="_blank">来自海因里希的 NFSP 算法/银纸</a></p></figure><h1 id="13f8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">Leduc 德州扑克</h1><p id="a780" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，我们来定义一下 Leduc 德州扑克游戏。<br/>这里是取自<a class="ae ky" href="https://github.com/lifrordi/DeepStack-Leduc" rel="noopener ugc nofollow" target="_blank"> DeepStack-Leduc </a>的定义。上面写着:</p><blockquote class="mt mu mv"><p id="14a6" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">Leduc Hold'em 是一种玩具扑克游戏，有时用于学术研究(首次在<a class="ae ky" href="http://poker.cs.ualberta.ca/publications/UAI05.pdf" rel="noopener ugc nofollow" target="_blank">Bayes ' Bluff:Poker 中的对手建模</a>中介绍)。它是用一副六张牌来玩的，每副牌包括两副三个等级的花色(通常是国王、王后和杰克——在我们的实现中是王牌、国王和王后)。游戏开始时，每个玩家私下发一张牌，然后是一轮下注。然后，另一张牌面朝上的牌作为公共牌(或公共牌)发出，然后进行另一轮下注。最后，玩家展示他们的私人牌。如果一个玩家的私人牌和棋盘牌的等级相同，他或她赢得这场游戏；否则，私人牌排名较高的玩家获胜。</p></blockquote><h1 id="29db" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">全局视图</h1><p id="8003" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">主类是<strong class="lb iu"> workers\driver\Driver.py </strong>，它有一个方法<strong class="lb iu"> run() </strong>来启动一切。<br/>它设置了每次迭代的主循环和算法执行，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/ac317254be73543054aae01bc69d286e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6rEucmc3wRccw-GZbQ5QJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/EricSteinberger/Neural-Fictitous-Self-Play/blob/master/NFSP/workers/driver/Driver.py" rel="noopener ugc nofollow" target="_blank"> Driver.py </a></p></figure><h1 id="a07b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">该算法</h1><p id="f85e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">大部分动作发生在<strong class="lb iu"> _HighLevelAlgo.py </strong>中，在这里很容易区分学术解决方案的不同部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/1b74d31e426bfff23d73b452f7286e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUXDh5UkJzdGHrPbCShASA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实际代码和理论解之间的映射:<a class="ae ky" href="https://github.com/EricSteinberger/Neural-Fictitous-Self-Play/blob/master/NFSP/workers/driver/_HighLevelAlgo.py" rel="noopener ugc nofollow" target="_blank"> _HighLevelAlgo.py </a></p></figure><h1 id="a730" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">播放阶段</h1><p id="086d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们放大播放阶段。<br/>代码不能完美地映射到理论解决方案，但也不远了。只是重组方式不同。<br/>动作<strong class="lb iu"> <em class="mw"> a(t) </em> </strong>的采样发生在类<strong class="lb iu"> SeatActor </strong>类中。你可以把<strong class="lb iu">的座位演员</strong>想象成玩家。不止一个。</p><p id="9436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<strong class="lb iu">pockerenv . py(poker rl \ game \ _ \ rl _ env \ base)</strong>实际上是游戏引擎，游戏动态和规则在这里执行。每当“玩家”在游戏中行动时，就会调用<strong class="lb iu"> PockerEnv.step() </strong>方法。</p><p id="e0b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<strong class="lb iu">learner actor(workers \ la \ local . py)</strong>是协调不同<strong class="lb iu"> SeatActors </strong>的类。它包含<strong class="lb iu"> play() </strong>方法，该方法执行对以下序列的几个类和方法的调用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/5278cd4b6971180d8825f02cf5c9b9c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tkLKRJr1mJGBN8vxfZXJpw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/7ac0a909c7b2d44761038195093055d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oUwfCoVeE6efNj0nFq7xJg.png"/></div></div></figure><h1 id="b518" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结果</h1><p id="b220" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">据 Eric Steinberger 称，该代码取得了与学术论文相同的结果。</p><blockquote class="mt mu mv"><p id="a66d" class="kz la mw lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">100 毫安/克(=来自纸张的 0.1A/克)线在 230 千次迭代(4:24 小时)后穿过，60 毫安/克线在 850 千次迭代(19 小时)后穿过。</p></blockquote><p id="0df5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该图显示了根据 NFSP 迭代次数的可开发性曲线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/930d24c72341bb1f298265c7b97a7579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_7v0OyZoBcZKCeVF.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/EricSteinberger/Neural-Fictitous-Self-Play" rel="noopener ugc nofollow" target="_blank">可开发性图</a></p></figure><p id="b948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提醒一下，可开发性是衡量策略最坏情况下的性能。关于可开发性的介绍可以在这些<a class="ae ky" href="https://pdfs.semanticscholar.org/7a33/0ac108ec90f405efb4ce3bec158566c1d9db.pdf" rel="noopener ugc nofollow" target="_blank">幻灯片</a>中找到。</p><h1 id="ad1b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="6c99" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这是由<a class="ae ky" href="https://github.com/EricSteinberger" rel="noopener ugc nofollow" target="_blank"> Eric Steinberger </a>在实践中实现 NFSP 的一个快速概述(点击查看<a class="ae ky" href="https://github.com/EricSteinberger/Neural-Fictitous-Self-Play" rel="noopener ugc nofollow" target="_blank">源代码)。<br/>它将帮助您找到进入代码的方法，代码具有相当复杂的结构，并让您清楚地了解真正的动作发生在哪里。</a></p><p id="1ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我要感谢埃里克·斯坦伯格审阅这篇文章并分享他的评论。<br/>再次感谢<a class="nf ng ep" href="https://medium.com/u/7e968a07c09e?source=post_page-----132836b69bf5--------------------------------" rel="noopener" target="_blank"> Arman Didandeh </a>校对本文。</p></div></div>    
</body>
</html>