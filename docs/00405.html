<html>
<head>
<title>Scraping the World Development Indicators (WDI)database using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python抓取世界发展指标(WDI)数据库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/scraping-the-world-development-indicators-wdi-database-using-python-632f6b7c8319?source=collection_archive---------27-----------------------#2020-01-12">https://towardsdatascience.com/scraping-the-world-development-indicators-wdi-database-using-python-632f6b7c8319?source=collection_archive---------27-----------------------#2020-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2dab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">本文提供了一个python函数的演示，该函数使用xmltree包从WDI数据库中一次抓取和处理多个序列的最新数据。</h2></div><p id="7d99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">世界银行维护的世界发展指标数据库是最强大和最多样化的开放存取数据库之一。该数据库包含各种发展指标的数据集，对于任何有兴趣从数量或质量上研究发展问题的人来说，都是一个分析金矿。</p><p id="7fce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就我个人而言，在我作为研究生的研究工作和作为科学家的职业生涯中，我经常依赖这个数据库。在本文中，我提供了一个脚本的演练，该脚本从WDI数据库中抓取数据集并将其保存到dataframe中。该脚本利用了python中的xmltree库，可以非常高效地从WDI数据库中抓取最新的可用数据。该脚本是我在过去一年中开发的更广泛的python数据处理项目的一部分。此处可进入<a class="ae le" href="https://github.com/kanishkan91/Python-DataUpdate-DataProcessor-kbn" rel="noopener ugc nofollow" target="_blank">项目。因此，不再浪费时间，让我们直接进入代码。</a></p><p id="a495" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们了解一下WDI网站的数据结构。我们将抓取为世界银行托管不同数据集的WDI API。https://api.worldbank.org/v2/countries/all/indicators/ WDI API包含以xml格式存储在url- <a class="ae le" href="https://api.worldbank.org/v2/countries/all/indicators/" rel="noopener ugc nofollow" target="_blank">的数据</a></p><p id="2271" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何用户都可以使用特定代码访问单个指示器。例如，代码‘AG。“CON.FERT.ZS”代表按国家和年份划分的施肥数据。因此，要访问这些数据，用户需要指定URL—【https://api.worldbank.org/v2/countries/all/indicators/AG. T4】CON.FERT.ZS 。</p><p id="85fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，第一步是将来自WDI的所有代码存储在一个列表中。为了简化，我在一个csv中存储了来自WDI的300个不同数据集的代码。csv看起来如下所示，</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/05a5409d06363b3ce9fbde77cfc061e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*ZMGF4mQbMld467PdSEUuJQ.png"/></div></figure><p id="ef32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使这变得更加容易，我将脚本构造为一个名为WDIData的函数。让我们首先从定义函数并在python中导入所需的库开始。如上所述，我们将需要xml etree包、numpy和pandas。我们还需要请求包，因为这是一个刮刀。</p><pre class="lg lh li lj gt ln lo lp lq aw lr bi"><span id="4686" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">def </strong>WDIData():<br/>    <strong class="lo iu">import </strong>numpy <strong class="lo iu">as </strong>np<br/>    <strong class="lo iu">import </strong>requests<br/>    <strong class="lo iu">import </strong>pandas <strong class="lo iu">as </strong>pd<br/>    <strong class="lo iu">import </strong>xml.etree.cElementTree <strong class="lo iu">as </strong>et</span></pre><p id="e5ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们将上面提到的WDICodes文件读入一个名为datadict的对象。让我们创建一个空的数据帧来存储我们的数据集。</p><pre class="lg lh li lj gt ln lo lp lq aw lr bi"><span id="f93d" class="ls lt it lo b gy lu lv l lw lx">datadict = pd.read_csv(<strong class="lo iu">'input\WDI\WDICodes.csv'</strong>, encoding=<strong class="lo iu">"ISO-8859-1"</strong>)</span><span id="237b" class="ls lt it lo b gy ly lv l lw lx">df=[]</span></pre><p id="fe21" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于csv中的每个代码，我们希望提取国家、代码、年份和值。因此，让我们为WDI代码创建一个for循环，其中我们为每个变量(国家、代码、年份和值)指定空列表。我们还必须创建一个url来从API请求数据。最后，我们将使用元素树中的“fromstring”函数从url中提取数据。</p><pre class="lg lh li lj gt ln lo lp lq aw lr bi"><span id="fe55" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">for </strong>row <strong class="lo iu">in </strong>datadict[<strong class="lo iu">'WDI Code'</strong>]:<br/>    #Specify empty lists for required variables<br/>    Countryname = []<br/>    SeriesCode = []<br/>    Year = []<br/>    Value = []</span><span id="be12" class="ls lt it lo b gy ly lv l lw lx">    #Create URL for each <br/>    url = <strong class="lo iu">'http://api.worldbank.org/v2/countries/all/indicators/' </strong>+ str(row) + <strong class="lo iu">'/?format=xml&amp;per_page=20000'<br/>    <br/>    </strong>#Get data from url and store to a variable <strong class="lo iu"><br/>    </strong>r = requests.get(url, stream=<strong class="lo iu">True</strong>)<br/>    root = et.fromstring(r.content)</span></pre><p id="99a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于每个代码中的数据，我们希望提取所有年份的所有值。这可以很容易地通过使用for循环来实现，这些循环使用python中xml树包内的‘ITER’函数。我们将为循环写4个，一个为系列id、国家名称，一个为年份，一个为值。如果您跟踪上面提到的URL，您会注意到数据存储在特定的属性中。</p><pre class="lg lh li lj gt ln lo lp lq aw lr bi"><span id="909f" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">for </strong>child <strong class="lo iu">in </strong>root.iter(<strong class="lo iu">"{http://www.worldbank.org}indicator"</strong>):<br/>    SeriesCode.append(child.attrib[<strong class="lo iu">'id'</strong>])<br/><strong class="lo iu">for </strong>child <strong class="lo iu">in </strong>root.iter(<strong class="lo iu">"{http://www.worldbank.org}country"</strong>):<br/>    Countryname.append(child.text)<br/><strong class="lo iu">for </strong>child <strong class="lo iu">in </strong>root.iter(<strong class="lo iu">"{http://www.worldbank.org}date"</strong>):<br/>    Year.append(child.text)<br/><strong class="lo iu">for </strong>child <strong class="lo iu">in </strong>root.iter(<strong class="lo iu">"{http://www.worldbank.org}value"</strong>):<br/>    Value.append((child.text))</span></pre><p id="a40c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们为列表中的每个代码创建一个数据帧。这可以在pandas中使用from_dict函数来完成。我们还将转置数据集。我们将把代码数据存储到一个名为test_df的临时变量中。</p><pre class="lg lh li lj gt ln lo lp lq aw lr bi"><span id="4de9" class="ls lt it lo b gy lu lv l lw lx">test_df = pd.DataFrame.from_dict({<strong class="lo iu">'SeriesName'</strong>: SeriesCode,<br/>                                  <strong class="lo iu">'Country'</strong>: Countryname,<br/>                                  <strong class="lo iu">'Year'</strong>: Year,<br/>                                  <strong class="lo iu">'Value'</strong>: Value}, orient=<strong class="lo iu">'index'</strong>)</span><span id="df42" class="ls lt it lo b gy ly lv l lw lx">test_df = test_df.transpose()</span></pre><p id="4ff4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了最小化数据集的大小，我们将消除值、国家和系列名称中的空值。</p><pre class="lg lh li lj gt ln lo lp lq aw lr bi"><span id="02da" class="ls lt it lo b gy lu lv l lw lx">test_df = test_df[pd.notnull(test_df[<strong class="lo iu">'Value'</strong>])]<br/>test_df = test_df[pd.notnull(test_df[<strong class="lo iu">'Country'</strong>])]<br/>test_df = test_df[pd.notnull(test_df[<strong class="lo iu">'Series'</strong>])]</span></pre><p id="fe63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们将该代码的数据追加到我们在开始时创建的第一个空数据帧中。让我们使用pandas中的pivot_table函数从合并的数据集创建一个表。使用pivot_table函数的想法是将系列名称存储在列中。</p><pre class="lg lh li lj gt ln lo lp lq aw lr bi"><span id="f5f2" class="ls lt it lo b gy lu lv l lw lx">df=pd.concat(df)</span><span id="00f0" class="ls lt it lo b gy ly lv l lw lx">data = pd.pivot_table(df, index=[<strong class="lo iu">'Country'</strong>, <strong class="lo iu">'Year'</strong>], columns=[<strong class="lo iu">'Series'</strong>], values=[<strong class="lo iu">'Value'</strong>],<br/>                      aggfunc=[np.sum])</span></pre><p id="2ad0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">合并数据集存储为数据透视表。让我们将这个表存储为记录。最后，让我们返回数据，完成函数。</p><pre class="lg lh li lj gt ln lo lp lq aw lr bi"><span id="eab5" class="ls lt it lo b gy lu lv l lw lx">#Create the pivot table<br/>data = pd.pivot_table(df, index=[<strong class="lo iu">'Country'</strong>, <strong class="lo iu">'Year'</strong>], columns=[<strong class="lo iu">'Series'</strong>], values=[<strong class="lo iu">'Value'</strong>],<br/>                      aggfunc=[np.sum])</span><span id="0297" class="ls lt it lo b gy ly lv l lw lx">#Convert the dataframe to records from a pivot table<br/>data = pd.DataFrame(data.to_records())</span><span id="1225" class="ls lt it lo b gy ly lv l lw lx">#Complete the function<br/><strong class="lo iu">return </strong>(data)</span></pre><p id="389e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你有它！最终的数据集如下所示。如上所述，WDI数据函数可以在DataUpdate.py文件<a class="ae le" href="https://github.com/kanishkan91/Python-DataUpdate-DataProcessor-kbn/blob/master/DataUpdate.py" rel="noopener ugc nofollow" target="_blank">中找到。请随时分享您对该职能的任何反馈。提取一个系列大约需要5秒钟，您可以用多达1000个文件更新csv，以提取多个系列的最新数据。</a></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lz"><img src="../Images/9c71433f88511ff17d1819d9022552f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDk-zpLN2sI8YPnvkv3rhQ.png"/></div></div></figure></div></div>    
</body>
</html>