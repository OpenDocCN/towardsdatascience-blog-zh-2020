<html>
<head>
<title>Pandas Join vs. Merge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫加入 vs .合并</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-join-vs-merge-c365fd4fbf49?source=collection_archive---------2-----------------------#2020-01-24">https://towardsdatascience.com/pandas-join-vs-merge-c365fd4fbf49?source=collection_archive---------2-----------------------#2020-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e1899f8172e9f80df8e1a740975bf4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z1yJhbxQgvVDd6m-"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">罗马卡夫在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="bb50" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">它们有什么作用，我们应该在什么时候使用它们？</h2></div><p id="a68d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di">我写了很多关于统计和算法的文章，但是为建模准备数据也是数据科学的一个重要部分。事实上，很有可能你会花更多的时间盯着你的数据，检查它，修补它的漏洞，而不是训练和调整你的模型。</span></p><p id="8989" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们在收集、清理和对数据执行快速“健全性检查”分析方面做得越好，我们就能在建模上花费越多的时间(大多数人认为这更有趣)。为此，让我们看看如何快速组合来自不同数据框架的数据，并为分析做好准备。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="5d10" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">数据</h1><p id="44df" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">让我们假设我们是一家生产和销售回形针的公司的分析师。我们需要运行一些关于我们公司销售部门的报告，以了解他们的工作情况，并从以下字典中获得数据:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="5a32" class="nq ml jj nm b gy nr ns l nt nu">import numpy as np<br/>import pandas as pd</span><span id="2382" class="nq ml jj nm b gy nv ns l nt nu"># Dataframe of number of sales made by an employee<br/>sales = {'Tony': 103,<br/>         'Sally': 202,<br/>         'Randy': 380,<br/>         'Ellen': 101,<br/>         'Fred': 82<br/>        }</span><span id="a0db" class="nq ml jj nm b gy nv ns l nt nu"># Dataframe of all employees and the region they work in<br/>region = {'Tony': 'West',<br/>          'Sally': 'South',<br/>          'Carl': 'West',<br/>          'Archie': 'North',<br/>          'Randy': 'East',<br/>          'Ellen': 'South',<br/>          'Fred': np.nan,<br/>          'Mo': 'East',<br/>          'HanWei': np.nan,<br/>         }</span></pre><p id="f460" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以从字典中创建两个独立的数据帧，如下所示:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="93d7" class="nq ml jj nm b gy nr ns l nt nu"># Make dataframes<br/>sales_df = pd.DataFrame.from_dict(sales, orient='index', <br/>                                  columns=['sales'])<br/>region_df = pd.DataFrame.from_dict(region, orient='index', <br/>                                   columns=['region'])</span></pre><p id="2f7e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据框架 sales_df 现在看起来像这样:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="0a04" class="nq ml jj nm b gy nr ns l nt nu">sales<br/>Tony     103<br/>Sally    202<br/>Randy    380<br/>Ellen    101<br/>Fred      82</span></pre><p id="f053" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">region_df 如下所示:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="58be" class="nq ml jj nm b gy nr ns l nt nu">       region<br/>Tony     West<br/>Sally   South<br/>Carl     West<br/>Archie  North<br/>Randy    East<br/>Ellen   South<br/>Fred      NaN<br/>Mo       East<br/>HanWei    NaN</span></pre></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="5be0" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">我应该合并，加入，还是连接？</h1><p id="da17" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">现在，让我们将所有数据合并到一个数据帧中。但是我们怎么做呢？</p><p id="e03f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">熊猫数据框架有很多类似 SQL 的功能。事实上，与 SQL 表相比，我更喜欢它们(全世界的数据分析师都对我虎视眈眈)。但是当我第一次开始用 Pandas 做许多类似 SQL 的东西时，我发现自己总是不确定是使用<strong class="la jk"> join </strong>还是<strong class="la jk"> merge </strong>，并且我经常互换使用它们(选择首先想到的)。那么我们应该在什么时候使用这些方法，它们之间到底有什么不同呢？好了，是时候不再困惑了！</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="20d0" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated"><strong class="ak">加入</strong></h1><p id="2427" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/sql-joins-a-brief-example-9d015868b56a"> <strong class="la jk"> <em class="nw">(如果你不熟悉什么是连接表，我写了这篇关于它的文章，我强烈建议你先读一读)</em> </strong> </a></p><p id="0e7e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">先从<strong class="la jk">加入</strong>开始吧，因为这是最简单的一个。数据帧有一个叫做索引的东西。这是您的表的关键，如果我们知道索引，那么我们可以使用<strong class="la jk">轻松地获取保存数据的行。loc </strong>。如果你打印你的数据帧，你可以通过查看最左边的一栏来看索引是什么，或者我们可以更直接地使用<strong class="la jk">。索引</strong>:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="4c90" class="nq ml jj nm b gy nr ns l nt nu">In:  sales_df.index</span><span id="1a3b" class="nq ml jj nm b gy nv ns l nt nu">Out: Index(['Tony', 'Sally', 'Randy', 'Ellen', 'Fred'], <br/>           dtype='object')</span></pre><p id="db5e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以 sales_df 的指标就是我们销售人员的名字。顺便说一下，与 SQL 表的主键不同，数据帧的索引不必是唯一的。但是一个唯一的索引使我们的生活更容易，搜索数据帧的时间更短，所以它绝对是一个好东西。给定一个索引，我们可以像这样找到行数据:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="9e7c" class="nq ml jj nm b gy nr ns l nt nu">In:  sales_df.loc['Tony']</span><span id="6092" class="nq ml jj nm b gy nv ns l nt nu">Out: sales    103<br/>     Name: Tony, dtype: int64</span></pre><p id="6175" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了，回到<strong class="la jk">加入</strong>。<strong class="la jk"> join </strong>方法获取两个数据帧，<strong class="la jk">在它们的索引</strong>上将它们连接起来(从技术上来说，您可以为左边的数据帧选择要连接的列)。让我们看看当我们通过<strong class="la jk"> join </strong>方法将两个数据帧组合在一起时会发生什么:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="f57e" class="nq ml jj nm b gy nr ns l nt nu">In:  joined_df = region_df.join(sales_df, how='left')<br/>     print(joined_df)</span><span id="2742" class="nq ml jj nm b gy nv ns l nt nu">Out: </span><span id="58a0" class="nq ml jj nm b gy nv ns l nt nu">       region  sales<br/>Tony     West  103.0<br/>Sally   South  202.0<br/>Carl     West    NaN<br/>Archie  North    NaN<br/>Randy    East  380.0<br/>Ellen   South  101.0<br/>Fred      NaN   82.0<br/>Mo       East    NaN<br/>HanWei    NaN    NaN</span></pre><p id="7bb7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果看起来像一个 SQL 连接的输出，它或多或少是这样的。<strong class="la jk"> join </strong>方法使用索引或它所调用的数据帧中的指定列，也就是左边的数据帧，作为连接键。因此，我们为左侧数据帧匹配的列不一定是它的索引。<strong class="la jk">但是对于正确的数据帧，连接键必须是它的索引。</strong>我个人觉得更容易把<strong class="la jk"> join </strong>方法理解为基于索引的连接，如果我不想在索引上连接，就使用<strong class="la jk"> merge </strong>(即将出现)。</p><p id="1b53" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在组合数据框架中有一些 nan。那是因为不是所有的员工都有销售。没有销售的那些在 sales_df 中不存在，但是我们仍然显示它们，因为<strong class="la jk">我们执行了一个左连接(通过指定“how=left”)，它从左数据帧 region_df 返回所有的行，不管是否有匹配</strong>。如果我们不想在我们的连接结果中显示任何 nan，我们将改为执行内部连接(通过指定“how=inner”)。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="a820" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">合并</h1><p id="5156" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">基本上，<strong class="la jk">合并</strong>和<strong class="la jk">加入</strong>差不多。这两种方法都用于将两个数据帧组合在一起，但 merge 更通用，代价是需要更详细的输入。让我们看看如何使用<strong class="la jk">合并</strong>创建与使用<strong class="la jk">连接</strong>相同的组合数据帧:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="1df2" class="nq ml jj nm b gy nr ns l nt nu">In:  joined_df_merge = region_df.merge(sales_df, how='left', <br/>                                      left_index=True,<br/>                                      right_index=True)<br/>     print(joined_df_merge)</span><span id="7972" class="nq ml jj nm b gy nv ns l nt nu">Out:</span><span id="b4a7" class="nq ml jj nm b gy nv ns l nt nu">       region  sales<br/>Tony     West  103.0<br/>Sally   South  202.0<br/>Carl     West    NaN<br/>Archie  North    NaN<br/>Randy    East  380.0<br/>Ellen   South  101.0<br/>Fred      NaN   82.0<br/>Mo       East    NaN<br/>HanWei    NaN    NaN</span></pre><p id="98b4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这与我们使用<strong class="la jk"> join </strong>时没有什么不同。但是<strong class="la jk"> merge </strong>允许我们为左右两个数据帧指定要连接的列。这里通过设置“左索引”和“右索引”等于真，我们让<strong class="la jk">合并</strong>知道我们想要在索引上连接。我们得到了与之前使用<strong class="la jk"> join </strong>时相同的组合数据帧。</p><p id="d229" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> Merge </strong>在我们不想在索引上连接的时候很有用。例如，假设我们想知道每个员工为他们的区域贡献了多少百分比。我们可以使用<strong class="la jk"> groupby </strong>来汇总每个地区的所有销售额。在下面的代码中，<strong class="la jk"> reset_index </strong>用于将 region 从 data frame(grouped _ df)的索引转换为普通的列——是的，我们可以将它保留为索引并在其上连接，但是我想演示如何在列上使用<strong class="la jk"> merge </strong>。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="629e" class="nq ml jj nm b gy nr ns l nt nu">In:  grouped_df = joined_df_merge.groupby(by='region').sum()<br/>     grouped_df.reset_index(inplace=True)<br/>     print(grouped_df)</span><span id="0c0f" class="nq ml jj nm b gy nv ns l nt nu">Out:</span><span id="9c44" class="nq ml jj nm b gy nv ns l nt nu">  region  sales<br/>0   East  380.0<br/>1  North    0.0<br/>2  South  303.0<br/>3   West  103.0</span></pre><p id="101d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让<strong class="la jk">使用 region 列合并</strong> joined_df_merge 和 grouped_df。我们必须指定一个后缀，因为我们的两个数据框架(我们正在合并)都包含一个名为 sales 的列。<strong class="la jk">后缀</strong>输入将指定的字符串附加到两个数据帧中具有相同名称的列的标签上。在我们的例子中，因为第二个 dataframe 的 sales 列实际上是整个地区的销售额，所以我们可以在它的标签后面加上“_region”来说明这一点。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="0cf0" class="nq ml jj nm b gy nr ns l nt nu">In:</span><span id="e2b6" class="nq ml jj nm b gy nv ns l nt nu">employee_contrib = joined_df_merge.merge(grouped_df, how='left', <br/>                                         left_on='region', <br/>                                         right_on='region',<br/>                                         suffixes=('','_region'))<br/>print(employee_contrib)</span><span id="8cf1" class="nq ml jj nm b gy nv ns l nt nu"><br/>Out:</span><span id="62de" class="nq ml jj nm b gy nv ns l nt nu">  region  sales  sales_region<br/>0   West  103.0         103.0<br/>1  South  202.0         303.0<br/>2   West    NaN         103.0<br/>3  North    NaN           0.0<br/>4   East  380.0         380.0<br/>5  South  101.0         303.0<br/>6    NaN   82.0           NaN<br/>7   East    NaN         380.0<br/>8    NaN    NaN           NaN</span></pre><p id="602c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哦不，我们的索引不见了！但是我们可以用<strong class="la jk"> set_index </strong>把它取回来(否则我们就不知道每行对应的是哪个员工):</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="2c85" class="nq ml jj nm b gy nr ns l nt nu">In:</span><span id="facb" class="nq ml jj nm b gy nv ns l nt nu">employee_contrib = employee_contrib.set_index(joined_df_merge.index)<br/>print(employee_contrib)</span><span id="faed" class="nq ml jj nm b gy nv ns l nt nu"><br/>Out:</span><span id="e1b2" class="nq ml jj nm b gy nv ns l nt nu">       region  sales  sales_region<br/>Tony     West  103.0         103.0<br/>Sally   South  202.0         303.0<br/>Carl     West    NaN         103.0<br/>Archie  North    NaN           0.0<br/>Randy    East  380.0         380.0<br/>Ellen   South  101.0         303.0<br/>Fred      NaN   82.0           NaN<br/>Mo       East    NaN         380.0<br/>HanWei    NaN    NaN           NaN</span></pre><p id="9429" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在有了原始的 sales 列和一个新的 sales_region 列，它告诉我们一个地区的总销售额。让我们计算每个雇员占销售额的百分比，然后通过删除没有区域的观察值(弗雷德和韩伟)并用零填充销售列中的 NaNs 来清理我们的数据框架</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="a4b8" class="nq ml jj nm b gy nr ns l nt nu">In:</span><span id="1817" class="nq ml jj nm b gy nv ns l nt nu"># Drop NAs in region column<br/>employee_contrib = employee_contrib.dropna(subset=['region'])</span><span id="93b8" class="nq ml jj nm b gy nv ns l nt nu"># Fill NAs in sales column with 0<br/>employee_contrib = employee_contrib.fillna({'sales': 0})</span><span id="cd56" class="nq ml jj nm b gy nv ns l nt nu">employee_contrib['%_of_sales'] = employee_contrib['sales']/employee_contrib['sales_region']</span><span id="32b8" class="nq ml jj nm b gy nv ns l nt nu">print(employee_contrib[['region','sales','%_of_sales']]\<br/>      .sort_values(by=['region','%_of_sales']))</span><span id="13fe" class="nq ml jj nm b gy nv ns l nt nu"><br/>Out:</span><span id="423a" class="nq ml jj nm b gy nv ns l nt nu">       region  sales  %_of_sales<br/>Mo       East    0.0    0.000000<br/>Randy    East  380.0    1.000000<br/>Archie  North    0.0         NaN<br/>Ellen   South  101.0    0.333333<br/>Sally   South  202.0    0.666667<br/>Carl     West    0.0    0.000000<br/>Tony     West  103.0    1.000000</span></pre><p id="78ff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">全部完成！请注意，北部地区没有销售额，因此有 NaN(不能被零除)。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="6807" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">结论</h1><p id="7716" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">让我们快速回顾一下:</p><ul class=""><li id="1209" class="nx ny jj la b lb lc le lf lh nz ll oa lp ob lt oc od oe of bi translated">我们可以使用<strong class="la jk"> join </strong>和<strong class="la jk"> merge </strong>来合并 2 个数据帧。</li><li id="f747" class="nx ny jj la b lb og le oh lh oi ll oj lp ok lt oc od oe of bi translated">当我们在索引上连接数据帧时,<strong class="la jk"> join </strong>方法效果最好(尽管您可以为左边的数据帧指定另一个要连接的列)。</li><li id="6417" class="nx ny jj la b lb og le oh lh oi ll oj lp ok lt oc od oe of bi translated"><strong class="la jk"> merge </strong>方法更加灵活，它允许我们指定索引之外的列来连接两个数据帧。如果索引在<strong class="la jk">合并</strong>后被重置为计数器，我们可以使用<strong class="la jk"> set_index </strong>将其改回。</li></ul><p id="62cb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一次，我们将了解如何通过 Pandas 的<strong class="la jk"> concatenate </strong>函数添加新的数据行(以及更多内容)。干杯！</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="ef5f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你总体上喜欢这篇文章和我的写作，请考虑通过我的推荐链接注册 Medium 来支持我的写作。谢谢！T32</p></div></div>    
</body>
</html>