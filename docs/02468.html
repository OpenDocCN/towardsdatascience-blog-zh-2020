<html>
<head>
<title>Parking spot detection using Mask-RCNN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 Mask-RCNN 的停车位检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/parking-spot-detection-using-mask-rcnn-cb2db74a0ff5?source=collection_archive---------15-----------------------#2020-03-09">https://towardsdatascience.com/parking-spot-detection-using-mask-rcnn-cb2db74a0ff5?source=collection_archive---------15-----------------------#2020-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="da47" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用 Mask-RCNN 检测停车位的可用性？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ba023130623ceb8509f2948c17c662b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jTH_AXjoRBi9H3NpPKOvA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">空的/被占用的停车位</p></figure><p id="f6ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我最近在做一个项目，根据安全视图摄像头的照片来检测停车位是否可用或被占用。我的工作有局限性，我将进一步深入探讨，但一旦这些问题得到解决，这个项目可能是优化停车可用性的低成本解决方案。这个项目当然有可能简化在给定区域寻找停车位的过程，因为大多数停车场都安装了安全摄像头，这样停车场就不需要安装任何额外的设备。</p><p id="853a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我详细说明一下我在这个项目中使用的资源。Kaggle 上有一个停车场数据集，它有足够的数据点来训练深度学习模型和 xml 文件，这些文件带有关于停车位是否被占用的注释。你可以在这里访问数据集停车场<a class="ae lr" href="https://www.kaggle.com/blanderbuss/parking-lot-dataset" rel="noopener ugc nofollow" target="_blank">数据集</a>。对于这个模型，我使用了最先进的对象检测和分割掩模-RCNN 模型，它表现令人惊讶，可以通过这个<a class="ae lr" href="https://github.com/matterport/Mask_RCNN" rel="noopener ugc nofollow" target="_blank">链接访问。</a></p><p id="7d8a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如你所看到的，Mask-RCNN 在 COCOdataset 模型上进行预训练，在对象检测和分割方面表现出色。尽管在某些情况下，它会将汽车误分为火车和卡车。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/fcf21104b9c6a273a014c02b5048ca04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRTfvhVawpZWG4lKKabGFQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">掩模-RCNN 目标检测和分割</p></figure><p id="9cfb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">顺便说一下，我还尝试了 YOLO-v3，其性能相同，所以我没有进一步使用 YOLO 模型，但如果你正在寻找替代 YOLO 是一个用于对象检测的可怕模型，这里有<a class="ae lr" href="https://pjreddie.com/darknet/yolo/" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/d20bc7bb988b261ee32a50cbc4abe22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJTQ7ovfeGzPzIwXQbXXQw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">YOLO 模型检测停车场上的汽车</p></figure><p id="941a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我使用 Mask-RCNN 模型来检测停车位上的车辆，并根据给定的停车位数量来计算空位。我们的模型不需要所有的 COCO 类，所以我将这些类限制在汽车、卡车和摩托车上。但是，在 COCOdataset 模型上预先训练的模型在检测小对象方面做得并不出色，即使我尝试调整阈值和边界框，那些被错误分类为火车的汽车也没有被检测到。这里绘制的是边界框，而不是模型的 visualize 方法提供的遮罩。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lu"><img src="../Images/a8c5e39c2a2028858df1619aeeb763fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F0kVWu1uy6wfoNuDoqiI3g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用绘制的边界框而不是遮罩的遮罩-RCNN 模型预测</p></figure><p id="e952" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">鉴于上述性能，我决定训练 COCO 模型的顶层，不仅从预训练的模型中转移知识，而且还根据我们的数据集改进预测，这样我们就有两个类来预测该位置是被占用还是空着。</p><p id="34aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该停车场数据集的约束条件是，照片仅从两个视角拍摄，这导致了训练模型的过度拟合问题，并且不允许更好地概括。第二，每个停车点的注释不完整，因此在训练期间产生异常，此外，不是照片上所有可用的停车点都被注释，这也导致模型的较差性能。我会告诉你我的意思，下面的照片只是显示了有多少停车位被标注:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/9a8b1fb94d6fddb0ac85dd1476389778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Imio76tA3FqsuMiqrCAoA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">并非所有的停车位都有标注</p></figure><p id="3050" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">许多 xml 文件没有填充占用类:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/a7e5484cd2ca07d63085d23ded745e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*ptHlrVIIl5KcwcFxl4jk5Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">注释文件中缺少信息</p></figure><p id="f921" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">信息缺失的停车位数量可能上升至 10-15 个左右。我以为这可以手动修复，但是在运行了一些代码之后:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/7c14133ca5d819faa7c6ed48a96e8a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*JmyADNloTN0nERoouUNvcg.png"/></div></figure><p id="2bf5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要修复的文件太多了，为了只训练模型的顶层，避免这些文件更容易。为了解析 xml 文件，我使用了 XML.etree.ElementTree 内置 python 包。同样值得注意的是，边界框的坐标是以一个中心点的角度给出的，所以如果我们想正确地解析和创建边界框，一些调整是必要的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/833dfcc4a9aed027145627f18e5439a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TbZXjOfpXmADxseI_BHQw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">函数解析 xml 文件并提取停车场的轮廓</p></figure><p id="d3a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于 Mask-RCNN 使用掩码来训练类，以类似于袋鼠检测文章的方式，可以在这里访问<a class="ae lr" href="https://machinelearningmastery.com/how-to-train-an-object-detection-model-with-keras/" rel="noopener ugc nofollow" target="_blank">，我使用边界框来创建掩码。这篇文章实际上在理解如何使用 Mask-RCNN 模型和机器学习掌握方面帮助了我很多，一般来说，对于许多机器学习应用程序来说，这是一个很好的资源。所以，如果你还没看过的话，就去看看吧。主要的区别是，我们将检测 2 个类别，而不是一个，从而根据已占用的类别以及边界框的计算方式来创建遮罩。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/bbab2e97441b6b95524b7c18176acfa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-zAsCwLidlwpHVqa6Ss3w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">函数从边界框中创建遮罩，并创建两个类来检测</p></figure><p id="9fd9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">至于数据集的组织，我们必须为训练和测试数据创建两个目录，每个目录包含 image 文件夹和 matching label 文件夹，其中每个 xml 文件都有相同的文件名，只是扩展名不同。而其余部分实际上遵循一般实践来训练 Mask-RCNN 的顶层。你可以在 Matterport GitHub 上查看不同的样本代码。</p><p id="f7f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们必须创建一个类 ParkingLot，它将加载数据集，通过解析 xml 注释文件提取边界框的轮廓，根据提取的轮廓创建遮罩，我们需要一个图像引用函数，它将返回注释 xml 文件的路径。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/dd85922ae2b001b8267380b187db1ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSrHZKUF46h9peQAaa_1-g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建 ParkingLot 类</p></figure><p id="1bad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们需要根据我们希望模型接受训练的类来指定配置类，加载训练和测试数据集，使用“训练”模式加载模型并开始训练。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ma"><img src="../Images/0a12216e5aa78e740693a74e4af34777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GGBNHKhV175gUYLzSPnScA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ParkingConfig 类</p></figure><p id="096f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该模型将在每个时期后保存在 logs 文件夹中，这样一旦训练完成，您就可以继续加载该模型以评估其性能。使用 Mask-RCNN 的方法是创建新的配置类来限制我们预测的范围</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/9875c88347ccaef6e5b4c93b43ec2345.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*nCxhmDFOlLuu5t9c_DVprg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预测配置类</p></figure><p id="60d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用“推理”模式加载模型，从日志文件夹加载模型:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/d2cbe61045816e1788c02a4ece1ff54e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yiu2tabOWM2s8so8ckuXwQ.png"/></div></div></figure><p id="b61f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于 Mask-RCNN 可视化了检测到的对象及其类的遮罩，我们将使用此函数来绘制边界框:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi md"><img src="../Images/b12681ef3a41d99485c5f88c221179c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhHaZtRfaWYu5jVwRXaO3w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">函数绘制检测到的对象的边界框</p></figure><p id="888b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，如果我们加载任何随机图像，检测可用和已占用的停车位，使用我们的函数来绘制它们，结果将是这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/fcf4b4c3d016f293e7d5115b01f8b701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMA2p-nqX6wHIn-3TYaIAA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">检测到可用停车位</p></figure><p id="53d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">绿色方框是可用的停车位，蓝色边框是已占用的停车位。看起来模型性能还不错，虽然还是检测不到小型车/停车点。数据集中有意忽略了停在人行道旁的汽车，以便模型在训练时不会将这些汽车考虑在内。这是使用 Mask-RCNN 的 visualize 方法得到的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mf"><img src="../Images/fd61d903f5ea3a7cf8b7dcece73171a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eCE14ZCTbg0sF5-hmSfOCQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Mask-RCNN 检测可用停车位</p></figure><p id="b357" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">鉴于这一结果，似乎该模型的性能真的很好。但是在我们的数据集中，我们只有停车场的两个角度，因为我只训练顶级模特，所以我只使用了数据集的一部分。那么，为什么不看看停车场的另一张照片，上面有一个类似的摄像头，但不是这个数据集的一部分。我们的模型会有多好？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/b9c1c6c44631df2672998fa149a5eda0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78He0Din3g27u6IyQNrY2w.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/d80ab416b14345027d2297e1c1593fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QI1u0jfjwZ73cTXzFGHaNA.png"/></div></div></figure><p id="6d74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">哇！这太糟糕了。很明显，该模型过度适合我们的停车场数据集，这意味着它在相同的数据集上表现良好，我没有说训练，因为训练和测试照片实际上是停车场中不同汽车的相同照片，虽然技术上没有泄漏测试数据，但在某种意义上它们是相同的。开箱即用的预训练 Mask-RCNN 将在检测车辆方面表现得更好。</p><p id="4b6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">考虑到这些结论和我前面提到的局限性，下一步可以采取什么措施来改进模型或向前发展呢？嗯，我们可以使用整套数据从头开始训练模型，看看它的表现如何，尝试调整检测阈值。我不妨试着这样做，也许这可以成为这篇文章的第二部分？但理想情况下，更多变化的数据集是必不可少的，完整的注释是创建准确的停车点检测模型的基础。此外，为了建立不仅准确而且鲁棒的检测模型，我认为考虑正在移动但尚未停放的车辆，即未经授权停放的车辆非常重要。这些可能是未来需要进一步研究的问题。</p><p id="4a60" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您花时间阅读我的帖子！</p></div></div>    
</body>
</html>