<html>
<head>
<title>Time Series of Price Anomaly Detection with LSTM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 LSTM 的时间序列价格异常检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-of-price-anomaly-detection-with-lstm-11a12ba4f6d9?source=collection_archive---------1-----------------------#2020-09-08">https://towardsdatascience.com/time-series-of-price-anomaly-detection-with-lstm-11a12ba4f6d9?source=collection_archive---------1-----------------------#2020-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ed9b04ae55a296e299534203bc6368df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2STe0WAobpVdOM2iIVVyA.png"/></div></div></figure><div class=""/><div class=""><h2 id="17a3" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">强生、JNJ、Keras、Autoencoder、Tensorflow</h2></div><p id="39b6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://en.wikipedia.org/wiki/Autoencoder" rel="noopener ugc nofollow" target="_blank">自动编码器</a>是一种无监督学习技术，尽管它们是使用监督学习方法训练的。目标是最小化基于损失函数的重建误差，例如均方误差。</p><p id="c03b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在本帖中，我们将尝试使用<a class="ae lm" href="https://machinelearningmastery.com/lstm-autoencoders/" rel="noopener ugc nofollow" target="_blank"> LSTM 自动编码器</a>来检测<a class="ae lm" href="https://finance.yahoo.com/quote/JNJ/history?p=JNJ" rel="noopener ugc nofollow" target="_blank">约翰逊&amp;约翰逊的历史股价时间序列数据</a>中的异常。</p><p id="54ec" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">数据可以从<a class="ae lm" href="https://finance.yahoo.com/quote/JNJ/history/" rel="noopener ugc nofollow" target="_blank">雅虎财经</a>下载。我选择的时间段是从 1985 年 9 月 4 日到 2020 年 9 月 3 日。</p><p id="b70e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用 LSTM 自动编码器检测强生股票价格数据异常时，我们将遵循的步骤:</p><ol class=""><li id="3505" class="ln lo jb ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">用强生公司从 1985 年 9 月 4 日到 2013 年 9 月 3 日的股票价格数据训练一个 LSTM 自动编码器。我们假设没有异常，它们是正常的。</li><li id="465d" class="ln lo jb ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">使用 LSTM 自动编码器重建 2013 年 9 月 4 日至 2020 年 9 月 3 日测试数据的误差。</li><li id="bc02" class="ln lo jb ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">如果测试数据的重建误差高于阈值，我们将该数据点标记为异常。</li></ol><p id="cf3a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们将分解一个 LSTM 自动编码器网络来逐层理解它们。</p><h1 id="505e" class="mb mc jb bd md me mf mg mh mi mj mk ml kh mm ki mn kk mo kl mp kn mq ko mr ms bi translated">数据</h1><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">LSTM _ 自动编码器 _ 异常. py</p></figure><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/631d81ce057a1d1500a0eb1296069dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r7BPmL_za2TS-wJG8Cjy-w.png"/></div></div></figure><h1 id="2905" class="mb mc jb bd md me mf mg mh mi mj mk ml kh mm ki mn kk mo kl mp kn mq ko mr ms bi translated">可视化时间序列</h1><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">viz_timeseries.py</p></figure><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/74aa84182d1f265d80cebc12208c13bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tTkBafghZOBEpr4AOFi5jQ.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图 1</p></figure><h1 id="90f1" class="mb mc jb bd md me mf mg mh mi mj mk ml kh mm ki mn kk mo kl mp kn mq ko mr ms bi translated">预处理</h1><ul class=""><li id="35e4" class="ln lo jb ks b kt nf kw ng kz nh ld ni lh nj ll nk lt lu lv bi translated">列车测试分离</li></ul><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">火车 _ 测试. py</p></figure><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/a968a12d3d7f13d6da89486c17c5ef19.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*Sn0mvNhMrvYuijI0ScbFsw.png"/></div></figure><ul class=""><li id="4318" class="ln lo jb ks b kt ku kw kx kz lp ld lq lh lr ll nk lt lu lv bi translated">使数据标准化</li></ul><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">标准化. py</p></figure><ul class=""><li id="8bd6" class="ln lo jb ks b kt ku kw kx kz lp ld lq lh lr ll nk lt lu lv bi translated">创建序列</li></ul><p id="a46a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">结合<code class="fe nm nn no np b">TIME_STEPS</code>将输入数据转换成三维数组。根据 LSTM 网络的要求，阵列的形状应为<code class="fe nm nn no np b">[samples, TIME_STEPS, features]</code>。</p><p id="c318" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们希望我们的网络有 30 天的记忆，所以我们设置了<code class="fe nm nn no np b">TIME_STEPS=30</code>。</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">create _ sequences.py</p></figure><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/dc086258c595f1d8d092fbd10c9ca0fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*brqyV0LurLV5rLIx47JvWw.png"/></div></figure><h1 id="9f4c" class="mb mc jb bd md me mf mg mh mi mj mk ml kh mm ki mn kk mo kl mp kn mq ko mr ms bi translated">建立模型</h1><ul class=""><li id="3d00" class="ln lo jb ks b kt nf kw ng kz nh ld ni lh nj ll nk lt lu lv bi translated">我们定义了重建 LSTM 自动编码器架构，其期望具有 30 个时间步长和一个特征的输入序列，并且输出具有 30 个时间步长和一个特征的序列。</li><li id="0521" class="ln lo jb ks b kt lw kw lx kz ly ld lz lh ma ll nk lt lu lv bi translated"><code class="fe nm nn no np b">RepeatVector()</code>重复输入 30 次。</li><li id="6ce4" class="ln lo jb ks b kt lw kw lx kz ly ld lz lh ma ll nk lt lu lv bi translated">设置<code class="fe nm nn no np b">return_sequences=True</code>，那么输出仍然是一个序列。</li><li id="a9fd" class="ln lo jb ks b kt lw kw lx kz ly ld lz lh ma ll nk lt lu lv bi translated"><code class="fe nm nn no np b">TimeDistributed(Dense(X_train.shape[2]))</code>加在最后得到输出，其中<code class="fe nm nn no np b">X_train.shape[2]</code>是输入数据中的特征数。</li></ul><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">LSTM _ 自动编码器. py</p></figure><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/e95492fb933ddf4de58ed2d11656d1a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_EOPLQBMfzK7wFlXX2dag.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图 2</p></figure><h1 id="4f08" class="mb mc jb bd md me mf mg mh mi mj mk ml kh mm ki mn kk mo kl mp kn mq ko mr ms bi translated">训练模型</h1><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">LSTM _ 自动编码器 _ 火车 _ 模型. py</p></figure><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/b9b6e5dec1ce19f62cb907bb1f04f87c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zjMe9QBC_HffFdmeoDSLJA.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图 3</p></figure><pre class="mt mu mv mw gt nt np nu nv aw nw bi"><span id="05b5" class="nx mc jb np b gy ny nz l oa ob">plt.plot(history.history['loss'], label='Training loss')<br/>plt.plot(history.history['val_loss'], label='Validation loss')<br/>plt.legend();</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/7217132b24f14b5c2681471107f947ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*S_s0EIu4YHl5gsoUpCagnQ.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图 4</p></figure><pre class="mt mu mv mw gt nt np nu nv aw nw bi"><span id="729d" class="nx mc jb np b gy ny nz l oa ob">model.evaluate(X_test, y_test)</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi od"><img src="../Images/9f644e48f6ef53ed3f40c070bcd0fee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qdbVA0jFozR7EhMfNYt_kg.png"/></div></div></figure><h1 id="7786" class="mb mc jb bd md me mf mg mh mi mj mk ml kh mm ki mn kk mo kl mp kn mq ko mr ms bi translated">确定异常</h1><ul class=""><li id="0f53" class="ln lo jb ks b kt nf kw ng kz nh ld ni lh nj ll nk lt lu lv bi translated">在训练数据上找到 MAE loss。</li><li id="2651" class="ln lo jb ks b kt lw kw lx kz ly ld lz lh ma ll nk lt lu lv bi translated">将训练数据中的最大 MAE 损失值作为<code class="fe nm nn no np b">reconstruction error threshold</code>。</li><li id="554c" class="ln lo jb ks b kt lw kw lx kz ly ld lz lh ma ll nk lt lu lv bi translated">如果测试集中一个数据点的重建损失大于这个<code class="fe nm nn no np b">reconstruction error threshold</code>值，那么我们将把这个数据点标记为异常。</li></ul><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">LSTM _ 火车 _ 损失. py</p></figure><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/23f0151a84419d33153889eccfbd3c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*c_uE4WS-TQTN42aaP95jEw.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图 5</p></figure><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">test _ 测试 _ 损失. py</p></figure><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi of"><img src="../Images/81a10e5d8c8d1ee1afc9d31f576b581a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*-MqJeqmME5X_QSjW1yI-Lg.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图 6</p></figure><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">测试 _ 损耗 _ vs _ 阈值. py</p></figure><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi og"><img src="../Images/16fd36f71321968635683f70cb33a805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JCb1l7mjYh4gZpK9g_WGBw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图 7</p></figure><pre class="mt mu mv mw gt nt np nu nv aw nw bi"><span id="b15c" class="nx mc jb np b gy ny nz l oa ob">anomalies = test_score_df.loc[test_score_df['anomaly'] == True]<br/>anomalies.shape</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/e8c679cb22a51036c714e8da3f12b2cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:258/format:webp/1*jQzUTGtB4D7rSpN_lpE0Cw.png"/></div></figure><p id="c60e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如您所见，测试集中有 22 个数据点超过了<code class="fe nm nn no np b">reconstruction error threshold</code>。</p><h1 id="4d0c" class="mb mc jb bd md me mf mg mh mi mj mk ml kh mm ki mn kk mo kl mp kn mq ko mr ms bi translated">可视化异常</h1><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">plot_anomalies.py</p></figure><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/b326bae1951cf1fc3d9998f1bf775fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHvS1PUj1EpfhbyaH5ZzdQ.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图 8</p></figure><p id="881f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">模型发现 3 月份出现一些低价异常，4 月份出现高价异常。据详细记载，<a class="ae lm" href="https://www.investors.com/news/technology/jnj-stock-buy-now/" rel="noopener ugc nofollow" target="_blank"> JNJ 股票在 3 月份触及 2020 年低点，但由于对其冠状病毒疫苗</a>的乐观预期，不到一个月之后迅速回升至高点。</p><p id="75c7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://github.com/susanli2016/Machine-Learning-with-Python/blob/master/Timeseries%20anomaly%20detection%20using%20LSTM%20Autoencoder%20JNJ.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>可以在<a class="ae lm" href="https://github.com/susanli2016/Machine-Learning-with-Python/blob/master/Timeseries%20anomaly%20detection%20using%20LSTM%20Autoencoder%20JNJ.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。祝你一周愉快！</p><p id="5398" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">参考资料:</p><div class="ip iq gp gr ir oj"><a href="https://machinelearningmastery.com/lstm-autoencoders/" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd jc gy z fp oo fr fs op fu fw ja bi translated">LSTM 自动编码器简介-机器学习掌握</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">LSTM 自动编码器是一个使用编码器-解码器 LSTM 的序列数据自动编码器的实现</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">machinelearningmastery.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ix oj"/></div></div></a></div><div class="ip iq gp gr ir oj"><a href="https://www.coursera.org/projects/anomaly-detection-time-series-keras" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd jc gy z fp oo fr fs op fu fw ja bi translated">基于 Keras 的时间序列数据异常检测</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">由 Coursera 项目网提供。在这个动手介绍异常检测的时间序列数据与 Keras…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">www.coursera.org</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ix oj"/></div></div></a></div><div class="ip iq gp gr ir oj"><a href="https://keras.io/examples/timeseries/timeseries_anomaly_detection/" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd jc gy z fp oo fr fs op fu fw ja bi translated">Keras 文档:使用自动编码器的时间序列异常检测</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">作者:pavithrasv 创建日期:2020/05/31 最近修改时间:2020/05/31 描述:检测时间序列中的异常…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">keras.io</p></div></div><div class="os l"><div class="oz l ou ov ow os ox ix oj"/></div></div></a></div></div></div>    
</body>
</html>