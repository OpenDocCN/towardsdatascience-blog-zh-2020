<html>
<head>
<title>Time Series Modeling with ARIMA to Predict Future House Price</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用ARIMA时间序列建模预测未来房价</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-modeling-with-arima-to-predict-future-house-price-9b180c3bbd2f?source=collection_archive---------12-----------------------#2020-02-09">https://towardsdatascience.com/time-series-modeling-with-arima-to-predict-future-house-price-9b180c3bbd2f?source=collection_archive---------12-----------------------#2020-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d4ae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从0到1的时间序列分析和建模</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ba605103131e2cabf9bb264ba0d4dc12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*peLpuF9XoHcIOBgbJQfbCg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">艾萨克·史密斯在<a class="ae kv" href="https://unsplash.com/s/photos/chart?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="45a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">时间序列曾经是我在研究生院时试图避免的话题，因为我的同龄人分享的课程非常理论化，课堂上讨论的所有案例都与金融有关，不幸的是，我当时对金融不感兴趣。多亏了我的数据科学训练营，我又有了一次接触时间序列的机会，我发现它在许多情况下都非常实用和有用。这一次，我使用时间序列分析和模型来预测投资布鲁克林的5个最佳邮政编码，我和我丈夫打算在那里购买一套公寓。在这篇博文中，我将分享你需要知道的关于时间序列的基础知识，以及我是如何一步步用ARIMA模型预测房价的。</p><p id="c07f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先我要打下一个时间序列建模项目的架构。我将在后面的章节中详细解释。</p><p id="f720" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第一步:数据处理</strong></p><p id="8546" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第二步:数据探索和可视化</strong></p><p id="52b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第三步:确定模型方法和KPI </strong></p><p id="6418" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">步骤4:在训练集上开发模型，并使用测试集进行验证</strong></p><p id="fd5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第五步:微调模型并进行预测</strong></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="7089" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，时间序列只是在一段时间内以一致的时间间隔测量的一系列定义明确的数据点。时间序列分析帮助我们理解隐藏的模式，有意义的特征和数据的统计。</p><h2 id="69cf" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">第一步:<strong class="ak">数据处理——将原始数据转换成以时间为索引的时间序列</strong></h2><p id="ecb3" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在处理来自Zillow.com的数据集时，我必须首先选择该城市，并使用<em class="mx"> pd.melt </em>将数据框从宽格式重塑为长格式，然后转换为时间序列数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/740eb6b47df09e597ce02072e223b163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Si4GP_tTGULmw_4V_FjQSg.png"/></div></div></figure><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="ed04" class="lz ma iq na b gy ne nf l ng nh">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="d251" class="lz ma iq na b gy ni nf l ng nh">dfm.set_index('Month', inplace = True)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/412aa6297f007d5ecb0329fa7f3e11bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*1KhNZ6Qy9jET_yyoU4A9eA.png"/></div></figure><h2 id="e24b" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">第二步:数据探索和可视化——季节分解、与ACF和PCAF的自相关等。</h2><p id="0aba" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">通过可视化，我们可以识别数据中潜在的趋势和故事。我们来看看布鲁克林的房价随着时间的变化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/9763476b6063d282bc6f2ee49b6fd377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V1guzoQpEz8hdsbmJi9owQ.png"/></div></div></figure><p id="85ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从1996年到2007年可以看到总体上升趋势，随后从2008年到2010年年中出现波动。2011年开始，房价更加稳定，再次持续上涨。我们可以非常自信地说，2008年的房地产市场崩溃是这次波动的原因，我们确实希望跳过这段时间，以便对未来有一个更准确的预测。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/d8aaf58323366e907798ef14b265d72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64p16HWePrbSwxOZPzoZTQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">2011年后趋势更加稳定</p></figure><p id="8cb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们关心的有三个重要特征:<strong class="ky ir">平稳性、季节性和自相关性</strong>。</p><h2 id="ccb8" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated"><strong class="ak">平稳性</strong></h2><p id="f17b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">大多数时间序列模型都假设时间序列是平稳的，这意味着时间序列的统计特性如均值、方差等是平稳的。保持不变。理想情况下，我们希望有一个平稳的时间序列来建模。<em class="mx"> Dickey-Fuller检验</em>可以用来检验一个时间序列是否平稳。注意零假设是:时间序列不是平稳的。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="5dd9" class="lz ma iq na b gy ne nf l ng nh">from statsmodels.tsa.stattools import adfuller</span><span id="f7b9" class="lz ma iq na b gy ni nf l ng nh">dftest = adfuller(ts)</span></pre><h2 id="77e1" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">季节性</h2><p id="1e86" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">季节性是指在一段固定时间内重复的周期性变化和模式。有时，季节性可以与上升或下降趋势相结合。季节性分解总是有助于检测数据集中的季节性、趋势和任何噪声。以布鲁克林住房数据为例:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8a1d" class="lz ma iq na b gy ne nf l ng nh">from statsmodels.tsa.seasonal import seasonal_decompose</span><span id="03be" class="lz ma iq na b gy ni nf l ng nh">decomposition = sm.tsa.seasonal_decompose(month_avg, model='additive')</span><span id="fe1f" class="lz ma iq na b gy ni nf l ng nh">trend = decomposition.trend<br/>seasonal = decomposition.seasonal<br/>residual = decomposition.resid</span><span id="0253" class="lz ma iq na b gy ni nf l ng nh"><em class="mx"># Plot gathered statistics</em><br/>plt.figure(figsize=(12,8))<br/>plt.subplot(411)<br/>plt.plot(month_avg, label='Original', color='blue')<br/>plt.legend(loc='best')<br/>plt.subplot(412)<br/>plt.plot(trend, label='Trend', color='blue')<br/>plt.legend(loc='best')<br/>plt.subplot(413)<br/>plt.plot(seasonal,label='Seasonality', color='blue')<br/>plt.legend(loc='best')<br/>plt.subplot(414)<br/>plt.plot(residual, label='Residuals', color='blue')<br/>plt.legend(loc='best')<br/>plt.tight_layout()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/6240781e9153559452f71d0384e37698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3DOp0vwpSX0ehZ6TtcHkw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">布鲁克林月平均房价的季节分解</p></figure><p id="6af1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的图表中我们可以清楚地看到，随着每年的季节性，有一个上升的趋势。下一步是用<em class="mx"> Dickey-Fuller </em>测试来测试我们的残差。</p><h2 id="1369" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">自相关</h2><p id="067c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">自相关有助于我们研究每个时间序列观测值如何与其最近(或不太最近)的过去相关联。很容易得出，明天的房价极有可能和今天的房价有关。<strong class="ky ir"> ACF(自相关函数)</strong>和<strong class="ky ir"> PACF(偏自相关函数)</strong>是两个强有力的工具。ACF将时间序列的自相关表示为时滞的函数。PACF试图移除观测值和先前时间步长的观测值的自相关中存在的间接相关性</p><p id="be3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查所有邮政编码的月平均价格的ACF和PACF。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="4cb4" class="lz ma iq na b gy ne nf l ng nh">from statsmodels.graphics.tsaplots import plot_acf, plot_pacf<br/>from matplotlib.pylab import rcParams</span><span id="25c4" class="lz ma iq na b gy ni nf l ng nh">rcParams['figure.figsize']=7,5<br/>plot_acf(month_avg); plt.xlim(0,24); plt.show()<br/>plot_pacf(month_avg); plt.xlim(0,24); plt.ylim(-1,1);plt.show()</span></pre><div class="kg kh ki kj gt ab cb"><figure class="nm kk nn no np nq nr paragraph-image"><img src="../Images/ccf4cf1f14538967687a6d2f11f0be5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*JtmbRTSynpUt-SOSsnGhWQ.png"/></figure><figure class="nm kk nn no np nq nr paragraph-image"><img src="../Images/23cf7e203a606a8d627b17c93bda507a.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*H_GDff7mETOQPu8OMI_duw.png"/></figure></div><p id="522e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ACF显示该时间序列与之前的时间周期具有自相关性，然而，PACF没有显示出显著的偏相关。</p><p id="2032" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们从当前月份的值中减去3个月前的值，换句话说，这是一个滞后3的差值。我们可以在PACF图中看到，当滞后=2时，存在负的偏自相关，这意味着滞后-1差异在时间序列数据中是显著的。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="a32c" class="lz ma iq na b gy ne nf l ng nh">plot_acf(month_avg.diff(periods=3).bfill()); plt.xlim(0,24); plt.show()<br/>plot_pacf(month_avg.diff(periods=3).bfill()); plt.xlim(0,24); plt.ylim(-1,1);plt.show()</span></pre><div class="kg kh ki kj gt ab cb"><figure class="nm kk ns no np nq nr paragraph-image"><img src="../Images/0b69cef6d33908f8bc099434e541e134.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*JqRL-ihmubh15v9ilf4YHw.png"/></figure><figure class="nm kk nt no np nq nr paragraph-image"><img src="../Images/8c987402311ac20c42fe2ba170a3fefe.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*WCVfHn75ZdIVZAeEMGmCgA.png"/></figure></div><h2 id="c176" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">步骤3:决定模型方法和KPI</h2><p id="c5e5" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">由于我们的数据集不是静态的，并且存在季节性成分，因此使用SARIMA模型——季节性ARIMA(带有外生回归量的季节性自回归综合移动平均)是合理的。在不深入研究方法论的情况下，我现在将重点关注重要的参数。</p><p id="3c65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据公式SARIMA( <em class="mx"> p </em>，<em class="mx"> d </em>，<em class="mx"> q </em> )x( <em class="mx"> P </em>，<em class="mx"> D </em>，<em class="mx"> Q，s </em>)，这些型号的参数如下:</p><ul class=""><li id="53e6" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr nz oa ob oc bi translated"><strong class="ky ir"> <em class="mx"> p </em> </strong>和季节性<strong class="ky ir"> <em class="mx"> P </em> </strong>:表示自回归项(平稳序列的滞后)的个数</li><li id="69d8" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated"><strong class="ky ir"> <em class="mx"> d </em> </strong> <em class="mx"> </em>和季节性<strong class="ky ir"> <em class="mx"> D </em> </strong>:表示为了平稳化系列必须进行的差分</li><li id="8701" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated"><strong class="ky ir"> <em class="mx"> q </em> </strong>和季节性<strong class="ky ir"> <em class="mx"> Q </em> </strong>:表示移动平均项的个数(预测误差的滞后)</li><li id="bba0" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated"><strong class="ky ir"> <em class="mx"> s </em> </strong>:表示时间序列的周期性(4表示季度，12表示年度)</li></ul><p id="6280" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> KPI:使用AIC选择最佳参数集</strong></p><h2 id="9f66" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated"><strong class="ak">第四步:开发模型并用测试集</strong>验证模型</h2><p id="c7cc" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">由于布鲁克林的Zillow数据集中有29个邮政编码，我决定首先在3个样本邮政编码上构建SARIMA模型，然后遍历所有其他邮政编码。</p><p id="9b5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我首先创建一个数据帧列表，每个数据帧都有一个邮政编码的信息。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="7f3f" class="lz ma iq na b gy ne nf l ng nh">zip_dfs = []<br/>zip_list = dfm.RegionName.unique()<br/>for x in zip_list:<br/>    zip_dfs.append(pd.DataFrame(dfm[dfm['RegionName']==x][['MeanValue']].copy()))</span></pre><p id="2541" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后定义P，D，Q和P，D，Q，s取0到2之间的任意值</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="076f" class="lz ma iq na b gy ne nf l ng nh">p = d = q = range(0,2)<br/># Generate all different combinations of p, d and q triplets<br/>pdq = list(itertools.product(p,d,q))<br/># Generate all different combinations of seasonal p, d and q triplets<br/>pdqs = [(x[0], x[1], x[2], 12) for x in list(itertools.product(p, d, q))]</span></pre><p id="bebe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">萨里玛模型</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="bb96" class="lz ma iq na b gy ne nf l ng nh">ans = []</span><span id="a923" class="lz ma iq na b gy ni nf l ng nh">for df, name in zip(zip_dfs, zip_list):<br/>    for para1 in pdq:<br/>        for para2 in pdqs:<br/>            try:<br/>                mod = sm.tsa.statespace.SARIMAX(df,<br/>                                                order = para1,<br/>                                                seasonal_order = para2,<br/>                                                enforce_stationarity = False,<br/>                                                enforce_invertibility = False)<br/>                output = mod.fit()<br/>                ans.append([name, para1, para2, output.aic])<br/>                print('Result for {}'.format(name) + ' ARIMA {} x {}12 : AIC Calculated = {}'.format(para1, para2, output.aic))<br/>            except:<br/>                continue</span></pre><p id="ff9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后将所有结果存储到数据框中</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8aef" class="lz ma iq na b gy ne nf l ng nh">result = pd.DataFrame(ans, columns = ['name','pdq','pdqs','AIC'])</span></pre><p id="8f1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按最低AIC排序，以找到每个邮政编码的最佳参数</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="17ca" class="lz ma iq na b gy ne nf l ng nh">best_para = result.loc[result.groupby("name")["AIC"].idxmin()]</span></pre><h2 id="1a7f" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">对部分数据进行动态预测，并与真实值进行比较</h2><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="11d9" class="lz ma iq na b gy ne nf l ng nh">#Make Prediction and compare with real values<br/>summary_table = pd.DataFrame()<br/>Zipcode = []<br/>MSE_Value = []<br/>models = []<br/>for name, pdq, pdqs, df in zip(best_para['name'], best_para['pdq'], best_para['pdqs'], zip_dfs):</span><span id="e445" class="lz ma iq na b gy ni nf l ng nh">ARIMA_MODEL = sm.tsa.SARIMAX(df,<br/>                                 order = pdq,<br/>                                 seasonal_order = pdqs,<br/>                                 enforce_stationarity = False,<br/>                                 enforce_invertibility = False,<br/>                                 )<br/>                                <br/>    <br/>    output = ARIMA_MODEL.fit()<br/>    models.append(output)<br/>    <br/>    #get dynamic predictions starting 2017-06-01<br/>    pred_dynamic = output.get_prediction(start=pd.to_datetime('2017-06-01'), dynamic = True, full_results = True)<br/>    pred_dynamic_conf = pred_dynamic.conf_int()<br/>    zip_forecasted = pred_dynamic.predicted_mean<br/>    zip_truth = df['2017-06-01':]['MeanValue']<br/>    <br/>    sqrt_mse = np.sqrt(((zip_forecasted - zip_truth)**2).mean())<br/>    <br/>    Zipcode.append(name)<br/>    MSE_Value.append(sqrt_mse)<br/>    <br/>summary_table['Zipcode'] = Zipcode<br/>summary_table['Sqrt_MSE'] = MSE_Value</span></pre><h2 id="65f2" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">第五步:预测未来</h2><p id="7b7d" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">下一步将是使用完整的数据集来预测未来的值。我用3年作为例子。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="f64e" class="lz ma iq na b gy ne nf l ng nh">#Final Model <br/>forecast_table = pd.DataFrame()<br/>current = []<br/>forecast_3Yr = []<br/><br/><br/>for zipcode, output, df in zip(Zipcode, models, zip_dfs):<br/>    pred_3 = output.get_forecast(steps = 36)<br/>    pred_conf_3 = pred_3.conf_int()<br/>    forecast_3 = pred_3.predicted_mean.to_numpy()[-1]<br/>    current.append(df['2018-04']['MeanValue'][0])<br/>    forecast_3Yr.append(forecast_3)<br/>    </span><span id="0c95" class="lz ma iq na b gy ni nf l ng nh">forecast_table['Zipcode'] = Zipcode<br/>forecast_table['Current Value'] = current<br/>forecast_table['3 Years Value'] = forecast_3Yr<br/></span><span id="2600" class="lz ma iq na b gy ni nf l ng nh">forecast_table['3Yr-ROI']=(forecast_table['3 Years Value'] - forecast_table['Current Value'])/forecast_table['Current Value']</span></pre><p id="906c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我的最终结果:</p><ul class=""><li id="3c53" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr nz oa ob oc bi translated">11220年:南日落公园(3年投资回报率:17%-87%)</li><li id="5904" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">第11205名:克林顿·希尔(3年投资回报率:16%-78%)</li><li id="7569" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">11203年:东弗拉特布什(3年投资回报率:8%-78%)</li><li id="2a9b" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">11224年:科尼岛(3年投资回报率:-0.5%-76%)</li><li id="529d" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">11217年:博勒姆山(3年投资回报率:6%-61%)</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/6d78d946fa593c8c71fb885e2e2b9d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*23ZaJTrvX8yAjcITuSjuhg.jpeg"/></div></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="e7fc" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">下一步</h2><p id="92cf" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">该模型纯粹基于时间序列，因此预测可能不太准确，因为显然还有许多其他因素影响房价，如经济、利率、房屋市场安全得分等。</p><p id="bc0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果要考虑其他因素，线性模型会更理想。</p><p id="5fdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！让我知道你的想法。</p><p id="61fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有用的资源:</p><p id="66af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/@josemarcialportilla/using-python-and-auto-arima-to-forecast-seasonal-time-series-90877adff03c" rel="noopener">利用Python和自动ARIMA预测季节性时间序列</a></p><p id="5eac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/almost-everything-you-need-to-know-about-time-series-860241bdc578">关于时间序列你需要知道的一切</a></p></div></div>    
</body>
</html>