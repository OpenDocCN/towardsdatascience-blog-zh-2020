<html>
<head>
<title>From a Vision to production: Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从愿景到生产:第 3 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-a-computer-vision-idea-to-an-mvp-deployment-part-3-6d6528809f80?source=collection_archive---------44-----------------------#2020-09-04">https://towardsdatascience.com/from-a-computer-vision-idea-to-an-mvp-deployment-part-3-6d6528809f80?source=collection_archive---------44-----------------------#2020-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e932" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">你建立了一个 ML 模型——</em><a class="ae km" href="https://github.com/aditi310896/Bulbdetection/blob/master/Multiclassmodeltrial1.ipynb" rel="noopener ugc nofollow" target="_blank"><em class="kl">这个</em> </a> <em class="kl">之后，你做什么呢？你如何把它变成可以在网上展示的东西？你如何把它变成其他人可以使用的东西，与之互动，并使之有用？<br/>你部署一下！</em></p><p id="54d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">大多数时候，人们在构建统计模型的阶段结束他们的项目，这可能是数据科学家的典型角色，他们通常不会最终将他们的模型作为开源软件部署到互联网上进行真实世界的测试，因为人们通常认为</em> <strong class="jp ir"> <em class="kl">前端和后端开发</em> </strong> <em class="kl">会发挥作用(这也是我在这个项目开始时的想法:P) </em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/bca03d06d0a0cae00cbf636f9e329279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hIvfnClY7bGKSrfcAxpFbg.jpeg"/></div></div><p class="kz la gj gh gi lb lc bd b be z dk translated">图片来源:Pexels</p></figure><p id="1d9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然有一些更简单的方法可以做到这一点，我将在我的博客中解释。我们使用 Heroku 和 Github 在 web 上部署我们的模型。</p><p id="a71e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章我们要看什么？<br/> 1。使用你编码并从头构建的模型来制作应用。<br/> 2。如何整合谷歌模式做 app？<br/> 3。在本地机器上部署这两种方法。<br/> 5。将模型推送到 Github 并部署在 Heroku 上</p><p id="9361" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么是烧瓶？<br/>当我到达这个阶段时，我想先在 GitHub 页面上部署这个模型。GitHub Pages 是一个免费的静态站点托管服务，旨在托管来自 GitHub 库的项目。</p><p id="152a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用 web 应用程序时，我不能使用 GitHub 页面来托管它们。GitHub Pages 只适用于静态网站，而不适用于需要服务器和数据库的动态应用程序。你必须使用云服务，比如亚马逊网络服务来链接 Gitpages。所以 flask 是下一个选择，因为它使用<strong class="jp ir"> Python 作为服务器端语言</strong>，并且确实与模型完美集成。我了解到我可以使用名为 Flask 的框架来使用 Python 作为服务器端语言</p><h2 id="dd74" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated"><strong class="ak">使用您的编码 CNN: </strong></h2><p id="7a08" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">使用 Flask 在 Herkou 上部署您的模型以供开源使用。</p><p id="5835" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">了解你的应用部署基础知识(如果你想看的话，可以在这里找到官方安装指南！)</p><p id="36cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">建立一个虚拟环境来管理项目的依赖关系是一个好主意。为此，您可以为您的项目设置一个文件夹，然后在您的终端上运行:</p><pre class="ko kp kq kr gt mb mc md me aw mf bi"><span id="6360" class="ld le iq mc b gy mg mh l mi mj">mkdir myproject<br/>cd myproject<br/>python3 -m venv venv</span></pre><blockquote class="mk ml mm"><p id="bc3a" class="jn jo kl jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated"><em class="iq">我将在这里用 Python 3 做 Windows 上的作品。如果您在 Mac 上工作或运行 Python 2，您可能想看看官方文档，看看您可能需要调整什么来启动和运行。</em></p></blockquote><p id="53c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，激活您的环境并安装 flask</p><pre class="ko kp kq kr gt mb mc md me aw mf bi"><span id="8d8a" class="ld le iq mc b gy mg mh l mi mj">py -3 -m venv venv<br/>pip install Flask</span></pre><p id="d1c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要创建一个非常小的 Flask 应用程序，首先要创建一个文件。创建文件并在文本编辑器中打开它。然后打字</p><pre class="ko kp kq kr gt mb mc md me aw mf bi"><span id="c850" class="ld le iq mc b gy mg mh l mi mj"><strong class="mc ir">from</strong> flask <strong class="mc ir">import</strong> Flask<br/>app = Flask<strong class="mc ir">(</strong>__name__<strong class="mc ir">)</strong></span><span id="2943" class="ld le iq mc b gy mq mh l mi mj">@app.route<strong class="mc ir">(</strong>'/'<strong class="mc ir">)</strong><br/><strong class="mc ir">def</strong> hello_world<strong class="mc ir">():</strong><br/>    <strong class="mc ir">return</strong> 'Hello, there!'</span></pre><p id="f875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码是做什么的？</p><p id="8521" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们导入了 Flask 类。接下来，我们创建了该类的一个实例。第一个参数是应用程序模块的名称。如果你使用单个模块，你将使用<code class="fe mr ms mt mc b">(__name__)</code>以便 Flask 知道在哪里寻找东西。“route”部分告诉 Flask 哪个 URL 应该触发我们的函数。我们给这个函数一个名字，这个名字也用来为这个函数生成 URL，并返回我们希望在用户浏览器中显示的消息。</p><p id="75ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以把这个存成 hello.py 或者 whatever.py 或者任何让你开心的东西。只是<strong class="jp ir">不要存成 flask.py </strong>因为那会和 flask 冲突。我喜欢用 app.py 作为 flask 的主文件，因为这将是 Flask 以后想要找到的文件。</p><p id="febd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想运行它，请在您的终端上键入:</p><pre class="ko kp kq kr gt mb mc md me aw mf bi"><span id="4e62" class="ld le iq mc b gy mg mh l mi mj">set FLASK_ENV=development<br/>set FLASK_APP=app.py</span></pre><p id="bef5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在运行<code class="fe mr ms mt mc b">flask run</code>之前运行这个命令。这将使您处于开发模式。这意味着，当您更改代码时，您的服务器会自动重新加载，而不是每次更改代码时都必须手动重启。当出现问题时，它还会为您提供一个非常有用的调试器！<br/>然后运行:</p><pre class="ko kp kq kr gt mb mc md me aw mf bi"><span id="d351" class="ld le iq mc b gy mg mh l mi mj">flask run</span></pre><p id="d450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一切正常，您会看到类似这样的内容</p><pre class="ko kp kq kr gt mb mc md me aw mf bi"><span id="f0de" class="ld le iq mc b gy mg mh l mi mj">Running on <a class="ae km" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/</a></span></pre><p id="f42e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您可以将它复制并粘贴到浏览器中。看看有没有用！要关闭它，你可以在终端窗口输入 Control C</p><p id="4b50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过更改您的<strong class="jp ir"> app.py 文件来轻松传递值。</strong>我的 app.py 文件是这样的:</p><pre class="ko kp kq kr gt mb mc md me aw mf bi"><span id="3933" class="ld le iq mc b gy mg mh l mi mj">from flask import Flask, request, render_template<br/>app = Flask(__name__)</span><span id="bbad" class="ld le iq mc b gy mq mh l mi mj">from commons import get_model<br/>from inference import read_image<br/>from inference import time<br/>from inference import test_single_image<br/>#import os<br/>#from werkzeug.utils import secure_filename</span><span id="d25c" class="ld le iq mc b gy mq mh l mi mj"><a class="ae km" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/', methods=['GET', 'POST'])<br/>def hello_world():<br/> if request.method == 'GET':<br/>  return render_template('index.html', value='hi')<br/> if request.method == 'POST':<br/>  print(request.files)<br/>  if 'file' not in request.files:<br/>   print('file not uploaded')<br/>   return<br/>  file = request.files['file']<br/>  # Save the file to ./uploads in case you want to save uploads<br/>  #basepath = os.path.dirname(__file__)<br/>  #img_path = os.path.join(basepath, 'uploads', secure_filename(file.filename))<br/>  #print(img_path)<br/>  #file.save(img_path)<br/>  bulbimage = file.read()<br/>  print(bulbimage)<br/>  bulbpreds,final = test_single_image(path=bulbimage)<br/>  test_single_image(path=bulbimage)<br/>  return render_template('index.html', bulb=bulbpreds,finalpred=final)</span><span id="d16d" class="ld le iq mc b gy mq mh l mi mj">if __name__ == '__main__':<br/> app.run(debug=True)</span></pre><p id="7b6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有了模型。文件，将该检查点放在您的项目文件夹中。</p><p id="e69d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们需要写信获取图像，并将信息发送到模板。首先，您需要一个函数来获取模型并创建您的预测。创建一个<strong class="jp ir"> commons.py </strong>文件，并编写一个函数来获取模型以及允许您将上传的文件转换为张量的内容。试试这个！</p><p id="11d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">公共文件:</p><pre class="ko kp kq kr gt mb mc md me aw mf bi"><span id="3554" class="ld le iq mc b gy mg mh l mi mj">import io<br/>import torch<br/>from PIL import Image<br/>from keras import layers<br/>from keras import models<br/>from keras import optimizers<br/>from keras.preprocessing.image import ImageDataGenerator<br/>from keras.preprocessing.image import img_to_array, load_img<br/>from keras.models import load_model<br/>import tensorflow as tf</span><span id="3023" class="ld le iq mc b gy mq mh l mi mj">def get_model():<br/> global model<br/> model = load_model('checkpoint_final.h5')<br/> print("Loaded Model from disk")<br/> model.compile(loss='categorical_crossentropy',optimizer='adam',metrics=['accuracy'])<br/> return model</span></pre><p id="d57d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保从其他文件中导入您使用的函数，比如从 commons import get_model 导入<strong class="jp ir">。<br/> </strong>该函数读入图像，转换成 NumPy 格式，并调整图像大小以传入模型。然后它调用 model.predict，后者从 commons.py 文件中获取模型。整理灯泡类并返回预测。</p><p id="bd86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，创建一个<strong class="jp ir">推论. py </strong>文件。我们需要能够整理出灯泡的名称、类别和标签，所以您可以编写如下内容:</p><pre class="ko kp kq kr gt mb mc md me aw mf bi"><span id="3f18" class="ld le iq mc b gy mg mh l mi mj">rom keras import layers<br/>from keras import models<br/>import numpy as np<br/>from keras import optimizers<br/>from commons import get_model<br/>from keras.preprocessing import image<br/>from keras.preprocessing.image import ImageDataGenerator<br/>from keras.preprocessing.image import img_to_array, load_img<br/>from PIL import Image<br/>import io<br/>#import torchvision.transforms as transforms<br/>import cv2</span><span id="cdcc" class="ld le iq mc b gy mq mh l mi mj">def read_image(file_path):<br/>    print("[INFO] loading and preprocessing image...")<br/>    #print(file_path)<br/>    bulbimage = np.array(Image.open(io.BytesIO(file_path)))<br/>    bulbimage = cv2.resize(bulbimage, dsize=(400, 400))<br/>    <br/>    #print(bulbimage)<br/>    #my_transforms = transforms.Compose([transforms.Resize(400)])<br/>    #bulbimage=my_transforms(bulbimage)<br/>    #print(bulbimage)<br/>    #bulbimage= load_img(file_path, target_size=(400, 400))  <br/>    #bulbimage = img_to_array(bulbimage)<br/>    bulbimage = bulbimage.astype('float') <br/>    #bulbimage= np.array(bulbimage).copy() <br/>    bulbimage = np.expand_dims(bulbimage, axis=0)<br/>    bulbimage /= 255.<br/>    print(bulbimage)<br/>    return bulbimage</span><span id="dea8" class="ld le iq mc b gy mq mh l mi mj">model=get_model()<br/>import time<br/>def test_single_image(path):<br/>    bulbs = ['A19', 'BR2040', 'MR16', 'PAR203038', 'R20', 'T5T8']<br/>    images = read_image(path)<br/>    time.sleep(.5)<br/>    preds = model.predict(images)  <br/>    predictions = {<br/>        "A19":round(preds[0][0],2),<br/>        "BR2040":round(preds[0][1],2),<br/>        "MR16":round(preds[0][2],2),<br/>        "PAR203038":round(preds[0][3],2),<br/>        "R20":round(preds[0][4],2),<br/>        "T5T8":round(preds[0][5],2),}<br/>    print('Final Decision:')<br/>    time.sleep(.5)<br/>    for x in range(3):<br/>        print('.'*(x+1))<br/>        time.sleep(.2)<br/>    class_predicted = model.predict_classes(images)<br/>    #class_predicted.shape()<br/>    class_dictionary= {'A19': 0, 'BR2040': 1, 'MR16': 2, 'PAR203038': 3, 'R20': 4, 'T5T8': 5} <br/>    inv_map = {v: k for k, v in class_dictionary.items()} <br/>    result= inv_map[class_predicted[0]]<br/>    #print("ID: {}, Label: {}".format(class_predicted[0], inv_map[class_predicted[0]]))  <br/>    return predictions,result</span></pre><p id="58ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的 index.html 看起来像:</p><pre class="ko kp kq kr gt mb mc md me aw mf bi"><span id="9f32" class="ld le iq mc b gy mg mh l mi mj">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;Bulb App&lt;/title&gt;<br/>&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;style&gt;<br/>body {<br/>margin: 0;<br/>font-family: Arial, Helvetica, sans-serif;<br/>}<br/>.hero-image {<br/>background-image: linear-gradient(rgba(0, 0, 0, 0.3),rgba(0, 0, 0, 0.3)), url("/static/image.jpg");<br/>background-color: #cccccc;<br/>height: 800px;<br/>background-position: center;<br/>background-repeat: no-repeat;<br/>background-size: cover;<br/>position: relative;<br/>}<br/>.hero-text {<br/>text-align: center;<br/>position: absolute;<br/>top: 50%;<br/>left: 50%;<br/>transform: translate(-50%, -50%);<br/>color: white;<br/>}<br/>input[type=file] {<br/>width: 100%;<br/>padding: 12px 20px;<br/>margin: 8px 0;<br/>display: block;<br/>width: 200px;<br/>color: white;<br/>justify-content: center;<br/>align-items: center;<br/>text-align: center;<br/>box-sizing: border-box;<br/>border-style: solid white;<br/>border-width: 2px;<br/>border-radius: 2px;<br/>}<br/>input[type=submit] {<br/>width: 100%;<br/>padding: 12px 20px;<br/>margin: 8px 0;<br/>display: block;<br/>width: 200px;<br/>font-size: 1.5em;<br/>color: white;<br/>justify-content: center;<br/>align-items: center;<br/>text-align: center;<br/>box-sizing: border-box;<br/>background-color: #DC143C;<br/>border-radius: 4px;<br/>}<br/>&lt;/style&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;div class="hero-image"&gt;<br/>&lt;div class="hero-text"&gt;<br/>&lt;h1 style="font-size:50px"&gt;Bulb Classifier&lt;/h1&gt;<br/>&lt;h3&gt;Upload a picture of a bulb to see what type it is! &lt;/h3&gt;</span><span id="9c67" class="ld le iq mc b gy mq mh l mi mj">&lt;form method ='file' enctype=multipart/form-data&gt;<br/>&lt;input type="file" name="file"&gt;<br/>&lt;input type="submit" value="upload"&gt;&lt;ul class="actions"&gt;<br/>&lt;h4&gt;Predictions: {{ bulb }}&lt;/p&gt;<br/>&lt;h5&gt;Final Prediction:{{ finalpred }}&lt;/p&gt;<br/>&lt;/div&gt;<br/>&lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;<br/></span><span id="312d" class="ld le iq mc b gy mq mh l mi mj">def get_model():<br/> global model<br/> model = load_model('checkpoint_final.h5')<br/> print("Loaded Model from disk")<br/> model.compile(loss='categorical_crossentropy',optimizer='adam',metrics=['accuracy'])<br/> return model</span></pre><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/0b5b2ce292d535a1f4484b32736ca63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*0WsnPKqHr_4N8LxifkGzzg.png"/></div></figure><p id="006d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是您应该拥有的文件结构。不要担心<br/>静态文件夹包含你在背景中使用的图像。templates 文件夹包含 index.html 文件，您将需要在 Heroku 中进行部署的文件需求，可以通过</p><p id="d474" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数读入图像，转换成 NumPy 格式，并调整图像的大小以传递到模型中。然后它调用 model.predict，后者从 commons.py 文件中获取模型。整理灯泡类并返回预测。<br/>看起来很简单，你应该能够上传一张图片并得到一个结果！</p><p id="eb6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果你想让公众可以使用它，让它对所有人开放。如果您想使用此应用程序部署到 Heroku，请跳到下一节。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="0416" class="nc le iq bd lf nd ne nf li ng nh ni ll nj nk nl lo nm nn no lr np nq nr lu ns bi translated">使用 Auto ML 模型集成到您的 web 应用程序中</h1><p id="dd6f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">使用 AutoML 的<code class="fe mr ms mt mc b">TensorFlow.js</code>模型格式的过程需要两个步骤:导出模型，然后加载它进行推理。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/89768f077b59feeaa0797dba3c58292a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lfk3fA9DwP01vWA5yuPrCw.png"/></div></div></figure><p id="7438" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下分步说明将帮助您加载任何基于 TF.js 的模型，并在您本地计算机的浏览器中部署您的应用程序，我们将为代码添加一些火花，以将其用作一个应用程序，人们可以上传图像并轻松获得他们的预测。这是一个良好的开端:</p><div class="nt nu gp gr nv nw"><a href="https://cloud.google.com/vision/automl/docs/tensorflow-js-tutorial" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">Edge TensorFlow.js 教程|云自动视觉文档</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">术语:参见 AutoML Vision Edge 术语页面，了解本教程中使用的术语列表。在本教程中…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">cloud.google.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok kx nw"/></div></div></a></div><blockquote class="mk ml mm"><p id="fe95" class="jn jo kl jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated"><em class="iq"/><code class="fe mr ms mt mc b"><em class="iq">loadImageClassification</em></code><em class="iq">函数在运行时使用</em> <code class="fe mr ms mt mc b"><em class="iq">model.json.</em></code>加载模型</p><p id="e549" class="jn jo kl jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated"><em class="iq"/><code class="fe mr ms mt mc b"><em class="iq">model.json</em></code><em class="iq">文件包含了所有</em> <code class="fe mr ms mt mc b"><em class="iq">.bin</em></code> <em class="iq">模型文件的信息。<br/>加载该文件会自动加载 TensorFlow.js </em>中的模型</p><p id="16ac" class="jn jo kl jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated"><em class="iq"/><code class="fe mr ms mt mc b"><em class="iq">classify</em></code><em class="iq">功能可应用于图像</em> <code class="fe mr ms mt mc b"><em class="iq">DOM</em></code> <em class="iq">元素。也就是说你只需要替换这里的 image DOM 元素:<br/> </em> <code class="fe mr ms mt mc b"><em class="iq">const image = document.getElementById('daisy');</em></code> <em class="iq">就可以得到图像预测。</em></p></blockquote><p id="f7b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于训练，<code class="fe mr ms mt mc b">classify</code>函数返回一个 JSON 文件，其中包含了这些类的置信度得分。</p><p id="919a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据你训练的模型类型，输出模型。JSON 和 bin 文件应该如下所示:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/08f92f27bbdd0c3c522789e3059b815c.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*d7M7kUL0TM0KUxDIlT3q5g.png"/></div></figure><p id="2642" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">templates 文件夹包含第二个文件夹中的文件，但是 model.json 文件也可以放在主文件夹中</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi om"><img src="../Images/8925cdb50848dbd63efba66217bcd768.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*iQhw4YUub8Xrv0FkFXUQSA.png"/></div></figure><p id="3c27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您没有 git 帐户，您可以在 git 上创建一个帐户，初始化一个存储库并上传存储库中的所有文件夹。<br/>通过键入以下内容将要求归档，您将看到下载的文本文件:</p><pre class="ko kp kq kr gt mb mc md me aw mf bi"><span id="5539" class="ld le iq mc b gy mg mh l mi mj">pip freeze &gt; requirements.txt</span></pre><p id="1668" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我能够上传模型，将其集成到 Heroku 中，并将其部署在 Heroku 上，而无需使用任何命令行界面。但是，如果您使用的是您编码的模型，则. h5 文件很大，需要通过 CLI 推送到 Github，您需要使用 Git LFS 来推一个大于 25mb 的文件。<br/>您可以在此浏览文档:</p><div class="nt nu gp gr nv nw"><a href="https://git-lfs.github.com/" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">Git 大文件存储</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">下载并安装 Git 命令行扩展。下载并安装后，为您的用户设置 Git LFS…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">git-lfs.github.com</p></div></div><div class="of l"><div class="on l oh oi oj of ok kx nw"/></div></div></a></div><p id="083d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想用命令行上传到 Heroku 你可以看这里:</p><div class="nt nu gp gr nv nw"><a href="https://devcenter.heroku.com/articles/git" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">使用 Git 部署</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">Heroku 使用流行的版本控制系统 Git 管理应用部署。你绝对不需要成为一个饭桶…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">devcenter.heroku.com</p></div></div><div class="of l"><div class="oo l oh oi oj of ok kx nw"/></div></div></a></div><p id="63c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的 proc 文件应该包含代码</p><pre class="ko kp kq kr gt mb mc md me aw mf bi"><span id="7f12" class="ld le iq mc b gy mg mh l mi mj">python -m http.server $PORT</span></pre><p id="b4d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在 Heroku 上自动观看:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi op"><img src="../Images/30c44571d95753a5f50528df7be9e707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rk6MwE_Am1Ms56zCkO1-Fw.png"/></div></div></figure><p id="00e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按如下方式配置变量:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oq"><img src="../Images/e178e3469c95a245664f97144faf2259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tfP-jd462WgP9U8dpmTIA.png"/></div></div></figure><p id="181d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您已经准备好部署应用程序，只需单击“部署”按钮，您就会看到一个如下所示的链接，其中包含了我们的模型:</p><p id="d91a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">https://bulbdetection.herokuapp.com/templates/<a class="ae km" href="https://bulbdetection.herokuapp.com/templates/" rel="noopener ugc nofollow" target="_blank"/></p><p id="7662" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的 web 应用程序已启动并运行！</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="or os l"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">图片来源:Giphy.com</p></figure><p id="393c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个项目可以在我的 Github repo 找到:<br/>数据准备和模型:<a class="ae km" href="https://github.com/aditi310896/Bulbdetection" rel="noopener ugc nofollow" target="_blank">https://github.com/aditi310896/Bulbdetection</a><br/>部署:<a class="ae km" href="https://github.com/aditi310896/wavelengthmodel" rel="noopener ugc nofollow" target="_blank">https://github.com/aditi310896/wavelengthmodel</a></p></div></div>    
</body>
</html>