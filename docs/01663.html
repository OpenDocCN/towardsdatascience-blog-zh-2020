<html>
<head>
<title>How to secure Azure Functions with Azure AD, Key Vault and VNETs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Azure AD、密钥库和VNETs保护Azure功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-secure-your-azure-function-data-processing-c9947bf724fb?source=collection_archive---------8-----------------------#2020-02-15">https://towardsdatascience.com/how-to-secure-your-azure-function-data-processing-c9947bf724fb?source=collection_archive---------8-----------------------#2020-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a84d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Azure AD、密钥库和VNETs保护Azure功能。然后使用防火墙规则和函数的托管身份连接到Azure SQL。</p><h1 id="3174" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">A.Azure功能安全性-简介</h1><p id="e6f4" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated"><a class="ae ls" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview" rel="noopener ugc nofollow" target="_blank"> Azure Functions </a>是一个流行的工具，用来创建可以执行简单任务的小代码片段。Azure功能可以使用队列触发器、HTTP触发器或时间触发器来触发。Azure函数的典型模式如下:</p><ul class=""><li id="42d1" class="lt lu it js b jt ju jx jy kb lv kf lw kj lx kn ly lz ma mb bi translated">Init:从存储帐户中检索状态</li><li id="f1b8" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">请求:端点被另一个应用程序/用户调用</li><li id="fb9c" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">处理:使用其他Azure资源处理数据</li><li id="81ed" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">响应:将结果回复给呼叫者</li></ul><p id="4d19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">模式如下所示，其中数据从Azure SQL检索并返回给应用程序/用户。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mh"><img src="../Images/826df9d00b38f1b80de1ad934558d88d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3xlNkxoJgxcwdXYzb6xvAg.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">1.安全Azure功能—简介</p></figure><p id="eaf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇博客中，讨论了如何保护Azure函数的安全。其中，使用了Azure AD、托管身份、密钥库、VNET和防火墙规则。为了创建专用和隔离的Azure功能，也可以决定创建单独的<a class="ae ls" href="https://docs.microsoft.com/en-us/azure/app-service/environment/intro" rel="noopener ugc nofollow" target="_blank"> App服务环境(ASE) </a>。然而，ASE可能很难管理，并且涉及更多的成本。因此，在这个博客中没有使用ASE，而是采用了常规的应用服务计划。结构如下:</p><ul class=""><li id="72c2" class="lt lu it js b jt ju jx jy kb lv kf lw kj lx kn ly lz ma mb bi translated">B0。init:Azure函数的安全存储帐户</li><li id="ead8" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">B1/B3。请求-响应:对Azure函数的安全访问</li><li id="253a" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">B2。处理数据:从Azure函数安全访问Azure SQL</li><li id="7f44" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">C.结论</li></ul><p id="6760" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于如何保护你的Azure数据工厂管道的详细信息，请看<a class="ae ls" rel="noopener" target="_blank" href="/how-to-secure-your-azure-data-factory-pipeline-e2450502cd43">这篇</a>博客。在这篇<a class="ae ls" rel="noopener" target="_blank" href="/how-to-create-a-selenium-web-scraper-in-azure-functions-f156fd074503">博客</a>中讨论了部署一个定制的docker映像作为Azure函数来运行Selenium web scraper。</p><h1 id="377a" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">B0。init:Azure函数的安全存储帐户</h1><p id="b897" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">Azure函数总是附带一个支持存储帐户。在此存储帐户上，可以在文件共享中找到代码，并且日志记录被写入blob存储中。在这个博客中，安全帐户的保护如下:</p><ul class=""><li id="a933" class="lt lu it js b jt ju jx jy kb lv kf lw kj lx kn ly lz ma mb bi translated">Azure功能的托管身份(MI)已启用，此MI用于向Azure密钥库进行身份验证以获取/设置机密</li><li id="a21c" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">存储密钥存储在密钥库中，而不是默认的应用程序设置中。此外，Azure功能键存储在这个密钥库中</li><li id="b4fb" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">VNET集成已启用Azure功能，以便所有出站流量都流经此VNET</li><li id="53bb" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">添加了NSG，仅允许到端口443、1433和目的地Azure WestEurope的出站流量</li><li id="dd05" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">只有Azure Function的VNET可以使用防火墙规则访问密钥库。</li><li id="44af" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">(可选)只有Azure Function的VNET可以使用防火墙规则访问支持存储帐户。请注意，这种情况是官方不支持的，请参见<a class="ae ls" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-networking-options#restrict-your-storage-account-to-a-virtual-network" rel="noopener ugc nofollow" target="_blank">此处</a>，它可能会破坏您的应用程序。使用此功能时，如果应用程序仍在工作，则应在部署到生产环境后进行明确测试，如果不工作，则应重新部署应用程序。</li></ul><p id="02c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面描述了在Azure函数模式中保护存储帐户的安全。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mx"><img src="../Images/84194ae0edeaafe53ea21c7628c1482d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mo4dNi3falAWOHamIjFKrA.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">B0。初始化函数安全性</p></figure><p id="3ad9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一步的代码通过使用下面找到，脚本也可以在<a class="ae ls" href="https://github.com/rebremer/azure_function_mi_sqldb/blob/master/scripts_deployment/B0_init_secure_storage_account.ps1" rel="noopener ugc nofollow" target="_blank">我的github </a>上找到。</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="78f0" class="nd kq it mz b gy ne nf l ng nh"><strong class="mz iu"># B0_1. Login </strong><br/>Clear-AzContext -Scope CurrentUser -Force                       Connect-AzAccount<br/><strong class="mz iu"># B0_2. Variables, take same id in all B0/B1B3/B2 scripts</strong><br/>$id = "3405" <br/>$rg = "test-funappsec" + $id + "-rg"                       <br/>$loc = "westeurope"                       <br/>$funname = "test-funappsec" + $id + "-func"<br/>$funstor = "testfunappsec" + $id + "stor"                       <br/>$akv = "test-funappsec" + $id + "-akv"<br/>$funplan = "test-funappsec" + $id + "-plan"<br/>$vnet = "test-funappsec" + $id + "-vnet"                       <br/>$nsg = "test-funappsec" + $id + "-nsg"                       <br/>$subnet = "azurefunction"                       <br/>$addressrange = "10.200.0.0"<br/><strong class="mz iu"># B0_3. Create resource group </strong>                      <br/>az group create -n $rg -l $loc                                               <strong class="mz iu"># B0_4. Create Storage account </strong>                      <br/>az storage account create -n $funstor -g $rg --sku Standard_LRS                                               <strong class="mz iu"># B0_5. Create VNET </strong>                      <br/>az network vnet create -g $rg -n $vnet --address-prefix $addressrange/16 -l $loc                                               <strong class="mz iu"># B0_6. create NSG  </strong>                     <br/>az network nsg create -g $rg -n $nsg                                               <strong class="mz iu"># B0_7. Create firewall rules <br/></strong># Only allow outbound to WE storage, port 443 and Azure WE<br/>az network nsg rule create -g $rg --nsg-name $nsg -n allow_we_stor_sql --priority 100 --source-address-prefixes VirtualNetwork --source-port-ranges '*' --destination-address-prefixes Storage.WestEurope --destination-port-ranges '443' '1433' --access Allow --protocol '*' --description "Allow storage West Europe 443" --direction Outbound                       <br/>az network nsg rule create -g $rg --nsg-name $nsg -n allow_azure_internal --priority 110 --source-address-prefixes VirtualNetwork --source-port-ranges '*' --destination-address-prefixes AzureCloud.WestEurope --destination-port-ranges '*' --access Allow --protocol '*' --description "Azure we" --direction Outbound                       <br/>az network nsg rule create -g $rg --nsg-name $nsg -n deny_all_outbound --priority 130 --source-address-prefixes '*' --source-port-ranges '*' --destination-address-prefixes '*' --destination-port-ranges '*' --access Deny --protocol '*' --description "Deny all outbound" --direction Outbound                                               <strong class="mz iu"># B0_8. Create subnet with NSG to VNET  </strong>                     <br/>az network vnet subnet create -g $rg --vnet-name $vnet -n $subnet --address-prefixes $addressrange/24 --network-security-group $nsg                                               <strong class="mz iu"># B0_9. Turn on firewall </strong>                      <br/>Update-AzStorageAccountNetworkRuleSet -ResourceGroupName $rg -Name $funstor -DefaultAction Deny                                               <strong class="mz iu"># B0_10. Set service endpoints for storage and web app to subnet   </strong>                    Get-AzVirtualNetwork -ResourceGroupName $rg -Name $vnet | Set-AzVirtualNetworkSubnetConfig -Name $subnet -AddressPrefix $addressrange/24 -ServiceEndpoint "Microsoft.Storage", "Microsoft.Web", "Microsoft.Sql", "Microsoft.KeyVault" | Set-AzVirtualNetwork                                               <br/><strong class="mz iu"># B0_11. Add firewall rules to Storage Account    </strong>                   $subnetobject = Get-AzVirtualNetwork -ResourceGroupName $rg -Name $vnet | Get-AzVirtualNetworkSubnetConfig -Name $subnet                       Add-AzStorageAccountNetworkRule -ResourceGroupName $rg -Name $funstor -VirtualNetworkResourceId $subnetobject.Id                                               <strong class="mz iu"># B0_12. Create Azure Function</strong>                       <br/>az appservice plan create -n $funplan -g $rg --sku P1v2 --is-linux                       az functionapp create -g $rg --os-type Linux --plan $funplan --runtime python --name $funname --storage-account $funstor                                               <strong class="mz iu"># B0_13. Turn on managed identity of Azure Function  </strong>                     az webapp identity assign --name $funname --resource-group $rg                                               <strong class="mz iu"># B0_14. Add VNET integration</strong><br/>az webapp vnet-integration add -g $rg -n $funname --vnet $vnet --subnet $subnet                                               <br/><strong class="mz iu"># B0_15. Create key vault     </strong>                  <br/>az keyvault create --name $akv --resource-group $rg --location $loc                                               <strong class="mz iu"># B0_16. Set policy such that Azure Function can read from AKV   </strong>                    $objectid_funname = az functionapp identity show -n $funname -g $rg --query "principalId"                       <br/>az keyvault set-policy -n $akv --secret-permissions set get list --object-id $objectid_funname                                               <br/><strong class="mz iu"># B0_17. Set acl on key vault  </strong>                     <br/>az keyvault network-rule add -n $akv -g $rg --subnet $subnet --vnet-name $vnet                                               <br/><strong class="mz iu"># B0_18. Get storage connection string and add to key vault   </strong>                    $storageconnectionstring = az storage account show-connection-string -n $funstor --query "connectionString"                       <br/>$keyref = az keyvault secret set -n storageconnectionstring --vault-name $akv --value $storageconnectionstring --query "id"                       $appkeyref = "@Microsoft.KeyVault(SecretUri=" + $keyref + ") " -replace '"',''                                               <br/><strong class="mz iu"># B0_19. Set app settings of function <br/></strong># Function gets function keys from AKV instead of storage account     <strong class="mz iu">                  </strong>az functionapp config appsettings set --name $funname --resource-group $rg --settings AzureWebJobsSecretStorageKeyVaultConnectionString="" AzureWebJobsSecretStorageKeyVaultName=$akv AzureWebJobsSecretStorageType="keyvault"                                               az functionapp config appsettings set --name $funname --resource-group $rg --settings AzureWebJobsStorage=$appkeyref                       az functionapp config appsettings set --name $funname --resource-group $rg --settings AzureWebJobsDashboard=$appkeyref                                               <strong class="mz iu"># B0_20. Done</strong></span></pre><h1 id="2338" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">B1B3。请求-响应:对函数的安全访问</h1><p id="c8ed" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">默认情况下，Azure功能键用于对Azure函数的请求进行身份验证。由于Azure功能在web应用中运行，因此可以为Azure功能启用Azure AD身份验证。在这篇博客中，对Azure函数的访问是安全的，如下所示:</p><ul class=""><li id="902d" class="lt lu it js b jt ju jx jy kb lv kf lw kj lx kn ly lz ma mb bi translated">为Azure函数启用了Azure AD，因此只有此Azure AD租户中的对象可以调用该函数。Azure AD中的对象可以是用户、服务主体或托管身份</li><li id="fd4f" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">(可选)仅将Azure AD租户中可以访问该功能的特定对象列入白名单。例如，只有Azure数据工厂实例的托管身份可以执行一个函数(参见这个<a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/(e.g. an ADFv2 managed identity">博客</a>)</li><li id="db60" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">(可选)在Azure功能的防火墙规则中添加<a class="ae ls" href="https://docs.microsoft.com/nl-nl/azure/app-service/app-service-ip-restrictions#adding-and-editing-access-restriction-rules-in-the-portal" rel="noopener ugc nofollow" target="_blank">访问限制</a></li></ul><p id="6136" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">限制对Azure函数的访问如下所示。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ni"><img src="../Images/25acb080a30ddd054cee6287594b9f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_T5sq1VJfzWEN8NSchZyw.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">B1B3。请求-响应安全性</p></figure><p id="0ca6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一步的代码通过使用下面找到，脚本也可以在<a class="ae ls" href="https://github.com/rebremer/azure_function_mi_sqldb/blob/master/scripts_deployment/B1B3_request_response_enable_easy_auth.ps1" rel="noopener ugc nofollow" target="_blank"> my github </a>上找到。</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="ebf4" class="nd kq it mz b gy ne nf l ng nh"><strong class="mz iu"># B1B3_1. Login </strong><br/>Clear-AzContext -Scope CurrentUser -Force                       Connect-AzAccount<br/><strong class="mz iu"># B1B3_2. Variables, take same id in all B0/B1B3/B2 scripts</strong><br/>$id = "3405" # take same id in all B0/B1B3/B2 scripts                                               $rg = "test-funappsec" + $id + "-rg"                       <br/>$funname = "test-funappsec" + $id + "-func"                                               # 0.2 connect to AAD                       <br/>$Environment = "AzureCloud"                       <br/>$aadConnection = Connect-AzureAD -AzureEnvironmentName $Environment                                               <strong class="mz iu"># B1B3_3. Creat App registration    </strong>                   <br/># step 2 is derived from https://devblogs.microsoft.com/azuregov/web-app-easy-auth-configuration-using-powershell/                       $Password = [System.Convert]::ToBase64String($([guid]::NewGuid()).ToByteArray())                       $startDate = Get-Date                       <br/>$PasswordCredential = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordCredential                       $PasswordCredential.StartDate = $startDate                       $PasswordCredential.EndDate = $startDate.AddYears(10)                       $PasswordCredential.Value = $Password                       $identifier_url = "https://" + $funname + ".azurewebsites.net"                       [string[]]$reply_url = $identifier_url + "/.auth/login/aad/callback"                       $reqAAD = New-Object -TypeName "Microsoft.Open.AzureAD.Model.RequiredResourceAccess"                       $reqAAD.ResourceAppId = "00000002-0000-0000-c000-000000000000"                       $delPermission1 = New-Object -TypeName "Microsoft.Open.AzureAD.Model.ResourceAccess" -ArgumentList "311a71cc-e848-46a1-bdf8-97ff7156d8e6","Scope"              <br/>$reqAAD.ResourceAccess = $delPermission1                                               $appRegName = $funname + "_easyauth"                       <br/>$appReg = New-AzureADApplication -DisplayName $appRegName -IdentifierUris $identifier_url -Homepage $identifier_url -ReplyUrls $reply_url -PasswordCredential $PasswordCredential -RequiredResourceAccess $reqAAD                                               <strong class="mz iu"># B1B3_4. Add new AppRole object to app registration </strong>                      # step 3 is derived from https://gist.github.com/psignoret/45e2a5769ea78ae9991d1adef88f6637                       <br/>$newAppRole = [Microsoft.Open.AzureAD.Model.AppRole]::new()                       $newAppRole.DisplayName = "Allow MSI SPN of ADFv2 to authenticate to Azure Function using its MSI"                       $newAppRole.Description = "Allow MSI SPN of ADFv2 to authenticate to Azure Function using its MSI"<br/>$newAppRole.Value = "Things.Read.All"                       <br/>$Id = [Guid]::NewGuid().ToString()                       $newAppRole.Id = $Id                       <br/>$newAppRole.IsEnabled = $true                       $newAppRole.AllowedMemberTypes = "Application"                       $appRoles = $appReg.AppRoles                       <br/>$appRoles += $newAppRole                       <br/>$appReg | Set-AzureADApplication -AppRoles $appRoles                                               <strong class="mz iu"># B1B3_5. Add app registration to web app </strong>                      $authResourceName = $funname + "/authsettings"                       $auth = Invoke-AzResourceAction -ResourceGroupName $rg -ResourceType Microsoft.Web/sites/config -ResourceName $authResourceName -Action list -ApiVersion 2016-08-01 -Force                       $auth.properties.enabled = "True"                       $auth.properties.unauthenticatedClientAction = "RedirectToLoginPage"                       $auth.properties.tokenStoreEnabled = "True"                       $auth.properties.defaultProvider = "AzureActiveDirectory"                       $auth.properties.isAadAutoProvisioned = "False"                       $auth.properties.clientId = $appReg.AppId                       $auth.properties.clientSecret = $Password                       $loginBaseUrl = $(Get-AzEnvironment -Name $environment).ActiveDirectoryAuthority                       $auth.properties.issuer = $loginBaseUrl + $aadConnection.Tenant.Id.Guid + "/"                       $auth.properties.allowedAudiences = @($identifier_url)                       New-AzResource -PropertyObject $auth.properties -ResourceGroupName $rg -ResourceType Microsoft.Web/sites/config -ResourceName $authResourceName -ApiVersion 2016-08-01 -Force                                               <strong class="mz iu"># B1B3_6. Create SPN connected to app registration   </strong>                    $SPN = New-AzADServicePrincipal -ApplicationId $appReg.AppId -DisplayName $appRegName                                                                                             <br/><strong class="mz iu"># B1B3_7. Set "User assignment required?" to true in SPN <br/></strong># (optional, in case you want to whitelist AAD users)                      #Set-AzureADServicePrincipal -ObjectId $SPN.Id -AppRoleAssignmentRequired $true                                                                  <strong class="mz iu"># B1B3_8. Set obj of ADFv2 as only authorized user to log in web app</strong><br/># (optional, in case you want to whitelist AAD users)                        #$adfv2_resource = Get-AzDataFactoryV2 -ResourceGroupName $rg -Name $adfv2_name                       <br/>#New-AzureADServiceAppRoleAssignment -ObjectId $adfv2_resource.Identity.PrincipalId -Id $newAppRole.Id -PrincipalId $adfv2_resource.Identity.PrincipalId -ResourceId $SPN.Id<br/><strong class="mz iu"># B1B3_9. Done</strong></span></pre><h1 id="fc8c" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">B2。进程:从函数安全访问SQLDB</h1><p id="efc1" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">Azure SQL(又名SQLDB)用于从。在这篇博客中，Azure SQL的数据处理受到如下保护:</p><ul class=""><li id="f51e" class="lt lu it js b jt ju jx jy kb lv kf lw kj lx kn ly lz ma mb bi translated">Azure功能的托管身份(MI)已启用，此MI用于向SQLDB进行身份验证</li><li id="ce8d" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">Azure函数的MI被配置为SQLDB中的外部Azure AD对象，并被授予读取者角色以检索数据</li><li id="0180" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">只有Azure函数的VNET可以使用防火墙规则访问SQLDB</li></ul><p id="7359" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面描述了如何限制从Azure函数访问SQLD。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nj"><img src="../Images/fdb5c6d50f23049cd32de829926541b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0F1jY7Fbif-_B-ol3pZ6w.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">2.在SQLDB安全性中处理数据</p></figure><p id="4876" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一步的代码通过使用下面找到，脚本也可以在<a class="ae ls" href="https://github.com/rebremer/azure_function_mi_sqldb/blob/master/scripts_deployment/B2_processing_mi_sqldb.ps1" rel="noopener ugc nofollow" target="_blank"> my github </a>上找到。</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="522f" class="nd kq it mz b gy ne nf l ng nh"><strong class="mz iu"># B2_1. Login </strong><br/>Clear-AzContext -Scope CurrentUser -Force                       Connect-AzAccount<br/><strong class="mz iu"># B2_2. Variables, take same id in all B0/B1B3/B2 scripts<br/></strong>$id = "3405" # take same id in all B0/B1B3/B2 scripts                                               $rg = "test-funappsec" + $id + "-rg"                       <br/>$rg_sql = "test-funappsec" + $id + "-rg"                       <br/>$loc = "westeurope"                       <br/>$funname = "test-funappsec" + $id + "-func"                       $vnet = "test-funappsec" + $id + "-vnet"                       $subnet = "azurefunction"                                               $sqlserver = "test-funappsec" + $id + "-dbs"                       $sqldb = "test-funappsec" + $id + "-sqldb"                       $sqluser = "testfunappsec" + $id + "sqluser"                       $pass = "&lt;&lt;SQLDB password, use https://passwordsgenerator.net/&gt;&gt;"                       $aaduser = "&lt;&lt;your AAD email account&gt;&gt;"                                              <strong class="mz iu"># B2_3. Create logical SQL server and SQLDB</strong><br/>az sql server create -l $loc -g $rg_sql -n $sqlserv -u sqluser -p $pass                       <br/>az sql db create -g $rg_sql -s $sqlserver -n $sqldb --service-objective Basic --sample-name AdventureWorksLT                                               <strong class="mz iu"># B2_4. Configure AAD access to logical SQL server </strong>                      <br/># Connect-AzureAD                       <br/>Set-AzSqlServerActiveDirectoryAdministrator -ResourceGroupName $rg_sql -ServerName $sqlserver -DisplayName $aaduser                                                <strong class="mz iu"># B2_5. log in SQL with AAD (e.g. via portal query editor/SSMS/VSC) </strong>                      # Execute following SQL statement                       <br/>#CREATE USER [&lt;&lt;your azure function name, equal to $funname&gt;&gt;] FROM EXTERNAL PROVIDER;                       <br/>#EXEC sp_addrolemember [db_datareader], [&lt;&lt;your azure function name, equal to $funname&gt;&gt;];                                               <br/><strong class="mz iu"># B2_6. point app settings to database </strong>                      <br/>az functionapp config appsettings set --name $funname --resource-group $rg --settings sqlserver=$sqlserver sqldb=$sqldb                                               <strong class="mz iu"># B2_7. Add firewall rules    </strong>                   <br/>$subnetobject = Get-AzVirtualNetwork -ResourceGroupName $rg -Name $vnet | Get-AzVirtualNetworkSubnetConfig -Name $subnet                       New-AzSqlServerVirtualNetworkRule -ResourceGroupName $rg_sql -ServerName $sqlserver -VirtualNetworkRuleName $subnet -VirtualNetworkSubnetId $subnetobject.Id                                               <strong class="mz iu"># B2_8. Upload code Azure Function </strong>                      <br/># To create Azure Function in Python, see https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/azure-functions/functions-create-first-function-python.md                       <br/># Get code from __init__.py and requirements.txt from this git repo, then run command below                                               func azure functionapp publish $funname<br/><strong class="mz iu"># B2_9. Done</strong></span></pre><h1 id="23c3" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">C.结论</h1><p id="84bf" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">Azure函数是一个流行的工具，用来创建可以执行简单任务的小代码片段。在这篇博客中，讨论了如何保护一个典型的Azure函数，如下所示</p><ul class=""><li id="b37a" class="lt lu it js b jt ju jx jy kb lv kf lw kj lx kn ly lz ma mb bi translated">0.init:Azure函数的安全存储帐户</li><li id="0463" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">1/3.请求-响应:对Azure函数的安全访问</li><li id="ab2f" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">2.处理数据:从Azure函数安全访问SQLDB</li></ul><p id="7862" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面也描述了具有安全性的模式。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nk"><img src="../Images/76418284e54f7e8ee3521ef93322c9b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZCu9rw2aR4xSEeqV87KiQ.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">C.具有安全性的Azure函数模式</p></figure><p id="4880" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">来自《走向数据科学》编辑的提示:</em> </strong> <em class="ko">虽然我们允许独立作者根据我们的</em> <a class="ae ls" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="ko">规则和指导方针</em> </a> <em class="ko">发表文章，但我们不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae ls" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="ko">读者术语</em> </a> <em class="ko">。</em></p></div></div>    
</body>
</html>