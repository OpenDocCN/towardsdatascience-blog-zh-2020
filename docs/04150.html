<html>
<head>
<title>3 MySQL Brain Storming Questions For a Beginner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给初学者的3个MySQL头脑风暴问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-mysql-brain-storming-questions-for-a-beginner-c99ad01963ee?source=collection_archive---------54-----------------------#2020-04-15">https://towardsdatascience.com/3-mysql-brain-storming-questions-for-a-beginner-c99ad01963ee?source=collection_archive---------54-----------------------#2020-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="25b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SQL问题，以评估和提高初学者的技能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0db3fe56c3ef13a6a0aab3d467b84401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-b2FlotbWn73oOlm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内特·格兰特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> T </span>他的文章总结了我在解决各种MySQL难题时发现的有趣且具有挑战性的问题。这些将向您介绍MySQL世界的3个领域，即:</p><ol class=""><li id="0934" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">CASE WHEN语句。</li><li id="443e" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">比较运算符。</li><li id="69a4" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">正则表达式。</li></ol><p id="19e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我相信尝试解决这些问题是MySQL初学者评估他们目前所学技能的一个更好的方法。让我们来看看这些问题。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h2 id="dded" class="mz na it bd nb nc nd dn ne nf ng dp nh li ni nj nk lm nl nm nn lq no np nq nr bi translated">1.标记二叉树节点</h2><p id="ce73" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">这个挑战是标记二叉树的节点。</p><p id="ab64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nx">查询:将二叉树节点标记为根节点、内部节点和叶节点。</em>T9】</strong></p><p id="691e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些不熟悉二叉树的人来说，它看起来会像下面这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/fb32714c40111ac21e0386c2205ee1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*PtzkonpZWd-mGnIXLFzong.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd nz">二叉树</strong></p></figure><p id="cfe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">节点1:根节点(没有父节点，有0个或更多子节点)</p><p id="5ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">节点4、5:内部节点(具有父节点和一个或多个子节点)</p><p id="8710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">节点9、8、2、3:叶节点(有父节点，没有子节点)</p><p id="5ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nx">设N为节点，P为N的父节点，则上述二叉树的数据表如下:</em> </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">双星树</strong></p></figure><p id="908a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决上述问题，可以使用MySQL CASE，其语法如下。</p><p id="ca86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">基本SQL CASE语句语法:</strong></p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="f75c" class="mz na it od b gy oh oi l oj ok">CASE<br/>    WHEN condition1 THEN result1<br/>    WHEN condition2 THEN result2<br/>    .<br/>    .<br/>    .<br/>    WHEN conditionN THEN resultN<br/>    ELSE result<br/>END;</span></pre><p id="eeb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nx"> SQL将二叉树节点标注为根节点、内节点和叶节点:</em> </strong></p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="09a7" class="mz na it od b gy oh oi l oj ok">SELECT N,<br/>CASE<br/>    WHEN P IS NULL THEN 'Root'<br/>    WHEN N IN (SELECT P FROM BinaryTree) THEN 'Inner'<br/>    ELSE 'Leaf'<br/>END<br/>from BinaryTree;</span></pre><p id="756f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">输出:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="47c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解释:</strong></p><ol class=""><li id="7784" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">节点1:P的值为空，因此节点1是根节点。</li><li id="bd16" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">节点4、5:满足这个条件“当N在(从BinaryTree中选择P)”因此它们是内部节点。</li><li id="f90d" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">节点9、8、2、3:无法满足上述两种情况中的任何一种，因此它们是叶节点。</li></ol></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h2 id="4ead" class="mz na it bd nb nc nd dn ne nf ng dp nh li ni nj nk lm nl nm nn lq no np nq nr bi translated">2.查找中间值</h2><p id="aa32" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">不幸的是，MySQL没有计算列的中值的默认函数。有多种方法可以实现这一点，但是，我想分享实现这一点的详细解决方案。</p><p id="6818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">中位数:</strong>中位数是奇数排序列表中的中间数，也是偶数排序列表中中间数的平均值。</p><p id="2b75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑以下数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">标记数据集—奇数</strong></p></figure><p id="01ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述案例中的中位数是30</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">标记数据集—偶数</strong></p></figure><p id="9366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述案例中的中位数是35岁</p><p id="ad74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">奇数值集的MySQL解决方案:</strong></p><p id="d66a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当参考<em class="nx">标记数据集-奇数</em>时，很明显，值30在其之前具有相同数量的元素(aka。2个值)和它下面的元素的相同元素(也称为。2值)。可以按照下面的步骤找到中间值。</p><ol class=""><li id="4d10" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">对于每个值，计算比它小的值的个数。</li><li id="9398" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">对于每个值，计算大于它的值的个数。</li><li id="e0d0" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">找出上面和下面有相同数量的值的值。这将是中间值。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">伯爵</strong></p></figure><p id="922a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上表中，值30有相等数量的大于它的值和相等数量的小于它的值。因此，中值为30。</p><p id="3b68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nx"> SQL查找奇数个数据值的中值:</em> </strong></p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="09bd" class="mz na it od b gy oh oi l oj ok">SELECT marks as Median FROM MarksTable m<br/>WHERE (SELECT COUNT(marks) from MarksTable<br/>       WHERE m.marks &gt; marks) = <br/>       SELECT COUNT(marks) from MarksTable<br/>       WHERE m.marks &lt; marks);</span></pre><p id="beec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">偶数集的MySQL解决方案:</strong></p><p id="e0eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以按照下面的步骤找到偶数组值的中值。</p><ol class=""><li id="c5af" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">对于每个值，找出值的个数加上大于它的个数的1，并在该计数上加1。就当是x吧。</li><li id="c871" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">对于每个值，找出小于它的值的个数。顺其自然吧。</li><li id="d74a" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">找出数据集中X = Y的值，设它为z。</li><li id="ae53" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">对于每个值，找出值的个数加一，小于它的个数加一。假设它是X1。</li><li id="42eb" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">对于每个值，找出大于它的值的个数。就当是Y1吧。</li><li id="cf10" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">找出数据集中X1 = Y1的值。假设是Z1。</li><li id="54f4" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">中位数是Z和Z1的平均值。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">计数</strong></p></figure><p id="9946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据上表，Z值为40，Z1值为30。因此，中位数是这两个值的平均值，即35。</p><p id="68da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nx"> SQL查找偶数个数据值的中位数:</em> </strong></p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="d302" class="mz na it od b gy oh oi l oj ok">SELECT avg(marks)as Median FROM MarksTable m<br/>WHERE (SELECT COUNT(marks) from MarksTable<br/>       WHERE m.marks &gt; marks) + 1 = <br/>       SELECT COUNT(marks) from MarksTable<br/>       WHERE m.marks &lt; marks)<br/>OR<br/>      (SELECT COUNT(marks) from MarksTable<br/>       WHERE m.marks &gt; marks) = <br/>       SELECT COUNT(marks) from MarksTable<br/>       WHERE m.marks &lt; marks) + 1)</span></pre><p id="22d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nx">因此整个查询找出的中位数会如下:</em> </strong></p><p id="8e82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果数据值的数目可被2整除，则该列中的值为偶数，否则为奇数。</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="4073" class="mz na it od b gy oh oi l oj ok">SELECT IF (SELECT COUNT(marks, 2) FROM MarksTable) = 0,<br/>       (SELECT avg(marks)as Median FROM MarksTable m<br/>              WHERE (SELECT COUNT(marks) from MarksTable<br/>              WHERE m.marks &gt; marks) + 1 = <br/>              SELECT COUNT(marks) from MarksTable<br/>              WHERE m.marks &lt; marks)<br/>        OR<br/>              (SELECT COUNT(marks) from MarksTable<br/>              WHERE m.marks &gt; marks) = <br/>              SELECT COUNT(marks) from MarksTable<br/>              WHERE m.marks &lt; marks) + 1)<br/>),<br/>      SELECT marks as Median FROM MarksTable m<br/>              WHERE (SELECT COUNT(marks) from MarksTable<br/>              WHERE m.marks &gt; marks) = <br/>              SELECT COUNT(marks) from MarksTable<br/>              WHERE m.marks &lt; marks)<br/>));</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h2 id="b9b6" class="mz na it bd nb nc nd dn ne nf ng dp nh li ni nj nk lm nl nm nn lq no np nq nr bi translated"><strong class="ak"> 3。查找不以元音字母开头和结尾的名字:</strong></h2><p id="9e63" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">考虑下面的学生姓名数据表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">学生表</strong></p></figure><p id="52e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nx">查询:查找不以元音字母</em> </strong>开头和结尾的学生姓名</p><p id="70f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MySQL支持<strong class="lb iu"> REGEXP </strong>操作符进行基于正则表达式的模式匹配操作。</p><p id="b1e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决上述查询所需的模式是:</p><ol class=""><li id="21f1" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">^:检查字符串的开头。</li><li id="21fb" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">$:检查字符串的结尾</li><li id="e831" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">[abc]:方括号中列出的任何字符。</li></ol><p id="7590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">查询:</strong></p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="eaf5" class="mz na it od b gy oh oi l oj ok">SELECT name FROM studentTable WHERE name NOT IN <br/>       (SELECT name FROM studentTable WHERE name <br/>        REGEXP '^[aeiou]' or name REGEXP '[aeiou]$';</span></pre><p id="db89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">输出:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d33f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>