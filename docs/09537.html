<html>
<head>
<title>Why Iterables Are Powerful in Python — Understand These 5 Distinct Usages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么 Iterables 在 Python 中如此强大——理解这 5 种不同的用法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-iterables-are-powerful-in-python-understand-these-5-distinct-usages-130f364bd0ba?source=collection_archive---------34-----------------------#2020-07-07">https://towardsdatascience.com/why-iterables-are-powerful-in-python-understand-these-5-distinct-usages-130f364bd0ba?source=collection_archive---------34-----------------------#2020-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b184" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">提高您的 Python 技能</h2><div class=""/><div class=""><h2 id="a8db" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">理解 iterables 的这些常见用例，以提高您的 Python 编码技能</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f625519ec0ce607eeaf20025306ef345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JpVtxyNaVh_1-_XM"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@intelligenciya?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿列克谢·鲁班</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="e5d6" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">什么是可迭代的？</h2><p id="e7e7" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">Iterables 是 Python 中重要数据结构的集合。例如，字符串、列表和字典等内置类型都是可迭代的。如果您使用过高阶函数，如<em class="mw">映射</em>和<em class="mw">过滤器</em>，您可能知道这些函数也创建可迭代对象(即<em class="mw">映射</em>和<em class="mw">过滤器</em>对象)。再举一个例子，你可能听说过生成器，它也是具有内存效率的强大工具。</p><p id="6f39" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">这些数据类型是我们在 Python 中使用的 iterables 的常见例子。但是什么是可迭代的呢？《流畅的 Python——一本关于更高级 Python 的好书——的作者卢西亚诺·拉马尔霍给出了以下定义。基本上，可迭代对象是那些可以被转换成迭代器的对象，这样它们的元素就可以被迭代来执行某些操作。</p><blockquote class="nc"><p id="f530" class="nd ne it bd nf ng nh ni nj nk nl mv dk translated">“iter 内置函数可以获取迭代器的任何对象形式。实现返回迭代器的 __iter__ 方法的对象是可迭代的。—卢西亚诺·拉马尔霍的《流畅的蟒蛇》</p></blockquote><p id="d109" class="pw-post-body-paragraph md me it mf b mg nm kd mi mj nn kg ml lr no mn mo lv np mq mr lz nq mt mu mv im bi translated">Iterables 是如此重要，以至于它们在许多地方被用于不同的目的。本文试图对 Python 中 iterables 的常见用例进行系统但非详尽的回顾。在回顾了这些使用场景之后，我希望您会对在 Python 项目中使用 iterables 感到更加舒适。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h2 id="0e3e" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">1.使用 For 循环的迭代</h2><p id="3db9" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">iterables 最明显的用法是在 for 循环中迭代 iterable 的每一项。在底层，每个 iterable 都被转换成一个迭代器(使用前面提到的<code class="fe ny nz oa ob b">iter()</code>函数)，迭代器通过调用<code class="fe ny nz oa ob b">next()</code>函数将项目呈现给 for 循环。当然，当前的文章并不是要提供一个彻底的关于迭代是如何实现的机械论解释(如果感兴趣，请看这里的<a class="ae lh" href="https://medium.com/swlh/understand-pythons-iterators-and-iterables-and-create-custom-iterators-633939eed3e7" rel="noopener">。相反，让我们看看 iterables 在迭代中是如何工作的。如下面的代码片段所示，常见的内置 iterables 都可以在迭代中使用。有两件事值得注意。</a></p><ul class=""><li id="1f9b" class="oc od it mf b mg mx mj my lr oe lv of lz og mv oh oi oj ok bi translated">字符串是可重复的，单个字符被认为是字符串对象的项目。</li><li id="1b95" class="oc od it mf b mg ol mj om lr on lv oo lz op mv oh oi oj ok bi translated">默认情况下，字典会遍历它们的键。如果需要迭代它们的值和项(即键值对)，就必须分别使用字典的<code class="fe ny nz oa ob b">values()</code>和<code class="fe ny nz oa ob b">items()</code>方法。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oq or l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">迭代迭代</p></figure></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h2 id="e75f" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">2.集合数据类型构造</h2><p id="5173" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">我们可以使用 iterables 来创建集合数据类型，一些常用的类型包括列表、集合、元组和字典。在包含可管理数量的元素的简单场景中，我们可以使用文字来创建这些数据。如前一节代码片段的开头所示，我们只是指定了将要存储在这些数据容器中的单个元素。很直白，对吧？</p><p id="4daf" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">然而，当我们需要创建包含大量元素的容器数据时，使用文字就不那么方便了。值得注意的是，每种集合数据类型都有自己的构造函数，使用各自的类名，并且它们可以简单地使用 iterables 来创建新的集合对象。下面的代码向您展示了我们如何做到这一点。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oq or l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用 Iterables 构建集合数据</p></figure><p id="4e2f" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">如果你从事数据科学或机器学习，你可能对 NumPy 和 Pandas 包并不陌生。这些包中最基本的数据结构都是使用 iterables 构造的。下面的代码片段向您展示了一些基本用法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oq or l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用 Iterables 创建结构化数据</p></figure></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h2 id="2939" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">3.理解和生成器表达式</h2><p id="0608" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">Python 中一个特别有用的特性是理解技术。具体来说，我们使用理解来创建列表、集合和字典，这些技术被称为列表理解、集合理解和字典理解。它们有以下基本形式。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oq or l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">理解语法</p></figure><p id="82f7" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">如上所示，所有这些形式都包括单行迭代的使用。每个理解都可以有一个可选的条件评估—当它为真时，该项目将被发送到表达式。列表和集合理解都只有一个表达式，而关键字理解有两个表达式，一个表示关键字，另一个表示值。另一个显著的区别是使用方括号来理解列表，而对于其他两个列表，则使用花括号。你必须清楚这些相关技术的微妙之处，因为如果你混淆了这些语法，你可能会得到意想不到的结果或者在你的代码中产生错误。下面的代码片段向您展示了这些理解技术的用例。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oq or l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">理解示例</p></figure><p id="3df6" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">与这些理解技术相关的是生成器表达式，它用于创建生成器。像这些理解的输出一样，生成器表达式的输出(即生成器)也是可迭代的。与这些来自理解的可重复项不同，生成器可以在被请求时产生值，因此它们的内存效率很高。如果你想了解更多关于发电机的知识，你可以在这里找到更多的<a class="ae lh" href="https://medium.com/swlh/generators-in-python-5-things-to-know-c76a1f60427a" rel="noopener"/>。下面让我们看看创建生成器的语法及其用法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oq or l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">生成器与列表</p></figure><p id="a4dd" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">如上所示，生成器只需要少量的内存，因为在这个例子中，它们不会将所有的元素都作为列表加载。重要的是，当我们使用内置的<code class="fe ny nz oa ob b">sum()</code>函数计算这些平方和时，生成器和列表可以产生相同的结果。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h2 id="ec14" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">4.列表和元组解包</h2><p id="2586" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">当我们处理列表和元组时，我们通常需要使用数据的特定部分。常见的方法是使用索引/切片技术，这将允许我们获得单个元素或数据块。然而，索引和切片可能很棘手，因为所用的数字看起来很神奇(也就是说，有人可能很难理解为什么要使用特定的索引)。相反，我们可以使用解包技术，这涉及到按顺序将元素分配给特定的变量。下面我们来看一个微不足道的例子。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oq or l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">元件的拆包</p></figure><p id="a72b" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">在上面的例子中，我们使用了与 iterable 中元素数量相同的变量。然而，为了使解包技术更加强大，Python 支持使用无所不包的方法来解包。具体来说，如果我们使用的变量数量少于 iterable 中的元素数量，带星号的变量将捕获所有剩余的元素。值得注意的是，特定的变量将被创建为可迭代的(即一个<em class="mw">列表</em>对象)。让我们看看这个特殊的用法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oq or l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用星号拆包</p></figure><p id="c223" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">分别给<code class="fe ny nz oa ob b">first_number</code>和<code class="fe ny nz oa ob b">last_number</code>分配列表的第一个和最后一个元素。有趣的是，<code class="fe ny nz oa ob b">middle_numbers</code>捕获了中间的所有数字，并且有一个数据类型为<em class="mw"> list </em>。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h2 id="4a6f" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">5.高阶函数</h2><p id="22a4" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">iterables 的另一个用例是它们是一些高阶函数的输入(即参数)和输出(即返回值)。涉及迭代的两个常见高阶函数是<em class="mw">映射</em>和<em class="mw">滤波器</em>函数。对于<em class="mw">过滤器</em>函数，它需要一个 iterable 和一个过滤函数，这将应用于 iterable 的每个元素。当条件满足时，该项将被保存在迭代器中。让我们看看如何对 iterables 使用<em class="mw"> filter </em>函数。如示例所示，<em class="mw"> filter </em>函数通过只包含可被 3 整除的序列来过滤序列。重要的是，生成的<em class="mw">过滤器</em>对象是一个迭代器，因此能够在迭代中使用。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oq or l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Iterables:过滤函数</p></figure><p id="c2fc" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">对于<em class="mw">映射</em>函数，它将采用一个映射函数和一个或多个 iterables。重要的是，iterables 的数量应该与映射函数接受的参数数量相匹配。iterable 中的每个元素都将被传递给映射函数进行处理。映射的项目将包含在输出<em class="mw">映射</em>对象中，该对象是一个迭代器对象。让我们在下面的代码片段中看看<em class="mw"> map </em>函数是如何工作的。与过滤功能相比，<em class="mw">映射</em>功能是使用映射功能转换对象，而不评估包括哪些元素。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oq or l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Iterables:映射函数</p></figure><p id="d92e" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">作为一个重要的旁注，即使我们可以在 map 和 filter 函数中使用 iterables，如果使用这些高阶函数来创建列表、字典、集合和生成器的整个目的，我们应该考虑使用相应的理解技术，因为它们更具可读性，被认为更 Pythonic 化。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="2533" class="os lj it bd lk ot ou ov ln ow ox oy lq ki oz kj lu kl pa km ly ko pb kp mc pc bi translated">结论</h1><p id="f146" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">在本文中，我们回顾了 Python 中 iterables 的五个常见用例。它们是一个非常宽泛的概念，包括内置的数据类型(例如，字符串、列表和字典)。因此，更好地理解这些用法可以帮助您处理 Python 项目中涉及 iterables 的大部分工作。</p><p id="bc43" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">感谢您阅读本文，祝您用 Python 编程愉快。</p></div></div>    
</body>
</html>