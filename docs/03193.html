<html>
<head>
<title>Optimal stopping and 50 shades of Gauss</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最佳停止和50个高斯阴影</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimal-stopping-and-50-shades-of-gauss-2ed031faf865?source=collection_archive---------39-----------------------#2020-03-26">https://towardsdatascience.com/optimal-stopping-and-50-shades-of-gauss-2ed031faf865?source=collection_archive---------39-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0ea3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我还是个孩子的时候，以色列电视上一个很受欢迎的节目是“谁想成为百万富翁”。对于那些不熟悉这种形式的人来说，参赛者会被问一些选择题形式的琐事问题(在希伯来语中，出于某种原因，这被称为“美国风格”)。如果他是正确的，他的试探性收益会翻倍，但是如果他没有回答正确，他将一无所获。在任何时候，他都可以退出，带着他所拥有的离开。这种直截了当的游戏形式中的主要戏剧是决策——以及对损失一大笔钱的不可避免的遗憾。通常64k NIS级别是真正的戏剧开始的地方。</p><p id="e8c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你如何着手模拟这个决策过程，并建议参赛者何时退出？作为建模者，你需要考虑几个问题:</p><ul class=""><li id="a961" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">这些问题是“公平的”(概率模型)还是“敌对的”，也就是说，在某些时候，产品会试图给你越来越难的问题，这些问题可能针对你的弱点？(然后，在初步问卷中，在你真正擅长的事情上表现很差可能是明智的)</li></ul><p id="e4ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在一个概率模型中，你会假设提升到下一个级别的指标函数来自一个I . I . d .<a class="ae kx" href="https://en.wikipedia.org/wiki/Bernoulli_distribution" rel="noopener ugc nofollow" target="_blank">伯努利试验</a>，其中每个参赛选手都有一个不同的p-强选手的p接近1，而弱选手的p接近0。</p><p id="faaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对抗模型更适合<a class="ae kx" href="https://en.wikipedia.org/wiki/Online_algorithm" rel="noopener ugc nofollow" target="_blank">在线算法</a>框架，所以我不会在这里讨论它。</p><ul class=""><li id="57c1" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">参赛选手<a class="ae kx" href="https://en.wikipedia.org/wiki/Risk_aversion" rel="noopener ugc nofollow" target="_blank">是厌恶风险</a>还是热爱风险？他参加比赛的财务目标是什么？</li></ul><p id="f08f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要想知道如何解决这类问题，让我们转到劳勒的书《随机过程简介》。第4章讨论了“最优停止”的问题。这是概率世界中关于决策的一般概率理论，有时也被称为“随机优化”或“随机控制”。他很好地处理了三种不同的场景——普通最优停止、带成本的最优停止和带折扣因子的最优停止。成本意味着你选择留在游戏本身就有一些成本，所以你每多走一步都会有所损失。贴现因子是同一事物的乘法版本——它意味着仅在下一步获得收益的价值可能是现在获得收益的90%。</p><p id="fb77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看一个练习——4.8——幸运之轮。在这种设置中，一个有12个点的轮子每轮转动一次。它上面有100美元到1100美元的数字，1点是破产——如果达到这个数字，您的所有收益都将丢失，游戏结束。问题是什么时候停止是最优的，在这个策略下你的预期收益是多少。</p><p id="158e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的决策规则看起来怎么样？我们只能使用所谓的<a class="ae kx" href="https://en.wikipedia.org/wiki/Stopping_time" rel="noopener ugc nofollow" target="_blank">停止时间</a>，即只能考虑游戏中目前发生的事情，而不能考虑未来会发生什么的规则。然后，我们需要定义一个从系统的这些状态到我们的决策的映射，在这种情况下，是一个{0，1}变量的退出/继续。可以看出，在我们的例子中，整个历史并不重要——如果你目前有2000美元的试探性收益，你的决定不应该受到你是在两轮中获得1000美元还是在20轮中获得100美元的影响。唯一重要的等式是下面的递归关系:</p><p id="5b13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">V[n+1] = 11/12 * (600 + V[n])</p><p id="67eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也就是说，如果在第n轮有V[n]次试探性的收益，在第n+1轮，你应该预期以1/12的概率获得0次收益，以11/12的概率获得当前的收益+ 600(这一轮的平均赢款)。每当右侧大于当前V[n]时，您应该继续，否则退出。这给出了等式</p><p id="ff9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">V = 11/12 * (600 + V)</p><p id="09f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者干脆V=6600。因此，6600美元是阈值，如果你的钱少，你应该继续，如果你有这个数目或更多，你应该退出。</p><p id="7317" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在给定这个规则，我们可以使用动态规划来计算预期的游戏价值。请注意，游戏的预期价值与您提取的价值并不相同！至于你的策略，你会一直坚持到6600年，但这并不意味着宇宙会允许你走这么远。对于我在这个<a class="ae kx" href="https://github.com/yotam-gafni/simulation_tools" rel="noopener ugc nofollow" target="_blank"> github库</a>中实现的动态编程过程，我们从6600向后传播条件期望。如果我们到达6600点，那么我们可以预期6600点的增益(或者X对于任何X &gt; 6600点)。如果我们到达6500点，根据停止规则，我们可以预期11/12 * (600 + 6500)。如果我们到了6400，我们可以期待1/12 * v(6500) + 10/12 *(650 + 6400)(为什么？)等等。通过线性期望，我们可以推断出游戏的价值大约是3134美元。</p><p id="f728" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我对大多数劳勒最优停止问题的解决方案也在<a class="ae kx" href="https://github.com/yotam-gafni/simulation_tools" rel="noopener ugc nofollow" target="_blank"> github资源库</a>中，你可以在尝试自己解决后查看它们——这些都是很好的问题。</p><p id="dba6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看一个稍微难一点的问题，这次来自Rubinstein Kroese关于蒙特卡罗方法和交叉熵的书。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/473bb03a10579c65735ba1c4cce2ab76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WmqB7PPdC1lbJPBjiz47Mw.png"/></div></div></figure><p id="f5df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以提醒一下，每次你碰到“绳子”(“蛇”)的上侧，你就会下到相应的下侧方块，反之亦然。为了计算穿过整个棋盘的预期时间，您可以尝试以动态编程的方式反向传播条件预期的相同方法，但是当您到达方块16/17时，您会遇到一个小问题——它们实际上取决于尚未计算其值的方块。但这只是意味着，不要把它当作一个动态规划问题，你需要把它当作一个线性方程组问题，并为每个方块求解由递归关系定义的系统。解决方案在snakes.py脚本中，您大约掷出7.1次骰子(我假设您从0开始，每当越过20就结束，但其他常见版本都假设您从1开始，只有当您正好落在20时才结束，否则您会回到掷骰子时的松弛量。这将改变递归关系，并相应地改变预期时间，可能会更长一点)。</p><p id="1c35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以考虑这个问题的优化版本，它与<a class="ae kx" href="https://en.wikipedia.org/wiki/Automated_planning_and_scheduling" rel="noopener ugc nofollow" target="_blank">计划</a>有关。如何定位蛇和梯子，以便最大限度地增加玩耍时间(对于那些希望孩子在家工作时忙碌的父母来说，这很有用)。如何定位它们，使游戏时间的变化最大化(可以带来更有趣的游戏体验)。在所有可能的游戏配置上，我没有发现比蛮力更好的方法，这在小棋盘上是可行的。这产生了大约7.67掷骰子的最大预期游戏时间，但是它在最开始有一个非常清楚的定位梯子的结构(所以有很大的机会完全错过它们)和在最后的绳子，所以看一看是否有更正式的东西可以在总体上解决这个问题是很有趣的。</p><p id="2f47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">高斯50度</strong></p><p id="9593" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在来点完全不同的。我曾经认为模拟随机变量是一个技术和枯燥的领域，但实际上它非常有趣。计算机编程的艺术第2卷第3章给出了一个很好的背景，解决了“什么是随机的”这一重要的哲学问题。既然我们生活在现实世界中，你如何确定一个数字序列是“随机”的？32乘以0的序列与011110011001010000001011011011111101一样代表32次独立的伯努利试验，但不知何故我们认为后者更“随机”。关于<a class="ae kx" href="https://www.academia.edu/39637153/Stochastic_Simulation_Algorithms_and_Analysis_-_Asmussen_S._Glynn_P.W" rel="noopener ugc nofollow" target="_blank">随机模拟</a>的Asmussen书的第1章和第2章给出了关于如何在计算机系统中实现从概率分布中抽取的更多技术背景。重要的概念是，一旦你知道如何模拟任何概率分布，就有办法通过<a class="ae kx" href="https://en.wikipedia.org/wiki/Inverse_transform_sampling" rel="noopener ugc nofollow" target="_blank">反演</a>和<a class="ae kx" href="https://en.wikipedia.org/wiki/Importance_sampling" rel="noopener ugc nofollow" target="_blank">重要性抽样</a>和其他方法将其重塑为任何其他概率分布。练习2.9非常好，它要求你用6种不同的方法从标准正态分布中提取数据。我做了9个。通过对样本执行μ+σ* RES，这可以容易地推广到正态分布的任何参数化(μ，σ)。在这个过程中，我学到了一些关于python实现中这个基本操作的警告的重要经验</p><ul class=""><li id="38b4" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated"><a class="ae kx" href="https://docs.python.org/3.1/library/random.html" rel="noopener ugc nofollow" target="_blank">随机包</a>普通变量实现有点慢。它使用<a class="ae kx" href="https://link.springer.com/chapter/10.1007/978-3-319-72634-2_5" rel="noopener ugc nofollow" target="_blank">制服比例</a>方法，该方法似乎比<a class="ae kx" href="https://en.wikipedia.org/wiki/Box–Muller_transform" rel="noopener ugc nofollow" target="_blank">箱式研磨机</a>变体更慢。高斯函数更好(使用box-muller)，但由于它没有要求多个样本的选项，因此它会抛出许多不必要的样本。由于box-muller每次运行产生两个样本，如果您要求random.gauss产生100k个样本，您实际上将丢弃100k个其他样本，浪费两倍的时间。</li><li id="5731" class="ko kp it js b jt lk jx ll kb lm kf ln kj lo kn kt ku kv kw bi translated">numpy包非常好——特别是因为它使用了cython，这占了节省时间的大部分(比现在提到的2倍因素多得多)。但这只有在你要求一批样品的情况下才适用——如果你一个一个的要求，效率非常低！我很高兴我现在知道它有多重要(对于100k样本，它是0.03秒和20秒之间的差异——660倍的因子)。</li></ul><p id="9d22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码在<a class="ae kx" href="https://github.com/yotam-gafni/simulation_tools" rel="noopener ugc nofollow" target="_blank"> github库</a>中给出。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><a href="https://twitter.com/Suflaky"><div class="gh gi lp"><img src="../Images/d1c1cf5307a9b25a182f4069172834ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*fIUhg_Xlpr73p_N4keHoOQ.png"/></div></a></figure></div></div>    
</body>
</html>