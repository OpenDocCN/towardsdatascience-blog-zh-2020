<html>
<head>
<title>Part 2: STUMPY Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第2部分:STUMPY基础知识</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stumpy-basics-21844a2d2d92?source=collection_archive---------15-----------------------#2020-06-16">https://towardsdatascience.com/stumpy-basics-21844a2d2d92?source=collection_archive---------15-----------------------#2020-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f1b0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用STUMPY分析图案和异常</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/457667ebb41af591c6f867f285b3755c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ZEIlDwiuACYz4Eayb2OjA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由<a class="ae kv" href="https://unsplash.com/@tbzr?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿诺·梅瑟尔</a>拍摄)</p></figure><h1 id="bffc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">整体大于部分之和</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/b9dc45622efb5d6ddbb94d3e2f91b304.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*NWV2vLKBciK49BAVfzvN4Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="1394" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated"><a class="ae kv" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank"> STUMPY是一个强大且可扩展的Python库，用于现代时间序列分析</a>，在其核心，有效地计算出一种叫做<em class="ml">矩阵轮廓</em>的东西。这个多部分系列的目标是解释什么是matrix profile，以及如何开始利用<a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>完成所有现代时间序列数据挖掘任务！</p><p id="b92d" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated"><em class="ml">注:这些教程最初出现在</em> <a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/tutorials.html" rel="noopener ugc nofollow" target="_blank"> <em class="ml"> STUMPY文档</em> </a> <em class="ml">中。</em></p><p id="af9b" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">第1部分:<a class="ae kv" rel="noopener" target="_blank" href="/the-matrix-profile-e4a679269692">矩阵轮廓图</a> <br/>第2部分:<a class="ae kv" rel="noopener" target="_blank" href="/stumpy-basics-21844a2d2d92"> STUMPY基础知识</a> <br/>第3部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-3-time-series-chains-da281450abbf">时间序列链</a> <br/>第4部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-4-semantic-segmentation-b42c3792833d">语义分割</a> <br/>第5部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-5-fast-approximate-matrix-profiles-with-scrump-c6d9c984c560">用STUMPY快速近似矩阵轮廓图</a> <br/>第6部分:<a class="ae kv" rel="noopener" target="_blank" href="/matrix-profiles-for-streaming-time-series-data-f877ff6f9eef">用于流式时间序列数据的矩阵轮廓图</a> <br/>第7部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-7-fast-pattern-searching-with-stumpy-2baf610a8de1">用STUMPY快速模式搜索</a> 10: <a class="ae kv" rel="noopener" target="_blank" href="/part-10-discovering-multidimensional-time-series-motifs-45da53b594bb">发现多维时间序列模体</a> <br/>第11部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-11-user-guided-motif-search-d3d317caf9ea">用户引导的模体搜索</a> <br/>第12部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-12-matrix-profiles-for-machine-learning-2dfd98d7ff3f">机器学习的矩阵轮廓</a></p><h1 id="1cbe" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用残肢分析图案和异常</h1><p id="6970" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">在这篇博客中，我们将使用<a class="ae kv" href="https://stumpy.readthedocs.org/" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>包来看看研究论文中的一些主要内容:<a class="ae kv" href="http://www.cs.ucr.edu/~eamonn/PID4481997_extend_Matrix%20Profile_I.pdf" rel="noopener ugc nofollow" target="_blank">矩阵概要I </a> &amp; <a class="ae kv" href="http://www.cs.ucr.edu/~eamonn/STOMP_GPU_final_submission_camera_ready.pdf" rel="noopener ugc nofollow" target="_blank">矩阵概要II </a>。</p><p id="a4be" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">为了探索基本概念，我们将使用workhorse <code class="fe mr ms mt mu b">stumpy.stump()</code>函数来寻找有趣的主题(模式)或不一致(异常/新奇),并用两个不同的时间序列数据集来演示这些概念:</p><ol class=""><li id="b179" class="mv mw iq lr b ls lt lv lw ly mx mc my mg mz mk na nb nc nd bi translated">Steamgen数据集</li><li id="e993" class="mv mw iq lr b ls ne lv nf ly ng mc nh mg ni mk na nb nc nd bi translated">纽约市出租车乘客数据集</li></ol><p id="276b" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated"><code class="fe mr ms mt mu b">stumpy.stump()</code>是流行的STOMP算法的<a class="ae kv" href="http://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Numba </a> JIT编译版本，在最初的<a class="ae kv" href="http://www.cs.ucr.edu/~eamonn/STOMP_GPU_final_submission_camera_ready.pdf" rel="noopener ugc nofollow" target="_blank"> Matrix Profile II </a>论文中有详细描述。<code class="fe mr ms mt mu b">stumpy.stump()</code>能够进行并行计算，它对特定时间序列内的模式和异常值进行有序搜索，并利用一些计算的局部性来最小化运行时间。</p><h1 id="b651" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">入门指南</h1><p id="d0c1" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">让我们导入加载、分析和绘制数据所需的包。</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="8498" class="nn kx iq mu b gy no np l nq nr">%matplotlib inline<br/><br/>import pandas as pd<br/>import stumpy<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import matplotlib.dates as dates<br/>from matplotlib.patches import Rectangle<br/>import datetime as dt<br/><br/>plt.rcParams["figure.figsize"] = [20, 6]  # width, height<br/>plt.rcParams['xtick.direction'] = 'out'</span></pre><h1 id="ca20" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是主题？</h1><p id="7ecd" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">时间序列基序是在一个较长的时间序列中发现的近似重复的子序列。能够说一个子序列是“近似重复的”需要你能够将子序列相互比较。在STUMPY的情况下，时间序列中的所有子序列可以通过计算成对的z归一化欧几里得距离进行比较，然后只存储其最近邻的索引。这个最近邻距离向量被称为<code class="fe mr ms mt mu b">matrix profile</code>，时间序列内每个最近邻的索引被称为<code class="fe mr ms mt mu b">matrix profile index</code>(参见<a class="ae kv" href="https://medium.com/@seanmylaw/the-matrix-profile-e4a679269692" rel="noopener">第1部分:矩阵轮廓</a>进行全面回顾)。幸运的是，<code class="fe mr ms mt mu b">stumpy.stump()</code>函数接受任何时间序列(具有浮点值),并计算矩阵轮廓和矩阵轮廓索引，反过来，人们可以立即找到时间序列主题。让我们看一个例子:</p><h1 id="e76b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">加载Steamgen数据集</h1><p id="4e61" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">该数据是使用模糊模型生成的，该模型用于模拟位于伊利诺伊州香槟市的Abbott电厂的蒸汽发生器。我们感兴趣的数据特性是输出蒸汽流量遥测，单位为kg/s，数据每三秒“采样”一次，共有9600个数据点。</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="7657" class="nn kx iq mu b gy no np l nq nr">steam_df = pd.read_csv("https://zenodo.org/record/4273921/files/STUMPY_Basics_steamgen.csv?download=1")<br/>steam_df.head()</span><span id="90a2" class="nn kx iq mu b gy ns np l nq nr">drum pressure  excess oxygen  water level  steam flow<br/>    320.08239       2.506774     0.032701    9.302970<br/>   1321.71099       2.545908     0.284799    9.662621<br/>   2320.91331       2.360562     0.203652   10.990955 <br/>   3325.00252       0.027054     0.326187   12.430107<br/>   4326.65276       0.285649     0.753776   13.681666</span></pre><h1 id="23ff" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">可视化Steamgen数据集</h1><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="20a4" class="nn kx iq mu b gy no np l nq nr">plt.suptitle('Steamgen Dataset', fontsize='30')<br/>plt.xlabel('Time', fontsize ='20')<br/>plt.ylabel('Steam Flow', fontsize='20')<br/>plt.plot(steam_df['steam flow'].values)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/fc5706d6cdd8333a7931e033b7e469d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-PEUgvuG103uiAa5-M71w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="f0c8" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">花一点时间，用肉眼仔细检查上面的情节。如果你被告知有一个模式是近似重复的，你能发现它吗？即使对于计算机来说，这也是非常具有挑战性的。以下是您应该寻找的内容:</p><h1 id="ff5a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">手动寻找主题</h1><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="c691" class="nn kx iq mu b gy no np l nq nr">m = 640<br/>fig, axs = plt.subplots(2)<br/>plt.suptitle('Steamgen Dataset', fontsize='30')<br/>axs[0].set_ylabel("Steam Flow", fontsize='20')<br/>axs[0].plot(steam_df['steam flow'], alpha=0.5, linewidth=1)<br/>axs[0].plot(steam_df['steam flow'].iloc[643:643+m])<br/>axs[0].plot(steam_df['steam flow'].iloc[8724:8724+m])<br/>rect = Rectangle((643, 0), m, 40, facecolor='lightgrey')<br/>axs[0].add_patch(rect)<br/>rect = Rectangle((8724, 0), m, 40, facecolor='lightgrey')<br/>axs[0].add_patch(rect)<br/>axs[1].set_xlabel("Time", fontsize='20')<br/>axs[1].set_ylabel("Steam Flow", fontsize='20')<br/>axs[1].plot(steam_df['steam flow'].values[643:643+m], color='C1')<br/>axs[1].plot(steam_df['steam flow'].values[8724:8724+m], color='C2')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/adec3988e24962d561bd7d305830a021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMYtS2Z0Oum2o1v3GyZqOA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="3043" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">上面突出显示了我们正在寻找的基序(图案),但仍然很难确定橙色和绿色的子序列是否匹配(上图)，也就是说，直到我们放大它们并将子序列彼此重叠(下图)。现在，我们可以清楚地看到，母题非常相似！计算矩阵轮廓的基本价值在于，它不仅能让你快速找到基序，还能识别时间序列中所有子序列的最近邻。请注意，我们实际上没有做任何特别的事情来定位主题，除了我们从原始文件中抓取位置并绘制它们。现在，让我们获取steamgen数据，并对其应用<code class="fe mr ms mt mu b">stumpy.stump()</code>函数:</p><h1 id="70c4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">使用STUMP找到主题</h1><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="f95a" class="nn kx iq mu b gy no np l nq nr">m = 640<br/>mp = stumpy.stump(steam_df['steam flow'], m)</span></pre><p id="07d8" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated"><code class="fe mr ms mt mu b">stump</code>需要两个参数:</p><ol class=""><li id="6558" class="mv mw iq lr b ls lt lv lw ly mx mc my mg mz mk na nb nc nd bi translated">时间序列</li><li id="d6f1" class="mv mw iq lr b ls ne lv nf ly ng mc nh mg ni mk na nb nc nd bi translated">一个窗口大小，<code class="fe mr ms mt mu b">m</code></li></ol><p id="e764" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在这种情况下，基于一些领域的专业知识，我们选择了<code class="fe mr ms mt mu b">m = 640</code>，这大约相当于半小时的窗口。同样，<code class="fe mr ms mt mu b">stump</code>的输出是一个数组，它包含所有的矩阵轮廓值(即，到最近邻居的z归一化欧几里德距离)和矩阵轮廓索引，分别在第一和第二列(我们现在忽略第三和第四列)。为了确定基元的索引位置，我们需要找到矩阵轮廓<code class="fe mr ms mt mu b">mp[:, 0]</code>具有最小值的索引位置:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="44fd" class="nn kx iq mu b gy no np l nq nr">motif_idx = np.argsort(mp[:, 0])[0]<br/>print(f"The motif is located at index {motif_idx}")</span><span id="c41e" class="nn kx iq mu b gy ns np l nq nr">The motif is located at index 643</span></pre><p id="9ca4" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">有了这个<code class="fe mr ms mt mu b">motif_idx</code>信息，我们还可以通过交叉引用矩阵轮廓索引来识别其最近邻居的位置，<code class="fe mr ms mt mu b">mp[:, 1]</code>:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="f94a" class="nn kx iq mu b gy no np l nq nr">nearest_neighbor_idx = mp[motif_idx, 1]<br/>print(f"The nearest neighbor is located at index {nearest_neighbor_idx}")</span><span id="610d" class="nn kx iq mu b gy ns np l nq nr">The nearest neighbor is located at index 8724</span></pre><p id="ad2a" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">现在，让我们将所有这些放在一起，并在原始数据旁边绘制矩阵图:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="5847" class="nn kx iq mu b gy no np l nq nr">fig, axs = plt.subplots(2, sharex=True, gridspec_kw={'hspace': 0})<br/>plt.suptitle('Motif (Pattern) Discovery', fontsize='30')</span><span id="9c8d" class="nn kx iq mu b gy ns np l nq nr">axs[0].plot(steam_df['steam flow'].values)<br/>axs[0].set_ylabel('Steam Flow', fontsize='20')<br/>rect = Rectangle((643, 0), m, 40, facecolor='lightgrey')<br/>axs[0].add_patch(rect)<br/>rect = Rectangle((8724, 0), m, 40, facecolor='lightgrey')<br/>axs[0].add_patch(rect)<br/>axs[1].set_xlabel('Time', fontsize ='20')<br/>axs[1].set_ylabel('Matrix Profile', fontsize='20')<br/>axs[1].axvline(x=643, linestyle="dashed")<br/>axs[1].axvline(x=8724, linestyle="dashed")<br/>axs[1].plot(mp[:, 0])</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/a62b56e9e95a5c222f1bf8c8f20d76ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edcAjMPkgDyGVfnzI2VZUg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="7554" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">我们了解到的是，来自矩阵轮廓的全局最小值(垂直虚线)对应于构成基序对的两个子序列的位置！并且这两个子序列之间的精确z归一化欧几里德距离是:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="3c77" class="nn kx iq mu b gy no np l nq nr">mp[:, 0].min()</span><span id="e99b" class="nn kx iq mu b gy ns np l nq nr">5.49161982776594</span></pre><p id="15af" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">因此，这个距离不是零，因为我们之前看到两个子序列不是完全相同的匹配，但是，相对于矩阵分布图的其余部分(即，与矩阵分布图的平均值或中值相比)，我们可以理解这个基序是非常好的匹配。</p><h1 id="8022" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">使用STUMP查找异常</h1><p id="c103" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">相反，矩阵轮廓中的最大值(根据上述<code class="fe mr ms mt mu b">stumpy.stump()</code>计算)为:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="7bf9" class="nn kx iq mu b gy no np l nq nr">print(f"The discord is located at index {discord_idx}")</span><span id="2926" class="nn kx iq mu b gy ns np l nq nr">The discord is located at index 3864</span></pre><p id="cb50" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">与这种不和谐最近的邻居有一段相当远的距离:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="58fa" class="nn kx iq mu b gy no np l nq nr">nearest_neighbor_distance = mp[discord_idx, 0]<br/>print(f"The nearest neighbor subsequence to this discord is {nearest_neighbor_distance} units away")</span><span id="74a0" class="nn kx iq mu b gy ns np l nq nr">The nearest neighbor subsequence to this discord is 23.476168367301987 units away</span></pre><p id="099a" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">位于这个全局最大值的子序列也被称为不一致、新奇或“潜在异常”:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="fc20" class="nn kx iq mu b gy no np l nq nr">fig, axs = plt.subplots(2, sharex=True, gridspec_kw={'hspace': 0})<br/>plt.suptitle('Discord (Anomaly/Novelty) Discovery', fontsize='30')</span><span id="41df" class="nn kx iq mu b gy ns np l nq nr">axs[0].plot(steam_df['steam flow'].values)<br/>axs[0].set_ylabel('Steam Flow', fontsize='20')<br/>rect = Rectangle((3864, 0), m, 40, facecolor='lightgrey')<br/>axs[0].add_patch(rect)<br/>axs[1].set_xlabel('Time', fontsize ='20')<br/>axs[1].set_ylabel('Matrix Profile', fontsize='20')<br/>axs[1].axvline(x=3864, linestyle="dashed")<br/>axs[1].plot(mp[:, 0])</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/30d94b8d72655916dd972cce417e2a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9ta2v6x3AY8VhTV7lJM5Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="8d96" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">为了进一步发展/加强我们不断增长的直觉，让我们继续探索另一个数据集！</p><h1 id="ac68" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">加载纽约市出租车乘客数据集</h1><p id="d87e" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">首先，我们将下载代表2014年秋季75天内纽约市出租车乘客半小时平均人数的历史数据。</p><p id="6859" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">我们提取该数据并将其插入到一个<a class="ae kv" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a> dataframe中，确保时间戳存储为<em class="ml"> datetime </em>对象，并且值的类型为<em class="ml"> float64 </em>。请注意，我们将进行比上面多一点的数据清理，以便您可以看到一个包含时间戳的示例。但是请注意，在计算矩阵概要文件时，<code class="fe mr ms mt mu b">stumpy.stump()</code>实际上根本不使用或者不需要时间戳列。</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="0490" class="nn kx iq mu b gy no np l nq nr">taxi_df = pd.read_csv("https://zenodo.org/record/4276428/files/STUMPY_Basics_Taxi.csv?download=1")<br/>taxi_df['value'] = taxi_df['value'].astype(np.float64)<br/>taxi_df['timestamp'] = pd.to_datetime(taxi_df['timestamp'])<br/>taxi_df.head()</span><span id="85fb" class="nn kx iq mu b gy ns np l nq nr">          timestamp    value<br/>2014-10-01 00:00:00  12751.0<br/>2014-10-01 00:30:00   8767.0<br/>2014-10-01 01:00:00   7005.0<br/>2014-10-01 01:30:00   5257.0<br/>2014-10-01 02:00:00   4189.0</span></pre><h1 id="98bc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">可视化出租车数据集</h1><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="fd3d" class="nn kx iq mu b gy no np l nq nr"># This code is going to be utilized to control the axis labeling of the plots<br/>DAY_MULTIPLIER = 7  # Specify for the amount of days you want between each labeled x-axis tick</span><span id="eb0f" class="nn kx iq mu b gy ns np l nq nr">x_axis_labels = taxi_df[(taxi_df.timestamp.dt.hour==0)]['timestamp'].dt.strftime('%b %d').values[::DAY_MULTIPLIER]<br/>x_axis_labels[1::2] = " "<br/>x_axis_labels, DAY_MULTIPLIER</span><span id="a29d" class="nn kx iq mu b gy ns np l nq nr">plt.suptitle('Taxi Passenger Raw Data', fontsize='30')<br/>plt.xlabel('Window Start Date', fontsize ='20')<br/>plt.ylabel('Half-Hourly Average\nNumber of Taxi Passengers', fontsize='20')<br/>plt.plot(taxi_df['value'])</span><span id="b6cf" class="nn kx iq mu b gy ns np l nq nr">plt.xticks(np.arange(0, taxi_df['value'].shape[0], (48*DAY_MULTIPLIER)/2), x_axis_labels)<br/>plt.xticks(rotation=75)<br/>plt.minorticks_on()<br/>plt.margins(x=0)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/1529db14c03d625578f55e04f9135d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8dXDDlm-ejZWfzUyXWYvcQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="46fb" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">似乎在一天和七天之间有一个普遍的周期性，这可能是因为更多的人在白天而不是晚上使用出租车，并且有理由说大多数周都有类似的出租车乘客模式。此外，也许在接近10月底的窗口右侧有一个异常值，但除此之外，仅从原始数据无法得出任何结论。</p><h1 id="68f5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">生成矩阵配置文件</h1><p id="5742" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">同样，定义窗口大小，<code class="fe mr ms mt mu b">m</code>，通常需要一定程度的领域知识，但是我们稍后将展示<code class="fe mr ms mt mu b">stumpy.stump()</code>对于该参数的变化是健壮的。因为这个数据是半小时采集一次的，所以我们选择了一个值<code class="fe mr ms mt mu b">m = 48</code>来表示正好一天的跨度:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="995a" class="nn kx iq mu b gy no np l nq nr">m = 48<br/>mp = stumpy.stump(taxi_df['value'], m=m)</span></pre><h1 id="9fbd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">可视化矩阵轮廓</h1><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="6ff1" class="nn kx iq mu b gy no np l nq nr">plt.suptitle('1-Day STUMP', fontsize='30')<br/>plt.xlabel('Window Start', fontsize ='20')<br/>plt.ylabel('Matrix Profile', fontsize='20')<br/>plt.plot(mp[:, 0])</span><span id="59a5" class="nn kx iq mu b gy ns np l nq nr">plt.plot(575, 1.7, marker="v", markersize=15, color='b')<br/>plt.text(620, 1.6, 'Columbus Day', color="black", fontsize=20)<br/>plt.plot(1535, 3.7, marker="v", markersize=15, color='b')<br/>plt.text(1580, 3.6, 'Daylight Savings', color="black", fontsize=20)<br/>plt.plot(2700, 3.1, marker="v", markersize=15, color='b')<br/>plt.text(2745, 3.0, 'Thanksgiving', color="black", fontsize=20)<br/>plt.plot(30, .2, marker="^", markersize=15, color='b', fillstyle='none')<br/>plt.plot(363, .2, marker="^", markersize=15, color='b', fillstyle='none')<br/>plt.xticks(np.arange(0, 3553, (m*DAY_MULTIPLIER)/2), x_axis_labels)<br/>plt.xticks(rotation=75)<br/>plt.minorticks_on()<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/2c2e5b9db8fab8a075afe025169ed20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wravb9L6EXpl7k-mu-2O5w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="18f7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">了解矩阵配置文件</h1><p id="fc25" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">让我们明白我们在看什么。</p><h1 id="d982" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">最低值</h1><p id="e83d" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">最低值(空心三角形)被认为是基元，因为它们代表具有最小z归一化欧几里得距离的一对最近邻子序列。有趣的是，两个最低的数据点<em class="ml">正好相隔</em> 7天，这表明，在这个数据集中，除了更明显的一天的周期性之外，可能还有七天的周期性。</p><h1 id="ca77" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">最高值</h1><p id="ee96" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">那么最高的矩阵轮廓值(实心三角形)呢？具有最高(局部)值的子序列实际上强调了它们的唯一性。我们发现前三个峰值恰好分别与哥伦布日、夏令时和感恩节的时间相对应。</p><h1 id="1d5b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">不同的窗口大小</h1><p id="ec10" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">如上所述，<code class="fe mr ms mt mu b">stumpy.stump()</code>对于窗口大小参数<code class="fe mr ms mt mu b">m</code>的选择应该是稳健的。下面，我们通过运行不同窗口大小的<code class="fe mr ms mt mu b">stumpy.stump()</code>来演示操作窗口大小如何对你生成的矩阵轮廓产生小的影响。</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="ebe2" class="nn kx iq mu b gy no np l nq nr">days_dict ={<br/>  "Half-Day": 24,<br/>  "1-Day": 48,<br/>  "2-Days": 96,<br/>  "5-Days": 240,<br/>  "7-Days": 336,<br/>}<br/><br/>days_df = pd.DataFrame.from_dict(days_dict, orient='index', columns=['m'])<br/>days_df.head()</span><span id="5107" class="nn kx iq mu b gy ns np l nq nr">           m<br/>Half-Day  24<br/>1-Day     48<br/>2-Days    96<br/>5-Days    240<br/>7-Days    336</span></pre><p id="7d94" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">我们特意选择了与人类可以选择的相当直观的白天长度相对应的时间跨度。</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="c7c1" class="nn kx iq mu b gy no np l nq nr">fig, axs = plt.subplots(5, sharex=True, gridspec_kw={'hspace': 0})<br/>fig.text(0.5, -0.1, 'Subsequence Start Date', ha='center', fontsize='20')<br/>fig.text(0.08, 0.5, 'Matrix Profile', va='center', rotation='vertical', fontsize='20')<br/>for i, varying_m in enumerate(days_df['m'].values):<br/>    mp = stumpy.stump(taxi_df['value'], varying_m)<br/>    axs[i].plot(mp[:, 0])<br/>    axs[i].set_ylim(0,9.5)<br/>    axs[i].set_xlim(0,3600)<br/>    title = f"m = {varying_m}"<br/>    axs[i].set_title(title, fontsize=20, y=.5)<br/>plt.xticks(np.arange(0, taxi_df.shape[0], (48*DAY_MULTIPLIER)/2), x_axis_labels)<br/>plt.xticks(rotation=75)<br/>plt.suptitle('STUMP with Varying Window Sizes', fontsize='30')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/079ed64356d2d966da2b60c77165a5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3OTHxFv4izYLnninDc_nQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="d8cb" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">我们可以看到，即使窗口大小不同，我们的峰值仍然突出。但是看起来好像所有的非峰值都在向彼此靠拢。这就是为什么在运行<code class="fe mr ms mt mu b">stumpy.stump()</code>之前了解数据环境非常重要的原因，因为它有助于获得一个可以捕捉数据集中重复模式或异常的窗口大小。</p><h1 id="4dd4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">GPU-STUMP —使用GPU加快STUMP速度</h1><p id="b3a8" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">当时间序列中的数据远远超过几千个数据点时，您可能需要提高速度来帮助分析数据。幸运的是，你可以试试<code class="fe mr ms mt mu b">stumpy.gpu_stump()</code>，一种超快速的GPU驱动的<code class="fe mr ms mt mu b">stumpy.stump()</code>的替代品，它提供几百个CPU的速度，并提供与<code class="fe mr ms mt mu b">stumpy.stump()</code>相同的输出:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="e59e" class="nn kx iq mu b gy no np l nq nr"><strong class="mu ir">import</strong> <strong class="mu ir">stumpy</strong></span><span id="ae02" class="nn kx iq mu b gy ns np l nq nr">mp = stumpy.gpu_stump(df['value'], m=m)  <em class="ml"># Note that you'll need a properly configured NVIDIA GPU for this</em></span></pre><p id="b902" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">事实上，如果你不处理PII/SII的数据，那么你可以在Google Colab 上用<a class="ae kv" href="https://colab.research.google.com/drive/1FIbHQoD6mJInkhinoMehBDj2E1i7i2j7" rel="noopener ugc nofollow" target="_blank">这个笔记本来试试<code class="fe mr ms mt mu b">stumpy.gpu_stump()</code>。</a></p><h1 id="672e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">树桩—分布式树桩</h1><p id="01ce" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">或者，如果您只能访问一个CPU集群，并且您的数据需要留在防火墙后面，那么<code class="fe mr ms mt mu b">stumpy.stump()</code>和<code class="fe mr ms mt mu b">stumpy.gpu_stump()</code>可能不足以满足您的需求。相反，您可以尝试<code class="fe mr ms mt mu b">stumpy.stumped()</code>函数，它是<code class="fe mr ms mt mu b">stumpy.stump()</code>的分布式并行实现，依赖于<a class="ae kv" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank"> Dask </a> distributed:</p><pre class="kg kh ki kj gt nj mu nk nl aw nm bi"><span id="c3e9" class="nn kx iq mu b gy no np l nq nr"><strong class="mu ir">import</strong> <strong class="mu ir">stumpy</strong><br/><strong class="mu ir">from</strong> <strong class="mu ir">dask.distributed</strong> <strong class="mu ir">import</strong> Client</span><span id="c397" class="nn kx iq mu b gy ns np l nq nr">dask_client = Client()</span><span id="be63" class="nn kx iq mu b gy ns np l nq nr">mp = stumpy.stumped(dask_client, df['value'], m=m)  <em class="ml"># Note that a dask client is needed</em></span></pre><h1 id="3308" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="4fc5" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">就是这样！现在，您已经加载了一个数据集，使用<a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>包在<code class="fe mr ms mt mu b">stumpy.stump()</code>中运行它，并且能够提取两个不同时间序列中现有模式和异常的多个结论。您现在可以导入这个包并在您自己的项目中使用它。编码快乐！</p><h2 id="db7f" class="nn kx iq bd ky ny nz dn lc oa ob dp lg ly oc od li mc oe of lk mg og oh lm oi bi translated">资源</h2><p id="982c" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated"><a class="ae kv" href="http://www.cs.ucr.edu/~eamonn/PID4481997_extend_Matrix%20Profile_I.pdf" rel="noopener ugc nofollow" target="_blank">Matrix Profile I</a><br/><a class="ae kv" href="http://www.cs.ucr.edu/~eamonn/STOMP_GPU_final_submission_camera_ready.pdf" rel="noopener ugc nofollow" target="_blank">Matrix Profile II</a><br/><a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">STUMPY Matrix Profile文档</a><br/><a class="ae kv" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank">STUMPY Matrix Profile Github代码库</a></p><h2 id="4fd0" class="nn kx iq bd ky ny nz dn lc oa ob dp lg ly oc od li mc oe of lk mg og oh lm oi bi translated"><strong class="ak"> ← </strong> <a class="ae kv" rel="noopener" target="_blank" href="/the-matrix-profile-e4a679269692"> <strong class="ak">第一部分:矩阵简介</strong> </a> <strong class="ak"> | </strong> <a class="ae kv" rel="noopener" target="_blank" href="/part-3-time-series-chains-da281450abbf"> <strong class="ak">第三部分:时间序列链</strong> </a> <strong class="ak"> → </strong></h2></div></div>    
</body>
</html>