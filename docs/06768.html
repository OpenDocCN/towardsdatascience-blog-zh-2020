<html>
<head>
<title>How I Programmed The First Hone Extension In Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何在Julia中编写第一个Hone扩展的</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-i-programmed-the-first-hone-extension-in-julia-edf7813d0e1b?source=collection_archive---------85-----------------------#2020-05-26">https://towardsdatascience.com/how-i-programmed-the-first-hone-extension-in-julia-edf7813d0e1b?source=collection_archive---------85-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f03d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Hone.jl</h2><div class=""/><div class=""><h2 id="2371" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在Julia中创建和使用我的绘图库的扩展。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/dfd0c9d68a80ebc859c92edb5257e6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3X5SKRAXqEYyaXvK908CQ.png"/></div></div></figure><blockquote class="ld"><p id="78e9" class="le lf it bd lg lh li lj lk ll lm ln dk translated"><a class="ae lo" href="https://github.com/emmettgb/LatheHE.jl" rel="noopener ugc nofollow" target="_blank"> Github回购</a></p></blockquote><h1 id="8c9a" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">介绍</h1><p id="d314" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp mq mr ms mt mu mv mw mx my mz na nb ln im bi translated">当我最初为Julia创建矢量绘图库Hone.jl时，我希望有一个模块化的绘图库，可以由任何人扩展。使用这种方法，用户将能够创建包扩展来增加功能，并使它成为一个更好的通用库。</p><p id="3478" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">创建一个能够做这样事情的包说起来容易做起来难。然而，这个想法对我很有吸引力，因为据我所知，真的没有其他图形库做这样的事情。对朱莉娅来说尤其如此。不幸的是，在我们开始创建一个Hone扩展之前，我们必须增加一些代码。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="0fc7" class="lp lq it bd lr ls no lu lv lw np ly lz ki nq kj mb kl nr km md ko ns kp mf mg bi translated">为Hone添加扩展</h1><p id="cbd9" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp mq mr ms mt mu mv mw mx my mz na nb ln im bi translated">从相对早期的版本开始，Hone就有了可扩展的能力。然而，这个系统并不是最好的。它使用一个名为custom的参数，用户可以在其中输入要作为元表达式计算的串联标记。像这样处理扩展有几个基本问题，会降低Hone扩展的可行性。</p><ul class=""><li id="7754" class="nt nu it mj b mk nc mn nd mq nv mu nw my nx ln ny nz oa ob bi translated">需要有一个自定义条件</li><li id="125a" class="nt nu it mj b mk oc mn od mq oe mu of my og ln ny nz oa ob bi translated">输入标记需要连接，或者是连接在函数中的数组。</li><li id="b819" class="nt nu it mj b mk oc mn od mq oe mu of my og ln ny nz oa ob bi translated">对于没有使用扩展的人来说，这将会降低功能的速度，使得Hone运行更慢，但没有任何好处。</li></ul><p id="f341" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">这里是代码，所以你可以理解我指的是什么。所有提及“自定义”的内容均以粗体显示。</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="e883" class="om lq it oi b gy on oo l op oq">function _arrayscatter(x,y,shape=Circle(.5,.5,25),axiscolor=:lightblue,<br/>        debug=false, grid=Grid(3),<strong class="oi jd"> custom=""</strong>, frame=Frame(1280,720,0mm,0mm,0mm,0mm))<br/>   topx = maximum(x)<br/>    topy = maximum(y)<br/>    axisx = Line([(0,frame.height), (frame.width,frame.height)],axiscolor)<br/>   axisx_tag = axisx.update([(-1,-1), (-1,1), (1,1)])<br/>    axisy = Line([(0,0), (0,frame.height)],axiscolor)<br/>    axisy_tag = axisy.update([(0,0), (0,1), (0,1)])<br/>    grid_tag = grid.update()<br/>    ######<br/>    ######<br/><strong class="oi jd">    fullcustom = ""<br/>    if custom != ""<br/>        [custom = string(fullcustom, i) for i in custom]<br/>    end</strong><br/>    expression = string("")<br/>    # Coordinate parsing -------<br/>    for (i, w) in zip(x, y)<br/>        inputx = (i / topx) * frame.width<br/>        inputy = (w / topy) * frame.height<br/>        exp = shape.update(inputx,inputy)<br/>        expression = string(expression,string(exp))<br/>    end<br/>    expression = string(expression, "(context(),", axisx_tag,grid_tag,<strong class="oi jd">custom</strong>, axisy_tag,"),")<br/>    tt = transfertype(expression)<br/>    frame.add([tt])<br/>    if debug == true println(expression) end<br/>    composition = eval(expression)<br/>    show() = frame.show()<br/>    tree() = introspect(composition)<br/>    save(name) = draw(SVG(name), composition);<br/>    get_frame() = frame<br/>    (var)-&gt;(show;composition;tree;save;get_frame)<br/>end</span></pre><p id="f06d" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">量化一下，这段代码总共有34行。与custom相关的行数总共是6，这意味着17%的代码行属于custom，而大多数时候它根本不会被使用。也许我疯了，但是</p><blockquote class="ld"><p id="2c96" class="le lf it bd lg lh or os ot ou ov ln dk translated">我不能忍受这个。</p></blockquote><p id="1978" class="pw-post-body-paragraph mh mi it mj b mk ow kd mm mn ox kg mp mq oy ms mt mu oz mw mx my pa na nb ln im bi translated">此外，每当我创建框架函数时，我都会创建一个名为add()的方法，您可以在其中向框架添加一个对象。我想到，使用这种方法来添加任何扩展对象都比使用定制标签优越得多，也比让用户获取标签并将它们连接起来以使用旧系统容易得多。因此，在从_arrayscatter()和_dfscatter()函数中清除了所有出现的custom之后，我决定改进框架，以便能够接受这些对象。</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="09f6" class="om lq it oi b gy on oo l op oq">add(object) = composition,objects,tag = _frameup(base,objects,object)</span></pre><p id="0fc1" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">add方法只是调用_frameup方法，并将为它提供框架的基本标记“base”、对象的迭代列表“objects”和object。以前，旧的add()方法是这样的:</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="7467" class="om lq it oi b gy on oo l op oq">add(objects) = composition,objects,tag = _frameup(base,objects)</span></pre><p id="3c50" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">这意味着几件事。首先，对象不会被添加到对象列表中，而是替换对象。更糟糕的是，提供的对象需要在一个数组中，函数才能工作(因为不能迭代单一类型。)这只是意味着当调用函数时，您需要使用数组语法:</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="90ce" class="om lq it oi b gy on oo l op oq"># This is how you would expect it to work:<br/>frame.add(object)<br/># This is the change you needed to make:<br/>frame.add([object])</span></pre><p id="8605" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">我不喜欢这样，因为它假设一个数组存在于一个对象中，而这个对象很可能永远是单独的。当然，这个函数只是_frameup()方法的一个路由器，所以让我们来看看:</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="2813" class="om lq it oi b gy on oo l op oq">function _frameup(tag,objects)<br/>    for object in objects<br/>       tag = string(tag,"(context(),",object.tag, ")")<br/>    end<br/>    tag = string(tag,")")<br/>    println(tag)<br/>    exp = Meta.parse(tag)<br/>    composition = eval(exp)<br/>    return(composition,objects,tag)<br/>end</span></pre><p id="e541" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">对象只是连接到字符串，然后在解析和计算之前添加到表达式中。相反，应该做的是将对象添加到由类型提供的对象数组中。之后，可以将一个字符串与每个对象的标签连接起来。我是这样做的:</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="e48b" class="om lq it oi b gy on oo l op oq">function _frameup(tag,objects,object)<br/>    push!(objects, object.tag)<br/>    objecttags = ""<br/>    for o in objects<br/>       objecttags = string(objecttags,"(context(),",o, "),")<br/>    end<br/>    println("objects: ",objecttags)<br/>    tag = string(tag,objecttags,")")<br/>    exp = Meta.parse(tag)<br/>    println(exp)<br/>    composition = eval(exp)<br/>    return(composition,objects,tag)<br/>ends</span></pre><p id="f48d" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">最后，我将向_arrayscatter()和_dfscatter()函数添加一个方法，该方法将调用框架来添加特性:</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="3699" class="om lq it oi b gy on oo l op oq">add(obj) = frame.add(obj)</span></pre><blockquote class="ld"><p id="debc" class="le lf it bd lg lh li lj lk ll lm ln dk translated">现在我们来测试一下！</p></blockquote><p id="d91f" class="pw-post-body-paragraph mh mi it mj b mk ow kd mm mn ox kg mp mq oy ms mt mu oz mw mx my pa na nb ln im bi translated">首先，我们将创建一个圆。这是我们将要添加到散点图顶部框架中的对象。我还创建了两个相同长度的数组来解析并绘制成散点图。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/a131a09f5c08e9448b5f639d001eb115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*ia30Dpb2IfW-W1ajF5wLBg.png"/></div></figure><p id="d6fe" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">现在我们将创建我们的散点图。幸运的是，如果我们不记得我们的参数，Hone有很好的文档可以参考。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/df928cf907c95aa80f9e88c27ddfed35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zIHXu-pHmxtpE8TV7kmnmQ.png"/></div></div></figure><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="f153" class="om lq it oi b gy on oo l op oq">plt = Scatter(x,y,Circle(.5,.5,25,:orange),:purple)</span></pre><p id="7cac" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">现在我们可以使用show()方法:</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="5829" class="om lq it oi b gy on oo l op oq">plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/3601105504e7d2beac3055b9cdfca11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*s-M8U86nE7ySTjYj-l3goQ.png"/></div></figure><p id="935b" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">我们可以把之前做的例子加进去，再展示一次。</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="69f2" class="om lq it oi b gy on oo l op oq">plt.add(exampshape)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/c22b4b1147a21470294d4da50c5e1fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*6skD3Yw_ILsIpLK-cWkZHw.png"/></div></figure><blockquote class="ld"><p id="4714" class="le lf it bd lg lh li lj lk ll lm ln dk translated">哎呀，</p></blockquote><p id="0014" class="pw-post-body-paragraph mh mi it mj b mk ow kd mm mn ox kg mp mq oy ms mt mu oz mw mx my pa na nb ln im bi translated">我们忘记将我们的方法添加到我们的类型中:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/b0fad83f6e899888a9397af1b9c7c131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*JfQqjVyYnuRDrJTpgFcXRw.png"/></div></figure><p id="9af8" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">您可能已经注意到，幸运的是，我们确实有一个get_frame()函数，我们可以调用它来返回我们的帧，并且我们可以从那里添加它。</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="1b01" class="om lq it oi b gy on oo l op oq">fr = plt.get_frame()<br/>fr.show()</span></pre><p id="32da" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">这时我意识到我们把形状的x和y分别设置为0.5和0.5，所以让我们改变一下…这次我们把它放在图的中心。这次我决定用文字:</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="b2d8" class="om lq it oi b gy on oo l op oq">realshape = Hone.Text("Greetings",(1280 / 2), (720 / 2), :blue, 30)<br/>fr.add(realshape)<br/>fr.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/3c327156af05dea08dc2648fc5b7a452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*V7AZg5hwJ8lwBIeGLogP0w.png"/></div></figure><blockquote class="ld"><p id="c03d" class="le lf it bd lg lh li lj lk ll lm ln dk translated">厉害！</p></blockquote><h1 id="0c1f" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">创建扩展</h1><p id="92da" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp mq mr ms mt mu mv mw mx my mz na nb ln im bi translated">众所周知，数据可视化和机器学习可以很好地结合在一起。考虑到这一点，我决定基于车床机器学习库对Hone进行第一次扩展。这也将是Hone的统计图的家，因为他们将使用车床模块。女士们先生们，我向你们介绍</p><blockquote class="ld"><p id="de02" class="le lf it bd lg lh or os ot ou ov ln dk translated">LatheHE.jl</p></blockquote><p id="5bf7" class="pw-post-body-paragraph mh mi it mj b mk ow kd mm mn ox kg mp mq oy ms mt mu oz mw mx my pa na nb ln im bi translated">我决定给这个扩展添加的第一件事是绘制最佳拟合线的能力。这将相对容易，所以不要期望我一开始就做什么疯狂的事情。然而，要做到这一点，我们必须导出散点图方法中使用的所有数据，以便任何人在扩展图时都可以访问这些数据。所以回到Hone，我只是将数据添加到类型中:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/fac35da3a458a0cc3a1923690ed1cd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*a2Z55V4XM3wChgLoK9pd1A.png"/></div></figure><p id="7d0f" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">现在回到我们的最佳拟合线示例，我们可以使用plt.x和plt.y从我们的图中获取数据。为了制作最佳拟合线，我们可以采用几种方法:</p><ul class=""><li id="c002" class="nt nu it mj b mk nc mn nd mq nv mu nw my nx ln ny nz oa ob bi translated">拟合线性回归模型。</li><li id="d600" class="nt nu it mj b mk oc mn od mq oe mu of my og ln ny nz oa ob bi translated">分离数据，得到所述数据每一部分的平均值，然后用这些点画一条线。</li><li id="bf99" class="nt nu it mj b mk oc mn od mq oe mu of my og ln ny nz oa ob bi translated">线性绘制四分位数。</li></ul><p id="501e" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">我决定选择第二种方法，因为我认为这种方法可以获得最好的结果，同时对性能的要求也最低。车床.预处理有一个名为SortSplit的函数。要查看它的文档，我们需要首先将其导入到我们当前的环境中。</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="3bfa" class="om lq it oi b gy on oo l op oq">using Lathe.preprocess</span></pre><p id="eb64" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">然后我们可以在文档窗格中搜索它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/d77e8cd4a0e29988780d848592c5d575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LW2suVq7sXbJjP-zhBNg_g.png"/></div></div></figure><blockquote class="ld"><p id="ae54" class="le lf it bd lg lh li lj lk ll lm ln dk translated">朱诺太方便了…</p></blockquote><p id="e785" class="pw-post-body-paragraph mh mi it mj b mk ow kd mm mn ox kg mp mq oy ms mt mu oz mw mx my pa na nb ln im bi translated">当然，第一步是从参数中获取数据，这是我设置函数的方式:</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="0522" class="om lq it oi b gy on oo l op oq">function BestFit(plt, divisions = 5, color = :lightblue, weight = 2)<br/>        frame = plt.get_frame()<br/>        x = plt.x<br/>        y = plt.y</span></pre><p id="e24e" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">我认为像在网格中一样使用分割可能会很酷，这样用户可以确定他们想要分割最佳拟合线的次数，并且它会自动确定这样做的数据百分比。用1除以划分的数目将得到一个百分比，我们可以用它来确定我们离创建每个划分还有多远。</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="c61f" class="om lq it oi b gy on oo l op oq">divisionamount = 1 / divisions</span></pre><p id="dd06" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">接下来，我们使用一个while循环，该循环不断地将除法量添加到一个变量中，该变量将处理每个除法的逻辑。</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="3f7e" class="om lq it oi b gy on oo l op oq">lower = 75<br/>        totaldivisions = 0<br/>        arrays = []<br/>        while totaldivisions &lt; 1<br/>            top, lower = SortSplit(y,divisionamount)<br/>            append!(arrays,top)<br/>            totaldivisions += divisionamount<br/>        end</span></pre><p id="5640" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">我们在这里所做的只是将数组的小分割版本附加到一个数组中。接下来，我们需要对这个数组做一些实际的操作。</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="cd88" class="om lq it oi b gy on oo l op oq">xmeans = [a = mean(a) for a in arrays]</span></pre><p id="ac67" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">我们将从数组中获取平均值，并将其赋给一个名为xmeans的变量。接下来，我们将对y值做同样的事情。</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="18a8" class="om lq it oi b gy on oo l op oq">lower = 75<br/>        totaldivisions = 0<br/>        arrays = []<br/>        while totaldivisions &lt; 1<br/>            top, lower = SortSplit(y,divisionamount)<br/>            append!(arrays,top)<br/>            totaldivisions += divisionamount<br/>        end<br/>        ymeans = [a = mean(a) for a in arrays]</span></pre><p id="16dc" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">接下来，为了执行缩放算法，我们需要y的顶部和x的顶部。</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="a769" class="om lq it oi b gy on oo l op oq">topy = maximum(y)<br/>topx = maximum(x)</span></pre><p id="6dc8" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">现在我们基本上要从Hone的Linear()函数中复制从两个数组生成数组对的循环。如果您想了解关于这个函数的更多信息，我在这里写了一篇关于它的文章:</p><div class="pj pk gp gr pl pm"><a rel="noopener follow" target="_blank" href="/adding-line-graphs-to-my-graphing-library-eb6447a0c726"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd jd gy z fp pr fr fs ps fu fw jc bi translated">向我的图形库添加线图</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">继续构建Hone.jl中实现的特性，并调试出现的问题。</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">towardsdatascience.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa lb pm"/></div></div></a></div><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="2e46" class="om lq it oi b gy on oo l op oq">pairs = []<br/>        first = true<br/>        for (i,w) in zip(xmeans,ymeans)<br/>            if first == true<br/>                x = 0<br/>                first = false<br/>            else<br/>                x = (i / topx * frame.width)<br/>            end<br/>            y = (w / topy * frame.height)<br/>            pair = Tuple([x,y])<br/>            push!(pairs,pair)<br/>        end</span></pre><p id="3b0f" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">在这个循环中唯一不同的是有一个新的变量和条件名为first，它将决定我们是否在第一个循环中。我这样做的原因是为了让这条线总是从左边来。另一种我们可以在这里做X的方法是，将框架高度除以划分的数量，然后将原始数量加到自身，直到我们达到划分的数量。这样做将确保该行始终是一个从零开始并在帧的末尾结束的函数。</p><p id="b1ef" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">最后，我们将把帧作为元组数组进行类型断言，创建一个line对象，把它放入一个transfer类型，而不是返回一个类型，我们只是把它添加到帧中。</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="080c" class="om lq it oi b gy on oo l op oq">pairs = Array{Tuple{Float64,Real},1}(pairs)<br/>        lin = Line(pairs,color,weight)<br/>        expression = string("(context(),",lin.update(:foo),")")<br/>        tt = Hone.transfertype(expression)<br/>        frame.add(tt)<br/>end</span></pre><p id="b560" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">现在让我们来试试吧！</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="83cb" class="om lq it oi b gy on oo l op oq">plt = Scatter(x,y,Circle(.5,.5,25,:orange),:purple)<br/>include("src/LatheHE.jl")<br/>using Main.LatheHE<br/>LatheHE.BestFit(plt,2)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/e0411db832ae3c54bec2e7032794b90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*ConU-1Ubu4jBk7-Qo0GS8w.png"/></div></figure><p id="71cf" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">在未来，我可能会考虑像我之前谈到的那样填充X，而不是像这样，因为我们确实有很多重叠，因为X是我们除法的手段。</p><h1 id="2cf3" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki qc kj mb kl qd km md ko qe kp mf mg bi translated">结论</h1><p id="368f" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp mq mr ms mt mu mv mw mx my mz na nb ln im bi translated">我对Hone extensions的潜力感到非常兴奋！您可以执行任何操作，从创建用于绘制数据的自定义图形，到向绘图添加新要素。最重要的是，一切都变得完全自定义，因为我们使用标签来呈现一切。任何可以适当组合的东西都可以添加到任何框架中。</p><p id="ba54" class="pw-post-body-paragraph mh mi it mj b mk nc kd mm mn nd kg mp mq ne ms mt mu nf mw mx my ng na nb ln im bi translated">我看到未来有很多延伸。也许有些很简单，只是添加了一些你可以使用的不同的看起来很酷的图例。也许一些或更复杂，实际上动画你的情节或添加Javascript的交互性——可能性是无限的！如果你想开始制作自己的Hone扩展，你可以添加#Unstable分支以获得最新版本(0.0.4)并开始试用它！</p><div class="pj pk gp gr pl pm"><a href="http://github.com/emmettgb/Hone.jl" rel="noopener  ugc nofollow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd jd gy z fp pr fr fs ps fu fw jc bi translated">emmettgb/Hone.jl</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">模块化的形状，网格和线条容易预制快速绘图简单和轻型车床集成(即将推出)…</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">github.com</p></div></div><div class="pv l"><div class="qf l px py pz pv qa lb pm"/></div></div></a></div></div></div>    
</body>
</html>