<html>
<head>
<title>Deep RL Case Study: Automating Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度RL案例研究:自动化工程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deep-rl-case-study-automating-engineering-96779921d108?source=collection_archive---------36-----------------------#2020-01-27">https://towardsdatascience.com/deep-rl-case-study-automating-engineering-96779921d108?source=collection_archive---------36-----------------------#2020-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="66e9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">人工智能和计算机系统能接管工程的其他领域吗？</h2></div><p id="d7b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">在不同的工程领域中，参数调整是一个常数。计算机科学家调整他们模型的值，电气工程师改变他们晶体管的宽度，化学工程师检查他们过程的效率。这些不同角色的不变方面:<em class="lk">人类在高维、非凸优化问题上是不可靠的。</em>在所有这些情况下，我们的大脑就是优化功能——<strong class="kh ir">设计工程师还可以使用哪些优化器</strong>，为什么要使用？最近发现的这些工程角色之间的差异<em class="lk">:只有计算问题被结构化和规范化到足以让学习戏剧性地改变它们。</em></p><h1 id="f103" class="ll lm iq bd ln lo lp lq lr ls lt lu lv jw lw jx lx jz ly ka lz kc ma kd mb mc bi translated">自动参数调整— AutoML:</h1><p id="cd78" class="pw-post-body-paragraph kf kg iq kh b ki md jr kk kl me ju kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">AutoML，即自动机器学习，正在流行起来。当我在脸书的时候，我正在测试PyTorch的预发布版本，Berkeley的同事刚刚发布了他们自己的开源包<a class="ae mi" href="https://ray.readthedocs.io/en/latest/tune.html" rel="noopener ugc nofollow" target="_blank"> Tune (for Ray) </a>。</p><div class="mj mk gp gr ml mm"><a href="https://medium.com/riselab/cutting-edge-hyperparameter-tuning-with-ray-tune-be6c0447afdf" rel="noopener follow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">使用射线调谐的尖端超参数调谐</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">介绍Ray Tune，这是最先进的超参数调节库，可供研究人员和开发人员在任何…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">medium.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na nb mm"/></div></div></a></div><p id="c4ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">AutoML是做什么的？简而言之，它…</p><ol class=""><li id="dd8b" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated"><strong class="kh ir">加载设计变量和目标的向量</strong>，</li><li id="da2e" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated"><strong class="kh ir">将模型</strong>拟合到目标函数，</li><li id="39e0" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated"><strong class="kh ir">返回当前数据集中的最佳参数</strong>。</li></ol><p id="1dda" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以了解这意味着什么。</p><h2 id="21eb" class="nq lm iq bd ln nr ns dn lr nt nu dp lv ko nv nw lx ks nx ny lz kw nz oa mb ob bi translated">设计变量和设置</h2><p id="dcc9" class="pw-post-body-paragraph kf kg iq kh b ki md jr kk kl me ju kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">每个设计问题都有一组要优化的变量，变量的数量决定了要使用的优化器的类型。由于难以限制优化器可访问的变量，自动化设计的采用受到限制。工程师运用多层次的知识来理解系统是如何工作的。他们利用这些知识来调整许多方面，并汇聚成一个解决方案——通常在不受约束的环境中工作。现代机器学习在结构化问题中工作得非常好，所以在实际问题中启用AutoML的很大一部分是有效的<strong class="kh ir">数据科学</strong>。设计师必须将系统最重要的方面提取到变量的子集里(有人知道主成分分析吗？)被标准化并准备好供计算机拟合和迭代。</p><p id="76b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些原则只有在工具设置好之后才能应用，也就是说，学习算法可以直接改变感兴趣的变量并运行新的模拟。自动化设计的影响力取决于它改变和测试新参数的能力。工具的障碍是这些问题的解决方案变得非常小众的原因— <em class="lk">需要对参数优化和设计工具有博士水平的理解才能在硬件中部署它们</em>。</p><h2 id="8371" class="nq lm iq bd ln nr ns dn lr nt nu dp lv ko nv nw lx ks nx ny lz kw nz oa mb ob bi translated">为目标建模</h2><p id="4e47" class="pw-post-body-paragraph kf kg iq kh b ki md jr kk kl me ju kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">贝叶斯优化是AutoML优化器中使用最频繁的工具(<em class="lk">可以使用任何非梯度依赖优化器:备选包括</em> <a class="ae mi" href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="noopener ugc nofollow" target="_blank"> <em class="lk">遗传算法</em> </a> <em class="lk">或</em> <a class="ae mi" href="https://en.wikipedia.org/wiki/Cross-entropy_method" rel="noopener ugc nofollow" target="_blank"> <em class="lk">交叉熵方法</em> </a>)。</p><figure class="od oe of og gt oh gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi oc"><img src="../Images/88f20f193d240e6a92424c56d7b6583d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZsVDnPHgo_axiPjQT5OvA.png"/></div></div><p class="on oo gj gh gi op oq bd b be z dk translated">在<strong class="bd or">贝叶斯优化</strong>循环(算法)中迭代<strong class="bd or">高斯过程</strong>(模型)的拟合。黑点代表数据，这显示了2到4个数据点。目标函数通过测量拟合表面，并预测状态空间剩余部分的平均值和方差。绿色(激活功能)用于选择下一组参数，参见下面的<strong class="bd or">优化选择</strong>部分。(来源— <a class="ae mi" href="https://www.cs.ox.ac.uk/people/nando.defreitas/publications/BayesOptLoop.pdf" rel="noopener ugc nofollow" target="_blank">将人类从循环中解放出来……</a>)</p></figure><p id="9a4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目标的模型就是<strong class="kh ir">所捕获的正在设计的系统的行为</strong>。这是至关重要的一步，它使计算机成为一种更加结构化的选择形式。计算机可以用平滑高斯过程、深度神经网络或概率分布的组合来模拟复杂的非线性函数。</p><p id="1f2d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些不同的模型选项<strong class="kh ir">在表达性、可解释性和样本效率</strong>之间进行权衡。高斯过程(最终是非参数高斯分布)是一个很好的选择，因为它们在样本效率方面占优势，同时带有可解释的不确定性概念。</p><h2 id="60f1" class="nq lm iq bd ln nr ns dn lr nt nu dp lv ko nv nw lx ks nx ny lz kw nz oa mb ob bi translated">最佳选择</h2><p id="8eb6" class="pw-post-body-paragraph kf kg iq kh b ki md jr kk kl me ju kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">这是计算机比人类获益最多的地方。</p><p id="2bb7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">人类擅长将一种设计与另一种设计进行比较(<em class="lk">也许是不可思议的强烈直觉</em>)，但我们缺乏任何真正的能力来提出给定数据集的最佳或接近最佳的下一组参数。使用结构化学习模型为算法提供了一种明确的方式来决定下一个参数集。</p><p id="d34b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在贝叶斯优化中，传递下一组参数的工具被称为<strong class="kh ir">采集函数</strong>。获取功能是另一个可供人类选择的设计选项。<em class="lk">其他方法(CMA、CEM等)可以将他们的预测建模为样本分布，取这种分布的平均值就是当前的最优估计。</em>采集函数的不同选择在参数探索、模型开发和先验知识之间进行平衡。关键是<strong class="kh ir"><em class="lk"/></strong><strong class="kh ir"><em class="lk">优化器消除了困扰人类调优</em> </strong>的选择歧义。</p><div class="mj mk gp gr ml mm"><a href="https://dash.harvard.edu/handle/1/27769882" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">将人带出循环:贝叶斯优化综述</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">编辑描述</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">dash.harvard.edu</p></div></div><div class="mv l"><div class="os l mx my mz mv na nb mm"/></div></div></a></div><p id="0a00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你正在为你的项目寻找一个AutoML工具——看看这个来自弗赖堡的<a class="ae mi" href="https://www.automl.org/" rel="noopener ugc nofollow" target="_blank">研究小组。</a></p></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><p id="9970" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们认为优化一组参数——人类在 <strong class="kh ir"> <em class="lk">中调十几个变量</em> </strong> <em class="lk">还是人类选择几个</em> <strong class="kh ir"> <em class="lk">算法棋子</em> </strong>哪个更好？让我们看看在研究中选择适合当前特定设计问题的优化器和模型的可能性。</p><figure class="od oe of og gt oh gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi pa"><img src="../Images/ed5c3cacaf73491536e6a207a56b486d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GdGy0TfkenfyUFEku-w6cg.png"/></div></div><p class="on oo gj gh gi op oq bd b be z dk translated">来源——我的大阪之旅。</p></figure><h1 id="0536" class="ll lm iq bd ln lo lp lq lr ls lt lu lv jw lw jx lx jz ly ka lz kc ma kd mb mc bi translated">自动化设计的前沿</h1><p id="10b7" class="pw-post-body-paragraph kf kg iq kh b ki md jr kk kl me ju kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我概述了去年给我留下深刻印象的自动化工程的两个最近的例子。(<em class="lk">我正试图从这些研究中获得灵感，在我自己的研究中优化机器人设计，这有望导致这篇博文的第二个版本。</em>)</p><h2 id="ed94" class="nq lm iq bd ln nr ns dn lr nt nu dp lv ko nv nw lx ks nx ny lz kw nz oa mb ob bi translated">电路设计</h2><p id="5347" class="pw-post-body-paragraph kf kg iq kh b ki md jr kk kl me ju kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Kourosh Hakhamaneshi等人。al将<strong class="kh ir">进化算法</strong>(优化选择)和<strong class="kh ir">深度神经网络鉴别器</strong>(目标函数模型)应用于高维<strong class="kh ir">电路设计问题</strong>(设计空间)。</p><p id="b407" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">电路设计涉及许多方面，但在高层次上，设计一个片上系统的一个组件归结为四个步骤:1)改变<strong class="kh ir">原理图</strong>(使用的组件，例如晶体管、电阻)，2) <strong class="kh ir">模拟</strong>原理图，直到它是准确的，3) <strong class="kh ir">布局</strong>原理图，以便它可以在电路代工厂(TSMC，英特尔)创建，4) <strong class="kh ir">模拟</strong>电路布局。<em class="lk">最耗时的环节是最后一步，模拟可能需要几天时间</em>。原理图-模拟-布局-模拟是一个非常宽的循环，其中简单的迭代不会产生任何功能性结果。</p><figure class="od oe of og gt oh gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi pb"><img src="../Images/a42eb64a619c1dcf0f52a06e7654d16d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAea2TLuvh_jl_ZWo-bSeg.png"/></div></div><p class="on oo gj gh gi op oq bd b be z dk translated">(来源— <a class="ae mi" href="https://bair.berkeley.edu/blog/2019/09/26/circuits/" rel="noopener ugc nofollow" target="_blank"> BAIR在BagNet上的博客文章</a>)</p></figure><p id="99d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一种算法不能减少模拟(和验证)电路如何制造所需的时间，那么它知道在哪里放置带电阻的晶体管只是难题的一小部分。有一个核心技术方面使本文能够实现功能性结果(过去其他项目失败的地方):<em class="lk">使用深度学习鉴别器来判断哪些新设计应该在布局后仿真中进行评估</em>。</p><p id="e0d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">电路设计的复杂性是作者以这种方式设置问题的原因。他们需要使用进化算法，因为它可以快速地提出更多的样本，并获得关于参数是否应该工作的初始指示(给定历史人口数据)，然后鉴别器充当过滤器，以大幅减少计算负担。</p><p id="6e19" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法的主要优势是<strong class="kh ir"> <em class="lk">它能够在模拟电路设计</em> </strong>的各种约束条件下工作。这篇论文的作者代表了离线优化和电路设计领域的知识高峰——在专门问题上实现新颖优化所需的罕见组合，因此希望<a class="ae mi" href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-25.pdf" rel="noopener ugc nofollow" target="_blank"> BagNet </a>取得成功。</p><div class="mj mk gp gr ml mm"><a href="https://bair.berkeley.edu/blog/2019/09/26/circuits/" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">模拟电路设计的样本高效进化算法</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">在这篇文章中，我们分享了一些关于深度学习在模拟IC设计中的应用的最新成果…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">bair.berkeley.edu</p></div></div><div class="mv l"><div class="pc l mx my mz mv na nb mm"/></div></div></a></div><h2 id="5172" class="nq lm iq bd ln nr ns dn lr nt nu dp lv ko nv nw lx ks nx ny lz kw nz oa mb ob bi translated">机器人设计</h2><p id="fee1" class="pw-post-body-paragraph kf kg iq kh b ki md jr kk kl me ju kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">这里托马斯·廖等人。al将<strong class="kh ir">贝叶斯优化</strong>(优化选择)和<strong class="kh ir">高斯过程</strong>(目标函数模型)应用于<strong class="kh ir">微机电系统</strong>优化(设计空间)。</p><p id="0594" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在任何硬件设计问题中，设计的<em class="lk">评估通常会因几周的制造时间</em>而延迟。这在微机电系统(MEMs)中尤其如此<strong class="kh ir">、</strong>，其中有两个阶段用于延迟和变化:掩模组装(工具设置)和纳米制造(实际构造)。该方法通过启用参数空间的<strong class="kh ir">并行搜索来增加设计优化的吞吐量。本文使用贝叶斯优化循环的升级版本。</strong></p><figure class="od oe of og gt oh gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi pd"><img src="../Images/c454fe6c76854c23fbc0eedb214cab4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_edz3UpF_y76Q3MiSS-rQ.png"/></div></div><p class="on oo gj gh gi op oq bd b be z dk translated">(来源—<a class="ae mi" href="https://arxiv.org/pdf/1905.01334.pdf" rel="noopener ugc nofollow" target="_blank">MEMs论文中的形态学学习</a>)</p></figure><p id="1bfc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">伟大的洞察力是用一个新的获取函数修改贝叶斯优化，该函数返回一组参数向量以在下一次评估中尝试。然后，该模型可以立即适应所有这些试验，并提出另一批试验。这就是所谓的<strong class="kh ir">分层过程约束批量贝叶斯优化(HPC-BBO) </strong>。该模型可以拟合来自问题的任何数据，因此并行评估是挂钟时间的实质性改进(使用新的采集功能可能会稍微降低采样效率)。</p><p id="3758" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现这一点的两个关键技术细节是1) <strong class="kh ir">用模型</strong>想象真实过程的回报(标准贝叶斯优化需要在获得另一个样本之前评估真实系统上的参数)，首先在<a class="ae mi" href="http://papers.nips.cc/paper/6933-process-constrained-batch-bayesian-optimisation.pdf" rel="noopener ugc nofollow" target="_blank">批量贝叶斯优化</a>中提出，以及2) <strong class="kh ir">关于第二个约束的批量建议参数的上下文优化</strong>——需要设计与特定控制器一起工作，这成为一个联合学习问题。</p><p id="3100" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种学习协议强调了AutoML在结构问题上的工作能力，这些问题过去是专门留给人类设计师的。<strong class="kh ir">结构和并行化</strong>使其在实际硬件中循环时非常高效。</p><div class="mj mk gp gr ml mm"><a href="https://arxiv.org/abs/1905.01334" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">微机器人形态学和控制器的高效数据学习</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">机器人设计通常是一个缓慢而困难的过程，需要反复构建和测试原型，并且…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">arxiv.org</p></div></div></div></a></div><div class="od oe of og gt ab cb"><figure class="pe oh pf pg ph pi pj paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><img src="../Images/32447b48a3304dcfd3a0959391cca326.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*tgQp3rD72tLf38YGng-fmA.png"/></div></figure><figure class="pe oh pk pg ph pi pj paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><img src="../Images/33b541cdae4acb3d67bb3ac37808410b.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*cWTrWxEfNoaSUX92rCRlJA.png"/></div></figure><figure class="pe oh pl pg ph pi pj paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><img src="../Images/af851f47a09d71aac9fbc71a7c9be410.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*TB37t6fZGqZVbjcmW92LAg.png"/></div><p class="on oo gj gh gi op oq bd b be z dk pm di pn po translated">来自我实验室的真实(外部)和想象的微型机器人。(来源相关<a class="ae mi" href="https://ieeexplore.ieee.org/abstract/document/7994197" rel="noopener ugc nofollow" target="_blank">学术</a> <a class="ae mi" href="https://ieeexplore.ieee.org/abstract/document/8373697" rel="noopener ugc nofollow" target="_blank">论文</a>来自我的小组)</p></figure></div></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><p id="1465" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法在很多方面都站不住脚——设计变量太多，无法访问特定机构使用的专有设计工具之外的数据，缺乏老一辈工程师的教育。也就是说，一些年轻的专家在他们的领域所付出的努力会产生巨大的回报。</p></div></div>    
</body>
</html>