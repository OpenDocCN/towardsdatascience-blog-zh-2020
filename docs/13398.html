<html>
<head>
<title>Data Preprocessing Guide for Every Data Scientist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每位数据科学家的数据预处理指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-data-preprocessing-67a67c42a036?source=collection_archive---------36-----------------------#2020-09-14">https://towardsdatascience.com/introduction-to-data-preprocessing-67a67c42a036?source=collection_archive---------36-----------------------#2020-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3e18e8bd57f4c71772e554d3b38b0993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kyYft8Tq0xEXquFgT_k1sg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://medium.com/@beginningofthefuture" rel="noopener">作者</a>提供)</p></figure><h2 id="9c67" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">终极数据科学指南</h2><div class=""/><div class=""><h2 id="7c00" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">理解数据预处理的概念，并使用 scikit 学习库实现它们</h2></div><p id="402c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">数据是以无组织或有组织的形式收集的事实和数字、观察结果或对事物的描述。数据可以以图像、文字、数字、字符、视频、音频等形式存在。</p><h2 id="5c1e" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">什么是数据预处理</h2><p id="80a5" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">为了分析我们的数据并从中提取洞察力，在我们开始建立我们的机器学习模型之前，有必要处理数据，即我们需要将我们的数据转换为我们的模型可以理解的形式。因为机器不能理解图像、音频等形式的数据。</p><blockquote class="na nb nc"><p id="01da" class="lh li nd lj b lk ll kt lm ln lo kw lp ne lr ls lt nf lv lw lx ng lz ma mb mc im bi translated"><strong class="lj jt">数据以算法可以轻松解释的形式(一种高效的格式)进行处理，并准确产生所需的输出。</strong></p></blockquote><p id="cd8e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们在现实世界中使用的数据并不完美，它是不完整的、不一致的(有异常值和噪声值)，并且是一种非结构化的形式。预处理原始数据有助于组织、缩放、清理(移除异常值)、标准化，即简化它以将数据馈送给机器学习算法。</p><p id="ccbb" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">数据预处理的过程包括几个步骤:</strong></p><ul class=""><li id="6da9" class="nh ni jj lj b lk ll ln lo lq nj lu nk ly nl mc nm nn no np bi translated"><strong class="lj jt">数据清洗:</strong>我们使用的数据可能会有一些遗漏点(比如不包含任何值的行或列)或者有噪声数据(机器难以解释的无关数据)。为了解决上述问题，我们可以删除空的行和列，或者用其他值填充它们，并且我们可以使用像回归和聚类这样的方法来处理有噪声的数据。</li><li id="5024" class="nh ni jj lj b lk nq ln nr lq ns lu nt ly nu mc nm nn no np bi translated"><strong class="lj jt">数据转换:</strong>将原始数据转换成适合模型的格式的过程。它可能包括分类编码、缩放、归一化、标准化等步骤。</li><li id="aebb" class="nh ni jj lj b lk nq ln nr lq ns lu nt ly nu mc nm nn no np bi translated"><strong class="lj jt">数据缩减:</strong>这有助于减少我们正在处理的数据的大小(便于分析)，同时保持原始数据的完整性。</li></ul><h2 id="495b" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">sci kit-用于数据预处理的学习库</h2><p id="7f52" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">Scikit-learn 是一个流行的开源机器学习库。这个库为我们提供了各种基本工具，包括用于随机森林、分类、回归的算法，当然还有用于数据预处理的算法。这个库是建立在 NumPy 和 SciPy 之上的，很容易学习和理解。</p><p id="b059" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以使用以下代码将库导入到工作区中:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="56ff" class="md me jj oa b gy oe of l og oh">import sklearn</span></pre><p id="6d7e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了包含预处理功能，我们可以使用以下代码:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="875f" class="md me jj oa b gy oe of l og oh">from <strong class="oa jt">sklearn</strong> import <strong class="oa jt">preprocessing</strong></span></pre><blockquote class="na nb nc"><p id="12ad" class="lh li nd lj b lk ll kt lm ln lo kw lp ne lr ls lt nf lv lw lx ng lz ma mb mc im bi translated">在本文中，我们将重点介绍一些基本的数据预处理功能，如<strong class="lj jt">标准化、规范化、分类编码、离散化、缺失值插补、生成多项式功能、</strong>和<strong class="lj jt">自定义转换器。</strong></p></blockquote><p id="2387" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">那么，现在让我们开始使用这些功能吧！</p><h2 id="7912" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">标准化</h2><p id="c849" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">标准化是一种用于缩放数据的技术，使得数据的平均值为零，标准偏差为一。这里的值不限于特定的范围。当输入数据集的特征在其范围之间存在较大差异时，我们可以使用标准化。</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/5a827eddecf8b7b8d80460fc8085f4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*OUcXeN0RRE7n0lg6O8BRcw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://medium.com/@beginningofthefuture" rel="noopener">作者</a>提供)数据标准化的公式</p></figure><p id="8490" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们考虑下面的例子:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="f2e6" class="md me jj oa b gy oe of l og oh">from sklearn import preprocessing<br/>import numpy as np<br/>x = np.array([[1, 2, 3],<br/>[ 4,  5,  6],<br/>[ 7,  8, 9]])<br/>y_scaled = <strong class="oa jt">preprocessing.scale</strong>(x)<br/>print(y_scaled)</span></pre><p id="f61c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里我们有一个 3x3 维的输入数组，它的值在 1 到 9 之间。使用<code class="fe oj ok ol oa b">preprocessing</code>中可用的<code class="fe oj ok ol oa b">scale</code>功能，我们可以快速缩放我们的数据。</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/0a8283d705466fea388d893f22bd10a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*hyGdFujQmf4kgSwsc2Yh-w.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://medium.com/@beginningofthefuture" rel="noopener">作者</a>提供)缩放数据</p></figure><p id="c78f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个库中还有另一个可用的函数<code class="fe oj ok ol oa b">StandardScaler</code>，它帮助我们计算训练数据集的均值和标准差，并通过实现<code class="fe oj ok ol oa b">Transformer API</code>对训练数据集重新应用相同的变换。</p><p id="0af3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果我们想在给定范围内缩放我们的特征，我们可以使用<code class="fe oj ok ol oa b">MinMaxScaler</code>(使用参数<code class="fe oj ok ol oa b">feature_range=(min,max)</code>)或<code class="fe oj ok ol oa b">MinAbsScaler</code>(不同之处在于每个特征的最大绝对值在<code class="fe oj ok ol oa b">MinAbsScaler</code>中被缩放到单位大小)</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="34b3" class="md me jj oa b gy oe of l og oh">from sklearn.preprocessing import MinMaxScaler<br/>import numpy as np<br/>x =<strong class="oa jt"> MinMaxScaler(feature_range=(0,8))</strong><br/>y = np.array([[1, 2, 3],<br/>[ 4,  -5,  -6],<br/>[ 7,  8, 9]])<br/>scale = x.<strong class="oa jt">fit_transform</strong>(y)<br/>scale</span></pre><p id="f336" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，3x3 维数组的值在给定的<code class="fe oj ok ol oa b">(0,8)</code>范围内缩放，我们使用了<code class="fe oj ok ol oa b">.fit_transform()</code>函数，它将帮助我们稍后对另一个数据集应用相同的转换。</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi on"><img src="../Images/88b2043105dfe9fa951fe032ea9b031d.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*cwI7Uln-QyZrgEeLWYUdpQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://medium.com/@beginningofthefuture" rel="noopener">作者</a>提供)指定范围内的缩放数据</p></figure><h2 id="bcd3" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">正常化</h2><p id="b99a" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">标准化是在<strong class="lj jt"> -1，1 </strong>的范围内对数值进行缩放的过程，即将数值转换成一个通用的比例。这确保了数据集中的大值不会影响学习过程，并且对模型的学习过程具有类似的影响。当我们想要量化任何一对样本(如点积)的相似性时，可以使用归一化。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="fc26" class="md me jj oa b gy oe of l og oh">from sklearn import preprocessing<br/>import numpy as np<br/>X = [[1,2,3],<br/>[4,-5,-6],<br/>[7,8,9]]<br/>y = preprocessing.normalize(X)<br/>y</span></pre><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/f2359f41bb086146e217365b1e9179ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*pQZ1Wj01cDHKrRcIQXPwgg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://medium.com/@beginningofthefuture" rel="noopener">作者</a>提供)归一化数据</p></figure><p id="20ba" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个模块也为我们提供了一个<code class="fe oj ok ol oa b">Transformer API</code>的替代方案，通过使用实现相同操作的<code class="fe oj ok ol oa b">Normalizer</code>函数。</p><h2 id="8031" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">编码分类特征</h2><p id="8a0b" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">很多时候，我们使用的数据可能不具有连续形式的特征值，而是具有文本标签的类别形式。为了让机器学习模型处理这些数据，有必要将这些分类特征转换成机器可理解的形式。</p><p id="5d99" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该模块中有两个可用的函数，通过它们我们可以对我们的分类特征进行编码:</p><ul class=""><li id="1fce" class="nh ni jj lj b lk ll ln lo lq nj lu nk ly nl mc nm nn no np bi translated"><strong class="lj jt"> OrdinalEncoder: </strong>这是将分类特征转换为整数值，以便该函数将每个分类特征转换为整数的一个新特征(0 到 n_categories — 1)。</li></ul><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="909c" class="md me jj oa b gy oe of l og oh">import sklearn.preprocessing<br/>import numpy as np<br/>enc = <strong class="oa jt">preprocessing.OrdinalEncoder</strong>()<br/>X = [['a','b','c','d'], ['e', 'f', 'g', 'h'],['i','j','k','l']]<br/>enc.fit(X)<br/>enc.transform([['a', 'f', 'g','l']])</span></pre><p id="f9e1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，三个类别被编码为<code class="fe oj ok ol oa b">0,1,2</code>，上述输入的输出结果是:</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi op"><img src="../Images/b37cc854debb601f62af870f9f1b2222.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*Zb0cv_TaR4ETp2kWzDXRRQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://medium.com/@beginningofthefuture" rel="noopener">作者</a>编码的数据)</p></figure><ul class=""><li id="283f" class="nh ni jj lj b lk ll ln lo lq nj lu nk ly nl mc nm nn no np bi translated"><strong class="lj jt"> OneHotEncode: </strong>该编码器功能将每个具有<code class="fe oj ok ol oa b">n_categories</code>可能值的分类特征转换为<code class="fe oj ok ol oa b">n_categories</code>二进制特征，其中一个为 1，所有其他为 0。为了更好的理解，请看下面的例子。</li></ul><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="e98b" class="md me jj oa b gy oe of l og oh">import sklearn.preprocessing<br/>import numpy as np<br/>enc = <strong class="oa jt">preprocessing.OneHotEncoder</strong>()<br/>X = [['a','b','c','d'], ['e', 'f', 'g', 'h'],['i','j','k','l']]<br/>enc.fit(X)<br/>enc.transform([['a', 'f', 'g','l']]).toarray().reshape(4,3)</span></pre><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/9ca512371685457f1ae07879d3995691.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*EIVGDVhfnyPZIyw44LYnFg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://medium.com/@beginningofthefuture" rel="noopener">作者</a>编码的数据)</p></figure><h2 id="9ca3" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">[数]离散化</h2><p id="9e8e" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">离散化过程有助于我们将数据的连续特征分离成离散值(也称为宁滨或量化)。这类似于使用连续数据创建直方图(其中离散化侧重于将特征值分配给这些箱)。在某些情况下，离散化可以帮助我们在线性模型中引入非线性。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="d39e" class="md me jj oa b gy oe of l og oh">import sklearn.preprocessing <br/>import numpy as np<br/>X = np.array([[ 1,2,3],<br/>              [-4,-5,6],<br/>              [7,8,9]])<br/>dis = preprocessing.KBinsDiscretizer(n_bins=[3, 2, 2], encode='ordinal')<br/>dis.fit_transform(X)</span></pre><p id="eb7a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用<code class="fe oj ok ol oa b">KBinsDiscretizer()</code>，该功能将特征离散到<code class="fe oj ok ol oa b">k</code>箱中。默认情况下，输出是一键编码的，我们可以用<code class="fe oj ok ol oa b">encode</code>参数来改变。</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/73353c70a9f15a73a19c9b5afcbe4593.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*vAhxv4OnZy5WQoAjo5kDMg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://medium.com/@beginningofthefuture" rel="noopener">作者</a>提供)数据离散化</p></figure><h2 id="715e" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">缺失值的插补</h2><p id="5564" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">此过程用于处理数据中的缺失值(nan、空白等)，方法是为它们赋值(基于数据集的已知部分进行输入),以便模型可以处理数据。让我们用一个例子来理解这一点:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="a37e" class="md me jj oa b gy oe of l og oh">from sklearn.impute import SimpleImputer<br/>import numpy as np<br/>impute =<strong class="oa jt"> SimpleImputer(missing_values=np.nan, strategy='mean')</strong><br/>X = [[np.nan, 1,2], [3,4, np.nan], [5, np.nan, 6]]<br/>impute.fit_transform(X)</span></pre><p id="c456" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，我们使用了<code class="fe oj ok ol oa b">SimpleImputer()</code>函数来输入缺失值。该函数中使用的参数是<code class="fe oj ok ol oa b">missing_values</code>来指定要估算的缺失值，<code class="fe oj ok ol oa b">strategy</code>来指定我们希望如何估算该值，就像在上面的示例中我们使用了<code class="fe oj ok ol oa b">mean</code>，这意味着缺失值将被列值的平均值替换。我们可以为<code class="fe oj ok ol oa b">strategy</code>使用其他参数，如中位数、众数、<code class="fe oj ok ol oa b">most_frequent</code>(基于列中特定值出现的频率)，或者<code class="fe oj ok ol oa b">constant</code>(一个常量)。</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi os"><img src="../Images/37d100f7e00e1474f5b89860fe638fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*fq3BGYTQVUpQLCbnE69GUQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://medium.com/@beginningofthefuture" rel="noopener">作者</a>提供)输入缺失值</p></figure><h2 id="4f13" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">生成多项式要素</h2><p id="a931" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">为了在我们的机器学习模型的结果中获得更大的准确性，有时在模型中引入复杂性(通过添加非线性)是好的。我们可以通过使用函数<code class="fe oj ok ol oa b">PolynomialFeatures()</code>简单地实现这一点。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="6e6b" class="md me jj oa b gy oe of l og oh">import numpy as np<br/>from sklearn.preprocessing import PolynomialFeatures<br/>x = <strong class="oa jt">np.array([[1,2],<br/>              [3,4]])</strong><br/>nonl = <strong class="oa jt">PolynomialFeatures(2)</strong><br/>nonl.fit_transform(x)</span></pre><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/9846c2583c91b473ff9a98780b1cf319.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*6l-x0q813qmw4d33vxzZCg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://medium.com/@beginningofthefuture" rel="noopener">作者</a>)生成多项式特征</p></figure><p id="c98d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在上面的例子中，我们已经在<code class="fe oj ok ol oa b">PolynomialFeatures()</code>函数中指定了<code class="fe oj ok ol oa b">2</code>所需的非线性模型的阶数。输入数组的特征值从<strong class="lj jt"> (X1，X2)转换到(1，X1，X2，X1，X1*X2，X2)。</strong></p><h2 id="274a" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">定制变压器</h2><p id="2ea6" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">如果出于数据处理或清理等任何目的，需要使用特定的函数(python 中已有的)来转换整个数据，我们可以通过实现函数<code class="fe oj ok ol oa b">FunctionTransformer()</code>并传递所需的函数来创建一个定制的转换器。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="8c04" class="md me jj oa b gy oe of l og oh">import sklearn.preprocessing <br/>import numpy as np<br/>transformer = <strong class="oa jt">preprocessing.FunctionTransformer</strong>(np.log1p, validate=True)<br/>X = np.array([[1,2,3],<br/>              [4,5,6],<br/>              [7,8,9]])<br/>transformer.transform(X)</span></pre><p id="f976" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本例中，我们使用了 log 函数来转换数据集值。</p><figure class="nv nw nx ny gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/02d78bf33f8fdfb6f78a647217326db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*jYOqF8FUDgZyKSxsQbDNTg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片来自<a class="ae jg" href="https://medium.com/@beginningofthefuture" rel="noopener">作者</a>)实现定制变压器</p></figure><h2 id="719d" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">结论</h2><p id="cb0c" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">我希望通过这篇文章，你能够理解机器学习模型中数据预处理的概念和需求，并且能够将这些概念应用到真实的数据集中。</p><p id="22c8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了更好地理解这些概念，我建议您尝试在 once 上实现这些概念。继续探索，我相信你会发现新的特性。</p><p id="0753" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你有任何问题或意见，请发表在评论区。</p><blockquote class="na nb nc"><p id="7c53" class="lh li nd lj b lk ll kt lm ln lo kw lp ne lr ls lt nf lv lw lx ng lz ma mb mc im bi translated">查看完整的数据可视化指南和 NumPy 的基本功能:</p></blockquote><div class="is it gp gr iu ov"><a rel="noopener follow" target="_blank" href="/data-visualization-with-python-8bc988e44f22"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd jt gy z fp pa fr fs pb fu fw js bi translated">用 Python 实现数据可视化</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">Master python 的数据可视化库</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">towardsdatascience.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ja ov"/></div></div></a></div><div class="is it gp gr iu ov"><a rel="noopener follow" target="_blank" href="/numpy-cheatsheet-for-essential-functions-python-2e7d8618d688"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd jt gy z fp pa fr fs pb fu fw js bi translated">NumPy 的备忘单:基本功能和鲜为人知的功能</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">学习你可能不知道的 NumPy 的各种基本功能(用代码)</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">towardsdatascience.com</p></div></div><div class="pe l"><div class="pk l pg ph pi pe pj ja ov"/></div></div></a></div></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><p id="6876" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt"> <em class="nd">最初发表于:</em></strong><a class="ae jg" href="http://www.patataeater.blogspot.com/" rel="noopener ugc nofollow" target="_blank"><strong class="lj jt"><em class="nd">【www.patataeater.blogspot.com】</em></strong></a></p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="a23a" class="md me jj oa b gy oe of l og oh">Resources:<br/><a class="ae jg" href="https://scikit-learn.org/stable/modules/preprocessing.html#" rel="noopener ugc nofollow" target="_blank">https://scikit-learn.org/stable/modules/preprocessing.html#</a></span></pre></div></div>    
</body>
</html>