<html>
<head>
<title>Power Analysis — The COOLEST thing you’ve never heard of.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">电源分析——你从未听说过的最酷的东西。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/power-analysis-the-coolest-thing-that-youve-never-heard-of-476d35c18161?source=collection_archive---------45-----------------------#2020-05-03">https://towardsdatascience.com/power-analysis-the-coolest-thing-that-youve-never-heard-of-476d35c18161?source=collection_archive---------45-----------------------#2020-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="18fa" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">从头做起</h2><div class=""/><div class=""><h2 id="205d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">将权力投入到您的物流决策中。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/62253fda4039c145c0e85a187f4338a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyjcPSmojeu1jn7gqU7_Ag.png"/></div></div></figure><blockquote class="ld"><p id="831b" class="le lf it bd lg lh li lj lk ll lm ln dk translated"><a class="ae lo" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/using%20powerlog%20to%20our%20advantage.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><p id="7f4e" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj ln im bi mk translated">无论我说什么，T2</p><blockquote class="ld"><p id="2764" class="le lf it bd lg lh mt mu mv mw mx ln dk translated">“基本概率”</p></blockquote><p id="d5cf" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj ln im bi translated">可能立即跳入你脑海的是统计学中的贝叶斯数学(可能是宗教的)。贝叶斯定理或条件概率定理都是很好的例子，说明为什么这是一个很好的假设。尽管条件概率与贝叶斯统计有很强的关系，但是，有很多独特而有趣的方法来进行推理。当你在一台计算机和程序机器学习算法(数据科学超级力量)后面时，尤其如此。)我主观地认为，统计学和统计学家这两个派别(很可能是宗教派别)实际上合作得非常好，或者可以互换。今天我将向你展示如何在Julia中使用简单的数学来操作逻辑概率。</p><p id="2077" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">逻辑回归功效分析的迷人之处在于，执行它的数学是相对基础的，不需要任何递归成本训练或任何类似的东西(甚至不需要sigmoid或relu。)这不仅方便，而且性能很好，易于编程和操作。此外，您可以将这种分析重新应用到机器学习算法中，并将其用于您的优势。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="d2f6" class="nk nl it bd nm nn no np nq nr ns nt nu ki nv kj nw kl nx km ny ko nz kp oa ob bi translated">说明</h1><p id="6417" class="pw-post-body-paragraph lp lq it lr b ls oc kd lu lv od kg lx ly oe ma mb mc of me mf mg og mi mj ln im bi translated">逻辑回归功效分析通常用于确定样本量。统计学家中一个常见的误解是，你的样本量是静态的；也就是说，对于每一种情况，没有一个特定的样本量。幸运的是，使用一个逻辑的决策模型将允许你为几乎任何场合计算一个精确的样本大小。作为一个额外的好处，功耗分析还可以做很多其他的事情。</p><h1 id="60c7" class="nk nl it bd nm nn oh np nq nr oi nt nu ki oj kj nw kl ok km ny ko ol kp oa ob bi translated">该功能</h1><p id="6c2e" class="pw-post-body-paragraph lp lq it lr b ls oc kd lu lv od kg lx ly oe ma mb mc of me mf mg og mi mj ln im bi translated">为了执行功耗分析，我们需要一些输入变量。不要太担心这些简短的解释，因为如果您处于未知领域，它可能在函数的示例使用中更有意义。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/ce5a6c6eccac52e9e5adb0b63f2ccc5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*XHlr3WShW4Tsteix099pEg.png"/></div></figure><p id="0e37" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">首先，我们需要p1和p2。这两个值中的p是一个概率，所以本质上，我们有</p><blockquote class="ld"><p id="b483" class="le lf it bd lg lh mt mu mv mw mx ln dk translated">概率1和概率2。</p></blockquote><blockquote class="on oo op"><p id="adf6" class="lp lq oq lr b ls lt kd lu lv lw kg lx or lz ma mb os md me mf ot mh mi mj ln im bi translated">记住:这些不是P值，而是百分比。</p></blockquote><p id="65b9" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">我们还需要阿尔法。一个<strong class="lr jd">阿尔法水平</strong>是一个类型I错误的概率，所以当它为真时，你拒绝零假设。这是在<strong class="lr jd"> <em class="oq">对比</em> </strong>到<strong class="lr jd">贝塔水平</strong>中，正好相反，会让你接受你的零假设。确保不要在这个问题上选边站，<strong class="lr jd">你不能选择是接受还是拒绝你的空值</strong>。有时候我喜欢用迷因来阐述观点，不久前我发现了这个:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/a2c6b469f12b21b63808210a0496df02.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*OVYrw2A7C0lFb5lrefYpHg.jpeg"/></div><p class="ov ow gj gh gi ox oy bd b be z dk translated">(不是质量最好的)</p></figure><p id="7aa0" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">我们的最后一个值是rsq，rsq是预测变量(y)和模型中所有其他变量(X('s))之间的多重相关的平方。我们需要在这个函数中获取的第一个值是l1和l2:</p><pre class="ks kt ku kv gt oz pa pb pc aw pd bi"><span id="bbd0" class="pe nl it pa b gy pf pg l ph pi">pd = p2 - p1<br/>    l1 = p1/(1-p1)<br/>    l2 = p2/(1-p2)</span></pre><p id="dd5a" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">如果X是一个未知变量，其概率分布为f(x ),其特征为未知参数θ，随机样本X1的大小为n，X2……..X2 XnX1……..Xn然后统计ϕ=h(X1,X2，)是θ\左(\θ\右)的点估计量。我们也可以说ϕϕ是θ的参数空间。所以本质上，当我们声明l1和l2时，我们所做的是，用我们的两个概率来设置θ的参数空间。现在我们计算θ，就像用较高概率(p2)的参数(l2)除以较低概率(p1)的参数(l1)一样简单。</p><pre class="ks kt ku kv gt oz pa pb pc aw pd bi"><span id="ec9e" class="pe nl it pa b gy pf pg l ph pi">θ = l2 / l1</span></pre><p id="ee8f" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">现在我们需要λ，我们可以通过简单地记录θ来得到。这可以在julia中用log()方法完成(正如您可能已经想到的。)我们也可以继续做λ。</p><pre class="ks kt ku kv gt oz pa pb pc aw pd bi"><span id="29aa" class="pe nl it pa b gy pf pg l ph pi">λ = log(θ)<br/>λ2 = λ^2</span></pre><p id="7f1b" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">接下来，我们需要一个正态分布，我们还想获得正态分布的分位数，在Julia中，我们将使用Julia基本统计库中的分位数函数:</p><pre class="ks kt ku kv gt oz pa pb pc aw pd bi"><span id="13c7" class="pe nl it pa b gy pf pg l ph pi">za = quantile(Normal(),1-alpha)</span></pre><p id="a785" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">这里我使用的是软件包“Distributions.jl”，这当然是一个很棒的软件包，可以在Julia Pkg注册表中找到，但是计算您自己的正态分布是相对简单的。如果你熟悉标准定标器，它就是<strong class="lr jd">一样的东西。</strong>您只需从X的迭代中减去样本均值，然后除以标准偏差。</p><p id="3218" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">f(x)=[I =(I-μ)/σfor I in x<strong class="lr jd">)</strong></p><p id="d0d8" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">您可能已经注意到我使用了一个语法循环，这是有意为之的，因为quantile()方法的语法不会采用单个规范化值，因为它依赖于分布和1-alpha来计算za。</p><pre class="ks kt ku kv gt oz pa pb pc aw pd bi"><span id="9478" class="pe nl it pa b gy pf pg l ph pi">using Lathe.stats: mean, std<br/># Function<br/>function normald(array)<br/>    <strong class="pa jd">σ </strong>= std(array)<br/>    μ = mean(array)<br/>    v = [i = (i-μ) / <strong class="pa jd">σ </strong>for i in array]<br/>    return(v)<br/>end</span><span id="81b4" class="pe nl it pa b gy pj pg l ph pi"># Syntactual expression<br/>normald(x) = [i = (i-mean(x)) / o for i in x]</span></pre><p id="33df" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">现在我不确定Julia是否真的使用了syntactual表达式，但是发行版中的Normalize()方法很有可能也适用于这个特定的实例。</p><blockquote class="on oo op"><p id="815d" class="lp lq oq lr b ls my kd lu lv mz kg lx or na ma mb os nb me mf ot nc mi mj ln im bi translated">朱利安提示:分位数是通过点<code class="fe pk pl pm pa b">((k-1)/(n-1), v[k])</code>之间的线性插值计算出来的，对于<code class="fe pk pl pm pa b">k = 1:n</code>其中<code class="fe pk pl pm pa b">n = length(v)</code>。</p></blockquote><p id="d97d" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">接下来，我们将打印出双尾检验的值。这一步当然是可选的，但对于这一特殊功能来说，这无疑是一个很有价值的步骤:</p><pre class="ks kt ku kv gt oz pa pb pc aw pd bi"><span id="ceb8" class="pe nl it pa b gy pf pg l ph pi">println("One-tailed test: alpha = ",alpha,", p1 = ",p1,", p2 = ",p2,", rsq = ",rsq,", odds ratio = ",or)</span></pre><blockquote class="ld"><p id="6fb0" class="le lf it bd lg lh li lj lk ll lm ln dk translated">如果你还在继续，这就是我们现在的情况:</p></blockquote><figure class="po pp pq pr ps kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/2c61f8def963c6548db5e7e9b8cf005d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfdRIuBLht3MXf74-9HSuw.png"/></div></div></figure><p id="a538" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">接下来，我们需要计算小写delta。幸运的是，对于这个特定的操作，我们已经有了可用的值。它看起来是这样的:</p><pre class="ks kt ku kv gt oz pa pb pc aw pd bi"><span id="9066" class="pe nl it pa b gy pf pg l ph pi">δ = (1 + (1 + λ2)*exp(5 * λ2/4))/(1 + exp(-1*λ2/4))</span></pre><p id="41cc" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">我们将为样本大小和功效值创建两个空数组。</p><pre class="ks kt ku kv gt oz pa pb pc aw pd bi"><span id="91e1" class="pe nl it pa b gy pf pg l ph pi">pwr = zeros(Float64,8)<br/>nn = zeros(Int64,8)</span></pre><p id="1c6b" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">然后，最重要的是，我们添加一个循环来迭代我们的幂和样本大小，并给出一个返回:</p><pre class="ks kt ku kv gt oz pa pb pc aw pd bi"><span id="53d8" class="pe nl it pa b gy pf pg l ph pi">i = 1<br/>    for power = 0.6:.05:.95<br/>        zb = quantile(Normal(),power)</span><span id="2873" class="pe nl it pa b gy pj pg l ph pi">N = ((za + zb*exp(-1 * λ2/4))^2 * (1 + 2*p1*δ))/(p1*λ2)<br/>        N /= (1 - rsq)<br/>        pwr[i] = power<br/>        nn[i] = ceil(Int64,N)<br/>        i += 1<br/>    end<br/>    return(pwr,nn)</span></pre><p id="786b" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">最终结果看起来有点像这样:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/ea119fa4cda312a1b7f2382d4bc9cb48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EYc4lLJKRmlGLFCuQHHnKg.png"/></div></div></figure></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="f87d" class="nk nl it bd nm nn no np nq nr ns nt nu ki nv kj nw kl nx km ny ko nz kp oa ob bi translated">例子</h1><p id="270c" class="pw-post-body-paragraph lp lq it lr b ls oc kd lu lv od kg lx ly oe ma mb mc of me mf mg og mi mj ln im bi translated">假设，让我们说我们正计划为我们的一个空缺职位招聘人员。在我们的带回家的面试中，我们给每个人都做了一个测试，他们必须通过这个测试才能被录用——但是那些分数较高的人更有可能被考虑。我们预计，只有大约25%的人会在测试中取得高于样本平均值的分数。然后我们还会考虑多15%的分数会比平均值高出一个标准差，或者</p><pre class="ks kt ku kv gt oz pa pb pc aw pd bi"><span id="0e4f" class="pe nl it pa b gy pf pg l ph pi">μ &lt; p1 = .25 + .15 = p2 &lt; <strong class="pa jd">σ</strong></span></pre><p id="61b6" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">有了这个表达式，我们可以假设值p2将是那些测试的15%+= P1，所以在我们的例子中，我们得到0.40。现在如果我们把它代入公式:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pu"><img src="../Images/f658f3e3b5c534b59e0ec3a68d244c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1n0y0AMTCSq53Ltue7ZTw.png"/></div></div></figure><p id="ed6c" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">现在我们可以用zip函数并行打印我们的幂和样本大小(或者成对连接它们，由您决定。)</p><pre class="ks kt ku kv gt oz pa pb pc aw pd bi"><span id="353f" class="pe nl it pa b gy pf pg l ph pi">for (i,w) in zip(pwr,nn)<br/>    println("Power: ", i, "   n: ", w)<br/>end</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/953a7ccc85da33ba90f06b81201d1a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*IdCZdu3g_1tolGsQk1IjqQ.png"/></div></figure><p id="abb5" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">功率的技术定义是，它是检测到一个“真实”效应存在时的概率。在大多数情况下，功耗分析涉及许多简化假设，以使问题易于处理，并使用不同的变量多次运行功耗分析，以涵盖所有的意外情况。</p><h1 id="474d" class="nk nl it bd nm nn oh np nq nr oi nt nu ki oj kj nw kl ok km ny ko ol kp oa ob bi translated">描绘我们的力量</h1><p id="291d" class="pw-post-body-paragraph lp lq it lr b ls oc kd lu lv od kg lx ly oe ma mb mc of me mf mg og mi mj ln im bi translated">当然，为了完成这一切，我们必须将这些数据可视化。为此，我将使用我的包Hone.jl。</p><pre class="ks kt ku kv gt oz pa pb pc aw pd bi"><span id="3ee4" class="pe nl it pa b gy pf pg l ph pi">using Hone</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pw"><img src="../Images/33cc3bd6cae68adea095981cefb3b586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-4GzLpmZCXdg0R_67SxHw.png"/></div></div></figure><p id="d509" class="pw-post-body-paragraph lp lq it lr b ls my kd lu lv mz kg lx ly na ma mb mc nb me mf mg nc mi mj ln im bi translated">看起来我的系统上有0.0.1版本的Hone.jl，但没关系，我可以忍受它…我们在这里可以观察到的是，随着功率的增加，nn也会增加。我们可以利用这些数据做的另一件有趣的事情是回到那个迭代循环，记录更多的功率。</p><h1 id="dae5" class="nk nl it bd nm nn oh np nq nr oi nt nu ki oj kj nw kl ok km ny ko ol kp oa ob bi translated">结论</h1><p id="3041" class="pw-post-body-paragraph lp lq it lr b ls oc kd lu lv od kg lx ly oe ma mb mc of me mf mg og mi mj ln im bi translated">坦白地说，我认为很多读者知道这种方法是可能的。话虽如此，我希望能从这篇文章中吸取一些东西。我在制作它的过程中获得了很多乐趣，我肯定会在Julia、R和——你猜对了，Python中添加更多“从头开始”的机器学习模型(也许我会变得疯狂，做一些Scala或C，谁知道呢。)</p></div></div>    
</body>
</html>