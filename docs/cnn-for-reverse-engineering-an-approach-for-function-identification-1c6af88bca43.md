# 用于逆向工程的 CNN:一种功能识别的方法

> 原文：<https://towardsdatascience.com/cnn-for-reverse-engineering-an-approach-for-function-identification-1c6af88bca43?source=collection_archive---------19----------------------->

## 为什么 CNN 对函数识别有用，如何实现

![](img/a4e2f860da08a46b40af2d26a5405b3c.png)

在将二进制文件部署到第三方环境之前，通常会删除二进制文件正常运行所不需要的任何信息。这样做是为了使二进制文件的逆向工程更加困难。从二进制文件中删除的一些信息是每个函数的边界。对于想对二进制文件进行逆向工程的人来说，这些信息非常有用。

> 函数识别是逆向工程领域中的一项任务，其中给定一个编译后的二进制文件，就应该确定每个函数边界的地址。函数的边界是函数的起始地址和结束地址。

# 为什么是神经网络？

*   识别边界没有简单的规则，尤其是对于在编译期间已经优化的二进制文件。
*   大量的数据——在互联网上很容易找到要编译的代码或已经用调试信息编译过的二进制文件来创建我们的数据集。
*   几乎不需要领域知识！神经网络(尤其是深度神经网络)的一大优势是它们能够很好地处理原始数据，并且不需要特征提取。

使用神经网络进行功能识别的想法并不新鲜。它首先在 Eui 等人撰写的名为[用神经网络](https://people.eecs.berkeley.edu/~dawnsong/papers/Recognizing%20functions%20in%20binaries%20with%20neural%20networks_augsut%202015.pdf)识别二进制函数的论文中介绍。作者使用双向 RNN 来学习函数边界。根据他们的论文，他们不仅取得了类似或更好的结果，而且将计算时间从 587 小时减少到 80 小时。我认为这项研究真正展示了神经网络的力量。

# 那么为什么是 CNN 呢？(CNN vs RNN)

CNN(卷积神经网络)在关于计算机视觉的任务中非常流行。原因之一是 CNN 只能捕捉到**的地方特色**。

> 局部特征描述输入面片(输入中的关键点)。例如，对于图像，它可以是关于图像中特定区域的任何特征，例如点或边缘。
> 
> 全局要素是从整体上描述输入的要素。

另一方面，RNN 是一个“更强”的模式，因为它可以学习 T4 的本地和全球特色。

但是更强并不总是更好。对于只需要学习局部特征的任务，使用能够学习局部和全局特征的模型可能会导致过度拟合并增加训练时间。

对于函数标识，对于二进制中的每个字节，只需查看它前面的 10 个字节和后面的 10 个字节，就可以确定它是函数的开始还是结束。这一特性使得 CNN 似乎应该为这一任务取得好的结果。
也就是说，有一些全局特征可以帮助确定函数的边界。例如，`call`操作码可以帮助我们确定一个函数的开始。然而，即使是 RNN 也将很难了解这些特征，因为 RNN 在长序列上表现不佳(这就是为什么在 Eui 等人的论文中，他们用来自二进制而不是整个二进制的随机 1000 字节序列来训练他们的网络)。

此外，与顺序模型的 RNN 不同，CNN 可以并行运行，这意味着网络的训练和测试都应该更快。

我们介绍完了。我们来编码吧！

# 密码

代码使用 PyTorch 库在 Python3.6 中实现。

为了简单起见，我们将实现一个模型来标识每个函数的开始，但是同样的代码也可以用于标识结束。

完整代码可从以下网址获得:

[](https://github.com/alonstern/function-identification?) [## 单独/功能识别

### 通过在 GitHub 上创建一个帐户，为独立/功能识别开发做出贡献。

github.com](https://github.com/alonstern/function-identification?) 

## 数据

我们将使用 Eui 等人在论文中使用的相同数据集。
该数据集最初是为一篇名为 [ByteWeight:学习识别二进制代码中的函数](https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-bao.pdf)的论文创建的。Eui 等人使用相同的数据集将他们的结果与原始论文中报告的结果进行了比较。

数据集可在[http://security.ece.cmu.edu/byteweight](http://security.ece.cmu.edu/byteweight/)
获得。数据集由一组编译有调试信息的二进制文件组成。

我们将使用 elf_32 数据集，但是相同的代码也可以应用于 elf_64 数据集(和 PE_dataset，但是需要不同的调试信息解析过程)。

可以通过运行以下命令来下载数据集:

```
wget — recursive — no-parent — reject html,signature [http://security.ece.cmu.edu/byteweight/elf_32](http://security.ece.cmu.edu/byteweight/elf_32/)
```

## 预处理数据

首先，我们需要从每个二进制文件中提取它的代码段和函数地址。

Elf 文件由部分组成。每个部分包含不同的信息。我们感兴趣的部分是`.text`部分和`.symtab`部分。

*   `.text`包含运行二进制文件时执行的操作码。
*   `.symtab`包含关于二进制文件中函数的信息(以及更多)。

请注意，`.symtab`部分中的信息可以从二进制文件中剥离出来。这个项目对于那些情况是有用的。

![](img/2b587d41db113f53225af2ef62df70d1.png)

为了解析二进制文件中的部分，我们将使用 Pyelftools 库。

首先，让我们提取`.text`部分的数据

对于二进制代码中的每个字节，我们需要提取它是否是函数的开始。

现在让我们迭代数据集中的二进制文件。
我们将使用 tqdm 库为我们的预处理制作一个漂亮的进度条，不费吹灰之力！

太好了！我们有自己的数据和标签。

要将数据输入到模型中，我们不应该只是一个文件一个文件地输入。相反，我们应该确定每次训练模型所需的数据大小，并将我们的数据分割成具有该大小的块。

此外，如果我们希望 CNN 输出一个大小为`tags`的向量，我们需要根据 CNN 内核大小填充输入。

让我们把它总结在一个`torch.utils.data.Dataset`类下:

## 构建模型

模型的输入将是一个向量，其中每个值都在 0 到 257 之间(0–255 表示字节值，256 表示文件的开始，257 表示文件的结束)。
模型的输出将进入一个矩阵，其中每一行包含两个值——一个字节作为函数开始的概率和一个字节不作为函数开始的概率(这些值的总和为 1)。

因为每个字节值代表一个不同的符号，我们想把每个值转换成一个向量。这样做的方法是使用嵌入层。

嵌入指南:

[](/neural-network-embeddings-explained-4d028e6f0526) [## 解释了神经网络嵌入

### 深度学习如何将战争与和平表现为一个向量

towardsdatascience.com](/neural-network-embeddings-explained-4d028e6f0526) 

在嵌入层之后，我们准备添加具有 Relu 激活功能的卷积层。
注意，我们希望卷积对整个字节起作用，因此内核大小应该是:我们要查看的字节数 X 每个字节的大小(嵌入层的输出维度)。

现在我们添加一个具有 softmax 激活功能的全连接输出层。

整个架构:

![](img/ace6e2d3f675953bdb2df5b12aa52360.png)

这就是整个模型！

## 训练和测试模型

首先，我们需要拆分数据进行训练和测试。我们将使用 90%的数据进行训练，10%的数据进行测试。

现在，为了创建模型，我们可以简单地实例化`CNNModel`

在培训中，我们将使用负对数似然损失函数和 Adam optimizer。同样，我们为我们的培训添加了一个漂亮的进度条 tqdm。

对于测试，我们看四个参数。准确度、精确度、召回率和 f 分数。

由于大部分字节不是函数的开始，因此仅用精确度不足以衡量该任务的性能。因此，即使是一个将所有事情都归类为“不是函数的开始”的模型也会获得很高的准确性。

# 结果

我在配备英特尔酷睿 i7–7500 u CPU、2.70GHz 和 16 GB 内存的个人笔记本电脑上对该模型进行了培训和测试。

## 定时性能

整个数据的预处理耗时 43 秒。
在 90%的数据集上训练模型耗时 33 分 43 秒。
其余 10%用 24 秒检测模型。

Eui 等在他们的论文中报道，每种模型的训练时间为 2 小时。我们的训练花了将近四分之一的时间！

## 预测性能

测试集的结果:

> 准确度:99.9981%
> 精密度:99.6905%
> 召回:99.4613%
> f1-评分:99.5758%

Eui 等人论文中报告的对函数起始地址进行分类的最佳模型获得了 99.24%的 f1 分数。

就是这样，一个有线电视新闻网，它可以在二进制文件中找到每个函数的开始。这是我写的第一篇媒体文章。
希望你喜欢！如需更多信息/问题，请随时与我联系。

**感谢您的阅读！**

[1] E. C. R. Shin，D. Song 和 R. Moazzezi。用神经网络识别二进制文件中的函数(2015)。第 24 届 USENIX 安全研讨会论文集。

[2] T. Bao，J. Burket，M. Woo，R. Turner，D. Brumley .BYTEWEIGHT:学习识别二进制代码中的函数(2014)。第 23 届 USENIX 安全研讨会论文集。