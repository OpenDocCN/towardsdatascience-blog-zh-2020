<html>
<head>
<title>Credit Risk Management: EDA &amp; Feature Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">信用风险管理:EDA 和特征工程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/credit-risk-management-eda-feature-engineering-81cc34efc428?source=collection_archive---------20-----------------------#2020-08-02">https://towardsdatascience.com/credit-risk-management-eda-feature-engineering-81cc34efc428?source=collection_archive---------20-----------------------#2020-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="36de" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这一部分从如何使用 EDA 和特征工程技术对数据进行清理和预处理开始，特别是在接触和不接触“目标”变量的情况下。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/615d348e1d01ffa4c50493dd55db0ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f6req9MWPWXKHN-JjqQ6Cw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://unsplash.com/photos/g7NfqV6C074" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/g7NfqV6C074</a></p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="ab58" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">语境</h1><p id="bd6a" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated"><em class="mr">在金融行业中，数据科学可以提供巨大帮助的常见用例有哪些？</em></p><p id="ce63" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">信用评分卡是金融行业中常见的风险控制方法之一，它使用个人信息和交易记录来识别和评估现有和潜在客户的信誉。有许多不同的用例利用这种方法，如贷款管理、信用卡审批、信用额度扩展等。</p><p id="b435" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">也就是说，这个项目的适用性因金融机构面临的问题而异。使该项目可用的核心引擎是输入数据的处理和转换，以从现有/新输入中产生高度可预测性的输出，从而最好地解决问题。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="f99d" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">目录</h1><p id="7a69" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">该端到端项目分为 3 个部分:</p><ol class=""><li id="b28e" class="mx my iq lx b ly ms mb mt me mz mi na mm nb mq nc nd ne nf bi translated">解释性数据分析(EDA)和特征工程</li><li id="e332" class="mx my iq lx b ly ng mb nh me ni mi nj mm nk mq nc nd ne nf bi translated">特征缩放和选择(奖励:不平衡数据处理)</li><li id="2306" class="mx my iq lx b ly ng mb nh me ni mi nj mm nk mq nc nd ne nf bi translated">机器学习建模(分类)</li></ol><p id="4f50" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated"><strong class="lx ir"> <em class="mr">注</em> : </strong>由于该项目旨在提高我在数据科学方面的能力，简而言之，为了自学和自我提高，该项目将把数据集分成 2 个更小的子集来测试哪个产生更好的结果，而不是只应用性能最好的技术。</p><p id="2ade" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">因此，让我们从项目的第一部分开始:EDA &amp;特性工程</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="af56" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">A.解释性数据分析(EDA)</h1><p id="82c7" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">让我们导入必要的库和两个数据集:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="fb6d" class="nq le iq nm b gy nr ns l nt nu">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns</span><span id="2008" class="nq le iq nm b gy nv ns l nt nu">application = pd.read_csv("application_record.csv")<br/>credit = pd.read_csv("credit_record.csv")</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/21594d342672a05b2ee93ae57a54277c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*flhb3P3MPnYK3RKHtdKa7w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用数据集</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/93f77dbcc8d070756e36ad2ec99adcdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*uko-ZqALrZw4Pdhn4NET_w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">信用数据集</p></figure><p id="7a91" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">如上所述，应用数据集提供现有银行客户提交的<strong class="lx ir"><em class="mr"/></strong>个人信息中的所有数据点(如身份证、性别、收入等。)，信用数据集将每个对应的 id 与他/她的<strong class="lx ir"> <em class="mr">贷款偿还状态</em> </strong>进行映射(例如，X 表示当月无贷款，C 表示已还清，&gt; 0 表示逾期还款月数)。</p><p id="ba9d" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">为了更好地使用信用信息，我清理了数据集，将“Status”列转换为数字，并按客户 ID 和最近一个月进行分组:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="164a" class="nq le iq nm b gy nr ns l nt nu">credit.status = credit.status.replace({'X':-2, 'C': -1})<br/>credit.status = credit.status.astype('int')<br/>credit.status = credit.status.apply(lambda x:x+1) </span><span id="55ec" class="nq le iq nm b gy nv ns l nt nu">credit_month = credit.groupby('id').months_balance.max().reset_index()</span><span id="3c12" class="nq le iq nm b gy nv ns l nt nu">record = pd.merge(credit_month, credit, how="inner", on=["id", "months_balance"])</span><span id="459b" class="nq le iq nm b gy nv ns l nt nu">record.head()</span></pre><p id="7c52" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">当一切都设置好后，我就利用“内部合并”将新处理的数据集与应用程序结合起来。在此之上，如果你回头参考原始数据集，“出生日期”和“就业”是从今天开始向后算的天数，这在最初有点难以理解。因此，我决定将这些变量转换成正数和年份。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="4256" class="nq le iq nm b gy nr ns l nt nu">df['age'] = df.birth_date.apply(lambda x: round(x/-365,0))<br/>df['year_of_employment'] = df.employment.apply(lambda x: round(x/-365,0) if x&lt;0 else 0)</span><span id="de29" class="nq le iq nm b gy nv ns l nt nu">df = df.drop(columns=["birth_date","employment"])</span></pre><p id="e277" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">继续，我建议你永远不要忽略的每个 EDA 的两个亮点是(1) <strong class="lx ir"> <em class="mr">检查空值</em> </strong>和(2) <strong class="lx ir"> <em class="mr">处理异常值</em> </strong>。前者确保我们在处理和插入建模之前有一个 100%干净的数据集，而后者有助于避免您的数据集因边缘极端异常值而过度倾斜。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="76b8" class="nq le iq nm b gy nr ns l nt nu">df.isnull().sum()<br/>df.occupation_type = df.occupation_type.fillna("Others")</span></pre><p id="a7ab" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">“职业类型”是唯一具有空值(NaN)的变量，所以我继续用“其他”填充这些值。</p><p id="debf" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">使用<strong class="lx ir"> df.describe </strong>和<strong class="lx ir"> sns.boxplot </strong>，我能够发现“年收入”和“Fam 成员”是数据集中有异常值的两个变量，直观显示如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/41113e953fe974d93d74dc40433a3229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGnh53YfDe9G9z6IB_-u4A.png"/></div></div></figure><p id="8230" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">为了消除异常值，我编写了一个函数，它可以很容易地应用于具有类似问题的变量:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="9cc4" class="nq le iq nm b gy nr ns l nt nu">def remove_outlier(col):<br/>    q25 = col.quantile(0.25)<br/>    q75 = col.quantile(0.75)<br/>    iqr = q75 - q25<br/>    cutoff = iqr*1.5<br/>    lower = q25 - cutoff<br/>    upper = q75 + cutoff<br/>    return lower, upper</span><span id="28b8" class="nq le iq nm b gy nv ns l nt nu">#Remove outliers for Annual Income</span><span id="c2e8" class="nq le iq nm b gy nv ns l nt nu">lower_1, upper_1 = remove_outlier(df.annual_income)<br/>df = df.loc[(df.annual_income &gt; lower_1) &amp; (df.annual_income &lt; upper_1)] </span><span id="0815" class="nq le iq nm b gy nv ns l nt nu">#Remove outliers for Fam Members</span><span id="c3b9" class="nq le iq nm b gy nv ns l nt nu">lower_2, upper_2 = remove_outlier(df.fam_members)<br/>df = df.loc[(df.annual_fam_members &gt; lower_2) &amp; (df.fam_members &lt; upper_2)]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/83c6b0fee4a8538a7a3f31ddebd8e773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qsn2bDd6gUpcNJjkM7fZ3g.png"/></div></div></figure><p id="9964" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">我们几乎已经完成了 EDA，接下来要定义“目标”变量，您可能在大多数分类课程中听过这个变量。</p><p id="3c9d" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">回到这个项目的主题，信用风险管理，我们需要确定我们应该如何处理客户的贷款偿还状态。有了这个数据集，我为那些当月没有任何贷款或没有还清贷款的人定义了“target = 0”，而剩余的数据(任何逾期贷款)被映射到“target = 1”。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="dfac" class="nq le iq nm b gy nr ns l nt nu">df['target'] = None<br/>df.loc[df.status &lt; 1,'target']=0<br/>df.loc[df.status &gt;= 1,'target']=1<br/>df.target = pd.to_numeric(df.target)</span></pre></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="b54e" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">B.特征工程</h1><p id="f2e7" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated"><em class="mr">什么是特征工程，它在建模前对数据预处理有什么帮助？</em></p><p id="3a74" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">根据<a class="ae kv" href="https://en.wikipedia.org/wiki/Feature_engineering" rel="noopener ugc nofollow" target="_blank">维基百科</a>，</p><blockquote class="oa ob oc"><p id="29e7" class="lv lw mr lx b ly ms jr ma mb mt ju md od mu mg mh oe mv mk ml of mw mo mp mq ij bi translated">特征工程是利用领域知识通过数据挖掘技术从原始数据中提取特征的过程。这些特征可以用来提高机器学习算法的性能。</p></blockquote><p id="e760" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">事实上，特征工程不仅需要领域知识，还需要对数据集的理解和实现的目标。特别地，对于我们的数据集，有相当多的不同特征，我们称之为<strong class="lx ir">自变量</strong>，它们与还款状态相关，这就是<strong class="lx ir">目标变量(0 或 1) </strong>。因此，为了调整出一个有洞察力和可操作的模型，我们需要通过转换现有的和/或添加支持数据来“工程化”那些特性，这使得特性工程不同于 EDA。</p><p id="b5db" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">正如我从一开始就提到的，我们永远不会知道哪种方法更好，直到我们进行测试。也就是说，我决定测试两个场景，有的<strong class="lx ir">和没有</strong>接触目标变量的<strong class="lx ir">，然后看看以后产生的结果是否有任何显著的不同。</strong></p><p id="4bd6" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">在深入实现之前，我们应该意识到，对于特征工程来说，没有“一刀切”的技术，因为它取决于您如何处理您的特征。在这个项目中，我在我的数据集中利用了“<strong class="lx ir">类别编码</strong>，因为大多数数据都是分类的，应该转换为数字，以便在大多数机器学习模型中更容易处理。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="135d" class="nq le iq nm b gy nr ns l nt nu">df_a = df #for encoding without target<br/>df_b = df #for encoding with target</span><span id="ff77" class="nq le iq nm b gy nv ns l nt nu">x_a = df_a.iloc[:, 1:-1]<br/>y_a = df_a.iloc[:, -1]</span><span id="7206" class="nq le iq nm b gy nv ns l nt nu">from sklearn.model_selection import train_test_split</span><span id="3d42" class="nq le iq nm b gy nv ns l nt nu">x_a_train, x_a_test, y_a_train, y_a_test = train_test_split(x_a, y_a, test_size=0.3, random_state=1)</span></pre><p id="6f4a" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">我们为两个场景创建了两个独立的数据集，这样我们就可以操作每个数据集，而不用担心会混淆。</p><p id="7415" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">此外，<strong class="lx ir">在处理之前需要注意的一个重要亮点是，强烈建议我们<strong class="lx ir">将数据集</strong>拆分为训练集和测试集<strong class="lx ir">，以避免数据泄露</strong>。本质上，如果我们在处理后进行分割，测试集的数据就会暴露出来，因此在建模阶段与训练集进行比较时不够客观。</strong></p><h1 id="c589" class="ld le iq bd lf lg og li lj lk oh lm ln jw oi jx lp jz oj ka lr kc ok kd lt lu bi translated">1.无目标分类编码</h1><p id="2c44" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated"><em class="mr">根据变量类型，我们将对每个变量应用合适的技术。</em></p><p id="adb5" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">如果你回头参考数据集，有 3 种类型的变量:(1)二元，(2)名义和(3)连续。虽然二进制和连续变量是不言自明的，但名义变量指的是一组不同的类别，它们之间没有内在的顺序。</p><h2 id="5d29" class="nq le iq bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt ov bi translated">1.1.二元变量</h2><p id="e086" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">对于我们数据集中的二进制变量(如性别、汽车、财产)，我们可以从 sklearn 库中选择<strong class="lx ir">标签编码器</strong>或<strong class="lx ir">标签二进制化器</strong>，这将<strong class="lx ir"> <em class="mr">将原始数据映射为 0 或 1: </em> </strong></p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="4dce" class="nq le iq nm b gy nr ns l nt nu">#Option 1: Label Encoder (applied to &gt;2 categories per variable)<br/>from sklearn.preprocessing import LabelEncoder, LabelBinarizer</span><span id="9aa7" class="nq le iq nm b gy nv ns l nt nu">le = LabelEncoder()<br/>gender_le = le.fit_transform(x_a_train.gender)</span><span id="83ec" class="nq le iq nm b gy nv ns l nt nu">#Option 2: LabelBinarizer (applied to 2 categories per variable)</span><span id="9654" class="nq le iq nm b gy nv ns l nt nu">bn = LabelBinarizer()<br/>gender_bn = np.array(x_a_train.gender).reshape(-1,1)<br/>gender_bn = bn.fit_transform(gender_bn)</span></pre><h2 id="f7bf" class="nq le iq bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt ov bi translated">1.2.名义可变因素</h2><p id="0f35" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">名义变量(如收入类型、教育、家庭状况、住房类型、职业类型)是分类变量，需要在建模前转换为数字变量。对类别进行编码的两种常见方法是(1) <strong class="lx ir">虚拟编码</strong>和(2) <strong class="lx ir">一个热编码器</strong>，它基本上创建 n 列作为该变量内的 n 个唯一类别，并根据每列中每个类别的存在与否分配 0 或 1。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/7de70649d25356c3be6f73baa2f9330c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HpIj52gOqR-PS7MW.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://deepai.org/machine-learning-glossary-and-terms/dummy-variable" rel="noopener ugc nofollow" target="_blank">https://deepai . org/machine-learning-glossary-and-terms/dummy-variable</a></p></figure><p id="4ea9" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">这些方法之间的区别在于伪编码转换成 n-1 个子变量，而一个热编码器转换成 n 个子变量。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="e94d" class="nq le iq nm b gy nr ns l nt nu">#Option 1: Dummy Encoding: kn - k variables</span><span id="a105" class="nq le iq nm b gy nv ns l nt nu">income_type_dummy = pd.get_dummies(x_a_train.income_type)</span><span id="d297" class="nq le iq nm b gy nv ns l nt nu">#Option 2: OneHotEcnoder: kn variables</span><span id="9a58" class="nq le iq nm b gy nv ns l nt nu">from sklearn.preprocessing import OneHotEncoder</span><span id="5b84" class="nq le iq nm b gy nv ns l nt nu">onehot = OneHotEncoder(sparse=False, drop='first', handle_unknown='error')</span><span id="5cb1" class="nq le iq nm b gy nv ns l nt nu">income_type_onehot = onehot.fit_transform(x_a_train.income_type.to_numpy().reshape(-1,1))<br/>income_type_onehot = pd.DataFrame(income_type_onehot, columns=onehot.get_feature_names(['income_type']))<br/></span></pre><p id="c530" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">虚拟编码可以通过<strong class="lx ir"> pd.get_dummies() </strong>轻松完成，因为它已经是 pandas 库的一部分。对于一个 Hot 编码器，我们需要从 sklearn 库中导入它，并单独或同时转换每个变量。</p><p id="517c" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">一个热编码器被设计为保持跨训练和测试集的类别数量的一致性(例如，处理没有出现在任何一个集合中的类别)，因此它比哑编码更值得推荐，因为它更容易用“<strong class="lx ir"> handle_unknown= "error" </strong>”来控制。</p><p id="5977" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">然而，一个热门编码器的缺点之一是<strong class="lx ir">多重共线性</strong>，它指的是变量或子变量之间高度线性相关，因此降低了我们模型的准确性。这可以通过分配参数“<strong class="lx ir">drop =‘first’</strong>”来纠正或避免，这有助于在编码后删除其中一个子变量。</p><h2 id="5641" class="nq le iq bd lf ol om dn lj on oo dp ln me op oq lp mi or os lr mm ot ou lt ov bi translated">1.3.连续变量</h2><p id="cfb8" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">连续变量<strong class="lx ir"> </strong>是在任意两个值之间有无限个值的数值变量。从本质上来说，它需要永远计数！让我们直观地看看数据集中每个连续变量的分布情况:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/149e7c6b6cf6d41abc22a31ed09130c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yw5bCErenx716f-fcU5oAA.png"/></div></div></figure><p id="0c08" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">左图显示了客户的年龄范围，而右图显示了不同收入群体的分布情况。处理这类变量的两种常用方法是(1) <strong class="lx ir">固定宽度宁滨</strong>和(2) <strong class="lx ir">自适应宁滨</strong>。特别是，前者从预定义的箱(例如年龄-10-20、20-30、30-40 等)创建子类别，而后者依赖于数据的分布。</p><p id="0c23" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">固定宽度宁滨的优点和缺点是:对变量进行编码<strong class="lx ir">容易且简单</strong>但是相对主观而不考虑数据本身。因此，我建议选择密切关注数据分布的自适应宁滨。根据我的观察，我决定采用“<strong class="lx ir">分位数</strong>”，而不是转换成 2-bin 类别，因为原始分布范围很广，<strong class="lx ir">之后应用了标签编码</strong>。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="eef6" class="nq le iq nm b gy nr ns l nt nu">#Convert each variable into 5 equal categories/each</span><span id="d70d" class="nq le iq nm b gy nv ns l nt nu">x_a_train['age_binned'] = pd.qcut(x_a_train.age, q=[0, .25, .50, .75, 1])<br/>x_a_train['annual_income_binned'] = pd.qcut(x_a_train.annual_income, q=[0, .25, .50, .75, 1])</span><span id="bed9" class="nq le iq nm b gy nv ns l nt nu">#Apply Label Encoder to assign the label to each category without bias</span><span id="a9ff" class="nq le iq nm b gy nv ns l nt nu">x_a_train['age'] = le.fit_transform(x_a_train['age_binned'])<br/>x_a_train['annual_income'] = le.fit_transform(x_a_train['annual_income_binned'])</span></pre><p id="14e4" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">Tada！我们已经设计了所有必要的变量，但从未触及目标变量！现在，让我们在将每一个拟合到建模阶段之前，移动到另一个。</p><h1 id="c480" class="ld le iq bd lf lg og li lj lk oh lm ln jw oi jx lp jz oj ka lr kc ok kd lt lu bi translated">2.带目标的类别编码</h1><p id="7547" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">由于在这种方法中利用了与目标变量的相关性，为了更好的客观性，我们应该以相同的方式对所有自变量进行编码。</p><p id="aa76" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">同样，必须遵循先决条件:处理前的训练测试分割</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="b912" class="nq le iq nm b gy nr ns l nt nu">x_b = df_b.iloc[:, 1:-1]<br/>y_b = df_b.iloc[:, -1]</span><span id="62cb" class="nq le iq nm b gy nv ns l nt nu">from sklearn.model_selection import train_test_split</span><span id="d621" class="nq le iq nm b gy nv ns l nt nu">x_b_train, x_b_test, y_b_train, y_b_test = train_test_split(x_b, y_b, test_size=0.3, random_state=1)</span></pre><p id="50fc" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">在涉及目标的类别编码技术中，我发现了 3 个普遍使用的选项:(1) <strong class="lx ir">证据权重编码器(WOE) </strong> , (2) <strong class="lx ir">目标编码器</strong>,( 3)<strong class="lx ir">留一编码器(LOO) </strong>。</p><p id="bd82" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">简而言之，</p><ul class=""><li id="ecd5" class="mx my iq lx b ly ms mb mt me mz mi na mm nb mq oy nd ne nf bi translated"><strong class="lx ir"> WOE 编码器</strong>:证据权重编码是信用风险建模中广泛使用的一种技术，它可以获得与目标相关的每个变量中不同类别之间的最大差异。这很容易理解，其数学计算如下——好的百分比(在这种情况下，目标= 0) /坏的百分比(目标= 1)的自然对数:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/cbb1df5b2ca17a7736c4c9120e331c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VALE5SvAG5QNHLy9assbVg.png"/></div></div></figure><ul class=""><li id="69fb" class="mx my iq lx b ly ms mb mt me mz mi na mm nb mq oy nd ne nf bi translated"><strong class="lx ir">目标编码器&amp; LOO 编码器</strong>:前一种方法用数据集中所有行的目标变量的平均值替换分类值，后一种方法做了同样的事情，但排除了行本身。原因是为了避免在建模前使用太多信息而导致直接目标泄漏。</li></ul><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="b1cf" class="nq le iq nm b gy nr ns l nt nu">#Option 1: WOE Encoder<br/>import category_encoders as ce</span><span id="9969" class="nq le iq nm b gy nv ns l nt nu">woe = ce.WOEEncoder()</span><span id="c6ec" class="nq le iq nm b gy nv ns l nt nu">def woe_encoder(col, target):<br/>    for i in range(len(x_b_train.columns)):<br/>        col.iloc[:,i] = woe.fit_transform(col, target)<br/>    return col</span><span id="7b05" class="nq le iq nm b gy nv ns l nt nu">df_woe_train = woe_encoder(x_b_train, y_b_train)<br/></span><span id="cbc8" class="nq le iq nm b gy nv ns l nt nu">#Option 2: Target Encoder<br/>from category_encoders import TargetEncoder</span><span id="329f" class="nq le iq nm b gy nv ns l nt nu">te = TargetEncoder()</span><span id="871e" class="nq le iq nm b gy nv ns l nt nu">def target_encoder(col, target):<br/>    for i in range(len(x_b_train.columns)):<br/>        col.iloc[:,i] = te.fit_transform(col, target)<br/>    return col</span><span id="7f56" class="nq le iq nm b gy nv ns l nt nu">df_te_train = target_encoder(x_b_train, y_b_train)</span></pre><p id="a4a3" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">在测试了这两种方法之后，两者之间新编码的数据集似乎没有太大的区别。因此，对于这个项目的后续步骤，我选择了带有 WOE 编码器的数据集。<strong class="lx ir">但是</strong>，请在其他数据集上进行测试，这可能会由于不同的数据分布而产生不同的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/ed8d1a78c28f88a9eabee07d3524cb42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QHzXQ5JMvUbWlJ2xh3HwWw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">WOE 编码器</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/e5ea0f22b5cfc84a70efb098568f6594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUUowahFAvuaLx2M-KorYw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">目标编码器</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="a1ae" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">瞧啊。这是这个项目第一部分的总结！</p><p id="3f26" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">如上所述，该项目是作为学习笔记和提高我的数据科学技能的过程中的亮点的存储库而创建的。因此，我在每一部分都测试了多种方法，以便找出最好的执行技术。</p><p id="2962" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">请务必注意接下来的两个部分，它们涵盖了<strong class="lx ir">特征缩放/选择</strong>和<strong class="lx ir">机器学习建模</strong>！与此同时，我们来连线:</p><p id="c5e4" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">github:<a class="ae kv" href="https://github.com/andrewnguyen07" rel="noopener ugc nofollow" target="_blank">https://github.com/andrewnguyen07</a><br/>领英:<a class="ae kv" href="http://www.linkedin.com/in/andrewnguyen07" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/andrewnguyen07</a></p><p id="1e5f" class="pw-post-body-paragraph lv lw iq lx b ly ms jr ma mb mt ju md me mu mg mh mi mv mk ml mm mw mo mp mq ij bi translated">谢谢！</p></div></div>    
</body>
</html>