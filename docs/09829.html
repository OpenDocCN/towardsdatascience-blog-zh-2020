<html>
<head>
<title>Part 1: Defining and timing an API function in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第 1 部分:用 Python 定义和计时 API 函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/part-1-defining-and-timing-an-api-function-with-python-b0849775e961?source=collection_archive---------28-----------------------#2020-07-12">https://towardsdatascience.com/part-1-defining-and-timing-an-api-function-with-python-b0849775e961?source=collection_archive---------28-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="47e1" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Python 中并发性的图形化探索</h2><div class=""/><div class=""><h2 id="7b81" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">探索 Python 中的并发性以加速从远程 API 检索数据的系列文章。</h2></div><h1 id="2535" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">问题是</h1><p id="deff" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">使用 API 时，大部分时间都花在等待响应上。当从外部服务大量收集信息时，这会导致大量时间浪费。本文探索了如何使用 Python 的<strong class="ll jd">多处理</strong>、<strong class="ll jd">线程</strong>和<strong class="ll jd">异步</strong>特性从顺序请求转变为并发请求。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/be1c49ba32729f0da728b3173a8466d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e56xzHi_b5cfBw1oiOV7Gg.png"/></div></div></figure><h1 id="99c3" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">介绍</h1><p id="eebf" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在<a class="ae mr" href="https://levelup.gitconnected.com/jira-api-with-python-and-pandas-c1226fd41219" rel="noopener ugc nofollow" target="_blank">之前的文章</a>中，我们编写了一个简单的函数，它可以处理单个查询返回的问题数量的吉拉 API 限制。这解决了问题，但即使只有几千个结果，检索所有问题的时间也可能会在几分钟内完成。</p><blockquote class="ms mt mu"><p id="422a" class="lj lk mv ll b lm mw kd lo lp mx kg lr my mz lu lv na nb ly lz nc nd mc md me im bi translated"><em class="it">一个 JQL 查询返回 1334 个问题，每个请求 50 个问题(27 个请求)，耗时</em> <strong class="ll jd"> <em class="it"> 31 秒。</em> </strong> <em class="it">使用并发通过</em> <strong class="ll jd"> <em class="it">改变 7 行代码</em> </strong> <em class="it">，我们可以将此减少到</em> <strong class="ll jd"> <em class="it"> 2.5 秒。</em> </strong></p></blockquote><p id="1350" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls mz lu lv lw nb ly lz ma nd mc md me im bi translated"><strong class="ll jd">为什么？</strong></p><p id="3d2c" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls mz lu lv lw nb ly lz ma nd mc md me im bi translated">使用 Jupyter 内置的<code class="fe ne nf ng nh b">%time</code>魔法的一个快速简介显示了为什么有这么大的改进空间。</p><pre class="mg mh mi mj gt ni nh nj nk aw nl bi"><span id="1010" class="nm ks it nh b gy nn no l np nq">CPU times: user 672 ms, sys: 125 ms, <strong class="nh jd">total: 797 ms</strong><br/>Wall time: <strong class="nh jd">31.4 s</strong></span></pre><p id="d7d5" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls mz lu lv lw nb ly lz ma nd mc md me im bi translated">在 31.4 秒的运行时间中，顺序执行请求只占用了 797 毫秒的 CPU 时间。所以在这 31 秒中，<em class="mv">比</em><strong class="ll jd"><em class="mv"/></strong><em class="mv">多 97%的时间都花在了</em> <strong class="ll jd"> <em class="mv">等待</em> </strong> <em class="mv">的网络呼叫上。</em></p><h1 id="bf37" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated"><strong class="ak">提高性能</strong></h1><p id="40b4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">本质上有两类性能问题:</p><ol class=""><li id="9f57" class="nr ns it ll b lm mw lp mx ls nt lw nu ma nv me nw nx ny nz bi translated">我一直在等待网络/磁盘/数据库/其他进程做一些事情，同时也想用 CPU 做一些有用的事情。<strong class="ll jd"> Python 解决方案:线程化还是异步化。</strong></li><li id="8f8a" class="nr ns it ll b lm oa lp ob ls oc lw od ma oe me nw nx ny nz bi translated">我正在做一些计算量很大的事情，希望尽可能使用所有的 CPU / GPU 时间。<strong class="ll jd"> Python 解决方案:多重处理或降至 c 语言</strong></li></ol><p id="a0f6" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls mz lu lv lw nb ly lz ma nd mc md me im bi translated">如上面的<code class="fe ne nf ng nh b">%time</code>示例所示，API 调用牢牢地属于第一类。这是需要记住的重要一点:</p><blockquote class="ms mt mu"><p id="5159" class="lj lk mv ll b lm mw kd lo lp mx kg lr my mz lu lv na nb ly lz nc nd mc md me im bi translated"><em class="it">我们</em> <strong class="ll jd"> <em class="it">难道</em> </strong> <em class="it">想方设法让</em> <strong class="ll jd"> <em class="it">各自的要求走得更快。</em> </strong></p><p id="159f" class="lj lk mv ll b lm mw kd lo lp mx kg lr my mz lu lv na nb ly lz nc nd mc md me im bi translated"><strong class="ll jd"> <em class="it">改为</em> </strong> <em class="it">我们试图将</em> <strong class="ll jd"> <em class="it">【等待并行】</em> </strong> <em class="it">所以</em> <strong class="ll jd"> <em class="it">整套要求</em> </strong> <em class="it">完成得更快。</em></p></blockquote><p id="94bf" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls mz lu lv lw nb ly lz ma nd mc md me im bi translated">由于我们的 CPU 做的工作很少，为了让单个请求运行得更快，我们需要查看网络层并升级连接。相反，我们可以通过分批启动请求并组合结果来加快整个请求集的速度。</p><h1 id="0419" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">方法</h1><p id="7c5a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在本系列中，我们将从最慢的情况开始，即顺序请求，然后尝试三种加快速度的方法:</p><ol class=""><li id="5e24" class="nr ns it ll b lm mw lp mx ls nt lw nu ma nv me nw nx ny nz bi translated"><strong class="ll jd">序贯，</strong>我们的基础案例参考点。</li><li id="30f9" class="nr ns it ll b lm oa lp ob ls oc lw od ma oe me nw nx ny nz bi translated"><strong class="ll jd">多重处理，</strong>与<code class="fe ne nf ng nh b"><strong class="ll jd">multiprocessing.Pool()</strong></code>多重处理并不完全适合这个问题，但仍然提供了很大的改进，这是一个有趣的比较。</li><li id="b9ed" class="nr ns it ll b lm oa lp ob ls oc lw od ma oe me nw nx ny nz bi translated"><strong class="ll jd">穿线，</strong>同<code class="fe ne nf ng nh b"><strong class="ll jd">concurrent.futures.ThreadPoolExecutor()</strong></code> <strong class="ll jd"> </strong>。</li><li id="726b" class="nr ns it ll b lm oa lp ob ls oc lw od ma oe me nw nx ny nz bi translated"><strong class="ll jd">异步，</strong>与<code class="fe ne nf ng nh b"><strong class="ll jd">asyncio.gather()</strong></code> <strong class="ll jd"> </strong>使用<code class="fe ne nf ng nh b">async</code>和<code class="fe ne nf ng nh b">await</code>以及<code class="fe ne nf ng nh b">httpx</code>模块来支持异步 HTTP 请求。</li></ol><blockquote class="ms mt mu"><p id="8fa5" class="lj lk mv ll b lm mw kd lo lp mx kg lr my mz lu lv na nb ly lz nc nd mc md me im bi translated">注意:本系列中的计时代表了测试设置中每种方法的平均值，而不是严格意义上的基准。我们对绝对性能的技术之间的比较更感兴趣</p></blockquote><p id="1df5" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls mz lu lv lw nb ly lz ma nd mc md me im bi translated">我们使用吉拉 API 作为示例，但是这些解决方案可以很容易地扩展到其他用例，其中您的应用程序花费大量时间等待其他计算机/网络/磁盘/进程做一些工作并返回结果。</p><p id="aef2" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls mz lu lv lw nb ly lz ma nd mc md me im bi translated">在这个系列中，我们将讨论两个函数。</p><ol class=""><li id="e7bb" class="nr ns it ll b lm mw lp mx ls nt lw nu ma nv me nw nx ny nz bi translated"><code class="fe ne nf ng nh b"><strong class="ll jd">jira_query()</strong></code> <strong class="ll jd"> </strong>接受一个吉拉 URL，JQL 查询字符串，一个指示要检索结果的“页面”的整数。</li><li id="586e" class="nr ns it ll b lm oa lp ob ls oc lw od ma oe me nw nx ny nz bi translated">一个函数，给定一个 JQL 查询，计算出检索所有结果需要多少个请求，并使用<code class="fe ne nf ng nh b"><strong class="ll jd">jira_query()</strong></code> <strong class="ll jd"> </strong>将所有结果以及相关的计时数据收集到一个列表中。在这里，我们将试验不同的并发方法(在每一节中显示)。</li></ol><h2 id="0556" class="nm ks it bd kt of og dn kx oh oi dp lb ls oj ok ld lw ol om lf ma on oo lh iz bi translated"><code class="fe ne nf ng nh b">jira_query()</code></h2><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="op oq l"/></div><p class="or os gj gh gi ot ou bd b be z dk translated">函数在给定起始页(查询号)、URL、JQL 查询字符串和要检索的结果数的情况下，检索吉拉问题列表。</p></figure><blockquote class="ms mt mu"><p id="5fee" class="lj lk mv ll b lm mw kd lo lp mx kg lr my mz lu lv na nb ly lz nc nd mc md me im bi translated"><strong class="ll jd"> <em class="it">侧边栏:用 perf _ counter _ ns()<br/></em></strong><em class="it">函数计时在整个系列中，我们将使用</em> <code class="fe ne nf ng nh b"><em class="it">time.perf_counter_ns()</em></code> <em class="it">函数来记录开始和结束时间。这将从系统相关的参考时间返回以纳秒为单位的当前时间。来自文档:</em></p><p id="0a7a" class="lj lk mv ll b lm mw kd lo lp mx kg lr my mz lu lv na nb ly lz nc nd mc md me im bi translated">返回值的参考点是未定义的，因此只有连续调用的结果之差才是有效的。</p><p id="329b" class="lj lk mv ll b lm mw kd lo lp mx kg lr my mz lu lv na nb ly lz nc nd mc md me im bi translated"><em class="it">因此，我们不能跨系统比较时间，或者系统重启，但是即使请求发生在不同的进程/线程上，我们</em> <strong class="ll jd"> <em class="it">也可以</em> </strong> <em class="it">比较相对的开始和结束时间，精确度很高。这有助于可视化不同并发模块中发生的事情。</em></p></blockquote><h1 id="82aa" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">顺序请求</h1><p id="a366" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">下面的函数使用<code class="fe ne nf ng nh b">jira_query()</code>建立一个结果列表，给出一个吉拉 URL、JQL 查询(例如<code class="fe ne nf ng nh b">Project = CAE ORDER BY key Asc</code>)和每个请求返回的结果数。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="op oq l"/></div><p class="or os gj gh gi ot ou bd b be z dk translated">按顺序从 JQL 查询结果集中检索所有问题。</p></figure><p id="1981" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls mz lu lv lw nb ly lz ma nd mc md me im bi translated">调用这个函数会返回一个由<code class="fe ne nf ng nh b">jira_query()</code>返回的字典列表。通常我们会对实际产生的问题感兴趣，但这里我们更感兴趣的是关于检索了多少个问题以及花费了多长时间的元数据，因此实际的问题列表嵌套在<code class="fe ne nf ng nh b">issue_list</code>键中。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="op oq l"/></div><p class="or os gj gh gi ot ou bd b be z dk translated">调用顺序版本，将结果加载到数据帧中进行显示和绘图。</p></figure><p id="9409" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls mz lu lv lw nb ly lz ma nd mc md me im bi translated">产生的数据帧显示了相对于<code class="fe ne nf ng nh b"><strong class="ll jd">t_0</strong></code> <strong class="ll jd"> </strong>(第一个请求开始的时间)的开始和结束时间。如您所见，我们最终收到 27 个请求，检索 1334 个问题，一次最多 50 个。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ov"><img src="../Images/c6d8c2d2165a977aab593c9326afa76e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qrxjjnKPmze4EfWsj-GxUQ.png"/></div></div></figure><p id="94b0" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls mz lu lv lw nb ly lz ma nd mc md me im bi translated">绘制结果真正说明了顺序行为。请记住，在每个蓝条期间，CPU 仅在大约 2–3%的时间内工作。剩下的时间用来等待网络请求返回。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ow"><img src="../Images/3199a8065f085612c43b89cb03bfa9a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1YcEcnXe1ceNsaTNTQWGzQ.png"/></div></div><p class="or os gj gh gi ot ou bd b be z dk translated">检索 1334 个问题，每批 50 个，有连续请求。总时间为 31.4 秒，平均请求时间为 1.16 秒。</p></figure><p id="54c5" class="pw-post-body-paragraph lj lk it ll b lm mw kd lo lp mx kg lr ls mz lu lv lw nb ly lz ma nd mc md me im bi translated">在下一节中，我们保持<code class="fe ne nf ng nh b">jira_query()</code>不变，但是使用<code class="fe ne nf ng nh b">multiprocessing.Pool()</code>来调整协调功能，这样可以大大加快速度。</p><h1 id="a465" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">系列地图</h1><ul class=""><li id="103c" class="nr ns it ll b lm ln lp lq ls ox lw oy ma oz me pa nx ny nz bi translated"><a class="ae mr" href="https://medium.com/@dmort.ca/part-1-defining-and-timing-an-api-function-with-python-b0849775e961" rel="noopener"> <strong class="ll jd"> <em class="mv">第 1 部分:在 Python 中定义和定时一个 API 函数(你在这里)</em> </strong> </a></li><li id="cbc8" class="nr ns it ll b lm oa lp ob ls oc lw od ma oe me pa nx ny nz bi translated"><a class="ae mr" href="https://medium.com/@dmort.ca/part-2-multiprocessing-api-requests-with-python-19e593bd7904" rel="noopener">第 2 部分:用 Python 多重处理 API 请求</a></li><li id="4d70" class="nr ns it ll b lm oa lp ob ls oc lw od ma oe me pa nx ny nz bi translated"><a class="ae mr" href="https://medium.com/@dmort.ca/part-3-threading-api-requests-with-python-10b2117cd805" rel="noopener">第 3 部分:用 Python 线程化 API 请求</a></li><li id="7685" class="nr ns it ll b lm oa lp ob ls oc lw od ma oe me pa nx ny nz bi translated"><a class="ae mr" href="https://medium.com/@dmort.ca/part-4-async-api-requests-with-python-and-httpx-9dcd630bc9b5" rel="noopener">第 4 部分:使用 Python 和 httpx 的异步 API 请求</a></li><li id="43e5" class="nr ns it ll b lm oa lp ob ls oc lw od ma oe me pa nx ny nz bi translated"><a class="ae mr" href="https://medium.com/@dmort.ca/part-5-api-request-timing-comparison-sequential-multiprocessing-threading-and-async-c4f699552ab3" rel="noopener">第 5 部分:API 请求时序比较——顺序、多处理、线程和异步</a></li></ul></div></div>    
</body>
</html>