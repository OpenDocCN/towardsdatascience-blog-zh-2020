<html>
<head>
<title>Surviving zombie apocalypse with random search algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用随机搜索算法幸存僵尸启示录</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/surviving-zombie-apocalypse-with-random-search-algorithm-b50c584e8066?source=collection_archive---------40-----------------------#2020-02-03">https://towardsdatascience.com/surviving-zombie-apocalypse-with-random-search-algorithm-b50c584e8066?source=collection_archive---------40-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/52423b3b2397a94b8d3b85de546b0e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ktnjeJksN_2uOCWm16Ig-Q.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">2019年波兰北部的日落。私图。</p></figure><h1 id="dd6a" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">介绍</h1><p id="b9c7" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">想象一个典型的好莱坞僵尸启示录场景…</p><p id="4817" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">一群绝望的人，在一个魅力四射的英雄的带领下，在某个建筑里设置路障，试图坚持到电影结束。大量的嗜血生物敲着每一扇门和每一扇窗户想要进去。人们试图用他们能使用的任何东西来击退他们，但是由于他们的弹药越来越少，英雄需要派人去取更多的炮弹。</p><p id="7e43" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">必须做出决定——权衡失去一名队员的风险和弹药耗尽的风险。听起来不像是一个<strong class="lf iu">优化问题吗？</strong></p><p id="9cf7" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">虽然它肯定可以用这种方式来表达，但我们会看到，并不总是可以应用<em class="mg">标准梯度下降算法</em> (SGD)。相反，我们将使用一种简单的替代方法，称为<strong class="lf iu">随机搜索</strong>。为了说明它的简单性，我们将用纯python实现它(参见:<a class="ae mh" href="https://gist.github.com/OlegZero13/3eae5d02cd8d2c931e0aa1877d219b9f" rel="noopener ugc nofollow" target="_blank">代码</a>)。</p><h2 id="f631" class="mi kg it bd kh mj mk dn kl ml mm dp kp lo mn mo kt ls mp mq kx lw mr ms lb mt bi translated">我们的生存场景</h2><p id="cebe" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">为了便于讨论，让我们假设我们的魅力英雄有一台装有文本编辑器(例如vim，如果他是一个真正的英雄)和python3的笔记本电脑——足以快速运行模拟并找出该做什么。</p><p id="c477" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">情况呈现如下:</p><ul class=""><li id="370b" class="mu mv it lf b lg mb lk mc lo mw ls mx lw my ma mz na nb nc bi translated">有危险的日子，在这期间他们必须挺过去。</li><li id="2ee6" class="mu mv it lf b lg nd lk ne lo nf ls ng lw nh ma mz na nb nc bi translated">第<strong class="lf iu"><em class="mg">(N+1)</em></strong>天一到，军方就会来营救幸存者。</li><li id="1825" class="mu mv it lf b lg nd lk ne lo nf ls ng lw nh ma mz na nb nc bi translated">在那之前，团队每天消耗<strong class="lf iu"> <em class="mg">一</em> </strong>箱弹药，完全耗尽等于不可避免的死亡。</li><li id="6e1b" class="mu mv it lf b lg nd lk ne lo nf ls ng lw nh ma mz na nb nc bi translated">此外，弹药每天都在失去抗僵尸的能力，使得它在<strong class="lf iu"> <em class="mg"> E </em> </strong>天后无法使用。</li><li id="ded8" class="mu mv it lf b lg nd lk ne lo nf ls ng lw nh ma mz na nb nc bi translated">小组从<strong class="lf iu"> <em class="mg"> X </em> </strong>箱弹药开始。</li><li id="f3f4" class="mu mv it lf b lg nd lk ne lo nf ls ng lw nh ma mz na nb nc bi translated">在指定的日子里<strong class="lf iu"> <em class="mg"> D = {d_1，d_2，…，d_K} </em> </strong>，空军会投放额外的装有弹药箱的吊舱来支援正在挣扎的士兵，这些日子提前就知道了。</li><li id="94cd" class="mu mv it lf b lg nd lk ne lo nf ls ng lw nh ma mz na nb nc bi translated">不幸的是，从分离舱中回收箱子是有风险的。在[0，1]  中表示为<strong class="lf iu"> <em class="mg"> p，代表失去一个组成员的概率。</em></strong></li><li id="bb4b" class="mu mv it lf b lg nd lk ne lo nf ls ng lw nh ma mz na nb nc bi translated">此外，每从一个箱子中取出一个箱子，风险就会随着箱子数量的增加而增加<em class="mg">。</em></li><li id="0c9b" class="mu mv it lf b lg nd lk ne lo nf ls ng lw nh ma mz na nb nc bi translated">最后，没有必要在“零日”之后积累任何弹药，因为军方会迅速将其全部带走。</li><li id="31f5" class="mu mv it lf b lg nd lk ne lo nf ls ng lw nh ma mz na nb nc bi translated">现在的挑战是确保团队永远不会耗尽弹药，同时尽量减少潜在的人类牺牲。</li></ul><h1 id="5aa0" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">建立模型</h1><p id="aa16" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">情况看起来相当复杂，所以我们的第一步是建立一个模型。我们将使用它来模拟不同的场景，这将有助于我们找到答案。这一步在某种程度上相当于SGD中的正向传递。</p><p id="e2da" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">我们知道系统完全是用<strong class="lf iu"> <em class="mg"> N，E，X </em> </strong>和成对的<strong class="lf iu"> <em class="mg"> (d_k，p_k) </em> </strong>来描述的。因此，将我们的模型实现为一个类并公开方法<code class="fe ni nj nk nl b">run</code>来执行我们的正向传递是很方便的。</p><p id="e742" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">让我们从构造函数开始。</p><pre class="nm nn no np gt nq nl nr ns aw nt bi"><span id="f11a" class="mi kg it nl b gy nu nv l nw nx">E = 30 # expiry of anti-zombie serum<br/>X = 10 # initial ammo supply<br/><br/>class Survival:<br/>    def __init__(self, total_days, pods, supplies_init=[E]*X):<br/>        self.total_days = total_days<br/>        self.pods = pods<br/>        self.supplies = supplies_init</span></pre><p id="5174" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated"><code class="fe ni nj nk nl b">pods</code>是一个元组列表，代表具有相关回收风险的输入弹药舱(例如<code class="fe ni nj nk nl b">[(10, 0.1), (20, 0.2)]</code>)。由于供应品耗尽，我们将其表示为“剩余天数”列表。一旦列表变空——就完了！</p><p id="818c" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">接下来，考虑到供应减少，我们定义以下受保护的方法:</p><pre class="nm nn no np gt nq nl nr ns aw nt bi"><span id="8bd1" class="mi kg it nl b gy nu nv l nw nx">def _consume(self):<br/>        self.supplies.remove(min(self.supplies))<br/>        self.supplies = list(map(lambda x: x - 1, self.supplies))<br/>        self.supplies = list(filter(lambda x: x != 0,     self.supplies))</span></pre><p id="94cb" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">每天消耗一箱弹药(第3行)，然后所有的补给离到期日又近了一天(第4行)，最后，过期的从列表中移除(第5行)。</p><p id="8575" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">另一件事发生在新的补给被收回的时候。</p><pre class="nm nn no np gt nq nl nr ns aw nt bi"><span id="a694" class="mi kg it nl b gy nu nv l nw nx">def _retrieve(self, risk, quantity):<br/>        new_ammo = [E] * quantity<br/>        cost = quantity**2 * risk<br/>        return new_ammo, cost</span></pre><p id="a39c" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在每一种情况下，当我们产生更多的弹药，我们也增加了分数风险，这与我们选择从吊舱中取回多少箱子成正比。(如果成本&gt; 1，我们可以将is视为损失一个以上人员的概率)。</p><p id="18c9" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">为了便于向前传递，让我们再定义一个函数:</p><pre class="nm nn no np gt nq nl nr ns aw nt bi"><span id="4ddc" class="mi kg it nl b gy nu nv l nw nx">def _get_risk(self, day):<br/>        pod = list(filter(lambda x: x[0] == day, self.pods))<br/>        if len(pod) &gt; 0:<br/>            return pod[0][1]<br/>        return None</span></pre><p id="a66b" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">该函数只是选择与为给定日期安排的pod相关联的风险(如果已安排)。</p><p id="0427" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">最后，向前传球的本质:</p><pre class="nm nn no np gt nq nl nr ns aw nt bi"><span id="f7bb" class="mi kg it nl b gy nu nv l nw nx">def run(self, retrieval_plan):<br/>        total_risk = 0<br/>        retrieval_idx = 0<br/>        for day in range(1, self.total_days + 1):<br/>            risk_involved = self._get_risk(day)<br/>            if risk_involved:<br/>                new_ammo, partial_risk = self._retrieve(<br/>                    risk_involved,<br/>                    retrieval_plan[retrieval_idx])<br/><br/>                self.supplies += new_ammo<br/>                total_risk += partial_risk<br/>                retrieval_idx += 1<br/>            if len(self.supplies) == 0:<br/>                return 0, total_risk, day<br/>            else:<br/>                self._consume()<br/>        return len(self.supplies), total_risk, day</span></pre><p id="9768" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">该过程从一些<code class="fe ni nj nk nl b">retrieval_plan</code>(稍后将详细介绍)开始，总风险为零。然后，随着我们一天一天的移动，将会有“机会”获得弹药。如果在某一天有这样的机会，我们会根据回收计划尝试回收一定数量的弹药。每当涉及到风险点时，我们都会将它们添加到总体风险计数中。</p><p id="596e" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">然后，不管我们是否有更多的弹药，我们检查我们的供应状况。如果我们到达终点，今晚将是这个团队的最后一晚。该函数返回0弹药剩余，总牺牲和纪念日。如果没有，这个团队会在英勇保卫他们的要塞时消耗弹药，这个函数会返回相应的值。</p><p id="70ff" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这就是我们向前传球所需要的。现在，让我们看看优化。</p><h1 id="ea30" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">解决办法</h1><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/169e8d7a344b64e92d012c1e33a8c4f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qxwkq5iQOmPXOFOsmX82WA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图一。两个pod的成本函数与参数空间(z)的关系示例。较低楼层区域与违反约束相关联。</p></figure><p id="45b8" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在涉及标准梯度下降的典型情况下，我们现在将设计反向传播通道，并讨论如何正确实施梯度。然而，这里没有梯度！描述风险累积的函数更像是一个过程。它是不可微的。(也没有僵尸参与……)</p><p id="8441" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">正因为如此，也因为我们之前提到的诸多限制，我们需要想出另一种方法来降低风险。这就是随机搜索算法的由来。</p><p id="7589" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">基本原则如下:</p><ol class=""><li id="9f66" class="mu mv it lf b lg mb lk mc lo mw ls mx lw my ma nz na nb nc bi translated">我们定义了一个成本函数，这是一种衡量解决方案有多“差”的方法。(在我们的示例中，它是团队成员流失的总风险)。</li><li id="b95e" class="mu mv it lf b lg nd lk ne lo nf ls ng lw nh ma nz na nb nc bi translated">我们在搜索空间中随机初始化系统(<strong class="lf iu"> <em class="mg"> z </em> </strong>)。</li><li id="db5c" class="mu mv it lf b lg nd lk ne lo nf ls ng lw nh ma nz na nb nc bi translated">我们从(<strong class="lf iu"> <em class="mg"> z </em> </strong>)的邻域内对我们的搜索空间中的新位置(<strong class="lf iu"><em class="mg">z’</em></strong>)进行采样。</li><li id="cd92" class="mu mv it lf b lg nd lk ne lo nf ls ng lw nh ma nz na nb nc bi translated">我们评估成本，如果更低，我们移动到那个点(<strong class="lf iu"><em class="mg">z’-&gt;z</em></strong>)。</li></ol><p id="f4a7" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">我们重复3遍。第四。只要需要改进，我们就可以应用硬停，例如，如果成本不再下降，时间用完，等等。</p><p id="2ccf" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">当然，这种方法并不能保证我们找到最好的解决方案，但是SGD也不能做到这一点。然而，凭直觉，我们可以认为，如果我们继续质疑“现状”并做出小的改进，我们应该会找到一个可能更好的解决方案。</p><p id="3dcb" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">我们来看一下实现。首先，初始化:</p><pre class="nm nn no np gt nq nl nr ns aw nt bi"><span id="f28a" class="mi kg it nl b gy nu nv l nw nx">def initialize_retrieval_plan(pods, total_days):<br/>    a = list(map(lambda x: x[0], pods))<br/>    a.append(total_days)<br/>    return [a[x + 1] - a[x] for x in range(len(a) - 1)]</span></pre><p id="a6eb" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">该函数接受pod的时间表(列表<strong class="lf iu"><em class="mg">【d _ k，p_k} </em> </strong>)和生存天数，并返回一个可能的计划，该计划描述了团队在每个机会可以取回多少弹药——这是一个整数列表。</p><p id="9dce" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">也许你已经注意到这里没有涉及到随机数。没错，我们不会随机初始化它。在没有从哪里开始的偏好的情况下，随机初始化工作得很好。由于我们的僵尸危机充满了约束，我们可以从至少一个约束可以很容易满足的位置开始。因此，我们从一个保证生存的计划开始，给人们足够的子弹来完成它。</p><p id="5c50" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">从此，我们可以优化。</p><pre class="nm nn no np gt nq nl nr ns aw nt bi"><span id="75cf" class="mi kg it nl b gy nu nv l nw nx">def calculate_plan(total_days, pods, <br/>    epochs=300, <br/>    supplies=[E]*X,<br/>    attempts=12, <br/>    radius=4):<br/>  ...</span></pre><p id="368d" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">函数<code class="fe ni nj nk nl b">calculate_plan</code>是反向传播步骤的替代方法。我们可以将<code class="fe ni nj nk nl b">epochs</code>、<code class="fe ni nj nk nl b">attempts</code>和<code class="fe ni nj nk nl b">radius</code>视为超参数，其中<code class="fe ni nj nk nl b">epochs</code>是搜索步骤的数量，<code class="fe ni nj nk nl b">attempts</code>是我们在每个步骤下采样的点的数量，<code class="fe ni nj nk nl b">radius</code>表示(<strong class="lf iu"> <em class="mg"> z </em> </strong>)的邻域的“伸展”。</p><p id="a362" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">因为理论上计算需要一些时间，我们要做的第一件事是检查条件是否不合适，或者计划是否不会让他们死。例如，如果第一个豆荚的日期是在团队耗尽补给之后，就没有机会再补给，死亡是不可避免的。在这种情况下，我们可以停止计算，开始祈祷。</p><pre class="nm nn no np gt nq nl nr ns aw nt bi"><span id="66e8" class="mi kg it nl b gy nu nv l nw nx">plan = initialize_retrieval_plan(pods, total_days) <br/>    if is_illegal(plan):<br/>        print("This retrieval plan cannot make them survive.")<br/>        return<br/>    S = Survival(total_days, pods, supplies.copy())<br/>    supplies_size, cost, day = S.run(plan)<br/>    if day &lt; total_days:<br/>        return</span></pre><p id="3908" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated"><code class="fe ni nj nk nl b">is_illegal</code>函数是一个简单的检查，如果计划中没有元素是负的(<code class="fe ni nj nk nl b">def is_illegal(plan): return (True in [c &lt; 0 for c in plan])</code>)。</p><p id="0a4f" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">检查了可行性之后，我们终于可以开始为最小风险进行优化了。我们的参数空间的维数等于吊舱的数量(等于<code class="fe ni nj nk nl b">plan</code>的长度)。该空间的采样意味着随机选取<code class="fe ni nj nk nl b">plan</code>的一个元素，看看如果我们从pod中移除一些箱子会发生什么。然而，为了防止违反团队不得耗尽弹药的条件，我们也选择了<code class="fe ni nj nk nl b">plan</code>的另一个元素来给这个数量。这创建了一个新的计划，我们使用<code class="fe ni nj nk nl b">S.run(plan)</code>验证该计划以获得新的结果。</p><pre class="nm nn no np gt nq nl nr ns aw nt bi"><span id="cc98" class="mi kg it nl b gy nu nv l nw nx">plan_range = range(len(plan))<br/>    cost_history = [9999999] # initializing cost history for early stopping<br/>    last_plan = plan.copy()<br/>    epoch = 1<br/>    while epoch &lt; epochs:<br/>        cache = {}<br/>        for attempt in range(attempts):<br/>            i1 = random.choice(plan_range)<br/>            i2 = random.choice(plan_range)<br/>                <br/>            plan = last_plan.copy()<br/>            qty = random.choice(range(1, radius + 1))<br/>            plan[i1] -= qty<br/>            plan[i2] += qty<br/><br/>            S = Survival(total_days, pods, supplies.copy())<br/>            supplies_size, cost, day = S.run(plan)</span></pre><p id="e48e" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">然后一系列的<code class="fe ni nj nk nl b">if-else</code>语句检查剩余的约束，但是如果新的计划是可行的，我们将它添加到<code class="fe ni nj nk nl b">cache</code>中，该计划包含具有相关成本函数的步骤的所有备选计划。然后，如果存在成本函数更低的替代方案，我们选择该方案用于下一次迭代(<strong class="lf iu"><em class="mg">z’-&gt;z</em></strong>)。</p><pre class="nm nn no np gt nq nl nr ns aw nt bi"><span id="77a0" class="mi kg it nl b gy nu nv l nw nx">            if supplies_size &lt; 0: # ran out of ammo<br/>                continue<br/>            elif day &lt; total_days: # ran out of days<br/>                continue<br/>            elif is_illegal(plan): # attempt to sell ammo<br/>                continue<br/>            else:                  # solution found<br/>                key = '-'.join([str(x) for x in plan]) <br/>                cache[key] = cost<br/><br/>        last_plan, cost = get_minimum(cache)<br/>        print (f"{epoch}, cost: {cost}, plan: {last_plan}")<br/>        epoch += 1<br/>        cost_history.append(cost)<br/>        if cost_history[epoch - 1] == cost_history[epoch - 2]:<br/>            break</span></pre><p id="ea74" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在某一点上，对某一步骤将没有进一步的计划。当这种情况发生时，我们依靠最后一个可行的计划作为解决方案。</p><pre class="nm nn no np gt nq nl nr ns aw nt bi"><span id="1e35" class="mi kg it nl b gy nu nv l nw nx">    if len(cache) == 0:<br/>        print ("No solution for this case. They must die.")<br/>        return<br/>    else:<br/>        print (f"Solution found, but it'll cost = {cost}.")<br/>        return last_plan</span></pre><p id="25ea" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated"><code class="fe ni nj nk nl b">get_minumum</code>功能是我们定制的<code class="fe ni nj nk nl b">arg min</code>版本:</p><pre class="nm nn no np gt nq nl nr ns aw nt bi"><span id="8371" class="mi kg it nl b gy nu nv l nw nx">def get_minimum(cache):<br/>    min_risk = min(cache.values())<br/>    key = list(cache.keys())[list(cache.values()).index(min_risk)]<br/>    return [int(x) for x in key.split('-')], min_risk</span></pre><p id="856a" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">潜在的问题和替代方案就是这样！例如，跑步:</p><pre class="nm nn no np gt nq nl nr ns aw nt bi"><span id="0794" class="mi kg it nl b gy nu nv l nw nx">if  __name__ == '__main__':<br/>    pods = [(10, 0.2), (15, 0.1), (35, 0.5), (50, 0.3)]<br/>    total_days = 70<br/>    <br/>    plan = calculate_plan(total_days, pods)<br/>    print(plan)</span></pre><p id="caa6" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">我们可以看到在寻找更好的计划和成本价值下降的进展。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/e8e39a181d385058a27df93428e7f7db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hEaXtytt8T2EjrJUSOfSQA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图二。N = 100和10个pod的随机搜索算法的最小成本(左)和最小时间(右)，对“尝试”和“半径”的每个组合检查10次。获得了成本函数与回收箱子数量的线性相关性的结果。</p></figure><p id="a3eb" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">不幸的是，如果我们多次执行这种优化，我们将很快发现最“最优”的计划会发生变化，并且成本值有时会高于其他计划。这是因为我们的算法是“盲的”。如果没有梯度，我们在每次迭代中只给它几次机会(<code class="fe ni nj nk nl b">attempts</code>)来寻找更好的计划，而且我们是随机进行的。因此，算法到达一个地方<strong class="lf iu"> <em class="mg"> (z`) </em> </strong>就有一个很大的威胁，它不能再前进了——类似于局部最小值。</p><p id="3292" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">为了克服这个问题，我们可以自然地增加<code class="fe ni nj nk nl b">attempts</code>的数量以给它更多的机会，或者增加<code class="fe ni nj nk nl b">radius</code>以允许更多的选择来找到更好的<strong class="lf iu"><em class="mg"/></strong>。</p><p id="ed2d" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在极端情况下，我们可以选择循环遍历距离为<code class="fe ni nj nk nl b">radius</code>的所有<strong class="lf iu"> <em class="mg"> (z，z’)</em></strong>对。这种方法相当于强制梯度，大大增加了我们达到全局最小值的机会。另一方面，这是要付出代价的。仅用<code class="fe ni nj nk nl b">radius == 1</code>，组合数<strong class="lf iu"> <em class="mg"> (z，z’)</em></strong>与<code class="fe ni nj nk nl b">K ** 2</code>成正比，其中<code class="fe ni nj nk nl b">K = len(plan)</code>。计算可能需要更长时间。</p><h1 id="8e33" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">结论</h1><p id="3126" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">防御不死族的囤积的确是一个巨大的挑战。除了僵尸之外，在本文中，我们给出了一个简单的随机搜索算法的裸python实现。每当我们可以定义一个代价函数，但是我们不能保证它的可微性时，这个算法可以是SGD的一个可行的替代方案。此外，如果问题充满了约束，像这样，这里提出的方法可以应用。最后，我们还讨论了算法本身的计算复杂性，如果确实存在重大僵尸危机，这可能会影响下一个英雄的决策。</p><h1 id="48e0" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">还会有更多…</h1><p id="f1b4" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我计划把文章带到下一个层次，并提供简短的视频教程。</p><p id="b613" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">如果您想了解关于视频和未来文章的更新，请订阅我的 <a class="ae mh" href="https://landing.mailerlite.com/webforms/landing/j5y2q1" rel="noopener ugc nofollow" target="_blank"> <strong class="lf iu">简讯</strong> </a> <strong class="lf iu">。你也可以通过填写<a class="ae mh" href="https://forms.gle/bNpf9aqZJGLgaU589" rel="noopener ugc nofollow" target="_blank">表格</a>让我知道你的期望。回头见！</strong></p></div></div>    
</body>
</html>