<html>
<head>
<title>Pandas: Combining Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫:组合数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-combining-data-b190d793b626?source=collection_archive---------76-----------------------#2020-07-13">https://towardsdatascience.com/pandas-combining-data-b190d793b626?source=collection_archive---------76-----------------------#2020-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="367a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/pytrix-series" rel="noopener" target="_blank"> PyTrix 系列</a></h2><div class=""/><div class=""><h2 id="394f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">PyTrix #5:对熊猫进行更多的数据操作</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e9d06df5319845f14857fbb43f02b63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F_ins9ztKrmJ2mgH"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">美国宇航局在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="85c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Pandas 框架配备了<code class="fe me mf mg mh b">Series</code>和<code class="fe me mf mg mh b">DataFrame</code>对象，它们是数据探索和分析的强大工具。这些对象拥有的部分能力可以归因于它们采用多方面的方法来组合单独的数据集。Pandas 提供的功能允许你<strong class="lk jd">合并</strong>、<strong class="lk jd">连接</strong>、<strong class="lk jd">连接</strong>和<strong class="lk jd">追加</strong>数据。<strong class="lk jd"> </strong>然而<strong class="lk jd">，</strong>在我看来我发现只需要学习 2 个就是<strong class="lk jd">合并</strong>和<strong class="lk jd">串联</strong>这里是为什么:</p><p id="d8b5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">df.append()</code>:将 other 的行追加到调用者的末尾，返回一个新的对象。</p><p id="7e43" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">pd.concat()</code>:沿特定轴连接熊猫对象，沿其他轴连接可选的集合逻辑。</p><p id="0914" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">df.join()</code>:连接另一个数据框架的列。</p><p id="731b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">pd.merge()</code>:用数据库风格的连接合并数据帧或命名系列对象。</p><blockquote class="mi mj mk"><p id="9b8a" class="li lj ml lk b ll lm kd ln lo lp kg lq mm ls lt lu mn lw lx ly mo ma mb mc md im bi translated"><strong class="lk jd">注:所有描述均来自官方熊猫</strong> <a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/reference/frame.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">文档</strong> </a></p></blockquote><p id="fa6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">阅读组合数据的不同方法的细节，您可能会注意到<code class="fe me mf mg mh b">df.append()</code>和<code class="fe me mf mg mh b">pd.concat()</code>本质上具有非常相似的功能，但是<code class="fe me mf mg mh b">pd.concat()</code>更加灵活。同样，<code class="fe me mf mg mh b">df.join()</code>和<code class="fe me mf mg mh b">pd.merge()</code>具有相似的功能，但是<code class="fe me mf mg mh b">pd.merge()</code>比<code class="fe me mf mg mh b">df.join()</code>提供了更多的灵活性。出于这个原因，我认为更有必要对<code class="fe me mf mg mh b">pd.concat()</code>和<code class="fe me mf mg mh b">pd.merge()</code>都有很好的理解，并使用这些顶级函数来完成你在 pandas 中的所有组合——在我看来。</p><blockquote class="mp"><p id="9d77" class="mq mr it bd ms mt mu mv mw mx my md dk translated">“应该有一种——最好只有一种——显而易见的方法来做到这一点，”Python 的 Zen。</p></blockquote><p id="69df" class="pw-post-body-paragraph li lj it lk b ll mz kd ln lo na kg lq lr nb lt lu lv nc lx ly lz nd mb mc md im bi translated">对于这个故事，我将使用<code class="fe me mf mg mh b">pandas</code>和来自<code class="fe me mf mg mh b">seaborn</code>的提示数据集来演示每个功能。让我们载入数据…</p><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="e6b7" class="ni nj it mh b gy nk nl l nm nn"><strong class="mh jd">import</strong> <strong class="mh jd">pandas</strong> <strong class="mh jd">as</strong> <strong class="mh jd">pd</strong> <br/><strong class="mh jd">import</strong> <strong class="mh jd">seaborn</strong> <strong class="mh jd">as</strong> <strong class="mh jd">sns</strong></span><span id="f21c" class="ni nj it mh b gy no nl l nm nn"><em class="ml"># load tips data from seaborn </em><br/>data = sns.load_dataset("tips")<br/>print(data.shape)<br/>data.head()</span><span id="aeee" class="ni nj it mh b gy no nl l nm nn">&gt;&gt;&gt;&gt; (244, 7)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e79603015ab5696a92bfc64348681c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*wxqipKvcTwShRG5OSibRsA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 1:上面代码块中生成的代码的结果；来自 seaborn 的 Tips 数据集。</p></figure><p id="94df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可能会立即注意到只有一个数据集。为了组合数据，我们需要多个数据集，因此我将数据集分成两个数据帧——我们假设这两个数据集是分开的。</p><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="c52f" class="ni nj it mh b gy nk nl l nm nn"><em class="ml"># splitting the data into two seperate df </em><br/>bill = data.groupby(["sex", "smoker"])["total_bill", "tip"].sum()<br/>tip = bill.copy() <br/><em class="ml"># removing bill from tip and tip from bill </em><br/><strong class="mh jd">del</strong> tip["total_bill"]<br/><strong class="mh jd">del</strong> bill["tip"]</span><span id="fa76" class="ni nj it mh b gy no nl l nm nn"># <em class="ml">visualizing bill dataset</em><br/>bill.reset_index(inplace= <strong class="mh jd">True</strong>)<br/>print(bill.shape)<br/>bill.head()</span><span id="6f90" class="ni nj it mh b gy no nl l nm nn">&gt;&gt;&gt;&gt; (4, 3)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/edfff7f68b19c8bab8ab6bb66084eb5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*on9tKWQQxn79lzhv6vtzPg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 2:账单数据集</p></figure><p id="8704" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看 tip 数据框是什么样子的…</p><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="c8eb" class="ni nj it mh b gy nk nl l nm nn"># visualizing tip dataset<br/>tip.reset_index(inplace= <strong class="mh jd">True</strong>) <br/>print(tip.shape)<br/>tip.head()</span><span id="0124" class="ni nj it mh b gy no nl l nm nn">&gt;&gt;&gt;&gt; (4, 3)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/03882b5007dda36b858fccedd97f87ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*P9qRsmtsEBSJKvjceMekiA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 3: Tip 数据集</p></figure><p id="ac19" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本故事中使用的代码可以在以下位置找到:</p><div class="ns nt gp gr nu nv"><a href="https://github.com/kurtispykes/demo/blob/master/pytrix/pytrix_combing_data_in_pandas.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd jd gy z fp oa fr fs ob fu fw jc bi translated">kurtispykes/演示</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">permalink dissolve GitHub 是超过 5000 万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">github.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj lb nv"/></div></div></a></div></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="f40d" class="ni nj it bd or os ot dn ou ov ow dp ox lr oy oz pa lv pb pc pd lz pe pf pg iz bi translated">合并</h2><p id="8e26" class="pw-post-body-paragraph li lj it lk b ll ph kd ln lo pi kg lq lr pj lt lu lv pk lx ly lz pl mb mc md im bi translated">在展示<code class="fe me mf mg mh b">pd.merge()</code>的一些功能之前，让我们花点时间来理解我们可以连接数据的不同方式:</p><blockquote class="mi mj mk"><p id="8464" class="li lj ml lk b ll lm kd ln lo lp kg lq mm ls lt lu mn lw lx ly mo ma mb mc md im bi translated">注意:如果您熟悉 SQL，那么您可能会从<code class="fe me mf mg mh b">JOIN</code>语法中认出不同的操作名。</p></blockquote><ul class=""><li id="4424" class="pm pn it lk b ll lm lo lp lr po lv pp lz pq md pr ps pt pu bi translated"><strong class="lk jd">内部联接</strong> —选择在两个数据帧中具有匹配值的记录。</li></ul><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="ef83" class="ni nj it mh b gy nk nl l nm nn"><em class="ml"># Inner join </em><br/>inner_join = pd.merge(bill, tip, how="inner", on=["sex", "smoker"])<br/>print(inner_join.shape)<br/>inner_join.head()</span><span id="5906" class="ni nj it mh b gy no nl l nm nn">&gt;&gt;&gt;&gt; (4, 4)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/b676acf94257709e1809fc63774cfc77.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*Zgl9Gm-ZbkWD7r-qhzaSdw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 4:对我们的数据执行内部连接</p></figure><ul class=""><li id="0abb" class="pm pn it lk b ll lm lo lp lr po lv pp lz pq md pr ps pt pu bi translated"><strong class="lk jd">外部连接</strong> —外部连接将从左侧和右侧数据帧返回所有记录。如果数据帧列中没有匹配，不匹配的结果将用<code class="fe me mf mg mh b">nan</code>填充。</li></ul><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="0f79" class="ni nj it mh b gy nk nl l nm nn"><em class="ml"># Outer join </em><br/>outer_join = pd.merge(bill.tail(2), tip.head(2), how= "outer", on=["sex", "smoker"], indicator=<strong class="mh jd">True</strong>)<br/>print(outer_join.shape)<br/>outer_join.head()</span><span id="e09b" class="ni nj it mh b gy no nl l nm nn">&gt;&gt;&gt;&gt; (4, 5)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/7636c1c1056808c9250d1864ad4445f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*IBQlh_Qqsnc-eNrZ50uTMg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 5:数据帧上的外部连接；请注意，有一个额外的“_merge”列指示合并是如何完成的。这是因为在 pd.merge()中将 indicator 设置为 True。</p></figure><ul class=""><li id="fe28" class="pm pn it lk b ll lm lo lp lr po lv pp lz pq md pr ps pt pu bi translated"><strong class="lk jd">左连接</strong> —左连接将返回左表中的所有记录，以及右表中的匹配记录。对于只存在于左侧数据帧中的键，右侧数据帧中不匹配的值将用<code class="fe me mf mg mh b">nan</code>填充。</li></ul><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="2650" class="ni nj it mh b gy nk nl l nm nn"># left join<br/>left_join = pd.merge(bill, tip.head(2), how= "left", on=["sex", "smoker"], indicator=<strong class="mh jd">True</strong>)<br/>print(left_join.shape)<br/>left_join.head()</span><span id="e2a0" class="ni nj it mh b gy no nl l nm nn">&gt;&gt;&gt;&gt; (4, 5)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi px"><img src="../Images/eb54cbdb625dbe50756059a9c31b2cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*AqqDtv9keaMdkCQ0mI_sdA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 6:左连接数据帧</p></figure><ul class=""><li id="6842" class="pm pn it lk b ll lm lo lp lr po lv pp lz pq md pr ps pt pu bi translated"><strong class="lk jd">右连接</strong> —右连接将返回右数据帧中的所有记录，以及左数据帧中的匹配记录。对于只存在于右侧数据帧中的键，左侧数据帧中不匹配的值将用<code class="fe me mf mg mh b">nan</code>填充。</li></ul><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="1cbf" class="ni nj it mh b gy nk nl l nm nn"><em class="ml"># Right join</em><br/>right_join = pd.merge(bill.head(2), tip, how= "right", on=["sex", "smoker"], indicator= <strong class="mh jd">True</strong>)<br/>print(right_join.shape)<br/>right_join.head()</span><span id="a3bc" class="ni nj it mh b gy no nl l nm nn">&gt;&gt;&gt;&gt; (4, 5)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi py"><img src="../Images/52a0e03d33589916845f4885378c5af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*755BEYnHgFiPB1UaOjB3Bw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 7:右连接数据帧</p></figure><p id="3444" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ml">图 8 </em>为我们提供了上述不同连接的可视化表示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pz"><img src="../Images/277f1c47495368746159bc0254169755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ARNQ9vFchxQZWLtZisBVeA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 8:不同连接的可视化表示；假设维恩图中的两个圆是两个数据帧。此外，我们还必须假设外部连接指示两个数据帧(集合并集)中的所有内容，而不是两个数据帧之外的所有内容。</p></figure><p id="8aa0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时，您想要合并的数据帧中的列可能是不同的，但是跨两个数据帧的索引是相同的。例如，按日期分组的显示开盘价的财务数据可以是一个数据框架，而按日期分组的显示收盘价的财务数据可以是另一个数据框架。我们可以使用<code class="fe me mf mg mh b">pd.merge()</code>合并指数上的数据框架，这将导致一个数据框架显示特定日期的开盘价和收盘价。</p><p id="55d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里有一个例子:</p><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="db18" class="ni nj it mh b gy nk nl l nm nn"><em class="ml"># Setting indexes<br/></em>bill.set_index(keys= ["sex", "smoker"], inplace= <strong class="mh jd">True</strong>) tip.set_index(keys= ["sex", "smoker"], inplace= <strong class="mh jd">True</strong>)</span><span id="c0d6" class="ni nj it mh b gy no nl l nm nn">bill.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/80ca1cc777c1657ea3eea83d5147b5f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*X0zIVVqueV1Q7xWfIjIzmg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 9:以“性”和“吸烟者”为索引的账单数据框架</p></figure><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="9b5e" class="ni nj it mh b gy nk nl l nm nn">tip.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/38203bb5b2dcb5c27fe9d95ad99f545c.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*vk5Jgfs4ACz2FxXtxPQ63Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 10:以“性别”和“吸烟者”为索引的 Tip 数据框架</p></figure><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="07a5" class="ni nj it mh b gy nk nl l nm nn"><em class="ml"># Merging on index</em><br/>index_merge= pd.merge(bill, tip, how="inner", left_index=<strong class="mh jd">True</strong>, right_index=<strong class="mh jd">True</strong>)<br/>index_merge.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/520a3f43605c2e484a174074f14cfda4.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*mPWT0M5EfJ_C_7KUMdh1eQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 11:索引合并</p></figure><p id="c0e9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过简单地将<code class="fe me mf mg mh b">left_index</code>和<code class="fe me mf mg mh b">right_index</code>设置为<code class="fe me mf mg mh b">True</code>，我们可以在索引上进行合并。此外，通过将一个要合并的索引设置为<code class="fe me mf mg mh b">True</code>，并定义与另一个数据帧中的索引相匹配的列，可以合并索引和列。例如…</p><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="1c27" class="ni nj it mh b gy nk nl l nm nn"><em class="ml"># Merging partial index and column </em><br/>partial_merge= pd.merge(bill, tip, how="inner", left_index=<strong class="mh jd">True</strong>, right_on=["sex", "smoker"])<br/>partial_merge.head()</span></pre><p id="571c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将返回<em class="ml">图 11 </em>。</p><p id="f62d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">额外信息</strong></p><p id="4e5a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据输入的数据，<code class="fe me mf mg mh b">pd.merge()</code>允许我们进行各种类型的连接，例如<em class="ml">一对一</em>、<em class="ml">多对一</em>和<em class="ml">多对多</em>:</p><p id="9d1b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="ml">一对一</em> </strong> —一个数据帧中的每一行都使用“键”列与另一个数据帧中的一行相关。</p><p id="7ee9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="ml">一对多</em> </strong> —一个数据帧中的每一行都使用“键”列链接到另一个数据帧中的一行或多行。</p><p id="5e34" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="ml">多对多</em> </strong> —一个数据帧中的一行或多行使用“键”列与另一个数据帧中的一行或多行相关。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="e6aa" class="ni nj it bd or os ot dn ou ov ow dp ox lr oy oz pa lv pb pc pd lz pe pf pg iz bi translated">串联</h2><p id="4ebf" class="pw-post-body-paragraph li lj it lk b ll ph kd ln lo pi kg lq lr pj lt lu lv pk lx ly lz pl mb mc md im bi translated">我们可以认为串联是沿着一个轴将我们的数据集粘合在一起——或者是<strong class="lk jd">行轴</strong>或者是<strong class="lk jd">列轴</strong>。<code class="fe me mf mg mh b">pd.concat()</code>允许我们做非常简单的连接，因此<code class="fe me mf mg mh b">pd.merge()</code>是必要的。</p><blockquote class="mi mj mk"><p id="d1b1" class="li lj ml lk b ll lm kd ln lo lp kg lq mm ls lt lu mn lw lx ly mo ma mb mc md im bi translated">注意:<code class="fe me mf mg mh b"><a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html#pandas.concat" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">concat()</strong></a></code>(因此也是<code class="fe me mf mg mh b"><strong class="lk jd">append()</strong></code>)制作了数据的完整副本，不断地重用这个函数会对性能产生重大影响。如果需要在几个数据集上使用该操作，请使用列表理解。—来源 Pandas 文档。</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pz"><img src="../Images/60b02173759b1c0e4061e660fcc3ea79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kD5__4_exAIf8WvfihotBg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 12:连接的可视化。</p></figure><p id="c25c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">pd.concat()</code>的默认行为是保留两个轴数据的外部连接。但是，通过调整<code class="fe me mf mg mh b">join</code>参数，您可以修改函数来执行内部连接，这可能会导致一些数据丢失——只有轴标签匹配的地方才会保留行和列数据。</p><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="11e5" class="ni nj it mh b gy nk nl l nm nn"><em class="ml"># Gluing dataframes row-wise </em><br/>row_glue= pd.concat([bill, tip], axis=0, sort=<strong class="mh jd">False</strong>)<br/>row_glue.head(8)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/8e041afe3648284c8bf29f67b3370cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*CGDNH0LpcInhjm2QegRKVQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 13:行连接</p></figure><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="d6fd" class="ni nj it mh b gy nk nl l nm nn"><em class="ml"># Gluing dataframes column-wise<br/></em>col_glue= pd.concat([bill, tip], axis=1, sort=<strong class="mh jd">False</strong>)<br/>col_glue.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/bd5923d16e8d581a8011ef68f06d11f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*BZzuAj-PGxz3EG1WqrjPig.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 14:列连接</p></figure><p id="5044" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还可以通过向<code class="fe me mf mg mh b">keys</code>传递一个序列来添加一个指示器，指示每个连接开始的位置。</p><pre class="ks kt ku kv gt ne mh nf ng aw nh bi"><span id="ed1a" class="ni nj it mh b gy nk nl l nm nn"><em class="ml"># Adding an indicator </em><br/>indicator_glue = pd.concat([bill, tip], axis=0, sort=<strong class="mh jd">False</strong>, keys=["df1", "df2"])<br/>indicator_glue</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/da0ae1ea2350b59b2d3f811ac5da9cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*niEW-pQ9GzUdCeY7u68dBQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 15:添加了一个指示器来标识 concat 数据的来源。</p></figure></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="960d" class="ni nj it bd or os ot dn ou ov ow dp ox lr oy oz pa lv pb pc pd lz pe pf pg iz bi translated">包裹</h2><p id="9457" class="pw-post-body-paragraph li lj it lk b ll ph kd ln lo pi kg lq lr pj lt lu lv pk lx ly lz pl mb mc md im bi translated">Pandas 有许多用于组合数据的有用技术，在我看来，这些技术允许你将 Pandas 框架变成你自己的，正如我所做的那样，我只选择使用 2 个顶级函数来组合数据，以完成我所有的组合操作。</p><p id="c51b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢您花时间阅读这个故事。如果你喜欢它，你可以在 PyTrix 系列中找到更多类似的文章。</p><div class="ns nt gp gr nu nv"><a href="https://towardsdatascience.com/tagged/pytrix-series" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd jd gy z fp oa fr fs ob fu fw jc bi translated">Pytrix 系列-走向数据科学</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">阅读《走向数据科学》中关于 Pytrix 系列的文章。共享概念、想法和代码的媒体出版物。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="qf l og oh oi oe oj lb nv"/></div></div></a></div><p id="81f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您想亲自联系我，我是 LinkedIn 上最活跃的用户，我会非常乐意与您联系！</p><div class="ns nt gp gr nu nv"><a href="https://www.linkedin.com/in/kurtispykes/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd jd gy z fp oa fr fs ob fu fw jc bi translated">Kurtis Pykes -人工智能作家-走向数据科学| LinkedIn</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">在世界上最大的职业社区 LinkedIn 上查看 Kurtis Pykes 的个人资料。Kurtis 有一个工作列在他们的…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">www.linkedin.com</p></div></div><div class="oe l"><div class="qg l og oh oi oe oj lb nv"/></div></div></a></div></div></div>    
</body>
</html>