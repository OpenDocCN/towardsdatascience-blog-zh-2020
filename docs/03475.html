<html>
<head>
<title>10 Interesting Python Tricks to knock your socks off</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你大吃一惊的 10 个有趣的 Python 技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-interesting-python-tricks-to-knock-your-socks-off-1dd4d8e82101?source=collection_archive---------14-----------------------#2020-04-02">https://towardsdatascience.com/10-interesting-python-tricks-to-knock-your-socks-off-1dd4d8e82101?source=collection_archive---------14-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="16b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提高代码效率的 10 个 python 代码片段的重要列表</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/26a6887b4eb27922b23bfc697fede2c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-W8u5bHnMHvu04s4"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">安德烈·格拉在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ffd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python 被认为是迄今为止最通用的编程语言，在不同领域有着广泛的应用。如果您已经掌握了 Python 的基础知识，那么是时候探索可以在日常工作中帮助您的独特代码片段了。</p><p id="89e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是 10 个特性或片段，它们可能会给你留下深刻印象，并有助于提高代码效率。</p><h1 id="93ec" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">将不常用的类别合并成一个</h1><p id="1dd6" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">有时你会得到一个元素分布不均匀的列。仅仅存在几个类别。您通常希望将这些类别合并成一个类别。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="8161" class="mn lg it mj b gy mo mp l mq mr">df.artists.value_counts()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/91f683912925bf331628dba6105e1d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*HWVDCs8sUrjeLN1s-rSWBg.png"/></div></figure><p id="4b54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们希望将 Coldplay 和 Weekend 合并到一个类别中，因为它们仅对数据集有影响。</p><p id="c0ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们需要找到我们不想改变的元素，即阿姆、泰勒·斯威夫特和布鲁诺·马斯</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="2e9a" class="mn lg it mj b gy mo mp l mq mr">myList = df.artists.value_counts().nlargest(3).index</span></pre><p id="0db3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用 where()函数来替换其他元素</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="9389" class="mn lg it mj b gy mo mp l mq mr">df_new = df.where(df.artists.isin(myList),other='other artists')<br/>df_new.artists.value_counts()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/1d10415c1a8dbf7aebc7573ad57d265a.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*YhWWrSP1WOsliJ6wot0CcA.png"/></div></figure><p id="6ed1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我们需要修改的更新专栏。</p><h1 id="b9d8" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">查找列表中的新元素</h1><p id="fc0b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">当我们有两个不同的列表，我们需要找到在一个列表中出现但在另一个列表中不出现的元素</p><p id="1397" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑两个列表</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="9669" class="mn lg it mj b gy mo mp l mq mr">A = [ 1, 3, 5, 7, 9 ]<br/>B = [ 4, 5, 6, 7, 8 ]</span></pre><p id="80e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了找到列表 A 的新元素，我们取 A 与 B 的集合差</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="91b4" class="mn lg it mj b gy mo mp l mq mr">set(A) - set(B)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/10df4b5c1207b3945a8e1267073c13b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*GpyFod3i4OG0KYvgNaK7pg.png"/></div></figure><p id="409d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">值 1、3 和 9 只出现在列表 A 中，而不在列表 b 中。</p><h1 id="8f9b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Map()函数</h1><p id="011c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Map 函数接受两个参数 function 和 iterable，并返回结果的映射</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="1e75" class="mn lg it mj b gy mo mp l mq mr">map(func,itr)</span></pre><p id="8d34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> func </strong>是一个函数，map 将给定 iterable 的每个元素传递给它。<br/> <strong class="js iu"> itr </strong>是要映射的可迭代对象。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="f994" class="mn lg it mj b gy mo mp l mq mr">def product(n1,n2): <br/>    return n1 *n2 </span><span id="cb1a" class="mn lg it mj b gy mv mp l mq mr">list1 = (1, 2, 3, 4) <br/>list2 = (10,20,30,40)</span><span id="b6b0" class="mn lg it mj b gy mv mp l mq mr">result = map(product, list1,list2) <br/>list(result)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/49347bcdf6956abd711225f4feb0388c.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*eDIvrXEMh2saggGM76wk-w.png"/></div></figure><p id="2323" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来分解代码</p><p id="3302" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> product </strong>函数接受两个列表并返回两个列表的乘积。</p><p id="7b30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">列表 1 </strong>和<strong class="js iu">列表 2 </strong>是两个列表，它们将作为我们地图函数的可迭代列表</p><p id="abbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> map </strong>()取乘积函数和 iterable → list1 和 list2，最后返回两个列表的乘积作为结果。</p><h1 id="91de" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Map + Lambda 组合</h1><p id="1ed6" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">可以使用 lambda 函数替换 product 函数来修改上面的代码</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="865f" class="mn lg it mj b gy mo mp l mq mr">list1 = (1, 2, 3, 4) <br/>list2 = (10,20,30,40)<br/>result = map(lambda x,y: x * y, list1,list2) <br/>print(list(result))</span></pre><p id="ff2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Lambda 函数有助于避免单独编写函数的开销。</p><h1 id="e15f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">开始、停止和设置</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/c5b4f07eee775b510dbb2b31deb9e717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HGU-1pPfrPl8ywal"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@bruno_nascimento?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁诺·纳西门托</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1dbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> slice(start:stop[:step]) </strong>是通常包含一部分序列的对象。</p><ul class=""><li id="4c21" class="my mz it js b jt ju jx jy kb na kf nb kj nc kn nd ne nf ng bi translated">如果只提供了 stop，它将生成从索引 0 到 stop 的序列部分。</li><li id="b4e6" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">如果只提供 start，它将生成从索引开始到最后一个元素的序列部分。</li><li id="7a04" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">如果同时提供了 start 和 stop，它将生成从索引开始到停止的序列部分。</li><li id="15ca" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">如果提供了 start、stop 和 step 这三个参数，它将在索引开始后生成序列的一部分，直到以索引步长的增量停止。</li></ul><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="0d63" class="mn lg it mj b gy mo mp l mq mr">x = [ 1, 2, 3, 4, 5, 6, 7, 8 ]<br/>x[ 1: 6: 2]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ec78298a341f2c62e5a3a7673cd53e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*foAsGt5-M4WcjGAKZ4bKHw.png"/></div></figure><p id="fb46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上面的代码来看，1 是我们的开始索引，6 是我们的停止索引，2 是我们的步进索引。这意味着我们从索引 1 到索引 6 开始，步长为 2。</p><p id="09b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以使用[::-1]操作翻转列表</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="2fde" class="mn lg it mj b gy mo mp l mq mr">x[::-1]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/9ff7e0dd87a81cdea56142fc900e0b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*fFXFjLUL9A4eps8mNCskzQ.png"/></div></figure><p id="2264" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，用开始、停止和步进操作来反转整个列表是很容易的。</p><h1 id="9b57" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">一起压缩和枚举</h1><p id="deb3" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">您可能听说过 zip 和 enumerate 函数。它们主要与<strong class="js iu">一起用于循环</strong>。但是把它们放在一起使用更酷。它不仅允许您在一个循环中迭代多个值，还可以同时获得索引。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="bfa2" class="mn lg it mj b gy mo mp l mq mr">NAME = ['Sid','John','David']<br/>BIRD = ['Eagle','Sparrow','Vulture']<br/>CITY =['Mumbai','US','London']</span><span id="4ad6" class="mn lg it mj b gy mv mp l mq mr">for i,(name,bird,city) in enumerate(zip(NAME,BIRD,CITY)):<br/>    print(i,' represents ',name,' , ',bird,' and ',city)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nn"><img src="../Images/a9f0260161b6124f132dfa2d8a975056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b2Ah-jCUMiTMDMFSe-dyog.png"/></div></div></figure><p id="6b00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Zip </strong>函数帮助你把所有的列表放在一起，这样你就可以同时遍历每一个列表，而<strong class="js iu"> Enumerate </strong>函数帮助你获取索引以及附加到该索引的元素。</p><h1 id="f36c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">随意采样</h1><p id="6e23" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">有时，当您遇到非常大的数据集时，您决定处理数据的随机子集。pandas dataframe 的<strong class="js iu">示例</strong>功能可帮助您实现更多功能。</p><p id="836a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们考虑一下上面已经创建的艺术家数据帧</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="5000" class="mn lg it mj b gy mo mp l mq mr">df.sample(n=10)</span></pre><p id="6d26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这有助于获得数据集的 10 个随机行。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="1bbf" class="mn lg it mj b gy mo mp l mq mr">df.sample(frac=0.5).reset_index(drop=True)</span></pre><p id="31f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们分解上面的代码，</p><p id="7f8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> frac </strong>参数取 0 到 1 之间的值，包括 1。它取分配给它的数据帧的一部分。在上面的代码片段中，我们指定了 0.5，因此它将返回大小为→ 0.5 *原始大小的随机子集</p><p id="4b84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以注意到它前面的 reset_index 函数。这有助于正确重置索引，因为当我们获取随机子集时，索引也会被打乱。</p><h1 id="8b5e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">消除警告</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi no"><img src="../Images/6fb8ce1f66d7ea7b55576fb7b7513768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T6jpOXMo-owSQabg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@christnerfurt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Christian Erfurt </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="267b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在运行代码时，您经常会收到很多警告。过了一点，它开始激怒我们。例如，每当您导入纪元时，您可能会收到一条未来警告消息</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi np"><img src="../Images/c1809c6d99cfa8820f38a6f231d89a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAOdHOlD747yEcPzmeGhRQ.png"/></div></div></figure><p id="dae3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以用下面的代码隐藏所有警告。请确保将这一点写在代码的顶部。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="7a0b" class="mn lg it mj b gy mo mp l mq mr">import warnings <br/>warnings.filterwarnings(action='ignore')<br/>import keras</span></pre><p id="a845" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将有助于隐藏整个代码中的所有警告。</p><h1 id="9774" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">保存你的记忆</h1><p id="582f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">随着对编码的深入研究，您开始意识到高效内存代码的重要性。生成器是一个函数，它返回一个我们可以迭代的对象。这有助于有效地利用内存，因此主要在我们迭代无限长的序列时使用。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="1495" class="mn lg it mj b gy mo mp l mq mr">def SampleGenerator(n):<br/>    yield n<br/>    n = n+1<br/>    yield n<br/>    n = n+1<br/>    yield n</span><span id="f0fc" class="mn lg it mj b gy mv mp l mq mr">gen = SampleGenerator(1)</span></pre><p id="3624" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Yield </strong>语句暂停保存所有状态的函数，稍后在后续调用中继续。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="e8f5" class="mn lg it mj b gy mo mp l mq mr">print(next(gen))<br/>print(next(gen))<br/>print(next(gen))</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/740442941b8e76715752469aef5e10e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*ngN0d5SDM0aCdNXC12S5GA.png"/></div></figure><p id="511e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你所看到的，yield 保存了前一个状态，每当我们调用下一个函数时，它就转移到下一个 yield，返回新的输出。</p><p id="7f3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以通过添加一个在生成器函数中无限运行的 while 循环来迭代单个 yield。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="8f72" class="mn lg it mj b gy mo mp l mq mr">def updatedGenerator(n):<br/>    while(1):<br/>        yield n<br/>        n = n + 1<br/>a = updatedGenerator(1)</span><span id="cb97" class="mn lg it mj b gy mv mp l mq mr">for i in range(5):<br/>    print(next(a))</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/d39e4b7d29b4ba61df6ca15e75990946.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*1V5NyIBMWX_R1fg3iCtQ5g.png"/></div></figure><p id="d3a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">while 语句帮助我们一遍又一遍地迭代相同的 yield 语句。</p><h1 id="06d3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">小艇——救星</h1><p id="7fd7" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">终于把最好的留给了我的最后一次。有没有遇到过读取一个 csv 文件太大，以至于你的内存无法容纳它的情况？Skiprows 帮你轻松应对。</p><p id="00a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它允许您指定数据帧中要跳过的行数。</p><p id="aef8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑一个 100 万行的数据集，它不适合您的内存。如果您指定 skiprows = 0.5 百万，它会在读取数据时跳过数据集中的 0.5 百万行，从而使您可以轻松地读取数据帧的子集。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="28ba" class="mn lg it mj b gy mo mp l mq mr">df = pd.read_csv('artist.csv')<br/>df_new = pd.read_csv('artist.csv',skiprows=50)<br/>df.shape, df_new.shape</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/bfb7fbfddd508c25689fc1501df0bb27.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*oUkanxdqFck5KFsGkNHgYw.png"/></div></figure><p id="8f52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码片段中，df 表示一个 112 行的数据集。在添加 skiprows=50 之后，它从您的数据集中跳过了 50 行，因此读取 62 行作为我们的新数据集。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ns"><img src="../Images/5c4256d622ecb1bc121d862b65823212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*31ta7c4uPfNU0Mgn"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@paul_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">保罗·花冈</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4369" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您阅读文章。希望你喜欢！</p></div></div>    
</body>
</html>