<html>
<head>
<title>What’s the best way to handle NaN values?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理NaN值的最好方法是什么？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/whats-the-best-way-to-handle-nan-values-62d50f738fc?source=collection_archive---------2-----------------------#2020-01-12">https://towardsdatascience.com/whats-the-best-way-to-handle-nan-values-62d50f738fc?source=collection_archive---------2-----------------------#2020-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f9dc0577857374099e9590da7cb0f7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvICETaCLqQNqjOTjwed4A.png"/></div></div></figure><p id="117e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我进行大数据分析的实践中，我发现了一个可以破坏每个数据分析过程的障碍。这种障碍在数据科学和机器学习中被称为NaN值。</p><h2 id="2443" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">什么是NaN价值观？</h2><p id="7238" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">NaN或Not数字是在<a class="ae lx" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html" rel="noopener ugc nofollow" target="_blank"> DataFrame </a>和<a class="ae lx" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> numpy </a>数组中的特殊值，表示单元格中缺少的值。在编程语言中，它们也被表示，例如在Python中，它们被表示为None值。</p><p id="b880" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能认为None(或NaN)值只是零，因为它们表示没有值。但是这里有一个陷阱，零和None值之间的区别在于，零是一个值(例如integer或float)，而None值表示没有该值。这里有一个迷因很好地解释了零价值和零价值之间的区别:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ly"><img src="../Images/67b1d9eeba52c7818c80bf4172f43141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*deBCy2VgkXZOzeH4osPiyA.jpeg"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">0和NULL的区别(来源——谷歌)</p></figure><h2 id="1997" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">南值有多危险？</h2><p id="e041" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">NaN值在两个方面是危险的:</p><ul class=""><li id="35ad" class="mh mi it kd b ke kf ki kj km mj kq mk ku ml ky mm mn mo mp bi translated">一些指标的变化，如平均值或中间值，因此给科学家错误的信息。</li><li id="6d65" class="mh mi it kd b ke mq ki mr km ms kq mt ku mu ky mm mn mo mp bi translated">sklearn实现的算法不能在具有这样的值的数据集上执行(尝试在心脏病数据集上实现TreeDecsisionClassifier)。</li></ul><h2 id="0c65" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">怎么处理他们？</h2><p id="3937" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">那么，如果NaN值对数据科学家的工作如此危险，我们应该如何处理它们呢？有几种解决方案:</p><ul class=""><li id="a90f" class="mh mi it kd b ke kf ki kj km mj kq mk ku ml ky mm mn mo mp bi translated">擦除具有NaN值的行。但是这不是一个好的选择，因为这样我们会丢失信息，尤其是当我们处理小数据集的时候。</li><li id="91d3" class="mh mi it kd b ke mq ki mr km ms kq mt ku mu ky mm mn mo mp bi translated">用特定的方法或值估算NaN值。本文参考了这些方法。</li></ul><p id="e68b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有很多方法来估算这些差距，在大多数情况下，数据科学家，尤其是新手，不知道它们。以下是实现这一目标的方法:</p><ul class=""><li id="1270" class="mh mi it kd b ke kf ki kj km mj kq mk ku ml ky mm mn mo mp bi translated">输入特定的值。</li><li id="07ab" class="mh mi it kd b ke mq ki mr km ms kq mt ku mu ky mm mn mo mp bi translated">用特殊度量估算，例如，平均值或中值。</li><li id="b869" class="mh mi it kd b ke mq ki mr km ms kq mt ku mu ky mm mn mo mp bi translated">使用方法估算:鼠标或KNN。</li></ul><p id="5072" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看每种方法是如何工作的，以及它们如何影响数据集。</p><h2 id="55ff" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">实验！</h2><p id="bf8d" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">为了验证每一种方法，我选择了一个名为<a class="ae lx" href="https://archive.ics.uci.edu/ml/datasets/iris" rel="noopener ugc nofollow" target="_blank">虹膜数据集</a>的数据集——这可能是机器学习测试中最常见的数据集。我还在更大、更复杂的数据集上尝试了这些方法，但对于某些算法来说，执行插补的时间太长了。</p><p id="2965" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我为这个数据集中的每个特性列生成了15个介于0和149之间的随机且唯一的索引。使用这些索引(对于每个列，它们是单独生成的)，我用NaN更改了列值。</p><p id="c074" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在对这些NaN值应用每种方法后，我使用均方差(MSE)来检查每种方法的“准确性”。</p><p id="6a9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，我们开始吧。</p><h2 id="9c3b" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">方法1:用特定值插补。</h2><p id="5ded" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">在这种方法中，NaN值用一个特定的值(例如一个数字)来改变，在大多数情况下，这个值是0。有时这是最好的选择，就像你的特征是花在糖果上的钱，但有时这是最糟糕的选择，就像年龄。</p><p id="98f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们看看它是如何影响初始数据集的:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/445cc7a82e8afa15fb4ba8ea5bf233f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uLt_eEFXW_f5EAelHHVZ1w.png"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">估算值用星号(*)表示，正常值用点表示。</p></figure><p id="792f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所看到的，用零填充NaN值会强烈影响那些不可能有0值的列。这将严重影响空间，取决于所使用的算法，尤其是KNN和TreeDecissionClassifier。</p><p id="ed1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">提示:</strong> <em class="mw">我们可以通过套用</em> <strong class="kd iu"> <em class="mw">来看看零是不是一个好的选择。向我们的数据帧描述()</em> </strong> <em class="mw">函数。如果最小值等于0，那么它可能是一个好的选择，如果不是，那么你应该选择另一个选项。</em></p><h2 id="8444" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">方法2:指标插补。</h2><p id="1518" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">指标插补是一种用一些特殊指标填充NaN值的方法，这些指标取决于您的数据:例如平均值或中值。</p><p id="22b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">平均值是一个序列中某个值的总和除以该序列中所有值的个数。它是统计学中最常用的度量类型之一。但是为什么我们用平均值来估算NaN值呢？均值有一个非常有趣的性质，如果你在数列中加入更多的均值，它不会改变。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/809a9b65e5398c7a3f06510b4966d58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eva6sbXRm0YYjXrFt523mg.png"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">均值插补后的数据可视化。</p></figure><p id="6a63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的图中，你可以看到它并没有过多地影响数据集的结构，最重要的是它没有将一个类中的任何样本放入另一个类的区域中。</p><p id="c08c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">中值将数字分成具有相同样本数的两半。有时在统计分析中，中间值比平均值更能提供信息，因为它不会被新值扭曲太多。在正态分布(实际上并不存在)中，平均值和中值是相等的。</p><p id="ab98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于不存在正态分布，在大多数情况下，平均值和中值非常接近。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/1d49d3d2fedff97de31f76b68d64a80a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gjmR3gmWfxf8DBYLrc1kRw.png"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">中位数插补后的数据可视化。</p></figure><p id="e728" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面的图中，如果你仔细观察，可以清楚地看到中间值是如何工作的，所有的星星(估算的值)都排列在两条正交线上(萼片长度为5.6，萼片宽度为3.0)。</p><h2 id="8a25" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">方法3:用KNN进行估算</h2><p id="6cfc" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">这种插补算法与sklearn的KNearesNeighbours非常相似。它从数据集中找到与NaN值的样本最接近的k个样本，并用它估算这些样本的平均值。</p><p id="9abc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个方法是在库impyute和sklearn中实现的(当我开始写这篇文章时，我不知道sklearn的实现。)</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/5695887a5de0e0c3e63667b633c04bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8ba6VX-kbS_HXqbInrDQw.png"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">用3个邻居进行KNN插补后的数据可视化。</p></figure><p id="60f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面的图中，我们可以看到一个严重的错误——将来自红色类的样本放置在蓝绿色区域中(这是具有3个邻居的knn实现)。</p><h2 id="248e" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">方法4:用小鼠输入</h2><p id="f8d2" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">本文的最后一个算法，也是我目前知道的最好的一个算法——链式方程的多重插补。这种算法适用于每一个有缺失值的列，可以用当前值进行线性回归。之后，它使用这些线性函数来估算具有这些值的预测的NaN值。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/d87c0a2740604ab12f6ce4dd6a246d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fa6gdXxHaYkZCzZrm2cxRw.png"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">小鼠插补后的数据可视化。</p></figure><p id="9a1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，在上面的图上，它并没有强烈影响2D图上的数据集表示。但是为什么呢？</p><p id="67a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">KNN和MICE插补使用整个数据集来替换NaN值，而中值和平均值仅使用缺失值的列，这就是为什么后两种算法不会强烈影响数据集结构，也不会改变其信息。</p><h2 id="ebe5" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">但是这些数字说明了什么呢？</h2><p id="27b8" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">最后的话交给数字。为了了解上述方法的效果，我使用了MSE(均方误差)。我计算了原始值和估算值之间的MSE值。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/2e4e388e00b6cb73175a7ac3befc5e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*0ArqZ17f8K_FJ8trkc_lAA.png"/></div></div></figure><p id="5c2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上表显示了每种方法的MSE(在KNN和鼠标上，我使用了两个版本:一个包括目标值(有y值),另一个不包括它)。</p><p id="3b1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是哪种算法最适合哪一列。</p><ul class=""><li id="da72" class="mh mi it kd b ke kf ki kj km mj kq mk ku ml ky mm mn mo mp bi translated">萼片长度—小鼠</li><li id="5a0a" class="mh mi it kd b ke mq ki mr km ms kq mt ku mu ky mm mn mo mp bi translated">萼片宽度— KNN4_y</li><li id="4e7e" class="mh mi it kd b ke mq ki mr km ms kq mt ku mu ky mm mn mo mp bi translated">花瓣长度—老鼠</li><li id="4824" class="mh mi it kd b ke mq ki mr km ms kq mt ku mu ky mm mn mo mp bi translated">花瓣宽度—鼠标</li></ul><p id="4ce1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我所想的那样，老鼠在大多数情况下都工作得很好。</p><h1 id="24cd" class="my la it bd lb mz na nb le nc nd ne lh nf ng nh lk ni nj nk ln nl nm nn lq no bi translated">遗言！</h1><p id="3c96" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我从这个实验中得到的结论是，估算连续值的最好方法是使用整个数据集，如MICE或KNN，而不仅仅是一列。</p><h2 id="1c70" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">感谢您的阅读！</h2></div></div>    
</body>
</html>