<html>
<head>
<title>Using Classes for Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用类进行机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-classes-for-machine-learning-2ed6c0713305?source=collection_archive---------5-----------------------#2020-02-12">https://towardsdatascience.com/using-classes-for-machine-learning-2ed6c0713305?source=collection_archive---------5-----------------------#2020-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2e29" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用面向对象编程来构建模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9ded254a1809850fe14449c065aff887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JCsUJSI8bV2uuEXMIdx8JQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Clem Onojeghuo 在<a class="ae ky" href="https://www.pexels.com/photo/assorted-assortment-booth-boxes-375897/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄的照片</p></figure><p id="f9d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类提供了一种结合数据和功能的有用方式。类的模块化支持有效的故障排除、代码重用和问题解决。例如，如果您的代码中断，您将能够指向一个特定的类或类方法，而不必筛选太多其他代码。由于这些因素，模型开发自然地适合于面向对象的编程实践。</p><p id="2e93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将讨论如何使用面向对象编程来读取数据、分割数据以进行训练、拟合模型以及进行预测。我们将使用天气数据，这些数据可以在<a class="ae ky" href="https://www.kaggle.com/budincsevity/szeged-weather" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="d241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，让我们进口熊猫:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f7e0" class="ma mb it lw b gy mc md l me mf">import pandas as pd </span></pre><p id="1040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们定义一个名为Model的类:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="567c" class="ma mb it lw b gy mc md l me mf">class Model:<br/>    def __init__(self, datafile = "weatherHistory.csv"):<br/>        self.df = pd.read_csv(datafile)</span></pre><p id="b119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类将有一个“__init__”函数，也称为构造函数，它允许我们在创建该类的新实例时初始化数据。我们可以将一个新变量“model_instance”定义为一个对象(模型类的一个实例):</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b62a" class="ma mb it lw b gy mc md l me mf">if __name__ == '__main__':<br/>    model_instance = Model()</span></pre><p id="4e8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该能够通过对象“model_instance”访问数据框让我们调用数据框并打印前五行数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9988" class="ma mb it lw b gy mc md l me mf">if __name__ == '__main__':<br/>    model_instance= Model()<br/>    print(model_instance.df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/66c7642cc255b7ce6f079a7f5780eba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*_up3FgG9tZZQwcO82dPa9w.png"/></div></figure><p id="036c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来不错。</p><p id="69e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们可以在初始化函数中定义一个线性回归对象。不要将它与“model_instance”混淆，后者是我们的自定义类“model”的一个实例:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4835" class="ma mb it lw b gy mc md l me mf">class Model:<br/>    def __init__(self, datafile = "weatherHistory.csv"):<br/>        self.df = pd.read_csv(datafile)<br/>        self.linear_reg = LinearRegression()</span></pre><p id="358e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，值得注意的是LinearRegression是一个独立于我们的自定义“模型”类的类，并且在代码行中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="be45" class="ma mb it lw b gy mc md l me mf">self.linear_reg = LinearRegression()</span></pre><p id="863b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在定义LinearRegression类的一个实例。</p><p id="3f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们确保可以访问我们的线性回归对象:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2501" class="ma mb it lw b gy mc md l me mf">if __name__ == '__main__':<br/>    model_instance = Model()<br/>    print(model_instance.linear_reg)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/5cea348578cf4a4e711abc8b45d303c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*bI40SDwPI0eMtEWw4w5TnQ.png"/></div></figure><p id="79fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们要做的是定义一个方法，让我们分割数据用于训练和测试。该函数将采用一个“test_size”参数，让我们指定训练和测试的规模。</p><p id="9771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们从“sklearn”中导入“train_test_split”方法，并导入“NumPy”:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="230d" class="ma mb it lw b gy mc md l me mf">from sklearn.model_selection import train_test_split<br/>import numpy as np</span></pre><p id="2696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将建立一个线性回归模型来预测温度。为简单起见，让我们用“湿度”和“压力(毫巴)”作为输入，用“温度”作为输出。我们将分割方法定义如下:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b583" class="ma mb it lw b gy mc md l me mf">def split(self, test_size):<br/>        X = np.array(self.df[['Humidity', 'Pressure (millibars)']])<br/>        y = np.array(self.df['Temperature (C)'])<br/>        self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(X, y, test_size = test_size, random_state = 42)</span></pre><p id="09ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们打印“X_train”和“y_train”以供检查:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c623" class="ma mb it lw b gy mc md l me mf">if __name__ == '__main__':<br/>    model_instance = Model()<br/>    model_instance.split(0.2)<br/>    print(model_instance.X_train)<br/>    print(model_instance.y_train)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/9796040466116ea8bca51cb69d250bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*FOwZh0ERis802aP-PdnQKQ.png"/></div></figure><p id="be31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将为线性回归模型定义一个“拟合”函数:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9205" class="ma mb it lw b gy mc md l me mf">def fit(self):<br/>        self.model = self.linear_reg.fit(self.X_train, self.y_train)</span></pre><p id="f1b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将定义一个“预测”函数:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="12e6" class="ma mb it lw b gy mc md l me mf">def predict(self):<br/>        result = self.linear_reg.predict(self.X_test)<br/>        return result</span></pre><p id="7dc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们打印我们的测试预测，其中测试规模是数据的20%:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9dfe" class="ma mb it lw b gy mc md l me mf">if __name__ == '__main__':    <br/>    model_instance = Model()   <br/>    model_instance.split(0.2)    <br/>    model_instance.fit()<br/>    print(model_instance.predict())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/41076f6851edb153626db8107f60e790.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*GHDr_TRZxaWWmdX7pmXdvQ.png"/></div></figure><p id="2e2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以打印模型性能:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8ec3" class="ma mb it lw b gy mc md l me mf">if __name__ == '__main__':<br/>    model_instance = Model()<br/>    model_instance.split(0.2)<br/>    model_instance.fit()    <br/>    print("Accuracy: ",     model_instance.model.score(model_instance.X_test, model_instance.y_test))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/5efa93045975538f8a68769d15e27060.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*I_GoVUyuVrWEwYC1n45SNQ.png"/></div></figure><p id="4c16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以向我们的predict方法传递一个“input_value”参数，这将允许我们做出样本外的预测。如果“无”通过，则将对测试输入进行预测。否则，将对“输入值”进行预测:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8777" class="ma mb it lw b gy mc md l me mf">def predict(self, input_value):<br/>    if input_value == None:<br/>        result = self.linear_reg.predict(self.X_test)<br/>    else: <br/>        result = self.linear_reg.predict(np.array([input_value]))<br/>    return result</span></pre><p id="7261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一些样本外的测试输入来预测:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="df74" class="ma mb it lw b gy mc md l me mf">if __name__ == '__main__':<br/>    model_instance = Model()<br/>    model_instance.split(0.2)<br/>    model_instance.fit()    <br/>    print(model_instance.predict([.9, 1000]))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/8c73d6b31c0bd17584290340f28ab080.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*Pda1TuHrGE1dbBHnxS_IbQ.png"/></div></figure><p id="a981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以将随机森林回归模型对象定义为模型字段，并运行我们的脚本:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f838" class="ma mb it lw b gy mc md l me mf">class Model:<br/>    def __init__(self, datafile = "weatherHistory.csv"):<br/>        self.df = pd.read_csv(datafile)<br/>        self.linear_reg = LinearRegression()<br/>        self.random_forest = RandomForestRegressor()<br/>    def split(self, test_size):<br/>        X = np.array(self.df[['Humidity', 'Pressure (millibars)']])<br/>        y = np.array(self.df['Temperature (C)'])<br/>        self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(X, y, test_size = test_size, random_state = 42)<br/>    <br/>    def fit(self):<br/>        self.model = self.random_forest.fit(self.X_train, self.y_train)<br/>    <br/>    def predict(self, input_value):<br/>        if input_value == None:<br/>            result = self.random_forest.fit(self.X_test)<br/>        else: <br/>            result = self.random_forest.fit(np.array([input_values]))<br/>        return result</span><span id="3ed5" class="ma mb it lw b gy mm md l me mf"><br/>if __name__ == '__main__':<br/>    model_instance = Model()<br/>    model_instance.split(0.2)<br/>    model_instance.fit()    <br/>    print("Accuracy: ", model_instance.model.score(model_instance.X_test, model_instance.y_test))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/c6015aefec5a31bf1c655bb0a53b917c.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*pDgi3abtbnrEbyLZTVZCnA.png"/></div></figure><p id="84a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以轻松地修改代码来构建支持向量回归模型、“xgboost”模型等等。我们可以通过向构造函数传递一个参数来进一步一般化我们的类，当指定时，该构造函数从可能的模型列表中选择。</p><p id="7c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">逻辑可能看起来像这样:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="751c" class="ma mb it lw b gy mc md l me mf">class Model:<br/>    def __init__(self, datafile = "weatherHistory.csv", model_type = None):<br/>       self.df = pd.read_csv(datafile)</span><span id="ec10" class="ma mb it lw b gy mm md l me mf">       if model_type == 'rf':<br/>            self.user_defined_model = RandomForestRegressor() <br/>       else:<br/>            self.user_defined_model = LinearRegression()</span></pre><p id="945d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且修改了“拟合”和“预测”方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1fc7" class="ma mb it lw b gy mc md l me mf">    def fit(self):<br/>        self.model = self.user_defined_model.fit(self.X_train, self.y_train)<br/>    <br/>    def predict(self, input_value):<br/>        if input_value == None:<br/>            result = self.user_defined_model.fit(self.X_test)<br/>        else: <br/>            result =     self.user_defined_model.fit(np.array([input_values]))<br/>        return result</span></pre><p id="ec2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们执行如下:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fbd8" class="ma mb it lw b gy mc md l me mf">if __name__ == '__main__':<br/>    model_instance = Model(model_type = 'rf')<br/>    model_instance.split(0.2)<br/>    model_instance.fit()    <br/>    print("Accuracy: ", model_instance.model.score(model_instance.X_test, model_instance.y_test))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/c6015aefec5a31bf1c655bb0a53b917c.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*pDgi3abtbnrEbyLZTVZCnA.png"/></div></figure><p id="0fc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们传递“None ”,我们会得到:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5f16" class="ma mb it lw b gy mc md l me mf">if __name__ == '__main__':<br/>    model_instance = Model(model_type = None)<br/>    model_instance.split(0.2)<br/>    model_instance.fit()    <br/>    print("Accuracy: ", model_instance.model.score(model_instance.X_test, model_instance.y_test))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/5efa93045975538f8a68769d15e27060.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*I_GoVUyuVrWEwYC1n45SNQ.png"/></div></figure><p id="ef6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在这里停下来，但我鼓励您添加额外的模型对象。您可以尝试的一些有趣的例子是支持向量机、“xgboost”回归和“lightgbm”回归模型。添加帮助器方法也很有用，这些方法可以为任何数字列生成汇总统计信息，如平均值和标准偏差。您还可以定义通过计算统计数据(如相关性)来帮助您选择要素的方法。</p><p id="9e79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概括地说，在这篇文章中，我讨论了如何在面向对象编程框架中构建机器学习模型。这个框架对于故障诊断、问题解决、字段收集、方法收集等等非常有用。我希望您能在自己的数据科学项目中找到OOP的用处。这篇文章的代码可以在GitHub 上找到。感谢阅读，机器学习快乐！</p></div></div>    
</body>
</html>