<html>
<head>
<title>Backup your Azure Storage using snapshots and Data Factory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用快照和数据工厂备份您的Azure存储</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-create-snapshots-and-backups-of-your-azure-storage-e72bef58e0aa?source=collection_archive---------21-----------------------#2020-03-26">https://towardsdatascience.com/how-to-create-snapshots-and-backups-of-your-azure-storage-e72bef58e0aa?source=collection_archive---------21-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="07b1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用blob快照和数据工厂增量备份来自动备份您的数据湖</h2></div><h2 id="7e02" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">完整的数据湖恢复解决方案请看我的后续博客:<a class="ae le" rel="noopener" target="_blank" href="/how-to-recover-your-azure-data-lake-5b5e53f3736f">https://towards data science . com/how-to-recover-your-azure-data-lake-5b 5e 53 f 3736 f</a></h2><h1 id="9018" class="lf kj it bd kk lg lh li kn lj lk ll kq jz lm ka ku kc ln kd ky kf lo kg lc lp bi translated">1.Azure存储备份-简介</h1><p id="8b60" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly kr lz ma mb kv mc md me kz mf mg mh mi im bi translated">Azure存储总是存储您数据的多个副本。当使用地理冗余存储(GRS)时，它也被复制到<a class="ae le" href="https://docs.microsoft.com/en-us/azure/best-practices-availability-paired-regions" rel="noopener ugc nofollow" target="_blank">配对区域</a>。这样，GRS可以防止数据在灾难发生时丢失。但是，当应用程序错误损坏数据时，GRS无法防止数据丢失。然后，损坏的数据会被复制到其他区域/地区。在这种情况下，<a class="ae le" href="https://azure.microsoft.com/nl-nl/blog/microsoft-azure-block-blob-storage-backup/" rel="noopener ugc nofollow" target="_blank">需要一个备份</a>来恢复你的数据。两种备份策略如下:</p><ul class=""><li id="4dbb" class="mj mk it ls b lt ml lw mm kr mn kv mo kz mp mi mq mr ms mt bi translated">快照创建:在添加或修改blob的情况下，从当前情况创建快照。由于blob的<a class="ae le" href="https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs" rel="noopener ugc nofollow" target="_blank">性质，这是一个高效的O(1)运算。快照可以快速恢复，但是，恢复并不总是能够完成(例如，已删除的blobs)，请参见下一个策略。</a></li><li id="129c" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">增量备份:在添加或修改blob的情况下，会在另一个存储帐户中创建增量备份。复制blobs是一个开销很大的O(N)操作，但是可以使用Azure Data Factory异步完成。恢复可以通过复制blobs来完成。</li></ul><p id="4c3f" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">在这篇博客中，讨论了如何从存储帐户创建快照和增量备份，另请参见下面的概述。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nc"><img src="../Images/a1f58ece80227875493aa225063ec691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xoaq2oJlWLebzQknMRnQDA.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">1.数据湖备份—高级概述</p></figure><p id="239f" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">为了支持您的存储帐户的自动快照和增量备份的创建，在本博客的剩余部分将使用和讨论三种类型的脚本:</p><ul class=""><li id="67ae" class="mj mk it ls b lt ml lw mm kr mn kv mo kz mp mi mq mr ms mt bi translated">生产者触发的基于事件的脚本，用于在接收/修改数据后创建快照和增量备份请求</li><li id="b285" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">使用ADFv2创建增量备份的队列触发器脚本</li><li id="49e4" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">管理员触发的基于时间的脚本，用于协调丢失的快照/增量备份</li></ul><p id="98dc" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">请注意，<a class="ae le" href="https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob" rel="noopener ugc nofollow" target="_blank"> blob快照</a>仅在常规存储帐户中受支持，在ADLSgen2中尚不受支持(但预计在ADLSgen2中也会可用)。因此，脚本基于常规存储帐户，下面提供了脚本的详细说明。另请注意，脚本处理快照/备份的创建，而不是恢复。</p><h1 id="dc70" class="lf kj it bd kk lg lh li kn lj lk ll kq jz lm ka ku kc ln kd ky kf lo kg lc lp bi translated">2.基于事件触发的快照/增量备份请求</h1><p id="6665" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly kr lz ma mb kv mc md me kz mf mg mh mi im bi translated">在数据湖中，数据通常由生产者使用Azure Data Factory获取。要创建基于事件的触发快照/增量备份，应部署以下内容:</p><ul class=""><li id="1da5" class="mj mk it ls b lt ml lw mm kr mn kv mo kz mp mi mq mr ms mt bi translated">将下面的<a class="ae le" href="https://github.com/rebremer/blog-snapshotbackup-azuredatalake/tree/master/blog-snapshots-func/HttpSnapshotIncBackupContainerProducer" rel="noopener ugc nofollow" target="_blank">脚本</a>部署为Python中的Azure函数。见此<a class="ae le" href="https://docs.microsoft.com/nl-nl/azure/azure-functions/functions-reference-python" rel="noopener ugc nofollow" target="_blank">链接</a>如何用Python创建Azure函数。参见我的另一篇<a class="ae le" rel="noopener" target="_blank" href="/how-to-secure-your-azure-function-data-processing-c9947bf724fb">博客</a>如何保护Azure函数。</li><li id="04ce" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">将Azure函数作为链接服务添加到Azure数据工厂实例中，并将Azure函数作为最后一步添加到<a class="ae le" href="https://github.com/rebremer/blog-snapshotbackup-azuredatalake/blob/master/blog-snapshots-adfv2/pipeline/blogtriggersnapshots.json" rel="noopener ugc nofollow" target="_blank">摄取管道</a>中。</li><li id="66fe" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">创建两个存储帐户作为源存储和备份存储。还要创建一个存储队列来处理备份请求消息。</li></ul><p id="27ba" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">现在，每次使用ADFv2接收新数据时，都会调用一个Azure函数来创建快照，并为新的/已更改的blobs发送增量备份请求，另请参见下文。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ns"><img src="../Images/7128b28df71bd6d133e70d5f64e999bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rnDCmHlWUMfRoNSMszraVA.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">2.基于事件触发的快照/增量备份请求</p></figure><p id="b549" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated"><a class="ae le" href="https://github.com/rebremer/blog-snapshotbackup-azuredatalake/blob/master/blog-snapshots-func/HttpSnapshotIncBackupContainerProducer/__init__.py" rel="noopener ugc nofollow" target="_blank">脚本HttpSnapshotIncBackupContainerProducer</a>的内部工作原理可以解释如下:</p><ul class=""><li id="7482" class="mj mk it ls b lt ml lw mm kr mn kv mo kz mp mi mq mr ms mt bi translated">0.初始化快照/备份脚本通过将blob的<a class="ae le" href="https://docs.microsoft.com/en-us/azure/storage/common/storage-concurrency#optimistic-concurrency-for-blobs-and-containers" rel="noopener ugc nofollow" target="_blank"> ETag </a>与之前的快照(如果有)进行比较，来检查存储帐户的容器中的已修改/新blob。在它检测到修改的/新的斑点的情况下，完成以下2个步骤:</li><li id="bedf" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">1a。从修改的/新的blob创建快照</li><li id="7808" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">1b。向存储队列发送增量备份请求消息。备份请求消息仅包含已修改blob的元数据。</li></ul><p id="5c75" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">脚本的核心如下:</p><pre class="nd ne nf ng gt nt nu nv nw aw nx bi"><span id="9e74" class="ki kj it nu b gy ny nz l oa ob"><strong class="nu iu"># Get all blobs in container<br/></strong>prev_blob_name = ""<br/>prev_blob_etag = ""<br/>blob_list = container.list_blobs(include=['snapshots'])                           for blob in blob_list:                                                       if blob.snapshot == None:<br/>    <strong class="nu iu"># Blob that is not snapshot<br/> </strong>   if prev_blob_name != blob.name: <br/>        <strong class="nu iu"># New blob without snapshot, create snapshot/backup</strong>                                        <br/>        create_snapshot_backup(blob.name, blob.etag)<br/>    elif prev_blob_etag != blob.etag:<br/>        <strong class="nu iu"># Existing blob that has changed, create snapshot/backup<br/>        </strong>create_snapshot_backup(blob.name, blob.etag)</span><span id="23dc" class="ki kj it nu b gy oc nz l oa ob">    prev_blob_name = blob.name<br/>    prev_blob_etag = blob.etag</span></pre><p id="7937" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">请注意，只有生产者ADFv2托管身份和此Azure函数托管身份对此容器具有写访问权限。Blob触发器在这种情况下不起作用，因为修改blob时不会触发任何事件。</p><p id="bb3e" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">异步增量备份创建将在下一章讨论。</p><h1 id="b088" class="lf kj it bd kk lg lh li kn lj lk ll kq jz lm ka ku kc ln kd ky kf lo kg lc lp bi translated">3.增量备份创建</h1><p id="acdb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly kr lz ma mb kv mc md me kz mf mg mh mi im bi translated">一旦新的增量备份请求被添加到存储队列，该消息将被处理，从而创建增量备份。在这种情况下，应部署以下内容:</p><ul class=""><li id="d156" class="mj mk it ls b lt ml lw mm kr mn kv mo kz mp mi mq mr ms mt bi translated">将下面的<a class="ae le" href="https://github.com/rebremer/blog-snapshotbackup-azuredatalake/tree/master/blog-snapshots-func/QueueCreateBlobBackupADFv2" rel="noopener ugc nofollow" target="_blank">脚本</a>部署为Python中队列触发的Azure函数。可以使用与步骤2中相同的应用服务计划</li><li id="709a" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">确保正确填写所有必需的应用程序设置，参见<a class="ae le" href="https://github.com/rebremer/blog-snapshotbackup-azuredatalake/blob/master/blog-snapshots-func/appsettings.txt" rel="noopener ugc nofollow" target="_blank">此处</a></li><li id="8ff1" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">部署ADFv2 <a class="ae le" href="https://github.com/rebremer/blog-snapshotbackup-azuredatalake/blob/master/blog-snapshots-adfv2/pipeline/blogtriggerbackup.json" rel="noopener ugc nofollow" target="_blank">管道</a>，通过将blobs从源存储帐户复制到备份存储帐户来创建增量备份</li><li id="c5a5" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">确保您为Azure函数分配了一个<a class="ae le" href="https://docs.microsoft.com/nl-nl/azure/app-service/overview-managed-identity?tabs=dotnet#add-a-system-assigned-identity" rel="noopener ugc nofollow" target="_blank">托管身份，并且Azure函数拥有</a><a class="ae le" href="https://docs.microsoft.com/en-us/azure/data-factory/concepts-roles-permissions" rel="noopener ugc nofollow" target="_blank"> RBAC角色</a>“contributor”来运行它</li></ul><p id="4104" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">现在，每次在存储队列上接收到新的增量备份请求消息时，都会触发一个Azure函数，该函数调用创建增量备份的ADFv2管道，另请参见下文。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi od"><img src="../Images/98b831e70394167368358d492fb7a064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXM7OxizheST3_ilXm1GpQ.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">3.增量备份创建</p></figure><p id="6ade" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated"><a class="ae le" href="https://github.com/rebremer/blog-snapshotbackup-azuredatalake/blob/master/blog-snapshots-func/QueueCreateBlobBackupADFv2/__init__.py" rel="noopener ugc nofollow" target="_blank">脚本queuecreateblobbackupadfv 2</a><strong class="ls iu"/>的工作原理可以解释如下:</p><ul class=""><li id="a166" class="mj mk it ls b lt ml lw mm kr mn kv mo kz mp mi mq mr ms mt bi translated">2a。存储队列收到blob的新备份请求消息。请注意，消息可以并行处理</li><li id="77f6" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">2b。Azure函数从存储队列中提取消息，并检查备份请求是否过期。然后，它使用REST API和Azure Function托管身份触发ADFv2管道</li><li id="a9ec" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">2c。ADFv2通过将blob从源存储帐户复制到备份存储帐户来启动复制活动</li></ul><p id="075f" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">在步骤2b中，还可以决定运行blob_lease模式，该模式排他地锁定文件并保证文件的正确版本被添加到备份存储帐户。是否使用blob租约取决于许多因素(例如，允许的最大租约时间、文件大小、作业数量、不变性)。</p><p id="c901" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">脚本的核心如下:</p><pre class="nd ne nf ng gt nt nu nv nw aw nx bi"><span id="3918" class="ki kj it nu b gy ny nz l oa ob">USING_BLOB_LEASE = True                       </span><span id="a980" class="ki kj it nu b gy oc nz l oa ob"><strong class="nu iu"># check if source blob has not changed in the meantime<br/></strong>if source_blob_changed(blob_name, blob_etag) == True:<br/>    return</span><span id="fc64" class="ki kj it nu b gy oc nz l oa ob"><strong class="nu iu"># Start copying using ADFv2<br/></strong>try:                               <br/>    if not USING_BLOB_LEASE:<br/>        <strong class="nu iu"># Copy without locking the file<br/></strong>        copy_adf_blob_source_backup(blob_name, blob_etag)<br/>    else:      <br/>        <strong class="nu iu"># Copy with blob lease locks the file<br/></strong>        copy_with_lease(blob_name, blob_etag)                           except:                               <br/>    logging.info("copy failed")</span></pre><p id="c683" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">在前两章中，我们讨论了当生产者使用ADFv2向数据湖添加新数据时，如何创建快照和增量备份。但是，也可能需要触发基于时间的快照/增量备份。这将在下一章讨论。</p><h1 id="35f5" class="lf kj it bd kk lg lh li kn lj lk ll kq jz lm ka ku kc ln kd ky kf lo kg lc lp bi translated">4.基于时间的触发快照/增量备份请求</h1><p id="54fe" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly kr lz ma mb kv mc md me kz mf mg mh mi im bi translated">在第2章中，讨论了生产者如何创建基于事件的快照/增量备份请求。然而，还需要能够创建丢失快照和/或丢失备份的协调脚本。当生产者忘记将Azure功能添加到其摄取管道和/或脚本无法运行时，会发生这种情况。为了创建基于时间的功能，应部署以下内容:</p><ul class=""><li id="b286" class="mj mk it ls b lt ml lw mm kr mn kv mo kz mp mi mq mr ms mt bi translated">将下面的<a class="ae le" href="https://github.com/rebremer/blog-snapshotbackup-azuredatalake/tree/master/blog-snapshots-func/HttpSnapshotIncBackupStorageReconciliation" rel="noopener ugc nofollow" target="_blank">脚本</a>部署为Python中的Azure函数。可以使用与步骤2中相同的应用服务计划。</li><li id="dc35" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">确保正确填写所有必需的应用程序设置，参见<a class="ae le" href="https://github.com/rebremer/blog-snapshotbackup-azuredatalake/blob/master/blog-snapshots-func/appsettings.txt" rel="noopener ugc nofollow" target="_blank">此处</a></li></ul><p id="60c6" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">现在，管理员可以将协调脚本配置为定期运行，以便创建快照并发送增量备份请求，另请参见下文。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oe"><img src="../Images/4469c319d47f684ebce5bcf2ea92524c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9VTxx1mKVdbOrLtWTXChCw.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">4.基于时间的触发快照/增量备份请求</p></figure><p id="a22a" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated"><a class="ae le" href="https://github.com/rebremer/blog-snapshotbackup-azuredatalake/blob/master/blog-snapshots-func/HttpSnapshotIncBackupStorageReconciliation/__init__.py" rel="noopener ugc nofollow" target="_blank">脚本httpsnapshotincbackupstoragereconcing</a>的内部工作原理可以解释如下:</p><ul class=""><li id="f74f" class="mj mk it ls b lt ml lw mm kr mn kv mo kz mp mi mq mr ms mt bi translated">0.基于初始化快照/备份时间的脚本通过将blob的<a class="ae le" href="https://docs.microsoft.com/en-us/azure/storage/common/storage-concurrency#optimistic-concurrency-for-blobs-and-containers" rel="noopener ugc nofollow" target="_blank"> ETag </a>与以前的快照(如果有)进行比较，来检查存储帐户中修改的/新的blob。在它检测到修改的/新的斑点的情况下，完成以下2个步骤:</li><li id="bb04" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">1a。如果它检测到还没有快照的修改的/新的blob，则创建新的快照:</li><li id="5eb0" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">1b。如果它检测到还没有增量备份的修改的/新的blob，则发送新的备份请求消息</li></ul><p id="4ab5" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">脚本的核心如下:</p><pre class="nd ne nf ng gt nt nu nv nw aw nx bi"><span id="0759" class="ki kj it nu b gy ny nz l oa ob"><strong class="nu iu"># Get all containers in storage account</strong><br/>container_list = client_source.list_containers()<br/>for container in container_list:<br/>    <strong class="nu iu"># Get all blobs in container<br/></strong>    prev_blob_name = ""<br/>    prev_blob_etag = ""<br/>    blob_list = container.list_blobs(include=['snapshots'])<br/>    for blob in blob_list:<br/>        if blob.snapshot == None:<br/>            <strong class="nu iu"># Blob that is not snapshot<br/>            # 1. Check if snapshot needs to be created<br/> </strong>           if prev_blob_name != blob.name: <br/>                <strong class="nu iu"># New blob without snapshot, create snapshot</strong><br/>                create_snapshot(blob.name, blob.etag)<br/>            elif prev_blob_etag != blob.etag:<br/>                <strong class="nu iu"># Existing blob that has changed, create snapshot<br/>                </strong>create_snapshot(blob.name, blob.etag)</span><span id="c8c9" class="ki kj it nu b gy oc nz l oa ob"><strong class="nu iu">            # 2. Check if incremental backup needs to be created</strong><br/><strong class="nu iu">            # Check if blob exists in backup<br/>            </strong>blob_exists = check_blob_exists(blob.name, blob.etag)<br/>            if blob_exists == False:         <br/><strong class="nu iu">                # Not in backup, put backup request message on queue</strong><br/>                queue_json = "{" + "\"container\":\"{}\",<br/>                \"blob_name\":\"{}\", \"etag\":\"{}\""<br/>                .format(container.name, blob.name, blob.etag) + "}"<br/>                queue_service.put_message(queue, queue_json)                <br/><br/>        prev_blob_name = blob.name<br/>        prev_blob_etag = blob.etag</span></pre><h1 id="a639" class="lf kj it bd kk lg lh li kn lj lk ll kq jz lm ka ku kc ln kd ky kf lo kg lc lp bi translated">5.结论</h1><p id="f151" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly kr lz ma mb kv mc md me kz mf mg mh mi im bi translated">Azure存储始终存储您的数据的多个副本，地理冗余存储(GRS)在成对的区域中额外存储副本。但是，GRS存储不能保护因应用程序错误而损坏的数据。然后，损坏的数据会被复制到其他分区和区域。可以防止数据损坏的两种方法如下:</p><ul class=""><li id="ed11" class="mj mk it ls b lt ml lw mm kr mn kv mo kz mp mi mq mr ms mt bi translated">快照创建:一旦添加或修改了blob，就会为当前情况创建一个快照。</li><li id="e1ae" class="mj mk it ls b lt mu lw mv kr mw kv mx kz my mi mq mr ms mt bi translated">增量备份:一旦添加或修改了一个blob，就会创建该blob到另一个存储帐户的增量备份。</li></ul><p id="2f6d" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly kr mz ma mb kv na md me kz nb mg mh mi im bi translated">在这篇博客中，我们讨论了如何使用github 中的脚本创建同步快照和异步增量备份。另请参见下文描述的扩展高级概述。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi of"><img src="../Images/c4eb1dea80eeb1676ba6f80e463f2e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZZeT7gAuJY7vSDTeqfmIvg.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">1.数据湖备份—高级概述扩展</p></figure></div></div>    
</body>
</html>