<html>
<head>
<title>Standard SQL in Google BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google BigQuery中的标准SQL</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/standard-sql-in-google-bigquery-c2636ae4b7c8?source=collection_archive---------8-----------------------#2020-04-23">https://towardsdatascience.com/standard-sql-in-google-bigquery-c2636ae4b7c8?source=collection_archive---------8-----------------------#2020-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/36b25a87a0c5e23948046e6d2ce0d588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0fNfnacQq47eo0uo3OMuQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://ru.depositphotos.com/174010544/stock-photo-web-developer-php-code-close.html" rel="noopener ugc nofollow" target="_blank">沉积照片</a></p></figure><div class=""/><div class=""><h2 id="363c" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">在市场营销中使用的优势和示例</h2></div><p id="2012" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2016年，Google BigQuery引入了一种新的与表交流的方式:标准SQL。在那之前，BigQuery有自己的结构化查询语言，称为BigQuery SQL(现在称为Legacy SQL)。</p><p id="3cf4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">乍一看，传统SQL和标准SQL没有太大的区别:表名的写法略有不同；标准有稍微严格的语法要求(例如，不能在FROM前加逗号)和更多的数据类型。但如果你仔细观察，会发现一些微小的语法变化给营销人员带来了许多优势。</p><p id="3ca5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在OWOX上，我们决定澄清以下问题的答案:</p><ul class=""><li id="858f" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">标准SQL相对于传统SQL的优势是什么？</li><li id="4ce1" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">标准SQL有哪些功能，如何使用？</li><li id="7ba6" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如何从传统SQL迁移到标准SQL？</li><li id="eeea" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">标准SQL还兼容哪些服务、语法特性、操作符和函数？</li><li id="b68f" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如何对营销报告使用SQL查询？</li></ul><h1 id="c3a8" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">标准SQL相对于传统SQL的优势是什么？</h1><h2 id="cf14" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">新数据类型:数组和嵌套字段</h2><p id="cc30" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">标准SQL支持新的数据类型:数组和结构(数组和嵌套字段)。这意味着在BigQuery中，使用从JSON/Avro文件加载的表变得更加容易，这些表通常包含多级附件。</p><p id="d103" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嵌套字段是较大表格中的小型表格:</p><figure class="ns nt nu nv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nr"><img src="../Images/bd59901922f8260cee83308f004b6620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WzuIGbHc0vdeYvH7.png"/></div></div></figure><p id="be5d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上图中，蓝色和黄色条是嵌入迷你表格的线条。每行是一个会话。会话有共同的参数:日期、ID号、用户设备类别、浏览器、操作系统等。除了每个会话的常规参数之外，还将命中数表附加到该行。</p><figure class="ns nt nu nv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/ce0a8e4e0f31a2b853047b8afb98031a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ie5JOLJCdU6buGLW.jpg"/></div></div></figure><p id="e821" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">点击数表包含用户在网站上的操作信息。例如，如果用户单击横幅、翻阅目录、打开产品页面、将产品放入购物篮或下订单，这些操作将被记录在hits表中。</p><p id="1532" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果用户在网站上下订单，关于订单的信息也将输入到hits表中:</p><ul class=""><li id="9718" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">transactionId(标识交易的编号)</li><li id="20ff" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">transactionRevenue(订单总值)</li><li id="c96f" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">交易装运(运输成本)</li></ul><p id="839e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用OWOX BI收集的会话数据表具有类似的结构。</p><p id="cb13" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您想知道过去一个月来自纽约市用户的订单数量。要找出答案，您需要参考hits表并计算唯一事务id的数量。为了从这样的表中提取数据，标准SQL有一个UNNEST函数:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="2f03" class="na mj jj ny b gy oc od l oe of">#standardSQL <br/><strong class="ny jk">SELECT</strong> <br/><strong class="ny jk">COUNT</strong> (<strong class="ny jk">DISTINCT</strong> hits.transaction.transactionId) -- count the number of unique order numbers; DISTINCT helps to avoid duplication<br/><strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_*` -- refer to the table group (wildcard tables)<br/><strong class="ny jk">WHERE</strong> <br/>  (<br/>  _TABLE_SUFFIX <strong class="ny jk">BETWEEN</strong> FORMAT_DATE('%Y%m%d',<strong class="ny jk">DATE_SUB</strong>(<strong class="ny jk">CURRENT_DATE</strong>(),   INTERVAL 1 <strong class="ny jk">MONTHS</strong>)) -- if we don’t know which dates we need, it’s better to use the function FORMAT_DATE INTERVAL <br/>  <strong class="ny jk">AND</strong><br/>  FORMAT_DATE('%Y%m%d',<strong class="ny jk">DATE_SUB</strong>(<strong class="ny jk">CURRENT_DATE</strong>(), INTERVAL 1 <strong class="ny jk">DAY</strong>)) <br/>  ) <br/><strong class="ny jk">AND</strong> geoNetwork.city = ‘<strong class="ny jk">New</strong> York’ -- choose orders made in New York City</span></pre><p id="165b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果订单信息记录在单独的表中，而不是在嵌套表中，则必须使用JOIN将包含订单信息的表和包含会话数据的表组合起来，以便找出订单是在哪个会话中生成的。</p><h2 id="2b64" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">更多子查询选项</h2><p id="3aee" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">如果需要从多级嵌套字段中提取数据，可以使用SELECT和WHERE添加子查询。例如，在OWOX BI会话流表中，另一个子表product被写入hits子表。product子表收集通过增强的电子商务数组传输的产品数据。如果网站上建立了增强型电子商务，并且用户已经查看了产品页面，则该产品的特征将被记录在产品子表中。</p><p id="d0db" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了获得这些产品特征，在主查询中需要一个子查询。对于每个产品特性，在括号中会创建一个单独的选择子查询:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="6338" class="na mj jj ny b gy oc od l oe of"><strong class="ny jk">SELECT</strong> <br/>  column_name1, -- list the other columns you want to receive<br/>  column_name2,<br/>  (<strong class="ny jk">SELECT</strong> productBrand <strong class="ny jk">FROM</strong> UNNEST(hits.product)) <strong class="ny jk">AS</strong>    hits_product_productBrand,<br/>  (<strong class="ny jk">SELECT</strong> productRevenue <strong class="ny jk">FROM</strong> UNNEST(hits.product)) <strong class="ny jk">AS</strong> hits_product_productRevenue, -- list product features<br/>  (<strong class="ny jk">SELECT</strong> localProductRevenue <strong class="ny jk">FROM</strong> UNNEST(hits.product)) <strong class="ny jk">AS</strong> hits_product_localProductRevenue,<br/>  (<strong class="ny jk">SELECT</strong> productPrice <strong class="ny jk">FROM</strong> UNNEST(hits.product)) <strong class="ny jk">AS</strong> hits_product_productPrice,<br/><strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_YYYYMMDD`</span></pre><p id="709d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于标准SQL的功能，构建查询逻辑和编写代码变得更加容易。相比之下，在遗留SQL中，您需要编写这种类型的阶梯:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="a63c" class="na mj jj ny b gy oc od l oe of"><strong class="ny jk">SELECT</strong> <br/>  column_name1,<br/>  column_name2, <br/>  column_name3 <br/><strong class="ny jk">FROM</strong> (<br/>  <strong class="ny jk">SELECT</strong> table_name.some_column <strong class="ny jk">AS</strong> column1…<br/>  <strong class="ny jk">FROM</strong> table_name<br/>)</span></pre><h2 id="2cc5" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">对外部来源的请求</h2><p id="6db6" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">使用标准SQL，您可以直接从Google Bigtable、Google Cloud Storage、Google Drive和Google Sheets访问BigQuery表。<br/>也就是说，不用将整个表加载到BigQuery中，只需一次查询就可以删除数据，选择需要的参数，上传到云存储。</p><h2 id="8ad0" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">更多用户功能(UDF)</h2><p id="7e91" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">如果你需要使用一个没有记录的公式，用户定义函数(UDF)会帮助你。在我们的实践中，这种情况很少发生，因为标准的SQL文档几乎涵盖了数字分析的所有任务。</p><p id="1a54" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在标准SQL中，用户自定义函数可以用SQL或JavaScript编写；传统SQL只支持JavaScript。这些函数的参数是列，它们取的值是操作列的结果。在标准SQL中，函数可以在与查询相同的窗口中编写。</p><h2 id="e953" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">更多连接条件</h2><p id="f3a9" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">在传统SQL中，连接条件可以基于等式或列名。除了这些选项之外，标准SQL方言还支持通过不等式和任意表达式进行连接。</p><p id="f4cf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，为了识别不公平的CPA伙伴，我们可以选择在交易的60秒内源被替换的会话。要在标准SQL中做到这一点，我们可以在连接条件中添加一个不等式:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="989c" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong> *<br/><strong class="ny jk">FROM</strong> <br/>  (<br/>  <strong class="ny jk">SELECT</strong><br/>  traff.clientId <strong class="ny jk">AS</strong> clientId,<br/>  traff.page_path <strong class="ny jk">AS</strong> pagePath,<br/>  traff.traffic_source <strong class="ny jk">AS</strong> startSource,<br/>  traff.traffic_medium <strong class="ny jk">AS</strong> startMedium,<br/>  traff.time <strong class="ny jk">AS</strong> startTime,<br/>  aff.evAction <strong class="ny jk">AS</strong> evAction,<br/>  aff.evSource <strong class="ny jk">AS</strong> finishSource,<br/>  aff.evMedium <strong class="ny jk">AS</strong> finishMedium,<br/>  aff.evCampaign <strong class="ny jk">AS</strong> finishCampaign,<br/>  aff.time <strong class="ny jk">AS</strong> finishTime,<br/>  aff.isTransaction <strong class="ny jk">AS</strong> isTransaction,<br/>  aff.pagePath <strong class="ny jk">AS</strong> <strong class="ny jk">link</strong>,<br/>  traff.time-aff.time <strong class="ny jk">AS</strong> diff<br/>  <strong class="ny jk">FROM</strong><br/>    (<br/>    <strong class="ny jk">SELECT</strong> <br/>    fullVisitorID <strong class="ny jk">AS</strong> clientId,<br/>    h.page.pagePath <strong class="ny jk">AS</strong> page_path,<br/>    trafficSource.source <strong class="ny jk">AS</strong> traffic_source,<br/>    trafficSource.medium <strong class="ny jk">AS</strong> traffic_medium,<br/>    trafficSource.campaign <strong class="ny jk">AS</strong> traffic_campaign,<br/>    date,<br/>    SAFE_CAST(visitStartTime+h.time/1000 <strong class="ny jk">AS</strong> INT64) <strong class="ny jk">AS</strong> <strong class="ny jk">time</strong><br/>      <strong class="ny jk">FROM</strong> `demoproject.google_analytics_sample.ga_sessions_20190301`,<br/>      UNNEST (hits) <strong class="ny jk">AS</strong> h<br/>      <strong class="ny jk">WHERE</strong> trafficSource.medium != 'cpa'<br/>      ) <strong class="ny jk">AS</strong> traff<br/><strong class="ny jk">JOIN</strong> (<br/>  <strong class="ny jk">SELECT</strong> <br/>  total.date date,<br/>  total.time <strong class="ny jk">time</strong>,<br/>  total.clientId <strong class="ny jk">AS</strong> clientId,<br/>  total.eventAction <strong class="ny jk">AS</strong> evAction,<br/>  total.source <strong class="ny jk">AS</strong> evSource,<br/>  total.medium <strong class="ny jk">AS</strong> evMedium,<br/>  total.campaign <strong class="ny jk">AS</strong> evCampaign,<br/>  tr.eventAction <strong class="ny jk">AS</strong> isTransaction,<br/>  total.page_path <strong class="ny jk">AS</strong> pagePath<br/>  <strong class="ny jk">FROM</strong> <br/>  (<br/>  <strong class="ny jk">SELECT</strong> <br/>  fullVisitorID <strong class="ny jk">AS</strong> clientId,<br/>  h.page.pagePath <strong class="ny jk">AS</strong> page_path,<br/>  h.eventInfo.eventAction <strong class="ny jk">AS</strong> eventAction, <br/>  trafficSource.source <strong class="ny jk">AS</strong> <strong class="ny jk">source</strong>,<br/>  trafficSource.medium <strong class="ny jk">AS</strong> <strong class="ny jk">medium</strong>,<br/>  trafficSource.campaign <strong class="ny jk">AS</strong> campaign,<br/>  date,<br/>  SAFE_CAST(visitStartTime+h.time/1000 <strong class="ny jk">AS</strong> INT64) <strong class="ny jk">AS</strong> <strong class="ny jk">time</strong><br/>  <strong class="ny jk">FROM</strong> `demoproject.google_analytics_sample.ga_sessions_20190301`,<br/>  UNNEST(hits) <strong class="ny jk">AS</strong> h<br/>    <strong class="ny jk">WHERE</strong><br/>    trafficSource.medium ='cpa'<br/>    ) <strong class="ny jk">AS</strong> total<br/><strong class="ny jk">LEFT</strong> <strong class="ny jk">JOIN</strong> <br/>  (<br/>  <strong class="ny jk">SELECT</strong><br/>  fullVisitorID <strong class="ny jk">AS</strong> clientId,<br/>  date,<br/>  h.eventInfo.eventAction <strong class="ny jk">AS</strong> eventAction,<br/>  h.page.pagePath pagePath,<br/>  SAFE_CAST(visitStartTime+h.time/1000 <strong class="ny jk">AS</strong> INT64) <strong class="ny jk">AS</strong> <strong class="ny jk">time</strong><br/>  <strong class="ny jk">FROM</strong> `demoproject.google_analytics_sample.ga_sessions_20190301`,<br/>  UNNEST(hits) <strong class="ny jk">AS</strong> h<br/>  <strong class="ny jk">WHERE</strong> h.eventInfo.eventAction = 'typ_page'<br/>  <strong class="ny jk">AND</strong> h.type = 'EVENT'<br/>  <strong class="ny jk">GROUP</strong> <strong class="ny jk">BY</strong> 1, 2, 3, 4, 5<br/>  ) <strong class="ny jk">AS</strong> tr<br/><strong class="ny jk">ON</strong> total.clientId=tr.clientId<br/><strong class="ny jk">AND</strong> total.date=tr.date<br/><strong class="ny jk">AND</strong> tr.time&gt;total.time -- JOIN tables by inequality. Pass the additional WHERE clause that was needed in Legacy SQL<br/><strong class="ny jk">WHERE</strong> tr.eventAction = 'typ_page'<br/>  ) <strong class="ny jk">AS</strong> aff<br/><strong class="ny jk">ON</strong> traff.clientId = aff.clientId<br/>)<br/><strong class="ny jk">WHERE</strong> diff&gt; -60<br/><strong class="ny jk">AND</strong> diff&lt;0<br/>  <strong class="ny jk">GROUP</strong> <strong class="ny jk">BY</strong> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13<br/>  <strong class="ny jk">ORDER</strong> <strong class="ny jk">BY</strong> clientId, finishTime</span></pre><p id="153a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">标准SQL在连接方面的唯一限制是，它不允许使用WHERE column IN (SELECT …)形式的子查询进行半连接:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="cb83" class="na mj jj ny b gy oc od l oe of">#legacySQL<br/><strong class="ny jk">SELECT</strong><br/>  mother_age,<br/>  <strong class="ny jk">COUNT</strong>(mother_age) total<br/><strong class="ny jk">FROM</strong><br/>  [bigquery-<strong class="ny jk">public</strong>-<strong class="ny jk">data</strong>:samples.natality]<br/><strong class="ny jk">WHERE</strong> -- such a construction cannot be used in Standard SQL<br/>  state <strong class="ny jk">IN</strong> (<strong class="ny jk">SELECT</strong><br/>              state<br/>            <strong class="ny jk">FROM</strong><br/>              (<strong class="ny jk">SELECT</strong><br/>                 state,<br/>                 <strong class="ny jk">COUNT</strong>(state) total<br/>               <strong class="ny jk">FROM</strong><br/>                 [bigquery-<strong class="ny jk">public</strong>-<strong class="ny jk">data</strong>:samples.natality]<br/>               <strong class="ny jk">GROUP</strong> <strong class="ny jk">BY</strong><br/>                 state<br/>               <strong class="ny jk">ORDER</strong> <strong class="ny jk">BY</strong><br/>                 total <strong class="ny jk">DESC</strong><br/>               <strong class="ny jk">LIMIT</strong> 10))<br/>  <strong class="ny jk">AND</strong> mother_age &gt; 50<br/><strong class="ny jk">GROUP</strong> <strong class="ny jk">BY</strong><br/>  mother_age<br/><strong class="ny jk">ORDER</strong> <strong class="ny jk">BY</strong><br/>  mother_age <strong class="ny jk">DESC</strong></span></pre><h2 id="3413" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">出错的可能性更小</h2><p id="f373" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">如果条件不正确，传统SQL中的某些函数会返回NULL。例如，如果您的计算中出现了被零除的情况，查询将被执行，空条目将出现在表的结果行中。这可能会掩盖查询或数据中的问题。</p><p id="eed3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">标准SQL的逻辑更简单。如果条件或输入数据不正确，查询将生成错误，例如被零除，因此您可以快速更正查询。以下检查嵌入在标准SQL中:</p><ul class=""><li id="a62b" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">+、-、×、总和、AVG、标准偏差的有效值</li><li id="5a95" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">被零除</li></ul><h2 id="d36d" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">请求运行更快</h2><p id="accd" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">由于对传入数据进行了初步过滤，用标准SQL编写的连接查询比用传统SQL编写的连接查询要快。首先，查询选择符合连接条件的行，然后处理它们。未来，Google BigQuery将致力于提高标准SQL的查询速度和性能。</p><h2 id="4a5e" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">表格可以编辑:插入和删除行，更新</h2><p id="b506" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">数据操作语言(DML)函数在标准SQL中可用。这意味着您可以通过编写查询的同一个窗口来更新表以及在表中添加或删除行。例如，使用DML，您可以将两个表中的数据合并成一个表:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="dc71" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">MERGE</strong> dataset.Inventory <strong class="ny jk">AS</strong> T<br/><strong class="ny jk">USING</strong> dataset.NewArrivals <strong class="ny jk">AS</strong> S<br/><strong class="ny jk">ON</strong> T.ProductID = S.ProductID<br/><strong class="ny jk">WHEN</strong> <strong class="ny jk">MATCHED</strong> <strong class="ny jk">THEN</strong><br/>  <strong class="ny jk">UPDATE</strong> <strong class="ny jk">SET</strong> quantity = T.quantity + S.quantity<br/><strong class="ny jk">WHEN</strong> <strong class="ny jk">NOT</strong> <strong class="ny jk">MATCHED</strong> <strong class="ny jk">THEN</strong><br/>  <strong class="ny jk">INSERT</strong> (ProductID, quantity) <strong class="ny jk">VALUES</strong> (ProductID, quantity)</span></pre><h2 id="bc6c" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">代码更容易阅读和编辑</h2><p id="97ee" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">使用标准SQL，复杂的查询不仅可以用SELECT启动，还可以用With启动，从而使代码更易于阅读、注释和理解。这也意味着更容易防止自己的错误和纠正别人的错误。</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="fbde" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/>WITH total_1 AS ( -- the first subquery in which the intermediate indicator will be calculated<br/>    <strong class="ny jk">SELECT</strong><br/>        <strong class="ny jk">id</strong>,<br/>        metric1,<br/>       <strong class="ny jk">SUM</strong>(metric2) <strong class="ny jk">AS</strong> total_sum1<br/>    <strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_YYYYMMDD`<br/>    <strong class="ny jk">GROUP</strong> <strong class="ny jk">BY</strong><br/>        <strong class="ny jk">id</strong>, metric<br/>),<br/>total_2 <strong class="ny jk">AS</strong> ( -- the second subquery<br/>    <strong class="ny jk">SELECT</strong><br/>        <strong class="ny jk">id</strong>,<br/>        metric1,<br/>        <strong class="ny jk">SUM</strong>(metric2) <strong class="ny jk">AS</strong> total_sum2<br/>    <strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_YYYYMMDD`<br/>           <strong class="ny jk">GROUP</strong> <strong class="ny jk">BY</strong><br/>        <strong class="ny jk">id</strong>, metric1<br/>),<br/>total_3 <strong class="ny jk">AS</strong> ( -- the third subquery<br/>    <strong class="ny jk">SELECT</strong><br/>        <strong class="ny jk">id</strong>,<br/>        metric,<br/>       <strong class="ny jk">SUM</strong>(metric2) <strong class="ny jk">AS</strong> total_sum3<br/>       <strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_YYYYMMDD`<br/>    <strong class="ny jk">GROUP</strong> <strong class="ny jk">BY</strong><br/>        <strong class="ny jk">id</strong>, metric<br/>)<br/><strong class="ny jk">SELECT</strong> *,<br/><strong class="ny jk">ROUND</strong>(100*( total_2.total_sum2 - total_3.total_sum3) / total_3.total_sum3, 3) <strong class="ny jk">AS</strong> <strong class="ny jk">difference</strong> -- get the difference index: subtract the value of the second subquery from the value of the third; divide by the value of the third <br/><strong class="ny jk">FROM</strong> total_1<br/><strong class="ny jk">ORDER</strong>  <strong class="ny jk">BY</strong> 1, 2</span></pre><p id="d8fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果有分几个阶段完成的计算，使用with运算符会很方便。首先，您可以在子查询中收集中间指标，然后进行最终计算。</p><p id="4edf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">谷歌云平台(GCP)包括BigQuery，是一个处理大数据的全周期平台，从组织数据仓库或数据云到运行科学实验以及预测和说明性分析。随着标准SQL的引入，BigQuery正在扩大其受众。对于营销分析师、产品分析师、数据科学家和其他专家团队来说，与GCP合作正变得越来越有趣。</p><h1 id="cf54" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">标准SQL的功能和用例示例</h1><p id="4dbf" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">在OWOX BI，我们经常使用使用标准的Google Analytics 360 export to Google big query或OWOX BI管道编译的表。在下面的例子中，我们将研究针对这些数据的SQL查询的细节。</p><h2 id="df2a" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">1.选择时间间隔的数据</h2><p id="90c5" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">在Google BigQuery中，您站点的用户行为数据存储在通配符表中(带星号的表)；每天形成一个单独的表。这些表的名称相同:只是后缀不同。后缀是YYYYMMDD格式的日期。例如，表owoxbi_sessions_20190301包含2019年3月1日的会话数据。</p><p id="8030" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在一个请求中直接引用一组这样的表，以便获得数据，例如，从2019年2月1日到2月28日。为此，我们需要在FROM中用*替换YYYYMMDD，在WHERE中，我们需要为时间间隔的开始和结束指定表后缀:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="222e" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong> sessionId, <br/><strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_*`<br/><strong class="ny jk">WHERE</strong> _TABLE_SUFFIX <strong class="ny jk">BETWEEN</strong> �' AND �'</span></pre><p id="5095" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们并不总是知道收集数据的具体日期。例如，每周我们可能需要分析过去三个月的数据。为此，我们可以使用FORMAT_DATE函数:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="5d72" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong><br/> &lt;enumerate <strong class="ny jk">field</strong> <strong class="ny jk">names</strong>&gt;<br/><strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_*`<br/><strong class="ny jk">WHERE</strong> <br/>_TABLE_SUFFIX <strong class="ny jk">BETWEEN</strong> FORMAT_DATE('%Y%m%d',<strong class="ny jk">DATE_SUB</strong>(<strong class="ny jk">CURRENT_DATE</strong>(), INTERVAL 3 <strong class="ny jk">MONTHS</strong>))<br/><strong class="ny jk">AND</strong><br/>FORMAT_DATE('%Y%m%d',<strong class="ny jk">DATE_SUB</strong>(<strong class="ny jk">CURRENT_DATE</strong>(), INTERVAL 1 <strong class="ny jk">DAY</strong>))</span></pre><p id="37ea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在BETWEEN之后，我们记录第一个表的后缀。短语CURRENT_DATE()，INTERVAL 3 MONTHS表示从当前日期开始选择最近3个月的数据。第二个表后缀在和之后格式化。需要将间隔的结束标记为昨天:CURRENT_DATE()，间隔1天。</p><h2 id="7ed1" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">2.检索用户参数和指标</h2><p id="bef4" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">Google Analytics导出表中的用户参数和指标被写入嵌套的hits表以及customDimensions和customMetrics子表。所有定制维度都记录在两列中:一列是站点上收集的参数数量，另一列是它们的值。下面是一次点击传输的所有参数的样子:</p><figure class="ns nt nu nv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi og"><img src="../Images/73a3394a539a8c4eea6cc2816fd221f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f3o57ZpACrLGYWiQ.png"/></div></div></figure><p id="b34a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了将它们解包并在单独的列中写入必要的参数，我们使用以下SQL查询:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="64e0" class="na mj jj ny b gy oc od l oe of">-- Custom Dimensions (in the line below index - the number of the user variable, which is set in the Google Analytics interface; dimension1 is the name of the custom parameter, which you can change as you like. For each subsequent parameter, you need to write the same line:</span><span id="22a0" class="na mj jj ny b gy oh od l oe of">  (<strong class="ny jk">SELECT</strong> <strong class="ny jk">MAX</strong>(<strong class="ny jk">IF</strong>(<strong class="ny jk">index</strong>=1, <strong class="ny jk">value</strong>, NULL)) <strong class="ny jk">FROM</strong> UNNEST(hits.customDimensions)) <strong class="ny jk">AS</strong> dimension1, <br/>-- Custom Metrics: the index below is the number of the user metric specified in the Google Analytics interface; metric1 is the name of the metric, which you can change as you like. For each of the following metrics, you need to write the same line: </span><span id="6f27" class="na mj jj ny b gy oh od l oe of">  (<strong class="ny jk">SELECT</strong> <strong class="ny jk">MAX</strong>(<strong class="ny jk">IF</strong>(<strong class="ny jk">index</strong>=1, <strong class="ny jk">value</strong>, NULL)) <strong class="ny jk">FROM</strong> UNNEST(hits.customMetrics)) <strong class="ny jk">AS</strong> metric1</span></pre><p id="a310" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请求看起来是这样的:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="f0ac" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong> &lt;<strong class="ny jk">column</strong> name1&gt;,<br/>&lt;column_name2&gt;, -- list column names<br/>(<strong class="ny jk">SELECT</strong> <strong class="ny jk">MAX</strong>(<strong class="ny jk">IF</strong>(<strong class="ny jk">index</strong>=1, <strong class="ny jk">value</strong>, NULL)) <strong class="ny jk">FROM</strong> UNNEST(hits.customDimensions)) <strong class="ny jk">AS</strong> page_type,<br/>(<strong class="ny jk">SELECT</strong> <strong class="ny jk">MAX</strong>(<strong class="ny jk">IF</strong>(<strong class="ny jk">index</strong>=2, <strong class="ny jk">value</strong>, NULL)) <strong class="ny jk">FROM</strong> UNNEST(hits.customDimensions)) <strong class="ny jk">AS</strong> visitor_type, -- produce the necessary custom dimensions<br/>(<strong class="ny jk">SELECT</strong> <strong class="ny jk">MAX</strong>(<strong class="ny jk">IF</strong>(<strong class="ny jk">index</strong>=1, <strong class="ny jk">value</strong>, NULL)) <strong class="ny jk">FROM</strong> UNNEST(hits.customMetrics)) <strong class="ny jk">AS</strong> metric1 -- produce the necessary custom metrics<br/>&lt;column_name3&gt; -- if you need more columns, continue to list<br/><strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_20190201`</span></pre><p id="dc10" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的截图中，我们从Google BigQuery中的Google Analytics 360演示数据中选择了参数1和2，并将其命名为page_type和client_id。每个参数都记录在单独的列中:</p><figure class="ns nt nu nv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/7436240c16098640f8ae49200d649b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kMysYRkYYIDInMOD.png"/></div></div></figure><h2 id="7aca" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">3.按流量来源、渠道、活动、城市和设备类别计算会话数量</h2><p id="51bc" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">如果您计划在Google Data Studio中可视化数据，并按城市和设备类别进行过滤，这样的计算非常有用。使用计数窗口功能很容易做到这一点:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="ad50" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong><br/>&lt;column_name 1&gt;, -- choose any columns <br/><strong class="ny jk">COUNT</strong> (<strong class="ny jk">DISTINCT</strong> sessionId) <strong class="ny jk">AS</strong> total_sessions, -- summarize the session IDs to find the total number of sessions<br/><strong class="ny jk">COUNT</strong>(<strong class="ny jk">DISTINCT</strong> sessionId) <strong class="ny jk">OVER</strong>(<strong class="ny jk">PARTITION</strong> <strong class="ny jk">BY</strong> date, geoNetwork.city, session.device.deviceCategory, trafficSource.source, trafficSource.medium, trafficSource.campaign) <strong class="ny jk">AS</strong> part_sessions -- summarize the number of sessions by campaign, channel, traffic source, city, and device category<br/><strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_20190201`</span></pre><h2 id="15e0" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">4.合并几个表中的相同数据</h2><p id="598c" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">假设您在几个BigQuery表中收集已完成订单的数据:一个收集来自商店A的所有订单，另一个收集来自商店b的订单。您希望将它们合并到一个包含以下列的表中:</p><ul class=""><li id="31ee" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">client _ id——标识唯一购买者的号码</li><li id="65ca" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">transaction_created —时间戳格式的订单创建时间</li><li id="3696" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">交易标识—订单编号</li><li id="9073" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">is_approved —订单是否已确认</li><li id="0b64" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">交易_收入—订单金额</li></ul><p id="e0e3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的示例中，从2018年1月1日到昨天的订单必须在表中。为此，从每组表中选择适当的列，为它们指定相同的名称，并用UNION ALL合并结果:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="fc0c" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong> <br/>cid <strong class="ny jk">AS</strong> client_id, <br/>order_time <strong class="ny jk">AS</strong> transaction_created,<br/>order_status <strong class="ny jk">AS</strong> is_approved,<br/>order_number <strong class="ny jk">AS</strong> transaction_id<br/><strong class="ny jk">FROM</strong> `project_name.dataset_name.table1_*`<br/><strong class="ny jk">WHERE</strong> (<br/>  _TABLE_SUFFIX <strong class="ny jk">BETWEEN</strong> �'<br/>  AND<br/>  FORMAT_DATE('%Y%m%d',DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY))<br/>  )</span><span id="43e3" class="na mj jj ny b gy oh od l oe of">UNION ALL <br/>SELECT<br/>userId AS client_id,<br/>created_timestamp AS transaction_created,<br/>operator_mark AS  is_approved,<br/>transactionId AS transaction_id<br/>FROM `project_name.dataset_name.table1_*`<br/>WHERE (<br/>  _TABLE_SUFFIX BETWEEN �'<br/>  <strong class="ny jk">AND</strong><br/>  FORMAT_DATE('%Y%m%d',<strong class="ny jk">DATE_SUB</strong>(<strong class="ny jk">CURRENT_DATE</strong>(), INTERVAL 1 <strong class="ny jk">DAY</strong>))<br/>  )<br/><strong class="ny jk">ORDER</strong> <strong class="ny jk">BY</strong> transaction_created <strong class="ny jk">DESC</strong></span></pre><h2 id="21d3" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">5.创建业务信道组的字典</h2><p id="8dd7" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">当数据进入Google Analytics时，系统会自动确定特定转换所属的群体:直接搜索、有机搜索、付费搜索等等。为了识别一组频道，Google Analytics查看转换的UTM标签，即utm_source和utm_medium。你可以在谷歌分析帮助中阅读更多关于渠道组和定义规则的内容。</p><p id="03cb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果OWOX BI客户端想要将它们自己的名称分配给通道组，我们创建一个字典，哪个转换属于一个特定的通道。为此，我们使用条件CASE操作符和REGEXP_CONTAINS函数。此函数选择指定正则表达式出现的值。</p><p id="e8f3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们建议从您的谷歌分析来源列表中选择姓名。以下是如何将此类条件添加到请求正文的示例:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="3876" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong> <br/><strong class="ny jk">CASE</strong> <br/><strong class="ny jk">WHEN</strong> (REGEXP_CONTAINS (<strong class="ny jk">source</strong>, 'yandex') <strong class="ny jk">AND</strong> <strong class="ny jk">medium</strong> = 'referral' <strong class="ny jk">THEN</strong> 'Organic Search' <br/><strong class="ny jk">WHEN</strong> (REGEXP_CONTAINS (<strong class="ny jk">source</strong>, 'yandex.market')) <strong class="ny jk">AND</strong> <strong class="ny jk">medium</strong> = 'referral' <strong class="ny jk">THEN</strong> 'Referral'<br/><strong class="ny jk">WHEN</strong> (REGEXP_CONTAINS (<strong class="ny jk">source</strong>, '^(go.mail.ru|google.com)$') <strong class="ny jk">AND</strong> <strong class="ny jk">medium</strong> = 'referral') <strong class="ny jk">THEN</strong> 'Organic Search'<br/><strong class="ny jk">WHEN</strong> <strong class="ny jk">medium</strong> = 'organic' <strong class="ny jk">THEN</strong> 'Organic Search'<br/><strong class="ny jk">WHEN</strong> (<strong class="ny jk">medium</strong> = 'cpc') <strong class="ny jk">THEN</strong> 'Paid Search'<br/><strong class="ny jk">WHEN</strong> REGEXP_CONTAINS (<strong class="ny jk">medium</strong>, '^(sending|email|mail)$') <strong class="ny jk">THEN</strong> 'Email'<br/>    <strong class="ny jk">WHEN</strong> REGEXP_CONTAINS (<strong class="ny jk">source</strong>, '(mail|email|Mail)') <strong class="ny jk">THEN</strong> 'Email'<br/>    <strong class="ny jk">WHEN</strong> REGEXP_CONTAINS (<strong class="ny jk">medium</strong>, '^(cpa)$') <strong class="ny jk">THEN</strong> 'Affiliate'<br/>    <strong class="ny jk">WHEN</strong> <strong class="ny jk">medium</strong> = 'social' <strong class="ny jk">THEN</strong> 'Social'<br/>    <strong class="ny jk">WHEN</strong> <strong class="ny jk">source</strong> = '(direct)' <strong class="ny jk">THEN</strong> 'Direct'<br/> <strong class="ny jk">WHEN</strong> REGEXP_CONTAINS (<strong class="ny jk">medium</strong>, 'banner|cpm') <strong class="ny jk">THEN</strong> 'Display'<br/>    <strong class="ny jk">ELSE</strong> 'Other'<br/>  <strong class="ny jk">END</strong> channel_group -- the name of the column in which the channel groups are written<br/><strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_20190201`</span></pre><h1 id="50c0" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">如何切换到标准SQL</h1><p id="ba78" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">如果您还没有切换到标准SQL，您可以在任何时候这样做。主要是避免在一个请求中混合使用方言。</p><h2 id="5518" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">备选方案1。切换到Google BigQuery界面</h2><p id="284e" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">默认情况下，在旧的BigQuery接口中使用遗留SQL。要在方言之间切换，单击查询输入字段下的<strong class="la jk">显示选项</strong>，取消选中SQL方言旁边的<strong class="la jk">使用传统SQL </strong>框。</p><figure class="ns nt nu nv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/b1cef50aae111a8571cfab1ec183d4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tvx0W9PfHCLimmtd.png"/></div></div></figure><p id="1387" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，新接口使用标准SQL。在这里，您需要转到“更多”选项卡来切换方言:</p><figure class="ns nt nu nv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/243259ec3a394e18424325d7300aaa6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B2SxiXqw2K7VSbVZ.png"/></div></div></figure><h2 id="1a80" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">选项2。在请求的开头写前缀</h2><p id="4c7a" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">如果您没有勾选请求设置，您可以从所需的前缀(#standardSQL或#legacySQL)开始:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="c6b2" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong><br/>  weight_pounds, state, <strong class="ny jk">year</strong>, gestation_weeks<br/><strong class="ny jk">FROM</strong><br/>  `bigquery-public-data.samples.natality`<br/><strong class="ny jk">ORDER</strong> <strong class="ny jk">BY</strong> weight_pounds <strong class="ny jk">DESC</strong><br/><strong class="ny jk">LIMIT</strong> 10;</span></pre><p id="4576" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，Google BigQuery将忽略界面中的设置，并使用前缀中指定的方言运行查询。</p><p id="2ad0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您有使用Apps脚本按计划启动的视图或保存的查询，请不要忘记在脚本中将useLegacySql的值更改为false:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="a21a" class="na mj jj ny b gy oc od l oe of">var job = {<br/>configuration: {<br/>  query: {<br/>    query: '<strong class="ny jk">INSERT</strong> <strong class="ny jk">INTO</strong> MyDataSet.MyFooBarTable (<strong class="ny jk">Id</strong>, Foo, Date) <strong class="ny jk">VALUES</strong> (1, \'bar\', current_Date);',<br/>    useLegacySql: false<br/>    }</span></pre><h2 id="a637" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">选项3。过渡到视图的标准SQL</h2><p id="7d18" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">如果您使用Google BigQuery而不是表，而是视图，那么这些视图就不能用标准的SQL方言访问。也就是说，如果您的演示文稿是用遗留SQL编写的，您就不能用标准SQL向它写请求。</p><p id="5b40" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要将视图转换为标准SQL，您需要手动重写创建它的查询。最简单的方法是通过BigQuery接口。</p><p id="7b59" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1.打开视图:</p><figure class="ns nt nu nv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/c7c33cefd53151cf8c1b9c648a6015df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IhoE1v1J5A7H4HVw.png"/></div></div></figure><p id="9b98" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.单击详细信息。查询文本应该会打开，下面会出现“编辑查询”按钮:</p><figure class="ns nt nu nv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/5870130684aeac3e196222f297dc4b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a0Job5fRlNPbLJ_h.png"/></div></div></figure><p id="705c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您可以根据标准SQL的规则编辑请求。<br/>如果您计划继续使用该请求作为演示文稿，请在完成编辑后单击保存视图。</p><h1 id="402c" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">兼容性、语法功能、运算符、函数</h1><h2 id="96c9" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">和睦相处</h2><p id="19b0" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">由于标准SQL的实现，您可以直接从BigQuery访问存储在其他服务中的数据:</p><ul class=""><li id="5a9c" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">Google云存储日志文件</li><li id="fb43" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">Google Bigtable中的交易记录</li><li id="589b" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">其他来源的数据</li></ul><p id="07bb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使得您可以使用谷歌云平台产品来完成任何分析任务，包括基于机器学习算法的预测和说明性分析。</p><h2 id="c8ec" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">查询语法</h2><p id="451c" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">标准方言中的查询结构几乎与传统语言中的相同:</p><p id="57bd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">表和视图的名称用句点(句号)分隔，整个查询用重音符括起来:` project _ name . data _ name _ name . table _ name ` big query-public-data . samples . natality '</p><p id="8bf4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">查询的完整语法，以及对每个操作符中可以包含的内容的解释，被编译为BigQuery文档中的一个模式。</p><p id="bf06" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">标准SQL语法的特征:</p><ul class=""><li id="4ac4" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">在SELECT语句中列出字段需要逗号。</li><li id="1c77" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果在FROM之后使用UNNEST运算符，则在UNNEST之前会放置一个逗号或连接。</li><li id="ae25" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">FROM前面不能加逗号。</li><li id="a076" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">两个查询之间的逗号相当于交叉连接，所以要小心使用。</li><li id="60d5" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">连接不仅可以通过列或等式来完成，还可以通过任意表达式和不等式来完成。</li><li id="f285" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">可以在SQL表达式的任何部分(在SELECT、FROM、WHERE等中)编写复杂的子查询。).在实践中，还不可能像在其他数据库中那样使用WHERE column_name IN (SELECT …)这样的表达式。</li></ul><h2 id="91ad" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">经营者</h2><p id="eb77" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">在标准SQL中，运算符定义数据的类型。例如，数组总是写在方括号[]中。运算符用于比较、匹配逻辑表达式(NOT、or、AND)以及算术计算。</p><h2 id="19a3" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">功能</h2><p id="3f7f" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">标准SQL比Legacy支持更多特性:传统聚合(sum、number、minimum、maximum)；数学、字符串和统计函数；以及HyperLogLog ++等罕见格式。</p><p id="97db" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在标准方言中，有更多处理日期和时间戳的函数。Google文档中提供了完整的特性列表。最常用的函数用于处理日期、字符串、聚合和窗口。</p><p id="33df" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 1。聚合函数</strong></p><p id="d2ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">COUNT (DISTINCT column_name)计算列中唯一值的数量。例如，假设我们需要统计2019年3月1日来自移动设备的会话数。由于一个会话号可以在不同的行上重复，所以我们只想计算唯一的会话号值:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="03ef" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong> <br/><strong class="ny jk">COUNT</strong> (<strong class="ny jk">DISTINCT</strong> sessionId) <strong class="ny jk">AS</strong> sessions<br/><strong class="ny jk">FROM</strong>  `project_name.dataset_name.owoxbi_sessions_20190301`<br/><strong class="ny jk">WHERE</strong> device.deviceCategory = 'mobile'</span></pre><p id="902c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SUM(column _ name)-列中值的总和</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="447e" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong> <br/><strong class="ny jk">SUM</strong> (hits.transaction.transactionRevenue) <strong class="ny jk">AS</strong> revenue<br/><strong class="ny jk">FROM</strong>  `project_name.dataset_name.owoxbi_sessions_20190301`,<br/>UNNEST (hits) <strong class="ny jk">AS</strong> hits -- unpacking the nested field hits<br/><strong class="ny jk">WHERE</strong> device.deviceCategory = 'mobile'</span></pre><p id="0fb6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">MIN(列名)| MAX(列名)-列中的最小值和最大值。这些函数便于检查表中数据的分布。</p><p id="590e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 2。窗口(分析)功能</strong></p><p id="9dff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分析函数考虑的不是整个表的值，而是某个窗口的值，即您感兴趣的一组行。也就是说，您可以在一个表中定义段。例如，您可以为城市、设备类别等计算SUM(收入),而不是为所有线路。通过向分析函数SUM、COUNT和AVG以及其他聚合函数添加OVER条件(PARTITION BY column_name ),可以转换这些函数。</p><p id="4247" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，您需要按流量来源、渠道、活动、城市和设备类别统计会话数量。在这种情况下，我们可以使用下面的表达式:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="a66b" class="na mj jj ny b gy oc od l oe of"><strong class="ny jk">SELECT</strong><br/>        date,<br/>        geoNetwork.city,<br/>        t.device.deviceCategory,<br/>        trafficSource.source,<br/>        trafficSource.medium,<br/>        trafficSource.campaign,<br/><strong class="ny jk">COUNT</strong>(<strong class="ny jk">DISTINCT</strong> sessionId) <strong class="ny jk">OVER</strong>(<strong class="ny jk">PARTITION</strong> <strong class="ny jk">BY</strong> date, geoNetwork.city, session.device.deviceCategory, trafficSource.source, trafficSource.medium, trafficSource.campaign) <strong class="ny jk">AS</strong> segmented_sessions<br/><strong class="ny jk">FROM</strong>  `project_name.dataset_name.owoxbi_sessions_20190301` t</span></pre><p id="8137" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">超过确定将进行计算的窗口。PARTITION BY指示应该对哪些行进行分组以进行计算。在某些函数中，需要用ORDER BY指定分组的顺序。</p><p id="ff7f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有关窗口函数的完整列表，请参见BigQuery文档。</p><p id="c034" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 3。字符串功能</strong></p><p id="baca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您需要更改文本、将文本格式化为一行或粘附列的值时，这些选项非常有用。例如，如果您想从标准的Google Analytics 360导出数据中生成唯一的会话标识符，字符串函数非常有用。让我们考虑一下最流行的字符串函数。</p><p id="3466" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SUBSTR剪切部分字符串。在请求中，这个函数被写成SUBSTR (string_name，0.4)。第一个数字指示从行首跳过多少个字符，第二个数字指示删除多少个数字。例如，假设您有一个日期列，其中包含字符串格式的日期。在这种情况下，日期如下所示:20190103。如果您想从这一行中提取年份，SUBSTR将帮助您:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="44ac" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong><br/><strong class="ny jk">SUBSTR</strong>(date,0,4) <strong class="ny jk">AS</strong> <strong class="ny jk">year</strong><br/><strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_20190301`</span></pre><p id="8e60" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">CONCAT (column_name等。)粘合价值观。让我们使用上一个示例中的日期列。假设你希望所有的日期都这样记录:2019–03–01。要将日期从当前格式转换成这种格式，可以使用两个字符串函数:首先，用SUBSTR剪切字符串的必要部分，然后通过连字符将它们粘合起来:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="8830" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong><br/><strong class="ny jk">CONCAT</strong>(<strong class="ny jk">SUBSTR</strong>(date,0,4),"-",<strong class="ny jk">SUBSTR</strong>(date,5,2),"-",<strong class="ny jk">SUBSTR</strong>(date,7,2)) <strong class="ny jk">AS</strong> date<br/><strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_20190301`</span></pre><p id="19ef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">REGEXP_CONTAINS返回正则表达式所在列的值:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="9290" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong> <br/><strong class="ny jk">CASE</strong><br/><strong class="ny jk">WHEN</strong> REGEXP_CONTAINS (<strong class="ny jk">medium</strong>, '^(sending|email|mail)$') <strong class="ny jk">THEN</strong> 'Email'<br/>    <strong class="ny jk">WHEN</strong> REGEXP_CONTAINS (<strong class="ny jk">source</strong>, '(mail|email|Mail)') <strong class="ny jk">THEN</strong> 'Email'<br/>    <strong class="ny jk">WHEN</strong> REGEXP_CONTAINS (<strong class="ny jk">medium</strong>, '^(cpa)$') <strong class="ny jk">THEN</strong> 'Affiliate'<br/><strong class="ny jk">ELSE</strong> 'Other'<br/><strong class="ny jk">END</strong> Channel_groups<br/><strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_20190301`</span></pre><p id="da1d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数可以在SELECT和WHERE中使用。例如，在WHERE中，您可以使用它来选择特定页面:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="5d05" class="na mj jj ny b gy oc od l oe of">WHERE REGEXP_CONTAINS(hits.page.pagePath, 'land[123]/|/product-order')</span></pre><p id="cc2f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 4。日期功能</strong></p><p id="49c6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，表格中的日期以字符串格式记录。如果您计划在Google Data Studio中可视化结果，需要使用PARSE_DATE函数将表中的日期转换为日期格式。</p><p id="592c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">PARSE_DATE将1900–01–01格式的字符串转换为日期格式。<br/>如果表格中的日期看起来不同(例如，19000101或01_01_1900)，您必须先将它们转换成指定的格式。</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="d33e" class="na mj jj ny b gy oc od l oe of">#standardSQL<br/><strong class="ny jk">SELECT</strong> <br/>PARSE_DATE('%Y-%m-%d', date)  <strong class="ny jk">AS</strong> date_new<br/><strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_20190301`</span></pre><p id="6c86" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">DATE_DIFF计算两个日期之间经过的时间，以天、周、月或年为单位。如果您需要确定用户看到广告和下订单之间的时间间隔，这很有用。下面是该函数在请求中的样子:</p><pre class="ns nt nu nv gt nx ny nz oa aw ob bi"><span id="a7fe" class="na mj jj ny b gy oc od l oe of">#standardSQL <br/><strong class="ny jk">SELECT</strong> DATE_DIFF( <br/>PARSE_DATE('%Y%m%d', date1), PARSE_DATE('%Y%m%d', date2), <strong class="ny jk">DAY</strong> <br/>) <strong class="ny jk">days</strong> -- convert the date1 and date2 lines to the DATE format; choose units to show the difference (DAY, WEEK, MONTH, etc.)<br/><strong class="ny jk">FROM</strong> `project_name.dataset_name.owoxbi_sessions_20190301`</span></pre><p id="64ba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于所列功能的信息，请阅读<a class="ae jg" href="https://www.owox.com/blog/use-cases/google-bigquery-functions-functions/" rel="noopener ugc nofollow" target="_blank">big query Google Features——详细回顾</a>。</p><h1 id="5f5e" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">营销报告的SQL查询</h1><p id="51ee" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">标准SQL方言允许企业通过深度细分、技术审计、营销KPI分析和识别CPA网络中的不公平承包商，从数据中提取最大限度的信息。下面是一些商业问题的例子，在这些问题中，对Google BigQuery中收集的数据进行SQL查询将会对您有所帮助。</p><p id="625a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1.ROPO分析:评估线上活动对线下销售的贡献。要执行ROPO分析，您需要将在线用户行为数据与来自CRM、呼叫跟踪系统和移动应用程序的数据结合起来。</p><p id="1b7d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果在第一个和第二个数据库中有一个关键字——一个对每个用户都是唯一的公共参数(例如，用户ID)——您可以跟踪:<br/>哪些用户在商店购买商品之前访问了网站<br/>用户在网站上的行为<br/>用户花了多长时间做出购买决定<br/>哪些活动对线下购买量的增加最大。</p><p id="7762" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.通过参数的任意组合对客户进行细分，从网站行为(访问的页面、浏览的产品、购买前访问网站的次数)到忠诚卡号和购买的商品。</p><p id="a201" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.找出哪些注册会计师的合作伙伴是在恶意工作，并取代UTM标签。</p><p id="6023" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.通过销售漏斗分析用户的进度。</p><p id="911a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经用标准的SQL方言准备了一些查询。如果您已经从您的网站、广告来源以及Google BigQuery中的CRM系统收集了数据，您可以使用这些模板来解决您的业务问题。只需用自己的项目名称、数据集和表替换BigQuery中的项目名称、数据集和表。在集合中，您将收到11个SQL查询。</p><p id="ec57" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">对于使用从Google Analytics 360到Google BigQuery的标准导出收集的数据:</strong></p><ul class=""><li id="2b6a" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">任何参数上下文中的用户操作</li><li id="253c" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">关键用户操作的统计数据</li><li id="da7c" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">查看特定产品页面的用户</li><li id="5558" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">购买特定产品的用户的行为</li><li id="6783" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">通过任何必要的步骤设置漏斗</li><li id="488c" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">内部搜索网站的有效性</li></ul><p id="52f8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">对于使用OWOX BI在Google BigQuery中收集的数据:</strong></p><ul class=""><li id="1da1" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">按来源和渠道划分的归因消费</li><li id="6e7d" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">城市吸引游客的平均成本</li><li id="4fe5" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">按来源和渠道列出的毛利润ROAS</li><li id="23d3" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">按付款方式和交付方式列出的CRM中的订单数量</li><li id="5046" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">各城市的平均交付时间</li></ul></div></div>    
</body>
</html>