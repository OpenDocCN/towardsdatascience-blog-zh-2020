<html>
<head>
<title>Priority Queues in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的优先级队列</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/priority-queues-in-python-3baf0bac2097?source=collection_archive---------12-----------------------#2020-03-14">https://towardsdatascience.com/priority-queues-in-python-3baf0bac2097?source=collection_archive---------12-----------------------#2020-03-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0f04" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">优先级队列的堆实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/adeddc3fb511a586c2abdfaa064a9541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jNJtE3Y33D5dSnppdMjuGg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/photo/person-in-black-sweater-hold-a-grey-road-bike-122477/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="7d2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优先级队列是一种类似于普通队列或堆栈的数据结构，但是每个元素都有一个相关的优先级。具有高优先级的元素在较低优先级的元素之前被服务。优先级队列通常使用堆数据结构来实现。</p><p id="54e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将讨论使用堆数据结构在python中实现优先级队列。</p><p id="d409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><p id="b03b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构建‘priority queue’类之前，有必要熟悉一下python‘heapq’模块。首先，让我们导入“heapq”模块:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f6fd" class="ma mb it lw b gy mc md l me mf">import heapq</span></pre><p id="425f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个IBM的历史价格列表:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ff04" class="ma mb it lw b gy mc md l me mf">ibm_prices = [108.68, 109.65, 121.01, 122.78, 120.16]</span></pre><p id="5d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想得到T2的最低或最高价格，我们可以使用。nsmallest()'和'。nlargest()”方法。要获得三个最低价格，我们可以做以下事情:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2202" class="ma mb it lw b gy mc md l me mf">print(heapq.nsmallest(3, ibm_prices))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/c2ab4eba3e7e24671fa0aebd7630965a.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*NxO4VFQZPAPhEtweGviCug.png"/></div></figure><p id="919c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于三个最高的价格:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d19a" class="ma mb it lw b gy mc md l me mf">print(heapq.nlargest(3, ibm_prices))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/48e3fde2c6bc5eff4de77842b235e6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*l3KmVGLZQQM5Bmcdg3NCBw.png"/></div></figure><p id="4faf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让事情变得更有趣一点，假设我们有一个科技公司股票的投资组合:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d54e" class="ma mb it lw b gy mc md l me mf">portfolio = [<br/>       {'name': 'IBM', 'shares': 200, 'price': 108.68},<br/>       {'name': 'AAPL', 'shares': 75, 'price': 277.97},<br/>       {'name': 'FB', 'shares': 40, 'price': 170.28},<br/>       {'name': 'HPQ', 'shares':125, 'price': 17.18},<br/>       {'name': 'UBER', 'shares': 50, 'price': 22.60},<br/>       {'name': 'TWTR', 'shares': 95, 'price': 29.29}<br/>]</span></pre><p id="d227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用。nsmallest()'和'。nlargest()'来分别拉最便宜和最贵的股票:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="211b" class="ma mb it lw b gy mc md l me mf">cheap_stocks = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])<br/>expensive_stocks = heapq.nlargest(3, portfolio, key=lambda s: s['price'])</span></pre><p id="2b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们打印结果:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e6e0" class="ma mb it lw b gy mc md l me mf">print("Cheap Stocks: ", cheap_stocks)<br/>print("Expensive Stocks: ", expensive_stocks)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/2404c83589b00977de9d8f2f299760ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hRghvMqSvvS8FVPOgpJvkQ.png"/></div></div></figure><p id="6316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些函数提供了卓越的性能，尤其是当<em class="mg"> N </em>元素(最大或最小)的大小与整个集合相比很小时。</p><p id="3d8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以构建我们的优先级队列类了。让我们使用“heapq”模块创建一个优先级队列类。首先，我们创建初始化方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9af3" class="ma mb it lw b gy mc md l me mf">class PriorityQueue:<br/>    def __init__(self):<br/>        self._queue = []<br/>        self._index = 0</span></pre><p id="8e8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义一个方法来检查队列是否为空:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6eb1" class="ma mb it lw b gy mc md l me mf">class PriorityQueue:<br/>    ...<br/>    def is_empty(self):<br/>        return not self._queue</span></pre><p id="220c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义一个方法，允许我们将对象推入我们的优先级队列。我们采用“heappush”方法，该方法将获取优先级和项目值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1d31" class="ma mb it lw b gy mc md l me mf">class PriorityQueue:<br/>    ...<br/>    def push(self, item, priority):<br/>        heapq.heappush(self._queue, (priority, self._index, item))<br/>        self._index += 1</span></pre><p id="8162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将添加一个方法，让我们使用“heappop”方法从优先级队列中删除元素:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1c08" class="ma mb it lw b gy mc md l me mf">class PriorityQueue:<br/>    ...<br/>    def pop(self):<br/>        return heapq.heappop(self._queue)[-1]</span></pre><p id="14ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来让我们定义一个名为Stock的类，我们将用它来演示优先级队列类的用法。该类将有一个“__init__”方法，让我们初始化股票价格、股份和报价器的值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dfa1" class="ma mb it lw b gy mc md l me mf">class Stock:<br/>    def __init__(self, stock_ticker, stock_price, stock_share):<br/>        self.stock_ticker = stock_ticker<br/>        self.stock_price = stock_price<br/>        self.stock_share = stock_share</span></pre><p id="ad16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以定义一个方法，允许我们打印类属性的表示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="90f1" class="ma mb it lw b gy mc md l me mf">class Stock:<br/>    ...<br/>    def __repr__(self):<br/>        return 'Stock({}, {}, {})'.format(self.stock_ticker ,   self.stock_price,  self.stock_share)</span></pre><p id="a801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们准备初始化我们的优先级队列并添加项目:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9f30" class="ma mb it lw b gy mc md l me mf">q = PriorityQueue()</span></pre><p id="1412" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将初始投资组合中的股票属性添加到优先级队列中。我们将优先考虑便宜的股票:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4454" class="ma mb it lw b gy mc md l me mf">q.push(Stock('IBM', 108.68, 200), 4)<br/>q.push(Stock('HPQ', 17.18, 125), 1)<br/>q.push(Stock('TWTR', 29.29, 95), 3)<br/>q.push(Stock('UBER', 22.6, 50), 2)<br/>q.push(Stock('AAPL', 277.97, 75), 6)<br/>q.push(Stock('FB', 170.28, 40), 5)</span></pre><p id="c6d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们打印优先级队列中的项目:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1a94" class="ma mb it lw b gy mc md l me mf">while not q.is_empty():<br/>    print(q.pop())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/f237f79478c250ef8af6d92829a3a814.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*VNyh2m_6WwyPZ8gqVzM2ow.png"/></div></figure><p id="251c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在这里停下来，但是您可以随意使用优先级队列的堆实现。此外，您可以尝试使用普通列表或链表来构建优先级队列。您可以在这里找到python中其他优先级队列实现的一些例子。我希望你觉得这篇文章有用/有趣。这篇文章的代码可以在<a class="ae ky" href="https://github.com/spierre91/medium_data_structures_and_algorithms/upload" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。感谢您的阅读！</p></div></div>    
</body>
</html>