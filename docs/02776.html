<html>
<head>
<title>Building Convolutional Neural Networks in Python using Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Keras在Python中构建卷积神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-convolutional-neural-networks-in-python-using-keras-7e4652f6456f?source=collection_archive---------20-----------------------#2020-03-17">https://towardsdatascience.com/building-convolutional-neural-networks-in-python-using-keras-7e4652f6456f?source=collection_archive---------20-----------------------#2020-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0a43" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建您自己的图像识别系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35a82da58dec5024b4252c4560d71d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_1kePqbwRHlTEzQ7mMHew.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由来自<a class="ae ky" href="https://www.pexels.com/photo/brown-hummingbird-selective-focus-photography-1133957/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@philippedonn?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Philippe Donn </a>拍摄</p></figure><h1 id="901f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">计算机视觉</h1><p id="658e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">计算机视觉是指计算机如何确定关于图像和视频的知识。最常见的例子是面部识别。卷积神经网络(CNN)主要用于促进图像或视频与所需标签或输出之间的学习。本文将使用Keras带您浏览Python中的卷积神经网络，并让您直观地了解其内部工作原理，以便您可以开始构建自己的图像识别系统。</p><p id="0746" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个项目的所有代码都可以在我的<a class="ae ky" href="https://github.com/RomanMichaelPaolucci/Weather_Recognition_System" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="9cd2" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">卷积神经网络演练</h1><h1 id="5ff3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据</h1><p id="3c54" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，我们需要数据供我们的深度学习模型学习。在这个例子中，我将使用来自<a class="ae ky" href="https://data.mendeley.com/datasets/4drtyfjtfy/1" rel="noopener ugc nofollow" target="_blank"> Mendeley </a>的开源天气数据进行分类，我鼓励你通过下载或使用你自己的数据来跟进。我将把天气数据作为一个多类分类问题来处理，标签如下:<em class="ne">多云</em>，<em class="ne">下雨</em>，<em class="ne">阳光</em>，<em class="ne">日出</em>。首先，我们将编写一些代码来创建一个图像路径列表，稍后我们将使用它来读取图像并对其进行标记。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b708" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们逐一分析这段代码的每一部分…</p><h2 id="b329" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">1.)获取所有图像路径集</h2><ul class=""><li id="dd68" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">这段代码负责一件事，为每个图像类创建图像路径列表。我将天气数据集中的所有图像放入文件夹<em class="ne"> weather_data </em>中，然后通过遍历该目录，我们将每个路径附加到列表中，如果每个图像属于其类，则检查其名称是否与其类相关。</li></ul><h2 id="68d7" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">2.)随机打乱图像</h2><ul class=""><li id="d751" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">为了在创建我们的训练和测试分割时没有选择偏差，我们将在聚合这些图像之前随机洗牌。</li></ul><h2 id="1e5e" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">3.)训练和测试图像集</h2><ul class=""><li id="b6fd" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">相对来说，我们将使用每个列表中的前150个随机图像作为我们的训练集，每个列表中的其余图像作为我们的测试集。</li></ul><h2 id="0648" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">4.)垃圾收集</h2><ul class=""><li id="ff9c" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">图像识别系统的计算成本很低，我们可以通过删除已经重新分配的列表和收集垃圾来清理一些内存分配。</li></ul><h1 id="089d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">图像预处理</h1><p id="a79f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在建立模型之前，我们需要重新格式化图像，以便模型知道预期的尺寸。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="9050" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">5.)静态图像变量</h2><ul class=""><li id="c016" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">这里我们将nRows和nCols声明为我们将重新格式化图像的像素高度和宽度。通道是指颜色通道，在这种情况下，我们使用3的RGB，但你可以使用1如果你喜欢灰度</li></ul><h2 id="baa4" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">6.)培训和测试拆分</h2><ul class=""><li id="cda1" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">我们之前创建了包含图像路径的集合，用于我们的训练和测试分割。现在，我们将使用这些数组来包含读取的图像及其标签。</li></ul><h2 id="0556" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">7/8.)图像读取和数据标记</h2><ul class=""><li id="1cec" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">可能是最重要的部分，让我们来分解一下。有两个for循环，一个用于构建训练集，另一个用于测试集。我们正在遍历前面构建的路径集中的每个图像路径。使用cv2，我们从<strong class="lt iu"> (5) </strong>读入图像并根据静态尺寸调整图像大小。接下来，我们有一系列if语句来确定每个读取图像的类别。每个图像的名称基于其类别(例如，rain1、rain2、rain 3……)，因此我们检查图像路径中是否包含<em class="ne">多云、</em>下雨、<em class="ne">日出、晴天</em>，并相应地附加1、2、3或4。最后，我想承认有些图像可能无法读取，所以我们想在for循环中使用try/except来捕获我们无法读取的图像。</li></ul><h2 id="659e" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">9.)垃圾收集</h2><ul class=""><li id="1385" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">参见<strong class="lt iu"> (4) </strong></li></ul><h2 id="242b" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">10.)转换成NumPy数组</h2><ul class=""><li id="06a1" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">我们希望将我们的训练和测试集转换为NumPy数组，以便我们可以将其输入到我们的卷积神经网络中，并使用Scikit-learn和Keras等附带的库重新格式化输入和目标数据。</li></ul><h2 id="7a67" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">11.)转换为分类</h2><ul class=""><li id="8e3a" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">因此，我们可以使用softmax激活函数<em class="ne">X</em><strong class="lt iu"><em class="ne">∈</em></strong><em class="ne">【0，1】</em>来预测图像类我们将把我们的标签向量(其中<em class="ne">L</em><strong class="lt iu"><em class="ne">∈</em></strong><em class="ne">{ 1，2，3，4} </em>转换为分类集<em class="ne"> L </em> <strong class="lt iu"> <em class="ne"> ∈)</em></strong></li></ul><h1 id="79d5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">模型开发</h1><p id="3c8e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，我们将使用Keras构建卷积神经网络。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="e309" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">12.)创建模型</h2><ul class=""><li id="4d09" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">在这里，我们创建一个顺序模型，以便在Conv2D、MaxPooling2D、Flatten和Dropout层完成工作后，我们可以将其直接输入到完全连接的层中进行分类。</li></ul><p id="063d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/keras-conv2d-class/" rel="noopener ugc nofollow" target="_blank">Conv2D</a>—从图像中提取关键特征</p><p id="a58b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://computersciencewiki.org/index.php/Max-pooling_/_Pooling" rel="noopener ugc nofollow" target="_blank">maxpooli2d</a>—通过下采样进行降维</p><p id="0db0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://keras.io/layers/core/#flatten" rel="noopener ugc nofollow" target="_blank">展平</a> —展平输入形状，例如(8，16) → 128</p><p id="3790" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://keras.io/layers/core/#dropout" rel="noopener ugc nofollow" target="_blank">辍学</a>——防止模型过拟合</p><p id="07c0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Dense" rel="noopener ugc nofollow" target="_blank">密集</a> —全连通层，对展平输入进行分类</p><h2 id="356a" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">13.)模型总结</h2><ul class=""><li id="076d" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">在这里，我们可以了解每次训练迭代优化了多少参数。尝试添加和移除MaxPooling2D层，看看这会如何影响训练参数的总数。这显然与训练时间相关。</li></ul><h2 id="dbc4" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">14.)编译并拟合模型</h2><ul class=""><li id="0d49" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">至此，我们基本上完成了模型。我们需要做的最后一件事是编译并使我们的模型适合训练数据。我们将使用adam作为我们的优化器，分类相关性和准确性分别作为我们的损失和度量。</li></ul><h1 id="b096" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结果</h1><h2 id="f1b1" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">15/16.)可视化结果</h2><ul class=""><li id="79be" class="nt nu it lt b lu lv lx ly ma nv me nw mi nx mm ny nz oa ob bi translated">我们可以做的最后一件事是帮助可视化我们的模型的结果，为模型的精度和训练期间的损失创建图表。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="a358" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">运行完本文中开发的所有代码后，让我们来看看模型的输出…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/1caa44615535e2ad6f1568844e0b1b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c6bje9xmGAzvdBOLMQK8Og.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/411b8230cecddd0d774b73ca9827796e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdTiLTgddKRYC7zBu4vtdw.png"/></div></div></figure><p id="6bd0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在10个训练周期之后，我们以大约88%的训练准确度和大约93%的验证准确度结束，还不错！</p><p id="f963" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有很多方法可以改进这个模型，你可以通过简单地添加更多的隐藏层和更多的训练时期来开始。</p><p id="aa88" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在你应该对如何创建自己的图像识别系统有了一个很好的想法！同样，如果你想下载这个项目，可以在我的GitHub上找到。</p></div></div>    
</body>
</html>