<html>
<head>
<title>Treatment Assignment Strategy in A/B Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">A/B测试中的处理分配策略</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/treatment-assignment-strategy-in-a-b-test-931133bb048f?source=collection_archive---------32-----------------------#2020-05-10">https://towardsdatascience.com/treatment-assignment-strategy-in-a-b-test-931133bb048f?source=collection_archive---------32-----------------------#2020-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c7f2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">A/B测试中常见处理分配策略的问题及克服方法概述。</h2></div><p id="8283" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我之前的<a class="ae lb" rel="noopener" target="_blank" href="/step-by-step-for-planning-an-a-b-test-ef3c93143c0b">帖子</a>中，我给出了规划A/B测试的一步一步的过程，但是没有涉及实现部分。本周，我将重点关注A/B测试实现的一个组成部分——治疗分配。</p><p id="1141" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有效的随机对照实验的要求之一是随机处理分配。尽管它很重要，但不幸的是，这也是大多数人似乎不太关心的部分。也许因为随机的概念看起来很简单，我只是随机地将我的实验对象分配到控制组和治疗组，就这样，对吗？在商业环境中，实际情况远非如此，因为有些需求使得随机性难以实现。</p><p id="eb7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇博文中，我将试图强调其中一些需求，人们用来满足这些需求的常用策略，这些策略带来的问题，以及最后一个满足所有需求的简单而优雅的解决方案。</p><h2 id="0e22" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">一致的治疗分配</h2><blockquote class="lv"><p id="2ba9" class="lw lx iq bd ly lz ma mb mc md me la dk translated">给予实验对象的治疗每次都必须是一致的。</p></blockquote><p id="8370" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">我在这里举几个例子:</p><ol class=""><li id="bab4" class="mk ml iq kh b ki kj kl km ko mm ks mn kw mo la mp mq mr ms bi translated">如果网飞想要衡量其新推荐引擎的效果，那么每个用户(实验对象)都应该像以前一样从相同的推荐引擎接收推荐。</li><li id="38ab" class="mk ml iq kh b ki mt kl mu ko mv ks mw kw mx la mp mq mr ms bi translated">如果我想测试一个新的移动应用设计是否有更快的加载时间，那么每个设备(实验对象)每次都需要加载相同的移动应用设计。</li></ol><p id="b169" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在每次实验对象暴露时随机分配治疗，那么我们将无法保证这一点。(例如，用户A可能每次都登录并看到不同的处理。)</p><p id="000b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了便于解释，并且考虑到大多数实验都是以用户为实验对象的事实，从今以后，我将把用户视为实验对象。</p><h2 id="8505" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">可量测性</h2><p id="ba35" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">满足第一个要求是相当容易的，我们只需记录下哪个用户第一次接触实验时接受了哪种治疗。在后续的登录或者后续的曝光中，我们只是查找这个用户过去的待遇，分配相同的待遇。</p><p id="b4c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于一个小公司来说可能是可行的，但是随着你规模的扩大，你会发现这种方法根本不具备很强的可扩展性。我们可以想象，在我们有几千万用户，几百次实验的情况下，要做到这一点几乎是不可能的。</p><h2 id="fbdd" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">为了做到真正的随机，跨实验的<strong class="ak">分配应该是独立的</strong></h2><p id="a110" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">为了解决上述两个问题，公司常用的策略之一是利用用户ID的最后一个字符或数字。在这种情况下，治疗将是一致的和完全可扩展的，因为治疗仅依赖于固定的用户ID。</p><p id="6d8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这带来了另一个问题。这个实验本身确实是随机的。但是随着我们做越来越多的实验，我们会发现不同实验的治疗任务现在是相互关联的。</p><p id="e88a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里举个例子。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="c62e" class="lc ld iq ni b gy nm nn l no np">+-------------------+-----------------+-------------------+-------+<br/>|                   | <strong class="ni ir">Exp 1 : Control</strong> | <strong class="ni ir">Exp 1 : Treatment</strong> | <strong class="ni ir">Total</strong> |<br/>+-------------------+-----------------+-------------------+-------+<br/>| <strong class="ni ir">Exp 2 : Control</strong>   |            2107 |              2929 |  <strong class="ni ir">5036 </strong>|<br/>| <strong class="ni ir">Exp 2 : Treatment</strong> |            2916 |              2048 |  <strong class="ni ir">4964</strong> |<br/>| <strong class="ni ir">Total</strong>             |            <strong class="ni ir">5023</strong> |              <strong class="ni ir">4977</strong> | <strong class="ni ir">10000</strong> |<br/>+-------------------+-----------------+-------------------+-------+</span></pre><p id="e282" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下，如果我们有10，000个用户，我们做了两个实验。在第一个实验(实验1)中，我们测试了订阅费的减少是否会增加付费会员的转化率，并发现了一个显著的结果。在第二个实验(实验2)中，我们测试了一个额外的特性是否会增加用户的购买次数，结果发现这种影响在统计上并不显著。</p><p id="2beb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是可能出现这种情况的原因:</p><ol class=""><li id="3e97" class="mk ml iq kh b ki kj kl km ko mm ks mn kw mo la mp mq mr ms bi translated">付费用户会因为打折而购买更多的东西。</li><li id="3964" class="mk ml iq kh b ki mt kl mu ko mv ks mw kw mx la mp mq mr ms bi translated">实验1中处理组的更多用户被分配到实验2中的控制组，这意味着实验2控制组有更多的付费用户。</li><li id="0b3d" class="mk ml iq kh b ki mt kl mu ko mv ks mw kw mx la mp mq mr ms bi translated">如果两组都服用安慰剂，实验2对照组的用户自然会比治疗组购买更多的东西。</li><li id="b08a" class="mk ml iq kh b ki mt kl mu ko mv ks mw kw mx la mp mq mr ms bi translated">因此，即使实验2中的额外特征确实增加了购买的数量，我们也不能准确地测量效果，因为实验2中的处理分配与实验1中的处理分配相关。</li></ol><blockquote class="lv"><p id="f3e2" class="lw lx iq bd ly lz nq nr ns nt nu la dk translated">为了真正随机，在不同实验中的处理分配之间不应该有相关性。</p></blockquote><h2 id="5067" class="lc ld iq bd le lf nv dn lh li nw dp lk ko nx lm ln ks ny lp lq kw nz ls lt lu bi translated">这种相关性多久发生一次？</h2><p id="9417" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">为了检验这一点，我执行了以下模拟。</p><ol class=""><li id="b303" class="mk ml iq kh b ki kj kl km ko mm ks mn kw mo la mp mq mr ms bi translated">生成10，000个用户id，其中每个id是长度为10的十六进制字符串(例如:<em class="oa"> d3ef2942d7 </em>)。</li></ol><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="fba3" class="lc ld iq ni b gy nm nn l no np">import pandas as pd<br/>import random</span><span id="22cf" class="lc ld iq ni b gy ob nn l no np">exp_df = pd.DataFrame(['%010x' % random.randrange(16**10) for x in range(10000)], columns=['user_id'])</span></pre><p id="cf0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.创建20个实验。对于每个实验，从16个可能值(0 - 9，a - f)中随机选择8个作为对照。如果用户ID的最后一个字符在控制中，则将他们分配到控制组，否则，将他们分配到处理组。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="3792" class="lc ld iq ni b gy nm nn l no np">import numpy as np</span><span id="bffe" class="lc ld iq ni b gy ob nn l no np"># number of experiments<br/>j = 20</span><span id="abd3" class="lc ld iq ni b gy ob nn l no np"># get all 16 possible values<br/>random_list = exp_df['user_id'].apply(lambda x: x[-1]).unique()</span><span id="71f1" class="lc ld iq ni b gy ob nn l no np">control_list = [set(np.random.choice(random_list, 8, replace=False)) for x in range(j)]<br/>treatment_list = [set(random_list) - x for x in control_list]<br/>    <br/>for k in range(j):<br/>    exp_df[f'exp_{k}'] = exp_df['user_id'].apply(lambda x: x[-1]).isin(control_list[k]).map({True:'control', False: 'treatment'})</span></pre><figure class="nd ne nf ng gt od gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi oc"><img src="../Images/80bc718ed3e00bd6a07dcfd533596b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VCcWEtjx7v1SYMfkWrRczQ.png"/></div></div><p class="ok ol gj gh gi om on bd b be z dk translated">结果数据帧的外观示例。</p></figure><p id="8805" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.对于每一对实验，生成如上例所示的列联表，并进行卡方检验。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="b571" class="lc ld iq ni b gy nm nn l no np">from scipy import stats</span><span id="6b70" class="lc ld iq ni b gy ob nn l no np"># initialize list to store chi-square results all experiment pairs<br/>chi2_res = []</span><span id="52a7" class="lc ld iq ni b gy ob nn l no np">for cols in combinations(exp_df.columns[1:], 2):</span><span id="90e4" class="lc ld iq ni b gy ob nn l no np">    target_cols = list(cols)</span><span id="e4cd" class="lc ld iq ni b gy ob nn l no np"># generate contingency table<br/>    aggregate_df = exp_df[target_cols]\<br/>                   .groupby(target_cols)\<br/>                   .size()\<br/>                   .to_frame()\<br/>                   .reset_index()\<br/>                   .pivot(index=target_cols[1], <br/>                           columns=target_cols[0])</span><span id="a0cf" class="lc ld iq ni b gy ob nn l no np"># store chi-square test result<br/>    chi2_res.append(stats.chi2_contingency(aggregate_df)[1])</span><span id="e422" class="lc ld iq ni b gy ob nn l no np"># number of pairs that fail the chi-square test at alpha = 0.01<br/>print((np.array(chi2_res) &lt; 0.01).sum())</span></pre><p id="f170" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">直观地说，如果处理分配是真正独立的，我们应该期望看到以下情况(假设50%的样本分配给对照，50%分配给处理)。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="0155" class="lc ld iq ni b gy nm nn l no np">+-------------------+-----------------+-------------------+-------+<br/>|                   | <strong class="ni ir">Exp 1 : Control</strong> | <strong class="ni ir">Exp 1 : Treatment</strong> | <strong class="ni ir">Total</strong> |<br/>+-------------------+-----------------+-------------------+-------+<br/>| <strong class="ni ir">Exp 2 : Control</strong>   |            2500 |              2500 |  <strong class="ni ir">5000 </strong>|<br/>| <strong class="ni ir">Exp 2 : Treatment</strong> |            2500 |              2500 |  <strong class="ni ir">5000</strong> |<br/>| <strong class="ni ir">Total</strong>             |            <strong class="ni ir">5000</strong> |              <strong class="ni ir">5000</strong> | <strong class="ni ir">10000</strong> |<br/>+-------------------+-----------------+-------------------+-------+</span></pre><p id="a987" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">卡方检验告诉我们实际计数离独立案例有多远。距离越远，卡方检验统计值越高，因此有更强的证据表明两个实验的处理分配之间存在某种关联。</p><p id="4bc9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将上面的模拟运行了100次，看看在每个模拟中有多少对实验没有通过卡方检验，得到了平均值<strong class="kh ir">62%</strong>(190对中的118对)！换句话说，如果我们使用这种方法，平均来说，我们将观察到62%的实验对没有通过卡方检验。我还尝试了5次或10次实验(而不是最初的20次)，得到了类似的结果(约60%)。</p><figure class="nd ne nf ng gt od gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi oo"><img src="../Images/222f7e0bcdf703029f42f82a142028f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MG9bN5fQ_6lKAU9FTZFA0A.png"/></div></div><p class="ok ol gj gh gi om on bd b be z dk translated">在100次模拟中未通过卡方检验的实验对数量的分布。</p></figure><h2 id="6dca" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">奋力营救</h2><p id="3875" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">满足上述所有要求的解决方案实际上非常简单。我们所要做的就是使用一个散列函数。散列函数是可以用来将任意大小的数据映射到固定大小的值的任何函数。该属性确保满足前两个要求(一致性和可伸缩性)。</p><p id="269e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了满足最终的需求，我们只需要散列用户ID和实验ID的连接，而不是只散列用户ID。</p><p id="de37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是如何使用python实现这一点的示例。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="5cca" class="lc ld iq ni b gy nm nn l no np">import mmh3</span><span id="3a27" class="lc ld iq ni b gy ob nn l no np">def treatment_assignment(user_id, exp_id, control_bucket):<br/>    <br/>    # calculates the number of buckets<br/>    num_buckets = len(control_bucket) * 2<br/>    <br/>    # this generates a 32 bit integer<br/>    hash_int = mmh3.hash(user_id  + exp_id)<br/>    <br/>    # get the mod of the 32 bit integer<br/>    mod = hash_int % num_buckets<br/>    <br/>    if mod in control_bucket:<br/>        return 'control'<br/>    else:<br/>        return 'treatment'<br/>    <br/># create 50 random integer as control group<br/>control_bucket = np.random.choice(np.arange(0,100,1), 50, replace=False)<br/>treatment_assignment('d3ef2942d7', 'exp_1', control_bucket)</span></pre><p id="bcf1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据您的控制桶和实验ID，上述函数将返回<code class="fe op oq or ni b">treatment</code>或<code class="fe op oq or ni b">control</code>。我们也可以把它扩展到两个以上变量的实验。</p><p id="c972" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我用这种方法再次运行了上面的模拟，下面是结果。</p><figure class="nd ne nf ng gt od gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi os"><img src="../Images/c3e5fb65d259010b9f8b8b0c9c65b6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fc4rJFvN2NvqhVAazstoPA.png"/></div></div><p class="ok ol gj gh gi om on bd b be z dk translated">模拟190个实验对中未通过卡方检验(α= 0.01)的实验对的数量。</p></figure><p id="6341" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，100次模拟中的<strong class="kh ir"> 73次</strong>导致2对或更少的实验(190对中)无法通过卡方检验，这证明这是一种分配治疗的健壮方法，而不违反任何要求。</p><h2 id="2f1a" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">结论</h2><p id="560b" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">在这篇博文中，我详细概述了实验中处理分配的要求。我列出了我见过的一些常见的实践，并陈述了它们为什么违反了一些需求。违反任何要求都意味着实验结果不再有效，这就是为什么我们应该开始更多地关注治疗方案。</p><p id="dcbb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我给出了一个简单的解决方案，它满足了适用于两个以上变量实验的所有要求。</p></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><h2 id="9aab" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">参考</h2><p id="9019" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">[1]好哈希难求(offer up)<br/><a class="ae lb" href="https://blog.offerup.com/a-good-hash-is-hard-to-find-60e8a201e8ce" rel="noopener ugc nofollow" target="_blank">https://blog . offer up . com/A-good-hash-is-hard-to-find-60 E8 A 201 E8 ce</a></p></div></div>    
</body>
</html>