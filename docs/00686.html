<html>
<head>
<title>4 Common Mistakes Python Beginners should Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python初学者应该避免的4个常见错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-common-mistakes-python-beginners-should-avoid-89bcebd2c628?source=collection_archive---------6-----------------------#2020-01-20">https://towardsdatascience.com/4-common-mistakes-python-beginners-should-avoid-89bcebd2c628?source=collection_archive---------6-----------------------#2020-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="504c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Python初学者</h2><div class=""/><div class=""><h2 id="2f77" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我很艰难地学会了，但你不需要</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/4fb4317b389bd798668f2001dd8ce4e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xKIoflZ27bTZ9v29"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@jamie452?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的杰米街</a>上<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的Unsplash </a></p></figure><blockquote class="li"><p id="e46a" class="lj lk it bd ll lm ln lo lp lq lr ls dk translated">让我们面对现实吧。学习编程很难。</p></blockquote><p id="5773" class="pw-post-body-paragraph lt lu it lv b lw lx kd ly lz ma kg mb mc md me mf mg mh mi mj mk ml mm mn ls im bi translated">许多人会同意，但有些人不同意。我不相信。</p><p id="33b7" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">这是因为我总能在不同的编程语言中发现微妙的方法来做我想做的事情。我以为我已经<strong class="lv jd">掌握了</strong>它们。但我错了。你可以在你的代码中做任何事情，但是你不应该做任何你想做的事情。</p><p id="b7fe" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">我很快意识到我尝试的那些“微妙”的方法是不好的做法。但是一段有效的代码怎么会是坏的呢？我习惯于采用这些不好的(和微妙的)做法，它回来困扰着我。我是吃了苦头才知道的。</p><p id="bdc3" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">在分享每个Python新手都应该知道的4个常见错误之前，确保你熟悉下面这篇文章中的一些Python内置特性。</p><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/5-python-features-i-wish-i-had-known-earlier-bc16e4a13bf4"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd jd gy z fp nb fr fs nc fu fw jc bi translated">我希望我能早点知道的5个Python特性</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">超越lambda、map和filter的Python技巧</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk lb mw"/></div></div></a></div></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="0af8" class="ns nt it bd nu nv nw nx ny nz oa ob oc ki od kj oe kl of km og ko oh kp oi oj bi translated">1.不使用迭代器</h1><p id="4c94" class="pw-post-body-paragraph lt lu it lv b lw ok kd ly lz ol kg mb mc om me mf mg on mi mj mk oo mm mn ls im bi translated">每个Python新手都这么做，不管他们对其他编程语言的熟练程度如何。无处可逃。</p><p id="d2e6" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">给定一个列表<code class="fe op oq or os b">list_</code>，如何使用for循环逐个访问列表中的元素？我们知道Python中的列表是由<strong class="lv jd">索引的</strong>，因此我们可以通过<code class="fe op oq or os b">list_[i]</code>访问第I个元素。然后我们可以为for循环创建一个范围从<code class="fe op oq or os b">0</code>到<code class="fe op oq or os b">len(list_)</code>的整数迭代器，如下所示:</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="2834" class="ox nt it os b gy oy oz l pa pb"><strong class="os jd">for</strong> i <strong class="os jd">in</strong> <strong class="os jd">range</strong>(<strong class="os jd">len</strong>(list_)):<br/>    foo(list_[i])</span></pre><p id="1830" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">它工作了。代码没有问题。这也是在其他语言如<em class="pc"> C </em>中构造for循环的标准方式。但是实际上我们可以用Python做得更好。</p><p id="2a6b" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated"><em class="pc">如何？</em></p><p id="898d" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">你知道Python中的列表是<strong class="lv jd">可迭代的</strong>吗？通过利用它的可迭代特性，我们可以生成可读性更好的代码，如下所示:</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="19d1" class="ox nt it os b gy oy oz l pa pb"><strong class="os jd">for</strong> element <strong class="os jd">in</strong> list_:<br/>    foo(element)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pd"><img src="../Images/18f3160bfbdd11f7917022f5330eaba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GIn07u6iOwlOeE1_"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@creativeexchange?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上创意交流</a>拍摄的照片</p></figure><p id="4f40" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated"><strong class="lv jd">在for循环中并行遍历多个列表</strong>可以通过<code class="fe op oq or os b">zip</code>函数实现，而<code class="fe op oq or os b">enumerate</code>可以帮助你在迭代一个iterable对象时获取索引号(即计数器)。在<a class="ae lh" rel="noopener" target="_blank" href="/5-python-features-i-wish-i-had-known-earlier-bc16e4a13bf4"> 5 Python特性中介绍和解释了它们，我希望我能早点知道</a>。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="4808" class="ns nt it bd nu nv nw nx ny nz oa ob oc ki od kj oe kl of km og ko oh kp oi oj bi translated">2.使用全局变量</h1><p id="ed48" class="pw-post-body-paragraph lt lu it lv b lw ok kd ly lz ol kg mb mc om me mf mg on mi mj mk oo mm mn ls im bi translated"><strong class="lv jd">全局</strong>变量是在主脚本中声明的具有全局作用域的变量，而<strong class="lv jd">局部</strong>变量是在具有局部作用域的函数中声明的变量。在Python中使用<code class="fe op oq or os b">global</code>关键字允许你在一个函数中局部访问和修改全局变量。这里有一个例子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="e010" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">许多初学者喜欢它，因为使用<code class="fe op oq or os b">global</code>似乎可以避免传递函数所需的所有参数。<em class="pc">但这其实不是真的。它只是隐藏了动作。</em></p><p id="ac46" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">使用<code class="fe op oq or os b">global</code> s也不利于<strong class="lv jd">调试</strong>目的。功能应被视为<strong class="lv jd">块盒</strong>，并且应该是<strong class="lv jd">可重用的</strong>。修改全局变量的函数可能会给主脚本带来<strong class="lv jd">副作用</strong>，这很难发现，而且很可能会导致复杂的代码，调试起来更加困难。</p><p id="4445" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">在局部函数中修改全局变量是一种糟糕的编程实践。您应该将变量作为参数传入，对其进行修改，并在函数结束时将其返回。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/2bf8dc3ee1226e45939e4c968daef586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YXmuu1RRtziESjLH"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@lemonvlad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗拉季斯拉夫·克拉平</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0868" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">*不要混淆全局变量和全局常量，因为在大多数情况下使用后者是完全可以的。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="d35c" class="ns nt it bd nu nv nw nx ny nz oa ob oc ki od kj oe kl of km og ko oh kp oi oj bi translated">3.不理解可变对象</h1><p id="7356" class="pw-post-body-paragraph lt lu it lv b lw ok kd ly lz ol kg mb mc om me mf mg on mi mj mk oo mm mn ls im bi translated">对于新的Python学习者来说，这可能是最常见的惊喜，因为这个特性在这种语言中是非常独特的。</p><p id="eb2d" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">Python中有两种对象。可变对象可以在运行时改变它们的状态或内容<strong class="lv jd">，而不可变对象则不能。很多内置对象类型是不可变的，包括<strong class="lv jd"> int、float、string、bool、</strong>和<strong class="lv jd"> tuple </strong>。</strong></p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="27e6" class="ox nt it os b gy oy oz l pa pb">st <strong class="os jd">=</strong> '<!-- -->A string'<!-- --> <br/>st[0] <strong class="os jd">=</strong> <!-- -->'B' # You cannot do this in Python</span></pre><p id="a660" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">另一方面，像<strong class="lv jd"> list </strong>、<strong class="lv jd"> set </strong>和<strong class="lv jd"> dict </strong>这样的数据类型是可变的。因此，您可以更改列表中元素的内容，例如<code class="fe op oq or os b">list_[0] = 'new'</code>。</p><p id="1695" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">当函数中的<strong class="lv jd">默认参数</strong>可变时，会发生意想不到的事情。让我们以下面的函数为例，其中一个<em class="pc">可变</em> <strong class="lv jd">空列表</strong>是参数<code class="fe op oq or os b">list_</code>的默认值。</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="6725" class="ox nt it os b gy oy oz l pa pb"><strong class="os jd">def</strong> foo(element, list_=[]):<br/>    list_.<strong class="os jd">append</strong>(element)<br/>    <strong class="os jd">return</strong> list_</span></pre><p id="2b60" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">让我们调用函数<strong class="lv jd">两次</strong>，而不为<code class="fe op oq or os b">list_</code>输入参数，这样它就取默认值。理想情况下，如果没有提供第二个参数，那么每次调用函数时都会创建一个新的空列表。</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="429f" class="ox nt it os b gy oy oz l pa pb">a = foo(1) # returns [1]<br/>b = foo(2) # returns [1,2], not [2]! WHY?</span></pre><p id="73b4" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated"><em class="pc">什么？</em></p><p id="26e1" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">原来Python中的默认参数是在定义函数时计算一次的<strong class="lv jd">。这意味着调用函数不会刷新默认参数。</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/e48b68c992f8c67e5374d083c7c26d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ePAwSNunCzPKeywu"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@ravi_roshan_inc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ravi Roshan </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2b1a" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">因此，如果默认参数是可变的，并且每次调用函数时都会发生变化。变异后的默认参数将<strong class="lv jd">用于所有未来的函数调用。“标准”<strong class="lv jd">修复</strong>是使用(不可变)<code class="fe op oq or os b">None</code>作为默认值，如下所示。</strong></p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="5160" class="ox nt it os b gy oy oz l pa pb"><strong class="os jd">def</strong> foo(element, list_=<strong class="os jd">None</strong>):<br/>    if list_ is <strong class="os jd">None</strong>:<br/>        list_ = []<br/>    list_.<strong class="os jd">append</strong>(element)<br/>    <strong class="os jd">return</strong> list_</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="63ec" class="ns nt it bd nu nv nw nx ny nz oa ob oc ki od kj oe kl of km og ko oh kp oi oj bi translated">4.不复制</h1><p id="7350" class="pw-post-body-paragraph lt lu it lv b lw ok kd ly lz ol kg mb mc om me mf mg on mi mj mk oo mm mn ls im bi translated">对于学习者来说，复制的概念可能是外国的，甚至是违反直觉的T42。假设你有一个列表<code class="fe op oq or os b">a = [[0,1],[2,3]]</code>，然后你在<code class="fe op oq or os b">b = a</code>前声明一个新列表。您现在有两个具有相同元素的列表。通过改变列表<code class="fe op oq or os b">b</code>中的一些元素，应该不会对列表<code class="fe op oq or os b">a</code>有什么(副作用)影响吧？</p><p id="43ca" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated"><em class="pc">错了。</em></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="b30e" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">当您使用<strong class="lv jd">赋值语句</strong>即<code class="fe op oq or os b">b = a</code>来“复制”一个列表时，对一个列表的元素所做的任何修改在两个列表中都是可见的。赋值操作符只在目标和对象之间创建<strong class="lv jd">绑定</strong>，因此示例中的<code class="fe op oq or os b">a</code>和<code class="fe op oq or os b">b</code>列表共享同一个<strong class="lv jd">引用</strong>，即Python中的<code class="fe op oq or os b">id()</code>。</p><p id="a077" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">如何复制对象？</p><p id="53c3" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">如果您想要“复制”对象，并且只修改新(或旧)对象中的值而不进行绑定，有两种方法可以创建副本:<strong class="lv jd">浅层复制</strong>和<strong class="lv jd">深层复制</strong>。两个对象将有不同的引用。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/389020cd858a4ab4cfa82938df3020e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*33DybyDgT3QaVOZT"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@louishansel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">路易·汉瑟</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d3a6" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">使用我们之前的例子，您可以通过<code class="fe op oq or os b">b = copy.copy(a)</code>创建一个<code class="fe op oq or os b">a</code>的浅层副本。浅层拷贝创建了一个新对象，它存储了原始元素的<strong class="lv jd">引用</strong>。这听起来可能很复杂，但让我们看看下面的例子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="13e6" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">在创建了一个<strong class="lv jd">嵌套列表</strong> <code class="fe op oq or os b">a</code>的浅层副本之后，我们称之为<code class="fe op oq or os b">b</code>，两个列表有不同的引用<code class="fe op oq or os b">id(a) != id(b)</code>，用符号<code class="fe op oq or os b">!=</code>表示‘不相等’。然而，它们的元素具有相同的引用，因此<code class="fe op oq or os b">id(a[0]) == id(b[0])</code>。</p><p id="90eb" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">这意味着改变<code class="fe op oq or os b">b</code>中的元素不会影响列表<code class="fe op oq or os b">a</code>，但是修改<code class="fe op oq or os b">b[1]</code>中的元素会影响<code class="fe op oq or os b">a[1]</code>，因此这个副本是浅层的。</p><p id="1433" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">简而言之，如果 <code class="fe op oq or os b"><strong class="lv jd">b</strong></code> <strong class="lv jd">是</strong> <code class="fe op oq or os b"><strong class="lv jd">a</strong></code>的浅层拷贝，那么<strong class="lv jd">对</strong> <code class="fe op oq or os b"><strong class="lv jd">b</strong></code> <strong class="lv jd">中嵌套对象内元素的任何更改都会出现在</strong> <code class="fe op oq or os b"><strong class="lv jd">a</strong></code> <strong class="lv jd">中。</strong></p><p id="ea41" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">如果你想复制一个嵌套的对象，而在它们的元素之间没有任何绑定，你需要一个由<code class="fe op oq or os b">b = copy.deepcopy(a)</code>生成的<code class="fe op oq or os b">a</code>的深层副本。深度复制创建一个新对象，而<strong class="lv jd">递归地</strong>在原始元素中创建嵌套对象的<strong class="lv jd">副本。</strong></p><p id="151d" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated">简而言之，<strong class="lv jd">深度拷贝无任何绑定复制一切</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/65f0c99b3b4352a36afdd9676ed883de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l57mfLeFckgjjVJd"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@drewcoffman?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">德鲁·科夫曼</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="d590" class="ns nt it bd nu nv nw nx ny nz oa ob oc ki od kj oe kl of km og ko oh kp oi oj bi translated">外卖</h1><p id="f1a5" class="pw-post-body-paragraph lt lu it lv b lw ok kd ly lz ol kg mb mc om me mf mg on mi mj mk oo mm mn ls im bi translated">这就是Python初学者应该避免的4个常见错误。我很艰难地学会了，但你不需要。你可以<a class="ae lh" href="http://edenau.mailchimpsites.com/" rel="noopener ugc nofollow" target="_blank">注册我的时事通讯</a>来接收我的新文章的更新。如果您对Python感兴趣，您可能会发现以下文章很有用:</p><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/5-python-features-i-wish-i-had-known-earlier-bc16e4a13bf4"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd jd gy z fp nb fr fs nc fu fw jc bi translated">我希望我能早点知道的5个Python特性</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">超越lambda、map和filter的Python技巧</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk lb mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/6-new-features-in-python-3-8-for-python-newbies-dc2e7b804acc"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd jd gy z fp nb fr fs nc fu fw jc bi translated">Python 3.8中针对Python新手的6项新特性</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">请做好准备，因为Python 2不再受支持</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="pk l nh ni nj nf nk lb mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/4-numpy-tricks-every-python-beginner-should-learn-bdb41febc2f2"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd jd gy z fp nb fr fs nc fu fw jc bi translated">每个Python初学者都应该学习的4个NumPy技巧</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">编写可读代码的技巧</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="pl l nh ni nj nf nk lb mw"/></div></div></a></div><p id="a0a9" class="pw-post-body-paragraph lt lu it lv b lw mo kd ly lz mp kg mb mc mq me mf mg mr mi mj mk ms mm mn ls im bi translated"><em class="pc">编码快乐！</em></p></div></div>    
</body>
</html>