<html>
<head>
<title>So why the heck are they called Support Vector Machines?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">那么，为什么他们被称为支持向量机呢？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/so-why-the-heck-are-they-called-support-vector-machines-52fc72c990a1?source=collection_archive---------23-----------------------#2020-03-23">https://towardsdatascience.com/so-why-the-heck-are-they-called-support-vector-machines-52fc72c990a1?source=collection_archive---------23-----------------------#2020-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2802" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的第一次有监督的机器学习很快就通过了:我对课程做了一些研究，并精心挑选了我想学习的主题。然后，我阅读了一些关于它们的文章，直到我理解了一般概念(或者我认为我理解了)，使用现成的 Scikit-Learn 版本的算法对它们进行了实验，然后继续前进。最近，我开始获得这些监督学习算法的正式、深入的知识(如果你愿意，可以说是“它们为什么工作”)。自然，支持向量机是基础的一部分，就在那时，我有了一个令人不安的发现:我不知道“支持向量机”是什么意思！我完全忽略了这样一个事实:这个花哨的名字可能有更深的含义。在这篇文章中，我总结了我的发现，并试图解释这个“复杂”名字背后的数学推理。</p><h1 id="9daa" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">感知器算法的缺点</h1><p id="d1bb" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">感知器算法是用于二进制分类的监督学习算法。形式上，它允许我们学习一个称为<strong class="jp ir">阈值函数</strong>的二进制分类器，它允许我们将<em class="lo"> n- </em>维空间中的一些<em class="lo"> x </em>映射到一个输出值<em class="lo"> f(x) </em> <strong class="jp ir"> <em class="lo">，</em> </strong>，这是一个二进制值:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/e564d8b060d8f43bd19de78573ade61f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jTUvf6prYRvzga0S5jRGfQ.png"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">用分段函数表示的二元分类器。</p></figure><p id="53fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，<em class="lo"> f(x) </em>为 1 的条件表达式包含点积<em class="lo"> w ⋅ x </em>形式的<strong class="jp ir">加权</strong>求和以及添加到其中的<strong class="jp ir">偏差</strong>。更仔细的观察告诉我们，我们可以重写条件，使得偏差代表我们的二元分类器的阈值:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mf"><img src="../Images/a6d2f616415f55d981a885b4e44c40ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AQ5Vjys0Ao_8zsSUlKpA5g.png"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">二进制分类器有条件重写以强调作为上述阈值的偏差。</p></figure><p id="c965" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，感知器是一个<strong class="jp ir">线性分类器</strong>，这意味着如果训练集<em class="lo"> D </em>不是线性可分的，那么使用学习算法将不会得到“近似”解决方案。然而，如果<em class="lo"> D </em>是线性可分的，那么算法保证找到线性分隔符。</p><p id="71b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，每个可线性分离的数据集允许<em class="lo">无限数量的可能线性决策边界</em>达到 0 的错误分类率。感知器肯定能找到其中的一个，但不能保证这个决策边界有多“好”。</p><blockquote class="mg"><p id="7086" class="mh mi iq bd mj mk ml mm mn mo mp kk dk translated">每个可线性分离的数据集允许<em class="mq">无限个</em>  <em class="mq">可能的线性判定边界</em>达到 0 的错误分类率。感知器肯定能找到其中的一个，但不能保证这个决策边界有多“好”。</p></blockquote><figure class="ms mt mu mv mw lu gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/273de9061e77ea76c72777d76745af18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*WKE6xuPNucGNmr2uXGzVXw.png"/></div><p class="mb mc gj gh gi md me bd b be z dk translated">2D 空间中的二进制分类问题，具有无限个分隔类别的决策边界。感知器算法可以产生这些决策边界中的任何一个。</p></figure><h1 id="faa5" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">最大空白分隔符:支持向量机的情况</h1><p id="1c1e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">这促使我们想出另一个算法，即<strong class="jp ir">最大化两个类之间的差距</strong>。边距被定义为数据实例和决策边界之间的<em class="lo">最小距离。</em></p><p id="01cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让决策边界由等式<em class="lo"> w ⋅ x + b = 0 定义。</em>在这种情况下，<em class="lo"> w </em>是超平面的<em class="lo"> n- </em>维法向量。我们将<em class="lo"> w </em>归一化，也就是说，如果它不是一个单位向量，就用它的长度来除它。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/038c4950b247674a552f2e0e28d618bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*U5DTPlRKSK8tUoSTP9k-_w.png"/></div><p class="mb mc gj gh gi md me bd b be z dk translated">边界与正类中最接近它的训练点之间的距离，后跟边界与负类中最接近它的训练点之间的距离。</p></figure><p id="2233" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设 T 是给定的 n 个训练实例的集合。我们需要找到一个向量<em class="lo"> w </em>来最大化裕量，它由下式给出:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi my"><img src="../Images/e62f4e6efbb522712298027dc9a49f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKldh-e_h_rBc297G0gwMQ.png"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">用数学方法表示的最大利润。请注意，方括号内的等式表示该点和边距之间的距离(存在“y”是为了区分正负类)。我们根据每个类中最接近它的点来定义边距，这就是为什么我们最小化所有训练示例的原因。</p></figure><h1 id="6580" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">将此公式化为约束优化问题</h1><p id="74e0" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">考虑向量组<em class="lo"> w </em>使得以下约束成立:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/31ce04c461cd508451815f50436bf853.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*qiyyjocIQCRo9UahDKJNsg.png"/></div></figure><p id="daa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些向量产生一个线性分隔符，该分隔符以非零边距完美地分隔数据<strong class="jp ir">。这有助于将一些等式引入到上述约束和比例<em class="lo"> w </em>中，以得到以下解集<em class="lo"> S </em>:</strong></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi na"><img src="../Images/625a8770d9dc4d996480be46d5c20e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*h8rMit99KGxIb12qVEEF-A.png"/></div></figure><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/983462e2697ecf4fa884fedba3c8665f.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/1*iOiC0uoFC6jekWa9T_Utpw.png"/></div></figure><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/91e486728485f0571e9e7b51a9ef172f.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*osvP4WkNRvup0Yb_xaw0Pg.png"/></div></figure><p id="13d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果<em class="lo"> D </em> =1，则</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/3c3565221196dd314ea8718937c50913.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*_uqRV-9daBxUi3nqukzJfg.png"/></div></figure><p id="2816" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反之，如果<em class="lo">D&gt;T27】1，则</em></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/9dfc53586c4978b8470d0273d75b52ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:230/format:webp/1*wwQ_neGLHpSyEiSgEzYyoQ.png"/></div></figure><p id="7541" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，如果最近点距离分离器超过 1 / || <em class="lo"> w </em> ||的距离，我们可以随时调整<em class="lo"> w </em>以确保距离减小。因此，数量 1 / || <em class="lo"> w </em> ||就是余量，我们需要最小化|| <em class="lo"> w </em> ||以便最大化余量。我们有以下优化问题:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nf"><img src="../Images/49c7a659fdedd039c39f0ce6927b170f.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*eCFolZRtyQlb1jD_-j6Tjw.png"/></div></div></figure><p id="36d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">受以下限制:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c2a9f18e55fdc078d780793adf0a806f.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*M4K8n307-aykMtG2kn9s-Q.png"/></div></figure><p id="e30d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个数学框架来解决这个问题，有一个警告我们需要解决:我们一直在假设我们拥有的数据是线性可分的。但如果不是呢？在这种情况下，<em class="lo"> S </em>将会是空的，我们将会得到一个不可行的解。我们可以通过放宽以下限制来解决这个问题:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nh"><img src="../Images/92310a9d836f1035be4aa37113f2491e.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*a_7FEiTDByR1q2SEO-8q5Q.png"/></div></div></figure><p id="5cb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们保持松弛常数ϵ &gt; 0，但是足够小，以便不会过冲并获得非最优解。我们将最小化问题改写为:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/3f25cd1a61bacb5c4e59b0295ab66899.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*sBv3XblGM_HKaHxMjrYd_g.png"/></div></figure><p id="7f2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参数<em class="lo"> C </em>代表最小化误差和最大化余量之间的折衷。通过<a class="ae nj" href="https://en.wikipedia.org/wiki/Quadratic_programming" rel="noopener ugc nofollow" target="_blank">二次规划</a>解决这个问题。</p><h1 id="baa2" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">输入支持向量</h1><p id="ce97" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">支持向量是满足约束的训练实例:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/77327a7d96499331769ae038594d9c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*x7m-NMy0tGfneeCuY7Tvpw.png"/></div><p class="mb mc gj gh gi md me bd b be z dk translated">训练实例成为支持向量所需满足的约束。</p></figure><p id="5b44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们移除除了支持向量之外的所有训练实例，我们的问题的解决方案，即最优(最大间隔)超平面保持不变。这就是它们被命名为“支持向量”的原因。这些训练实例可以被认为是“支持”或“支撑”最优超平面。</p><blockquote class="mg"><p id="4e2e" class="mh mi iq bd mj mk ml mm mn mo mp kk dk translated">这就是它们被命名为“支持向量”的原因。这些训练实例可以被认为是“支持”或“支撑”最优超平面。</p></blockquote><h1 id="fb6c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw nl ky kz la nm lc ld le nn lg lh li bi translated">支持向量机的目标</h1><p id="955c" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">那么，支持向量机如何处理我们提供给它们的数据呢？目标如下:</p><blockquote class="no np nq"><p id="ddf4" class="jn jo lo jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">假设每个数据点是<strong class="jp ir"> <em class="iq"> n </em> </strong> <em class="iq"> - </em>维的，支持向量机试图找到最大间隔的<strong class="jp ir">-<em class="iq">(n-1)</em>-</strong>维超平面<strong class="jp ir">。</strong></p></blockquote><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/c1660bc3b2050ce5fd5d15b167a44c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*FGzasG-84SHk_XXSClcoqA.png"/></div></figure><p id="be8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直观地，这被证明在提高分类器/回归器的性能方面非常有效，因为裕度越大，分类器/回归器的泛化误差越低。</p><h1 id="6071" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">参考</h1><p id="a78a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">"大页边距分隔符":<a class="ae nj" href="http://cs.brown.edu/people/pfelzens/engn2520/CS1420_Lecture_10.pdf" rel="noopener ugc nofollow" target="_blank">http://cs . brown . edu/people/pfelzens/engn 2520/cs 1420 _ Lecture _ 10 . pdf</a></p><p id="7d23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“支持向量机”:<a class="ae nj" href="https://en.wikipedia.org/wiki/Support-vector_machine" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Support-vector_machine</a></p></div></div>    
</body>
</html>