<html>
<head>
<title>Aggregating and grouping data in SQL with Group by and Partition by</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Group by 和 Partition by 对 SQL 中的数据进行聚合和分组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/aggregating-and-grouping-data-in-sql-with-group-by-and-partition-by-fd5eaccece75?source=collection_archive---------7-----------------------#2020-05-10">https://towardsdatascience.com/aggregating-and-grouping-data-in-sql-with-group-by-and-partition-by-fd5eaccece75?source=collection_archive---------7-----------------------#2020-05-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5b62" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过一个简单的例子理解 GROUP BY 和 PARTITION BY 之间的区别。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1136c502e779ac80ddb1cd09fc6c3eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPAlMN46I9ObMUehLmGHXw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">照片由</strong> <a class="ae kz" href="http://Caspar Camille Rubin" rel="noopener ugc nofollow" target="_blank"> <strong class="bd ky">卡斯帕卡米尔·鲁宾</strong></a><strong class="bd ky"/><a class="ae kz" href="https://unsplash.com/photos/fPkvU7RDmCo" rel="noopener ugc nofollow" target="_blank"><strong class="bd ky">Unsplash</strong></a></p></figure><h1 id="05be" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated"><strong class="ak">简介</strong></h1><p id="ef2d" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">聚合函数是一个非常强大的工具，可以用来分析数据和获得有用的业务洞察力。最常用的 SQL 聚合函数有<strong class="lu iu"> </strong> SUM、MAX、MIN、COUNT、AVERAGE。为了汇总数据，聚合器通常与分组功能结合使用。在这个故事中，我将向您展示如何使用聚合函数和分组函数的组合。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="06d4" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated">得到💬任何数据科学或编程问题的 GPT 式答案。为成千上万的人生成摘要和学习笔记📚只需一次点击即可获得学习资源。👉</p><div class="na nb gp gr nc nd"><a href="https://aigents.co/learn" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">面向数据科学家和开发人员的免费学习资源。精选的博客、教程、书籍和…</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">机器学习和人工智能工程师的培训课程、黑客马拉松、活动和工作</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">aigents.co</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ks nd"/></div></div></a></div></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="d358" class="la lb it bd lc ld ns lf lg lh nt lj lk jz nu ka lm kc nv kd lo kf nw kg lq lr bi translated"><strong class="ak">准备一些样本数据</strong></h1><p id="af7e" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">让我们使用下面的脚本为这节课准备一些样本数据。你可以使用自己选择的不同平台，例如<a class="ae kz" href="http://sqlfiddle.com/" rel="noopener ugc nofollow" target="_blank"> SQL FIDDLE </a>、<a class="ae kz" href="https://www.khanacademy.org/computer-programming/new/sql" rel="noopener ugc nofollow" target="_blank"> KHAN ACADEMY </a>等。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="95eb" class="oc lb it ny b gy od oe l of og">CREATE TABLE Customer (id INTEGER , name TEXT, product TEXT, OwnershipPercentage numeric(4,3) , Effective_date numeric);</span><span id="93b4" class="oc lb it ny b gy oh oe l of og">INSERT INTO Customer VALUES (1, “BankA”, “A01”, 0.028, 20180223) ;<br/>INSERT INTO Customer VALUES (1, “BankA”,”A02", 0.018, 20181224) ;<br/>INSERT INTO Customer VALUES (2, “BankB”,”B01", 0.025, 20190101) ;<br/>INSERT INTO Customer VALUES (2, “BankB”,”B02", 0.045, 20200101) ;</span><span id="671c" class="oc lb it ny b gy oh oe l of og">select * from Customer;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/cb248b9bda8ce39a374300c151ebbdc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*QccntmJS8RByEpcKIh8oTg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">表客户</strong></p></figure><h1 id="6c27" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated"><strong class="ak">问题</strong></h1><p id="91d6" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">现在您可以看到，对于每个客户，都有多个(在本例中是 2 个)关于不同产品的所有权百分比和生效日期的记录。比方说，我需要为我的老板制作一份报告，并希望做一些数据分析来支持我的报告。根据我想要看到的内容，我将使用不同的聚合函数。在这节课中，我将给出使用 SUM()和 MAX()函数的例子。您可以想出不同的场景来使用其他功能。</p><h1 id="4e3f" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated"><strong class="ak">解决方案</strong></h1><p id="5325" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">例如，我希望看到<strong class="lu iu">与之前的报告相比，每个客户的投资组合随着时间的推移发生了怎样的变化</strong>。为此，我希望看到每个客户的总所有权百分比，而不考虑产品。有两种方法可以做到这一点:使用分组依据和分区依据</p><p id="0dbf" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated"><strong class="lu iu">使用分组依据</strong></p><p id="b3ee" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated">很简单，我能做的就是使用 aggregate SUM()函数，后跟一个“GROUP BY”子句。在查询中，SUM()函数会将一个数字列(OwnershipPercentage)中的所有值相加。GROUP BY 子句将列中所有相同的值分组，这些列是我们选择的属性，在本例中是客户 ID 和名称。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="ecc4" class="oc lb it ny b gy od oe l of og">SELECT ID,<br/>Name,<br/>sum(p.ownershippercentage) AS onwership_percentage</span><span id="d5be" class="oc lb it ny b gy oh oe l of og">FROM Customer GROUP BY ID, Name</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/af54d26239a27f522c49b3e2d64f1b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*QjhbvQOabFjMRkUK14IWkA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">按</strong>分组的结果</p></figure><p id="7af9" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated"><strong class="lu iu">使用 OVER 和 PARTITION(BY) </strong></p><p id="317d" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated">获得类似结果的另一种方法是使用 OVER 和 PARTITION(BY)函数。要使用 OVER 和 PARTITION BY 子句，只需指定要对聚合结果进行分区的列。Over(partition by)子句将要求 SQL 只将每个分区内的值相加(在本例中为客户 ID)。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="1b76" class="oc lb it ny b gy od oe l of og">SELECT ID, <br/>Name,<br/>ProductID,<br/>OwnershipPercentage,<br/>sum(OwnershipPercentage) over(partition by ID) as total_ownership_percentage</span><span id="dd9d" class="oc lb it ny b gy oh oe l of og">FROM Customer c</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/523e294829a9f868418deb513dc6f9a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2QobtjamqqIahge_j7Bfw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">结果为过(分区通过)</strong></p></figure><p id="112c" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated">通过上面的查询，我将得到一个名为 total_ownership_percentage 的列，它是每个客户的所有权百分比值的总和。</p><p id="1487" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated">现在您可能已经意识到 GROUP BY 和 OVER(PARTITION BY)的输出之间的差异。GROUP BY 通过使用我们指定的属性汇总数据，从本质上减少了返回记录的数量。OVER(PARTITION BY)同时提供汇总的数据，而不汇总所有记录。在这种情况下，通过使用 PARTITION BY，我将能够返回每个客户的每个给定产品的 OwnershipPercentage 以及同一行中每个客户的总百分比。这意味着我将拥有每个客户的总所有权百分比的重复数据，但好的一面是，在聚合过程中没有数据丢失——与 GROUP BY 的情况相反。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="dc0d" class="oc lb it ny b gy od oe l of og">SELECT ID,Name, <br/>p.OwnershipPercentage,<br/>max(c.OwnershipPercentage) as ownership_percentage FROM Customer c GROUP BY ID,Name</span></pre><p id="9978" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated">使用上面的代码，我将收到这条消息:<em class="ol">列</em><strong class="lu iu"><em class="ol">‘客户。“OwnershipPercentage”在选择列表中无效，因为它既不包含在聚合函数中，也不包含在 GROUP BY 子句</em> </strong> <em class="ol">中。</em>这是因为 GROUP BY 将只返回每个组的唯一结果，并且选择列表只能包含作为 GROUP BY 子句一部分的聚合函数或列。</p><p id="1cb9" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated">因此，根据您想要得到的结果，您可以使用不同的函数来获得最佳输出。当您需要每个组有一个唯一的记录时，请选择 GROUP BY，当您不想丢失任何数据但仍想进行聚合时，PARTITION BY 将是最佳选择。</p><p id="65e8" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated"><strong class="lu iu">使用聚合最大值()和分组依据</strong></p><p id="fd84" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated">下面是另一个使用 MAX()的场景。假设我现在想知道最近添加的产品及其每个客户的所有权百分比。</p><p id="f6d8" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated">一种解决方案是在子查询中应用 aggregate Max()函数和 GROUP BY。子查询是另一个 SQL 语句中的 SELECT 语句。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8a99" class="oc lb it ny b gy od oe l of og">select c.Name, <br/>c.ownershippercentage,<br/>c.Effective_date as effective_date<br/>from Customer c</span><span id="5ffd" class="oc lb it ny b gy oh oe l of og">inner join (</span><span id="6309" class="oc lb it ny b gy oh oe l of og">select Name, <br/>max(Effective_date) as max_date<br/>from Customer group by Name) d</span><span id="07d2" class="oc lb it ny b gy oh oe l of og">on c.Name = d.Name<br/>and c.Effective_date = d.max_date</span></pre><p id="2bb7" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated">子查询将返回一个我称为“d”的表。通过这个子查询，我获得了表“d”中每个客户的最新生效日期。在此基础上，我在表“Customer”和表“d”之间执行了一个连接，以得出最近生效日期的 OwnershipPercentage。上述查询将给出您想要的输出，但不是最佳解决方案。我们必须在子查询中使用 JOIN 语句以及 aggregate MAX()和 GROUP BY 的组合，这增加了复杂性。在下面找到更有效的代码:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="c911" class="oc lb it ny b gy od oe l of og">SELECT c.ID, c.Name, c.ProductID, c.OwnershipPercentage, c.Effective_Date</span><span id="4ff1" class="oc lb it ny b gy oh oe l of og">FROM Customer c</span><span id="9db7" class="oc lb it ny b gy oh oe l of og">WHERE c.Effective_Date = (SELECT MAX(p.Effective_Date) FROM Customer p WHERE p.ID = C.ID)</span></pre><p id="4f5a" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated">任何一种方法都会得到如下相同的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/7bd94a8baac9d8d8fea9d9db9683206c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*30imlnbP0jhhBi1SVf3u8A.png"/></div></figure><p id="6907" class="pw-post-body-paragraph ls lt it lu b lv mv ju lx ly mw jx ma mb mx md me mf my mh mi mj mz ml mm mn im bi translated">感谢您的阅读。希望这对学习有帮助。</p></div></div>    
</body>
</html>