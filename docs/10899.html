<html>
<head>
<title>Genetic Algorithm Based Approach for Robotic Controllers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于遗传算法的机器人控制器方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/genetic-algorithm-based-approach-for-robotic-controllers-3966a9b874fb?source=collection_archive---------32-----------------------#2020-07-29">https://towardsdatascience.com/genetic-algorithm-based-approach-for-robotic-controllers-3966a9b874fb?source=collection_archive---------32-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bbc7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">用 Python 实现</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/82f53a4a3d81d08b4f8b02a83766de05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Gr5PtQGgH4vYOpBb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@ekrull?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃里克·克鲁尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ec26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们要解决的一个现实问题是设计一个机器人控制器。有许多技术可以用来解决这个问题。其中包括遗传算法、粒子群优化算法和神经网络。</p><p id="b5be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的是将一种算法应用于机器人，作为设计机器人控制器的方法，使机器人能够执行复杂的任务和行为。</p><blockquote class="lv"><p id="7874" class="lw lx it bd ly lz ma mb mc md me lu dk translated">自主机器人是指在没有人类帮助的情况下，能够独立完成一定工作的机器人。</p></blockquote><p id="0685" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">机器人的能力之一是从一点移动到另一点，这称为自主导航。想象一下，我们建造了一个可以在仓库里移动货物的机器人。在本文中，我们将使用 Python 语言实现这一功能。机器人如何看到它的局部环境？是的，我们将安装传感器，这使机器人可以环顾四周，我们给了它轮子，所以它可以根据传感器的输入进行导航。最大的问题是我们如何将传感器数据与电机动作联系起来，以便机器人能够在仓库中导航。</p><p id="e8c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，我们经常使用神经网络，通过在学习过程中使用强化学习算法，成功地将机器人传感器映射到输出。但是我们今天将使用另一种方法，那就是使用遗传算法。通常，遗传算法将通过使用适应度函数来评估大量个体，以找到下一代的最佳个体，该适应度函数基于某些预定义的规则来计算个体的表现。</p><p id="8fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们将面临一个新的挑战，对每个机器人控制器进行物理评估对于一个大群体来说是不可行的，因为对每个机器人控制器进行物理测试是困难的，而且这样做需要时间。为此，我们将使用我们的遗传算法知识来设计和实现机器人控制器，并将其应用于虚拟环境中的虚拟机器人。</p><h1 id="409b" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">目标</h1><p id="0054" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们的机器人可以采取四种行动:向前一步，左转，右转，什么也不做。</p><p id="fc8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图中机器人也有六个传感器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/1fc4c11d7a6a3723466f2cd242f9cdb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*3BoyAnO2flkAB4_SrE1NmA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">有 6 个传感器的机器人</p></figure><ul class=""><li id="4098" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">前面三个</li><li id="d6d9" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">一个在左边</li><li id="bc33" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">一个在右边</li><li id="8f36" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">一个在后面</li></ul><p id="c438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迷宫由机器人无法跨越的墙壁组成，并将有一条勾勒出的路线。我们将设计一个机器人控制器，它可以使用机器人传感器来成功地引导机器人通过迷宫。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/745052abb3dbab629a27fb8aa177ba0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*mkC_erGnTpQ4vDOuZzVGIw.png"/></div></figure><h1 id="f4e0" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">解决方案</h1><h2 id="6b2d" class="nx ml it bd mm ny nz dn mq oa ob dp mu li oc od mw lm oe of my lq og oh na oi bi translated">遗传算法伪代码</h2><p id="a1f7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">基本遗传算法的伪代码如下</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="8b6d" class="nx ml it ok b gy oo op l oq or">generation = 0;<br/>population[generation] = initializePopulation(populationSize); <br/>evaluatePopulation(population[generation]);<br/>While isTerminationConditionMet() == false do <br/>    parents = selectParents(population[generation]); <br/>    population[generation+1] = crossover(parents); <br/>    population[generation+1] = mutate(population[generation+1]);<br/>    evaluatePopulation(population[generation]);<br/>    generation++;<br/>End loop;</span></pre><p id="7803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个伪代码演示了一个遗传算法的基本过程。接下来，我们将用 Python 实现它们。</p><h2 id="3281" class="nx ml it bd mm ny nz dn mq oa ob dp mu li oc od mw lm oe of my lq og oh na oi bi translated">将传感器值映射到动作</h2><p id="cabf" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">如前所述，机器人有四个动作，可以用二进制表示如下:</p><ul class=""><li id="bcec" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">“00”——什么都不做；</li><li id="eaea" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">“01”——前进；</li><li id="e14c" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">“10”——左转；</li><li id="f976" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">还有“11”——右转。</li></ul><p id="3157" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有六种不同的传感器。为了简化表示，我们将测量限制为二进制编码，也就是说，小于阈值的值表示检测到障碍物，大于阈值的值表示畅通无阻。6 个传感器为我们提供了 2⁶ = 64 种可能的传感器输入组合。由于一个动作需要 2 位，我们的控制器需要 64*2 = 128 位的存储来表示任何可能的输入。假设我们需要 128 位来表示不同组合指令。但是，我们应该如何组织染色体，以便对其进行编码和解码呢？</p><p id="1d5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个人类可读的输入和输出列表，如下所示:</p><ul class=""><li id="b12e" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">传感器#1(前):开</li><li id="7145" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">传感器#2(左前):关闭</li><li id="3f83" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">传感器#3(右前):开</li><li id="1804" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">传感器#4(左侧):关闭</li><li id="d421" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">传感器#5(右):关闭</li><li id="f301" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">传感器#6(背面):关闭</li></ul><p id="dc0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有一个二进制值为 10 的“左转”指令。下一步是获取六个传感器值并进一步编码。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="1e26" class="nx ml it ok b gy oo op l oq or">000101 =&gt; 10</span></pre><p id="b515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在将传感器值的位串转换为十进制，我们会得到以下结果:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="e6b7" class="nx ml it ok b gy oo op l oq or">5 =&gt; 10</span></pre><p id="2d99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以使用传感器的十进制值作为染色体中的位置，表示传感器输入的组合，如下所示。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="526e" class="nx ml it ok b gy oo op l oq or">xx xx xx xx xx 10 xx xx xx xx (… 54 more pairs…)</span></pre><p id="5ecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从下图中可以看出，传感器值的组合产生了一个二进制输出，描述了典型的染色体如何将机器人的传感器值映射到动作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/d6be1c492604c0d8a24d24c3d38a6768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HxuftYRr5KAmsOo28SYk5g.png"/></div></div></figure><p id="6f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种编码方案初看起来可能很迟钝，染色体也不可读，但它有几个有用的特性。</p><ul class=""><li id="755d" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">首先，染色体可以作为一组位来操作，这使得交叉、变异和其他操作更加容易。</li><li id="1de4" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">其次，每个 128 位的值都是有效的解。</li></ul><h1 id="9428" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">履行</h1><p id="8111" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">首先，我们需要在(<code class="fe ot ou ov ok b">world.py</code>文件)中创建并初始化一个迷宫来运行机器人。我们创建的迷宫对象使用整数来表示不同的地形类型:</p><ul class=""><li id="f579" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">1 定义了一面墙；</li><li id="fa0e" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">2 是起始位置；</li><li id="a8b5" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">3 描绘通过迷宫的最佳路线；</li><li id="e9e3" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">4 是目标位置；</li><li id="b58a" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">0 是一个空位置，机器人可以走过，但不在通往目标的路线上。</li></ul><p id="ce76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们编写了一个构造函数来从一个 double int 数组创建一个新的迷宫，并实现公共方法来获得起始位置，在迷宫中找到一条路线。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h2 id="a5a0" class="nx ml it bd mm ny nz dn mq oa ob dp mu li oc od mw lm oe of my lq og oh na oi bi translated">个人</h2><p id="ed11" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">一个个体由一条由多个基因组成的染色体代表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h2 id="53a4" class="nx ml it bd mm ny nz dn mq oa ob dp mu li oc od mw lm oe of my lq og oh na oi bi translated">机器人</h2><p id="e7b6" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">接下来，我们需要创建一个能够遵循指令并通过执行这些指令来生成路线的机器人。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h2 id="3662" class="nx ml it bd mm ny nz dn mq oa ob dp mu li oc od mw lm oe of my lq og oh na oi bi translated">人口</h2><p id="a775" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">群体是指一组染色体。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h2 id="b5b6" class="nx ml it bd mm ny nz dn mq oa ob dp mu li oc od mw lm oe of my lq og oh na oi bi translated">遗传算法</h2><p id="0c47" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们实现了计算适应度、选择个体、交叉和变异的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h2 id="1ef1" class="nx ml it bd mm ny nz dn mq oa ob dp mu li oc od mw lm oe of my lq og oh na oi bi translated">机器人控制器</h2><p id="287b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">最后，我们可以编写一个实际执行算法的类。如下创建另一个名为<code class="fe ot ou ov ok b">main.py</code>的新文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="eccc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/fa630a33a0ba40c3cd156f673a095890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rj93sSHpLuyIukm4IertSA.png"/></div></div></figure><p id="c452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，对吧？</p><h1 id="3805" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">参考</h1><p id="c57f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">[1] <a class="ae ky" rel="noopener" target="_blank" href="/an-introduction-to-genetic-algorithms-c07a81032547">遗传算法简介</a></p><p id="833c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]<a class="ae ky" href="https://github.com/housecricket/Genetic-Algorithm-Based-Approach-for-Robotic-Controllers" rel="noopener ugc nofollow" target="_blank">https://github . com/house cricket/基于遗传算法的机器人控制器方法</a></p></div></div>    
</body>
</html>