<html>
<head>
<title>Tutorial: Network Visualization Basics with Networkx and Plotly in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">教程:Python中Networkx和Plotly的网络可视化基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tutorial-network-visualization-basics-with-networkx-and-plotly-and-a-little-nlp-57c9bbb55bb9?source=collection_archive---------2-----------------------#2020-05-15">https://towardsdatascience.com/tutorial-network-visualization-basics-with-networkx-and-plotly-and-a-little-nlp-57c9bbb55bb9?source=collection_archive---------2-----------------------#2020-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="23e7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从莎士比亚的剧本到网络图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9608b9f901c178ab87a999b7985ea7cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2zxUSsBHAnVjA4-70zo8mg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">人物网络图<em class="kz">仲夏夜之梦</em>T3】</strong></p></figure><p id="9ef5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于这个项目，我想结合我对文学、社会学和数据科学的热爱。更具体地说，我从大学时代起就对社交网络感兴趣，鉴于最近的事件，代表不同代理如何连接变得越来越重要。所以我开发了一个<em class="lw">仲夏夜之梦</em>的人物网络，这是我最喜欢的莎翁剧。如果你还没有读过它，并且喜欢一些相当异想天开的东西，我会推荐它！</p><p id="82ea" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在下面的帖子中，我将首先介绍网络的基础知识。然后，我将简要回顾一下我用来以我需要的格式获取数据的代码。然后，我检查了我用来创建和定制上述图表的代码。我使用的所有资源都在底部链接。希望这篇教程有帮助！如有任何问题，欢迎留言！制图快乐！</p><p id="8e83" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">所有的代码都可以在</strong><a class="ae lx" href="https://github.com/rweng18/midsummer_network" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">my GitHub repo</strong></a><strong class="lc iu">上找到。</strong></p><p id="0501" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">(这篇博客的灵感来自马丁·格兰让的惊人之作《将莎士比亚悲剧中的网络可视化》，你可以在这里找到</strong><a class="ae lx" href="http://www.martingrandjean.ch/network-visualization-shakespeare/" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu"/></a><strong class="lc iu">。)</strong></p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="3f10" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">目标</h1><ul class=""><li id="a819" class="mx my it lc b ld mz lg na lj nb ln nc lr nd lv ne nf ng nh bi translated">解释如何使用Python的Networkx包和Plotly创建视觉上吸引人的网络图</li><li id="1c99" class="mx my it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated">为了举例说明一个网络绘图的应用程序和我采取的一些数据清理步骤(因为我处理的是自然语言数据，所以数据清理比我在这篇文章中介绍的要复杂得多)</li><li id="edaf" class="mx my it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated">提供一些技巧、示例代码和资源</li></ul></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="8068" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">01:网络由哪些部分组成？</h1><p id="9ad7" class="pw-post-body-paragraph la lb it lc b ld mz ju lf lg na jx li lj nn ll lm ln no lp lq lr np lt lu lv im bi translated">在我们可视化任何东西之前，我们需要理解我们如何定义一个网络。出于本练习的目的，我们将使用以下定义:</p><blockquote class="nq nr ns"><p id="4097" class="la lb lw lc b ld le ju lf lg lh jx li nt lk ll lm nu lo lp lq nv ls lt lu lv im bi translated">一个<strong class="lc iu">网络</strong>由一组<strong class="lc iu">节点</strong>组成，这些节点通过一组<strong class="lc iu">边</strong>相互连接。</p></blockquote><p id="8cf9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以将<strong class="lc iu">节点</strong>视为我们试图连接的任何类型的代理或对象。例如，在我的例子中，我的节点是<em class="lw">仲夏夜之梦</em>中的人物，但是如果您想要显示纽约市的地铁网络，您的节点可能是地铁站。</p><p id="9d63" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可以把<strong class="lc iu">边</strong>想象成节点之间的连接。在我的项目中，我认为连接剧中角色的是他们一起出现的场景。我认为，如果两个角色(节点)一起出现在一个场景中(一条边)，它们就是相连的。对于地铁网络的例子，它可能是地铁线路。所以两个地铁站(节点)是相连的，如果一条地铁线在两个站(一条边)之间运行。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="f5a8" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">02:让我们看一个NLP的例子</h1><p id="8f49" class="pw-post-body-paragraph la lb it lc b ld mz ju lf lg na jx li lj nn ll lm ln no lp lq lr np lt lu lv im bi translated">既然我们已经了解了网络的基本知识，我们可以开始将我们的理解转化为代码。我们需要以下东西来创建网络图:</p><ol class=""><li id="98d5" class="mx my it lc b ld le lg lh lj nw ln nx lr ny lv nz nf ng nh bi translated">最原始的数据——一个文本文件的脚本<em class="lw">的《仲夏夜之梦》</em></li><li id="bcfa" class="mx my it lc b ld ni lg nj lj nk ln nl lr nm lv nz nf ng nh bi translated">节点——T4《仲夏夜之梦》中的人物列表</li><li id="f9e2" class="mx my it lc b ld ni lg nj lj nk ln nl lr nm lv nz nf ng nh bi translated">边缘——一种数据结构，告诉我们每个角色何时与另一个角色一起出现在场景中<strong class="lc iu"> (*注意:这是项目中最耗时的部分)</strong></li></ol><p id="9494" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">既然我们已经在高层次上建立了我们所需要的东西，我们就可以开始编码了。</p><h2 id="cb7a" class="oa mg it bd mh ob oc dn ml od oe dp mp lj of og mr ln oh oi mt lr oj ok mv ol bi translated">导入包</h2><p id="e59c" class="pw-post-body-paragraph la lb it lc b ld mz ju lf lg na jx li lj nn ll lm ln no lp lq lr np lt lu lv im bi translated">对于这个项目，我需要两套不同的包。第一个是收集和清理我的数据，这样我就可以在Python数据结构中拥有一组节点和边。第二组包用于可视化。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="483f" class="oa mg it on b gy or os l ot ou"># Import packages for data cleaning<br/>import numpy as np<br/>import pandas as pd<br/>import re # For finding specific strings in the text</span><span id="a01f" class="oa mg it on b gy ov os l ot ou"># Import packages for data visualization<br/>import plotly.offline as py<br/>import plotly.graph_objects as go<br/>import networkx as nx</span></pre><h2 id="6a4d" class="oa mg it bd mh ob oc dn ml od oe dp mp lj of og mr ln oh oi mt lr oj ok mv ol bi translated">加载数据</h2><p id="e2ff" class="pw-post-body-paragraph la lb it lc b ld mz ju lf lg na jx li lj nn ll lm ln no lp lq lr np lt lu lv im bi translated">在安装和加载包之后，您可以加载原始数据。我在这里找到了古腾堡计划<a class="ae lx" href="https://www.gutenberg.org/ebooks/1514" rel="noopener ugc nofollow" target="_blank">的<em class="lw">仲夏夜之梦</em>的文本</a>。</p><p id="6c98" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><a class="ae lx" href="https://www.gutenberg.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iu">古腾堡计划</strong> </a>是一个令人惊叹的免费电子书图书馆。有超过60，000本电子书，如果你想探索自然语言处理(NLP)的世界，我强烈推荐你把它作为一种资源。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="65d8" class="oa mg it on b gy or os l ot ou"># Load the data<br/>f = open("midsummer.txt", "r")<br/>whole_text = f.read()</span></pre><h2 id="0f92" class="oa mg it bd mh ob oc dn ml od oe dp mp lj of og mr ln oh oi mt lr oj ok mv ol bi translated">检查和清理数据:简要概述</h2><p id="e9c4" class="pw-post-body-paragraph la lb it lc b ld mz ju lf lg na jx li lj nn ll lm ln no lp lq lr np lt lu lv im bi translated">因为这不是一篇NLP文章，所以我只强调我在处理自然语言数据时必须考虑的一些问题。</p><blockquote class="nq nr ns"><p id="50b2" class="la lb lw lc b ld le ju lf lg lh jx li nt lk ll lm nu lo lp lq nv ls lt lu lv im bi translated">如果你对我的数据清理代码的细节部分感兴趣，请随意查看我的GitHub，上面和下面都有链接。</p></blockquote><p id="72a8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">第一步:查看你的数据</strong></p><p id="4e18" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我知道这听起来很基本，但是如果你想可视化你的数据，最好的做法是真正理解你的数据。例如，下面是我问我的数据的一些问题:</p><ul class=""><li id="77de" class="mx my it lc b ld le lg lh lj nw ln nx lr ny lv ne nf ng nh bi translated">有我能得到我的节点的一个字符列表吗？我怎样才能找到它？(是的。从“戏剧人物”开始)</li><li id="3ce4" class="mx my it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated">有没有一条线清楚地把每个场景分开？(是的。“场景”)</li><li id="f301" class="mx my it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated">在这个关键字之前或之后，是否有多余的字符需要我处理或删除？(是的。)</li><li id="3b15" class="mx my it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated">我怎样才能知道一个场景中有哪些角色？(特定格式的阶段说明！“进入”、“退出”和许多不同的变化，我不会在这里进入，因为它是非常特定的NLP。)</li></ul><p id="db92" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">第二步:从你的数据中提取一个简单的样本，并尝试处理它</strong></p><p id="4317" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您试图获取整个脚本并对其进行处理，这将非常容易出错，并且您可能会错过模块化代码的机会。所以我拍了第一幕第二场，因为所有的角色都在场景的开始进入，没有其他的角色进入，也没有人在场景结束前离开。</p><ul class=""><li id="bc0e" class="mx my it lc b ld le lg lh lj nw ln nx lr ny lv ne nf ng nh bi translated">什么样的数据结构最适合以最符合逻辑的方式获取最多的信息？(我主要用了一本字典的字典。)</li></ul><p id="5427" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">第三步:</strong> <strong class="lc iu">模块化你的流程</strong></p><p id="126f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我用两个主函数和几个辅助函数创建了一个process.py文件。这绝不是唯一的方法，但这是我解决问题的方法，我的数据是复杂多样的。</p><ul class=""><li id="b8be" class="mx my it lc b ld le lg lh lj nw ln nx lr ny lv ne nf ng nh bi translated">1函数为节点和边创建了一个空数据结构</li><li id="ef70" class="mx my it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated">1函数接收一个场景，并获取在给定时间内出现的所有角色</li><li id="9aa3" class="mx my it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated">当一个新的角色出现或者一个角色退出时，辅助函数进行处理，等等。</li></ul><p id="6e3c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面是我的数据结构的一个例子:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="f88a" class="oa mg it on b gy or os l ot ou"># Create the empty data structure using custom function<br/>appearance_counts = get_empty_appearances(characters, True)</span><span id="926f" class="oa mg it on b gy ov os l ot ou"># Show a part of the data structure<br/># Dictionary of dictionaries where each key is each character and each value is a dictionary with all other characters as keys, and values as 0 or [].<br/><br/>appearance_counts<br/>{'Theseus': {'Hippolyta': 0,<br/>  'Egeus': 0,<br/>  'Hermia': 0,<br/>  'Helena': 0,<br/>  'Lysander': 0,<br/>  'Demetrius': 0,...</span></pre><p id="3e1e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">第四步:使用你的函数来处理数据</strong></p><p id="85e3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在我有了这些数据结构，我需要用重要的信息填充这个结构——每个字符与另一个字符(边)一起出现了多少次。</p><blockquote class="nq nr ns"><p id="6727" class="la lb lw lc b ld le ju lf lg lh jx li nt lk ll lm nu lo lp lq nv ls lt lu lv im bi translated">还有很多代码支持下面的代码片段。如果你有问题，你可以看到我的GitHub回购链接以上和以下的更多细节。</p></blockquote><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="6f1e" class="oa mg it on b gy or os l ot ou"># For each character that appears, get how many scenes the character # appears in and how many times each pair of characters appears <br/># together<br/>for character in all_appearances:<br/>    scene_counts[character] = []<br/>    for co_char in all_appearances[character]:<br/>        appearance_counts[character][co_char] = len(all_appearances[character][co_char])<br/>        scene_counts[character].extend(all_appearances[character][co_char])<br/>        <br/>    scene_counts[character] = len(set(scene_counts[character]))</span></pre><p id="d182" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">终于！你有你的优势！</strong></p><blockquote class="nq nr ns"><p id="4551" class="la lb lw lc b ld le ju lf lg lh jx li nt lk ll lm nu lo lp lq nv ls lt lu lv im bi translated"><strong class="lc iu">注意:</strong>如果你对记录两个节点是如何连接的不感兴趣，而只关心两个节点是否连接，你可以只使用一个布尔值而不是一个整数。</p></blockquote><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="d26c" class="oa mg it on b gy or os l ot ou"># If the number is greater than 0, then the characters appeared in a<br/># scene together.</span><span id="84b7" class="oa mg it on b gy ov os l ot ou">appearance_counts<br/>{'Theseus': {'Hippolyta': 3,<br/>  'Egeus': 2,<br/>  'Hermia': 3,<br/>  'Helena': 2,<br/>  'Lysander': 3,<br/>  'Demetrius': 3,<br/>  'Philostrate': 2,<br/>  'Quince': 1,<br/>  'Snug': 1,<br/>  'Bottom': 2,<br/>  'Flute': 1,<br/>  'Snout': 1,<br/>  'Starveling': 1,...</span></pre><p id="8c19" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">不要忘记你的节点！</strong></p><blockquote class="nq nr ns"><p id="9874" class="la lb lw lc b ld le ju lf lg lh jx li nt lk ll lm nu lo lp lq nv ls lt lu lv im bi translated"><strong class="lc iu">注意:</strong>如果您对跟踪每个节点的重要性不感兴趣，而只关心节点的存在，那么您可以只使用一个列表来跟踪节点，而不是字典。</p></blockquote><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="812b" class="oa mg it on b gy or os l ot ou"># Number of scenes that each character appeared in<br/>scene_counts<br/>{'Theseus': 3,<br/> 'Hippolyta': 3,<br/> 'Egeus': 2,<br/> 'Hermia': 5,<br/> 'Helena': 6,<br/> 'Lysander': 5,<br/> 'Demetrius': 6,...</span></pre><h2 id="5311" class="oa mg it bd mh ob oc dn ml od oe dp mp lj of og mr ln oh oi mt lr oj ok mv ol bi translated">创建您的网络图</h2><p id="0606" class="pw-post-body-paragraph la lb it lc b ld mz ju lf lg na jx li lj nn ll lm ln no lp lq lr np lt lu lv im bi translated">我们将从创建图形、添加节点和添加边开始。有几行代码可以让你自定义你的图表，我会在这篇博文的最后一节把它们说出来。</p><p id="2755" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">添加节点&amp;边</strong></p><blockquote class="nq nr ns"><p id="f1d7" class="la lb lw lc b ld le ju lf lg lh jx li nt lk ll lm nu lo lp lq nv ls lt lu lv im bi translated"><strong class="lc iu">注意:</strong>我分别根据一个角色出现的场景数和两个角色共享的场景数，定制了节点的size变量和边的weight变量。这是可选的。</p></blockquote><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="b9b1" class="oa mg it on b gy or os l ot ou">midsummer = nx.Graph()</span><span id="8291" class="oa mg it on b gy ov os l ot ou"># Add node for each character<br/>for char in scene_counts.keys():<br/>    if scene_counts[char] &gt; 0:<br/>        midsummer.add_node(char, size = scene_counts[char])</span><span id="68ec" class="oa mg it on b gy ov os l ot ou"># For each co-appearance between two characters, add an edge<br/>for char in appearance_counts.keys():<br/>    for co_char in appearance_counts[char].keys():<br/>        <br/>        # Only add edge if the count is positive<br/>        if appearance_counts[char][co_char] &gt; 0:<br/>            midsummer.add_edge(char, co_char), weight = appearance_counts[char][co_char])</span></pre><blockquote class="nq nr ns"><p id="97f9" class="la lb lw lc b ld le ju lf lg lh jx li nt lk ll lm nu lo lp lq nv ls lt lu lv im bi translated">您可以使用属性<strong class="lc iu">仲夏.节点</strong>和<strong class="lc iu">仲夏.边</strong>查看Networkx图中的节点和边。</p></blockquote><p id="bd65" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">获得职位</strong></p><p id="ce0c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后我们需要得到图中节点的位置。有几种不同的布局可供选择。我认为春季的布置看起来是最好的。您可以在图形布局部分的<a class="ae lx" href="http://networkx.github.io/" rel="noopener ugc nofollow" target="_blank"> Networkx包的开发说明</a>中看到更多选项。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="0998" class="oa mg it on b gy or os l ot ou"># Get positions for the nodes in G<br/>pos_ = nx.spring_layout(midsummer)</span></pre><p id="b438" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">制作边缘痕迹</strong></p><p id="7041" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因为我是根据两个角色一起出现的场景数量来定制每条边的宽度/重量，所以我创建了一个定制函数，使用Plotly为每个节点对创建一个唯一的边轨迹。</p><blockquote class="nq nr ns"><p id="dcdc" class="la lb lw lc b ld le ju lf lg lh jx li nt lk ll lm nu lo lp lq nv ls lt lu lv im bi translated">该函数接受两个节点(字符)，<strong class="lc iu"> x </strong>和<strong class="lc iu"> y </strong>，当您将鼠标悬停在边缘上时想要显示的任何<strong class="lc iu">文本</strong>，以及边缘轨迹的<strong class="lc iu">宽度</strong>。</p></blockquote><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="b363" class="oa mg it on b gy or os l ot ou"># Custom function to create an edge between node x and node y, with a given text and width<br/>def make_edge(x, y, text, width):<br/>    return  go.Scatter(x         = x,<br/>                       y         = y,<br/>                       line      = dict(width = width,<br/>                                   color = 'cornflowerblue'),<br/>                       hoverinfo = 'text',<br/>                       text      = ([text]),<br/>                       mode      = 'lines')</span></pre><p id="fe4d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在您已经使用您的规范创建了一个函数，迭代您的边，并为指定宽度(由边的权重决定)的每条边创建一个边迹。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="84a1" class="oa mg it on b gy or os l ot ou"># For each edge, make an edge_trace, append to list<br/>edge_trace = []<br/>for edge in midsummer.edges():<br/>    <br/>    if midsummer.edges()[edge]['weight'] &gt; 0:<br/>        char_1 = edge[0]<br/>        char_2 = edge[1]</span><span id="2d63" class="oa mg it on b gy ov os l ot ou">x0, y0 = pos_[char_1]<br/>        x1, y1 = pos_[char_2]</span><span id="0bd6" class="oa mg it on b gy ov os l ot ou">text   = char_1 + '--' + char_2 + ': ' + str(midsummer.edges()[edge]['weight'])<br/>        <br/>        trace  = make_edge([x0, x1, None], [y0, y1, None], text, <br/>                           width = 0.3*midsummer.edges()[edge]['weight']**1.75)</span><span id="b8ed" class="oa mg it on b gy ov os l ot ou">edge_trace.append(trace)</span></pre><p id="15ae" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">制作节点轨迹</strong></p><p id="cb28" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于节点，您可以坚持只进行单个节点跟踪—单个散布对象—并仍然自定义每个节点的大小。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="c3c7" class="oa mg it on b gy or os l ot ou"># Make a node trace<br/>node_trace = go.Scatter(x         = [],<br/>                        y         = [],<br/>                        text      = [],<br/>                        textposition = "top center",<br/>                        textfont_size = 10,<br/>                        mode      = 'markers+text',<br/>                        hoverinfo = 'none',<br/>                        marker    = dict(color = [],<br/>                                         size  = [],<br/>                                         line  = None))<br/># For each node in midsummer, get the position and size and add to the node_trace<br/>for node in midsummer.nodes():<br/>    x, y = pos_[node]<br/>    node_trace['x'] += tuple([x])<br/>    node_trace['y'] += tuple([y])<br/>    node_trace['marker']['color'] += tuple(['cornflowerblue'])<br/>    node_trace['marker']['size'] += tuple([5*midsummer.nodes()[node]['size']])<br/>    node_trace['text'] += tuple(['&lt;b&gt;' + node + '&lt;/b&gt;'])</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="28d2" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">03:绘制和定制您的网络</h1><p id="d92b" class="pw-post-body-paragraph la lb it lc b ld mz ju lf lg na jx li lj nn ll lm ln no lp lq lr np lt lu lv im bi translated">现在我们有了包含所有节点的节点轨迹，以及我们的边轨迹，我们可以把它们放在一个图表中，看看它看起来像什么。</p><h2 id="49b6" class="oa mg it bd mh ob oc dn ml od oe dp mp lj of og mr ln oh oi mt lr oj ok mv ol bi translated">自定义您的布局</h2><p id="82c2" class="pw-post-body-paragraph la lb it lc b ld mz ju lf lg na jx li lj nn ll lm ln no lp lq lr np lt lu lv im bi translated">为了定制我的布局，我修改了网格线、图例和刻度标签的背景颜色和外观。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="bb73" class="oa mg it on b gy or os l ot ou"># Customize layout<br/>layout = go.Layout(<br/>    paper_bgcolor='rgba(0,0,0,0)', # transparent background<br/>    plot_bgcolor='rgba(0,0,0,0)', # transparent 2nd background<br/>    xaxis =  {'showgrid': False, 'zeroline': False}, # no gridlines<br/>    yaxis = {'showgrid': False, 'zeroline': False}, # no gridlines<br/>)</span><span id="1045" class="oa mg it on b gy ov os l ot ou"># Create figure<br/>fig = go.Figure(layout = layout)</span><span id="399a" class="oa mg it on b gy ov os l ot ou"># Add all edge traces<br/>for trace in edge_trace:<br/>    fig.add_trace(trace)</span><span id="399f" class="oa mg it on b gy ov os l ot ou"># Add node trace<br/>fig.add_trace(node_trace)</span><span id="06ff" class="oa mg it on b gy ov os l ot ou"># Remove legend<br/>fig.update_layout(showlegend = False)</span><span id="4d8c" class="oa mg it on b gy ov os l ot ou"># Remove tick labels<br/>fig.update_xaxes(showticklabels = False)<br/>fig.update_yaxes(showticklabels = False)</span><span id="d817" class="oa mg it on b gy ov os l ot ou"># Show figure<br/>fig.show()</span></pre><h2 id="02f9" class="oa mg it bd mh ob oc dn ml od oe dp mp lj of og mr ln oh oi mt lr oj ok mv ol bi translated">自定义您的颜色和文本</h2><p id="cbc6" class="pw-post-body-paragraph la lb it lc b ld mz ju lf lg na jx li lj nn ll lm ln no lp lq lr np lt lu lv im bi translated">在最基本的层面上，您总是可以自定义节点和边的颜色，以及静态显示在节点/边旁边或当您将鼠标悬停在节点或边上时显示的任何文本。</p><p id="ca1a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可以很容易地访问<strong class="lc iu">颜色</strong>和<strong class="lc iu">文本</strong>，只需使用节点和边缘轨迹中的属性。您会注意到我在本文分享的代码片段中调用这些属性的地方。但是我用来使我的文本更加突出的一个巧妙的技巧是学习如何加粗我的节点旁边的静态文本:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="a136" class="oa mg it on b gy or os l ot ou"># Add &lt;b&gt; and &lt;/b&gt; at the beginning and end of your string to bold<br/># the text in question!<br/>node_trace['text'] += tuple(['&lt;b&gt;' + node + '&lt;/b&gt;'])</span></pre><h2 id="2776" class="oa mg it bd mh ob oc dn ml od oe dp mp lj of og mr ln oh oi mt lr oj ok mv ol bi translated">自定义边缘宽度和节点大小</h2><p id="61c1" class="pw-post-body-paragraph la lb it lc b ld mz ju lf lg na jx li lj nn ll lm ln no lp lq lr np lt lu lv im bi translated">最后，我想在视觉上突出我所做的最重要的定制。这涉及到我认为最好的尝试和错误。以下代码行分别位于关于创建边跟踪和节点跟踪的部分:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="0171" class="oa mg it on b gy or os l ot ou"># Line that customized the width of each edge trace<br/>trace  = make_edge([x0, x1, None], [y0, y1, None], text, <br/>         width = 0.3*midsummer.edges()[edge]['weight']**1.75)</span><span id="1b77" class="oa mg it on b gy ov os l ot ou"># Line that customized the size of each node in the node trace<br/>node_trace['marker']['size'] += tuple([5*midsummer.nodes()[node]['size']])</span></pre><p id="c02d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">正如你所看到的，我硬编码了标量和指数，以确定在剧中x和y场景中出现的差异有多大(节点的大小)，或者在x和y场景中出现的角色相同(边缘的宽度)。你所使用的具体数字会极大地改变你的图表的外观。所以和他们一起玩，直到你感到满意为止！</p><h1 id="3402" class="mf mg it bd mh mi ow mk ml mm ox mo mp jz oy ka mr kc oz kd mt kf pa kg mv mw bi translated">奖金:未来网络项目的想法</h1><ul class=""><li id="012c" class="mx my it lc b ld mz lg na lj nb ln nc lr nd lv ne nf ng nh bi translated">创建一个以时间为变量的动画网络</li><li id="c4ea" class="mx my it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated">创建一个基于进出链接的维基百科文章网络</li><li id="e01c" class="mx my it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated">根据地铁线路在城市中创建地铁站网络</li><li id="f8bc" class="mx my it lc b ld ni lg nj lj nk ln nl lr nm lv ne nf ng nh bi translated">在一群人之间建立一个社交网络(注意，你需要某种封闭的系统或方法来监控网络成员在特定时间的变化)</li></ul><h1 id="dd51" class="mf mg it bd mh mi ow mk ml mm ox mo mp jz oy ka mr kc oz kd mt kf pa kg mv mw bi translated">资源</h1><div class="pb pc gp gr pd pe"><a href="https://www.gutenberg.org/" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">古登堡计划</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">古登堡计划是一个拥有超过60，000本免费电子书的图书馆。在免费的epub和Kindle电子书中选择，下载它们或…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">www.gutenberg.org</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps ks pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a href="https://plotly.com/python/network-graphs/" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">网络图</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">Dash是一个用于构建分析应用程序的开源框架，不需要Javascript，而且它是紧密结合的…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">plotly.com</p></div></div><div class="pn l"><div class="pt l pp pq pr pn ps ks pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a href="http://www.martingrandjean.ch/network-visualization-shakespeare/" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">网络可视化:映射莎士比亚的悲剧</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">莎士比亚的悲剧结构都一样吗？这些角色是相当孤立的，成组的，还是都有联系的…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">www . martingrandjen . ch</p></div></div><div class="pn l"><div class="pu l pp pq pr pn ps ks pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a href="http://networkx.github.io/" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">NetworkX - NetworkX文档</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">NetworkX是一个Python包，用于创建、操作和研究…的结构、动力学和功能</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">networkx.github.io</p></div></div></div></a></div><div class="pb pc gp gr pd pe"><a href="https://github.com/rweng18/midsummer_network" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">rweng 18/仲夏_网络</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">创建字符网络图。在……上创建一个帐户，为rweng 18/summers _ network的发展做出贡献</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">github.com</p></div></div><div class="pn l"><div class="pv l pp pq pr pn ps ks pe"/></div></div></a></div></div></div>    
</body>
</html>