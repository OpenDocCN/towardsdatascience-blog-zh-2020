<html>
<head>
<title>Introduction to Sequence Alignments with Biopython</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Biopython序列比对简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-sequence-alignments-with-biopython-f3b6375095db?source=collection_archive---------19-----------------------#2020-06-21">https://towardsdatascience.com/introduction-to-sequence-alignments-with-biopython-f3b6375095db?source=collection_archive---------19-----------------------#2020-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a9bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Biopython中使用序列比对软件包装器</h2></div><p id="ba25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上周，我开始用Biopython库摆弄Python中的一些生物信息学工具。<a class="ae le" href="https://medium.com/@wvsharber/introduction-to-genbank-and-bioinformatics-with-python-8a25a0f15e3f" rel="noopener">在我之前的帖子</a>中，我介绍了生物信息学领域，并提供了一个用Biopython的API接口从GenBank下载数据的例子。今天，我想转到分析DNA序列数据的下一个典型步骤——比对过程。我将对序列比对进行介绍，然后给出一个使用Biopython过滤一些数据并运行比对软件的简单示例。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="6a33" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">序列比对介绍</strong></p><p id="ce53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当处理生物序列数据(DNA、RNA或蛋白质)时，生物学家通常希望能够将一个序列与另一个序列进行比较，以便对序列的功能或进化做出一些推断。就像您不希望使用数据表中数据在错误的列进行分析一样，为了从序列数据中做出可靠的推断，我们需要确保我们的序列数据组织良好或“对齐”不幸的是，序列数据没有漂亮的标签，比如日期、每加仑英里数或马力。相反，我们所拥有的只是序列中的位置编号，而且只与该序列相关。幸运的是，许多序列在相关生物之间高度保守或相似(并且所有生物在某种程度上都是相关的！).如果我们相当确定我们已经从来自多个生物体的相同序列中获得了数据，我们可以将这些数据放入一个我们称之为比对的矩阵中。如果你只是比较两个序列，这叫做<em class="lm">成对比对</em>。如果您正在比较三个或更多序列，这被称为<em class="lm">多序列比对</em> (MSA)。</p><p id="9763" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">利用序列中每个分子的位置和身份，我们可以推断出每个分子在基质中的相对位置。有时序列中会有差异，比如在一个大多数序列都是C的位置，我们发现一个序列带有g，这被称为单核苷酸多态性(SNP)。在其他时候，我们发现一个序列缺少一个存在于其他序列中的分子，或者一个序列有一个额外的分子。前者是删除，而后者是插入，统称为“插入”当用indels比对序列时，我们必须通过在剩余的序列上添加缺口来解释这些额外的或缺失的分子。这些微小的差异通常是序列数据中有趣的部分，因为变异是我们如何对序列的功能或进化做出推断的。以下是SNPS和因德尔斯签订的管理服务协议的几个例子。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="0394" class="lw lx it ls b gy ly lz l ma mb">Example 1. Multiple Sequence Alignment with a Single Nucleotide Polymorphism (SNP) in Sequence 3 at position 3. </span><span id="eb8a" class="lw lx it ls b gy mc lz l ma mb">     1 2 3 4 5 6 7 8 &lt;- Nucleotide Positions<br/>Seq1 G T <strong class="ls iu">C</strong> G C A A A <br/>Seq2 G T <strong class="ls iu">C</strong> G C A A A<br/>Seq3 G T <strong class="ls iu">G</strong> G C A A A</span><span id="f6ab" class="lw lx it ls b gy mc lz l ma mb">Example 2. Multiple Sequence Alignment with an insertion in Sequence 1 at position 6.</span><span id="4577" class="lw lx it ls b gy mc lz l ma mb">     1 2 3 4 5 6 7 8<br/>Seq1 G T C G C <strong class="ls iu">A</strong> A A <br/>Seq2 G T C G C <strong class="ls iu">-</strong> A A<br/>Seq3 G T C G C <strong class="ls iu">-</strong> A A</span></pre><p id="da60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面两个例子中，序列长度短，序列个数少，序列间相似度高。因此，直观地排列序列非常容易。然而，如果您有数百个序列，有数千或数万个位置要对齐，您可能不想全部手动对齐！相反，有一些程序使用算法来排列序列。</p><p id="7107" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于算法来说，比对是非常有趣的问题。首先，您希望通过对齐序列来最小化它们之间的差异。对于不同的序列区域，该算法有两种选择:(1)在比对中添加一个缺口，说明“该区域对于该序列是唯一的，并且在其他序列中没有类似的东西，”或者(2)将不相似的序列比对在一起，实质上说明“这些在这里是不同的，但是周围的序列足够相似以保持位置结构相同。”如果算法的唯一目标是最小化差异，它只会不断增加差距！相反，大多数比对算法的第二个目标也是最小化缺口的数量，并且当缺口被引入时，它们被给予惩罚分数。由于要跨许多序列和序列中的许多位置执行两种优化，这些程序的计算时间和内存需求可能非常大。我已经等了几个小时甚至几天来完成跑步！</p><p id="9ed2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管排列序列很费时间，但结果在遗传和进化研究中至关重要。序列之间的相似性和差异可以告诉你一个生物体与另一个生物体的进化关系，或者一个基因与另一个基因相比的功能。不建立序列之间的关系，你就不能做出这种推论。我已经掩饰了进入这个过程的一些更好的细节和假设，但是，在本质上，比对是分子生物学世界的数据框架。</p><p id="b5fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">使用Biopython进行序列比对</strong></p><p id="d45b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我之前的文章中，我从GenBank下载了新型冠状病毒病毒(又名新冠肺炎病毒)样本的序列数据。我想将这些序列相互比较，以进行一些进化分析，但这首先需要比对！因此，继续我离开的地方，我将使用Biopython使用多序列比对软件MUSCLE来创建我的MSA。</p><p id="fba0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生物信息学python库Biopython有几个用于操作和构建序列比对的工具。<code class="fe md me mf ls b">Bio.AlignIO</code>和<code class="fe md me mf ls b">Bio.Align</code>模块包含这些工具。您可以读取和写入路线文件，转换其类型，并使用路线软件界面来创建路线。因为对齐软件相当慢，所以创建该软件的Python实现效率不是很高。相反，Biopython只是使用包装器来执行用其他更快的语言编写的软件。它基本上与从命令行运行这些软件相同，但是Biopython让您有机会完全在python中构建工作流。Biopython为九个常用的比对软件提供了包装器(在本文撰写之时)，您可以通过运行下面一行来查看这些包装器:<code class="fe md me mf ls b">import Bio.Align.Applications; dir(Bio.Align.Applications)</code>。</p><p id="bc8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用包装器非常类似于在命令行中使用它们。使用对齐的所有参数设置实例化一个对象，然后执行该对象。下面，我展示了如何将我的新型冠状病毒数据过滤成完整的序列，然后使用MUSCLE来排列这些序列。(<strong class="kk iu">注意:</strong>你需要先装上MUSCLE才可以。你可以<a class="ae le" href="http://www.drive5.com/muscle" rel="noopener ugc nofollow" target="_blank">在这里</a>下载肌肉。将可执行文件重命名为“muscle”会很有帮助然后，您应该确保<code class="fe md me mf ls b">muscle</code>在您的PATH中，即在<code class="fe md me mf ls b">usr/local/bin</code>目录中。只需将下载并重命名的副本复制并粘贴到该目录中。)</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="7df1" class="lw lx it ls b gy ly lz l ma mb">from Bio import SeqIO<br/>from Bio.Align.Applications import MuscleCommandline</span><span id="32ec" class="lw lx it ls b gy mc lz l ma mb">#Read in unfiltered data<br/>unfiltered = SeqIO.parse("../../data/raw/SARS-CoV-2.gbk", "genbank")</span><span id="5528" class="lw lx it ls b gy mc lz l ma mb">#Drop data without (close to) full length sequences<br/>full_length_records = []<br/>for record in unfiltered:<br/>    if len(record.seq) &gt; 29000:<br/>        full_length_records.append(record)</span><span id="c17a" class="lw lx it ls b gy mc lz l ma mb">#Write filtered data to file<br/>SeqIO.write(full_length_records, "../../data/raw/SARS-CoV-2.fasta", "fasta")</span><span id="352a" class="lw lx it ls b gy mc lz l ma mb">#Align sequences with MUSCLE (using parameters to make the alignment<br/>#process as fast as possible)<br/>muscle_cline = MuscleCommandline(input="SARS-CoV-2.fasta", <br/>                                 out="SARS-CoV-2_aligned.fasta", <br/>                                 diags = True, <br/>                                 maxiters = 1, <br/>                                 log="../../data/raw/align_log.txt")<br/>muscle_cline()</span></pre><p id="5674" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我前面提到的，运行校准需要相当长的时间。有一些在线服务可以比你在本地机器上更快地运行你的比对。如果你时间不够，这些可能会有用。此外，看起来有一些新兴的技术可以利用Hadoop和Spark等系统来并行化这一过程，但在推荐之前，我想进一步了解这些技术。</p><p id="2ced" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对齐完成后，您可以使用多种对齐查看器之一对其进行目视检查。不幸的是，这不是一个容易从命令行完成的过程，所以Biopython没有试图给你这种能力。是的，您可以读取与<code class="fe md me mf ls b">Bio.AlignIO</code>模块的对齐，并通过切片来迭代滚动，但这不是很有效。这是我用NCBI的多序列比对查看器打开的一个比对实例，这是一个基于浏览器的选项。</p><figure class="ln lo lp lq gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mg"><img src="../Images/a70ea00d64317c8344cb6aa5f4a81cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igeGEu5cZZgBirCFyanElw.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">多序列比对示例，用NCBI多序列比对查看器查看。</p></figure></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="1365" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我本周关于对齐的文章的结尾。下周，我将利用这里创建的比对继续分析新型冠状病毒数据。像往常一样，如果你有问题或意见，请告诉我！感谢阅读！</p></div></div>    
</body>
</html>