<html>
<head>
<title>How to Apply K-means Clustering to Time Series Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何对时间序列数据应用 K 均值聚类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-apply-k-means-clustering-to-time-series-data-28d04a8f7da3?source=collection_archive---------0-----------------------#2020-07-17">https://towardsdatascience.com/how-to-apply-k-means-clustering-to-time-series-data-28d04a8f7da3?source=collection_archive---------0-----------------------#2020-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="79a5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使 k-means 算法适应时间序列的理论和代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8fd7b56fbcf4520beabfb6341936254f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0E0q8WWOnDZhbFQ3.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://www.piqsels.com/en/public-domain-photo-zzzsy" rel="noopener ugc nofollow" target="_blank"> Piqsels </a>提供</p></figure><p id="e069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">聚类是一种无监督的学习任务，其中算法将相似的数据点分组，而没有任何“基础事实”标签。数据点之间的相似性用距离度量来衡量，通常是<a class="ae ky" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank">欧几里德距离</a>。</p><p id="0b41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将不同的时间序列聚类到相似的组中是一项具有挑战性的聚类任务，因为每个数据点都是有序的序列。</p><p id="1ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间序列聚类最常见的方法是将时间序列展平到一个表中，每个时间索引(或序列的聚合)有一列，并直接应用标准的聚类算法，如<a class="ae ky" href="https://scikit-learn.org/stable/modules/clustering.html#k-means" rel="noopener ugc nofollow" target="_blank"> k-means </a>。<em class="lv"> (K-means 是一种常见的聚类算法，通过将样本分成 K 组并最小化每个聚类中的平方和来构建数据聚类)。</em></p><p id="cfb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如下所示，这并不总是很好。图表中的每个子图都绘制了一个由具有欧几里德距离的 k 均值聚类生成的聚类。<em class="lv"> </em>红色的簇形心没有捕捉到系列的形状。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/5bf87e74d89eed475d8250e28adf8c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*fhgXrZR7dfNcOZBH8-FAew.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://tslearn.readthedocs.io/en/stable/user_guide/clustering.html" rel="noopener ugc nofollow" target="_blank">来源</a> : tslearn 文档</p></figure><p id="e237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直观上，标准聚类算法中使用的距离度量，如欧几里德距离，通常不适用于时间序列。更好的方法是<strong class="lb iu">用一个比较时间序列的度量代替默认的距离度量，比如</strong> <a class="ae ky" href="https://en.wikipedia.org/wiki/Dynamic_time_warping" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">动态时间扭曲</strong> </a>。</p><p id="f10a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将解释如何使用动态时间弯曲将 k 均值聚类调整到时间序列。我将提供来自<code class="fe lx ly lz ma b"><a class="ae ky" href="https://github.com/tslearn-team/tslearn" rel="noopener ugc nofollow" target="_blank">tslearn</a></code>包的简单代码示例。</p><h1 id="78b6" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">时间序列的动态时间弯曲距离度量</h1><p id="c40b" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">但首先，为什么常见的<a class="ae ky" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank">欧氏距离</a>度量<a class="ae ky" href="http://alexminnaar.com/2014/04/16/Time-Series-Classification-and-Clustering-with-Python.html" rel="noopener ugc nofollow" target="_blank">不适合</a>时间序列？简而言之，它对时间偏移是不变的，忽略了数据的时间维度。如果两个时间序列高度相关，但其中一个移动了一个时间步长，欧几里德距离就会错误地将它们测量为相距较远。点击<a class="ae ky" href="http://alexminnaar.com/2014/04/16/Time-Series-Classification-and-Clustering-with-Python.html" rel="noopener ugc nofollow" target="_blank">此处</a>查看详细示例。</p><p id="c318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，最好使用动态时间弯曲(DTW)来比较序列。DTW 是一种测量在时间、速度或长度上不完全一致的两个时间序列之间的相似性的技术。</p><h2 id="2b84" class="my mc it bd md mz na dn mh nb nc dp ml li nd ne mn lm nf ng mp lq nh ni mr nj bi translated">DTW 解释道</h2><p id="ba46" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">给定系列<strong class="lb iu"> X </strong> =(x₀、…、xₙ)和系列<strong class="lb iu"> Y </strong> =(y₀、…、yₘ)，从<strong class="lb iu"> X </strong>到<strong class="lb iu"> Y </strong>的 DTW 距离被公式化为以下优化问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/d221e89c55aeef08981ac9883c18a50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*uJIgUXGDH8cYOHkrIda8Ew.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://tslearn.readthedocs.io/en/stable/user_guide/dtw.html" rel="noopener ugc nofollow" target="_blank"> tslearn 文档</a></p></figure><p id="6d26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总结一下 DTW 方程:<strong class="lb iu"> DTW 计算为 X 中每个元素与其在 Y 中最近的点<em class="lv"/></strong>之间的平方距离之和的平方根。<em class="lv">注意，DTW(X，Y) ≠ DTW(Y，X)。</em></p><p id="2cc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们进一步分析一下。</p><p id="3c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DTW 将序列<strong class="lb iu"> X </strong>中的每个元素与序列<strong class="lb iu"> Y </strong>中的每个元素进行比较(n x m 比较)。比较起来，<em class="lv"> d(xᵢ，yⱼ)，</em>不过是简单的减法<em class="lv"> xᵢ — yⱼ </em>。</p><p id="187f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后对于<strong class="lb iu"> X </strong>中的每个<em class="lv"> xᵢ </em>，DTW 选择 y 中最近的点进行距离计算。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/44674fe0273264b8c2475dc93e9b58b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*m63OOTUf2NQYk5Y_69Y_XQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上图:说明 DTW 如何将蓝色系列中的每个点与红色系列中最近的点进行匹配。下图:说明欧几里得距离度量如何匹配两个时间序列中的点。请注意，系列长度不同，与欧几里得匹配不同，DTW 能够将蓝色系列中的每个点与红色系列中的一个点进行比较。来源:<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:Euclidean_vs_DTW.jpg" rel="noopener ugc nofollow" target="_blank"> wikicommons </a></p></figure><p id="8994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在<strong class="lb iu"> X </strong>和<strong class="lb iu"> Y </strong>之间创建了一条扭曲的“路径”,将 X 中的每个点与 Y 中最近的点对齐。该路径是时间序列的时间对齐，可最小化对齐序列之间的欧几里德距离。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/2d9ff1551538006db524ecd02ff5476f.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*MuDrv0mZWhZiTEajmTMrag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">两个时间序列(蓝色)之间的 DTW 路径(白线)的图像。热度图突出显示了距离值(<em class="nn"> xᵢ — yⱼ)。</em> <a class="ae ky" href="https://tslearn.readthedocs.io/en/stable/user_guide/dtw.html#dtw-softdtw" rel="noopener ugc nofollow" target="_blank"> <em class="nn">来源</em> </a> <em class="nn"> : tslearn 文档</em></p></figure><p id="e125" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用复杂度为 O(MN)的动态规划来计算动态时间弯曲。点击<a class="ae ky" href="https://en.wikipedia.org/wiki/Dynamic_time_warping" rel="noopener ugc nofollow" target="_blank">此处</a>或<a class="ae ky" href="http://alexminnaar.com/2014/04/16/Time-Series-Classification-and-Clustering-with-Python.html" rel="noopener ugc nofollow" target="_blank">此处</a>了解具体算法详情。</p><p id="9520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用 python 中的 DTW 很容易比较两个时间序列:</p><pre class="kj kk kl km gt no ma np nq aw nr bi"><span id="37d9" class="my mc it ma b gy ns nt l nu nv"><strong class="ma iu">from</strong> <strong class="ma iu">tslearn.metrics</strong> <strong class="ma iu">import</strong> dtw<br/>dtw_score = dtw(x, y)</span></pre><h2 id="765d" class="my mc it bd md mz na dn mh nb nc dp ml li nd ne mn lm nf ng mp lq nh ni mr nj bi translated">DTW 的变体:软 DTW</h2><p id="0b50" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated"><a class="ae ky" href="https://arxiv.org/abs/1703.01541" rel="noopener ugc nofollow" target="_blank">软 DTW </a>是 DTW 的一个可微分变体，它用一个可微分的<code class="fe lx ly lz ma b">soft-min</code>运算代替了不可微分的<code class="fe lx ly lz ma b">min</code>运算:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/261f330de174e58d3b1d6a8d7afed30e.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*xE3ECmCkB5-CldCodRnbDQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://tslearn.readthedocs.io/en/stable/user_guide/dtw.html#dtw-softdtw" rel="noopener ugc nofollow" target="_blank"> <em class="nn">来源</em> </a> <em class="nn"> : tslearn 文档</em></p></figure><p id="c2f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据该函数，软 DTW 依赖于一个超参数<em class="lv"> γ </em>来控制结果度量的平滑。像 DTW 一样，可以使用动态规划在二次时间内计算软 DTW。</p><p id="853a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">脚注:软 DTW 的主要优势源于它处处可微。这允许软 DTW 被用作神经网络损失函数，比较地面真实序列和预测序列。</p><pre class="kj kk kl km gt no ma np nq aw nr bi"><span id="56cc" class="my mc it ma b gy ns nt l nu nv"><strong class="ma iu">from</strong> <strong class="ma iu">tslearn.metrics</strong> <strong class="ma iu">import</strong> soft_dtw<br/>soft_dtw_score = soft_dtw(x, y, gamma=.1)</span></pre><h1 id="fc29" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">具有动态时间弯曲的 k-均值聚类</h1><p id="6d2b" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">通过以下修改，k-means 聚类算法可以应用于具有动态时间弯曲的时间序列。</p><ol class=""><li id="7446" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">动态时间弯曲(DTW)用于收集相似形状的时间序列。</li><li id="cd87" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">群集质心，或<em class="lv">重心</em>，是相对于 DTW 计算的。A <em class="lv">重心</em>是 DTW 空间中一组时间序列的平均序列。<a class="ae ky" href="http://lig-membres.imag.fr/bisson/cours/M2INFO-AIW-ML/papers/PetitJean11.pdf" rel="noopener ugc nofollow" target="_blank"> DTW 重心平均(DBA) </a>算法最小化重心和聚类中序列之间的 DTW 距离的平方和。<a class="ae ky" href="https://arxiv.org/abs/1703.01541" rel="noopener ugc nofollow" target="_blank">软 DTW 算法</a>最小化重心和聚类中系列之间的软 DTW 距离的加权和。权重可以调整，但总和必须为 1。</li></ol><p id="03a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果，质心具有模拟集群成员形状的平均形状，而不管成员之间的时间偏移发生在哪里。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/ab61fbdb126e53847aca07b4b1ca3502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*rKV7fP9oGWdaWTRg15ma7A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">顶行:使用 DTW 的 K-均值聚类(DBA 算法)。底部一行:使用软 DTW 的 K-均值聚类。每一列显示了来自不同簇的系列和它们的质心，用红色绘制。<a class="ae ky" href="https://tslearn.readthedocs.io/en/stable/auto_examples/clustering/plot_kmeans.html#sphx-glr-auto-examples-clustering-plot-kmeans-py" rel="noopener ugc nofollow" target="_blank">源码+代码</a>。</p></figure><p id="ff74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lx ly lz ma b"><a class="ae ky" href="https://tslearn.readthedocs.io/en/stable/user_guide/clustering.html" rel="noopener ugc nofollow" target="_blank">tslearn</a></code> Python 包，用 k-means 和 DTW 简单聚类时间序列数据集:</p><pre class="kj kk kl km gt no ma np nq aw nr bi"><span id="db51" class="my mc it ma b gy ns nt l nu nv"><strong class="ma iu">from</strong> <strong class="ma iu">tslearn.clustering</strong> <strong class="ma iu">import</strong> TimeSeriesKMeans</span><span id="e8b0" class="my mc it ma b gy om nt l nu nv">model = TimeSeriesKMeans(n_clusters=3, metric="dtw", max_iter=10)<br/>model.fit(data)</span></pre><p id="c989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用软 DTW 代替 DTW，只需设置<code class="fe lx ly lz ma b">metric="softdtw"</code>。</p><p id="0482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe lx ly lz ma b"><a class="ae ky" href="https://tslearn.readthedocs.io/en/stable/gettingstarted.html#time-series-format" rel="noopener ugc nofollow" target="_blank">tslearn</a></code>期望一个单一的时间序列被格式化为二维数组。一组时间序列应该被格式化为一个形状为<code class="fe lx ly lz ma b">(num_series, max_length, 1)</code>的三维数组。如果集合中的系列长度不等，则较短的系列将增加 NaN 值。tslearn 具有易于使用的<a class="ae ky" href="https://tslearn.readthedocs.io/en/stable/gettingstarted.html#time-series-format" rel="noopener ugc nofollow" target="_blank">实用函数</a>用于正确格式化数据，并且<a class="ae ky" href="https://tslearn.readthedocs.io/en/stable/integration_other_software.html" rel="noopener ugc nofollow" target="_blank">易于与其他时间序列包和数据格式</a>集成。</p><h1 id="76d0" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">最后一句话</h1><p id="e86c" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">我希望你喜欢读这篇文章。要了解时间序列机器学习，请查看我的其他文章:</p><div class="on oo gp gr op oq"><a href="https://link.medium.com/1nJUjkUg4bb" rel="noopener follow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">如何对时间序列应用层次聚类</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">聚类是一种无监督的学习任务，其中算法将相似的数据点分组，而没有任何“基础事实”…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">link.medium.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a rel="noopener follow" target="_blank" href="/a-brief-introduction-to-time-series-classification-algorithms-7b4284d31b97"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">时间序列分类算法简介</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">专门为时间序列分类设计的专用算法</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pf l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://medium.com/towards-artificial-intelligence/highly-comparative-time-series-analysis-a-paper-review-5b51d14a291c" rel="noopener follow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">高度比较的时间序列分析——一篇论文综述</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">用于比较、聚类、分类和注释的时间序列特征提取分析</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">medium.com</p></div></div><div class="oz l"><div class="pg l pb pc pd oz pe ks oq"/></div></div></a></div><h1 id="47cd" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">参考</h1><ul class=""><li id="17d1" class="nx ny it lb b lc mt lf mu li ph lm pi lq pj lu pk od oe of bi translated"><a class="ae ky" href="https://databricks.com/blog/2019/04/30/understanding-dynamic-time-warping.html" rel="noopener ugc nofollow" target="_blank">通过数据块了解动态时间扭曲</a></li><li id="ddd4" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu pk od oe of bi translated">帕帕里佐斯，约翰和格拉瓦诺，路易斯，2015。<a class="ae ky" href="http://www1.cs.columbia.edu/~jopa/Papers/PaparrizosSIGMOD2015.pdf" rel="noopener ugc nofollow" target="_blank"> k 形:高效准确的时间序列聚类</a></li><li id="428a" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu pk od oe of bi translated"><a class="ae ky" href="http://alexminnaar.com/2014/04/16/Time-Series-Classification-and-Clustering-with-Python.html" rel="noopener ugc nofollow" target="_blank">时间序列分类和聚类</a>Alex Minnaar</li><li id="f615" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu pk od oe of bi translated">ts 了解<a class="ae ky" href="https://tslearn.readthedocs.io/en/stable/user_guide/clustering.html" rel="noopener ugc nofollow" target="_blank">集群</a>的用户指南</li><li id="ae23" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu pk od oe of bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Dynamic_time_warping" rel="noopener ugc nofollow" target="_blank">动态时间扭曲百科</a>文章</li><li id="b723" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu pk od oe of bi translated"><a class="ae ky" href="http://www.lumenai.fr/blog/time-series-aggregation" rel="noopener ugc nofollow" target="_blank">lumen ai 的时间序列聚合</a></li></ul><div class="on oo gp gr op oq"><a href="https://alexandra-amidon.medium.com/membership" rel="noopener follow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">阅读亚历山德拉·阿米登(以及媒体上成千上万的其他作家)的每一个故事</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">alexandra-amidon.medium.com</p></div></div></div></a></div></div></div>    
</body>
</html>