<html>
<head>
<title>5 Essential Pandas Tips For Easier Data Manipulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化数据操作的 5 个熊猫小贴士</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-essential-pandas-tips-for-easier-data-manipulation-4c2968d37a79?source=collection_archive---------43-----------------------#2020-09-01">https://towardsdatascience.com/5-essential-pandas-tips-for-easier-data-manipulation-4c2968d37a79?source=collection_archive---------43-----------------------#2020-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="afe4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用这些简单有效的熊猫技巧让你的科学课有个好的开始！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f457c557c18537aed2c7b59043d80bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZIbQBlmhfO2JvnLNVVLBBQ.jpeg"/></div></div></figure><h1 id="5ee0" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="e7fd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi mi translated">Python 的 andas 是一款无需介绍的软件。无论您是第一次接触 Python 数据科学，还是已经在这个领域工作了很长时间，您都可能听说过 Pandas Python 模块。该库在业界被广泛用于数据操作，并且是任何想要使用数据框和 Numpy 的有抱负的数据科学家的首选工具。许多数据科学家每天都在使用 Pandas，它被广泛认为是使用 Python 操作数据的重要工具。</p><p id="1503" class="pw-post-body-paragraph lm ln it lo b lp mr ju lr ls ms jx lu lv mt lx ly lz mu mb mc md mv mf mg mh im bi translated">虽然 Pandas 相当容易使用，并且有许多简单的方法可供使用，但是 Pandas 有许多部分，其中一些大部分时间都被完全忽略了。熊猫是一种复杂的动物，可能需要几个月，甚至几年才能适应它的绝对最高水平。也就是说，熊猫声称有一些基本属性可以在目前大多数情况下有效使用。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="dacc" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">条件掩蔽</h1><p id="cf02" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一个最有可能使 Pandas 超越其竞争对手和字典类型本身的属性是条件屏蔽。条件屏蔽允许用户使用简单的条件语句过滤掉不符合要求的值。这是令人难以置信的方便，是目前 Julia 或 R 中可用的联盟以上。然而以 Julia 为例，我们需要使用过滤器！为了管理我们的数据，Pandas 通过使用所谓的条件掩码使过滤数据变得非常容易。</p><p id="1284" class="pw-post-body-paragraph lm ln it lo b lp mr ju lr ls ms jx lu lv mt lx ly lz mu mb mc md mv mf mg mh im bi translated">条件掩码迭代遍历数据帧中的所有数据，并将数据与预设条件进行比较。返回的将是遵循掩码中设置的条件的过滤后的数据帧。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="c758" class="nn kv it nj b gy no np l nq nr">import pandas as pd<br/>df = pd.DataFrame({"NA": [0,1,0,1,0,1], "Label": ["TN", "GA", "TN", "MN", "CA","CA"]})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/6f071b30991554c9a2b32baf46a96181.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*gfGPQYpuKtIxS3KiaWgBkQ.png"/></div></figure><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="e96f" class="nn kv it nj b gy no np l nq nr">ones_only = df["NA"] == 1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/b91f90ebb46b435a4b6b3bda7ede5889.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*EaQuH7NlCeORemVbR42QNg.png"/></div></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="827e" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">着色</h1><p id="8b02" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有时数据可能很难读取。对于数据科学家来说，这可能没什么大不了的，但通常需要呈现数据并使其更易读。Pandas 使得改变数据框中不同值的颜色变得相当容易。让我们考虑一个例子，我们想要显示哪些值低于某个阈值，哪些值低于该阈值。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="1676" class="nn kv it nj b gy no np l nq nr">df = pd.DataFrame({"Store ID": [1,8,7,4,11,2], "Income": [-12, 56, -2, 23, 7, 16]})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/8d9b7831e9c6e03224db13fda891aeb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*Or-BVWUrnDnSWWNO5fjCJA.png"/></div></figure><p id="05aa" class="pw-post-body-paragraph lm ln it lo b lp mr ju lr ls ms jx lu lv mt lx ly lz mu mb mc md mv mf mg mh im bi translated">首先，我们需要写一个小函数来根据我们的条件给我们的值着色。在本例中，我们将负值映射为红色，以显示每个商店的亏损与其他商店的盈利。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="f650" class="nn kv it nj b gy no np l nq nr">def negatives(input):</span><span id="9573" class="nn kv it nj b gy nv np l nq nr">color = 'red' if input &lt; 0 else 'black'</span><span id="48e9" class="nn kv it nj b gy nv np l nq nr">return 'color: %s' % color</span></pre><p id="ab4b" class="pw-post-body-paragraph lm ln it lo b lp mr ju lr ls ms jx lu lv mt lx ly lz mu mb mc md mv mf mg mh im bi translated">这就是所谓的风格图。样式地图是 Pandas 用来确定数据框应如何呈现的功能。我们可以用<code class="fe nw nx ny nj b">df.style.applymap().</code>应用一个样式图</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="ce37" class="nn kv it nj b gy no np l nq nr">df.style.applymap(negatives)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/f6e08f29b16f6b8371ba1583cfdb3fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*ZG9fHDDRp6CwuATk9VCq5w.png"/></div></figure><p id="bbb9" class="pw-post-body-paragraph lm ln it lo b lp mr ju lr ls ms jx lu lv mt lx ly lz mu mb mc md mv mf mg mh im bi translated">请注意，我们的数据框的样式确实发生了变化。Pandas 数据框使用级联样式表进行样式设计，因此实际上非常容易修改。可以使用<code class="fe nw nx ny nj b">df.style.set_table_styles.</code>应用新的样式表</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="18e8" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">汇总和交叉列表</h1><p id="85dc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当试图探索和理解大型数据集时，在许多情况下可能有用的一件事是获得某些列的总计数，我们可以使用 lambda 应用它。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="0fde" class="nn kv it nj b gy no np l nq nr">df = pd.DataFrame({"Group A": [7,9,11,12,16], "Group B": [12,14, 3, 7, 2]})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8f4abe1167a0dec00934aab0db4d23db.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*VjICWDVW9MSym07Q1kAJ2A.png"/></div></figure><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="7a16" class="nn kv it nj b gy no np l nq nr">df['total']     = df.apply(lambda x: x.sum(), axis=1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/9bc4239990629132d309afaceabec506.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*_XnnuWfFT_MH43YTqtVdQg.png"/></div></figure><p id="a735" class="pw-post-body-paragraph lm ln it lo b lp mr ju lr ls ms jx lu lv mt lx ly lz mu mb mc md mv mf mg mh im bi translated">同样，我们可以使用交叉列表来实现本质上相同的目标。交叉列表用于计算列中的频率，然而，上面的方法提供了列的总和。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="0df3" class="nn kv it nj b gy no np l nq nr">cross = pd.crosstab(index = df["Group A"], columns = df["Group B"])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/bb7b92799574485bf6c769dcdb749382.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*Q3MZZkn5TPzEZfrnbKchtQ.png"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="85f2" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">配置</h1><p id="a09f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">关于熊猫的另一个很酷的事情是它是高度可配置和动态的。Pandas 允许在运行时创建各种各样的“配置文件”,这些文件可以用来改变环境变量，以确定它如何工作。这在许多不同的情况下都很有用。例如，考虑这种显示配置:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="adca" class="nn kv it nj b gy no np l nq nr">def load_config():</span><span id="0bd5" class="nn kv it nj b gy nv np l nq nr">options = {</span><span id="91d1" class="nn kv it nj b gy nv np l nq nr">'display': {</span><span id="b1b2" class="nn kv it nj b gy nv np l nq nr">'max_columns': None,</span><span id="a8ce" class="nn kv it nj b gy nv np l nq nr">'max_colwidth': 25,</span><span id="d380" class="nn kv it nj b gy nv np l nq nr">'expand_frame_repr': False,</span><span id="bc9d" class="nn kv it nj b gy nv np l nq nr">'max_rows': 14,</span><span id="2672" class="nn kv it nj b gy nv np l nq nr">'max_seq_items': 50,</span><span id="0256" class="nn kv it nj b gy nv np l nq nr">'precision': 4,</span><span id="ec25" class="nn kv it nj b gy nv np l nq nr">'show_dimensions': False</span><span id="f552" class="nn kv it nj b gy nv np l nq nr">},</span><span id="c5ff" class="nn kv it nj b gy nv np l nq nr">'mode': {</span><span id="a734" class="nn kv it nj b gy nv np l nq nr">'chained_assignment': None</span><span id="7395" class="nn kv it nj b gy nv np l nq nr">}</span><span id="7d3e" class="nn kv it nj b gy nv np l nq nr">}</span><span id="188c" class="nn kv it nj b gy nv np l nq nr">for category, option in options.items():</span><span id="be8f" class="nn kv it nj b gy nv np l nq nr">for op, value in option.items():</span><span id="89b2" class="nn kv it nj b gy nv np l nq nr">pd.set_option(f'{category}.{op}', value)</span></pre><p id="bb5a" class="pw-post-body-paragraph lm ln it lo b lp mr ju lr ls ms jx lu lv mt lx ly lz mu mb mc md mv mf mg mh im bi translated">这当然是通过 set_option 方法来完成的，该方法将类别名和相应的值作为参数。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="096e" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">访问者</h1><p id="aafc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Series 类型必须提供的一个重要特性是使用访问器的能力。在最新版本的 Pandas 中有四种类型的访问器。</p><ul class=""><li id="75fb" class="od oe it lo b lp mr ls ms lv of lz og md oh mh oi oj ok ol bi translated"><code class="fe nw nx ny nj b">str</code>地图到<code class="fe nw nx ny nj b">StringMethods</code>。</li><li id="d528" class="od oe it lo b lp om ls on lv oo lz op md oq mh oi oj ok ol bi translated"><code class="fe nw nx ny nj b">.dt</code>地图到<code class="fe nw nx ny nj b">CombinedDatetimelikeProperties</code>。</li><li id="c777" class="od oe it lo b lp om ls on lv oo lz op md oq mh oi oj ok ol bi translated"><code class="fe nw nx ny nj b">.cat</code>到<code class="fe nw nx ny nj b">CategoricalAccessor</code>的路线。</li></ul><p id="ecd5" class="pw-post-body-paragraph lm ln it lo b lp mr ju lr ls ms jx lu lv mt lx ly lz mu mb mc md mv mf mg mh im bi translated">这些都是使用缓存附件连接到 Series 类的独立类。他们都有自己独特的方法，有时非常有用。考虑下面的例子:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="3920" class="nn kv it nj b gy no np l nq nr">locations = pd.Series([</span><span id="c98a" class="nn kv it nj b gy nv np l nq nr">'Cleveland, TN 37311',</span><span id="774a" class="nn kv it nj b gy nv np l nq nr">'Brooklyn, NY 11211-1755',</span><span id="55c1" class="nn kv it nj b gy nv np l nq nr">'East Moline, IL 61275',</span><span id="e49e" class="nn kv it nj b gy nv np l nq nr">'Pittsburgh, PA 15211'</span><span id="eb56" class="nn kv it nj b gy nv np l nq nr">])</span></pre><p id="bc61" class="pw-post-body-paragraph lm ln it lo b lp mr ju lr ls ms jx lu lv mt lx ly lz mu mb mc md mv mf mg mh im bi translated">在这个例子中，我们想计算每个邮政编码中有多少个数字。我们可以这样使用字符串访问器:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="80f6" class="nn kv it nj b gy no np l nq nr">locations.str.count(r'\d')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/8123a6c291a316a652aa8c445ba2afc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:278/format:webp/1*09e_Ag7B5TK6pvlmvonwTA.png"/></div></figure><blockquote class="os"><p id="b189" class="ot ou it bd ov ow ox oy oz pa pb mh dk translated">很酷，对吧？</p></blockquote></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="f69b" class="ku kv it bd kw kx nd kz la lb ne ld le jz nf ka lg kc ng kd li kf nh kg lk ll bi translated">结论</h1><p id="f47d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Pandas 是一个用 Python 处理数据的很好的库，它有很多非常有用的特性，使得数据操作比其他方式容易得多。从简单的访问器类和条件掩码，到简单的样式和完全动态的选项集，Pandas 是一个非常动态的库，可以用于不同操作的负载。这当然使熊猫很难与之竞争。很难证明在现代分析中使用任何其他软件是正确的，因为 Pandas 实在是太棒了！</p></div></div>    
</body>
</html>