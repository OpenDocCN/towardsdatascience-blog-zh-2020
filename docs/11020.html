<html>
<head>
<title>9 Cool Julia Tricks In 4 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4 分钟内 9 个超酷的朱莉娅戏法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/9-cool-julia-tricks-in-4-minutes-47a3a4496054?source=collection_archive---------31-----------------------#2020-07-31">https://towardsdatascience.com/9-cool-julia-tricks-in-4-minutes-47a3a4496054?source=collection_archive---------31-----------------------#2020-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="68ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">朱莉娅·REPL 的最佳特征</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/825dfad527222856ac9f7223fcf412d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YDXbVfZ3Diz1mHjWn1vT2g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@filipbaotic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菲利普·鲍蒂奇</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="e670" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="1538" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Julia 是一种新的科学计算语言，像 Python 一样容易学习，但执行速度和 C 语言一样快。Julia 是一种编译语言，但是由于它使用了实时编译器(像 Java)，你的代码可以立即执行。这个特性在朱莉娅·REPL 中得到了应用，在这里你可以运行代码行或代码块。REPL 代表读取、执行、打印和循环。</p><p id="8dba" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一旦安装了 Julia，在命令行输入 Julia 将打开 REPL。REPL 有许多功能可以帮助您测试代码片段和调试代码。</p><h1 id="2e54" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">1.包装模式</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/edae032b16d6af5b4420df4a5e1e7619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lwNMU5q60lZCyPGt1ZCHbA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包装模式下的朱莉娅·REPL</p></figure><p id="1c59" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在行首键入<code class="fe mt mu mv mw b">]</code>进入包模式。这是访问 Julia 的包管理器 Pkg 的快捷方式。在这种模式下，你可以安装软件包，更新它们，查看当前软件包的版本等等。在打包模式中有几个有用的命令是<code class="fe mt mu mv mw b">add</code>、<code class="fe mt mu mv mw b">remove</code>、<code class="fe mt mu mv mw b">build</code>和<code class="fe mt mu mv mw b">update</code>。</p><h1 id="1baa" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">2.外壳模式</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/e3a2d77003fec325d18640956a3604af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nKP1KxAS4yjsSUdma-ZEeQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">外壳模式</p></figure><p id="72e0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在行首键入<code class="fe mt mu mv mw b">;</code>进入 shell 模式。这改变了朱莉娅·REPL 来运行 bash 命令，而不是朱莉娅。在 shell 模式下，REPL 的行为类似于 Bash shell，您可以输入标准的 Bash 命令，如<code class="fe mt mu mv mw b">ls</code>、<code class="fe mt mu mv mw b">cd</code>、<code class="fe mt mu mv mw b">mkdir</code>等。这个功能我用过很多次。</p><h1 id="20db" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">3.帮助模式</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/4055a5593878e5ee9b660bfa64e3906d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KIINK4-Eq07OoVdZ93oCnQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">帮助模式</p></figure><p id="6f5f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">键入<code class="fe mt mu mv mw b">?</code>进入帮助模式。在这种模式下，您可以看到函数或类型文档以及其他提示和提示。当您输入文本时，Julia 将搜索与您输入的文本相匹配的文档和函数名。</p><h1 id="f072" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">4.函数参数制表符结束</h1><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="17f4" class="nd la it mw b gy ne nf l ng nh"><strong class="mw iu">julia&gt;</strong> uppercase([PRESS TAB]<br/>    uppercase(c::T) where T&lt;:AbstractChar in Base.Unicode at strings/unicode.jl:247<br/>    uppercase(s::AbstractString) in Base.Unicode at strings/unicode.jl:518</span></pre><p id="b6c6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">制表符补全在 REPL 中的工作方式与在 shell 或 iPython 中的工作方式相同，但是它有一个额外的有用特性。键入函数名时，在左括号后按 tab 键。如果这样做了，Julia 将显示与函数名相关的方法列表、它们的参数类型以及它们在源代码中的位置。</p><h1 id="3e6b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">5.宏:@doc</h1><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="6cce" class="nd la it mw b gy ne nf l ng nh"><strong class="mw iu">julia&gt;</strong> @doc max<br/> max(x, y, ...)</span><span id="be51" class="nd la it mw b gy ni nf l ng nh">Return the maximum of the arguments. See also the maximum function  to take the maximum element from a collection.</span></pre><p id="5574" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在函数或类型之前调用<code class="fe mt mu mv mw b">@doc</code>将打印该对象的文档。(在 Julia 文档中出现在函数定义前的一个字符串中。)这有助于快速找到您需要的功能，或者提醒自己某个特定功能的用法。</p><h1 id="441f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">6.宏:@时间</h1><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="77ae" class="nd la it mw b gy ne nf l ng nh"><strong class="mw iu">julia&gt;</strong> @time sum(rand(1000));<br/> 0.000030 seconds (6 allocations: 8.109 KiB)</span></pre><p id="9722" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe mt mu mv mw b">@time</code>宏是另一个非常有用的工具。正如您所料，它会计算它前面的语句的执行时间。</p><h1 id="a5a3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">7.功能:中肯()</h1><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="26c5" class="nd la it mw b gy ne nf l ng nh"><strong class="mw iu">julia&gt; </strong>apropos("capital")<br/> Base.Unicode.titlecase <br/> Base.Unicode.uppercasefirst</span></pre><p id="b27d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该函数接受一个字符串，并在所有文档中搜索相关的函数和类型。这有助于避免在文档中寻找您需要的函数。</p><h1 id="be91" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">8.函数:方法()</h1><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="7fc8" class="nd la it mw b gy ne nf l ng nh"><strong class="mw iu">julia&gt;</strong> methods(uppercase)<br/> # 2 methods for generic function "uppercase":<br/> [1] uppercase(c::T) where T&lt;:AbstractChar in Base.Unicode at strings/unicode.jl:247<br/> [2] uppercase(s::AbstractString) in Base.Unicode at strings/unicode.jl:518</span></pre><p id="55d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe mt mu mv mw b">methods</code>函数接受一个函数，并返回该函数的所有调度定义，以及它们接受的类型和它们在源代码中的位置。当你试图寻找一个函数或者当你不记得参数的顺序时，这是很有用的。</p><h1 id="9a28" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">9.函数:methodswith()</h1><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="7504" class="nd la it mw b gy ne nf l ng nh"><strong class="mw iu">julia&gt; </strong>using Flux</span><span id="1446" class="nd la it mw b gy ni nf l ng nh"><strong class="mw iu">julia&gt;</strong> methodswith(BatchNorm)<br/> [1] show(io::IO, l::BatchNorm) in Flux at /Users/djpassey/.julia/packages/Flux/NpkMm/src/layers/normalise.jl:211<br/> [2] testmode!(m::BatchNorm) in Flux at /Users/djpassey/.julia/packages/Flux/NpkMm/src/layers/normalise.jl:207<br/> [3] testmode!(m::BatchNorm, mode) in Flux at /Users/djpassey/.julia/packages/Flux/NpkMm/src/layers/normalise.jl:207</span></pre><p id="98e9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是另一个有用的功能。该函数接受类型并返回作用于该类型的所有函数。在上面的例子中，我导入了一个机器学习包 Flux，并在<code class="fe mt mu mv mw b">BatchNorm</code>结构上调用<code class="fe mt mu mv mw b">methodswith</code>。它向我们展示了三个接受<code class="fe mt mu mv mw b">BatchNorm</code>对象作为参数的函数。</p><p id="dac2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当您开始了解一个新的包并想了解库中定义的结构时，这很有用。当你在寻找一个作用于某种类型的函数时，这也是很有帮助的。</p><h2 id="a250" class="nd la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated">结论</h2><p id="cbb7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">总的来说，朱莉娅·REPL 在帮助开发人员定位正确的功能和测试代码片段方面非常有用。希望这些提示能派上用场，加速你的 Julia 发展。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ob"><a href="https://medium.com/swlh/how-julia-uses-multiple-dispatch-to-beat-python-8fab888bb4d8" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">Julia 如何利用多重调度击败 Python</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">亲自看</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div><div class="oq or gp gr os ob"><a href="https://medium.com/@djpasseyjr/it-only-takes-10-minutes-to-add-a-julia-kernel-to-jupyter-739490456a2b" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">给 Jupyter 添加一个 Julia 内核只需要 10 分钟</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">为什么这很酷。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="ot l om on oo ok op ks ob"/></div></div></a></div></div></div>    
</body>
</html>