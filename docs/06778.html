<html>
<head>
<title>Malware Classification using Convolutional Neural Networks — Step by Step Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用卷积神经网络的恶意软件分类—分步指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/malware-classification-using-convolutional-neural-networks-step-by-step-tutorial-a3e8d97122f?source=collection_archive---------8-----------------------#2020-05-27">https://towardsdatascience.com/malware-classification-using-convolutional-neural-networks-step-by-step-tutorial-a3e8d97122f?source=collection_archive---------8-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0638" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据科学项目</h2><div class=""/><div class=""><h2 id="7923" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">关于恶意软件分类的有趣方法的快速简单的教程。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/261a16a507370be95b5038669b3b2fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rWIk5AjHi93sSyNW"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">马库斯·斯皮斯克在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><blockquote class="li lj lk"><p id="134f" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一个<strong class="lo jd">恶意软件</strong>是一个通用术语，描述任何对系统有害的恶意代码或程序。</p></blockquote><p id="8b3c" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">如今，有无数类型的恶意软件试图破坏公司的信息系统。因此，<strong class="lo jd">检测</strong>和<strong class="lo jd">预防</strong>是避免任何风险的关键。<strong class="lo jd">恶意软件分类</strong>是一个广泛使用的任务，正如你可能知道的，可以通过<strong class="lo jd">机器学习</strong>模型非常有效地完成。</p><p id="5c4f" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">在本文中，我决定将重点放在一个有趣的基于<strong class="lo jd">卷积神经网络</strong>的恶意软件分类方法上。这个想法直接来自L. Nataraj、S. Karthikeyan、G. Jacob和B. S. Manjunath的论文<strong class="lo jd">恶意软件图像:可视化和自动分类</strong>。</p><p id="19e3" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我的目标是给你一个快速简单的教程，教你如何实现他们的解决方案，从恶意软件的<strong class="lo jd">预处理</strong>到<strong class="lo jd">推理</strong>部分。希望您能够理解主要概念，并使用本文来构建自己的项目！</p><p id="578c" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">这个项目可以在我的<a class="ae lh" href="https://github.com/hugom1997/Malware_Classification" rel="noopener ugc nofollow" target="_blank"> <strong class="lo jd"> Github </strong> </a>上找到。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="f196" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">资料组</h1><p id="9400" class="pw-post-body-paragraph ll lm it lo b lp nk kd lr ls nl kg lu mi nm lx ly mj nn mb mc mk no mf mg mh im bi translated">首先我们来介绍一下数据集！我们将主要使用来自前述论文<strong class="lo jd"> </strong>的<a class="ae lh" href="https://www.dropbox.com/s/ep8qjakfwh1rzk4/malimg_dataset.zip?dl=0" rel="noopener ugc nofollow" target="_blank"> <strong class="lo jd">恶意数据集</strong> </a> <strong class="lo jd"> </strong>。</p><p id="24d2" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">恶意软件数据集</strong>包含<strong class="lo jd"> 9339 </strong>恶意软件图像，属于<strong class="lo jd"> 25 </strong>家族/类。因此，我们的目标是对恶意软件进行<strong class="lo jd">多类分类</strong>。</p><p id="5c22" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">以下是关于数据集的信息:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/d608bb7b9a06868986aab4ba74ac1db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mEoaG1K_it29SniZJ58aoA.png"/></div></div></figure><p id="bc2d" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们的模型将试图预测每个恶意软件属于哪个<strong class="lo jd">家族</strong>。<strong class="lo jd">类型</strong>栏仅提供信息。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="4fe3" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">预处理</h1><h2 id="3597" class="nq mt it bd mu nr ns dn my nt nu dp nc mi nv nw ne mj nx ny ng mk nz oa ni iz bi translated">从二进制到图像</h2><p id="f12a" class="pw-post-body-paragraph ll lm it lo b lp nk kd lr ls nl kg lu mi nm lx ly mj nn mb mc mk no mf mg mh im bi translated">由于<strong class="lo jd">恶意数据集</strong>已经包含了<strong class="lo jd">恶意图像</strong>，我将使用另一个数据集首先向您展示如何将<strong class="lo jd">恶意图像</strong>转换为<strong class="lo jd">图像</strong>。<strong class="lo jd"> </strong>我从这个<a class="ae lh" href="https://www.kaggle.com/c/malware-classification/data?select=train.7z" rel="noopener ugc nofollow" target="_blank">数据集</a>中选取了示例文件。</p><p id="9cd9" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">对于每个文件，原始数据包含文件二进制内容的十六进制表示。目标是将这些文件转换成<strong class="lo jd"> PNG </strong>图像，并将它们用作我们<strong class="lo jd"> CNN </strong>的输入。</p><p id="676a" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们可以使用以下函数转换每个恶意软件:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="acb4" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">下面是将<strong class="lo jd">0 acdb r5 m3 zhbjajygtuf . bytes</strong>二进制文件转换成<strong class="lo jd"> PNG后的结果图。</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/d939ff4eb6df45223adb5285b2ef9a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYGIaYgIHB-tWVJmmUxK6A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">0ACDbR5M3ZhBJajygTuf.bytes至PNG</p></figure><p id="06e6" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">由于这种方法，我们可以创建自己的PNG恶意软件数据集。然而，我不会处理整个数据集，现在将重点关注<strong class="lo jd">恶意数据集</strong>，其中恶意软件已经转换为图像。</p><p id="363e" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">而且，每个恶意软件镜像都需要放入与其<strong class="lo jd">类</strong>对应的<strong class="lo jd">子文件夹</strong>中。因此，在创建您自己的图像数据集时，不要忘记在执行下一步之前按家族将恶意软件收集到子文件夹中。</p><h2 id="729a" class="nq mt it bd mu nr ns dn my nt nu dp nc mi nv nw ne mj nx ny ng mk nz oa ni iz bi translated">生成数据集</h2><p id="d3ed" class="pw-post-body-paragraph ll lm it lo b lp nk kd lr ls nl kg lu mi nm lx ly mj nn mb mc mk no mf mg mh im bi translated">以下是我们的恶意软件类别/家族，作为包含<strong class="lo jd">png</strong>的子文件夹:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/989040a5982f24470975e2c252105d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*uwkSFV-jLHD-WlwY3Jv8kQ.jpeg"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作为子文件夹的类别</p></figure><p id="d31e" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><code class="fe of og oh oi b">ImageDataGenerator.flow_from_directory()</code>从各自的数据目录(在我们的例子中是系列)生成批量归一化张量图像数据。多亏了这个功能，我们可以将我们的图像用于<strong class="lo jd">训练</strong>和<strong class="lo jd">测试</strong>。</p><ul class=""><li id="0f60" class="oj ok it lo b lp lq ls lt mi ol mj om mk on mh oo op oq or bi translated"><strong class="lo jd"> target_size </strong>:将所有图像调整到指定尺寸。我选择了(64*64)的图片。</li><li id="3b36" class="oj ok it lo b lp os ls ot mi ou mj ov mk ow mh oo op oq or bi translated"><strong class="lo jd"> batch_size </strong>:是我们将要使用的批次的大小。在我们的例子中，我们只有9339个图像，因此设置大于这个值的批量大小不会改变任何事情。</li></ul><p id="21b0" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">一旦生成了我们的批次，我们可以使用<code class="fe of og oh oi b">train_test_split()</code>功能在<strong class="lo jd">序列</strong>和<strong class="lo jd">测试</strong>之间分割数据，遵循(7<em class="ln">0–30</em>)的比例。</p><p id="de07" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">下面是相应的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a366" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><code class="fe of og oh oi b">ImageDataGenerator().flow_from_directory()</code>的输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/7dc74705ba5acf77245a79e8e3dd0f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*FLMRXjfy4AHxCmdf5ywMQw.jpeg"/></div></figure><p id="ce34" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">如您所见，由于子文件夹的名称，该函数很好地识别了<strong class="lo jd"> 25 </strong>类。</p><p id="42cf" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">这是我们数据集的一个示例:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/e2a5b80a1b95edd817fb2c6912cf9edd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWC-6NYVuwGtxgu0SQMfYQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">样品</p></figure><p id="af65" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们已经可以看到文件之间的一些差异。然而，对我们来说，要准确地将恶意软件划分到不同的家庭中去太难了。</p><h2 id="2625" class="nq mt it bd mu nr ns dn my nt nu dp nc mi nv nw ne mj nx ny ng mk nz oa ni iz bi translated">快速分析</h2><p id="3e23" class="pw-post-body-paragraph ll lm it lo b lp nk kd lr ls nl kg lu mi nm lx ly mj nn mb mc mk no mf mg mh im bi translated">根据下图，我们的数据集是相当<strong class="lo jd">不平衡</strong>的:超过30%的图像属于第二类:<strong class="lo jd">all ple。一个</strong>和17%的三级:<strong class="lo jd">全部。L </strong>！我们将需要稍后处理这个问题。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/03c2d687f0881705ab52578671ea2436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*KYOSvzkb24c8LvO-ZhVZ5g.jpeg"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">不平衡数据集</p></figure><blockquote class="pa"><p id="ee40" class="pb pc it bd pd pe pf pg ph pi pj mh dk translated">让我们现在建立我们的CNN模型</p></blockquote></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="0965" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">CNN模型</h1><h2 id="e87f" class="nq mt it bd mu nr ns dn my nt nu dp nc mi nv nw ne mj nx ny ng mk nz oa ni iz bi translated">体系结构</h2><p id="d152" class="pw-post-body-paragraph ll lm it lo b lp nk kd lr ls nl kg lu mi nm lx ly mj nn mb mc mk no mf mg mh im bi translated">现在我们的数据集已经准备好了，我们可以使用Keras构建我们的模型。将使用以下结构:</p><ul class=""><li id="cfc7" class="oj ok it lo b lp lq ls lt mi ol mj om mk on mh oo op oq or bi translated"><strong class="lo jd">卷积层</strong> : 30个滤波器，(3 * 3)内核大小</li><li id="32e7" class="oj ok it lo b lp os ls ot mi ou mj ov mk ow mh oo op oq or bi translated"><strong class="lo jd">最大池层</strong> : (2 * 2)池大小</li><li id="50be" class="oj ok it lo b lp os ls ot mi ou mj ov mk ow mh oo op oq or bi translated"><strong class="lo jd">卷积层</strong> : 15个滤波器，(3 * 3)内核大小</li><li id="751b" class="oj ok it lo b lp os ls ot mi ou mj ov mk ow mh oo op oq or bi translated"><strong class="lo jd">最大池层数</strong> : (2 * 2)池大小</li><li id="5aff" class="oj ok it lo b lp os ls ot mi ou mj ov mk ow mh oo op oq or bi translated"><strong class="lo jd">脱落层</strong>:脱落25%的神经元。</li><li id="9886" class="oj ok it lo b lp os ls ot mi ou mj ov mk ow mh oo op oq or bi translated"><strong class="lo jd">展平图层</strong></li><li id="e0c1" class="oj ok it lo b lp os ls ot mi ou mj ov mk ow mh oo op oq or bi translated"><strong class="lo jd">密集/全连接层</strong> : 128个神经元，Relu激活功能</li><li id="c4b2" class="oj ok it lo b lp os ls ot mi ou mj ov mk ow mh oo op oq or bi translated"><strong class="lo jd">脱落层</strong>:脱落50%的神经元。</li><li id="6c32" class="oj ok it lo b lp os ls ot mi ou mj ov mk ow mh oo op oq or bi translated"><strong class="lo jd">密集/全连接层</strong> : 50个神经元，Softmax激活功能</li><li id="63b2" class="oj ok it lo b lp os ls ot mi ou mj ov mk ow mh oo op oq or bi translated"><strong class="lo jd">密集/全连接层</strong> : num_class神经元，Softmax激活函数</li></ul><p id="da08" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">输入</strong>的形状为【64 * 64 * 3】:【宽*高*深】。在我们的例子中，每个恶意软件都是一个<strong class="lo jd"> RGB </strong>图像。</p><p id="54cb" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">下面是相应的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="9385" class="nq mt it bd mu nr ns dn my nt nu dp nc mi nv nw ne mj nx ny ng mk nz oa ni iz bi translated">不平衡数据</h2><p id="c1f6" class="pw-post-body-paragraph ll lm it lo b lp nk kd lr ls nl kg lu mi nm lx ly mj nn mb mc mk no mf mg mh im bi translated">有几种方法可以处理<strong class="lo jd">不平衡数据</strong>。我选择给少数阶级较高的权重，给多数阶级较低的权重。</p><p id="348c" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">sk learn . utilis . class _ weights</strong>函数使用<strong class="lo jd"> y </strong>的值自动调整输入数据中与类别频率成反比的权重。要使用这种方法，<strong class="lo jd"> y_train </strong>不能被一键编码。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="e92c" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">结果</h1><p id="22e1" class="pw-post-body-paragraph ll lm it lo b lp nk kd lr ls nl kg lu mi nm lx ly mj nn mb mc mk no mf mg mh im bi translated">在对我们的模型进行训练和测试之后，我们最终达到了95%的准确率，这还不错！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/0575c24d6c90c0d2ea05b3738590cc30.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*qyLEBDzxXIPB2dLZfDm7bw.jpeg"/></div></figure><p id="c5f1" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">绘制<strong class="lo jd">混淆矩阵</strong>可以给我们一些提示，告诉我们在分类过程中哪里出错了。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pl"><img src="../Images/74889bf54a2ff66c99098082453fdf86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KmOnLV35I9-wCCfa_Wx20A.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">混淆矩阵</p></figure><p id="6a2f" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们可以观察到，虽然大部分恶意软件被很好的分类，<strong class="lo jd">自动运行。K </strong>总是被误认为<strong class="lo jd">允儿。答</strong>。这大概是因为我们的<strong class="lo jd"> Autorun的样本非常少。K </strong>在我们的数据集中，并且两者都是close <strong class="lo jd"> Worm </strong>类型的一部分。</p><p id="883c" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">而且，<strong class="lo jd"> Swizzor.gen！E </strong>就是<strong class="lo jd"> </strong>经常被误认为<strong class="lo jd"> Swizzor.gen！l </strong>，这可以用这样一个事实来解释，他们来自非常相近的家族和类型，因此他们的代码可能有相似之处。</p><p id="aff6" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">最后，我相信，由于本文中提到的预处理步骤，我们可以通过创建更大的数据集来大大提高模型的性能。现在就看你的了！</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="1e73" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">结论</h1><p id="3043" class="pw-post-body-paragraph ll lm it lo b lp nk kd lr ls nl kg lu mi nm lx ly mj nn mb mc mk no mf mg mh im bi translated">就是这样！由于这篇文章，你现在能够建立你的<strong class="lo jd">恶意软件图像</strong>数据集，并使用它来执行<strong class="lo jd">多类分类</strong>，由于<strong class="lo jd">卷积神经网络</strong>。</p><p id="bbfb" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我希望这篇教程能以任何方式帮助你构建你的项目！现在，下一步可能是理解如何部署它😉</p><p id="fddf" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">再说一次，我的目标只是给出一个关于其他人的<a class="ae lh" href="https://dl.acm.org/doi/10.1145/2016904.2016908" rel="noopener ugc nofollow" target="_blank">伟大作品</a>的简单教程，所以为他们欢呼吧！🍺</p><p id="2fff" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">当然，我的<a class="ae lh" href="https://github.com/hugom1997/Malware_Classification" rel="noopener ugc nofollow" target="_blank"> <strong class="lo jd"> Github </strong> </a>上什么都有。</p><p id="4578" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">祝您愉快！</strong></p><h1 id="cdeb" class="ms mt it bd mu mv pm mx my mz pn nb nc ki po kj ne kl pp km ng ko pq kp ni nj bi translated">参考</h1><p id="a060" class="pw-post-body-paragraph ll lm it lo b lp nk kd lr ls nl kg lu mi nm lx ly mj nn mb mc mk no mf mg mh im bi translated">以下是我找到灵感的地方:</p><div class="pr ps gp gr pt pu"><a href="https://dl.acm.org/doi/10.1145/2016904.2016908" rel="noopener  ugc nofollow" target="_blank"><div class="pv ab fo"><div class="pw ab px cl cj py"><h2 class="bd jd gy z fp pz fr fs qa fu fw jc bi translated">恶意软件图片|第八届网络安全可视化国际研讨会会议录</h2><div class="qb l"><h3 class="bd b gy z fp pz fr fs qa fu fw dk translated">我们提出了一种简单而有效的方法，使用图像处理技术对恶意软件进行可视化和分类…</h3></div><div class="qc l"><p class="bd b dl z fp pz fr fs qa fu fw dk translated">dl.acm.org</p></div></div><div class="qd l"><div class="qe l qf qg qh qd qi lb pu"/></div></div></a></div><div class="pr ps gp gr pt pu"><a href="https://sarvamblog.blogspot.com/2014/08/supervised-classification-with-k-fold.html" rel="noopener  ugc nofollow" target="_blank"><div class="pv ab fo"><div class="pw ab px cl cj py"><h2 class="bd jd gy z fp pz fr fs qa fu fw jc bi translated">基于多家族恶意软件数据集的k-fold交叉验证监督分类</h2><div class="qb l"><h3 class="bd b gy z fp pz fr fs qa fu fw dk translated">随着恶意软件及其家族数量的不断增加，将恶意软件分类到特定的家族非常具有挑战性…</h3></div><div class="qc l"><p class="bd b dl z fp pz fr fs qa fu fw dk translated">sarvamblog.blogspot.com</p></div></div><div class="qd l"><div class="qj l qf qg qh qd qi lb pu"/></div></div></a></div><div class="pr ps gp gr pt pu"><a href="https://dzone.com/articles/malware-detection-with-convolutional-neural-networ" rel="noopener  ugc nofollow" target="_blank"><div class="pv ab fo"><div class="pw ab px cl cj py"><h2 class="bd jd gy z fp pz fr fs qa fu fw jc bi translated">Python - DZone AI中基于卷积神经网络的恶意软件检测</h2><div class="qb l"><h3 class="bd b gy z fp pz fr fs qa fu fw dk translated">在本帖中，我们将学习人工网络架构以及如何使用其中一种(卷积神经…</h3></div><div class="qc l"><p class="bd b dl z fp pz fr fs qa fu fw dk translated">dzone.com</p></div></div><div class="qd l"><div class="qk l qf qg qh qd qi lb pu"/></div></div></a></div><div class="pr ps gp gr pt pu"><a href="https://deeplizard.com/learn/video/LhEMXbjGV_4" rel="noopener  ugc nofollow" target="_blank"><div class="pv ab fo"><div class="pw ab px cl cj py"><h2 class="bd jd gy z fp pz fr fs qa fu fw jc bi translated">基于Keras的CNN图像分类器图像预处理</h2><div class="qb l"><h3 class="bd b gy z fp pz fr fs qa fu fw dk translated">在这一集里，我们将演示如何使用Keras设置训练一个卷积神经网络(CNN)。我们的…</h3></div><div class="qc l"><p class="bd b dl z fp pz fr fs qa fu fw dk translated">deeplizard.com</p></div></div><div class="qd l"><div class="ql l qf qg qh qd qi lb pu"/></div></div></a></div></div></div>    
</body>
</html>