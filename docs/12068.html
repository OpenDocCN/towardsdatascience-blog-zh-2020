<html>
<head>
<title>Perfectly Pythonic Python Stuff That You Should Definitely Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完美的 Pythonic Python 你绝对应该知道的东西</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/perfectly-pythonic-python-stuff-that-you-should-definitely-know-daa559528d58?source=collection_archive---------7-----------------------#2020-08-20">https://towardsdatascience.com/perfectly-pythonic-python-stuff-that-you-should-definitely-know-daa559528d58?source=collection_archive---------7-----------------------#2020-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="807d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">像 Python 禅师一样编写简单而优雅的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9f4c914b9d6606885389057754cf1777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQenOO5OanDRNZkqIVWVsA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://www.wallpaperflare.com/closeup-photo-of-eyeglasses-screen-computer-electronics-monitor-wallpaper-ezhbo/download/1920x1080" rel="noopener ugc nofollow" target="_blank">壁纸 flare </a></p></figure><p id="6e3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> M </span>我们大多数人在编码时都有一些定位功能。一旦我们习惯了以某种方式编码，我们倾向于一遍又一遍地使用相同的函数，即使可能有更好的方式。而且，按照 Python 的禅理，<em class="me">应该只有一种——最好只有一种——显而易见的方法来做这件事！</em></p><p id="3267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比我愿意承认的更多的时候，我也掉进了这个陷阱。例如，太习惯于循环，太频繁地使用打印而不是日志，等等。这绝对不是蟒蛇的方式。您可以随时更新关于 Pythonic 的知识，即编写清晰、简洁且易于维护的代码，更多内容请点击此处:</p><div class="mf mg gp gr mh mi"><a href="https://docs.python-guide.org/writing/style/" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd iu gy z fp mn fr fs mo fu fw is bi translated">代码风格 Python 的搭便车指南</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">如果你问 Python 程序员他们最喜欢 Python 的什么，他们往往会引用它的高可读性。的确，一个…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">docs.python-guide.org</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw ks mi"/></div></div></a></div><p id="0cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一段时间，以下 7 个功能成为我最喜欢使用的功能，因为它们的简单和内在的优雅。如果你到现在还没有，你应该尽可能地使用它们。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="368c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 1。f 弦</strong></p><p id="3a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 3.6 提出了一种格式化字符串的绝妙方法，称为 string(格式化字符串文字)。在 Python 3 中的 f-strings 之前，我们可以通过以下两种方式中的任何一种来实现:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="b65a" class="nj nk it nf b gy nl nm l nn no"># Method_1 Using %s</span><span id="9316" class="nj nk it nf b gy np nm l nn no">&gt;&gt; name = "Leonardo"<br/>&gt;&gt; surname = "Da Vinci"<br/>&gt;&gt; Occupation_1 = "Artist"<br/>&gt;&gt; Occupation_2 = "Inventor"<br/>&gt;&gt; Occupation_3 = "Scientist"<br/>&gt;&gt; Occupation_4 = "Mathematician"<br/>&gt;&gt; Occupation_5 = "Philosopher"</span><span id="98a6" class="nj nk it nf b gy np nm l nn no">&gt;&gt; print ("%s %s was an %s, %s, %s, %s and %s." % (name, surname, Occupation_1, Occupation_2, Occupation_3, Occupation_4, Occupation_5))</span><span id="9c2a" class="nj nk it nf b gy np nm l nn no">'<!-- -->Leonardo Da Vinci was an Artist, Inventor, Scientist, Mathematician and <!-- -->Philosopher<!-- -->.<!-- -->'</span></pre><p id="c730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，代码的可读性完全被破坏了。下面的 str.format()就是这种情况。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="a8c0" class="nj nk it nf b gy nl nm l nn no"># Method_2 Using str.format()</span><span id="d101" class="nj nk it nf b gy np nm l nn no">&gt;&gt; print (("{name} {surname} was an {Occupation_1}, {Occupation_1}, {Occupation_1}, {Occupation_1} and {Occupation_1}.").format(name = name, surname = surname, Occupation_1 = Occupation_1, Occupation_2 = Occupation_2, Occupation_3 = Occupation_3, Occupation_4 = Occupation_4, Occupation_5 = Occupation_5))</span><span id="93bb" class="nj nk it nf b gy np nm l nn no">'<!-- -->Leonardo Da Vinci was an Artist, Inventor, Scientist, Mathematician and <!-- -->Philosopher<!-- -->.<!-- -->'</span></pre><p id="9476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一点也不比第一个好。幸运的是，我们有 Python 3 f-strings 来拯救我们。他们是这样工作的:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="ea07" class="nj nk it nf b gy nl nm l nn no">&gt;&gt; f'{name} {surname} was an {Occupation_1}, {Occupation_2}, {Occupation_3}, {Occupation_4} and {Occupation_5}.'</span><span id="5a26" class="nj nk it nf b gy np nm l nn no">'<!-- -->Leonardo Da Vinci was an Artist, Inventor, Scientist, Mathematician and <!-- -->Philosopher<!-- -->.<!-- -->'</span></pre><p id="179f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这么简单！好家伙，我们有可读性。最重要的是，因为 f 字符串是在运行时计算的，所以你可以做很多事情，包括其他函数和方法。请看这里:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="74b0" class="nj nk it nf b gy nl nm l nn no">&gt;&gt; f'{2*3}'<br/>&gt;&gt; <!-- -->f'{name.lower()}'</span><span id="f3c0" class="nj nk it nf b gy np nm l nn no">'6'<br/>'leonardo'</span></pre><p id="02b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道有些保守的 python 专家会引用 Python 的禅，说 f 字符串是不符合 Python 的，因为应该只有一种显而易见的方法来做事。在这种情况下，有两个。但是实用性胜过纯粹性和可读性。我现在发现了一个显而易见的方法，那就是 f 弦！</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="855d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。清单和字典(打包、拆包)</strong></p><p id="c6dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表和字典是 python 中最常用的两个对象，尤其是当您对数据争论和分析感兴趣的时候。它们也很难使用。以精益的方式使用它们是极其重要的。在这种情况下，我们释放*和**的力量，作为与创建函数的列表和字典相关的重要参数。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="5219" class="nj nk it nf b gy nl nm l nn no">&gt;&gt; def some_function (a,b,c,d):<br/>       print (a,b,c,d)</span><span id="e3f1" class="nj nk it nf b gy np nm l nn no">&gt;&gt; some_list = [1,2,3,4]<br/>&gt;&gt; some_dictionary = <!-- -->{'a':1, 'b':2, 'c':13, 'd':14}</span></pre><p id="9585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们来看看上面的解包是如何工作的:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="aace" class="nj nk it nf b gy nl nm l nn no"># Unpacking list</span><span id="4360" class="nj nk it nf b gy np nm l nn no">&gt;&gt; <!-- -->some_function(<!-- -->some_list)</span><span id="b940" class="nj nk it nf b gy np nm l nn no">TypeError: <!-- -->some_function<!-- -->() missing 3 required positional arguments: 'b', 'c', and 'd'</span></pre><p id="4264" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，它自然地将列表视为一个位置参数。为了正确地做到这一点，您可以在列表前使用*号，瞧:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="4eb5" class="nj nk it nf b gy nl nm l nn no"># Unpacking list</span><span id="60d3" class="nj nk it nf b gy np nm l nn no">&gt;&gt; <!-- -->some_function(*<!-- -->some_list)</span><span id="30f2" class="nj nk it nf b gy np nm l nn no">1 2 3 4</span></pre><p id="3dff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，对于字典来说，是**。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="6189" class="nj nk it nf b gy nl nm l nn no"># Unpacking dictionary</span><span id="3e2e" class="nj nk it nf b gy np nm l nn no">&gt;&gt; <!-- -->some_function(**<!-- -->some_dictionary)</span><span id="3d40" class="nj nk it nf b gy np nm l nn no">1 2 13 14</span></pre><p id="53b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">必须注意的是，字典的键是与函数相匹配的，如果键不同，你会得到一个错误。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="ce5e" class="nj nk it nf b gy nl nm l nn no"># Unpacking dictionary</span><span id="e748" class="nj nk it nf b gy np nm l nn no">&gt;&gt; some_dictionary_2 = <!-- -->{'x':1, 'y':2, 'z':13, 'w':14}<br/>&gt;&gt; <!-- -->some_function(**<!-- -->some_dictionary_2)</span><span id="7744" class="nj nk it nf b gy np nm l nn no">TypeError: <!-- -->some_function<!-- -->() got an unexpected keyword argument 'x'</span></pre><p id="942e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看包装是如何工作的。对于列表，我们可以使用带*的包参数。同样，对于字典，我们使用**来打包关键字参数(kwargs)。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="2ba8" class="nj nk it nf b gy nl nm l nn no"># List Packing</span><span id="d300" class="nj nk it nf b gy np nm l nn no">&gt;&gt; def<!-- --> <!-- -->some_list_packing(<strong class="nf iu">*</strong>args):<br/>       args <strong class="nf iu">=</strong> <!-- -->list(args)<br/>       <br/>       args[0] <strong class="nf iu">=</strong> <!-- -->'I am about to'<br/>       args[1] <strong class="nf iu">=</strong> <!-- -->'pack lists'</span><span id="8cef" class="nj nk it nf b gy np nm l nn no">       <!-- -->some_function(*<!-- -->args) # use the previous function unpacking</span><span id="15b8" class="nj nk it nf b gy np nm l nn no">&gt;&gt; some_list_packing('I am packing','','','')</span><span id="c9d7" class="nj nk it nf b gy np nm l nn no">I am about to pack lists</span><span id="ca20" class="nj nk it nf b gy np nm l nn no"># Dictionary Packing</span><span id="de7b" class="nj nk it nf b gy np nm l nn no">&gt;&gt;&gt; def some_dictionary_packing(**kwargs):</span><span id="8c99" class="nj nk it nf b gy np nm l nn no">&gt;&gt;&gt; for key in kwargs:</span><span id="e619" class="nj nk it nf b gy np nm l nn no">        print(f'{key} = {kwargs[key]}')<br/>            # See how I used the f-string there?</span><span id="0642" class="nj nk it nf b gy np nm l nn no">&gt;&gt;&gt; some_dictionary_packing(a= "I", b= "am", c= "about", d= "to write..")<br/><br/>a = I<br/>b = am<br/>c = about<br/>d = to write..</span></pre><p id="9082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所注意到的，列表和字典的打包和解包非常容易，可以大大简化你的代码！</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="d26f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。动态新型</strong></p><p id="cd54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道这听起来像是最新的流行时尚，但在 Python 中它更酷。您知道 Python 允许您随时使用“类型”创建类吗？这是如何做到的，它比你想象的更棒:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="6921" class="nj nk it nf b gy nl nm l nn no">&gt;&gt;&gt; NewClass = type("NewClass", (object,), {"intro": "This is an awesome new class"})</span><span id="f1d5" class="nj nk it nf b gy np nm l nn no">&gt;&gt;&gt; n = NewClass()<br/>&gt;&gt;&gt; n.intro</span><span id="fe76" class="nj nk it nf b gy np nm l nn no">"This is an awesome new class"</span></pre><p id="88a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与以下内容完全相同:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="a46a" class="nj nk it nf b gy nl nm l nn no">&gt;&gt;&gt; class NewClass(object):<br/>        intro = "This is an awesome new class"<br/>&gt;&gt;&gt; n = NewClass()<br/>&gt;&gt;&gt; n.intro</span><span id="83df" class="nj nk it nf b gy np nm l nn no">"This is an awesome new class"</span></pre><p id="ea73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，为了让您更容易理解动态类的强大功能，我简化了这里的示例。使用这个功能，您可以轻松地创建高级类。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="5540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 4。试试除了</strong></p><p id="9e09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我无法数清有多少次感谢 python 之神创造了这一切。它测试一个代码块，并允许我们以简单有效的方式处理错误！</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="1e66" class="nj nk it nf b gy nl nm l nn no"># use the unpacking lists function again for the example</span><span id="1060" class="nj nk it nf b gy np nm l nn no">&gt;&gt; def some_function (a,b,c,d):<br/>       print (a,b,c,d)</span><span id="f2b5" class="nj nk it nf b gy np nm l nn no">a_list = [1,2,3,4]</span><span id="825d" class="nj nk it nf b gy np nm l nn no">&gt;&gt; try:<br/>       <!-- -->some_function (a_list)<br/>   except:<br/>       print(“Put * before the input list in the function”)</span><span id="95fc" class="nj nk it nf b gy np nm l nn no"><br/>Put * before the input list in the function</span></pre><p id="ecf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您的代码变得更大时，您应该更频繁地使用它和日志功能。在任何情况下，切勿执行以下操作:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="d5fe" class="nj nk it nf b gy nl nm l nn no">&gt;&gt; try:<br/>       <!-- -->some_function (a_list)<br/>   except:<br/>       pass</span></pre><p id="1d6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">蟒蛇神永远不会原谅你的！</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="ba30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 5。可变默认值</strong></p><p id="ca81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个漂亮的小技巧，它的好处比看起来要多，如果没有正确遵循，出错的可能性也比你最初想象的要大。下面是一个代码示例，可以让您明白我的意思:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="2485" class="nj nk it nf b gy nl nm l nn no">&gt;&gt;&gt; def something(x=[]):<br/>        x.append(1)<br/>        print (x)<br/><br/>&gt;&gt;&gt; something()<br/>[1]</span><span id="749b" class="nj nk it nf b gy np nm l nn no">&gt;&gt;&gt; something()<br/>[1, 1]</span><span id="c660" class="nj nk it nf b gy np nm l nn no">&gt;&gt;&gt; something()<br/>[1, 1, 1]</span></pre><p id="cea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看，每次使用这个函数时，列表都会被追加。相反，你应该使用一个缺省值来表示“未指明”,并替换为你希望作为缺省值的可变变量:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="86d7" class="nj nk it nf b gy nl nm l nn no">&gt;&gt;&gt; def something(x= None):<br/>        if x is None:<br/>            x= []<br/>        x.append(1)<br/>        print (x)</span><span id="440a" class="nj nk it nf b gy np nm l nn no">&gt;&gt;&gt; something()<br/>[1]<br/>&gt;&gt;&gt; something()<br/>[1]</span></pre><p id="f906" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相信我，事先知道如何使用可变的默认参数将为您节省大量调试时间！</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="594d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 6。价值交换</strong></p><p id="5a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我依稀记得当我学习 Java 时，我们被介绍交换值的基础是创建第三个临时变量。</p><p id="43e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">a = 1，b =2。想交换价值观吗？创建一个临时变量 c .然后 c = a，a = b，b = c .多烦啊！下面是它在 Java 中的样子:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="0bb9" class="nj nk it nf b gy nl nm l nn no">void swap(int a, int b)<br/>{<br/>    int temp = a;<br/>    a = b;<br/>    b = temp;<br/>    // a and b are copies of the original values.<br/>}</span></pre><p id="c9b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，我们有 python 元组来拯救。当我们可以将它们互换位置时，为什么要创建第三个变量呢！</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="c997" class="nj nk it nf b gy nl nm l nn no">&gt;&gt; a = 10<br/>&gt;&gt; b = 5<br/>&gt;&gt; a, b = b, a<br/></span><span id="9b09" class="nj nk it nf b gy np nm l nn no">&gt;&gt; print(a)<br/>5</span><span id="a5e8" class="nj nk it nf b gy np nm l nn no">&gt;&gt; <!-- -->print(b)<br/>10</span></pre><p id="8a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这没什么大不了的，但有时，从长远来看，了解简单的基础知识会对我们有很大帮助。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="adca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 7。用大括号替换空格？</strong></p><p id="8b4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，伙计们，你们没听错！我们都属于 Java 阵营，我们知道你讨厌空格分隔块，喜欢那些花括号。最后，还有一个办法:</p><p id="ca21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nq nr ns nf b">from __future__ import braces</code></p><p id="7d1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦运行了上面的代码，您会得到</p><p id="bd44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nq nr ns nf b">SyntaxError: not a chance</code></p><p id="b1a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">逮到你了！</strong>那永远不会发生。这么长的吸盘！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/e490fdde76f9ec8352cecfc922bf7e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fcPZPrqR5Z1K1euI.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/vectors/snake-python-serpent-green-reptile-312561/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="55ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请原谅我用复活节彩蛋来描绘和开始这一小节，我控制不住自己。</p><p id="e283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是 __ 未来 _ _ 模块比你想象的更有用。这次是真的！它有助于兼容最新版本的 python。以此为例:</p><p id="4476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用的是 Python 2.7</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="28b6" class="nj nk it nf b gy nl nm l nn no">a = 1000</span><span id="44b8" class="nj nk it nf b gy np nm l nn no">print a</span><span id="8330" class="nj nk it nf b gy np nm l nn no">&gt;&gt; 1000</span></pre><p id="1cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以从最新的 Python 版本中导入打印功能。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="58ec" class="nj nk it nf b gy nl nm l nn no">&gt;&gt; from __future__ import print_function</span><span id="add8" class="nj nk it nf b gy np nm l nn no">&gt;&gt; print a</span><span id="a231" class="nj nk it nf b gy np nm l nn no">SyntaxError: Missing parentheses in call to ‘print’. Did you mean print(a)?</span><span id="a09d" class="nj nk it nf b gy np nm l nn no">&gt;&gt; print (a)</span><span id="7260" class="nj nk it nf b gy np nm l nn no">1000</span></pre><p id="05db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">未来模块包括一系列功能。你可以在这里查看:</p><div class="mf mg gp gr mh mi"><a href="https://www.pythonsheets.com/notes/python-future.html#:~:text=__future__%20is%20a,import%20to%20current%20Python%20interpreter.&amp;text=Future%20statements%20not%20only%20change,_Feature%20into%20the%20current%20program." rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd iu gy z fp mn fr fs mo fu fw is bi translated">未来- pysheeet</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">未来语句告诉解释器编译一些语义作为将来可用的语义…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">www.pythonsheets.com</p></div></div></div></a></div></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="37b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样，伙计们！上面的清单只包含了 Python 中许多优秀功能中的一小部分。我希望你发现它们是有用的，如果你应用了它们，你的编码同行一定会发现你的代码更容易审查。</p><p id="1e5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>