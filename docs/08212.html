<html>
<head>
<title>How to implement a Serverless Batch Job Architecture on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在AWS上实现无服务器批处理作业架构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-implement-a-serverless-batch-job-architecture-on-aws-b3358cd33428?source=collection_archive---------24-----------------------#2020-06-16">https://towardsdatascience.com/how-to-implement-a-serverless-batch-job-architecture-on-aws-b3358cd33428?source=collection_archive---------24-----------------------#2020-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ba55" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">概念性的想法和使它们工作的代码</h2></div><p id="19ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇博文是关于AWS上无服务器批处理作业的特定类型架构的三篇技术深度文章之一。该架构背后的基本前提是，我们希望使用AWS的托管服务来运行批处理作业。如果您想了解更多关于该架构的信息，请点击<a class="ae le" href="https://blog.codecentric.de/en/2020/06/cost-effective-batch-jobs-on-aws-serverless-infrastructure/" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多详情。该架构的整体情况如下:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/2ec7945e1beff7e24f686da08cf47f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BTBz6dXPkYnNI7-sTBWJw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">整体架构(作者图解)。</p></figure><p id="526b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，该架构由一个用于开发的组件块和另一个用于执行批处理作业的组件块组成。在这篇博文中，我们只关注这个架构的<strong class="kk iu">托管服务</strong>。还有一个<a class="ae le" href="https://github.com/timo-boehm/serverless_batch_aws" rel="noopener ugc nofollow" target="_blank">公共代码库</a>，允许你基于Cloudformation脚本复制完整的服务及其所有部分。</p><p id="637e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">云提供商用两个核心承诺宣传托管服务。首先，云提供商管理维护和其他底层职责。因此，客户可以专注于功能和架构。第二，托管服务往往更便宜，因为您只需为您使用的服务付费，而无需大量的前期投资。</p><p id="5091" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">托管服务支持<strong class="kk iu">无服务器</strong>设计。换句话说，体系结构可以让您摆脱与服务器堆栈相关的许多顾虑。这种抽象级别加速了开发，并引入了与服务架构相关的不可能的灵活性级别。</p><p id="9178" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从云形成脚本的初级入门开始。如果你已经有了云形成或者类似概念的经验，你可以略读或者跳过下面三段。</p><p id="0fdc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> CloudFormation </strong>是针对<em class="lv">基础设施的AWS服务，代码为</em>。也就是说，您定义一个目标基础设施，将其推送给AWS，AWS为您提供它。您将资源组织在所谓的堆栈中，使其易于调整、监控或删除。</p><p id="c0d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在JSON或YAML文件中编写CloudFormation脚本。这里和代码库中的所有例子都是YAML文件，但是您也可以在JSON中做同样的事情。</p><p id="2c3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一组专门针对CloudFormation的命令可供您使用。在接下来的例子中，我使用了其中的四个:</p><ol class=""><li id="a47b" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld mb mc md me bi translated"><strong class="kk iu">！Ref </strong>是内部参考；也就是说，CloudFormation从同一个堆栈插入一个值。</li><li id="97fe" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld mb mc md me bi translated"><strong class="kk iu">！Sub </strong>用于将变量替换成字符串。</li><li id="9741" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld mb mc md me bi translated"><strong class="kk iu">！GetAtt </strong>类似于“！Ref”但是指向资源的特定属性，而不是一般的引用。</li><li id="3502" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld mb mc md me bi translated"><strong class="kk iu">！ImportValue </strong>用于从当前堆栈外部导入值。在本例中，网络和策略规范来自其他配置文件。</li></ol></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="ac31" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">大局</h1><p id="2d5e" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">该架构的指导原则是开发和生产工作流的分离。也就是说，这里涉及到两个角色:<strong class="kk iu">开发者</strong>负责实现业务逻辑，<strong class="kk iu">云工程师</strong>保证稳定运营。</p><p id="a69a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">开发工作流程</strong>由三个功能组成——一个<em class="lv">代码库</em>，它是开发者之间协作的主要工具。一个<em class="lv">构建环境</em>克隆存储库，并将代码转换成容器。最后，每当代码库发生变化时，编排工具就会触发新的构建，并将结果推送到映像注册中心。只要开发人员确保主分支反映了他们工作的当前状态，容器就会自动更新。</p><p id="9112" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">批处理工作流程</strong>包含两个功能。首先，计算资源需要加载容器并运行它。第二，触发器需要在要求的时间间隔内开始计算。</p><p id="85d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个工作流之间唯一的重叠是图像注册。这种最小重叠的减少确保了开发和生产之间的分离。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="4b10" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">实施细节</h1><p id="6d0f" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">我将实现细节分成三个小节，它们反映了上面描述的大背景。对于每个托管服务，我解释了它们在架构中的角色以及它们最相关的参数。我还提供了CloudFormation片段，以便您可以将我的解释与实际代码联系起来。</p><blockquote class="no np nq"><p id="9dcc" class="ki kj lv kk b kl km ju kn ko kp jx kq nr ks kt ku ns kw kx ky nt la lb lc ld im bi translated"><strong class="kk iu">注意:</strong>这些说明仅涵盖托管服务。但是不包括网络和访问管理。如果你想了解更多的细节，请看<a class="ae le" rel="noopener" target="_blank" href="/network-configurations-for-fargate-tasks-6333314c4001">网络</a>和<a class="ae le" rel="noopener" target="_blank" href="/how-to-configure-iam-roles-for-fargate-tasks-on-aws-76ad54f11314"> IAM角色和政策</a>上的两篇相关文章。</p></blockquote></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="733a" class="nu ms it bd mt nv nw dn mx nx ny dp nb kr nz oa nd kv ob oc nf kz od oe nh of bi translated">开发组件中的托管服务</h2><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi og"><img src="../Images/9070d57c27666d90863c8da1345b9b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8niQwJb3hd4LnibOfW1I2Q.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">开发工作流程(作者插图)。</p></figure><p id="ba25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开发工作流程的第一个组成部分是一个<strong class="kk iu">代码提交</strong>库。唯一特殊的配置是<em class="lv">代码</em>部分。这个部分允许你在S3上以ZIP文件的形式提供一个初始代码库。我在示例中使用它来使整个工作流直接启动，但是它是可选的。但是，如果您为代码指定了一个不可用或不可访问的位置，则堆栈创建会失败。下面是相关的CloudFormation脚本:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="f792" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二，有一个<strong class="kk iu"> CodeBuild </strong>项目。它将一个<em class="lv">源</em>转换成一个图像，并将结果推送到一个容器注册表中。在这种情况下，源代码是上面定义的CodeCommit存储库。该项目使用存储库的HTTP URL来克隆它。注意，构建的规范来自一个<em class="lv"> buildspec.yml </em>文件，它是克隆代码的一部分。</p><p id="9fd5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦CodeBuild克隆了存储库，构建的映像就会在您需要指定的<em class="lv">环境</em>中发生。要使它按预期工作，您必须了解几个参数:</p><ul class=""><li id="39cd" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld oj mc md me bi translated"><strong class="kk iu">类型</strong>描述了总体环境，例如，您是否需要GPU。通常，<em class="lv"> LINUX_CONTAINER </em>完成这项工作。</li><li id="10ff" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld oj mc md me bi translated"><strong class="kk iu">计算类型</strong>指定用于构建的虚拟硬件。在撰写本文时，对于<em class="lv"> LINUX_CONTAINER </em>，有四个不同的<strong class="kk iu"> </strong>选项可供选择。最小的选项包括3 GB内存和两个vCPUs。</li><li id="bd3e" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld oj mc md me bi translated">特定基础图像的选择取决于你的构建需要什么。查看文档中的运行时列表，看看哪个选项能满足您的需要，并做出相应的选择。例如，寻找正确的Python版本。</li><li id="3a11" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld oj mc md me bi translated">特权模式使项目能够构建Docker容器。由于本例使用了Docker图像，因此参数为<em class="lv"> true </em>。</li><li id="3d02" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld oj mc md me bi translated">您还可以为构建指定额外的<strong class="kk iu">环境变量</strong>。在这个例子中，我们传递了帐户ID、容器注册名和一个图像标签。你需要什么变量取决于<em class="lv"> buildspec.yml </em>和Dockerfile。</li></ul><p id="c6ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将该列表与Cloudformation脚本进行比较，了解更多详细信息:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="aa46" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，还有一个<strong class="kk iu">代码管道</strong>用于编排。它由两个阶段组成，包括一个<em class="lv">名称</em>和一个<em class="lv">动作列表</em>。不同类型的操作需要不同的配置参数集，所以我在这里主要关注其中的一些。</p><p id="a03d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主分支中的每个变化都会触发<strong class="kk iu">源</strong>阶段。这个阶段充当流水线的初始化阶段。主要参数是存储库的<em class="lv">名称</em>、您想要监控变更的<em class="lv">分支</em>，以及一个指示管道是否应该拉取变更的标志。如果您将此设置为<em class="lv"> true </em>，每当库被更新时，新的运行将自动开始。</p><p id="37ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果采购成功，则<strong class="kk iu">构建</strong>阶段开始。所有管道需要的是对上述CodeBuild项目的有效引用。</p><p id="079a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是CloudFormation脚本中涵盖管道的部分:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="482d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于CodePipeline来说，还有比我列出的更多的可用操作。例如，您可以用GitHub或Bitbucket上的库替换源库，用webhook替换对变更的提取。请将此设置视为您实验的起点。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="392c" class="nu ms it bd mt nv nw dn mx nx ny dp nb kr nz oa nd kv ob oc nf kz od oe nh of bi translated">连接环节</h2><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/57f7687d7669dad9bfff4707735fd0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*usukqtycgrXS9XZkJ_j2fw.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">连接容器注册表(由作者图解)。</p></figure><p id="74fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<strong class="kk iu">弹性容器注册表(ECR) </strong>很容易。您需要做的就是定义一个存储库的名称:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="f1bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，选择注册表作为链接是分离开发和执行的一种强有力的方式。只要开发工作流将图像推送到图像存储库，它就不会中断批处理作业工作流。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="d5d3" class="nu ms it bd mt nv nw dn mx nx ny dp nb kr nz oa nd kv ob oc nf kz od oe nh of bi translated">批处理作业组件中的托管服务</h2><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/7d7b1bce50af7186a3a3f9f05e6dbff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*DS_uVXkzV8UqqlWxn232Eg.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">批处理作业架构(作者举例说明)。</p></figure><p id="8d5f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">批处理作业的计算核心是<strong class="kk iu"> Fargate任务</strong>。但是我们首先需要一个托管的地方来运行它们，即AWS <strong class="kk iu">弹性容器服务(ECS) </strong>上的集群。幸运的是，我们需要实现的只是它的<em class="lv">集群名</em>:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="aa7a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在任务定义中涉及到更多的配置。有两组值需要设置:通用参数和容器定义。让我们从常规设置开始:</p><ul class=""><li id="2700" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld oj mc md me bi translated"><strong class="kk iu"> CPU </strong>和<strong class="kk iu">内存</strong>是任务的硬件需求。AWS只允许这两个参数的某种组合，因此请查看文档以避免出现错误消息。请注意，您指定了CPU单元的数量，因此256是0.25个vCPU，1024是一个vCPU，依此类推。</li><li id="e2f8" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld oj mc md me bi translated">Fargate任务的正确<strong class="kk iu">网络模式</strong>是<em class="lv"> awsvpc </em>。如果您尝试使用另一个选项，您的容器将无法连接到外部。</li><li id="3a21" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld oj mc md me bi translated">为了确保任务使用无服务器基础设施，您需要将<strong class="kk iu">所需的兼容性</strong>设置为<em class="lv"> Fargate </em>。</li></ul><p id="21bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些参数定义了图像运行的框架。接下来让我们看看确切的容器定义:</p><ul class=""><li id="6e9b" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld oj mc md me bi translated"><strong class="kk iu">映像</strong>是容器注册表中容器映像的地址。不幸的是，AWS没有提供一种干净的方法来提取它，所以您必须自己构建字符串。</li><li id="6c3d" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld oj mc md me bi translated">我不能夸大<strong class="kk iu">日志配置</strong>的重要性。如果做错了，调试应用程序几乎是不可能的。相比之下，如果将<strong class="kk iu">日志驱动</strong>设置为<em class="lv"> awslogs </em>，则可以访问CloudWatch中的所有日志记录信息。</li></ul><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="45e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在任务已经就绪，我们需要添加一种方法来定期触发它。这个功能由一个<strong class="kk iu"> CloudWatch规则</strong>接管。<em class="lv"> ScheduleExpression </em>定义触发器触发的频率。<em class="lv">状态</em>参数指定一旦CloudFormation部署它，触发器是否激活。配置中更重要的部分是触发器的<em class="lv">目标</em>，所以我想为您提供更多的细节:</p><ul class=""><li id="9016" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld oj mc md me bi translated"><strong class="kk iu"> Arn </strong>参数指向我们上面指定的虚拟ECS集群。其余设置参考ECS细节。</li><li id="d8a4" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld oj mc md me bi translated"><strong class="kk iu">发射类型</strong>有两种选择:<em class="lv"> EC2 </em>和<em class="lv"> Fargate </em>。因为我们设计的一切都是无服务器的，所以我们需要选择后者。</li><li id="e509" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld oj mc md me bi translated">从安全角度来看，关键的是<strong class="kk iu">网络配置</strong>，这是我们在AWS VPC中指定的。为了确保无法访问互联网，我们禁用了<em class="lv">公共IP </em>并分配了<em class="lv">子网</em>和<em class="lv">安全组</em>。</li><li id="04e2" class="lw lx it kk b kl mf ko mg kr mh kv mi kz mj ld oj mc md me bi translated"><strong class="kk iu">任务定义Arn </strong>指的是我们上面指定的实际任务。</li></ul><p id="942c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是CloudFormation中的完整规范:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="1ed1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了完整起见，下面是我如何在CloudFormation脚本中指定两个S3桶。请注意，可以定义生命周期策略或其他更细微的配置:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="5732" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这篇文章能帮助你更好地理解每个托管服务对无服务器工作流的贡献。同样，如果你想了解更多关于架构的知识，请参考<a class="ae le" href="https://blog.codecentric.de/en/2020/06/cost-effective-batch-jobs-on-aws-serverless-infrastructure/" rel="noopener ugc nofollow" target="_blank">概念帖子</a>。如果你打算重建它，看看<a class="ae le" href="https://github.com/timo-boehm/serverless_batch_aws" rel="noopener ugc nofollow" target="_blank">公共代码库</a>。</p><p id="523e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请在评论中告诉我你的想法和经历。我也很乐意在<a class="ae le" href="https://twitter.com/timo_data" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae le" href="https://www.linkedin.com/in/timo-boehm-datascience/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上连接。感谢您的阅读！</p></div></div>    
</body>
</html>