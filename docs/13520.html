<html>
<head>
<title>4 Lesser-Known Yet Very Functional Pandas Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4 个鲜为人知但非常实用的熊猫手术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-less-known-yet-very-functional-pandas-operations-46dcf2bd9688?source=collection_archive---------42-----------------------#2020-09-16">https://towardsdatascience.com/4-less-known-yet-very-functional-pandas-operations-46dcf2bd9688?source=collection_archive---------42-----------------------#2020-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c27a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">发现更多的熊猫</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c9d5cf284f088c10eb81fab5fe3760af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PzzXz-libhJvAq41xXiylw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kymellis?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">金莎·艾利斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/view?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3fd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas 是使用最广泛的数据分析和操作库，它提供了许多处理数据的函数和方法。由于它们执行的任务，其中一些比其他的更频繁地被使用。</p><p id="9197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将介绍 4 个熊猫手术，它们不太常用，但仍然非常实用。</p><p id="4f5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说进口 NumPy 和熊猫。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="485d" class="ma mb it lw b gy mc md l me mf">import numpy as np<br/>import pandas as pd</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="8089" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak"> 1。因式分解</strong></h1><p id="2b4c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">它提供了一种编码分类变量的简单方法，这是大多数机器学习技术中的一项必需任务。</p><p id="1dc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是来自客户流失数据集的分类变量。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="29fa" class="ma mb it lw b gy mc md l me mf">df = pd.read_csv('/content/Churn_Modelling.csv')</span><span id="b1f3" class="ma mb it lw b gy nj md l me mf">df['Geography'].value_counts()<br/>France     5014 <br/>Germany    2509 <br/>Spain      2477 <br/>Name: Geography, dtype: int64</span></pre><p id="dda7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用一行代码对类别进行编码(即转换成数字)。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1940" class="ma mb it lw b gy mc md l me mf">df['Geography'], unique_values = pd.factorize(df['Geography'])</span></pre><p id="2b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">factorize 函数返回转换后的值以及类别索引。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d869" class="ma mb it lw b gy mc md l me mf">df['Geography'].value_counts()<br/>0    5014 <br/>2    2509 <br/>1    2477 <br/>Name: Geography, dtype: int64</span><span id="2269" class="ma mb it lw b gy nj md l me mf">unique_values<br/>Index(['France', 'Spain', 'Germany'], dtype='object')</span></pre><p id="99c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果原始数据中有丢失的值，您可以为它们指定一个值。默认值为-1。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="55a7" class="ma mb it lw b gy mc md l me mf">A = ['a','b','a','c','b', np.nan]<br/>A, unique_values = pd.factorize(A)<br/>array([ 0,  1,  0,  2,  1, -1])</span><span id="dd15" class="ma mb it lw b gy nj md l me mf">A = ['a','b','a','c','b', np.nan]<br/>A, unique_values = pd.factorize(A, na_sentinel=99)<br/>array([ 0,  1,  0,  2,  1, 99])</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="7a1a" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak"> 2。分类</strong></h1><p id="2949" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">它可用于创建分类变量。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0ce6" class="ma mb it lw b gy mc md l me mf">A = pd.Categorical(['a','c','b','a','c'])</span></pre><p id="c410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类别属性用于访问类别:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="70c7" class="ma mb it lw b gy mc md l me mf">A.categories<br/>Index(['a', 'b', 'c'], dtype='object')</span></pre><p id="5f30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只能从一个现有类别中分配新值。否则，我们将得到一个值错误。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5e52" class="ma mb it lw b gy mc md l me mf">A[0] = 'd'</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/203336f94bd70453190d3c4bcdac295a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KmvjAWJ7hcAx1eT83Ta-4Q.png"/></div></div></figure><p id="4296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用 dtype 参数指定数据类型。缺省值是 CategoricalDtype，由于内存消耗，它实际上是最好的选择。</p><p id="ec1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来做一个例子，比较一下内存使用情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/7789d64d4a541353e4ceaaef5e39afb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*zlVMhhTrdoWQ2TLe3d6kYQ.png"/></div></figure><p id="537d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是每列的内存使用量(以字节为单位)。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="479a" class="ma mb it lw b gy mc md l me mf">countries = pd.Categorical(df['Geography'])<br/>df['Geography'] = countries</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/6bdced5a7f07526db54651ce02eb2a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*G3ndYcHCeG6Ngz5o_gCBZQ.png"/></div></figure><p id="f642" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内存使用比原始功能少 8 倍。对于较大的数据集，节省的内存量将进一步增加，尤其是当我们只有很少的类别时。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="d349" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak"> 3。区间</strong></h1><p id="a64e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">它返回一个表示区间的不可变对象。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="40a3" class="ma mb it lw b gy mc md l me mf">iv = pd.Interval(left=1, right=5, closed='both')</span><span id="8bbd" class="ma mb it lw b gy nj md l me mf">3 in iv<br/>True</span><span id="38a4" class="ma mb it lw b gy nj md l me mf">5 in iv<br/>True</span></pre><p id="d421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">closed 参数指示边界是否包含在内。它取的值是“两个”、“左”、“右”和“都不是”。默认值为“右”。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ac4b" class="ma mb it lw b gy mc md l me mf">iv = pd.Interval(left=1, right=5, closed='neither')</span><span id="6c12" class="ma mb it lw b gy nj md l me mf">5 in iv<br/>False</span></pre><p id="d599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们处理日期-时间数据时，时间间隔很方便。我们可以很容易地检查日期是否在指定的间隔内。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5903" class="ma mb it lw b gy mc md l me mf">date_iv = pd.Interval(left = pd.Timestamp('2019-10-02'), <br/>                      right = pd.Timestamp('2019-11-08'))</span><span id="2aff" class="ma mb it lw b gy nj md l me mf">date = pd.Timestamp('2019-10-10')</span><span id="f185" class="ma mb it lw b gy nj md l me mf">date in date_iv<br/>True</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="14d3" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak"> 4。宽到长</strong></h1><p id="2e35" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">Melt 将宽数据帧转换为长数据帧。这个任务也可以用融化功能来完成。Wide_to_long 提供了一种不太灵活但更用户友好的方式。</p><p id="f438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的样本数据帧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/409145528cf333039e9113cae2101b31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*ZzigKpzaYIuDcc6h4ecXdg.png"/></div></figure><p id="8c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它包含了一些人不同的分数。我们希望以一行(而不是单独的一列)表示分数类型的方式来修改(或重塑)该数据帧。例如，A 下面有 3 种分数类型(A1、A2、A3)。在我们转换数据帧之后，将只有列(A)和类型(1，2，3)将用行值表示。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8bdc" class="ma mb it lw b gy mc md l me mf">pd.wide_to_long(df, stubnames=['A','B'], i='names', j='score_type')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/05260801b210e39da15413cdb1dcec6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*OC3HydSCkjihaDZPO9GN5Q.png"/></div></figure><p id="d262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">stubnames 参数指示将包含这些值的新列的名称。宽格式的列名需要以 stubnames 开头。“I”参数是用作 id 变量的列,“j”参数是包含子类别的列的名称。</p><p id="60ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回的数据帧有一个多级索引，但我们可以通过应用 reset_index 函数将其转换为普通索引。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="878f" class="ma mb it lw b gy mc md l me mf">pd.wide_to_long(df, stubnames=['A','B'], i='names', j='score_type').reset_index()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/aa1c9dead73a408e8f2b28e44c10a83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*BhwSkY95li4T-KlhdeZZIQ.png"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="5dd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas 在数据科学和机器学习领域的成功和优势归功于功能和方法的多样性和灵活性。一些方法执行基本的任务，但是也有更详细和更具体的任务。</p><p id="c9fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫通常有多种方式来完成一项任务，这使得它很容易很好地适应特定的任务。</p><p id="94c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>