<html>
<head>
<title>Advanced Streamlit Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级 Streamlit 缓存</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/advanced-streamlit-caching-6f528a0f9993?source=collection_archive---------14-----------------------#2020-03-27">https://towardsdatascience.com/advanced-streamlit-caching-6f528a0f9993?source=collection_archive---------14-----------------------#2020-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bcfba3661a8ba9da732127c9d73bac10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwINFsj_EMgDfGYGZe4e1Q.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/users/sasint-3639875/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1822459" rel="noopener ugc nofollow" target="_blank"> Sasin Tipchai </a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1822459" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="01b8" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">缓存=更好的用户体验</h2></div><p id="8ec1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如何使用 Streamlit 创建 web 应用程序非常简单，但是它还不允许您做很多事情。我最近面临的一个主要问题是关于缓存的，当时我试图使用一个新闻 API 在 Streamlit 中创建一个分析新闻仪表板。</p><p id="69b1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">问题是我经常点击新闻 API，并且已经达到了免费 API 的极限。此外，每次用户刷新应用程序时运行新闻 API 变得相当慢。</p><p id="cdf3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决这个问题的方法是缓存 API 数据。但是当我使用<code class="fe lu lv lw lx b">@st.cache</code> decorator 时，页面不会刷新，因为 API 调用的参数保持不变。</p><p id="cf9b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这也是我开始理解 Streamlit 在缓存方面的局限性的原因。</p><p id="61a4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，简而言之，我想要的是一种不会在每次页面刷新时都点击 API 的方法。与此同时，由于我正在获取新闻数据，我还希望每隔 5 分钟访问一次 API。T11】</p><p id="2063" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我完成这项工作的简单方法。</p><p id="18f4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">更新:</strong></p><p id="8924" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在昨天刚刚出来的<a class="ae jg" href="https://discuss.streamlit.io/t/version-0-57-0/2301" rel="noopener ugc nofollow" target="_blank"> 0.57.0 </a>新发行说明中，streamlit 对<code class="fe lu lv lw lx b">st.cache</code>进行了更新。这个版本的一个显著变化是“能够通过设置<code class="fe lu lv lw lx b">max_entries</code>和<code class="fe lu lv lw lx b">ttl</code>参数来设置缓存函数的到期选项”。来自<a class="ae jg" href="https://docs.streamlit.io/api.html?highlight=cache#streamlit.cache" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><ul class=""><li id="298a" class="lz ma jj la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><strong class="la jk"> max_entries </strong> ( <em class="ly"> int 或 None </em> ) —保留在<strong class="la jk">缓存</strong>中的最大条目数，或者对于无界缓存为 None。(当一个新条目被添加到满缓存时，最旧的缓存条目将被删除。)默认为无。</li><li id="5a5b" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="la jk">TTL</strong>(<em class="ly">float or None</em>)—将条目保留在<strong class="la jk">缓存</strong>中的最大秒数，如果缓存条目不应过期，则为 None。默认值为无。</li></ul><p id="ca55" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可能有所帮助的两个用例是:</p><ul class=""><li id="2fb6" class="lz ma jj la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">如果您正在为您的应用程序提供服务，并且不希望缓存永远增长。</li><li id="ed68" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">如果您有一个从 URL 读取实时数据的缓存函数，并且应该每隔几个小时清除一次以获取最新数据</li></ul><p id="db8a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以现在你需要做的就是:</p><pre class="mn mo mp mq gt mr lx ms mt aw mu bi"><span id="7a90" class="mv mw jj lx b gy mx my l mz na"><a class="ae jg" href="http://twitter.com/st" rel="noopener ugc nofollow" target="_blank">@st</a>.cache(ttl=60*5,max_entries=20)<br/>def hit_news_api(country, n):<br/>    # hit_api</span></pre><p id="b2ca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事情变化之快真是令人难以置信。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="2c7b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我开始之前，这里有一个关于 streamlit 的教程，如果你不理解这篇文章的话。</p><div class="is it gp gr iu ni"><a rel="noopener follow" target="_blank" href="/how-to-write-web-apps-using-simple-python-for-data-scientists-a227a1a01582"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jk gy z fp nn fr fs no fu fw ji bi translated">如何为数据科学家使用简单的 Python 编写 Web 应用？</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">无需了解任何 web 框架，即可轻松将您的数据科学项目转换为酷炫的应用程序</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">towardsdatascience.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ja ni"/></div></div></a></div></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="8102" class="nx mw jj bd ny nz oa ob oc od oe of og kp oh kq oi ks oj kt ok kv ol kw om on bi translated">简化缓存基础知识:</h1><p id="beda" class="pw-post-body-paragraph ky kz jj la b lb oo kk ld le op kn lg lh oq lj lk ll or ln lo lp os lr ls lt im bi translated">当我们用 streamlit 的缓存装饰器<code class="fe lu lv lw lx b">@st.cache</code>标记一个函数时，无论何时调用该函数，Streamlit 都会检查调用该函数时使用的输入参数。后端发生的事情是，当一个函数用<code class="fe lu lv lw lx b">@st.cache</code> streamlit 修饰时，它将函数的所有状态保存在内存中。</p><p id="6b73" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果我们有一个简单的 streamlit 应用程序，如下所示:</p><pre class="mn mo mp mq gt mr lx ms mt aw mu bi"><span id="56a1" class="mv mw jj lx b gy mx my l mz na"><strong class="lx jk">import</strong> <strong class="lx jk">streamlit</strong> <strong class="lx jk">as</strong> <strong class="lx jk">st</strong><br/><strong class="lx jk">import</strong> <strong class="lx jk">time</strong></span><span id="fdf5" class="mv mw jj lx b gy ot my l mz na"><strong class="lx jk">def</strong> expensive_computation(a, b):<br/>    time.sleep(2)  <em class="ly"># 👈 This makes the function take 2s to run</em><br/>    <strong class="lx jk">return</strong> a * b</span><span id="7953" class="mv mw jj lx b gy ot my l mz na">a = 2<br/>b = 21<br/>res = expensive_computation(a, b)<br/>st.write("Result:", res)</span></pre><p id="51c7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们刷新应用程序时，我们会注意到<code class="fe lu lv lw lx b">expensive_computation(a, b)</code>在每次应用程序运行时都会被重新执行。这对用户来说不是一个很好的体验。</p><p id="49df" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们添加<code class="fe lu lv lw lx b"><a class="ae jg" href="https://docs.streamlit.io/api.html#streamlit.cache" rel="noopener ugc nofollow" target="_blank">@st.cache</a></code>装饰器:</p><pre class="mn mo mp mq gt mr lx ms mt aw mu bi"><span id="88e7" class="mv mw jj lx b gy mx my l mz na"><strong class="lx jk">import</strong> <strong class="lx jk">streamlit</strong> <strong class="lx jk">as</strong> <strong class="lx jk">st</strong><br/><strong class="lx jk">import</strong> <strong class="lx jk">time</strong></span><span id="5a97" class="mv mw jj lx b gy ot my l mz na">@st.cache  <em class="ly"># 👈 Added this</em><br/><strong class="lx jk">def</strong> expensive_computation(a, b):<br/>    time.sleep(2)  <em class="ly"># This makes the function take 2s to run</em><br/>    <strong class="lx jk">return</strong> a * b</span><span id="75c0" class="mv mw jj lx b gy ot my l mz na">a = 2<br/>b = 21<br/>res = expensive_computation(a, b)<br/>st.write("Result:", res)</span></pre><p id="146a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为参数<code class="fe lu lv lw lx b">a</code>和<code class="fe lu lv lw lx b">b</code>的结果已经被缓存，所以<code class="fe lu lv lw lx b">expensive_computation</code>不会在每次用户刷新页面时再次运行。这将带来更好的用户体验。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="f87c" class="nx mw jj bd ny nz oa ob oc od oe of og kp oh kq oi ks oj kt ok kv ol kw om on bi translated">最小示例</h1><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ou"><img src="../Images/c5ee0633ec110e6b6dfef0a77fa767a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UmKPECS8nYxkVbLx"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">罗马卡夫在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e681" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="ly">那么如果我想执行一个函数，如果页面在设定的时间段后刷新了呢？</em> </strong>也就是说，缓存的函数已经有一段时间没有运行了，结果需要更新。</p><p id="7882" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了理解这一点，让我们创建一个基本的例子。在这个例子中，我们的函数采用一个参数<code class="fe lu lv lw lx b">n</code>和一个参数 country，并返回该国家的前 n 条新闻。</p><p id="446d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个最小的例子中，它类似于返回一个随机数列表。我们希望在接下来的 5 分钟内继续向我们的用户显示这个列表。如果用户在 5 分钟后刷新页面，我们希望列表被刷新。这非常类似于点击新闻 API。</p><p id="7ab3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们的基本应用程序代码看起来像这样:</p><pre class="mn mo mp mq gt mr lx ms mt aw mu bi"><span id="a10f" class="mv mw jj lx b gy mx my l mz na">import streamlit as st<br/>import random</span><span id="293c" class="mv mw jj lx b gy ot my l mz na">def hit_news_api(country, n):<br/> st.write("Cache Miss for n:",n)<br/> return [random.randint(0,1000) for i in range(n)]</span><span id="ca1d" class="mv mw jj lx b gy ot my l mz na">results = hit_news_api("USA", 5)<br/>st.write(results)</span></pre><p id="95e1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个应用程序看起来像:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/d475e21b657095457e265f75e6a94fef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-X2xnGem2uvlNOGRndCDvg.png"/></div></div></figure><p id="4659" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，每次我刷新页面，函数<code class="fe lu lv lw lx b">hit_news_api</code>都会被再次调用，这意味着随着用户数量的增加，我们将达到 API 的极限。那么我们如何解决这个问题呢？</p><p id="0596" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用缓存。没错。所以让我们看看如果我们缓存<code class="fe lu lv lw lx b">hit_news_api</code>函数会发生什么。</p><pre class="mn mo mp mq gt mr lx ms mt aw mu bi"><span id="357c" class="mv mw jj lx b gy mx my l mz na">import streamlit as st<br/>import random</span><span id="12a7" class="mv mw jj lx b gy ot my l mz na"><a class="ae jg" href="http://twitter.com/st" rel="noopener ugc nofollow" target="_blank">@st</a>.cache<br/>def hit_news_api(country, n):<br/> st.write("Cache Miss for n:",n)<br/> return [random.randint(0,1000) for i in range(n)]</span><span id="5e17" class="mv mw jj lx b gy ot my l mz na">results = hit_news_api("USA", 5)<br/>st.write(results)</span></pre><p id="e657" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在的问题是，如果 API 参数保持不变，我们的仪表板在点击一次新闻 API 后就再也不会调用它了。我们看到同一组参数的静态结果是永恒的。我们做什么呢</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="d6c6" class="nx mw jj bd ny nz oa ob oc od oe of og kp oh kq oi ks oj kt ok kv ol kw om on bi translated">想法 1 —虚拟时间变量</h1><p id="b70d" class="pw-post-body-paragraph ky kz jj la b lb oo kk ld le op kn lg lh oq lj lk ll or ln lo lp os lr ls lt im bi translated">我们可以使用这种方法——向每五分钟/十分钟改变一次值的<code class="fe lu lv lw lx b">hit_news_api</code>函数调用传递一个依赖于时间的伪参数。实现这一点的代码是:</p><figure class="mn mo mp mq gt iv"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="a53e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，<code class="fe lu lv lw lx b">truncate_time</code>函数帮助我们将当前日期时间截断为该分钟最接近的最小除数。例如，给定<code class="fe lu lv lw lx b">dt_time=’2020–03–27 02:32:19.684443'</code>和<code class="fe lu lv lw lx b">period = 5</code>，函数返回<code class="fe lu lv lw lx b">‘2020–03–27 02:30:00.0’.</code></p><p id="65ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看我们现在如何用截断的时间调用<code class="fe lu lv lw lx b">hit_news_api</code>函数。现在，无论何时从<code class="fe lu lv lw lx b">dt_time=’2020–03–27 02:30:00.0' and dt_time=’2020–03–27 02:34:59.99999'</code>开始调用<code class="fe lu lv lw lx b">hit_news_api</code>函数，函数调用的参数都保持不变，因此我们不会一次又一次地调用 API。正是我们想要的！</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="b4f3" class="nx mw jj bd ny nz oa ob oc od oe of og kp oh kq oi ks oj kt ok kv ol kw om on bi translated">想法 2-刷新/清除缓存</h1><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/454d40015876a012d7dc30dac2a6cb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HyKbLevRbVM_nWFf"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">清理缓存。<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">去飞溅</a></p></figure><p id="d4a6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一切都很好，但是您能发现这种方法的问题吗？缓存大小将随着时间的推移而增长。这意味着我们需要定期手动清除缓存。我们如何自动化缓存清除过程？</p><p id="d224" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个非常简单的方法。我们可以在代码顶部使用下面的代码，在一天的时间内清除整个缓存。</p><pre class="mn mo mp mq gt mr lx ms mt aw mu bi"><span id="7f15" class="mv mw jj lx b gy mx my l mz na">from streamlit import caching<br/>from datetime import date</span><span id="fb6c" class="mv mw jj lx b gy ot my l mz na">def cache_clear_dt(dummy):<br/>   clear_dt = date.today()<br/>   return clear_dt</span><span id="c46d" class="mv mw jj lx b gy ot my l mz na">if cache_clear_dt("dummy")&lt;date.today():<br/>   caching.clear_cache()</span></pre></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="3307" class="nx mw jj bd ny nz oa ob oc od oe of og kp oh kq oi ks oj kt ok kv ol kw om on bi translated">最终应用代码</h1><p id="8384" class="pw-post-body-paragraph ky kz jj la b lb oo kk ld le op kn lg lh oq lj lk ll or ln lo lp os lr ls lt im bi translated">这是上面所有功能的整个应用程序的外观。</p><figure class="mn mo mp mq gt iv"><div class="bz fp l di"><div class="ow ox l"/></div></figure></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="0470" class="nx mw jj bd ny nz oa ob oc od oe of og kp oh kq oi ks oj kt ok kv ol kw om on bi translated">结论</h1><p id="5f46" class="pw-post-body-paragraph ky kz jj la b lb oo kk ld le op kn lg lh oq lj lk ll or ln lo lp os lr ls lt im bi translated">Streamlit 使创建应用程序的整个过程民主化了，我不能再推荐它了。</p><p id="ff7e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，有些事情我们需要绕道而行。在这个令人敬畏的平台上，我仍然喜欢拥有很多东西。我已经与 Streamlit 团队就他们将要引入的新功能进行了讨论，我将尽力让您了解最新情况。</p><p id="cf02" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在我的 Github repo 上找到最终应用的完整代码。</p><p id="5d85" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解创建可视化的最佳策略，我想从密歇根大学调用一门关于<a class="ae jg" href="https://www.coursera.org/specializations/data-science-python?ranMID=40328&amp;ranEAID=lVarvwc5BD0&amp;ranSiteID=lVarvwc5BD0-SAQTYQNKSERwaOgd07RrHg&amp;siteID=lVarvwc5BD0-SAQTYQNKSERwaOgd07RrHg&amp;utm_content=3&amp;utm_medium=partners&amp;utm_source=linkshare&amp;utm_campaign=lVarvwc5BD0" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">数据可视化和应用绘图</strong> </a>的优秀课程，它是一个非常好的<a class="ae jg" href="https://www.coursera.org/specializations/data-science-python?ranMID=40328&amp;ranEAID=lVarvwc5BD0&amp;ranSiteID=lVarvwc5BD0-SAQTYQNKSERwaOgd07RrHg&amp;siteID=lVarvwc5BD0-SAQTYQNKSERwaOgd07RrHg&amp;utm_content=3&amp;utm_medium=partners&amp;utm_source=linkshare&amp;utm_campaign=lVarvwc5BD0" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">数据科学专业的一部分，本身带有 Python </strong> </a>。一定要去看看。</p><p id="1032" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">谢谢你的阅读。将来我也会写更多初学者友好的帖子。在<a class="ae jg" href="https://medium.com/@rahul_agarwal" rel="noopener"> <strong class="la jk">媒体</strong> </a>关注我，或者订阅我的<a class="ae jg" href="http://eepurl.com/dbQnuX" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae jg" href="https://twitter.com/MLWhiz" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系。</p><p id="8632" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，一个小小的免责声明——这篇文章中可能会有一些相关资源的附属链接，因为分享知识从来都不是一个坏主意。</p></div></div>    
</body>
</html>