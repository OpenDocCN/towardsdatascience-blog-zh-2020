<html>
<head>
<title>Comparing Grakn to Semantic Web Technologies — Part 3/3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较 Grakn 和语义 Web 技术—第 3/3 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/comparing-grakn-to-semantic-web-technologies-part-3-3-cb2fb233fbd5?source=collection_archive---------40-----------------------#2020-06-26">https://towardsdatascience.com/comparing-grakn-to-semantic-web-technologies-part-3-3-cb2fb233fbd5?source=collection_archive---------40-----------------------#2020-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ce3b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索共同的概念和差异</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5720cfbb040f15e5ce406412d22a016f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyI_GvKDzixTFb2_UESkQw.png"/></div></div></figure><p id="5fdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是比较语义网技术和 Grakn 的第三部分。在前两部分中，我们研究了 RDF、RDFS 和 SPARQL 与 Grakn 的比较。在这一部分，我们特别关注 OWL 和 SHACL。如果你还没看完第 1 部分，跟着 <a class="ae lr" href="https://medium.com/@tasabat/comparing-grakn-to-semantic-web-technologies-part-1-3-3558c447214a" rel="noopener"> <em class="lq">这个链接</em> </a> <em class="lq">，或者第 2 部分上</em> <a class="ae lr" href="https://medium.com/@tasabat/comparing-grakn-to-semantic-web-technologies-part-2-3-4602b56969fc" rel="noopener"> <em class="lq">这个链接</em> </a> <em class="lq">。</em></p><p id="5c31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">要了解更多信息，请务必通过</em> <a class="ae lr" href="https://discuss.grakn.ai/t/were-taking-our-summer-tour-online/1947/2" rel="noopener ugc nofollow" target="_blank"> <em class="lq">此链接</em> </a> <em class="lq">参加我们即将举办的网络研讨会。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="40f8" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">猫头鹰</h1><h2 id="34b6" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">猫头鹰和 Grakn</h2><p id="ed49" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">OWL 是一种基于描述逻辑(DL)的本体语言，它在 RDFS 的基础上增加了本体结构来表达条件和推导新的事实。为了有意义地使用它们，OWL 提供了不同的风格:OWL QL、OWL RL、OWL DL，用户需要决定哪一个最适合他们的用例。</p><p id="b8ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，Grakn 自带内置的本地推理功能。这是一个重要的区别，因为 OWL 假设用户对逻辑领域有很好的理解，而使用 Grakn 不需要用户对这个领域有广泛的研究。</p><p id="85a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果是 OWL 在表达性和复杂性之间努力保持令人满意的平衡。仅仅为了推理两个简单的约束:<em class="lq">每个父母都有一个孩子</em>和<em class="lq">每个孩子都是一个人</em>需要使用成熟的 OWL DL 推理器。此外，OWL 不适合复杂关系的推理。它的正式基础基于树模型属性，这使它更适合树形数据，但对于更复杂的数据伸缩性较差。</p><p id="01a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">OWL 采用开放世界假设，而不是 Grakn 的封闭世界假设。这意味着在 OWL 有约束的例子中:<em class="lq">每个父母必须至少有一个孩子</em>，如果我们有一个人没有孩子，这仍然符合约束，因为我们可能还不知道 John 的孩子。然而，根据 Grakn 的封闭世界假设，如果没有实际提到约翰的孩子，这意味着他真的没有任何孩子，也不是父母。</p><p id="216a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">开放世界的假设非常适合于开放式网络，它包含来自多个来源的不完全信息，这就是为什么 OWL 提供了许多概念来管理和处理这种不完全性。然而，由于这种开放世界的假设，OWL 很难验证数据的一致性。这就是关系数据库维护模式约束以保证数据质量的原因。Grakn 结合了两种类型的推理:本体类型的开放世界推理和模式类型的封闭世界约束检查。</p><p id="e247" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有的东西放在一起，OWL 对于非逻辑学家来说有着非常高的入门门槛。由于它基于描述逻辑，开发人员避免使用 OWL，因为理解这种语言及其预期行为非常重要。正因为如此，Grakn 的知识表示形式仍然是轻量级的，为比 OWL 更多的受众提供了语义能力。换句话说，Grakn 比 OWL 更容易使用。</p><p id="aa35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们看看 OWL 中的一些常见公理，并将它们与 Grakn 进行比较。这不是一个详尽的列表，提供它是为了帮助用户理解如何考虑迁移到 Grakn。</p><h2 id="a66d" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">限制</h2><p id="a9b3" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">OWL 的一个关键功能是定义限制类(<code class="fe nd ne nf ng b">owl:Restriction</code>)。这些未命名的类是基于该类的某些属性值的限制而定义的。OWL 允许对某个类的某些成员需要具有某些属性的情况进行建模。限制允许区分适用于一个类的所有成员的东西。通过给出一个描述来定义一个限制，该描述限制了关于该类成员的事情的种类。</p><p id="9802" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个例子是限制<code class="fe nd ne nf ng b">AllValuesFrom</code>，它声明在特定类的上下文中，属性的范围应该总是特定的类。例如，如果<code class="fe nd ne nf ng b">AllValuesFrom</code>已经被申请为<code class="fe nd ne nf ng b">Person</code>类，并且这被应用到具有<code class="fe nd ne nf ng b">Person</code>的<code class="fe nd ne nf ng b">hasParent</code>的范围，那么它们只能有<code class="fe nd ne nf ng b">Person</code>父类，而<code class="fe nd ne nf ng b">Animal</code>不能有<code class="fe nd ne nf ng b">Person</code>父类。下面的例子也表明只有<code class="fe nd ne nf ng b">Animal</code> s 可以有<code class="fe nd ne nf ng b">Animal</code> -parents。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="9db1" class="mm lv it ng b gy nl nm l nn no">:Person<br/>  a owl:Class ;<br/>  rdfs:subClassOf<br/>    [ a owl:Restriction ;<br/>      owl:onProperty :hasParent ;<br/>      owl:allValuesFrom :Person<br/>   ] .</span><span id="c919" class="mm lv it ng b gy np nm l nn no">:Animal<br/>  a owl:Class ;<br/>  rdfs:subClassOf<br/>    [ a owl:Restriction ;<br/>      owl:onProperty :hasParent ;<br/>      owl:allValuesFrom :Animal<br/>   ] .</span></pre><p id="e017" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了在 Grakn 中实现这一点，在模式定义中表示了限制。创建<code class="fe nd ne nf ng b">person</code>和<code class="fe nd ne nf ng b">animal</code>实体类型和两个带约束的关系:<code class="fe nd ne nf ng b">person-parentship</code>和<code class="fe nd ne nf ng b">animal-parenthship</code>。前者仅与<code class="fe nd ne nf ng b">person</code>相关，后者与<code class="fe nd ne nf ng b">animal</code>相关。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="78d1" class="mm lv it ng b gy nl nm l nn no">person sub entity, <br/>plays person-child,<br/>plays person-parent;</span><span id="7623" class="mm lv it ng b gy np nm l nn no">animal sub entity,<br/>plays animal-child,<br/>plays animal-parent;</span><span id="a37b" class="mm lv it ng b gy np nm l nn no">parentship sub relation, abstract;</span><span id="0189" class="mm lv it ng b gy np nm l nn no">person-parentship sub parentship,<br/>relates person-child,<br/>relates person-parent;</span><span id="97f0" class="mm lv it ng b gy np nm l nn no">animal-parentship sub parentship;<br/>relates animal-child,<br/>relates animal-parent;</span></pre><h2 id="10a5" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">传递属性</h2><p id="6c2f" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">OWL 中一个常见的推论是传递性。这说明关系 R 被说成是<em class="lq">传递的</em>，如果 A 用 R(a，B)连接到 B，B 用 R(b，C)连接到 C，这暗示 A 用 R(a，C)连接到 C。构造<code class="fe nd ne nf ng b">owl:TransitiveProperty</code>用于此目的。下面的例子可以推断国王十字车站位于欧洲。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="7818" class="mm lv it ng b gy nl nm l nn no">:isLocated rdf:type owl:TransitiveProperty.</span><span id="2da9" class="mm lv it ng b gy np nm l nn no">:KingsCross isLocated :London.<br/>:London isLocated :UK.<br/>:UK isLocated :Europe.</span></pre><p id="9767" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Grakn 中，将创建一个规则来表示传递性:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="f097" class="mm lv it ng b gy nl nm l nn no">when {<br/>	$r1 (located: $a, locating: $b); <br/>	$r2 (located: $b, locating: $c); 	<br/>}, then {<br/>	(located: $a, locating: $c);<br/>};</span></pre><p id="0fe2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦定义了规则，如果加载了此数据:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="cb07" class="mm lv it ng b gy nl nm l nn no">insert <br/>$a isa city, has name "London"; <br/>$b isa country, has name "Uk"; <br/>$c isa continent, has name "Europe"; <br/>(located: $a, locating: $b); (located: $b, locating: $c);</span></pre><p id="bfa4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们接着查询:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="81a7" class="mm lv it ng b gy nl nm l nn no">match  <br/>$b isa continent, has name "Europe"; <br/>(located: $a, locating: $b); get $a;</span></pre><p id="992b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这不仅会产生与<code class="fe nd ne nf ng b">continent</code>“欧洲”有直接关系的<code class="fe nd ne nf ng b">country</code>“英国”，而且还会产生与<code class="fe nd ne nf ng b">continent</code>“欧洲”有过渡关系的<code class="fe nd ne nf ng b">city</code>“伦敦”。</p><h2 id="1ffb" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">等效属性</h2><p id="afb5" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">OWL 还提供了一个构造来模拟等价的属性。这表明两个属性具有相同的属性扩展。一个例子:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="b7fb" class="mm lv it ng b gy nl nm l nn no">:borrows owl:equivalentProperty :checkedOut .</span></pre><p id="b5ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可以用 Grakn 中的规则来表示，其中可以推断出如下新关系<code class="fe nd ne nf ng b">checked-out</code>:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="f7f5" class="mm lv it ng b gy nl nm l nn no">when {<br/>    (borrower: $x, borrowing: $y) isa borrowing;<br/>}, <br/>then {<br/>    (checking-out: $x, checked-out: $y) isa checked-out;<br/>};</span></pre><h2 id="0ec4" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">对称属性</h2><p id="5f66" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">对称关系表示一种具有自身反向属性的关系。例如，如果 Susan 通过一个<code class="fe nd ne nf ng b">hasSibling</code>属性与 Bob 相关，那么可以推断 Bob 也通过一个<code class="fe nd ne nf ng b">hasSibling</code>属性与 Susan 相关。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="e8c3" class="mm lv it ng b gy nl nm l nn no">:hasSibling rdf:type owl:SymmetricProperty .</span></pre><p id="49ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Grakn 中，对称性可以通过简单地在一个或多个关系中重复角色来建模:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="f1ee" class="mm lv it ng b gy nl nm l nn no">(sibling: $p, sibling: $p2) isa siblingship;</span></pre><p id="d880" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，在 OWL 中需要显式构造的东西是 Grakn 模型固有的，也就是说，对称性规则不需要显式。然而，这也是 OWL 和 Grakn 比较困难的地方，因为两者服务于不同的用例。特别是，鉴于 Grakn 的封闭世界假设，OWL 中的许多问题根本不存在。</p><h2 id="a931" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">功能属性</h2><p id="940b" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">这就是我们如何建模更多 OWL 结构的方法。<code class="fe nd ne nf ng b">owl:FunctionalProperty</code>表示如下:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="199a" class="mm lv it ng b gy nl nm l nn no">hasFather rdf:type owl:FunctionalProperty .</span></pre><p id="5541" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Grakn 中，可以使用一个规则:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="8912" class="mm lv it ng b gy nl nm l nn no">when {<br/>	(father: $x, child: $ y) isa fatherhood;<br/>	(father: $d, child: $ y) isa fatherhood;<br/>}, <br/>then {<br/>	(father: $x, father: $y) isa same-father;<br/>};</span></pre><h2 id="50cb" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">的交叉</h2><p id="4660" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">如果我们在这个例子中使用<code class="fe nd ne nf ng b">owl:intersectionOf</code>:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="5699" class="mm lv it ng b gy nl nm l nn no">:Mother rdfs:subClassOf [ owl:interesctionOf ( :Female :Parent ) ]</span></pre><p id="d38a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果资源既是<code class="fe nd ne nf ng b">:Female</code>又是<code class="fe nd ne nf ng b">Parent</code>，那么这将分配类<code class="fe nd ne nf ng b">:Mother</code>。在 Grakn 中，我们可以选择使用包含连接条件的规则来表示这一点:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="4d48" class="mm lv it ng b gy nl nm l nn no">when {<br/>	$p isa person, has gender "female"; <br/>	(mother: $p) isa motherhood; <br/>}, <br/>then {<br/>	(parent: $p) isa parenthood; <br/>};</span></pre><h2 id="95f2" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">工会联合会</h2><p id="5994" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">如果我们有这个<code class="fe nd ne nf ng b">owl:unionOf</code>的例子:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="2276" class="mm lv it ng b gy nl nm l nn no">:Person owl:equivalentClass [ owl:unionOf (: Woman :Man ) ]</span></pre><p id="8781" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果资源是类<code class="fe nd ne nf ng b">:Woman</code>或<code class="fe nd ne nf ng b">:Man</code>，则分配类<code class="fe nd ne nf ng b">:Person</code>。在 Grakn 中，如果我们想达到同样的目的，一种方法是使用类型继承:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="ced6" class="mm lv it ng b gy nl nm l nn no">person sub entity; <br/>man sub person;<br/>woman sub person;</span></pre><h2 id="69b7" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">散列值</h2><p id="749c" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated"><code class="fe nd ne nf ng b">owl:hasValue</code>限制可以规定红葡萄酒应该具有颜色“红色”作为其<code class="fe nd ne nf ng b">color</code>属性的值:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="4ca7" class="mm lv it ng b gy nl nm l nn no">:RedWine<br/>  a owl:Class ;<br/>  rdfs:subClassOf<br/>    [ a owl:Restriction ;<br/>      owl:onProperty :color ;<br/>      owl:hasValue "red" <br/>    ] .</span></pre><p id="3a94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Grakn 中，可以使用一个规则来表示这一点:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="04c8" class="mm lv it ng b gy nl nm l nn no">when {<br/>	$w isa red-wine; <br/>}, <br/>then {<br/>	$w has color "red"; <br/>};</span></pre><h2 id="c2d3" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">哈斯尔夫</h2><p id="7e31" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">限制可以说明自恋者爱自己。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="e576" class="mm lv it ng b gy nl nm l nn no">:Narcissist rdfs:subClassOf<br/>	[ owl:hasSelf true ; owl:onProperty :loves ]</span></pre><p id="2cc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可以用 Grakn 表示:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="8507" class="mm lv it ng b gy nl nm l nn no">when {<br/>	$n isa narcissist; <br/>}, <br/>then {<br/>	(loving: $n) isa loves; <br/>};</span></pre><p id="4347" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，Grakn 不是为 OWL 的相同用例而构建的。因此，无法进行一对一的直接映射。例如，当处理多个类时，需要考虑建模决策:在 Grakn 中，哪些成为实体，哪些成为角色。</p><h1 id="d313" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">向 SHACL 核实</h1><p id="dbd3" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">传统上，RDF 不能确保接收的数据符合一组条件——即模式。这就是 SHACL 标准的作用，它在提交之前检查 RDF 是否与模式逻辑一致。还有其他检查逻辑验证的方法，只是实现略有不同。</p><p id="6231" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像 SHACL 一样，Grakn 也检查有效性，并强调与数据质量有关的问题。但是尽管 SHACL 只是一个验证模式，Grakn 却实现了一个语义模式。</p><p id="c72f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用验证模式时，如果被摄取的数据源包含模式冲突，事务将失败。然后，我们会查看来源，对其进行筛选，并再次摄取。使用语义模式，我们可以加载数据，验证数据，并标记数据是否违规。然后我们可以在它们被载入的时候在线处理它们。</p><p id="af79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从这个意义上说，语义模式为您提供了额外的保证，即所有获取的数据都符合您的模式。这意味着数据库中的所有数据都与已定义的模式一致。</p><p id="b1f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">SHACL 中的代码片段显示了数据需要如何遵守某些限制:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="d7bf" class="mm lv it ng b gy nl nm l nn no">:Person a sh:NodeShape, rdfs:Class ;<br/>	sh:property [<br/>	sh:path schema:worksFor ;<br/>	sh:node :Company ;<br/>] .</span><span id="3de4" class="mm lv it ng b gy np nm l nn no">:Company a sh:Shape ;<br/>	sh:property [<br/>	sh:path     schema:name ;<br/>	sh:datatype xsd:string;<br/>] .</span></pre><p id="eae8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Grakn 中，这种验证发生在 Graql 的模式语言中。<code class="fe nd ne nf ng b">Person</code>实体定义为在<code class="fe nd ne nf ng b">employment</code>关系中只扮演<code class="fe nd ne nf ng b">employee</code>的角色，通过<code class="fe nd ne nf ng b">employer</code>的角色与<code class="fe nd ne nf ng b">company</code>实体相关联，包括类型<code class="fe nd ne nf ng b">name</code>和值<code class="fe nd ne nf ng b">string</code>的属性。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="525c" class="mm lv it ng b gy nl nm l nn no">define <br/>person sub entity, <br/>	plays employee; <br/>company sub entity, <br/>	has name,<br/>	plays employer; <br/>employment sub relation, <br/>	relates employer,<br/>	relates employee;<br/>name sub attribute, value string;</span></pre><h1 id="797b" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="66fa" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">总之，我们已经看到了:</p><ol class=""><li id="220a" class="nq nr it kw b kx ky la lb ld ns lh nt ll nu lp nv nw nx ny bi translated">与语义网相比，Grakn 降低了复杂性，同时保持了高度的表达能力。有了 Grakn，我们不必学习不同的语义 Web 标准，每个标准都有很高的复杂性。这降低了进入的门槛。</li><li id="55c5" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated">与语义网标准相比，Grakn 为处理复杂数据提供了更高层次的抽象。使用 RDF，我们用三元组来建模世界，这是一个比 Grakn 的实体-关系概念级模式更低级的数据模型。对高阶关系和复杂数据的建模和查询是 Grakn 的原生功能。</li><li id="ddc2" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated"><strong class="kw iu">语义网标准是为网络构建的，Grakn 适用于封闭世界系统</strong>。前者旨在处理开放网络上不完整数据的链接数据，而 Grakn 的工作方式类似于封闭环境中的传统数据库管理系统。</li></ol><p id="2d63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Grakn 为我们提供了一种语言，这种语言为我们提供了概念级模型、类型系统、查询语言、推理引擎和模式验证。用语义 Web 标准做同样的事情需要多种标准和它们各自的实现，每种标准都有自己固有的复杂性。特别是，OWL 的特性非常丰富，这导致了高度的复杂性，使它不适合大多数软件应用程序。相反，在处理知识表示和自动推理时，Grakn 提供了复杂性和表达性之间的适当平衡。</p><p id="117c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种比较旨在提供两种技术之间的高层次的相似性和差异，但是，当然，Grakn 和语义 Web 还有比我们在这里试图展示的更多的东西。</p><p id="e4ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">要了解更多信息，请务必通过</em> <a class="ae lr" href="https://discuss.grakn.ai/t/were-taking-our-summer-tour-online/1947/2" rel="noopener ugc nofollow" target="_blank"> <em class="lq">此链接</em> </a> <em class="lq">参加我们即将举办的网络研讨会。</em></p></div></div>    
</body>
</html>