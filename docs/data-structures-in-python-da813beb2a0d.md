# Python 中的数据结构

> 原文：<https://towardsdatascience.com/data-structures-in-python-da813beb2a0d?source=collection_archive---------17----------------------->

![](img/eb1f713f3833a0ed184f9216d475173c.png)

丁满·克劳斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

## 精通列表——Python 最通用的数据结构

这篇文章是关于**列表**的。它们是 Python 中最通用、最足智多谋的**内置数据结构**。它们可以同时保存**异构数据**，即整数、浮点、字符串、NaN、布尔、函数等。在同一个列表中。它们是条目的有序序列，这意味着在访问列表时元素的顺序是保持不变的。它们是**可变的**，即你可以改变(添加、删除、修改)列表中的任何一项。它们可以有旧的重复项，不像“集合”Python 中的另一种数据结构。

读完这篇文章后，你将对 Python 列表有一个清晰的理解并有能力在**高级水平上工作。**

我将讨论以下主题:

*   **创建列表并添加元素**
*   **访问列表元素**
*   **删除列表元素**
*   **插入元素**
*   **列表运算**
*   **反转列表**
*   **排序列表**
*   **某项的索引**
*   **盘点列表中的项目频率**
*   **列举理解**
*   **复制列表**
*   **嵌套列表**

# 1)创建列表并添加元素

首先，我们初始化一个名为“数据”的**空列表**。该列表是使用方括号创建的。自然，空列表的长度为零。

```
data = []len(data)
>>> 0# Check the type of the variable 'data'
type(data)
>>> list
```

现在让我们将第一个元素添加到这个列表中。这是使用 **append()** 函数完成的。你会注意到它的长度现在变成了 1。

```
data.append(100)data 
>>> [100]len(data)
>>> 1
```

让我们添加第二个元素。它将被附加(添加)在列表的末尾。同样，您可以添加任意多的元素。

```
data.append(200)
data
>>> [100, 200]len(data)
>>> 2data.append(300)
data
>>> [100, 200, 300]
```

当**您事先不知道**列表中有多少元素时，**追加**功能很有用。例如，要存储每小时进入商店的人数，需要追加每小时的顾客人数。但是，如果你只是主持了一次考试，你就知道到底有多少学生写了试卷。现在，如果你想在一个列表中存储他们的成绩，而不是追加，你可以初始化你的列表。

```
grades = [70, 100, 97, 67, 85]len(grades)
>>> 5
```

**不用担心！**您仍然可以使用 append 向已经初始化的列表中添加更多的元素。只需简单地使用`data.append(80)`来添加第六个学生的成绩，它将被附加在列表的末尾。

## **如何一次性将两个或两个以上学生的分数相加？**

假设你想同时追加三个学生的分数。您不能使用 **grades.append(99，100，95)** ，因为**“append”只接受一个参数**。您将不得不使用“追加”功能三次。

在这种情况下，您可以使用 **extend()** 而不是追加三次。您需要将这三个元素放在一个元组形式中(一个 iterable)。

注意**不能使用 extend 来追加单个元素**，即`data.extend((90))`不起作用。

```
grades = [70, 100, 97, 67, 85]
grades.extend((99, 100, 95))
print (grades)
>>> [70, 100, 97, 67, 85, 99, 100, 95]
```

## **现在你会问，“为什么我们不能一次追加三个等级？”**

可以，**但是有一个条件**。如下所示，一起插入的三个等级在主列表中显示为一个列表。这样的列表被称为**【嵌套列表】**。我将在本文的最后一节展示更多的例子。

```
grades = [70, 100, 97, 67, 85]
grades.append([99, 100, 95])
print (grades)
>>> [70, 100, 97, 67, 85, [99, 100, 95]] # A nested list
```

# 2)访问列表元素

如果你正在处理数据结构，了解**索引**的概念是非常有用的。你可以认为索引是分配给列表中每个元素的序列号。简单来说，就是类似于你在一个班级的点名。

> ****最重要的*** *要知道的是，Python 中的* ***索引是从 0*** *开始的。**

*因此，第一个元素的索引为 0，第二个元素的索引为 1，依此类推。在五个元素的列表中，最后一个(第五个)元素的索引值为 4。*

```
*grades = [70, 100, 97, 67, 85]# First element (index 0)
grades[0]
>>> 70# Second element (index 1)
grades[1]
>>> 100# Last element (index 4)
grades[4]
>>> 85*
```

*不要越界。如果你试图使用一个大于列表长度的索引值，你将得到一个 **IndexError** 。因此，在一个包含 5 个元素的列表中，不能使用索引 5(因为它引用了第 6 个元素)。*

```
*grades[5]
**-----------------------------------------------------------------**
**IndexError** Traceback (most recent call last)
**<ipython-input-29-d8836f1h2p9>** in <module>
**----> 1** data**[5]****IndexError**: list index out of range*
```

## *访问列表的多个元素*

*如果您想要前三个元素，您可以使用**切片**来访问它们。一般格式是`list[start_index:end_index]`。这里比较棘手的部分是这个符号会返回值，直到 **end_index - 1** 的索引值。这意味着，要获得索引为 0、1 和 2 的列表的前三个元素，需要以下方法。*

```
*grades = [70, 100, 97, 67, 85]
grades[0:3]
>>> [70, 100, 97]*
```

*如果您只想访问索引为 0 的第一个元素，可以使用切片符号来获取它。*

```
*grades[0:1]
>>> [70]*
```

## *反向索引*

*现在你也应该知道我称之为**【反向索引】**或**【负索引】**的有用概念。*

*要访问最后一个元素，首先需要知道列表的长度。因此，在 5 个元素的列表中，需要使用索引 4(= 5–1，因为索引从 0 开始)。因此，数据[4]将是您的最后一个元素。类似地，倒数第二个元素将是 data[3]，依此类推。*

*如您所见，这种计算很麻烦。负指数将在这里帮助你。简单来说就是从末尾开始数元素个数。最后一个元素不能在索引-0 处，因为没有这样的数字。因此，您需要使用索引值-1 来访问它。类似地，倒数第二个元素可以使用索引值-2 来访问，依此类推。*

```
*grades = [70, 100, 97, 67, 85]
grades[-1]
>>> 85grades[-2]
>>> 67*
```

## *"负索引可以用来访问最后 3 个元素吗？"。*

*是的。您需要指定起始负索引。要获取从倒数第三个元素开始的所有元素，不需要指定结束索引。*

```
*grades = [70, 100, 97, 67, 85]
grades[-3:]
>>> [97, 67, 85]*
```

*但是，假设您想要获取倒数第三个和倒数第二个元素，而不是最后一个元素。您可以将结束索引限制为:*

```
*grades[-3:-1]
>>> [97, 67]*
```

## *2.1)定期访问元素*

*到目前为止，您已经学习了如何访问单个元素或几个连续的元素。假设你想从列表中得到第 n 个项目。这样做的一般语法是`list[start_index : stop_index : step]`。*

***举例:**如果你想从第一个元素开始到第七个元素，即从[1，2，3，4，5，6，7]开始，每隔一个元素访问一次，你需要[1，3，5，7]。*

```
*data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
data[0:7:2]
>>> [1, 3, 5, 7]*
```

*如果你想要从第一个元素开始的整个列表中的第二个元素，你可以跳过`start_index`和`stop_index`。*

```
*data[::2]
>>> [1, 3, 5, 7, 9]*
```

*如果您想要从第二个元素开始的整个列表中的每第二个元素，使用下面的代码。*

```
*data[1::2]
>>> [2, 4, 6, 8, 10]*
```

***注意:**你也可以使用`data[::1]`来访问整个列表，因为这将返回从开始到结束的所有元素。*

***以固定的间隔向后遍历一个列表** 你需要使用一个负的步长值。要获取从末尾开始的每个元素，即整个列表的逆序，请使用下面的代码。*

```
*data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
data[::-1]
>>> [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]*
```

*若要从最后一个元素开始每隔一个元素访问一次，请使用以下代码。*

```
*data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
data[::-2]
>>> [10, 8, 6, 4, 2]*
```

*让我们看一个更复杂的反向遍历例子。假设你想从倒数第三个元素开始，一直到第四个元素，每隔一个元素选择一个。您的开始索引现在变为-3，停止索引变为 3(第四个元素的索引从 0 开始)。*

```
*data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
data[-3:3:-2]
>>> [8, 6]*
```

# *3)删除列表元素*

*有三种方法可以从列表中删除元素。这三种方法都执行就地删除，也就是说，在删除之后，您不需要将列表重新分配给新的变量。*

*a) `del`(内置函数)**能否一次删除多个项目**
b)`remove()`(列表的方法)**能否一次删除一个项目**
c)`pop()`(列表的方法)**能否一次删除一个项目***

*让我们逐一研究它们。*

## *a)德尔*

*使用`del`时，需要传递要删除的元素的索引或一部分索引。您可以使用上面介绍的所有索引/切片概念，通过 **del** 删除元素。*

```
*# Deleting first element
data = [79, 65, 100, 85, 94]
del data[0]
print (data)
>>> [65, 100, 85, 94] ############################################################## Deleting second last element
data = [79, 65, 100, 85, 94]
del data[-2]
print (data)
>>> [79, 65, 100, 94]############################################################# # Deleting multiple consecutive elements using slice
data = [79, 65, 100, 85, 94]
del data[0:3]
print (data)
>>> [85, 94]############################################################## # Deleting multiple elements at regular interval using slice
data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
del data[1::2]
data
# [1, 3, 5, 7, 9]*
```

## *b)移除()*

*这个方法用于**从列表中删除一个特定的元素**。如果一个元素出现不止一次，那么**只有第一次出现的元素**会被删除。例如，在下面的列表中，1 出现了 3 次。所以使用`remove(1)`将删除第一个值，保留其余的值。*

```
*data = [1, 1, 4, 4, 3, 1, 3, 2, 4, 2]
data.remove(1)
print (data)
>>> [1, 4, 4, 3, 1, 3, 2, 4, 2]*
```

***奖励:**你可以使用一个 **while 循环**来移除所有出现的 1。*

```
*data = [1, 1, 4, 4, 3, 1, 3, 2, 4, 2]
to_del = 1while to_del in data:
    data.remove(to_del)

print (data)
>>> [4, 4, 3, 3, 2, 4, 2]*
```

## *c) pop()*

*这个方法的语法是`list.pop(i)`，它从列表中弹出(删除)索引‘I’**处的元素。下面的代码演示了它在连续应用于一个列表时是如何工作的。***

*****注意:**如果不指定索引，最后一个元素将被删除。***

```
***# Using pop(i) by specifying the index i
data = [1, 2, 3, 4, 5]
data.pop(0)
print (data)
>>> [2, 3, 4, 5]data.pop(1)
print (data)
>>> [2, 4, 5]data.pop(1)
print (data)
>>> [2, 5]############################################################## Using pop() without specifying the index i
data = [1, 2, 3, 4, 5]
data.pop()
print (data)
>>> [1, 2, 3, 4]data.pop()
print (data)
>>> [1, 2, 3]***
```

# ***4)插入元素***

***可以使用功能`list.insert(i, element)`在指定位置插入一个元素。这里的‘I’是列表中要插入`element`的现有元素的索引。正如您之前看到的，`append()`函数将元素插入到列表的末尾。***

*****注意:**这是一个**就地操作**，所以你不必重新分配列表。***

```
***# Inserting value of 4 at the start, before the element at index 0
data = [1, 2, 3]
data.insert(0, 4) 
print (data)
>>> [4, 1, 2, 3]############################################################## Inserting value of 4 before the element at index 1
data = [1, 2, 3]
data.insert(1, 4)
print (data)
>>> [1, 4, 2, 3]***
```

***如果你想在列表的末尾插入，也就是说，追加，那么简单地使用列表的长度作为插入的位置。***

```
***data = [1, 2, 3]
data.insert(len(data), 4)
print (data)
>>> [1, 2, 3, 4]***
```

# ***5)列表算法***

***当您添加两个或更多列表时会发生什么？假设您有以下两个列表。***

```
***list_A = [1, 2, 3, 4, 5]
list_B = [6, 7, 8, 9, 10]***
```

***如果您添加它们，您会期望两个列表的元素相加。但是，您将得到一个列表，其中两个列表的元素按照相加的顺序被附加(连接)在一起。***

```
***list_A + list_B 
>>> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]***
```

***顺序很重要。对于列表来说，A + B 不等于 B+A**所以，如果颠倒加法的顺序，就会得到不同的结果。*****

```
*****list_B + list_A
>>> [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]*****
```

## *****你能做两个列表的减法、乘法或除法吗？*****

*****不，你不能。举个例子，如果你试着把上面两个列表相减，你会得到一个`TypeError`。类似地，乘法或除法也会抛出错误。尝试一下说服自己。*****

*****如果你将列表乘以一个大于 0 的正整数，你的列表将重复(复制)那么多次。例如，将列表乘以 3 会将列表重复 3 次。乘以浮点数(3.0)会产生错误。将列表乘以 0 或负整数产生一个空列表**。*******

```
*****# Multiplication by positive integer
data = [1, 2, 3]
data * 3 # equivalent to data + data + data
>>> [1, 2, 3, 1, 2, 3, 1, 2, 3]# Multiplication by 0
data * 0
>>> []*****
```

*******注意:**如果您试图乘以[3]而不是 3，将会报告错误。*****

# *****6)反转列表*****

*****有两种方法可以反转列表。*****

*****a)使用**切片**作为[::-1]。这不会就地更改列表。您必须重新分配列表，以反映原始列表中的更改。*****

```
*****data = [1, 2, 3]
data[::-1]
>>> [3, 2, 1]print (data)
>>> [1, 2, 3] # The original list does not change# You have to re-assign the list after reversing
data = [1, 2, 3]
data = data[::-1] # Re-assign print (data)
>>> [3, 2, 1]*****
```

*****b)使用`**list.reverse()**` 功能。在这里，您不需要重新分配，因为列表是就地反转的。*****

```
*****data = [1, 2, 3]
data.reverse() # reverses the list in-place print (data)
>>> [3, 2, 1] # The original list does not change*****
```

# *****7)对列表进行排序*****

*****对列表进行排序有两种直接的方法。*****

*****a)使用`**sorted()**` 功能。这不会对列表进行就地排序。
b)使用`**list.sort()**` 功能。执行就地排序。*****

*****在这两个函数中，您可以使用关键字“reverse”选择升序或降序排序。如果“reverse=True”，则列表按降序排序。默认情况下，列表按升序排序。*****

```
*****# First method using sorted()
data = [7, 4, 1, 3, 8, 5, 9, 6, 2]
sorted(data, reverse=False) # Same as sorted(data) due to default
>>> [1, 2, 3, 4, 5, 6, 7, 8, 9]############################################################## Second method using list.sort()
data = [7, 4, 1, 3, 8, 5, 9, 6, 2]
data.sort(reverse=True)
print (data)
>>> [1, 2, 3, 4, 5, 6, 7, 8, 9]*****
```

## *******字符串是如何排序的？*******

*   *****默认情况下，不同长度的字符串将按字母顺序排序。*****
*   *****如果字符串的起始字母相同，但大小写不同，则大写字母优先。*****
*   *****如果两个或两个以上的字符串具有相同的大小写首字母，它们将根据第二个字母按字母顺序排序，依此类推。*****

*****让我们看一些使用第二种方法的字符串示例。*****

```
*****data = ['pineapple', 'kiwi', 'apple', 'azure', 'Apricot', 'mango']
data.sort() # in-place sorting
print (data)
>>> ['Apricot', 'apple', 'azure', 'kiwi', 'mango', 'pineapple']#############################################################data = ['pineapple', 'kiwi', 'apple', 'Apricot', 'mango']
data.sort(reverse=True)
print (data)
>>> ['pineapple', 'mango', 'kiwi', 'apple', 'Apricot']*****
```

## *******如何根据字符串的长度进行排序？*******

*****你需要使用关键字`key=len`。如果你想要长度降序排列，使用一个额外的关键字`reverse=True`。*****

```
*****data = ['pineapple', 'kiwi', 'apple', 'Apricot', 'orange', 'mango']
data.sort(key=len, reverse=True)
print (data)
>>> ['pineapple', 'Apricot', 'orange', 'apple', 'mango', 'kiwi']*****
```

# *****8)项目的索引*****

*****如果您想获得给定列表中某个条目的索引，可以使用命令`list.index(item)`来实现。它在整个列表中搜索项目。如果同一个项目出现多次，您将只获得它第一次出现的索引。*****

```
*****grades = [70, 100, 97, 70, 85]
grades.index(100)
>>> 7grades.index(70) # 70 appears twice at indices 0 and 3
>>> 0            # Only the first index returns*****
```

*****假设您的列表非常大，并且您希望只在列表的特定子集中搜索一个元素。您可以为子集指定“开始”和“结束”索引。*****

```
*****grades = [70, 100, 97, 70, 85, 100, 400, 200, 32] # Search in the whole list
grades.index(100)
>>> 7# Search in the partial list from index 3 until index 8grades.index(100, 3, 8)
>>> 5  # Now the index of the second 100 is returned*****
```

# *****9)统计列表中的项目频率*****

*****您可以使用`list.count(item)`统计列表中给定项目的出现频率。让我们考虑下面的例子。*****

```
*****data = [6, 4, 1, 4, 4, 3, 4, 8, 5, 4, 6, 2, 6]
data.count(4)
>>> 5*****
```

## *******功能使用示例*******

*****假设您想要计算并打印所有元素的频率。为此，我们首先需要列表中的唯一项目。我会用 NumPy 的`unique()`。*****

```
*****import numpy as npdata = [1, 1, 4, 4, 3, 1, 3, 2, 4, 2]for item in np.unique(data):
    print("{} occurs {} times in the list"\
           .format(item, data.count(item)))>>> 1 occurs 3 times in the list
>>> 2 occurs 2 times in the list
>>> 3 occurs 2 times in the list
>>> 4 occurs 3 times in the list*****
```

# *****10)列出理解*****

*****假设您想计算从 0 到 5 的数字的立方，并将它们存储在一个列表中。首先需要初始化一个空列表，创建一个 for 循环，然后将各个数字的立方体追加到这个列表中。*****

```
*****cubes = []
for i in range(6):
    cubes.append(i**3)

print (cubes)
>>> [0, 1, 8, 27, 64, 125]*****
```

*****上面的代码对于这么简单的任务来说太多了吧？嗯，你可以简单地使用【列表理解】如下所示。*****

```
*****cubes = [i**3 for i in range(6)]
print (cubes)
>>> [0, 1, 8, 27, 64, 125]*****
```

# *****11)复制列表*****

*****假设你有一个名为‘list _ A’的列表，你把这个列表分配给另一个名为‘list _ B’的列表。如果您从“list_A”中删除一个元素，您会期望“list_B”不会改变。下面的代码表明事实并非如此。从“list_A”中删除元素也会将其从“list_B”中删除。*****

```
*****list_A = [1, 2, 3, 4, 5]
list_B = list_Adel list_A[0] # Delete an element from list_Aprint (list_A, list_B)
# [2, 3, 4, 5] [2, 3, 4, 5]*****
```

## *******为什么 list_B 会受到影响？*******

*****这是因为当你写`list_A = list_B`的时候，你创建了一个对‘列表 _ A’的引用。因此,‘list _ A’中的变化也会反映到‘list _ B’中的。*****

## *******如何避免 list_B 的变化？*******

*****答案是创建一个浅拷贝。我将解释做这件事的两种方法。*****

*****a)使用`list.copy()` b)使用`list[:]`*****

*****下面的例子表明，现在从‘list _ A’中删除一个元素并不影响浅层拷贝，即‘list _ B’。*****

```
*****# First method using list.copy()
list_A = [1, 2, 3, 4, 5]
list_B = list_A.copy()del list_A[0] # Delete an element from list_A
print (list_A, list_B)
# [2, 3, 4, 5] [1, 2, 3, 4, 5]#############################################################
# Second method using list[:]
list_A = [1, 2, 3, 4, 5]
list_B = list_A[:]del list_A[0] # Delete an element from list_A
print (list_A, list_B)
# [2, 3, 4, 5] [1, 2, 3, 4, 5]*****
```

# *****12)嵌套列表*****

*****包含另一个子列表作为元素的列表称为**嵌套列表**。元素子列表可以包含更多的子列表。子列表中的元素也可以使用索引和切片来访问。让我们考虑下面的例子。*****

```
*****data = [1, 2, 3, [4, 5, 6]]data[2]   # Single element
>>> 3 data[3]   # Sublist
>>> [4, 5, 6]*****
```

*****现在的问题是，“如何访问子列表的元素？”。您可以使用双重索引来访问它们。例如，data[3]返回子列表。所以这个子列表的第一个元素可以使用 data[3][0]来访问。*****

```
*****data[3][0]
>>> 4data[3][1]
>>> 5data[3][2]
>>> 6*****
```

*****现在考虑下面的**列表，它在子列表**中有一个子列表。列表的长度是 4，其中前 3 个元素是 1、2 和 3，最后一个元素是[4、5、6、[7、8、9]]。最后一个元素的长度是 4，它是一个子列表。这样，你就可以越来越深入到嵌套列表中。*****

*****要访问子列表的元素，您需要使用**双索引、三索引**等。如下例所示。*****

```
*****data = [1, 2, 3, [4, 5, 6, [7, 8, 9]]] # A nested list# Length of the list
len(data)
>>> 4# The last element
data[3]
>>> [4, 5, 6, [7, 8, 9]]# Length of the last element
len(data[3])
>>> 4#############################################################
# Accessing the elements of the first sublist
data[3][1]     # Double indices
>>> 5data[3][3]     # Double indices
>>> [7, 8, 9]#############################################################
# Accessing the elements of the second sublist
data[3][3][0]  # Triple indices 
>>> 7data[3][3][-1] # Triple indices
>>> 9*****
```

*****这让我想到了这篇文章的结尾。我介绍了与列表相关的大部分操作，现在读者应该对 Python 中的列表有了进一步的了解。如果你有兴趣了解即将到来的 Python 3.10 版本和 **Matplotlib 3.0** 中的**新特性，请参考以下帖子。*******

*****[](/python-in-2021-timeline-and-upcoming-features-c8369abbcc52) [## 2021 年的 Python 时间表和即将推出的功能

### Python 3.10 的一些新特性的预览

towardsdatascience.com](/python-in-2021-timeline-and-upcoming-features-c8369abbcc52) [](/whats-new-in-matplotlib-3-1b3b03f18ddc) [## Matplotlib 3 的新特性

### 第 3 代中最重要的更新概述

towardsdatascience.com](/whats-new-in-matplotlib-3-1b3b03f18ddc)*****