<html>
<head>
<title>How to Create a Correlation Matrix with Too Many Variables in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建R中变量过多的相关矩阵</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-create-a-correlation-matrix-with-too-many-variables-309cc0c0a57?source=collection_archive---------8-----------------------#2020-02-23">https://towardsdatascience.com/how-to-create-a-correlation-matrix-with-too-many-variables-309cc0c0a57?source=collection_archive---------8-----------------------#2020-02-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="47ba" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有效地过滤掉不相关的变量，以查看更相关的结果。</h2></div><p id="4d54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我使用了<a class="ae lb" href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques" rel="noopener ugc nofollow" target="_blank"> Kaggle房价数据集</a>，它有79个解释变量。在我的分析中，我试图查看所有变量之间的相关性，并意识到有太多的变量使任何典型的视觉辅助工具变得有意义。</p><p id="5c64" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我尝试了几种不同的软件包和工具，并决定我可以操纵<a class="ae lb" href="https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html" rel="noopener ugc nofollow" target="_blank"> corrplot </a>做我最想要的事情。没有任何处理，这就是相关矩阵的样子。这显然是一种非常无益的视觉化。肯定有方法可以改变包中内置的视图，但是没有一种方法可以真正处理这么多的变量。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="9ada" class="ll lm iq lh b gy ln lo l lp lq">library(corrplot)</span><span id="cbc0" class="ll lm iq lh b gy lr lo l lp lq">df_cor &lt;- cor(df)<br/>corrplot(df_cor)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/11cb549972b21f3fcf6ff4e04f539f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*i_BNM9z4eUb0pf0dzhuBAQ.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">corrplot中的初始图表</p></figure><p id="fc9f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经过大量的反复试验和对堆栈溢出的清理，我能够创建一个函数来简化这个过程。首先，它会将所有变量转换成数值(如果还没有)。然后，它会丢弃重复项并完善相关性(与自身的相关性)。这些显然是没用的。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="3924" class="ll lm iq lh b gy ln lo l lp lq">corr_simple &lt;- function(data=df,sig=0.5){<br/>  #convert data to numeric in order to run correlations<br/>  #convert to factor first to keep the integrity of the data - each value will become a number rather than turn into NA<br/>  df_cor &lt;- data %&gt;% mutate_if(is.character, as.factor)<br/>  df_cor &lt;- df_cor %&gt;% mutate_if(is.factor, as.numeric)</span><span id="0ed1" class="ll lm iq lh b gy lr lo l lp lq">  #run a correlation and drop the insignificant ones<br/>  corr &lt;- cor(df_cor)<br/>  #prepare to drop duplicates and correlations of 1     <br/>  corr[lower.tri(corr,diag=TRUE)] &lt;- NA <br/>  #drop perfect correlations<br/>  corr[corr == 1] &lt;- NA </span><span id="1184" class="ll lm iq lh b gy lr lo l lp lq">  #turn into a 3-column table<br/>  corr &lt;- as.data.frame(as.table(corr))<br/>  #remove the NA values from above <br/>  corr &lt;- na.omit(corr) </span><span id="043e" class="ll lm iq lh b gy lr lo l lp lq">  #select significant values  <br/>  corr &lt;- subset(corr, abs(Freq) &gt; sig) <br/>  #sort by highest correlation<br/>  corr &lt;- corr[order(-abs(corr$Freq)),] </span><span id="37af" class="ll lm iq lh b gy lr lo l lp lq">  #print table<br/>  print(corr)</span><span id="cee6" class="ll lm iq lh b gy lr lo l lp lq">  #turn corr back into matrix in order to plot with corrplot<br/>  mtx_corr &lt;- reshape2::acast(corr, Var1~Var2, value.var="Freq")<br/>  <br/>  #plot correlations visually<br/>  corrplot(mtx_corr, is.corr=FALSE, tl.col="black", na.label=" ")<br/>}</span><span id="a55c" class="ll lm iq lh b gy lr lo l lp lq">corr_simple()</span></pre><p id="ed7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，它将设置数据框以查看表中的原始相关性，因为原始数据可能会有所帮助。数据帧首先按照最高相关性排序。</p><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ma"><img src="../Images/e1a0e4d675e29b30477c3f9350ed2e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a1GDj_DwOvUY9gFNNYxOVg.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">相关表</p></figure><p id="b8b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了减少变量的绝对数量(无需手动挑选)，只选择高于特定显著性水平阈值的变量。初始默认值设置为0.5。</p><p id="26b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成表格后，它将返回以下经过筛选的相关矩阵图。只有显著性水平足够高的相关性才会有彩色圆圈。如果仍然有许多剩余变量，这进一步有助于去除噪声。</p><figure class="lc ld le lf gt lt gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/2975230bb7b0a681dd752052dc6600ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*lOCqw2i558hUZb5qS1yIxA.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">使用corr_simple函数过滤掉有用的相关矩阵</p></figure><h2 id="1bb7" class="ll lm iq bd mf mg mh dn mi mj mk dp ml ko mm mn mo ks mp mq mr kw ms mt mu mv bi translated">结论</h2><p id="a5e4" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">这个“corr_simple”函数可以在一些特征工程之后反复运行，或者具有不同的显著性水平。这确实有助于更快的分析和只查看相关数据。对于更多的变量，可能需要使用不同的显著性水平和/或使用更多的特征工程来减少相关变量的数量，然后重新运行函数，直到结果可读且有用。</p></div></div>    
</body>
</html>