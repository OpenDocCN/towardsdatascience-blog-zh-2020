<html>
<head>
<title>10 Idiomatic Ways to Refactor Your Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构 Python 代码的 10 种惯用方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-idiotic-ways-to-refactor-your-python-code-cbb05bb0c820?source=collection_archive---------6-----------------------#2020-07-03">https://towardsdatascience.com/10-idiotic-ways-to-refactor-your-python-code-cbb05bb0c820?source=collection_archive---------6-----------------------#2020-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c79a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">提高您的 Python 技能</h2><div class=""/><div class=""><h2 id="ebd4" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">让您的 Python 代码更具可读性和性能</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e1585a3d232dd2e33b5c1393817ef98a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X3IfQvbK9gZ2BpEu"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@martinshreder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马丁·施瑞德</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b7b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python 是一种通用编程语言，广泛用于科学计算、人工智能、web 开发、金融建模和许多其他领域。它受欢迎的一个主要原因是它可以灵活地为各种操作提供多种解决方案。然而，在大多数情况下，有一个可能的愚蠢的解决方案是经验丰富的 Python 程序员更喜欢的。在本文中，我想回顾 10 个惯用案例，您可以考虑使用它们来重构您的 Python 代码。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="9f13" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">1.（听力或阅读）理解测试</h2><p id="9ea0" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">Python 中有三种常见的可变容器数据类型，包括列表、字典和集合。如果我们从一个 iterable 开始，我们可以使用 for 循环遍历 iterable，用 for 循环创建一个新的列表。但是惯用的方式是使用列表理解，其语法如下:<code class="fe ni nj nk nl b">[expression for x in iterable if any_condition]</code>。请注意，条件求值部分是可选的。让我们看看下面的代码。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">列表理解</p></figure><p id="85ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了列表理解，我们还可以使用词典和集合理解，它们分别被称为词典理解和集合理解。字典理解的语法如下:<code class="fe ni nj nk nl b">{key_expr: val_expr for item in iterable}</code>，集合理解的语法为:<code class="fe ni nj nk nl b">{expr for item in iterable}</code>。下面的代码向您展示了它们的用法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">字典和集合理解</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="ac72" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">2.f-刺</h2><p id="0d41" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">字符串是一种常见的原始数据类型，我们在几乎所有的项目中都使用它。为了显示字符串数据，在大多数情况下，我们需要进一步以特定的方式格式化字符串。我们可以用 C 风格的方法格式化字符串，包括使用%符号或 Python 字符串的<em class="no"> format </em>方法。</p><p id="e063" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，在 Python 的最新版本中，引入了新的字符串格式化方法。它被称为 f-strings，代表格式化字符串——一种简洁易读的字符串格式化方法。让我们来比较一下这些不同的格式化方法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">f 弦</p></figure><p id="38ec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当然，上面的代码只是向您展示了 string 的最基本的用法，事实上它实现了 C-style 或者 string 的<em class="no"> format </em>方法支持的几乎所有格式样式。你可以在<a class="ae lh" href="https://www.python.org/dev/peps/pep-0498/" rel="noopener ugc nofollow" target="_blank">官方文档</a>或<a class="ae lh" href="https://medium.com/swlh/string-formatting-in-python-6-things-to-know-about-f-strings-72fd38d96172" rel="noopener">我最近的文章</a>中读到更多关于 f 弦的内容。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="8385" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">3.多重赋值和元组解包</h2><p id="cbbc" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">当我们处理变量时，通常的做法是在每一行定义一个变量。然而，当我们声明多个变量时，我们可以在一行中完成。请注意，为了避免混淆，您可能希望声明语义相关的变量。如果他们服务于不同的目的，我不建议这样做。我们来看看下面的重构。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">多重赋值</p></figure><p id="50ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在底层，多重赋值涉及右边元组的创建和左边元组的解包。下面的代码展示了如何解包一个元组。如你所见，这看起来像多重赋值，因为它们使用相同的机制。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">元组解包</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="5c7e" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">4.一揽子拆包</h2><p id="4634" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在上一节中，我们回顾了如何使用最基本的格式解包元组——用相同数量的变量来表示元素中的每个元素。然而，当元组中有多个元素时，有时您可能希望使用 catch-all 方法来解包它。具体来说，变量没有明确表示的所有元素都将被带有星号前缀的变量捕获。为了获得相同的结果，非惯用方法通常涉及切片，如果我们错过了正确的索引，这很容易出错。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一揽子拆包</p></figure><p id="4a1a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可能注意到了，<code class="fe ni nj nk nl b">middle_numbers0</code>和<code class="fe ni nj nk nl b">middle_numbers1</code>的值不相等。这是因为在默认情况下，一揽子解包(使用星号)会生成一个列表对象。因此，为了使最终解包的数据具有相同的数据类型，我们可以使用 tuple 构造函数，如下所示。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">从一揽子解包创建元组</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="917b" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">5.赋值表达式</h2><p id="6d52" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">赋值表达式更好地称为使用海象运算符的海象表达式:=，它看起来像一只有一对眼球和长牙的海象，不是吗？顾名思义，赋值表达式允许你给一个变量赋值，同时，它也可以作为一个表达式使用，比如在 if 语句中。这个定义听起来令人困惑，让我们在下面的代码片段中看看它的用法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">赋值表达式</p></figure><p id="900b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上所示，当我们不使用赋值表达式时，我们必须首先获得账号，并用它来进行取款操作，这就产生了一些代码重复。相比之下，我们可以通过赋值表达式消除一行代码，它调用函数，同时将返回值赋给要计算的新变量。</p><p id="9da3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有些人可能会认为保存一行代码没什么大不了的，但这让我们的意图更加明确，即变量<code class="fe ni nj nk nl b">account_number</code>只在 if 语句的范围内相关。如果您有 SwIft 的编码经验，那么在 if 语句中赋值表达式的用法很像可选的绑定技术，如下所示。基本上，临时变量<code class="fe ni nj nk nl b">accountNumber</code>只有在有效时才会在后续的作用域中使用。因此，您应该熟悉赋值表达式，过一会儿，您会发现代码可读性更好。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">可选绑定</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="3c46" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">6.枚举迭代</h2><p id="a2ef" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">几乎在每个项目中，我们都不可避免地让程序对列表、元组或其他容器数据类型中的所有元素重复特定的操作。这些重复的操作可以通过 for 循环来实现。通常，我们可以使用基本形式:<code class="fe ni nj nk nl b">for item in iterable</code>。但是，对于迭代，如果我们需要跟踪当前迭代循环的计数，最好使用<code class="fe ni nj nk nl b">enumerate</code>函数，它可以为我们创建计数器。此外，我们可以设置启动计数器的次数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">枚举迭代</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="43dc" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">7.用 zip/zip_longest 连接 Iterables</h2><p id="7555" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">假设我们从两个 iterables 开始，我们想要为每一对对应的元素连接这两个 iterables。通常，我们可以通过从每个 iterable 中检索元素来使用索引方法，这样我们就可以将它们连接起来形成一个字典。然而，Python 有内置函数<em class="no"> zip </em>，这正是我们想要实现的。基本上，<em class="no"> zip </em>函数接受多个 iterables，并创建一个长度与 iterables 中最短长度相匹配的 iterable。让我们看看下面的例子。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">对 Iterables 使用 Zip</p></figure><p id="7d06" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="no"> zip </em>函数的作用是创建一个迭代器<em class="no"> zip </em>对象，其中每个元素都是一个元组，由提供的 iterables 中的条目组成。需要注意的一点是，默认情况下，<em class="no"> zip </em>函数会在到达任何 iterable 的末尾时停止。相比之下，<em class="no"> zip_longest </em>函数将使用最长的可重复项。</p><p id="6b36" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面惯用的方法是利用<em class="no"> dict </em>构造函数能够使用 iterable 来创建<em class="no"> dict </em>对象。除了上面的用法，<em class="no"> zip </em>对象可以直接在迭代中使用，如下所示。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">迭代中的压缩</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="9aa0" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">8.串联可重复项</h2><p id="c339" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在上面的例子中，我们使用了<em class="no"> zip </em>函数来按元素连接 iterables。如果我们的特定业务需求是连接可重复项，我们应该怎么做？假设我们需要为同一个操作检查同一个类别的两个可迭代元素。我们可以通过使用<em class="no">链</em>函数来实现这个功能。下面来看看用法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">链式迭代</p></figure><p id="578f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上所示，非惯用方法需要创建额外的列表，这不是最节省内存的。相比之下，<em class="no">链</em>函数从这些最初定义的可迭代对象中创建一个可迭代对象。此外，<em class="no">链</em>函数是灵活的，它可以接受任何类型的可迭代对象，这意味着它可以接受字典、集合、列表、<em class="no"> zip </em>对象、<em class="no"> map </em>对象(使用<em class="no"> map </em>函数)，以及 Python 中许多其他类型的可迭代对象。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="2670" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">9.三元表达式</h2><p id="b0cd" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">如果我们需要给一个变量赋值，不同的值会根据条件被赋值。在这种情况下，我们可以使用 if 语句来评估条件，并确定使用什么值进行赋值。这通常涉及几行代码。但是，我们可以使用三元表达式，只用一行代码就可以完成这项工作，它具有以下通用语法:<code class="fe ni nj nk nl b">var = true_value if condition else false_value</code>。我们来看看它们各自的用法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">三元表达式</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="c552" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">10.发电机的使用</h2><p id="1acc" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">对于那些刚接触 Python 的人来说，生成器的概念可能并不熟悉，因为它在许多其他编程语言中并不是一种常见的技术。这是一个巧妙的技巧，允许您在不需要预先建立数据流的情况下处理数据流。相反，当要求生成器生成下一个值时，它会生成下一个值，这非常节省内存。</p><p id="5f01" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">考虑下面这个微不足道的例子。假设我们需要处理一个文件中的大量数据。理论上，我们可以将整个文件读入一个列表，并处理列表中的每一行数据。然而，当文件非常大时，你的计算机完全有可能耗尽内存。相反，更好、更惯用的解决方案是从文件中生成一个生成器，每次只生成一行数据。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">发电机</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="5058" class="np mm it bd mn nq nr ns mq nt nu nv mt ki nw kj mw kl nx km mz ko ny kp nc nz bi translated">结论</h1><p id="5f37" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在 Python 中，有许多更惯用的方法来做各种事情，本文中涵盖的主题只是我在日常项目中发现有用的技巧的不完整列表。我希望它们也能帮助你编写 Python 代码。最后一个提示是，您必须使用这些和其他习惯用法有目的地重构您的代码，这通常是更具性能的方式。通过不断地重构代码，您将逐渐提高您的 Python 编码技能。</p><p id="414b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读这篇文章和快乐编码。</p></div></div>    
</body>
</html>