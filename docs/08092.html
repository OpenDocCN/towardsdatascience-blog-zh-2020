<html>
<head>
<title>Kubernetes Application Deployment with AWS EKS and ECR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 AWS EKS 和 ECR 部署 Kubernetes 应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kubernetes-application-deployment-with-aws-eks-and-ecr-4600e11b2d3c?source=collection_archive---------1-----------------------#2020-06-15">https://towardsdatascience.com/kubernetes-application-deployment-with-aws-eks-and-ecr-4600e11b2d3c?source=collection_archive---------1-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1eef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 AWS EKS 和 AWS ECR 映像将应用程序部署到 Kubernetes。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29e38ebb9ed3867db261ccc102fba581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhR0GNM_wrfEawQ4HfU2ZQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@clemhlrdt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克莱门特·H</a>在<a class="ae ky" href="/s/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="548c" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">库伯内特斯</h2><p id="2209" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Kubernetes 是 Google 在 2014 年创建的一个容器编排平台。它是一个开源平台，目前许多组织广泛用于容器部署和管理。尽管社区中有其他容器编排工具可用，如 Docker Swarm，但 Kubernetes 仍因其特性和灵活的可用性而保持容器编排的领先地位。</p><h2 id="93f9" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">AWS EKS</h2><p id="952f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">亚马逊弹性 Kubernetes 服务是在 AWS 基础设施上为 Kubernetes 提供的服务。像 AWS 提供的任何其他服务一样，Kubernetes 资源将完全由 AWS 自己管理，这减少了开发人员维护它们的负担。AWS 还确保这些资源每次都高度可用和可靠。</p><h2 id="abbb" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">AWS ECR</h2><p id="ce95" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Amazon Elastic Container Registry 是 AWS 提供的一个完全托管的 Docker 注册表。就像流行的 docker 注册表 Dockerhub 一样，ECR 也支持非常安全的私有和公共存储库。我们可以使用 AWS CLI 将图像推送或拉入 ECR。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/6e6563e8a0cba8a6fe1f7917c36d4098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jusFdv1Hl4l8M1cqKhP3yg.jpeg"/></div></div></figure><p id="b412" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在本文中，我们将探讨如何使用 AWS EKS 和 ECR 服务部署 Kubernetes 应用程序。在深入了解我们将如何实施我们的 Kubernetes 解决方案的复杂细节之前，下面是我们将执行的任务的摘要。</p><ul class=""><li id="8573" class="mu mv it lx b ly mp mb mq li mw lm mx lq my mn mz na nb nc bi translated">使用 Node.js 创建一个简单的 web 应用程序</li><li id="4740" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">创建 web 应用程序的 docker 映像</li><li id="91e5" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">将我们的 docker 图像推送到 AWS ECR</li><li id="ccee" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">为我们的 EKS 集群创建一个包含公共和私有子网的 VPC</li><li id="7bf3" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">创建一个 Kubernetes 集群</li><li id="d886" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">创建 Kubernetes 工人(公共和私人工人)</li><li id="7bf5" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">在 Kubernetes 上部署我们的 web 应用程序</li></ul><p id="9cf7" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">现在我希望你至少对我们将在这篇文章中涉及的内容有一点点概念。在我们开始实现之前，我们需要在我们的开发机器中具备以下先决条件。</p><h2 id="4d4c" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">先决条件</h2><ul class=""><li id="05df" class="mu mv it lx b ly lz mb mc li ni lm nj lq nk mn mz na nb nc bi translated"><strong class="lx iu"> Kubectl </strong> —我们将用来在我们的 Kubernetes 集群和我们的机器之间进行通信的通信工具。安装说明可从<a class="ae ky" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.io/docs/tasks/tools/install-kubectl/</a>获得</li><li id="063a" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated"><strong class="lx iu"> AWS CLI </strong> — AWS 工具，我们将使用它发布与 AWS 配置相关的命令。要安装，请遵循<a class="ae ky" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/CLI/latest/user guide/CLI-chap-configure . html</a></li><li id="1060" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated"><strong class="lx iu"> Aws iam 认证者</strong> —授予 iam 角色访问我们的 Kubernetes 集群的权限。用于安装<a class="ae ky" href="https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/eks/latest/user guide/install-AWS-iam-authenticator . html</a></li><li id="16e5" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">eks CTL—AWS EKS 官方 CLI 工具。对于安装 h<a class="ae ky" href="https://github.com/weaveworks/eksctl" rel="noopener ugc nofollow" target="_blank">ttps://github . com/weave works/eks CTL</a></li></ul><p id="e1e4" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在满足我们的先决条件后，第一个任务将是创建一个简单的服务器。我使用 Node.js 和 express 来创建一个非常简单的 web 应用程序，它将在端口 3000 上进行侦听。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8e43" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">接下来，让我们对我们的 web 应用程序进行 dockerize。创建 docker 文件并发出 docker 构建命令。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="237b" class="kz la it no b gy ns nt l nu nv">docker build -t webapp .</span></pre><p id="cef4" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">现在，如果您发布 docker 图像，我们将看到我们的 webapp 图像。下一个任务是将我们的图像推送到 AWS ECR。</p><h2 id="1d72" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建 ECR 存储库</h2><p id="451e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在推送映像之前，我们需要在 ECR 上创建一个存储库。为此，转到 ECR 仪表板并点击<strong class="lx iu">创建存储库。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/bebf4fbbed6312b0f7270e7af1d7ae3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fW3kf0ZdHFKtx2AXZ07-gg.png"/></div></div></figure><p id="c23f" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">现在，我们有了一个存储库来推送我们的图像。但在此之前，我们需要验证我们的 AWS CLI，以便将图像推送到我们的存储库。对于下面的问题命令。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="a4ae" class="kz la it no b gy ns nt l nu nv">(Get-ECRLoginCommand).Password | docker login --username AWS --password-stdin 628640267234.dkr.ecr.ap-southeast-1.amazonaws.com</span></pre><p id="abc8" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">之后，用我们的库名标记图像。在这里作为版本，你可以给任何版本，但在这种情况下，我将使版本作为最新的。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="599b" class="kz la it no b gy ns nt l nu nv">docker tag webapp:latest 628640267234.dkr.ecr.ap-southeast-1.amazonaws.com/eks-demo:latest</span></pre><p id="1439" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">现在是最后一步，将我们的映像推送到 ECR 存储库。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="bbd3" class="kz la it no b gy ns nt l nu nv">docker push 628640267234.dkr.ecr.ap-southeast-1.amazonaws.com/eks-demo:latest</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/1b410fb4e38523dfd71fe9331cd01ce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qIAfffLuIuMZ6LegM2f3qw.png"/></div></div></figure><p id="c803" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">如果您遇到任何权限问题，请确保您的 AWS CLI 角色拥有权限<a class="ae ky" href="https://console.aws.amazon.com/iam/home?region=ap-southeast-1#/policies/arn%3Aaws%3Aiam%3A%3Aaws%3Apolicy%2FAmazonEC2ContainerRegistryFullAccess" rel="noopener ugc nofollow" target="_blank">amazonec 2 containerregistryfull access</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/838133295b6c61fc9047bc2c5769d79c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMoBIdiHXNv0yqB-BPfIYg.png"/></div></div></figure><p id="18b4" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">现在转到我们的存储库，我们推送的图像应该在那里可用。</p><h2 id="e88b" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">正在创建 AWS EKS 集群</h2><p id="36c8" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">下一步是创建我们的 EKS 集群。创建集群时，我们需要指定集群要使用的 VPC 子网。亚马逊 EKS 需要至少两个可用区域中的子网。创建 VPC 时，我们有两个选择。</p><ul class=""><li id="836d" class="mu mv it lx b ly mp mb mq li mw lm mx lq my mn mz na nb nc bi translated">创建公共和私有子网</li><li id="e78a" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">仅创建公共子网</li></ul><p id="95c6" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在本文中，我们将创建公共子网和私有子网的组合。在这种情况下，可以使用公共子网从外部访问我们的 web 应用程序，此外，如果我们需要部署数据库之类的东西，我们可以将它们设为私有，只有我们的 web 应用程序和 VPC 内的任何其他应用程序可以访问它们。</p><h2 id="44eb" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创造 VPC</h2><p id="e7ef" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">如果需要，可以手动为我们的集群创建 VPC。但是让我们使用 AWS Cloudformation 创建我们的 VPC，因为 AWS 已经有了一个创建公共和私有子网 VPC 的模板。</p><ul class=""><li id="19ab" class="mu mv it lx b ly mp mb mq li mw lm mx lq my mn mz na nb nc bi translated">转到 CloudFormation dashboard 并选择创建堆栈</li><li id="4cdc" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">在这里选择模板源作为亚马逊 S3 网址，并提供以下模板已经由 AWS 创建。</li></ul><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="83c5" class="kz la it no b gy ns nt l nu nv"><a class="ae ky" href="https://amazon-eks.s3.us-west-2.amazonaws.com/cloudformation/2020-06-10/amazon-eks-vpc-private-subnets.yaml" rel="noopener ugc nofollow" target="_blank">https://amazon-eks.s3.us-west-2.amazonaws.com/cloudformation/2020-06-10/amazon-eks-vpc-private-subnets.yaml</a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/ca3cacced81be8cb6e4fef7fe300c9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TcNOuQSSLO4lAv3DfeUfNQ.png"/></div></div></figure><ul class=""><li id="abed" class="mu mv it lx b ly mp mb mq li mw lm mx lq my mn mz na nb nc bi translated">VPC 的 CIDR 地址将是 192.168.0.0/16</li><li id="466b" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">使用 CIDR 地址块 192.168.0.0/18 和 192.168.64.0/18 创建两个公共子网</li><li id="ac9e" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">使用 CIDR 地址块 192.168.128.0/18 和 192.168.192.0/18 创建两个私有子网</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/a6daf1ccea69dfab21f0552c67e0ca5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1VyFczShsQ6ONdRkVdR7KQ.png"/></div></div></figure><p id="6ef6" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">最后，选择 Create 并等待直到栈被创建。在堆栈创建的最后，它将给出 3 个输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/fa9c8c9d4b41a232d939d9a79d89838f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*STEXkTvFSdEo8o_KxnM3dQ.png"/></div></div></figure><ul class=""><li id="b36c" class="mu mv it lx b ly mp mb mq li mw lm mx lq my mn mz na nb nc bi translated">SecurityGroups —这是为我们的 VPC 创建的安全组。</li><li id="ae38" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">SubnetIds —我们创建的 4 个子网的 id。A</li><li id="0056" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">VpcId —创建的 VPC 的 Id。</li></ul><h2 id="b4ab" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用工人创建 EKS 集群</h2><p id="c45e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们可以通过给出<strong class="lx iu"> eksctl create </strong> cluster 命令来轻松创建集群。但是让我们用下面的附加配置创建一个 YAML 文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2cd4" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在上面的 cluster.yaml 文件中，我们为集群定义了以下配置。</p><ul class=""><li id="eb66" class="mu mv it lx b ly mp mb mq li mw lm mx lq my mn mz na nb nc bi translated">集群名称将为<strong class="lx iu"> EKS 演示集群</strong></li><li id="4e62" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">在 vpc 部分，我们提供了之前已经创建的 VPC</li><li id="36e4" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">在节点组中，我们使用 t2.meduim 实例创建 3 个 workers。三个工人中有两个将被创建为公共工人，而一个将被创建为私有工人。</li></ul><p id="5f7f" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">现在发出下面的命令，在 EKS 上创建我们的集群。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="06e8" class="kz la it no b gy ns nt l nu nv">eksctl create cluster -f cluster.yaml <strong class="no iu">--kubeconfig</strong>=C:\Users\{user}\.kube\config</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/c62c42048fb0c07ccd3ce5414ef29084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bbvEkUkFV-JOIEOoG_voKg.png"/></div></div></figure><p id="3fd4" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">之后，eksctl 将根据我们的 YAML 文件开始创建我们的集群。创建群集和节点将需要几分钟时间。在 get issue 下面的命令检查我们的集群是否已经部署。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="6b75" class="kz la it no b gy ns nt l nu nv">kubectl get svc</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/308f9d0acd705db8e48ff7e3f993947d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*eP_hFBeY5W5JXgdoRQFWSQ.png"/></div></figure><p id="24ee" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">当您发出 kubectl 命令时，有时可能会得到以下错误。这可能意味着在我们的 kubectl 配置文件中，没有定义访问集群所需的凭证和用户。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="8081" class="kz la it no b gy ns nt l nu nv">error: no configuration has been provided, try setting KUBERNETES_MASTER environment variable</span></pre><p id="4e12" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">要将这些配置详细信息写入配置文件，请发出以下命令。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="17de" class="kz la it no b gy ns nt l nu nv">aws eks --region {region} update-kubeconfig --name EKS-Demo-Cluster</span></pre><h2 id="74db" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建部署清单</h2><p id="7a9c" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">现在让我们开始在创建的 Kubernetes 集群上部署我们的应用程序。首先，要在 pods 上部署我们的应用程序，我们需要创建一个部署。下面是将用于部署的部署清单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ul class=""><li id="ee2e" class="mu mv it lx b ly mp mb mq li mw lm mx lq my mn mz na nb nc bi translated">我们的应用标签将是<strong class="lx iu"> app:web </strong></li><li id="0848" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">在规格:模板:规格:容器中为我们推送的 AWS ECR 图像设置图像</li><li id="3589" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">应用程序的副本数量为 2</li></ul><p id="4b8a" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">发出以下命令来创建我们的部署。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="2005" class="kz la it no b gy ns nt l nu nv">kubectl apply -f deployment.yaml</span></pre><p id="1041" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">要检查我们的部署是否已创建，请发出以下命令。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="015c" class="kz la it no b gy ns nt l nu nv">kubectl get deployments</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/11e00a812ac713bdcd2e287174155ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*MgBqyD-O_MeUzfEfeitHZw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/119c83ef2c8ed036a4bfa250b4fa3120.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*p8t5K4NRu3dnRqN-E5YrHw.png"/></div></figure><p id="2822" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">现在，我们可以看到我们的部署已经创建并运行在两个 pod 上。</p><h2 id="9f03" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建服务清单</h2><p id="27e3" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">现在要访问我们的应用程序，我们需要创建一个服务。我们的服务类型将是<strong class="lx iu">节点端口</strong>，因为我们需要我们的应用程序从外部访问。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ul class=""><li id="08c0" class="mu mv it lx b ly mp mb mq li mw lm mx lq my mn mz na nb nc bi translated">服务类型为<strong class="lx iu">节点端口</strong></li><li id="4f74" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">targetPort 是<strong class="lx iu"> 3000 </strong>，因为这是我们的集装箱暴露端口</li><li id="35e5" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">选择器将是<strong class="lx iu"> app:web </strong>，因为这是我们在部署中定义的标签</li></ul><p id="5287" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">根据命令创建我们的服务问题</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="8481" class="kz la it no b gy ns nt l nu nv">kubectl apply -f service.yaml</span></pre><p id="a8f6" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">要检查我们的服务是否已创建，请发出以下命令。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="c05f" class="kz la it no b gy ns nt l nu nv">kubectl get services</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/1538e28d9d16c3c6e9b9b997c6017f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sic7G_4mZZnWnQT7rR2ZqA.png"/></div></div></figure><p id="de51" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">现在让我们尝试从外部访问我们的 web 应用程序。从服务中，我们知道我们的应用程序正在侦听端口 31479。接下来，我们需要获取应用程序节点的公共 IP 地址。让我们首先尝试确定我们的应用程序在哪里运行。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="d16b" class="kz la it no b gy ns nt l nu nv">kubectl get pods -o wide</span></pre><p id="268f" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">由此，我们可以识别我们的应用程序正在运行的 pod 的节点。要获取这些节点的外部 IP 地址，请发出 get nodes 命令。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/227d7a5d5df8d01587f61264afa80464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bpd8rMM-QNIjQtAyECgjnQ.png"/></div></div></figure><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="143e" class="kz la it no b gy ns nt l nu nv">kubectl get nodes -o wide</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/39edf78e1564b4d5c728e4e6e381928e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MT-FpNfNPdn8YBPKR1M_Gw.png"/></div></div></figure><p id="67c5" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在上面的节点列表中，我们可以看到两个节点有外部 IP，而一个没有，因为我们将其配置为私有工作节点。现在我们有了我们的 IP 地址以及它正在监听的端口。下一个任务是将此端口添加到节点的安全组中，以允许流量进入。并添加入站规则以允许端口 31479 中流量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/ff0034be82cef6494c7461efbfc64e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yMqoV7gFB2M7h4ddUqIGKA.png"/></div></div></figure><p id="21e6" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">之后，我们可以获得一个公共节点 IP 地址，并使用端口 31479 调用它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/ca081afabfa9de7a4bbe9723ea525d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iiOkcy4b5rvcCARplhyRAQ.png"/></div></div></figure><p id="8113" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">我们也可以对其他 IP 地址做同样的事情，结果应该是一样的。</p><p id="4e16" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">下一个任务是将数据库部署到我们的 Kubernetes 集群中。但是我会把这个任务留给你去尝试。之后，确保通过发出以下命令删除集群，以避免对我们创建的 EC2 实例收费。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="d557" class="kz la it no b gy ns nt l nu nv">eksctl delete cluster --region=ap-southeast-1 --name=EKS-Demo-Cluster</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/d2b002ade15ddc7a22ede5ed14a5fb40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R7PaCeImjQVdgbQzyzlcIg.png"/></div></div></figure><p id="febc" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">这就是如何使用 AWS EKS 和 ECR 创建和部署应用程序到 Kubernetes。在 Kubernetes 和 EKS 上还有很多其他的概念值得我们学习。因此，一定要不断学习，直到你有信心部署和管理应用程序。谢谢你。</p></div></div>    
</body>
</html>