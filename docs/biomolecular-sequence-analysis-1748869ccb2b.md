# 生物分子序列分析

> 原文：<https://towardsdatascience.com/biomolecular-sequence-analysis-1748869ccb2b?source=collection_archive---------67----------------------->

## 第一部分:序列相似性搜索

![](img/4e74dc2a6babeba342e9e189e5a6586e.png)

[亚历山大·波波夫](https://unsplash.com/@5tep5?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/dna?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍照

在某种程度上，生物分子序列“只是”固定字母表上的字符串。这可能会吸引计算机科学家，即使他们发现分子生物学神秘而有趣，但他们绝对理解字符串和字母！

在 DNA 和 RNA 中，这个字母是 A、C、T 和 g。在蛋白质序列中，这个字母是组成蛋白质的 20 个氨基酸。当然，在序列内部和序列之间发生了很多事情。这是分子生物学家和生物技术人员的领域。

在这篇文章中，我们将讨论所有生物分子序列分析中最有用的计算算法和工具:在已知序列的数据库中搜索一个新序列，以找到相似的序列。

**为什么序列相似性搜索很重要**

考虑一个已知蛋白质序列的数据库，注释了关于它们的已知信息，例如它们的功能和它们的进化谱系。考虑一个新确定的序列。搜索数据库来寻找与这个新序列高度相似的序列可能会很有启发性。这可能有助于阐明这个序列在进化等级中的位置。它也可能产生对这个序列的功能作用的见解。

以新冠肺炎序列为例。谁知道在已知病毒序列的数据库中搜索会发现什么。

**变异游戏**

这将极大地有助于理解接下来的相似性搜索问题。相信我。

我们会挑选 DNA 序列。只是因为他们的字母表更容易描述。这个游戏的经验同样适用于蛋白质序列。

游戏的整体结构是:

1.  我们从一组不同的序列开始。
2.  我们将这些收集到一个数据库中，我们称之为“已知序列”。
3.  我们以特定的方式突变其中的一些序列(我们将在后面讨论细节)。
4.  这些产生了我们所认为的“新确定的”序列。
5.  我们使用相似性搜索算法和工具在数据库中搜索这些“新确定的”序列。
6.  如果一切顺利，在每种情况下，我们都希望找到产生突变序列的序列。(正如我们很快就会看到的那样，事情不会总是一帆风顺。)

**变异模式**

我们将重点介绍三种类型的变异操作:*在某个位置插入*一个新符号，*删除*某个位置的符号，*用另一个符号替换*某个位置的符号。第三个是通过一个*替代矩阵*来完成的，该矩阵捕获替换偏好。我们把这三个操作分别叫做 I，D，S。

我们假设 I 和 D 中的每一个都有一个固定的概率，这个概率不依赖于突变在序列中的位置。(这个假设可以放宽。在一些特殊的用例中，这非常有帮助。然而，它有训练数据和算法结果。)替换也将用概率来建模。

让我们看一个例子。(我们将概率表示为百分比。)说 P(I) = 5%，P(D) = 8%。这意味着在任何位置都有 5%的机会插入字符，8%的机会删除字符。我们假设插入的字符是随机选择的。(更高级的模型允许在要插入的字符上的分布取决于位置。在某些用例中，这非常有帮助。然而，这也使建模变得复杂。)

假设我们的替代矩阵是

```
 A   C  T  G
A **90%** 2% 4% 4%
C 7% **80%** 5% 8%
T 3% 5% **85%** 7%
G 6% 2% 3% **89%**
```

首先，我们来带出它的特点。每行总和为 100%。这是因为包括了自身替换。所以，在每一个位置，一定会发生一些替换。第二，对角线项接近 100%。这表明自我替换比改变符号的可能性要大得多。最后，注意我们的替换矩阵是不对称的。对称在这个阶段是额外的不必要的假设。

**突变单个序列**

让我们来做一个突变单个序列的心理模拟。我们将获得一个输入序列，并从左端开始，在每个位置上概率性地应用三个变异操作。我们将展示有变化的所有中间序列。

我们的首发顺序很傻；尽管如此，它将完成我们为它设定的任务。

```
AAAAAAAAAA → AA**T**AAAAAAAA → AA**T**AA**G**AAAAA → AA**T**AA**G**AAAA
                                                 ^
```

第一个突变是紧接在位置 2 之后的 T 的插入。第二个是替换 A → G，我们用粗体标出了这两个。第三个是删除序列中倒数第二个字符。我们用^.标记了这一删除

最后，我们可以通过简单地多次重复这一过程来模拟更长期的进化。也就是说，我们对序列进行多次突变。毫不奇怪，我们通过的次数越多，最终的突变序列与我们开始时的序列差异就越大。由此产生的突变序列被称为(起始序列的)远源同源物。

**突变多个序列**

既然我们已经详细了解了突变单个序列所涉及的内容，让我们继续来突变几个。这当然是现实中发生的事情。对我们的目的同样重要的是，它将帮助我们更好地理解为什么序列相似性算法如此复杂。简而言之，我们突变的序列越多，就越难辨别突变序列是从哪个序列进化而来的。

为了阐明上一句的观点，我们将从一个比第一个更愚蠢的例子开始。

```
AAA → A**C**AA → ACA
ACC → A**A**C
TTT → **C**TT
```

AAA、ACC 和 TTT 这三个序列中的每一个都发生了突变。注意，第一个序列经历了两个突变。

现在让我们将已知序列的数据库设置为我们开始时的数据库:`{AAA, ACC, TTT}`。可以考虑用 ACA 搜索一下。有理由期待会发现两个结果:AAA 和 ACC，因为它们都与 ACA 足够相似。接下来，考虑在数据库中搜索 CTT。在这种情况下，只有一个结果将被发现，TTT，在同一水平的相似性。

我们试图用这种比较来说明什么？

```
*The statistical significance of a search result depends on the number of search results on the same query that get found*. 
```

结果 ACA → AAA 不像结果 CTT → TTT 那样具有统计显著性，因为对于查询 ACA 有两个足够相似的结果，而对于查询 CTT 只有一个。这也有直观意义吧？我们对 CTT → TTT 的结果更有信心，因为它是独一无二的。在 ACA → AAA 中不那么明显，因为它不是。

如果我们把这个例子扩大到现实，直觉会变得更有说服力。当在足够高的相似性阈值下搜索数百万个序列的数据库时，一个查询可能返回唯一的结果，第二个查询可能返回数千个结果。显然，第一个查询的结果比第二个查询的结果更重要。

**编辑距离**

至此，我们已经不严格地使用了术语“相似”和“相似性阈值”。现在让我们将它们形式化。这将有助于我们更具体地理解上述问题。它也是通向更高级的相似性度量的桥梁，我们将在讨论具体的相似性算法时看到。

两个序列的编辑距离是将一个序列转变成另一个序列所需的最小突变数。考虑(AAA，ACA)。它们的编辑距离是 1，因为我们可以通过一次替换将一个转换为另一个。

编辑距离是量化两个序列之间相似性的一个很好的近似度量。我们说“近似”有以下几个原因。首先，可能发生了比编辑距离所暗示的更多的突变。拿我们的例子 AAA → … → ACA。这涉及到两个突变。编辑距离建议一个。第二，编辑距离不能捕捉特定突变的不同概率:插入、缺失和特定替换。

好的，让我们用编辑距离的语言重新表达一下我们之前看到的例子。我们的数据库是`{AAA, ACC, TTT}`。根据它搜索 ACA 会在编辑距离 1 处找到两个结果。搜索 CTT 在编辑距离 1 处找到一个结果。

所有三个结果到查询的编辑距离相同。然而，如前所述，第三个结果比前两个结果更具统计学意义。也就是说，它更值得信任。

显然，编辑距离无法衡量统计意义。我们需要一个独立的机制。我们就不详细讨论了。它体现了我们已经讨论过的原则:*一个查询返回的结果越多，应该分配给其中任何一个的信任就越少*。

在所谓的“局部比对”搜索的设置中，结果的统计显著性从“非常重要”到“极其重要”。到目前为止，我们还没有讨论“局部比对搜索”。所以读者可能不知道我们的意思。然而，我们认为在现阶段提出这一点是重要的。

**序列相似性算法**

我们已经看到了各种变异算子。现在让我们描述考虑到这些的序列相似性算法。

**全局对齐**

首先，我们需要另一个关键概念。两个序列(相同类型:DNA 或蛋白质)的*全局比对*是它们的符号之间的 1-1 对应，遵循序列顺序。让我们看一个例子。

```
A-CAT     ACAT
| | |     ||||
AAC-T     AACT
```

我们看到 ACAT 和 AACT 两个序列的两个全局比对。左侧对齐中的“-”符号表示“‘无’与符号对齐”。这些实现了移动一个或另一个序列的效果，使得对准的符号是兼容的。第二次对齐不使用任何“-”符号。

凭直觉，读者可能会猜测左边的排列比右边的好。读者可能是对的。这个会在下面出来。

**全球比对分数**

接下来，我们描述全局比对分数的概念。最常用的形式，实际上也是我们将描述的算法所使用的形式，简单地将比对中各种比对对的分数相加。

这里有一个例子。考虑左边的对齐方式，可能表示为{(A，A)，(-，A)，(C，C)，(A，-)，(T，T)。该比对的分数可以描述为

```
S({(A,A),(-,A),(C,C),(A,-),(T,T)}) = **S(A,A)** + *S(-,A)* + **S(C,C)** + *S(A,-)* + **S(T,T)**
```

粗体的术语对应于我们之前在突变游戏中看到的替换。斜体术语对应于插入和删除突变。

关键的一点是，尽管序列相似性算法至少部分是由突变博弈的考虑所驱动的，但在实践中，当比较两个序列时，我们经常不知道哪个扮演祖先的角色，哪个扮演后代的角色。

事实上，在许多用例中，甚至可能不存在这样的关系。想象一下，试图辨别两个序列是否是不太远的祖先的兄弟。高度的序列相似性可能对此有所帮助。很明显，没有祖孙关系，只有兄弟姐妹关系。

鉴于以上所述，相似性算法对称地对待两个序列是有意义的。其结果是对齐中出现的'-'不再能被解析为插入或删除。考虑对齐对(X=A-，Y=AA)。如果我们认为 Y 是祖先，那么'-'可以被视为删除，如果我们认为 X 是祖先，那么'-'可以被视为插入。由于这个原因，从现在起我们称 a 为'-' an *indel* 。事实上，我们将更进一步。我们将使用术语 *gap* 来表示 *indel* ，因为它听起来更好。

其进一步的结果是，将间隙与实际字符对齐的成本是相同的，而不管间隙是在顶部还是在底部。

接下来，让我们根据上一段中提到的要点来改进我们的分数示例。 *S* (A，A)*S*(C，C)*S*(T，T)都是来自一个 DNA 置换矩阵的分数。 *S* (-，A)和 *S* (A，-)都由一个负数表示，称为*缺口*成本。这个数字是负数，因为它是成本。

现在让我们详细阐述一下 DNA 置换矩阵。这在性质上类似于我们之前看到的 DNA 替换矩阵，在突变游戏中。性质相似但不相同。

如果你想知道为什么两个替换矩阵会不同，请阅读下一段，否则跳过它(它有点长，而且有点偏离我们在这篇文章中的主要路径)。

由于前面讨论的原因，相似性算法对称地处理两个序列。这意味着我们的替换矩阵也需要对称。相比之下，进化替代矩阵不必如此。第二个原因是我们正在对单个比对对的分数求和。在我们的例子中，限于涉及替换的术语，这是 *S* (A，A) + *S* (C，C) + *S* (T，T)。如果替换矩阵条目是概率(就像在突变游戏中那样)，我们将会进行乘法运算。实际上还有更多。我们就陈述一下，不做解释。符号的对齐对(X，Y)的得分 *S* (X，Y)被定义为 log [ *P* (X，Y)/[*P*(X)*P*(Y)]，其中 *P* (X，Y)是在真实的全局对齐中看到对齐对(X，Y)的概率，而 *P* (X)和 *P 【T*

好吧，回到主路。出于说明的目的，甚至下面的替换矩阵就足够了:

```
S(X,Y) = 1 if X equals Y and -1 if not. 
```

给定这个替代矩阵，我们想要选择一个绝对值小于 1 的缺口成本。我们把它设置成。

好了，现在我们已经准备好计算我们两个全球比对的精确分数了:

```
S({(A,A),(-,A),(C,C),(A,-),(T,T)}) = 
S(A,A) + *S(-,A)* + S(C,C) + *S(A,-)* + S(T,T) **=** 1–½ +1–½ +1 = **2**S({(A,A),(C,A),(A,C),(T,T)}) = 
S(A,A) + S(C,A) + S(A,C) + S(T,T) = 1–1–1+1 = **0**
```

第一次比对得分较高，如您所愿！

**找到高分比对**

我们现在知道如何进行全球比对。接下来，我们将介绍如何在众多比对中找到得分最高的比对。这是更多奇迹发生的地方。

给我们两个 DNA 序列 X 和 Y，置换矩阵 M，以及缺口成本 C < 0\. Our aim is to find the highest-scoring alignment of X and Y.

The exhaustive search approach of generating every alignment, scoring each, and picking the one that scores the highest is excessively slow on long sequences. There are too many alignments to wade through!

Fortunately, there is a clever algorithm that is guaranteed to find an optimal alignment much faster. It uses an approach called dynamic programming.

The algorithm involves building a matrix S with *n* +1 行和 *m* +1 列其中 *n* 和 *m* 分别是 X 和 Y 的长度。

接下来，关键点来了。花时间去吸收它。不到一分钟，我保证。

```
*S*(i,j) is the score of a best alignment of the first *i* symbols in X with the first *j* symbols in Y.
```

为什么这很重要？该算法的关键思想是以最优方式解决问题的较小版本，并从这些版本中为较大版本构建最优版本。具体来说，我们从左上角开始填充矩阵，最终在到达右下角时停止。(我们将很快介绍完整的端到端示例。)

我们首先将 *S* (0，0)设置为 0。这是有道理的。没有要对齐的内容，因此它的得分为“nothing”，其数值转换为 0。(注意“没什么”不等于“不知道”。)

接下来，我们为所有的*I*0 设置 *S* ( *i* ，0)到 *i* *C，为所有的 *j* > 0 设置 *S* (0， *j* )到 *j* *C。为什么？考虑 *S* ( *i* ，0)。它是 X[1]的最佳比对的分数.. *i* 带有空前缀 y .这样的对齐只有一个，其中 X[1.. *i* 与 *i* 间隙对齐。这次对齐的分数是 *i* *C，同理，我们可以看出为什么 *S* (0， *j* )被设置为 *j* * *C* 。

下一个关键点现在来了。如何从 S 矩阵中到那时的分数计算出 *S* ( *i* ， *j* )。这是公式

```
S(i,j) = max{ S(i-1,j-1) + M(Xi,Yj), S(i,j-1) + C, S(i-1,j) + C}
```

max 中的第一项对应于扩展 X[1.. *i* -1】和 Y[1.. *j* -1】添加对齐的对(X[ *i* ，Y[ *j* )。得到的比对分数为 *S* ( *i* -1， *j* -1) + M(X *i* ，Y *j* )。

max 中的第二项对应于扩展 X[1.. *i* 和 Y【1.. *j* -1】通过添加对齐的对(-，Y[ *j* ])。X 部分是一个间隙，因为正在延伸的路线中已经有 X[*I*]。

第三任期为第二任期，其中 *i* 和 *j* 互换。

S(i，j)被设置为“最佳中的最佳”，即这些项中的最大值。

到目前为止提出的算法仅找到最优全局比对的*分数*，而不是比对本身。在我们讨论后一个话题之前，让我们先来看一个端到端的例子，因为即使在评分部分也有很多东西需要学习。

**示例**

如果 *x* 等于 *y* ，我们将使用替换矩阵 *S* ( *x* ， *y* ) = 1，否则为-1。我们会用差距成本。我们将计算 X = ACA 和 Y = AAC 的全局比对分数。(即使在这个简单的例子中，得到的分数矩阵也会惊人的丰富！)

```
 **A      A      C**
      0     -½    -1    -3/2
**A**    -½     1      ½      0
**C**    -1     ½      0     3/2
**A**   -3/2    0     3/2     1
```

在解释这个矩阵中的各种值之前，让我们检查一下最后的分数，即右下角的“1”是否正确。对于我们的替代矩阵和缺口成本，ACA 和 AAC 的最佳比对是

```
ACA-
| |
A-AC
```

这次比对的分数确实是 1。

现在让我们讨论一下这个矩阵中的一些不同的分数。第一行和第一列中的分数对应于将连续的缺口串与另一序列的前缀进行比对。我们之前已经看到过，这是一个初始化步骤。

接下来我们来看看分数 *S* (1，1)。这表示 A 与 A 的最佳比对分数。它应该是 1。它的值来自于项 *S* (0，0) + M(A，A) = 0 + 1 = 1。很容易检查到来自其他项的分数，即涉及 *S* (0，1)和 *S* (1，0)的分数较低。

接下来我们来看看分数 *S* (3，2)。这代表 ACA 与 AA 的最佳比对分数。我们可以看到这种排列必须是(ACA，A-A)的形式。它的分数是 2 –= 3/2，这正是我们所看到的。

**从得分矩阵重建最佳比对**

在许多用例中，例如数据库相似性搜索，对两个序列进行相似性评分就足够了。可以单独使用查询结果相似性得分来对相似性数据库搜索的结果进行排名。

在其他用例中，我们还需要找到实际的最佳匹配。我们现在涵盖这一点。

关键思想是这样的:当我们构建评分矩阵时，我们记录在计算单元格的值时使用了哪个术语。也就是在计算 *S* ( *i* 、 *j* )、 *S* ( *i* -1、 *j* -1)、 *S* ( *i* 、 *j* -1)、或 *S* ( *i* -1、 *j 【T(如果使用了多个，如果我们想要找到所有的最优全局比对，我们应该记录所有的，或者如果我们只寻找一个，则任意地打破联系。)*

让我们看看添加了额外元数据的示例版本。计算 *S* ( *i* ， *j* )，D 表示使用了 *S* ( *i* -1， *j* -1)，L 表示使用了 S( *i* ， *j* -1)，U 表示 *S* ( *i* -1)d、L、U 分别对应对角线、左、上。

```
 **A         A        C**
     0       -½       -1       -3/2
**A**    -½      1 (**D**)    ½ (**D,L**)   0 (**L**)
**C**    -1      ½ (**U**)    0 (**L,U**)   3/2 (**D**)
**A**   -3/2     0       3/2 (**D**)    1 (**L,U**)
```

下面解释一下 *S* (2，3) = 3/2 附带的元数据。这个元数据是 d，我们看到 X[2]和 Y[3]都等于 C，因此我们可以看到 *S* (2，3) = *S* (1，2) + M(C，C)。

**回溯阶段**:一旦构建了完整的得分矩阵(包括元数据)，通过反向“回溯”来重建实际的最优比对。这可以被视为仅仅跟随从矩阵的右下角单元开始的反向指针。

让我们在例子中说明这一点。我们从细胞(3，3)开始。这里附上的元数据是(L，U)。让我们任意选择:l。所以我们向左移动，在单元格(3，2)处结束。在单元格(3，2)中，我们有一个 d，所以我们对角移动到单元格(2，1)。在单元格(2，1)中，我们有一个 u，所以我们向上移动到单元格(1，1)。在单元格(1，1)中，我们有一个 D，所以我们对角移动到单元格(0，0)。

我们从终点出发，到达起点。所以我们结束了。(尽管如此，我们仍然需要填充一些细节——事实上，实际的对齐。)让我们按照采取行动的顺序来看看我们采取的行动。

```
(3,3) → L → (3,2) → D → (2,1) → U → (1,1) → D → (0,0)
```

太好了。但是对齐在哪里呢？这是我们接下来要讨论的。首先让我们再看一遍 2D 排列中的序列，这样我们就可以随着解释的展开来想象它们。

```
X\Y AAC
A
C
A
```

我们刚刚看到的脚手架上将会分层排列。我们的第一步是从单元格(3，3)中取出 L。想象它离开 Y[3] = C，停留在 X[3]。接下来，将此视为创建对齐对(-，C)，即 X 中的一个缺口与 Y 对齐[3]。

我们的下一步是从单元格(3，2)中取出 D。想象这个移动离开 X[3]和 Y[2]。把这想象成创建对齐的对(X[3]，Y[2]) = (A，A)。

我们的下一步是从单元格(2，1)中取出 U。这是一种进步。它创建了对齐的对(C，-)。我们的最后一步是从单元格(1，1)开始的 D。它创建了对齐的对(A，A)。

好的，让我们看看所有这些附加到我们的脚手架上。

```
(3,3) → **L** → (3,2) → **D** → (2,1) → **U** → (1,1) → **D** → (0,0)
X       **—**           **A**           **C**           **A**
Y       **C**           **A**           **—**           **A**
```

这是反向排列。逆转它给

```
ACA-
| |
A-AC
```

我们可以看到这是一个最佳的排列。

**局部对准**

通常我们感兴趣的是局部比对两个序列，而不是全局比对。在局部比对中，一个序列的连续切片与另一个序列的连续切片进行比对。这既包括*找到*相似的切片，也包括*将它们对齐*。

下面是一个局部对齐的例子。这一个在排列中没有任何间隙。

```
 ACACT**TAACTTAACGAT**SACA
         ||||||||||||
GTCATCAGT**TAACTTAACAAT**GAGA
```

局部比对的一个常见用例涉及识别蛋白质序列中的保守区域。这种区域称为结构域，可以独立于蛋白质的其他部分进化和发挥功能。大多数蛋白质都有多个结构域。这些结构域决定了蛋白质的功能。因此，识别蛋白质序列中的结构域是非常有用的。典型地，这是通过对照具有已知结构域的蛋白质序列的数据库，对其结构域未被表征的蛋白质序列进行局部比对搜索来完成的。或者对照结构域序列数据库。

这是第二个涉及局部对齐的场景。我们有一个基因序列。我们感兴趣的是找到所有含有与其高度相似的基因的基因组。这包括以该基因的序列作为查询进行局部比对搜索，并以合适的全基因组序列数据库作为目标。

**两个序列的最佳局部比对**

先前描述的全局对齐算法可以被调整以找到最佳的局部对齐。

关键的变化包括用以下公式替换计算单元格得分的全局对齐公式

```
S(i,j) = max{ S(i-1,j-1) + M(Xi,Yj), S(i,j-1) + C, S(i-1,j) + C, **0** }
```

唯一不同的是加粗的 0。我们如何看待这一点？如果前三项都是负的，则该算法停止扩展先前的比对，而是从(X[i]，Y[j])开始新的局部比对。此选项在全局对齐中不可用，只能进行扩展。全局对齐必须从单元格(0，0)开始。相比之下，局部对齐可以从任何单元格开始。

出于同样的原因，初始化步骤也被修改如下:

```
S(i,0) = 0 for all i; S(0,j) = 0 for all j
```

第二个变化涉及从哪里开始重建最佳局部比对。在全局对齐的情况下，是从 *S* ( *m* ， *n* )其中 *m* 和 *n* 分别是 X 和 Y 的长度。在局部对齐的情况下，对齐可以在任何地方结束。因此，代表最佳局部比对末端的单元是包含评分矩阵中最大值的单元。追溯阶段从该单元开始。然后，它完全像全局对准器那样重建最优对准，除了它在其重建期间遇到的值为 0 的第一个单元处停止。

**局部比对搜索:BLAST**

局部和全局对齐算法都是计算密集型的。使用它们将查询与数据库中的每个序列进行比较可能会非常慢。

一种称为 BLAST(基本局部比对搜索工具)的工具放弃了寻找最佳比对的目标，而是通过一种更快的算法来寻找“足够好”的比对。BLAST 是所有生物分子序列分析中使用最广泛的软件。

下面是 BLAST 的工作原理。

首先，它识别查询序列中的 *k* -grams。(一个 *k* -gram 只是一个序列中长度为 *k* 的连续片段)。对于 DNA 序列来说， *k* 的默认值比蛋白质序列大得多。

接下来，它将新的*k*-克添加到这个列表中。这个步骤是特别为蛋白质序列而做的。它包括找到 k 个对于适当选择的替换矩阵来说分数足够高的图。不允许有缺口，所以这只是简单的计分。无评分矩阵；没有追溯。足够相似的 k 图对的构造可以离线完成。这加快了寻找与查询中相似的字母的过程。

接下来，BLAST 在数据库中查找所有包含这个列表中至少一个 *k* -gram 的序列。(计算机科学家，这类似于在搜索引擎中使用单词的倒排索引来查找候选文档。)

接下来，它考虑每个这样的事件，称为*命中*，并试图在两个方向上扩展它。将此过程视为旨在找到锚定在该命中点的最佳局部比对。

接下来，它计算比对的统计显著性分数。虽然细节很复杂，但高层次的目标是我们在本文前面讨论过的。这是为了考虑局部对齐偶然出现的可能性有多大。这个(机会)可能性低的时候分数就高。

最后，局部比对根据它们的统计显著性分数按顺序输出。

**示例**

我们的目的是用最简单的方式来说明 BLAST 算法。这个例子完全不现实。例如，它选择的 k 太小，在实践中不能很好地工作。

假设我们的查询序列是 ACATGA。假设我们选择 *k* = 3。该序列中的*k*-克为

```
ACA, CAT, ATG, TGA
```

下一步，添加更多类似于这些的*k*-gram，为了说明，想象一下，选择的替换矩阵认为替换 C ⇔ G 和⇔ T 是兼容的，其余的不兼容。假设选择分数阈值，使得最多允许这些替换中的一个，这将导致向上面的列表添加以下 k-gram

```
ACA → AGA, TCA, ACT, CAT → GAT, CTT, CAA, ATG → TTG, **AAG**, ATC
TGA → AGA, TCA, TGT
```

有一些重复的。还是，咻！

接下来，我们在数据库中搜索至少包含上面列表中一个 *k* -gram 的序列。假设我们发现的一个序列是 TTAC **AAG** ACC。这里，粗体区域标记了我们的 k 图列表中的一个热门图。接下来，我们将查询定位到这个命中的序列，如下所示。

```
 ACATGA
    |||
TTAC**AAG**ACC
```

接下来，只要分数保持增加，我们就尝试在两个方向上延伸对齐。在我们的例子中，这种对齐将覆盖整个查询序列。

**关键环节**

[](https://blast.ncbi.nlm.nih.gov/Blast.cgi) [## 基本局部对齐搜索工具

### 基本局部比对搜索工具(BLAST)寻找序列之间的局部相似区域。该程序比较…

blast.ncbi.nlm.nih.gov](https://blast.ncbi.nlm.nih.gov/Blast.cgi) 

**局部比对动态规划算法**[https://en . Wikipedia . org/wiki/Smith % E2 % 80% 93 waterman _ Algorithm #:~:text = The % 20 Smith % E2 % 80% 93 waterman % 20 Algorithm % 20 performs，acid % 20 sequences % 20 or % 20 protein % 20 sequences。&text = Like % 20 the % 20 needleman % E2 % 80% 93Wunsch % 20 算法，就是% 20a % 20 dynamic % 20 programming % 20 算法](https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm#:~:text=The%20Smith%E2%80%93Waterman%20algorithm%20performs,acid%20sequences%20or%20protein%20sequences.&text=Like%20the%20Needleman%E2%80%93Wunsch%20algorithm,is%20a%20dynamic%20programming%20algorithm.)。