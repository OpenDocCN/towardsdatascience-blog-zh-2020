<html>
<head>
<title>Intersection over union (IoU) calculation for evaluating an image segmentation model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于评估图像分割模型的交集(IoU)计算</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intersection-over-union-iou-calculation-for-evaluating-an-image-segmentation-model-8b22e2e84686?source=collection_archive---------6-----------------------#2020-07-24">https://towardsdatascience.com/intersection-over-union-iou-calculation-for-evaluating-an-image-segmentation-model-8b22e2e84686?source=collection_archive---------6-----------------------#2020-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="35b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个计算 IoU 度量的实际例子，它允许我们评估一个预测的边界框与地面真实框有多相似</h2></div><p id="9ba9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最简单的情况下，分割是将数字图像分成几个片段的过程。使用<a class="ae le" href="https://github.com/matterport/Mask_RCNN" rel="noopener ugc nofollow" target="_blank">遮罩 R-CNN </a>进行实例分割的结果是应用于所需对象的遮罩和围绕该对象的边界框。</p><p id="3b8a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我解决的一个实际任务中，有必要确定谷歌地球照片中的建筑物。这项任务成功地完成了使用掩模 R-CNN 的实例分割。在训练模型之后，有必要评估它的质量以预测建筑物周围的包围盒。我想让读者熟悉我用来评估预测边界框坐标的质量的方法(用代码)。</p><p id="9373" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://www.pyimagesearch.com/2016/11/07/intersection-over-union-iou-for-object-detection/" rel="noopener ugc nofollow" target="_blank">并集上的交集</a> (IoU)被认为是测量两个边界框或遮罩之间重叠的良好度量。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/549b6e1b582b9d66b885f87c48c71920.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*2w493Z_V6-sE_3aYa48a9w.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图片由 Oleksii Sheremet 用<a class="ae le" href="https://www.microsoft.com/uk-ua/microsoft-365/visio/flowchart-software" rel="noopener ugc nofollow" target="_blank">微软 Visio </a>创建</p></figure><p id="b8a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果预测完全正确，IoU = 1。IoU 越低，预测结果越差。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lr"><img src="../Images/95a04317cddc5947af0eff7069eb37d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kK0G-BmCqigHrc1rXs7tYQ.jpeg"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图片由 Oleksii Sheremet 使用<a class="ae le" href="https://www.microsoft.com/uk-ua/microsoft-365/visio/flowchart-software" rel="noopener ugc nofollow" target="_blank"> Microsoft Visio </a>创建</p></figure><p id="ef95" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有代码都是在 Google Colab 中实现的。让我们仔细看看。导入库并加载源图像:</p><pre class="lg lh li lj gt lw lx ly lz aw ma bi"><span id="6d62" class="mb mc it lx b gy md me l mf mg">import cv2</span><span id="c969" class="mb mc it lx b gy mh me l mf mg">import numpy</span><span id="5c47" class="mb mc it lx b gy mh me l mf mg">import matplotlib.pyplot as plt</span><span id="11ec" class="mb mc it lx b gy mh me l mf mg">img = cv2.imread(“./some_image.jpg”)</span><span id="71ba" class="mb mc it lx b gy mh me l mf mg">plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/42cba4864aff536bbb2021ceea5a7645.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*jGjWrdgrjcNzQ6WSatpSEw.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图像由 Oleksii Sheremet 使用<a class="ae le" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>模块创建</p></figure><p id="d259" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">导入库并加载源图像:</p><pre class="lg lh li lj gt lw lx ly lz aw ma bi"><span id="6290" class="mb mc it lx b gy md me l mf mg"># An example of first bounding box</span><span id="9b95" class="mb mc it lx b gy mh me l mf mg">first_bb_points = [[250, 210], [440, 210], [440, 390], [250, 390]]</span><span id="b46a" class="mb mc it lx b gy mh me l mf mg">stencil = numpy.zeros(img.shape).astype(img.dtype)</span><span id="1ccf" class="mb mc it lx b gy mh me l mf mg">contours = [numpy.array(first_bb_points)]</span><span id="20d4" class="mb mc it lx b gy mh me l mf mg">color = [255, 255, 255]</span><span id="2760" class="mb mc it lx b gy mh me l mf mg">cv2.fillPoly(stencil, contours, color)</span><span id="5207" class="mb mc it lx b gy mh me l mf mg">result1 = cv2.bitwise_and(img, stencil)</span><span id="251d" class="mb mc it lx b gy mh me l mf mg">result1 = cv2.cvtColor(result1, cv2.COLOR_BGR2RGB)</span><span id="44b9" class="mb mc it lx b gy mh me l mf mg">plt.imshow(result1)</span></pre><p id="2069" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们设置原始边界框的坐标，并用黑色填充边界框外照片的全部内容:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/058039fec82dee5563a1503ae9a86197.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*laK_yCKgQVkBgVLVhKhTYQ.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图像由 Oleksii Sheremet 使用<a class="ae le" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>模块创建</p></figure><p id="c210" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为预测的结果，获得第二边界框的坐标:</p><pre class="lg lh li lj gt lw lx ly lz aw ma bi"><span id="e748" class="mb mc it lx b gy md me l mf mg"># An example of second bounding box</span><span id="2ab5" class="mb mc it lx b gy mh me l mf mg">second_bb_points = [[280, 190], [438, 190], [438, 390], [280, 390]]</span><span id="b8db" class="mb mc it lx b gy mh me l mf mg">stencil = numpy.zeros(img.shape).astype(img.dtype)</span><span id="4d1d" class="mb mc it lx b gy mh me l mf mg">contours = [numpy.array(second_bb_points)]</span><span id="86a9" class="mb mc it lx b gy mh me l mf mg">color = [255, 255, 255]</span><span id="5b4b" class="mb mc it lx b gy mh me l mf mg">cv2.fillPoly(stencil, contours, color)</span><span id="6f49" class="mb mc it lx b gy mh me l mf mg">result2 = cv2.bitwise_and(img, stencil)</span><span id="a960" class="mb mc it lx b gy mh me l mf mg">result2 = cv2.cvtColor(result2, cv2.COLOR_BGR2RGB)</span><span id="d946" class="mb mc it lx b gy mh me l mf mg">plt.imshow(result2)</span></pre><p id="9be9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像上一个例子一样，用黑色填充边界框外的所有内容:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/c7ca4736b377360d98dda9b5e2e34f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*aBOfdndycTuE_LetWo6Ysg.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图像由 Oleksii Sheremet 使用<a class="ae le" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>模块创建</p></figure><p id="7737" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过在边界框外用黑色填充图像，感兴趣区域外的像素不会影响 IoU 计算:</p><pre class="lg lh li lj gt lw lx ly lz aw ma bi"><span id="55e6" class="mb mc it lx b gy md me l mf mg"># IoU calculation</span><span id="390c" class="mb mc it lx b gy mh me l mf mg">intersection = numpy.logical_and(result1, result2)</span><span id="ea1f" class="mb mc it lx b gy mh me l mf mg">union = numpy.logical_or(result1, result2)</span><span id="5415" class="mb mc it lx b gy mh me l mf mg">iou_score = numpy.sum(intersection) / numpy.sum(union)</span><span id="f7e1" class="mb mc it lx b gy mh me l mf mg">print(‘IoU is %s’ % iou_score)</span></pre><p id="f0ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们得到以下结果:</p><pre class="lg lh li lj gt lw lx ly lz aw ma bi"><span id="c503" class="mb mc it lx b gy md me l mf mg">IoU is 0.7625239952938262</span></pre><p id="a5ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">结论</strong></p><p id="f859" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所提出的方法在实践中运行良好。可以定义图像区域之间的重叠，不一定是矩形的。例如，您可以使用<a class="ae le" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>计算被遮罩对象周围轮廓的坐标。然后，利用这些点和上述方法，可以计算两个掩膜之间的 IoU。</p><p id="6154" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">参考文献</strong></p><ul class=""><li id="ab09" class="ml mm it kk b kl km ko kp kr mn kv mo kz mp ld mq mr ms mt bi translated"><a class="ae le" href="https://github.com/matterport/Mask_RCNN" rel="noopener ugc nofollow" target="_blank">屏蔽 R-CNN 进行目标检测和分割</a></li><li id="57b3" class="ml mm it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank">打开计算机视觉库</a></li><li id="2e0e" class="ml mm it kk b kl mu ko mv kr mw kv mx kz my ld mq mr ms mt bi translated"><a class="ae le" href="https://www.pyimagesearch.com/2016/11/07/intersection-over-union-iou-for-object-detection/" rel="noopener ugc nofollow" target="_blank">用于对象检测的并集交集(IoU)</a></li></ul></div></div>    
</body>
</html>