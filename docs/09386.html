<html>
<head>
<title>Why You Should Wrap Decorators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该用 Python 包装 Decorators</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-you-should-wrap-decorators-in-python-5ac3676835f9?source=collection_archive---------11-----------------------#2020-07-05">https://towardsdatascience.com/why-you-should-wrap-decorators-in-python-5ac3676835f9?source=collection_archive---------11-----------------------#2020-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b6a0" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">提高您的 Python 技能</h2><div class=""/><div class=""><h2 id="e3ab" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">利用 functools.wraps</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/2052581815e170274f3a0ef4c241c21e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AgiuB9lLJvTcrcff"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@vorosbenisop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">本杰明·沃罗斯</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h2 id="8332" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">介绍</h2><p id="993a" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">装饰器是 Python 中的一个重要特性。本质上，装饰器是修改被装饰函数的行为而不改变其固有功能的函数。在 Python 中，使用 decorator 的最常见语法是将 decorator 函数放在要修饰的函数之上。装饰函数名以@符号作为前缀，表示它是一个装饰函数。下面来看看它最基本的用法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">装饰者的基本用法</p></figure><p id="e44a" class="pw-post-body-paragraph md me it mf b mg my kd mi mj mz kg ml lr na mn mo lv nb mq mr lz nc mt mu mv im bi translated">在上面的代码中，我们定义了一个名为<code class="fe nd ne nf ng b">invocation_log</code>的装饰函数，它将记录特定函数调用前后的消息。要使用这个装饰器，我们只需简单地将它放在要装饰的函数之上，在本例中为<code class="fe nd ne nf ng b">say_hello</code>。不要忘记装饰函数名前面的@符号。让我们调用修饰函数，看看会发生什么。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">修饰函数的调用</p></figure><p id="c2ae" class="pw-post-body-paragraph md me it mf b mg my kd mi mj mz kg ml lr na mn mo lv nb mq mr lz nc mt mu mv im bi translated">这三行输出正是我们从装修中可以期待的。具体来说，decorator 只记录了两条消息——在调用被修饰的函数之前和之后。值得注意的是，如前所述，修饰函数做它最初定义的事情，而装饰函数做它自己的工作而不影响修饰函数的功能。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h2 id="5257" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">问题</h2><p id="1557" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">在调试过程中，我们有时需要检查特定的对象，以便更好地理解实现细节。让我们考虑下面对上面定义的修饰函数的检查。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">修饰函数的字符串表示</p></figure><p id="ec00" class="pw-post-body-paragraph md me it mf b mg my kd mi mj mz kg ml lr na mn mo lv nb mq mr lz nc mt mu mv im bi translated">如你所见，它并没有真正告诉我们它是什么。相反，它告诉我们这个函数是装饰函数的内部函数。这并不奇怪，因为使用@ symbol 作为 decorator 函数的前缀来修饰函数相当于下面几行代码。换句话说，装饰函数实际上是在装饰函数中定义的返回的内部函数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">修饰函数的显式创建</p></figure><p id="70c2" class="pw-post-body-paragraph md me it mf b mg my kd mi mj mz kg ml lr na mn mo lv nb mq mr lz nc mt mu mv im bi translated">如果其他人使用我们的代码，一些人可能需要获取关于函数调用的更多细节。为此设计了一个方便的内置函数——<code class="fe nd ne nf ng b">help()</code>函数。但是对修饰的功能有帮助吗？不完全是，因为它显示了内部函数的信息。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">修饰函数的帮助</p></figure><p id="1aaa" class="pw-post-body-paragraph md me it mf b mg my kd mi mj mz kg ml lr na mn mo lv nb mq mr lz nc mt mu mv im bi translated">或者，有些人更喜欢查看函数的文档字符串。然而，它并不像你想象的那样工作。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">修饰函数的文档字符串</p></figure><p id="d8a8" class="pw-post-body-paragraph md me it mf b mg my kd mi mj mz kg ml lr na mn mo lv nb mq mr lz nc mt mu mv im bi translated">此外，有时我们希望使用序列化程序保存代码，比如标准库中的<em class="no"> pickle </em>模块。但是，我们不能将修饰函数序列化为它现在的形式，因为模块不能序列化在修饰函数范围内的本地对象。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">装饰功能的酸洗问题</p></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h2 id="7cc2" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">解决方案</h2><p id="ec12" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">实际上解决方案一点也不困难——我们可以利用标准库中<em class="no"> functools </em>模块中的<em class="no">包装</em>函数。有趣的是，<em class="no">包装了</em>函数本身就是一个装饰器，我们将使用这个函数通过配置要装饰的函数来装饰内部函数。听起来不简单吗？用下面的例子就很好理解了。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">包装装潢师</p></figure><p id="31a1" class="pw-post-body-paragraph md me it mf b mg my kd mi mj mz kg ml lr na mn mo lv nb mq mr lz nc mt mu mv im bi translated">如上图所示，我们只是使用了装饰器<em class="no">包装</em>函数，通过包装<code class="fe nd ne nf ng b">say_hello</code>函数来装饰内部函数。这只是一行代码。让我们看看这个看似微不足道的变化之后，事情是如何变化的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">包装装饰器的调用</p></figure><p id="d2a9" class="pw-post-body-paragraph md me it mf b mg my kd mi mj mz kg ml lr na mn mo lv nb mq mr lz nc mt mu mv im bi translated">如上所示，当我们不使用包装器时，装饰器的功能保持不变。更重要的问题是被修饰的函数是否有不同的“表现形式”。让我们通过运行下面的代码来检查一下。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">支票装饰包装</p></figure><p id="54a6" class="pw-post-body-paragraph md me it mf b mg my kd mi mj mz kg ml lr na mn mo lv nb mq mr lz nc mt mu mv im bi translated">正如您从输出中看到的，一切都按预期运行。例如，文档字符串显示了那些在<code class="fe nd ne nf ng b">say_hello</code>函数中定义的内容。我们现在能够序列化该函数以供进一步处理。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h2 id="d4ef" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">结论</h2><p id="981f" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">在本文中，我们回顾了为什么以及如何在<em class="no"> functools </em>模块中使用<em class="no"> wraps </em> decorator 来解决我们使用 decorator 时出现的几个突出问题。通过几行额外的代码，修饰函数就像其他常规函数一样具有期望的行为。</p></div></div>    
</body>
</html>