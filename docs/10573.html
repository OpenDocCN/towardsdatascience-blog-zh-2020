<html>
<head>
<title>Deep Learning and LSTM based Malware Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于深度学习和 LSTM 的恶意软件分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deep-lstm-based-malware-analysis-6b36ac247f34?source=collection_archive---------29-----------------------#2020-07-24">https://towardsdatascience.com/deep-lstm-based-malware-analysis-6b36ac247f34?source=collection_archive---------29-----------------------#2020-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="841a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 Windows Exe API 调用进行恶意软件分析的基于深度学习的顺序模型</h2></div><p id="a676" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恶意软件开发在架构和功能方面呈现出多样性。恶意软件能力的这一进步构成了严重的威胁，并为恶意软件检测开辟了新的研究领域。这项研究的重点是变形恶意软件，它是恶意软件家族中最高级的成员。使用传统的基于签名的方法的反病毒应用程序很难检测变形恶意软件，这使得很难相应地对这种类型的恶意软件进行分类。最近关于恶意软件检测和分类的研究文献讨论了与恶意软件行为相关的这个问题。</p><p id="5621" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">引用作品</strong> <br/>如果你觉得这个实现有用，请引用它:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5a36" class="lk ll iq lg b gy lm ln l lo lp">@article{10.7717/peerj-cs.285,<br/>title = {Deep learning based Sequential model for malware analysis using Windows exe API Calls},<br/>author = {Catak, Ferhat Ozgur and Yazı, Ahmet Faruk and Elezaj, Ogerta and Ahmed, Javed},<br/>year = 2020,<br/>month = jul,<br/>keywords = {Malware analysis, Sequential models, Network security, Long-short-term memory, Malware dataset},<br/>volume = 6,<br/>pages = {e285},<br/>journal = {PeerJ Computer Science},<br/>issn = {2376-5992},<br/>url = {https://doi.org/10.7717/peerj-cs.285},<br/>doi = {10.7717/peerj-cs.285}<br/>}</span></pre><p id="ff5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以从我的<a class="ae lq" href="https://github.com/ocatak/lstm_malware_detection" rel="noopener ugc nofollow" target="_blank">我的 GitHub 库</a>访问数据集。</p><h2 id="669c" class="lk ll iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">介绍</h2><p id="6bfe" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">恶意软件，通常被称为恶意软件，是任何故意设计来破坏计算机系统和危害用户安全的软件。如果某个应用程序或代码暗中违背计算机用户的利益并执行恶意活动，则该应用程序或代码被视为恶意软件。恶意软件针对各种平台，如服务器、个人电脑、手机和相机，以获得未经授权的访问，窃取个人数据，并破坏系统的正常功能。</p><p id="9aaa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">处理恶意软件保护问题的一种方法是通过识别恶意软件并评估其行为。通常，这个问题是通过分析恶意软件行为来解决的。该领域紧密遵循恶意软件家族的模型，该模型也反映了恶意行为的模式。很少有研究证明了根据恶意软件家族进行分类的方法。</p><p id="848a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何软件对操作系统 API 的调用都显示了这个程序的总体方向。该程序是否是恶意软件可以通过深入检查这些操作来了解。如果是恶意软件，那么它的恶意软件家族是什么。恶意软件制造的操作系统 API 调用是一种数据属性，并且这些 API 调用生成的顺序对于检测恶意软件家族也是至关重要的。执行特定的 API 调用是代表一种行为的特定顺序。深度学习方法之一 LSTM(长短期记忆)通常用于处理这种时序数据。</p><h2 id="ebc1" class="lk ll iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">系统结构</h2><p id="a8e1" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这项研究有两个主要目标:首先，我们创建了一个相关的数据集，然后，使用这个数据集，我们进行了一项比较研究，使用各种机器学习来根据恶意软件的类型自动检测和分类。</p><h2 id="5daf" class="lk ll iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">数据集创建</h2><p id="8102" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这项工作最重要的贡献之一是新的 Windows PE 恶意软件 API 序列数据集，其中包含恶意软件分析信息。在这个数据集中有 7107 个来自不同类别的恶意软件。如上所述，Cuckoo 沙箱应用程序用于获取恶意软件的 Windows API 调用序列，而 VirusTotal 服务用于检测恶意软件的类别。</p><p id="7846" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下图说明了用于收集数据并使用 LSTM 算法对数据进行分类的系统架构。</p><figure class="lb lc ld le gt mn gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/c6a86f7fe94222c5c03dd4e51f070e64.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ygfDPBpCquH3dYNchb5S5Q.png"/></div></figure><p id="97fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的系统包括三个主要部分，数据收集，数据预处理和分析，以及数据分类。</p><p id="ddb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建数据集时遵循了以下步骤。</p><p id="ad5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Cuckoo 沙盒应用程序安装在运行 Ubuntu Linux 发行版的计算机上。分析机器作为虚拟服务器运行，以运行和分析恶意软件。此服务器上安装了 Windows 操作系统。</p><h2 id="d027" class="lk ll iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">让我们编码吧</h2><p id="11da" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们导入常用的标准库来构建一个 LSTM 模型来检测恶意软件。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4f43" class="lk ll iq lg b gy lm ln l lo lp">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>from sklearn.preprocessing import LabelEncoder<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import confusion_matrix<br/>from keras.preprocessing.text import Tokenizer<br/>from keras.layers import LSTM, Dense, Dropout, Embedding<br/>from keras.preprocessing import sequence<br/>from keras.utils import np_utils<br/>from keras.models import Sequential<br/>from keras.layers import SpatialDropout1D<br/>from mlxtend.plotting import plot_confusion_matrix</span></pre><p id="89f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这项工作中，我们将使用标准的恶意软件数据集来显示结果。您可以从<a class="ae lq" href="https://github.com/ocatak/lstm_malware_detection" rel="noopener ugc nofollow" target="_blank"> My GitHub Repository </a>访问数据集。我们需要合并调用和标签数据集。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="98b3" class="lk ll iq lg b gy lm ln l lo lp">malware_calls_df = pd.read_csv("calls.zip", compression="zip",<br/>                               sep="\t", names=["API_Calls"])<br/><br/>malware_labels_df = pd.read_csv("types.zip", compression="zip",<br/>                                sep="\t", names=["API_Labels"])<br/><br/>malware_calls_df["API_Labels"] = malware_labels_df.API_Labels<br/>malware_calls_df["API_Calls"] = malware_calls_df.API_Calls.apply(lambda x: " ".join(x.split(",")))<br/><br/>malware_calls_df["API_Labels"] = malware_calls_df.API_Labels.apply(lambda x: 1 if x == "Virus" else 0)</span></pre><p id="cf56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们分析一下阶级分布</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="180b" class="lk ll iq lg b gy lm ln l lo lp">sns.countplot(malware_calls_df.API_Labels)<br/>plt.xlabel('Labels')<br/>plt.title('Class distribution')<br/>plt.savefig("class_distribution.png")<br/>plt.show()</span></pre><figure class="lb lc ld le gt mn gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/ebd05b1d9fde9ec008a1b541f8e8a0de.png" data-original-src="https://miro.medium.com/v2/format:webp/1*wUANBv1VDrvaDPIwsm5hMQ.png"/></div></figure><p id="b03f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以创建我们的序列矩阵。为了构建 LSTM 模型，您需要创建一个基于符号化的序列矩阵作为输入数据集</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6398" class="lk ll iq lg b gy lm ln l lo lp">max_words = 800<br/>max_len = 100<br/><br/>X = malware_calls_df.API_Calls<br/>Y = malware_calls_df.API_Labels.astype('category').cat.codes<br/><br/>tok = Tokenizer(num_words=max_words)<br/>tok.fit_on_texts(X)<br/>print('Found %s unique tokens.' % len(tok.word_index))<br/>X = tok.texts_to_sequences(X.values)<br/>X = sequence.pad_sequences(X, maxlen=max_len)<br/>print('Shape of data tensor:', X.shape)<br/><br/>X_train, X_test, Y_train, Y_test = train_test_split(X, Y,<br/>                                                    test_size=0.15)<br/><br/>le = LabelEncoder()<br/>Y_train_enc = le.fit_transform(Y_train)<br/>Y_train_enc = np_utils.to_categorical(Y_train_enc)<br/><br/>Y_test_enc = le.transform(Y_test)<br/>Y_test_enc = np_utils.to_categorical(Y_test_enc)</span><span id="44ca" class="lk ll iq lg b gy mr ln l lo lp">Found 278 unique tokens.<br/>Shape of data tensor: (7107, 100)</span></pre><p id="a7df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为练习，这里给出了基于 LSTM 的分类模型:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d150" class="lk ll iq lg b gy lm ln l lo lp">def malware_model(act_func="softsign"):<br/>    model = Sequential()<br/>    model.add(Embedding(max_words, 300, input_length=max_len))<br/>    model.add(SpatialDropout1D(0.1))<br/>    model.add(LSTM(32, dropout=0.1, recurrent_dropout=0.1,<br/>                   return_sequences=True, activation=act_func))<br/>    model.add(LSTM(32, dropout=0.1, activation=act_func, return_sequences=True))<br/>    model.add(LSTM(32, dropout=0.1, activation=act_func))<br/>    model.add(Dense(128, activation=act_func))<br/>    model.add(Dropout(0.1))<br/>    model.add(Dense(256, activation=act_func))<br/>    model.add(Dropout(0.1))<br/>    model.add(Dense(128, activation=act_func))<br/>    model.add(Dropout(0.1))<br/>    model.add(Dense(1, name='out_layer', activation="linear"))<br/>    return model</span></pre><p id="826d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是训练模型。我训练并保存了我的模型。由于数据集的原因，训练阶段需要花费大量时间。为了减少执行时间，您可以从 GitHub 存储库中加载我以前训练过的模型。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1a7a" class="lk ll iq lg b gy lm ln l lo lp">model = malware_model()<br/>print(model.summary())<br/>model.compile(loss='mse', optimizer="rmsprop",<br/>              metrics=['accuracy'])<br/><br/>filepath = "lstm-malware-model.hdf5"<br/>model.load_weights(filepath)<br/><br/>history = model.fit(X_train, Y_train, batch_size=1000, epochs=10,<br/>                    validation_data=(X_test, Y_test), verbose=1)</span><span id="9f83" class="lk ll iq lg b gy mr ln l lo lp">Model: "sequential"<br/>_________________________________________________________________<br/>Layer (type)                 Output Shape              Param #   <br/>=================================================================<br/>embedding (Embedding)        (None, 100, 300)          240000    <br/>_________________________________________________________________<br/>spatial_dropout1d (SpatialDr (None, 100, 300)          0         <br/>_________________________________________________________________<br/>lstm (LSTM)                  (None, 100, 32)           42624     <br/>_________________________________________________________________<br/>lstm_1 (LSTM)                (None, 100, 32)           8320      <br/>_________________________________________________________________<br/>lstm_2 (LSTM)                (None, 32)                8320      <br/>_________________________________________________________________<br/>dense (Dense)                (None, 128)               4224      <br/>_________________________________________________________________<br/>dropout (Dropout)            (None, 128)               0         <br/>_________________________________________________________________<br/>dense_1 (Dense)              (None, 256)               33024     <br/>_________________________________________________________________<br/>dropout_1 (Dropout)          (None, 256)               0         <br/>_________________________________________________________________<br/>dense_2 (Dense)              (None, 128)               32896     <br/>_________________________________________________________________<br/>dropout_2 (Dropout)          (None, 128)               0         <br/>_________________________________________________________________<br/>out_layer (Dense)            (None, 1)                 129       <br/>=================================================================<br/>Total params: 369,537<br/>Trainable params: 369,537<br/>Non-trainable params: 0<br/>_________________________________________________________________<br/>None<br/>Epoch 1/10<br/>7/7 [==============================] - 22s 3s/step - loss: 0.0486 - accuracy: 0.9487 - val_loss: 0.0311 - val_accuracy: 0.9672<br/>Epoch 2/10<br/>7/7 [==============================] - 21s 3s/step - loss: 0.0378 - accuracy: 0.9591 - val_loss: 0.0302 - val_accuracy: 0.9672<br/>Epoch 3/10<br/>7/7 [==============================] - 21s 3s/step - loss: 0.0364 - accuracy: 0.9604 - val_loss: 0.0362 - val_accuracy: 0.9625<br/>Epoch 4/10<br/>7/7 [==============================] - 20s 3s/step - loss: 0.0378 - accuracy: 0.9593 - val_loss: 0.0328 - val_accuracy: 0.9616<br/>Epoch 5/10<br/>7/7 [==============================] - 22s 3s/step - loss: 0.0365 - accuracy: 0.9609 - val_loss: 0.0351 - val_accuracy: 0.9606<br/>Epoch 6/10<br/>7/7 [==============================] - 21s 3s/step - loss: 0.0369 - accuracy: 0.9601 - val_loss: 0.0369 - val_accuracy: 0.9606<br/>Epoch 7/10<br/>7/7 [==============================] - 22s 3s/step - loss: 0.0371 - accuracy: 0.9594 - val_loss: 0.0395 - val_accuracy: 0.9625<br/>Epoch 8/10<br/>7/7 [==============================] - 22s 3s/step - loss: 0.0378 - accuracy: 0.9601 - val_loss: 0.0365 - val_accuracy: 0.9588<br/>Epoch 9/10<br/>7/7 [==============================] - 22s 3s/step - loss: 0.0358 - accuracy: 0.9618 - val_loss: 0.0440 - val_accuracy: 0.9456<br/>Epoch 10/10<br/>7/7 [==============================] - 21s 3s/step - loss: 0.0373 - accuracy: 0.9589 - val_loss: 0.0354 - val_accuracy: 0.9644</span></pre><h2 id="f1b1" class="lk ll iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">模型评估</h2><p id="dac1" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">现在，我们已经完成了 LSTM 模型的培训阶段。我们可以使用混淆矩阵来评估模型的分类性能。根据混淆矩阵，该模型的分类性能相当好。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2c36" class="lk ll iq lg b gy lm ln l lo lp">y_test_pred = model.predict_classes(X_test)<br/>cm = confusion_matrix(Y_test, y_test_pred)<br/><br/>plot_confusion_matrix(conf_mat=cm,<br/>                      show_absolute=True,<br/>                      show_normed=True,<br/>                      colorbar=True)<br/>plt.savefig("confusion_matrix.png")<br/>plt.show()</span></pre><figure class="lb lc ld le gt mn gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/4a5c8bd5cefac7d44cc2564e21b971c7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*DwByCgi1dZUD9HqEFD0BbA.png"/></div></figure><p id="64f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们继续我们模型的训练历史。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4f93" class="lk ll iq lg b gy lm ln l lo lp">plt.plot(history.history['accuracy'])<br/>plt.plot(history.history['val_accuracy'])<br/>plt.title('model accuracy')<br/>plt.ylabel('accuracy')<br/>plt.xlabel('epoch')<br/>plt.legend(['train', 'test'], loc='upper left')<br/>plt.grid()<br/>plt.savefig("accuracy.png")<br/>plt.show()<br/><br/>plt.plot(history.history['loss'])<br/>plt.plot(history.history['val_loss'])<br/>plt.title('model loss')<br/>plt.ylabel('loss')<br/>plt.xlabel('epoch')<br/>plt.legend(['train', 'test'], loc='upper left')<br/>plt.grid()<br/>plt.savefig("loss.png")<br/>plt.show()</span></pre><figure class="lb lc ld le gt mn gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/f3bd3687257f247515f7a97a886a6e12.png" data-original-src="https://miro.medium.com/v2/format:webp/1*UTmINDP3fCFKgh324TyvIA.png"/></div></figure><figure class="lb lc ld le gt mn gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/a96f6d52e98f2166eb45e37a0d000c5d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*6hz8s30Zxoorw0CZGn6Ifw.png"/></div></figure><h2 id="cd9b" class="lk ll iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">结论</h2><p id="d952" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这项研究的目的是使用我以前的恶意软件数据集创建一个基于 LSTM 的恶意软件检测模型。虽然我们的数据集包含属于一些分布不平衡的恶意软件家族的实例，但我们已经表明这个问题不会影响分类性能。</p></div></div>    
</body>
</html>