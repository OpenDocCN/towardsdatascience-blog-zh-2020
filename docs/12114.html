<html>
<head>
<title>Unpacking Operators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的解包运算符</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/unpacking-operators-in-python-306ae44cd480?source=collection_archive---------5-----------------------#2020-08-21">https://towardsdatascience.com/unpacking-operators-in-python-306ae44cd480?source=collection_archive---------5-----------------------#2020-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c7c0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在 Python 中使用*和**解包运算符</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4a43996cddfb1754d8598dd6624752d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5HbCAAB0Ro9vZrKP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="84bf" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">介绍</h2><p id="b86c" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">在本教程中，我们将学习如何使用星号(*)操作符解包可迭代对象，以及如何使用两个星号(**)解包字典。此外，我们将讨论如何使用同一个运算符将几个值打包到一个变量中。最后，我们将讨论什么是*args 和**kwargs 以及何时可以使用它们。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="b417" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">*操作员</h2><p id="f1cd" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">假设我们有一个列表:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="899d" class="lg lh it mw b gy na nb l nc nd">num_list = [1,2,3,4,5]</span></pre><p id="26b3" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">我们定义了一个函数，它接受 5 个参数并返回它们的和:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="b571" class="lg lh it mw b gy na nb l nc nd">def num_sum(num1,num2,num3,num4,num5):<br/>    return num1 + num2 + num3 + num4 + num5</span></pre><p id="c623" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">我们想找出<strong class="me iu"> num_list </strong>中所有元素的总和。嗯，我们可以通过将<strong class="me iu"> num_list </strong>的所有元素传递给函数<strong class="me iu"> num_sum </strong>来实现这一点。由于<strong class="me iu"> num_list </strong>中有五个元素，因此<strong class="me iu"> num_sum </strong>函数包含五个参数，每个参数对应于<strong class="me iu"> num_list </strong>中的一个元素。</p><p id="720f" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">一种方法是通过使用元素的索引来传递元素，如下所示:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="9beb" class="lg lh it mw b gy na nb l nc nd">num_sum(num_list[0], num_list[1], num_list[2], num_list[3], num_list[4])</span><span id="5c2a" class="lg lh it mw b gy nj nb l nc nd"># 15</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="6b8e" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">然而，有一种更简单的方法，那就是使用*操作符。*操作符是一个解包操作符，它将解包来自任何可迭代对象的值，例如列表、元组、字符串等…</p><p id="0fcd" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">例如，如果我们想解包<strong class="me iu"> num_list </strong>并传入 5 个元素作为<strong class="me iu"> num_sum </strong>函数的独立参数，我们可以这样做:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="03af" class="lg lh it mw b gy na nb l nc nd">num_sum(*num_list)</span><span id="6e82" class="lg lh it mw b gy nj nb l nc nd"># 15</span></pre><p id="03a0" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">就是这样！星号*或解包操作符解包<strong class="me iu"> num_list </strong>，并将<strong class="me iu"> num_list </strong>的值或元素作为单独的参数传递给<strong class="me iu"> num_sum </strong>函数。</p><blockquote class="nk nl nm"><p id="780e" class="mc md nn me b mf ne ju mh mi nf jx mk no ng mm mn np nh mp mq nq ni ms mt mu im bi translated">注意:为了实现这一点，<strong class="me iu"> num_list </strong>中的元素数量必须与<strong class="me iu"> num_sum </strong>函数中的参数数量相匹配。如果它们不匹配，我们会得到一个类型错误。</p></blockquote></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="f3dd" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak"> *带内置函数的运算符:</strong></h2><p id="7aaf" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">我们还可以在 python 的内置函数中使用星号，*或解包操作符，比如 print:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="fa16" class="lg lh it mw b gy na nb l nc nd">print(*num_list)</span><span id="337c" class="lg lh it mw b gy nj nb l nc nd"># 1 2 3 4 5</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="0d19" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">解包多个列表:</strong></h2><p id="99d7" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">假设我们有另一个列表:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="60c7" class="lg lh it mw b gy na nb l nc nd">num_list_2 = [6,7,8,9,10]</span></pre><p id="c6fe" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">我们希望打印出<strong class="me iu"> num_list </strong>和<strong class="me iu"> num_list_2 </strong>中的所有元素。我们可以使用解包操作符*来实现这一点，如下所示:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="c4c1" class="lg lh it mw b gy na nb l nc nd">print(*num_list, *num_list_2)</span><span id="f7e7" class="lg lh it mw b gy nj nb l nc nd"># 1 2 3 4 5 6 7 8 9 10</span></pre><p id="e73a" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated"><em class="nn">两个</em> <strong class="me iu"> <em class="nn"> num_list </em> </strong> <em class="nn">和</em><strong class="me iu"><em class="nn">num _ list _ 2</em></strong><em class="nn">都被解包。然后，所有的元素都作为单独的参数传递给 print。</em></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="676b" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">合并多个列表:</strong></h2><p id="4528" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">我们还可以创建一个新的列表，包含来自<strong class="me iu"> num_list </strong>和<strong class="me iu"> num_list_2 </strong>的所有元素:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="4a58" class="lg lh it mw b gy na nb l nc nd">new_list = [*num_list, *num_list_2]</span><span id="c5d5" class="lg lh it mw b gy nj nb l nc nd"># [1,2,3,4,5,6,7,8,9,10]</span></pre><p id="b0cf" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated"><strong class="me iu"><em class="nn">num _ list</em></strong><em class="nn">和</em><strong class="me iu"><em class="nn">num _ list _ 2</em></strong><em class="nn">被解包，导致它们的元素构成新制作的 list 的元素，</em><strong class="me iu"><em class="nn">new _ list</em></strong><em class="nn">。</em></p><blockquote class="nk nl nm"><p id="1f57" class="mc md nn me b mf ne ju mh mi nf jx mk no ng mm mn np nh mp mq nq ni ms mt mu im bi translated">注意:我们可以简单地添加<strong class="me iu"> num_list </strong>和<strong class="me iu"> num_list_2 </strong>来创建<strong class="me iu"> new_list </strong>。然而，这只是为了描述拆包操作员的功能。</p></blockquote></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><div class="kj kk kl km gt nr"><a rel="noopener follow" target="_blank" href="/the-walrus-operator-in-python-a315e4f84583"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">Python 中的海象算子</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">了解什么是 walrus 操作符以及如何在 Python 中使用它</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="87a9" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">*运算符的其他用途:</h2><p id="7729" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">假设我们有一个字符串分配给变量<strong class="me iu"> name </strong>:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="f368" class="lg lh it mw b gy na nb l nc nd">name = ‘Michael’</span></pre><p id="ed17" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">我们想把这个名字分成三部分，第一个字母分配给一个变量，最后一个字母分配给另一个变量，中间的所有字母分配给第三个变量。我们可以这样做:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e767" class="lg lh it mw b gy na nb l nc nd">first, *middle, last = name</span></pre><p id="8901" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">就是这样！由于 name 是一个字符串，而字符串是可迭代的对象，所以我们可以对它们进行解包。赋值操作符右边的值将根据它们在 iterable 对象中的相对位置被赋给左边的变量。因此,“Michael”的第一个字母被分配给变量<strong class="me iu"> first </strong>，在本例中为“M”。最后一个字母‘l’被分配给变量<strong class="me iu"> last </strong>。而变量<strong class="me iu">中间</strong>会以列表的形式包含‘M’和‘l’之间的所有字母:[‘I’，‘c’，‘h’，‘a’，‘e’]。</p><blockquote class="nk nl nm"><p id="0725" class="mc md nn me b mf ne ju mh mi nf jx mk no ng mm mn np nh mp mq nq ni ms mt mu im bi translated">注意:上面的<strong class="me iu">第一个</strong>和<strong class="me iu">最后一个</strong>变量被称为强制变量，因为它们必须被赋予具体的值。由于使用了*或解包操作符，中间的<strong class="me iu">变量可以有任意数量的值，包括零。如果没有足够的值来解包强制变量，我们将得到一个 ValueError。</strong></p></blockquote><p id="680a" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">例如，如果我们使用下面的赋值语句:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="2c7d" class="lg lh it mw b gy na nb l nc nd">first, *middle, last = ‘ma'</span></pre><p id="115a" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">然后，变量<strong class="me iu">第一个</strong>将被赋值为“m”，变量<strong class="me iu">最后一个</strong>将被赋值为“a”，而变量<strong class="me iu">中间的</strong>将只是一个空列表，因为没有其他值要赋值给它。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><div class="kj kk kl km gt nr"><a rel="noopener follow" target="_blank" href="/ternary-operators-in-python-49c685183c50"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">Python 中的三元运算符</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">用三元运算符改进您的 Python 代码！</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="ed46" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">用*运算符打包:</strong></h2><p id="9fb1" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">我们还可以使用*运算符将多个值打包到一个变量中。例如:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="5a6b" class="lg lh it mw b gy na nb l nc nd">*names, = ‘Michael’, ‘John’, ‘Nancy’</span><span id="4c7a" class="lg lh it mw b gy nj nb l nc nd"># names <br/>['Michael', 'John', 'Nancy']</span></pre><p id="a053" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">在* <strong class="me iu">名称</strong>后使用尾随逗号的原因是因为赋值的左边必须是元组或列表。因此，<strong class="me iu"> names </strong>变量现在以列表的形式包含了右侧的所有名字。</p><blockquote class="nk nl nm"><p id="eddf" class="mc md nn me b mf ne ju mh mi nf jx mk no ng mm mn np nh mp mq nq ni ms mt mu im bi translated">注意:这就是我们在定义可以接收不同数量参数的函数时所做的事情！那就是*args 和**kwargs 的概念！</p></blockquote></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="db33" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">*参数:</strong></h2><p id="e374" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">例如，假设我们有一个函数，<strong class="me iu"> names_tuple </strong>，它接受名字作为参数并返回它们。然而，我们传递给这个函数的名字的数量是可变的。我们不能只选择这个函数的一些参数，因为位置参数的数量会随着函数的每次调用而变化。我们可以使用*运算符将传入的参数打包成一个元组，如下所示:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="766b" class="lg lh it mw b gy na nb l nc nd">def names_tuple(*args):<br/>    return args</span><span id="619e" class="lg lh it mw b gy nj nb l nc nd">names_tuple('Michael', 'John', 'Nancy')<br/># ('Michael', 'John', 'Nancy')</span><span id="2231" class="lg lh it mw b gy nj nb l nc nd">names_tuple('Jennifer', 'Nancy')<br/># ('Jennifer', 'Nancy')</span></pre><p id="a613" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">无论我们在调用<strong class="me iu"> names_tuple </strong>函数时传入多少个位置参数，* <strong class="me iu"> args </strong>参数都会将位置参数打包到一个元组中，类似于上面的* <strong class="me iu"> names </strong>赋值。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="6ed5" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">* *夸格斯</strong></h2><p id="50cd" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">为了传递不同数量的关键字或命名参数，我们在定义函数时使用了**操作符。**解包操作符将把我们传入的不同数量的命名参数打包到一个字典中。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="759f" class="lg lh it mw b gy na nb l nc nd">def names_dict(**kwargs):<br/>    return kwargs</span><span id="00be" class="lg lh it mw b gy nj nb l nc nd">names_dict(Jane = 'Doe')<br/># {'Jane': 'Doe'}</span><span id="c243" class="lg lh it mw b gy nj nb l nc nd">names_dict(Jane = 'Doe', John = 'Smith')<br/># {'Jane': 'Doe', 'John': 'Smith'}</span></pre><blockquote class="nk nl nm"><p id="a02c" class="mc md nn me b mf ne ju mh mi nf jx mk no ng mm mn np nh mp mq nq ni ms mt mu im bi translated">注意:当使用*运算符创建一个在定义函数时接收不同数量的位置参数的参数时，通常使用参数名 args(和 kwargs 来接收不同数量的关键字或命名参数)。但是，可以为这些参数选择任何名称。</p></blockquote></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><div class="kj kk kl km gt nr"><a rel="noopener follow" target="_blank" href="/iterables-and-iterators-in-python-849b1556ce27"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">Python 中的迭代器和迭代器</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Python 中的可迭代对象、迭代器和迭代</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="oh l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="2676" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">字典</h2><p id="368d" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">当我们尝试在字典中使用*操作符时会发生什么？</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="21cc" class="lg lh it mw b gy na nb l nc nd">num_dict = {‘a’: 1, ‘b’: 2, ‘c’: 3}</span><span id="26e4" class="lg lh it mw b gy nj nb l nc nd">print(*num_dict)</span><span id="835c" class="lg lh it mw b gy nj nb l nc nd"># a b c</span></pre><p id="4256" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">注意它是如何打印字典的键而不是值的？要解包一个字典，我们需要使用**解包操作符。但是，由于每个值都与一个特定的键相关联，所以我们将这些参数传递给的函数必须具有与被解包的字典的键同名的参数。例如:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="6eba" class="lg lh it mw b gy na nb l nc nd">def dict_sum(a,b,c):<br/>    return a+b+c</span></pre><p id="ad3c" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">这个<strong class="me iu"> dict_sum </strong>函数有三个参数:<strong class="me iu"> a </strong>、<strong class="me iu"> b </strong>和<strong class="me iu"> c </strong>。这三个参数的命名与<strong class="me iu"> num_dict </strong>的键相同。因此，一旦我们使用**操作符传入解包的字典，它将根据相应的参数名分配键值:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="ffda" class="lg lh it mw b gy na nb l nc nd">dict_sum(**num_dict)</span><span id="8d32" class="lg lh it mw b gy nj nb l nc nd"># 6</span></pre><p id="541a" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated"><em class="nn">因此，对于</em> <strong class="me iu"> <em class="nn"> a </em> </strong> <em class="nn">、</em> <strong class="me iu"> <em class="nn"> b </em> </strong> <em class="nn">和</em><strong class="me iu"><em class="nn"/></strong><em class="nn"/><strong class="me iu"><em class="nn">中的参数 dict_sum </em> </strong> <em class="nn">将分别为 1、2 和 3。这三个值之和是 6。</em></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="5a4f" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">合并字典:</strong></h2><p id="b226" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">就像列表一样，**操作符可以用来合并两个或更多的字典:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="3ed8" class="lg lh it mw b gy na nb l nc nd">num_dict = {‘a’: 1, ‘b’: 2, ‘c’: 3}</span><span id="e0ed" class="lg lh it mw b gy nj nb l nc nd">num_dict_2 = {‘d’: 4, ‘e’: 5, ‘f’: 6}</span><span id="9195" class="lg lh it mw b gy nj nb l nc nd">new_dict = {**num_dict, **num_dict_2}</span><span id="73bf" class="lg lh it mw b gy nj nb l nc nd"># {‘a’: 1, ‘b’: 2, ‘c’: 3, ‘d’: 4, ‘e’: 5, ‘f’: 6}</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="e05d" class="pw-post-body-paragraph mc md it me b mf ne ju mh mi nf jx mk lp ng mm mn lt nh mp mq lx ni ms mt mu im bi translated">如果你喜欢阅读这样的故事，并想支持我成为一名作家，考虑注册成为一名媒体成员。每月 5 美元，你可以无限制地阅读媒体上的故事。如果你用我的 <a class="ae ky" href="https://lmatalka90.medium.com/membership" rel="noopener"> <em class="nn">链接</em> </a> <em class="nn">注册，我会赚一小笔佣金。</em></p><div class="oi oj gp gr ok nr"><a href="https://lmatalka90.medium.com/membership" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">通过我的推荐链接加入媒体——卢艾·马塔尔卡</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">阅读卢艾·马塔尔卡的每一个故事(以及媒体上成千上万的其他作家)。您的会员费直接支持…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">lmatalka90.medium.com</p></div></div><div class="oa l"><div class="ol l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="e957" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h2><p id="f7b4" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">在本教程中，我们学习了如何使用*运算符解包可迭代对象，以及如何使用**运算符解包字典。我们还学习了利用这些操作符完成许多不同任务的许多方法。此外，在定义接收不同数量的位置或命名参数的函数时，我们通过使用*和**操作符简要讨论了用*args 和**kwargs 打包的概念。</p></div></div>    
</body>
</html>