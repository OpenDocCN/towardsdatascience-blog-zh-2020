<html>
<head>
<title>How I Created an Interactive, Scrolling Visualisation with D3.js, and how you can too</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何用D3.js创建了一个交互式的滚动可视化，你也可以</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-i-created-an-interactive-scrolling-visualisation-with-d3-js-and-how-you-can-too-e116372e2c73?source=collection_archive---------2-----------------------#2020-02-27">https://towardsdatascience.com/how-i-created-an-interactive-scrolling-visualisation-with-d3-js-and-how-you-can-too-e116372e2c73?source=collection_archive---------2-----------------------#2020-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="972c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过交互式和可滚动的可视化，让您的故事栩栩如生，这通过出色的D3.js库成为可能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0741d528adf6fbb79e0dc82d980417c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R3Z8nPSZw2FCoKJ3b-N8vQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按类别划分的大学专业</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/adb4e4009cd163527f8eeb0654ac7df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/1*5uB-Z-P3H90_mJoFYtCHLg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动画版</p></figure><div class="kz la gp gr lb lc"><a href="https://cuthchow.github.io/college-majors-visualisation/" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">最佳大学专业</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">大多数人想要一个能让他们毕业后赚大钱的学位。这里是(几乎)所有的…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">cuthchow.github.io</p></div></div></div></a></div><ul class=""><li id="1a19" class="ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><a class="ae md" href="https://cuthchow.github.io/college-majors-visualisation/" rel="noopener ugc nofollow" target="_blank">可视化</a></li><li id="e5a6" class="ll lm it ln b lo me lq mf ls mg lu mh lw mi ly lz ma mb mc bi translated"><a class="ae md" href="https://github.com/cuthchow/college-majors-visualisation" rel="noopener ugc nofollow" target="_blank">代码(Github Repo) </a></li></ul><h1 id="878e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">动机</h1><p id="c274" class="pw-post-body-paragraph nb nc it ln b lo nd ju ne lq nf jx ng ls nh ni nj lu nk nl nm lw nn no np ly im bi translated">网络上充斥着滚动和交互式可视化的惊人例子，通常是用D3构建的。如果你读过《彭博》或《纽约时报》的这类专题文章，我肯定你知道我在说什么。我最喜欢的这种形式的例子有:</p><ul class=""><li id="5471" class="ll lm it ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Shirley Wu的<a class="ae md" href="https://pudding.cool/2017/03/hamilton/index.html" rel="noopener ugc nofollow" target="_blank">对汉密尔顿</a>中非常线的示范性可视化，用D3和React构建。事实上，她所有的工作都很出色。</li><li id="058c" class="ll lm it ln b lo me lq mf ls mg lu mh lw mi ly lz ma mb mc bi translated">《纽约时报》关于经济如何被衰退重塑的文章，用255个不同的图表讲述。</li><li id="8538" class="ll lm it ln b lo me lq mf ls mg lu mh lw mi ly lz ma mb mc bi translated">这个<a class="ae md" href="http://www.r2d3.us/visual-intro-to-machine-learning-part-1/" rel="noopener ugc nofollow" target="_blank">绝对令人难以置信的作品，可视化了机器学习</a>的内部机制，由R2D3的人创造。</li><li id="96ba" class="ll lm it ln b lo me lq mf ls mg lu mh lw mi ly lz ma mb mc bi translated">这种古怪的形象化，分解了我们每天消耗的水量</li><li id="5bb0" class="ll lm it ln b lo me lq mf ls mg lu mh lw mi ly lz ma mb mc bi translated">《纽约时报》的另一篇文章，描述了<a class="ae md" href="https://www.nytimes.com/interactive/2015/01/09/sports/the-dawn-wall-el-capitan.html" rel="noopener ugc nofollow" target="_blank">背信弃义地爬上埃尔卡皮坦的黎明之墙</a></li><li id="dadb" class="ll lm it ln b lo me lq mf ls mg lu mh lw mi ly lz ma mb mc bi translated">还有<a class="ae md" href="https://vallandingham.me/scroll_talk/examples/" rel="noopener ugc nofollow" target="_blank">这么多更</a>。</li><li id="e4e9" class="ll lm it ln b lo me lq mf ls mg lu mh lw mi ly lz ma mb mc bi translated">说真的，这些项目中的每一个都值得检查和学习。他们太棒了。</li></ul><p id="e836" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">每一次滚动事件后，视觉元素的行为方式令人满意，完全受你的控制。很多时候，当我上下滚动页面，看着所有的形状和颜色飞来飞去，我的脸上挂着灿烂的笑容。这种感觉让人想起自己发现了数据中的秘密，我相信这是这些演示如此令人信服的原因。它还提供了一个更具命令性的叙事流程，这在其他静态作品中是缺乏的。浏览这些文章，你可能会发现自己制作这样的视觉效果会非常复杂，你可能会认为它们最好留给顶级出版物的编辑和作者。但我在这里帮助消除这种观念:任何人都可以做一个，包括你！</p><p id="970d" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">在通读了一堆在线资源之后(我会在文章末尾列出这些资源)，我决定尝试自己创建一个。正如我之前提到的，学习一项新工具、技术、技能或能力的最好方式是在你知道自己是否有能力做这件事之前，就把它投入使用。这就是我在一周内所做的。</p><p id="986e" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">(本文假设您对D3.js及其工作原理有一些基本的了解)</p><h1 id="d3bd" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">项目描述</h1><p id="cd0a" class="pw-post-body-paragraph nb nc it ln b lo nd ju ne lq nf jx ng ls nh ni nj lu nk nl nm lw nn no np ly im bi translated">在浏览了一系列数据集后，我找到了一个托管在Kaggle上的数据集，它最初来自分析博客Fivethirtyeight(如果你正在寻找很酷的数据集，请查看<a class="ae md" href="https://datasetsearch.research.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌的数据集搜索工具</a>)。这是一个(有点过时的)关于美国大学专业的数据集。它有每个大学专业的注册人数的信息，以及这些学生的中位数，第75个百分点和第25个百分点的工资。有趣的是，它还提供了每个专业的男性/女性代表的信息，我认为这将是这篇文章的一个重点。</p><p id="1ac3" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">决定数据集后，我开始在Jupyter笔记本上使用Python和Pandas探索数据，寻找任何有趣的趋势或我想在可视化中强调的点。我还对我想在最终产品中展示的图表做了粗略的近似。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/e3c9b5869f06cfe1d3ebef7235e10d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LA2Hi9As9ET5-MC8941dpA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我匆忙拼凑的几张草图，只是为了大致勾勒出我希望达到的叙事流程</p></figure><p id="b1cb" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">我对观想的总体概念是，每个大学专业都用一个泡泡来代表。然后，气泡会根据我试图强调的数据类型(如性别差异、工资中位数、类别分组等)改变形状和颜色。).当气泡被特定的属性分组时，我想通过一个D3力模拟来实现，这样气泡看起来会被一个看不见的力吸引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/da35067b3359fe3604cae239746f8230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xmNRlWtp1W_2y6Zchc7VBA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我用matplotlib制作的性别分布与工资中位数图表的预览。我在研究这些数据，看看是否有有趣的趋势需要强调，这是其中之一</p></figure><p id="1b3e" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">经过一番探索，我知道我想关注的是专业内的性别分布对毕业生平均工资的影响。我强烈建议你在开始任何可视化过程之前深入研究你的数据，因为在真正坐下来编码最终产品之前，你想要有一些你脑海中的交互的表象。</p><p id="8dc3" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">如果您想要一种真正快速的方法来观察变量之间的关系，python可视化包seaborn有一个“pairplot()”方法来帮助您做到这一点，它会在传递给它的数据帧中的所有变量之间创建一个散点图矩阵。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="cba6" class="oa mk it nw b gy ob oc l od oe"><strong class="nw iu">#Plotting a scatter matrix</strong></span><span id="9e58" class="oa mk it nw b gy of oc l od oe">import seaborn as sns</span><span id="2842" class="oa mk it nw b gy of oc l od oe">factors = df[['Total', 'Major_category', 'ShareWomen', 'Sample_size', 'Employed', 'Unemployed', 'Median']]</span><span id="3bf0" class="oa mk it nw b gy of oc l od oe">sns.pairplot(factors)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/b922b7325c2fac419ad58bc31d2cfacc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nP1wl1zy39a4X5XEinbzwQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">根据数据子集创建的配对图示例</p></figure><p id="a970" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">现在我们对想要包含的东西有了一个坚实的想法，我们准备开始创建。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="db0c" class="mj mk it bd ml mm oo mo mp mq op ms mt jz oq ka mv kc or kd mx kf os kg mz na bi translated">处理滚动事件</h1><p id="32d4" class="pw-post-body-paragraph nb nc it ln b lo nd ju ne lq nf jx ng ls nh ni nj lu nk nl nm lw nn no np ly im bi translated">这(显然)是你构建的每个滚动条中最重要的部分。但方便的是，它也是最可重用的部分，这意味着一旦构建完成，就可以开始使用了。</p><p id="9377" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">事实上，我已经创建了一个滚动条功能的模板版本，你可以在这里找到它。(再次感谢吉姆·瓦兰丁汉姆，因为使用的大部分代码来自他的原创文章<a class="ae md" href="https://vallandingham.me/scroller.html" rel="noopener ugc nofollow" target="_blank">。事实上，他写了一篇关于创建滚动器的类似文章，重点是滚动机制，所以你应该先读一下。在这篇文章中，我将把重点放在我发现令人困惑的元素上，并把重点放在实际创造观想的部分上。</a></p><h2 id="2c2e" class="oa mk it bd ml ot ou dn mp ov ow dp mt ls ox oy mv lu oz pa mx lw pb pc mz pd bi translated">HTML和CSS大纲</h2><p id="b724" class="pw-post-body-paragraph nb nc it ln b lo nd ju ne lq nf jx ng ls nh ni nj lu nk nl nm lw nn no np ly im bi translated">整个可视化应该包含在一个HTML页面中。在页面中，有一个包含所有元素的div，在这个div中，有两个单独的div用于文本和可视化。</p><p id="6b9e" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">在“sections”div中有一组section元素，每个元素都有一个类“step”。这些部分中的每一个都应该包含一个不同的文本部分，并且对应于观想的一个阶段或部分。当用户在部分之间移动时，可视化将被更新，</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="417d" class="oa mk it nw b gy ob oc l od oe">&lt;div id="graphic"&gt;</span><span id="1246" class="oa mk it nw b gy of oc l od oe">    &lt;div id="sections"&gt;</span><span id="058e" class="oa mk it nw b gy of oc l od oe">         &lt;section class="step"&gt;&lt;/section&gt;<br/>         &lt;section class="step"&gt;&lt;/section&gt;</span><span id="1884" class="oa mk it nw b gy of oc l od oe">    &lt;/div&gt;<br/>    &lt;div id="vis"&gt;</span><span id="22f4" class="oa mk it nw b gy of oc l od oe">    &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="ba8d" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">您可以随意调整这些元素的大小和位置，只要您将#vis元素固定在页面上(使用display: fixed)，这样它就不会随着用户的滚动而移动。您也可以调整每个的高度。step元素基于您希望每个部分包含多少文本。</p><h2 id="4ca5" class="oa mk it bd ml ot ou dn mp ov ow dp mt ls ox oy mv lu oz pa mx lw pb pc mz pd bi translated">滚动事件</h2><p id="30fa" class="pw-post-body-paragraph nb nc it ln b lo nd ju ne lq nf jx ng ls nh ni nj lu nk nl nm lw nn no np ly im bi translated">下面是处理滚动事件的代码。我添加了一些注释来澄清某些部分。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="97b5" class="oa mk it nw b gy ob oc l od oe">function scroller(){</span><span id="ed67" class="oa mk it nw b gy of oc l od oe">  let container = d3.select('body')<br/>  let dispatch = d3.dispatch('active', 'progress');<br/>  let sections = d3.selectAll('.step')<br/>  let sectionPositions<br/>  let currentIndex = -1<br/>  let containerStart = 0;</span><span id="f7c6" class="oa mk it nw b gy of oc l od oe"><strong class="nw iu">// Binds the position function to the scroll event, and the resize function to the resize event. What these functions do are detailed below. </strong></span><span id="a412" class="oa mk it nw b gy of oc l od oe">  function scroll(){</span><span id="cb6f" class="oa mk it nw b gy of oc l od oe">    d3.select(window)<br/>      .on('scroll.scroller', position)<br/>      .on('resize.scroller', resize)</span><span id="5a25" class="oa mk it nw b gy of oc l od oe">      resize();</span><span id="7c90" class="oa mk it nw b gy of oc l od oe">    let timer = d3.timer(function() {<br/>      position();<br/>      timer.stop();<br/>    });<br/>  }</span><span id="792c" class="oa mk it nw b gy of oc l od oe"><strong class="nw iu">//The resize function determines where each of the .step elements are on the page, relative to the top of the first element. It saves all of the co-ordinates of these elements in an array called sectionPositions</strong></span><span id="6e98" class="oa mk it nw b gy of oc l od oe">  function resize(){<br/>    sectionPositions = [];<br/>    let startPos;</span><span id="ed6e" class="oa mk it nw b gy of oc l od oe">    sections.each(function(d, i) {<br/>      let top = this.getBoundingClientRect().top;<br/>      if (i === 0 ){<br/>        startPos = top;<br/>      }<br/>      sectionPositions.push(top - startPos)<br/>    });<br/>  }</span><span id="2e3b" class="oa mk it nw b gy of oc l od oe"><strong class="nw iu">//The position function determines where the user is on the page (using window.pageYOffset), and uses that to determine which section of text should currently be in view. It then uses D3’s dispatching tools to signal the 'progress' event, which will be used in the main script, passing along the current section index so that the script knows which stage of the animation/visualisation should be showing. </strong></span><span id="2e84" class="oa mk it nw b gy of oc l od oe">  function position() {<br/>    let pos = window.pageYOffset - 300 - containerStart;<br/>    let sectionIndex = d3.bisect(sectionPositions, pos);<br/>    sectionIndex = Math.min(sections.size()-1, sectionIndex);</span><span id="ab22" class="oa mk it nw b gy of oc l od oe">    if (currentIndex !== sectionIndex){<br/>      dispatch.call('active', this, sectionIndex);<br/>      currentIndex = sectionIndex;<br/>    }</span><span id="030a" class="oa mk it nw b gy of oc l od oe">    let prevIndex = Math.max(sectionIndex - 1, 0);<br/>    let prevTop = sectionPositions[prevIndex]<br/>    let progress = (pos - prevTop) / (sectionPositions[sectionIndex]   - prevTop);<br/>    dispatch.call('progress', this, currentIndex, progress)<br/>  }</span><span id="8aa3" class="oa mk it nw b gy of oc l od oe">//<strong class="nw iu">The code here adds an event listener to the dispatcher.</strong></span><span id="17ff" class="oa mk it nw b gy of oc l od oe">  scroll.container = function(value) {<br/>    if (arguments.legth === 0){<br/>      return container<br/>    }<br/>    container = value<br/>    return scroll<br/>  }</span><span id="2df9" class="oa mk it nw b gy of oc l od oe">  scroll.on = function(action, callback){<br/>    dispatch.on(action, callback)<br/>  };<br/>  return scroll;</span><span id="5d2a" class="oa mk it nw b gy of oc l od oe">}</span></pre><p id="c4c6" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">上述所有代码都保存在一个单独的脚本文件中。然后我们创建一个主脚本文件，它负责在每次查看器改变部分时更新可视化。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="fcbe" class="oa mk it nw b gy ob oc l od oe">let scroll = scroller().container(d3.select('#graphic'))</span><span id="4e2b" class="oa mk it nw b gy of oc l od oe">scroll()</span><span id="2e4a" class="oa mk it nw b gy of oc l od oe">let lastIndex, activeIndex = 0</span><span id="43e8" class="oa mk it nw b gy of oc l od oe"><strong class="nw iu">//This is where most of the magic happens. Every time the user scrolls, we receive a new index. First, we find all the irrelevant sections, and reduce their opacity. </strong></span><span id="9dde" class="oa mk it nw b gy of oc l od oe">scroll.on('active', function(index){<br/>  d3.selectAll('.step')<br/>    .transition().duration(500)<br/>    .style('opacity', function (d, i) {return i === index ? 1 : 0.1;});</span><span id="b0f9" class="oa mk it nw b gy of oc l od oe"><strong class="nw iu">//Next, we selection from a range of activationFunctions (which we create), based on the index of the current section. </strong></span><span id="488d" class="oa mk it nw b gy of oc l od oe">  activeIndex = index<br/>  let sign = (activeIndex - lastIndex) &lt; 0 ? -1 : 1;<br/>  let scrolledSections = d3.range(lastIndex + sign, activeIndex + sign, sign);<br/>  scrolledSections.forEach(i =&gt; {<br/>    activationFunctions[i]();<br/>  })<br/>  lastIndex = activeIndex;</span><span id="9952" class="oa mk it nw b gy of oc l od oe">})</span><span id="c1f4" class="oa mk it nw b gy of oc l od oe"><strong class="nw iu">//I placed all the functions in an array. Each function corresponds to a different change in the visualisation. One may change the graph into a scatter plot, and another may initiate a force simulation.</strong></span><span id="f5e3" class="oa mk it nw b gy of oc l od oe">let activationFunctions = [<br/>  draw1,<br/>  draw2,<br/>  draw3,<br/>  draw4,<br/>  draw5,<br/>  draw6,<br/>  draw7,<br/>  draw8<br/>]</span></pre></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="1de4" class="mj mk it bd ml mm oo mo mp mq op ms mt jz oq ka mv kc or kd mx kf os kg mz na bi translated">构建滚动条的一般建议</h1><p id="d1b5" class="pw-post-body-paragraph nb nc it ln b lo nd ju ne lq nf jx ng ls nh ni nj lu nk nl nm lw nn no np ly im bi translated">有了滚动条的一般组件，你从这里开始所做的将会根据你希望构建的观想类型而有很大的不同。尽管如此，我还是希望能提供一些有用的建议，我希望我能在这个过程中早点意识到。</p><h2 id="e0e6" class="oa mk it bd ml ot ou dn mp ov ow dp mt ls ox oy mv lu oz pa mx lw pb pc mz pd bi translated">在起点画出所有的元素</h2><p id="9195" class="pw-post-body-paragraph nb nc it ln b lo nd ju ne lq nf jx ng ls nh ni nj lu nk nl nm lw nn no np ly im bi translated">基本思想是，当页面加载时，应该创建可视化所需的所有元素。我创建了一个名为drawInitial()的函数，并在数据加载后调用它。这包括创建所有的比例，轴，形状，用于模拟和其他你在观想中需要的元素。</p><p id="b93d" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">一旦它们都创建好了，你可以简单地把它们的不透明度属性设置为0，以确保它们直到可视化需要时才显示出来。确保每组特征(即特定图表的一组轴或详细标注)都有相关的类名或ID名，以便在需要时可以引用这些特定的特征。</p><p id="2eac" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">我发现创建一个清理函数很有用，它会在每一步被调用。我将传入我试图创建的图表类型，该函数将移除(或者隐藏)与该图表无关的所有元素，从而使我不必编写大量重复的代码。这是函数的一部分:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="d60a" class="oa mk it nw b gy ob oc l od oe">function clean(chartType){<br/>    let svg = d3.select('#vis').select('svg')</span><span id="5ae6" class="oa mk it nw b gy of oc l od oe">    if (chartType !== "isScatter") {<br/>      svg.select('.scatter-x').transition().attr('opacity', 0)<br/>      svg.select('.scatter-y').transition().attr('opacity', 0)<br/>    }</span><span id="9582" class="oa mk it nw b gy of oc l od oe">    if (chartType !== "isMultiples"){<br/>      svg.selectAll('.lab-text').transition().attr('opacity', 0)<br/>      svg.selectAll('.cat-rect').transition().attr('opacity', 0)</span><span id="bae2" class="oa mk it nw b gy of oc l od oe">...</span></pre><h2 id="ebdf" class="oa mk it bd ml ot ou dn mp ov ow dp mt ls ox oy mv lu oz pa mx lw pb pc mz pd bi translated">与原力打交道</h2><p id="ab86" class="pw-post-body-paragraph nb nc it ln b lo nd ju ne lq nf jx ng ls nh ni nj lu nk nl nm lw nn no np ly im bi translated">正如我提到的，我将使用力模拟来分组几个阶段中的圆形元素。要记住的关键是，每次重新使用时，要“重新加热”力模拟。D3的力模拟有一个alpha值，这是一个冷却参数，随着时间的推移逐渐减少，减少了力对节点的影响。你应该在每次重启原力时将alpha重置回某个值，以确保它有足够的“能量”达到期望的状态。您还可以调整alpha衰减率，以影响模拟稳定到平衡状态的速度。</p><h2 id="ccb4" class="oa mk it bd ml ot ou dn mp ov ow dp mt ls ox oy mv lu oz pa mx lw pb pc mz pd bi translated">总是使用过渡</h2><p id="7cf8" class="pw-post-body-paragraph nb nc it ln b lo nd ju ne lq nf jx ng ls nh ni nj lu nk nl nm lw nn no np ly im bi translated">这一部分很关键:当改变观想的状态时，总是使用过渡，即使这种改变是你想要立即发生的。通过利用D3的转换特性(即使持续时间为0)，您允许更改被中断。这意味着，如果用户快速滚动各个部分，一个过渡可以被下一个覆盖，从而避免出现尴尬、无效的状态。</p><h2 id="0a44" class="oa mk it bd ml ot ou dn mp ov ow dp mt ls ox oy mv lu oz pa mx lw pb pc mz pd bi translated">你鼓舞了我</h2><p id="5140" class="pw-post-body-paragraph nb nc it ln b lo nd ju ne lq nf jx ng ls nh ni nj lu nk nl nm lw nn no np ly im bi translated">SVG元素是根据它们被附加到父元素的时间来排序的。把它想象成把颜料泼在画布上:最后一层颜料是在顶部可见的。您可以通过将元素从它们的父元素中移除，然后再将它们追加到最末尾来对元素进行重新排序。或者，您可以利用D3的. raise()和。lower()方法，当给定一组元素时，这些方法可以方便地完成这个过程。</p><h2 id="e0eb" class="oa mk it bd ml ot ou dn mp ov ow dp mt ls ox oy mv lu oz pa mx lw pb pc mz pd bi translated">构建一致的调色板</h2><p id="2fc9" class="pw-post-body-paragraph nb nc it ln b lo nd ju ne lq nf jx ng ls nh ni nj lu nk nl nm lw nn no np ly im bi translated">颜色是良好数据可视化不可或缺的组成部分。在我的项目中，我试图用颜色对16种不同类别的大学专业进行编码。这导致了一个精心挑选颜色的过程，因为我想避免任何两种颜色太相似，因此很容易混淆。</p><p id="d5d0" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">我强烈推荐使用<a class="ae md" href="https://colorhunt.co/" rel="noopener ugc nofollow" target="_blank">颜色搜索</a>来构建你的调色板。这是一个网站，其他创意人员已经建立并分享了他们自己的调色板，它允许你轻松地复制你想要的颜色的十六进制代码，并保存你自己的调色板以供将来使用。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="55d4" class="pw-post-body-paragraph nb nc it ln b lo lp ju ne lq lr jx ng ls nq ni nj lu nr nl nm lw ns no np ly im bi translated">希望这至少揭开了滚动可视化过程的一部分。老实说，这比看起来容易得多，所以一定要去找一个有趣的数据集，亲自尝试一下！</p><h1 id="bd0b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">参考的资源</h1><ul class=""><li id="c8ee" class="ll lm it ln b lo nd lq nf ls pe lu pf lw pg ly lz ma mb mc bi translated">吉姆·瓦兰丁汉姆:<a class="ae md" href="https://vallandingham.me/scroller.html" rel="noopener ugc nofollow" target="_blank">关于小偷的文章</a>，<a class="ae md" href="https://vallandingham.me" rel="noopener ugc nofollow" target="_blank">博客</a></li><li id="17e8" class="ll lm it ln b lo me lq mf ls mg lu mh lw mi ly lz ma mb mc bi translated">吴雪莉的<a class="ae md" href="https://sxywu.com" rel="noopener ugc nofollow" target="_blank">作品</a>，还有她的<a class="ae md" href="https://www.youtube.com/watch?v=A4vNRIgvyH0&amp;t=6s" rel="noopener ugc nofollow" target="_blank"> YouTube频道</a>和<a class="ae md" href="https://www.youtube.com/redirect?redir_token=dBTsb_HDyTWCsMwuJWv8gpTFwrN8MTU4Mjg5NDEzNUAxNTgyODA3NzM1&amp;event=video_description&amp;v=A4vNRIgvyH0&amp;q=https%3A%2F%2Fwww.twitch.tv%2Fsxywu" rel="noopener ugc nofollow" target="_blank"> Twitch streams </a></li><li id="165e" class="ll lm it ln b lo me lq mf ls mg lu mh lw mi ly lz ma mb mc bi translated">迈克·博斯托克，<a class="ae md" href="https://bl.ocks.org/mbostock" rel="noopener ugc nofollow" target="_blank">积木</a>，关于<a class="ae md" href="https://bost.ocks.org/mike/scroll/" rel="noopener ugc nofollow" target="_blank">如何滚动的文章</a></li></ul></div></div>    
</body>
</html>