# MATLAB/Octave 中的结构

> 原文：<https://towardsdatascience.com/structures-in-matlab-octave-96145b0b3f9f?source=collection_archive---------67----------------------->

![](img/98e4168f22bffd1157bfff2b4ed016f8.png)

图片由作者提供。图片来源于[https://pixabay.com/](https://pixabay.com/)。

## 帮助您的数据保持完整！

结构，或*结构*，是 MATLAB/Octave 中的一种基本数据类型，可用于将多个属性组织和组合成一个公共数据结构。结构上的属性也称为字段，可以是不同的类型和不同的大小。然后，可以像平常一样访问和操作结构上的每个属性。结构在 MATLAB/Octave 中有多种用途，对于那些更熟悉 Python 的人来说，它非常类似于字典。

在本文中，我将介绍结构的基础知识，然后分享一些我认为最有用的使用它们的“技巧”。特别是，我涵盖了以下主题:

*   动态属性访问和 *filednames()* 函数
*   使用结构数组
*   使用结构编写高效代码的注意事项

所有例子的源代码都可以在 [GitHub 库](https://github.com/ThinkData-science/CodingTips/tree/master/matlab)中找到。需要注意的是，MATLAB 和 Octave 显示结构的方式非常不同，因此根据运行代码的应用程序，您可能会看到一些差异。在本教程中，我用 Octave 运行了所有的例子，以尽可能地使事情变得容易理解。

# 基础知识

MATLAB/Octave 中的结构是动态管理的，所以我们可以随时添加和删除新的属性。创建结构最简单的方法是使用 *struct()* 命令创建一个空结构，并使用点操作符填充它。这里有一个简单的例子。

```
s = struct(); % create an empty struct
s.val1 = 100; % add a scalar
s.val2 = 0 : 25 : 100; % add a vectorize
s.val3 = randn( 2, 3, 5 ); % add an ND array
s.char1 = 'This is a character string'; % add a character string
s.cell1 = { 100, 300, '5', 'abc' };  % add a cell array
disp( s );scalar structure containing the fields:val1 =  100
    val2 =0    25    50    75   100val3 =ans(:,:,1) =-0.49715   0.32621  -0.81624
      -0.34628   1.85946   0.29556ans(:,:,2) =-0.32521   0.44471   2.40743
      -0.97223  -0.24240   0.39241ans(:,:,3) =-1.63085  -0.34078   0.46239
       0.48026  -0.45361   1.62214ans(:,:,4) =

       0.523431  -0.576770  -0.028377
      -1.035780   0.093593  -2.001485ans(:,:,5) =0.30492  -2.05388   0.13755
      -0.98662  -1.36354  -0.43432char1 = This is a character string
    cell1 =
    {
      [1,1] =  100
      [1,2] =  300
      [1,3] = 5
      [1,4] = abc
    }
```

我们现在可以使用相应的字段名称来访问任何新添加的属性。例如，让我们访问“val2”的第 2 个元素。

```
>> disp( s.val2(2) );25
```

或者我们可以访问“单元格 1”的最后一个元素。

```
>> disp( s.cell1{end} );abc
```

事实上，我们现在可以访问和修改所有的属性，就像它们不在结构上一样。让我们给“单元格 1”添加一个新值。

```
>> s.cell1{ end+1 } = 'I am new!';
>> disp( s.cell1 );{
  [1,1] =  100
  [1,2] =  300
  [1,3] = 5
  [1,4] = abc
  [1,5] = I am new!
}
```

或者让我们从“val2”中删除一些值。

```
>> disp( s.val2 );0    25    50    75   100>> s.val2( 2:3 ) = [];>> disp( s.val2 );0    75   100
```

最后，使用 *rmfield()* 函数，我们可以从一个结构中完全删除字段。例如，让我们创建一个名为“s2”的新结构，并删除除“val1”之外的所有字段。其语法是: *sOut = rmfield( s，{ 'name1 '，' name2 '，etc… } )* ，其中如果我们想要覆盖原始结构，则“sOut”可以是“s”，并且单元格数组包含我们想要移除的所有字段的名称。

```
>> s2 = rmfield( s, { 'val2', 'val3', 'char1', 'cell1' } );
>> disp( s2 );scalar structure containing the fields:val1 =  100
```

这是对结构的最基本用法的快速介绍。如果你是一个结构新手，花点时间浏览一下 MATLAB 文档可能是值得的。本文的其余部分将涉及一些更高级的，或者可能不太明显的使用结构的方法。

# 动态访问属性和 fieldnames()函数

结构的另一个非常有用的特性是你可以构建它们的数组。这些数组的行为与任何其他数组非常相似，但是，在填充它们时还需要额外的注意。特别是，结构数组中的每个元素都必须具有相同的属性。它们可以是空的，但是在将多个结构连接成一个数组之前，所有的属性都必须存在。

从一个简单的例子开始，让我们将“s3”的第二个元素设置为其自身的另一个副本。

```
>> s3(2) = s3;
>> disp( s3 );1x2 struct array containing the fields:noodles
    dexter
    ron
    greg
```

现在我们可以看到有一个 1x2 的结构数组。请注意，这是可行的，因为两个结构具有完全相同的属性。

结构数组的行为就像任何其他数组一样，可以使用 *()* 来访问。例如，让我们将第一个结构上的“面条”字段更新为等于当前值的两倍。

```
>> s3(1).noodles = s3(1).noodles * 2;
>> disp( s3(1).noodles );62
>> disp( s3(2).noodles );31
```

我们还可以通过将元素设置为空值来从结构中移除元素。

```
>> s3(1) = [];
>> disp( s3 );scalar structure containing the fields:noodles =  31
    dexter =  11
    ron =  46
    greg =  28
```

请注意，上面的输出显示我们再次拥有了一个标量结构。因为我们已经移除了结构数组的第一个元素。

最后，跨结构数组收集值也很方便。例如，假设我们有一个包含带有地理标签的图像的结构数组，我们对查看所有图像的位置感兴趣。我们可以通过捕获方括号 *[]* 之间的结构输出将这些值收集到一个数组中。

让我们用另一个例子来证明这一点。首先，我们将构建 10 个结构，每个结构都有“img”、“lat”和“lon”属性。请注意，在循环中，临时变量用于在将每个结构添加到数组之前完全填充该结构。在这种情况下，这实际上是不必要的，因为我是通过向后循环来预分配结构内存的；但是，一般来说，这是一个很好的做法，因为这将确保在您尝试连接结构之前所有的字段都存在。

```
% - Build a fake array of structs.
for iS=10 : -1 : 1
    tmp = struct();
    tmp.lat = randi( [-89, 90], 1 );
    tmp.lon = randi( [-179, 180], 1 );
    tmp.img = randn( 16, 16, 3 );
    img( iS ) = tmp;
end
```

结构的结果数组将如下所示。

```
>> disp( img );1x10 struct array containing the fields:lat
    lon
    img
```

接下来，我们可以将结构数组中的所有纬度和经度值收集到单独的数组中。

```
% - Collect all of the lat and lon values into separate arrays
lat = [ img(:).lat ];
lon = [ img(:).lon ];>> disp( lat );5   48  -36  -29   45   49  -68  -62   34  -31
>> disp( lon );28   -62    60    80  -130   125   -68     2    33   177
```

方便的是，我们现在可以访问所有的 lat/lon 值，而不必遍历结构。当你想绘制图表或计算统计数据时，这是非常方便的。它还可以节省大量的运行时间，我将在下一节演示这一点。

令人惊讶的是，当您收集具有不止一个非单例维度的属性时，甚至可以做更奇妙的事情。在这种情况下，技巧是使用 *cat()* 函数来明确说明数据应该如何分组。例如，我们可以将所有的像素数据从结构中收集到一个大小为 16 x 16 x 3 x 10 的新 ND 数组中，其中第四维对应于每个结构。

```
>> pixelData = cat( 4, img(:).img );
>> disp( size( pixelData ) );16   16    3   10
```

现在你可以看到我们有一个 4 维数组，它是高乘宽乘通道乘图像。我发现这是一种非常优雅的方法，可以同时访问一个结构中多个元素的数据。这个“技巧”起初对我来说也不是很明显，但现在我经常使用。

# 性能呢？

尽管结构很棒也很灵活，但当然也有一些代价。在这种情况下，代价是运行时间的增加，这主要是由于数据在内存中的存储方式。好消息是，使用我们刚刚介绍的技巧，您可以解决大多数问题。如果您有兴趣了解更多关于数组顺序和在 MATLAB 中编写高效循环的知识，请务必查看详细讨论该主题的[以前的文章](https://thinkdata.science/?p=239)。

让我们以前面的图像为例，但是现在我们将创建 50，000 个伪图像结构。

```
for iS=50000 : -1 : 1
    tmp = struct();
    tmp.lat = randi( [-89, 90], 1 );
    tmp.lon = randi( [-179, 180], 1 );
    tmp.img = randn( 16, 16, 3 );
    img( iS ) = tmp;
end
```

接下来，我们可以编写一些代码来对每个图像执行一个简单的任务。在这种情况下，我们将计算每个图像的平均像素强度，并将其保存在一个 1x10，000 元素的数组中。如果我们直接从结构中访问数据，代码看起来就是这样。

```
a = tic();% Loop over each struct
avgPixelInt = nan( 1, numel( img ) );
for iS=1 : numel( img )
  avgPixelInt( iS ) = mean( img( iS ).img(:) );
endt1 = toc( a )
```

或者，如果我们使用上一节中的 *cat()* 技巧，我们实际上可以编写相同的代码，而不必遍历数据。

```
a = tic();% Capture all of the images into an ND array
pixelData = cat( 4, img(:).img );% Reshape so we can take the mean over the entire image
sz = size( pixelData );
pixelData = reshape( pixelData, [ prod( sz(1:3) ), sz(4) ] );% Calculate the mean for all images at once
avgPixelInt = mean( pixelData, 1 );t2 = toc( a );
```

现在，如果我们运行两组代码，并使用 *tic()* 和 *toc()* 对执行进行计时，这就是我们得到的结果。

```
>> t1 = toc( a )t1 =  9.8469>> t2 = toc( a )t2 =  1.9880>> disp( t1/t2 );
 4.9531
```

在这种情况下，使用 *cat()* 技巧使代码运行速度提高了近 5 倍！现在，在这个例子中，节省实际上来自于消除环路；但是，通常情况下，最好不要在循环中访问或设置结构的属性。几乎在所有情况下，由于结构中的数据存储在内存中的方式，这将导致代码变慢。所以，当有疑问时， *cat()* 它出来了。

# 摘要

这篇文章介绍了 MATLAB/Octave 中的结构，并介绍了一些基本的用法。一些更高级的用法基于使用变量来访问结构上的特定属性。这些技术确实给了程序员很大的能力来以编程方式解析和生成结构。最后，讨论了结构数组的使用，以及一些有助于编写高效代码的技巧。

以下是一些需要记住的关键事项:

*   结构可以包含不同类型的数据作为属性
*   可以随时添加或删除结构属性(或字段)
*   结构可以连接成数组；但是，结构数组的每个元素必须包含完全相同的属性
*   函数可以用来将所有结构中的特定属性收集到一个数组中
*   虽然本文没有讨论，但是结构也可以包含其他结构作为属性
*   尽管结构很棒，但是在使用它们的时候你应该小心，以避免编写低效的代码

编码快乐！