<html>
<head>
<title>J.A.C.W.I.B — Autonomous Car</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">J.自动驾驶汽车</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/j-a-c-w-i-b-autonomous-car-9c42bc732279?source=collection_archive---------43-----------------------#2020-04-26">https://towardsdatascience.com/j-a-c-w-i-b-autonomous-car-9c42bc732279?source=collection_archive---------43-----------------------#2020-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7cf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">作者/开发者</strong> : <a class="ae ko" href="https://www.linkedin.com/in/udit-gavasane-183b161a7/" rel="noopener ugc nofollow" target="_blank">乌迪特·加瓦桑</a>，<a class="ae ko" href="https://in.linkedin.com/in/rohan-tergaonkar-481b17188" rel="noopener ugc nofollow" target="_blank">罗汉·特冈卡尔</a>，<a class="ae ko" href="https://www.linkedin.com/in/amod-sahasrabudhe-685b011a7/" rel="noopener ugc nofollow" target="_blank">阿莫德·萨哈斯·拉布德赫</a></p><p id="539b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非常感谢<a class="ae ko" href="https://towardsdatascience.com/@dctian" rel="noopener" target="_blank"> David Tian </a>，他在《深度少年派汽车》系列中的工作启发我们开发了一个类似的模型。可以参考他的文章<a class="ae ko" rel="noopener" target="_blank" href="/deeppicar-part-1-102e03c83f2c">这里</a>。</p><h1 id="ea55" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">介绍</h1><h2 id="6580" class="ln kq it bd kr lo lp dn kv lq lr dp kz kb ls lt ld kf lu lv lh kj lw lx ll ly bi translated">自动驾驶汽车有多重要？</h2><p id="e443" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">自动驾驶汽车是未来的事情。许多科技巨头如特斯拉、谷歌和汽车公司如优步、通用、宝马都在投资自动驾驶汽车。人们相信，在不久的将来，自动驾驶汽车将会在路上随处可见。使用经济的工具和零件来建造你自己的能够探测车道并跟随它们的自动驾驶汽车怎么样？这是我们命名为 J.A.C.W.I.B(又一辆拥有智能大脑的汽车)的汽车的清晰图像</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/53b167890033a12e739ec37d1daa5a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5OfhYdxemCmD-6kweTAVA.jpeg"/></div></div></figure><div class="mf mg mh mi gt ab cb"><figure class="mq mj mr ms mt mu mv paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/6dc96223234a041e97f6ad2fc2011a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*ZyVG7sSS9HzJBDc4DHN30w.jpeg"/></div></figure><figure class="mq mj mr ms mt mu mv paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/3d0969d40ab4375c6f34975b80756a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Jnu9uHR2eZk41Ck6QXx2bg.jpeg"/></div></figure><figure class="mq mj mr ms mt mu mv paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/1c728581b74421abcde8ea3a52172aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*V4rOUq43CuLyQCU4Xed9qg.jpeg"/></div></figure></div><div class="ab cb"><figure class="mq mj mw ms mt mu mv paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/bb231753cec0d841573d7cfada9b2fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*0mQUK8IJ2p0T2EVQawApHg.jpeg"/></div></figure><figure class="mq mj mw ms mt mu mv paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/eb0236f8ae586f6f2c91b6239538e4ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*RhF89j3EN2-3AfSLrDL_Lw.jpeg"/></div></figure></div><h1 id="1dda" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">硬件组件</h1><ul class=""><li id="f73c" class="mx my it js b jt lz jx ma kb mz kf na kj nb kn nc nd ne nf bi translated">遥控车:我们使用了一辆使用了 3 个 DC 马达(一个用于转向，两个用于节流)的遥控车。</li><li id="e823" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">树莓 Pi 3 型号 B+</li><li id="b712" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">32 GB micro SD:用于部署 Raspbian OS 和 Raspberry Pi 的内存。</li><li id="605a" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">RaspberryPi 5MP 摄像头模块:支持 1080p @ 30 fps，720p @ 60 fps，640x480p 60/90 录制。</li><li id="9e34" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">电机驱动器(LM298N):用于控制 DC 电机的方向和速度。支持 1 块板 2 个直流电机的控制，能承受 1.5 A。</li><li id="288a" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">电源组:电源组(额定电压为 5V，2.1A)为 Raspberry Pi 模块供电。</li><li id="619b" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">电池:9V 锂离子 USB 充电电池，500mAh 容量。用于给电机驱动器供电。</li><li id="001c" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">公对公和母对母跳线。</li><li id="1627" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">蓝色胶带:这是这个项目的一个非常重要的组成部分，它用于制作两条车道线，汽车将在这两条车道线之间行驶。</li><li id="84ca" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">拉链</li><li id="fdc5" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">螺丝刀</li></ul><h1 id="e2b4" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Raspberry Pi 设置</h1><h2 id="3459" class="ln kq it bd kr lo lp dn kv lq lr dp kz kb ls lt ld kf lu lv lh kj lw lx ll ly bi translated">Raspberry Pi 操作系统</h2><p id="58e4" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">Raspberry Pi 需要一个操作系统来运行不同类型的程序。可以参考这个优秀的<a class="ae ko" href="https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up" rel="noopener ugc nofollow" target="_blank">指南</a>。</p><h2 id="604e" class="ln kq it bd kr lo lp dn kv lq lr dp kz kb ls lt ld kf lu lv lh kj lw lx ll ly bi translated">设置远程访问</h2><p id="cea8" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">建议您设置远程访问您的 Raspberry Pi，因为您不能在汽车行驶时将其连接到外部显示器。要设置远程访问，您可以参考本<a class="ae ko" href="https://www.raspberrypi.org/documentation/remote-access/" rel="noopener ugc nofollow" target="_blank">指南</a>。你也可以参考这个<a class="ae ko" href="https://www.youtube.com/watch?v=IDqQIDL3LKg" rel="noopener ugc nofollow" target="_blank">视频指南</a>。</p><h2 id="1ac7" class="ln kq it bd kr lo lp dn kv lq lr dp kz kb ls lt ld kf lu lv lh kj lw lx ll ly bi translated">设置远程文件访问</h2><p id="1559" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">因为我们的 Raspberry Pi 是使用远程访问运行的，所以我们可以轻松地将文件传输到 Raspberry Pi 或从 Raspberry Pi 传输文件也是至关重要的。请参考本<a class="ae ko" href="https://www.raspberrypi.org/documentation/remote-access/samba.md" rel="noopener ugc nofollow" target="_blank">指南</a>。</p><p id="33b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在 Raspberry Pi 安装完成后，我们现在可以继续安装必要的库了。</p><h1 id="0203" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">安装 OpenCV</h1><p id="87d9" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated"><a class="ae ko" href="http://opencv.org" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> OpenCV </strong> </a> ( <em class="nl">开源计算机视觉库</em>)是一个高级库，包含主要针对实时计算机视觉的函数。OpenCV 的使用将使我们能够感知前方的情况，并帮助我们识别车道。在您的 Raspberry Pi 终端中运行命令(粗体)。</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="c448" class="ln kq it nn b gy nr ns l nt nu">#Installing dependent libraries</span><span id="1012" class="ln kq it nn b gy nv ns l nt nu">pi@raspberrypi:~ $  <strong class="nn iu">sudo apt-get install libhdf5-dev -y &amp;&amp; sudo apt-get install libhdf5-serial-dev -y &amp;&amp; sudo apt-get install libatlas-base-dev -y &amp;&amp; sudo apt-get install libjasper-dev -y &amp;&amp; sudo apt-get install libqtgui4 -y &amp;&amp; sudo apt-get install libqt4-test -y</strong></span><span id="b82a" class="ln kq it nn b gy nv ns l nt nu"># install OpenCV<br/>pi@raspberrypi:~ $ <strong class="nn iu">pip3 install opencv-python</strong><br/>Collecting opencv-python<br/>[Omitted....]<br/>Installing collected packages: numpy, opencv-python<br/>Successfully installed numpy-1.16.2 opencv-python-3.4.4.19</span></pre><p id="fdc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过运行以下代码测试 OpenCV 安装。</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="0133" class="ln kq it nn b gy nr ns l nt nu">pi@raspberrypi:~ $ <strong class="nn iu">python3 -c "import cv2"</strong></span></pre><p id="1a20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在运行该命令时没有看到任何错误，则库应该安装正确。</p><h1 id="30c2" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">硬件装配</h1><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nw"><img src="../Images/4c05afb10be12ba727ca55895a791fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6LZUsE3rp4HvRDTsfT5Mg.png"/></div></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">Raspberry Pi +电机驱动器装配示意图</p></figure><p id="1dcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上图显示了 Raspberry Pi、Raspberry Pi 摄像头模块和 LM298N 电机驱动器之间的连接。因为我们希望控制两个马达的节流速度，所以我们将它们连接到同一个端口。这些连接是借助公-公和母-母跳线完成的。摄像头模块安装在汽车的前格栅上。</p><p id="9f02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Raspberry Pi GPIO 引脚配置</strong></p><ul class=""><li id="ba8b" class="mx my it js b jt ju jx jy kb ob kf oc kj od kn nc nd ne nf bi translated">ENA — GPIO 25</li><li id="406f" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">IN1 — GPIO 23</li><li id="4a34" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">IN2 — GPIO 24</li><li id="aed9" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">IN3 — GPIO 17</li><li id="0c67" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">IN4 — GPIO27</li><li id="7d6d" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">ENB — GPIO22</li></ul><h1 id="8611" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">测试零件</h1><p id="e7dd" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">完成所有连接后，我们将测试它们以确保所有连接都是正确的。</p><h2 id="f678" class="ln kq it bd kr lo lp dn kv lq lr dp kz kb ls lt ld kf lu lv lh kj lw lx ll ly bi translated">测试摄像机</h2><p id="28b5" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在您的 Raspberry Pi 上打开一个新的 python 文件，并键入以下内容。</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="98b7" class="ln kq it nn b gy nr ns l nt nu">import cv2</span><span id="c6de" class="ln kq it nn b gy nv ns l nt nu">video = cv2.VideoCapture(0)</span><span id="42f4" class="ln kq it nn b gy nv ns l nt nu">while True:<br/>  ret,frame = video.read()<br/>  cv2.imshow('original',frame)<br/>  cv2.imwrite('original.jpg',frame)<br/>  <br/>  key = cv2.waitKey(1) #wait for 1 ms for any keyboard button<br/>  if key == 27:<br/>     break</span><span id="59fd" class="ln kq it nn b gy nv ns l nt nu">video.release()<br/>cv2.destroyAllWindows()</span></pre><p id="1c24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一行是导入我们的 OpenCV 库并使用它的函数。VideoCapture(0)功能从信号源开始传输实时视频。所提供的参数为“0 ”,这意味着我们使用默认摄像机，即本例中的 Raspberry Pi 摄像机。video.read()将读取来自摄像机的每一帧，并将其保存在一个名为“frame”的变量中。函数 imshow()将显示以单词“original”开头的帧，函数 imwrite()将在我们的存储设备上将“帧”存储为“original.jpg”。如果按下“esc”按钮，将返回十进制值 27，并相应地中断循环。</p><h2 id="9c49" class="ln kq it bd kr lo lp dn kv lq lr dp kz kb ls lt ld kf lu lv lh kj lw lx ll ly bi translated">测试电机</h2><p id="e3df" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我们需要测试马达，以检查速度并了解马达旋转的方向。在您的 Raspberry Pi 上运行以下代码来检查电机速度和方向。</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="1096" class="ln kq it nn b gy nr ns l nt nu"><strong class="nn iu">import </strong>RPi.GPIO <strong class="nn iu">as </strong>GPIO          <br/><strong class="nn iu">from </strong>time <strong class="nn iu">import </strong>sleep<br/><br/>in1 = 24<br/>in2 = 23<br/>in3 = 17<br/>in4 = 27<br/>en1 = 25<br/>en2 = 22<br/>temp1=1<br/><br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setup(in1,GPIO.OUT)<br/>GPIO.setup(in2,GPIO.OUT)<br/>GPIO.setup(in3,GPIO.OUT)<br/>GPIO.setup(in4,GPIO.OUT)<br/>GPIO.setup(en1,GPIO.OUT)<br/>GPIO.setup(en2,GPIO.OUT)<br/>GPIO.output(in1,GPIO.LOW)<br/>GPIO.output(in2,GPIO.LOW)<br/>GPIO.output(in3,GPIO.LOW)<br/>GPIO.output(in4,GPIO.LOW)<br/>p=GPIO.PWM(en1,1000)<br/>q=GPIO.PWM(en2,1000)<br/><br/>p.start(75)<br/>q.start(75)<br/>print(<strong class="nn iu">"\n"</strong>)<br/>print(<strong class="nn iu">"The default speed &amp; direction of motor is LOW &amp; Forward....."</strong>)<br/>print(<strong class="nn iu">"r-run x-stop w-forward s-backward a-left d-right m-medium e-exit f-front"</strong>)<br/>print(<strong class="nn iu">"\n"</strong>)    <br/><br/><strong class="nn iu">while</strong>(1):<br/><br/>    x=raw_input()<br/>    <br/>    <strong class="nn iu">if </strong>x==<strong class="nn iu">'r'</strong>:<br/>        print(<strong class="nn iu">"run"</strong>)<br/>        <strong class="nn iu">if</strong>(temp1==1):<br/>         GPIO.output(in1,GPIO.HIGH)<br/>         GPIO.output(in2,GPIO.LOW)<br/>         GPIO.output(in3,GPIO.HIGH)<br/>         GPIO.output(in4,GPIO.LOW)<br/>         <br/>         print(<strong class="nn iu">"forward"</strong>)<br/>         x=<strong class="nn iu">'z'<br/>        else</strong>:<br/>         GPIO.output(in1,GPIO.LOW)<br/>         GPIO.output(in2,GPIO.HIGH)<br/>         GPIO.output(in3,GPIO.LOW)<br/>         GPIO.output(in4,GPIO.HIGH)<br/>         <br/>         print(<strong class="nn iu">"backward"</strong>)<br/>         x=<strong class="nn iu">'z'<br/><br/><br/>    elif </strong>x==<strong class="nn iu">'x'</strong>:<br/>        print(<strong class="nn iu">"stop"</strong>)<br/>        GPIO.output(in1,GPIO.LOW)<br/>        GPIO.output(in2,GPIO.LOW)<br/>        GPIO.output(in3,GPIO.LOW)<br/>        GPIO.output(in4,GPIO.LOW)<br/>        <br/>        x=<strong class="nn iu">'z'<br/><br/>    elif </strong>x==<strong class="nn iu">'w'</strong>:<br/>        print(<strong class="nn iu">"forward"</strong>)<br/>        GPIO.output(in1,GPIO.HIGH)<br/>        GPIO.output(in2,GPIO.LOW)<br/>        temp1=1<br/>        x=<strong class="nn iu">'z'<br/><br/>    elif </strong>x==<strong class="nn iu">'s'</strong>:<br/>        print(<strong class="nn iu">"backward"</strong>)<br/>        GPIO.output(in1,GPIO.LOW)<br/>        GPIO.output(in2,GPIO.HIGH)<br/>        temp1=0<br/>        x=<strong class="nn iu">'z'<br/>    <br/>    elif </strong>x==<strong class="nn iu">'d'</strong>:<br/>        print(<strong class="nn iu">"right"</strong>)<br/>        GPIO.output(in3,GPIO.LOW)<br/>        GPIO.output(in4,GPIO.HIGH)<br/>        temp1=1<br/>        x=<strong class="nn iu">'z'<br/>     <br/>    elif </strong>x==<strong class="nn iu">'a'</strong>:<br/>        print(<strong class="nn iu">"left"</strong>)<br/>        GPIO.output(in3,GPIO.HIGH)<br/>        GPIO.output(in4,GPIO.LOW)<br/>        temp1=0<br/>        x=<strong class="nn iu">'z'<br/>        <br/>    elif </strong>x==<strong class="nn iu">'f'</strong>:<br/>        print(<strong class="nn iu">"front"</strong>)<br/>        GPIO.output(in3,GPIO.LOW)<br/>        GPIO.output(in4,GPIO.LOW)<br/>        temp1=0<br/>        x=<strong class="nn iu">'z'<br/><br/>    elif </strong>x==<strong class="nn iu">' '</strong>:<br/>        print(<strong class="nn iu">"brake"</strong>)<br/>        GPIO.output(in1,GPIO.LOW)<br/>        GPIO.output(in2,GPIO.LOW)   <br/>        x=<strong class="nn iu">'z'<br/><br/>    elif </strong>x==<strong class="nn iu">'m'</strong>:<br/>        print(<strong class="nn iu">"medium"</strong>)<br/>        p.ChangeDutyCycle(50)<br/>        q.ChangeDutyCycle(50)<br/>        x=<strong class="nn iu">'z'<br/><br/>    elif </strong>x==<strong class="nn iu">'e'</strong>:<br/>        GPIO.cleanup()<br/>        print(<strong class="nn iu">"GPIO Clean up"</strong>)<br/>        <strong class="nn iu">break<br/>    <br/>    else</strong>:<br/>        print(<strong class="nn iu">"&lt;&lt;&lt;  wrong data  &gt;&gt;&gt;"</strong>)<br/>        print(<strong class="nn iu">"please enter the defined data to continue....."</strong>)</span></pre><p id="c1a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使能引脚从 Raspberry Pi 获取脉宽调制(PWM)输入信号，并相应地运行电机。例如，100% PWM 信号表示我们正在以最大速度工作，0% PWM 信号表示电机不旋转。您可以使用 ChangeDutyCycle()函数进行调整。如果万一你的马达在相反的方向上运转，那么只要颠倒极性。如果电机根本不起作用，那么再次测试你的硬件连接。参考此<a class="ae ko" href="https://www.raspberrypi.org/documentation/usage/gpio/" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多关于 Raspberry Pi GPIO 引脚配置的信息。</p><p id="fdb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经完成了测试。现在是开始实际编程的时候了！</p><h1 id="f317" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">车道导航</h1><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi oe"><img src="../Images/a87f03ccc589bf61b78880000c0f7730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7iM1FQqZu3Xv7s8xL7CfA.png"/></div></div></figure><p id="8f21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用了由<a class="ae ko" rel="noopener" target="_blank" href="/deeppicar-part-4-lane-following-via-opencv-737dd9e47c96"> David Tian </a>开发的车道检测算法，我们将在这里分模块进行解释。</p><h2 id="1692" class="ln kq it bd kr lo lp dn kv lq lr dp kz kb ls lt ld kf lu lv lh kj lw lx ll ly bi translated">转换到 HSV 空间</h2><p id="3b15" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我们将图像使用的颜色空间，即 RGB(红/绿/蓝)转换为 HSV(色调/饱和度/值)颜色空间。这样做的主要优点是通过颜色的亮度来区分颜色。</p><h2 id="4be4" class="ln kq it bd kr lo lp dn kv lq lr dp kz kb ls lt ld kf lu lv lh kj lw lx ll ly bi translated">检测蓝色和边缘</h2><p id="03bf" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">使用蓝色车道的原因是在我们制造汽车的地方不常见。为了从 HSV 帧中提取蓝色，应该提到色调、饱和度和值的范围。为了减少每一帧中的整体失真，使用 Canny 边缘检测器检测边缘。你可以参考更多关于精明的<a class="ae ko" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="541a" class="ln kq it nn b gy nr ns l nt nu"><strong class="nn iu">def </strong>detect_edges(frame):<br/>    <em class="nl"># filter for blue lane lines<br/>    </em>hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)<em class="nl"><br/>    </em>lower_blue = np.array([90, 120, 0], dtype=<strong class="nn iu">"uint8"</strong>)<br/>    upper_blue = np.array([150, 255, 255], dtype=<strong class="nn iu">"uint8"</strong>)<br/>    mask = cv2.inRange(hsv, lower_blue, upper_blue)<em class="nl"><br/>    # detect edges<br/>    </em>edges = cv2.Canny(mask, 50, 100)</span><span id="1e32" class="ln kq it nn b gy nv ns l nt nu"><em class="nl">    </em><strong class="nn iu">return </strong>edges</span></pre><h2 id="b812" class="ln kq it bd kr lo lp dn kv lq lr dp kz kb ls lt ld kf lu lv lh kj lw lx ll ly bi translated">选择感兴趣区域</h2><p id="573c" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我们可以观察到，在我们的框架中也会出现其他蓝色。我们只需要隔离车道，因为这是我们希望关注的部分。</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="6485" class="ln kq it nn b gy nr ns l nt nu"><strong class="nn iu">def </strong>region_of_interest(edges):<br/>    height, width = edges.shape<br/>    mask = np.zeros_like(edges)</span><span id="a91a" class="ln kq it nn b gy nv ns l nt nu">    <em class="nl"># only focus lower half of the screen<br/>    </em>polygon = np.array([[<br/>        (0, height),<br/>        (0, height / 2),<br/>        (width, height / 2),<br/>        (width, height),<br/>    ]], np.int32)</span><span id="d392" class="ln kq it nn b gy nv ns l nt nu">    cv2.fillPoly(mask, polygon, 255)</span><span id="374a" class="ln kq it nn b gy nv ns l nt nu">    cropped_edges = cv2.bitwise_and(edges, mask)<br/>    cv2.imshow(<strong class="nn iu">"roi"</strong>, cropped_edges)</span><span id="5bd9" class="ln kq it nn b gy nv ns l nt nu">    <strong class="nn iu">return </strong>cropped_edges</span></pre><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi of"><img src="../Images/72dc14b1b4abcbc851b0c430e1db08c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Y89shkmVZSehar9aODny_Q.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">隔离感兴趣区域</p></figure><h2 id="66f2" class="ln kq it bd kr lo lp dn kv lq lr dp kz kb ls lt ld kf lu lv lh kj lw lx ll ly bi translated">检测线段</h2><p id="2c6c" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">霍夫变换用于检测帧中的任何形状，如果我们用数学形式表示它的话。在我们的例子中，我们需要检测线条。它也可以处理轻微扭曲的形状。更多关于霍夫变换<a class="ae ko" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_houghlines/py_houghlines.html" rel="noopener ugc nofollow" target="_blank">的内容可以参考这里的</a>。</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="3f6b" class="ln kq it nn b gy nr ns l nt nu"><strong class="nn iu">def </strong>detect_line_segments(cropped_edges):<br/>    rho = 1<br/>    theta = np.pi / 180<br/>    min_threshold = 10</span><span id="d1dc" class="ln kq it nn b gy nv ns l nt nu">    line_segments = cv2.HoughLinesP(cropped_edges, rho, theta, min_threshold,np.array([]), minLineLength=5, maxLineGap=150)</span><span id="de48" class="ln kq it nn b gy nv ns l nt nu">    <strong class="nn iu">return </strong>line_segments</span></pre><p id="f47b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">HoughLinesP()函数采用以下参数:</p><ul class=""><li id="59c0" class="mx my it js b jt ju jx jy kb ob kf oc kj od kn nc nd ne nf bi translated">Frame:是我们要在其中检测线条的框架。在我们的例子中，它是裁剪边</li><li id="d213" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">rho:是以像素为单位的距离精度。</li><li id="b19c" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">θ:角度精度，单位为弧度(始终= π/180 ~ 1 度)</li><li id="5cab" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">min_threshold 是被认为是线段所需的投票数。如果一条线有更多的投票，霍夫变换认为它们更有可能检测到线段。</li><li id="dd5f" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">maxLineGap:被视为一行的两行之间的最大像素间距。</li></ul><h2 id="4cd9" class="ln kq it bd kr lo lp dn kv lq lr dp kz kb ls lt ld kf lu lv lh kj lw lx ll ly bi translated">计算转向角度</h2><p id="c402" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我们知道直线的方程是<em class="nl"> y=mx+b，</em>其中<em class="nl"> m </em>是直线的斜率，<em class="nl"> b </em>是 y 截距。将计算使用霍夫变换检测的线段的斜率和截距的平均值。左车道线有<em class="nl"> x₁ &lt; x₂ </em>和<em class="nl"> y₂ &lt; y₁ </em>和坡度<em class="nl">，m= (y₂ — y₁) / (x₂ — x₁) </em>会给出负坡度。右边的车道则完全相反。右侧车道有 x<em class="nl">₂</em>t28】x<em class="nl">₁</em>和 y<em class="nl">₂</em>t29】y<em class="nl">₁</em>这将给出一个正斜率。在垂直线的情况下(x <em class="nl"> ₁ </em> = x <em class="nl"> ₂ </em>)，斜率将为无穷大。在这种情况下，我们将跳过所有垂直线，以防止出现错误。为了准确地检测车道，通过边界线将帧分成两个区域，右边和左边。</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="9b9d" class="ln kq it nn b gy nr ns l nt nu"><strong class="nn iu">def </strong>average_slope_intercept(frame, line_segments):<br/>    lane_lines = []</span><span id="72f5" class="ln kq it nn b gy nv ns l nt nu">    <strong class="nn iu">if </strong>line_segments <strong class="nn iu">is None</strong>:<br/>        print(<strong class="nn iu">"no line segments detected"</strong>)<br/>        <strong class="nn iu">return </strong>lane_lines</span><span id="04b8" class="ln kq it nn b gy nv ns l nt nu">    height, width, _ = frame.shape<br/>    left_fit = []<br/>    right_fit = []</span><span id="2580" class="ln kq it nn b gy nv ns l nt nu">    boundary = 1 / 3<br/>    left_region_boundary = width * (1 - boundary)<br/>    right_region_boundary = width * boundary<br/></span><span id="9e90" class="ln kq it nn b gy nv ns l nt nu">    <strong class="nn iu">for </strong>line_segment <strong class="nn iu">in </strong>line_segments:<br/>        <strong class="nn iu">for </strong>x1, y1, x2, y2 <strong class="nn iu">in </strong>line_segment:<br/>            <strong class="nn iu">if </strong>x1 == x2:<br/>                print(<strong class="nn iu">"skipping vertical lines"</strong>)<br/>                <strong class="nn iu">continue</strong></span><span id="fbe6" class="ln kq it nn b gy nv ns l nt nu"><strong class="nn iu">            </strong>fit = np.polyfit((x1, x2), (y1, y2), 1)<br/>            slope = (y2 - y1) / (x2 - x1)<br/>            intercept = y1 - (slope * x1)</span><span id="36e8" class="ln kq it nn b gy nv ns l nt nu">            <strong class="nn iu">if </strong>slope &lt; 0:<br/>                <strong class="nn iu">if </strong>x1 &lt; left_region_boundary <strong class="nn iu">and </strong>x2 &lt; left_region_boundary:<br/>                    left_fit.append((slope, intercept))<br/>            <strong class="nn iu">else</strong>:<br/>                <strong class="nn iu">if </strong>x1 &gt; right_region_boundary <strong class="nn iu">and </strong>x2 &gt; right_region_boundary:<br/>                    right_fit.append((slope, intercept))</span><span id="d9a7" class="ln kq it nn b gy nv ns l nt nu">    left_fit_average = np.average(left_fit, axis=0)<br/>    <strong class="nn iu">if </strong>len(left_fit) &gt; 0:<br/>        lane_lines.append(make_points(frame, left_fit_average))</span><span id="cdf4" class="ln kq it nn b gy nv ns l nt nu">    right_fit_average = np.average(right_fit, axis=0)<br/>    <strong class="nn iu">if </strong>len(right_fit) &gt; 0:<br/>        lane_lines.append(make_points(frame, right_fit_average))</span><span id="6723" class="ln kq it nn b gy nv ns l nt nu">    <strong class="nn iu">return </strong>lane_lines</span></pre><p id="c196" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">make_points()是 average_slope_intercept()函数的辅助函数，它将返回车道线的有界坐标。</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="6015" class="ln kq it nn b gy nr ns l nt nu"><strong class="nn iu">def </strong>make_points(frame, line):<br/>    height, width, _ = frame.shape</span><span id="4f1e" class="ln kq it nn b gy nv ns l nt nu">    slope, intercept = line</span><span id="1e3d" class="ln kq it nn b gy nv ns l nt nu">    y1 = height  <em class="nl"># bottom of the frame<br/>    </em>y2 = int(y1 / 2)  <em class="nl"># make points from middle of the frame down</em></span><span id="6231" class="ln kq it nn b gy nv ns l nt nu"><em class="nl">    </em><strong class="nn iu">if </strong>slope == 0:<br/>        slope = 0.1</span><span id="7f22" class="ln kq it nn b gy nv ns l nt nu">    x1 = int((y1 - intercept) / slope)<br/>    x2 = int((y2 - intercept) / slope)</span><span id="5e52" class="ln kq it nn b gy nv ns l nt nu">    <strong class="nn iu">return </strong>[[x1, y1, x2, y2]]</span></pre><p id="e058" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要在帧上显示车道线，使用以下函数</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="4389" class="ln kq it nn b gy nr ns l nt nu"><strong class="nn iu">def </strong>display_lines(frame, lines, line_color=(0, 255, 0), line_width=6):<br/>    line_image = np.zeros_like(frame)</span><span id="f2fb" class="ln kq it nn b gy nv ns l nt nu">    <strong class="nn iu">if </strong>lines <strong class="nn iu">is not None</strong>:<br/>        <strong class="nn iu">for </strong>line <strong class="nn iu">in </strong>lines:<br/>            <strong class="nn iu">for </strong>x1, y1, x2, y2 <strong class="nn iu">in </strong>line:<br/>                cv2.line(line_image, (x1, y1), (x2, y2), line_color, line_width)</span><span id="7e0c" class="ln kq it nn b gy nv ns l nt nu">    line_image = cv2.addWeighted(frame, 0.8, line_image, 1, 1)</span><span id="6dbc" class="ln kq it nn b gy nv ns l nt nu">    <strong class="nn iu">return </strong>line_image</span></pre><p id="e9c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在将速度应用到我们的电机之前，最重要的步骤是计算转向角。我们需要确保汽车准确地停留在检测到的车道线的中间。我们可能会遇到两种情况:</p><ul class=""><li id="07c7" class="mx my it js b jt ju jx jy kb ob kf oc kj od kn nc nd ne nf bi translated">两条检测到的车道线</li><li id="582a" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">单条检测车道线</li></ul><p id="7d0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">计算航向线是使用三角函数 tan 和 atan(即 tan⁻)。</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="9f44" class="ln kq it nn b gy nr ns l nt nu"><strong class="nn iu">def </strong>get_steering_angle(frame, lane_lines):<br/>    height, width, _ = frame.shape</span><span id="25f2" class="ln kq it nn b gy nv ns l nt nu">    <strong class="nn iu">if </strong>len(lane_lines) == 2:<br/>        _, _, left_x2, _ = lane_lines[0][0]<br/>        _, _, right_x2, _ = lane_lines[1][0]<br/>        mid = int(width / 2)<br/>        x_offset = (left_x2 + right_x2) / 2 - mid<br/>        y_offset = int(height / 2)</span><span id="ca89" class="ln kq it nn b gy nv ns l nt nu">    <strong class="nn iu">elif </strong>len(lane_lines) == 1:<br/>        x1, _, x2, _ = lane_lines[0][0]<br/>        x_offset = x2 - x1<br/>        y_offset = int(height / 2)</span><span id="1626" class="ln kq it nn b gy nv ns l nt nu">    <strong class="nn iu">elif </strong>len(lane_lines) == 0:<br/>        x_offset = 0<br/>        y_offset = int(height / 2)</span><span id="9267" class="ln kq it nn b gy nv ns l nt nu">    angle_to_mid_radian = math.atan(x_offset / y_offset)<br/>    angle_to_mid_deg = int(angle_to_mid_radian * 180.0 / math.pi)<br/>    steering_angle = angle_to_mid_deg + 90<br/>    <em class="nl">#print(steering_angle)</em></span><span id="1e09" class="ln kq it nn b gy nv ns l nt nu"><em class="nl">    </em><strong class="nn iu">return </strong>steering_angle</span></pre><p id="075d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">标题线显示如下。</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="40c6" class="ln kq it nn b gy nr ns l nt nu"><strong class="nn iu">def </strong>display_heading_line(frame, steering_angle, line_color=(0, 0, 255), line_width=5):<br/>    heading_image = np.zeros_like(frame)<br/>    height, width, _ = frame.shape</span><span id="b37d" class="ln kq it nn b gy nv ns l nt nu">    steering_angle_radian = steering_angle / 180.0 * math.pi</span><span id="294e" class="ln kq it nn b gy nv ns l nt nu">    x1 = int(width / 2)<br/>    y1 = height<br/>    x2 = int(x1 - height / 2 / math.tan(steering_angle_radian))<br/>    y2 = int(height / 2)</span><span id="a629" class="ln kq it nn b gy nv ns l nt nu">    cv2.line(heading_image, (x1, y1), (x2, y2), line_color, line_width)<br/>    heading_image = cv2.addWeighted(frame, 0.8, heading_image, 1, 1)</span><span id="f639" class="ln kq it nn b gy nv ns l nt nu">    <strong class="nn iu">return </strong>heading_image</span></pre><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi og"><img src="../Images/931e5fe9365523a3861c26d3c7857b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*WTjUMALNCf4_oGNvgceIIg.png"/></div></figure><h2 id="9e7a" class="ln kq it bd kr lo lp dn kv lq lr dp kz kb ls lt ld kf lu lv lh kj lw lx ll ly bi translated">使用套筒传递转向角度</h2><p id="b661" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">既然我们已经计算了转向角度，我们需要利用这个角度来驾驶我们的汽车。从技术上来说，你可以在 Raspberry Pi 上运行车道检测算法。然而，上述处理对于 Raspberry Pi 来说可能太重，可能会导致延迟。这可能会产生不准确的结果。为了解决这个问题，我们使用我们的笔记本电脑/个人电脑的处理能力，并利用插座。因此，输入相机流(使用 Raspberry Pi 相机模块捕获)从插座到达笔记本电脑/PC，在那里执行上述车道检测和转向角计算。以下代码显示了套接字程序的用法以及如何调用通道检测模块。</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="004e" class="ln kq it nn b gy nr ns l nt nu">ser_soc = socket.socket()<br/>ser_soc.bind((<strong class="nn iu">'192.168.2.11'</strong>, 5500))<br/>ser_soc.listen(2)<br/>conn, address = ser_soc.accept()</span><span id="df05" class="ln kq it nn b gy nv ns l nt nu"><strong class="nn iu">class </strong>VideoStreamingTest(object):<br/>    <strong class="nn iu">def </strong>__init__(self, host, port):</span><span id="2260" class="ln kq it nn b gy nv ns l nt nu">        self.server_socket = socket.socket()<br/>        self.server_socket.bind((host, port))<br/>        self.server_socket.listen(1)<br/>        self.connection, self.client_address = self.server_socket.accept()<br/>        self.connection = self.connection.makefile(<strong class="nn iu">'rb'</strong>)<br/>        self.host_name = socket.gethostname()<br/>        self.host_ip = socket.gethostbyname(self.host_name)<br/>        self.streaming()</span><span id="d81c" class="ln kq it nn b gy nv ns l nt nu">    <strong class="nn iu">def </strong>streaming(self):</span><span id="2f3e" class="ln kq it nn b gy nv ns l nt nu">        <strong class="nn iu">try</strong>:<br/>            print(<strong class="nn iu">"Host: "</strong>, self.host_name + <strong class="nn iu">' ' </strong>+ self.host_ip)<br/>            print(<strong class="nn iu">"Connection from: "</strong>, self.client_address)<br/>            print(<strong class="nn iu">"Streaming..."</strong>)<br/>            print(<strong class="nn iu">"Press 'q' to exit"</strong>)</span><span id="efca" class="ln kq it nn b gy nv ns l nt nu">            <em class="nl"># need bytes here<br/>            </em>stream_bytes = <strong class="nn iu">b' '<br/>            while True</strong>:<br/>                stream_bytes += self.connection.read(1024)<br/>                first = stream_bytes.find(<strong class="nn iu">b'\xff\xd8'</strong>)<br/>                last = stream_bytes.find(<strong class="nn iu">b'\xff\xd9'</strong>)<br/>                <strong class="nn iu">if </strong>first != -1 <strong class="nn iu">and </strong>last != -1:<br/>                    jpg = stream_bytes[first:last + 2]<br/>                    stream_bytes = stream_bytes[last + 2:]<br/>                    frame = cv2.imdecode(np.frombuffer(jpg, dtype=np.uint8), cv2.IMREAD_COLOR)<br/>                    edges = detect_edges(frame)<br/>                    roi = region_of_interest(edges)<br/>                    line_segments = detect_line_segments(roi)<br/>                    lane_lines = average_slope_intercept(frame, line_segments)<br/>                    lane_lines_image = display_lines(frame, lane_lines)<br/>                    steering_angle = get_steering_angle(frame, lane_lines) <em class="nl">#pass value through socket<br/>                    </em>print(steering_angle)<br/>                    server_program(steering_angle)<br/>                    heading_image = display_heading_line(lane_lines_image, steering_angle)<br/>                    cv2.imshow(<strong class="nn iu">"heading line"</strong>, heading_image)</span><span id="f382" class="ln kq it nn b gy nv ns l nt nu">                    <strong class="nn iu">if </strong>cv2.waitKey(1) &amp; 0xFF == ord(<strong class="nn iu">'q'</strong>):<br/>                        <strong class="nn iu">break</strong></span><span id="f939" class="ln kq it nn b gy nv ns l nt nu"><strong class="nn iu">        finally</strong>:<br/>            self.connection.close()<br/>            self.server_socket.close()</span><span id="a449" class="ln kq it nn b gy nv ns l nt nu"><strong class="nn iu">if </strong>__name__ == <strong class="nn iu">'__main__'</strong>:<br/>    <em class="nl"># host, port<br/>    </em>h, p = <strong class="nn iu">"192.168.2.11"</strong>, 8000<br/>    VideoStreamingTest(h, p)</span></pre><p id="aa74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">发送套接字程序如下所述:</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="9ad7" class="ln kq it nn b gy nr ns l nt nu"><strong class="nn iu">def </strong>server_program(data):<br/>    data = str(data)<br/>    conn.send(data.encode())  <em class="nl"># send data to the Raspberry Pi</em></span></pre><p id="36c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在这里了解更多关于套接字编程<a class="ae ko" href="https://docs.python.org/3/library/socket.html" rel="noopener ugc nofollow" target="_blank">的知识。</a></p><p id="7670" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:您的 Raspberry Pi 和笔记本电脑需要连接到同一个网络来传输数据。</p><h1 id="a814" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">驾驶汽车</h1><p id="9bf3" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我们现在需要将 Pi 摄像机捕获的视频流发送到我们的主机。为此，我们将编写以下代码。</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="7e0d" class="ln kq it nn b gy nr ns l nt nu"><strong class="nn iu">import </strong>io<br/><strong class="nn iu">import </strong>socket<br/><strong class="nn iu">import </strong>struct<br/><strong class="nn iu">import </strong>time<br/><strong class="nn iu">import </strong>picamera<br/><br/><em class="nl"># create socket and bind host<br/></em>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>client_socket.connect((<strong class="nn iu">'192.168.2.11'</strong>, 8000))<br/>connection = client_socket.makefile(<strong class="nn iu">'wb'</strong>)<br/><br/><strong class="nn iu">try</strong>:<br/>    <strong class="nn iu">with </strong>picamera.PiCamera() <strong class="nn iu">as </strong>camera:<br/>        camera.resolution = (320, 240)      <em class="nl"># pi camera resolution<br/>        </em>camera.framerate = 15               <em class="nl"># 15 frames/sec<br/>        </em>time.sleep(2)                       <em class="nl"># give 2 secs for camera to initilize<br/>        </em>start = time.time()<br/>        stream = io.BytesIO()<br/>        <br/>        <em class="nl"># send jpeg format video stream<br/>        </em><strong class="nn iu">for </strong>foo <strong class="nn iu">in </strong>camera.capture_continuous(stream, <strong class="nn iu">'jpeg'</strong>, use_video_port = <strong class="nn iu">True</strong>):<br/>            connection.write(struct.pack(<strong class="nn iu">'&lt;L'</strong>, stream.tell()))<br/>            connection.flush()<br/>            stream.seek(0)<br/>            connection.write(stream.read())<br/>            <strong class="nn iu">if </strong>time.time() - start &gt; 600:<br/>                <strong class="nn iu">break<br/>            </strong>stream.seek(0)<br/>            stream.truncate()<br/>            <br/>    connection.write(struct.pack(<strong class="nn iu">'&lt;L'</strong>, 0))<br/>    <br/><br/><br/>    <br/><strong class="nn iu">finally</strong>:<br/>    connection.close()<br/>    client_socket.close()</span></pre><p id="b1df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，一旦我们的初始程序计算出转向角，我们需要接收它来执行一些动作。因此，我们将编写以下代码</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="1e10" class="ln kq it nn b gy nr ns l nt nu"><strong class="nn iu">import </strong>socket<br/><strong class="nn iu">import </strong>math<br/><strong class="nn iu">import </strong>sys<br/><strong class="nn iu">import </strong>time<br/><strong class="nn iu">import </strong>RPi.GPIO <strong class="nn iu">as </strong>GPIO<br/><br/><br/><strong class="nn iu">def </strong>client_program():<br/>    <br/>    cli_soc = socket.socket()  <em class="nl"># instantiate<br/>    </em>cli_soc.connect((<strong class="nn iu">'192.168.2.11'</strong>, 5500))<br/><br/><br/>    <strong class="nn iu">while True</strong>:<br/>        <br/>        data = cli_soc.recv(1024).decode()  <em class="nl"># receive response<br/><br/>        </em>print(<strong class="nn iu">'Received from server: ' </strong>+ data)  <em class="nl"># show in terminal<br/>        <br/>        </em>steering_angle = int(data)<br/><br/>        speed = 20<br/>        lastTime = 0<br/>        lastError = 0<br/>        <br/>        now = time.time()<br/>        dt = now - lastTime<br/><br/>        kp = 0.4<br/>        kd = kp * 0.65<br/><br/><br/>        deviation = steering_angle - 90<br/>        error = abs(deviation)<br/>        <br/>        <strong class="nn iu">if </strong>deviation &lt; 10 <strong class="nn iu">and </strong>deviation &gt; -10:<br/>            deviation = 0<br/>            error = 0<br/>            GPIO.output(in1,GPIO.LOW)<br/>            GPIO.output(in2,GPIO.LOW)<br/>            steering.stop()<br/><br/>        <strong class="nn iu">elif </strong>deviation &gt; 10:<br/>            GPIO.output(in1,GPIO.LOW)<br/>            GPIO.output(in2,GPIO.HIGH)<br/>            steering.start(100)<br/>            <br/><br/>        <strong class="nn iu">elif </strong>deviation &lt; -10:<br/>            GPIO.output(in1,GPIO.HIGH)<br/>            GPIO.output(in2,GPIO.LOW)<br/>            steering.start(100)<br/><br/>        derivative = kd * (error - lastError) / dt<br/>        proportional = kp * error<br/>        PD = int(speed + derivative + proportional)<br/>        spd = abs(PD)<br/>        print(spd)<br/>        <br/>        <strong class="nn iu">if </strong>spd &gt; 35:<br/>            spd = 35<br/>        <br/>        <br/>        throttle.start(spd)<br/><br/>        lastError = error<br/>        lastTime = time.time()<br/><br/>        <br/>    cli_soc.close()  <em class="nl"># close the connection<br/>    <br/><br/>    <br/></em><strong class="nn iu">if </strong>__name__ == <strong class="nn iu">'__main__'</strong>:<br/>    GPIO.setwarnings(<strong class="nn iu">False</strong>)<br/><br/>    <em class="nl">#throttle<br/>    </em>throttlePin = 25 <em class="nl"># Physical pin 22<br/>    </em>in3 = 24 <em class="nl"># physical Pin 16 <br/>    </em>in4 = 23 <em class="nl"># physical Pin 18<br/><br/>    #Steering of front wheels<br/>    </em>steeringPin = 22 <em class="nl"># Physical Pin 15<br/>    </em>in1 = 17 <em class="nl"># Physical Pin 11<br/>    </em>in2 = 27 <em class="nl"># Physical Pin 13<br/><br/><br/>    </em>GPIO.setmode(GPIO.BCM)<br/>    GPIO.setup(in1,GPIO.OUT)<br/>    GPIO.setup(in2,GPIO.OUT)<br/>    GPIO.setup(in3,GPIO.OUT)<br/>    GPIO.setup(in4,GPIO.OUT)<br/><br/>    GPIO.setup(throttlePin,GPIO.OUT)<br/>    GPIO.setup(steeringPin,GPIO.OUT)<br/><br/>    <em class="nl"># Steering<br/>    # in1 = 1 and in2 = 0 -&gt; Left<br/>    </em>GPIO.output(in1,GPIO.LOW)<br/>    GPIO.output(in2,GPIO.LOW)<br/>    steering = GPIO.PWM(steeringPin,1000)<br/>    steering.stop()<br/><br/>    <em class="nl"># Throttle<br/>    # in3 = 1 and in4 = 0 -&gt; Forward<br/>    </em>GPIO.output(in3,GPIO.HIGH)<br/>    GPIO.output(in4,GPIO.LOW)<br/>    throttle = GPIO.PWM(throttlePin,1000)<br/>    throttle.stop()<br/><br/>    client_program()<br/>    <br/>    GPIO.output(in1,GPIO.LOW)<br/>    GPIO.output(in2,GPIO.LOW)<br/>    GPIO.output(in3,GPIO.LOW)<br/>    GPIO.output(in4,GPIO.LOW)<br/>    throttle.stop()<br/>    steering.stop()</span></pre><p id="b9d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，由于我们使用 DC 电机作为转动机构，我们计算了偏差。</p><h1 id="b687" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">执行步骤</h1><p id="4950" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">查看我们的<a class="ae ko" href="https://github.com/Udit-Gavasane/J.A.C.W.I.B" rel="noopener ugc nofollow" target="_blank"> GitHub </a>页面，下载项目并参考执行步骤。</p><h2 id="b159" class="ln kq it bd kr lo lp dn kv lq lr dp kz kb ls lt ld kf lu lv lh kj lw lx ll ly bi translated">怎么开车</h2><ol class=""><li id="e904" class="mx my it js b jt lz jx ma kb mz kf na kj nb kn oh nd ne nf bi translated">连接:使用远程桌面连接将 Raspberry Pi 连接到主机，以通过主机控制 Raspberry Pi。</li><li id="373b" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn oh nd ne nf bi translated">测试:在树莓 Pi 终端执行<code class="fe oi oj ok nn b">test_drive.py</code>程序，检查汽车的油门和方向。</li><li id="fbab" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn oh nd ne nf bi translated">初始化服务器:在主机上，执行<code class="fe oi oj ok nn b">computer_server.py</code>。</li><li id="495b" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn oh nd ne nf bi translated">初始化客户端:在 Raspberry Pi 上同时执行两个客户端程序，分别是<code class="fe oi oj ok nn b">raspi_client_1.py</code>和<code class="fe oi oj ok nn b">raspi_client_2.py</code>。此时，主机将开始根据<code class="fe oi oj ok nn b">raspi_client_2.py</code>从树莓派接收到的视频流计算转向角度，并通过 socket 发送回来，由<code class="fe oi oj ok nn b">raspi_client_1.py</code>客户端接收。</li><li id="eace" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn oh nd ne nf bi translated">自驾在行动:基于转向角度，程序<code class="fe oi oj ok nn b">raspi_client_1.py</code>会给树莓 Pi 的 GPIO 引脚发出指令，让电机运行(电机用来驱动汽车的车轮)。因此，汽车将开始在指定的车道上自主行驶。</li><li id="cf98" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn oh nd ne nf bi translated">自驾在行动:基于转向角度，程序<code class="fe oi oj ok nn b">raspi_client_1.py</code>会给树莓 Pi 的 GPIO 引脚发出指令，让电机运行(电机用来驱动汽车的车轮)。因此，汽车将开始在指定的车道上自主行驶。</li></ol><h1 id="1c6e" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结果</h1><p id="2cd7" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">查看我们的 YouTube 视频，了解自动驾驶汽车的运行情况！</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="ol om l"/></div></figure><h1 id="fa1d" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">未来的工作</h1><p id="57ea" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在写这篇文章的时候，因为新冠肺炎·疫情，我们被封锁了。一旦封锁停止，我们的下一步是在车上安装一个超声波传感器。在这里，我们可以计算汽车和障碍物之间的距离。在此基础上，我们可以调整我们的汽车，使其在检测到障碍物时以某种方式发挥作用。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><blockquote class="ou ov ow"><p id="00eb" class="jq jr nl js b jt ju jv jw jx jy jz ka ox kc kd ke oy kg kh ki oz kk kl km kn im bi translated">非常感谢您完整地阅读我们的文章！这碰巧是我们第一次就自己开发的项目写文章，所以这种体验相当令人兴奋。我们希望你喜欢它，并尝试建立自己的类似的东西。如果您对此有任何疑问，请提出问题，我们将尽力回答您的问题。</p><p id="b135" class="jq jr nl js b jt ju jv jw jx jy jz ka ox kc kd ke oy kg kh ki oz kk kl km kn im bi translated">再次感谢！</p></blockquote></div></div>    
</body>
</html>