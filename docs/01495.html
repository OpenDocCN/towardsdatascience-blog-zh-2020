<html>
<head>
<title>Easy Outlier Detection in Data Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据流中的简单异常检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/easy-outlier-detection-in-data-streams-3089bfefe528?source=collection_archive---------15-----------------------#2020-02-10">https://towardsdatascience.com/easy-outlier-detection-in-data-streams-3089bfefe528?source=collection_archive---------15-----------------------#2020-02-10</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="df76" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">一种在数据流中寻找异常值的简单方法及其 Python 实现</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/8c94bde28f536663becbe560f0308c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zH63bvaRgCtSmdi0PX5upg.png"/></div></div></figure><p id="b35c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi lr translated">在我的上一篇文章中，我已经解释了<a class="ae ma" rel="noopener" target="_blank" href="/introduction-to-streaming-algorithms-b71808de6d29">流算法</a>的概念，并给出了许多如何应用它们的例子。其中之一是计算数据流的滚动平均值，而不保存数据流中的元素。现在，我想扩展这个例子，并向您展示在<em class="mb">异常值检测</em>环境中的另一个流算法用例。</p><p id="e168" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">当我们监控机器的功耗以检测任何异常行为时，就会出现这样的问题。如果我们看到异常值增加(不寻常的观察)，这可能是这台机器的一个默认指标，可能值得检查。</p><h1 id="1a93" class="mc md iu bd me mf mg mh mi mj mk ml mm ka mn kb mo kd mp ke mq kg mr kh ms mt bi translated">定义和示例</h1><p id="911d" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">离群值可以用多种方式定义。在本文中，我们将使用以下定义:</p><blockquote class="mz"><p id="f0d4" class="na nb iu bd nc nd ne nf ng nh ni lq dk translated">如果一个数字数据流中的一个元素不在目前所见元素平均值的 3 个标准偏差之内，则该元素被视为异常值。</p></blockquote><p id="5f34" class="pw-post-body-paragraph kv kw iu kx b ky nj jv la lb nk jy ld le nl lg lh li nm lk ll lm nn lo lp lq in bi translated">这需要举一个小例子。让我们假设我们按这个顺序得到数据 3，2，4，3，5，3，2，10，2，3，1。让我们进一步假设我们<strong class="kx iv">从零</strong>的均值和方差(以及标准偏差)开始，即如果不等于零，第一个元素将总是被视为异常值。</p><p id="d79c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">所以，<strong class="kx iv"> 3 被认为是离群值</strong>，因为<em class="mb"> 3 &gt; 0+3*0。</em>现在我们根据目前看到的元素更新均值和方差，只有数字 3。因此<strong class="kx iv">新均值为 3，方差为 0 </strong>。</p><p id="fc12" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">然后我们看到一个 2。我们有<em class="mb"> 2 &gt; 3+3*0，</em>所以<strong class="kx iv"> 2 也被认为是异常值</strong>。这是有道理的，因为到目前为止我们只看到了一个 3，所以任何其他数字都不符合该模式。<strong class="kx iv">平均值更新为<em class="mb">(3+2)/2 = 2.5</em></strong><em class="mb"/>，方差更新为<em class="mb">((3–2.5)+(2–2.5))/2 = 0.25</em>，这意味着<strong class="kx iv">标准差为 0.5 </strong>。</p><p id="edae" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">现在我们看到一个 4。由于 2.5–3 * 0.5≤4≤2.5+3 * 0.5，因此该数字<strong class="kx iv">不是异常值</strong>(即<em class="mb">正常值</em>)。<strong class="kx iv">平均值更新为(3+2+4)/3=3 </strong>，方差更新为((3–3)+(2–3)+(4–3))/3 = 2/3<strong class="kx iv">，</strong>，因此<strong class="kx iv">标准偏差约为 0.81 </strong>。</p><p id="99ae" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">以下数字 3、5、3 和 2 被认为是正常的<em class="mb">。凭直觉，我们会认为下面的数字 10 又是一个异常值。让我们看看算法是做什么的。此时的平均值约为 3.1，标准偏差约为 1。因为<em class="mb"> 10 &gt; 3.1+3*1 </em>，10 被认为是一个异常值，正如我们所希望的。</em></p><p id="33c3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如果你继续最后 3 个元素，你会看到它们都是正常的。</p><p id="05d3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">问题:</strong>要计算均值和标准差，我们得把目前看到的所有元素都背下来。如果我们有一个每天输出成千上万个元素的系统，这不是一个选项。</p><h1 id="5620" class="mc md iu bd me mf mg mh mi mj mk ml mm ka mn kb mo kd mp ke mq kg mr kh ms mt bi translated"><strong class="ak">拯救流媒体算法</strong></h1><p id="434f" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">解决这个问题的一种方法是使用流算法，该算法在数据流的每个扫描元素之后更新其内部状态。内部状态由迄今为止在任何点看到的所有元素的均值和方差组成，在看到任何元素之前，从均值和方差为零开始。准确的说，让<em class="mb"> mₙ </em>为均值<em class="mb"> vₙ </em>为看到数据流的第<em class="mb"> n </em>个元素后的方差，附加定义<em class="mb"> m₀=v₀=0 </em>。</p><h2 id="30f4" class="no md iu bd me np nq dn mi nr ns dp mm le nt nu mo li nv nw mq lm nx ny ms nz bi translated">计算平均值</h2><p id="4943" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">在我关于<a class="ae ma" rel="noopener" target="_blank" href="/introduction-to-streaming-algorithms-b71808de6d29">流算法</a>的文章中，我们已经看到了如何仅使用旧的平均值、正在扫描的最新元素以及迄今为止看到的元素数量来更新平均值。这意味着我们在任何时候都只需要用这种方法存储<strong class="kx iv">两个</strong>数字，而不是像简单方法那样存储<em class="mb"> n 个</em>。让我再展示一次，将数据流的第<em class="mb"> i </em>个输入元素表示为<em class="mb"> aᵢ: </em></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oa"><img src="../Images/c9e25cd93832e8da8bc46dd49cd4a6a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4smjMY9fmqZOnf8dbg7zQ.png"/></div></div></figure><p id="fb04" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这个公式不难开发，对吗？有了它，我们就有了预期元素大小的基线。现在，我们只需要标准偏差，我们可以将平均值分为异常值和正常数据点。我们通过计算方差，然后求它的平方根来得到标准差。</p><h2 id="90c9" class="no md iu bd me np nq dn mi nr ns dp mm le nt nu mo li nv nw mq lm nx ny ms nz bi translated">计算方差</h2><p id="1209" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">在这种情况下，我们也可以毫不费力地找到一个递归公式。首先，看到<em class="mb"> n </em>个元素后的方差如下所示</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ob"><img src="../Images/52a2533c716cd91cd71832a5964239aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*_G3UBZI8kpTd6C4O_tqCdg.png"/></div></figure><p id="b065" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">让我们试着用<em class="mb"> n </em>、<em class="mb"> vₙ、</em>和最新的元素再写一遍。因为方差取决于平均值，我们也想包括 mₙ.在我们开始之前，让我们重新安排一下这个公式，让事情变得简单一些:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oc"><img src="../Images/49873003cfa4559f5776f602287e3643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*8jLUxnXkoegQHvLJLy-x4A.png"/></div></figure><p id="3c72" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">现在，我们的目标是把 vₙ放进去。一种方法是从下面的简单重排开始，分离平方和，直到索引<em class="mb"> n </em>，它也作为术语出现在<em class="mb"> vₙ </em>中:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj od"><img src="../Images/6b36d169d59d058e31504d6cf12f56b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*V6f7iM0nO5Dk2tooEMnlwg.png"/></div></figure><p id="d9cc" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这相当于</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oe"><img src="../Images/ef8ddd18f7a84670a6a23c384e021775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dSosXLr2kl01AB45ckuisw.png"/></div></div></figure><p id="2615" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这反过来导致</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj of"><img src="../Images/97b7941dcd2cf459dc3056740d4860d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*kMzzYm2Eym-PJm33mZTiSA.png"/></div></div></figure><p id="61c3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">现在，我们有了公式，让我们看看它在 Python 中是如何工作的！</p><h1 id="4ce6" class="mc md iu bd me mf mg mh mi mj mk ml mm ka mn kb mo kd mp ke mq kg mr kh ms mt bi translated">用 Python 实现</h1><p id="62d1" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">我们可以通过以下方式实现上述解释:</p><pre class="kk kl km kn gu og oh oi bn oj ok bi"><span id="1590" class="ol md iu oh b be om on l oo op">class StreamingMeanAndVariance:<br/>    def __init__(self):<br/>        self.mean = 0<br/>        self.variance = 0<br/>        self.n_elements = 0<br/><br/>    def update(self, element):<br/>        self.variance = ((self.variance + self.mean ** 2) * self.n_elements + element ** 2) / (self.n_elements + 1)<br/>        self.mean = ((self.mean * self.n_elements) + element) / (self.n_elements + 1)<br/>        self.variance = self.variance - self.mean ** 2<br/>        self.n_elements += 1</span></pre><p id="87f7" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">注意:<code class="fe oq or os oh b">update</code>方法的第一行计算方差，但是<strong class="kx iv">没有减去当前的均方值。</strong>第二行，计算当前平均值。在第三行中，从方差中减去它，因为它在第一行中仍然缺失。</p><p id="be4a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">为了使用它，我们做到了</p><pre class="kk kl km kn gu og oh oi bn oj ok bi"><span id="5a7c" class="ol md iu oh b be om on l oo op">import numpy as np<br/><br/>m = StreamingMeanAndVariance()<br/>n = 10000<br/><br/>for i, s in enumerate(np.random.randn(n)):<br/>    if not - 3 &lt;= (s - m.mean) / np.sqrt(m.variance) &lt;= 3:<br/>        print(i, s)<br/>    m.update(s)</span></pre><p id="fb52" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这将扫描数据流，该数据流在本例中由 10000 个正态分布的数字组成(我们将其表示为<strong class="kx iv"> <em class="mb"> N </em> (0，1) </strong>)，并在异常值出现时打印出来。</p><p id="c5b7" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如果您将正常点的间隔与平均值(黄色)一起绘制，您将得到下图:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/6f099962111c739cebbba0e517858bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ii7YjVQmcZGcsz9FMQRmbw.png"/></div></div><p class="ot ou gk gi gj ov ow bd b be z dk translated">用蓝色，你可以看到测量结果。绿色区域包含正常点，其外的测量值(以红色表示)被视为异常值。在黄色部分，您可以看到期望值(平均值)。</p></figure><h1 id="8a33" class="mc md iu bd me mf mg mh mi mj mk ml mm ka mn kb mo kd mp ke mq kg mr kh ms mt bi translated">讨论</h1><p id="6ab9" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">算法做了我们期待的事情！然而，到目前为止，我们没有看到它是如何处理分布的变化的，而只是在任何时候都是标准的正态分布的数字。</p><p id="6241" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">让我们测试算法在执行以下操作时的表现:</p><ul class=""><li id="fa91" class="ox oy iu kx b ky kz lb lc le oz li pa lm pb lq pc pd pe pf bi translated">经过 10%的观察，我们将分布从<em class="mb"> N </em> (0，1)转移到<em class="mb"> N </em> (2，1)</li><li id="192c" class="ox oy iu kx b ky pg lb ph le pi li pj lm pk lq pc pd pe pf bi translated">在另一个 40%之后，我们将分布从<em class="mb"> N </em> (2，1)转移到<em class="mb"> N </em> (-2，1)</li></ul><p id="3571" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">结果看起来像这样:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/058ae836c818edf0fbcf17090f8ccac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edQdw_VELnzMiT4zRKJ8qg.png"/></div></div><p class="ot ou gk gi gj ov ow bd b be z dk translated">一切都在慢慢适应新数据。</p></figure><h2 id="fa45" class="no md iu bd me np nq dn mi nr ns dp mm le nt nu mo li nv nw mq lm nx ny ms nz bi translated">好人</h2><p id="ac52" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">这看起来很有希望！一切都会自动适应新数据。当数据的均值从 0 转移到 2 时，我们可以看到许多异常值，这是有意义的。新平均值 2 的观测值越多，检测到的异常值就越少，因为大约 2 <em class="mb">是新的常态</em>。</p><p id="e0e7" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">当将平均值从 2 改为-2 时，我们可以看到更多的异常值，因为变化要严重得多。到目前为止，一切顺利。</p><h2 id="661c" class="no md iu bd me np nq dn mi nr ns dp mm le nt nu mo li nv nw mq lm nx ny ms nz bi translated">坏事</h2><p id="7404" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">如果你看图的右半部分，你可以看到对新数据的适应相当缓慢。一段时间后，平均值和标准差将再次达到正确水平，正如您所看到的，因为黄线(平均值)下降，绿色区域也再次变窄。但是直到它变平，没有异常值被检测到。</p></div><div class="ab cl pl pm hy pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="in io ip iq ir"><p id="0643" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">为了解决这个问题，我们只能使用最后的<em class="mb"> k 个</em>样本来计算平均值和标准偏差，因为这打破了第一次测量的影响。如果我们将 k 设为无穷大，我们就可以得到之前的算法。</p><p id="bfed" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我们设定的<em class="mb"> k </em>越低，算法适应新数据的速度就越快。然而，将<em class="mb"> k </em>设置得过小可能会导致丢弃异常值，因为算法认为新数据<em class="mb">就像这个</em>。在设置<em class="mb"> k=1 的极端情况下，</em>没有元素被认为是异常值，因为只考虑最新的元素。</p><p id="64e8" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">根据不同的使用情况，也许几百或几千应该没问题。</p><h1 id="5002" class="mc md iu bd me mf mg mh mi mj mk ml mm ka mn kb mo kd mp ke mq kg mr kh ms mt bi translated">结论</h1><p id="787a" class="pw-post-body-paragraph kv kw iu kx b ky mu jv la lb mv jy ld le mw lg lh li mx lk ll lm my lo lp lq in bi translated">在本文中，我们看到了如何为数据流构建一个非常简单的异常检测机制。我们的算法不需要存储所有的测量值，这使得它非常容易应用，也可以在极其有限的硬件上应用，并且只需要恒定的存储。该算法甚至可以适应数据的变化，因此无需手动更新。</p><p id="a5f3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">唯一需要调整的是适应率，我们在本文中没有涉及到，但这是一件容易的事情。</p></div><div class="ab cl pl pm hy pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="in io ip iq ir"><p id="62cf" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我希望你今天学到了新的、有趣的、有用的东西。感谢阅读！</p><p id="45ee" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">作为最后一点，如果你</strong></p><ol class=""><li id="ca1e" class="ox oy iu kx b ky kz lb lc le oz li pa lm pb lq ps pd pe pf bi translated"><strong class="kx iv">想支持我多写点机器学习和</strong></li><li id="5330" class="ox oy iu kx b ky pg lb ph le pi li pj lm pk lq ps pd pe pf bi translated"><strong class="kx iv">无论如何都计划获得一个中等订阅，</strong></li></ol><p id="d34f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">为什么不做</strong> <a class="ae ma" href="https://dr-robert-kuebler.medium.com/membership" rel="noopener"> <strong class="kx iv">通过这个环节</strong> </a> <strong class="kx iv">？这将对我帮助很大！😊</strong></p><p id="5557" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><em class="mb">说白了，给你的价格不变，但大约一半的订阅费直接归我。</em></p><p id="dca3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">非常感谢，如果你考虑支持我的话！</p><blockquote class="mz"><p id="b6d0" class="na nb iu bd nc nd ne nf ng nh ni lq dk translated"><em class="pt">如有问题，在</em><a class="ae ma" href="https://www.linkedin.com/in/dr-robert-k%C3%BCbler-983859150/" rel="noopener ugc nofollow" target="_blank"><em class="pt">LinkedIn</em></a><em class="pt">上写我！</em></p></blockquote></div></div>    
</body>
</html>