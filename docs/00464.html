<html>
<head>
<title>Download Email Attachment from Microsoft Exchange Web Services Automatically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动从 Microsoft Exchange Web 服务下载电子邮件附件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/download-email-attachment-from-microsoft-exchange-web-services-automatically-9e20770f90ea?source=collection_archive---------10-----------------------#2020-01-14">https://towardsdatascience.com/download-email-attachment-from-microsoft-exchange-web-services-automatically-9e20770f90ea?source=collection_archive---------10-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5918" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">用 Python 自动化枯燥的程序</h2><div class=""/><div class=""><h2 id="b5b1" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">学习使用 Python 库 Exchangelib 处理电子邮件附件</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/42f8d4935ffc1291b603c75496d8977f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vDEQm9PgUV4Q_Npo"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@webaroo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Webaroo.com.au</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="8e20" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">介绍</h1><p id="390f" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">您需要定期下载电子邮件附件吗？你想让这个无聊的过程自动化吗？我知道那种感觉，兄弟。刚来工作的时候，我被分配了一个日常任务:每天从发给我们团队的邮件里下载附呈的报告。这不是一个困难的任务，但它非常无聊，我经常忘记这样做。</p><blockquote class="mw"><p id="11d7" class="mx my it bd mz na nb nc nd ne nf mv dk translated">我怎样才能摆脱这个虚拟任务:定期下载电子邮件附件。</p></blockquote><p id="abcf" class="pw-post-body-paragraph ma mb it mc b md ng kd mf mg nh kg mi mj ni ml mm mn nj mp mq mr nk mt mu mv im bi translated">在研究了互联网之后，我发现一个小小的 Python 脚本可以接管我的工作。让我们来探索一下 Python 能帮到我们什么。</p><h1 id="1231" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">Exchangelib</h1><p id="25cf" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">Exchangelib 是一个 Python 库，它提供了一个简单的接口，允许 Python 脚本与 Microsoft Exchange 或 Exchange Web 服务(EWS)进行交互</p><div class="nl nm gp gr nn no"><a href="https://github.com/nylas/exchangelib" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd jd gy z fp nt fr fs nu fu fw jc bi translated">nylas/exchangelib</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">该模块提供了一个性能良好、行为良好、独立于平台的简单接口，用于通信…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc lb no"/></div></div></a></div><p id="8551" class="pw-post-body-paragraph ma mb it mc b md od kd mf mg oe kg mi mj of ml mm mn og mp mq mr oh mt mu mv im bi translated">您可以从 PyPI 安装这个包:</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="68fd" class="on lj it oj b gy oo op l oq or">pip install exchangelib</span></pre><p id="d566" class="pw-post-body-paragraph ma mb it mc b md od kd mf mg oe kg mi mj of ml mm mn og mp mq mr oh mt mu mv im bi translated">然后按照官方网站的说明导入包。你可能不会全部用到，</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="a45b" class="on lj it oj b gy oo op l oq or">#import pytz</span><span id="e1b0" class="on lj it oj b gy os op l oq or">from exchangelib import DELEGATE, IMPERSONATION, Account, Credentials, ServiceAccount, EWSDateTime, EWSTimeZone, Configuration, NTLM, GSSAPI, CalendarItem, Message, Mailbox, Attendee, Q, ExtendedProperty, FileAttachment, ItemAttachment, HTMLBody, Build, Version, FolderCollection</span></pre><p id="0a07" class="pw-post-body-paragraph ma mb it mc b md od kd mf mg oe kg mi mj of ml mm mn og mp mq mr oh mt mu mv im bi translated">下一步是指定您的凭证，即登录用户名和密码</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="9042" class="on lj it oj b gy oo op l oq or">credentials = Credentials(<a class="ae lh" href="mailto:username='john@example.com" rel="noopener ugc nofollow" target="_blank">username='john@example.com</a>', password='topsecret')</span></pre><h1 id="cc0e" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">邮件服务器配置</h1><p id="b6a2" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">当然，您必须配置邮件服务器。Exchangelib 应该能够识别您的电子邮件服务器使用的身份验证类型，但是在我的例子中，它失败了，我将身份验证类型指定为 NTLM。</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="9cca" class="on lj it oj b gy oo op l oq or">ews_url = 'mail.example.com'<br/>ews_auth_type = 'NTLM'<br/>primary_smtp_address = 'john@example.com'</span><span id="3c90" class="on lj it oj b gy os op l oq or">config = Configuration(service_endpoint=ews_url, credentials=credentials, auth_type=ews_auth_type)</span><span id="0357" class="on lj it oj b gy os op l oq or"># An Account is the account on the Exchange server that you want to connect to.</span><span id="3029" class="on lj it oj b gy os op l oq or">account = Account(<br/>primary_smtp_address=primary_smtp_address,<br/>config=config, autodiscover=False,<br/>access_type=DELEGATE)</span></pre><h1 id="aa1c" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">从文件夹下载附件</h1><p id="fac3" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在您有了一个 Account 对象，您可以在其中导航。它只是遵循你的电子邮件帐户文件夹结构。比如你想对收件箱文件夹进行操作，就用这个简单的语法:<code class="fe ot ou ov oj b">account.inbox</code>。要操作收件箱里面的一个文件夹，只需要像这样放一个反斜杠和单引号:<code class="fe ot ou ov oj b">account.inbox / 'some_folder'</code>。</p><p id="e3d2" class="pw-post-body-paragraph ma mb it mc b md od kd mf mg oe kg mi mj of ml mm mn og mp mq mr oh mt mu mv im bi translated">如果您只想下载一个文件夹中的所有附件，这个短代码会有所帮助。您可能需要<code class="fe ot ou ov oj b">os</code>包来处理本地目录。</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="b32c" class="on lj it oj b gy oo op l oq or">some_folder = account.inbox / 'some_folder'</span><span id="1d7f" class="on lj it oj b gy os op l oq or">for item in some_folder.all():<br/>    for attachment in item.attachments:<br/>        if isinstance(attachment, FileAttachment):<br/>            local_path = os.path.join(local_path, attachment.name)<br/>            with open(local_path, 'wb') as f:<br/>                f.write(attachment.content)</span></pre><blockquote class="mw"><p id="575a" class="mx my it bd mz na ow ox oy oz pa mv dk translated">就是这样！</p></blockquote><h1 id="0b1f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki pb kj lu kl pc km lw ko pd kp ly lz bi translated">奖金部分</h1><p id="a451" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">如果我只想下载我以前没有下载过的文件，我可以进一步做什么？我需要一种机制来检查附件是否存在于本地。</p><p id="c4a4" class="pw-post-body-paragraph ma mb it mc b md od kd mf mg oe kg mi mj of ml mm mn og mp mq mr oh mt mu mv im bi translated">我们的团队使用 FTP 服务器来存储所有附加的报告。因此，在我的 Python 脚本中，首先，我登录到 FTP 服务器并列出所有带有指定前缀的文件。在脚本中添加了一项检查，以确定该文件是否存在于当前文件列表中。</p><p id="e19e" class="pw-post-body-paragraph ma mb it mc b md od kd mf mg oe kg mi mj of ml mm mn og mp mq mr oh mt mu mv im bi translated">为此，我使用了 ftplib，这是一个 FTP 协议客户端库。</p><div class="nl nm gp gr nn no"><a href="https://docs.python.org/3/library/ftplib.html" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd jd gy z fp nt fr fs nu fu fw jc bi translated">ftplib — FTP 协议客户端— Python 3.8.1 文档</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">源代码:Lib/ftplib.py 这个模块定义了类和一些相关的项。该类实现了客户端…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">docs.python.org</p></div></div></div></a></div><p id="9199" class="pw-post-body-paragraph ma mb it mc b md od kd mf mg oe kg mi mj of ml mm mn og mp mq mr oh mt mu mv im bi translated">以下代码登录到 FTP 服务器(<code class="fe ot ou ov oj b">ftp.login()</code>)，导航到目标文件夹(<code class="fe ot ou ov oj b">ftp.cwd()</code>)并列出所有匹配指定前缀(<code class="fe ot ou ov oj b">file.startswith()</code>)的文件(<code class="fe ot ou ov oj b">ftp.nlst()</code>)</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="4e0a" class="on lj it oj b gy oo op l oq or">from ftplib import FTP</span><span id="673c" class="on lj it oj b gy os op l oq or">ftp_server_ip = FTP_SERVER_IP<br/>username = 'username'<br/>password = 'password'<br/>remote_path = 'remote_path'<br/>local_path = 'local_path'</span><span id="abc5" class="on lj it oj b gy os op l oq or">with FTP(ftp_server_ip) as ftp:<br/>    ftp.login(user=username, passwd=password)<br/>    ftp.cwd(remote_path + '/copied data')<br/>    filelist = [file for file in ftp.nlst() if file.startswith('YOUR_FILE_PREFIX')]</span></pre><p id="910b" class="pw-post-body-paragraph ma mb it mc b md od kd mf mg oe kg mi mj of ml mm mn og mp mq mr oh mt mu mv im bi translated">在本地下载附件后，我将文件上传到 FTP 服务器。我用<code class="fe ot ou ov oj b">storbinary</code>向 STOR 发送上传附件的命令。</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="69ba" class="on lj it oj b gy oo op l oq or">if attachment.name not in filelist:<br/># Check if the attachment downloaded before<br/>    local_path = os.path.join(local_path, attachment.name)<br/>    with open(local_path, 'wb') as f:<br/>        f.write(attachment.content)</span><span id="c8f4" class="on lj it oj b gy os op l oq or">with FTP(ftp_server_ip) as ftp:<br/>    ftp.login(user=username, passwd=password)<br/>    ftp.cwd(remote_path)<br/>    file = open(local_path, 'rb')<br/>    ftp.storbinary('STOR {}'.format(attachment.name), file)<br/>    file.close()</span></pre><h1 id="9b87" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">结论</h1><p id="ca1f" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我使用一个简单的 Python 脚本自动完成了这个日常工作，该脚本可以定期运行。该脚本自动化了从邮件服务器下载丢失的附件并将它们上传到 FTP 服务器的工作流。</p></div></div>    
</body>
</html>