# 对 Clojure 的温和介绍

> 原文：<https://towardsdatascience.com/a-gentle-intro-to-clojure-ad6c6802babe?source=collection_archive---------25----------------------->

## 一个小的真实世界的例子；探索 GitHub repos

![](img/3383786d4252d43f7bd257cfbf0c002f.png)

照片由 [Arian Darvishi](https://unsplash.com/@arianismmm?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

# 这个计划

我们将使用 [HttpKit](http://http-kit.github.io/) 来访问 GitHub API，并获取关于一个组织的存储库的信息。然后，我们将利用 Clojure 的内置特性来操作和探索集合。现在，我们不会尝试任何异步或复杂的东西——我们可以把它留到以后的文章中:)

# 入门指南

在某个新目录中，我创建了一个`deps.edn`文件，具有以下依赖关系:

然后我们可以在与`deps.edn`文件相同的目录下启动一个`clj` REPL:

```
**❯** cljClojure 1.10.1user=>
```

并要求(粘贴)我们在 REPL 的属地:

## 快速地图提醒

map 中的键也是函数，它允许我们非常简洁地从 map 中访问键值。假设我们用`:error`和`:status`属性定义了一个名为`test-map`的地图。我们可以像这样访问属性`:status`:

# 提出 API 请求

> 👋生成个人访问令牌来使用 API 是最容易的。

此时，最好尝试访问 GitHub API，以确保我们的身份验证和 URL 是正确的。将下面的`def's`调整为您自己的信息/设置，并将其粘贴到 REPL 中:

## 承诺

HttpKit `(http/get)`函数返回一个承诺。一旦完成，这个承诺将解析为一张地图。我们可以使用@ symbol: `@(http/get .. ..)`进行阻塞，直到这个承诺完成。一旦完成，我们就可以访问各种键值，比如`:status`，应该是 200:

## 头球

GitHub 有一个很好的分页模型，我们将利用它来告诉我们是否需要发出更多的请求。如果我们查看响应头，有一个名为`link`的属性，它包含一个逗号分隔的链接数组以及它们相对于当前页面的位置。我们可以通过`get-in`函数从响应图中访问它。然后，如果链接字符串包含`rel="next"`，我们可以判断是否有下一页要获取:

我们现在可以创建一个`get-repos`函数来将上述所有内容放在一起。它需要两个参数；`page`和`per_page` —当前页码和每页返回的库数量，分别为:

> ⚠️:到目前为止，GitHub API 的最大值是 100。

注意，我们的`get-repos`函数返回一个包含响应`:body`的映射，作为一个解析的 json **数组**和`:has_next`作为一个**布尔值**。

# 循环浏览 GitHub 页面

我们有发出请求和检索 GitHub 库的所有小逻辑。接下来，我们需要遍历所有页面的数据，并将回购添加到一个不断增长的列表中。

## 快速循环提醒

Clojure 中的循环要么很棒，要么是一场灾难，这取决于您的背景。让我们从一个简单的循环开始。这里我们将`i`绑定到`0`，只有在`i < 5`时才调用`recur`。当我们调用`recur`时，我们将`i`绑定到`i + 1`的值，从而递增`i`并打印其值:

上述表达式的值就是`loop`函数最后返回的值。这种情况下，`5`。如果我们将这个表达式设置为一个`def`，我们将把那个`def`的值设置为`5`:

## 循环浏览页面

我们可以快速检查自己，以确保在请求一个存储库后有更多的页面。

> 👋请确保您的组织有多个存储库！😅

请注意下面我们有多个字母绑定。首先，`resp`被设置为表达式`(get-repos 1 1)`的结果，然后`has_next`将访问新设置的`resp`变量，所有这些都在同一行代码中:

我们可以将上述内容与一些循环逻辑结合起来，以获取所有存储库。我将所有存储库放在一个名为`repos`的全局列表中:

> 我知道我的组织中有 200 多个存储库，所以我将变量`per_page`设置为最大值 100。

运行一个快速检查以确保存储库的数量与您预期的相匹配:

```
(println (count @repos))
; => 233
```

太好了！我们所有的库都在一个全局原子列表中。我们现在可以按照我们认为合适的方式对数据进行分割。

## 过滤

让我们试试看有多少回购处于活动状态，即没有`archived`。我们可以使用 Clojure 的`filter`和一个匿名函数来实现这一点。匿名函数接受一个存储库映射作为输入，并检查`:archived`属性是否为假:

我们做到了！`active-repos`包含属性`:archived`等于`false`的存储库。

我希望这是进入 Clojure 的一个有用的方法！我们利用一个库来发出 http 请求，然后利用核心语言特性来进行一些基本的循环、过滤、多 let 和状态管理。