<html>
<head>
<title>Query Smarter, Not Harder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更智能的查询，而不是更难</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-subqueries-f2c490bf772c?source=collection_archive---------65-----------------------#2020-06-01">https://towardsdatascience.com/sql-subqueries-f2c490bf772c?source=collection_archive---------65-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b728" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用子查询实现子查询</h2></div><p id="376c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论在哪个行业，关系数据库都是最常见的数据存储类型之一。使用SQL(以任何形式)创建查询是访问数据的一种非常有效和容易的方法，但有时会有点混乱。查询可能会变得非常复杂，需要多种方法来正确获取正确的数据。当查询开始变长并变得复杂时，子查询是一种非常有用的方法，可以用更容易理解的方式对查询进行分段。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/621245fd2f6fedc229a44e28db989eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lbGKGnZ5v7BxPsQwxpBkCw.png"/></div></div></figure><p id="0968" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们上面的表模式显示了一个有点复杂，但绝对不罕见的数据库。</p><h1 id="3489" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">标准连接</strong></h1><p id="4cdc" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">我们将从一个常规查询开始，该查询将返回在该公司美国办公室工作的所有雇员。</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="96cf" class="ms lr it mo b gy mt mu l mv mw"># Establish an sqlite3 connection to our database<br/>conn = sqlite3.Connection('data.sqlite')</span><span id="18bd" class="ms lr it mo b gy mx mu l mv mw"># Establish a connection cursor for building our query<br/>cur = conn.cursor()</span><span id="c4b6" class="ms lr it mo b gy mx mu l mv mw"># Use the cursor's execute method to execute the query<br/>cur.execute("""SELECT lastName, firstName, officeCode<br/>               FROM employees e<br/>               JOIN offices o<br/>               USING(officeCode)<br/>               WHERE country = "USA";<br/>             """)</span><span id="aa4d" class="ms lr it mo b gy mx mu l mv mw"># Wrap our cursor in a pandas DataFrame<br/>df = pd.DataFrame(cur.fetchall())</span><span id="7eae" class="ms lr it mo b gy mx mu l mv mw"># Utilize the cursor's description attribute to add corresponding<br/># column titles to our DataFrame<br/>df.columns = [x[0] for x in cur.description]</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi my"><img src="../Images/ce481de5343188dd37a6f2a8c3331371.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*Za88D5be-2z2gdRKqU4mYw.png"/></div></figure><p id="63a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的数据帧返回到上面的样子。我们使用简单的多对多连接，使用officeCode作为我们的键。这是一个非常简单的查询，但是有时在大型表模式中使用连接和主键/外键会造成混乱。现在让我们来看看如何使用子查询以一种不同且更简单的方式编写这个查询。</p><h1 id="4232" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">使用子查询</h1><p id="ae1b" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">子查询本质上只是查询中的一个查询。我们将执行一个查询语句，该语句的条件依赖于一个完全独立的查询。听起来有点混乱，所以让我们看看我们在谈论什么。</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="c398" class="ms lr it mo b gy mt mu l mv mw">cur.execute("""SELECT lastName, firstName, officeCode<br/>               FROM employees<br/>               WHERE officeCode IN (SELECT officeCode<br/>                                    FROM offices <br/>                                    WHERE country = "USA");<br/>                                    """)</span><span id="27e1" class="ms lr it mo b gy mx mu l mv mw">df = pd.DataFrame(cur.fetchall())<br/>df.columns = [x[0] for x in cur.description]<br/>df</span></pre><p id="7ab8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哒哒！该查询将输出与前面代码中相同的数据帧。我们只是从子查询中创建的初始表中选择要素，而不是连接到新表。让我们尝试一个稍微复杂一点的问题。</p><p id="2c5f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">编写一个查询，返回雇员超过5人的办公室的所有雇员。</strong></p><p id="7932" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个特别困难的查询，因为它要求我们返回一个基于聚合条件的查询<strong class="kk iu">，但是我们实际上并不返回聚合本身。我们需要创建一个条件，只选择符合该条件的员工。通常，我们使用“HAVING”或“GROUP BY”语句来检索聚合数据，但在这种情况下，我们希望对聚合进行过滤。这种情况正是子查询真正发挥作用的地方。</strong></p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="bfb1" class="ms lr it mo b gy mt mu l mv mw">cur.execute("""SELECT lastName, firstName, officeCode<br/>               FROM employees<br/>               WHERE officeCode IN (SELECT officeCode <br/>                                    FROM offices <br/>                                    JOIN employees<br/>                                    USING(officeCode)<br/>                                    GROUP BY 1<br/>                                    HAVING COUNT(employeeNumber)&gt;5);<br/>                                    """)<br/>df = pd.DataFrame(cur.fetchall())<br/>df.columns = [x[0] for x in cur.description]<br/>df.head(10)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/2df6af32945c57aa3e27d1df1c2cc102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*8KSVZeI6eIaTPA9orgSlMw.png"/></div></figure><p id="be7b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，我们首先嵌套了一个包含条件语句的初始查询:“HAVING COUNT(employeeNumber) &gt; 5”。光标暂时使这个新执行的内部查询成为新表，然后我们可以为我们的答案选择必要的特性。当我开始使用SQL时，帮助我理解这个过程的一个小技巧是首先从内部查询开始，包含我们的条件，然后从那里开始。</p><h1 id="255a" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">汇总数据的子查询</strong></h1><p id="b0a3" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">在上一个查询中，我们选择了基于 <strong class="kk iu">的<strong class="kk iu">聚合条件，但是如果我们想要返回一个聚合函数结果呢？</strong></strong></p><p id="b698" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编写一个查询，返回所有客户的平均付款额。</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="6999" class="ms lr it mo b gy mt mu l mv mw">cur.execute("""SELECT AVG(customerAvgPayment) AS averagePayment<br/>               FROM (SELECT AVG(amount) AS customerAvgPayment<br/>                     FROM payments<br/>                     JOIN customers USING(customerNumber)<br/>                     GROUP BY customerNumber);""")<br/>df = pd.DataFrame(cur.fetchall())<br/>df.columns = [x[0] for x in cur.description]<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d7303a825ca0ade08e446019fa503305.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*sbljPAH36IPmQMbkosda3A.png"/></div></figure><p id="4378" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们实际上使用子查询来定义数学聚合函数。聚合函数“AVG(amount)AS customerAvgPayment”有别名，最初在嵌套语句中执行。剩下要做的就是选择聚合函数作为它自己的变量，瞧！</p><h1 id="b3b1" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">收尾</strong></h1><p id="5579" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">对于编码和SQL来说，从来没有一种单一的方式来获得输出。编写查询和子查询的方法有很多，对于我来说，这是掌握SQL事件流的一个很好的方法。</p></div></div>    
</body>
</html>