<html>
<head>
<title>10 Minutes to Building a Binary Image Classifier By Applying Transfer Learning to MobileNet in TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过在 TensorFlow 中将迁移学习应用到 MobileNet，用 10 分钟时间构建一个二值图像分类器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-minutes-to-building-a-binary-image-classifier-by-applying-transfer-learning-to-mobilenet-eab5a8719525?source=collection_archive---------30-----------------------#2020-07-13">https://towardsdatascience.com/10-minutes-to-building-a-binary-image-classifier-by-applying-transfer-learning-to-mobilenet-eab5a8719525?source=collection_archive---------30-----------------------#2020-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/489b56d485edd0d8c0a6819e9dc52621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v2iz0qbvD02T7Dbd"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">莎拉·多维勒在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="e6c7" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">如何通过在 MobileNet 模型上训练来构建二值图像分类器</h2></div><p id="2f5a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是对计算机视觉的简短介绍，即如何在 MobileNet 模型上使用转移学习来构建二值图像分类器，主要面向新用户。这份简单易懂的教程分为 3 个部分:</p><ol class=""><li id="fdb5" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">数据</li><li id="4f1b" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">模型架构</li><li id="45a3" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">准确性、ROC 曲线和 AUC</li></ol><p id="e10d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要求:没事！按照本教程，你所需要的就是这个包含数据和代码的<a class="ae jd" href="https://colab.research.google.com/drive/1XYAXOHiXNWqmKedCj1WRcJ6mGpr4aVC0?usp=sharing" rel="noopener ugc nofollow" target="_blank"> Google Colab 笔记本</a>。Google Colab 允许您在浏览器中编写和运行 Python 代码，无需任何设置，并且包括免费的 GPU 访问！要运行此代码，只需转到<code class="fe mf mg mh mi b">File -&gt; Make a copy</code>创建一个您可以运行和编辑的笔记本副本。</p><h1 id="3fde" class="mj mk jg bd ml mm mn mo mp mq mr ms mt km mu kn mv kp mw kq mx ks my kt mz na bi translated">1.数据</h1><p id="b5ac" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">我们将建立一个蒲公英和草的图像分类器。我已经使用 Google Images 中的图片创建了一个小的图片数据集，您可以在本教程的前 8 个单元格中下载并解析它。</p><p id="70a2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这 8 行结束时，可视化图像数据集的样本将如下所示:</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/e7a94798816fd3e76c66fefde0f22c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k79tPkr1PppKp2yuoD-VvA.png"/></div></div></figure><p id="7a89" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，数据集中的一些图像并不是草地或蒲公英的完美代表。为了简单起见，让我们把它做好，然后继续讨论如何轻松地创建我们的训练和验证数据集。</p><p id="aa0c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们之前获取的数据被分成两个文件夹，<code class="fe mf mg mh mi b">train</code>和<code class="fe mf mg mh mi b">valid</code>。在这些文件夹中，文件夹<code class="fe mf mg mh mi b">dandelion</code>和<code class="fe mf mg mh mi b">grass</code>包含每个班级的图像。为了创建数据集，让我们使用<code class="fe mf mg mh mi b">keras.preprocessing.image.ImageDataGenerator</code>类来创建我们的训练和验证数据集，并规范化我们的数据。这个类所做的是创建一个数据集，并自动为我们做标记，允许我们只用一行就创建一个数据集！</p><h1 id="63f4" class="mj mk jg bd ml mm mn mo mp mq mr ms mt km mu kn mv kp mw kq mx ks my kt mz na bi translated">2.模型架构</h1><p id="3363" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">在本节的开始，我们首先导入 TensorFlow。</p><p id="6590" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们添加 MobileNet 模型。请确保包含 include_top 参数，并将设置为 False。这将减去模型的最后一层，以便我们可以添加我们自己的层，我们将在其上训练。这叫迁移学习！然后，我们将添加一个 GlobalAveragePooling2D 层，以减少我们将输入到最后一层的输出的大小。对于最后一层，我们将添加一个 Sigmoid 层用于二进制分类。这一点很重要:我们必须将 MobileNet 层的可训练参数设置为 False，这样我们就不会训练整个模型——我们只需要训练最后一层！</p><p id="5669" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我们建立的模型:</p><pre class="nh ni nj nk gt nl mi nm nn aw no bi"><span id="6663" class="np mk jg mi b gy nq nr l ns nt">model = Sequential()</span><span id="151c" class="np mk jg mi b gy nu nr l ns nt">model.add(MobileNetV2(include_top = False, weights="imagenet", input_shape=(200, 200, 3)))</span><span id="1062" class="np mk jg mi b gy nu nr l ns nt">model.add(tf.keras.layers.GlobalAveragePooling2D())</span><span id="ba7f" class="np mk jg mi b gy nu nr l ns nt">model.add(Dense(1, activation = 'sigmoid'))</span><span id="15fb" class="np mk jg mi b gy nu nr l ns nt">model.layers[0].trainable = False</span></pre><p id="ae5c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看我们构建的模型的摘要:</p><pre class="nh ni nj nk gt nl mi nm nn aw no bi"><span id="2bf7" class="np mk jg mi b gy nq nr l ns nt">Model: "sequential" _________________________________________________________________ Layer (type)                 Output Shape              Param #    ================================================================= mobilenetv2_1.00_224 (Model) (None, 7, 7, 1280)        2257984    _________________________________________________________________ global_average_pooling2d (Gl (None, 1280)              0          _________________________________________________________________ dense (Dense)                (None, 1)                 1281       ================================================================= Total params: 2,259,265 Trainable params: 1,281 Non-trainable params: 2,257,984</span></pre><p id="9e59" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将配置模型训练的规范。我们将用<code class="fe mf mg mh mi b">binary_crossentropy</code>损失来训练我们的模型。我们将使用<code class="fe mf mg mh mi b">RMSProp</code>优化器。<a class="ae jd" href="https://wikipedia.org/wiki/Stochastic_gradient_descent#RMSProp" rel="noopener ugc nofollow" target="_blank"> RMSProp </a>是一个明智的优化算法，因为它为我们自动化了学习率调整(或者，我们也可以使用<a class="ae jd" href="https://wikipedia.org/wiki/Stochastic_gradient_descent#Adam" rel="noopener ugc nofollow" target="_blank"> Adam </a>或<a class="ae jd" href="https://developers.google.com/machine-learning/glossary/#AdaGrad" rel="noopener ugc nofollow" target="_blank"> Adagrad </a>获得类似的结果)。我们将增加<code class="fe mf mg mh mi b">metrics</code>的准确性，这样模型将在训练过程中监控准确性。</p><pre class="nh ni nj nk gt nl mi nm nn aw no bi"><span id="42b2" class="np mk jg mi b gy nq nr l ns nt">model.compile(optimizer=RMSprop(lr=0.01), loss = 'binary_crossentropy', metrics = 'accuracy')</span></pre><p id="6570" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们训练 15 个纪元:</p><pre class="nh ni nj nk gt nl mi nm nn aw no bi"><span id="2328" class="np mk jg mi b gy nq nr l ns nt">history = model.fit(train_generator,</span><span id="b9ca" class="np mk jg mi b gy nu nr l ns nt">steps_per_epoch=8,</span><span id="cb49" class="np mk jg mi b gy nu nr l ns nt">epochs=15,</span><span id="4f19" class="np mk jg mi b gy nu nr l ns nt">verbose=1,</span><span id="47c3" class="np mk jg mi b gy nu nr l ns nt">validation_data = validation_generator,</span><span id="3c0d" class="np mk jg mi b gy nu nr l ns nt">validation_steps=8)</span></pre><h1 id="45e3" class="mj mk jg bd ml mm mn mo mp mq mr ms mt km mu kn mv kp mw kq mx ks my kt mz na bi translated">3.准确性、ROC 曲线和 AUC</h1><p id="6585" class="pw-post-body-paragraph kv kw jg kx b ky nb kh la lb nc kk ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">让我们评估一下我们模型的准确性:</p><pre class="nh ni nj nk gt nl mi nm nn aw no bi"><span id="b330" class="np mk jg mi b gy nq nr l ns nt">model.evaluate(validation_generator)</span></pre><p id="272b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们计算我们的 ROC 曲线并绘制它。</p><p id="86fa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我们对我们的验证集进行预测。当使用生成器进行预测时，我们必须首先关闭 shuffle(正如我们在创建 validation_generator 时所做的那样)并重置生成器:</p><pre class="nh ni nj nk gt nl mi nm nn aw no bi"><span id="5513" class="np mk jg mi b gy nq nr l ns nt">STEP_SIZE_TEST=validation_generator.n//validation_generator.batch_size</span><span id="cc3f" class="np mk jg mi b gy nu nr l ns nt">validation_generator.reset()</span><span id="a823" class="np mk jg mi b gy nu nr l ns nt">preds = model.predict(validation_generator,</span><span id="2744" class="np mk jg mi b gy nu nr l ns nt">verbose=1)</span></pre><p id="d379" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了创建 ROC 曲线和 AUC，我们需要计算假阳性率和真阳性率:</p><pre class="nh ni nj nk gt nl mi nm nn aw no bi"><span id="f0cb" class="np mk jg mi b gy nq nr l ns nt">fpr, tpr, _ = roc_curve(validation_generator.classes, preds)</span><span id="f9a8" class="np mk jg mi b gy nu nr l ns nt">roc_auc = auc(fpr, tpr)</span><span id="343f" class="np mk jg mi b gy nu nr l ns nt">plt.figure()</span><span id="dbdc" class="np mk jg mi b gy nu nr l ns nt">lw = 2</span><span id="7515" class="np mk jg mi b gy nu nr l ns nt">plt.plot(fpr, tpr, color='darkorange',</span><span id="27b4" class="np mk jg mi b gy nu nr l ns nt">lw=lw, label='ROC curve (area = %0.2f)' % roc_auc)</span><span id="5421" class="np mk jg mi b gy nu nr l ns nt">plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')</span><span id="1f82" class="np mk jg mi b gy nu nr l ns nt">plt.xlim([0.0, 1.0])</span><span id="75aa" class="np mk jg mi b gy nu nr l ns nt">plt.ylim([0.0, 1.05])</span><span id="5f84" class="np mk jg mi b gy nu nr l ns nt">plt.xlabel('False Positive Rate')</span><span id="e9f4" class="np mk jg mi b gy nu nr l ns nt">plt.ylabel('True Positive Rate')</span><span id="d25b" class="np mk jg mi b gy nu nr l ns nt">plt.title('Receiver operating characteristic example')</span><span id="6595" class="np mk jg mi b gy nu nr l ns nt">plt.legend(loc="lower right")</span><span id="2383" class="np mk jg mi b gy nu nr l ns nt">plt.show()</span></pre><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/d9147610ab037f036c4cef5fbdca67e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*oecwJ6H9NEyJ2---mqLKkw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">我们模型的 ROC 曲线</p></figure><p id="d423" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">ROC 曲线是绘制真阳性率(TPR)对假阳性率(FPR)的概率曲线。在这条曲线中，对角线是随机猜测的曲线，例如抛硬币，所以上面的 ROC 曲线表明我们的模型在分类上做得很好！</p><p id="2a64" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似地，AUC(曲线下面积)如上面的图例所示，测量我们的模型在多大程度上能够区分我们的两个类别，蒲公英和草。AUC 越高，我们的模型在分类上就越好。AUC 为 0.96 被认为相当不错！</p><p id="6105" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，在笔记本的最后，你将有机会对你自己的图像进行预测！</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/2bd0acdc0f7e9ea5c3972ddf4697a819.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/0*nZ4i0ZXS5RDIGEQw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">你现在可以在你自己的图像上做预测了！</p></figure><p id="affa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这能让您对在 MobileNet 模型上使用迁移学习构建一个简单的二值图像分类器有一个温和的了解！如果你对类似的教程感兴趣，请看看我的其他故事。</p></div></div>    
</body>
</html>