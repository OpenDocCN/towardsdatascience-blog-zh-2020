<html>
<head>
<title>Julia For Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia负责数据科学</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/julia-for-data-science-how-to-build-linear-regression-from-scratch-with-julia-6d1521a00611?source=collection_archive---------29-----------------------#2020-01-21">https://towardsdatascience.com/julia-for-data-science-how-to-build-linear-regression-from-scratch-with-julia-6d1521a00611?source=collection_archive---------29-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fc4c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Julia中从零开始建立具有梯度下降的多元线性回归</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fdd2278857dfd03255474a1e11835dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wD8W15KVXfoq0A06.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://discourse.julialang.org/t/open-graph-image-for-the-julia-repository/23384" rel="noopener ugc nofollow" target="_blank">朱丽亚话语</a></p></figure><p id="84a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，Python和R无疑是机器学习领域使用最广泛的编程语言。不幸的是，这些编程的高级和优雅的抽象通常是有代价的，尤其是在处理大型系统时。在我们开始之前，这篇文章不会对Python或R进行无休止的抨击，所以任何有这种期望的读者都应该去别处看看。相反，这篇文章旨在启发和告知读者Julia可能会加入他们的工具箱。归根结底，所有这些编程语言都只是具有不同用例的工具。</p><h2 id="fe06" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">朱莉娅到底是什么？</h2><p id="bbdc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><a class="ae ky" href="https://julialang.org/" rel="noopener ugc nofollow" target="_blank"> Julia </a>被描述为一种动态编程语言，它专注于高性能，即使是高级抽象。因此，这种语言非常适合数字和科学计算。2009年，4名计算机科学家(其中3人的照片如下)共同创造了Julia。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mt"><img src="../Images/2d3f1d2e7f56c24101addc9a383a50d9.png" data-original-src="https://miro.medium.com/v2/0*2OC2aWM6Bm0ci4YI"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Juila图像信用的共同创造者:麻省理工学院新闻</p></figure><h2 id="5483" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">"说话像Python，走路像C ."</h2><p id="7e7a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这一行是最常用的引用之一，总而言之，这是这种编程语言的主要优点。有些读者可能读过关于臭名昭著的“<em class="mu">两种语言问题</em>”的报道。对于门外汉来说，这两个语言问题简单地描述了这种情况；</p><blockquote class="mv mw mx"><p id="b7e5" class="kz la mu lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">开发人员必须用C/C++等低级语言重新编写代码库的关键和性能部分，因为Python/R等高级语言由于其高级抽象而在某些任务上可能会很慢</p></blockquote><p id="25f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python和r等高级语言中，快速构建新想法的原型相对更容易。这些语言在数据科学生态系统中占据如此主导地位的一个主要原因是，数据科学生态系统严重依赖于尽快尝试新想法。这里的折衷(就速度而言)对于中小规模的应用程序来说是可以接受的，但是对于大规模的系统和应用程序来说非常明显。</p><p id="2e57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Julia被称为可以解决这种双语言问题的语言，它提供了Python/R这样的高级语言的友好性，同时匹配C/C++这样的低级语言的速度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">gif信用:<a class="ae ky" href="https://giphy.com/gifs/how-H6JdkRnhXQaImiCYp2/media" rel="noopener ugc nofollow" target="_blank">https://giphy.com</a></p></figure><h2 id="d091" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">"足够的速度基准，告诉我如何使用它！"</h2><p id="f43f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我听说过朱莉娅，但我总是想知道它的用法。有Python/R那么简单吗？</p><p id="4e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章简单地通过使用Julia的梯度下降从零开始构建多元线性回归来测试这个断言。我使用Python和R已经有几年了，所以我决定看看用Julia来快速解决这样的任务有多快。这篇文章不是Julia和其他语言之间的基准测试，因为这样的测试已经被很好地覆盖了，而是关注于这种语言对那些习惯于Python/R的人的用户友好性。</p><h2 id="be33" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">数据</h2><p id="5c5c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">将用于该测试的数据集是来自UCI数据仓库的<strong class="lb iu"> </strong> <a class="ae ky" href="https://archive.ics.uci.edu/ml/datasets/combined+cycle+power+plant" rel="noopener ugc nofollow" target="_blank">联合循环发电厂数据集</a> ( <em class="mu"> Sheet5 </em>)。这里的目的是生成一个模型，该模型可以根据4个数值(连续)特征预测<strong class="lb iu"><em class="mu">【EP】</em></strong>:</p><ul class=""><li id="4a13" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><strong class="lb iu">温度(AT) </strong>在<em class="mu"> 1.81摄氏度</em>和<em class="mu"> 37.11摄氏度</em>范围内。</li><li id="a6e2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">排气真空(V) </strong>在<em class="mu">25.36–81.56</em>厘米汞柱范围内。</li><li id="2989" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">环境压力(AP) </strong>在<em class="mu">992.89–1033.30</em>毫巴范围内。</li><li id="49be" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">相对湿度</strong>在<em class="mu"> 25.56%到100.16%的范围内。</em></li></ul><h2 id="3aaf" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">建模工作流</h2><p id="875f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个实验的攻击计划就像一个典型的建模工作流，其中数据将是:</p><ul class=""><li id="13ec" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><strong class="lb iu">加载到内存</strong>:数据以DataFrame对象的形式加载到内存中，大多数读者对这段代码已经很熟悉了:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr nc l"/></div></figure><ul class=""><li id="d404" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><strong class="lb iu">为算法进行预处理:</strong>随着数据成功加载到内存中，现在让我们将它分成一个训练和验证集，使用比例<em class="mu"> 80% </em>用于模型的训练，保留<em class="mu"> 20% </em>用于生成模型的评估。下面的代码片段实现了这个功能(但是更健壮的方法是打乱索引)。我们的目标是快速启动并运行，所以这就足够了。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr nc l"/></div></figure><p id="2346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您可能已经注意到的，这些特征处于不同的标度(从百分比到毫巴)，这对于大多数算法来说可能是有问题的，因此常见的做法是标准化特征，以便它们可以处于相同的“<em class="mu">标度</em>”。下面代码片段中的两个函数用于标准化训练和测试特性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr nc l"/></div></figure><p id="a54c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的数据现在已经过预处理，可以进行建模了。</p><ul class=""><li id="bac4" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><strong class="lb iu">模型拟合&amp;评估</strong>:这里的目标是找到一个线性模型，最好地最小化良好的旧均方差函数。我们的均方成本函数本质上是一个半均方函数，其定义如下:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr nc l"/></div></figure><p id="54aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义好成本函数后，让我们使用梯度下降法为每个特征(包括常数)找到最佳权重，使成本函数最小化。下一个函数负责处理这个问题:</p><p id="b3e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="mu"> NB </em> </strong> <em class="mu">:这个实现实现了没有正则化的梯度下降(我鼓励你添加到你自己的实现中)。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr nc l"/></div></figure><p id="3158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们通过绘制成本历史向量𝐉:来检查梯度下降是否有效并最小化我们的成本函数</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr nc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/14ab817a8fd656eb0bd6e1e739dff78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*eMU_4kEJrM6fP_eioVl9wQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每个时期的成本</p></figure><p id="acff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从图中可以看出，随着迭代次数的增加，成本下降，直到在某个点持平。看来梯度下降在寻找最小化我们的成本函数的权重方面做得很好。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">gif信用:<a class="ae ky" href="https://giphy.com/gifs/how-H6JdkRnhXQaImiCYp2/media" rel="noopener ugc nofollow" target="_blank">https://giphy.com</a></p></figure><p id="a5bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候做一些预测并评估我们新的闪亮回归模型的性能了。两个新函数用于生成预测并对训练和测试数据集进行评分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr nc l"/></div></figure><p id="2311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从评分函数来看，训练集和测试集的<strong class="lb iu">均方根误差</strong> ( <strong class="lb iu"> RMSE </strong>)为:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="b3cc" class="lv lw it nv b gy nz oa l ob oc"><strong class="nv iu">RMSE</strong> for Training Set: <strong class="nv iu">4.578258826855693</strong><br/><strong class="nv iu">RMSE</strong> for Testing Set: <strong class="nv iu">4.473104537374325</strong></span></pre><p id="61eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看模型在两个数据集中的预测能力(根据<strong class="lb iu"> R平方值</strong>),以及该函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr nc l"/></div></figure><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="f25c" class="lv lw it nv b gy nz oa l ob oc"><strong class="nv iu">Training R²</strong> score for test sets: <strong class="nv iu">0.9274046053983883</strong><br/><strong class="nv iu">Testing R²</strong> score for test sets: <strong class="nv iu">0.9335248094191678</strong></span></pre><p id="cb90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些分数似乎表明，一些像样的预测能力(<strong class="lb iu"> 0.927 &amp; 0.934 </strong>)！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">gif信用:<a class="ae ky" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">https://giphy.com/</a></p></figure><p id="1754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，测试分数优于训练分数，这似乎表明该模型对数据拟合不足。修改阿尔法项(<em class="mu"> α </em>)和/或迭代次数(<em class="mu"> n_iter </em>)应该可以从这个模型中挤出更多的性能，但是我将让读者自己去修改。</p><h2 id="2c43" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">基于这个朱莉娅实验的好恶</h2><p id="0e6c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">从这个实验中，我基于之前与Python和r的互动，自然对Julia有了一些好恶。</p><p id="c3a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">喜欢</strong></p><ul class=""><li id="2183" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">本地Unicode/符号支持:我最喜欢的Julia无疑是它对Unicode和科学符号的本地支持。在脚本中使用'<em class="mu"> θ </em>而不是'<em class="mu">θ</em>'，使用'α'而不是' alpha '，这很酷也很简洁。这是一种为科学/数字计算而从头开始构建的语言！我发现每次我不得不使用科学记数法时，我都在微笑。</li><li id="321e" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">一种语言的语法在它快速将思想原型化的能力中起着关键的作用。Julia的语法和Python没什么区别。就语法而言，Julia感觉自己是Python和Matlab之间的私生子。在大多数情况下，我需要快速查找文档，以避开一些糟糕的语法调用。此外，用真正的科学符号分享和阅读科学代码是非常容易的！</li><li id="64e9" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">对现有Python/R生态系统的支持:</strong>作为一门年轻的语言，预计生态系统中会缺少一些急需的包。然而，令人耳目一新的是，现有的Python/R包可以在Julia中使用。这种功能让朱莉娅享受成熟的生态系统的好处，并避免不必要的重新发明某些车轮。</li></ul><p id="408d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">不喜欢</strong></p><ul class=""><li id="ca95" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><strong class="lb iu">缓慢的预编译时间:</strong>与Python/R相比，人们注意到的第一件事是在Julia中加载包所花费的时间。每次加载包都需要预编译，这确实需要一些明显的时间(<em class="mu">超过10秒</em>)。对于习惯于即时导入包的Python/R用户来说，这可能会令人沮丧。</li><li id="6e96" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">年轻的语言/生态系统</strong>:无论是Python还是r，几乎都有一些常见的数据角力任务的包，Julia作为一个新人，自然没有老牌语言享有的那么原生丰富的生态系统。然而，这个问题现在可以通过使用PyCall &amp; JuliaCall包支持从Python和R导入来解决。</li><li id="c4fd" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">缺乏传统的OOP支持:</strong>Python对于数据科学应用程序的魅力和广泛采用的部分原因是它用面向对象编程构造函数的简洁而方便的方式。例如，如果所有预处理功能以及所有学习到的参数都可以在一个类中获得，那将是非常简洁的。Julia采用了"<a class="ae ky" href="https://en.wikipedia.org/wiki/Multiple_dispatch" rel="noopener ugc nofollow" target="_blank"> <em class="mu">多重分派</em> </a>"范例，这有助于它比其他高级语言更快。</li></ul><h2 id="4f01" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="a5a0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Julia是一种很有前途的语言，它是为数字和科学计算而从头开始构建的。在这篇文章中，我已经展示了在Julia中建立原型相对容易，并成功实现了使用梯度下降的多元线性回归。这是每一个数据至少应该保持的一种语言，并且是一个数字眼睛。对于Julia来说，有一些令人惊讶的数据科学软件包。拿些数据集，和Julia玩玩，让我知道你的想法？在我看来，启动并运行的最佳方式是安装使用Atom的IDE附带的JuliaPro。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="78e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，我期待着反馈(好的或坏的！).这个博客的<a class="ae ky" href="https://github.com/PyDataBlog/Python-for-Data-Science" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上可以找到这个<a class="ae ky" href="https://github.com/PyDataBlog/Python-for-Data-Science/tree/master/Tutorials/power_plant_project" rel="noopener ugc nofollow" target="_blank">pos</a>t的所有功能的脚本。最后，你可以在我的个人博客上查看其他帖子。直到下一个帖子，祝你在茱莉亚编码愉快！</p></div></div>    
</body>
</html>