<html>
<head>
<title>Implementing Custom Data Generators in Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Keras中实现自定义数据生成器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-custom-data-generators-in-keras-de56f013581c?source=collection_archive---------7-----------------------#2020-06-08">https://towardsdatascience.com/implementing-custom-data-generators-in-keras-de56f013581c?source=collection_archive---------7-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c3a4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何实现自定义数据生成器以在Keras模型中启用动态数据流</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/abc4bb95bfaf3efca0c2c524add85d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xzjCA4G0TalZQi68"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历山大·辛恩在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7b65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据生成器是Keras API最有用的特性之一。考虑这样一种情况，您有大量的数据，多到无法一次将所有数据都存储在RAM中。Wyd？购买更多的内存显然不是一个选项。</p><p id="f864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题的解决方案可以是动态地装载小批量数据给<strong class="lb iu">模型。</strong>这正是数据生成器的工作。它们可以动态生成模型输入，从而形成从存储器到RAM的管道，以便在需要时加载数据。这种管道的另一个优点是，在准备向模型提供数据时，可以很容易地对这些小批量数据应用预处理例程。</p><p id="805d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看到如何子类化<em class="lv"> tf.keras.utils.Sequence </em>类来实现定制数据生成器。</p><h1 id="83c2" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">图像数据生成器</h1><p id="99a3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，我们现在将了解如何使用ImageDataGenerator API进行动态图像流水线操作，从而满足实现自定义API的需求。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="aee1" class="my lx it mu b gy mz na l nb nc">datagen = ImageDataGenerator(<br/>        rescale=1./255,<br/>        shear_range=0.2,<br/>        zoom_range=0.2,<br/>        horizontal_flip=True<br/>)</span></pre><p id="3225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ImageDataGenerator API提供了从目录以及数据帧中提到的路径中管道传输图像数据的功能。其中一个可能包括预处理步骤，如图像的缩放、增强，这些步骤将直接实时应用于图像<strong class="lb iu">。</strong></p><h1 id="149d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">那么，为什么要定制呢？</h1><p id="d6c3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">模型训练不限于单一类型的输入和目标。有时一个模型会同时被输入多种类型的输入。例如，假设您正在处理一个多模态分类问题，您需要同时处理文本和图像数据。在这里，显然不能使用ImageDataGenerator。而且，一次加载所有数据是不可承受的。因此，我们通过实现自定义数据生成器来解决这个问题。</p><h1 id="b42c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">实现自定义数据生成器</h1><p id="a08b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们最后从实现开始。</p><blockquote class="nd ne nf"><p id="dd28" class="kz la lv lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">这将是一个非常通用的实现，因此可以直接复制。你只需要用自己的逻辑来填空/替换某些变量。</p></blockquote><p id="9a98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，我们将子类化<em class="lv">TF . keras . utils . sequence</em>API。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="cfd5" class="my lx it mu b gy mz na l nb nc">def __init__(<br/>     self, <br/>     df, <br/>     x_col, <br/>     y_col=None, <br/>     batch_size=32, <br/>     num_classes=None,<br/>     shuffle=True<br/>):<br/>     self.batch_size = batch_size<br/>     self.df = dataframe<br/>     self.indices = self.df.index.tolist()<br/>     self.num_classes = num_classes<br/>     self.shuffle = shuffle<br/>     self.x_col = x_col<br/>     self.y_col = y_col<br/>     self.on_epoch_end()</span></pre><p id="e558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们定义构造函数来初始化生成器的配置。注意，这里我们假设数据的路径在dataframe列中。因此，我们定义x_col和y_col参数。这也可以是您可以从中加载数据的目录名。</p><p id="7c25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> on_epoch_end </em>方法是在每个epoch之后调用的方法。我们可以在这里加入洗牌之类的套路。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="cf1a" class="my lx it mu b gy mz na l nb nc">def on_epoch_end(self):<br/>     self.index = np.arange(len(self.indices))<br/>     if self.shuffle == True:<br/>          np.random.shuffle(self.index)</span></pre><p id="7938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我们在这个代码片段中打乱了数据帧行的顺序。</p><p id="5bc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的另一个实用方法是<em class="lv"> __len__ </em>。它实际上使用样本和批量大小返回一个时期中的步骤数。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c1bb" class="my lx it mu b gy mz na l nb nc">def __len__(self):<br/>     <strong class="mu iu"># Denotes the number of batches per epoch</strong><br/>     return len(self.indices) // self.batch_size</span></pre><p id="828f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来是<em class="lv"> __getitem__ </em>方法，使用批号作为参数调用该方法以获得给定的一批数据。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="100a" class="my lx it mu b gy mz na l nb nc">def __getitem__(self, index):<br/><strong class="mu iu">     # Generate one batch of data<br/>     # Generate indices of the batch</strong><br/>     index = self.index[index * self.batch_size:(index + 1) * self.batch_size]</span><span id="52f4" class="my lx it mu b gy nj na l nb nc">     <strong class="mu iu"># Find list of IDs</strong><br/>     batch = [self.indices[k] for k in index]</span><span id="3f36" class="my lx it mu b gy nj na l nb nc">     <strong class="mu iu"># Generate data</strong><br/>     X, y = self.__get_data(batch)<br/>     return X, y</span></pre><p id="8282" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我们只是获得混洗的索引，并从不同的方法调用数据集，然后将其返回给调用者。数据集生成的逻辑可以在这里自己实现。但是，将它抽象到其他地方是一个很好的做法。</p><p id="193c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们在__ <em class="lv"> get_data </em>方法中编写数据生成的逻辑。既然这个方法要被我们调用，我们可以随便取什么名字。此外，这个方法没有理由是公共的，因此我们将其定义为私有的。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5065" class="my lx it mu b gy mz na l nb nc">def __get_data(self, batch):<strong class="mu iu"><br/>     # X.shape : (batch_size, *dim)<br/>     # We can have multiple Xs and can return them as a list</strong></span><span id="ec11" class="my lx it mu b gy nj na l nb nc">     X = <strong class="mu iu"># logic to load the data from storage<br/>     </strong>y = <strong class="mu iu"># logic for the target variables</strong></span><span id="2788" class="my lx it mu b gy nj na l nb nc">     <strong class="mu iu"># Generate data</strong><br/>     for i, id in enumerate(batch):<br/>     <strong class="mu iu"># Store sample</strong><br/>          X[i,] = <strong class="mu iu"># logic</strong></span><span id="4d57" class="my lx it mu b gy nj na l nb nc">     <strong class="mu iu"># Store class</strong><br/>     y[i] = <strong class="mu iu"># labels</strong><br/>     return X, y</span></pre><p id="ba2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以添加预处理/增强例程来实时启用它们。在上面这段代码中，X和y是根据方法中传递的批处理索引参数从数据源加载的。这可以是从加载图像到加载文本或同时加载两者或任何其他类型的数据。</p><p id="0128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合并所有方法后，完整的生成器如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">完整的自定义数据生成器类</p></figure><h1 id="43ad" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="8d7f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在本文中，我们看到了数据生成器在用大量数据训练模型时的用处。我们查看了ImageDataGenerator API，以了解它是什么，并解决对自定义API的需求。然后，我们最终了解了如何通过子类化<em class="lv">TF . keras . utils . sequence</em>API来实现定制数据生成器。</p><p id="9afb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意复制这段代码，并在其中添加您自己的生成器逻辑。</p><h1 id="8c94" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">参考</h1><div class="nm nn gp gr no np"><a href="https://www.tensorflow.org/api_docs/python/tf/keras/utils/Sequence" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">TF . keras . utils . sequence | tensor flow Core v 2 . 2 . 0</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">通过TensorFlow学习ML基础知识的教育资源</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">www.tensorflow.org</p></div></div></div></a></div><div class="nm nn gp gr no np"><a href="https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/image/ImageDataGenerator" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">TF . keras . preprocessing . image . imagedata generator</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">通过TensorFlow学习ML基础知识的教育资源</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">www.tensorflow.org</p></div></div></div></a></div><div class="nm nn gp gr no np"><a href="https://stanford.edu/~shervine/blog/keras-how-to-generate-data-on-the-fly" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">使用Keras的数据生成器的详细示例</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">python keras 2 fit _ generator Afshine Amidi和Shervine Amidi的大型数据集多重处理您是否曾经不得不…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">stanford.edu</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div></div></div>    
</body>
</html>