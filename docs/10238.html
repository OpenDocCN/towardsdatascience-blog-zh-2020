<html>
<head>
<title>Instance Segmentation Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实例分段 Web 应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/instance-segmentation-web-app-63016b8ed4ae?source=collection_archive---------25-----------------------#2020-07-19">https://towardsdatascience.com/instance-segmentation-web-app-63016b8ed4ae?source=collection_archive---------25-----------------------#2020-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0c67" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 Docker、Flask 和 Detectron2 构建用于实例分割的 Web 应用程序</h2></div><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="kk kl l"/></div></figure><p id="6a85" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae li" href="https://github.com/facebookresearch/detectron2" rel="noopener ugc nofollow" target="_blank"> Detectron2 </a>提供最先进的实例分割模型。训练非常快，而且效果非常好。</p><p id="9b9b" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">模型训练相当简单。那里有很多<a class="ae li" href="https://github.com/facebookresearch/detectron2/blob/master/GETTING_STARTED.md" rel="noopener ugc nofollow" target="_blank">教程</a>可以帮你。将模型部署到 web 应用程序是另一回事。当我尝试这样做的时候，我没有在网上找到很多帮助。</p><p id="a780" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">因此，在这篇文章中，我们将为 detectron2 的实例分段创建一个 web 应用程序。</p><h1 id="6396" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">后端</h1><p id="dfd8" class="pw-post-body-paragraph km kn iq ko b kp mb jr kr ks mc ju ku kv md kx ky kz me lb lc ld mf lf lg lh ij bi translated">首先，我们将创建机器学习后端。这将使用基本的<a class="ae li" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank">烧瓶</a>。我们将从一些相当标准的<a class="ae li" href="https://github.com/realpython/flask-boilerplate/blob/master/app.py" rel="noopener ugc nofollow" target="_blank">样板代码</a>开始</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mg kl l"/></div></figure><p id="d3d3" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这个应用程序将简单地呈现模板<code class="fe mh mi mj mk b">index.html</code>。我已经手动指定了端口。</p><p id="4e66" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">接下来，我们将添加函数来获取图像。我们希望能够上传图像到网站。我们也希望能够提供一个网址和图像将自动下载的网站。我已经创建了如下代码。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mg kl l"/></div></figure><p id="2575" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这段代码允许我们将图像上传到后端(POST 请求)。或者我们可以提供一个 url 的后端，它会自动下载图像(获取请求)。该代码还将图像转换成一个<code class="fe mh mi mj mk b">jpg</code>。我无法用探测器 2 对<code class="fe mh mi mj mk b">png</code>图像进行推断。所以我们必须转换成一个<code class="fe mh mi mj mk b">jpg</code>。</p><p id="21d1" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如果代码因为某种原因不能下载图像，它将返回<code class="fe mh mi mj mk b">failure.html</code>模板。这基本上只是一个简单的<code class="fe mh mi mj mk b">html</code>页面，说明在检索图像时出现了错误。</p><p id="609f" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">另外，我指定了一个不同的<code class="fe mh mi mj mk b">@app.route</code>。这需要反映在<code class="fe mh mi mj mk b">index.html</code>文件中。</p><h1 id="ef11" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">前端</h1><p id="831b" class="pw-post-body-paragraph km kn iq ko b kp mb jr kr ks mc ju ku kv md kx ky kz me lb lc ld mf lf lg lh ij bi translated">现在我将创建前端<code class="fe mh mi mj mk b">html</code>代码。这个接口允许用户上传图片或者指定图片的 url。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mg kl l"/></div></figure><p id="8d72" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">没什么大不了的。我们创建一个简单的表单，并告诉它链接到@app.route('/detect') flask 代码。我们还需要指定方法。如果用户上传的是图片，那就是 POST。如果用户给我们一个图片的 url，那就是 GET。</p><p id="de48" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><code class="fe mh mi mj mk b">failure.html</code>模板甚至更简单。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mg kl l"/></div></figure><p id="0496" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在我们可以进入实际的深度学习部分。</p><p id="3ad8" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在这一部分，我们将得到一个 detectron2 预训练模型来对图像进行推理。然后我们将它链接到我们现有的后端。</p><p id="6153" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这部分稍微复杂一点。我们将创建一个名为<code class="fe mh mi mj mk b">Detector</code>的新类。因为我们将创建探测器 2 所需的<code class="fe mh mi mj mk b">cfg</code>。然后，我们将创建另一个函数来对图像进行推理。</p><p id="db96" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我将使用在<a class="ae li" href="https://cocodataset.org/" rel="noopener ugc nofollow" target="_blank"> COCO </a>数据集上训练的 mask rcnn 预训练模型。它将使用一个<a class="ae li" rel="noopener" target="_blank" href="/an-overview-of-resnet-and-its-variants-5281e2f56035"> ResNet </a> + <a class="ae li" rel="noopener" target="_blank" href="/review-fpn-feature-pyramid-network-object-detection-262fc7482610"> FPN </a>主干。据说这款机型获得了<a class="ae li" href="https://github.com/facebookresearch/detectron2/blob/master/MODEL_ZOO.md#common-settings-for-coco-models" rel="noopener ugc nofollow" target="_blank">最好的速度/精度权衡</a>。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mg kl l"/></div></figure><p id="3319" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这段代码基本上完成了我们推理所需的一切。我们只需要指定我们下载的预训练模型的路径。</p><p id="aa45" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">它从模型动物园中自动获取对应于我们的预训练模型的配置。它还应该从模型动物园获得预训练模型。但是我发现这在 docker 中并不奏效——至少对我来说是这样。</p><p id="3bd7" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">下一步是将这个<code class="fe mh mi mj mk b">Detector</code>类集成到我们现有的脚本中。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mg kl l"/></div></figure><p id="0f3f" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在这段代码中，我添加了我们之前创建的<code class="fe mh mi mj mk b">Detector</code>类。我还创建了一个名为<code class="fe mh mi mj mk b">run_inference</code>的函数。这是后端将在图像上运行 detectron2 模型的地方。它将接受一个图像路径，并通过我们之前创建的<code class="fe mh mi mj mk b">Detector</code>类调用 detectron2 模型。</p><p id="2083" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">一旦实例分割完成，<code class="fe mh mi mj mk b">run_inference</code>函数将返回一个图像。我不得不对<code class="fe mh mi mj mk b">run_inference</code>函数的结果做一些不寻常的事情来让它工作。<code class="fe mh mi mj mk b">result_img</code>被粘贴到文件对象中，该文件对象作为 png 返回。不过，可能有更好的方法来做到这一点。</p><p id="cb86" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">最后一步是为我们的代码创建 docker 容器。然后我们将在本地部署 docker 容器。</p><p id="4a6e" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">谢天谢地，detectron2 已经为我们创建了一个<a class="ae li" href="https://github.com/facebookresearch/detectron2/blob/master/docker/Dockerfile" rel="noopener ugc nofollow" target="_blank"> dockerfile </a>。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mg kl l"/></div></figure><p id="477f" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我基本上使用了 detectron2 的<a class="ae li" href="https://github.com/facebookresearch/detectron2/blob/master/docker/Dockerfile" rel="noopener ugc nofollow" target="_blank"> github repo </a>中提供的 dockerfile。但是我做了一些改变。</p><p id="4023" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我添加了一个<code class="fe mh mi mj mk b"><a class="ae li" href="https://github.com/spiyer99/detectron2_web_app/blob/master/requirements.txt" rel="noopener ugc nofollow" target="_blank">requirements.txt</a></code>文件。我在需求文件中做了一个<code class="fe mh mi mj mk b">pip install</code>。安装了一些我们需要的库。我还修改了命令来启动我们之前创建的<code class="fe mh mi mj mk b">app.py</code>脚本。这将启动 flask 应用程序并呈现<code class="fe mh mi mj mk b">index.html</code>模板。</p><p id="f306" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在我们可以启动 docker 容器了。我们可以通过以下方式实现这一点:</p><pre class="kf kg kh ki gt ml mk mm mn aw mo bi"><span id="5655" class="mp lk iq mk b gy mq mr l ms mt">docker build . -f Dockerfile -t detectron2 &amp;&amp;\<br/>docker run -d -p 8080:8080 detectron2</span></pre><p id="b3f3" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这将在当前工作目录中构建当前 dockerfile。然后它将在端口 8080 上运行该映像。这是我之前指定的端口。</p><p id="5d76" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">但问题是，如果你一直运行这些命令，你的电脑上会有太多的 docker 镜像和容器。这会在你的电脑上占据大量的空间。</p><p id="d89c" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">Jim Hoskins 对此有一个非常优雅的解决方案，我根据自己的目的进行了修改。</p><p id="3304" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我创建了一个不错的 shell 脚本:</p><ul class=""><li id="2dbf" class="mu mv iq ko b kp kq ks kt kv mw kz mx ld my lh mz na nb nc bi translated">停止所有容器</li><li id="5015" class="mu mv iq ko b kp nd ks ne kv nf kz ng ld nh lh mz na nb nc bi translated">移除未标记的容器</li><li id="210c" class="mu mv iq ko b kp nd ks ne kv nf kz ng ld nh lh mz na nb nc bi translated">生成新的容器</li><li id="1e3f" class="mu mv iq ko b kp nd ks ne kv nf kz ng ld nh lh mz na nb nc bi translated">在端口 8080 上运行容器</li><li id="8354" class="mu mv iq ko b kp nd ks ne kv nf kz ng ld nh lh mz na nb nc bi translated">显示容器的尾部日志</li></ul><p id="1841" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这个脚本非常有用。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mg kl l"/></div></figure><p id="a750" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">从终端运行这个脚本。它将构建并运行 detectron2 web 应用程序。网络应用应该会出现在你浏览器的<code class="fe mh mi mj mk b">localhost:8080</code>上。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/594ea38ceef9a1224a298a9f0c1842d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oPyJY-nhOHRcvPxV.png"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">作者图片</p></figure><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nu"><img src="../Images/acfd03be7415f6d5b51077f57d28b8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kB2OQ5fAspcIbB2-JOISzQ.jpeg"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">由<a class="ae li" href="https://unsplash.com/@nabeelsyed" rel="noopener ugc nofollow" target="_blank">纳比尔·赛义德</a>在<a class="ae li" href="https://unsplash.com/photos/Jk3-Uhdwjcs" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的源图像</p></figure><p id="5b54" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">有用！</p><p id="8137" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这方面的代码可以在<a class="ae li" href="https://github.com/spiyer99/detectron2_web_app" rel="noopener ugc nofollow" target="_blank"> github </a>上找到。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="c11b" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><em class="ni">原载于 2020 年 7 月 19 日</em><a class="ae li" href="https://spiyer99.github.io/Detectron2-Web-App/" rel="noopener ugc nofollow" target="_blank"><em class="ni">https://spiyer 99 . github . io</em></a><em class="ni">。</em></p></div></div>    
</body>
</html>