<html>
<head>
<title>What’s New in Pandas 1.0 and TensorFlow 2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫 1.0 和 TensorFlow 2.0 的新增功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/whats-new-in-pandas-1-0-and-tensorflow-2-0-7c8e68251dd5?source=collection_archive---------22-----------------------#2020-02-03">https://towardsdatascience.com/whats-new-in-pandas-1-0-and-tensorflow-2-0-7c8e68251dd5?source=collection_archive---------22-----------------------#2020-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9093" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于用于数据分析和机器学习的流行 python 包的大版本，需要记住一些事情。</h2></div><p id="51c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文假设读者对这些库有一定的了解。如果你需要一个快速介绍，这里有一些关于<a class="ae lb" rel="noopener" target="_blank" href="/an-introduction-to-pandas-in-python-b06d2dd51aba">熊猫</a>和<a class="ae lb" rel="noopener" target="_blank" href="/a-beginner-introduction-to-tensorflow-part-1-6d139e038278"> TensorFlow </a>的很棒的媒体文章。</p><h1 id="0b8e" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">熊猫 1.0.0</h1><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lu"><img src="../Images/d69ac7488d334ad951a144dff9c314a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cN1MqVTzGdpB-673qihhaw.png"/></div></div><p class="mg mh gj gh gi mi mj bd b be z dk translated">来源:<a class="ae lb" href="https://pandas.pydata.org/docs/user_guide/index.html" rel="noopener ugc nofollow" target="_blank">熊猫用户指南</a></p></figure><h2 id="57ec" class="mk ld iq bd le ml mm dn li mn mo dp lm ko mp mq lo ks mr ms lq kw mt mu ls mv bi translated">(2020 年 1 月 29 日发布)</h2><p id="3f15" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">pandas(Panel Data 的缩写)是一个用于数据分析和操作的 Python 包，早在 2008 年就从 AQR Capital Management <a class="ae lb" href="https://en.wikipedia.org/wiki/Pandas_(software)" rel="noopener ugc nofollow" target="_blank">开源了。它的主要特性是 DataFrame 对象，该对象为 Python 用户提供了一种简单且标准化的方式来与表格数据进行交互。当我开始使用它时，我觉得很奇怪，这样一个突出和广泛使用的软件还没有 1.0 版本。</a></p><p id="155e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从 0.25.3 →1.0.0 变化不多。尽管如此，以下是主要的主题。</p><h2 id="acc0" class="mk ld iq bd le ml mm dn li mn mo dp lm ko mp mq lo ks mr ms lq kw mt mu ls mv bi translated">新数据框列类型</h2><p id="ad44" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">这是熊猫在 1.0  <em class="nb">版本</em>之前处理数据类型的方式:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nc"><img src="../Images/5a10eaf7914b1be2e8d770d48de6e4ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRXWM7hwR9HHbpe-goewFQ.png"/></div></div><p class="mg mh gj gh gi mi mj bd b be z dk translated">来源:<a class="ae lb" href="https://pbpython.com/pandas_dtypes.html" rel="noopener ugc nofollow" target="_blank">https://pbpython.com/pandas_dtypes.html</a></p></figure><p id="6c6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以在列表中再添加两个:<code class="fe nd ne nf ng b">pd.StringDtype()</code>和<code class="fe nd ne nf ng b">pd.BooleanDtype()</code>。</p><p id="b66e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">字符串类型:</strong>在添加<code class="fe nd ne nf ng b">string</code>数据类型之前，Pandas 字符串列被编码为 NumPy <code class="fe nd ne nf ng b">object</code>数组。这太笼统了，因为任何东西都可以存储在熊猫对象列中。很难区分哪些列是只有字符串的，哪些列包含混合的对象类型。</p><p id="aca1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在有了 Pandas 中的<code class="fe nd ne nf ng b">pd.StringDtype()</code>列，你应该可以在字符串列上运行所有的<a class="ae lb" href="https://docs.python.org/3.8/library/stdtypes.html#string-methods" rel="noopener ugc nofollow" target="_blank"> python 字符串方法</a>，比如<code class="fe nd ne nf ng b">.lower()</code>、<code class="fe nd ne nf ng b">.upper()</code>、<code class="fe nd ne nf ng b">.replace()</code>等等。</p><p id="36eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">布尔类型:</strong>在新的熊猫布尔类型之前，布尔列被编码为<code class="fe nd ne nf ng b">bool</code>类型的 NumPy 数组。唯一的问题是这些数组不能包含缺失值。新的<code class="fe nd ne nf ng b">pd.BooleanDtype()</code>解决了这个问题。</p><h2 id="08a2" class="mk ld iq bd le ml mm dn li mn mo dp lm ko mp mq lo ks mr ms lq kw mt mu ls mv bi translated">说到缺失值…</h2><p id="c0fd" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">三种不同的数据类型表示熊猫对象的“缺失”:<code class="fe nd ne nf ng b">np.NaN</code>表示浮点类型，<code class="fe nd ne nf ng b">np.NaT</code>表示日期时间类型，<code class="fe nd ne nf ng b">None</code>表示其他对象类型。一些人(包括我)认为这很烦人，很困惑。</p><p id="6b9b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">引入<code class="fe nd ne nf ng b">pd.NA</code>，新的捕捉所有缺失数据的熊猫类型。那么它是如何工作的呢？</p><p id="ea46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用于算术运算；任何被加、减、连、乘、除等的东西。将返回<code class="fe nd ne nf ng b">pd.NA</code>。</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="34e6" class="mk ld iq ng b gy nl nm l nn no">In[1]: pd.NA + 72<br/>Out[1]: &lt;NA&gt;</span><span id="1b9b" class="mk ld iq ng b gy np nm l nn no">In[2]: pd.NA * "abc"<br/>Out[2]: &lt;NA&gt;</span></pre><p id="e4e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了少数特殊情况，比如<code class="fe nd ne nf ng b">pd.NA</code>所代表的数值与结果无关。</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="2a21" class="mk ld iq ng b gy nl nm l nn no">In[3]: 1 ** pd.NA<br/>Out[3]: 1</span><span id="70d2" class="mk ld iq ng b gy np nm l nn no">In[3]: pd.NA ** 0<br/>Out[3]: 1</span></pre><p id="8529" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了便于比较，<code class="fe nd ne nf ng b">pd.NA</code>的行为就像您所期望的那样，通过操作进行传播。</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="82c9" class="mk ld iq ng b gy nl nm l nn no">In[4]: pd.NA == 2.75<br/>Out[4]: &lt;NA&gt;</span><span id="808d" class="mk ld iq ng b gy np nm l nn no">In[5]: pd.NA &lt; 65<br/>Out[5]: &lt;NA&gt;</span><span id="6ebc" class="mk ld iq ng b gy np nm l nn no">In[6]: pd.NA == pd.NA<br/>Out[6]: &lt;NA&gt;</span></pre><p id="a09a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要测试缺失数据:</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="0396" class="mk ld iq ng b gy nl nm l nn no">In[7]: pd.NA is pd.NA<br/>Out[7]: True</span><span id="f729" class="mk ld iq ng b gy np nm l nn no">In[7]: pd.isna(pd.NA)<br/>Out[7]: True</span></pre><p id="361f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于布尔运算，<code class="fe nd ne nf ng b">pd.NA</code>跟在<em class="nb">三值逻辑</em> ( <a class="ae lb" href="https://en.wikipedia.org/wiki/Three-valued_logic#Kleene_and_Priest_logics" rel="noopener ugc nofollow" target="_blank">又名 Kleen 逻辑</a>)之后，类似于 SQL、R、Julia。</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="73d8" class="mk ld iq ng b gy nl nm l nn no">In[8]: True | pd.NA<br/>Out[8]: True</span><span id="e9d5" class="mk ld iq ng b gy np nm l nn no">In[9]: False | pd.NA<br/>Out[9]: &lt;NA&gt;</span><span id="012b" class="mk ld iq ng b gy np nm l nn no">In[10]: True &amp; pd.NA<br/>Out[10]: &lt;NA&gt;</span><span id="a8b3" class="mk ld iq ng b gy np nm l nn no">In[11]: False &amp; pd.NA<br/>Out[11]: False</span></pre><p id="6557" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe nd ne nf ng b">pd.NA</code>的值可以改变结果，那么操作返回<code class="fe nd ne nf ng b">&lt;NA&gt;</code>，但是如果<code class="fe nd ne nf ng b">pd.NA</code>的值对结果没有<em class="nb">可能的影响，就像在<code class="fe nd ne nf ng b">True | pd.NA</code>和<code class="fe nd ne nf ng b">False &amp; pd.NA</code>中那样，那么它将返回正确的值。</em></p><p id="3c23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">挑战问题</strong>:这也能评价什么？(<em class="nb">答案在最后。)</em></p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="8dec" class="mk ld iq ng b gy nl nm l nn no">In[12]: ((True | pd.NA) &amp; True) | (False &amp; (pd.NA | False))<br/>Out[12]: ???</span></pre><p id="3ab1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:该<code class="fe nd ne nf ng b">pd.NA</code>值是实验性的，并且<em class="nb">行为可能会在没有警告</em>的情况下改变。有关更多信息，请查看文档中的<a class="ae lb" href="https://pandas.pydata.org/pandas-docs/version/1.0.0/user_guide/missing_data.html#missing-data-na" rel="noopener ugc nofollow" target="_blank"> <em class="nb">处理缺失数据</em> </a>部分。</p><h2 id="f1f8" class="mk ld iq bd le ml mm dn li mn mo dp lm ko mp mq lo ks mr ms lq kw mt mu ls mv bi translated">速度和动力</h2><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nq"><img src="../Images/9618b8a1ee59be2ef0b2ebd1229f0025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3hoY28r-yUGyfCa0WrWIA.png"/></div></div><p class="mg mh gj gh gi mi mj bd b be z dk translated">来源:<a class="ae lb" href="http://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Numba 文档</a></p></figure><p id="2088" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">C 运行速度比 Python 快主要原因是 C 得到编译而 Python 得到直接解释<em class="nb">(注:</em> <a class="ae lb" href="https://www.quora.com/Why-does-C-code-run-faster-than-Pythons" rel="noopener ugc nofollow" target="_blank"> <em class="nb">稍微多一点</em> </a> <em class="nb"> ) </em>。Pandas 和 NumPy 使用<a class="ae lb" href="https://cython.org/" rel="noopener ugc nofollow" target="_blank"> Cython </a>将 Python 代码转换成 C 语言并获得性能提升。</p><p id="ae1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在 Python 社区中，另一个编译器<a class="ae lb" href="http://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> Numba </strong> </a>正在迅速获得关注。Numba 允许你编译 Python 代码到<em class="nb">几乎</em>达到 C 和 FORTRAN 的速度；没有任何额外编译步骤或安装 C/C++编译器的复杂工作。只需导入<code class="fe nd ne nf ng b">numba</code>库，<a class="ae lb" href="http://book.pythontips.com/en/latest/decorators.html" rel="noopener ugc nofollow" target="_blank">用<code class="fe nd ne nf ng b">@numba.jit()</code>修饰</a>你的函数。<br/>举例:</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="bfbc" class="mk ld iq ng b gy nl nm l nn no">@numba.jit(nopython=True, parallel=True)<br/>def my_function():<br/>    ...<br/>    # Some really long and computationally intense task<br/>    return(the_result)</span></pre><p id="4a50" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Pandas 在<code class="fe nd ne nf ng b">apply()</code>函数中添加了一个<code class="fe nd ne nf ng b">engine=’numba’</code>关键字，用 Numba 运行你的数据操作。我认为我们将开始在 Python 数据科学生态系统中看到更多这种功能。</p><h2 id="d811" class="mk ld iq bd le ml mm dn li mn mo dp lm ko mp mq lo ks mr ms lq kw mt mu ls mv bi translated">可视化原始数据</h2><p id="4f8e" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">眼见为实。甚至在用数据制作图表之前，当人们将数据放入 DataFrame 对象时，他们做的第一件事就是运行<code class="fe nd ne nf ng b">.head()</code>方法来了解数据的样子。</p><p id="6535" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您现在有 2 个选项来轻松查看您的数据。</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="ac8d" class="mk ld iq ng b gy nl nm l nn no"># Create a DataFrame to print out<br/>df = pd.DataFrame({<br/>       'some_numbers': [5.12, 8.66, 1.09],<br/>       'some_colors': ['blue',  'orange', 'maroon'],<br/>       'some_bools': [True, True, False],<br/>       'more_numbers': [2,5,8],<br/>})</span></pre><p id="9ed8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">漂亮的 JSON:</strong><code class="fe nd ne nf ng b">.to_json()</code>方法现在有了一个<code class="fe nd ne nf ng b">indent=</code>参数，它将以更易于阅读的方式打印出您的数据。</p><p id="d4be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是像这样得到输出的文本转储:</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="936c" class="mk ld iq ng b gy nl nm l nn no">print(df.to_json(orient='records'))</span><span id="5185" class="mk ld iq ng b gy np nm l nn no">[{"some_numbers":5.12,"some_colors":"blue","some_bools":true,"more_numbers":2},{"some_numbers":8.66,"some_colors":"orange","some_bools":true,"more_numbers":5},{"some_numbers":1.09,"some_colors":"maroon","some_bools":false,"more_numbers":8}]</span></pre><p id="2cc7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以这样美化 JSON:</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="b751" class="mk ld iq ng b gy nl nm l nn no">print(df.to_json(orient='records',indent=2))</span><span id="4c04" class="mk ld iq ng b gy np nm l nn no">[<br/>  {<br/>    "some_numbers":5.12,<br/>    "some_colors":"blue",<br/>    "some_bools":true,<br/>    "more_numbers":2<br/>  },<br/>  {<br/>    "some_numbers":8.66,<br/>    "some_colors":"orange",<br/>    "some_bools":true,<br/>    "more_numbers":5<br/>  },<br/>  {<br/>    "some_numbers":1.09,<br/>    "some_colors":"maroon",<br/>    "some_bools":false,<br/>    "more_numbers":8<br/>  }<br/>]</span></pre><p id="fb7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是将表格打印到控制台的另一种方式。这产生了一种更容易复制和粘贴到 markdown 文档中的格式。仅供参考，你需要安装<code class="fe nd ne nf ng b">tabulate</code>包才能工作。</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="4920" class="mk ld iq ng b gy nl nm l nn no">print(df.to_markdown())</span><span id="0d88" class="mk ld iq ng b gy np nm l nn no">|    | some_numbers | some_colors | some_bools  | more_numbers |<br/>|---:|-------------:|:------------|:------------|-------------:|<br/>|  0 |         5.12 | blue        | True        |            2 |<br/>|  1 |         8.66 | orange      | True        |            5 |<br/>|  2 |         1.09 | maroon      | False       |            8 |</span></pre><h2 id="27d6" class="mk ld iq bd le ml mm dn li mn mo dp lm ko mp mq lo ks mr ms lq kw mt mu ls mv bi translated">有趣的事实</h2><p id="1607" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">您过去可以从 Pandas 包中访问 NumPy 和 datetime 名称空间。像这样:</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="d450" class="mk ld iq ng b gy nl nm l nn no">import pandas as pd</span><span id="6c1e" class="mk ld iq ng b gy np nm l nn no">x = pd.np.array([1, 2, 3])</span><span id="def1" class="mk ld iq ng b gy np nm l nn no">current_date = pd.datetime.date.today()</span></pre><p id="5ce5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是你不应该这样做。这使得代码变得混乱。自己导入库。</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="2a84" class="mk ld iq ng b gy nl nm l nn no">from datetime import date<br/>import numpy as np<br/>import pandas as pd</span><span id="c8a1" class="mk ld iq ng b gy np nm l nn no">x = np.array([1,2,3])<br/>current_date = date.today()</span></pre><p id="7ca1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种名称空间攻击最终被否决了。点击查看公关讨论<a class="ae lb" href="https://github.com/pandas-dev/pandas/issues/30296" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="c564" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">张量流 2.0</h1><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nq"><img src="../Images/63b087ed303613fa2d96cf828090f0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Om-tctYo9NueUslIjh1jsw.png"/></div></div><p class="mg mh gj gh gi mi mj bd b be z dk translated">来源:<a class="ae lb" href="https://blog.tensorflow.org/2019/09/tensorflow-20-is-now-available.html" rel="noopener ugc nofollow" target="_blank">发行说明</a></p></figure><h2 id="54e8" class="mk ld iq bd le ml mm dn li mn mo dp lm ko mp mq lo ks mr ms lq kw mt mu ls mv bi translated">(2019 年 9 月 30 日发布)</h2><p id="1d52" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">TensorFlow 是一个深度学习的 Python 包，已经被整个行业广泛采用。它最初是谷歌 DeepMind 的一个内部项目，但在 2015 年 11 月 9 日向公众发布。<a class="ae lb" href="https://github.com/tensorflow/tensorflow/blob/07bb8ea2379bd459832b23951fb20ec47f3fdbd4/RELEASE.md" rel="noopener ugc nofollow" target="_blank">1.0 版本</a>2017 年 2 月问世。现在我们已经到了 2.0。</p><p id="2089" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TensorFlow 因其可移植性和易于将模型部署到生产级软件中而在工业用例中广受欢迎。但对于研究用例，许多人发现，与 PyTorch 等其他框架相比，它缺乏创建和运行机器学习实验的便利性(<a class="ae lb" href="https://thegradient.pub/state-of-ml-frameworks-2019-pytorch-dominates-research-tensorflow-dominates-industry/" rel="noopener ugc nofollow" target="_blank">阅读更多</a>)。</p><p id="70d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管你喜欢还是讨厌 TensorFlow 1。x，以下是你需要知道的。</p><h2 id="2307" class="mk ld iq bd le ml mm dn li mn mo dp lm ko mp mq lo ks mr ms lq kw mt mu ls mv bi translated">更多关注热切的执行</h2><p id="912f" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">在 TensorFlow 1。x 您通常会构建出想要执行的操作的整个控制流，然后通过运行一个会话来一次执行所有的操作。</p><p id="fa23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不是很 Pythonic 化。Python 用户喜欢能够交互式地运行数据并与数据交互。TensorFlow v1.7 中发布了急切执行，现在在 2.0 中将成为处理计算的主要方式。这里有一个例子。</p><p id="fdc1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有急切的执行。</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="3dd3" class="mk ld iq ng b gy nl nm l nn no">In[1]: x = tf.constant([[1,0,0],[0,1,0],[0,0,1]], dtype=float)</span><span id="c4e9" class="mk ld iq ng b gy np nm l nn no">In[2]: print(x)<br/>Out[2]: Tensor("Const:0", shape=(3, 3), dtype=float32)</span></pre><p id="9bca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">急切地执行。</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="7bf7" class="mk ld iq ng b gy nl nm l nn no">In[1]: x = tf.constant([[1,0,0],[0,1,0],[0,0,1]], dtype=float)</span><span id="f108" class="mk ld iq ng b gy np nm l nn no">In[2]: print(x)<br/>Out[2]: Tensor([[1,0,0]<br/>                [0,1,0]<br/>                [0,0,1]], shape=(3, 3), dtype=float32)</span></pre><p id="582a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您可以实际看到您正在处理的数字时，理解和调试正在发生的事情会容易多少？这使得 TensorFlow 与原生 Python 控制流更加兼容，因此更容易创建和理解。(<a class="ae lb" href="https://medium.com/coding-blocks/eager-execution-in-tensorflow-a-more-pythonic-way-of-building-models-e461810618c8" rel="noopener">阅读更多</a>)</p><h2 id="8ea1" class="mk ld iq bd le ml mm dn li mn mo dp lm ko mp mq lo ks mr ms lq kw mt mu ls mv bi translated">功能强大，但仍便于携带</h2><p id="cef8" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">行业背景下的 ML 从业者较早采用 TensorFlow 的部分原因是它的可移植性。您可以用 Python 构建逻辑(或执行图)，导出它，然后用 C、JavaScript 等无缝运行它。</p><p id="778f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TensorFlow 听到了人们的呼声，即让接口更加 Python 化，但仍然保持了使用<code class="fe nd ne nf ng b">@tf.function</code> decorator 将代码移植到其他执行环境的便利性。这个装饰器使用<a class="ae lb" href="https://www.tensorflow.org/guide/function" rel="noopener ugc nofollow" target="_blank"> AutoGraph </a>自动将您的 python 函数翻译成 TensorFlow 执行图。</p><p id="c3e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://www.tensorflow.org/guide/effective_tf2" rel="noopener ugc nofollow" target="_blank">来自文件</a>:</p><ul class=""><li id="2aea" class="nr ns iq kh b ki kj kl km ko nt ks nu kw nv la nw nx ny nz bi translated"><code class="fe nd ne nf ng b">for</code>/<code class="fe nd ne nf ng b">while</code>-&gt;-<code class="fe nd ne nf ng b"><a class="ae lb" href="https://www.tensorflow.org/api_docs/python/tf/while_loop" rel="noopener ugc nofollow" target="_blank">tf.while_loop</a></code>(支持<code class="fe nd ne nf ng b">break</code>、<code class="fe nd ne nf ng b">continue</code>)</li><li id="2396" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated"><code class="fe nd ne nf ng b">if</code>-&gt;-T7】</li><li id="15d3" class="nr ns iq kh b ki oa kl ob ko oc ks od kw oe la nw nx ny nz bi translated"><code class="fe nd ne nf ng b">for _ in dataset</code> - &gt; <code class="fe nd ne nf ng b">dataset.reduce</code></li></ul><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="14e4" class="mk ld iq ng b gy nl nm l nn no"># TensorFlow 1.X<br/>outputs = session.run(f(placeholder), <br/>                      feed_dict={placeholder: input})<br/># TensorFlow 2.0<br/>outputs = f(input)</span></pre><h2 id="15b6" class="mk ld iq bd le ml mm dn li mn mo dp lm ko mp mq lo ks mr ms lq kw mt mu ls mv bi translated">Keras 的本地支持</h2><p id="770e" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">Keras 最初是作为一种更高级别的深度学习 API 开发的，它包装了 TensorFlow、Theano 或 CNTK。从<a class="ae lb" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank">首页</a>:</p><blockquote class="of og oh"><p id="f185" class="kf kg nb kh b ki kj jr kk kl km ju kn oi kp kq kr oj kt ku kv ok kx ky kz la ij bi translated">“它的开发重点是支持快速实验。能够以尽可能少的延迟从想法到结果是做好研究的关键。”</p></blockquote><p id="b30f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TensorFlow 决定在<code class="fe nd ne nf ng b">tf</code>名称空间内原生支持 Keras API。这为用户提供了模型实验的模块化方法，并解决了“<em class="nb"> TensorFlow 不适合研究</em>”的问题。</p><p id="43a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Keras 仍然作为一个独立的库存在，但建议使用 TensorFlow 后端的用户切换到<code class="fe nd ne nf ng b">tf.Keras</code>。所以现在当人们说他们在用“Keras”时，我不知道它是<code class="fe nd ne nf ng b">tf.Keras</code>还是原来的<code class="fe nd ne nf ng b">Keras</code> …哦，好吧。</p><h2 id="02e5" class="mk ld iq bd le ml mm dn li mn mo dp lm ko mp mq lo ks mr ms lq kw mt mu ls mv bi translated">API 重构</h2><p id="be3e" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">从 v1 手动升级您的旧代码。x 到 v2。x 并不容易。但是 TensorFlow 开发人员通过创建一个脚本来自动重新排序参数、更改默认参数和切换模块名称空间，从而减少了这种痛苦。</p><p id="7323" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自<a class="ae lb" href="https://www.tensorflow.org/guide/effective_tf2" rel="noopener ugc nofollow" target="_blank">指南</a>:</p><blockquote class="of og oh"><p id="066c" class="kf kg nb kh b ki kj jr kk kl km ju kn oi kp kq kr oj kt ku kv ok kx ky kz la ij bi translated">很多 API 在 TF 2.0 中要么没有了，要么移动了。一些主要的变化包括移除<code class="fe nd ne nf ng b"><em class="iq">tf.app</em></code>、<code class="fe nd ne nf ng b"><em class="iq">tf.flags</em></code>和<code class="fe nd ne nf ng b"><em class="iq">tf.logging</em></code>以支持现在开源的 absl-py，重新组织存在于<code class="fe nd ne nf ng b"><em class="iq">tf.contrib</em></code>中的项目，以及通过将较少使用的函数移动到类似<code class="fe nd ne nf ng b"><em class="iq">tf.math</em></code>的子包中来清理主<code class="fe nd ne nf ng b"><em class="iq">tf.*</em></code>名称空间。一些 API 已经被替换为它们的 2.0 等效版本- <code class="fe nd ne nf ng b"><em class="iq">tf.summary</em></code>、<code class="fe nd ne nf ng b"><em class="iq">tf.keras.metrics</em></code>和<code class="fe nd ne nf ng b"><em class="iq">tf.keras.optimizers</em></code>。自动应用这些重命名的最简单方法是使用 v2 升级脚本。</p></blockquote><h1 id="c5b2" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">结论</h1><p id="e7d2" class="pw-post-body-paragraph kf kg iq kh b ki mw jr kk kl mx ju kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">Pandas 反对在其名称空间中使用 NumPy 和 datetime，并建议用户直接导入它们。但是 TensorFlow 建议使用 Tensorflow 内部的 Keras，而不是直接导入它。🤷‍♂️</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ol"><img src="../Images/a0cb9291ad99d74d8a83a4705d924239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rFW4kjSDfM_SFYe0wghe4Q.png"/></div></div></figure><p id="03fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你觉得这很有用。如果有你认为应该包含的大功能，请告诉我。</p><p id="02af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！</p><p id="5952" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">挑战问题的答案</strong>:</p><pre class="lv lw lx ly gt nh ng ni nj aw nk bi"><span id="b381" class="mk ld iq ng b gy nl nm l nn no">In[12]: ((True | pd.NA) &amp; True) | (False &amp; (pd.NA | False))<br/>Out[12]: True</span></pre></div></div>    
</body>
</html>