<html>
<head>
<title>Fairly Allocating Debts Using the Talmud and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用犹太法典和Python公平分配债务</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fairly-allocating-debts-using-the-talmud-and-python-b3946f7f6fc8?source=collection_archive---------38-----------------------#2020-05-08">https://towardsdatascience.com/fairly-allocating-debts-using-the-talmud-and-python-b3946f7f6fc8?source=collection_archive---------38-----------------------#2020-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f96e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用博弈论分割遗产的古老方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/beab1c4c136f81b914b24752d8dac95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d0yrmiEAHYhCCFkh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">坦纳·马迪斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据Experian的一项研究，2016年10月至12月间死亡的73%的美国人都有一些未偿还的债务<a class="ae ky" href="https://www.credit.com/blog/americans-are-dying-with-an-average-of-62k-of-debt-168045/" rel="noopener ugc nofollow" target="_blank">【1】</a>。不幸的是，负债而死对许多人来说是一种新常态，我预计这一比例在未来还会增加。尽管逃了税，但当你死后，债务不会简单地消失。未偿还的债务通常会通过你的遗产来收回，除非你使用退休账户或人寿保险来保护自己免受债权人的伤害。如果你的遗产不能偿还所有债务怎么办？你的债务如何公平分配？</p><h2 id="b0ba" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">债务分配方法</h2><ul class=""><li id="47a3" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">平均分配</li></ul><p id="d12a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照债权人的数量平均分配遗产</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="17a9" class="lv lw it na b gy ne nf l ng nh">Estate = 100<br/>Creditors = [100, 200, 300]</span><span id="28f5" class="lv lw it na b gy ni nf l ng nh">## Equal Division</span><span id="dbd5" class="lv lw it na b gy ni nf l ng nh">Payments = {'0_100': 33.33, '1_200': 33.33, '2_300': 33.33}</span></pre><p id="066d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，每个债权人得到33 1/3美元。</p><ul class=""><li id="0cb6" class="mo mp it lb b lc ld lf lg li nj lm nk lq nl lu mv mw mx my bi translated">比例除法</li></ul><p id="f34e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比例分割将更多的财产判给最高的债权人</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7a24" class="lv lw it na b gy ne nf l ng nh">Estate = 300<br/>Creditors = [100, 200, 300]</span><span id="a229" class="lv lw it na b gy ni nf l ng nh">## Equal Division</span><span id="fc7f" class="lv lw it na b gy ni nf l ng nh">Payments = {'0_100': 50, '1_200': 100, '2_300': 150}</span></pre><p id="12c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，每个债权人将获得其要求金额的一半，最大的债权人将获得最大的一笔金额。</p><ul class=""><li id="748f" class="mo mp it lb b lc ld lf lg li nj lm nk lq nl lu mv mw mx my bi translated">犹太法典部</li></ul><p id="0b7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到1985年，Robmann Aumann和Michael Maschler编写了一种算法来解决下面的奇怪除法，这种方法仍然是一个数学之谜:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9822" class="lv lw it na b gy ne nf l ng nh">Estate = 200<br/>Creditors = [100, 200, 300]</span><span id="162a" class="lv lw it na b gy ni nf l ng nh">## Equal Division</span><span id="5277" class="lv lw it na b gy ni nf l ng nh">Payments = {'0_100': 50, '1_200': 75, '2_300': 75}</span></pre><p id="6be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拆分既不是等额拆分，也不是比例拆分。分割实际上是基于竞争金额的<strong class="lb iu">等分。</strong></p><h2 id="dbc3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">该算法</h2><p id="8beb" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">下面的五个步骤详细说明了由Aumann和Maschler提出的有争议的和算法的等分。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><ol class=""><li id="fab6" class="mo mp it lb b lc ld lf lg li nj lm nk lq nl lu nw mw mx my bi translated">按从低到高的顺序排列债权人</li><li id="92af" class="mo mp it lb b lc nx lf ny li nz lm oa lq ob lu nw mw mx my bi translated">在所有债权人之间平均分配财产，直到最低的债权人得到一半的债权</li><li id="ade9" class="mo mp it lb b lc nx lf ny li nz lm oa lq ob lu nw mw mx my bi translated">删除最低的债权人，重复步骤2，直到所有债权人拥有一半的索赔权或产业是空的</li><li id="60f7" class="mo mp it lb b lc nx lf ny li nz lm oa lq ob lu nw mw mx my bi translated">反向操作:从遗产中给予最高债权人，直到损失(分配和索赔之间的差额)等于次高债权人的损失。</li><li id="e004" class="mo mp it lb b lc nx lf ny li nz lm oa lq ob lu nw mw mx my bi translated">重复第4步，直到所有的钱都分配完</li></ol></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="c3ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定算法后，我想创建一个函数来实现一个有争议的和的等分。我写了带有债务函数的talmud _ debts包来完成这个任务。还有一个带有jupyter笔记本实现的<a class="ae ky" href="https://github.com/Datadolittle/Talmud_Debts" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="303f" class="lv lw it na b gy ne nf l ng nh">pip install talmud_debts</span></pre><p id="e67e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将安装带有债务功能的软件包。要运行该函数，请导入talmud _ debts并在python中调用debits函数。预期的参数是遗产大小(整数)和要支付的债权人数组。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a447" class="lv lw it na b gy ne nf l ng nh">from talmud_debts import debts</span><span id="e08c" class="lv lw it na b gy ni nf l ng nh">Estate = 200<br/>Creditors = [100,200, 300]</span><span id="b805" class="lv lw it na b gy ni nf l ng nh">debts(Estate, Creditors)</span></pre><p id="b581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是一个有序的字典，债权人由一个索引定义，然后是债务金额。0_100表示最低债权人的预期支出。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h2 id="a390" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">Python中算法的伪代码</h2><p id="b110" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><strong class="lb iu">步骤1–3</strong></p><p id="6651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是对数组进行排序，使债务从索引0处的最低值到索引n处的最高值。我生成了一些帮助器函数来为字典值添加一个或一个浮点数。我使用了for和while循环O(N**2)来分配所有债权人，直到至少一半的债务被给予最低的债权人。我跳出了循环，用值更新了第二个字典，然后删除了最低的债权人。</p><p id="a73e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤4–5</strong></p><p id="73e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个while循环，for循环组合用于获得债权人的最新损失。如果破产财产少于最高债权人的损失与次高债权人的损失之间的差额，则将剩余部分分配给损失最大的债权人。否则，在具有最大损失的债权人匹配下一个最大损失之后，循环重复。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="74a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，这个算法实现既有趣又有挑战性。实现这个算法的想法来自Presh Talwalkar的书<a class="ae ky" href="https://www.amazon.com/Joy-Game-Theory-Introduction-Strategic/dp/1500497444" rel="noopener ugc nofollow" target="_blank"> <em class="oc">《博弈论的快乐》</em> </a>。该算法适用于任何数量的债权人和任何规模的财产。如果遗产规模大于债权人的总和，该函数将打印一个声明，说明所有债务都可以支付。我可以在LinkedIn上找到我，我希望我们能像兰尼斯特家一样，永远偿还我们的债务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/45f3bfea3a8882cdffb0a44a9e646025.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*ZlTyw5roLrrwKDS8V8V8Ug.png"/></div></figure></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="3843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]<a class="ae ky" href="https://www.credit.com/blog/americans-are-dying-with-an-average-of-62k-of-debt-168045/" rel="noopener ugc nofollow" target="_blank">https://www . credit . com/blog/Americans-are-dead-in-a-average-62k-of-debt-168045/</a></p><p id="e762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]<a class="ae ky" href="https://www.msn.com/en-us/money/personalfinance/on-average-americans-die-with-dollar61000-in-debt-who-pays/ar-BBMBgqM" rel="noopener ugc nofollow" target="_blank">https://www . MSN . com/en-us/money/personal finance/on-average-Americans-die-with-dollar 61000-in-debt-who-pays/ar-BBMBgqM</a></p><p id="0ac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3]http://www.cs.cmu.edu/~arielpro/15896s15/docs/paper8.pdf<a class="ae ky" href="http://www.cs.cmu.edu/~arielpro/15896s15/docs/paper8.pdf" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>