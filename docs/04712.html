<html>
<head>
<title>Understanding ARIMA (Time Series Modeling)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解ARIMA(时间序列建模)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-arima-time-series-modeling-d99cd11be3f8?source=collection_archive---------5-----------------------#2020-04-26">https://towardsdatascience.com/understanding-arima-time-series-modeling-d99cd11be3f8?source=collection_archive---------5-----------------------#2020-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/68e7372074746a22377536334a7e0ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*llOS5WvMvgCCG5R-"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">杰克·希尔斯在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="fb63" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">利用过去来预测未来</h2></div><p id="3015" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">那句老马克·吐温的名言是什么来着？"历史不会重演，但它经常会重复。"</p><p id="2791" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我喜欢分析时间序列。所以当我说我认为马克·吐温是对的时，我可能是有偏见的。我们绝对应该以怀疑的态度对待所有的预测——未来本质上是不确定的，无论多少计算或数据都无法改变这一事实。但是通过观察和分析历史趋势，我们至少可以解开一小部分的不确定性。</p><p id="62c6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> ARIMA模型是线性回归模型的一个子集，它试图使用目标变量的过去观察值来预测其未来值。ARIMA模型的一个关键方面是，在其基本形式中，它们不考虑外生变量。更确切地说，预测纯粹是用目标变量的过去值(或从那些过去值精心制作的特征)做出的。</strong></p><p id="acbe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> ARIMA代表自回归综合移动平均线。让我们浏览一下ARIMA模型的每一部分，以便充分理解它。</strong></p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="e18b" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">AR:自回归</h1><p id="f1c3" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">这是最简单的部分。<strong class="la jk">自回归意味着我们对目标变量自身的过去值进行回归。</strong>也就是说，我们使用目标变量的滞后值作为X变量:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="807b" class="nq ml jj nm b gy nr ns l nt nu">Y = B0 + B1*Y_lag1 + B2*Y_lag2 + ... + B<strong class="nm jk"><em class="nv">n</em></strong>*Y_lag<strong class="nm jk"><em class="nv">n</em></strong></span></pre><p id="4873" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很简单。这个等式说的是Y的当前观察值是它过去的<strong class="la jk"> <em class="nv"> n </em> </strong>值的某个线性函数(其中<strong class="la jk"> <em class="nv"> n </em> </strong>是我们选择的一个参数；以及B0、B1等。是我们在训练模型时适合的回归betas)。前面的等式通常被称为AR( <strong class="la jk"> <em class="nv"> n </em> </strong>)模型，其中<strong class="la jk"> <em class="nv"> n </em> </strong>表示滞后的数量。通过稍微改变符号，我们可以很容易地预测未来:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="63c6" class="nq ml jj nm b gy nr ns l nt nu">Y_forward1 = B0 + B1*Y + B2*Y_lag1 + B3*Y_lag3 + ... B<strong class="nm jk"><em class="nv">n</em></strong><em class="nv">*</em>Y_lag<strong class="nm jk"><em class="nv">(n-1)</em></strong></span></pre><p id="db08" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们使用当前值及其过去的滞后值来预测未来值(提前1个时间步)。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="fec3" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">I:集成</h1><p id="4edc" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated"><strong class="la jk">集成表示我们对数据应用差分步骤。也就是说，不是像下面这样运行回归:</strong></p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="1782" class="nq ml jj nm b gy nr ns l nt nu">Y_forward1 = B0 + B1*Y + B2*Y_lag1 + ...</span></pre><p id="c242" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们这样做:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="bff8" class="nq ml jj nm b gy nr ns l nt nu">Y_forward1 - Y = B0 + B1*(Y - Y_lag1) + B2*(Y_lag1 - Y_lag2) + ...</span></pre><p id="4c04" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二个方程的意思是，Y的未来变化是Y的过去变化的线性函数，为什么要用差分呢？原因是差异通常比原始的无差异值更稳定。当我们做时间序列建模时，我们希望我们的Y变量是<strong class="la jk">均值方差平稳</strong>。这意味着一个模型的主要统计特性不会因为取样时间的不同而改变。建立在静态数据上的模型通常更稳健。</p><p id="55f0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以真实GDP(真实意味着它已经被通货膨胀调整)为例。从图中可以明显看出，原始GDP数据不是稳定的。它的上升使得图表前半部分的平均GDP比后半部分的低很多。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/0c28118a1184339fe2c8bdd63ddc5931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bl8ktX-5ms206KDhSPOZMQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">美国实际国内生产总值(来源:圣路易斯美联储银行)</p></figure><p id="52f2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们对这些数据求差，就会得到下面的曲线图。请注意，它现在明显更加稳定(多年来平均值和方差大致一致)。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/5862e61d2f5fae66364ed9635f4fb514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWvEICoL9asz3b1Sjr9HWg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">实际国内生产总值的变化更加平稳</p></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="6fab" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">马:移动平均线</h1><p id="456f" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">当我第一次研究时间序列时，我假设移动平均只是Y变量的移动平均(例如，200天的移动平均)。尽管它们在精神上有些相似，但它们是不同的数学实体。</p><p id="3cae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">移动平均模型由以下等式总结:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="43ff" class="nq ml jj nm b gy nr ns l nt nu">Y = B0 + B1*E_lag1 + B2*E_lag2 + ... + B<strong class="nm jk"><em class="nv">n</em></strong>*E_lag<strong class="nm jk"><em class="nv">n</em></strong></span></pre><p id="409e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似于AR部分，我们在这里用历史值做一些事情，因此所有的滞后。但是这个E是什么？在对MA模型的大多数解释中，e通常被称为误差，它表示模型和目标变量之间的随机剩余偏差(如果您问我们在拟合模型之前怎么可能会有误差，请稍等片刻)。</p><p id="d43c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本回归模型的完整等式是:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="88be" class="nq ml jj nm b gy nr ns l nt nu">Y = B0 + B1*X + E</span></pre><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/d8af0f030fec578b998604b46eb21b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ZmsmS1ouqarEUTCjTYPaA.jpeg"/></div></div></figure><p id="7c17" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要方程中的E来表明回归输出B0 + B1*X仅仅是y的近似值。左边的图说明了我的意思。黑点是我们试图预测的，蓝线是我们的预测。虽然我们成功地捕捉到了总体趋势，但总会有一些无法捕捉的特殊变化。E项说明了这个未被捕获的部分——换句话说，<strong class="la jk"> E代表精确答案和我们的模型提供的近似正确答案之间的差异。</strong></p><p id="0c2b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，如果你一直在仔细阅读，你可能会问，“难道我们不需要先有一个模型，然后才会有模型错误吗？”你完全正确。e是我们所说的不可观测的参数。与Y(我们的目标变量)或外生X变量的滞后值不同，E不可直接观察到。另一方面，这也意味着我们不能用OLS来拟合ARIMA模型(因为我们有不可观测的参数)。相反，我们需要像<a class="ae jg" rel="noopener" target="_blank" href="/understanding-maximum-likelihood-estimation-mle-7e184d3444bd"> MLE(最大似然估计)</a>这样的迭代估计方法，它可以同时估计β参数和残差(以及残差项上的β)。</p><blockquote class="nz"><p id="8224" class="oa ob jj bd oc od oe of og oh oi lt dk translated">所以MA模型使用模型过去的误差来预测Y(类似于AR模型，我们告诉它我们希望它考虑多少过去的误差)。</p></blockquote><p id="dffb" class="pw-post-body-paragraph ky kz jj la b lb oj kk ld le ok kn lg lh ol lj lk ll om ln lo lp on lr ls lt im bi translated">让我们花一点时间来思考一下为什么会这样。考虑以下简化的MA(1)模型:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="1198" class="nq ml jj nm b gy nr ns l nt nu">Y = u + B1*E_lag1</span><span id="b076" class="nq ml jj nm b gy oo ns l nt nu">where u = the mean of Y</span><span id="83c1" class="nq ml jj nm b gy oo ns l nt nu">E = Y - predicted</span></pre><p id="058e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">第一项，u，意味着我们的模型围绕Y </strong>的均值进行预测(就像说不知道别的，我就猜均值)。第二项B1*E_lag1是误差所在。让我们假设现在我们估计B1是0.2。<strong class="la jk">而误差(E)被定义为Y的实际值减去模型的预测值。</strong></p><p id="1a58" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">这意味着如果最近的误差(E_lag1)为正(意味着实际误差大于我们的预测)，我们将把预测误差上调1/5。</strong>这具有使模型的错误稍微减少的效果(因为第二项B1*E_lag1将模型的预测稍微推向正确答案)。</p><p id="dbae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，如果模型知道自己的错误，那么为什么它不经常过度拟合(换句话说，为什么我们不通过不公平地给它一些答案来偏置我们的模型)？除了过度拟合，MA模型没有固有的偏差，因为模型误差是独立的，并且近似正态分布(误差是一个随机变量)。因为它们是随机变量，误差(E_lag1)可以根据它们被观察的时间步长而呈现出非常不同的值。误差中的这种固有噪声意味着，仅用一个β(B1)来拟合，几乎不可能找到一个B1来完美地调整每个误差，以便他们的产品完美地填补实际和预测Ys之间的每个漏洞。换句话说，<strong class="la jk">MA(1)模型只能利用它对误差的了解，非常近似地将自己推回到正确的方向。</strong></p><p id="5236" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，像任何其他模型一样，我们可以通过允许更多的特征来过度拟合MA模型，在这种情况下，将会有越来越多的滞后误差(这意味着拟合更多的betas)。但是这样一个过度拟合的模型在样本之外会表现得很糟糕。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="5c83" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">ARIMA实际国内生产总值预测</h1><p id="c057" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">让我们通过建立一个ARIMA模型来预测实际GDP，从而将所有这些放在一起。我们将使用ARIMA的statsmodel实现。我从FRED(圣路易斯美联储银行的数据仓库)中提取了真实GDP的数据。</p><p id="3d88" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">statsmodel中的ARIMA函数至少需要两个参数:</p><ol class=""><li id="7a18" class="op oq jj la b lb lc le lf lh or ll os lp ot lt ou ov ow ox bi translated">数据——在这种情况下，我们给它一个熊猫系列的原始实际GDP值(我们不需要提前求差，因为ARIMA算法会为我们做)。</li><li id="a142" class="op oq jj la b lb oy le oz lh pa ll pb lp pc lt ou ov ow ox bi translated">第二个参数order告诉ARIMA函数，在下面的序列中要考虑每种模型类型的多少个组件— (AR滞后，差值之间的时间步长，MA滞后)。</li></ol><p id="116d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看AR(4)模型是什么样子的(没有MA)。我们采用1个时间步长差值，使数据保持稳定:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="d1f0" class="nq ml jj nm b gy nr ns l nt nu">from statsmodels.tsa.arima_model import ARIMA</span><span id="5c1c" class="nq ml jj nm b gy oo ns l nt nu">mod = ARIMA(master_df['GDP'], order=(4,1,0))<br/>mod.fit()<br/>predictions = mod.fit().predict()</span></pre><p id="f1e2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的预测绘制在下图中。如果你仔细观察，橙色线(我们的预测)落后于蓝色线(实际)。这很糟糕。这意味着我们的预测总是落后于现实；因此，如果我们遵循这种模式，我们将永远落后几步。但这是AR模型的预期，AR模型试图通过推断最近的过去来预测未来(如果有那么简单就好了)。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pd"><img src="../Images/15eedf709af7d8b7a2e6fc761562114f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84wQa0rok0G32XGd1-aTuA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">AR(4)模型</p></figure><p id="dede" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样重要的是要注意，在这个演示中，我并没有将一个训练集和一个测试集分开；我使用整个数据集来拟合我的参数(而不是扩展窗口)。在实践中，我们希望对模型的样本外预测能力进行更加稳健的测试。因此，我们希望使用时间点数据(而不是修正后的GDP数据)和扩展窗口回归，以便在每个时间点，我们仅使用历史上该时间点的可用数据来估计参数。</p><p id="1306" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们将2 MA元件添加到模型中:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="2ac2" class="nq ml jj nm b gy nr ns l nt nu">mod = ARIMA(master_df['GDP'], order=(4,1,2))<br/>mod.fit()<br/>predictions = mod.fit().predict()</span></pre><p id="6c1d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经通过允许模型考虑其误差的大小和方向，赋予了模型稍微修正航向的能力。这是以更长的模型估计过程为代价的——最大似然估计需要一些时间来收敛，而OLS则非常快。让我们看看我们的新预测是什么样的:</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pd"><img src="../Images/72a437390670a0e4a282babd84a88c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTW2hvRyMF1zobdBak7LwQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">具有4个AR滞后和2个MA滞后的ARIMA</p></figure><p id="109f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也好不到哪里去。但是我们不应该期望仅仅通过增加几个MA组件就能获得巨大的改进。AR和MA分量都来自目标变量的过去值，因此它们都是通过外推过去来预测未来的尝试。你可能会认为这在平静时期行得通，但在试图预测转折点时会遭遇惨败。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="b10c" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated"><strong class="ak">结论</strong></h1><p id="503d" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">因此，在经历了这一切之后，我们最终得到了一个乏善可陈的模型。但是不要绝望。ARIMA模型并不意味着是一个完美的预测工具。相反，这是第一步。从我们的目标变量的过去值导出的特征意味着是外生变量的补充而不是替代。因此，在现实中，我们的GDP模型不仅包括AR和MA组件，还包括与GDP密切相关的外生组件，如通货膨胀、股票回报、利率等。</p><p id="f607" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，拟合的测试版本身也常常令人感兴趣。例如，如果我们正在构建实际GDP的模拟，那么我们需要测量GDP的自相关性(自相关性是指GDP的当前变化与其过去值之间的相关性)。因为如果存在自相关，那么我们肯定不想建立一个GDP模型，在这个模型中，我们模拟每个季度的GDP变化，而不考虑其他因素。那将是错误的，我们的模型将产生脱离现实的结果。因此，分析ARIMA模型的贝塔系数有助于我们更好地理解感兴趣的目标变量的统计特性。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="86e6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://tonester524.medium.com/membership" rel="noopener"> <strong class="la jk"> <em class="nv">如果你总体上喜欢这篇文章和我的写作，请考虑通过我在这里的推荐链接注册Medium来支持我的写作。谢谢！</em> </strong> </a></p></div></div>    
</body>
</html>