<html>
<head>
<title>AOS: Wrangle Nested Data with Regex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AOS:用正则表达式争论嵌套数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/aos-wrangle-nested-data-with-regular-exprs-5510a27bab13?source=collection_archive---------56-----------------------#2020-04-24">https://towardsdatascience.com/aos-wrangle-nested-data-with-regular-exprs-5510a27bab13?source=collection_archive---------56-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="dc5d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">U的形状？</h1><p id="cd5f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">开发人员花费大量时间<em class="lm">破译</em>传入数据的结构，以便进行转换。考虑下面的代码，它从一个特定的<em class="lm"> url </em>请求数据。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="b1c3" class="lw jr it ls b gy lx ly l lz ma">import requests<br/>data = requests.get(url, options).text #request data from url<br/># data: {'f1': .. , 'f2': [{...}, {...}, ...]}</span></pre><p id="39f4" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">这里返回的<code class="fe mg mh mi ls b">data </code>的<em class="lm">形状</em>是什么？这里缺少传入的<code class="fe mg mh mi ls b">data</code>的<em class="lm">模式</em>，所以您的最佳选择是打印<code class="fe mg mh mi ls b">data</code>和/或猜测其结构。</p><p id="f4ab" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">无法用<em class="lm">系统地描述</em>和<em class="lm">探测</em>数据<em class="lm">形状</em>使得编写数据转换器和管道非常困难。<br/> *数据采用异构形式:JSON、XML、表格、张量、组合。<br/> *许多API(每个库一个)——Strings、BeautifulSoup、Pandas、Numpy、… <br/> * SQL并没有真正实现跨语言的统一。几个定制的变体。</p><p id="77a3" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">每个库都有一个专用的API来处理特定类型的数据，并且有一个重要的学习曲线。</p><ul class=""><li id="8a68" class="mj mk it kq b kr mb kv mc kz ml ld mm lh mn ll mo mp mq mr bi translated">数据<em class="lm">形状</em>在代码中从来都不是显式的，并且经常(短暂地)驻留在开发人员的头脑中。</li><li id="9598" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated">没有明确表示形状的标准方法——例如，许多人使用python类型库，这会变得冗长(<code class="fe mg mh mi ls b">Sequence[Tuple[Tuple[str,int], Dict[str,str]]]</code>)。</li><li id="fca7" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated">猜测形状、打印出它们并学会有效地使用不同的库API是一项艰苦的工作。</li></ul><blockquote class="mx my mz"><p id="71a6" class="ko kp lm kq b kr mb kt ku kv mc kx ky na md lb lc nb me lf lg nc mf lj lk ll im bi translated">如果我们有一个<em class="it">统一的</em>，<em class="it">直观的</em>语言来<strong class="kq iu">指定</strong>和<strong class="kq iu">推断</strong>数据的形状，<strong class="kq iu">匹配</strong>和<strong class="kq iu">转换</strong>数据，跨越所有这些异构数据类型，生活将(潜在地)令人敬畏！</p></blockquote></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><blockquote class="nk"><p id="aa98" class="nl nm it bd nn no np nq nr ns nt ll dk translated">我们引入了一种新的类似正则表达式的语言(<strong class="ak"> aos </strong>)和工具来启用通用形状<em class="nu">规范</em>、<em class="nu">推理</em>和<em class="nu">转换</em>，用于<strong class="ak">异构</strong>数据。</p><p id="b9e7" class="nl nm it bd nn no np nq nr ns nt ll dk translated"><a class="ae nv" href="https://github.com/ofnote/aos" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">储存库</strong></a>:<a class="ae nv" href="https://github.com/ofnote/aos" rel="noopener ugc nofollow" target="_blank">https://github.com/ofnote/aos</a></p></blockquote></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="5365" class="jq jr it bd js jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn bi translated">形状与值</h1><p id="4ce6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里快速澄清一下:通过<em class="lm">形状</em>或<em class="lm">模式</em>，我们指的是数据实例的<em class="lm">核心结构</em>或<em class="lm">骨架</em>。可以用许多不同的方式实例化骨架(使用不同的<em class="lm">叶</em>值)来获得不同的数据实例。如果你知道数据库<em class="lm">模式</em>，形状本质上是模式，扩展到其他数据类型。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="c45c" class="lw jr it ls b gy lx ly l lz ma"># data instance<br/>d = { 'a': [1, 2, 3], 'b' : {'c': 1} }</span><span id="0628" class="lw jr it ls b gy ob ly l lz ma"># its 'shape' S<br/># {'a': &lt;list of ints&gt;, 'b' : {'c': int} }</span><span id="8505" class="lw jr it ls b gy ob ly l lz ma"># another instance of S<br/>e = { 'a': [1, 2, 3, 4, 5], 'b' : {'c': 10} }</span></pre></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="db21" class="jq jr it bd js jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn bi translated">与或形状(AOS)</h1><p id="1f1c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">考虑到数据类型的这种异质性，我们如何<strong class="kq iu">系统地表示任意数据实例的形状</strong>？</p><p id="ca7f" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated"><strong class="kq iu">观察</strong>这些数据实例可以被视为<strong class="kq iu">树</strong>(下图)。</p><figure class="ln lo lp lq gt od gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi oc"><img src="../Images/c5f82589568f0fbec82af7daeb9a47cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OFfwHDNnS18zr5REojFnJA.png"/></div></div><p class="ok ol gj gh gi om on bd b be z dk translated">将numpy数组、pandas表、JSON数据可视化为树。</p></figure><p id="f273" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">我们将指定这些树的<em class="lm">形状</em>(对，全部！)使用我们的新语言<strong class="kq iu">AOS</strong>(<em class="lm">and-or shapes</em>)。我们有三个熟悉的操作员:</p><ul class=""><li id="473e" class="mj mk it kq b kr mb kv mc kz ml ld mm lh mn ll mo mp mq mr bi translated"><strong class="kq iu">和</strong> ( &amp;)允许你沿着<strong class="kq iu">树向下</strong>。</li><li id="c3f4" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated"><strong class="kq iu">或</strong> (|)在同一树<em class="lm">级</em>的同级中导航<strong class="kq iu">。</strong></li><li id="9af1" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated">一个<strong class="kq iu">列表中的</strong><em class="lm">=一个<em class="lm">序列</em>中的<strong class="kq iu">或</strong> -s，我们写为<strong class="kq iu"> (item)* </strong>。</em></li></ul></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><p id="8c9c" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">让我们看看这在<strong class="kq iu"> JSON </strong>的上下文中是如何工作的，然后我们将进行归纳。</p><blockquote class="mx my mz"><p id="9d9c" class="ko kp lm kq b kr mb kt ku kv mc kx ky na md lb lc nb me lf lg nc mf lj lk ll im bi translated">考虑JSON值<code class="fe mg mh mi ls b">x = {a: [1,2,3], b: {c: 3, d: 4.0}</code>。</p></blockquote><p id="5fd9" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">我们把<code class="fe mg mh mi ls b">x</code>的<strong class="kq iu">形状</strong>表示为下面的<strong class="kq iu"> aos </strong>表达式:<br/>T2】</p><p id="f73b" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">我们如何<em class="lm">解读</em>这个表达？</p><ul class=""><li id="0ccd" class="mj mk it kq b kr mb kv mc kz ml ld mm lh mn ll mo mp mq mr bi translated"><strong class="kq iu">和</strong>代表每个键值对:例如<code class="fe mg mh mi ls b">c:3 </code>-&gt;-<code class="fe mg mh mi ls b">(c &amp; int)</code></li><li id="b7fe" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated">a <strong class="kq iu"> dict </strong> <code class="fe mg mh mi ls b">{c: 3, d: 4.0} </code>是<strong class="kq iu">和</strong> s: <br/> <code class="fe mg mh mi ls b">(c &amp; int) | (d &amp; float)</code>的序列(<strong class="kq iu">或</strong>)。</li><li id="4894" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated"><strong class="kq iu">列表</strong> <code class="fe mg mh mi ls b">[1,2,3]</code>表示为<code class="fe mg mh mi ls b">(int)*</code>。</li></ul><p id="7b55" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">一般情况下，同一级别的多个字典键<code class="fe mg mh mi ls b">a</code>、<code class="fe mg mh mi ls b">b</code>用<strong class="kq iu">或-和</strong>形状的形式表示:<code class="fe mg mh mi ls b">(a &amp; ...) | (b &amp; ...)</code></p><p id="4237" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">请注意这种语言的一些独特之处:</p><ul class=""><li id="92c7" class="mj mk it kq b kr mb kv mc kz ml ld mm lh mn ll mo mp mq mr bi translated">键或变量没有关联的类型，也就是说，我们没有将类型<code class="fe mg mh mi ls b">List[int]</code>与<code class="fe mg mh mi ls b">a</code>关联，或者将<code class="fe mg mh mi ls b">int</code>与<code class="fe mg mh mi ls b">c</code>关联。</li><li id="c5d6" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated">相反，我们表示键和键所指向的值(的类型):<code class="fe mg mh mi ls b">a &amp; (int)*</code>，<code class="fe mg mh mi ls b">c &amp; int</code>。</li></ul><p id="4c4c" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated"><strong class="kq iu">超越JSON数据</strong>。除了类似JSON的数据，表格、张量以及它们的<em class="lm">嵌套</em> <em class="lm">组合</em>都很容易用aos表示。举个例子，</p><ul class=""><li id="0f36" class="mj mk it kq b kr mb kv mc kz ml ld mm lh mn ll mo mp mq mr bi translated">具有<code class="fe mg mh mi ls b">n</code>行和列(<code class="fe mg mh mi ls b">A</code>、<code class="fe mg mh mi ls b">B</code>、<code class="fe mg mh mi ls b">C)</code>)的表格由aos <code class="fe mg mh mi ls b">(A | B | C) &amp; n</code>表示。或者，等价地，<code class="fe mg mh mi ls b">n &amp; (A | B | C)</code>。</li><li id="4c2b" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated">形状为<code class="fe mg mh mi ls b">(N, C, H, W)</code>的int32张量被表示为<code class="fe mg mh mi ls b">(N &amp; C &amp; H &amp; W &amp; int32)</code>。</li><li id="ca06" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated">带键<code class="fe mg mh mi ls b">a</code>和<code class="fe mg mh mi ls b">b</code>的张量字典(用<code class="fe mg mh mi ls b">.</code>代替<code class="fe mg mh mi ls b">&amp;</code> ): <br/> <code class="fe mg mh mi ls b">(a &amp; (N.C.H.W.float32)) | (b &amp; (B.T.D.long))</code></li></ul><p id="4d56" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">阅读更多关于使用<code class="fe mg mh mi ls b">aos</code> : <a class="ae nv" href="https://github.com/ofnote/aos/blob/master/docs/and-or-thinking.md" rel="noopener ugc nofollow" target="_blank">和-or-style.md </a>建模数据结构的信息</p><p id="e793" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated"><a class="ae nv" href="https://github.com/ofnote/aos" rel="noopener ugc nofollow" target="_blank"> <strong class="kq iu">储存库</strong></a>:<a class="ae nv" href="https://github.com/ofnote/aos" rel="noopener ugc nofollow" target="_blank">https://github.com/ofnote/aos</a></p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="bf70" class="jq jr it bd js jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn bi translated">紧凑的形状</h1><p id="2f2d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">aos与现有的模式描述相比如何？</p><p id="a809" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">请注意这个来自<a class="ae nv" href="https://www.jsonschema.net/home" rel="noopener ugc nofollow" target="_blank">https://www.jsonschema.net/home</a>的示例快照。schema (rhs)非常<em class="lm">冗长:</em>不能很快搞清楚数据的形状。</p><figure class="ln lo lp lq gt od gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi oo"><img src="../Images/66cea2872d20422e71608b02d3ae6cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0n6tcKfj1DmiltVl-Xv3g.png"/></div></div><p class="ok ol gj gh gi om on bd b be z dk translated">左:JSON数据。右图:它的模式表示。</p></figure><p id="f256" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">相反，考虑相应的aos表达式:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="4993" class="lw jr it ls b gy lx ly l lz ma">( checked &amp; bool <br/>| dimensions &amp; (width &amp; int | height &amp; int)<br/>| id &amp; int <br/>| name &amp; str <br/>| price &amp; float <br/>| tags &amp; (str *))</span></pre><p id="0380" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">这要简洁得多，快速浏览一下就能准确揭示JSON数据的形状。这太棒了！如果数据嵌套很深或者有大量的记录，这就更有用了！</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><blockquote class="nk"><p id="dd67" class="nl nm it bd nn no np nq nr ns nt ll dk translated">在实践中，aos对于构建数据管道有多大用处？</p></blockquote></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="972d" class="jq jr it bd js jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn bi translated">AOS:(推断|验证|转换)&amp;数据</h1><p id="b53f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">AOS在几个方面有助于构建健壮的数据管道。</p><ul class=""><li id="e96b" class="mj mk it kq b kr mb kv mc kz ml ld mm lh mn ll mo mp mq mr bi translated">处理<em class="lm">不透明的</em>数据- &gt; <strong class="kq iu">从数据中推断出</strong>形状。使用<code class="fe mg mh mi ls b">aos.infer</code></li><li id="fb24" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated">交叉- <strong class="kq iu">检查</strong>输入数据形状- &gt; <strong class="kq iu">使用<code class="fe mg mh mi ls b">aos.instanceof</code>验证</strong></li><li id="aa8b" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated"><strong class="kq iu">使用<code class="fe mg mh mi ls b">aos.tfm</code> <em class="lm">转换</em></strong>数据(输入- &gt;输出<em class="lm"> aos </em>)。</li><li id="fb6c" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated">去<strong class="kq iu">超越</strong> <strong class="kq iu"> JSON </strong>？<em class="lm">熊猫</em>表格，<em class="lm"> Numpy </em>张量，XML，…..，甚至还有<br/> <em class="lm">张量字典的表</em>。</li><li id="bafc" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated">与现有数据库的接口:pandas，numpy，xarray，Spark，Kafka，TileDB，…</li></ul><p id="3004" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated"><strong class="kq iu">局部形状。</strong>在许多情况下，复杂数据形状(许多字段或深层嵌套)中只有一小部分是相关的<em class="lm">。</em>我们可以使用<em class="lm">通配符</em>编写部分形状来表示数据子树:<code class="fe mg mh mi ls b"><em class="lm">_</em></code>、<code class="fe mg mh mi ls b"><em class="lm">...</em></code>，只针对数据实例的相关部分。当字典键不相关时，我们可以把形状写成<code class="fe mg mh mi ls b">(str &amp; int)*</code>而不是<code class="fe mg mh mi ls b">(a &amp; int | b &amp; int | c &amp; int)</code>。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="bf9c" class="jq jr it bd js jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn bi translated">转换</h1><p id="6786" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最酷的部分是如何执行数据转换，只使用<code class="fe mg mh mi ls b">aos </code>。这使我们能够避免记忆和费力地通过pandas / numpy /…的几个API，并且简单地使用aos进行大多数(如果不是全部)数据转换。</p><p id="bec2" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">为了将输入数据转换为输出数据，我们编写了形式为<code class="fe mg mh mi ls b">lhs -&gt; rhs</code>的aos规则，其中<code class="fe mg mh mi ls b">lhs</code>和<code class="fe mg mh mi ls b">rhs</code>都是aos表达式。<code class="fe mg mh mi ls b">lhs</code>表达式<em class="lm">将</em>与输入数据匹配，<code class="fe mg mh mi ls b">lhs</code> <em class="lm">中的变量<code class="fe mg mh mi ls b">V</code>将</em>与部分输入数据绑定。output <code class="fe mg mh mi ls b">rhs</code>表达式指定了输出数据的形状，并使用了之前绑定的变量<code class="fe mg mh mi ls b">V</code>。</p><p id="e663" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">这里有几个使用JSON数据的快速<em class="lm">转换</em>示例。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="3e8d" class="lw jr it ls b gy lx ly l lz ma">from aos.tfm import do_tfm</span><span id="ec1f" class="lw jr it ls b gy ob ly l lz ma">d1 = {<br/>    "a": 1, "b": 2, "c": 3<br/>}  <br/># shape: (a &amp; int) | (b &amp; int) | (c | int)</span><span id="63c1" class="lw jr it ls b gy ob ly l lz ma">do_tfm(d1, 'a &amp; v -&gt; x &amp; y &amp; v') #v on lhs binds to value '1'<br/>#output: {x : {y: 1}}</span><span id="ea3e" class="lw jr it ls b gy ob ly l lz ma">################################</span><span id="7447" class="lw jr it ls b gy ob ly l lz ma">d2 = [{ "x": 1 }, { "x": 2 }]      # shape (x &amp; int)*</span><span id="100d" class="lw jr it ls b gy ob ly l lz ma">rule = '(x &amp; v)* -&gt; x &amp; (v)*' <br/>#v on lhs binds to values '1' and '2' iteratively</span><span id="4c19" class="lw jr it ls b gy ob ly l lz ma">do_tfm(d2, rule) </span><span id="b364" class="lw jr it ls b gy ob ly l lz ma">#output: { "x": [1, 2] }</span></pre><p id="91b9" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">规则可以更复杂，例如，包括<em class="lm">条件</em>，<em class="lm">函数</em>应用于查询变量。更多例子<a class="ae nv" href="https://github.com/ofnote/aos/blob/master/tests/test_tfm_spark_json.py" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><p id="6e1e" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated"><code class="fe mg mh mi ls b">aos</code>库正在积极开发中。我们邀请早期反馈和贡献。<a class="ae nv" href="mailto:nishant@offnote.co" rel="noopener ugc nofollow" target="_blank">让我们知道</a>如果aos可以帮助你的数据管道！</p><p id="63b1" class="pw-post-body-paragraph ko kp it kq b kr mb kt ku kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll im bi translated">了解更多关于<code class="fe mg mh mi ls b">aos</code> : <br/> <a class="ae nv" href="https://github.com/ofnote/aos" rel="noopener ugc nofollow" target="_blank"> <strong class="kq iu">知识库</strong></a>:<a class="ae nv" href="https://github.com/ofnote/aos" rel="noopener ugc nofollow" target="_blank">https://github.com/ofnote/aos</a></p></div></div>    
</body>
</html>