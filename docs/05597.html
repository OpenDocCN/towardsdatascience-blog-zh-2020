<html>
<head>
<title>DIY machine learning training pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DIY 机器学习培训管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/diy-machine-learning-training-pipeline-1d408c972804?source=collection_archive---------39-----------------------#2020-05-10">https://towardsdatascience.com/diy-machine-learning-training-pipeline-1d408c972804?source=collection_archive---------39-----------------------#2020-05-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e10a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">或者如何使用 Git 和 CI 服务器自动化您的机器学习培训管道。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fd7c9aeaf083605fb386ecac74a8c671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*alUmwG_20gD8ohGM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@realaxer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">田宽</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="8e1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">机器学习管道不仅仅是一些粘在一起的工具。这是一个过程，通过消除任何平凡的任务或容易出错的步骤，可以使数据科学家和开发人员的生活更加轻松。培训过程的自动化需要许多不同团队成员的协作术语<a class="ae ky" href="https://cloud.google.com/solutions/machine-learning/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning" rel="noopener ugc nofollow" target="_blank"> MLOps </a>已经被用来描述软件工程、机器学习和系统操作的结合，以便将模型投入生产。管理机器学习管道的平台已经存在。在接下来的段落中，将介绍一个使用 Git 和 CI/CD 作为管道核心的解决方案。</p><p id="421f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写这篇文章的原因是:</p><ul class=""><li id="fa6f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">强调构建机器学习管道时遇到的基本部分和最常见的问题。</li><li id="543e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">提出一个培训管道的设计方案，供较小的团队使用，而不需要在部署方面付出很大的努力。</li></ul><h1 id="8eb4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">培训渠道</h1><p id="05af" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们从一个典型的机器学习训练管道的描述开始。这些管道由三个步骤组成:</p><ul class=""><li id="4f75" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">数据集准备</li><li id="f680" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">模特培训</li><li id="dbaa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">部署模型</li></ul><p id="732d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每一步都有自己的细节。</p><h2 id="f786" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">数据集准备</h2><p id="92ed" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">数据可能来自不同格式的不同来源。它们需要被合并、清理、转换等。输出是可用于训练模型的数据集。将这些数据集存储在一个便于团队中的每个人或观众检索的地方非常重要。为了重现过去的实验结果或测试解决问题的不同方法，也需要数据集。数据集也需要是不可变的。例如，数据集可以从数据库生成。数据库是其数据的快照，并且随着每次更新而快速变化。即使使用完全相同的参数运行相同的数据集生成脚本，也可能会产生不同的数据集。一种流行的解决方案是将生成的文件存储在一些对象存储中，如亚马逊 S3 或谷歌云存储，通常使用一些对象的键/路径的约定。</p><p id="f1d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个经常被忽视的方面是，生成数据集的代码是可以从数据集中发现的(反之亦然)。这有助于生成包含更多数据的更新版本的数据集，或者在修复错误后创建修订版本。</p><p id="eea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，了解数据集是如何生成的也很重要。使用了哪些数据库连接，作为输入传递的任何参数等等。</p><h2 id="f7b1" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">模特培训</h2><p id="4cc3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">一旦数据集准备好，就可以用于实验。训练过程可能产生多个工件(模型、报告、标度、词汇等)。此外，尝试不同的解决方案或迭代最佳性能模型是很常见的。有很多工具可以跟踪单个模型的性能。然而，他们中的大多数缺乏将结果/报告与生成的工件联系起来的方法。</p><p id="69f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像数据集准备一样，模型训练通常会产生许多不同的代码分支，每个分支用于不同的实验。保持模型源代码、用作输入的数据集和生成的模型/报告之间的联系非常有用。</p><p id="fa59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，必须记录运行模型所需的任何参数或配置。如果您在笔记本电脑或 EC2 实例上通过手动键入培训命令来运行培训，您很可能会丢失或忘记这些信息。</p><h2 id="5fbc" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">部署</h2><p id="13bc" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们成功了。我们有一个看起来很有前景的模型，您希望将其部署到生产中。我不打算详细说明，但这可能有许多不同的工作方式，包括</p><ul class=""><li id="8230" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">通过 RESTful 端点提供模型，</li><li id="703c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">处理来自流或队列的事件，或者</li><li id="7518" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">批处理输入数据。</li></ul><p id="a235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们需要确保部署了模型的正确版本。一个非常糟糕的做法是手动复制训练好的模型。这可能会引入很多错误。模型可能是错误的版本，或者 REST 端点可能有更新的代码，并且它可能与模型的代码不兼容。</p><h1 id="0f40" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">要求</h1><p id="f8ca" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">记住以上所有内容，我们可以为构建机器学习培训管道创建一个需求列表。</p><ul class=""><li id="1c39" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">数据集必须“易于”访问。</li><li id="0b8f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据集必须进行版本化。</li><li id="b914" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">必须能够确定用于创建数据集的代码。</li><li id="cd24" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据集生成必须自动化。</li><li id="774f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">必须能够生成数据集的不同版本。</li><li id="c778" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">模型训练必须自动化。</li><li id="7216" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">模型必须被版本化。</li><li id="101d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">结果必须是可重复的。</li><li id="8c02" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">必须能够训练不同的模型。</li><li id="68a6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">必须能够确定用于训练模型的代码和数据集的版本。</li><li id="fbf4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据科学家/开发人员必须能够选择部署哪种模型。</li><li id="e0e5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当部署一个模型时，必须能够回溯整个训练过程。</li></ul><h1 id="08e7" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">建立培训流程</h1><p id="f827" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这些要求可以分为三组:</p><ul class=""><li id="7834" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">所有工件(代码、数据集和模型)都需要版本化。每个工件的版本需要以某种方式与所有相关工件的版本相联系。对于每个数据集，必须能够找到相关的代码，对于每个模型，必须能够找到相关的代码和数据集。</li><li id="c701" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据集生成和模型训练等耗时的任务需要自动化。</li><li id="61de" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据科学家/开发人员需要控制部署的内容和时间。</li></ul><h2 id="2cda" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">版本化事物</h2><p id="7e20" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">很明显，代码、数据集和模型的版本控制是最重要的部分之一。这是进行可重复实验和追踪用于生成数据集、特征提取等的代码所必需的。有许多版本控制系统(VCS)允许对代码进行版本控制。Git 是最流行的版本控制系统，可以肯定大多数团队都使用 Git(我希望没有人仍然通过电子邮件交换代码)。实际上，这就是我们将在本文中使用的方法。Git 允许团队在项目的不同部分工作，或者并行工作，在分支中测试不同的解决方案。说到这里，这里有几个假设:</p><ul class=""><li id="391d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">所有代码都存在于 Git 上。</li><li id="4926" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用于生成数据集、训练模型和服务模型的代码位于同一个存储库中。这使得从其他步骤引用代码变得更加容易。你当然可以有其他的库(*只要你注意版本控制)或者使用不同的 repo，但是将所有代码放在一个 repo 中会更容易。</li></ul><p id="8cdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像其他 VCS 一样，Git 在版本控制代码方面非常出色。此外，它允许您保留代码的分支，并选择将哪个分支合并到主分支。第一个想法可能是将其他工件(如数据集和模型)也添加到 Git 中。这是可能的，但有几个问题:</p><ul class=""><li id="a8fa" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">向 Git 添加大文件或二进制文件可能会导致存储库的大小增加，当您想要推送更改或克隆存储库时，会导致非常大的下载量。</li><li id="3b99" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据集生成和模型训练是需要时间的过程。稍后我们将分享一些关于如何自动化它们的想法。这些长时间运行的流程需要将工件提交给 Git repo，这可能会导致合并冲突等问题。</li></ul><p id="5af0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用一些从 Git 到外部系统的“指针”,而不是将文件存储在 Git 中。Git 通过一个惟一的散列来标识不同版本的代码。每当我们运行一些代码并生成一些工件(数据集、模型、报告)时，我们可以使用散列来引用代码的版本。我们也可以做相反的事情。给定一些工件和散列代码，我们可以找到用来生成它们的代码版本。我们需要做的是遵循这些惯例:</p><ul class=""><li id="35fc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">数据集必须存储在包含 git 哈希的路径下的对象存储中。</li><li id="6367" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">模型必须存储在包含 git 散列的路径下的对象存储中。</li><li id="822c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">每当分发代码时，也就是部署到服务器时，git 散列必须与代码一起存储。但是，如果您使用某种版本控制方案，您也可以从版本中获得 git 散列。</li></ul><p id="a943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是等等，有几个问题。用于生成数据集或训练模型的配置参数呢？它们必须存储在 git repo 中。当您实际运行生成工件的代码时，您只需要阅读它们。我们可以将配置文件与代码打包在一起(即在 Docker 映像中)。或者我们可以有一个命令行界面来运行该过程的每一步。配置参数可以作为命令行参数传递，我们可以编写一个包含所有配置的小型 bash 脚本。</p><p id="35d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想测试多个版本呢？我们只是创建不同的分支。然后，我们可以合并，以掌握一个有最好的结果。</p><p id="1262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个问题是，如果一切都基于 git 散列，那么如何将数据集与训练代码联系起来？它们需要共享同一个 git hash 吗？一种方法是共享相同的代码。然而，这不允许我们在同一个数据集上有不同的模型。一个改进的解决方案是将数据集的 git 哈希作为训练脚本配置的一部分进行传递。这允许一系列选项:</p><ul class=""><li id="96fe" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">数据集可能来自任何分支。</li><li id="a82c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">多个模型可能会重用同一个数据集(因为它只是一个链接)。</li></ul><p id="e54c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个 bash 脚本示例。它运行假想的<code class="fe ns nt nu nv b">train</code>命令，负责训练模型。该脚本将存储在 git 存储库中。因此，对它的任何更改都会被版本化。目的是在运行自动化模型训练任务时用作入口点。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="3967" class="ng mk it nv b gy oa ob l oc od">#!/bin/bash</span><span id="d69c" class="ng mk it nv b gy oe ob l oc od"># Dataset version to use. Note that this is the commit hash of <br/># the dataset generation's code, not the hash of current commit!</span><span id="2b91" class="ng mk it nv b gy oe ob l oc od">DATASET_VERSION=da7a1</span><span id="05b3" class="ng mk it nv b gy oe ob l oc od">#  Download dataset<br/>aws s3 cp s3://bucket/project/datasets/${DATASET_VERSION}/dataset.csv data/dataset.csv</span><span id="bf2c" class="ng mk it nv b gy oe ob l oc od">echo "Training model..."</span><span id="a641" class="ng mk it nv b gy oe ob l oc od"># Imaginary command that trains a model using the given parameters<br/>train data/dataset.csv --estimators 50 \<br/>                       --max-depth 10 \<br/>                        --output model.clf<br/>...</span></pre><p id="c242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个聚焦于流的例子。代码在<em class="of">主</em>分支上。创建一个名为<em class="of">数据集</em>的新分支，用于编写数据集生成代码。几次提交之后，代码就准备好了(git hash <strong class="lb iu"> <em class="of"> da7a1 </em> </strong>)。一些神奇的过程(我们将在后面讨论)从分支运行代码，并将数据集的两个文件上传到数据集对象存储。现在数据集生成代码和工件已经“连接”起来了。您可以向分支添加更多的提交，并再次执行相同的操作，或者您可以创建新的分支。您甚至可以并行执行此操作。现在，假设我们对结果很满意，并且<strong class="lb iu"> <em class="of"> da7a1 </em> </strong>被合并回<em class="of">主</em>分支。</p><p id="61b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是用几个模型做实验。创建两个不同的分支，每个模型一个。与数据集生成类似，模型训练将导致在使用 git 散列的路径中上传模型对象存储中的工件。这里需要注意的一点是如何将数据集对象存储中的数据集与模型代码连接起来。如前所述，这可以使用 repo 中的配置文件来完成。该文件可能包含指向数据集或分支哈希的链接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/914bc2735b9b337350fe1d75f200f6dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tDkjPANMIptt36QyJg7qAw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于 Git 的流程示例</p></figure><h2 id="e7a9" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">自动化</h2><p id="092e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">既然我们已经建立了关于每个工件将“生活”在哪里的约定，那么是时候继续自动化各个部分了。数据集生成和模型训练是需要在项目的某个时间点执行的任务。某些进程必须检测代码中的变化，触发任务的执行，并将结果上传到对象存储。由于代码在 VCS 中，持续集成(CI)服务器是一个完美的匹配。CI 服务器能够监视存储库的变化，并根据特定的触发器运行命令。一个真正常见的用例是在创建拉请求时运行单元测试。这样，在合并代码之前，成功的测试执行被强制执行。</p><p id="d04b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的例子，我们可以有以下步骤:</p><ol class=""><li id="7f24" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oh mb mc md bi translated">对代码进行测试(确保我们的更改没有破坏任何东西)。</li><li id="4ba9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oh mb mc md bi translated">运行代码的触发任务。</li><li id="0137" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oh mb mc md bi translated">将结果存储在目标对象存储的正确路径中。</li></ol><p id="19d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步非常明显。步骤#2 取决于它是数据集生成还是模型训练。根据可用的基础架构、数据大小等，有许多不同的方法来执行此操作。以下是一些想法:</p><ul class=""><li id="1344" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在 CI 服务器内部运行—(尽管可能不可行，也不是最佳解决方案)。</li><li id="31fa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">提交给一些始终在线的基础设施(服务器、kubernetes 集群、Kubernetes 作业、Spark 作业等)。</li><li id="ae37" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">提交给允许按需任务的基础设施(如<a class="ae ky" href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html" rel="noopener ugc nofollow" target="_blank"> AWS Sagemaker </a>)。</li></ul><p id="1042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤#3 也可以用不同的方式完成。例如，Spark 可能向 S3 输出一个数据帧。Sagemaker 可以配置为在特定的 S3 路径上传结果。甚至你的代码可以直接上传到 S3 或者使用 AWS CLI 推送。但是，您需要确保 CI 服务器将传递包含 git 散列的路径。</p><p id="f035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子。您的代码公开了用于生成数据集的命令行接口。您可以编写一个像这样的小型 bash 脚本:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="cfef" class="ng mk it nv b gy oa ob l oc od">#!/bin/bash<br/></span><span id="8d96" class="ng mk it nv b gy oe ob l oc od"># Get current git hash (short version)<br/>VERSION=$(git rev-parse --short HEAD | head -c7)</span><span id="bf81" class="ng mk it nv b gy oe ob l oc od">echo "Creating dataset..."</span><span id="c627" class="ng mk it nv b gy oe ob l oc od"># Imaginary command that extracts data from a database and stores <br/># them to a CSV<br/>dataset generate --db-url redshift://user:pass@host:5439/warehouse \<br/>                 --from 2019-01-01<br/>                 --to 2019-12-31<br/>                 --output data/dataset.csv</span><span id="389f" class="ng mk it nv b gy oe ob l oc od">#  Upload generated file to S3<br/>aws s3 cp data/dataset.csv s3://bucket/project/datasets/${VERSION}/dataset.csv</span></pre><p id="3a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行时，它将生成数据集并将文件上传到 S3。使用这种方法的另一个好处是传递给数据集生成脚本的参数也存储在 git repo 中，因为它们是 bash 脚本的一部分。你绝对可以按照同样的逻辑进行模型训练。</p><p id="e0c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，CI 服务器将负责触发任务的执行。但是我们希望什么时候触发任务的执行呢？最简单的方法是对主分支打开拉请求。这可能会触发对分支的每个后续提交的任务的执行(即使是对项目自述文件的一个小的提交)。这是耗时的、资源饥渴的，并且可能产生重复的工件。相反，我们可以依靠数据科学家或开发人员的判断来决定何时开始执行任务。当指示一个 CI 服务器需要准备一个新的项目发布时，类似的事情也会发生。常见的做法是创建一个<a class="ae ky" href="https://git-scm.com/book/en/v2/Git-Basics-Tagging" rel="noopener ugc nofollow" target="_blank">标签</a>。CI 服务器可以在检测到标签时触发任务。更好的是，我们可以根据标签建立一些约定，以便根据标签类型触发不同类型的任务。比如前缀为<code class="fe ns nt nu nv b">dataset/</code>的标签可以用来触发数据集生成，而<code class="fe ns nt nu nv b">experiment/</code>可以用来触发不同模型或实验的训练。下图正好说明了这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/889dd6d7559dcc8703eeedc7f9e07a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*Dzf-WSVPAq30Kw0QCoefjQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于触发任务的 Git 标签</p></figure><p id="cfd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员为数据集生成创建了一个分支。一旦标签(<code class="fe ns nt nu nv b">dataset/1.1</code>)被添加到带有散列<code class="fe ns nt nu nv b">cafe1</code>的提交中，任务就从 CI 服务器中选取，导致数据存储在对象存储中。检查结果后，修复了一个 bug，并推送了一个新的提交。一旦创建了新的标记(<code class="fe ns nt nu nv b">dataset/1.2</code>)，CI 服务器就会运行新的任务，并将其存储到新的位置。</p><p id="7558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，对于训练模型，两个分支可以并行存在。标签被应用，CI 服务器触发模型训练任务。注意，在分支<code class="fe ns nt nu nv b">model2</code>中，标签是在第二次提交时添加的。第一次提交时没有运行任何任务。只有标签存在时，任务才会运行。</p><p id="dbfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说得更专业一点，这里有一个关于如何使用<a class="ae ky" href="https://travis-ci.org/" rel="noopener ugc nofollow" target="_blank"> Travis </a>实现流程的例子:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="19d3" class="ng mk it nv b gy oa ob l oc od">language: python<br/>python:<br/>- '3.6'<br/>git:<br/>  depth: false<br/><br/>jobs:<br/>  include:<br/>  - stage: test<br/>    script: python setup.py test<br/>  - stage: extract dataset<br/>    script: source scripts/generate-dataset.sh<br/>    if: tag =~ /^(dataset\/)/<br/>    before_script:<br/>      - pip install -e .<br/>  - stage: train model<br/>    script: source scripts/train.sh<br/>    if: tag =~ /^(experiment\/)/<br/>    before_script:<br/>    - pip install -e .</span></pre><p id="8dbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Travis 使用阶段对作业进行分组。每个阶段都是构建的一部分，可能被触发，也可能不被触发。在上述示例中，阶段<code class="fe ns nt nu nv b">test</code>始终运行。只有前缀为<code class="fe ns nt nu nv b">dataset/</code>的标签存在时，Stage <code class="fe ns nt nu nv b">extract dataset</code>才会运行<code class="fe ns nt nu nv b">scripts/generate-dataset.sh</code> bash 脚本。类似地，只有当标签以<code class="fe ns nt nu nv b">experiment/</code>开始时，stage <code class="fe ns nt nu nv b">train model</code>才会运行<code class="fe ns nt nu nv b">scripts/train.sh</code>。</p><h2 id="4e25" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">部署</h2><p id="ba3d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">部署是管道的最后一步。正如前面所讨论的，一个模型可以部署在许多不同的环境中(流、REST 端点、批处理等)。重要的部分是拥有与代码的当前状态相匹配的模型版本。开发人员/数据科学家还应该控制什么模型可以投入生产。最简单的解决方案是，如果某个东西需要投入生产，那么它需要被合并到<code class="fe ns nt nu nv b">master</code>分支。然后，CI 服务器可以下载模型的最新版本，将其与代码打包在一起，运行测试并部署。</p><p id="8f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是 CI 服务器如何知道什么是最新版本呢？这可以通过简单地获取以<code class="fe ns nt nu nv b">experiment</code>开始的<code class="fe ns nt nu nv b">master</code>分支的最后一个标签来完成。下面是如何用 git 和一些 bash 魔法来实现的:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="8cd1" class="ng mk it nv b gy oa ob l oc od">$ git rev-list --tags | xargs git describe | grep experiment | head -n 1</span><span id="113d" class="ng mk it nv b gy oe ob l oc od">experiment/model2</span></pre><p id="fc42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了标记名，还可以获得 git 散列:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="9a71" class="ng mk it nv b gy oa ob l oc od">$ git rev-list --tags | xargs git describe | grep experiment | head -n 1 | xargs git rev-list -n 1 | head -c 7<br/>caca000</span></pre><h1 id="aa1e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">最后的想法</h1><p id="3bad" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在本文中，我描述了一个使用 Git 和 CI 服务器来驱动机器学习管道的流程。在结束之前，我想讨论几个话题。</p><p id="2b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发时，编写小型的自包含提交被认为是一个很好的实践，它可以被快速地审查和合并到主分支。这与机器学习项目设置形成对比，在机器学习项目设置中，不同版本的模型需要经过测试和微调，才能获得最终结果。许多分支(尤其是用于模型不同版本的分支)可能不会被合并到主分支中。这是模型标签的建议约定是<code class="fe ns nt nu nv b">experiment</code>而不是<code class="fe ns nt nu nv b">model</code>的原因之一。</p><p id="2f34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，还有几个可能的问题:</p><ul class=""><li id="bcb7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在任务完成之前合并分支。这可能会中断 CI/CD 流程。例如，如果带有实验标记的分支在训练完成之前被合并到主模型中，CI 服务器将无法找到已训练的模型，从而导致构建失败。这实际上是一件好事，因为在没有模型的情况下推送代码是没有意义的:)一个快速的解决方法是删除新合并的标签。</li><li id="17d8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">挤压-合并分支(或<a class="ae ky" href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" rel="noopener ugc nofollow" target="_blank">历史重写</a>)。这导致了单个提交的崩溃，创建了一个新的提交(带有一个新的 git hash ),从而打破了代码和工件之间的链接。</li><li id="5d69" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">重定基数也可能导致同样的情况。但是重定基础意味着在别人的代码之后添加你的代码。在大多数情况下，再次触发管道可能是一个好主意，只是为了验证模型的预期性能没有改变。</li></ul><p id="d904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里描述的分支模型也假设有一个主分支和特征分支。它与<a class="ae ky" href="https://guides.github.com/introduction/flow/" rel="noopener ugc nofollow" target="_blank"> Github 流</a>非常接近，但肯定可以适用于其他分支模型，如<a class="ae ky" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank">Github 流</a>。类似地，如果您的项目需要支持多个版本或者有一些其他需求，您可能需要适应。</p><p id="e012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有几件事情没有讨论，但可以明确支持。第一个是循环训练。只是自动化整个过程(从数据集生成到部署)，以便使用新数据。第二是如何记录每个实验的结果和超参数。同样，有多种解决方案可供选择，包括<a class="ae ky" href="https://github.com/IDSIA/sacred" rel="noopener ugc nofollow" target="_blank">神圣</a>、<a class="ae ky" href="https://mlflow.org/" rel="noopener ugc nofollow" target="_blank"> mlflow </a>或<a class="ae ky" href="https://docs.aws.amazon.com/sagemaker/latest/dg/training-metrics.html" rel="noopener ugc nofollow" target="_blank"> AWS Sagemaker 的培训指标</a>。在任何情况下，git 散列都可以用作日志参数。</p></div></div>    
</body>
</html>