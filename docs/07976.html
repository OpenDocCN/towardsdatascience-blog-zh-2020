<html>
<head>
<title>New Features in Python 3.9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.9中的新功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/new-features-in-python39-2529765429fe?source=collection_archive---------1-----------------------#2020-06-13">https://towardsdatascience.com/new-features-in-python39-2529765429fe?source=collection_archive---------1-----------------------#2020-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d07a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看Python最新版本中包含的最佳特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e1382a93dafb689616fa35128c082b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L1XrGRLGHUl1OgO7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@pablothewarrior?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pablo Guerrero </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e0dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又到那个时候了，Python的新版本迫在眉睫。现在是测试版(3.9.0b3)，我们很快就会看到Python 3.9的完整版本。</p><p id="c6e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些最新的特性令人难以置信地兴奋，在发布后看到它们被使用将是令人惊奇的。我们将讨论以下内容:</p><ul class=""><li id="a5cf" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">字典联合运算符</strong></li><li id="7a40" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">类型提示</strong></li><li id="d2c1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">两种新的弦乐方法</li><li id="5b2f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">新的Python解析器——这非常酷</li></ul><p id="e7d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先来看看这些新特性以及如何使用它们。</p><p id="7e3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj"> ( </em> <a class="ae ky" href="https://medium.com/code-italia/novit%C3%A0-in-python-3-9-61fddf6bfef7" rel="noopener"> <em class="mj">意大利文</em> </a> <em class="mj"> ) </em></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="9e3b" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">字典联盟</h1><p id="c0a1" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我最喜欢的新特性之一，语法简洁。如果我们有两个字典<code class="fe no np nq nr b">a</code>和<code class="fe no np nq nr b">b</code>需要合并，我们现在使用<em class="mj">联合操作符</em>。</p><p id="3553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有<strong class="lb iu">合并</strong>操作员<code class="fe no np nq nr b">|</code>:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="2377" class="nw ms it nr b gy nx ny l nz oa">a = {1: <strong class="nr iu">'a'</strong>, 2: <strong class="nr iu">'b'</strong>, 3: <strong class="nr iu">'c'</strong>}<br/>b = {4: <strong class="nr iu">'d'</strong>, 5: <strong class="nr iu">'e'</strong>}</span><span id="2d1e" class="nw ms it nr b gy ob ny l nz oa">c = <strong class="nr iu">a | b</strong><br/>print(c)</span></pre><p id="9a09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b"><strong class="lb iu">[Out]:</strong> {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e'}</code></p><p id="84aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和<strong class="lb iu">更新</strong>操作符<code class="fe no np nq nr b">|=</code>，它更新原始字典:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="2f7d" class="nw ms it nr b gy nx ny l nz oa">a = {1: 'a', 2: 'b', 3: 'c'}<br/>b = {4: 'd', 5: 'e'}</span><span id="b371" class="nw ms it nr b gy ob ny l nz oa"><strong class="nr iu">a |= b</strong><br/>print(a)</span></pre><p id="ba86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b"><strong class="lb iu">[Out]:</strong> {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e'}</code></p><p id="e770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的字典共享一个<strong class="lb iu">公共键</strong>，将使用第二个字典中的键-值对:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="2853" class="nw ms it nr b gy nx ny l nz oa">a = {1: 'a', 2: 'b', 3: 'c', <strong class="nr iu">6: 'in both'</strong>}<br/>b = {4: 'd', 5: 'e', <strong class="nr iu">6: 'but different'</strong>}</span><span id="f3fd" class="nw ms it nr b gy ob ny l nz oa">print(a | b)</span></pre><p id="5ab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b"><strong class="lb iu">[Out]: </strong>{1: 'a', 2: 'b', 3: 'c', <strong class="lb iu">6: 'but different'</strong>, 4: 'd', 5: 'e'}</code></p><h2 id="82b3" class="nw ms it bd mt oc od dn mx oe of dp nb li og oh nd lm oi oj nf lq ok ol nh om bi translated">用Iterables更新字典</h2><p id="bf35" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><code class="fe no np nq nr b">|=</code>操作符的另一个很酷的行为是<strong class="lb iu">能够使用一个<strong class="lb iu">可迭代</strong>对象用新的键值对更新</strong>字典——比如一个列表或生成器:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="188e" class="nw ms it nr b gy nx ny l nz oa">a = {'a': 'one', 'b': 'two'}<br/><strong class="nr iu">b = ((i, i**2) for i in range(3))</strong></span><span id="6dd8" class="nw ms it nr b gy ob ny l nz oa">a |= <strong class="nr iu">b</strong><br/>print(a)</span></pre><p id="d637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b"><strong class="lb iu">[Out]:</strong> {'a': 'one', 'b': 'two', <strong class="lb iu">0: 0, 1: 1, 2: 4</strong>}</code></p><p id="2faf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们用标准的union操作符<code class="fe no np nq nr b">|</code>进行同样的尝试，我们将得到一个<code class="fe no np nq nr b">TypeError</code>，因为它只允许<code class="fe no np nq nr b">dict</code>类型之间的联合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/dd9b254560b9fb9db41c4ae8c9e57a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*hjJrDDymvrkVwtGDyifa4w.png"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="a833" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">类型提示</h1><p id="56fc" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">Python是动态类型的，这意味着我们不需要在代码中指定数据类型。</p><p id="185f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这没什么，但有时会令人困惑，突然之间Python的灵活性变得比其他任何东西都更令人讨厌。</p><p id="acf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从3.5开始，我们可以指定类型，但这相当麻烦。这次更新确实改变了这一点，让我们举个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/a24177241404905b5d1c911648ded45c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i-sP6OeH73BfGczYDouk2w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无类型提示(左)使用3.9的v类型提示(右)</p></figure><p id="666a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe no np nq nr b">add_int</code>函数中，我们显然想给自己加上相同的数字(出于某种神秘的未定义的原因)。但是我们的编辑器不知道这一点，使用<code class="fe no np nq nr b">+</code>将两个字符串加在一起是完全可以的——所以不会给出警告。</p><p id="2d62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以做的是将预期的输入类型指定为<code class="fe no np nq nr b">int</code>。利用这一点，我们的编辑立即发现了问题。</p><p id="3bf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以非常具体地了解所包含的类型，例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/728a96b41ee71c8596bb7bad84933866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjnGYVlFcR7_ZtaKpPLFJg.png"/></div></div></figure><p id="bc0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型提示可以在任何地方使用——多亏了新的语法，它现在看起来更简洁了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/740224d8df1f2c62c6c05bdc11e997d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwMmOsv5riSfm622yfsstQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们将sum_dict的参数指定为dict，返回值指定为int。在测试定义期间，我们也确定它的类型。</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="dff5" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">字符串方法</h1><p id="03e9" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">不像其他新功能那样吸引人，但仍然值得一提，因为它特别有用。添加了两个用于删除前缀和后缀的新字符串方法:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="f1c1" class="nw ms it nr b gy nx ny l nz oa">"Hello world".remove<strong class="nr iu">prefix</strong>("He")</span></pre><p id="31c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b"><strong class="lb iu">[Out]:</strong> "llo world"</code></p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="441a" class="nw ms it nr b gy nx ny l nz oa">Hello world".remove<strong class="nr iu">suffix</strong>("ld")</span></pre><p id="e5c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b"><strong class="lb iu">[Out]: </strong>"Hello wor"</code></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d51f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">新解析器</h1><p id="3bb9" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这是一个看不到的变化，但有可能成为Python未来发展中最重要的变化之一。</p><p id="b542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python目前主要使用基于LL(1)的语法，该语法又可以被LL(1)解析器解析，该解析器从上到下、从左到右解析代码，并且只对一个标记进行前瞻。</p><p id="9590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我几乎不知道这是如何工作的——但我可以给你一些当前Python中由于使用这种方法而出现的问题:</p><ul class=""><li id="80bb" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">Python包含非LL(1)语法；正因为如此，当前语法的某些部分使用了变通方法，造成了不必要的复杂性。</li><li id="1051" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">LL(1)在Python语法中造成了限制(没有可能的变通办法)。<a class="ae ky" href="https://bugs.python.org/issue12782" rel="noopener ugc nofollow" target="_blank">这个问题</a>强调了下面的代码根本无法使用当前的解析器实现(引发一个<em class="mj"> SyntaxError </em>):</li></ul><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="c9c9" class="nw ms it nr b gy nx ny l nz oa">with (open("a_really_long_foo") as foo,<br/>      open("a_really_long_bar") as bar):<br/>    pass</span></pre><ul class=""><li id="78bd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">LL(1)在解析器中用左递归中断。这意味着特定的递归语法会导致解析树中的无限循环。<a class="op oq ep" href="https://medium.com/u/1ecea0006127?source=post_page-----2529765429fe--------------------------------" rel="noopener" target="_blank">Python的创造者<a class="ae ky" href="https://medium.com/@gvanrossum_83706/left-recursive-peg-grammars-65dab3c580e1" rel="noopener">吉多·范·罗苏姆</a>在这里</a>对此进行了解释。</li></ul><p id="c237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些因素(以及更多我无法理解的因素)都对Python产生了重大影响；它们限制了语言的发展。</p><p id="53ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于<strong class="lb iu"> PEG，</strong>的新解析器将让Python开发者拥有更大的灵活性——从<a class="ae ky" href="https://docs.python.org/3.9/whatsnew/3.9.html#pep-617-new-parser" rel="noopener ugc nofollow" target="_blank"> Python 3.10开始</a>我们将开始注意到这一点。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="9fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们对即将到来的Python 3.9所能期待的一切。如果你真的等不及了，最新的测试版3.9.0b3 — <a class="ae ky" href="https://www.python.org/downloads/release/python-390b3/" rel="noopener ugc nofollow" target="_blank">在这里</a>可以找到。</p><p id="7cf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有任何问题或建议，请随时通过<a class="ae ky" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或在下面的评论中联系我们。</p><p id="c8f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="e1b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您喜欢这篇文章，并且想了解Python中一些鲜为人知的特性，您可能会对我以前的文章感兴趣:</p><div class="or os gp gr ot ou"><a rel="noopener follow" target="_blank" href="/lesser-known-python-features-f87af511887"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">鲜为人知的Python特性</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">一些鲜为人知和被低估的Python特性的示例</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div></div></div>    
</body>
</html>