<html>
<head>
<title>Exploring the Graph Catalog feature of Neo4j Graph data science plugin on a Lord of the Rings dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索指环王数据集上 Neo4j 图表数据科学插件的图表目录功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploring-the-graph-catalog-feature-of-neo4j-graph-data-science-plugin-on-a-lord-of-the-rings-d2de0d0a023?source=collection_archive---------27-----------------------#2020-03-09">https://towardsdatascience.com/exploring-the-graph-catalog-feature-of-neo4j-graph-data-science-plugin-on-a-lord-of-the-rings-d2de0d0a023?source=collection_archive---------27-----------------------#2020-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b289" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解 Neo4j 图形数据科学插件的基础知识，以及如何将图形投影到内存中</h2></div><p id="0742" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了继续介绍<a class="ae lb" href="https://github.com/neo4j/graph-data-science" rel="noopener ugc nofollow" target="_blank"> Neo4j 图形数据科学插件</a>，我们将回顾基础知识，并查看该库的图形管理部分。这是库的一部分，负责将存储的 Neo4j 图形投影到内存中，从而允许更快地执行图形算法。图表管理部分的一个重要部分是图表目录功能。到底是什么？让我们看看<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/1.0/management-ops/graph-catalog-ops/" rel="noopener ugc nofollow" target="_blank">的官方文件</a>。</p><blockquote class="lc ld le"><p id="e0a3" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><em class="iq">图形算法在图形数据模型上运行，图形数据模型是 Neo4j 属性图形数据模型的</em>投影<em class="iq">。图形投影可视为存储图形的视图，仅包含分析相关的、潜在聚合的拓扑和属性信息。图形投影使用针对拓扑和属性查找操作优化的压缩数据结构完全存储在内存中。</em></p><p id="8b06" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><em class="iq">图形目录是 GDS 库中的一个概念，允许通过名称管理多个图形投影。使用该名称，创建的图形可以在分析工作流中多次使用。</em></p></blockquote><p id="7f5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两个不同的选项可以将存储的图形投影到内存中:</p><ul class=""><li id="532e" class="lj lk iq kh b ki kj kl km ko ll ks lm kw ln la lo lp lq lr bi translated"><a class="ae lb" href="https://neo4j.com/docs/graph-data-science/1.0/management-ops/native-projection/" rel="noopener ugc nofollow" target="_blank">本机投影</a>通过读取 Neo4j 存储文件提供最佳性能。</li><li id="a3d1" class="lj lk iq kh b ki ls kl lt ko lu ks lv kw lw la lo lp lq lr bi translated"><a class="ae lb" href="https://neo4j.com/docs/graph-data-science/1.0/management-ops/cypher-projection/" rel="noopener ugc nofollow" target="_blank"> Cypher projection </a>，更灵活、更富表现力的方法，较少关注性能</li></ul><p id="659b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇博文中，我们将深入探讨图表目录的原生投影选项。</p><h1 id="173b" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">图形模型</h1><p id="b2c7" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">我已经记不清使用 GoT 数据集的次数了，所以我决定探索互联网，搜索新的令人兴奋的图表。我偶然发现了这个<a class="ae lb" href="https://github.com/morethanbooks/projects/tree/master/LotR" rel="noopener ugc nofollow" target="_blank">指环王数据集</a>由<a class="ae lb" href="http://www.morethanbooks.eu/" rel="noopener ugc nofollow" target="_blank"> José Calvo </a>提供，我们将在这篇博文中使用。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mu"><img src="../Images/4aed6149833945712f1120ddb0a4f128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2qesLWz5DQEv7VTn.png"/></div></div></figure><p id="9dd4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据集描述了人、地点、群体和事物(环)之间的相互作用。在选择如何对此数据集进行建模时，我决定让“主”节点具有两个标签，主标签为“节点”,辅助标签为以下之一:</p><ul class=""><li id="2173" class="lj lk iq kh b ki kj kl km ko ll ks lm kw ln la lo lp lq lr bi translated">人</li><li id="ba2d" class="lj lk iq kh b ki ls kl lt ko lu ks lv kw lw la lo lp lq lr bi translated">地方</li><li id="d5c0" class="lj lk iq kh b ki ls kl lt ko lu ks lv kw lw la lo lp lq lr bi translated">组</li><li id="c536" class="lj lk iq kh b ki ls kl lt ko lu ks lv kw lw la lo lp lq lr bi translated">东西</li></ul><p id="df4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上图中，出于清晰起见，我只添加了“人”作为二级标签。我们将每本书的交互存储为一个单独的关系，这意味着第一本书的交互将被保存为<strong class="kh ir">交互 _1 </strong>关系，第二本书的交互将被保存为<strong class="kh ir">交互 _2 </strong>，以此类推。请记住，我们将把交互关系视为无向和加权的。这些“主”节点也可以是一个职业的一部分，比如兽人、精灵、人类等等。</p><h1 id="706b" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">输入数据</h1><p id="c56b" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">如前所述，数据集在<a class="ae lb" href="https://github.com/morethanbooks/projects/tree/master/LotR" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上可用，我们可以用<code class="fe ng nh ni nj b">LOAD CSV</code>语句轻松获取它。</p><h1 id="866e" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">导入节点</h1><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="08bf" class="no ly iq nj b gy np nq l nr ns">LOAD CSV WITH HEADERS FROM <br/>"https://raw.githubusercontent.com/morethanbooks/projects/master/LotR/ontologies/ontology.csv" as row FIELDTERMINATOR "\t"<br/>WITH row, CASE row.type WHEN 'per' THEN 'Person'<br/>                        WHEN 'gro' THEN 'Group'<br/>                        WHEN 'thin' THEN 'Thing'<br/>                        WHEN 'pla' THEN 'Place' END as label<br/>CALL apoc.create.nodes(['Node',label], [apoc.map.clean(row,['type','subtype'],[null,""])]) YIELD node<br/>WITH node, row.subtype as class<br/>MERGE (c:Class{id:class})<br/>MERGE (node)-[:PART_OF]-&gt;(c)</span></pre><p id="3615" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们向“主”节点添加两个标签的主要原因是为了优化交互关系的导入。现在，你可能会说优化是不必要的，因为我们的数据集很小，我同意，但让我们假设我们可能要处理数百万个节点。我们从定义标签“节点”的唯一约束开始。</p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="f55f" class="no ly iq nj b gy np nq l nr ns">CREATE CONSTRAINT ON (n:Node) ASSERT n.id IS UNIQUE</span></pre><h1 id="0db3" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">导入关系</h1><p id="c0af" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">既然我们已经设置了 unique 约束，cypher query planner 将使用它来更快地匹配我们现有的节点。</p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="0c54" class="no ly iq nj b gy np nq l nr ns">UNWIND ['1','2','3'] as book<br/>LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/morethanbooks/projects/master/LotR/tables/networks-id-volume" + book + ".csv" AS row<br/>MATCH (source:Node{id:coalesce(row.IdSource,row.Source)})<br/>MATCH (target:Node{id:coalesce(row.IdTarget,row.Target)})<br/>CALL apoc.create.relationship(source, "INTERACTS_" + book,<br/>         {weight:toInteger(row.Weight)}, target) YIELD rel<br/>RETURN distinct true</span></pre><h1 id="5f16" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">GDS 图表目录</h1><p id="749c" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">在图形目录中创建命名图形的语法是:</p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="1086" class="no ly iq nj b gy np nq l nr ns">CALL gds.graph.create(graph name, node label, relationship type).</span></pre><h2 id="08b1" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">描述我们想要投影的节点</h2><p id="a883" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">一般来说，对于本机投影变体，有三个选项来描述我们想要投影到内存中的节点:</p><ul class=""><li id="a5ed" class="lj lk iq kh b ki kj kl km ko ll ks lm kw ln la lo lp lq lr bi translated">使用字符串投影单个节点标签:</li></ul><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="d5d4" class="no ly iq nj b gy np nq l nr ns">'Label' ('*' is a wildcard operator that projects all nodes)</span></pre><ul class=""><li id="2c0e" class="lj lk iq kh b ki kj kl km ko ll ks lm kw ln la lo lp lq lr bi translated">使用数组投影多个节点标签:</li></ul><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="1579" class="no ly iq nj b gy np nq l nr ns">['Label1', 'Label2', 'Label3']</span></pre><ul class=""><li id="e700" class="lj lk iq kh b ki kj kl km ko ll ks lm kw ln la lo lp lq lr bi translated">使用配置图投影多个节点标签及其属性:</li></ul><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="76e8" class="no ly iq nj b gy np nq l nr ns">{ Label: { label: 'Label', <br/>           properties: ['property1', 'property2']}, <br/>  Label2:{ label: 'Label2', <br/>           properties: ['foo', 'bar']}<br/>}</span></pre><p id="2899" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于投影节点标签，有一点需要注意:</p><blockquote class="lc ld le"><p id="4ecd" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><em class="iq">在内存图中，所有投影的节点标签合并成一个标签。与关系投影不同，当前无法在投影标签上指定过滤器。如果该图用作算法的输入，则将考虑所有节点。</em></p></blockquote><p id="829b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然我们可以过滤我们想要投影到内存中图形的节点标签，但是当前不支持在执行图形算法时额外过滤节点。</p><h2 id="0451" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">描述我们想要表达的关系</h2><p id="81ca" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">描述我们想要投影的关系的语法非常类似于节点的语法。</p><ul class=""><li id="a310" class="lj lk iq kh b ki kj kl km ko ll ks lm kw ln la lo lp lq lr bi translated">使用字符串投影单个关系类型:</li></ul><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="da3e" class="no ly iq nj b gy np nq l nr ns">'TYPE' ('*' is a wildcard that projects all relationship-types)</span></pre><ul class=""><li id="52dc" class="lj lk iq kh b ki kj kl km ko ll ks lm kw ln la lo lp lq lr bi translated">使用数组投影多个关系类型:</li></ul><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="4471" class="no ly iq nj b gy np nq l nr ns">['TYPE1','TYPE2']</span></pre><ul class=""><li id="25a3" class="lj lk iq kh b ki kj kl km ko ll ks lm kw ln la lo lp lq lr bi translated">使用配置图投射更多关系类型及其属性:</li></ul><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="6fab" class="no ly iq nj b gy np nq l nr ns">{ALIAS_OF_TYPE: {type:'RELATIONSHIP_TYPE', <br/>                 orientation: 'NATURAL', <br/>                 aggregation: 'DEFAULT', <br/>                 properties:['property1','property2']}</span></pre><p id="9e7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">配置图中的方向参数定义了我们想要投射的关系的方向。可能的值有:</p><ul class=""><li id="d51d" class="lj lk iq kh b ki kj kl km ko ll ks lm kw ln la lo lp lq lr bi translated">“自然”-&gt;每种关系的投影方式与其在 Neo4j 中的存储方式相同</li><li id="09fa" class="lj lk iq kh b ki ls kl lt ko lu ks lv kw lw la lo lp lq lr bi translated">反向'--&gt;在图形投影过程中，每个关系都是反向的</li><li id="2b90" class="lj lk iq kh b ki ls kl lt ko lu ks lv kw lw la lo lp lq lr bi translated">“无向”-&gt;每个关系都以自然和相反的方向投射</li></ul><p id="6307" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的重要一点是，GDS 库支持在一个<a class="ae lb" href="https://en.wikipedia.org/wiki/Multigraph" rel="noopener ugc nofollow" target="_blank">多重图</a>上运行图算法。当我们想要将一个多图转换成一个单图(不是多图)时，聚合参数是很方便的，但是我们将在另一篇博客文章中进一步研究这个问题。</p><p id="266a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们来看一些实际的例子。</p><h1 id="634b" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">整个图表</h1><p id="10da" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">让我们首先对节点和关系使用通配符操作符，将整个图形投影到内存中。</p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="8f51" class="no ly iq nj b gy np nq l nr ns">CALL gds.graph.create('whole_graph','*', '*')</span></pre><p id="e07b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数情况下，我们通过运行(弱)连通分量算法来开始图表分析，以了解我们的图表实际上是如何(不)连通的。</p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="7b31" class="no ly iq nj b gy np nq l nr ns">CALL gds.wcc.stream('whole_graph') YIELD nodeId, componentId<br/>RETURN componentId, count(*) as size<br/>ORDER BY size DESC LIMIT 10</span></pre><h2 id="fed4" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">结果</h2><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8cf7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该图作为一个整体由一个单独的部分组成。通常，您将从真实世界的数据中获得的是单个超级组件(所有节点的 85%以上)和一些小的不连接组件。</p><h2 id="a414" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">从目录中删除投影图</h2><p id="55b4" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">每次分析后，我们将从内存中释放投影图。</p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="6428" class="no ly iq nj b gy np nq l nr ns">CALL gds.graph.drop('whole_graph');</span></pre><h1 id="a657" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">交互图</h1><p id="873e" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">下一步，我们想忽略关系中的<strong class="kh ir">部分，只关注<strong class="kh ir">交互 X </strong>关系。我们将使用一个数组来描述关系类型，以考虑所有三个<strong class="kh ir">interactions _ X</strong>关系。</strong></p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="ccb8" class="no ly iq nj b gy np nq l nr ns">CALL gds.graph.create('all_interacts','Node',<br/>     ['INTERACTS_1', 'INTERACTS_2', 'INTERACTS_3'])</span></pre><p id="24c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在新的投影图上运行弱连通分量算法。</p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="3de8" class="no ly iq nj b gy np nq l nr ns">CALL gds.wcc.stream('all_interacts') YIELD nodeId, componentId<br/>RETURN componentId, count(*) as size, <br/>       collect(gds.util.asNode(nodeId).Label) as ids<br/>ORDER BY size DESC LIMIT 10</span></pre><h2 id="c53d" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">结果</h2><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="d7be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的新图由三部分组成。我们有一个超级组件和两个仅由一个节点组成的小组件。我们可以推断出地点“幽暗密林”和“旧森林”没有<strong class="kh ir">相互作用 _X </strong>关系。</p><p id="2bfc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用同样的投影图，只看第一本书中的交互。我们可以使用<strong class="kh ir"> relationshipTypes </strong>参数过滤图表算法应该考虑哪些关系类型。</p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="d7a8" class="no ly iq nj b gy np nq l nr ns">CALL gds.wcc.stream('all_interacts', <br/>    {relationshipTypes:['INTERACTS_1']})<br/>YIELD nodeId, componentId<br/>RETURN componentId, count(*) as size, <br/>       collect(gds.util.asNode(nodeId).Label) as ids<br/>ORDER BY size DESC LIMIT 10</span></pre><h2 id="d1bd" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">结果</h2><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="1cff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们只考虑第一本书中的相互作用，我们会得到更多不相关的部分。这是有意义的，因为一些角色/地点在第一本书中还没有介绍，所以他们没有<strong class="kh ir">交互 _1 </strong>关系。</p><h2 id="2060" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">从目录中删除投影图</h2><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="e7d1" class="no ly iq nj b gy np nq l nr ns">CALL gds.graph.drop('all_interacts');</span></pre><h1 id="67ed" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">无向加权交互图</h1><p id="7f46" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">在最后一个例子中，我们将展示如何投影一个无向加权图。我们将只考虑标记为<strong class="kh ir"> Person </strong>和<strong class="kh ir"> Thing，</strong>的节点，对于关系，我们将投影所有的<strong class="kh ir">interactions _ X</strong>关系及其权重属性，它们将被视为无向图。</p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="b28d" class="no ly iq nj b gy np nq l nr ns">CALL gds.graph.create('undirected_weighted',['Person', 'Thing'],<br/>    {INTERACTS_1:{type: 'INTERACTS_1',<br/>                  orientation: 'UNDIRECTED',<br/>                  properties:['weight']},<br/>    INTERACTS_2:{type:'INTERACTS_2',<br/>                 orientation: 'UNDIRECTED',<br/>                 properties:['weight']},<br/>    INTERACTS_3: {type:'INTERACTS_3',<br/>                  orientation:'UNDIRECTED',<br/>                  properties:['weight']}});</span></pre><h2 id="83f2" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">未加权 pageRank</h2><p id="993a" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">为了在我们的投影图上运行未加权的 pageRank，我们不需要指定任何额外的配置。</p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="0133" class="no ly iq nj b gy np nq l nr ns">CALL gds.pageRank.stream('undirected_weighted')<br/>YIELD nodeId, score<br/>RETURN gds.util.asNode(nodeId).Label as name, score<br/>ORDER BY score DESC LIMIT 5</span></pre><h2 id="9b5a" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">结果</h2><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="2f06" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">加权网页排名</h2><p id="27e8" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">为了让算法知道它应该考虑关系权重，我们需要使用<strong class="kh ir">关系权重属性</strong>参数。</p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="bce9" class="no ly iq nj b gy np nq l nr ns">CALL gds.pageRank.stream('undirected_weighted', <br/>   {relationshipWeightProperty:'weight'})<br/>YIELD nodeId, score <br/>RETURN gds.util.asNode(nodeId).Label as name, score <br/>ORDER BY score DESC <br/>LIMIT 5</span></pre><h2 id="c2c7" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">结果</h2><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8538" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于弗罗多与其他角色有更多的互动(定义为重量)，他在 pageRank 的加权变量中名列前茅。</p><h1 id="7714" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">第一本书的图形分析:</h1><p id="9593" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">写完这篇博文，我们来分析一下第一本书的网络。我们首先只对第一本书的交互关系进行加权 pageRank。</p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="6532" class="no ly iq nj b gy np nq l nr ns">CALL gds.pageRank.stream('undirected_weighted', <br/>    {relationshipWeightProperty:'weight', <br/>     relationshipTypes:['INTERACTS_1']})<br/>YIELD nodeId, score <br/>RETURN gds.util.asNode(nodeId).Label as name, score <br/>ORDER BY score DESC <br/>LIMIT 5</span></pre><h2 id="2786" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">结果</h2><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="ba14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">标准嫌疑人在最上面。佛罗多是目前最重要的角色，其次是甘道夫、阿拉贡和山姆，从排名的中心性来看，他们的重要性差不多。戒指也出现在最重要角色的前五名。</p><h2 id="dd39" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">基于 Louvain 算法的社区发现</h2><p id="7092" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">我们也对网络的社区结构感兴趣。我们将使用<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/1.0/algorithms/louvain/" rel="noopener ugc nofollow" target="_blank"> Louvain </a>模块化算法来确定社区结构。</p><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="94b2" class="no ly iq nj b gy np nq l nr ns">CALL gds.louvain.stream('undirected_weighted',<br/>   {relationshipWeightProperty:'weight', <br/>    relationshipTypes:['INTERACTS_1']})<br/>YIELD nodeId, communityId<br/>RETURN communityId,<br/>       collect(gds.util.asNode(nodeId).Label) as members <br/>ORDER BY length(members) DESC LIMIT 5</span></pre><h2 id="0d0e" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">结果</h2><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="6c70" class="no ly iq bd lz nt nu dn md nv nw dp mh ko nx ny mj ks nz oa ml kw ob oc mn od bi translated">放下投影图</h2><pre class="mv mw mx my gt nk nj nl nm aw nn bi"><span id="fcfb" class="no ly iq nj b gy np nq l nr ns">CALL gds.graph.drop('undirected_weighted');</span></pre><h1 id="c89d" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">使用 Neo4j Bloom 进行可视化</h1><p id="90f9" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">由于一张图胜过千言万语，我们就把第一本书的网络形象化。PageRank 用于确定节点的大小，community 用于确定节点的颜色。</p><p id="63a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一次，我将使用<a class="ae lb" href="https://neo4j.com/bloom/" rel="noopener ugc nofollow" target="_blank"> Neo4j Bloom </a>来可视化网络，因为最新版本(1.2)增加了对可视化的基于规则的样式的支持。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi og"><img src="../Images/6f821fd1ab0121701b54f6ab3240dc56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lgnkYCfxWLmi3Sx9.png"/></div></div></figure><p id="4609" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以观察到阿拉贡和索伦、萨鲁曼是一个群体。这与实际的社区检测算法无关，但它显示了从作为共现图的文本中提取信息的弱点。我想下一步是从书中获取知识，比如朋友、敌人或其他人的关系。</p><h1 id="a2bd" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">结论</h1><p id="59c3" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">我希望读完这篇博客后，你能更好地理解如何用<a class="ae lb" href="https://github.com/neo4j/graph-data-science" rel="noopener ugc nofollow" target="_blank">图形数据科学库</a>来投影图形。请继续关注，因为我们仍然需要通过图表管理部分的<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/1.0/management-ops/cypher-projection/" rel="noopener ugc nofollow" target="_blank"> Cypher projection </a>部分。</p><p id="4005" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和往常一样，代码可以在<a class="ae lb" href="https://github.com/tomasonjo/blogs/tree/master/lotr_graph_data_science_catalog" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>