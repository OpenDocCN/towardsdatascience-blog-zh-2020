<html>
<head>
<title>How To Analyse Multiple Time Series Variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何分析多个时间序列变量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-analyse-multiple-time-series-variable-5a8d3a242a2e?source=collection_archive---------33-----------------------#2020-04-06">https://towardsdatascience.com/how-to-analyse-multiple-time-series-variable-5a8d3a242a2e?source=collection_archive---------33-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="607c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">探索时间序列建模</h2><div class=""/><div class=""><h2 id="bd3e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用 Python 代码进行时间序列建模</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/9f0c10f9119b7b735c0ee70bcb7b927c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hh7XaYVmDd6N0dRi"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@tangib?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> tangi bertin </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d3c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">欢迎回来！这是探索用 Python 代码对时间序列数据进行分析和建模的系列文章中的第 3 篇。在第一篇文章中，我们已经讨论了基础统计:<a class="ae lh" rel="noopener" target="_blank" href="/fundamental-statistics-7770376593b"> <strong class="lk jd"> <em class="me">用 Python 代码进行时间序列建模:基础统计</em> </strong> </a>。第二个帖子已经涵盖了单个时间序列变量的分析:<a class="ae lh" rel="noopener" target="_blank" href="/how-to-analyse-a-single-time-series-variable-11dcca7bf16c"> <strong class="lk jd"> <em class="me">用 Python 代码进行时间序列建模:如何分析单个时间序列变量</em> </strong>。</a></p><p id="14ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本帖中，我们将继续探讨如何分析多个时间序列变量。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="94a2" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated"><strong class="ak"> 1。滚动协方差</strong></h1><p id="8fb4" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">协方差是两个随机变量的联合线性可变性的度量。协方差本身很难解释，因为它取决于变量的大小。为了归一化协方差，通常使用相关系数。两种常用的相关系数是:皮尔逊相关系数和斯皮尔曼排名相关系数。</p><p id="37f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">皮尔逊相关系数值在-1 到 1 之间，其中-1 表示强的负线性关系，0 表示没有线性关系，1 表示强的正线性关系。</p><p id="f99d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">斯皮尔曼的排名相关系数值也位于-1 和 1 之间。但 Spearman 的排名相关系数衡量的是两个变量之间的单调性，其中-1 表示强负单调关系，0 表示无单调关系，1 表示强正单调关系。要理解这两个变量之间的单调性，我们可以想到(y₁ -y₁)是如何随(y₂ -y₂)变化的:如果它们同向变化，那么这两个变量就是正单调的；否则，它们是负单调的。</p><p id="7895" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下模拟显示了皮尔逊相关系数和斯皮尔曼排名相关系数之间的差异。当 y1 和 y2 呈线性关系时，皮尔逊相关系数和斯皮尔曼排名相关系数都接近 1。然而，当 y1 和 y2 呈现单调关系时，皮尔逊相关系数变得小于斯皮尔曼排名相关系数。</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="aa94" class="no mn it nk b gy np nq l nr ns">import numpy as np<br/>from scipy.stats import spearmanr<br/>from scipy.stats import pearsonr<br/>import matplotlib.pyplot as plt</span><span id="271a" class="no mn it nk b gy nt nq l nr ns">N=20<br/>x = np.linspace(1,N,num=N)<br/>y1 = x*5 + np.random.normal(0, 3, N)<br/>y2 = np.exp(0.3*x) + np.random.normal(0, 3, N)<br/>#y2 = y1 + np.random.normal(0, 3, N)</span><span id="f90e" class="no mn it nk b gy nt nq l nr ns">plt.scatter(x,y1,color='r',label='y1 = x*5 + np.random.normal(0, 3, N)')<br/>plt.scatter(x,y2,color='b',label='y2 = y1 + np.random.normal(0, 3, N)')<br/>plt.legend(loc='upper left')<br/>plt.xlabel('x')<br/>plt.ylabel('y')<br/>plt.xlim(0,N)<br/>plt.ylim(min(min(y1),min(y2)),max(max(y1),max(y2)))</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nu"><img src="../Images/adec89490a984c61e15d2ae9d86440c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUHZHzy5c-6sgvrwSdorVQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">皮尔逊系数衡量两个变量的线性，而斯皮尔曼系数衡量两个变量的单调性</p></figure><h1 id="4133" class="mm mn it bd mo mp nv mr ms mt nw mv mw ki nx kj my kl ny km na ko nz kp nc nd bi translated">2.虚假关系与滚动协整</h1><p id="27f8" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">为了使用时间序列数据 x 对时间序列数据 y 建模，我们通常要求 x 和 y 都是平稳的 I(0)过程。如果不熟悉单个时间序列变量的平稳性检验，可以参考我之前的帖子:<a class="ae lh" rel="noopener" target="_blank" href="/how-to-analyse-a-single-time-series-variable-11dcca7bf16c"> <strong class="lk jd"> <em class="me">用 Python 代码进行时间序列建模:如何分析单个时间序列变量</em> </strong> </a>。</p><p id="401e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当两个时间序列变量都是非平稳的时，即使基本的生成过程没有偶然的关系，它们也可能表现出很强的相关性。这种强烈的相关性可能纯粹是由两个时间序列变量具有非常数均值这一事实引起的。这种现象被称为虚假关系。</p><p id="efce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，在特殊情况下，我们可以使用时间序列数据 x 对时间序列数据 y 建模，当 x 和 y 都是 I(1)过程且协整时。基本上，协整意味着 x 和 y 之间存在放大效应，在任何时间点，我们总是可以将 x 乘以同一个参数，得到一个接近 y 的值，这样，残差就是 I(0)过程。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/9fb11debdd9ba8ffc49c127dfd189e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wI__1U6er33muOXtaVVPA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">x 和 y 之间的协整</p></figure><p id="5b68" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用 statsmodels 库可以很容易地检验协整。</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="adae" class="no mn it nk b gy np nq l nr ns">import numpy as np<br/>from statsmodels.tsa.stattools import coint</span><span id="0bf7" class="no mn it nk b gy nt nq l nr ns">N=20<br/>x = np.linspace(1,N,num=N)<br/>y1 = x*5 + np.random.normal(0, 3, N)<br/>y2 = np.exp(0.3*x) + np.random.normal(0, 3, N)<br/>print(f'P value is {coint(y1,y2)[1]}')</span></pre><p id="c3c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输出:</p><p id="7e66" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">p 值为 0.9859002580259643</p><p id="df8e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于 P 值大于 0.05 的显著性水平，我们不能拒绝不存在协整的零假设。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="c049" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">摘要</h1><p id="6e4d" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">在这篇文章中，我们讨论了如何分析多个时间序列变量的协方差和协整性。在下一篇文章中，我们将更进一步，探索如何使用线性回归来建模时间序列数据。敬请关注！</p></div></div>    
</body>
</html>