<html>
<head>
<title>Representing Graph Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">表示图形数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/representing-graph-data-structures-6e3c19ccd677?source=collection_archive---------18-----------------------#2020-01-15">https://towardsdatascience.com/representing-graph-data-structures-6e3c19ccd677?source=collection_archive---------18-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="98ef" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/graphs-and-data-science" rel="noopener" target="_blank">图表和数据科学</a></h2><div class=""/><div class=""><h2 id="d398" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">真的都是边缘问题。</h2></div><p id="1c63" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当你表示一个图结构<em class="ln"> G </em>时，顶点<em class="ln"> V </em>非常容易存储，因为它们是一个集合，可以直接这样表示。例如，对于5个顶点的图形:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="27f5" class="lx ly it lt b gy lz ma l mb mc">V = {0,1,2,3,4}</span></pre><p id="9836" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当你开始存储边缘时，事情变得更有趣了。这里有三种常见的结构可用于表示和导航边集:</p><ul class=""><li id="eff8" class="md me it kt b ku kv kx ky la mf le mg li mh lm mi mj mk ml bi translated">边缘列表</li><li id="1121" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated">邻接矩阵</li><li id="e527" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated">邻接表</li></ul><p id="469f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将看一看一个简单的图形，并遍历它的每个表示。我们将根据其<strong class="kt jd">空间复杂度</strong>和<strong class="kt jd">邻接复杂度来评估每一个。</strong></p><h1 id="426d" class="mr ly it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">但是首先一些术语</h1><ul class=""><li id="e31b" class="md me it kt b ku ni kx nj la nk le nl li nm lm mi mj mk ml bi translated">一个<strong class="kt jd">图</strong> <em class="ln"> G </em> ( <em class="ln"> V </em>，<em class="ln"> E </em>)是由一组顶点(<em class="ln"> V </em>)和一组边(<em class="ln"> E </em>)定义的数据结构。</li><li id="ff35" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated"><strong class="kt jd">顶点</strong> ( <em class="ln"> v </em>)或节点是一个不可分割的点，由下图中的字母组件表示</li><li id="7940" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated">一条<strong class="kt jd">边</strong> ( <em class="ln"> vu </em>)将顶点<em class="ln"> v </em>和顶点<em class="ln"> u </em>连接在一起。</li><li id="8b4b" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated">顶点<em class="ln"> v </em>的<strong class="kt jd">度</strong> <em class="ln"> d </em> ( <em class="ln"> v </em>)，就是连接到它的边数。</li><li id="33bb" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated"><strong class="kt jd">空间复杂度</strong>显示为<strong class="kt jd"/><em class="ln">θ(G)</em>，表示需要多少内存来保存给定的图形</li><li id="d28b" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated"><strong class="kt jd">邻接复杂度</strong>用<strong class="kt jd"> </strong> <em class="ln">表示O(G) </em>是找到一个给定顶点的所有邻接顶点所需要的时间<em class="ln"> v </em>。</li></ul><h1 id="7d56" class="mr ly it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">边缘列表</h1><p id="50ff" class="pw-post-body-paragraph kr ks it kt b ku ni kd kw kx nj kg kz la nn lc ld le no lg lh li np lk ll lm im bi translated">给定带有顶点集的图<em class="ln"> G </em>:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="3b20" class="lx ly it lt b gy lz ma l mb mc">V = {0,1,2,3,4}</span></pre><p id="6662" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在让我们给G一些边，使它成为一个合适的图形:</p><figure class="lo lp lq lr gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nq"><img src="../Images/e3ffd4bf420f32b4f4bfbdf7e46ecbe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbgOS-RMyrNH8R9qvJRBwg.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">图一。g，都长大了</p></figure><p id="fd69" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">G的<strong class="kt jd">边列表</strong>是边的文字列表，其中每条边是它连接的顶点的列表，在这种情况下:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="8b71" class="lx ly it lt b gy lz ma l mb mc">E = [[0,1],[0,2],[0,4],[3,4]]</span></pre><p id="1c34" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">赞成的意见</p><ul class=""><li id="3edf" class="md me it kt b ku kv kx ky la mf le mg li mh lm mi mj mk ml bi translated">简单！</li><li id="bda5" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated">大s <strong class="kt jd">步距复杂度</strong>of<em class="ln">θ(G)= | E |</em></li></ul><p id="a242" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">骗局</p><ul class=""><li id="4e57" class="md me it kt b ku kv kx ky la mf le mg li mh lm mi mj mk ml bi translated"><strong class="kt jd">O(G)= | E |的邻接复杂度</strong>。这里的<em class="ln"> |E| </em>是一个很差的值。你必须查看每一个边缘，以便将它们全部排除。从某些方面来说，这是最糟糕的成绩。</li></ul><h1 id="31dc" class="mr ly it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">邻接矩阵</h1><p id="5131" class="pw-post-body-paragraph kr ks it kt b ku ni kd kw kx nj kg kz la nn lc ld le no lg lh li np lk ll lm im bi translated">G的<strong class="kt jd">邻接矩阵</strong>是每个<em class="ln"> v </em>都有对应的列和行的方阵。如果两个顶点v，u共享一条边，那么在相应的位置有一个1，否则是一个0。</p><figure class="lo lp lq lr gt nr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/8db934003dc1e59a3510d99684719610.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/0*OqXL5yRPc6eMBgL1.gif"/></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">图二。三个不同4点图的邻接矩阵</p></figure><p id="02e6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对于我们的图来说，G是:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="d8d7" class="lx ly it lt b gy lz ma l mb mc">G = [[0,1,1,0,1],<br/>     [1,0,0,0,0],<br/>     [1,0,0,0,0],<br/>     [0,0,0,0,1],<br/>     [1,0,0,1,0]]</span></pre><p id="4a3f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">赞成的意见</p><ul class=""><li id="0a13" class="md me it kt b ku kv kx ky la mf le mg li mh lm mi mj mk ml bi translated">高度可解释性。即它是对称的，除非它是一个有向图，你可以在每个矩阵条目中整齐地存储边值。</li><li id="9554" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated">体面的<strong class="kt jd">邻接复杂度</strong>的<em class="ln"> O(G) = |V|。</em>为了找到与<em class="ln"> v、</em>相邻的所有顶点，我们需要用邻接矩阵扫描它们的整行。</li></ul><p id="e95d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">骗局</p><ul class=""><li id="38eb" class="md me it kt b ku kv kx ky la mf le mg li mh lm mi mj mk ml bi translated">可怕的s <strong class="kt jd">步调复杂度<em class="ln">的</em></strong>θ(G)= | V |。这里我们存储了长度为2的每个可能的顶点排列，包括每个与其自身配对的顶点。这是可能组合的最大顶点集的两倍多，(<em class="ln"> |V| choose 2) </em></li></ul><h1 id="74ae" class="mr ly it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">邻接表</h1><p id="744b" class="pw-post-body-paragraph kr ks it kt b ku ni kd kw kx nj kg kz la nn lc ld le no lg lh li np lk ll lm im bi translated">G的<strong class="kt jd">邻接表</strong>是另一个链表。这一次，我们将为g中的每个v创建一个空列表，而不是列出每个单独的边。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="26d8" class="lx ly it lt b gy lz ma l mb mc">E = [[],[],[],[],[]]</span></pre><p id="5efc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里，每个列表元素的索引代表其对应的顶点。现在我们需要遍历并添加每个顶点的相邻邻居列表。</p><figure class="lo lp lq lr gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nq"><img src="../Images/e3ffd4bf420f32b4f4bfbdf7e46ecbe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbgOS-RMyrNH8R9qvJRBwg.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">图三。又回来了！</p></figure><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ebbd" class="lx ly it lt b gy lz ma l mb mc">E = [[1,2,4],[0],[0],[4],[0,3]]</span></pre><p id="0f02" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">虽然这是一个最简单的列表，但我也发现把它想象成一个字典很有帮助，其中每个顶点都是一个键。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="cf13" class="lx ly it lt b gy lz ma l mb mc">E = {0:[1,2,4], <br/>     1:[0], <br/>     2:[0], <br/>     3:[4], <br/>     4:[0,3]}</span></pre><p id="187b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">优点:</p><ul class=""><li id="709d" class="md me it kt b ku kv kx ky la mf le mg li mh lm mi mj mk ml bi translated">就像一本字典！</li><li id="3eee" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated">S <strong class="kt jd">步距复杂度</strong>of<em class="ln">θ(G)= | V |+</em>2<em class="ln">| E |</em>我们有一个每个顶点的列表，这些列表总共将存储2个<em class="ln"> |E| </em>元素，因为每个边将出现在两个顶点列表中。</li><li id="585a" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated">极大的<strong class="kt jd">邻接复杂度。</strong>对于给定的顶点<em class="ln"> v </em>，<em class="ln"> O(G) </em>等于<em class="ln">d</em>(<em class="ln">v</em>)v<em class="ln">的度数。当寻找所有相邻的邻居时，这实际上是这里的最佳可能值。</em></li></ul><h1 id="2b70" class="mr ly it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">最佳表示</h1><p id="58cf" class="pw-post-body-paragraph kr ks it kt b ku ni kd kw kx nj kg kz la nn lc ld le no lg lh li np lk ll lm im bi translated">选择最佳数据结构来表示给定的图G实际上取决于G中的边密度。这可以大致概括如下。</p><ul class=""><li id="9fa7" class="md me it kt b ku kv kx ky la mf le mg li mh lm mi mj mk ml bi translated">如果<em class="ln"> |E|≈|V| </em> ie的边数与顶点数一样多，那么G被认为是稀疏的<strong class="kt jd">并且邻接表是优选的。</strong></li><li id="0e51" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated">如果<em class="ln"> |E|≈ </em> ( <em class="ln"> |V|选择2) </em> ie接近G中的最大边数，则认为<strong class="kt jd">密集</strong>，邻接矩阵优先。</li></ul><p id="08a0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">边列表很少被使用，因为它们的邻接复杂度很低。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h2 id="fcc6" class="lx ly it bd ms ok ol dn mw om on dp na la oo op nc le oq or ne li os ot ng iz bi translated">来源</h2><ul class=""><li id="00b5" class="md me it kt b ku ni kx nj la nk le nl li nm lm mi mj mk ml bi translated"><a class="ae ou" href="https://www.hackerearth.com/practice/basic-programming/complexity-analysis/time-and-space-complexity/tutorial/" rel="noopener ugc nofollow" target="_blank">时间和空间复杂度</a></li><li id="fac8" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated"><a class="ae ou" href="https://courses.cs.northwestern.edu/311/html/space-complexity.html" rel="noopener ugc nofollow" target="_blank">空间复杂度</a></li><li id="31e9" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated"><a class="ae ou" href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" rel="noopener ugc nofollow" target="_blank">表示图形</a></li><li id="d6c3" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated"><a class="ae ou" href="https://www.hackerearth.com/practice/algorithms/graphs/graph-representation/tutorial/" rel="noopener ugc nofollow" target="_blank">图形表示</a></li><li id="0628" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated"><a class="ae ou" href="https://en.wikipedia.org/wiki/Adjacency_matrix" rel="noopener ugc nofollow" target="_blank">邻接矩阵维基</a></li><li id="2343" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated"><a class="ae ou" href="https://en.wikipedia.org/wiki/Adjacency_list" rel="noopener ugc nofollow" target="_blank">邻接表维基</a></li><li id="5359" class="md me it kt b ku mm kx mn la mo le mp li mq lm mi mj mk ml bi translated"><a class="ae ou" href="http://mathworld.wolfram.com/AdjacencyMatrix.html" rel="noopener ugc nofollow" target="_blank"> Wolfram邻接矩阵</a></li></ul></div></div>    
</body>
</html>