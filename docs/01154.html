<html>
<head>
<title>Machine Learning with Datetime Feature Engineering: Predicting Healthcare Appointment No-Shows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于日期时间特征工程的机器学习:预测医疗预约失约</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-with-datetime-feature-engineering-predicting-healthcare-appointment-no-shows-5e4ca3a85f96?source=collection_archive---------0-----------------------#2020-02-02">https://towardsdatascience.com/machine-learning-with-datetime-feature-engineering-predicting-healthcare-appointment-no-shows-5e4ca3a85f96?source=collection_archive---------0-----------------------#2020-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3dd4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们根据日期和时间为我们的模型制作特写！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ac3ecfeaafb3958da78e09975d3d09cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TRWmoCBfiLpT5DbyCWDEpQ.jpeg"/></div></div></figure><p id="da6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">日期和时间是可用于机器学习模型的丰富信息源。然而，这些日期时间变量确实需要一些特性工程来将它们转换成数字数据。在这篇文章中，我将演示如何用内置的熊猫函数为你的机器学习模型创建日期时间特性。</p><p id="2b8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我在东北大学教授机器学习课程时，我的几个学生使用了一个非常有趣的数据集(医疗预约失约)，我将在这篇博文中探讨这个数据集。医疗预约失约是医疗保健领域的一个大问题，因为大约五分之一的患者会错过预约(<a class="ae ln" href="https://www.solutionreach.com/blog/which-wins-the-national-average-no-show-rate-or-yours" rel="noopener ugc nofollow" target="_blank">来源</a>)。这对每个相关的人来说都是一个问题:1)被安排的患者大概需要被看，否则他们不会有预约，2)其他患者希望有那个位置但是不能，3)医疗服务提供者必须花费额外的时间来联系和重新安排患者，以及浪费他们用于准备就诊的任何时间。</p><h1 id="671d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">项目定义</h1><p id="9f6e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">给定排班日和预约日的日期和时间，预测患者是否会错过他们的医疗预约。</p><h1 id="e53c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">资料组</h1><p id="c841" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这里，我们将使用Kaggle(<a class="ae ln" href="https://www.kaggle.com/joniarroba/noshowappointments" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/joniarroba/noshowappointments</a>)上的医疗预约缺席。该数据集包含超过110，000个医疗预约。我们将为此项目使用的三个主要列是ScheduledDay(安排约会的日期和时间)、AppointmentDay(约会的日期，不包括时间)、No-Show(指示他们是否未出现的二进制标志)。出于本文的目的，我们将忽略其余的数字特征(尽管老实说，它们没有增加AUC的价值)。</p><h1 id="c496" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">数据准备</h1><p id="c115" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">让我们首先加载我们的数据集，创建一个输出列(1 =不显示，0=显示)，并将我们的datetime(当前为字符串)转换为python datetimes。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="6131" class="mq lp iq mm b gy mr ms l mt mu">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span></pre><p id="f7ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我假设您从Kaggle下载了数据，并将其放在“data”文件夹中:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="de10" class="mq lp iq mm b gy mr ms l mt mu">df = pd.read_csv(‘data/KaggleV2-May-2016.csv’)</span></pre><p id="1974" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用<code class="fe mv mw mx mm b">value_counts</code>调查未出现的列</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/f87b9206faade4565cbe2841aec3981c.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*y_JkKDXWtdySFuvCESzkWQ.png"/></div></div></figure><p id="7c99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们定义一个二进制列OUTPUT_LABEL来表示Yes = 1，No = 0。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="439c" class="mq lp iq mm b gy mr ms l mt mu">df[‘OUTPUT_LABEL’] = (df[‘No-show’] == ‘Yes’).astype(‘int’)</span></pre><p id="6b05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以检查我们的OUTPUT_LABEL的流行程度:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3a69" class="mq lp iq mm b gy mr ms l mt mu">def calc_prevalence(y):<br/> return (sum(y)/len(y))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/094e46b1cf95d01c8955a8b0b962ac70.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*Sddwv2i0hZPkONc2I1DfeA.png"/></div></figure><p id="93d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着五分之一的病人将错过他们的预约。</p><p id="0c9b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们通过查看ScheduledDay和AppointmentDay的前5行来处理datetime列</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/18091713f54bb993021d7a80c05b638f.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*xd4rsNnUAYN9CxVZ5pqt2Q.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/2bc67dd20a3a23f466bee7f109cee8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*EoWGfmA6Dpc0J1wjI6PUIw.png"/></div></figure><p id="e576" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，两列的dtype都是<code class="fe mv mw mx mm b">object</code>，这意味着pandas当前将这些值视为字符串。需要指出的另一点是，ScheduledDay中的约会日的所有时间都是00:00:00。我们也许应该处理这个问题，但是我发现他们没有把约会的时间包括在数据集中有点奇怪。据推测，约会的时间也是可以预测的。</p><p id="3536" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要将这些字符串转换成内部日期时间，我们可以使用pandas函数<code class="fe mv mw mx mm b">to_datetime</code>。我喜欢用format参数来明确表示格式。如果使用format参数，则必须指定如何处理错误。在这里，我将把任何错误转换成非日期时间(NaT)。一般来说(虽然这里不是这样)，使用format参数会加快这一行的执行速度。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="9d37" class="mq lp iq mm b gy mr ms l mt mu">df[‘ScheduledDay’] = pd.to_datetime(df[‘ScheduledDay’], <br/> format = ‘%Y-%m-%dT%H:%M:%SZ’, <br/> errors = ‘coerce’)<br/>df[‘AppointmentDay’] = pd.to_datetime(df[‘AppointmentDay’], <br/> format = ‘%Y-%m-%dT%H:%M:%SZ’, <br/> errors = ‘coerce’)</span></pre><p id="804b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我以前没有见过标准格式的T和Z，所以我只是把它们放在格式字符串中。如果有人知道如何更好地处理这些，请告诉我。</p><p id="6e67" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每当我使用format参数时，如果我假设所有行都应该有日期，我喜欢放一个断言语句来验证我没有得到不正确的格式。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="96eb" class="mq lp iq mm b gy mr ms l mt mu">assert df.ScheduledDay.isnull().sum() == 0, ‘missing ScheduledDay dates’<br/>assert df.AppointmentDay.isnull().sum() == 0, ‘missing AppointmentDay dates’</span></pre><p id="e7f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您现在检查dtype，您将看到它是datetime64，这正是我们想要的，因为它向我们展示了pandas中的所有datetime属性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/bb869e4dda46c7ebb3574f7f002023c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*0hId1Lbeue-pH_5M-3VWGw.png"/></div></figure><p id="3877" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我注意到的一件事是，目前大约有40k个约会被安排在约会日期之后。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/a02a8304e65a94ee92238baf4652d062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*5uB2cWBNMmZo_IbSLA56kA.png"/></div></figure><p id="3ee2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我认为这是因为所有的预约时间都设置在最早的时间(00:00:00 ),而这些时间包含在ScheduledDay中。为了适应这种情况，让我们把所有的约会时间移到一天的最后。如果我是为了工作而做这个项目，我会去了解预约时间。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="9bd2" class="mq lp iq mm b gy mr ms l mt mu">df[‘AppointmentDay’] = df[‘AppointmentDay’] +pd.Timedelta(‘1d’) — pd.Timedelta(‘1s’)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/9f3c7a9301397a344e907b4cb9a13e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*QgsLD7CrrfxNbaJLJP-43A.png"/></div></figure><p id="668d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这一更改，只有5行的计划日期时间在约会日期之后。我们把这几行删掉吧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/4524970d724dd66a069e0feb6bcf5313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*2Rrb-_ayMxJRfigqgbTPAw.png"/></div></figure><h1 id="0eb8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">工程师日期时间功能</h1><p id="1209" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">通过将字符串转换为datetimes，这将公开所有熊猫dt属性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/3a177699b7b5d5fa88c574b1b65d332e.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*S5vHn10C5T_0PqIwZhTf1g.png"/></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">来源:<a class="ae ln" href="https://pandas.pydata.org/pandas-docs/version/0.23/api.html#datetimelike-properties" rel="noopener ugc nofollow" target="_blank">https://pandas . pydata . org/pandas-docs/version/0.23/API . html # datetime like-properties</a></p></figure><p id="16a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上你可以把日期分开，得到年、月、周、日、小时、分钟、秒等。还可以得到星期几(星期一= 0，星期日= 6)。请注意一年中的第几周，因为如果该周开始于前一年，则一年的第几天可能是53。让我们将其中一些属性应用到我们的两个datetime列中。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="bfcf" class="mq lp iq mm b gy mr ms l mt mu">df[‘ScheduledDay_year’] = df[‘ScheduledDay’].dt.year<br/>df[‘ScheduledDay_month’] = df[‘ScheduledDay’].dt.month<br/>df[‘ScheduledDay_week’] = df[‘ScheduledDay’].dt.week<br/>df[‘ScheduledDay_day’] = df[‘ScheduledDay’].dt.day<br/>df[‘ScheduledDay_hour’] = df[‘ScheduledDay’].dt.hour<br/>df[‘ScheduledDay_minute’] = df[‘ScheduledDay’].dt.minute<br/>df[‘ScheduledDay_dayofweek’] = df[‘ScheduledDay’].dt.dayofweek</span><span id="59b4" class="mq lp iq mm b gy nl ms l mt mu">df[‘AppointmentDay_year’] = df[‘AppointmentDay’].dt.year<br/>df[‘AppointmentDay_month’] = df[‘AppointmentDay’].dt.month<br/>df[‘AppointmentDay_week’] = df[‘AppointmentDay’].dt.week<br/>df[‘AppointmentDay_day’] = df[‘AppointmentDay’].dt.day<br/>df[‘AppointmentDay_hour’] = df[‘AppointmentDay’].dt.hour<br/>df[‘AppointmentDay_minute’] = df[‘AppointmentDay’].dt.minute<br/>df[‘AppointmentDay_dayofweek’] = df[‘AppointmentDay’].dt.dayofweek</span></pre><p id="45b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以验证这是否有效:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/d71283731dc6f982244b01d4fed95872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_9yjF-K0-guKgYVRhjZpw.png"/></div></div></figure><p id="7da0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这一点上，这将是一个很好的探索我们的日期了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/fac97a8013f4f5da0a9b8a21776b42b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*JhyoeYqY-qaSnZF2lkzO4w.png"/></div></div></figure><p id="953a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你在这里看到的，约会是在2016年的4月、5月和6月，从周一到周六，周日没有约会。我永远不会使用年份作为一个特征(但还是显示了它)，因为我们可能希望在未来使用这个预测模型，而这些未来的年份不会包含在数据集中。然而，我有点失望，这几个月只是一年中的几个月。这意味着月(以及一年中的周)可能也不应该被用作一个特性。如果我是为了工作而这样做，我会回到数据库，得到一整年(或许多年)的数据。我可以想象，一年中的某些时候(即假期前后)会影响不露面的比率。</p><p id="6d0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们快速检查一下dayofweek是否预示着失约:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/1092a19b88c7d908d1a75e2fac2c82a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-MfrS6Ya-bVt5bi3JyMZhw.png"/></div></div></figure><p id="364f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看起来更多的人在周五和周六跳过他们的约会，尽管效果不大。</p><p id="1a1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">熊猫日期时间表示的另一个好处是你可以计算日期时间之间的“时间”。让我们创建一个新特性，即计划日期和约会日期之间的天数。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="fce6" class="mq lp iq mm b gy mr ms l mt mu">df[‘delta_days’] = (df[‘AppointmentDay’]-df[‘ScheduledDay’]).dt.total_seconds()/(60*60*24)</span></pre><p id="6269" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意这里我用的是<code class="fe mv mw mx mm b">total_seconds</code>。有一个函数dt.days，但是我习惯使用total_seconds，因为1) dt.days舍入到最近的一天，2) dt.days过去花费的时间比total_seconds长得多。第二点似乎在熊猫后期版本中已经修复。</p><p id="6568" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以在这个变量上绘制两个类的直方图:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3d0f" class="mq lp iq mm b gy mr ms l mt mu">plt.hist(df.loc[df.OUTPUT_LABEL == 1,’delta_days’], <br/> label = ‘Missed’,bins = range(0,60,1), normed = True)<br/>plt.hist(df.loc[df.OUTPUT_LABEL == 0,’delta_days’], <br/> label = ‘Not Missed’,bins = range(0,60,1), normed = True,alpha =0.5)<br/>plt.legend()<br/>plt.xlabel(‘days until appointment’)<br/>plt.ylabel(‘normed distribution’)<br/>plt.xlim(0,40)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/5309db07b932ecf994773e2c1d5bba57.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*_I9ME6PICqJNjmYsif0oyg.png"/></div></figure><p id="a36c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种分布对我来说有点奇怪，因为大多数没有错过预约的患者都在同一天安排了预约。我有点想知道这个数据集中是否包括预约。我的猜测是，这个模型只会在1天画一条线，并说如果你在同一天安排它，就不会错过。</p><p id="4951" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在准备分割我们的样本并训练一个模型！</p><h1 id="a2c9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">分割样本</h1><p id="12ea" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了简单起见，我只分成两个数据集:训练(70%)和验证(30%)。打乱你的样本是很重要的，因为你可能是按照日期顺序得到数据的。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="9f08" class="mq lp iq mm b gy mr ms l mt mu"># shuffle the samples<br/>df = df.sample(n = len(df), random_state = 42)<br/>df = df.reset_index(drop = True)</span><span id="d76b" class="mq lp iq mm b gy nl ms l mt mu">df_valid = df.sample(frac = 0.3, random_state = 42)<br/>df_train = df.drop(df_valid.index)</span></pre><p id="43d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以查一下每个地区的患病率约为20%:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="2c35" class="mq lp iq mm b gy mr ms l mt mu">print(‘Valid prevalence(n = %d):%.3f’%(len(df_valid),calc_prevalence(df_valid.OUTPUT_LABEL.values)))<br/>print(‘Train prevalence(n = %d):%.3f’%(len(df_train), calc_prevalence(df_train.OUTPUT_LABEL.values)))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/e4c6b527afc3354bccfb8b44423b94ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*mr7cX8onka45UsvlwU6-8g.png"/></div></figure><p id="ec0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">鉴于该数据仅来自2016年4月至6月，且无预约时间，我们将仅使用这些列:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="0ea0" class="mq lp iq mm b gy mr ms l mt mu">col2use = [‘ScheduledDay_day’, ‘ScheduledDay_hour’,<br/> ‘ScheduledDay_minute’, ‘ScheduledDay_dayofweek’, <br/> ‘AppointmentDay_day’,<br/> ‘AppointmentDay_dayofweek’, ‘delta_days’]</span></pre><p id="4eae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“日”特征甚至可能是可疑的，但是现在让我们离开。</p><p id="acf8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们具备以下条件，这一范围还可以扩大:</p><ul class=""><li id="1efc" class="nr ns iq kt b ku kv kx ky la nt le nu li nv lm nw nx ny nz bi translated">整个日历年的约会</li><li id="019c" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">约会时间</li></ul><p id="3923" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以构建用于训练和验证的X(输入)和Y(输出):</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3945" class="mq lp iq mm b gy mr ms l mt mu">X_train = df_train[col2use].values<br/>X_valid = df_valid[col2use].values</span><span id="c60d" class="mq lp iq mm b gy nl ms l mt mu">y_train = df_train[‘OUTPUT_LABEL’].values<br/>y_valid = df_valid[‘OUTPUT_LABEL’].values</span><span id="58f4" class="mq lp iq mm b gy nl ms l mt mu">print(‘Training shapes:’,X_train.shape, y_train.shape)<br/>print(‘Validation shapes:’,X_valid.shape, y_valid.shape)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/d63ff0442f3442e43dd90c1bbfc90a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*lDHivewIWZBp9YTRHmZxzw.png"/></div></figure><h1 id="1d5b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">训练一个机器学习模型</h1><p id="99e0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">因为这篇文章的重点是关于日期时间的特性，我们将在这里训练一个随机的森林模型。注意如果要使用其他类型的模型，可能需要对数据进行缩放或规范化。您可能想做的另一件事是通过一键编码将dayofweek转换成分类变量。但是对于基于树的方法，我们不需要做这些事情。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3d75" class="mq lp iq mm b gy mr ms l mt mu">from sklearn.ensemble import RandomForestClassifier<br/>rf=RandomForestClassifier(max_depth = 5, n_estimators=100, random_state = 42)<br/>rf.fit(X_train, y_train)</span></pre><p id="c5c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们可以得到我们的预测:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="df51" class="mq lp iq mm b gy mr ms l mt mu">y_train_preds = rf.predict_proba(X_train)[:,1]<br/>y_valid_preds = rf.predict_proba(X_valid)[:,1]</span></pre><h1 id="632a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">评估绩效</h1><p id="154d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在这里，我们将评估模型的性能。如果你是分类指标的新手，我推荐你看看我关于这些指标的帖子(<a class="ae ln" rel="noopener" target="_blank" href="/understanding-data-science-classification-metrics-in-scikit-learn-in-python-3bc336865019">技术帖子</a>或<a class="ae ln" rel="noopener" target="_blank" href="/data-science-performance-metrics-for-everyone-4d68f4859eef">非技术帖子</a>)。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="fcf1" class="mq lp iq mm b gy mr ms l mt mu">from sklearn.metrics import roc_auc_score, accuracy_score, precision_score, recall_score<br/>def calc_specificity(y_actual, y_pred, thresh):<br/> # calculates specificity<br/> return sum((y_pred &lt; thresh) &amp; (y_actual == 0)) /sum(y_actual ==0)</span><span id="2c0b" class="mq lp iq mm b gy nl ms l mt mu">def print_report(y_actual, y_pred, thresh):<br/> <br/> auc = roc_auc_score(y_actual, y_pred)<br/> accuracy = accuracy_score(y_actual, (y_pred &gt; thresh))<br/> recall = recall_score(y_actual, (y_pred &gt; thresh))<br/> precision = precision_score(y_actual, (y_pred &gt; thresh))<br/> specificity = calc_specificity(y_actual, y_pred, thresh)<br/> print(‘AUC:%.3f’%auc)<br/> print(‘accuracy:%.3f’%accuracy)<br/> print(‘recall:%.3f’%recall)<br/> print(‘precision:%.3f’%precision)<br/> print(‘specificity:%.3f’%specificity)<br/> print(‘prevalence:%.3f’%calc_prevalence(y_actual))<br/> print(‘ ‘)<br/> return auc, accuracy, recall, precision, specificity</span></pre><p id="0ace" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用这个<code class="fe mv mw mx mm b">print_report </code>函数，我们可以评估训练和验证的性能。在这里，我将阈值设置为患病率0.201</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e8f416631c7cd187e41e00dc53060640.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*Rm3UjNbp3L6re5bcWv6N1A.png"/></div></figure><p id="684a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用它来绘制ROC</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="43ef" class="mq lp iq mm b gy mr ms l mt mu">from sklearn.metrics import roc_curve</span><span id="a765" class="mq lp iq mm b gy nl ms l mt mu">fpr_train, tpr_train, thresholds_train = roc_curve(y_train, y_train_preds)<br/>auc_train = roc_auc_score(y_train, y_train_preds)</span><span id="cb0c" class="mq lp iq mm b gy nl ms l mt mu">fpr_valid, tpr_valid, thresholds_valid = roc_curve(y_valid, y_valid_preds)<br/>auc_valid = roc_auc_score(y_valid, y_valid_preds)</span><span id="dc11" class="mq lp iq mm b gy nl ms l mt mu">plt.plot(fpr_train, tpr_train, ‘r-’,label =’Train AUC:%.3f’%auc_train)<br/>plt.plot(fpr_valid, tpr_valid, ‘b-’,label =’Valid AUC:%.3f’%auc_valid)<br/>plt.plot([0,1],[0,1],’k — ‘)<br/>plt.xlabel(‘False Positive Rate’)<br/>plt.ylabel(‘True Positive Rate’)<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/a825dcb26b8d37a1395756f2494e9aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*4cCdIUC9sD7kEcQKT5UnDw.png"/></div></figure><p id="4afa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这表明，仅使用日期时间特征，我们就可以获得0.71的AUC。这条摇摆曲线有点奇怪，因为它有肘部。</p><p id="97d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过查看主要特性来对此进行一些研究</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3a4e" class="mq lp iq mm b gy mr ms l mt mu">feature_importances = pd.DataFrame(rf.feature_importances_,<br/> index = col2use,<br/> columns=[‘importance’]).sort_values(‘importance’,<br/> ascending=False)</span><span id="6dea" class="mq lp iq mm b gy nl ms l mt mu">num = min([50,len(col2use)])<br/>ylocs = np.arange(num)<br/># get the feature importance for top num and sort in reverse order<br/>values_to_plot = feature_importances.iloc[:num].values.ravel()[::-1]<br/>feature_labels = list(feature_importances.iloc[:num].index)[::-1]</span><span id="cc6a" class="mq lp iq mm b gy nl ms l mt mu">plt.figure(num=None, figsize=(6, 6), dpi=80, facecolor=’w’, edgecolor=’k’);<br/>plt.barh(ylocs, values_to_plot, align = ‘center’)<br/>plt.ylabel(‘Features’)<br/>plt.xlabel(‘Importance Score’)<br/>plt.title(‘Feature Importance Score — Random Forest’)<br/>plt.yticks(ylocs, feature_labels)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/7dbb39a777a36ca6eccf8db820e8a9cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*zShn7o7IwrTY9AALBAcxxw.png"/></div></div></figure><p id="bd30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这表明delta_days基本上是模型中使用的唯一特征。这证实了我们上面的怀疑，即模型可能会因为那些同一天的约会而陷入困境。</p><p id="6a5d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我们的训练和验证分数非常相似，这意味着我们处于高偏倚的情况下。为了改进这个模型，我们将需要额外的功能，所以我将在这里结束这个项目。</p><h1 id="3f8e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="bdb0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在这个项目中，我们通过解包日期时间变量来预测患者是否会缺席，从而创建了许多新功能。根据我的经验，日期时间功能对医疗保健机器学习模型有很大的影响。我强烈建议在你的下一个项目中尝试一下。如果你对这篇文章有任何问题或疑虑，请联系我们。</p></div></div>    
</body>
</html>