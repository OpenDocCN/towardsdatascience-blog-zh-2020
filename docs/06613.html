<html>
<head>
<title>Run Multiple Services In Single Docker Container Using Supervisor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Supervisor在单个Docker容器中运行多个服务</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/run-multiple-services-in-single-docker-container-using-supervisor-b2ed53e3d1c0?source=collection_archive---------12-----------------------#2020-05-25">https://towardsdatascience.com/run-multiple-services-in-single-docker-container-using-supervisor-b2ed53e3d1c0?source=collection_archive---------12-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/157b7a736b9da9db725161a6da543f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YOOHeywoAwLnlMWty6C2HA.png"/></div></div></figure><p id="716a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您是否曾经遇到过这种情况，您希望在同一个容器中运行两个或更多的轻量级服务？</p><p id="e7bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然Docker提供了一个Docker-compose工具，用于在多个容器中构建和运行多服务应用程序。Docker-compose需要一个YAML文件来配置您的多个服务。但是有时我们希望在同一个容器中运行两个或更多的轻量级服务。</p><p id="8413" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将解释如何使用“Supervisor”工具在同一个docker容器中启动多个服务。</p><blockquote class="kz la lb"><p id="8b98" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated"><strong class="kd iu">那么什么是主管呢？</strong></p></blockquote><p id="dfaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">管理程序是一种工具，它允许我们像操作系统一样在Linux中同时管理多个不同的进程。监督工具需要一个<em class="lc">。conf </em>文件，我们在其中指定进程和与该进程相关的不同选项，如<em class="lc">输出日志位置、自动启动、自动重启等。</em></p><blockquote class="kz la lb"><p id="cefd" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated"><strong class="kd iu">我将使用的示例服务</strong></p></blockquote><p id="d8ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将在同一个容器中运行两个不同的服务“运行Django app的Gunicorn服务器”和“Redis服务器”。因此，在我创建的示例项目中，包含一个简单的Django REST API，用于从Redis服务器添加和获取数据。在生产环境中，这两个服务在具有生产级配置的独立容器中使用。为了便于演示，我将在一个docker容器中运行这两个服务。</p><blockquote class="kz la lb"><p id="16f3" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated"><strong class="kd iu">项目目录结构</strong></p></blockquote><p id="bd83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">开始构建项目的一个好方法是拥有一个整洁清晰的项目结构。因此，考虑到这一点，我们将使用下面的代码目录结构:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="4345" class="lp lq it ll b gy lr ls l lt lu">multi_service<br/>├── django_app<br/>│   ├── db.sqlite3<br/>│   ├── django_app<br/>│   ├── manage.py<br/>│   ├── redis_test<br/>│   └── requirements.txt<br/>├── Dockerfile<br/>└── supervisor<br/>    └── service_script.conf</span></pre><blockquote class="kz la lb"><p id="23fc" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated"><strong class="kd iu">在本地测试我们的服务(Django App和Redis) </strong></p></blockquote><p id="3eb2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在docker中发布服务之前，首先，让我们在本地测试它们。您可以使用下面的链接从GitHub下载完整的项目。<br/>网址:<a class="ae lv" href="https://github.com/aakash-rathore/docker_multi_services.git" rel="noopener ugc nofollow" target="_blank">https://github.com/aakash-rathore/docker_multi_services.git</a></p><p id="9678" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要测试Redis服务器，只需使用以下命令下载它:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="0bd1" class="lp lq it ll b gy lr ls l lt lu">Using apt package installer<br/><br/>$ sudo apt-get install redis-server<br/><br/># Use apk add (For alpine linux)<br/><br/># apk add redis</span></pre><p id="ad7b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在使用以下命令运行服务器:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="e411" class="lp lq it ll b gy lr ls l lt lu">$ redis-serve</span></pre><p id="5b6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您将看到服务正在运行:</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lw"><img src="../Images/c33b68291c867a27fff1c90463a006fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WGJCe-NIag7lkOzdPzVlNw.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">本地redis服务器测试</p></figure><p id="fa4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了在本地测试Django应用程序，我们将使用Gunicorn服务器。使用以下命令在gunicorn服务器中运行应用程序:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="d2b6" class="lp lq it ll b gy lr ls l lt lu">$ gunicorn --bind 0.0.0.0:8000 django_app.wsgi</span></pre><p id="1bf1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该命令的输出如下所示:</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mb"><img src="../Images/240b802ff7fe983502c272deb419c4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMikyPraRrja68z6gzRkdQ.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">在本地运行gunicorn</p></figure><blockquote class="kz la lb"><p id="dd1b" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated"><strong class="kd iu">主管配置文件</strong></p></blockquote><p id="7f42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">按照上面指定的目录结构创建一个文件<strong class="kd iu"><em class="lc">【service _ script . conf】</em></strong>。按照下面的配置添加django和redis服务:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="8469" class="lp lq it ll b gy lr ls l lt lu">## service_script.conf<br/><br/>[supervisord]  ## This is the main process for the Supervisor    <br/>nodaemon=true  ## This setting is to specify that we are not running in daemon mode<br/><br/>[program:redis_script] ## This is the part where we give the name and add config for our 1st service<br/>command=redis-server  ## This is the main command to run our 1st service<br/>autorestart=true ## This setting specifies that the supervisor will restart the service in case of failure<br/>stderr_logfile=/dev/stdout ## This setting specifies that the supervisor will log the errors in the standard output<br/>stderr_logfile_maxbytes = 0<br/>stdout_logfile=/dev/stdout ## This setting specifies that the supervisor will log the output in the standard output<br/>stdout_logfile_maxbytes = 0<br/><br/>## same setting for 2nd service<br/>[program:django_service] <br/>command=gunicorn --bind 0.0.0.0:8000 django_app.wsgi<br/>autostart=true<br/>autorestart=true<br/>stderr_logfile=/dev/stdout<br/>stderr_logfile_maxbytes = 0<br/>stdout_logfile=/dev/stdout<br/>stdout_logfile_maxbytes = 0</span></pre><blockquote class="kz la lb"><p id="dbc5" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated"><strong class="kd iu">docker文件创建</strong></p></blockquote><p id="3b4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们将开始制作docker文件。添加图层的步骤如下:<br/> <strong class="kd iu"> <em class="lc">基础镜像- &gt;安装所需工具- &gt;添加源代码- &gt;添加配置文件- &gt;启动服务</em> </strong> <br/>最终Dockerfile如下:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="b886" class="lp lq it ll b gy lr ls l lt lu"># Base Image<br/>FROM alpine<br/><br/># Installing required tools<br/>RUN apk --update add nano supervisor python3 redis<br/><br/># Adding Django Source code to container <br/>ADD /django_app /src/django_app<br/><br/># Adding supervisor configuration file to container<br/>ADD /supervisor /src/supervisor<br/><br/># Installing required python modules for app<br/>RUN pip3 install -r /src/django_app/requirements.txt<br/><br/># Exposing container port for binding with host<br/>EXPOSE 8000<br/><br/># Using Django app directory as home<br/>WORKDIR /src/django_app<br/><br/># Initializing Redis server and Gunicorn server from supervisord<br/>CMD ["supervisord","-c","/src/supervisor/service_script.conf"]</span></pre><blockquote class="kz la lb"><p id="26f7" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated"><strong class="kd iu">构建和测试</strong></p></blockquote><p id="0be5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，使用下面的命令构建docker映像:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="183f" class="lp lq it ll b gy lr ls l lt lu">$ docker build -t multi_service:1 .</span></pre><p id="3310" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">成功构建操作后的输出:</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mb"><img src="../Images/756bf958c1f556cac4117d901205234f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ViXmc5-fHrs1uW3MCNykuQ.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">docker构建成功</p></figure><p id="ee16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在使用上面构建的映像运行docker容器:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="fd70" class="lp lq it ll b gy lr ls l lt lu">$ docker run -it -p 8000:8000 multi_service:1</span></pre><p id="7f40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里docker容器是在非守护模式下运行的如果你想在守护模式下运行它使用<strong class="kd iu"> <em class="lc"> '-d' </em> </strong>选项，上面命令的输出:</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/a94a14a0dd2b7a3440a98d8b15895968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ysOhsI3_-PSxUAATvVScSw.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">运行docker的输出</p></figure><p id="6b07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们在API测试工具中测试django应用程序，我使用的是一个轻量级的“高级REST客户端”,可以在Google Chrome扩展商店中找到。您可以使用Postman、Curl或任何其他工具进行测试:</p><p id="8713" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">测试添加用户功能:</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/f72c16b2f5f3f4cbd8b46af15b2802d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9qz2LAsOCSKdO18wiWfaug.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">测试添加用户功能</p></figure><p id="b6d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">测试获取用户:</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi me"><img src="../Images/1bda68414ac558b95279fe5bd413a860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*grQju01EGMGlVPiSam02mQ.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">测试提取用户功能</p></figure><blockquote class="kz la lb"><p id="bd99" class="kb kc lc kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated"><strong class="kd iu">结论</strong></p></blockquote><p id="5c5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我解释了如何在一个docker容器中运行多个服务(Django app和Redis server)。最后，我们还做了一些测试来检查这两个服务是否都在运行。</p><p id="4875" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请在下面留下您对本文的评论，如果您在上面指定的任何步骤中遇到问题，您可以通过<a class="ae lv" href="https://www.instagram.com/_aakash.rathore/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> Instagram </strong> </a>和<a class="ae lv" href="https://www.linkedin.com/in/aakash-data-engineer" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">LinkedIn</strong></a><strong class="kd iu">联系我。</strong></p></div></div>    
</body>
</html>