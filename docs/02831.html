<html>
<head>
<title>Statistical Decision Theory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">统计决策理论</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/statistical-decision-theory-382b04f517f2?source=collection_archive---------31-----------------------#2020-03-18">https://towardsdatascience.com/statistical-decision-theory-382b04f517f2?source=collection_archive---------31-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ab2c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">机器学习的框架</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4f4210d3ff2596a2c2d5482b17aab312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gxT5XVNbaVkuAXA7SsJ6g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/photo/black-and-white-blackboard-business-chalkboard-356043/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="de39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将讨论一些为开发机器学习模型提供框架的理论。</p><p id="2bbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><p id="a5d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们考虑一个实值随机输入向量，<em class="lv"> X </em>和一个实值随机输出向量，<em class="lv"> Y </em>，目标是找到一个函数<em class="lv"> f </em> ( <em class="lv"> X </em>)来预测Y的值。这需要一个损失函数，<em class="lv"> L </em> ( <em class="lv"> Y </em>，<em class="lv"> f </em> ( <em class="lv"> X </em>)。这个函数允许我们惩罚预测中的错误。常用损失函数的一个例子是平方误差损失:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/ed9a551a2ae68f8e70826be08dd08940.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*4nU_y1cjhwRyZVcuwwv74g.png"/></div></figure><p id="4931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">损失函数是真实结果值和我们的预测之间的平方差。如果<em class="lv">f</em>(<em class="lv">X</em>)=<em class="lv">Y</em>，这意味着我们的预测等于真实结果值，我们的损失函数等于零。所以我们想找到一种方法来选择一个函数<em class="lv"> f </em> ( <em class="lv"> X </em>)，它给出的值尽可能接近<em class="lv"> Y </em>。</p><p id="7f1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定我们的损失函数，我们有一个选择<em class="lv"> f </em> ( <em class="lv"> X </em>)的标准。我们可以通过对x <em class="lv">和y </em>上的损失函数进行积分来计算预期平方预测误差:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/697755c2652916a93b8dcbaae359dd01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*koXSwsssB39g0Dx3l_nf_w.png"/></div></div></figure><p id="cb43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中P( <em class="lv"> X </em>，<em class="lv"> Y </em>)是输入和输出的联合概率分布。然后，我们可以以X为条件，计算预期平方预测误差，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/3d32e4d721e7bcc57de07544bed7e9f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*9pFSyN--2fyXMYj3OaP3hg.png"/></div></figure><p id="350f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以逐点最小化该期望平方预测误差，方法是找到值<em class="lv"> c </em>，其最小化给定的误差<em class="lv"> X </em>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/57043309b2f498a14a073bc2247e3ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*yf2bMEJZa1Xo6vkBAQ_Q3Q.png"/></div></figure><p id="5392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此的解决方案是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/0f7e1516e40a1bd5fccb752bf612a186.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*diQ3TJOdf8Rmo8c_gLEwcQ.png"/></div></figure><p id="0d5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<em class="lv"> Y </em>的条件期望，给定<em class="lv"> X </em> = <em class="lv"> x. </em>换句话说，回归函数给出了<em class="lv"> Y、</em>的条件均值，给定了<em class="lv"> X. </em>的知识，有趣的是，<em class="lv">k</em>-最近邻方法是从训练数据实现该方法的直接尝试。对于最近邻，对于每个<em class="lv"> x </em>，我们可以求<em class="lv"> y </em>的平均值，其中输入<em class="lv"> x </em>等于特定值。我们对<em class="lv"> Y </em>的估计可以写成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/52c68757369fb957a565d270583757fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*rKfXuSC3g7DwoKzzzUuVIg.png"/></div></figure><p id="271c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中我们对样本数据取平均值，并使用结果来估计期望值。我们也在调整一个区域，它的k个邻居离目标点最近。随着样本量变大，邻域内的点很可能接近<em class="lv"> x </em>。此外，随着邻居数量<em class="lv"> k </em>变大，平均值变得更加稳定。</p><p id="ecdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣了解更多，Trevor Hastie的《统计学习元素》是一个很好的资源。感谢您的阅读！</p></div></div>    
</body>
</html>