<html>
<head>
<title>Using K-Means Clustering for Image Segregation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用K-均值聚类进行图像分离</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-k-means-clustering-for-image-segregation-fd80bea8412d?source=collection_archive---------25-----------------------#2020-06-21">https://towardsdatascience.com/using-k-means-clustering-for-image-segregation-fd80bea8412d?source=collection_archive---------25-----------------------#2020-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4ea6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用CNN和KMeans来分离图像。</h2></div><p id="d9d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">KMeans聚类是最常用的无监督机器学习算法之一。顾名思义，它可以用来创建数据集群，本质上是隔离它们。</p><p id="f798" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们开始吧。这里我将举一个简单的例子，从一个既有猫和狗的图像的文件夹中分离图像到它们自己的簇中。这将创建两个独立的文件夹(集群)。我们还将介绍如何自动确定k的最佳值。</p><p id="97e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经生成了一个猫和狗的图像数据集。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/6fbfd78465990eba1a310a36a48ea667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TIGukNCiwFTyY7YOl4ytHw.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">猫和狗的图像。</p></figure><p id="d51f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将从导入所需的库开始。</p><pre class="lf lg lh li gt lu lv lw lx aw ly bi"><span id="2609" class="lz ma it lv b gy mb mc l md me">import numpy as np<br/>import tensorflow as tf<br/>import matplotlib.pyplot as plt<br/>from sklearn.cluster import KMeans<br/>from sklearn.metrics import silhouette_score<br/>import cv2<br/>import os, glob, shutil</span></pre><p id="66d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们将从图像文件夹中读取所有图像，并对它们进行处理以提取特征。我们将图像的大小调整为224x224，以匹配我们的模型的输入层的大小，用于特征提取。</p><pre class="lf lg lh li gt lu lv lw lx aw ly bi"><span id="1433" class="lz ma it lv b gy mb mc l md me">input_dir = 'pets'<br/>glob_dir = input_dir + '/*.jpg'</span><span id="4401" class="lz ma it lv b gy mf mc l md me">images = [cv2.resize(cv2.imread(file), (224, 224)) for file in glob.glob(glob_dir)]</span><span id="0ca3" class="lz ma it lv b gy mf mc l md me">paths = [file for file in glob.glob(glob_dir)]<br/>images = np.array(np.float32(images).reshape(len(images), -1)/255)</span></pre><p id="6cf3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们将在MobileNetV2(迁移学习)的帮助下进行特征提取。为什么选择MobileNetV2？你可能会问。我们可以用ResNet50，InceptionV3等。但是MobileNetV2速度快，资源也不多，所以这是我的选择。</p><pre class="lf lg lh li gt lu lv lw lx aw ly bi"><span id="fb3a" class="lz ma it lv b gy mb mc l md me">model = tf.keras.applications.MobileNetV2(<em class="mg">include_top</em>=False,<br/><em class="mg">weights</em>=’imagenet’, <em class="mg">input_shape</em>=(224, 224, 3))</span><span id="ac7a" class="lz ma it lv b gy mf mc l md me">predictions = model.predict(images.reshape(-1, 224, 224, 3))<br/>pred_images = predictions.reshape(images.shape[0], -1)</span></pre><p id="3065" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们已经提取了特征，现在我们可以使用KMeans进行聚类。因为我们已经知道我们正在分离猫和狗的图像</p><pre class="lf lg lh li gt lu lv lw lx aw ly bi"><span id="c3fa" class="lz ma it lv b gy mb mc l md me">k = 2<br/>kmodel = KMeans(<em class="mg">n_clusters </em>= k, <em class="mg">n_jobs</em>=-1, <em class="mg">random_state</em>=728)<br/>kmodel.fit(pred_images)<br/>kpredictions = kmodel.predict(pred_images)<br/>shutil.rmtree(‘output’)</span><span id="af3b" class="lz ma it lv b gy mf mc l md me">for i in range(k):<br/>    os.makedirs(“output\cluster” + str(i))</span><span id="f345" class="lz ma it lv b gy mf mc l md me">for i in range(len(paths)):<br/>    shutil.copy2(paths[i], “output\cluster”+str(kpredictions[i]))</span></pre><p id="38a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是输出，成功了！它把图像分离出来:</p><p id="c3be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">狗:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mh"><img src="../Images/016752ade021557f2b8ce06bbd46b17c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Sb8By53P6y-IlJgXvpnAg.png"/></div></div></figure><p id="e81a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">猫:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mi"><img src="../Images/51bf638dd081405488ae5c459934b685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*621lz5OEeT-4UvqXEJyQZw.png"/></div></div></figure><p id="a5c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一件事，我们如何确定一个数据集的K值，对于这个数据集，你不知道类的数量。我们可以用侧影法或肘法来确定。这里我们将使用剪影法。这两种方法都应该用来获得最有把握的结果。我们将直接确定k。</p><p id="1be2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更多关于确定K的值:<a class="ae mj" href="https://medium.com/analytics-vidhya/how-to-determine-the-optimal-k-for-k-means-708505d204eb" rel="noopener">https://medium . com/analytics-vid hya/how-to-determine-the-optimal-K-for-K-means-708505d 204 EB</a></p><p id="265e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们将马的图像添加到原始数据集中。我们现在将确定k的值。</p><pre class="lf lg lh li gt lu lv lw lx aw ly bi"><span id="a2cf" class="lz ma it lv b gy mb mc l md me">sil = []<br/>kl = []<br/>kmax = 10</span><span id="6d9c" class="lz ma it lv b gy mf mc l md me">for k in range(2, kmax+1):<br/>    kmeans2 = KMeans(<em class="mg">n_clusters</em> = k).fit(pred_images)<br/>    labels = kmeans2.labels_<br/>    sil.append(silhouette_score(pred_images, labels, <em class="mg">metric</em> =   ‘euclidean’))<br/>    kl.append(k)</span></pre><p id="0f4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在将绘制这些值:</p><pre class="lf lg lh li gt lu lv lw lx aw ly bi"><span id="e372" class="lz ma it lv b gy mb mc l md me">plt.plot(kl, sil)<br/>plt.ylabel(‘Silhoutte Score’)<br/>plt.ylabel(‘K’)<br/>plt.show()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/4c8271d9be43fba06ad2e74197348b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*BSFxWmksnZQGFHljkUdAFw.png"/></div></figure><p id="a7f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，K的最佳值是3。我们还成功创建了第三个集群:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ml"><img src="../Images/710f306dda8d7290e33fa20f119f6eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hS6aGrYpnYtc0Zpodru4_w.png"/></div></div></figure><h1 id="5398" class="mm ma it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">结论</h1><p id="a485" class="pw-post-body-paragraph ki kj it kk b kl nd ju kn ko ne jx kq kr nf kt ku kv ng kx ky kz nh lb lc ld im bi translated">如您所见，KMeans聚类是一种很好的图像分离算法。有时，我们使用的方法可能不会给出准确的结果，我们可以尝试通过使用不同的卷积神经网络来修复它，或者尝试将我们的图像从BGR转换为RGB。</p><p id="48b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GitHub资源库:<a class="ae mj" href="https://github.com/Hrishi1999/Image-Segregation-with-KMeans/" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/hris 1999/Image-Segregation-with-k means/</a></p><p id="e994" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读！希望你有美好的一天:)</p></div></div>    
</body>
</html>