<html>
<head>
<title>Making a RNN model learn Arithmetic Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让 RNN 模型学习算术运算</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/making-rnn-model-learn-arithmetic-operations-b016ec4d8388?source=collection_archive---------25-----------------------#2020-08-05">https://towardsdatascience.com/making-rnn-model-learn-arithmetic-operations-b016ec4d8388?source=collection_archive---------25-----------------------#2020-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d0f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 RNN 的文本预测</h2></div><p id="6d82" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">问题</strong>:</p><p id="7239" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定短语“34+17”，模型应该预测序列“51”中的下一个单词。输入和输出是一个字符序列，依次是两个数及其结果的算术表达式。因此，我们的数据被表示为两个单词的序列<em class="lb">表达式</em>和<em class="lb">结果</em>。</p><p id="02a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">动机:</strong></p><p id="fa2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于递归神经网络(RNNs)最适合处理顺序数据，我们将建立一个简单的 RNN 模型来解决这个问题。</p><p id="f42b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可以通过 6 个步骤实现:</p><ol class=""><li id="82db" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">生成数据</li><li id="221f" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">建筑模型</li><li id="a3e1" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">矢量化、去矢量化数据&amp;移除填充</li><li id="af5a" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">创建数据集</li><li id="9ef1" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">训练模型</li><li id="bfe0" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">预言</li></ol><p id="c16a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">导入必要的库</strong></p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="2b85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤 1:生成数据</strong></p><p id="e8a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要为输入和输出字符串定义一个包含所需字符集的词汇表。因此，词汇表由 0 到 9 位数、+、-、*、/和十进制(.)符号。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="aa71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在构建的 RNN 模型需要张量中的数值作为输入。这个字符序列的一个合适的表示是独热编码矢量。向量的维数应该等于词汇的长度，也就是特征的总数。需要创建一个字典来将字符标记为数值。此外，创建另一个字典，将索引作为键，将相应的字符作为值，以便在后面的步骤中使用。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="efb8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们生成数据，它是一个单一的<strong class="kh ir">表达式、</strong>和<strong class="kh ir">结果</strong>对。为了做到这一点，首先创建两个随机整数‘first’和‘second’，然后创建<strong class="kh ir"> <em class="lb">表达式</em> </strong>作为字符串转换后的数字的串联，<em class="lb"/><strong class="kh ir"><em class="lb">结果</em> </strong>是字符串转换后的计算结果<strong class="kh ir"> <em class="lb"> first+second </em> </strong>。该函数应返回创建的<strong class="kh ir">表达式、</strong>和<strong class="kh ir">结果</strong>对。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="5c65" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">第二步:建立模型</strong></p><p id="5707" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该模型是由编码器和解码器两部分组成的 keras 序列模型。编码器部分是一个 SimpleRNN 层，hidden_units=128，num_features。它是一个完全连接的 RNN 层，这些单元的输出反馈到网络，它默认使用“tanh”激活。该层的输出将是单个矢量表示，为了实现整个输出的单个矢量表示，我们将使用 RepeatVector()层，重复“max_time_steps”。</p><p id="2f53" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个矢量表示被输入到解码器部分。解码器由另一个 SimpleRNN 层组成，它采用输入的矢量表示并生成预测序列。因此，用“hidden_units”定义这个层，并将“return_sequences”设置为“True”。</p><p id="9b5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该 RNN 的输出是一个序列，该序列将进入具有“softmax”激活功能的密集层。所以，在每个时间步，对于不同的字符，输出会有不同的可能性。</p><p id="e9f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们需要将密集层应用于各个时间步长，我们将把密集层封装在 TimeDistribute 层中，不同时间步长的隐藏状态是不同的。我们需要我们的角色的概率分布‘num _ features’。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/42279314c10dd5df18d2b5ebc29968fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*xVerg_zGwWunEEpyynQnQA.png"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">RNN 模型的编码器和解码器部分</p></figure><p id="594d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤 3:矢量化、去矢量化数据&amp;移除填充符</strong></p><p id="e990" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了对给定的表达式和结果进行矢量化，定义了以下函数。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="923b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要将“表达式”和“结果”反向矢量化，请使用“index_to_char”字典和相关索引创建一个列表。使用“np.argmax()”通过枚举“expression”或“result”来选取最大索引值。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="2f55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果生成的(表达式，结果)是(' 3–34 '，'-31 ')，那么它的去矢量化形式应该用零填充，如' 03–34 '，' 00–31 '。我们可以在显示输出结果时删除填充。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="e731" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">第四步:创建数据集</strong></p><p id="b876" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经定义了一个函数来创建一个(表达式，结果)对。现在创建一个包含许多这样的(表达式，结果)对的数据集来训练模型。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="b64a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">第五步:训练模型</strong></p><p id="be23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建 50，000 个样本的数据集，并使用 20%的验证拆分来训练模型。定义一个回调函数来监控“val_loss ”,如果连续 10 个时期没有观察到变化，则停止模型训练。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="adad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">第六步:预测</strong></p><p id="ffb5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在创建一个包含 20 个样本的测试数据集，并使用训练好的模型预测结果。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="2bff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">输出:</strong></p><p id="813b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面给出了 20 个测试数据样本的预测，我们观察到 70%的预测是正确的。由于测试数据集是随机生成的，预测序列的准确性每次都会发生变化。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi me"><img src="../Images/2fcc11159b66273de131ccbeab1707cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*UQwM8hVGprl4gLD0hD0WhQ.png"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">预测结果</p></figure></div></div>    
</body>
</html>