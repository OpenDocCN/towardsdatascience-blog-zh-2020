<html>
<head>
<title>5 Bigquery SQL Commands You [Probably] Didn’t Know About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您[可能]不知道的 5 个 Bigquery SQL 命令</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-bigquery-sql-commands-you-probably-didnt-know-about-ebfd9d0dc160?source=collection_archive---------18-----------------------#2020-05-26">https://towardsdatascience.com/5-bigquery-sql-commands-you-probably-didnt-know-about-ebfd9d0dc160?source=collection_archive---------18-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="29b2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将对您的数据科学职业生涯有巨大帮助的 5 个 SQL 技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6df929ef9c927f743952ff8145577dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1-RjvctFd95edSU8Aw-WQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="bec3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">读者好。</p><p id="3316" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你正在阅读这篇文章，你可能是一名数据从业者，或者渴望成为一名数据从业者。欢迎来到数据世界，在这里放松一下，你将会花相当多的时间学习新的东西。</p><p id="c907" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着数据科学领域工作需求的增加，人们渴望掌握该职业所需的技能。Python、机器学习、数据可视化，不胜枚举。然而，一项经常被忽视的技能是…</p><h2 id="5b2a" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">结构化查询语言</h2><p id="429a" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">SQL 一直是所有数据库的首选查询语言，而且它不会很快走向任何地方。<strong class="la iu">所有数据科学家都必须从某个地方获取数据。</strong>通常情况下，它来自 SQL 关系数据库。</p><p id="0108" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">快进到今天，我们可以在自己的公司中运行 SQL 相关的数据仓库。这些是 OLAP(在线分析处理)数据库，通常允许复杂的查询和与数据可视化工具的协作，同时不会干扰生产数据库。</p><p id="ba03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">著名的有 Google Bigquery，Amazon Redshift，Azure SQL 数据仓库，不胜枚举。</p><p id="81ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我们将讨论一些独特的<strong class="la iu"> SQL 命令</strong>，这些命令你可能不知道，但是当你碰到类似的砖墙时，它们将会有很大的帮助。</p><p id="1d1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们开始吧。</p><h1 id="1181" class="ms lv it bd lw mt mu mv lz mw mx my mc jz mz ka mf kc na kd mi kf nb kg ml nc bi translated">1.JSON 列到表</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/d69a23a4d47ff964c5fcefa68727344d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkyTnmEvfM9p3Lv9suEW2A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="db07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如图所示，这是一个命令，我们用它将一个属于<strong class="la iu"> JSON 字符串</strong>类型的 Bigquery 列转换成一个完整的<strong class="la iu">表</strong>。您可能会在执行数据工程任务(通常来自外部数据源)时遇到这种情况。</p><p id="13d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，我们可以使用 JSON_EXTRACT_SCALAR Bigquery 命令。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="eb1b" class="lu lv it nf b gy nj nk l nl nm"><strong class="nf iu">JSON_EXTRACT_SCALAR(&lt;JSON COLUMN&gt;, $[&lt;PARENT&gt;])</strong></span></pre><p id="bb9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个命令中，JSON 字符串被拆分成<strong class="la iu">父</strong>、<strong class="la iu">子</strong>和<strong class="la iu">子</strong>。<br/>函数是这样工作的:<br/>JSON _ EXTRACT _ SCALAR(<strong class="la iu">JSON _ STRING</strong>，" $[' <strong class="la iu"> PARENT_NAME </strong> ']")将得到子值。对于数据工程师来说，可以把它看作是一种键值的概念。</p><p id="3617" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本例中，<br/>我们使用 JSON _ EXTRACT _ SCALAR(<strong class="la iu">saved _ fields</strong>，" $[' <strong class="la iu"> email </strong> ']")，这将在 JSON <strong class="la iu"> </strong>字符串中产生一列所有电子邮件。很酷吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae np" href="https://giphy.com/storksmovie/" rel="noopener ugc nofollow" target="_blank">鹳</a>的 Gif</p></figure><p id="ebe3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果孩子是在一个<strong class="la iu">列表</strong>格式中，就像这个例子中的父<strong class="la iu"> language_skill </strong>一样，该怎么办？</p><p id="e81a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用 JSON _ EXTRACT _ SCALAR(saved _ fields，“$。language_skill[0]")，这将为您提供列表中的第一个元素作为列。</p><p id="fa95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">差不多就是这样。为了提取该列中的所有信息，我们使用</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="2f17" class="lu lv it nf b gy nj nk l nl nm"><strong class="nf iu">SELECT</strong> JSON_EXTRACT_SCALAR(saved_fields, "$['email']") <strong class="nf iu">as</strong> email, JSON_EXTRACT_SCALAR(saved_fields, "$['name']") <strong class="nf iu">as</strong> <strong class="nf iu">name</strong>, JSON_EXTRACT_SCALAR(saved_fields, "$['phone']")<strong class="nf iu">as</strong> phone, JSON_EXTRACT_SCALAR(saved_fields, "$['gender']")<strong class="nf iu">as</strong> gender, JSON_EXTRACT_SCALAR(saved_fields, "$['nationality']")<strong class="nf iu">as</strong> nationality, JSON_EXTRACT_SCALAR(saved_fields, "$['birthday']")<strong class="nf iu">as</strong> birthday, JSON_EXTRACT_SCALAR(saved_fields, "$['experience_seeker']")<strong class="nf iu">as</strong> experience_seeker, JSON_EXTRACT_SCALAR(saved_fields, "$.language_skill[0]") <strong class="nf iu">as</strong> language_skill_1, JSON_EXTRACT_SCALAR(saved_fields, "$.language_skill[1]") <strong class="nf iu">as</strong> language_skill_2, JSON_EXTRACT_SCALAR(saved_fields, "$.language_skill[2]") <strong class="nf iu">as</strong> language_skill_3, JSON_EXTRACT_SCALAR(saved_fields, "$.language_skill[3]") <strong class="nf iu">as</strong> language_skill_4, JSON_EXTRACT_SCALAR(saved_fields, "$.language_skill[4]") <strong class="nf iu">as</strong> language_skill_5, JSON_EXTRACT_SCALAR(saved_fields, "$['highest_edu_qualification']")<strong class="nf iu">as</strong> highest_edu_qualification, JSON_EXTRACT_SCALAR(saved_fields, "$['job_cv']")<strong class="nf iu">as</strong> job_cv <strong class="nf iu">from</strong>  dataset.<strong class="nf iu">table</strong></span></pre><p id="4d27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">官方文档，此处阅读<a class="ae np" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/json_functions" rel="noopener ugc nofollow" target="_blank"><strong class="la iu"/></a>。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="8c7f" class="ms lv it bd lw mt nx mv lz mw ny my mc jz nz ka mf kc oa kd mi kf ob kg ml nc bi translated">2.划分依据</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/94e141fb7952170c6b6e2e873100019f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*MnzxOJpYiJMHi3SANGvvtw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="549f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个命令不仅是这个列表中最常用的，而且在<strong class="la iu">数据科学访谈</strong>中也经常被提到。</p><p id="960e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当谈到数据聚合时，许多经验丰富的数据科学家会自动求助于<strong class="la iu"> Group By，</strong>这是聚合数据最常用的命令。</p><p id="77cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，您可能会遇到<strong class="la iu">按</strong>分组不够的情况。<br/><strong class="la iu">Group By</strong>函数要求你按列对数据进行分组，但是如果你不想分组呢？如果您希望在聚合数据的同时保留所有现有的行，该怎么办？</p><p id="6623" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我能描述它的最好方式是给你一个面试问题:</p><h2 id="4663" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">分组依据</h2><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="9fe0" class="lu lv it nf b gy nj nk l nl nm">Given customerID, date and revenue columns. <br/>For <strong class="nf iu">EACH</strong> date, how do I show the total revenue value for <strong class="nf iu">EACH</strong> customer?</span></pre><p id="c8c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">诸如此类的问题可以由<strong class="la iu">小组通过</strong>来解决</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="afb3" class="lu lv it nf b gy nj nk l nl nm">Select<br/>date,<br/>customerID,<br/>sum(revenue)<br/>from dataset<br/>group by date, customerID</span></pre><p id="7cc2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该命令按日期和 customerID 对数据进行分组。<br/>这实质上意味着对于每个日期，我们将为每个 customerID 提供 1 行。</p><h2 id="5f77" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">划分依据</h2><p id="59fa" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当您希望在执行聚合后<strong class="la iu">保留所有行</strong>时，Partition By 就派上了用场。对于上面的同一个问题:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="ae9d" class="lu lv it nf b gy nj nk l nl nm">Given customerID, date and revenue columns. <br/>For <strong class="nf iu">EACH</strong> date, how do I show the total revenue value for <strong class="nf iu">EACH</strong> customer while keeping all the rows?</span></pre><p id="5d0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过以下方式实现这一点</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="d3d4" class="lu lv it nf b gy nj nk l nl nm">Select<br/>date,<br/>customerID,<br/>revenue,<br/>sum(revenue) over (partition by date,customerID) as revenue_per_day<br/>from dataset </span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/84362bc3df902a9d02c6e81cc01cdffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*vbRVZeL3dTa0zlQJ5jyzCg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8d78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意所有的行在聚合后是如何被保留的。这里有一个我经常得到的更实际的例子。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="872a" class="lu lv it nf b gy nj nk l nl nm">Given customerID, date and revenue columns. <br/>For each date, how do I show the highest revenue row for each customer?</span></pre><p id="4f00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用 partition by 命令，您可以通过以下方式轻松实现这一点</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="7e51" class="lu lv it nf b gy nj nk l nl nm">Select<br/>date,<br/>customerID,<br/>revenue,<br/>sum(1) over (partition by date order by revenue desc rows unbounded preceding) as row_num<br/>from dataset <br/>having row_num = 1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/5bf464a1b6aeabbdd5bdb59055031281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R1PjVOwfI1rXq9cstPdAZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="bdd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该命令正在执行:</p><ul class=""><li id="614b" class="of og it la b lb lc le lf lh oh ll oi lp oj lt ok ol om on bi translated">对于每个日期和 customerID，每次出现一行时，将行号+1，按收入值排序(降序)</li><li id="52dc" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated">仅筛选 row_num=1 的行，这将返回每个客户每个日期的最高收入行</li></ul><p id="aab1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望现在你意识到通过命令分割<strong class="la iu">是多么强大。</strong></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="8208" class="ms lv it bd lw mt nx mv lz mw ny my mc jz nz ka mf kc oa kd mi kf ob kg ml nc bi translated">3.拥有</h1><p id="dd2c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><strong class="la iu">有</strong>条款。<br/>如果你熟悉<strong class="la iu"> Where </strong>子句，那是极其相似的。<br/>当根据<strong class="la iu">布尔</strong>表达式进行评估时，它过滤返回<strong class="la iu">真值</strong>的行。</p><p id="253c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唯一的区别是对于有子句的<strong class="la iu">，它:</strong></p><ul class=""><li id="e3ad" class="of og it la b lb lc le lf lh oh ll oi lp oj lt ok ol om on bi translated">工作查询中必须有一个按分组的<strong class="la iu">或任何<strong class="la iu">聚合</strong></strong></li><li id="7e1e" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated">发生在任何表示的<strong class="la iu">聚合之后，order by 之前。</strong>另一方面，<strong class="la iu"> Where </strong>子句出现在任何聚合之前</li></ul><p id="7abe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您已经可以使用嵌套的 where 子句实现这一点:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="d1bc" class="lu lv it nf b gy nj nk l nl nm">#Looking for revenue &gt; 100</span><span id="6198" class="lu lv it nf b gy ot nk l nl nm">Select * from(<br/>Select<br/>date,<br/>customerID,<br/>sum(revenue) as revenue_sum<br/>from dataset<br/>group by 1,2) <br/>where revenue_sum &gt; 100</span></pre><p id="e911" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，当你可以选择编写更专业、看起来更酷的代码时，为什么要这样做呢？</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="c8be" class="lu lv it nf b gy nj nk l nl nm">Select<br/>date,<br/>customerID,<br/>sum(revenue) as revenue_sum<br/>from dataset<br/>group by 1,2<br/>having revenue_sum &gt; 100</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae np" href="https://wifflegif.com/" rel="noopener ugc nofollow" target="_blank"> wiffleGif </a>的 gif</p></figure></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="85e2" class="ms lv it bd lw mt nx mv lz mw ny my mc jz nz ka mf kc oa kd mi kf ob kg ml nc bi translated">4.正则表达式</h1><p id="c1ee" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">Regex 是正则表达式的缩写，是 NLP 领域中一个非常流行的术语。正则表达式被定义为一系列定义搜索模式的<strong class="la iu">字符。它主要用于处理文本、数字和标点符号。</strong></p><p id="c88b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是 Regex 上的<a class="ae np" href="https://www.rexegg.com/regex-quickstart.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">文档</strong> </a>。</p><p id="904a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在正则表达式中做很多事情，比如查找特定的文本，删除数字或标点符号，替换某些字符等等。下面是如何在 Bigquery SQL 中实现的。</p><p id="ce70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Bigquery 中有 3 个主要的 Regex 命令:</p><h2 id="501f" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">正则表达式包含</h2><p id="ec25" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果提供的字符串(值)与正则表达式(REGEXP)部分匹配，则 REGEXP_CONTAINS 返回 TRUE。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="ae4b" class="lu lv it nf b gy nj nk l nl nm">REGEXP_CONTAINS(value, regexp)</span></pre><p id="6df5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个例子，我们想要过滤 customerID 以<strong class="la iu">‘P’</strong>字符开始的数据。我们可以通过以下方式实现这一目标</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="149f" class="lu lv it nf b gy nj nk l nl nm">#^P means string starts with the character P<br/>Select<br/>*<br/>from dataset <br/>where REGEXP_CONTAINS(customerID, '^P')</span></pre><h2 id="36f3" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">正则表达式 _ 替换</h2><p id="e93f" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">REGEXP_REPLACE 从提供的字符串(值)中搜索特定的正则表达式模式，并用您指定的内容替换它。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="19ca" class="lu lv it nf b gy nj nk l nl nm">REGEXP_REPLACE(value, regexp, replacement)</span></pre><p id="8d6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与上一个示例类似，让我们将所有以字符<strong class="la iu">‘P’</strong>开头的 customerID 替换为‘以 P 开头’。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="086a" class="lu lv it nf b gy nj nk l nl nm">select <br/>*,<br/>REGEXP_REPLACE(customerID,'^P','Starts with P')<br/>from dataset</span></pre><h2 id="95b5" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">正则表达式 _ 提取</h2><p id="f513" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">REGEXP_EXTRACT 从提供的字符串(值)中返回与指定的 Regex 模式匹配的第一个子字符串。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="87bb" class="lu lv it nf b gy nj nk l nl nm">REGEXP_EXTRACT(value, regexp)</span></pre><p id="3d46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似于前面的例子，让我们提取第一个字母子串。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="994c" class="lu lv it nf b gy nj nk l nl nm">select <br/>*,<br/>REGEXP_EXTRACT(customerID,'[a-zA-Z]')<br/>from dataset</span></pre></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="d90b" class="ms lv it bd lw mt nx mv lz mw ny my mc jz nz ka mf kc oa kd mi kf ob kg ml nc bi translated">5.随着</h1><p id="28b8" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">带有子句的<strong class="la iu">包含子查询，每次后续的<strong class="la iu"> SELECT </strong>语句运行时都会运行这些子查询。它可以在查询的任何地方被引用，包括<strong class="la iu">联接</strong>、<strong class="la iu">联合、</strong>和<strong class="la iu">where</strong>。</strong></p><p id="0d70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">带有子句的<strong class="la iu">对于可读性非常有用，它也有助于数据从业者对所编写的查询有一个高层次的理解。</strong></p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="80c4" class="lu lv it nf b gy nj nk l nl nm">WITH q1 AS (my_query)<br/>SELECT *<br/>FROM<br/>  (WITH q2 AS (SELECT * FROM q1) SELECT * FROM q2)</span><span id="c74d" class="lu lv it nf b gy ot nk l nl nm">WITH q1 AS (my_query)<br/>SELECT *<br/>FROM q2 a<br/>left join my_query b on <br/>a.id = b.id</span></pre><p id="694f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，在同一个<strong class="la iu"> With </strong>子句中引入的别名必须是唯一的，但是同一个别名可以使用多次。如果有相似的别名，带子句的<strong class="la iu">将自动取最新引用的别名。</strong></p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="a94b" class="lu lv it nf b gy nj nk l nl nm">WITH q1 AS (my_query)<br/>SELECT *<br/>FROM<br/>  (WITH q2 AS (SELECT * FROM q1),  # q1 resolves to my_query<br/>        q3 AS (SELECT * FROM q1),  # q1 resolves to my_query<br/>        q1 AS (SELECT * FROM q1),  # q1 (in the query) resolves to my_query<br/>        q4 AS (SELECT * FROM q1)   # q1 resolves to the WITH subquery<br/>                                   # on the previous line.<br/>    SELECT * FROM q1)  # q1 resolves to the third inner WITH subquery.</span></pre></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="bbeb" class="ms lv it bd lw mt nx mv lz mw ny my mc jz nz ka mf kc oa kd mi kf ob kg ml nc bi translated">结论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/0d09223588d09ae3a1f4fa97d72e33b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zTf-LqO0fJF-zEOd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae np" href="https://unsplash.com/@hellosmith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">龙威·史密斯</a>在<a class="ae np" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7f5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">干得好！如果你已经做到了这一步，我想你已经对 SQL 有所了解了。在本文中，我们浏览了这些 SQL 命令:</strong></p><ul class=""><li id="22e7" class="of og it la b lb lc le lf lh oh ll oi lp oj lt ok ol om on bi translated">JSON 列到表</li><li id="dbd8" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated">划分依据</li><li id="bb8c" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated">拥有</li><li id="85f1" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated">正则表达式</li><li id="2d74" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated">随着</li></ul><p id="67e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让它留在你的脑海里，因为我发誓你以后会经常用到它。</p><h1 id="788a" class="ms lv it bd lw mt mu mv lz mw mx my mc jz mz ka mf kc na kd mi kf nb kg ml nc bi translated">在你走之前</h1><p id="6f66" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们的数据之旅还没有结束。敬请关注，我正在撰写关于<strong class="la iu">更多数据科学项目</strong>，以及更多数据行业的故事、指南和经验。与此同时，请随意查看我的其他<a class="ae np" href="https://medium.com/@nickmydata" rel="noopener">文章</a>，以暂时填补您对数据的渴望。<br/>一如既往，我引用一句话作为结束。</p><blockquote class="ow ox oy"><p id="32c7" class="ky kz oz la b lb lc ju ld le lf jx lg pa li lj lk pb lm ln lo pc lq lr ls lt im bi translated">从数据中学习几乎是普遍有用的。掌握它，你将在任何地方受到欢迎。Splunk 首席技术官托德·帕帕约安努</p></blockquote></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h2 id="472a" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">订阅我的时事通讯，保持联系。</h2><p id="bf7b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">也可以通过<a class="ae np" href="https://nickefy.medium.com/membership" rel="noopener"> <strong class="la iu">我的链接</strong> </a>注册一个中等会员来支持我。你将能够从我和其他不可思议的作家那里读到无限量的故事！</p><p id="597b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我正在撰写更多关于数据行业的故事、文章和指南。你绝对可以期待更多这样的帖子。与此同时，可以随时查看我的其他<a class="ae np" href="https://medium.com/@nickmydata" rel="noopener"> <strong class="la iu">文章</strong> </a>来暂时填补你对数据的饥渴。</p><p id="1896" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="oz">感谢</em> </strong> <em class="oz">的阅读！如果你想与我取得联系，请随时联系我，地址是 nickmydata@gmail.com 或我的</em> <a class="ae np" href="https://www.linkedin.com/in/nickefy/" rel="noopener ugc nofollow" target="_blank"> <em class="oz"> LinkedIn 个人资料</em> </a> <em class="oz">。也可以在我的</em><a class="ae np" href="https://github.com/nickefy" rel="noopener ugc nofollow" target="_blank"><em class="oz">Github</em></a><em class="oz">中查看之前写的代码。</em></p></div></div>    
</body>
</html>