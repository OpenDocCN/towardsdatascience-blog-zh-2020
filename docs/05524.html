<html>
<head>
<title>Graph Theory | Breadth First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图论|广度优先搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-theory-breadth-first-search-d898e9f40fdd?source=collection_archive---------34-----------------------#2020-05-09">https://towardsdatascience.com/graph-theory-breadth-first-search-d898e9f40fdd?source=collection_archive---------34-----------------------#2020-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5601" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">简化的图论</h2><div class=""/><blockquote class="jz ka kb"><p id="d8b8" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">欢迎大家回来。今天我们讨论的是<strong class="kf jd">广度优先搜索</strong>(<strong class="kf jd">BFS</strong>)——一种图探索算法。我们在之前的帖子中讨论了关于<strong class="kf jd">深度优先搜索</strong>。如果你不知道什么是图，或者想快速复习一下核心概念，我绝对推荐你看看我全新的关于图论的<strong class="kf jd">系列</strong>这里。</p></blockquote><h2 id="1552" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated">概观</h2><p id="b763" class="pw-post-body-paragraph kc kd it kf b kg lx ki kj kk ly km kn ll lz kq kr lp ma ku kv lt mb ky kz la im bi translated"><strong class="kf jd"> <em class="ke">广度优先搜索</em> </strong>或简称为<strong class="kf jd"> <em class="ke"> BFS </em> </strong>是我们用来探索图的边和顶点的基本算法，它在许多现实世界的应用中起着关键作用。它运行的复杂度为<strong class="kf jd">O</strong>(<strong class="kf jd">V</strong>+<strong class="kf jd">E</strong>)其中 O、V、E 分别对应<strong class="kf jd"> <em class="ke">大 O </em> </strong>、<strong class="kf jd"> <em class="ke">顶点</em> </strong>和<strong class="kf jd"> <em class="ke">边</em> </strong>。这种机制是许多应用程序的主要构件。我们可以通过实际遍历图的方式来区分 BFS 和 DFS。顾名思义，BFS 访问广度先于深度。这是把他们分开的基本事实。BFS 可以用于一个目的:在无向图中寻找最短路径<strong class="kf jd"><em class="ke"/></strong>。</p><h2 id="c2eb" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated">基本 BFS</h2><p id="bfda" class="pw-post-body-paragraph kc kd it kf b kg lx ki kj kk ly km kn ll lz kq kr lp ma ku kv lt mb ky kz la im bi translated">BFS 算法从某个任意节点开始，并在移动到下一个深度之前访问其所有邻居。简而言之，BFS 是分层工作的。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/c5a894eb907ac307392ae555d98645a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*EOOO-ocyu4XdmUMdeFLX3Q.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者照片</p></figure><p id="a5ca" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">如果我们从节点 1 开始 BFS，它将首先访问它的邻居，即 2、3 和 4。一旦我们完成了节点 1，我们最终会移动到下一个节点。在我们的例子中，节点 2、3 和 4 没有任何邻居，因此我们移动到下一个未访问的节点，即节点 6。节点 6 的直接邻居是 5、7 和 8。与前一个例子一样，节点 5 和 7 没有任何邻居，因此我们必须使用节点 8。游戏在这里发生了变化，节点 8 有两个邻居未被访问，所以我们访问它们并标记为已访问。这是一个非常基本的例子，但是相信我，这种图表只存在于纸上。</p><p id="0fb7" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">为了跟踪下一个要访问的节点，我们将顺序保存在一个<strong class="kf jd">队列中。我将用一个更复杂的例子来解释它，这样我们会对它有更好的理解。</strong></p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/9bb8ee27fb7915ff487d4f776e335c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*pjWhbRsssI-x312gpH98NQ.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者照片</p></figure><p id="993a" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">我们从节点 0 开始，将其添加到队列中，如下所示。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/2a0c4ce48028c868cb2e5204db5403c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:242/format:webp/1*raDGp_2PL3TcEZf_olmUyw.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者照片</p></figure><p id="52d3" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">现在，我们必须检查是否有任何邻居未被访问，是的。0 的直接邻居是 9、7 和 11。首先，我们将 0 标记为已访问，并将 0 的所有邻居添加到队列中。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/34844c979f0b6cbf39527fe35b2ed041.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*ph_KfC92hURRzLs915KlOA.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者照片</p></figure><p id="1346" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">如上所示，队列中有三个新的未访问节点。下一个要访问的节点是 9。因此，我们将其标记为已访问，并将所有直接邻居添加到队列中，如下所示。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/f5be5dde5d437e59b006031de739df47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6L9W6Q5PnD_BR09l8BeeXg.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者照片</p></figure><p id="6daf" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">下一个要访问的节点是 7，所以我们考虑到它，并将其所有邻居添加到队列中。节点 7 有三个邻居，即 3、6 和 11。如果我们看一下队列，11 已经在那里了，所以我们省略它，把其余的添加到队列中，如下所示。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mw"><img src="../Images/e7b02c2f80edf1a3d2f6b72a60d48418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JKuVcOgtrtAukcxInQqYCA.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者照片</p></figure><p id="01a2" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">我们重复这个过程，直到队列中的所有元素都被访问。这是 BFS 的整体工作流程。</p><h2 id="788d" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated">使用队列</h2><p id="9fb6" class="pw-post-body-paragraph kc kd it kf b kg lx ki kj kk ly km kn ll lz kq kr lp ma ku kv lt mb ky kz la im bi translated">BFS 算法使用队列来跟踪下一个要访问的节点。到达一个节点后，我们将所有邻居节点添加到同一个队列中，以便以后访问。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mx"><img src="../Images/932ce9bec64a52fd698202307a7fb16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5GRONqP7WAEPaUptyUnWw.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者照片</p></figure><p id="a8fa" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">队列数据结构的工作方式与真实世界的队列完全一样，对象被添加到队列的后面。首先进入队列的对象具有最高优先级。这意味着添加到队列中的第一个元素将得到服务，并首先离开队列。有两种与队列相关的基本操作，即在队列的后面插入一个元素和从前面移除一个元素，前者称为<strong class="kf jd"><em class="ke"/></strong>，后者称为<strong class="kf jd"><em class="ke"/></strong>。</p><h2 id="1bea" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated">伪码</h2><pre class="md me mf mg gt my mz na nb aw nc bi"><span id="3572" class="lc ld it mz b gy nd ne l nf ng"><strong class="mz jd"># </strong>global variables<strong class="mz jd"><br/>n = number_of_nodes_in_the_graph<br/>g = adjacency_list<br/>visited = [false] * n<br/>q = Queue()<br/><br/>q.enqueue(initial node)<br/><br/>while q is not empty<br/>   {<br/>     x = q.dequeue();<br/>     if x is not visited:<br/>      {<br/>        visited[x] = true<br/>        neighbors = g[x] <br/>        for y in neighbors:<br/>            if y is not visited:  <br/>	       q.enqueue(y)<br/>      }<br/>   }</strong></span></pre><p id="51e3" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">我们将节点总数保存在一个名为<strong class="kf jd"> <em class="ke"> n </em> </strong>的变量中。我们将有一个<a class="ae lb" rel="noopener" target="_blank" href="/get-started-with-graph-theory-2b4460eeafc"> <strong class="kf jd"> <em class="ke">邻接表</em></strong></a>——一个用于在内存中存储图形的结构——它包括每个节点及其对应的相邻连接。这是节点到边列表的映射。我们用一个 list <strong class="kf jd"> <em class="ke"> visited </em> </strong>来检查一个特定的节点是否被访问过，它用 n 个 false 值初始化，因为我们还没有访问过任何节点。正如我们前面讨论的，我们使用队列<strong class="kf jd"> <em class="ke"> q </em> </strong>来跟踪要访问的节点。我们向队列中插入或<strong class="kf jd"> <em class="ke">入队</em> </strong>一个任意节点，以启动 BFS 过程。我们移除或<strong class="kf jd"> <em class="ke">出队</em> </strong>队列中存在的元素，我们必须确保当前节点尚未被访问。如果否，我们将当前节点的已访问状态更改为真。最后，我们将把所有直接邻居排入我们使用的队列。这个过程将被重复，直到队列变空，即当所有节点都被访问时。</p><h2 id="2ae4" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated">BFS 还能做什么</h2><ul class=""><li id="d4fd" class="nh ni it kf b kg lx kk ly ll nj lp nk lt nl la nm nn no np bi translated">对等网络</li><li id="5c95" class="nh ni it kf b kg nq kk nr ll ns lp nt lt nu la nm nn no np bi translated">社交网站</li><li id="a450" class="nh ni it kf b kg nq kk nr ll ns lp nt lt nu la nm nn no np bi translated">路径寻找</li><li id="92c9" class="nh ni it kf b kg nq kk nr ll ns lp nt lt nu la nm nn no np bi translated">碎片帐集</li><li id="f698" class="nh ni it kf b kg nq kk nr ll ns lp nt lt nu la nm nn no np bi translated">网络广播</li></ul><p id="24bc" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">这是一个关于<strong class="kf jd">广度优先搜索</strong>的简介。希望大家觉得有帮助。</p><p id="3047" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">在下一篇文章中，我们会看到如何使用 BFS 从图中找到最短路径。谢谢你的时间和努力。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nv"><img src="../Images/12a42ea150b669878b350084c16af78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgzROdVHD1jDW91xwO8mVA.png"/></div></div></figure></div></div>    
</body>
</html>