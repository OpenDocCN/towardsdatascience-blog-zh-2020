<html>
<head>
<title>A brief guide to data imputation with Python and R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和R进行数据插补的简要指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-brief-guide-to-data-imputation-with-python-and-r-5dc551a95027?source=collection_archive---------33-----------------------#2020-05-31">https://towardsdatascience.com/a-brief-guide-to-data-imputation-with-python-and-r-5dc551a95027?source=collection_archive---------33-----------------------#2020-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fc9f" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据科学提示</h2><div class=""/><div class=""><h2 id="52fa" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">让数据变得干净</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/47d6f2e8692e60b42b9101690064186f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z4a2C0C3rDnOnGGw"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@nosoylasonia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">胡安·戈麦斯</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="5807" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们都知道，数据清理是数据分析过程中最耗时的阶段之一。我们需要<a class="ae lh" rel="noopener" target="_blank" href="/7-idioms-to-acquire-missing-values-every-data-scientist-should-know-2edf4224360c">获取缺失值</a>、<a class="ae lh" rel="noopener" target="_blank" href="/handle-missing-data-with-r-10-daily-used-idioms-13d849d01690">检查它们的分布</a>，找出模式，并决定如何填充空间。此时，您应该意识到，缺失数据模式的识别和正确的插补过程将影响进一步的分析。所以，让我介绍一些常见分析语言的技巧:R和Python。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="550a" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">为什么数据丢失了？</h2><p id="d0d5" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在开始插补过程之前，我们应该首先获取数据，并找到缺失数据的模式或方案。简单地说，有两种类型的缺失数据:MCAR和MNAR。</p><p id="47b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">MNAR(非随机缺失)是数据最严重的问题。这意味着，我们需要找到缺失功能之间的依赖关系，并开始数据收集过程。它提供了某种分析步骤，包括使用不同的数据源、分析连接和搜索替代数据。</p><p id="d1bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">MCAR(完全随机缺失)意味着缺失值中没有深层模式，因此我们可以利用这一点来决定是否可以移除或估算一些行/要素。这是我们可以处理的事情，但只能在经验范围内，因为可能有太多的缺失数据(占总记录的百分比)。</p><p id="de96" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，为了便于说明，我们将使用下一个玩具示例:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/53c218829c3219d4de1af2d3a47c9e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*pKH82CyEkjVm1gsQ4fky-Q.png"/></div></figure><p id="dc23" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以看到对多个缺失值、数值和分类缺失值的影响。</p><h2 id="619f" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">R的力量</h2><p id="1809" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">R编程语言有一个很棒的社区，给R开发仓库增加了很多包和库。所以，这并不奇怪，我们有了<a class="ae lh" href="https://cran.r-project.org/web/packages/mice/index.html" rel="noopener ugc nofollow" target="_blank">鼠标包</a>。它包括许多与链式方程多元插补相关的功能(<a class="ae lh" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3074241/" rel="noopener ugc nofollow" target="_blank">即MICE算法</a>)。您可以深入<a class="ae lh" href="https://cran.r-project.org/web/packages/mice/mice.pdf" rel="noopener ugc nofollow" target="_blank">文档</a>了解细节，但我将给出基本示例。</p><p id="5e28" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，让我们看看上面提到的玩具示例中缺失数据的模式:</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="47d4" class="ml mm it nk b gy no np l nq nr">library(mice)<br/>md.pattern(df_test)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/36278611efb7ebaf05368dd22ccb69ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*yl2CE9i2Jc85sYbpvOa58A.png"/></div></figure><p id="b589" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Mice包内置工具<code class="fe nt nu nv nk b">md.pattern()</code>，显示缺失值的分布和缺失特征的组合。你可以在我之前的关于用R 熟悉<a class="ae lh" rel="noopener" target="_blank" href="/handle-missing-data-with-r-10-daily-used-idioms-13d849d01690">缺失数据的文章中读到更多关于这个工具的内容。这个函数也给了我们一个很好的例子:</a></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/8962096673ab41c69b4a80a41191e786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*QYaBTg70se4Xr3JvPdtx1A.png"/></div></figure><p id="ce5c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用mice-imputor的工作分为两个阶段。在第一阶段，我们准备估算器，在第二阶段，我们应用它。</p><p id="6276" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">插补准备包括预测方法的选择以及在计算中包括/排除列。我们只需要通过<code class="fe nt nu nv nk b">$method</code>属性重写必要列的默认插补方法。在我们的例子中，我们对第一列和第三列使用了<code class="fe nt nu nv nk b">mean</code>(无条件均值)，对第五列使用了<code class="fe nt nu nv nk b">pmm</code>(预测均值匹配)，对第四列使用了norm(基于其他特征的贝叶斯线性回归预测)，对条件变量使用了<code class="fe nt nu nv nk b">logreg</code>(对2值变量的逻辑回归预测)。关于<code class="fe nt nu nv nk b">mice()</code>方法和命令<code class="fe nt nu nv nk b">methods(your_mice_instance)</code>，请参见文档中的更多<a class="ae lh" href="https://www.rdocumentation.org/packages/mice/versions/2.25/topics/mice" rel="noopener ugc nofollow" target="_blank">。我们还从算法中排除了第二列。</a></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c6cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们已经为第二阶段做好了准备:重用当前的mice实例作为实际估算器的输入值:</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="0a12" class="ml mm it nk b gy no np l nq nr">imputation &lt;- mice(df_test, method=init$method, <br/>                            predictorMatrix=init$predictorMatrix, <br/>                            maxit=10,<br/>                            m = 5,<br/>                            seed=123)</span></pre><p id="40bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">MICE软件包的一个主要特性是生成几个插补集，我们可以在进一步的ML模型中使用它们作为测试示例。因此，我们将能够选择最合适的设置。在我们的例子中，我们有<code class="fe nt nu nv nk b">m=5</code>，所以算法生成5个估算数据集。你可以在这个包的作者的文章中阅读更多关于生成的数据集的工作和它们在你的ML管道<a class="ae lh" href="https://www.jstatsoft.org/article/view/v045i03" rel="noopener ugc nofollow" target="_blank">中的使用。</a></p><p id="84f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后一步是用估算数据集的具体数字运行算法:</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="0cc2" class="ml mm it nk b gy no np l nq nr">imputed &lt;- complete(imputation, 2)</span></pre><p id="4037" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以在mice实例的<code class="fe nt nu nv nk b">$imp</code>属性中看到所有生成的集合。不过，我选择了第二个生成集:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b71f3bed40176d104a0c19075e32a2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*texqaCTFwW04ABMRnY7TdQ.png"/></div></figure><h2 id="fe3a" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">Pythonic式的</h2><p id="9c1b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在其他编程语言中，Python拥有来自社区的最强支持。数据科学包有特别棒的代码库。你可能会在著名的 <code class="fe nt nu nv nk b"><a class="ae lh" href="https://scikit-learn.org/stable/modules/impute.html" rel="noopener ugc nofollow" target="_blank">scikit-learn</a></code> <a class="ae lh" href="https://scikit-learn.org/stable/modules/impute.html" rel="noopener ugc nofollow" target="_blank">包</a>里找到几种插补算法<a class="ae lh" href="https://scikit-learn.org/stable/modules/impute.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7de4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个软件包也支持多变量插补，但正如文档所述，它仍处于实验阶段。那么，我们来看一个不那么复杂的算法:<code class="fe nt nu nv nk b">SimpleImputer</code>。尽管如此，<code class="fe nt nu nv nk b">sklearn</code>软件包的估算组件有更酷的特性，比如通过K-nearest算法进行估算，所以你可以在文档中自由地<a class="ae lh" href="https://scikit-learn.org/stable/modules/impute.html" rel="noopener ugc nofollow" target="_blank">探索它。</a></p><p id="2e61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将使用相同的玩具示例。当然，一个简单的插补算法并不那么灵活，给我们的预测能力也比较低，但它仍然可以处理这项任务。我将跳过缺失数据检查这一部分，因为它与前面的示例相同。不过，你可以在我的文章<a class="ae lh" rel="noopener" target="_blank" href="/7-idioms-to-acquire-missing-values-every-data-scientist-should-know-2edf4224360c">中找到一些关于Python </a>中丢失数据的好习惯用法。</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="731f" class="ml mm it nk b gy no np l nq nr">from sklearn.impute import <strong class="nk jd">SimpleImputer</strong><br/>impNumeric = <strong class="nk jd">SimpleImputer</strong>(missing_values=np.nan, strategy='mean')<br/>impCategorical = <strong class="nk jd">SimpleImputer</strong>(missing_values=np.nan, <br/>                               strategy='most_frequent')</span></pre><p id="3890" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们为每个数字列选择了<code class="fe nt nu nv nk b">mean</code>策略，为分类列选择了<code class="fe nt nu nv nk b">most_frequent</code>策略。你可以在<code class="fe nt nu nv nk b">SingleImputer</code>的文档页面上阅读更多关于应用策略<a class="ae lh" href="https://scikit-learn.org/stable/modules/impute.html" rel="noopener ugc nofollow" target="_blank">的信息。您可能还注意到，<code class="fe nt nu nv nk b">SingeImputer</code>允许设置我们视为缺失的值。进一步的过程比R中的要短得多:input类和其他<code class="fe nt nu nv nk b">sklearn</code>组件有相同的拟合转换过程。因此，我们再次为每一列设置插补策略(第二列除外):</a></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="ca78" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我们估算的数据集:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/f1d7f955483b5483b695440af54ea3b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*FktYDYJ9PQE-FrUCq_lzjA.png"/></div></figure><p id="0465" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以自由地试验、比较和选择R和Python实现中最好的一个。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="0e8f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">数据清理只是分析过程的开始，但是这个阶段的错误可能会对后续步骤造成灾难性的影响。清理数据，查看我的Github上的文章中的工作代码:</p><div class="ob oc gp gr od oe"><a href="https://github.com/Midvel/medium_jupyter_notes/tree/master/data-imputation" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd jd gy z fp oj fr fs ok fu fw jc bi translated">中级/中等_jupyter_notes</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os lb oe"/></div></div></a></div><p id="6703" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另外，请确保您没有错过我的其他数据清理文章:</p><div class="ob oc gp gr od oe"><a rel="noopener follow" target="_blank" href="/7-idioms-to-acquire-missing-values-every-data-scientist-should-know-2edf4224360c"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd jd gy z fp oj fr fs ok fu fw jc bi translated">每个数据科学家都应该知道的获取缺失值的7个习惯用法</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">你应该把命令自动化</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="ot l op oq or on os lb oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a rel="noopener follow" target="_blank" href="/handle-missing-data-with-r-10-daily-used-idioms-13d849d01690"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd jd gy z fp oj fr fs ok fu fw jc bi translated">用R: 10日常习惯用法处理缺失数据</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">你应该把命令自动化</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="ou l op oq or on os lb oe"/></div></div></a></div></div></div>    
</body>
</html>