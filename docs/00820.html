<html>
<head>
<title>Web App for Pneumonia Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">肺炎检测的Web应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pneumonia-detection-with-keras-and-fastapi-6c10dab657e0?source=collection_archive---------14-----------------------#2020-01-23">https://towardsdatascience.com/pneumonia-detection-with-keras-and-fastapi-6c10dab657e0?source=collection_archive---------14-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f297" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">使用Keras和FastAPI构建一个简单的web应用程序，在x光图像中检测肺炎。</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/af232e1f1f2fa4dad5a6af8d0402da9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdMQfj36bHm8qMA-SJkmSQ.jpeg"/></div></div></figure><p id="029e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">所有使用的Python 3.7代码都可以在<a class="ae lr" href="https://github.com/happilyeverafter95/pneumonia-detection" rel="noopener ugc nofollow" target="_blank">这里</a>找到。本文详细介绍了每个步骤，但是您也可以按照repo的自述文件中的说明启动本地服务器。Github repo还带有预先训练的重量，以防您想跳过训练过程。</p><p id="ad28" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">本文的目标是用一个简单的模型建立框架。有大量的改进可以提高模型的性能！</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="1c27" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">肺炎检测</h1><p id="38d1" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">我们将使用标记的胸部x光图像来训练肺炎检测模型。<a class="ae lr" href="https://www.kaggle.com/paultimothymooney/chest-xray-pneumonia" rel="noopener ugc nofollow" target="_blank">数据集</a>托管在Kaggle上，由5863张x光图像组成。肺炎图像被进一步分类为病毒性或细菌性。忽略这个二级分类，我们的模型将图像分类为<em class="mw">肺炎或正常。</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4028dd7399e922bc666be02ecc2d9292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/0*AQHd0bgpb9tLEIub.png"/></div></figure><h1 id="86ca" class="lz ma it bd mb mc my me mf mg mz mi mj jz na ka ml kc nb kd mn kf nc kg mp mq bi translated">数据集限制</h1><p id="0446" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">使用AI进行疾病诊断的最大挑战之一是缺乏标记数据。数据不容易获得，只有医疗专业人员有资格标记数据。此外，数据收集通常偏向于特定的人口统计数据和用于收集数据的医院设备。</p><p id="35b9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">肺炎数据集中的图像来自广州妇女儿童医疗中心1-5岁的儿科患者。由“两位专家医生”对这些图像的诊断进行分级。</p><p id="62e8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">每个医院使用的影像工具和不同种族、性别和年龄的患者之间的生物因素有很大的差异。有了这些限制，很难理解我们的模型在一般情况下对肺炎的检测有多好。</p><h1 id="8f6d" class="lz ma it bd mb mc my me mf mg mz mi mj jz na ka ml kc nb kd mn kf nc kg mp mq bi translated">属国</h1><h2 id="4b4e" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">码头工人</h2><p id="b449" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">我们可以在没有Docker的情况下启动模型服务器，因此安装Docker是完全可选的。如果你想使用Docker，但还没有安装，请点击<a class="ae lr" href="https://runnable.com/docker/getting-started/" rel="noopener ugc nofollow" target="_blank">这里</a>并按照你正在使用的操作系统的说明进行操作。</p><h2 id="011e" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">Kaggle API</h2><p id="f2f0" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">Kaggle API使得以编程方式/通过命令行界面下载Kaggle数据集变得很容易。</p><ol class=""><li id="52f0" class="np nq it kx b ky kz lb lc le nr li ns lm nt lq nu nv nw nx bi translated">如果您还没有Kaggle帐户，请创建一个</li><li id="63f7" class="np nq it kx b ky ny lb nz le oa li ob lm oc lq nu nv nw nx bi translated">在<code class="fe od oe of og b">kaggle.com/USERNAME/accounts.</code>生成新令牌这将提示您下载一个<code class="fe od oe of og b">kaggle.json</code>文件，其中包含访问API的凭证</li><li id="f8d2" class="np nq it kx b ky ny lb nz le oa li ob lm oc lq nu nv nw nx bi translated">将json文件中的凭证作为环境变量导出。最简单的方法是运行:</li></ol><pre class="kk kl km kn gt oh og oi oj aw ok bi"><span id="e5db" class="nd ma it og b gy ol om l on oo">export KAGGLE_USERNAME = [kaggle username]<br/>export KAGGLE_KEY = [generated_key]</span></pre><p id="c7dd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Github上的代码使用了<a class="ae lr" href="https://direnv.net/" rel="noopener ugc nofollow" target="_blank"> direnv </a>，这是一个用于管理环境变量的shell扩展。如果您喜欢使用<code class="fe od oe of og b">direnv</code>来管理Kaggle凭证，那么填充<code class="fe od oe of og b">.envrc</code>文件并在目录中运行<code class="fe od oe of og b">direnv allow</code>来接收变量。</p><h2 id="41cd" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">安装Python依赖项</h2><p id="8e84" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">运行传统的<code class="fe od oe of og b">pip install -r requirements.txt</code>来下载Python依赖项。</p><h1 id="a031" class="lz ma it bd mb mc my me mf mg mz mi mj jz na ka ml kc nb kd mn kf nc kg mp mq bi translated">训练分类器</h1><h2 id="f9d2" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">记录与打印</h2><p id="cc52" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">您将在代码库中找到几个日志记录实例。日志的使用类似于print语句，因为它们提供信息、警告并有助于调试。在生产环境中，日志记录优于打印，因为日志更易于配置(可以将日志发送到目的地进行存储/监控),并提供堆栈跟踪来确定其来源。</p><h2 id="1f89" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">加载所需的库并设置配置</h2><p id="2bd6" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">用于数据处理和模型构建的代码将包含在一个名为<code class="fe od oe of og b">Train</code>的类中。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="c9f9" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">从Kaggle下载数据</h2><p id="70fd" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">当<code class="fe od oe of og b">force_download</code>参数设置为<em class="mw"> true </em>时(或者没有找到数据文件夹时)，脚本从Kaggle下载并解压数据。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="5c91" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当我们认证Kaggle API时，它会在我们的环境变量中搜索凭证。下一行下载数据集，它从<code class="fe od oe of og b">self.dataset_name</code>(<em class="mw">paultimothymooney/chest-x-ray-pneumonia)</em>中识别数据集，并将其保存到指定路径。</p><p id="4e40" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">数据集名称并不总是直观的。我们可以在Kaggle UI上通过点击右边的三个垂直点然后<code class="fe od oe of og b">Copy API command</code>找到名字。该名称可以从复制的命令中推断出来。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi or"><img src="../Images/fe983cac687b531f96b0086ec0f5d6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4pIebN7TD_i7h21l7cCfXA.png"/></div></div></figure><h2 id="e88a" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">将数据载入内存</h2><p id="ee1a" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">Kaggle数据集下载到以下jpeg图像目录中:</p><p id="cc64" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">├──火车<br/> │ ├──正常<br/> │ ├──肺炎<br/> ├──测试<br/> │ ├──正常<br/> │ ├──肺炎<br/> ├──瓦尔<br/> │ ├──正常<br/> │ ├──肺炎</p><p id="d0d1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将使用Keras的<a class="ae lr" href="https://keras.io/preprocessing/image/" rel="noopener ugc nofollow" target="_blank"> ImageDataGenerator </a>将这些图像加载到内存中。数据生成器对象使得将数据加载到内存变得容易，并且通过批量加载数据克服了RAM的限制。</p><p id="f14d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们为训练、测试和验证集定义了一个单独的生成器。ImageDataGenerators附带了一整套可以应用于图像的预处理步骤。为简单起见，我们将只应用1/255.0的重新标度因子。</p><p id="040e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在生成器中，我们指定每个图像的目标尺寸为64×64像素，颜色模式为<em class="mw">灰度。</em>数据生成器将根据文件夹名推断出类别标签。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="bf7d" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">用计算机视觉表示图像</h2><p id="8104" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">彩色图像通常使用三个通道(红色、绿色和蓝色)来表示，而灰度图像使用一个通道来表示。这些表示存储在嵌套数组中，其中每个值代表特定通道的像素色调。像素值范围从0(黑色)到255(白色)。</p><h2 id="2a5f" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">为什么要除以255？</h2><p id="8aa1" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">将每个像素除以255.0是归一化数据的常用方法。这允许分类器更快地收敛(较小的值=更快的计算)。缩放的另一种标准化技术是<em class="mw">定心。</em>我们可以通过将数据转换成标准的正态分布来集中我们的数据。</p><h2 id="3b9f" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">定义模型</h2><p id="8c7c" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">对于这个应用程序，我们将从头开始训练我们的模型。然而，对于少于6000个图像，这并不理想。图像分类的复杂性与高维特征空间相结合，使得在小数据集上训练的分类器容易过拟合。</p><p id="5edd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，对于小数据集，从预训练模型进行迁移学习是一种非常受欢迎的方法。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="eb2e" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">迁移学习</h2><p id="d139" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">在迁移学习中，我们采用一个复杂的预训练模型(如VGG或ResNet)，该模型从大型数据集学习复杂的标准对象检测。我们冻结(实质上删除)最后几个层，并根据较小的数据集重新训练这些层。这允许复杂模型理解胸部X射线之间的区别。</p><h2 id="d471" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">训练模型</h2><p id="96fe" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">我们使用<code class="fe od oe of og b">fit_generator</code>批量拟合模型。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="5250" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">“部署”模型</h2><p id="8fe2" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">部署步骤将模型权重保存在同一目录中的特定位置。对于一个较大规模的项目，这个位置将是集中的，可能托管在一个云存储服务，如S3。在下一部分中，应用程序将使用这些权重进行推理来恢复模型。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="028b" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">模型性能</h2><p id="7d22" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">第3行显示测试准确率为76%。测试集中有624个x射线图像(390个肺炎，234个正常)。f1的分数是72%。</p><p id="5cf2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">根据记录，我为模型架构创建了一个通用的CNN，所以提高这个性能应该很容易。</p><h1 id="17f8" class="lz ma it bd mb mc my me mf mg mz mi mj jz na ka ml kc nb kd mn kf nc kg mp mq bi translated">部署应用程序</h1><p id="f42d" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">我们将使用FastAPI和Docker来部署这个应用程序。在本节中，我将大量引用我以前关于FastAPI 的一篇文章。</p><h2 id="f9f2" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">创建路由器</h2><p id="c233" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">路由器用于将复杂的API分解成更小的部分。每台路由器都有自己的前缀来标记这种分离。虽然这不是立即需要的，但我决定使用路由器，以防我们的API变得更加复杂。</p><p id="d2c5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">创建一个名为<code class="fe od oe of og b">routers</code>的文件夹来存放我们的路由器。在<code class="fe od oe of og b">routers</code>文件夹中，定义接收x光图像后输出分类结果的API端点。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="d9f4" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">向应用程序发送数据</h2><p id="450f" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">我们不应该要求客户端应用程序发送numpy数组来接收分类输出。对于大多数应用程序来说，这将是非常乏味的。</p><p id="71c4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">方便的是，FastAPI接受<code class="fe od oe of og b">File</code>对象，在这种情况下是图像的二进制表示。使用<code class="fe od oe of og b">PILLOW</code>库，我们可以将字节转换成numpy数组。</p><h2 id="fa2d" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">定义应用程序</h2><p id="0e12" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">在与<code class="fe od oe of og b">routers</code>文件夹相同的目录下，创建另一个脚本<code class="fe od oe of og b">app.py</code>。在此脚本中，定义应用程序并指定路由器。</p><p id="9eb6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们还定义了一个<code class="fe od oe of og b">healthcheck</code>函数。健康检查API返回应用程序的运行状态。当应用程序健康时，我们的健康检查返回文本<em class="mw"> Good to go </em>。注意，这调用了一个<code class="fe od oe of og b">200</code>状态代码。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="8f7c" class="nd ma it bd mb ne nf dn mf ng nh dp mj le ni nj ml li nk nl mn lm nm nn mp no bi translated">在本地运行应用程序</h2><p id="5a5d" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">我们可以通过在命令行中运行以下代码来本地启动我们的应用程序:</p><pre class="kk kl km kn gt oh og oi oj aw ok bi"><span id="7730" class="nd ma it og b gy ol om l on oo">uvicorn --host 0.0.0.0 --port 5000 classifier.app:app</span></pre><p id="08ed" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">日志通知我们服务器正在运行于<a class="ae lr" href="http://0.0.0.0:5000" rel="noopener ugc nofollow" target="_blank"> http://0.0.0.0:5000 </a></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi os"><img src="../Images/8e0a64d6c9a32ac57be0a64979e223f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*XM5CIZtt3z7sHjdtHFiRuA.png"/></div></figure><p id="06be" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以通过编程向服务器发送POST请求，但这需要将图像的字节再现作为参数传递。</p><p id="443b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">方便的是，我们可以去<a class="ae lr" href="http://0.0.0.0:5000/docs" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0:5000/docs</a>获得更友好的UI。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/4e6beb1bf5c7fbb4c2186983d9171692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*hdEpvpAqsoPPnyZBz1DQ4w.png"/></div></figure><p id="0e3c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">点击绿色的POST按钮，它会把你带到这个页面。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ou"><img src="../Images/850fb652f489d1044ba265a68a5c3ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IwrMpYVLWZwivsGiZQYFNQ.png"/></div></div></figure><p id="2e67" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在右侧，单击尝试一下。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ou"><img src="../Images/43bdb0ecc2623089d08170138ee61c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YA5Dol8Smjh0EHYerrjLAw.png"/></div></div></figure><p id="8b1a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这将提示您上传图像。在Github repo的<a class="ae lr" href="https://github.com/happilyeverafter95/pneumonia-detection/tree/master/fixtures" rel="noopener ugc nofollow" target="_blank"> fixtures文件夹</a>中，您可以找到我从训练集中提取的几张图片(不用于判断模型性能！).该名称表示类别。</p><p id="268a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我上传了<code class="fe od oe of og b">pneumonia_1.jpeg</code>，收到了以下结果:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ov"><img src="../Images/9e1b03d1feb1b3f7eb1679e46c9b7ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*hBFYgKG-D6eSeWjO1l8poQ.png"/></div></div></figure><p id="16e0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">很好，我们为肺炎检测构建了一个漂亮的本地应用程序！</strong></p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="7f73" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">repo更进一步，添加了一个<code class="fe od oe of og b">Dockerfile</code>来用Docker构建应用程序。Dockers将构建和运行应用程序所需的一切封装在一个地方，使得通过公共URL共享和部署变得更加容易。</p><p id="0600" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您克隆了repo，您可以按照<a class="ae lr" href="https://github.com/happilyeverafter95/pneumonia-detection" rel="noopener ugc nofollow" target="_blank"> README </a>中的说明构建并运行Docker容器。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="a232" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">感谢您的阅读！</h1><p id="3246" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">如果你喜欢这篇文章，可以看看我关于数据科学、数学和编程的其他文章。<a class="ae lr" href="https://medium.com/@mandygu" rel="noopener">请通过媒体</a>关注我的最新消息。😃</p><p id="c4c4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">作为一个业余爱好项目，我还在<a class="ae lr" href="http://www.dscrashcourse.com/" rel="noopener ugc nofollow" target="_blank">www.dscrashcourse.com</a>建立了一套全面的<strong class="kx iu">免费</strong>数据科学课程和练习题。</p><p id="fb9b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你想支持我的写作，下次你报名参加Coursera课程时，可以考虑使用我的<a class="ae lr" href="https://click.linksynergy.com/fs-bin/click?id=J2RDo*Rlzkk&amp;offerid=759505.198&amp;type=3&amp;subid=0" rel="noopener ugc nofollow" target="_blank">会员链接</a>。完全公开—我从每一次注册中获得佣金，但不会对您产生额外费用。</p><p id="99bf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">再次感谢您的阅读！📕</p></div></div>    
</body>
</html>