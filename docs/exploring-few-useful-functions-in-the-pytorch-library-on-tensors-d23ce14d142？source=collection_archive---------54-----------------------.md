# 探索 Pytorch 库中几个有用的张量函数

> 原文：<https://towardsdatascience.com/exploring-few-useful-functions-in-the-pytorch-library-on-tensors-d23ce14d142?source=collection_archive---------54----------------------->

## 通过探索 Pytorch 的库开始使用 py torch

![](img/279b8aacbc7b2aa99e5a6b3f77f892ef.png)

马库斯·斯皮斯克在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

D 由脸书人工智能研究实验室开发的 ***PyTorch*** 如今被广泛用作深度学习框架，原因很多，从小规模的机器学习原型到生产层面的应用。

> “Pytorch 是一个开源的机器学习框架，它加速了从研究原型到生产部署的道路”，官方[网站](https://pytorch.org/)上的描述说。

这篇博客故事是由 [Jovian.ml](https://jovian.ml/) 与 [freecodecamp](https://www.freecodecamp.org/) 合作提供的关于 Pytorch 深度学习的 6 周课程的一部分。#零托甘人

在本教程中，我们将深入探讨 ***Pytorch*** 库中关于张量的 5 个有用函数。让我们开始吧。

首先:**进口 Pytorch**

```
import torch
```

# torch.rand():

该函数返回一个张量，其中填充了区间[0，1]上均匀分布的随机数。它的一些参数如下所示:

> size(int)-定义输出张量形状的整数序列。可以是可变数量的参数或集合，如列表或元组。
> 
> dtype (torch.dtype，可选)-返回张量的所需数据类型。默认值:如果没有，则使用全局默认值(请参见 torch.set_default_tensor_type())。
> 
> requires_grad (bool，可选)-如果自动签名应该记录对返回张量的操作。默认值:False。

让我们看看这个相当简单的函数的几个例子。

工作示例-1

我们可以观察到，我们得到了区间[0，1]中 9 个元素的张量向量。

工作示例-2

这里，我们得到一个形状为 3x4 的张量，其元素在区间[0，1]中

> 何时使用该功能？
> 
> 当我们希望以随机值的张量作为[0，1]范围内的元素时，可以使用这个函数。

# torch.mean():

torch.mean 函数返回张量的平均值。下面列出了它的一些参数。

> **输入**(张量)——输入张量。
> 
> **dim** (int 或 python 的 tuple:ints)-要减少的一个或多个维度。
> 
> **keep dim**(bool)——输出张量是否保留 dim。
> 
> **out** (张量，可选)—输出张量。

现在，让我们看几个使用这个非常方便的函数的例子。

在单元格中，通过对张量向量应用 torch.mean()，我们可以观察到张量向量中的所有数字相加并除以元素的个数。

让我们用这个函数来解决一些复杂的问题。

有时我们可能不想在整个张量上计算平均值，而是在行或列上计算。

使用 torch.mean()的“dim”参数

在上述单元格中，torch.mean()应用于(3，5)张量，并带有一个名为“dim”的附加参数。此参数指定应该对行(如果 dim=0，则为每一列)或列(如果 dim=1，则为每一行)取平均值

> ***有人曾经说过，“当你知道如何打破一个东西，那么你就真正知道如何用好它。”现在，让我们试着打破这个函数，我的意思是让我们理解这个函数什么时候不能像预期的那样工作。***

打破火炬

在单元格中，我们得到的运行时误差”只能计算浮点类型的平均值。却得到了布尔。”这意味着 torch.mean()只能应用于 floating 类型，其他所有情况下都会失败。

不知道这是 bug 还是特性。我会把它留给你去想象。

> 何时使用该功能？
> 
> 当有人想要计算张量的平均值时，例如当我们想要使用均方根误差(RMSE)作为损失函数时，可以使用该函数。

# torch.view(形状):

PyTorch 有趣的一点是，它允许一个张量成为一个现有张量的视图。视图张量与其基础张量共享相同的底层数据。视图避免了显式的数据复制，因此允许我们进行快速且节省内存的整形、切片和基于元素的操作。

***该函数返回一个新的张量，其数据与自张量相同，但形状不同。***

正如我们可以观察到的，我们得到了给定张量的一个不同大小的副本，我们可以对它进行运算。

这是使用 view 函数的另一个例子。这里的-1 是从其他维度推断出来的。

**看看这个功能什么时候不行。**

这里，我们得到一个错误，因为形状应该匹配输入张量的大小。

> torch.view 的灵感来源于 numpy . ndarray . shape()或 numpy.reshape()。它创建了张量的新视图，只要新形状与原始张量的形状兼容。
> 
> torch.reshape()函数将返回一个视图，与使用 torch 完全相同。Tensor.view()只要新的形状与原始张量的形状兼容。否则，它将返回一个副本。
> 
> 然而，torch.reshape()的注释警告说:
> 
> 连续输入和具有兼容步幅的输入可以在不复制的情况下被重新整形，但是不应该依赖于复制和查看行为。

# torch.linspace():

个人感觉这个功能以后会很好用。

该函数返回“开始”和“结束”参数之间等距点的一维张量向量。点数是“步数”参数。它的一些重要参数是:

> start(float)-点集的起始值
> 
> 结束(浮点)-点集的结束值
> 
> steps(int)-开始和结束之间的采样点数。默认值:100。
> 
> out(张量，可选)-输出张量。
> 
> dtype (torch.dtype，可选)-返回张量的所需数据类型。默认值:如果没有，则使用全局默认值(请参见 torch.set_default_tensor_type())。
> 
> requires_grad (bool，可选)—如果**亲笔签名的**应该记录对返回张量的操作。默认值:False。

在单元格中，开始=10，结束=4，步数=25。因此，我们得到 25 个等间距的点，在 10 和 4 之间(包括 10 和 4)。默认情况下， **PyTorch** 给我们的元素是浮点。

这类似于上面的例子，但是这里我们得到的是类型为 **int32** 的元素。

**现在我们来试着破函数。**

torch.linspace()的“out”参数，它指定要由 torch.linspace 函数返回的值替换的所需张量。运行时错误“dtype Int 不匹配 dtype of out 参数(Float)”告诉我们，要使用“out”参数，两种类型的张量应该相同。

> 何时使用该功能？
> 
> 当我们知道真实数据位于特定区间时，可以使用 torch.linspace 创建张量形式的数据。

# torch.trace():

该函数返回输入二维矩阵的主对角线(从左上到右下)的元素之和。它唯一需要的参数是一个输入 2D 张量。

正如我们所见，该函数接受输入的 2D 张量，并计算对角线上元素的总和。

正如我们所见，该函数接受输入的 2D 张量，并计算对角线上元素的总和。

这个函数只需要一个 2D 矩阵，给它任何东西都会破坏它。这里，我们给出了一个 1D 数组。

虽然现在还不可用，但是这个函数的一个简单的新特性是允许我们得到任意对角线元素的和。但那不会被称为矩阵的“迹”。

> 何时使用该功能？
> 
> 单独来看，跟踪操作并不有趣，但是它提供了一种更简单的符号，并且它被用作其他关键矩阵操作中的一个元素。

# 结论:

这里，我们展示了一些与 PyTorch 张量的一些核心概念相关的基本函数，如:

*   如何生成元素在[0，1]范围内的随机张量？
*   如何计算张量及其不同变量的平均值？
*   如何为给定的张量创建不同的**视图**。
*   如何创建一个张量，其元素在点与点之间等距。
*   如何计算 2D 张量的轨迹？

我希望你喜欢这个博客。感谢您的阅读，我希望这对您有所帮助。

参考资料:

*   链接到我的笔记本:[https://jovian.ml/shivasankeerth/01-tensor-operations](https://jovian.ml/shivasankeerth/01-tensor-operations)
*   链接开始 py torch ZerotoGANs by freeCodeCamp:[https://www . freeCodeCamp . org/news/free-deep-learning-with-py torch-live-course/](https://www.freecodecamp.org/news/free-deep-learning-with-pytorch-live-course/)
*   [Pytorch 文档](https://pytorch.org/docs/stable/index.html)