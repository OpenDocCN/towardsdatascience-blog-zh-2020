<html>
<head>
<title>Graph Theory | Introduction to Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图论|树的介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-theory-introduction-to-trees-a34ab267fc28?source=collection_archive---------45-----------------------#2020-05-26">https://towardsdatascience.com/graph-theory-introduction-to-trees-a34ab267fc28?source=collection_archive---------45-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2169" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/graph-theory-simplified" rel="noopener" target="_blank">图论简化版</a></h2><div class=""/><blockquote class="jz ka kb"><p id="f7d4" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">大家都怎么了？这是我的全新系列<a class="ae lb" href="https://medium.com/@kelvinjose/graph-theory-go-hero-1b5917da4fc1" rel="noopener"> <strong class="kf jd">图论的最新补充:Go Hero </strong> </a>在这里我们深入讨论图和相关算法。查看一下，快速浏览一下。这里我们将简单介绍一下树，它是一种图形。所以，我们开始吧。</p></blockquote><p id="c480" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated"><strong class="kf jd">什么是树</strong>？</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/a30ee071ac53c45934fc33e5bc25fce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lz2keZBvTCrRns-OS0Be9Q.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><p id="b08e" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">我们上面有两张图表，你能找出不一样的吗？</p><p id="4a58" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">正确，第四个脱颖而出。但是为什么呢？</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/81142898644e49e45c71790b68471a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*slYdp-34S3XohYDohYSodw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><p id="102d" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">因为<strong class="kf jd">树是没有圈的无向图</strong>。要记住的关键是树里面不允许有循环。你能找到一个打破规则的，对吗？干得好。</p><p id="8600" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">然而，还有另一种简单的方法，我们可以用它来判断给定的图是否是树。所有的树都有<strong class="kf jd"> N - 1 条边，</strong>其中 N 是节点的数量。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lv"><img src="../Images/31e21d7ee98f32cd5c502d85e6215957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29CZ_RNJl_05PdPDCLqcFg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><p id="6b77" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">我们的图表中有三个符合规则，对吗？但最后一个没有。</p><h2 id="9702" class="lw lx it bd ly lz ma dn mb mc md dp me lc mf mg mh ld mi mj mk le ml mm mn iz bi translated">野外的树木</h2><p id="fcb2" class="pw-post-body-paragraph kc kd it kf b kg mo ki kj kk mp km kn lc mq kq kr ld mr ku kv le ms ky kz la im bi translated">让我们来看几个我们遇到树的应用的场合。</p><ul class=""><li id="9619" class="mt mu it kf b kg kh kk kl lc mv ld mw le mx la my mz na nb bi translated"><strong class="kf jd">文件结构</strong></li></ul><p id="ec32" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">计算机文件系统包含目录、子目录和文件，它本质上是一棵树。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nc"><img src="../Images/cd030f711a4001ee1d1ae3ecdd33615c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djxmc3WdwiDisl5XLIMwEw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><ul class=""><li id="f5f8" class="mt mu it kf b kg kh kk kl lc mv ld mw le mx la my mz na nb bi translated"><strong class="kf jd">公司层级</strong></li></ul><p id="41d9" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">公司层级是指公司内部根据权力、地位和工作职能对个人进行的安排和组织。它划分了权力和责任，根据员工、部门、分部和其他管理人员在层级中的位置指定他们的领导。一个完整的公司应该有一个树状结构。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/46ff55c93e2d3705f4d55157aaa0c960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBUyrODpfv_HV87NkWJ9Xw.png"/></div></figure><ul class=""><li id="6650" class="mt mu it kf b kg kh kk kl lc mv ld mw le mx la my mz na nb bi translated"><strong class="kf jd">评估数学表达式</strong></li></ul><p id="96f9" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">Tress 可用于将数学表达式和源代码分解成抽象格式，以便以正式的方式对它们进行评估。下面是一个表达式及其相应的树表示。</p><blockquote class="jz ka kb"><p id="0432" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf jd"> (a * b) + (c - d) </strong></p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/0716009b40951ca7ef708032974f0ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*X_xUuzNrXP635W3_m5sIQA.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><ul class=""><li id="460d" class="mt mu it kf b kg kh kk kl lc mv ld mw le mx la my mz na nb bi translated"><strong class="kf jd"> Web 文档对象模型(DOM) </strong></li></ul><p id="b558" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">我们访问的每个网页都是由某些标签组成的，如、<h1>、<title>等。DOM 是一种将 XML 或 HTML 文档视为树结构的接口，其中每个节点都是表示文档一部分的对象。下面给出了一个这样的树。</title></h1></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/27acce007356254d0132a96bc484b19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*iDIMbHOKiqJWdOunSqOEnw.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">安东尼通过<a class="ae lb" href="https://pixabay.com" rel="noopener ugc nofollow" target="_blank"> pixabay </a>拍摄的照片</p></figure><p id="06e4" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">树木还有更多应用，</p><ul class=""><li id="16da" class="mt mu it kf b kg kh kk kl lc mv ld mw le mx la my mz na nb bi translated">决策树</li><li id="a1ec" class="mt mu it kf b kg ng kk nh lc ni ld nj le nk la my mz na nb bi translated">家谱</li><li id="e456" class="mt mu it kf b kg ng kk nh lc ni ld nj le nk la my mz na nb bi translated">分类学</li><li id="5267" class="mt mu it kf b kg ng kk nh lc ni ld nj le nk la my mz na nb bi translated">图论树</li><li id="8862" class="mt mu it kf b kg ng kk nh lc ni ld nj le nk la my mz na nb bi translated">文本分析树</li><li id="436b" class="mt mu it kf b kg ng kk nh lc ni ld nj le nk la my mz na nb bi translated">社会等级</li><li id="5c97" class="mt mu it kf b kg ng kk nh lc ni ld nj le nk la my mz na nb bi translated">概率树</li></ul><h2 id="3228" class="lw lx it bd ly lz ma dn mb mc md dp me lc mf mg mh ld mi mj mk le ml mm mn iz bi translated">存储无向树</h2><p id="1ad5" class="pw-post-body-paragraph kc kd it kf b kg mo ki kj kk mp km kn lc mq kq kr ld mr ku kv le ms ky kz la im bi translated">我们应该从给树中的每个节点分配编号开始，从<strong class="kf jd"> 0 </strong>到<strong class="kf jd"> n - 1 </strong>，其中 n 是节点总数。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/48e7dbae082992f736c09b47491aa856.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*CWIKV_Qq_lnE3Ufo7SMHAg.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><p id="ed92" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">存储这棵树最简单的方法是使用一个<strong class="kf jd">边列表</strong>，其中列表中的每一对表示两个节点之间的一条边。对于上面的树表示，相应的边列表将是，</p><blockquote class="jz ka kb"><p id="8be5" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf jd"> <em class="it"> [(0，2)，(2，3)，(2，4)，(2，1)，(1，5)，(5，6)，(5，7)，(7，8)] </em> </strong></p></blockquote><p id="16c6" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">迭代边对非常快速和容易，但不会存储任何邻域信息。由于这个缺点，我们宁愿使用另一种叫做<strong class="kf jd">邻接表的表示法。</strong>这是一张从一个节点到其邻居的地图。上面给定的相同的树可以转换成如下的邻接表，</p><blockquote class="jz ka kb"><p id="752c" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf jd"><em class="it">【0】→【2】</em></strong></p><p id="d73e" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf jd"><em class="it">【1】→【2，5】</em></strong></p><p id="0ecd" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf jd"><em class="it">【2】→【0，1，3，4】</em></strong></p><p id="e502" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf jd"><em class="it">【3】→【2】</em></strong></p><p id="e911" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf jd"><em class="it">【4】→【2】</em></strong></p><p id="ca13" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf jd"><em class="it">【5】→【1，6，7】</em></strong></p><p id="ebb0" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf jd"><em class="it">【6】→【5】</em></strong></p><p id="4553" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf jd"><em class="it">【7】→【5，8】</em></strong></p><p id="6709" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf jd"><em class="it">【8】→【7】</em></strong></p></blockquote><p id="3c72" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">除了这两种方法，我们还有另外一个解决这个问题的方法。我们可以使用<strong class="kf jd">邻接矩阵</strong>来显示两个节点之间是否存在边。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/b126327caded1bf95e1b05d767842cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*A07g6wdpuoP3M2D6osgx4Q.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><p id="7e4d" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">如果存在从节点<strong class="kf jd"> i </strong>到<strong class="kf jd">j</strong>else 0 的边，我们用 1 填充邻接矩阵的【T50(I，j)】单元。例如，如果在节点 5 和 7 之间存在边，那么(5，7)将是 1。</p><p id="18d6" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">实际上，将树作为邻接矩阵很麻烦，因为大多数节点之间可能有边，也可能没有边，所以大多数单元会很稀疏，足以完全不占用内存。</p><h2 id="3e24" class="lw lx it bd ly lz ma dn mb mc md dp me lc mf mg mh ld mi mj mk le ml mm mn iz bi translated">有根的树</h2><p id="9479" class="pw-post-body-paragraph kc kd it kf b kg mo ki kj kk mp km kn lc mq kq kr ld mr ku kv le ms ky kz la im bi translated">有根树会有一个特殊的节点被指定为<strong class="kf jd">根节点</strong>，因此命名为有根树。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nn"><img src="../Images/1d754db974f525836b60e1726fcf53c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E14vR57ACGhFA2DbSr63RA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图片 bu 作者</p></figure><p id="2d96" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">这里，橙色的节点被指定为根。任一边缘都可能靠近根部或远离根部。每棵有根的树都只有一个根。一些递归算法使用有根树来跟踪执行流程。</p><h2 id="dca1" class="lw lx it bd ly lz ma dn mb mc md dp me lc mf mg mh ld mi mj mk le ml mm mn iz bi translated">二叉树</h2><p id="558d" class="pw-post-body-paragraph kc kd it kf b kg mo ki kj kk mp km kn lc mq kq kr ld mr ku kv le ms ky kz la im bi translated">我们永远不能离开这个会议没有提到二叉树。我们称之为二叉树或简称为 B 树是因为树中的每个节点总共最多有 2 个子节点。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi no"><img src="../Images/52e862ea623b7f6b64a0bc7ef1b3f75f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5aY-WH7fwv3HzOskMkDskQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><p id="0bac" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">在现实世界中，B 树很少存在。</p><h2 id="a338" class="lw lx it bd ly lz ma dn mb mc md dp me lc mf mg mh ld mi mj mk le ml mm mn iz bi translated">二叉查找树</h2><p id="fbc2" class="pw-post-body-paragraph kc kd it kf b kg mo ki kj kk mp km kn lc mq kq kr ld mr ku kv le ms ky kz la im bi translated">我们称一棵树为二叉查找树当且仅当它满足 BST 不变量，BST 不变量定义为，对于每个节点 x，左子树中的值严格小于 x 的值，右子树中的值大于 x 的值。二叉查找树在搜索问题时非常有用。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi np"><img src="../Images/70b8659f38494291134c7606ec7316ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oyoZB8GIDT2U8UvnQ0VKzA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><p id="219c" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">上面的实现禁止我们的树有重复的条目。所以树中的每个节点都会感知到一个独特的元素。</p><h2 id="ba62" class="lw lx it bd ly lz ma dn mb mc md dp me lc mf mg mh ld mi mj mk le ml mm mn iz bi translated"><strong class="ak">存储有根的树</strong></h2><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a273e8624d3fa846f9e14d99bfa6bf23.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*_oi8Yd_XmDaSYz9zz8VucA.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><p id="5b22" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">有根树最自然地以自顶向下的方式递归定义。实际上，我们总是维护一个指向根节点的指针，这样我们就可以访问树及其内容。此外，每个节点都可以访问其子节点。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/35ec0ae5be265d02a317da00040d29c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*2J40iMoLqSA5E7TGDowZrw.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><p id="0fa7" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">这里，橙色的节点是当前引用节点，所有绿色的节点是子节点。注意，子节点是叶子，它们没有任何特定的子节点。</p><p id="2fb0" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">如果我们的树是一棵<strong class="kf jd">二叉树</strong>，我们可以将它存储在一个扁平数组中。在这种表示中，每个节点都有一个基于它在树中的位置而分配的索引位置。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/c025b820105192f6f5e6d8ca00ac49dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*W0vYlPdK303n3HyDomXUqA.png"/></div></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/3ec4dd0e0d8beaa812f601e31219842e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*BjE4po06cGwzTLmtcLnoaQ.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><p id="aa3f" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">我们从值为 9 的根节点开始，它存储在索引 0 中。接下来，我们有一个值为 8 的节点，它在索引 1 中，依此类推。如果你仔细观察数组，你可以看到一些位置用<strong class="kf jd"> null、</strong> why 填充，因为我们在树中没有任何特定位置的值。根节点将总是在索引 0 中，并且相对于位置 I 访问当前节点 I 的子节点。</p><p id="7fe3" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">例如，假设我是当前节点的索引，那么</p><blockquote class="jz ka kb"><p id="e60f" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">左侧节点:<strong class="kf jd"> 2 * i + 1 </strong></p><p id="56c9" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">右节点:<strong class="kf jd"> 2 * i + 2 </strong></p></blockquote><p id="00c8" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">反过来，一个节点的父节点应该是，</p><blockquote class="jz ka kb"><p id="6372" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf jd">楼层((i - 1)/2) </strong></p></blockquote><h2 id="9d91" class="lw lx it bd ly lz ma dn mb mc md dp me lc mf mg mh ld mi mj mk le ml mm mn iz bi translated">结论</h2><p id="af09" class="pw-post-body-paragraph kc kd it kf b kg mo ki kj kk mp km kn lc mq kq kr ld mr ku kv le ms ky kz la im bi translated">今天我们发现了什么是树和它的不同种类。这篇文章的核心思想是让你了解数据结构和它在现实世界中的应用。我们将在本系列的下一篇文章中讨论更多的算法。在那之前，敬请期待。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nu"><img src="../Images/12a42ea150b669878b350084c16af78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgzROdVHD1jDW91xwO8mVA.png"/></div></div></figure></div></div>    
</body>
</html>