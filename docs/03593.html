<html>
<head>
<title>15 Git Commands To Master Before Your Very First Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在你开始第一个项目之前，要掌握15个Git命令</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/15-git-commands-you-should-learn-before-your-very-first-project-f8eebb8dc6e9?source=collection_archive---------10-----------------------#2020-04-05">https://towardsdatascience.com/15-git-commands-you-should-learn-before-your-very-first-project-f8eebb8dc6e9?source=collection_archive---------10-----------------------#2020-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="209f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您需要掌握的唯一Git教程是在命令行控制版本，并加速您的开发职业生涯</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/404ac5e39efeffadbab986a441cc2c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ykaS01WMQ-pcs2Vw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@synkevych?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗曼·辛克维奇</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="c27b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名<strong class="lb iu"> web开发人员</strong>，你刚刚开始你的第一个项目，并且希望跟踪你的工作目录中的大量变化？你最终被选为<strong class="lb iu">一名初级数据工程师</strong>参加面试，并对版本控制话题感到有些生疏？或者您只是从事<strong class="lb iu">数据科学</strong>的工作，想要学习更多关于Git和命令行的知识，以便向您的团队展示您根本不使用任何GUI也可以获得同样的结果？</p><p id="9c22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你回答“是的，我在这里！”至少添加到上面的一个配置文件中，那么本教程肯定可以帮助你通过命令行学习更多关于版本控制的知识，而且会很快完成！</p><p id="c3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和许多其他数据分析师和BI开发人员一样，我通过<strong class="lb iu"> GitHub GUI </strong>了解了版本控制。当时，我的公司正在使用<a class="ae ky" href="https://looker.com/platform/overview" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Looker </strong> </a>作为可视化工具，它可以配置一个方便的<a class="ae ky" href="https://docs.looker.com/data-modeling/getting-started/version-control-and-deploying-changes" rel="noopener ugc nofollow" target="_blank"> Git集成，以便在开发模式下管理文件版本</a>。</p><p id="f1de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在提交和部署变更时，每一步在视觉上都非常吸引人和用户友好，直到有一天一位数据工程师告诉我:“版本控制？我总是在我的终端上使用相同的4–5个命令，工作完成了！我很少访问用户界面”。</p><p id="0a6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后他又打了一个字，而我则羡慕地盯着他的笔记本电脑。那时我意识到下一步应该是学习命令行以及如何用Git进行版本控制。</p><p id="fbc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程的剩余部分，你会发现我在项目中使用最多的15个命令。</p><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/3-nanodegrees-you-should-consider-to-advance-your-data-engineering-career-in-2021-baf597debc72"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">3纳米学位你应该考虑在2021年推进你的数据工程职业</h2><div class="mj l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp ks mc"/></div></div></a></div><h2 id="7cf0" class="mq mr it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">首先，什么是Git？</h2><p id="ffda" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><a class="ae ky" href="https://git-scm.com/docs/git" rel="noopener ugc nofollow" target="_blank"> Git是一个用于版本控制的命令行工具</a>，只需在shell中输入Git即可访问。第一步是创建一个新目录并初始化一个存储库:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="734d" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">mkdir medium_git</strong><br/>$ <strong class="ly iu">cd medium_git/</strong></span></pre><p id="7706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经创建了一个<em class="nw"> medium_git </em>文件夹，我将在本教程的剩余部分使用它，它将包括下面讨论的所有命令的列表。可以在我的<a class="ae ky" href="https://github.com/anbento0490/code_tutorials" rel="noopener ugc nofollow" target="_blank"> GitHub </a>的code_tutorials资源库中找到。</p><h2 id="d75a" class="mq mr it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">Git命令解释</h2><p id="588f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><strong class="lb iu"> 1。<em class="nw"> </em> git init → </strong>该命令初始化<em class="nw"> medium_git </em>文件夹中的存储库，这意味着从现在开始，它将跟踪文件夹中文件的多个版本。初始化Git存储库还会创建一个名为<strong class="lb iu">的目录。存储库文件夹中的git </strong>。带有句点前缀的文件和文件夹。)通常是私有的，当您列出文件夹中的文件时，默认情况下不会显示，除非使用ls -a命令:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="0007" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git init</strong></span><span id="7114" class="mq mr it ly b gy nx nt l nu nv">Initialized empty Git repository in /Users/antonellobenedetto/Documents/medium_git/.git/</span><span id="5ab2" class="mq mr it ly b gy nx nt l nu nv">$ <strong class="ly iu">ls -a</strong></span><span id="bb2b" class="mq mr it ly b gy nx nt l nu nv">.  ..  .git </span></pre><p id="a85e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，让我们创建一个名为<em class="nw"> git_commands、</em>的markdown文件(<code class="fe lv lw lx ly b">.md</code>，它只包含对<code class="fe lv lw lx ly b">git init </code>功能的简要描述，并将它保存在<em class="nw"> medium_git </em>存储库中。</p><p id="71fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<strong class="lb iu"> git添加</strong> →在git中，文件可以处于以下三种状态之一:<strong class="lb iu">已修改</strong>、<strong class="lb iu">已登台</strong>、<strong class="lb iu">已提交</strong>。如果您准备提交您修改过的文件，您可以使用<code class="fe lv lw lx ly b">git add [file name] </code>命令将它们添加到暂存区。然后，暂存文件被标记为包含在下一次提交中，但尚未提交:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="6b23" class="mq mr it ly b gy ns nt l nu nv">$ cat git_commands.md</span><span id="102f" class="mq mr it ly b gy nx nt l nu nv">1. git init &lt;-- initializes a repository inside the folder</span><span id="cc67" class="mq mr it ly b gy nx nt l nu nv">$ git add git_commands.md</span></pre><p id="77bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">git add .</code>(或者使用通配符<code class="fe lv lw lx ly b">git add *</code>)可以获得相同的结果。唯一的区别是，通过这种方式，存储库中的所有文件将同时转移。</p><p id="396f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。git配置user.name/user.email<em class="nw">→</em></strong>在你第一次提交之前，告诉git你是谁是个好习惯。当您在团队中工作时，这一点尤为重要，这样每个成员都可以识别出是谁做出了某项承诺:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="eb5c" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git config --global user.name ‘anbento’</strong><br/>$ <strong class="ly iu">git config --global user.email ‘anbento@myemail.com’</strong></span></pre><p id="8253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望检查您的配置设置，请键入<code class="fe lv lw lx ly b">git config -l</code>。</p><p id="373c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 4。git commit-m ' your message '</strong>→commit在某个时间点将文件的快照存储在存储库中。通过构建这些快照的历史，您可以回滚到更早的时间点。<strong class="lb iu"> -m </strong>标志表示您正在添加一条消息，并且它后面的引号中的文本就是提交消息本身。习惯上，提交消息应该提供一些信息，所以如果我们必须回卷或合并代码，那么很明显已经做了哪些更改以及何时做的:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="639e" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git commit -m ‘Adding git_commands.md file’</strong></span><span id="f9a4" class="mq mr it ly b gy nx nt l nu nv">[master (root-commit) 815d087] Adding git_commands.md file</span><span id="e0d3" class="mq mr it ly b gy nx nt l nu nv">1 file changed, 3 insertions(+)</span><span id="f527" class="mq mr it ly b gy nx nt l nu nv">create mode 100644 git_commands.md</span></pre><p id="594f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 5。git log </strong> →您可以使用这个命令调出存储库的提交历史。每个提交都分配有一个40字符长的唯一ID或散列。<strong class="lb iu">提交散列是永久的</strong>，这意味着<strong class="lb iu"> </strong> Git保存它们，并将它们包含在本地和远程repos之间的传输中。另请注意，提交作者的姓名和电子邮件如何显示在每个提交历史记录下:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="d78a" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git log</strong></span><span id="a331" class="mq mr it ly b gy nx nt l nu nv">commit 815d087f132288112b7e427617be0408e6db4974 (<strong class="ly iu">HEAD -&gt; master</strong>)</span><span id="052e" class="mq mr it ly b gy nx nt l nu nv">Author: anbento &lt;anbento@myemail.com&gt;</span><span id="7633" class="mq mr it ly b gy nx nt l nu nv">Date: Sat Apr 4 08:19:16 2020 +0100</span><span id="778b" class="mq mr it ly b gy nx nt l nu nv">Adding git_commands.md file</span></pre><p id="74d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 6。git remote add[remote name][remote URL]</strong>→有时，您可能希望将您的更改推送到(例如)GitHub上的一个存储库，以便您可以使用其他设备访问您的完整项目历史，或者只是与您的团队协作。为了做到这一点，您首先必须创建存储库本身，然后在终端中运行命令:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="fdaa" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git remote add origin </strong><a class="ae ky" href="https://github.com/anbento0490/code_tutorials.git" rel="noopener ugc nofollow" target="_blank">https://github.com/anbento0490/code_tutorials.git</a></span><span id="1880" class="mq mr it ly b gy nx nt l nu nv">$ <strong class="ly iu">git remote -v</strong></span><span id="4ea0" class="mq mr it ly b gy nx nt l nu nv">origin https://github.com/anbento0490/code_tutorials.git (fetch)<br/>origin https://github.com/anbento0490/code_tutorials.git (push)</span></pre><p id="930f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，首先我在我的GitHub帐户上创建了<strong class="lb iu"><em class="nw">code _ tutorials</em></strong>资源库，然后我将它作为remote添加到<strong class="lb iu"> <em class="nw"> origin </em> </strong>别名下。请记住"<strong class="lb iu"><em class="nw"/></strong>只是一个约定俗成的名称，但是如果您愿意，您可以随意给遥控器起不同的名字。通过指定<strong class="lb iu"> -v </strong>选项，您可以检索分配给每个别名的完整远程url。如果您犯了一个错误，希望移除遥控器，只需运行<code class="fe lv lw lx ly b">git remote remove origin </code>命令。</p><p id="f2ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">7。git push[remote name][branch name]→一旦您对repo的本地版本进行了更改，您就可以将它们推送到远程repo，这样您的项目及其整个提交历史就可以安全地存储在云中。这意味着，即使你的笔记本电脑崩溃或被盗，你的作品也不会丢失，并且可以从你的GitHub帐户中找回。为此，您需要<strong class="lb iu">将主分支推至远程<em class="nw">【原点】</em>回购</strong>:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="cdda" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git push origin master</strong></span><span id="1e6b" class="mq mr it ly b gy nx nt l nu nv">Counting objects: 3, done.<br/>Delta compression using up to 4 threads.<br/>Compressing objects: 100% (2/2), done.<br/>Writing objects: 100% (3/3), 282 bytes | 282.00 KiB/s, done.<br/>Total 3 (delta 0), reused 0 (delta 0)To <a class="ae ky" href="https://github.com/anbento0490/code_tutorials.git" rel="noopener ugc nofollow" target="_blank">https://github.com/anbento0490/code_tutorials.git</a><br/>* [new branch] master -&gt; master</span></pre><p id="9354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您这样做了，原来只在本地工作目录中可用的文件将被上传到您的远程repo中，以及关于您的提交的信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/f7076c755c8bc38c6728aee7600f806f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z31Oo5K0iS6jGVtAk83tlQ.png"/></div></div></figure><p id="1eba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 8。git clone[repository URL][folder name]→</strong>如果您或您的同事希望在另一个设备上下载您的项目文件夹，您可以通过在本地克隆远程存储库来实现。在我的例子中，我回到了主目录，并克隆了存储库，指定了原来的名称<em class="nw"> medium_git </em>:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="ef66" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git clone </strong><a class="ae ky" href="https://github.com/anbento0490/code_tutorials.git" rel="noopener ugc nofollow" target="_blank"><strong class="ly iu">https://github.com/anbento0490/code_tutorials.git</strong></a><strong class="ly iu"> medium_git</strong></span><span id="c886" class="mq mr it ly b gy nx nt l nu nv">Cloning into ‘medium_git’…<br/>remote: Enumerating objects: 3, done.<br/>remote: Counting objects: 100% (3/3), done.<br/>remote: Compressing objects: 100% (2/2), done.<br/>remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.</span></pre><p id="13ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的命令不仅创建了一个名为"<em class="nw"> medium_git </em>"的目录，而且还初始化了其中的一个<code class="fe lv lw lx ly b">.git</code>目录，下载了该存储库的所有数据，并签出了一个最新版本的工作副本。</p><p id="392c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://help.github.com/en/github/using-git/caching-your-github-password-in-git" rel="noopener ugc nofollow" target="_blank">第一次尝试从远程存储库克隆私有repo时，会要求您提供用户名和密码</a> ( <a class="ae ky" href="https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh" rel="noopener ugc nofollow" target="_blank">除非已经使用SSH密钥连接到GitHub </a>)。凭据可以通过以下方式直接嵌入url:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="ac0f" class="mq mr it ly b gy ns nt l nu nv">git clone https://your_username:your_pw@github.com/anbento0490/repo_name.git</span></pre><p id="5232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提供一次身份验证后，Git会在内存中缓存您的凭证，并在需要时分发它们。如果<code class="fe lv lw lx ly b">git config credential.helper </code>命令返回<code class="fe lv lw lx ly b">manager</code>，密码被存储在windows凭证管理器中，如果它返回<code class="fe lv lw lx ly b">store</code>，密码被存储在用户文件夹的<code class="fe lv lw lx ly b">.git-credentials</code>文件中，如果它返回<code class="fe lv lw lx ly b">oskeychain</code>，密码被存储在钥匙串中。</p><p id="cd0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 9 </strong>。<strong class="lb iu"> git pull </strong>对于本教程，为了模拟协作环境中通常会发生的情况，我直接在GitHub中编辑了<em class="nw"> git_commands.md </em>文件，向列表中添加了更多命令，并提交了更改:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/ebe44d87f475bce88bf33ee8dc86e02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JD3xTdmESJiqGD2Vc3momA.png"/></div></div></figure><p id="fa33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此操作创建了一个具有唯一标识符的新提交。在运行以下命令之前，提交和更改仅在远程存储库中可见:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="114f" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git pull origin master</strong></span><span id="5c46" class="mq mr it ly b gy nx nt l nu nv">remote: Enumerating objects: 5, done.<br/>remote: Counting objects: 100% (5/5), done.<br/>remote: Compressing objects: 100% (2/2), done.<br/>remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0<br/>Unpacking objects: 100% (3/3), done.<br/>From <a class="ae ky" href="https://github.com/anbento0490/code_tutorials" rel="noopener ugc nofollow" target="_blank">https://github.com/anbento0490/code_tutorials</a><br/>* branch master -&gt; FETCH_HEAD<br/>815d087..b3088e3 master -&gt; origin/master<br/>Updating 815d087..b3088e3<br/>Fast-forward<br/>git_commands.md | 10 +++++++++-<br/>1 file changed, 9 insertions(+), 1 deletion(-)</span></pre><p id="8c01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 10 </strong>。<strong class="lb iu"> git diff [HEAD~1] [HEAD]→ </strong>如果您现在从远程repo中提取后运行<code class="fe lv lw lx ly b">git log </code>,<strong class="lb iu"/>您将看到两次提交，最上面的一次是最近的一次。要查看两次提交之间的差异，只需键入:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="0913" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git diff HEAD~1 HEAD</strong></span><span id="27a4" class="mq mr it ly b gy nx nt l nu nv"><strong class="ly iu">diff — git a/git_commands.md b/git_commands.md<br/>index ddd61c8..3cb7e12 100644<br/>— — a/git_commands.md<br/>+++ b/git_commands.md<br/></strong>@@ -1,3 +1,11 @@</span><span id="f178" class="mq mr it ly b gy nx nt l nu nv">+Git 15 Most Used Commands<br/>1. git init ← initializes a repository inside the folder<br/>+2. git add<br/>+3. git config user.name/user.email<br/>+4. git commit -m ‘ your message’<br/>+5. git log<br/>+6. git remote add [remote name][remote url]<br/>+7. git push [remote name] [branch name]<br/>+8. git clone [repository url] [folder name]<br/>+9. git pull [remote name] [branch name]</span></pre><p id="d37c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用名为<strong class="lb iu"> HEAD </strong>的<strong class="lb iu">特殊变量</strong>，而不是键入每个散列的前3-4个字符，该变量总是指向当前分支中最近的提交。您还可以使用快捷方式来获取旧的提交散列，其中<strong class="lb iu"> HEAD~1 </strong>是本地回购中第二个最新的提交，<strong class="lb iu"> HEAD~2 </strong>是第三个最新的提交，依此类推。</p><p id="ae85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 11。git fetch[remote name][branch name]→</strong>与<strong class="lb iu"> </strong> <code class="fe lv lw lx ly b">git pull </code>完全一样，该命令用于从远程存储库下载文件并提交到本地存储库中。您可以考虑这两个命令的更保守的版本，因为它将下载远程内容，但不更新您的本地repo的工作状态，保持您当前的工作不变。如果您在本地有正在进行的未决变更，<code class="fe lv lw lx ly b">git fetch </code>将避免冲突的发生，并且通常用于协作环境中，以查看其他人都在做什么，而不会强迫您将变更合并到您的存储库中。</p><p id="35a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了展示<code class="fe lv lw lx ly b">git fetch</code>有多有用，我在GitHub的列表中添加了另一个命令并提交了更改，这样远程存储库再次比本地存储库有更多的提交。第三个提交ID以<em class="nw"> 40ae0be </em>开始，您可以通过运行以下3个命令来验证:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="46ca" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git fetch origin master</strong></span><span id="732f" class="mq mr it ly b gy nx nt l nu nv">remote: Enumerating objects: 5, done.<br/>remote: Counting objects: 100% (5/5), done.<br/>remote: Compressing objects: 100% (2/2), done.<br/>remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0<br/>Unpacking objects: 100% (3/3), done.<br/>From <a class="ae ky" href="https://github.com/anbento0490/code_tutorials" rel="noopener ugc nofollow" target="_blank">https://github.com/anbento0490/code_tutorials</a><br/>b3088e3..40ae0be master -&gt; origin/master</span><span id="10da" class="mq mr it ly b gy nx nt l nu nv">$ <strong class="ly iu">git checkout origin/master</strong></span><span id="d1ea" class="mq mr it ly b gy nx nt l nu nv">Note: checking out 'origin/master'.<br/>You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example:</span><span id="b584" class="mq mr it ly b gy nx nt l nu nv">git checkout -b &lt;new-branch-name&gt;</span><span id="d66b" class="mq mr it ly b gy nx nt l nu nv">HEAD is now at 40ae0be... Update git_commands.md</span><span id="d65b" class="mq mr it ly b gy nx nt l nu nv">$ <strong class="ly iu">git log</strong></span><span id="e8d0" class="mq mr it ly b gy nx nt l nu nv">commit 40ae0bebb77b8df716439b94bb5005a65c0e6301 (<strong class="ly iu">HEAD</strong>, <strong class="ly iu">origin/master</strong>)</span><span id="36c7" class="mq mr it ly b gy nx nt l nu nv">Author: AnBento &lt;35920666+anbento0490@users.noreply.github.com&gt;<br/>Date:   Sun Apr 5 06:56:07 2020 +0100</span><span id="96e7" class="mq mr it ly b gy nx nt l nu nv">Update git_commands.md</span><span id="2baa" class="mq mr it ly b gy nx nt l nu nv">commit b3088e373b881a526844826a2dade7b1443eefbb (<strong class="ly iu">master</strong>)<br/>Author: AnBento &lt;35920666+anbento0490@users.noreply.github.com&gt;<br/>Date:   Sat Apr 4 18:39:48 2020 +0100</span><span id="c77a" class="mq mr it ly b gy nx nt l nu nv">Update git_commands.md</span><span id="264e" class="mq mr it ly b gy nx nt l nu nv">commit 815d087f132288112b7e427617be0408e6db4974<br/>Author: anbento &lt;anbento@myemail.com&gt;<br/>Date:   Sat Apr 4 08:19:16 2020 +0100<br/>Adding git_commands.md file</span></pre><p id="bd18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为提取不会向本地回购添加任何新的提交，所以您应该使用<code class="fe lv lw lx ly b">git checkout origin/master </code>从本地分支(<strong class="lb iu">主</strong>)切换到远程分支(<strong class="lb iu">源/主</strong>)并进入所谓的“分离头状态”。这允许您运行熟悉的命令，如<code class="fe lv lw lx ly b">git log </code>和<code class="fe lv lw lx ly b">git diff </code>，探索您的同事提交给远程回购的内容。</p><p id="6a11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 12。git reset [ — flag][#hash] </strong> →让我们假设在获取新的提交之后，您对团队所做的更改感到满意，因此您运行<code class="fe lv lw lx ly b">git pull </code>来更新您的本地目录，但是在稍后阶段，您注意到了一个问题，并且想要恢复到倒数第二个提交，或者您只是希望看到项目在更早的时间点是什么样子。在这两种情况下，您都可以运行:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="f30f" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git reset — hard HEAD~1</strong></span><span id="8481" class="mq mr it ly b gy nx nt l nu nv">HEAD is now at b3088e3 Update git_commands.md</span></pre><p id="baf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个命令，Git切换回具有该特定散列的提交。如上所述，为了使你的工作流程更快，你可以利用<strong class="lb iu">特殊可变头</strong>。<strong class="lb iu"> — hard </strong>标志将工作目录和Git历史重置为特定状态。如果您省略了这个标志，或者使用了<strong class="lb iu"> —软</strong>标志，它将跳过对工作目录的修改，只重置Git历史。</p><p id="ba41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 13。Git branch[branch name]/Git branch-d[branch name]→</strong>Git branch允许用户在同一个repo中创建几个不同的工作区域。在专业环境中，<strong class="lb iu">通常会创建一个新的分支，每当你希望对一个项目做一些改变或者修复一个bug </strong>，然后当我们完成后，将那个分支合并回主分支。当你初始化一个新的本地repo时，Git自动创建<strong class="lb iu"> <em class="nw">主</em> </strong>分支:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="c92a" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git branch</strong><br/>* master</span></pre><p id="632e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建新分支，请运行以下命令:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="ac4c" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git branch project1/add_commands</strong></span><span id="841b" class="mq mr it ly b gy nx nt l nu nv">$ <strong class="ly iu">git branch project1/branch_to_delete</strong></span><span id="52f1" class="mq mr it ly b gy nx nt l nu nv">$ <strong class="ly iu">git branch</strong>* master<br/>project1/add_commands<br/>project1/branch_to_delete</span></pre><p id="c3f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，您将创建两个分支(<strong class="lb iu"> project1/add_commands </strong>和<strong class="lb iu">project 1/branch _ to _ delete</strong>)，这两个分支现在将与主分支一起列出。分支的名字应该是有意义的，并且清楚地表明它最初被创建的原因(<em class="nw">添加一个新特性，修复一个bug，执行一个杂务</em>)。使用<code class="fe lv lw lx ly b">git branch delete [branch name] </code>命令删除一个分支:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="f061" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git branch -d branch project1/branch_to_delete</strong></span><span id="7934" class="mq mr it ly b gy nx nt l nu nv">Deleted branch project1/branch_to_delete (was b3088e3).</span></pre><p id="7175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 14。git checkout [branch name] → </strong>要切换到新的分支，请运行以下命令:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="a800" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git checkout project1/add_commands</strong></span><span id="b162" class="mq mr it ly b gy nx nt l nu nv">Switched to branch ‘project1/add_commands’</span></pre><p id="a67c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个常见的快捷方式是使用<code class="fe lv lw lx ly b">git checkout -b [branch name] </code>命令创建一个新的分支并立即切换到它。一旦创建了分支并添加了commit，就可以将分支推送到远程repo。这允许其他人看到您的更改，并在单独的工作区域与您协作:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="2130" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git push origin project1/add_commands</strong></span><span id="17ba" class="mq mr it ly b gy nx nt l nu nv">Counting objects: 3, done.<br/>Delta compression using up to 4 threads.<br/>Compressing objects: 100% (2/2), done.<br/>Writing objects: 100% (3/3), 444 bytes | 444.00 KiB/s, done.<br/>Total 3 (delta 1), reused 0 (delta 0)<br/>remote: Resolving deltas: 100% (1/1), completed with 1 local object.<br/>remote: Create a pull request for ‘project1/add_commands’ on GitHub by visiting:<br/>remote:<a class="ae ky" href="https://github.com/anbento0490/code_tutorials/pull/new/project1/add_commands" rel="noopener ugc nofollow" target="_blank">https://github.com/anbento0490/code_tutorials/pull/new/project1/add_commands</a><br/>remote: To <a class="ae ky" href="https://github.com/anbento0490/code_tutorials.git" rel="noopener ugc nofollow" target="_blank">https://github.com/anbento0490/code_tutorials.git</a><br/>* [new branch] project1/add_commands -&gt; project1/add_commands</span></pre><p id="4602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，我已经将最后5个命令添加到列表中，并通过<strong class="lb iu">项目1/add_commands </strong>分支<strong class="lb iu">提交了更改。</strong>最后，我将提交推送到远程回购，这样现在GitHub帐户上就可以看到两个分支，其中<strong class="lb iu"> project1/add_commands </strong>比主回购多显示一个提交:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/2881c35eed15e2ecca63625864b7ba49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRdqKmPMUbe67Z45LzdPwg.png"/></div></div></figure><p id="17e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以使用<code class="fe lv lw lx ly b">git branch -r </code>来显示遥控器上的所有分支，并确认你的分支在那里。相反，<code class="fe lv lw lx ly b">git branch -a </code>将显示本地可用的所有分支:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="0216" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git branch -r</strong></span><span id="4ec9" class="mq mr it ly b gy nx nt l nu nv">origin/master<br/>origin/project1/add_commands</span><span id="d1c5" class="mq mr it ly b gy nx nt l nu nv">$ <strong class="ly iu">git branch -a</strong></span><span id="3fe3" class="mq mr it ly b gy nx nt l nu nv">master<br/>* project1/add_commands<br/>remotes/origin/master<br/>remotes/origin/project1/add_commands</span></pre><p id="b942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">15。git merge [new_branch name] → 合并允许开发人员将提交从一个分支复制到另一个分支。这使得协作工作成为可能，因为每个团队成员都可以在他们自己的分支上高效地开发项目功能，而不会发生冲突，然后将它们合并到<strong class="lb iu">主</strong>中，以便最终用户可以访问它们。要将<strong class="lb iu"> project1/add_commands </strong>合并到<strong class="lb iu"> <em class="nw"> master，</em> </strong>检出到master分支，然后运行<code class="fe lv lw lx ly b">git merge </code>命令:</p><pre class="kj kk kl km gt no ly np nq aw nr bi"><span id="f8ef" class="mq mr it ly b gy ns nt l nu nv">$ <strong class="ly iu">git checkout master</strong></span><span id="a5d6" class="mq mr it ly b gy nx nt l nu nv">Switched to branch ‘master’</span><span id="9fb3" class="mq mr it ly b gy nx nt l nu nv">$ <strong class="ly iu">git merge project1/add_commands</strong></span><span id="c8dd" class="mq mr it ly b gy nx nt l nu nv">Updating b3088e3..cdb97d4<br/>Fast-forward<br/>git_commands.md | 8 +++++++-<br/>1 file changed, 7 insertions(+), 1 deletion(-)</span><span id="6ba2" class="mq mr it ly b gy nx nt l nu nv">$ <strong class="ly iu">git branch -d project1/add_commands</strong></span><span id="d11a" class="mq mr it ly b gy nx nt l nu nv">Deleted branch project1/add_commands (was cdb97d4).</span></pre><p id="fa23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免混淆，一旦丢失的提交被合并到主<strong class="lb iu"><em class="nw"/></strong>分支中，较新的本地分支通常被删除。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h2 id="a21b" class="mq mr it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated"><strong class="ak">结论</strong></h2><p id="49c0" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">对于那些设法完成本教程的人，我要说:“做得非常好！”我希望你在这里学到的，对你的耐心有所回报。在这篇文章中，我带你了解了在你开始你的第一个web开发或数据科学项目之前需要掌握的15个Git命令，因为版本控制很酷，可以帮你省去很多麻烦！如果你想阅读更多，请确保查看Bitbucket提供的这个优秀的<a class="ae ky" href="https://www.atlassian.com/git/tutorials/what-is-git" rel="noopener ugc nofollow" target="_blank"> Git教程</a>。</p><h2 id="9cb6" class="mq mr it bd ms mt mu dn mv mw mx dp my li mz na nb lm nc nd ne lq nf ng nh ni bi translated">您可能还喜欢:</h2><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/8-popular-sql-window-functions-replicated-in-python-e17e6b34d5d7"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">Python中复制的8个流行的SQL窗口函数</h2><div class="oh l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">关于如何利用业务分析中的Pandas高效复制最常用的SQL窗口的教程…</h3></div><div class="mj l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="mk l"><div class="oi l mm mn mo mk mp ks mc"/></div></div></a></div><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/airflow-how-to-refresh-stocks-data-while-you-sleep-part-1-a464514e45b7"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">气流:如何在睡觉时刷新股票数据——第1部分</h2><div class="oh l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">在这个关于Apache Airflow的第一个教程中，学习如何构建一个数据管道来自动提取、转换和…</h3></div><div class="mj l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="mk l"><div class="oj l mm mn mo mk mp ks mc"/></div></div></a></div></div></div>    
</body>
</html>