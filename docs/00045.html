<html>
<head>
<title>How to Use Cross-Validation for Matrix Completion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用交叉验证完成矩阵</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-cross-validation-for-matrix-completion-2b14103d2c4c?source=collection_archive---------16-----------------------#2020-01-02">https://towardsdatascience.com/how-to-use-cross-validation-for-matrix-completion-2b14103d2c4c?source=collection_archive---------16-----------------------#2020-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6d10" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">寻找最佳 k 个潜在特征和因子矩阵的逐步交叉验证优化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f5fb326082d0c6d7197e75478916bf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_2LilLuCDe_ogr0e"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jespl?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">施巧灵·佩纳</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="b7f4" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">一般</h2><p id="3062" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">交叉验证是机器学习中一个众所周知的实践，通常，它是训练过程的一部分，确保我们的模型在不拟合的数据上表现良好。有不同的方法进行交叉验证，但在所有这些方法中，我们都是根据不适合的数据来预测适合的模型。</p><p id="f7d4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在我搜索矩阵补全工具时，我发现主要是使用全部数据的例子，并且没有留下测试集。在这篇文章中，我将一步一步地演示如何使用交叉验证在 NMF(非负矩阵分解)算法中找到最佳的<strong class="lx iu"> k </strong>(潜在特征)来完成矩阵中的缺失值。然而，这也可以应用于其他算法。</p><p id="66a1" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了让每个人都在同一页上，矩阵分解是使用线性代数将矩阵分解成其组成部分。任何矩阵<strong class="lx iu"> X </strong>都可以化简为一对因子矩阵<strong class="lx iu"> A </strong>和<strong class="lx iu"> Y </strong>，其中<strong class="lx iu"> X </strong>是这些矩阵的点积:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/def720c123b91730c13b178782b25061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-HRUeWOD_HCpXpJH6CTlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">x 矩阵和 A/Y 作为它的因子矩阵</p></figure><p id="8393" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">网上关于矩阵分解的信息数不胜数，我就不细说了。当矩阵及其因子矩阵的所有值都非负时，称为 NMF。更多信息见<a class="ae ky" href="https://en.wikipedia.org/wiki/Non-negative_matrix_factorization" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Non-negative _ matrix _ factorization</a></p><p id="16e4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这篇文章展示了:</p><p id="73e4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">1.如何实现交叉验证以找到最佳 k 个潜在特征</p><p id="1620" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">2.如何处理初始因子矩阵的随机性</p><p id="073e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">以下是我工作的基础:</p><p id="40c9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">1.Alex Williams 的一个帖子，我从中获得了 NMF 交叉验证的灵感:<a class="ae ky" href="http://alexhwilliams.info/itsneuronalblog/2018/02/26/crossval/" rel="noopener ugc nofollow" target="_blank">http://alexhwilliams . info/itsneuronalbog/2018/02/26/crossval/</a>，我的帖子<strong class="lx iu">实际上是那个概念的一步一步的实现。</strong></p><p id="66e2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">2.Tautvydas 的 Stackoverflow 答案，其 NMF 优化函数被用作代码的基础:<a class="ae ky" href="https://stackoverflow.com/questions/22767695/python-non-negative-matrix-factorization-that-handles-both-zeros-and-missing-dat" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/22767695/python-non-negative-matrix-factorization-that-handles-both-zero-and-missing-dat</a></p><p id="8621" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">代码是用 Python 编写的，并在 Numpy 数组上演示，但可以很容易地修改以用于 Pandas 数据框架。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="afa7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">什么是‘潜在特征’，为什么我们需要正确的数量？</strong></p><p id="3944" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">对于一个矩阵<strong class="lx iu"> X，</strong>可能有许多对<strong class="lx iu"> A </strong> / <strong class="lx iu"> Y </strong>，每对在<strong class="lx iu">形状</strong>和<strong class="lx iu">值</strong>上有所不同。</p><p id="f5eb" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了将讨论集中在<strong class="lx iu">形状</strong>元素上，我们假设<strong class="lx iu"> X </strong>有<strong class="lx iu"> m </strong>行和<strong class="lx iu"> n </strong>列，如上图所示。因此<strong class="lx iu"> A </strong>和<strong class="lx iu"> Y </strong>的形状对于<strong class="lx iu"> A </strong>应该是<strong class="lx iu"> m </strong>乘<strong class="lx iu"> k </strong>，对于<strong class="lx iu"> Y </strong>应该是 k 乘<strong class="lx iu"> n </strong>，其中<strong class="lx iu"> k </strong>可以是任意的计数(正整数)。</p><p id="d9d0" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> k </strong>代表<strong class="lx iu"> A </strong>和<strong class="lx iu">Y</strong>的特征数量，但是由于我们只有<strong class="lx iu"> X </strong>，我们不知道<strong class="lx iu"> k </strong>的尺寸，因此我们也不知道<strong class="lx iu"> A </strong> / <strong class="lx iu"> Y </strong>的形状。这就是为什么<strong class="lx iu"> k </strong>所代表的特征被称为<strong class="lx iu">潜在特征</strong>的原因。在下图中我们看到不同对的因子矩阵<strong class="lx iu"> A </strong> / <strong class="lx iu"> Y </strong>，每对都有不同的<strong class="lx iu"> k </strong>，它们都是有效矩阵:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/b3aa4ae093301e97d91468ba52071d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*esKSPo4xvwtOcDLbKj6i8g.png"/></div></div></figure><p id="d5d7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了演示什么是<strong class="lx iu">潜在特征</strong>，我们来看一个例子。矩阵补全有很多用途，然而最著名的是基于<a class="ae ky" href="https://en.wikipedia.org/wiki/Netflix_Prize" rel="noopener ugc nofollow" target="_blank"> Netflix Prize </a>的电影分级推荐系统，其中用户的偏好部分缺失。</p><p id="6e86" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">下面是一个完整矩阵的例子(蓝色的)，其中的数字代表用户的排名，因子矩阵嵌入了一些特性，在本例中为 3。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/950c6f31a068c78382466f0b9525349a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6vK1XZcjK3qlyIiVXQT5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果约翰喜欢喜剧，而电影 B、C、E 是喜剧，则算法可以“分配”一个特征来表示喜剧偏好，因为有一些支持信息。</p></figure><p id="a9bb" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">想要补全<strong class="lx iu"> X </strong>中的缺失值，应该选择使用哪个<strong class="lx iu"> k </strong>？</p><p id="c3a2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">太小的<strong class="lx iu"> k </strong>可能会缺少我们需要的信息，导致拟合不足。在这种情况下，添加更多的特性可以告诉我们更多关于缺失值的信息。</p><p id="4ddd" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">对于<strong class="lx iu"> k </strong>过高的值可能会导致过度拟合。这是因为我们得到了多个解决方案，如下表所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/32ebf8e79e4c5cfd48600e9362ca1697.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*zRAV4rGrW1oxqgSxVG2RYg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">右边的向量不提供任何新信息。它只是其余向量(x+y-z)的线性组合。</p></figure><p id="6898" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">通过交叉验证流程确定 k。</strong></p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="745e" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 1-生成样本数据</h2><p id="0de3" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这里我们创建自己的“缺失数据”。背后是什么？</p><p id="b6a3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">1.我们希望创建一个完整的表，包括“缺失的值”，这样我们就可以真正看到在过程结束时我们是否很好地完成了这些值。</p><p id="3e2d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">2.我们希望从 real <strong class="lx iu"> A </strong>和<strong class="lx iu"> Y </strong>生成表格，这样我们就知道什么样的<strong class="lx iu"> k </strong>是最优的，并看看我们是否得到这个作为输出。</p><p id="29ba" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在打印输出中，我使用了一个小矩阵(10 乘 12)，主要是为了演示方便。然而，为了看到交叉验证的真实效果，我们需要一个更大的矩阵，所以所有的图都取自一个 40×25 的矩阵。两个矩阵都有 5 个潜在特征。</p><p id="8d6d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">注意，k 必须小于矩阵的行/列的最小值，否则我们有多个解。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ddd3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">输出(10 乘 12):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/2fbe67ff5c846b7309a5bcf9e918e0ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4FITUn-w9nmNuvA5"/></div></div></figure><p id="e50c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，我们随机创建空值来模拟真正的“缺失值”:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fcef" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">输出(10 乘 12):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/2e6240b2e2fd0f3050be7215c10a62f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AlPg6qgK-th63eu9"/></div></div></figure><p id="2321" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">从现在开始，代码与具有缺失值的实矩阵相关。</p><h2 id="854e" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 2 —准备阶段</h2><p id="04d0" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">首先，我们创建空掩码。这是最后一步所需要的，在这一步中，我们用得到的矩阵来填充缺失的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="708f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在我们给矩阵加 1(或任何其他数字)。这是为什么呢？</p><p id="6138" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">学习阶段从用 0 填充零开始，所以我们想要区分真正的零和用零填充的零。</p><p id="89b3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">当然，这只是在矩阵中有零的情况下才有意义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="1837" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 3-折叠准备</h2><p id="2fa8" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在任何交叉验证中，我们都将数据分开，例如一部分数据被拟合，其余的数据用于测试。</p><p id="1dc6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在这里，我们将数据矩阵划分为四个部分，每个部分都作为一个等待测试的集合。矩阵被垂直和水平分成两半，如下图所示。</p><p id="ce98" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这满足了一个基本要求，即拟合区域应该分布在所有的行和列上，否则，算法就没有正确的数据可以学习。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/61bc7dbc7a86a6b15a6c9dceaf6ae559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJbbidxIOhW-jFJt4AlYOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在左手边:分成 4 折。在右侧:折叠 1 作为测试集，其他折叠作为训练集。</p></figure><p id="ff04" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们得到每个折叠的训练和测试误差，然后使用它们的平均值。</p><p id="288d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我用了 4 折。然而，人们可以使用不同的折叠数，甚至将其发展为一个参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="04d4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在我们的矩阵上应用该函数产生了训练和测试集，以及每个集的 0/1 掩码。例如，当 fold=2 时，我们得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/cb3a89ca901a0e2acc3d5a4a94c3193a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MWt2hXpnZt5PDon3"/></div></div></figure><p id="06dc" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这些掩码仅用于折叠，还不包括空掩码。这将在下一步中与折叠遮罩合并为一个。</p><h2 id="1766" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 4 —交叉验证</h2><p id="dec0" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">交叉验证函数相对较长，所以首先我将它的主要组件写成一个简短的算法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/c08078956365d383b97d53f386893a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*oojYazfzE6Eidw5-BYu7Hg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">交叉验证算法流程</p></figure><p id="96b3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">为什么我们要把每个褶皱分成几个周期？</strong></p><p id="5717" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">学习过程从给因子矩阵<strong class="lx iu"> A </strong>和<strong class="lx iu"> Y </strong>中的一个分配随机值开始。然后在学习过程中，更新矩阵，直到我们达到最优。</p><p id="0916" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">然而，我们不知道我们开始使用的随机矩阵会把我们引向绝对最优还是仅仅一个局部最优。</p><p id="575a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">所以这里我们在几个周期中尝试几个初始随机矩阵，取最佳周期的<strong class="lx iu">端矩阵</strong>。请注意，我们的最佳周期是具有较低<strong class="lx iu">序列误差</strong>(不是测试误差)的周期，因为这仍然是装配阶段而不是测试阶段的一部分。</p><p id="cf4d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">下图描述了<strong class="lx iu">一折</strong>的几个循环:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/6996b9be6c0038a6349a7dff2372ddb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYpkflqpF3sC9OeZ1zk-Lg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">被绿线包围的矩阵将被用于实际学习中，该学习使用已经优化的<strong class="bd nm"> k </strong>(参见步骤 7)。</p></figure><p id="c11e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">完整的交叉验证功能有几个部分。下面介绍一些主要的方法。其余的可以在文章底部提到的完整笔记本中找到。</p><p id="afd9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">第一部分:每次折叠的准备</strong> —主要是每次折叠准备面膜。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a192" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">第二部分:矩阵初始化</strong> —每个周期初始化 Y，A，X(屏蔽)。还初始化训练和测试误差值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="88f9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">第三部分:更新</strong>——每次迭代更新<strong class="lx iu"> A </strong>、<strong class="lx iu"> Y </strong>和<strong class="lx iu"> X </strong>的学习过程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="81d9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">第四部分:结论</strong> —收集所有结果，选出每次折叠的最佳周期和平均折叠误差。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="8962" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 5 —运行多个<strong class="ak"> k </strong></h2><p id="753f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这里，我们对不同的<strong class="lx iu"> k </strong>使用 nmf_cv 函数。在学习期间，我们可以跟踪每个周期的训练和测试误差，以及每个折叠的最佳周期图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="953f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">下面是三个有代表性的图和各自的误差——左侧的欠拟合(过低<strong class="lx iu"> k </strong>)、中间的右<strong class="lx iu"> k </strong>和右侧的过拟合。注意不同之处。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/df51c61262c54615fe589f60e7656c22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RqVMrFl_KfypoLgJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每 k 训练和测试误差的差异</p></figure><p id="2353" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">然后我们提取最佳运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cfe5" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">下图显示了每个<strong class="lx iu"> k </strong>的训练和测试误差。正如我们所料，最佳的<strong class="lx iu"> k </strong>是 5，这是由于我们在步骤 1 中创建样本数据时选择的潜在特征。在真实数据中，我们当然不知道这个数字。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/17c699f4c1bd5d9b3674af3a175866aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/0*XeQ9HJ1UiowloFWZ"/></div></figure><p id="0a06" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">对于某些<strong class="lx iu"> k </strong>(例如 k=8)，测试误差非常高，似乎偏离了“完美”的测试误差曲线。为了克服这个问题，可以使用平方根或对数矩阵，以减少数字，并以此“控制”误差。</p><h2 id="ef80" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 6 —捕获<strong class="ak"> A </strong>和<strong class="ak"> Y </strong></h2><p id="8ab0" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">如前所述，给定的矩阵<strong class="lx iu"> X </strong>可能具有完全不同的因子矩阵，不仅在形状上，而且在它们的值上。因此，对于不同的折叠，我们可以在相似的<strong class="lx iu"> X </strong>矩阵中结束训练过程，但是非常不同的<strong class="lx iu"> A </strong>和<strong class="lx iu"> Y </strong>。参见 2×2 矩阵的示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/d603e3e5dda650f827caa6c4ed3f7db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*sJY0g0NYS1K2f_YebjNh5g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">同一 X 矩阵的不同组因子矩阵。</p></figure><p id="2250" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这意味着我们不能只对所有的<strong class="lx iu"> A </strong>或<strong class="lx iu"> Y </strong>求平均值。替代方法是使用其中一对(例如来自 fold 0 的<strong class="lx iu"> A </strong>和<strong class="lx iu"> Y </strong>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="e4b9" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 7 —使用优化的<strong class="ak"> k </strong>和捕获的<strong class="ak"> A </strong> / <strong class="ak"> Y </strong>矩阵进行训练</h2><p id="e571" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这是我们实际使用交叉验证结果的步骤:</p><p id="8515" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">-我们使用最佳 k(仅隐含地，A<strong class="lx iu">A</strong>/<strong class="lx iu">Y</strong>的形状假定为右<strong class="lx iu"> k </strong>)</p><p id="411d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">-我们使用末端 A/Y 矩阵。由于这些是端矩阵，我们不必使用非常高的迭代次数。</p><p id="b145" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="40cb" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们得到了预测矩阵。我们可以将原始矩阵与预测矩阵(两者的左上角)以及<strong class="lx iu">非空</strong>值的误差进行比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/739dffa7881dc154cec3a36318fd12cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EYSmxpE-VAS1Q4dO"/></div></div></figure><p id="448d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在是原文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/86dc425f0f90e0a3641c7192738a5d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/0*LhNyuWI6hA7rrSVk"/></div></figure><h2 id="ba5b" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 8-检查空值错误</h2><p id="6d94" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">因为我们知道缺失值(我们创建了原始矩阵)，所以我们有机会检查算法预测缺失值的能力。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/442f0cc2f4ca7fa44ed778bb78ef9e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gX70si_eLZjvte4a"/></div></div></figure><p id="a55c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在是原文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/8d23103033237c7a40cdd74906274abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/0*JfSiG9dajt0k17f4"/></div></figure><h2 id="26d5" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 9-合并 NMF 中缺失的值</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6e81" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这里我们得到了完整的矩阵。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="5e63" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">重新加盖</strong></h2><p id="7be3" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">如果没有交叉验证，我们就不可能知道要使用的<strong class="lx iu"> k </strong>潜在特征，并且对于任何更高的<strong class="lx iu"> k </strong>我们都会获得更好的<strong class="lx iu">列车</strong>性能，因为我们使用了所有的数据。</p><p id="c1ad" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">此外，随机矩阵可能会将我们引向局部优化点，而不是最佳点。通过使用最佳运行的末端<strong class="lx iu"> A/Y </strong>矩阵，我们确保达到最小误差。</p><p id="cfae" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">人们可以按原样使用该代码，或者根据特定需要对其进行修改，例如使用另一种算法。</p><p id="7ed2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">完整的笔记本可以在<a class="ae ky" href="https://github.com/IshayTelavivi/cross_validation_matrix_completion/blob/master/cv_for_nmf_sample1.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/ishaytelaviv/cross _ validation _ matrix _ completion/blob/master/cv _ for _ NMF _ sample 1 . ipynb</a>中找到</p></div></div>    
</body>
</html>