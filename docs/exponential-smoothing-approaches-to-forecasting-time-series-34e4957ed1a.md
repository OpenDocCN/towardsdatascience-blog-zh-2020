# 时间序列预测中的指数平滑方法

> 原文：<https://towardsdatascience.com/exponential-smoothing-approaches-to-forecasting-time-series-34e4957ed1a?source=collection_archive---------31----------------------->

## 对各种时间序列简单有效

![](img/fe1a36e480d93efea80aaa73ecd91dfb.png)

[Ocean Ng](https://unsplash.com/@oceanng?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/s/photos/clock?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍照

在这篇文章中，我们描述并解释了一些预测时间序列未来值的经典算法。这些算法被称为指数平滑器，已经被广泛使用了几十年。我们用例子传达直觉，一些例子在附录中增加了 Python 代码

指数平滑器在深度机器学习的现代继续保持吸引力。它们简单且易于实现。它们对于短期预测也惊人地有效。尤其是在快速变化的时间序列上。

指数平滑器也有助于增量学习，这通常是快速变化的时间序列的必备工具。这是为了使算法能够跟上变化的特征。例如趋势时间序列突然开始振荡。

**基本概念**

时间序列是一段时间内的一系列值。比如某个城市的日平均气温，某只股票的日收盘价，iPhone 11 的月销量。

我们的兴趣在于从时间序列的历史值预测其未来值。(在一个更广泛的公式中，我们不会在这里讨论，我们可能会包括额外的预测，甚至额外的时间序列。)

这个问题非常有趣。企业希望预测未来的销售。交易者希望尽可能预测股票或指数价格。我们都想预报天气。

接下来，一个关键概念。*预测范围*，一个正整数 *h* ，是我们想要预测的未来步骤数。因此，对于每日时间序列，预测范围 1 将预测第二天的值，预测范围 7 将预测未来 7 天的值。

我们从天真的预测者开始。虽然用起来太幼稚，但它可以作为一个有用的基线来与各种指数平滑器进行比较。

天真的预测者预测*x*(*t*+*h*)为 *x* ( *t* )。注意，不管 *h* 是什么，预测总是 *x* ( *t* )。

现在，我们的第一个指数平滑器。

**简单指数平滑**

让我们对时间序列建模如下:

*x*(t)=*f*(*t*)+噪音

这里 *f* ( *t* )是 *t* 的确定性函数，通过从合适的分布中采样，例如标准正态，在每个时间步长独立产生噪声。这个模型既丰富又直观。 *f* ( *t* )对时间序列的确定性分量进行建模。这可能相当复杂，包括多种趋势和多个季节，如果我们愿意的话。*噪声*模拟随机波动和其他未建模的影响。

下面是一些例子

```
*x*(*t*) = *t* + noise
*x*(*t*) = log(*t*) + noise
*x*(*t*) = *t*² + noise
*x*(*t*) = sin(*t*) + noise
```

SES 中的主要思想是从 *x* ( *t* )， *x* ( *t* -1)，估计 *f* ( *t* )，然后用这个估计来预测 *x* 的未来值。

SES 对 *f* ( *t* )的估计是 *x* ( *t* )、 *x* ( *t* -1)、 *x* ( *t* -2)等的指数加权平均值。 *x* ( *t* )贡献最多， *x* ( *t* -1)第二多， *x* ( *t* -2)第三多，以此类推。该贡献以指数方式衰减，其速率由衰减参数 *a* 控制。

这可以递归地表示为

*f*^(*t*)=*ax*(*t*)+(1-*a*)*f*^(*t-1*)

^在那里提醒我们，这是对 *f.* 的估计，而不是 *f* 本身，它对我们是隐藏的。

现在的预测简直是*x*^(*t*+*h*)=*f*^(*t*。NF 是 SES 的一个特例，其中*f*^(*t*)=*x*(*t*)。

简单来说，SES 对于一步预测非常有效，即 *h* =1。其原因是 SES 不仅平滑噪声，而且它还局部地适合 *f* ( *t* )，即在时间 *t* 时，这在时间序列快速变化时很重要。NF 也适合局部 *f* ( *t* )，但是，它并不能平滑噪点。SES 对长期预测无效，即 *h* > 1。

**简单指数平滑+趋势(TrES)**

如前所述，SES 对长期预测无效。通过向 SES 添加趋势组件，我们可以改善这种情况。直觉很简单。如果在 *x* ( *t* )存在局部趋势，趋势组件可以估计它，并使用它来预测稍微更长的时间范围。(这类似于推理:如果你知道一个物体当前的位置和速度，你就可以预测它稍后会在哪里。)

这里有一个简单的例子。考虑 *x* ( *t* ) = *t* +噪声。比方说，我们算出 *x* ( *t* )在每个时间单位内增长 1(噪声除外)。知道了这一点，我们可以预测出 *x* 的值 *h* 时间单位之后将是其当前值加上 *h* 。

好了，让我们更彻底地描述一下算法。为此，让我们将时间序列重新表述为

*x*(*t*)=*f*(*t*-1)+*df*(*t*-1)+噪音

这里 *f* ( *t* ')是 *t* '的函数， *df* ( *t* ')是时间 *t* '的局部趋势。我们把它写成*df*(*t*’)，因为它是 *f* 在*t*’的一阶导数的离散模拟。

这个模型相当于我们的第一个模型。我们只是将 *f* ( *t* )分解为*f*(*t*-1)+*df*(*t*-1)。

下面是一些重构的例子。

```
*x*(*t*) = (*t*-1) + 1 + noise
*x*(*t*) = (*t*-1)² + 2*t* + noise
```

这种保理有什么意义？我们可以分别估计两项 *f* ( *t* -1)和 *df* ( *t* -1)。这允许我们对可以精确估计 *df* ( *t* )的系列做出合理的长期预测。如在*x*(*t*)=*t*+噪声。在因式分解*x*(*t*)=(*t*-1)+1+噪声下我们看到 *df* ( *t* )等于 1。利用这一估计，我们可以对未来做出明智的预测。

我们如何估算 *f* ( *t* -1)和 *df* ( *t* -1)？都是通过指数平滑。 *f* ( *t* )的估计是 *x* ( *t* )， *x* ( *t* -1)，…。 *df* ( *t* )的估计是*x*(*t*)-*x*(*t*-1)、*x*(*t*-1)-*x*(*t*-2)、 *x* ()

姑且把这些估算分别叫做 *f* ^( *t* 和 *df* ^( *t* )吧。现在的天气预报是

*x*^(*t*+*h*)=*f*^(*t*)+*h***df*^(*t*)

注意 *f* ^( *t* )和 *df* ^( *t* )都是局部估计。因此算法适应于 *f* ( *t* )以及 *df* ( *t* )的变化。我们可以使用 *a* 和 *b* 分别作为估计 *f* 和 *df* 的指数衰减参数。这给了我们更多的调整余地。(按照下面的例子，我们将讨论调整这些旋钮一点。)

**例子**

```
t           1   2    3    4    5     ...
x           1   2    3    4    5     ...
f^(a=½)     2   2.5  3.25 ... 
df^(b=½)    1   1    1    ...
```

因为我们已经将其初始化为 *x* (2)，所以 f ^(2)为 2。 *df* ^(2)为 1 是因为我们已经将其初始化为*x*(2)——*x*(1)。我们看到，算法已经推导出序列在每个时间步长中增长 1 的趋势。

让我们在时间 *t* =4 时计算 *x* ^( *t* +1)。就是*f*^(4)+*df*^(4)= 3.25+1 = 4.25。接近实际值 x(5) = 5，尽管有点滞后。滞后是指数平滑的结果。我们可以通过提高最近的权重来减少延迟，但这可能会在其他地方产生成本。我们将在下一段讨论这方面的权衡。

接下来，我们来计算 *x* ^( *t* +3)在时间 *t* = 4。就是*f*^(4)+3 **df*^(4)= 3.25+3 * 1 = 6.25。显然，我们已经能够利用这一趋势来预测未来！x(7)是 7。在这种情况下，长期预测与一步预测一样准确！滞后没有增加。

平滑参数为我们提供了控制滞后的方法。在我们的例子中，增加 *a* 的值将减少滞后。另一方面，在我们示例的噪声版本中，过大的 *a* 值将无法消除噪声。所以，是的，滞后会减少，但预测质量不会。就好像我们在追逐最近的值，随着其中的噪声移动。

类似的推理适用于参数 *b* 。除了它适用于 *df* ，即斜率。在我们的例子中，斜率总是相同的，1。所以改变 *b* 不会有任何效果。然而，如果斜率大于 1 并且其中有乘性噪声，例如 *df* 是 5 *噪声，其中噪声的平均值为 1 并且围绕其波动，改变 *b* 可能会影响 *df* ^滞后 *df* 的程度与 *df* ^追赶 *df* 中的噪声的程度。

这里的方法是在输入数据的适当切片上自动调整这些参数。也就是说，机器学习它们以最小化合适的损失函数。这里就不赘述了。

**简单指数平滑+趋势+季节性(TrSeES)**

参见**，**虽然对呈现局部线性趋势的序列有效，但对具有周期结构的序列并不总是有效。

考虑时间序列

```
1, 2, 3, 1, 2, 3, 1, 2, 3, … 
```

SeES 将预测 *x* ^(3)接近 4。现实中， *x* (3)是 1。这是一个很大的区别。如果我们知道时间序列每三个时间步重复一次，我们就可以用这个信息来改进预测。

我们如何改进 TrES？假设序列有单一的季节性，即单一的重复成分，我们知道它的顺序，即 *k* 。我们可以如下模拟这样的时间序列。

*x*(*t*)=*tr*(*t*)+*s*(*t*)+噪音

*s*(*t*)=*s*(*t*-*k*)

这里 *s* ( *t* )是一个重复的时间序列。 *x* ( *t* )是将 *s* ( *t* )加到另一个时间序列上得到的，我们称之为 *tr* ( *t* )。我们称之为 *tr* ( *t* )是因为我们认为它是建模 *x* ( *t* )的趋势分量。也就是说，现实中， *tr* ( *t* )建模的是从 *x* ( *t* )中去掉 *s* ( *t* )后剩下的东西。它还可能有其他重复成分。 *tr* ( *t* )只是比 *x* ( *t* )不太及时。当我们看到下面的算法时会变得很清楚，即使去掉一个季节性也是一种进步。

让我们看一个这样表达的例子。

```
*t*   1  2  3  4  5  6  7  8  9
*s*   **1  2  3**  1  2  3  1  2  3
*tr*  1  2  3  4  5  6  7  8  9
*x*   2  4  6  5  7  9  8  10 12
```

我们如何估算 *tr* ( *t* )和 *s* ( *t* )？首先，我们假设我们知道顺序 *k* 。一个合理的方法是获得一个新的时间序列*yk*(*t*)=*x*(*t*)-*x*(*t*-*k*)，去掉季节性的影响。然后我们可以应用 TrES 来预测*yk*^(*t*+*h*。然后我们将*x*(*t*+*h*-*k*)与*yk*^(*t*+*h*)相加，这给我们一个合理的预测*x*^(*t*+*h*

让我们看看上面的例子是如何进行的。

```
t   1  2  3  4  5  6  7  8  9
x   2  4  6  5  7  9  8  10 12
y3  3  3  3  3  3  3
```

太好了，y3 很容易预测。其值始终为 3。消除季节性的影响帮助很大！TrES 会很快算出 y3 是常数。

我们来预测一下*x*(*t*+3 = 12)在 *t* =9。首先我们预测 y*y*3(12)是 3。然后我们把 *x* (9) = 12 加到这个预测上。我们得到 *x* ^(12) = 3+12 = 15。除非未来发生变化，否则这个预测是准确的。

只要 *h* 小于或等于 *k* 我们就可以这样做。(如果 *h* 大于 *k* ，*t*+*h*-*k*将大于 *t* ，即进入未来！)

**平滑季节性**

我们可以进一步改进。在从*y*^*k*(*t*+*h*)推导 *x* ^( *t* + *h* 时，我们可以添加它的平滑版本，而不是添加*x*(*t*+*h*-*k*)。用什么方法抚平？取*x*(*t*+*h*-*k*)、*x*(*t*+*h*-2*k*)、*x*(*t*+*h*-3*k 的指数加权平均值*

为什么我们认为平滑季节性可以进一步改善旅游？考虑季节性成分中含有乘性噪声的情况。即，

*s* ( *t* ) =噪声**s*(*t*-*k*)

其中，为了便于说明，假设该噪声是一个均值为 1、标准差大于 0 但远小于 1 的高斯噪声。这样的季节性模型是现实的。

在这种情况下，*x*(*t*+*h*-*k*)，x(*t*+*h*-2*k*)，*x*(*t*+*h*-3TrES 将解决我们之前遇到的附加噪声问题。但不是这种乘法噪声。使用从*x*(*t*-*k*)、x(*t*+*h-*2*得到的*x*(*t*+*h*-*k*)的指数平滑估计值*

**Python 代码**

我把它放在这里，这样人们可以看到一些实际的代码。也就是说，它有些部分是不完整的。也可能有 bug。所以，如果你想让它正常工作，就要准备做一些额外的工作。

**时间序列发生器**

```
import numpy as np
noise = np.random.normal
f = lambda t: <**some function of t**>
x = [f(t) + noise for t in range(n)]
```

通过适当地选择 f，我们可以生成各种时间序列。包括有趋势的，有周期的，两者都有。

接下来，我们展示各种指数平滑器的代码。作为所有这些语句的第一条语句，添加

```
x = [1,2,3,4,5,6,7]
```

或者，更好的方法是，使用时间序列生成器生成 x。

**SES 算法**

```
<**initialize x here**>
f = x[0]
y = {}
a = 0.5
for t in range(len(x)):
   xhat_tplus1 = f        # **forecast next value**
   f = a*x[t] + (1-a)*f
```

**TrES 算法**

```
<**initialize x here**>
f,df    = x[1], x[1]-x[0]
y       = {}
h, a, b = 3, 0.5, 0.5for t in range(2,len(x)):
   x_hat_tplush = f + h*df # **forecast h steps ahead**
   f  = a*x[t] + (1-a)*f
   df = b*(x[t]-x[t-1]) + (1-b)*df
```

**TrSeES**

这需要更多的工作来实现端到端。它也不能平滑季节性。

```
<**initialize x here**>
yk = [x[t] — x[t-k] for t in range(k,n)]<**Run TrES on yk**># Forecast x. forecast_y(t+h) uses the forecast model built earlier on yk using TrES.xhat_tplus_h = forecast_y(t+h) + x[t+h-k]
```

**延伸阅读**

1.  https://otexts.com/fpp2/第七章是关于指数平滑法。