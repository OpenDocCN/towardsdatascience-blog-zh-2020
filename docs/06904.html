<html>
<head>
<title>Looking Inside Mahalanobis Metric Matching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Mahalanobis度量匹配</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/looking-inside-mahalanobis-metric-matching-4e43cca46a6?source=collection_archive---------55-----------------------#2020-05-28">https://towardsdatascience.com/looking-inside-mahalanobis-metric-matching-4e43cca46a6?source=collection_archive---------55-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c43b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它实际上是如何工作的？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7c239112625b2d5ae0c2260911127246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L2s5pPeVvGhKMyD5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安妮·尼加德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="32d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之前的<a class="ae ky" href="https://medium.com/@bowenchen_9406/matching-estimator-is-powerful-and-simple-82350f08515a" rel="noopener">帖子</a>展示了如何使用13行<em class="lv"> R </em>代码实现倾向评分匹配。通过这些代码，您可以看到匹配更多的是关于数据预处理。我们的想法是找到与治疗单位相当的控制单位，这样我们就可以更有把握地将治疗组之间的结果差异归因于治疗。此外，我想说匹配实际上很简单，所以你不应该被它吓到。</p><p id="aa06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我研究了一个流行的替代倾向评分匹配的方法:Mahalanobis度量匹配。这两种匹配方法的不同之处主要在于MM匹配使用Mahalanobis度量而不是倾向得分来查找匹配。我将一步一步向你展示在实践中如何使用最简单的<em class="lv"> R </em>代码完成MM匹配。这些步骤嵌入在进行匹配的程序中，但它们通常是不可见的。</p><h1 id="c572" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">进行马氏度量匹配的r码</h1><p id="a5e1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">与我之前的<a class="ae ky" href="https://medium.com/@bowenchen_9406/matching-estimator-is-powerful-and-simple-82350f08515a" rel="noopener">帖子</a>类似，我为数据练习模拟了一个小数据集。从<a class="ae ky" href="https://github.com/cbw1243/rfuncs/blob/master/do1.R" rel="noopener ugc nofollow" target="_blank">这里</a>可以找到生成模拟数据的<em class="lv"> R </em>代码。模拟数据有两个连续协变量(W1，W2)，一个二元处理(A)，和一个连续结果(Y)。为了简单起见，我只生成10个数据点，其中4个显示为处理过的单元。</p><p id="6e54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成数据的代码是:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4d75" class="my lx it mu b gy mz na l nb nc">library(Matching)<br/>library(dplyr)<br/>library(tidyr) # call libraries <br/>set.seed(123) # seed for reproducibility<br/>data &lt;- generateData(10) # generate 10 data points (need to download # the function provided in the main text)</span></pre><p id="f360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模拟数据值为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f6f0aedfae5b8bfb4f7e712bb67c9e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*MCbVn6L2QbX6ENnqU1Ss4w.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。模拟数据值</p></figure><p id="d627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步。定义一个函数来计算马氏距离</p><p id="a61e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算马氏距离的数学公式为:MD =(<strong class="lb iu">X1</strong>-<strong class="lb iu">X2</strong>)’<strong class="lb iu">S</strong>(<strong class="lb iu">X1</strong>-<strong class="lb iu">X2</strong>)，其中<strong class="lb iu"> X1、X2 </strong>分别为处理单元和对照单元的协变量(本例中为W1和W2)的向量。<strong class="lb iu"> S </strong>是数据的样本协方差的倒数。注意，我们可以计算每一对的距离(处理对对照)。我们不计算治疗单位之间的距离，因为我们是在治疗组之间匹配，而不是在同一治疗组内。</p><p id="9ccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义一个函数，它可以计算一对观察单元的MD。然后我们可以循环遍历所有的线对。该函数如下所示。每一行代码都是不言自明的，所以我在这里不再提供更多的讨论。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4299" class="my lx it mu b gy mz na l nb nc">mahalDist &lt;- function(Tr, Cn, inv.cov, dataset) {<br/> covars &lt;- dimnames(inv.cov)[[1]] # get covariate names<br/> xtreat &lt;- as.matrix(dataset[Tr, covars]) # get X1 (treated)<br/> xcntrl &lt;- as.matrix(dataset[Cn, covars]) # get X2 (control)<br/> xdiffs &lt;- as.matrix(xtreat — xcntrl) # calculate differences<br/> out &lt;- as.numeric(xdiffs %*% inv.cov %*% t(xdiffs)) # MD<br/> names(out) &lt;- paste0(Tr, ‘-’, Cn) # Set a name for the output<br/> return(out)<br/>}</span></pre><p id="33e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二步。计算每个治疗/对照对的马氏距离</p><p id="8928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们使用以下代码计算每个处理/对照对的MD:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ece1" class="my lx it mu b gy mz na l nb nc">icv &lt;- solve(cov(data[, c(‘W1’, ‘W2’)])) # Inverse of the variance<br/>treat.rows &lt;- which(data$A == 1) # treated rows<br/>cntrl.rows &lt;- which(data$A == 0) # control rows</span><span id="88ed" class="my lx it mu b gy ne na l nb nc">mdist &lt;- mapply(function(x,y) mahalDist(x, y, inv.cov = icv, data = data), rep(treat.rows, each = length(cntrl.rows)),<br/>       rep(cntrl.rows, times = length(treat.rows)))</span></pre><p id="3020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，最后一个<em class="lv"> mapply </em>函数只是简单地循环计算MD(由<em class="lv"> mahalDist </em>定义)，基于所有可能的处理/控制对的行号。下面报告了<em class="lv"> mdist </em>的输出，例如，位于第1行的处理单元和位于第3行的控制单元之间的MD为12.12。该值似乎是与位于第1行的处理单元相关的所有MDs中最大的。与位于第6行的控制单元相关的最小MD是1.67。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/c5502db001a3395d842a0677431295a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tdq-miCa18t7WO3lD1tHXA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。mdist的输出</p></figure><p id="e8ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三步。寻找距离最短的最佳匹配</p><p id="b3a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于样本量很小，我们可以很容易地找到每个处理单元的最佳匹配(最低MD)。但是下面是一些自动找到最佳匹配的代码:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="d7c1" class="my lx it mu b gy mz na l nb nc">mdist_data &lt;- <br/> data.frame(pairs = names(mdist), maha_dist = unlist(mdist),<br/> stringsAsFactors = F) %&gt;% # Create a data frame to save pair names #and MD values. <br/> separate(pairs, into = c(‘treat’, ‘cntrl’), sep = ‘-’) %&gt;% # get #separate names for treated and control units.<br/> group_by(treat) %&gt;% # Search for the lowest MD by each treated unit<br/> filter(maha_dist == min(maha_dist)) # return the lowest MD </span></pre><p id="c54b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> mdist_data </em>的输出为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/4cc39fb520c96be6ff9907040b9c6d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*IzZhhBKVd_CbyinkPbgxUw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3。mdist_data的输出</p></figure><p id="9a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到，四个MD最低的对照单位与四个治疗单位相匹配。相对而言，最后一对(即第7行的处理单位-第9行的对照单位)是最接近的一对，而第一部分(即第1行的处理单位-第6行的对照单位)是最不同的一对。事实上，如图1所示，第1行的处理单元恰好具有最低的w 1和最高的W2。因此，很难为它找到一个好的匹配(与其他人太不同)。</p><p id="6f9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过三个步骤和少量代码，我们完成了基于马氏距离匹配的数据预处理。人们可以用匹配的数据做进一步的分析。我希望你喜欢这本书！</p></div></div>    
</body>
</html>