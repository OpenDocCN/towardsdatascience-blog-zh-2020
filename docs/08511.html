<html>
<head>
<title>An overview of using TensorFlow 2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow 2.0使用概述</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-overview-of-using-tensorflow-2-0-8d841748e680?source=collection_archive---------42-----------------------#2020-06-20">https://towardsdatascience.com/an-overview-of-using-tensorflow-2-0-8d841748e680?source=collection_archive---------42-----------------------#2020-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="612a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个想法的显现。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4965578c3f65e000e5863e657b09ad9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6WMoZ2xq5hjOUAehtMZgw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pngkit.com/bigpic/u2e6e6q8y3q8t4w7/" rel="noopener ugc nofollow" target="_blank">透明tensor flow Logo Png@pngkit.com</a></p></figure><p id="21a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Tensorflow已经成为最受欢迎的深度学习库之一。程序员、数据科学家和研究人员可以使用它，通过使用API或从头开始编写东西来创建开箱即用的模型。它和你的需求一样抽象。</p><p id="dcd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决机器学习问题所需的基本步骤序列包括拥有数据集、创建模型、训练和评估模型以及最终部署它。我们将详细讨论这些步骤。不过，在此之前，让我们讨论一些与TensorFlow 2相关的有用更新。</p><h2 id="3e5e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">急切的执行</h2><p id="d7bc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">TensorFlow 2默认启用了急切执行。在TensorFlow的早期版本中，即使是打印张量这样最简单的任务也要创建一个会话。急切执行使代码更加直观。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">打印张量z值的旧方法。它不是直观的。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新更直观的方式打印张量(TF2)。</p></figure><h2 id="f0bb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">比如Numpy</h2><p id="0d36" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Numpy是一个流行的Python库，专注于涉及矩阵的数学运算。由于急切的执行，TensorFlow 2感觉更像numpy。张量上的“numpy”方法也允许张量转换成numpy数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">TensorFlow更像Numpy。</p></figure><h2 id="778e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">tf .函数装饰</h2><p id="51d7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个装饰器加速了函数在后续调用中的执行。它允许使用TensorFlow使用的底层图模型的性能优势。装饰器告诉TensorFlow跟踪函数的计算并提高性能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">@ tf.function decorator用来提升性能。</p></figure><h2 id="18a5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">清洁剂API</h2><p id="7c85" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">TensorFlow API已经过清理，其中添加了tf.keras.layers和TF . keras . loss等命名空间。为了更好地组织，许多命名空间都被重命名，例如tf.mod被重命名为tf.math.mod。少数端点(如tf.rint)已被弃用。有关所有变更的详细列表，请参考<a class="ae ky" href="https://github.com/tensorflow/community/blob/master/rfcs/20180827-api-names.md" rel="noopener ugc nofollow" target="_blank"> TensorFlow名称空间</a>。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="2a93" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated">数据设计</h1><p id="04bf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">随着时间的推移，机器学习社区已经整合了许多有用的数据集，其中一些可以与深度学习库一起使用。很明显，您可以使用自己的数据并创建一个输入管道来进行训练。例如，“flow_from_directory”可用于高效地读取图像并动态地对其进行扩充。也可以使用CSV等文件中存储的数据。然而，在TensorFlow 2中，在数据集方面有两个选项—</p><h2 id="10f4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用Keras数据集</h2><p id="4894" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Keras datasets提供回归数据集(如boston housing)、图像分类数据集(如mnist)和情感分类数据集(如imdb)。这些数据集以numpy格式提供，并适合内存。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从keras数据集导入MNIST数据集。<strong class="ak">文档</strong> <a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/keras/datasets" rel="noopener ugc nofollow" target="_blank"> tf.keras.datasets </a>。</p></figure><h2 id="68f3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用张量流数据集</h2><p id="25ff" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Tensorflow数据集是使用数据的更快、更有效的方式。这是一种高性能的数据集格式。使用TensorFlow数据集读取的数据不是numpy格式，而是tf.data格式。它由大量面向研究的数据集组成，这些数据集被分类为音频、图像、图像分类、对象检测、结构化、摘要、文本、翻译和视频。这些数据集更加真实。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用张量流数据集导入MNIST数据集。阅读数据集<a class="ae ky" href="https://www.tensorflow.org/datasets/catalog/overview" rel="noopener ugc nofollow" target="_blank"> TensorFlow数据集的完整目录。</a> <strong class="ak">文档</strong> <a class="ae ky" href="https://www.tensorflow.org/datasets" rel="noopener ugc nofollow" target="_blank">张量流_数据集。</a></p></figure><h1 id="e93d" class="nc lw it bd lx nd nn nf ma ng no ni md jz np ka mg kc nq kd mj kf nr kg mm nm bi translated">模型设计</h1><p id="527a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">TensorFlow 2已经推荐使用Keras作为其官方API。在Tensorflow中设计模型就像插入内置层一样简单，从零开始为研究应用程序编写一切。</p><h2 id="d919" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">顺序API</h2><p id="86d5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">顺序API用于制作线性模型，一层一层的堆叠在另一层的顶部。使用add()方法将不同的层(如Dense、Flatten和Conv2D)添加到模型中。一旦你创建了你的模型，你就可以看到模型的概要。顺序API是创建模型最常用的API。基本思想是堆叠一堆层来创建一个模型，该模型随后被编译和进一步训练以得出推论。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">顺序卷积神经网络。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/7dd446853690e5ead09c9a164431ebc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXeukXOGnz2FSIBvCSAjPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模型摘要。<strong class="bd nt">文档</strong><a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/keras/Sequential" rel="noopener ugc nofollow" target="_blank">TF . keras . sequential .</a></p></figure><h2 id="d6e8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">功能API</h2><p id="6a48" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">顺序API建立线性模型，而函数API用于建立非线性模型。这些模型的架构类似于有向图(DAG)。这些模型具有接受多个输入、产生多个输出和共享层的能力。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用函数式API创建的模型。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/5140fbbec1faa9bb17fd0dcc051bf120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*gaXojISU1bql0N3FOnWS3w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用图形表示模型。<strong class="bd nt">文档</strong> : <a class="ae ky" href="https://www.tensorflow.org/guide/keras/functional" rel="noopener ugc nofollow" target="_blank"> Keras功能API </a></p></figure><h2 id="f7c7" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">子类</h2><p id="d56e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">子类化允许从头开始写所有的东西。它对创建模型的各个方面提供了更好的控制。框架给出了一个类，其中构造函数定义了要使用的层，调用方法将这些层按顺序放在一起。如果您想了解事情在幕后是如何工作的，推荐使用这种方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">__init__方法定义层。call方法定义了如何使用已定义的层。您可以打印第12行生成的“x”值。你可以得到x的值，并对它应用各种数学函数。<strong class="ak">文档</strong> : <a class="ae ky" href="https://www.tensorflow.org/guide/keras/custom_layers_and_models" rel="noopener ugc nofollow" target="_blank">编写自定义图层和模型</a></p></figure><h1 id="0408" class="nc lw it bd lx nd nn nf ma ng no ni md jz np ka mg kc nq kd mj kf nr kg mm nm bi translated">培训设计</h1><h2 id="4e13" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用拟合方法</h2><p id="3692" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">拟合是用于训练模型的最常用方法。它适用于使用上述任何策略创建的模型。当数据集很小并且适合内存时使用它。</p><p id="9c4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用fit方法训练模型之前，模型被编译，在此期间为模型指定损失函数、优化器和度量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用拟合方法训练模型。<strong class="ak">文档</strong> <a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/keras/Model#fit" rel="noopener ugc nofollow" target="_blank"> model.fit() </a>。</p></figure><h2 id="b117" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用回调</h2><p id="68de" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">各种图表用于在训练期间监控模型的进度。或者，可以使用回调来监控各种评估指标的状态，并做出决定，例如停止训练、定期保存模型、安排学习速率、可视化训练进度等。它们在训练期间的不同点被调用，例如一个时期的开始、一批的结束等等。回调作为列表传递给fit方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">EarlyStopping的回调示例，它根据某个条件停止训练。<strong class="ak">文档</strong> <a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/keras/callbacks" rel="noopener ugc nofollow" target="_blank">回调。</a></p></figure><h2 id="98b2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用Fit生成器</h2><p id="58cb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这是训练模型的另一种方式。当数据集太大而无法放入内存时，使用拟合生成器方法。fit generator的一个常见用例是从目录中读取图像，同时对它们应用数据扩充。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">fit_generator()的示例。这些图像是从/tmp/data(第3行)中读取的，batch_size为20(第16行)。您还可以在从目录流动时应用放大，如缩放和剪切。<strong class="ak">文档</strong> : <a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/keras/Model#fit_generator" rel="noopener ugc nofollow" target="_blank"> fit_generator </a></p></figure><h2 id="db47" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">批量使用列车</h2><p id="b52c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">分批训练在分批水平上工作。它将单个批次作为输入，并在执行反向传播后更新模型参数。它允许我们在每批之间做额外的事情。一个用例是根据您可能稍后收集的一批新样本来更新预训练模型。它也用于LSTM，其中LSTM的状态通常需要在每个数据系列之后复位。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">批量训练的一个例子。<strong class="ak">文件</strong> : <a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/keras/Model#train_on_batch" rel="noopener ugc nofollow" target="_blank">批量培训</a></p></figure><h2 id="6e59" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">编写自定义训练循环</h2><p id="bb39" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在训练模型时，fit和fit_generator函数抽象了许多细节。但是，如果需要，TensorFlow 2允许您使用“GradientTape”查看网络的梯度。您还可以看到权重如何使用这些渐变进行更新。基本上，它可以让你更好地控制如何更新权重。讨论自定义训练循环的完整示例可能会让人不知所措。这里已经讨论过<a class="ae ky" href="https://www.tensorflow.org/tutorials/customization/custom_training" rel="noopener ugc nofollow" target="_blank">的一个详细例子。</a></p><h2 id="6681" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">分布式培训</h2><p id="adc9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在训练深度学习模型时，可扩展性至关重要。TensorFlow 2允许在不对代码进行重大更改的情况下扩大学习任务的规模，以加快学习速度。训练过程可以扩展到多个GPU、TPU和机器。定义了多种策略来满足不同的用例。例如，MirroredStartegy支持在一台机器上对多个GPU进行训练，而MultiWorkerMirroredStrategy支持在多台机器上进行同步分布式训练，每台机器都可以有多个GPU。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用MirroredStrategy的示例。代码中只添加了第4行和第6行，以支持分布式培训。其中的函数是分布式感知的。<strong class="ak">文档</strong> : <a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/distribute" rel="noopener ugc nofollow" target="_blank"> tf.distribute </a></p></figure><h1 id="4327" class="nc lw it bd lx nd nn nf ma ng no ni md jz np ka mg kc nq kd mj kf nr kg mm nm bi translated">序列化</h1><p id="ddbd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">一旦模型被训练，它需要被保存以便在生产中使用。在TensorFlow 2中，保存模型已使用SavedModel格式标准化，该格式保存完整的模型及其权重。SavedModel formal使使用TensorFlowJS、TensorFlowLite或TensorFlow Serving部署模型变得更加容易。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用saved_model保存张量流模型。<strong class="ak">文档:</strong> <a class="ae ky" href="https://www.tensorflow.org/guide/saved_model" rel="noopener ugc nofollow" target="_blank">已保存的模型</a></p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加载模型以备将来使用。</p></figure><h1 id="e2d1" class="nc lw it bd lx nd nn nf ma ng no ni md jz np ka mg kc nq kd mj kf nr kg mm nm bi translated">部署</h1><h2 id="b5de" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用TensorFlow服务</h2><p id="b276" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">TensorFlow服务允许机器学习模型作为REST或gRPC(远程过程调用)客户端API。通过提供docker文件，TensorFlow中的服务变得更加容易。这里已经讨论了一个实现<a class="ae ky" href="https://www.tensorflow.org/tfx/guide/serving" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="4fec" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用TensorFlow Lite</h2><p id="8082" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">移动和物联网设备也可用于部署TensorFlow模型。然而，这些设备具有诸如功耗和电池寿命的限制。TensorFlow提供了一种方法，用于将最初训练的模型转换为它们的轻量级版本，这些版本可以部署在具有功率和处理约束的设备上。它是一个适用于Android、iOS和嵌入式系统的轻量级解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将SavedModel转换为较简单的格式。<strong class="ak">文档</strong> : <a class="ae ky" href="https://www.tensorflow.org/lite/guide/get_started" rel="noopener ugc nofollow" target="_blank"> TFLite </a></p></figure><h2 id="1f5a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用TensorFlowJS</h2><p id="877e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">TensorFlowJS已经能够使用NodeJS在浏览器或服务器端直接使用机器学习。一旦保存了模型，就可以使用TensorFlowJS轻松地部署它。该模型首先被转换成TensorFlowJS web格式，然后被加载用于部署。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于将SavedModel格式转换为TensorFlow的脚本。JS web格式。<strong class="ak">文档</strong> : <a class="ae ky" href="https://www.tensorflow.org/js/tutorials/conversion/import_saved_model" rel="noopener ugc nofollow" target="_blank">导入一个模型TensorFlowJS </a></p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">导入转换后的模型并将其用于预测。</p></figure><h1 id="5353" class="nc lw it bd lx nd nn nf ma ng no ni md jz np ka mg kc nq kd mj kf nr kg mm nm bi translated">结论</h1><p id="61c9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在tf.keras命名空间下整合不同的优化器、度量、损失函数和层之后，我能够在TensorFlow 2中编写更一致的代码。急切执行简化了调试。我现在可以使用python的标准print <em class="nv"> </em>函数打印出来，而不是创建一个会话来获取张量的值。tf.function decorator的加入使得使用标准python编写的函数能够通过TensorFlow进行性能优化。我可以使用tf.distribute提供的策略轻松调整我的模型的训练，而无需对代码进行重大更改。</p><p id="e186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，<a class="ae ky" href="https://www.tensorflow.org/hub" rel="noopener ugc nofollow" target="_blank"> TensorFlow hub </a>允许我通过使用迁移学习来重用机器学习模型，从而加快训练过程。总的来说，TensorFlow已经成长为一个开发者友好而强大的人工智能库。</p></div></div>    
</body>
</html>