<html>
<head>
<title>Implementing gRPC server using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 实现 gRPC 服务器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-grpc-server-using-python-9dc42e8daea0?source=collection_archive---------6-----------------------#2020-05-15">https://towardsdatascience.com/implementing-grpc-server-using-python-9dc42e8daea0?source=collection_archive---------6-----------------------#2020-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9b2a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你的下一个 API 不需要用 REST 和 JSON 来构建。gRPC 和协议缓冲区如何更好的性能和结构？</h2></div><p id="e4c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如今，当人们想要实现后端 API 时，他们会直接使用 RESTful API 创建使用 JSON 通信的应用程序，甚至不考虑其他选项。然而最近几年，gRPC 和它的<em class="le"> protobufs </em>由于它们的许多优点开始得到一些关注和欢迎。因此，让我们来看看有什么值得关注的，并使用 Python 实现 gRPC 服务器！</p><p id="0106" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">TL；DR:这里是我的带有</em> <code class="fe lf lg lh li b"><em class="le">grpc</em></code> <em class="le">分支的存储库，包含本文的所有源代码:</em><a class="ae lj" href="https://github.com/MartinHeinz/python-project-blueprint/tree/grpc" rel="noopener ugc nofollow" target="_blank"><em class="le">https://github . com/MartinHeinz/python-project-blue print/tree/grpc</em></a></p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/8709d8a5e16a5854bc0c3b3931ed1716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hgIW0NPDSdm88scZEaRUxQ.jpeg"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated"><a class="ae lj" href="https://unsplash.com/@zaks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Zak Sakata </a>在<a class="ae lj" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原始照片</p></figure><h1 id="ec0c" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">gRPC 到底是什么？</h1><p id="4799" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated"><em class="le"> gRPC </em>是远程过程调用(RPC)协议，利用<em class="le">协议缓冲区(protobufs) </em>作为其消息格式。使用 gRPC，客户端应用程序可以使用方法存根直接调用远程服务器上的可用方法。只要有客户端语言的存根(生成),服务器端应用程序用什么语言实现并不重要。gRPC 支持多种语言，包括 Go、Java、Ruby、C#或者我们选择的语言——Python。你可以在这个<a class="ae lj" href="https://grpc.io/docs/guides/" rel="noopener ugc nofollow" target="_blank">概述</a>中找到更多信息。</p><p id="3df6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，什么是<em class="le">协议缓冲区(protobufs) </em>？Protobufs 是 JSON 或 XML 等格式的替代品。它们是一种更小、更简单、更有效的序列化数据的方式。要使用<em class="le"> protobufs </em>，您需要定义您希望交换的消息看起来是什么样子，例如(更多细节参见<a class="ae lj" href="https://developers.google.com/protocol-buffers/docs/proto" rel="noopener ugc nofollow" target="_blank">本语言指南</a>):</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="478f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了消息，我们还需要定义将在服务器端实现并从客户端调用的<code class="fe lf lg lh li b">service</code>及其<code class="fe lf lg lh li b">rpc</code>方法:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="4fdd" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">我为什么要在乎呢？</h1><p id="a6f9" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">与 REST 相比，使用 gRPC 有很多优点。首先，gRPC 在性能方面要好得多，这要归功于<em class="le"> protobufs </em>的紧密封装，它减少了发送的有效载荷的大小。它还使用 HTTP/2，而不是 REST 使用的 HTTP/1.1。由于这些原因，它是物联网、移动设备或其他受限/低功耗环境的绝佳选择。</p><p id="86fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">选择 gRPC 而不是 REST 的另一个原因是 REST 不要求任何真正的结构。您可以使用 OpenAPI 定义请求和响应的格式，但是这是松散的和可选的。另一方面，gRPC 合同更加严格且定义明确。</p><p id="f591" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，gRPC 使用 HTTP/2，值得一提的是它充分利用了它的特性。举几个例子:并发请求，流而不是请求-响应，对延迟的敏感度更小。</p><p id="2389" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也就是说，也有缺点，最大的缺点是采用。并非所有的客户端(浏览器)都支持 HTTP/2 的使用，这使得它在外部使用时存在问题。考虑到性能优势，它显然是您可以控制的内部服务和通信的最佳选择。</p><h1 id="d66c" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">安装</h1><p id="c1b9" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">要使用 gRPC 和<em class="le"> protobufs </em>做任何事情，我们需要安装它的编译器:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c112" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑到我们使用 python 来构建我们的应用程序，我们还需要<code class="fe lf lg lh li b">grpcio</code>和<code class="fe lf lg lh li b">grpcio-tools</code>库:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="dc49" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">让我们建造一些东西</h1><p id="9314" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">准备好所有工具后，我们现在可以开始构建应用程序了。对于这个例子，我选择了一个简单的 echo 服务器，它可以向您发回自己的消息。</p><p id="3572" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过，我们首先应该讨论的是项目布局。我选择了以下目录/文件结构:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8da8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种布局帮助我们清楚地分离<em class="le"> protobuf </em>文件(<code class="fe lf lg lh li b">.../proto</code>)、生成的源代码(<code class="fe lf lg lh li b">.../generated</code>)、实际的源代码和我们的测试套件。要了解更多关于如何用这种布局设置 Python 项目的信息，可以查看我以前的文章:</p><div class="mz na gp gr nb nc"><a rel="noopener follow" target="_blank" href="/ultimate-setup-for-your-next-python-project-179bda8a7c2c"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">下一个 Python 项目的最终设置</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">从零开始任何项目都可能是一项艰巨的任务…但如果您有这个最终的 Python 项目蓝图就不会了！</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq lu nc"/></div></div></a></div><p id="8790" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，要构建 gRPC 服务器，我们首先需要定义<em class="le">消息</em>和<em class="le">服务</em>，它将使用您与客户端进行通信:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0a6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个<code class="fe lf lg lh li b">echo.proto</code>文件中，我们可以看到一个非常简单的消息类型定义——一个用于请求(<code class="fe lf lg lh li b">EchoRequest</code>)，一个用于来自服务器的回复(<code class="fe lf lg lh li b">EchoReply</code>)。然后这些消息被由一个名为<code class="fe lf lg lh li b">Reply</code>的 RPC 方法组成的<code class="fe lf lg lh li b">Echo</code>服务使用。</p><p id="1030" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了能够在 Python 代码中使用这些定义，我们需要生成服务器和客户端接口。为此，我们可以运行以下命令:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ecbf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们指定了相当多的参数。第一个——<code class="fe lf lg lh li b">-I blueprint/proto</code>，告诉<code class="fe lf lg lh li b">grpc_tools</code>在哪里寻找我们的<code class="fe lf lg lh li b">.proto</code>文件(它定义了<code class="fe lf lg lh li b">PATH</code>)。接下来的两个，<code class="fe lf lg lh li b">--python-out</code>和<code class="fe lf lg lh li b">--grpc_python_out</code>分别指定将生成的<code class="fe lf lg lh li b">*_pb2.py</code>和<code class="fe lf lg lh li b">*_grpc_pb2.py</code>文件输出到哪里。最后一个参数——<code class="fe lf lg lh li b">./blueprint/proto/*.proto</code>是指向<code class="fe lf lg lh li b">.proto</code>文件的实际路径——这看起来有些多余，因为我们用<code class="fe lf lg lh li b">-I</code>指定了<code class="fe lf lg lh li b">PATH</code>，但是你需要两者来完成这项工作。</p><p id="8167" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，当您运行这一个命令时，您将在这些生成的文件中结束一些中断的导入。在<code class="fe lf lg lh li b">grpc</code>和<code class="fe lf lg lh li b">protobuf</code>存储库中有多个提出的<a class="ae lj" href="https://github.com/protocolbuffers/protobuf/issues/1491" rel="noopener ugc nofollow" target="_blank">问题</a>，最简单的解决方案是用<code class="fe lf lg lh li b">sed</code>修复那些导入。</p><p id="15a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">写出这个命令不会很愉快，也没有效率，所以我把它包装在<code class="fe lf lg lh li b">make</code> target 中，让你(和我)的生活更轻松。你可以在我的资源库<a class="ae lj" href="https://github.com/MartinHeinz/python-project-blueprint/blob/grpc/Makefile" rel="noopener ugc nofollow" target="_blank">找到完整的<code class="fe lf lg lh li b">Makefile</code>这里</a>。</p><p id="d03e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有相当多的代码是使用这个命令生成的，所以我不会一一查看，但是有一些重要的事情需要注意。这些<code class="fe lf lg lh li b">*_pb2_grpc.py</code>文件中的每一个都有以下三样东西:</p><ul class=""><li id="d79e" class="nr ns it kk b kl km ko kp kr nt kv nu kz nv ld nw nx ny nz bi translated"><em class="le">存根</em>——第一个是<em class="le">存根</em>，在我们的例子中是<code class="fe lf lg lh li b">EchoStub</code>——是客户端用来连接 gRPC 服务的类</li><li id="70de" class="nr ns it kk b kl oa ko ob kr oc kv od kz oe ld nw nx ny nz bi translated"><em class="le">服务器</em>——在我们的例子中是<code class="fe lf lg lh li b">EchoServicer</code>——被服务器用来实现 gRPC 服务</li><li id="9169" class="nr ns it kk b kl oa ko ob kr oc kv od kz oe ld nw nx ny nz bi translated"><em class="le">注册功能</em> —最后一项，<code class="fe lf lg lh li b">add_EchoServicer_to_server</code>需要向 gRPC 服务器注册服务器。</li></ul><p id="2aa3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，让我们检查一下代码，看看如何使用这个生成的代码。</p><p id="247d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们要做的第一件事是实现实际的服务。我们将在<code class="fe lf lg lh li b">grpc.py</code>文件中这样做，在那里我们将保存所有 gRPC 特定的代码:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0263" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面，我们创建了从生成的<code class="fe lf lg lh li b">EchoServicer</code>类继承而来的<code class="fe lf lg lh li b">Echoer</code>类，它包含了<code class="fe lf lg lh li b">.proto</code>文件中定义的所有方法。所有这些方法都旨在我们的实现中被覆盖，这里我们就是这么做的。我们通过返回之前在<code class="fe lf lg lh li b">.proto</code>文件中定义的<code class="fe lf lg lh li b">EchoReply</code>消息来实现唯一的方法<code class="fe lf lg lh li b">Reply</code>。我想指出的是，这里的<code class="fe lf lg lh li b">request</code>参数是<code class="fe lf lg lh li b">EchoReply</code>的一个实例——这就是为什么我们可以从中取出<code class="fe lf lg lh li b">message</code>。这里我们不使用<code class="fe lf lg lh li b">context</code>参数，但是它包含一些有用的特定于 RPC 的信息，比如超时限制。</p><p id="d44c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我还想提到的一个巧妙的特性是，如果您想利用<em class="le">响应流</em>，您可以用<code class="fe lf lg lh li b">yield</code>替换<code class="fe lf lg lh li b">return</code>，并返回多个响应(在<code class="fe lf lg lh li b">for</code>周期中)。</p><p id="5722" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们已经实现了 gRPC 服务，我们想运行它。为此，我们需要一台服务器:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4996" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有这些都只是一个静态方法。它用几个工人从<code class="fe lf lg lh li b">grpc</code>库创建服务器——在本例中是 10 个。之后，它使用前面提到的注册函数(<code class="fe lf lg lh li b">add_EchoServicer_to_server</code>)将我们的<code class="fe lf lg lh li b">Echoer</code>服务绑定到服务器。剩下的 3 行只是添加监听端口，启动服务器并等待中断。</p><p id="ae9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于服务器端来说，剩下的就是<code class="fe lf lg lh li b">__main__.py</code>，因此我们可以将它作为 Python 模块启动:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="775a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们就可以启动服务器了。你可以用<code class="fe lf lg lh li b">python -m blueprint</code>来做，或者如果你用的是我的模板，那么就用<code class="fe lf lg lh li b">make run</code>。</p><p id="2b46" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个正在运行的服务器，但是我们没有办法调用它…这就是客户端调用它的地方。出于演示目的，我们将使用为我们生成的存根用 Python 创建客户机，但是您可以用完全不同的语言编写客户机。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d3d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于客户端，我们只需要一个函数，我们称之为<code class="fe lf lg lh li b">run</code>。在连接服务器之后，它会创建一个存根，允许我们调用服务器方法，这是下一步。它通过传入带有一些有效载荷的<code class="fe lf lg lh li b">EchoRequest</code>消息来调用在服务器端实现的<code class="fe lf lg lh li b">Reply</code>方法。剩下的就是打印了。</p><p id="dad5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们运行客户端，看看是否一切正常:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="03db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而且确实有效！</p><h1 id="b47c" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">使用 Pytest 进行测试</h1><p id="b220" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">正如我所有的小项目和文章一样，在对所有代码进行单元测试之前，我们还没有完成。为了编写这个 gRPC 服务器的示例测试，我将使用<em class="le"> Pytest </em>及其插件<code class="fe lf lg lh li b">pytest-grpc</code>。</p><p id="c8da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们首先来看看用于模拟客户机和服务器之间的请求-响应交换的装置:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="69da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为这些都很简单。只要确保为这些设备使用这些特定的名称，因为这是插件所寻找的。需要注意的一点是<code class="fe lf lg lh li b">grpc_stub</code>中的<code class="fe lf lg lh li b">grpc_channel</code>论证。这是<code class="fe lf lg lh li b">pytest-grpc</code>插件提供的假频道。要了解更多信息，我建议直接去<code class="fe lf lg lh li b">pytest-grpc</code> <a class="ae lj" href="https://github.com/kataev/pytest-grpc/blob/master/pytest_grpc/plugin.py" rel="noopener ugc nofollow" target="_blank">源代码</a>，因为这个插件非常简单。现在，让我们继续实际的测试:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="65c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过利用在上一步中编写的<code class="fe lf lg lh li b">grpc_stub</code> fixture 来创建这个测试。我们创建了传递给<code class="fe lf lg lh li b">grpc_stub.Reply</code>的<code class="fe lf lg lh li b">EchoRequest</code>，后面是简单的<code class="fe lf lg lh li b">assert</code>。并且，当我们运行测试(<code class="fe lf lg lh li b">make run</code>)时:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d24f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过了！我们完成了！</p><h1 id="a805" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结论</h1><p id="9eab" class="pw-post-body-paragraph ki kj it kk b kl ms ju kn ko mt jx kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">如果你从这篇文章中只学到一样东西，那么我认为应该是这样一个事实:当我们决定我们想要用于某个项目的解决方案/技术时，我们应该总是考虑可能的替代方案。并不总是需要 REST 和 JSON。有时 gRPC 可能更符合要求。这种想法也适用于任何其他技术或工具。要查看使用<code class="fe lf lg lh li b">Makefile</code>自动化的完整代码清单、准备好的 Docker 映像，甚至是部署到 Kubernetes 的设置，请查看我的存储库中的<code class="fe lf lg lh li b">grpc</code>分支:<a class="ae lj" href="https://github.com/MartinHeinz/python-project-blueprint/tree/master" rel="noopener ugc nofollow" target="_blank">https://github . com/Martin Heinz/python-project-blue print/tree/master</a>。感谢任何反馈，如果你喜欢这类内容，star 或 fork 也是如此。😉</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="c479" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">本文最初发布于</em><a class="ae lj" href="https://martinheinz.dev/blog/23?utm_source=tds&amp;utm_medium=referral&amp;utm_campaign=blog_post_23" rel="noopener ugc nofollow" target="_blank"><em class="le">martinheinz . dev</em></a></p></div></div>    
</body>
</html>