<html>
<head>
<title>Image recognition with Machine Learning on Python, Image processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 Python 的机器学习图像识别，图像处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-recognition-with-machine-learning-on-python-image-processing-3abe6b158e9a?source=collection_archive---------1-----------------------#2020-05-21">https://towardsdatascience.com/image-recognition-with-machine-learning-on-python-image-processing-3abe6b158e9a?source=collection_archive---------1-----------------------#2020-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0c801d410bec31304d45f7c9cae493f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rZecOAy_WVr16810"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://online.stanford.edu/courses/cs231n-convolutional-neural-networks-visual-recognition" rel="noopener ugc nofollow" target="_blank">在线斯坦福课程</a></p></figure><h2 id="e480" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">作为图像识别的第一步，图像处理对于创建可用于操作图像识别的神经网络的数据集是必不可少的</h2><div class=""/><p id="017a" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">计算机视觉，即机器能够理解图像和视频的领域，是科技行业最热门的话题之一。机器人技术、自动驾驶汽车和面部识别都依赖于计算机视觉来工作。计算机视觉的核心是<em class="ln">图像识别</em>，即识别图像代表什么的任务。</p><p id="15d4" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在执行任何与图像相关的任务之前，几乎总是需要首先处理图像，以使它们更适合作为输入数据。在这篇文章中，我将重点介绍图像处理，特别是我们如何将图像从 JPEG 或 PNG 文件转换为我们的神经网络可用的数据。然后，在其他文章中，我将集中讨论经典卷积神经网络或 ResNet 和 SqueezeNet 等特定网络的实现。</p><p id="5a43" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我将使用的库是 TensorFlow 2.0，因为它提供了各种实用函数来从文件中获取图像数据，调整图像大小，甚至一次性转换大量图像。</p><h1 id="35c6" class="lo lp jj bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">图象档案</h1><p id="40a5" class="pw-post-body-paragraph kp kq jj kr b ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm im bi translated">在我们进行任何图像处理之前，我们需要了解图像文件是如何工作的。具体来说，我们将讨论这些文件如何使用字节数据和像素来表示图像。</p><p id="bc15" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你以前看过一个图像文件的属性，它会显示图像的尺寸，即图像的高度和宽度。高度和宽度基于像素数。例如，如果图像的尺寸为 400x300(宽 x 高)，则图像中的像素总数为 120000。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mr"><img src="../Images/d29cacb9e4db5aa22acd2086a2b24b96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBFPPyf8bsTDSNDNJGlulw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://scoresports.com/giant-40-soccer-ball-no-1790.html" rel="noopener ugc nofollow" target="_blank">足球</a>，<a class="ae jg" href="http://hobieclass.com/focus-on-the-stripes-of-the-tennis-ball/" rel="noopener ugc nofollow" target="_blank">网球</a></p></figure><p id="9f7c" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">足球图像的尺寸为 1710x1980(宽 1710 像素，高 1980 像素)，而网球图像的尺寸为 1024x1024(宽 1024 像素，高 1024 像素)。</p><p id="5e50" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">函数<strong class="kr jt"> tensorflow.io.read_file </strong>将文件名作为其必需的参数，并以张量的形式返回文件内容，类型为<strong class="kr jt"> tensorflow.string </strong>。当输入文件是图像时，<strong class="kr jt">tensor flow . io . read _ file</strong>的输出将是图像文件的原始字节数据。虽然原始字节输出代表图像的像素数据，但不能直接使用。让我们首先看看使用足球图像的 Python 实现。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="6ebc" class="nb lp jj mx b gy nc nd l ne nf">import tensorflow </span><span id="b743" class="nb lp jj mx b gy ng nd l ne nf">values = tf.io.read_file('soccer_ball.jpg')</span></pre><blockquote class="nh ni nj"><p id="df09" class="kp kq ln kr b ks kt ku kv kw kx ky kz nk lb lc ld nl lf lg lh nm lj lk ll lm im bi translated"><strong class="kr jt">像素到底是什么？</strong></p></blockquote><p id="b4e9" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">像素本质上只是图像上的一个点，具有特定的阴影、颜色和/或不透明度。我们通常将一个像素表示为一个整数或多个整数。基于对图像的解释，像素采用特定的形式，通常是以下形式之一:</p><ul class=""><li id="079e" class="nn no jj kr b ks kt kw kx la np le nq li nr lm ns nt nu nv bi translated"><strong class="kr jt"><em class="ln"/></strong>:以黑白阴影的形式查看图像。每个像素都是 0-255 之间的整数，其中 0 表示全黑，255 表示全白。</li><li id="2667" class="nn no jj kr b ks nw kw nx la ny le nz li oa lm ns nt nu nv bi translated"><strong class="kr jt"> <em class="ln"> RGB </em> </strong>:彩色图像的默认解释。每个像素由 0-255 之间的 3 个整数组成，其中整数分别代表像素的红色、绿色和蓝色强度。</li><li id="8e38" class="nn no jj kr b ks nw kw nx la ny le nz li oa lm ns nt nu nv bi translated"><strong class="kr jt"> <em class="ln"> RGBA </em> </strong>:增加了<em class="ln"> alpha </em>字段的 RGB 扩展。alpha 字段表示图像的不透明度，在本实验中，我们将像素的 alpha 值表示为 0-255 之间的整数，其中 0 表示完全透明，255 表示完全不透明。</li></ul><p id="259b" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以选择以任何我们想要的方式来解释一幅图像，但是通常有一种解释是最佳的。例如，我们可以用 RGB 像素值解释黑白图像，但更有效的方法是将其视为灰度图像(使用 3 倍的整数)。另一方面，用灰度像素解释彩色图像是不明智的，因为这些像素无法捕捉任何实际的颜色。</p><h1 id="ea4c" class="lo lp jj bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">图像类型</h1><p id="01e7" class="pw-post-body-paragraph kp kq jj kr b ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm im bi translated">既然已经学习了如何加载图像，那么是时候使用 TensorFlow 将图像数据解码为像素数据了。<br/>我们使用的解码功能取决于图像的格式。对于一般解码(即解码任何图像格式)，我们使用<strong class="kr jt">tensor flow . image . decode _ image</strong>，但是如果输入是 JPEG 图像，我们使用<strong class="kr jt">tensor flow . image . decode _ JPEG</strong>。</p><p id="f4ea" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">既然<strong class="kr jt">tensor flow . image . decode _ image</strong>可以解码任何类型的图像，你可能会奇怪为什么我们还要为其他两个解码函数费心。一个原因是，您可能希望只使用特定的图像格式，在这种情况下，只使用特定格式的解码函数会更有效，对代码清晰度也更好。</p><p id="f86e" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">另一个原因是<strong class="kr jt">tensor flow . image . decode _ image</strong>支持 GIF 解码，结果输出形状为(num_frames，height，width，channels。由于函数可以返回不同形状的数据，当我们还需要用<strong class="kr jt">tensor flow . image . resize _ images</strong>调整图像大小时，我们就不能用<strong class="kr jt">tensor flow . image . decode _ image</strong>(见下一节)。</p><p id="4aae" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在上一节中，我们讨论了图像解释。如果我们只传递<strong class="kr jt">值(见前面的代码)</strong>作为一个解码函数的必需参数，我们使用的是原始图像数据中指定的解释。通常这样做是没问题的，但有时我们希望对像素使用特定的格式。</p><p id="9cd7" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以通过<strong class="kr jt">通道</strong>关键字参数改变解码图像的像素格式。<strong class="kr jt">通道</strong>参数表示每个像素的整数数量。<strong class="kr jt">通道</strong>的默认值为<strong class="kr jt"> 0 </strong>，这意味着解码功能使用原始数据中指定的解释。将<strong class="kr jt">通道</strong>设置为<strong class="kr jt"> 1 </strong>指定灰度图像，而将<strong class="kr jt">通道</strong>设置为<strong class="kr jt"> 3 </strong>指定 RGB 图像。对于 PNG 图像，我们也可以设置<strong class="kr jt">通道</strong>到<strong class="kr jt"> 4 </strong>，对应于 RGBA 图像。将<strong class="kr jt">通道</strong>设置为<strong class="kr jt"> 2 </strong>无效。</p><p id="2537" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有时，我们需要<strong class="kr jt">调整图像</strong>的大小来增加数据。我们用来调整像素数据大小的函数是<strong class="kr jt">tensor flow . image . resize _ images</strong>。它接受两个必需的参数:原始图像的解码数据和图像的新大小，图像的新大小是两个整数的元组/列表，依次表示<strong class="kr jt"> new_height </strong>和<strong class="kr jt"> new_width </strong>。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5ec4" class="nb lp jj mx b gy nc nd l ne nf">def <strong class="mx jt">decode_image</strong>(filename, image_type, resize_shape, channels):<br/>    value = tensorflow.io.read_file(filename)<br/>    if image_type == 'png':<br/>        decoded_image = tensorflow.image.decode_png(value, channels=channels)<br/>    elif image_type == 'jpeg':<br/>        decoded_image = tensorflow.image.decode_jpeg(value, channels=channels)<br/>    else:<br/>        decoded_image = tensorflow.image.decode_image(value, channels=channels)<br/>    <br/>    if resize_shape is not None and image_type in ['png', 'jpeg']:<br/>        decoded_image = tf.image.resize(decoded_image, resize_shape)<br/>    <br/>    return decoded_image</span></pre><h1 id="734c" class="lo lp jj bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">资料组</h1><p id="49b8" class="pw-post-body-paragraph kp kq jj kr b ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm im bi translated">通常，当我们执行与图像相关的任务时，我们会处理大量的图像数据。在这种情况下，最好使用 TensorFlow 数据集，即<strong class="kr jt">tensor flow . data . dataset</strong>来存储所有图像。我们可以使用<strong class="kr jt"> from_tensor_slices </strong>函数创建数据集。</p><p id="d517" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kr jt">数据集</strong>类使得使用所有图像文件执行任务变得更加容易和高效。在我们用图像文件创建数据集之后，我们需要将每个文件的内容解码成可用的像素数据。由于<strong class="kr jt"> decode_image </strong>函数适用于单个图像文件，我们将需要使用数据集对象的<strong class="kr jt">映射</strong>函数来将<strong class="kr jt"> decode_image </strong>应用于我们数据集中的每个图像文件。</p><p id="2e72" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kr jt"> map </strong>函数的输出是一个新的数据集，其中每个元素现在都从原始图像文件转换为其相应的像素数据。我们使用 map 而不是使用 for 循环来手动转换每个图像文件，因为 map 跨文件并行进行图像解码，这使它成为更有效的解决方案。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="4104" class="nb lp jj mx b gy nc nd l ne nf">import tensorflow as tf</span><span id="7131" class="nb lp jj mx b gy ng nd l ne nf">def <strong class="mx jt">get_dataset</strong>(image_paths, image_type, resize_shape, channels):<br/>    filename_tensor = tf.constant(image_paths)<br/>    dataset = tf.data.Dataset.from_tensor_slices(filename_tensor)<br/>    <br/>    def <strong class="mx jt">_map_fn</strong>(filename):<br/>        decode_images = decode_image(filename, image_type, resize_shape, channels=channels)<br/>        return decode_images<br/>    <br/>    map_dataset = dataset.map(_map_fn) # we use the map method: allow to apply the function _map_fn to all the <br/>    # elements of dataset <br/>    return map_dataset</span></pre><h1 id="e6d9" class="lo lp jj bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">迭代程序</h1><p id="2c1d" class="pw-post-body-paragraph kp kq jj kr b ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm im bi translated">我们从数据集中提取解码图像数据的方法是通过一个<strong class="kr jt"> tensorflow.data.Iterator </strong>。我们使用<strong class="kr jt"> get_next </strong>函数获得一个<em class="ln">下一个元素张量</em>，用于数据提取。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="47d9" class="nb lp jj mx b gy nc nd l ne nf">def get_image_data(image_paths, image_type, resize_shape, channels):<br/>    dataset = get_dataset(image_paths, image_type, resize_shape, channels)<br/>    iterator = tf.compat.v1.data.make_one_shot_iterator(dataset)<br/>    next_image = iterator.get_next()<br/>    <br/>    return next_image</span></pre><h1 id="f6da" class="lo lp jj bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">执行</h1><p id="1a1f" class="pw-post-body-paragraph kp kq jj kr b ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm im bi translated">现在，如果我们将所有步骤收集在一起，并将其应用于足球图片，我们最终会得到以下结果:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/041aa65efa1cbd8cbb9d65cafd713f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ltxZJ8Uvo3ym0BXWc2uMwg.png"/></div></div></figure><p id="ac1e" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这种情况下，数据集仅由一幅图像组成。get_image_data 的输出是一个大小为 1980x1710x3 的数组，因为它是像素为 1980x1710 的 RGB 图片。然后我们得到每个像素的值。</p><p id="2374" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦我们为数据集的所有图像完成了这一处理步骤，下一步就是创建我们的神经网络，并用我们的数据集来填充它，以便学习如何识别一些模式、对象、现象…</p><h1 id="f05b" class="lo lp jj bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">未完待续…</h1><p id="5fc1" class="pw-post-body-paragraph kp kq jj kr b ks mm ku kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm im bi translated">在本文中，我解决了图像识别的第一部分，即<strong class="kr jt">图像处理。这是一项重要但并不容易实现的任务。我们数据集的质量对我们神经网络算法的性能有很大的影响。</strong></p><p id="4d4c" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我希望你在这篇文章中找到了你来这里的目的，并在接下来的图像识别之旅中与我在一起！</p><p id="1326" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你喜欢阅读这样的故事，并想支持我成为一名作家，考虑注册成为一名灵媒成员。每月 5 美元，你可以无限制地阅读媒体上的故事。如果你注册使用<a class="ae jg" href="https://medium.com/@jonathan_leban/membership" rel="noopener">我的链接</a>，我会赚一小笔佣金，你仍然要支付 5 美元。谢谢大家！！</p><div class="is it gp gr iu oc"><a href="https://medium.com/@jonathan_leban/membership" rel="noopener follow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd jt gy z fp oh fr fs oi fu fw js bi translated">通过我的推荐链接加入媒体-乔纳森·莱班</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">阅读乔纳森·莱班的每一个故事(以及媒体上成千上万的其他作家)。您的会员费直接支持…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">medium.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ja oc"/></div></div></a></div><p id="962d" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln"> PS:我目前是伯克利的工程硕士学生，如果你想讨论这个话题，请随时联系我。</em> <a class="ae jg" href="http://jonathan_leban@berkeley.edu/" rel="noopener ugc nofollow" target="_blank"> <em class="ln">这里的</em> </a> <em class="ln">是我的邮箱。</em></p></div></div>    
</body>
</html>