<html>
<head>
<title>TensorFlow vs PyTorch — Linear Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow 与 PyTorch —线性回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tensorflow-vs-pytorch-linear-regression-e07781a83525?source=collection_archive---------21-----------------------#2020-05-23">https://towardsdatascience.com/tensorflow-vs-pytorch-linear-regression-e07781a83525?source=collection_archive---------21-----------------------#2020-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">TensorFlow 和 PyTorch 框架中线性回归的实现及其结果的比较</h2></div><p id="4363" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你是深度学习和神经网络的新手，那么你一定遇到过术语“<strong class="kk iu"> TensorFlow </strong>”和“<strong class="kk iu"> PyTorch </strong>”。这是在数据科学领域使用的两个流行的深度学习框架。</p><p id="d2e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本练习中，我将向您展示使用两种框架实现最简单的<strong class="kk iu"> <em class="le">神经网络</em> </strong> ( <strong class="kk iu"> <em class="le">线性回归</em> </strong>)并比较它们的结果。</p><h2 id="30a2" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">起源-</h2><p id="22f4" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated"><em class="le"> PyTorch </em>是基于 Torch 库的开源机器学习库。PyTorch 最初是由脸书的人工智能研究实验室(FAIR)开发的。这是一个免费的开源软件。</p><p id="8245" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，<em class="le"> TensorFlow </em>由<em class="le">谷歌大脑</em>团队开发，用于谷歌内部研究目的。它广泛用于机器学习应用，如神经网络。它也是一个免费的开源软件。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi md"><img src="../Images/392637dfd256744ad2357137ce7ddc09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*zwNPmOBLvkJ4RzAEWLnFCg.jpeg"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">TensorFlow vs PyTorch(图片来自<a class="ae mp" href="https://medium.com/@UdacityINDIA/tensorflow-vs-pytorch-79e7a23f48c5" rel="noopener">来源</a></p></figure><p id="956e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比较两个框架最有效的方法是同时使用它们并分析它们的结果来解决同一个问题。在本练习中，我们将使用<strong class="kk iu"> <em class="le"> TensorFlow </em> </strong>和<strong class="kk iu"> <em class="le"> PyTorch </em> </strong>框架执行<strong class="kk iu"> <em class="le">线性回归</em> </strong>，并比较它们的结果。</p><h2 id="e869" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">问题-</h2><p id="eeb8" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">在这个练习中，我们将使用一个非常简单的例子。这里给我们一个数字数组，<strong class="kk iu"> x= [-1.0，0.0，1.0，2.0，3.0，4.0] </strong>和<strong class="kk iu"> y= [-3.0，-1.0，1.0，3.0，5.0，7.0] </strong>。这里用到的公式是<strong class="kk iu"> y = 2*x -1 </strong>，这是一个线性回归。</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="ed30" class="lf lg it mr b gy mv mw l mx my">x= [-1.0, 0.0, 1.0, 2.0, 3.0, 4.0]<br/>y= [-3.0, -1.0, 1.0, 3.0, 5.0, 7.0]</span><span id="f69f" class="lf lg it mr b gy mz mw l mx my">y = 2*x -1</span></pre><p id="62d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在使用这两个框架训练线性回归模型时，我们将为 x=10 输入一个新值，并查看模型对 y 的预测。</p><h2 id="9a73" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">张量流框架-</h2><p id="b5ad" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">首先，我们将通过张量流框架。</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="na nb l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">张量流—线性回归</p></figure><p id="7b3c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是使用<strong class="kk iu"> <em class="le"> keras </em> </strong>库用 TensorFlow 执行线性回归的代码。让我们仔细检查上面程序中的每个代码块。</p><p id="68d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一步，我们将<em class="le">导入</em>库。</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="ead1" class="lf lg it mr b gy mv mw l mx my">import tensorflow as tf<br/>import numpy as np<br/>from tensorflow import keras</span></pre><p id="cfb9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一步中，我们使用<em class="le">序列、</em>设计我们的模型，它是层的线性堆栈。在这个模型中，我们只使用了一层(神经元)。</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="20d5" class="lf lg it mr b gy mv mw l mx my">model = tf.keras.Sequential([keras.layers.Dense(units=1, input_shape=[1])])</span></pre><p id="664f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二步，我们定义我们的<em class="le">优化器</em>和<em class="le">损失</em>函数来训练我们的神经网络模型。在此，我们使用随机梯度下降(<strong class="kk iu"> <em class="le"> SDG </em> </strong>)优化器和均方误差(<strong class="kk iu"> <em class="le"> MSE </em> </strong>)作为我们的损失函数。</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="c46d" class="lf lg it mr b gy mv mw l mx my">model.compile(optimizer='sgd', loss='mean_squared_error')</span></pre><p id="1e42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一步之后，我们用两个变量"<strong class="kk iu"><em class="le">【xs】</em></strong>"和"<strong class="kk iu"> <em class="le"> ys </em> </strong>"初始化我们的数字。</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="afa1" class="lf lg it mr b gy mv mw l mx my">xs = np.array([-1.0,  0.0, 1.0, 2.0, 3.0, 4.0], dtype=float)<br/>ys = np.array([-3.0, -1.0, 1.0, 3.0, 5.0, 7.0], dtype=float)</span></pre><p id="f07f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最后一步，我们用变量“xs”和“ys”来拟合我们的模型。我们用<strong class="kk iu"> <em class="le"> 500 个历元</em> </strong>训练模型。</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="ddc1" class="lf lg it mr b gy mv mw l mx my">model.fit(xs, ys, epochs=500)</span><span id="d9d4" class="lf lg it mr b gy mz mw l mx my">&gt;&gt;Epoch 500/500<br/>1/1 [==============================] - 0s 1ms/step - loss: 5.1584e-05</span></pre><p id="a5a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这最后一步，我们预测新的<strong class="kk iu"> <em class="le"> xs = 10 </em> </strong>的值。根据公式，y=2*x-1，对于 xs=10，我们得到一个值<strong class="kk iu"> <em class="le"> 19 </em> </strong>。现在让我们看看我们的模型使用 TensorFlow 框架预测创造了什么价值。</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="5246" class="lf lg it mr b gy mv mw l mx my">print(model.predict([10.0]))</span><span id="4751" class="lf lg it mr b gy mz mw l mx my">&gt;&gt;[[<strong class="mr iu">18.979048</strong>]]</span></pre><p id="dfcf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到，使用 TensorFlow 框架设计的线性回归模型，我们得到了接近 19 的值。</p><h2 id="9562" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">PyTorch 框架</h2><p id="6289" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">现在让我们看看使用 PyTorch 框架设计的线性回归模型。</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="na nb l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">PyTorch —线性回归</p></figure><p id="1688" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与 TensorFlow 模型相比，线性回归的 PyTorch 应用确实<em class="le">大</em>且<em class="le">复杂</em>。让我们分析模型的每一步。</p><p id="9b1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一步，我们<em class="le">导入</em>设计线性回归模型所需的库。</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="6b27" class="lf lg it mr b gy mv mw l mx my">import torch<br/>from torch.autograd import Variable</span></pre><p id="dd2d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一步中，我们将初始化与 TensorFlow 模型中定义的“<strong class="kk iu"><em class="le">【xs】</em></strong>”和“<strong class="kk iu"> <em class="le"> ys </em> </strong>”相同的值。对于 PyTorch 应用程序，我们使用适当的函数将列表转换为张量<em class="le"/><strong class="kk iu"><em class="le"/></strong>。</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="b3a4" class="lf lg it mr b gy mv mw l mx my">xs = [[-1.0],  [0.0], [1.0], [2.0], [3.0], [4.0]]<br/>ys = [[-3.0], [-1.0], [1.0], [3.0], [5.0], [7.0]]<br/>xs = Variable(torch.Tensor(xs))<br/>ys = Variable(torch.Tensor(ys))</span></pre><p id="220c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这之后，我们定义一个类'<strong class="kk iu"> LinearRegressionModel </strong>'，我们将使用它来定义我们的模型。由于这是一个具有 1 个输入和 1 个输出的简单线性回归，我们使用输入和输出维度都等于 1 的线性模型。最后，我们使用上面定义的类创建一个“<strong class="kk iu"> <em class="le">模型</em> </strong>”。</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="d5cd" class="lf lg it mr b gy mv mw l mx my"><strong class="mr iu">class</strong> <strong class="mr iu">LinearRegressionModel</strong>(torch.nn.Module): <br/>  <br/>    <strong class="mr iu">def</strong> __init__(self): <br/>        super(LinearRegressionModel, self).__init__() <br/>        self.linear = torch.nn.Linear(1, 1)  <em class="le"># One in and one out </em><br/>  <br/>    <strong class="mr iu">def</strong> forward(self, x): <br/>        y_pred = self.linear(x) <br/>        <strong class="mr iu">return</strong> y_pred <br/><br/>model = LinearRegressionModel()</span></pre><p id="2b4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们选择优化器和损失标准。我们选择了与 TensorFlow 应用程序相同的函数，即优化器的<strong class="kk iu"> <em class="le"> SDG </em> </strong>函数和损失函数的<strong class="kk iu"> <em class="le"> MSE </em> </strong>。此外，我们任意地将<em class="le">学习率</em>固定为 0.01。</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="abc4" class="lf lg it mr b gy mv mw l mx my">criterion = torch.nn.MSELoss(size_average = <strong class="mr iu">False</strong>) <br/>optimizer = torch.optim.SGD(model.parameters(), lr = 0.01)</span></pre><p id="24a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在到达我们的训练步骤。在这一阶段，我们为<strong class="kk iu"> <em class="le"> 500 </em> </strong>迭代执行三项任务，因为我们将历元值设置为 500。</p><ol class=""><li id="558f" class="nc nd it kk b kl km ko kp kr ne kv nf kz ng ld nh ni nj nk bi translated">通过传递数据并预测每个 xs 的 ys 值，执行<em class="le">正向传递</em>。</li><li id="ee36" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">使用 MSE 损失函数计算<em class="le">损失</em>。</li><li id="cc8b" class="nc nd it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">将所有梯度重置为 0，执行<em class="le">反向传播</em>，最终更新权重。</li></ol><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="1afe" class="lf lg it mr b gy mv mw l mx my"><strong class="mr iu">for</strong> epoch <strong class="mr iu">in</strong> range(500): <br/>  <br/>    <em class="le"># Forward pass: Compute predicted y by passing  </em><br/>    <em class="le"># x to the model </em><br/>    pred_y = model(xs) <br/>  <br/>    <em class="le"># Compute and print loss </em><br/>    loss = criterion(pred_y, ys) <br/>  <br/>    <em class="le"># Zero gradients, perform a backward pass,  </em><br/>    <em class="le"># and update the weights. </em><br/>    optimizer.zero_grad() <br/>    loss.backward() <br/>    optimizer.step() <br/>    print('epoch <strong class="mr iu">{}</strong>, loss <strong class="mr iu">{}</strong>'.format(epoch, loss.item()))</span><span id="39fd" class="lf lg it mr b gy mz mw l mx my">&gt;&gt;epoch 499, loss 5.151434834260726e-13</span></pre><p id="fc7f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们使用这个模型预测新的 xs=10 的值。如前所述，我们必须得到一个接近 19 的值。现在让我们看看 PyTorch 模型的输出。</p><pre class="me mf mg mh gt mq mr ms mt aw mu bi"><span id="603a" class="lf lg it mr b gy mv mw l mx my">new_var = Variable(torch.Tensor([[10.0]])) <br/>pred_y = model(new_var) <br/>print(model(new_var).item())</span><span id="9ee0" class="lf lg it mr b gy mz mw l mx my">&gt;&gt;<strong class="mr iu">18.999998092651367</strong></span></pre><p id="3a74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到使用 PyTorch 框架构建的线性回归模型也给出了接近 19 的值。</p><h2 id="b705" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">比较-</h2><p id="9a5b" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">在可视化从 TensorFlow 和 PyTorch 模型获得的结果时，我们看到 TensorFlow 模型给我们的结果是<strong class="kk iu"> <em class="le"> 18.979048 </em> </strong>，而 PyTorch 模型给我们的结果是<strong class="kk iu"><em class="le">18.998092651367</em>。</strong></p><p id="49c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">张量流模型— 18.979048 </em> </strong></p><p id="6331" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le"> PyTorch 型号—18.99998092651367</em></strong></p><p id="f548" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以清楚地看到，使用 PyTorch 框架构建的非常简单的神经网络比使用 TensorFlow 框架构建的模型具有更高的精确度。然而，PyTorch 模型本质上更复杂，初学者很难理解。</p><p id="7c95" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你对深度学习和神经网络完全陌生，我会建议你们从 TensorFlow 框架开始，然后在获得前者的经验后再转向 PyTorch 框架。</p><p id="72a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我附上了代码的详细版本。ipynb ),供您参考。</p><div class="nq nr gp gr ns nt"><a href="https://github.com/mk-gurucharan/TensorFlow-vs-PyTorch-Linear-Regression-/" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">MK-gurucharan/tensor flow-vs-py torch-线性回归-</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">这个库包含使用 TensorFlow 对 Python 中的数组执行线性回归的基本代码…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">github.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh mj nt"/></div></div></a></div><p id="7821" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望我能够使用今天在深度学习中使用的两个最流行的框架来解释和演示简单神经网络(线性回归模型)的实现。到那时，快乐的机器学习！</p></div></div>    
</body>
</html>