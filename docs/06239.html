<html>
<head>
<title>AI, Cluster Analysis of Categorical Data (Part I)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分类数据的聚类分析(上)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ai-cluster-analysis-of-categorical-data-part-i-8e702ca6675b?source=collection_archive---------46-----------------------#2020-05-19">https://towardsdatascience.com/ai-cluster-analysis-of-categorical-data-part-i-8e702ca6675b?source=collection_archive---------46-----------------------#2020-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9e07" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">CRL元卡片组的聚类分析</h2><div class=""/><div class=""><h2 id="99a9" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用Clash Royale原始数据提取最新的元卡片组</h2></div><p id="98a0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">* * *代码在Clash Royale介绍之后开始:如果您不感兴趣，请跳过</p><p id="5bac" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我的资料库里有完整的代码。笔记本名为:CRL_Clustering。</p><p id="722f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在本文中，我将创建一个人工智能，给定一个Clash Royale匹配的数据集，它将识别哪些是主要的聚类。所有数据都是分类的，因此我不会使用传统的因子分析技术，而是使用K-Node算法。</p><h1 id="07e9" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">视频游戏中的元卡片组介绍</h1><p id="5525" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">在解释我将要创建的人工智能背后的代码之前，我需要澄清什么是元甲板，以及它们如何与这个项目相关。专业的电子游戏玩家已经把对竞技电子游戏的研究变成了一门真正的学科。</p><p id="50b7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在视频游戏中，你需要从一堆卡片中准备你的牌组，有大量的可能组合，从这个可能性的海洋中出现了一小批帮助玩家获得竞争优势的组合:所谓的<strong class="kt jd">元牌组</strong>。</p><p id="5766" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我将创建一个人工智能，可以找到哪些是在名为皇家冲突的竞争游戏中使用的元甲板，从原始数据中提取它们。</p><h2 id="2ad0" class="ml lp it bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me iz bi translated">皇家冲突，选择8张牌</h2><p id="5eff" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">在这个游戏中有98张卡(直到2020年5月，游戏每隔几个月增加一张卡)。每个玩家必须组成一副8张牌，与其他玩家对战。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/05c2d7d67260cfc8914d5d02979e8463.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*vQ1IKwJEUpFza-KVYH-UXQ.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">由8张牌组成的一副牌的例子，从:【www.theclashify.com】T4检索</p></figure><h2 id="e4fc" class="ml lp it bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me iz bi translated">有多少副牌？</h2><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/690615d4b6d35aed2e4ed6d232f863e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*PFyV_gUsUmGOWniOT7qXlw.png"/></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">简单组合的公式</p></figure><p id="3b15" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">可能的套牌数量是<strong class="kt jd"> 6345015248033280，</strong>顶级玩家从这些组合中找出元套牌。元牌经常变化，所以职业玩家需要保持更新，继续研究游戏。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/6e8616847d75e9272263af1aae0750cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U366o04YNqHsPYMX88pMFw.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">皇家竞技对决中著名的元牌示例，图片来自<a class="ae ln" href="http://www.statsroyale.com" rel="noopener ugc nofollow" target="_blank">www.statsroyale.com</a></p></figure><h1 id="ec93" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">meta套牌是怎么诞生的？</h1><p id="f59b" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">不幸的是，没有数学方法来确定哪些是最好的套牌。冠军拥有的唯一可能性是尝试他们中的许多人，看看哪一个比其他球员表现得更好。</p><p id="decd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从本质上讲，通过不断的迭代，元牌是那些允许顶级玩家持续获胜的牌，因此允许他们在竞争对手的等级中攀升至顶级。因此，这些特定的套牌在社区中数百万场比赛中幸存了下来。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi no"><img src="../Images/bae37f97db0c5cec985ae9f22d0e54de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdgsiJzjrAdCMETFKEfJhw.png"/></div></div></figure><p id="9648" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如你所看到的，在某件事情上变得优秀，即使是在电子游戏上，也需要很多努力、承诺和学习。</p><h1 id="f255" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">玩家如何知道哪些是元套牌？</h1><p id="b69f" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">最后，玩家社区(不仅仅是前100名)如何找出每个赛季的元套牌？由于使用了Youtube、脸书小组和www.statsroyale.com等皇家冲突的统计网站，人们可以看到顶级玩家玩什么以及他们的胜率。然后，这些套牌被社区中的所有玩家复制和使用，无论是普通玩家还是专家，直到职业玩家级别。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi np"><img src="../Images/c6638df9ce172c78f0b466466fe1a5c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CbJ0ne-Gt1wSwgL4XArUyA.jpeg"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">检索自:【https://clashroyale.fandom.com/wiki/2v2 T2】</p></figure><h1 id="08a8" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">使用聚类从原始数据中提取元数据组</h1><p id="8c5f" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">现在让我们假设我们对这款电子游戏一无所知，也不知道这一季的主打牌是什么。我拥有近700场顶级球员的比赛(669场)。</p><p id="41a1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我的人工智能要做的是找出哪些牌组被玩得更一致，并隔离它们。</p><h2 id="52b1" class="ml lp it bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me iz bi translated">变异问题</h2><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nq"><img src="../Images/a98ae77d63646616e7b20324da549c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T12eM7o_XVxokHlH0TOskA.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">原始meta-deck的一个常见变体:X-Bow，从www.statsroyale.com<a class="ae ln" href="http://www.statsroyale.com" rel="noopener ugc nofollow" target="_blank">取回的图像</a></p></figure><p id="9350" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们记住，任何人都可以编辑他们的卡片组，所以玩家可以很容易地创建一个元卡片组的独特变体，我们不想在计算中考虑它，所以我们需要一个算法来找出哪些是原始卡片组，而不是变体。我们假设变奏曲会以较低的频率播放，而原始牌组会以最高的频率播放。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nr"><img src="../Images/1603fd2b0605e48b7806feaa1e5190dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yf_KWWhN1iQ2EJrgST_J1w.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">变化的层次</p></figure><p id="97ae" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在元牌的层级中，由于数百万玩家可能的变化和实验的频率，变化的程度可以达到数百个深度。</p><p id="ad8c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">整个程序</strong></p><ol class=""><li id="298f" class="ns nt it kt b ku kv kx ky la nu le nv li nw lm nx ny nz oa bi translated">使用API下载匹配数据集</li><li id="ebf6" class="ns nt it kt b ku ob kx oc la od le oe li of lm nx ny nz oa bi translated">预处理:对每一行进行个性化排序</li><li id="b851" class="ns nt it kt b ku ob kx oc la od le oe li of lm nx ny nz oa bi translated">预处理:整个数据集的标签编码</li><li id="21be" class="ns nt it kt b ku ob kx oc la od le oe li of lm nx ny nz oa bi translated">预处理:整个数据集的one_hot编码</li><li id="8c32" class="ns nt it kt b ku ob kx oc la od le oe li of lm nx ny nz oa bi translated">执行聚类分析</li><li id="513f" class="ns nt it kt b ku ob kx oc la od le oe li of lm nx ny nz oa bi translated">训练K节点算法</li><li id="6abb" class="ns nt it kt b ku ob kx oc la od le oe li of lm nx ny nz oa bi translated">调整聚类数以获得准确的结果</li><li id="2ad3" class="ns nt it kt b ku ob kx oc la od le oe li of lm nx ny nz oa bi translated">估计最高元牌组</li></ol><p id="1dee" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在本文中，我将讨论第3步:对整个数据集进行标签编码。在教程的下一部分，我将完成人工智能。</p><h1 id="5152" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">1.匹配数据集</h1><p id="c3b0" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">为了方便起见，我<a class="ae ln" href="https://github.com/arditoibryan/Projects/tree/master/20200518_CRL" rel="noopener ugc nofollow" target="_blank">已经下载并准备了数据集</a>，我们将使用它对分类数据进行聚类。如果您希望下载您自己的Clash Royale比赛数据集，请<a class="ae ln" href="https://medium.com/towards-artificial-intelligence/clash-royale-api-looping-query-for-data-collection-2a6ed6a505d4" rel="noopener">按照这个完整的指南来创建一个下载数据的API。</a></p><pre class="mx my mz na gt og oh oi oj aw ok bi"><span id="0b39" class="ml lp it oh b gy ol om l on oo">X = pd.read_csv('/content/drive/My Drive/Colab Notebooks/CRL daily collector/CRL (1).csv')</span></pre><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi op"><img src="../Images/d8dfee3ff10c1cbf35d518fd6b3f7d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a5zCYxZjcFeIHYcXtzVI9g.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">查看CRL.csv</p></figure><p id="26c6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">目前，数据集包含了太多的信息:我们需要去掉所有不包含关于球员n. 2的数据的列。原因是我下载了被选为玩家n.1的几个玩家的最近25场游戏。一个玩家通常玩一个原型，如果我们的整个数据集重复包含单个用户玩的牌组的比例太高，我们的数据集中元牌组的方差将会大大降低。</p><pre class="mx my mz na gt og oh oi oj aw ok bi"><span id="f1de" class="ml lp it oh b gy ol om l on oo">X = X[['p2.card_1', 'p2.card_2', 'p2.card_3', 'p2.card_4', 'p2.card_5', 'p2.card_6', 'p2.card_7', 'p2.card_8']]<br/>X</span></pre><p id="69a7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将只查看玩家n. 2的牌组列表。</p><p id="c452" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">* * *在我的例子中，我将数据与我的Google Drive连接。您应该根据存储您的的位置编辑第一行。csv文件。</p><h1 id="6171" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">2.预处理:订购套牌</h1><p id="e2e6" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">不幸的是，我们收集的数据非常混乱。每一行中的牌的顺序对应于一场比赛中打出的牌的顺序。玩家可以开始使用军队，但也可以开始使用法术。为了看得更清楚，我们需要按照特定的顺序将卡片分类。</p><p id="11c4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">* * *特征的顺序不影响最终结果。然而，我相信这一步是必要的，以便清楚和全面地看到最终结果。</p><h2 id="dc21" class="ml lp it bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me iz bi translated">将每张卡转换成它的类型</h2><p id="e994" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">在游戏中，基本上有四种类型的卡。它们被概念化，以允许人们创建适当的甲板。</p><ul class=""><li id="0aee" class="ns nt it kt b ku kv kx ky la nu le nv li nw lm oq ny nz oa bi translated">获胜条件</li><li id="0527" class="ns nt it kt b ku ob kx oc la od le oe li of lm oq ny nz oa bi translated">部队</li><li id="d2fb" class="ns nt it kt b ku ob kx oc la od le oe li of lm oq ny nz oa bi translated">建筑物</li><li id="383c" class="ns nt it kt b ku ob kx oc la od le oe li of lm oq ny nz oa bi translated">拼写</li></ul><p id="92a5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因为我所拥有的数据集没有显示卡片的类型，所以我们需要创建一个能够将每张卡片转换为其相应类型的算法。</p><h2 id="faa3" class="ml lp it bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me iz bi translated">例子</h2><p id="2cd5" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">这就是我所说的将每张卡映射到其类型的意思:使用下面的模拟列表:</p><pre class="mx my mz na gt og oh oi oj aw ok bi"><span id="2577" class="ml lp it oh b gy ol om l on oo">['Zap', 'Knight', 'Giant', 'Earthquake', 'Musketeer', 'Ice Spirit', 'Skeletons']</span></pre><p id="335f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">…相应的类型将是:</p><pre class="mx my mz na gt og oh oi oj aw ok bi"><span id="9a7c" class="ml lp it oh b gy ol om l on oo">['Spell', 'Troop', 'Troop', 'Win Condition', 'Spell', 'Troop',   'Troop', 'Troop']</span></pre><h2 id="b10a" class="ml lp it bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me iz bi translated">转换算法</h2><p id="b8fe" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">我创建了一个名为CRL_Cards_Classification.csv的. csv文件，该文件将每个现有的卡与其对应的类型进行映射。</p><pre class="mx my mz na gt og oh oi oj aw ok bi"><span id="1260" class="ml lp it oh b gy ol om l on oo">#https://docs.google.com/spreadsheets/d/1wIH69gfuCCoPRoWOIyUqQHMKkUfpb4GAxUbBYX8PwRc/edit#gid=1477229539<br/>C = pd.read_csv('/content/drive/My Drive/Colab Notebooks/CRL daily collector/CRL_Cards_Classification.csv')</span><span id="4796" class="ml lp it oh b gy or om l on oo">cards_classifier = C.copy()<br/>#getting rid of the first column, useless<br/>cards_classifier.pop('Type_1')<br/>cards_classifier = cards_classifier.values.transpose()<br/>cards_classifier</span><span id="d6c5" class="ml lp it oh b gy or om l on oo">def order_row(list1):<br/>  #mapping input list made of cards with their type<br/>  card_dictionary = dict(zip(cards_classifier[0],   cards_classifier[1]))<br/>  card_dictionary</span><span id="172b" class="ml lp it oh b gy or om l on oo">list_tot_classification = list()<br/>  for m in list1:<br/>    a = card_dictionary.get(m)<br/>    list_tot_classification.append(a)<br/>  list_tot_classification</span></pre><h2 id="fa2e" class="ml lp it bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me iz bi translated">个性化排序</h2><p id="3458" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">对于数据集中的每一副牌，我希望所有的牌都按顺序排列:胜利条件，队伍，建筑，法术。</p><p id="6958" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为此，我们将首先为每种类型分配一个升序值，这样我们就知道哪种类型最先出现:</p><pre class="mx my mz na gt og oh oi oj aw ok bi"><span id="0cf3" class="ml lp it oh b gy ol om l on oo">class_dict = {'Win Condition': 0, 'Troop': 1, 'Building': 2, 'Spell': 3}<br/>  list_tot_num = list()<br/>  for m in list_tot_classification:<br/>    a = class_dict.get(m)<br/>    list_tot_num.append(a)</span><span id="ff9b" class="ml lp it oh b gy or om l on oo">ordered_list = [x for _,x in sorted(zip(list_tot_num, list1))]<br/>  return ordered_list</span></pre><h2 id="c844" class="ml lp it bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me iz bi translated">例子</h2><pre class="mx my mz na gt og oh oi oj aw ok bi"><span id="3387" class="ml lp it oh b gy ol om l on oo">list1 = ['Arrows', 'Baby Dragon',  'Bomber', 'Golem',  'Lightning',  'Mega Minion',  'Mini P.E.K.K.A', 'Night Witch', 'Cannon']<br/>ordered_list = order_row(list1)</span></pre><p id="8bf4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">会变成:</p><pre class="mx my mz na gt og oh oi oj aw ok bi"><span id="2237" class="ml lp it oh b gy ol om l on oo">ordered_list<br/>['Golem',  'Baby Dragon',  'Bomber',  'Mega Minion',  'Mini P.E.K.K.A',  'Night Witch',  'Cannon',  'Arrows',  'Lightning']</span></pre><h1 id="1a92" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">3.预处理:对整个数据集进行排序</h1><pre class="mx my mz na gt og oh oi oj aw ok bi"><span id="fcf7" class="ml lp it oh b gy ol om l on oo">#sort each row in the dataset based on type order<br/>for c in range(len(X.values)):<br/>X.values[c] = order_row(X.values[c])<br/>X = pd.DataFrame(e.X.values)</span></pre><p id="0dd8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">* * *如果我们想按字母顺序对列表进行排序，我们将使用下面的代码，而不是order_now</p><pre class="mx my mz na gt og oh oi oj aw ok bi"><span id="db1b" class="ml lp it oh b gy ol om l on oo">X.values[c] = sorted(X.values[c])</span></pre><h1 id="b6ae" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">3.预处理:标注整个数据集</h1><p id="d86b" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">现在，我们已经根据易于理解的层次结构对数据集进行了排序，我们可以开始对其进行预处理。我们现在将标记整个数据集，稍后您会明白为什么，这将比标记单个行更有问题。</p><p id="dc82" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通常，工程师使用scikit-learn工具来轻松标记分类数据。不幸的是，scikit-learn和其他工具一次只允许标记一列。这是一个例子，说明为什么它可以代表一个<strong class="kt jd">问题</strong>:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi os"><img src="../Images/80dddf0133a22dc500a09c75e86149d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcnQT1wAEyeoPXL2gMIQ5Q.png"/></div></div></figure><p id="9c90" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">可以看到，在第一列b = 1，在第二列b = 0。原因是该算法将标签应用于每个<strong class="kt jd">单独的列</strong>，而不考虑其他列中的值。</p><h2 id="5536" class="ml lp it bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me iz bi translated">正确的标签</h2><p id="a069" class="pw-post-body-paragraph kr ks it kt b ku mg kd kw kx mh kg kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">为了获得准确的标注，我们需要将所有内容平铺到一列中，然后应用标注并重新构建初始数据集:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ot"><img src="../Images/c4fc99aa5f59c8f9072eb8c3409a828f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KGE0I0uJ8Or2jUiA3pcgyQ.png"/></div></div></figure><p id="9a4e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这将使用下面的代码来执行:</p><pre class="mx my mz na gt og oh oi oj aw ok bi"><span id="9357" class="ml lp it oh b gy ol om l on oo">#flat everything in one list<br/>one_row = list()<br/>for k in e.X.values:<br/>for n in k:<br/>one_row.append(n)<br/>one_row = pd.DataFrame(one_row)<br/>one_row</span><span id="b0b0" class="ml lp it oh b gy or om l on oo">#labeled list<br/>from sklearn.preprocessing import LabelEncoder<br/>le = LabelEncoder()<br/>le.fit(one_row[0])<br/>one_row_labeled = le.transform(one_row[0])<br/>one_row_labeled</span><span id="9084" class="ml lp it oh b gy or om l on oo">#rebuild the original dataset and convert it to DataFrame<br/>import numpy<br/>X_labeled = numpy.array_split(one_row_labeled, (len(one_row)/8))<br/>X_labeled = pd.DataFrame(X_labeled)<br/>X_labeled</span></pre><figure class="mx my mz na gt nb gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/0bbc58ca8d5bcbfb7f4b987c0a17dfc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*afuRFrHQ0YCa2KVq-Cn4gA.png"/></div></figure><p id="aa45" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我们已经成功地正确标记了我们的每个特征，我们可以执行one_hot编码来将我们的数据集输入到AI中。</p><p id="c1b9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在我的下一篇文章中，我将描述整个过程，但是，在我的知识库中的笔记本上，你已经可以找到第二部分了。</p><p id="aac6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">-&gt; <a class="ae ln" rel="noopener" target="_blank" href="/ai-cluster-analysis-of-categorical-data-part-ii-47f3a13601a2">转到第二部分</a></p></div></div>    
</body>
</html>