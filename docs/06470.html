<html>
<head>
<title>Should You Jump Python’s Ship And Move To Julia?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">该不该跳Python的船，搬去茱莉亚？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/should-you-jump-pythons-ship-and-move-to-julia-ccd32e7d25d9?source=collection_archive---------3-----------------------#2020-05-23">https://towardsdatascience.com/should-you-jump-pythons-ship-and-move-to-julia-ccd32e7d25d9?source=collection_archive---------3-----------------------#2020-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e77b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">意见</h2><div class=""/><div class=""><h2 id="4464" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">是应该为了朱丽亚的表现而抛弃Python，还是朱丽亚的速度只是精心炒作？</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3138e13db2d2502d8d89964f80144d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cznmVtggjvDzM-uSRFclsg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">(python徽标由<a class="ae lh" href="http://python.org/" rel="noopener ugc nofollow" target="_blank">http://python.org/</a>提供，julia徽标由<a class="ae lh" href="http://julialang.org" rel="noopener ugc nofollow" target="_blank">http://julialang.org</a>提供，北海巨妖src = http://cleanpng.com)</p></figure><p id="959c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di">在过去的几年里，Python，一种用C语言编写的解释语言，越来越受欢迎。虽然Python肯定是一种有用的语言，从一开始就相当受欢迎，但这种受欢迎程度的飙升通常要归功于Python在机器学习和统计分析方面的出色能力。然而，随着时间的推移，新的语言应运而生，试图取代Python，为机器学习创造普遍更快的体验。属于这一类的最有前途和最受欢迎的语言之一是Julia。</span></p><p id="a059" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Julia是一种多范式、静态类型的通用语言，它是基于机器学习和统计学而构建的。大多数Julia用法背后的主要动机往往是Julia的速度，但我认为重要的是要记住仅速度一项就有多少变量。这甚至还没有触及到该语言的其他能力或缺陷。</p><blockquote class="mn"><p id="9f3c" class="mo mp it bd mq mr ms mt mu mv mw md dk translated"><a class="ae lh" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/pythonspeedtest.ipynb" rel="noopener ugc nofollow" target="_blank"> Python笔记本</a></p><p id="dd16" class="mo mp it bd mq mr ms mt mu mv mw md dk translated"><a class="ae lh" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/jlspeedtest.ipynb" rel="noopener ugc nofollow" target="_blank">朱丽亚笔记本</a></p></blockquote></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="6b52" class="ne nf it bd ng nh ni nj nk nl nm nn no ki np kj nq kl nr km ns ko nt kp nu nv bi translated">概述</h1><p id="5057" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">虽然速度当然很重要，甚至在机器学习的环境中更重要，但我认为在讨论性能的同时讨论其他障碍和优势也很重要。在跳Python船之前应该问的一个大问题是</p><blockquote class="mn"><p id="9f91" class="mo mp it bd mq mr ms mt mu mv mw md dk translated">朱莉娅有什么问题？</p></blockquote><p id="700a" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">如果权衡超过了表现这一单一的好处，那么学习一门新语言是没有意义的。Julia确实有一些问题，对于某些开发人员来说，这些问题可能不一定使切换成为最佳选择。</p><p id="5b59" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python和Julia之间的转换中丢失的第一个，也是最大的一个东西是</p><blockquote class="mn"><p id="67f6" class="mo mp it bd mq mr ms mt mu mv mw md dk translated">包裹。</p></blockquote><p id="c35b" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">虽然Julia确实有一些很棒的包值得一试，也有一个很棒的包管理器来帮助它们，但是这些包的范围远不如Python成熟。许多Julia包严重缺乏文档，有依赖问题，或者错综复杂，分割得太多，以至于你必须添加50个包才能完成一件事。虽然这肯定是一个很大的缺点，但应该注意的是，Julia没有Python所拥有的模块王朝，因为Python作为一种语言要成熟得多。随着时间的推移，这个问题几乎肯定会得到解决，随着伟大的开发人员致力于这种语言，再加上Julia周围的奇妙和快速发展的社区，这可能不会是一个很长时间的大问题。我理解为什么一些朱利安可能会指出“PyCall.jl”是一个潜在的解决方案，但我不同意这种立场，因为对所有东西都使用PyCall比对所有东西都使用Python要慢，所以为什么不在这一点上使用Python呢？</p><p id="02d9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Julia的另一个显著“缺点”是它的范式。虽然Julia确实是一种支持许多泛型的多范式编程语言，但Julia的语法本质上是静态的，这意味着在大多数情况下，Julia代码将属于函数范式。虽然我敢肯定Lisp、R和Haskell的粉丝们会高兴得跳起来，但是看看最流行的编程语言列表，就会明白为什么转换到这种范式会令人难以置信地不舒服，即使对于有经验的程序员来说也是如此。因此，虽然这对我或其他人来说可能不是一个缺点，但肯定会让那些对这种语言没有太大兴趣的人望而却步。</p><p id="d3ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很可能我们都熟悉Python，所以我不打算花太多时间来解释为什么您可能想从Python切换到Julia。然而，我认为Python有一些缺点，应该客观地提出来，以便确定潜在的转换编程语言的利弊。</p><p id="c3ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我确信我们都听说过，Python是一种解释型语言。虽然肯定有解决方案来解决这个问题，使用各种工具来获得编译后的可执行文件，以及更快的速度，但这些都不是使软件包更快或分发软件的万无一失的方法。虽然我并不特别热衷于“Python == 'slow '”这一潮流，但不可否认Python的速度不够快。幸运的是，Python通过C语言的解释确实把它放在了一个独特的位置，因为它可以用来从高级接口操纵和调用C代码。</p><p id="a296" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然这对Python来说是一个很大的优势，但并不是所有的数据科学工作都是在已经用C编写的模块中完成的，有时Python.h头文件的附加层也会降低计算速度，破坏C的出色性能。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="3ea6" class="ne nf it bd ng nh ni nj nk nl nm nn no ki np kj nq kl nr km ns ko nt kp nu nv bi translated">“由你决定”</h1><p id="4072" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">虽然速度绝对重要，但我想重申，它绝对不是一切。同时使用Python和Julia有很多显著的优势，其中一些甚至是主观的。例如，我对Python中的缩进语法恨之入骨，所以在Julia中使用以分隔符结尾的函数是我主观的偏好。</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="8acc" class="ol nf it oh b gy om on l oo op">def func:<br/>    print("function body")<br/>function func<br/>println("I can put syntax here")<br/>    println("Here")<br/>        println("Or here, without any errors.")</span><span id="89bf" class="ol nf it oh b gy oq on l oo op">end</span></pre><p id="a896" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我想指出的另一件事是Julia的多态调度和Python的更简单的语法。所有这些都是为了说明，虽然性能很重要，但在选择使用哪种语言时，一种语言中的许多特性可能是更重要的因素。不仅如此，您还可以挑选在您当前的场景中使用哪种语言，因为自然有一些事情一种语言会比另一种语言更好。</p><p id="bf3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一个有趣的事情是，我以前在Julia中提到过，使用Python作为Julia的接口，而不是与c接口。这样做的好处是能够更快地编写快速代码，同时仍然保持类似的性能。幸运的是，我甚至创建了一个包来这样做，这样您就可以通过PyPi进行安装。</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="9228" class="ol nf it oh b gy om on l oo op">sudo pip3 install TopLoader</span></pre><div class="or os gp gr ot ou"><a href="https://github.com/emmettgb/TopLoader" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jd gy z fp oz fr fs pa fu fw jc bi translated">emmettgb/TopLoader</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">你好，装载愉快！您可以使用以下命令安装TopLoader:sudo pip 3立即从TopLoader安装TopLoader您可以…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">github.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi lb ou"/></div></div></a></div><p id="1335" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你选择的语言不一定是二进制的。Julia的一个优点是，考虑到Julia的大数据能力和浮点精度，您可以保留对Python的使用，并像使用Scala一样使用Julia。Julia甚至有BigInt和BigFloat类型来处理比一般熊大的数字。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="9534" class="ne nf it bd ng nh ni nj nk nl nm nn no ki np kj nq kl nr km ns ko nt kp nu nv bi translated">速度测试</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/8720ecb5b186602d958f0de667ee2f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFn45QQCZ-nJnqcRUoo-mg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">(src =茱莉亚计算<a class="ae lh" href="https://julialang.org/benchmarks/" rel="noopener ugc nofollow" target="_blank">https://julialang.org/benchmarks/</a></p></figure><p id="873e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实际速度方面，我已经把朱莉娅的基准放在上面了。正如我们从这个基本基准中看到的，Julia倾向于徘徊在Go的性能附近，同时保持一点点的一致性。有趣的是，在极少数情况下，Julia甚至可以超越C和Rust。虽然这肯定是一个伟大的壮举，但这里的目标不是比较Julia和C，而是比较Julia和Python。</p><h2 id="e198" class="ol nf it bd ng pk pl dn nk pm pn dp no lr po pp nq lv pq pr ns lz ps pt nu iz bi translated">测试设置</h2><p id="0375" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">为了保持两种比较之间的一致性，我将使用Julia的<a class="ae lh" rel="noopener" target="_blank" href="/syntactical-expressions-are-awesome-dc9ba5f25911?source=---------4------------------">语法表达式</a>来强制语言的类型更像Python。如果你想进一步了解如何做到这一点，以及更熟悉Julia的调度，我有一篇我很自豪的文章，它会告诉你你需要知道的一切:</p><div class="or os gp gr ot ou"><a rel="noopener follow" target="_blank" href="/turn-julia-into-python-and-duck-type-in-a-statically-typed-language-119f708936ff"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jd gy z fp oz fr fs pa fu fw jc bi translated">用静态类型语言将Julia转换成Python和Duck-Type</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">通过结合Julia富有表现力的语法和令人敬畏的调度，将Julia变成Python。</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pu l pf pg ph pd pi lb ou"/></div></div></a></div><p id="2196" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于我的迭代测试，我在Julia中创建了这个函数:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="1c3a" class="ol nf it oh b gy om on l oo op">function LinearRegression(x,y)<br/>    # a = ((∑y)(∑x^2)-(∑x)(∑xy)) / (n(∑x^2) - (∑x)^2)<br/>    # b = (x(∑xy) - (∑x)(∑y)) / n(∑x^2) - (∑x)^2<br/>    if length(x) != length(y)<br/>        throw(ArgumentError("The array shape does not match!"))<br/>    end<br/>    # Get our Summations:<br/>    Σx = sum(x)<br/>    Σy = sum(y)<br/>    # dot x and y<br/>    xy = x .* y<br/>    # ∑dot x and y<br/>    Σxy = sum(xy)<br/>    # dotsquare x<br/>    x2 = x .^ 2<br/>    # ∑ dotsquare x<br/>    Σx2 = sum(x2)<br/>    # n = sample size<br/>    n = length(x)<br/>    # Calculate a<br/>    a = (((Σy) * (Σx2)) - ((Σx * (Σxy)))) / ((n * (Σx2))-(Σx^2))<br/>    # Calculate b<br/>    b = ((n*(Σxy)) - (Σx * Σy)) / ((n * (Σx2)) - (Σx ^ 2))<br/>    # The part that is super struct:<br/>    predict(xt) = (xt = [i = a + (b * i) for i in xt])<br/>    (test)-&gt;(a;b;predict)<br/>end</span></pre><p id="ddd1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，我用Python创建了这个类来实现同样的目标:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="9de4" class="ol nf it oh b gy om on l oo op">class LinearRegression:<br/>    def __init__(self,x,y):<br/>        # a = ((∑y)(∑x^2)-(∑x)(∑xy)) / (n(∑x^2) - (∑x)^2)<br/>        # b = (x(∑xy) - (∑x)(∑y)) / n(∑x^2) - (∑x)^2<br/>        if len(x) != len(y):<br/>            pass<br/>        # Get our Summations:<br/>        Σx = sum(x)<br/>        Σy = sum(y)<br/>        # dot x and y<br/>        xy = dot(x,y)<br/>        # ∑dot x and y<br/>        Σxy = sum(xy)<br/>        # dotsquare x<br/>        x2 = sq(x)<br/>        # ∑ dotsquare x<br/>        Σx2 = sum(x2)<br/>        # n = sample size<br/>        n = len(x)<br/>        # Calculate a<br/>        self.a = (((Σy) * (Σx2)) - ((Σx * (Σxy)))) / ((n * (Σx2))-(Σx**2))<br/>        # Calculate b<br/>        self.b = ((n*(Σxy)) - (Σx * Σy)) / ((n * (Σx2)) - (Σx ** 2))<br/>        # The part that is super struct:<br/>    def predict(self,xt):<br/>        xt = [self.a + (self.b * i) for i in xt]<br/>        return(xt)</span></pre><p id="b3c5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可能会注意到我用dot()和sq()来代替。*对于逐元素乘法，和。元素式平方的^。这些功能如下:</p><pre class="ks kt ku kv gt og oh oi oj aw ok bi"><span id="eb35" class="ol nf it oh b gy om on l oo op">def dot(x,y):<br/>    lst = []<br/>    for i,w in zip(x,y):<br/>        lst.append(i * w)<br/>    return(lst)<br/>def sq(x):<br/>    x = [c ** 2 for c in x]<br/>    return(x)</span></pre><h1 id="3416" class="ne nf it bd ng nh pv nj nk nl pw nn no ki px kj nq kl py km ns ko pz kp nu nv bi translated">数据</h1><p id="a109" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">对于我的数据，我在Julia中生成了一个500，000的模糊数据帧，如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/adc3bbd117468c311c2c3a717d3c08e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*an63NWuWOYdkmPJYR8x6PQ.png"/></div></figure><p id="fd8d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我还做了一个有60万个暗点的测试数据框架:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qb"><img src="../Images/6dafaf1abf173af55027f37141246e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*etFgNrf3u1GzfRCVwxvfHQ.png"/></div></div></figure><p id="a2f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了保持一致性，我保存了数据帧，并使用Pandas将它们读入Python:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/26ed660d5acd47e4770a22d4676e8071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*WO7KnKYDlXKKo3a9ZIIfMg.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/c7bdf8ff6f59b8554afa316e821eb29c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*bZG_NhaR_jg18ZXvIm-nnA.png"/></div></figure><h1 id="08af" class="ne nf it bd ng nh pv nj nk nl pw nn no ki px kj nq kl py km ns ko pz kp nu nv bi translated">最终时机</h1><p id="c6e4" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">当然，为了计时Python结果，我将使用IPython %timeit magic命令。至于Julia的结果，正如你所料，我将使用@time宏。结果如下:</p><h2 id="7900" class="ol nf it bd ng pk pl dn nk pm pn dp no lr po pp nq lv pq pr ns lz ps pt nu iz bi translated">朱莉娅</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qe"><img src="../Images/05529e0172823ec341982724a642fc38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_sXRWyun1Z49R936QxNtgQ.png"/></div></div></figure><h2 id="bb25" class="ol nf it bd ng pk pl dn nk pm pn dp no lr po pp nq lv pq pr ns lz ps pt nu iz bi translated">计算机编程语言</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/feb4c6a85575dee931b7a5552072aca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*NHc7G8yWO6DsJXkSJxa0WQ.png"/></div></figure><p id="a33b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然这是一个很好的比较，而且Julia在计算上确实节省了大约30%的时间，但是我想</p><blockquote class="mn"><p id="a4fc" class="mo mp it bd mq mr ms mt mu mv mw md dk translated">“向上反”</p></blockquote><p id="3ef2" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">我们试试10，000，000个dims。</p><h2 id="e0e8" class="ol nf it bd ng pk pl dn nk pm pn dp no lr po pp nq lv pq pr ns lz ps pt nu iz bi translated">朱莉娅</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/36261e70b3c73ce37834a6cfc0bf4495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QgGY7mcNUkZaWVhgje3DWg.png"/></div></div></figure><h2 id="ce26" class="ol nf it bd ng pk pl dn nk pm pn dp no lr po pp nq lv pq pr ns lz ps pt nu iz bi translated">计算机编程语言</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/6184e07851b020c84c7bcd44d1d02782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*dPuiq3JiH4YAxWJcng2MRg.png"/></div></figure><blockquote class="mn"><p id="92b5" class="mo mp it bd mq mr qi qj qk ql qm md dk translated">R.I.P. Python</p></blockquote></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="a3d8" class="ne nf it bd ng nh ni nj nk nl nm nn no ki np kj nq kl nr km ns ko nt kp nu nv bi translated">结论</h1><p id="35ab" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">虽然Python能够如此出色地击败Julia令人印象深刻，但对于这个Julia胜过Python的真实机器学习示例，肯定有一些东西值得一提。我认为这也很好地说明了我之前所说的，Julia在处理大数据方面非常有用。我想如果这个测试教会了我什么的话，那就是Julia在机器学习的世界里绝对有一席之地。即使Julia不能取代Python，它也肯定能取代Scala和许多其他类似的语言。</p><p id="7f2b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管这种语言有其独特之处，并且在不断发展，但性能肯定是存在的。尽管现在可能还不是开始Python编程的时候</p><blockquote class="mn"><p id="5e63" class="mo mp it bd mq mr ms mt mu mv mw md dk translated">(尚未)</p></blockquote><p id="7bb1" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated">(我是开玩笑的)，或者可能永远也不会为了机器学习而放弃Python，同时我也找不到不学习Julia的好理由。幸运的是，如果您已经熟悉Python，那么学习Julia应该相对简单，因为语法非常相似。谁知道呢——也许你也会在朱莉娅身上找到一些你喜欢的东西！总的来说，Julia在机器学习领域的未来非常令人兴奋。我认为，任何希望拓宽自己视野的数据科学家都应该去看看，甚至为Julia语言这个日益壮大的庞然大物做出贡献。</p></div></div>    
</body>
</html>