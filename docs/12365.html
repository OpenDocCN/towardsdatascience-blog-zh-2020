<html>
<head>
<title>Using Naive Bayes to Create a Chess AI from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用朴素贝叶斯从零开始创建国际象棋人工智能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-naive-bayes-to-create-a-chess-ai-from-scratch-e35bc64ef109?source=collection_archive---------53-----------------------#2020-08-25">https://towardsdatascience.com/using-naive-bayes-to-create-a-chess-ai-from-scratch-e35bc64ef109?source=collection_archive---------53-----------------------#2020-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d03b4fc4c81b99e1ed8c59d5ad0bb81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MYMrfhvOanSi6bMzVzrLDA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">皮奥特·马科夫斯基在<a class="ae kf" href="https://unsplash.com/s/photos/chess?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7b2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">国际象棋一直被认为是智力和智力的测试。1996 年，在国际象棋大师加里·卡斯帕罗夫和 IBM 的深蓝之战后，它也成为了人工智能的一块基石。因为它的重要性，我认为尝试创造一个有能力的象棋人工智能会很有趣。</p><p id="162a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了实现创建一个有能力的国际象棋人工智能的目标，我开发了一个朴素贝叶斯分类器，使用概率来寻找最佳可能的移动。</p><p id="8674" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我使用的数据集有超过 20，000 个游戏。可惜我再也找不到源头了。如果你正在寻找数据集，你可以联系我在 victorwtsim@gmail.com。</p><h1 id="efc2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">朴素贝叶斯分类器:</h1><p id="f04c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">朴素贝叶斯分类器依赖于使用从数据集收集的概率来做出最佳决策。对于国际象棋，这是如何实现的？以下是一个逐步指南:</p><p id="7715" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">第一步</strong>:统计每一步棋在输赢游戏中出现的次数。</p><p id="1875" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">第二步</strong>:将每一个计数值，除以输局的总棋数和赢局的总棋数，变成一个概率。</p><p id="8c7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">第三步</strong>:利用贝叶斯定理计算出获胜概率最高的招式。</p><h1 id="b4f8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">代码:</h1><p id="f16c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><strong class="ki iu">第一步</strong>:在一场输和赢的游戏中，每出现一个招式，就数一次。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1741" class="mq lf it mm b gy mr ms l mt mu">from pandas import read_csv<br/>import chess<br/>file = '/Users/XXXXXXX/Desktop/Files/Data/chess.csv'<br/>csv = read_csv(file)</span><span id="10ea" class="mq lf it mm b gy mv ms l mt mu">outcomes = list(csv['winner'])<br/>moves = list(csv['moves'])<br/>for i in range(len(moves)):<br/>    moves[i] = moves[i].split()<br/>white_moves = 0<br/>black_moves = 0</span></pre><p id="9143" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在进入实际程序之前，这些是我用来访问我的数据的先决条件。如果您可以访问数据集，您可以复制它。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="90d7" class="mq lf it mm b gy mr ms l mt mu">def initialize_dictionaries():<br/>    white = {}<br/>    black = {}<br/>    all_moves = []<br/>    for game in moves:<br/>        for move in game:<br/>            if not(move in all_moves):<br/>                all_moves.append(move)<br/>    for move in all_moves:<br/>        white[move] = 1<br/>        black[move] = 1<br/>    return white,black</span><span id="aee9" class="mq lf it mm b gy mv ms l mt mu">def initialize_data(white,black):<br/>    white_moves = 0<br/>    black_moves = 0<br/>    for outcome in outcomes:<br/>        index = outcomes.index(outcome)<br/>        if outcome == 'white':<br/>            work_dict = white<br/>            white_moves += len(moves[index])<br/>            ip2 = 0<br/>        elif outcome == 'black':<br/>            work_dict = black<br/>            black_moves += len(moves[index])<br/>            ip2 = 1<br/>        for move in moves[index]:<br/>            if moves[index].index(move) % 2 == ip2:<br/>                if move in work_dict:<br/>                    work_dict[move] += 1<br/>    return white,black,white_moves,black_moves</span><span id="db30" class="mq lf it mm b gy mv ms l mt mu">white,black = initialize_dictionaries()<br/>white,black,white_moves,black_moves = initialize_data(white,black)</span></pre><p id="8476" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个函数查看数据，将游戏的结果与移动匹配，并相应地添加每个移动在输赢游戏中出现的次数。我以 Python 字典的形式存储数据，以支持基于文本的索引。</p><p id="eedd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">第二步</strong>:将每一个计数值除以输局的总棋数和赢局的总棋数，变成一个概率。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cc74" class="mq lf it mm b gy mr ms l mt mu">def to_probability(dictionary,length):<br/>    for term in dictionary:<br/>        dictionary[term] = dictionary[term]/length<br/>    return dictionary<br/>white = to_probability(white,white_moves)<br/>black = to_probability(black,black_moves)</span></pre><p id="ed16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数非常简单，几乎不需要解释:用一个移动出现的次数除以移动的总数，得到一个概率。</p><p id="2564" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">第三步</strong>:利用贝叶斯定理计算出获胜概率最高的招式。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/1ee87d7d3d03be129eec7a580245da9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*3uz2tUaO4kDSv5hgp-OdRw.png"/></div></figure><p id="78ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">贝叶斯定理指出，假设 B 发生了，A 发生的概率是 B 发生的概率，当 A 发生时，乘以 A 发生的概率，除以 B 的概率。</p><p id="d6dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用赢来代替 A，用移动 X 来代替 B。赢的概率，给定移动 X 被使用，可以计算为:移动 X 在赢的配置中出现多少次，乘以总的赢的概率，再乘以移动 X 被使用的概率。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5b89" class="mq lf it mm b gy mr ms l mt mu">PA = outcomes.count('white')/len(outcomes)<br/>PB = 1<br/>PBgiveA = white[move]/outcomes.count('white')<br/>whitePAgiveB = (PBgiveA * PA) / PB</span></pre><p id="892f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的代码是这个概念的应用，给出了白棋赢的概率。请注意，移动 X 的概率是 1，如果我们想移动，移动有 100%的机会发生。</p><p id="b6af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完整的功能是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f202" class="mq lf it mm b gy mr ms l mt mu">def calculate_probability(side,board,white,black,white_moves,black_moves):<br/>    len_white = white_moves<br/>    len_black = black_moves<br/>    if side == True:<br/>        color = 'white'<br/>    else:<br/>        color = 'black'<br/>    legal_moves = str(board.legal_moves)[36:-2].replace(',','').split()<br/>    probs = []<br/>    for move in legal_moves:<br/>        if not(move in white):<br/>            len_white += 1<br/>            white[move] = 1/len_white<br/>        PA = outcomes.count('white')/len(outcomes)<br/>        PB = 1<br/>        PBgiveA = white[move]/outcomes.count('white')<br/>        whitePAgiveB = (PBgiveA * PA) / PB<br/>        if not(move in black):<br/>            len_black += 1<br/>            black[move] = 1/len_black<br/>        PA = outcomes.count('black')/len(outcomes)<br/>        PB = 1<br/>        PBgiveA = black[move]/outcomes.count('black')<br/>        blackPAgiveB = (PBgiveA * PA) / PB<br/>        if color == 'white':<br/>            probs.append(whitePAgiveB-blackPAgiveB)<br/>        elif color == 'black':<br/>            probs.append(blackPAgiveB-whitePAgiveB)<br/>    final_move = legal_moves[legal_moves.index(max(legal_moves))]<br/>    return white_moves,black_moves,final_move</span></pre><h1 id="a197" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结果:</h1><p id="2cb6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我试着用这个算法和它自己玩。它对开局和理想位置有很好的感觉(比如确保中路)，但在捕捉棋子时有问题。</p><p id="b35c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为这是因为朴素贝叶斯分类器只知道合法的移动，而不掌握棋盘上的整体状态。</p></div></div>    
</body>
</html>