<html>
<head>
<title>Using Pandas Method Chaining to improve code readability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Pandas 方法链接提高代码可读性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-pandas-method-chaining-to-improve-code-readability-d8517c5626ac?source=collection_archive---------4-----------------------#2020-08-07">https://towardsdatascience.com/using-pandas-method-chaining-to-improve-code-readability-d8517c5626ac?source=collection_archive---------4-----------------------#2020-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5b3d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">熊猫方法链接的最佳实践教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/61de23bc2c4811a06fe4f393e18acfd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MeA7SjBhFDPuWawt_GaSXg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@stephenleo1982?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">斯蒂芬·莱昂纳迪</a>在<a class="ae ky" href="https://unsplash.com/s/photos/chain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3bdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们一直在讨论使用<a class="ae ky" rel="noopener" target="_blank" href="/using-pandas-pipe-function-to-improve-code-readability-96d66abfaf8"> Pandas 管道函数来提高代码可读性</a>。在本文中，我们来看看熊猫<strong class="lb iu">方法链接</strong>。</p><p id="7d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数据处理中，经常需要对某一行或某一列执行操作以获得新的数据。而不是写作</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="473b" class="ma mb it lw b gy mc md l me mf">df = pd.read_csv('data.csv')<br/>df = df.fillna(...)<br/>df = df.query('some_condition')<br/>df['new_column'] = df.cut(...)<br/>df = df.pivot_table(...)<br/>df = df.rename(...)</span></pre><p id="bd54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能做的</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4b34" class="ma mb it lw b gy mc md l me mf">(pd.read_csv('data.csv')<br/>   .fillna(...)<br/>   .query('some_condition')<br/>   .assign(new_column = df.cut(...))<br/>   .pivot_table(...)<br/>   .rename(...)<br/>)</span></pre><p id="354f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">方法链接</strong>在 Pandas 中一直可用，但是<strong class="lb iu">通过添加新的“可链接”方法，对链接的支持增加了</strong>。例如<code class="fe mg mh mi lw b">query()</code>、<code class="fe mg mh mi lw b">assign()</code>、<code class="fe mg mh mi lw b">pivot_table()</code>，特别是<code class="fe mg mh mi lw b"><a class="ae ky" rel="noopener" target="_blank" href="/using-pandas-pipe-function-to-improve-code-readability-96d66abfaf8">pipe()</a></code>、<a class="ae ky" rel="noopener" target="_blank" href="/using-pandas-pipe-function-to-improve-code-readability-96d66abfaf8">，用于在方法链</a>中允许用户自定义方法。</p><blockquote class="mj"><p id="7f3d" class="mk ml it bd mm mn mo mp mq mr ms lu dk translated">方法链是一种编程风格，它按顺序调用多个方法调用，每个调用对同一个对象执行一个操作并返回该操作。</p><p id="8f8f" class="mk ml it bd mm mn mo mp mq mr ms lu dk translated">它消除了在每个中间步骤命名变量的认知负担。<a class="ae ky" href="https://en.wikipedia.org/wiki/Fluent_interface" rel="noopener ugc nofollow" target="_blank"> Fluent 接口</a>，一种创建面向对象 API 的方法依赖于方法级联(又名方法链)。这类似于 Unix 系统中的管道。</p><p id="61f3" class="mk ml it bd mm mn mo mp mq mr ms lu dk translated">阿迪亚曼·科尔提</p></blockquote><p id="87ae" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">方法链接大大增加了代码的可读性。让我们深入教程，看看它如何提高我们的代码可读性。</p><p id="db7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源代码请访问我的<a class="ae ky" href="https://github.com/BindiChen/machine-learning/blob/master/data-analysis/007-method-chaining/method-chaining.ipynb" rel="noopener ugc nofollow" target="_blank"> Github 笔记本</a>。</p><h1 id="7640" class="my mb it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">数据集准备</h1><p id="1318" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在本教程中，我们将处理来自 Kaggle 的<a class="ae ky" href="https://www.kaggle.com/c/titanic/overview" rel="noopener ugc nofollow" target="_blank">泰坦尼克号数据集。这是一个非常著名的数据集，通常是学生学习数据科学的第一步。让我们导入一些库并加载数据来开始。</a></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="08f6" class="ma mb it lw b gy mc md l me mf">import pandas as pd<br/>import sys<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline<br/>%config InlineBackend.figure_format = 'svg'</span><span id="475f" class="ma mb it lw b gy nu md l me mf"><strong class="lw iu">df = pd.read_csv('data/train.csv')</strong><br/>df.head()</span></pre><p id="71ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<strong class="lb iu"> train.csv </strong>文件加载到熊猫数据帧中</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/4ad00883912e1bbac6cf2d4b3bbe758c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSW10flNY94VcXRAl-DHGA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">泰坦尼克号数据预览</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/2e47b80781ae34a5a32bf6bd1de4a049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E3a8GqyrscvgA515Vb5auw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.kaggle.com/c/titanic/data?select=train.csv" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的数据字典</p></figure><p id="da26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从检查缺失值开始。我们可以使用 seaborn 创建一个简单的热图来查看哪里缺少值</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="63e1" class="ma mb it lw b gy mc md l me mf">sns.heatmap(<strong class="lw iu">df.isnull()</strong>, <br/>            yticklabels=False, <br/>            cbar=False, <br/>            cmap='viridis')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/d6afe812a9ef1628282ae5920a4ef2c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_90628Q1-s_FNERAFlbIA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缺失值的 seaborn 热图输出</p></figure><p id="793a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ny">年龄</em> </strong>，<strong class="lb iu"> <em class="ny">船舱</em> </strong>，<strong class="lb iu"> <em class="ny">上船</em> </strong>有缺失值。<strong class="lb iu"> <em class="ny">年龄</em> </strong>缺失的比例很可能小到足以用某种形式的插补进行合理替换。看着<strong class="lb iu"> <em class="ny">舱</em> </strong>栏，好像缺了很多值。<strong class="lb iu"> <em class="ny">着手</em> </strong>缺失的比例很小。</p><h1 id="94b5" class="my mb it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">工作</h1><p id="59d6" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">假设我们被要求看一看从南安普顿出发的乘客，并计算出不同年龄组和<strong class="lb iu"><em class="ny">p 等级</em> </strong>的存活率。</p><p id="3b61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把这项任务分成几个步骤，一步一步地完成。</p><ol class=""><li id="d602" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">数据清理:用某种形式的插补替换缺失的<strong class="lb iu"> <em class="ny">年龄</em> </strong></li><li id="003e" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">选择从南安普敦出发的乘客</li><li id="c22f" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">将年龄转换为年龄范围组:≤12 岁、青少年(≤ 18 岁)、成人(≤ 60 岁)和老年人(&gt; 60 岁)</li><li id="48df" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">创建一个数据透视表来显示不同年龄组的存活率和<strong class="lb iu"> <em class="ny"> Pclass </em> </strong></li><li id="31c0" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">通过重命名轴标签和格式化值来改进数据透视表的显示。</li></ol><p id="ce63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷，让我们继续使用熊猫<strong class="lb iu">方法链接</strong>来完成它们。</p><h2 id="e8ae" class="ma mb it bd mz on oo dn nd op oq dp nh li or os nj lm ot ou nl lq ov ow nn ox bi translated">1.用某种形式的插补替代缺失的年龄</h2><p id="48fe" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">正如在数据准备中提到的，我们希望用某种形式的插补来替换缺失的<strong class="lb iu"> <em class="ny">年龄</em> </strong>。一种方法是填写所有乘客的平均年龄。然而，我们可以更聪明地处理这个问题，按乘客级别检查平均年龄。例如:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="093e" class="ma mb it lw b gy mc md l me mf">sns.boxplot(x='Pclass',<br/>            y='Age',<br/>            data=df,<br/>            palette='winter')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/4332bbb540a5459d55a96dc32e2ec81c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4wJjYUvU_R2hOExf5LFnUA.png"/></div></div></figure><p id="bbf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，在较高的阶层中，较富裕的乘客往往年龄较大，这是有道理的。我们将根据年龄的 Pclass 使用这些平均年龄值进行估算。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4897" class="ma mb it lw b gy mc md l me mf">pclass_age_map = {<br/>  <strong class="lw iu">1: 37,<br/>  2: 29,<br/>  3: 24,</strong><br/>}</span><span id="df9e" class="ma mb it lw b gy nu md l me mf">def replace_age_na(x_df, fill_map):<br/>    <strong class="lw iu">cond=x_df['Age'].isna()<br/>    res=x_df.loc[cond,'Pclass'].map(fill_map)<br/>    x_df.loc[cond,'Age']=res</strong></span><span id="ddac" class="ma mb it lw b gy nu md l me mf">    return x_df</span></pre><p id="8323" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">x_df['Age'].isna()</code>选择<strong class="lb iu"> <em class="ny">年龄</em> </strong>栏，检测缺失值。然后，<code class="fe mg mh mi lw b">x_df.loc[cond, 'Pclass']</code>用于有条件地访问<strong class="lb iu"> <em class="ny"> Pclass </em> </strong>值，并调用熊猫<code class="fe mg mh mi lw b"><a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-pandas-apply-applymap-and-map-5d3e044e93ff">map()</a></code>将每个值替换为另一个值。最后，<code class="fe mg mh mi lw b">x_df.loc[cond, 'Age']=res</code>有条件地用<code class="fe mg mh mi lw b">res</code>替换所有缺失的年龄值。</p><p id="602d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行以下代码</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e64f" class="ma mb it lw b gy mc md l me mf">res = (<br/>  pd.read_csv('data/train.csv')<br/>    <strong class="lw iu">.pipe(replace_age_na, pclass_age_map)</strong><br/>)</span><span id="36c3" class="ma mb it lw b gy nu md l me mf">res.head()</span></pre><p id="c480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应根据年龄的 Pclass 替换所有缺失的年龄。让我们通过运行<code class="fe mg mh mi lw b">res</code>上的热图来检查一下。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4a5f" class="ma mb it lw b gy mc md l me mf">sns.heatmap(<strong class="lw iu">res.isnull()</strong>, <br/>            yticklabels=False, <br/>            cbar=False, <br/>            cmap='viridis')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/f5731fd16fdc9651b72c0c73eb370688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GlJIFHC6BjuUjkM1VPIt4Q.png"/></div></div></figure><p id="c107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，成功了！</p><h2 id="b4b7" class="ma mb it bd mz on oo dn nd op oq dp nh li or os nj lm ot ou nl lq ov ow nn ox bi translated">2.选择从南安普敦出发的乘客</h2><p id="a514" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">根据泰坦尼克号数据字典，从南安普顿出发的乘客应该是乘坐<strong class="lb iu"> <em class="ny">登上</em> </strong>，价值<code class="fe mg mh mi lw b">S</code>。让我们使用 Pandas <code class="fe mg mh mi lw b">query()</code>函数进行查询。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b65a" class="ma mb it lw b gy mc md l me mf">res = (<br/>  pd.read_csv('data/train.csv')<br/>    .pipe(replace_age_na, pclass_age_map)<br/>    <strong class="lw iu">.query('Embarked == "S"')</strong><br/>)</span><span id="26f0" class="ma mb it lw b gy nu md l me mf">res.head()</span></pre><p id="4eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了评估查询结果，我们可以使用<code class="fe mg mh mi lw b">value_counts()</code>进行检查</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ca43" class="ma mb it lw b gy mc md l me mf">res.Embarked.value_counts()</span><span id="e12c" class="ma mb it lw b gy nu md l me mf"><strong class="lw iu">S    644</strong><br/>Name: Embarked, dtype: int64</span></pre><h2 id="7a12" class="ma mb it bd mz on oo dn nd op oq dp nh li or os nj lm ot ou nl lq ov ow nn ox bi translated">3.将年龄转换为年龄范围组:≤12 岁、青少年(≤ 18 岁)、成人(≤ 60 岁)和老年人(&gt; 60 岁)</h2><p id="c321" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我们在文章<a class="ae ky" rel="noopener" target="_blank" href="/using-pandas-pipe-function-to-improve-code-readability-96d66abfaf8"> Pandas pipe function </a>中使用了一个自定义函数。或者，我们可以使用 Pandas 内置函数<code class="fe mg mh mi lw b">assign()</code>向 DataFrame 添加新列。让我们从<code class="fe mg mh mi lw b">assign()</code>开始。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0f36" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">bins=[0, 13, 19, 61, sys.maxsize]<br/>labels=['&lt;12', 'Teen', 'Adult', 'Older']</strong></span><span id="4590" class="ma mb it lw b gy nu md l me mf">res = (<br/>  pd.read_csv('data/train.csv')<br/>    .pipe(replace_age_na, pclass_age_map)<br/>    .query('Embarked == "S"')<br/>    <strong class="lw iu">.assign(ageGroup = lambda df: pd.cut(df['Age'], bins=bins, labels=labels))</strong><br/>)</span><span id="b87b" class="ma mb it lw b gy nu md l me mf">res.head()</span></pre><p id="5b4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫<code class="fe mg mh mi lw b">assign()</code>用于创建新列<strong class="lb iu"> <em class="ny">年龄组</em> </strong>。新列是用 lambda 函数和 Pandas <code class="fe mg mh mi lw b">cut()</code>一起创建的，用于将年龄转换为范围组。</p><p id="294a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行代码，我们应该得到如下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/435c7cb1dc76f6642c699fe159fbc5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BqwntajSZrGrP1LBIEmA7w.png"/></div></div></figure><h2 id="5b54" class="ma mb it bd mz on oo dn nd op oq dp nh li or os nj lm ot ou nl lq ov ow nn ox bi translated">4.创建一个数据透视表来显示不同年龄组和<strong class="ak"><em class="pb">p 类</em> </strong>的存活率</h2><p id="b752" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">数据透视表让我们能够洞察我们的数据。让我们用它来计算存活率。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="350d" class="ma mb it lw b gy mc md l me mf">bins=[0, 13, 19, 61, sys.maxsize]<br/>labels=['&lt;12', 'Teen', 'Adult', 'Older']</span><span id="db52" class="ma mb it lw b gy nu md l me mf">(<br/>  pd.read_csv('data/train.csv')<br/>    .pipe(replace_age_na, pclass_age_map)<br/>    .query('Embarked == "S"')<br/>    .assign(ageGroup = lambda df: pd.cut(df['Age'], bins=bins, labels=labels))<br/>    <strong class="lw iu">.pivot_table(<br/>        values='Survived', <br/>        columns='Pclass', <br/>        index='ageGroup', <br/>        aggfunc='mean')</strong><br/>)</span></pre><p id="4063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个参数<code class="fe mg mh mi lw b">values='Survived'</code>指定要聚合的幸存列。由于存活的值是<code class="fe mg mh mi lw b">1</code>或<code class="fe mg mh mi lw b">0</code>，我们可以使用聚合函数<code class="fe mg mh mi lw b">mean</code>来计算存活率，因此使用了<code class="fe mg mh mi lw b">aggfunc='mean'</code>。<code class="fe mg mh mi lw b">index='ageGroup'</code>和<code class="fe mg mh mi lw b">columns='Pclass'</code>会在输出表中将<strong class="lb iu"> <em class="ny">年龄组</em> </strong>显示为行，将<strong class="lb iu"> <em class="ny"> Pclass </em> </strong>显示为列。</p><p id="f6d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行代码，我们应该得到如下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/54f4571a393d733793f46c1510569535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*0ZwuXmFvnKGFCZZE6eL1EA.png"/></div></figure><h2 id="fe15" class="ma mb it bd mz on oo dn nd op oq dp nh li or os nj lm ot ou nl lq ov ow nn ox bi translated">5.通过重命名轴标签和格式化值来改进数据透视表的显示。</h2><p id="346b" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">到目前为止，我们得到的结果不是很清楚。让我们继续改进显示。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7f6e" class="ma mb it lw b gy mc md l me mf">bins=[0, 13, 19, 61, sys.maxsize]<br/>labels=['&lt;12', 'Teen', 'Adult', 'Older']</span><span id="9483" class="ma mb it lw b gy nu md l me mf">(<br/>  pd.read_csv('data/train.csv')<br/>    .pipe(replace_age_na, pclass_age_map)<br/>    .query('Embarked == "S"')<br/>    .assign(ageGroup = lambda df: pd.cut(df['Age'], bins=bins, labels=labels))<br/>    .pivot_table(<br/>        values='Survived', <br/>        columns='Pclass', <br/>        index='ageGroup', <br/>        aggfunc='mean')<br/>    <strong class="lw iu">.rename_axis('', axis='columns')<br/>    .rename('Class {}'.format, axis='columns')<br/>    .style.format('{:.2%}')</strong><br/>)</span></pre><p id="2b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">rename_axis()</code>用于清除列标签。之后，<code class="fe mg mh mi lw b">rename('Class {}'.format, axis='columns')</code>用于格式化列标签。最后，<code class="fe mg mh mi lw b">style.format('{:.2%}')</code>用于将值格式化为带两位小数的百分比。</p><p id="eb54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行代码，我们应该得到如下输出</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/9ee85692d1c7d8cbbf9df9f9324aeab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*fk47q6kPmvkys7C_gJDG_w.png"/></div></figure><h1 id="f82d" class="my mb it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">性能和缺点</h1><p id="a67d" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在性能方面，根据 DataSchool [2]，方法链提前告诉 pandas 所有事情，因此 pandas 可以更有效地计划其操作，因此它应该比常规方法有更好的性能。</p><p id="b7ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法链接可读性更好。然而，一个非常长的方法链可能可读性较差，特别是当在链中调用其他函数时，例如，在我们的教程中，在<code class="fe mg mh mi lw b">assign()</code>方法中使用了<code class="fe mg mh mi lw b">cut()</code>。</p><p id="94cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，使用方法链的一个主要缺点是调试会更加困难，尤其是在非常长的链中。如果最后看起来有问题，你没有中间值来检查。</p><p id="fef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个主题的更长的讨论，请参见汤姆·奥格斯伯格的<a class="ae ky" href="https://tomaugspurger.github.io/method-chaining.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">方法链接帖子</strong></a>【1】。</p><h1 id="ba37" class="my mb it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">好了</h1><p id="257b" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">感谢阅读。</p><p id="723d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请在我的 Github 上查看<a class="ae ky" href="https://github.com/BindiChen/machine-learning" rel="noopener ugc nofollow" target="_blank">笔记本的源代码。</a></p><p id="6c66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对机器学习的实用方面感兴趣，请继续关注。</p><p id="d6f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这里有两篇你可能感兴趣的相关文章</p><ul class=""><li id="76e3" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu pe of og oh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/working-with-missing-values-in-pandas-5da45d16e74">处理熊猫的缺失值</a></li><li id="c63e" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu pe of og oh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/using-pandas-pipe-function-to-improve-code-readability-96d66abfaf8">使用熊猫管道函数提高代码可读性</a></li></ul><h1 id="219e" class="my mb it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">参考</h1><ul class=""><li id="cdd2" class="nz oa it lb b lc np lf nq li pf lm pg lq ph lu pe of og oh bi translated">[1]Tom Augspurger 的方法链接【https://tomaugspurger.github.io/method-chaining.html T2</li><li id="a96a" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu pe of og oh bi translated">[2] <a class="ae ky" href="https://www.dataschool.io/future-of-pandas/#methodchaining" rel="noopener ugc nofollow" target="_blank">来自 DataSchool.io 的熊猫未来</a></li></ul></div></div>    
</body>
</html>