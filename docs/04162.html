<html>
<head>
<title>Python Variable Assignment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python变量赋值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-variable-assignment-9f43aed91bff?source=collection_archive---------5-----------------------#2020-04-16">https://towardsdatascience.com/python-variable-assignment-9f43aed91bff?source=collection_archive---------5-----------------------#2020-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2c32" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解释Python编程语言最基本的概念之一</h2></div><p id="848e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文旨在解释Python变量赋值是如何工作的。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/98cb46d05666efce70ab35260ff5db99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6OxSGmQFYMTxZjRi"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">阿里安·达尔维什在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="a0db" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基础知识:变量—对象类型和范围</h1><ul class=""><li id="5cd1" class="mn mo it kk b kl mp ko mq kr mr kv ms kz mt ld mu mv mw mx bi translated">变量存储可以在程序中使用和/或更改的信息。该信息可以是整数、文本、集合等。</li><li id="4e85" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">变量用于保存用户输入、程序的本地状态等。</li><li id="314d" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">变量有一个<strong class="kk iu">名</strong>，这样它们就可以在代码中被引用。</li><li id="91ef" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">要理解的基本概念是，在Python中，一切都是对象。</li></ul><p id="61a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> Python支持数字、字符串、集合、列表、元组和字典。这些是标准的数据类型。我将详细解释它们中的每一个。</strong></p><h2 id="b491" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">声明变量并赋值</h2><p id="1aee" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">赋值给变量设置一个值。</p><p id="fa25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要给变量赋值，请使用等号(=)</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="6623" class="nd lw it nt b gy nx ny l nz oa">myFirstVariable = 1<br/>mySecondVariable = 2<br/>myFirstVariable = "Hello You"</span></pre><ul class=""><li id="72dd" class="mn mo it kk b kl km ko kp kr ob kv oc kz od ld mu mv mw mx bi translated">在Python中，赋值被称为<strong class="kk iu">绑定</strong>。在上面的例子中，我们将值2赋给了mySecondVariable。</li></ul><p id="df36" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="oe">注意我是如何将一个整数值1和一个字符串值“Hello You”赋给同一个myFirstVariable变量的。</em> <strong class="kk iu"> <em class="oe">这是可能的，因为数据类型在python中是动态类型化的。</em>T15】</strong></p><p id="4d77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是Python被称为动态类型编程语言的原因。</p><p id="7cc4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想将相同的值赋给多个变量，那么您可以使用链式赋值:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="9a63" class="nd lw it nt b gy nx ny l nz oa">myFirstVariable = mySecondVariable = 1</span></pre><h2 id="a2be" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">数字的</h2><ul class=""><li id="3dfe" class="mn mo it kk b kl mp ko mq kr mr kv ms kz mt ld mu mv mw mx bi translated">支持整数、小数、浮点数。</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="d7a9" class="nd lw it nt b gy nx ny l nz oa">value = 1 #integer<br/>value = 1.2 #float with a floating point</span></pre><ul class=""><li id="ed59" class="mn mo it kk b kl km ko kp kr ob kv oc kz od ld mu mv mw mx bi translated">也支持长整型。它们的后缀是L，例如999999999999L</li></ul><h2 id="a4bd" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">用线串</h2><ul class=""><li id="4d9d" class="mn mo it kk b kl mp ko mq kr mr kv ms kz mt ld mu mv mw mx bi translated">文本信息。字符串是一系列字母。</li><li id="967c" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">字符串是字符的数组</li><li id="5f52" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">字符串值用引号括起来:单引号、双引号或三引号。</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="8609" class="nd lw it nt b gy nx ny l nz oa">name = 'farhad'<br/>name = "farhad"<br/>name = """farhad"""</span></pre><ul class=""><li id="87c9" class="mn mo it kk b kl km ko kp kr ob kv oc kz od ld mu mv mw mx bi translated">字符串是不可变的。一旦创建，就不能更改，例如</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="b256" class="nd lw it nt b gy nx ny l nz oa">a = 'me'</span><span id="2a9a" class="nd lw it nt b gy of ny l nz oa">Updating it will fail:<br/>a[1]='y'</span><span id="91fc" class="nd lw it nt b gy of ny l nz oa">It will throw a Type Error</span></pre><ul class=""><li id="c406" class="mn mo it kk b kl km ko kp kr ob kv oc kz od ld mu mv mw mx bi translated">当变量被赋予一个新值时，Python会在内部创建一个新对象来存储这个值。</li></ul><p id="79ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，创建了对对象的引用/指针。然后将这个指针赋给这个变量，这样，这个变量就可以在程序中使用了。</p><p id="3227" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以将一个变量赋给另一个变量。它所做的只是创建一个指向同一对象的新指针:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="3b1b" class="nd lw it nt b gy nx ny l nz oa">a = 1 #new object is created and 1 is stored there, new pointer is created, the pointer connects a to 1<br/>b = a #new object is not created, new pointer is created only that connects b to 1</span></pre><h2 id="dfd1" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">变量可以有局部或全局范围。</h2><h2 id="c346" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">局部范围</h2><ul class=""><li id="55c8" class="mn mo it kk b kl mp ko mq kr mr kv ms kz mt ld mu mv mw mx bi translated">例如，在函数中声明的变量只能存在于块中。</li><li id="b818" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">一旦块存在，变量也变得不可访问。</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="2020" class="nd lw it nt b gy nx ny l nz oa">def some_funcion():<br/>  TestMode = False</span><span id="aebd" class="nd lw it nt b gy of ny l nz oa">print(TestMode) &lt;- Breaks as the variable doesn't exist outside</span></pre><p id="aba2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Python中，if-else和for/while循环块不创建任何局部范围。</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="4839" class="nd lw it nt b gy nx ny l nz oa">for i in range(1, 11):<br/>    test_scope = "variable inside for loop"</span><span id="7666" class="nd lw it nt b gy of ny l nz oa">print(test_scope)</span></pre><p id="fd30" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="719b" class="nd lw it nt b gy nx ny l nz oa">variable inside for loop</span></pre><p id="7dee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用if-else块</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="4e20" class="nd lw it nt b gy nx ny l nz oa">is_python_awesome = True</span><span id="9741" class="nd lw it nt b gy of ny l nz oa">if is_python_awesome:<br/>    test_scope = "Python is awesome"</span><span id="a2e8" class="nd lw it nt b gy of ny l nz oa">print(test_scope)</span></pre><p id="f914" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="39d6" class="nd lw it nt b gy nx ny l nz oa">Python is awesome</span></pre><h2 id="69aa" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">全球范围</h2><ul class=""><li id="e2f8" class="mn mo it kk b kl mp ko mq kr mr kv ms kz mt ld mu mv mw mx bi translated">可以从任何函数中访问的变量都具有全局范围。它们存在于__main__框架中。</li><li id="4fa8" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">您可以在函数外部声明一个全局变量。需要注意的是，要给一个全局变量赋一个新值，你必须使用"<em class="oe"> global </em>"关键字:</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="017b" class="nd lw it nt b gy nx ny l nz oa">TestMode = True<br/>def some_function():<br/>  global TestMode<br/>  TestMode = False</span><span id="06bc" class="nd lw it nt b gy of ny l nz oa">some_function()<br/>print(TestMode) &lt;--Returns False</span></pre><p id="a2f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="oe">删除“全局测试模式”这一行只会将some_function()函数中的变量设置为False。</em></p><p id="ff1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注意:虽然我稍后会写更多关于模块的概念，但是如果你想在多个模块间共享一个全局变量，你可以创建一个共享的模块文件，比如configuration.py，并在那里定位你的变量。最后，在您的消费者模块中导入共享模块。</strong></p><h2 id="c358" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">查找变量类型</h2><ul class=""><li id="a8bf" class="mn mo it kk b kl mp ko mq kr mr kv ms kz mt ld mu mv mw mx bi translated">如果要查找变量的类型，可以实现:</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="fee0" class="nd lw it nt b gy nx ny l nz oa">type('farhad')<br/>--&gt; Returns &lt;type 'str'&gt;</span></pre><h2 id="56d6" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">整数变量中的逗号</h2><ul class=""><li id="bf46" class="mn mo it kk b kl mp ko mq kr mr kv ms kz mt ld mu mv mw mx bi translated">逗号被视为一系列变量，例如</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="7660" class="nd lw it nt b gy nx ny l nz oa">9,8,7 are three numeric variables</span></pre><h1 id="5a71" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.操作</h1><ul class=""><li id="9ed7" class="mn mo it kk b kl mp ko mq kr mr kv ms kz mt ld mu mv mw mx bi translated">允许我们对变量进行计算</li></ul><h2 id="3dd2" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">数字运算</h2><ul class=""><li id="6a86" class="mn mo it kk b kl mp ko mq kr mr kv ms kz mt ld mu mv mw mx bi translated">Python支持基本的<strong class="kk iu"> *、/、+、- </strong></li><li id="6af9" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">Python也支持楼层划分</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="50b6" class="nd lw it nt b gy nx ny l nz oa">1//3  #returns 0<br/>1/3 #returns 0.333</span></pre><ul class=""><li id="de72" class="mn mo it kk b kl km ko kp kr ob kv oc kz od ld mu mv mw mx bi translated">此外，python支持通过**运算符求幂:</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="d79e" class="nd lw it nt b gy nx ny l nz oa">2**3 = 2 * 2 * 2 = 8</span></pre><ul class=""><li id="4068" class="mn mo it kk b kl km ko kp kr ob kv oc kz od ld mu mv mw mx bi translated">Python也支持模数(余数)运算符:</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="b9d9" class="nd lw it nt b gy nx ny l nz oa">7%2 = 1</span></pre><p id="6792" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个<strong class="kk iu"> divmod </strong>内置方法。它返回除法器和模数:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="4cce" class="nd lw it nt b gy nx ny l nz oa">print(divmod(10,3)) #it will print 3 and 1 as 3*3 = 9 +1 = 10</span></pre><h2 id="fa0a" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">字符串操作</h2><p id="70a4" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated"><strong class="kk iu">串联字符串:</strong></p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="570d" class="nd lw it nt b gy nx ny l nz oa">'A' + 'B' = 'AB'</span></pre><p id="07b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记住字符串是不可变的数据类型，因此，连接字符串会创建一个新的字符串对象。</p><p id="82e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">重复字符串:</strong></p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="4781" class="nd lw it nt b gy nx ny l nz oa">‘A’*3 will repeat A three times:  AAA</span></pre><p id="102c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">切片:</strong></p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="333b" class="nd lw it nt b gy nx ny l nz oa">y = 'Abc'<br/>y[:2] = ab<br/>y[1:] = bc<br/>y[:-2] = a<br/>y[-2:] = bc</span></pre><p id="d05a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">反转:</strong></p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="ac97" class="nd lw it nt b gy nx ny l nz oa">x = 'abc'<br/>x = x[::-1]</span></pre><p id="35ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">负指数:</strong></p><p id="4a60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想从最后一个字符开始，那么使用负索引。</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="37d6" class="nd lw it nt b gy nx ny l nz oa">y = 'abc'<br/>print(y[:-1]) # will return ab</span></pre><p id="1b38" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还用于移除任何新的线路托架/空间。</p><p id="f649" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数组中的每个元素都有两个索引:</p><ul class=""><li id="6ee3" class="mn mo it kk b kl km ko kp kr ob kv oc kz od ld mu mv mw mx bi translated">从左到右，索引从0开始，增量为1</li><li id="d672" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">从右到左，索引从-1开始，递减1</li><li id="30a6" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">因此，如果我们做y[0]和y[-len(y)]那么两者都将返回相同的值:“a”</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="db23" class="nd lw it nt b gy nx ny l nz oa">y = 'abc'<br/>print(y[0])<br/>print(y[-len(y)])</span></pre><p id="73de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">寻找指数</strong></p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="71f0" class="nd lw it nt b gy nx ny l nz oa">name = 'farhad'<br/>index = name.find('r')</span><span id="75a7" class="nd lw it nt b gy of ny l nz oa">#returns 2</span><span id="4119" class="nd lw it nt b gy of ny l nz oa">name = 'farhad'<br/>index = name.find('a', 2) # finds index of second a</span><span id="bbf1" class="nd lw it nt b gy of ny l nz oa">#returns 4</span></pre><p id="e8f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">对于正则表达式，使用:</strong></p><ul class=""><li id="6a82" class="mn mo it kk b kl km ko kp kr ob kv oc kz od ld mu mv mw mx bi translated">split():通过正则表达式将一个字符串拆分成一个列表</li><li id="2fe5" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">sub():通过正则表达式替换匹配的字符串</li><li id="876a" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">subn():通过正则表达式替换匹配的字符串，并返回替换次数</li></ul><h2 id="f376" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">铸造</h2><ul class=""><li id="282b" class="mn mo it kk b kl mp ko mq kr mr kv ms kz mt ld mu mv mw mx bi translated">str(x):到字符串</li><li id="9da6" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">int(x):到整数</li><li id="078c" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">浮动(x):到浮动</li><li id="1ed1" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">元组(列表):To元组:print(元组([1，2，3]))</li><li id="aa94" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">list(tuple(1，2，3)): To list: print(list((1，2，3)))</li></ul><p id="bac4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记住列表是可变的(可以更新),元组是不可变的(只读)</p><h2 id="7de7" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">集合操作</h2><ul class=""><li id="63f3" class="mn mo it kk b kl mp ko mq kr mr kv ms kz mt ld mu mv mw mx bi translated">该集合是没有任何重复的无序数据集合。我们可以将集合变量定义为:</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="56d7" class="nd lw it nt b gy nx ny l nz oa">a = {1,2,3}</span></pre><p id="b613" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">相交集</strong></p><ul class=""><li id="db5c" class="mn mo it kk b kl km ko kp kr ob kv oc kz od ld mu mv mw mx bi translated">得到两组的共同点</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="3d3e" class="nd lw it nt b gy nx ny l nz oa">a = {1,2,3}<br/>b = {3,4,5}<br/>c = a.intersection(b)</span></pre><p id="94e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">器械包差异</strong></p><ul class=""><li id="946d" class="mn mo it kk b kl km ko kp kr ob kv oc kz od ld mu mv mw mx bi translated">要检索两个集合之间的差异:</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="3a61" class="nd lw it nt b gy nx ny l nz oa">a = {1,2,3}<br/>b = {3,4,5}<br/>c = a.difference(b)</span></pre><p id="195f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">集合的联合</strong></p><ul class=""><li id="f997" class="mn mo it kk b kl km ko kp kr ob kv oc kz od ld mu mv mw mx bi translated">以获得两个集合的不同组合集合</li></ul><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="7b1c" class="nd lw it nt b gy nx ny l nz oa">a = {1,2,3}<br/>b = {3,4,5}<br/>c = a.union(b)</span></pre><h2 id="c93a" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">三元运算符</h2><ul class=""><li id="015b" class="mn mo it kk b kl mp ko mq kr mr kv ms kz mt ld mu mv mw mx bi translated">用于在单行中编写条件语句。</li></ul><p id="9f93" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">语法:</strong></p><p id="edb7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"><em class="oe">【If True】If【表情】Else【If False】</em></strong></p><p id="7ef9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="d143" class="nd lw it nt b gy nx ny l nz oa">Received = True if x == 'Yes' else False</span></pre><h1 id="7ac4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">对象身份</h1><p id="a170" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">我现在将尝试解释客体同一性的重要主题。</p><p id="782c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当我们在Python中创建一个对象，比如变量、函数等，底层的Python解释器都会创建一个唯一标识该对象的编号。一些对象是预先创建的。</p><p id="3602" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个对象在代码中不再被引用时，它就会被删除，它的标识号可以被其他变量使用。</p><ul class=""><li id="a2f3" class="mn mo it kk b kl km ko kp kr ob kv oc kz od ld mu mv mw mx bi translated">Python代码被加载到位于堆栈中的帧中。</li><li id="2a22" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">函数连同它们的参数和变量一起被加载到一个框架中。</li><li id="de8a" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">随后，帧以正确的执行顺序加载到堆栈中。</li><li id="32a4" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">堆栈概述了函数的执行。在函数外部声明的变量存储在__main__中</li><li id="6ace" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">Stacks首先执行最后一帧。</li></ul><p id="b197" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果遇到错误，您可以使用<strong class="kk iu">回溯</strong>来查找函数列表。</p><p id="a66a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> dir()和help() </strong></p><ul class=""><li id="222a" class="mn mo it kk b kl km ko kp kr ob kv oc kz od ld mu mv mw mx bi translated">dir()-显示定义的符号</li><li id="38a0" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">help()-显示文档</li></ul><h2 id="2a4e" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">我们来详细了解一下:</h2><p id="aa0a" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">考虑下面的代码:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="c86f" class="nd lw it nt b gy nx ny l nz oa">var_one = 123<br/>def func_one(var_one):<br/>    var_one = 234<br/>    var_three = 'abc'</span><span id="9c53" class="nd lw it nt b gy of ny l nz oa">var_two = 456<br/>print(dir())</span></pre><p id="357b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">var_one和var_two是上面代码中定义的两个变量。与变量一起，还定义了一个名为func_one的函数。需要记住的重要一点是，在Python中，一切都是对象，包括函数。</p><p id="e5ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在该函数中，我们将值234赋给了var_one，并创建了一个名为var_three的新变量，并将值“abc”赋给了它。</p><p id="cc3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">现在，让我们借助dir()和id() </strong>来理解代码</p><p id="fdef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述代码及其变量和函数将被加载到全局框架中。全局框架将包含其他框架需要的所有对象。例如，Python中加载了许多内置方法，可用于所有框架。这些是功能框架。</p><p id="ec40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行上面的代码将会打印:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="d68d" class="nd lw it nt b gy nx ny l nz oa"><em class="oe">[‘__annotations__’, ‘__builtins__’, ‘__cached__’, ‘__doc__’, ‘__file__’, ‘__loader__’, ‘__name__’, ‘__package__’, ‘__spec__’, </em><strong class="nt iu"><em class="oe">‘func_one’, ‘var_one’, ‘var_two’</em></strong><em class="oe">]</em></span></pre><p id="8bde" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以__为前缀的变量称为特殊变量。</p><p id="2338" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，var_three还不可用。让我们执行func_one(var_one)然后评估dir():</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="2f55" class="nd lw it nt b gy nx ny l nz oa">var_one = 123<br/>def func_one(var_one):<br/>    var_one = 234<br/>    var_three = 'abc'</span><span id="80bc" class="nd lw it nt b gy of ny l nz oa">var_two = 456<br/>func_one(var_one)<br/>print(dir())</span></pre><p id="eca5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将再次看到相同的列表:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="4825" class="nd lw it nt b gy nx ny l nz oa">['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'func_one', 'var_one', 'var_two']</span></pre><p id="bf99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着func_one内的变量只在func_one内。执行func_one时，会创建一个帧。Python是自顶向下的，因此它总是从上到下执行代码行。</p><p id="1e31" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">功能框架可以引用全局框架中的变量，但任何其他功能框架都不能引用在自身内部创建的相同变量。举个例子，如果我创建一个新的函数func_two，试图打印var_three，那么它将会失败:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="b76c" class="nd lw it nt b gy nx ny l nz oa">var_one = 123<br/>def func_one(var_one):<br/>    var_one = 234<br/>    var_three = 'abc'</span><span id="c6d5" class="nd lw it nt b gy of ny l nz oa">var_two = 456<br/></span><span id="81b7" class="nd lw it nt b gy of ny l nz oa">def func_two():<br/>    print(var_three)</span><span id="339a" class="nd lw it nt b gy of ny l nz oa">func_one(var_one)<br/>func_two()<br/>print(dir())</span></pre><p id="6f59" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到一个错误，即<strong class="kk iu">名称错误:名称“var_three”未定义</strong></p><p id="7b42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">如果我们在func_two()内部创建一个新变量，然后打印dir()会怎么样？</strong></p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="8df1" class="nd lw it nt b gy nx ny l nz oa">var_one = 123<br/>def func_one(var_one):<br/>    var_one = 234<br/>    var_three = 'abc'</span><span id="737b" class="nd lw it nt b gy of ny l nz oa">var_two = 456<br/></span><span id="3759" class="nd lw it nt b gy of ny l nz oa">def func_two():<br/>    var_four = 123<br/>    print(dir())</span><span id="c468" class="nd lw it nt b gy of ny l nz oa">func_two()</span></pre><p id="5a69" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打印var_four，因为它是func_two的本地变量。</p><h2 id="7a70" class="nd lw it bd lx ne nf dn mb ng nh dp mf kr ni nj mh kv nk nl mj kz nm nn ml no bi translated">Python中赋值是如何工作的？</h2><p id="7370" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">这是Python中最重要的概念之一。Python有一个id()函数。</p><p id="e52e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个对象(函数、变量等。)时，CPython会在内存中为它分配一个地址。id()函数返回一个对象的“身份”。它本质上是一个唯一的整数。</p><p id="7742" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，让我们创建四个变量并为它们赋值:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="46eb" class="nd lw it nt b gy nx ny l nz oa">variable1 = 1<br/>variable2 = "abc"<br/>variable3 = (1,2)<br/>variable4 = ['a',1]</span><span id="bbba" class="nd lw it nt b gy of ny l nz oa">#Print their Ids<br/>print('Variable1: ', id(variable1))<br/>print('Variable2: ', id(variable2))<br/>print('Variable3: ', id(variable3))<br/>print('Variable4: ', id(variable4))</span></pre><p id="2fab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">id将按如下方式打印:</p><p id="91f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量1: 1747938368 <br/>变量2: 152386423976 <br/>变量3: 152382712136 <br/>变量4: 152382633160</p><p id="ce37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个变量都被赋予一个新的整数值。</p><p id="d240" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个假设是，每当我们使用赋值“=”时，Python就会创建一个新的内存地址来存储变量。是不是百分百真实，不是真的！</p><p id="dd13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将创建两个变量，并将它们赋给现有的变量。</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="abbb" class="nd lw it nt b gy nx ny l nz oa">variable5 = variable1<br/>variable6 = variable4</span><span id="ce80" class="nd lw it nt b gy of ny l nz oa">print('Variable1: ', id(variable1))<br/>print('Variable4: ', id(variable4))<br/>print('Variable5: ', id(variable5))<br/>print('Variable6: ', id(variable6))</span></pre><p id="a7ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">蟒蛇皮印花:</p><p id="e6f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量1:<strong class="kk iu">1747938368</strong>T5】变量4: 819035469000 <br/>变量5:<strong class="kk iu">1747938368</strong>T9】变量6: 819035469000</p><p id="4efe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="oe">注意Python没有为这两个变量创建新的内存地址。这一次，它将两个变量指向同一个内存位置。</em></p><p id="f4c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们为变量1设置一个新值。记住2是整数，整数是不可变的数据类型。</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="c523" class="nd lw it nt b gy nx ny l nz oa">print('Variable1: ', id(variable1))<br/>variable1 = 2<br/>print('Variable1: ', id(variable1))</span></pre><p id="47f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打印:</p><p id="8691" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="oe">变量1: 1747938368 <br/>变量1: 1747938400 </em></p><p id="2ab2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">这意味着每当我们使用=并给一个不是变量引用的变量赋值时，就会在内部创建一个新的内存地址来存储该变量。让我们看看它能不能坚持住！</strong></p><p id="af6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当变量是可变数据类型时会发生什么？</p><p id="a9dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量6是一个列表。让我们给它添加一个条目并打印它的内存地址:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="1dcc" class="nd lw it nt b gy nx ny l nz oa">print('Variable6: ', id(variable6))<br/>variable6.append('new')<br/>print('Variable6: ', id(variable6))</span></pre><p id="6e9a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，变量的内存地址保持不变，因为它是可变数据类型，我们只是更新了它的元素。</p><p id="8620" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量6: 678181106888 <br/>变量6: 678181106888</p><p id="602e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建一个函数，并向它传递一个变量。如果我们在函数内部设置变量的值，它在内部会做什么？让我们评估一下</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="a7fd" class="nd lw it nt b gy nx ny l nz oa">def update_variable(variable_to_update):<br/> print(id(variable_to_update))<br/></span><span id="7ecf" class="nd lw it nt b gy of ny l nz oa">update_variable(variable6)</span><span id="c28d" class="nd lw it nt b gy of ny l nz oa"><br/>print(’Variable6: ', id(variable6))</span></pre><p id="423e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到:</p><p id="df09" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">678181106888 <br/>变量6: 678181106888</p><p id="3bdc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意variable_to_update的id指向变量6的id。</p><p id="6676" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着如果我们在一个函数中更新变量_to_update，并且如果变量_to_update是可变数据类型，那么我们将更新变量6。</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="224b" class="nd lw it nt b gy nx ny l nz oa">variable6 = [’new’]<br/>print(’Variable6: ', variable6</span><span id="c72c" class="nd lw it nt b gy of ny l nz oa">def update_variable(variable_to_update):    variable_to_update.append(’inside’)</span><span id="7585" class="nd lw it nt b gy of ny l nz oa">update_variable(variable6)<br/>print('Variable6: ', variable6)</span></pre><p id="0c45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是打印的:</p><p id="9503" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量6: ['新'] <br/>变量6: ['新'，'内部']</p><p id="d10d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它向我们展示了同一个对象在函数中按照预期被更新，因为它们有相同的ID。</p><p id="0b86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们给一个变量赋一个新值，不管它的数据类型是不可变的还是可变的，一旦我们从函数中出来，这个变化就会丢失:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="29eb" class="nd lw it nt b gy nx ny l nz oa">print('Variable6: ', variable6)</span><span id="8bc4" class="nd lw it nt b gy of ny l nz oa">def update_variable(variable_to_update):<br/>    print(id(variable_to_update))<br/>    variable_to_update = ['inside']</span><span id="bb3b" class="nd lw it nt b gy of ny l nz oa">update_variable(variable6)<br/>print('Variable6: ', variable6)</span></pre><p id="cd8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量6: ['新'] <br/> 344115201992 <br/>变量6: ['新']</p><p id="bfa8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在有一个有趣的场景:Python并不总是为所有新变量创建一个新的内存地址。让我解释一下。</p><p id="b63b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，如果我们给两个不同的变量赋值一个字符串值，比如' a '会怎么样。会不会产生两个内存地址？</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="39d3" class="nd lw it nt b gy nx ny l nz oa">variable_nine = "a"<br/>variable_ten = "a"<br/>print('Variable9: ', id(variable_nine))<br/>print('Variable10: ', id(variable_ten))</span></pre><p id="3ddd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，这两个变量有相同的内存位置:</p><p id="0d9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量9: 792473698064</p><p id="dadc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们创建两个不同的变量并给它们分配一个长字符串值会怎么样:</p><pre class="lf lg lh li gt ns nt nu nv aw nw bi"><span id="6549" class="nd lw it nt b gy nx ny l nz oa">variable_nine = "a"*21<br/>variable_ten = "a"*21<br/>print('Variable9: ', id(variable_nine))<br/>print('Variable10: ', id(variable_ten))</span></pre><p id="89a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这次Python为两个变量创建了两个内存位置:</p><p id="fdf6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量9: 541949933872 <br/>变量10: 541949933944</p><p id="a412" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为Python在启动时会创建一个值的内部缓存。这样做是为了提供更快的结果。它为-5到256之间的小整数和更小的字符串值创建了一些内存地址。这就是为什么我们例子中的两个变量有相同的ID。</p><p id="49e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文解释了变量是如何赋值的。</p><p id="5b70" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想详细了解Python，请阅读本文:</p><div class="og oh gp gr oi oj"><a href="https://medium.com/fintechexplained/everything-about-python-from-beginner-to-advance-level-227d52ef32d2" rel="noopener follow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">关于Python的一切——从初级到高级</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">在一篇文章中你需要知道的一切</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">medium.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox lo oj"/></div></div></a></div></div></div>    
</body>
</html>