<html>
<head>
<title>Find your way out of a mass of tourist attractions — A city itinerary planner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在众多旅游景点中寻找出路——城市行程规划者</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/find-your-way-out-of-a-mass-of-tourist-attractions-a-city-itinerary-planner-eb9c1731f851?source=collection_archive---------22-----------------------#2020-01-18">https://towardsdatascience.com/find-your-way-out-of-a-mass-of-tourist-attractions-a-city-itinerary-planner-eb9c1731f851?source=collection_archive---------22-----------------------#2020-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4ab6a2ac8156ba0b640acacd2a25b900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*glT6baTxoLJEi0PP6-wNTA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:谷歌搜索</p></figure><div class=""/><p id="4692" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">数据科学的最终目标是优化人们的生活，尤其是日常生活。从我的生活中找到真正的问题和不便，并利用技术工具来解决它，这正是我如何在这个寒假发现数据科学的魅力。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><p id="75c3" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">整个故事始于我的旧金山之旅，这是一个世界闻名但对我来说却有些陌生的城市。我知道我要去参观金门大桥、朗伯德街、斯坦福大学和其他著名的景点。然而，伴随我兴奋而来的是任何旅行中最烦人和最耗时的部分——为一天的往返行程制定一个有效的旅行计划。事实上，对于那些到一个不熟悉的城市旅行的人来说，规划行程是一个很常见的障碍，因为通常情况下，我们不知道每个景点的位置以及它们各自相对于彼此的方向，这使得设计一条精心规划的路线变得极其困难。我能做的最好的事情就是在谷歌地图上标出每一个感兴趣的地方，并根据我内置的雷达直觉设计一条旅行路线。大体上知道去哪个地区是容易的，但困扰我的是确定在一个区域内去的地方的具体顺序。例如，我知道我将在SF的东北部(在地图中圈出)度过我的第一天，但我很难立即找到最省时高效的路线来覆盖地图中所有标记的地方。此外，游客开始一天生活的最典型地点——住宿的酒店，将在很大程度上影响他们随后选择的路线。</p><figure class="ll lm ln lo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lk"><img src="../Images/efe7b6d1d129df83dd81367bc0351f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*bmLBFUOg3GftDHf2Sp2R2g.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><em class="lp">图1:旧金山旅行的准备工作</em></p></figure><p id="d9a0" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">被每天规划旅行路线的不便所困扰，我转向算法来实现路线设计的自动化。这个项目的目标是解决一个痛点:我如何优化一天往返的路线？</p><h1 id="581f" class="lq lr ji bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">数据收集</strong></h1><p id="27fc" class="pw-post-body-paragraph kf kg ji kh b ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky ms la lb lc im bi translated">我需要的数据无非就是地理信息。因此，唯一的数据来源是谷歌地图。使用了他们的几个应用程序接口(API)。具体来说，我需要旅游景点的名称，各自的经度和纬度，所在的城市，路线的长度，以及估计的乘车旅行时间。</p><h1 id="4db0" class="lq lr ji bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">假设</strong></h1><p id="bc6e" class="pw-post-body-paragraph kf kg ji kh b ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky ms la lb lc im bi translated">我为这个项目做了几个假设。</p><p id="c93a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">1.源和目的地应该相同。在现实世界中，典型的一日城市游是往返旅行。我假设你旅行的起点是你住宿的地方，比如一个Airbnb公寓(我这里不是打广告)或者一个酒店房间。固定起点的目的是提供个性化的旅行路线，因为开始旅行的地点将在很大程度上影响当天剩余时间的旅行路线设计。此外，没有人喜欢在忙碌了一天游览城市后的游牧生活。</p><p id="b496" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">2.全程你都要开车。为了方便编程，运输工具固定为汽车。游客在旅游期间可能会改变停留的地点，以及他们选择交通工具的个人偏好。然而，在这个项目的最初版本中，这些可能性都被排除了。</p><h1 id="7768" class="lq lr ji bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">背景</strong></h1><p id="adba" class="pw-post-body-paragraph kf kg ji kh b ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky ms la lb lc im bi translated">我在访问SF时遇到的问题的本质是一个经典的动态规划问题——旅行推销员问题(TSP)。在TSP中，要问的问题是:“给定一个城市列表和每对城市之间的距离，访问每个城市并最终绕回到原始城市的最短可能路线是什么？”因此，处理这个问题的主要算法类似于TSP的解决方案。</p><h1 id="ca5b" class="lq lr ji bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">让我们开始吧！</strong></h1><p id="ceb7" class="pw-post-body-paragraph kf kg ji kh b ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky ms la lb lc im bi translated">该项目的蓝图如下:</p><p id="fc9d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Python用于实现算法和数据信息检索。web开发框架Flask用于嵌入Python脚本和制作交互式web用户界面(UI)。</p><p id="9a14" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">步骤1:定义一个Python函数，从Google Map APIs中检索两个地方之间的地理数据，以便TSP算法能够运行。</p><pre class="ll lm ln lo gt mt mu mv mw aw mx bi"><span id="e1c8" class="my lr ji mu b gy mz na l nb nc"><strong class="mu jj">import </strong>tsp<br/><strong class="mu jj">import </strong>numpy <strong class="mu jj">as </strong>np<br/><strong class="mu jj">import </strong>requests<br/>def get_api(source, dest):<br/>    gmaps_key = 'YOUR GOOGLE MAP API'<br/>    url ='<a class="ae nd" href="https://maps.googleapis.com/maps/api/distancematrix/json?'" rel="noopener ugc nofollow" target="_blank">https://maps.googleapis.com/maps/api/distancematrix/json?'</a><br/>    r = requests.get(url + 'origins=' + source +<br/>                     '&amp;destinations=' + dest +<br/>                     '&amp;key=' + gmaps_key)<br/>    x = r.json()<br/>    x = dict(x)<br/>    distance = str(x['rows'][0]['elements'][0]['distance']['text']).replace(" km", "").replace(",", "")<br/>    return float(distance)</span></pre><p id="f35e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第二步:获取用户输入。用户可以输入他们旅程的起点/终点，以及他们想去的中间地点。</p><pre class="ll lm ln lo gt mt mu mv mw aw mx bi"><span id="9d2c" class="my lr ji mu b gy mz na l nb nc">#determine the ending of a loop.<br/>flag = 1<br/>#geolist<br/>list = []<br/># get the starting point<br/>dimensions = input("please enter 1 to start your journey ...\nand enter 0 to end...")<br/>if dimensions == "1":<br/>    dimensions = input("\nplease input the source &amp; dest to start your journey...")<br/>    list.append(dimensions)<br/>    while flag == 1:<br/>            #prompt the in-between places<br/>        dimensions = input("\nplease input any place within your journey...")<br/>        if dimensions == "0":<br/>            flag = 0<br/>        else:<br/>            list.append(dimensions)<br/>else:<br/>    print("\nyour journey ends...\n")</span><span id="3ccf" class="my lr ji mu b gy ne na l nb nc">print("the places you want to go are ",list," , and you want to go back to ",list[0]," after this busy day..")</span></pre><p id="104d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">步骤3:用中间位置构建每个起点/终点，并将它们集成到配对元组中，并将它们推送到一个列表中。</p><pre class="ll lm ln lo gt mt mu mv mw aw mx bi"><span id="5bf0" class="my lr ji mu b gy mz na l nb nc">#construct a source-destination pair<br/>source_dest_pair = []<br/>for i in range(0,len(list)):<br/>    #source;<br/>    source = list[i]<br/>    for j in range(i+1,len(list)):<br/>        #destination<br/>        temp = []<br/>        temp.append(source)<br/>        dest = list[j]<br/>        temp.append(dest)<br/>        source_dest_pair.append(temp)</span></pre><p id="3454" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">步骤4:应用步骤1中定义的函数计算每对的距离。</p><pre class="ll lm ln lo gt mt mu mv mw aw mx bi"><span id="8379" class="my lr ji mu b gy mz na l nb nc">#construct a list to get distance for each pair<br/>distance_list=[]</span><span id="be84" class="my lr ji mu b gy ne na l nb nc">#calculate distance for each pair using get_api function<br/>    for i in range(0,len(source_dest_pair)):<br/>        distance_list.append(get_api(source_dest_pair[i][0],source_dest_pair[i][1]))</span></pre><p id="67fc" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">步骤5:构建一个距离矩阵，其中存储了每对地点的对应距离。</p><pre class="ll lm ln lo gt mt mu mv mw aw mx bi"><span id="8317" class="my lr ji mu b gy mz na l nb nc">distance_matrix=[]<br/>for i in range(0,len(list)):<br/>    temp_matrix = [0] * len(list)<br/>    distance_matrix.append(temp_matrix)</span><span id="f5df" class="my lr ji mu b gy ne na l nb nc">temp_list_row = distance_list.copy()</span><span id="380c" class="my lr ji mu b gy ne na l nb nc">for i in range(0,distance_matrix.__len__()):<br/>    # for each source<br/>    for j in range(i+1,distance_matrix.__len__()):<br/>        distance_matrix[i][j] = temp_list_row.pop(0)</span><span id="e6e1" class="my lr ji mu b gy ne na l nb nc">temp_list_col = distance_list.copy()</span><span id="1b5b" class="my lr ji mu b gy ne na l nb nc">for i in range(0,distance_matrix.__len__()):<br/>    # for each source<br/>    for j in range(i+1,distance_matrix.__len__()):<br/>        distance_matrix[j][i] = temp_list_col.pop(0)</span></pre><p id="8b54" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">步骤6:将距离矩阵中的值转换为字典格式，这是Python中常用的键值对数据结构，也是TSP算法工作的兼容格式。然后，应用算法，得到最有效的出行路线。</p><pre class="ll lm ln lo gt mt mu mv mw aw mx bi"><span id="538d" class="my lr ji mu b gy mz na l nb nc">r = range(len(distance_matrix))</span><span id="b5bb" class="my lr ji mu b gy ne na l nb nc">#construct a path matrix and put it into a dictionary<br/>shortestpath = {(i,j): distance_matrix[i][j] for i in r for j in r}</span><span id="8ff9" class="my lr ji mu b gy ne na l nb nc">print("----------------------------------------------")<br/>print("\nyour travel routine is ")</span><span id="b3bb" class="my lr ji mu b gy ne na l nb nc">for i in range(len(tsp.tsp(r,shortestpath)[1])):<br/>    print(list[tsp.tsp(r,shortestpath)[1][i]],end=" -&gt; ")<br/>print(list[0],end="")<br/>print(", and the total distance of travel is: ",tsp.tsp(r,shortestpath)[0], " km.")</span></pre><p id="8b74" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是该项目的视频演示。</p><figure class="ll lm ln lo gt iv"><div class="bz fp l di"><div class="nf ng l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">项目演示</p></figure><p id="cd18" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">【http://uihojk.pythonanywhere.com/】点击以下链接，您可以尝试设计自己的旅行路线:<a class="ae nd" href="http://uihojk.pythonanywhere.com/" rel="noopener ugc nofollow" target="_blank"/></p><p id="2a7e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh jj">注意:</strong>出于认证目的，用户必须通过谷歌地图申请自己的API，然后才能成功使用该产品。关于如何从Google Maps获取API的详细说明可以通过以下链接找到:</p><div class="is it gp gr iu nh"><a href="https://developers.google.com/maps/documentation/embed/get-api-key" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jj gy z fp nm fr fs nn fu fw jh bi translated">获取API密钥|地图嵌入API | Google开发者</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">新用户:在开始使用谷歌地图平台API和SDK之前，你必须注册并创建一个账单…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">developers.google.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv ja nh"/></div></div></a></div><h1 id="a979" class="lq lr ji bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">限制</strong></h1><p id="6e7b" class="pw-post-body-paragraph kf kg ji kh b ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky ms la lb lc im bi translated">有几个限制。当我在考虑用户界面时，我发现谷歌地图上显示的计算出的有效路线是一种理想的可视化方式，让用户对他们将拥有的计划有一种直观的感觉。不幸的是，Google API不允许任何包含方向层的HTML格式输出(如果我想显示路线，我需要添加一个方向层)。因此，包含方向和顺序引导的直接地图在本项目中不适用。</p><figure class="ll lm ln lo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/cc899d50b780d773cc7c65490f7fa0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3IBO6zHZK0huv3iwcDXrxQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><em class="lp">图2:最终输出的理想可视化效果</em></p></figure><p id="f85a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">与此同时，用户界面仍然是一项正在进行的工作，在功能和美学方面都有改进的空间。在当前版本中，最多总共有10个位置。但是，如果用户不想访问那么多位置，他们就被迫使用0来填充web表单中的空白。下一个版本将会有一个动态的网络表单，用户只需点击“再添加一个停靠点”按钮，就可以提示服务器提供额外的空间来添加位置。</p><p id="06cc" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此外，为了准确定位感兴趣的地方，我必须避免任何歧义(例如，具有相同的名称，但在不同的城市)，因此用户必须在每个地方后添加这些地方所在的城市名称。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><p id="77e3" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">过去，我一直认为很难产生一个好的商业想法。然而，请记住，数据科学源于日常生活，因此，请反思您的活动，并尝试解决您经常面临的问题。你可能会对身边等待你抓住的机会数量感到震惊——很多机会和有趣的东西其实就在我们身边。</p><h1 id="a455" class="lq lr ji bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">参考</h1><p id="ecd6" class="pw-post-body-paragraph kf kg ji kh b ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky ms la lb lc im bi translated"><a class="ae nd" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Travelling_salesman_problem</a></p><p id="ac1a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae nd" href="https://jupyter-gmaps.readthedocs.io/en/latest/tutorial.html" rel="noopener ugc nofollow" target="_blank">https://jupyter-gmaps . readthedocs . io/en/latest/tutorial . html</a></p><p id="836f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae nd" href="https://console.developers.google.com/apis" rel="noopener ugc nofollow" target="_blank">https://console.developers.google.com/apis</a></p></div></div>    
</body>
</html>