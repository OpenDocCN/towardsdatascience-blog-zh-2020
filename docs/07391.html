<html>
<head>
<title>Deep into partitioning databases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入分区数据库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deep-into-partitioning-in-databases-b5e53197cae0?source=collection_archive---------29-----------------------#2020-06-04">https://towardsdatascience.com/deep-into-partitioning-in-databases-b5e53197cae0?source=collection_archive---------29-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="37ba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于数据库中数据如何分区的所有内容</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/67c3f3f0c04ec3cf839196e14fcf6136.png" data-original-src="https://miro.medium.com/v2/0*496yV8IsN49YUYz3"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">照片来自<a class="ae ku" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/</a></p></figure><p id="dfa1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">数据库是任何应用程序设计中不可或缺的一部分，在应用程序设计中，进程会写入和管理数据。尽管可能永远不需要从头开始设计数据库，但了解其设计以及不同数据库处理数据的方式将有助于您选择最合适的数据存储，从而提供所需的可伸缩性和性能。本文将详细介绍数据库如何处理数据分区。</p><h1 id="6327" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">什么是数据分区？</h1><p id="1085" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">数据库中的数据被分成多个分区。每个分区都被定义为每个数据恰好驻留在一个分区中。一个节点可以包含多个分区。进行分区是为了确保可伸缩性，因为整个数据可能无法放入单个节点。不同的分区可以驻留在不同的节点上。每个节点都可以用自己的分区提供查询服务。这个过程也被称为<strong class="kx iu">分片</strong>。除了分区，每个分区还被复制到多个节点以确保可用性。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/228bdf919e30074272a2b51f443f3b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xYEqDhfx_nIlIRUw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">数据分区(来源:<a class="ae ku" href="https://docs.microsoft.com/en-us/rest/api/storageservices/designing-a-scalable-partitioning-strategy-for-azure-table-storage" rel="noopener ugc nofollow" target="_blank">微软文档</a></p></figure><h1 id="9d1e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">倾斜的分区和热点</h1><p id="2e81" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">创建数据分区所遵循的技术可能会导致分区之间的负载分布不均匀。一些分区比其他分区提供更多的查询。这种不公平的划分被称为倾斜。在极端情况下，整个负载可以在单个分区ie上结束。5个分区中有4个是空闲的。具有不成比例的高负载的分区被称为热点。这种分区效率较低，会导致节点间的负载分布不均匀。</p><h1 id="6b52" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">数据分区的方法</h1><p id="914a" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">我们将讨论三种不同的数据分区方法:</p><ol class=""><li id="8831" class="mp mq it kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">随机分布</li><li id="738a" class="mp mq it kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">按键范围分区</li><li id="226f" class="mp mq it kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">通过键的散列进行分区</li></ol><h1 id="51bc" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">密钥的随机分布</h1><p id="b3ce" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">一种简单的方法是将数据随机平均分配到不同的分区中。这将导致相等的数据分布，但是没有办法确定哪个键位于哪个分区。这将使阅读变得极其困难。</p><h1 id="73c4" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">按键范围分区</h1><p id="ce41" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">另一种方法是将关键字划分为不同的范围，并将每个范围分配给一个分区。例如，值为A–E的键可以位于分区1，F–K位于分区2，L–R位于分区3，依此类推。范围需要等间距。例如，具有关键字F、G、H的数据可以更少，并导致形成其中具有更多关键字的范围(F-K)。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/a73373fd865cb773f2dba8a22b8adb8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fS-UeLqeWblh64RR.gif"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">按键分区(来源:<a class="ae ku" href="https://aws.amazon.com/blogs/database/sharding-with-amazon-relational-database-service/" rel="noopener ugc nofollow" target="_blank"> AWS博客</a></p></figure><p id="48d0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这种方法的优点是数据在分区之间均匀分布，并简化了范围查询。但是这种方法的问题是它可能导致热点的形成。考虑一种情况，其中密钥依赖于时间戳。在这种情况下，所有的写流量都将移动到单个分区。</p><h1 id="1ac7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">通过键的散列进行分区</h1><p id="f9f4" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">另一种方法可以是计算密钥的散列，并且每个分区可以被分配一个散列范围。在这种情况下，一个好的散列函数不需要在加密方面很强，但应该均匀地分布数据。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ni"><img src="../Images/ca647e072e71e5016a5e7984c4c915b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LeE-P7ry9EFKCg5S.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">通过范围键的散列进行分区(来源:<a class="ae ku" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.Partitions.html" rel="noopener ugc nofollow" target="_blank"> AWS文档</a></p></figure><p id="b852" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它将在不同的分区之间平均分配数据和负载，但是使得范围查询变得困难。</p><h1 id="6a28" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">分区和辅助索引</h1><p id="4e41" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">辅助索引用于根据不同于主键的字段高效地查询数据。分区将如何解决二级索引上的查询？如果整个数据都驻留在一个分区中，那么为整个数据创建一个二级索引并使用它就很简单了。分区使辅助索引上的查询变得复杂。这种查询有两种方法:</p><ol class=""><li id="79fc" class="mp mq it kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated"><strong class="kx iu"> <em class="nj">按文档划分二级索引(或本地索引)</em> </strong>:这样每个分区维护自己的本地二级索引。查询作为分散和收集工作，即它需要从每个分区收集结果，然后合并它。</li></ol><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nk"><img src="../Images/9561068b04ca6b0200db84b19cd85aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nTS-odNcP35avhtT.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">按文档划分二级索引(<em class="nl">来源:</em> <a class="ae ku" href="http://a-fwd.to/1AuRTAU" rel="noopener ugc nofollow" target="_blank">设计数据密集型应用</a>)</p></figure><p id="2bfb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="nj"> 2。</em> <strong class="kx iu"> <em class="nj">按项划分二级索引(或全局索引)</em> </strong> <em class="nj"> : </em>这里有一个覆盖全部数据的全局二级索引。对于每个键，它存储它所在的分区。由于单个节点可能无法容纳完整的索引，因此全局索引也可以划分到不同的节点中。例如，带有键A-R的索引可以驻留在节点1上，而驻留在节点2上。全局索引增加了写入延迟，但提供了更快的读取速度。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nm"><img src="../Images/dab9ae111db1aa8b0d40a00ece60e041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4PEE9K5mEROBXydQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><em class="nl">按项目划分二级索引(来源:</em> <a class="ae ku" href="http://a-fwd.to/1AuRTAU" rel="noopener ugc nofollow" target="_blank">设计数据密集型应用</a></p></figure><h1 id="6d51" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">重新平衡分区</h1><p id="d008" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">随着时间的推移，数据可能会增长，查询类型可能会改变，或者需要替换、删除或添加一些节点。这种情况包括将数据从一个节点移动到另一个节点。重新平衡的要求是:</p><ol class=""><li id="1ad2" class="mp mq it kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">重新平衡后，负载应该在节点间平均分配。</li><li id="a601" class="mp mq it kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">在重新平衡时，数据库应该能够提供读写ie。数据存储应该可用。</li><li id="5acf" class="mp mq it kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">不应在节点之间移动不必要的数据。</li></ol><p id="0be8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">重新平衡可以自动完成，也可以手动完成。</p><h1 id="0da7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">再平衡战略</h1><ol class=""><li id="70a9" class="mp mq it kx b ky mj lb mk le nn li no lm np lq mu mv mw mx bi translated"><em class="nj">怎么不做</em>:为什么不通过hash(key) mod N给一个分区分配键，其中N是节点数？因为随着N的变化，它将需要大量的重新洗牌和分区移动。</li><li id="c8f0" class="mp mq it kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated"><em class="nj">固定分区数量:</em>决定分区数量。分区数量可以大于节点数量(N)。每个节点将包含许多分区。当删除或添加一个节点时，一些现有分区可以移动到新节点。</li><li id="4a29" class="mp mq it kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated"><em class="nj">动态分区:</em>在固定分区的情况下，分区无法适应不断增长的数据量。在动态分区中，您可以决定分区的初始数量。随着分区大小随着数据的增加而增加，它会拆分以创建新的分区。同样，如果数据被删除，它也会收缩。拆分后，其中一个分区可以分配给不同的节点。</li><li id="d691" class="mp mq it kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated"><em class="nj">按节点比例划分:</em>在这种情况下，每个节点包含固定数量的分区。每个分区的大小与数据集的大小成比例增长。当添加一个新节点时，一些现有的分区被分成两半，一半被移动到新节点。分区边界是随机选取的，因此需要通过键的散列进行分区。</li></ol><h1 id="4293" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">资源</h1><p id="bd69" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">要阅读更多关于数据库和应用程序设计的内容，我强烈推荐阅读Martin Kleppmann的“<a class="ae ku" href="http://a-fwd.to/1AuRTAU" rel="noopener ugc nofollow" target="_blank">设计数据密集型应用程序</a>”。</p><p id="f64d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">希望你喜欢这篇文章！</p></div></div>    
</body>
</html>