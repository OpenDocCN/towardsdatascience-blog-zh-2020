<html>
<head>
<title>An Intro to Graph Theory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图论导论</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-intro-to-graph-theory-centrality-measurements-and-networkx-1c2e580adf37?source=collection_archive---------13-----------------------#2020-04-03">https://towardsdatascience.com/an-intro-to-graph-theory-centrality-measurements-and-networkx-1c2e580adf37?source=collection_archive---------13-----------------------#2020-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b3be" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何制作、理解和计算图形的性质</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d277b6b9ba92efae84719f4305107aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DfACVGfKyMHr4wdKbA_PA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://commons.wikimedia.org/wiki/User:AzaToth" rel="noopener ugc nofollow" target="_blank">阿扎托斯</a>拍摄</p></figure><p id="bbdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图论是对图形的研究，图形是用来模拟对象之间成对关系的数学结构。这些图由通常代表一个对象或一个人的节点(也称为点和顶点)和代表节点之间关系的边(也称为线或链接)组成。图在机器学习中有许多用途，所以这篇博客文章将研究如何制作图，关于图的一些关键测量和如何计算它们，以及如何使用Python的NetworkX包执行这些计算。</p><h2 id="a6f4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">创建图表</h2><p id="6706" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">用NetworkX包创建一个图形并不太难，只需确保它和matplotlib一起导入，以便您可以绘制它。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f4d7" class="lv lw it mu b gy my mz l na nb">import networkx as nx<br/>import matplotlib.pyplot as plt</span><span id="1f9e" class="lv lw it mu b gy nc mz l na nb">G = nx.Graph()<br/>G.add_node('A')<br/>nx.draw(G, with_labels=True)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/1d289e71f6db8413236be4094eaebcd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*6Y60vvYf0HJx2r4kQya7Qg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单个节点的图</p></figure><p id="a95b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像这样，你就有了一张图表！我们可以通过添加更多的节点和边来使这些图形变得更加复杂。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4612" class="lv lw it mu b gy my mz l na nb">G = nx.Graph()<br/>G.add_edge('A','B')<br/>nx.draw(G, with_labels=True)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/794282bb8c47c94afaa2cf691bf7aa8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*2lPnQeRicsBDjMcaMvJr8w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用无向边表示两个节点A和B的图。</p></figure><p id="d9f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加边允许我们检查节点之间的关系。可以在<a class="ae ky" href="https://networkx.github.io/documentation/stable/index.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到NetworkX包的完整概述。这里创建的边是一条无向边，这意味着节点<em class="nf"> A </em>和<em class="nf"> B </em>之间的关系是相等的。如果我们想做一个有方向的边呢？我们可以用有向图函数来实现。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e103" class="lv lw it mu b gy my mz l na nb">G = nx.DiGraph()<br/>G.add_edge('A','B')<br/>nx.draw(G, with_labels=True)<br/>plt.show()<br/></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/1affb3ff27cf5afd81cf7b9d7af4cec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*OuIWupgIoQTqnaOURYnDmA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表示两个节点A和B的图，这两个节点有一条从A到B的有向边。</p></figure><p id="03f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果看起来像上面的图，除了现在边上有一个箭头，它向我们显示了边指向的方向。有向边可以代表现实世界中的许多事情，如社交媒体影响或传染病的传播。</p><p id="e7e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然漂亮的图片看起来很有趣，但很难从中获得洞察力，特别是如果它们有大量的节点和边。幸运的是，我们可以对图表进行测量，这可以给我们提供有价值的信息。让我们画一个更复杂的图，这样我们可以更好地理解这些测量。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c56b" class="lv lw it mu b gy my mz l na nb">G = nx.Graph()<br/>G.add_edge('A','B')<br/>G.add_edge('A','C')<br/>G.add_edge('A','D')<br/>G.add_edge('B','C')<br/>G.add_edge('B','E')<br/>G.add_edge('B','F')<br/>G.add_edge('C','E')<br/>G.add_edge('C','D')<br/>G.add_edge('C','F')<br/>G.add_edge('E','F')<br/>G.add_edge('D','G')<br/>G.add_edge('F','G')<br/>G.add_edge('G','H')<br/>G.add_edge('G','I')<br/>G.add_edge('H','J')<br/>G.add_edge('H','K')<br/>G.add_edge('H','L')<br/>G.add_edge('J','M')<br/>G.add_edge('J','N')<br/>G.add_edge('J','O')<br/>G.add_edge('J','K')<br/>G.add_edge('J','L')<br/>G.add_edge('M','N')<br/>G.add_edge('M','L')<br/>G.add_edge('N','O')<br/>G.add_edge('O','P')<br/>G.add_edge('P','Q')<br/>nx.draw(G, with_labels=True)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/99f6c8061329dd9a50be34035ddc357b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*1jqFW0jbuIRxFbeJmEw9zw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">所创建图形的绘图</p></figure><h2 id="46f1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">中心性测量</h2><p id="6994" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">中心性测量给我们提供了关于图中节点重要性的信息。取决于节点的位置、它有多少个连接以及它连接到什么其他节点，它们可以对图有很大的影响。这里将看看一些更受欢迎的中心性测量和他们是如何计算的。</p><p id="5c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Degree_%28graph_theory%29" rel="noopener ugc nofollow" target="_blank">度中心性</a>测量连接到一个节点的边的数量。它用于确定哪些节点连接最紧密。在有向图中，度中心性分为传入边的入度和传出边的出度。要计算一个节点的归一化度中心性，只需将连接到该节点的边数相加，然后除以节点总数减1。在数学上，如果我们想找到节点<em class="nf"> x，</em>的度中心性，我们可以使用以下等式</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a8c45cac3511e83c48037767c792b581.png" data-original-src="https://miro.medium.com/v2/resize:fit:306/format:webp/1*Djvd9V80-SE2gc6A752hyw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">度中心性方程</p></figure><p id="e4fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<em class="nf"> N </em>是图上节点的数量，而<em class="nf"> a </em>具有0或1的值，这取决于节点<em class="nf"> x </em>和<em class="nf"> y </em>是否共享一条边。我们可以使用下面的代码来查找每个节点的度中心性度量。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a437" class="lv lw it mu b gy my mz l na nb">for node in G.nodes():<br/>    print(node, nx.degree_centrality(G)[node])</span></pre><p id="669d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给了我们结果</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/e214b149a8579645184e2b8a7a7a8b4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:194/format:webp/1*Hy_G4LfesX16W6ouLGr0qA.png"/></div></figure><p id="e073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明节点<em class="nf"> J </em>具有最大的度中心性。这很容易从视觉上验证，因为<em class="nf"> J </em>的大多数边都与6连接。</p><p id="49c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Closeness_centrality" rel="noopener ugc nofollow" target="_blank">接近中心性</a>测量从一个节点到任何其他节点的平均距离。一个节点越中心，它离所有其他节点就越近。节点的紧密度通常是指其归一化形式，由以下等式给出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/64bfa15708ba9f939f1f70c1ad9743ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*q95ilhTEI60-TZA2hsJM3A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">接近中心性方程</p></figure><p id="62df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<em class="nf"> N </em>是图上的节点数，<em class="nf"> d(y，x) </em>是顶点<em class="nf"> x </em>和<em class="nf"> y </em>之间的距离。在图论中，距离是最短路径中的边数。在大图中，<em class="nf"> -1 </em>变得很小，所以通常会被丢弃。使用代码</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8fbb" class="lv lw it mu b gy my mz l na nb">for node in G.nodes():<br/>    print(node, nx.closeness_centrality(G, node))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d86024774d6b735564833ba0f3ebbe1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*LxSVRzCZrSsoN6cY5nDExw.png"/></div></figure><p id="a47e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将节点<em class="nf"> H </em>视为最高的接近中心性，这意味着它比所有其他节点更接近大多数节点。</p><p id="2a22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Betweenness_centrality" rel="noopener ugc nofollow" target="_blank">中间中心性</a>:测量节点所在的最短路径的数量。这种中心性通常用于确定图中的信息流。数字越大，通过它的信息就越多。中间中心性可以用下面的等式来计算</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/900dca60dd64c2380d02c951e28a8e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*Fi6y03elWHCbvSkqbsow-g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">中间中心性</p></figure><p id="8e0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中分母是顶点<em class="nf"> u </em>和<em class="nf"> v </em>之间的最短路径数，分子是顶点<em class="nf"> u </em>和<em class="nf"> v </em>之间经过顶点<em class="nf"> x </em>的最短路径数。典型地，该测量被重新调整，并且通常通过将该值除以不包括<em class="nf"> x </em>的对的数量来完成，留给我们0和1之间的最终值。对于有向图，值除以<em class="nf"> (N-1)(N-2) </em>，对于无向图，值除以<em class="nf"> (N-1)(N-2)/2 </em>。用代码</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="21dc" class="lv lw it mu b gy my mz l na nb">for node in G.nodes(): <br/>    print(node, nx.betweenness_centrality(G)[node])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9716d51afebaf3780c8e101a761ee79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*5p8yM4Mk2RZsBFWbHt1bHw.png"/></div></figure><p id="d71d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到节点<em class="nf"> G </em>在我们的图中具有最高的中间中心度，这意味着它位于最短的路径上。</p><p id="950d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Eigenvector_centrality" rel="noopener ugc nofollow" target="_blank">特征向量中心性</a>:测量节点在网络中的相对影响力，或者一个节点与其他高度连接的节点的连接程度。这是对“重要的不是你知道什么，而是你认识谁”这句话的数学度量。</p><p id="8398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算特征向量的中心性比计算其他中心性稍微复杂一点(或者复杂很多)。数学上，特征向量的中心性是通过以下等式计算的</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/5060fc423b381fed8be0d05533c6eeed.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*VwHYRRtep345XcBLTwUGBQ.png"/></div></figure><p id="8bb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中𝜆是计算的最大特征值，<em class="nf"> M(x) </em>是顶点<em class="nf"> x </em>的一组邻居，<em class="nf"> y </em>是相邻顶点，<em class="nf"> G </em>是被求值的图。<em class="nf"> a </em>根据<em class="nf"> x </em>和<em class="nf"> y </em>是否为邻居，取值为0或1。这个表达式是特征向量方程的一个解</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/939d8f9b675562552149ab3b63eb5e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:152/format:webp/1*XTew0MTpGbqSKJSFtx9j6Q.png"/></div></figure><p id="fb66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，<strong class="lb iu"> A </strong>是<a class="ae ky" href="https://en.wikipedia.org/wiki/Adjacency_matrix" rel="noopener ugc nofollow" target="_blank">邻接矩阵</a>，它本质上以矩阵形式计算节点之间的连接数量，𝜆是上面提到的特征值，而<strong class="lb iu"> x </strong>是我们正在求解的特征向量。</p><p id="bfc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理大型矩阵时，为了避免寻找大次数多项式的特征值解，通过迭代过程找到特征向量。这更清楚地解释了这个过程，让我们看一个简单的例子。让我们从下面的简单图表开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c067ee40f2bfcf67973ec2aa2b8f048c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*VoML-DEjnRTob_hgjRVvPw.png"/></div></figure><p id="bb97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有4个节点<em class="nf"> A </em>、<em class="nf"> B </em>、<em class="nf"> C </em>和<em class="nf"> D </em>，它们之间有边(<em class="nf"> A </em>、<em class="nf"> B </em>)、(<em class="nf"> A </em>、<em class="nf"> C </em>)、(<em class="nf"> A </em>、<em class="nf"> D </em>)和(<em class="nf"> B </em>)邻接矩阵看起来像</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/0b40a9f12ac805a193d898f67108b67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*YQhnDfvfI9SIMF_ZR7UmjQ.png"/></div></figure><p id="6ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中元素在行和列方向上排列为<em class="nf"> A </em>、<em class="nf"> B </em>、<em class="nf"> C </em>和<em class="nf"> D </em>。矩阵中的数字表示有多少条边连接每个节点。例如，左上角的数字是0，因为有0条边将<em class="nf"> A </em>连接到<em class="nf"> A </em>。因为我们的图是没有方向的，所以我们的矩阵是对称的。</p><p id="5d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里开始，我们将这个矩阵乘以我们的初始向量，它只是一个1的向量。这给了我们结果</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/9d8e15eb2af0c9ee3c518b27ea39aef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*chP97dOyFAA1pbkZ9s_tPA.png"/></div></div></figure><p id="ff83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里开始，我们用归一化的向量代替初始向量，把它插回到方程中。重复这个过程给了我们</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/f9c61339d65c4a282ca2b23458febca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*q2sBgkhpkYgUqg6Q88Fp8w.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/38acf9cff7c904732969e0bff27584ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*rh3VQ5Nf2UZ-T-cM5yBKQw.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/d27ac1a556f9c4a3315415bc80ed8b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*NgNKK736xNJxXO47i0wo5Q.png"/></div></figure><p id="dbb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程一直持续到特征向量收敛到稳定解。在这个例子中，最终的解决方案是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/94a69e16c738a119d438cd9f01a9f8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*jb2oF9QTZ43enJvC70lL0w.png"/></div></figure><p id="f770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们了解了这个过程是如何发生的，我们就可以计算原始图的特征值中心性了。我们可以用代码做到这一点</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5a1c" class="lv lw it mu b gy my mz l na nb">for node in G.nodes(): <br/>    print(node, nx.eigenvector_centrality(G, max_iter=1000)[node])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/ad38baa8dee772b6d48733cbbdd990fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*pEIJOxcMu6baYrh60DUNHg.png"/></div></figure><p id="c1e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明节点<em class="nf"> C </em>具有最大的特征向量中心性。有趣的是注意到所有四个中心性测量的最大值是在不同的节点上。</p><p id="9269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于图和中心性度量还有很多要学的，我希望这篇文章能让你开始你的图之旅。</p><h2 id="2159" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">推荐读物</h2><div class="ny nz gp gr oa ob"><a href="https://en.wikipedia.org/wiki/Graph_theory" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">图论</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">在数学中，图论是对数学结构的研究，这些数学结构用于模拟成对关系…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">en.wikipedia.org</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div></div></div>    
</body>
</html>