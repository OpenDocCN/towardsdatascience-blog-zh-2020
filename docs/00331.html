<html>
<head>
<title>How to Code Inheritance in Java — Beginner’s Tutorial in OOP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Java 中编写继承代码——面向对象的初学者教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-code-inheritance-in-java-beginners-tutorial-in-oop-d0fc0a71be98?source=collection_archive---------19-----------------------#2020-01-10">https://towardsdatascience.com/how-to-code-inheritance-in-java-beginners-tutorial-in-oop-d0fc0a71be98?source=collection_archive---------19-----------------------#2020-01-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="bd49" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">面向对象编程</h2><div class=""/><div class=""><h2 id="b815" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">让我们来理解面向对象编程中“继承”的概念</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0a1ed2a60a70957c218aec13cfe281db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kLoXipbvWJ-t14c4"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@hngstrm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亨利&amp;公司</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3c57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">韦氏在线词典将遗传定义为<em class="me">从过去几代人那里获得一种财产、条件或特征。</em>在<a class="ae lh" rel="noopener" target="_blank" href="/beginners-in-java-getting-started-with-oop-6398f0dcdf86">面向对象设计中</a>继承有相似(不完全相同)的内涵。继承意味着</p><ol class=""><li id="d3c1" class="mf mg it lk b ll lm lo lp lr mh lv mi lz mj md mk ml mm mn bi translated">以层次结构组织班级</li><li id="c2db" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated">较高层次从较低层次继承属性</li><li id="00cd" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated">把相似的东西归入同一类</li><li id="b870" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated">等级越高，等级就从一般到特殊</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mt"><img src="../Images/ee2e80190434ce2e0448205ce7af1235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CaTNbDiboMzEXuBB2AaDjg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">层次结构看起来如何|由<a class="ae lh" href="https://www.flaticon.com/authors/pixel-perfect" rel="noopener ugc nofollow" target="_blank">像素完美制作的图标</a>来自<a class="ae lh" href="http://www.flaticon.com/" rel="noopener ugc nofollow" target="_blank">www.flaticon.com</a></p></figure><p id="b616" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这意味着最基本的类，也称为<strong class="lk jd">基类</strong>，将是最通用的一个。它也被称为父类或超类。例如,“电子产品”是基类，它的<strong class="lk jd">子类</strong>将是“手机”或“音响系统”。</p><blockquote class="mu mv mw"><p id="4e56" class="li lj me lk b ll lm kd ln lo lp kg lq mx ls lt lu my lw lx ly mz ma mb mc md im bi translated">要了解更多关于构造类的基础知识，关于字段、方法和构造函数的细节，你可以参考这篇文章。</p></blockquote><p id="9eed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用数学符号，手机是电子设备的子集，但却是固定电话的超集。级别之间的对应关系通常被称为<strong class="lk jd"> <em class="me">“是”关系</em> </strong>，即电话是电子产品，座机是电话</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi na"><img src="../Images/a2e3fdb79917a75e1182cbbe1ffbcf5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*or2cEgY60PLtC4HFvEioVQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd nb">是/是</strong>的层次关系</p></figure><p id="c28a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随着我们在等级中的地位越来越高，我们变得越来越具体。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nc"><img src="../Images/8e90b711014f4626489a4bbe430fce34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SYfgHUs2o-QVNrYMhETqug.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">等级和一般性</p></figure><p id="ebc8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种分层设计非常有用，因为它促进了代码的重用。共同的功能可以归入同一个类别，而不同的行为可以形成特定的情况或子类。</p><p id="0a22" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用专业术语来说，我们说子类<strong class="lk jd"> <em class="me">扩展了超类</em> </strong>。当使用继承时，子类自动从超类继承所有的<strong class="lk jd">方法</strong>(除了构造函数)。子类通过以下两种方法将其自身与其超类区分开来。</p><ol class=""><li id="53e1" class="mf mg it lk b ll lm lo lp lr mh lv mi lz mj md mk ml mm mn bi translated">它可以<strong class="lk jd"> <em class="me">通过添加新字段和新方法来扩充</em> </strong>超类。</li><li id="034c" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated">它<strong class="lk jd"> <em class="me">通过提供现有方法的新实现来覆盖</em> </strong>现有行为。</li></ol><blockquote class="mu mv mw"><p id="701b" class="li lj me lk b ll lm kd ln lo lp kg lq mx ls lt lu my lw lx ly mz ma mb mc md im bi translated">类—一组相似的对象<br/>字段—类的属性<br/>对象—类的实例<br/>方法—可应用于对象的操作<br/>构造函数—用于创建对象的操作</p></blockquote><h1 id="226e" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">理论够了。我们来编码吧！</h1><p id="df4d" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">作为一个更简单的例子，让我们考虑下面的层次。图书作为基类，电子书和纸质书作为 2 个子类。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/836cbdc5851d14a9d555d2411384cf94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xPR1IbBKNz7d-lyvXQ_dMA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="http://Icons made by Pixel perfect from www.flaticon.com" rel="noopener ugc nofollow" target="_blank">图标来源</a></p></figure><ul class=""><li id="ec4e" class="mf mg it lk b ll lm lo lp lr mh lv mi lz mj md ob ml mm mn bi translated"><strong class="lk jd">图书字段</strong> —作者姓名、成本价、售价、书名和页数</li><li id="bcda" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md ob ml mm mn bi translated"><strong class="lk jd">记账方法</strong> —净利润()和 getTax()</li><li id="4670" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md ob ml mm mn bi translated"><strong class="lk jd">电子书字段</strong> —下载网站和大小 MB</li><li id="750d" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md ob ml mm mn bi translated"><strong class="lk jd">电子书方法</strong> — pageSize()，printTitle()和 getTax()</li></ul><p id="88a0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，书籍字段是每本书都必须具有的属性。因为电子书将从 book 类继承，所以它将拥有 book 类的字段以及它自己的 2 个字段。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="8ede" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在要注意的是，ebook 不仅可以访问 book 类的两个方法，即 netProfit()和 getTax()，而且还可以修改它们。请注意下面代码中对税收计算的修改。在下面的代码中，注意 EBook 是如何通过使用关键字<strong class="lk jd"> extends 来继承 Book 的。</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><ul class=""><li id="90c7" class="mf mg it lk b ll lm lo lp lr mh lv mi lz mj md ob ml mm mn bi translated"><strong class="lk jd">增强</strong> — EBook 类通过添加字段 downloadSite 和 sizeMB 以及添加方法 pageSize()来增强 Book 类。注意，downloadSite 与纸质书无关，所以不能放在 Book 类中。此外，pageSize()是以 MBs 为单位测量的，因此它只适用于电子书。</li><li id="4657" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md ob ml mm mn bi translated"><strong class="lk jd">撤销— </strong>除了 30%的利润税之外，电子书还要额外支付 2 美元的税。在这里，我们可以看到 EBook 类覆盖了原始的 getTax()方法，在原始税收计算的基础上增加了固定的 2 美元费用。</li></ul><p id="7617" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在上一篇文章中看到，当程序运行时，它是实际运行的主方法。因为我们在上面的两个类中没有包含任何 main 方法，所以我们将创建一个单独的测试文件来编写 main 方法并运行这两个类。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4be1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">testbook 类的输出清楚地显示了继承的作用。我们甚至可以在电子书上打印图书类的字段。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oe"><img src="../Images/6123ad429c241543fb0a6cbebe813d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*52lvEsG8MINsBQLUe-uDAA.png"/></div></div></figure></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h2 id="4058" class="om ne it bd nf on oo dn nj op oq dp nn lr or os np lv ot ou nr lz ov ow nt iz bi translated">注意事项</h2><ul class=""><li id="0d4a" class="mf mg it lk b ll nv lo nw lr ox lv oy lz oz md ob ml mm mn bi translated">继承通过使用关键字<strong class="lk jd">扩展</strong>来工作</li><li id="46c4" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md ob ml mm mn bi translated">构造函数永远不会被继承，只有字段和方法会被继承</li><li id="d382" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md ob ml mm mn bi translated">即使一个类定义没有显式使用 extends 子句，它也会自动继承一个类，<strong class="lk jd"> java.lang.Object </strong>，它是 java 中的通用超类</li><li id="e0f5" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md ob ml mm mn bi translated">在 Java 中，使用关键字 super 调用超类的构造函数</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/59891e5b56b9841c6230eb5638006260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51Eeu7bR0ZbEmImtuS6_TQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">看看 super()函数——它调用了超类的构造函数</p></figure><p id="4198" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">完整的代码在<a class="ae lh" href="https://github.com/rishisidhu/inheritance_java" rel="noopener ugc nofollow" target="_blank">这个 git repo </a>里。</p></div></div>    
</body>
</html>