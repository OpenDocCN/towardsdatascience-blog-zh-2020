<html>
<head>
<title>Complete Image Augmentation in OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenCV 中的完整图像增强</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/complete-image-augmentation-in-opencv-31a6b02694f5?source=collection_archive---------10-----------------------#2020-05-13">https://towardsdatascience.com/complete-image-augmentation-in-opencv-31a6b02694f5?source=collection_archive---------10-----------------------#2020-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0da6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是一篇详尽的文章，通过使用 Python 中的 OpenCV 的自定义数据生成器，涵盖了所有的图像增强功能。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8928f4d6e6136e70627fcec70ff205e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hLZGBZrDNK0_A67W"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@steve_j?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯蒂夫·约翰森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="1570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">答</span>几天前，我在写一篇关于使用不同色彩空间作为 CNN 输入的文章<a class="ae ky" rel="noopener" target="_blank" href="/different-colorspaces-as-inputs-to-cnns-406ae62d1bd6?source=friends_link&amp;sk=92a03aaf5c423b0c61558b87febfdb3d">，为此，我不得不使用一个定制的数据生成器。这意味着我不能使用 Tensorflow 的内置图像数据生成器进行图像放大。我在网上搜索并找到了一些文章，但找不到任何全面涵盖这个主题的内容，所以我决定写一篇。</a></p><h1 id="c586" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">目录</h1><ul class=""><li id="3225" class="mw mx it lb b lc my lf mz li na lm nb lq nc lu nd ne nf ng bi translated">水平移动</li><li id="a35f" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">垂直移位</li><li id="a6a1" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">聪明</li><li id="0188" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">一款云视频会议软件</li><li id="45cc" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">频道转换</li><li id="5a27" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">水平翻转</li><li id="68e3" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">垂直翻转</li><li id="a306" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">旋转</li><li id="8377" class="mw mx it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">填充模式</li></ul><p id="3601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道这些是如何工作的，你可以看看这篇文章。为了形象化，我将使用下面的凯旋门图片。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c57f98efaa21cad66b4bbb0c91027ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*_6oVkevOvRtVUhOCzkLklA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试图像</p></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="ef99" class="me mf it bd mg mh nu mj mk ml nv mn mo jz nw ka mq kc nx kd ms kf ny kg mu mv bi translated">水平移动</h1><p id="fcf5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">水平移动或平移是根据定义最大移动量的比率向左或向右移动图像。默认情况下，Keras 使用一种叫做“最近”的填充模式来将图像的尺寸调整回原始尺寸。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b5ede4d16017a93b613d681b5a87765f.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*HIqxRF8sp2RPlcpTpiT5Ag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">填充模式“最近”的结果</p></figure><p id="bc8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我觉得这会使那部分图像变得无用，因此我会简单地将它们调整到原来的大小。因此，要做到这一点，我们需要生成一个随机数，然后使用索引向左或向右移动图像。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="6d1a" class="oi mf it oe b gy oj ok l ol om">import cv2<br/>import random</span><span id="7780" class="oi mf it oe b gy on ok l ol om">img = cv2.imread('arc_de_triomphe.jpg')</span><span id="e476" class="oi mf it oe b gy on ok l ol om">def fill(img, h, w):<br/>    img = cv2.resize(img, (h, w), cv2.INTER_CUBIC)<br/>    return img<br/>        <br/>def horizontal_shift(img, ratio=0.0):<br/>    if ratio &gt; 1 or ratio &lt; 0:<br/>        print('Value should be less than 1 and greater than 0')<br/>        return img<br/>    ratio = random.uniform(-ratio, ratio)<br/>    h, w = img.shape[:2]<br/>    to_shift = w*ratio<br/>    if ratio &gt; 0:<br/>        img = img[:, :int(w-to_shift), :]<br/>    if ratio &lt; 0:<br/>        img = img[:, int(-1*to_shift):, :]<br/>    img = fill(img, h, w)<br/>    return img</span><span id="7241" class="oi mf it oe b gy on ok l ol om">img = horizontal_shift(img, 0.7)<br/>cv2.imshow('Result', img)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/913e025b9d717b625215c11eae88ad51.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*_h8YfUmK9z4qGE5eDPa6Jg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">水平移动</p></figure><h1 id="394e" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">垂直移位</h1><p id="8cd1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">在我们知道如何实现水平移动之后，实现垂直移动就相当容易了。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="1a9d" class="oi mf it oe b gy oj ok l ol om">import cv2<br/>import random</span><span id="89c0" class="oi mf it oe b gy on ok l ol om">img = cv2.imread('arc_de_triomphe.jpg')</span><span id="157a" class="oi mf it oe b gy on ok l ol om">def fill(img, h, w):<br/>    img = cv2.resize(img, (h, w), cv2.INTER_CUBIC)<br/>    return img</span><span id="8246" class="oi mf it oe b gy on ok l ol om">def vertical_shift(img, ratio=0.0):<br/>    if ratio &gt; 1 or ratio &lt; 0:<br/>        print('Value should be less than 1 and greater than 0')<br/>        return img<br/>    ratio = random.uniform(-ratio, ratio)<br/>    h, w = img.shape[:2]<br/>    to_shift = h*ratio<br/>    if ratio &gt; 0:<br/>        img = img[:int(h-to_shift), :, :]<br/>    if ratio &lt; 0:<br/>        img = img[int(-1*to_shift):, :, :]<br/>    img = fill(img, h, w)<br/>    return img</span><span id="daaf" class="oi mf it oe b gy on ok l ol om">img = vertical_shift(img, 0.7)<br/>cv2.imshow('Result', img)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/f04f0c42c4d31af32782c6cc4a0960e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*YKTD5SucH7YO6fmvphqulg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">垂直移位</p></figure><h1 id="3206" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">聪明</h1><p id="efa8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">这很容易，因为我已经写了一篇关于创建不同的图像过滤器漫画，夏天，冬天等，它已经包括亮度功能。</p><div class="op oq gp gr or os"><a href="https://medium.com/dataseries/designing-image-filters-using-opencv-like-abode-photoshop-express-part-1-8765e3f4495b" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">使用 OpenCV 设计图像滤镜(第 1 部分)</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">我们都编辑过我们的图像，也许是为了改善白平衡，增加温暖，使用不同的滤镜，甚至…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><p id="1b59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们利用 HSV 色彩空间来完成这项任务。饱和度和值矩阵的值越多，亮度就越大。因此，要增加亮度，请将它们乘以一个大于 1 的值，要降低亮度，请乘以一个小于 1 的值。在 Tensorflow 中，指定了一个范围，并在其中选择了一个随机值，所以这就是我们如何创建它。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="3b22" class="oi mf it oe b gy oj ok l ol om">import cv2<br/>import random<br/>import numpy as np</span><span id="8078" class="oi mf it oe b gy on ok l ol om">img = cv2.imread('arc_de_triomphe.jpg')</span><span id="690b" class="oi mf it oe b gy on ok l ol om">def brightness(img, low, high):<br/>    value = random.uniform(low, high)<br/>    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)<br/>    hsv = np.array(hsv, dtype = np.float64)<br/>    hsv[:,:,1] = hsv[:,:,1]*value<br/>    hsv[:,:,1][hsv[:,:,1]&gt;255]  = 255<br/>    hsv[:,:,2] = hsv[:,:,2]*value <br/>    hsv[:,:,2][hsv[:,:,2]&gt;255]  = 255<br/>    hsv = np.array(hsv, dtype = np.uint8)<br/>    img = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)<br/>    return img</span><span id="ec93" class="oi mf it oe b gy on ok l ol om">img = brightness(img, 0.5, 3)<br/>cv2.imshow('Result', img)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/a872aecf974cdfa37b1bb942cb293366.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*ced5M1OEKw4Y176aKRrKXA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">聪明</p></figure><h1 id="183b" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">一款云视频会议软件</h1><p id="3591" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">在 Tensorflow 中，缩放函数采用一个范围，并在该范围之间使用随机值。如果这些值小于 1，它会放大图像，如果值大于 1，它会缩小图像并“最近”填充图像。然而，当我们调整图像的尺寸时，我们只取小于 1 的值。例如:值为 0.6 意味着取整个图像的 60%，然后我们将把它调整回原始大小。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="2048" class="oi mf it oe b gy oj ok l ol om">import cv2<br/>import random</span><span id="63cf" class="oi mf it oe b gy on ok l ol om">img = cv2.imread('arc_de_triomphe.jpg')</span><span id="80d9" class="oi mf it oe b gy on ok l ol om">def fill(img, h, w):<br/>    img = cv2.resize(img, (h, w), cv2.INTER_CUBIC)<br/>    return img</span><span id="6cef" class="oi mf it oe b gy on ok l ol om">def zoom(img, value):<br/>    if value &gt; 1 or value &lt; 0:<br/>        print('Value for zoom should be less than 1 and greater than 0')<br/>        return img<br/>    value = random.uniform(value, 1)<br/>    h, w = img.shape[:2]<br/>    h_taken = int(value*h)<br/>    w_taken = int(value*w)<br/>    h_start = random.randint(0, h-h_taken)<br/>    w_start = random.randint(0, w-w_taken)<br/>    img = img[h_start:h_start+h_taken, w_start:w_start+w_taken, :]<br/>    img = fill(img, h, w)<br/>    return img</span><span id="5f46" class="oi mf it oe b gy on ok l ol om">img = zoom(img, 0.5)<br/>cv2.imshow('Result', img)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/ba0ba83e521f5a46538462f21d6fd320.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*Alrp8hYxouUVjbEGaxmOXQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一款云视频会议软件</p></figure><h1 id="5a66" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">频道转换</h1><p id="367c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">在通道偏移中，随机数量的值被添加到从指定范围中选择的图像的所有通道中。它的结果有点像亮度函数。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="ea32" class="oi mf it oe b gy oj ok l ol om">import cv2<br/>import random<br/>import numpy as np</span><span id="98d2" class="oi mf it oe b gy on ok l ol om">img = cv2.imread('arc_de_triomphe.jpg')</span><span id="e7ff" class="oi mf it oe b gy on ok l ol om">def channel_shift(img, value):<br/>    value = int(random.uniform(-value, value))<br/>    img = img + value<br/>    img[:,:,:][img[:,:,:]&gt;255]  = 255<br/>    img[:,:,:][img[:,:,:]&lt;0]  = 0<br/>    img = img.astype(np.uint8)<br/>    return img</span><span id="68f8" class="oi mf it oe b gy on ok l ol om">img = channel_shift(img, 60)<br/>cv2.imshow('Result', img)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/2003984373d5d6a13fc746fa9973f098.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*Z3WqTl3UDlAICg8hzdLPmQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">频道转换</p></figure><h1 id="2798" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">水平翻转</h1><p id="0c96" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">我认为这不需要任何解释。它采用一个布尔变量来定义是否要执行水平翻转。OpenCV <code class="fe pi pj pk oe b">cv2.flip</code>中有一个内置函数就是用来执行这个操作的。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="00fc" class="oi mf it oe b gy oj ok l ol om">import cv2</span><span id="acfa" class="oi mf it oe b gy on ok l ol om">img = cv2.imread('arc_de_triomphe.jpg')<br/>def horizontal_flip(img, flag):<br/>    if flag:<br/>        return cv2.flip(img, 1)<br/>    else:<br/>        return img</span><span id="8bd6" class="oi mf it oe b gy on ok l ol om">img = horizontal_flip(img, True)<br/>cv2.imshow('Result', img)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/31473829036c8a3a4b1e2640083720c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*zi99PqJ_fu4hAP9UISQOng.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">水平翻转</p></figure><h1 id="8175" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">垂直翻转</h1><p id="f717" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">像水平翻转一样，使用<code class="fe pi pj pk oe b">cv2.flip</code>来执行，但是它的第二个参数应该是 0。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="53d0" class="oi mf it oe b gy oj ok l ol om">import cv2</span><span id="428a" class="oi mf it oe b gy on ok l ol om">img = cv2.imread('arc_de_triomphe.jpg')<br/>def vertical_flip(img, flag):<br/>    if flag:<br/>        return cv2.flip(img, 0)<br/>    else:<br/>        return img</span><span id="35a9" class="oi mf it oe b gy on ok l ol om">img = vertical_flip(img, True)<br/>cv2.imshow('Result', img)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/0ee42d85abdf3a9da8d293c5723f9b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*giQ_odn_idqrJw1QIWUAEA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">垂直翻转</p></figure><h1 id="fc9b" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">旋转</h1><p id="dcda" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">要在 OpenCV 中执行旋转，我们需要创建一个旋转矩阵，然后对其应用仿射变换。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="6637" class="oi mf it oe b gy oj ok l ol om">import cv2</span><span id="bc78" class="oi mf it oe b gy on ok l ol om">img = cv2.imread('arc_de_triomphe.jpg')<br/>def rotation(img, angle):<br/>    angle = int(random.uniform(-angle, angle))<br/>    h, w = img.shape[:2]<br/>    M = cv2.getRotationMatrix2D((int(w/2), int(h/2)), angle, 1)<br/>    img = cv2.warpAffine(img, M, (w, h))<br/>    return img</span><span id="2d85" class="oi mf it oe b gy on ok l ol om">img = rotation(img, 30)    <br/>cv2.imshow('Result', img)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/ab145ed21062c0d8a24efdefb7470c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*3BFKk6p477iMAZ1sztRCIA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">旋转</p></figure><h1 id="92b4" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">填充模式</h1><p id="047c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">上面我提到了“最近的”填充模式，我说过我不会使用它，而是调整图像的大小。我决定向你展示如何在 OpenCV 中创建填充模式，因为我试图创建一个完整的列表，所以如果你想执行一个，你不会有任何问题。来自 Tensorflow 的<a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/image/ImageDataGenerator" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="pl pm pn"><p id="cc65" class="kz la po lb b lc ld ju le lf lg jx lh pp lj lk ll pq ln lo lp pr lr ls lt lu im bi translated"><code class="fe pi pj pk oe b"><strong class="lb iu">fill_mode</strong></code>:为{“常数”、“最近”、“反射”或“换行”之一。默认值为“最近”。根据给定模式填充输入边界外的点:</p><p id="a065" class="kz la po lb b lc ld ju le lf lg jx lh pp lj lk ll pq ln lo lp pr lr ls lt lu im bi translated">' constant ':kkkkkkkkk | ABCD | kkkkkkkk(cval = k)</p><p id="1e22" class="kz la po lb b lc ld ju le lf lg jx lh pp lj lk ll pq ln lo lp pr lr ls lt lu im bi translated">' nearest ':aaaaaaaa | ABCD | dddddddd</p><p id="3cb1" class="kz la po lb b lc ld ju le lf lg jx lh pp lj lk ll pq ln lo lp pr lr ls lt lu im bi translated">' reflect ':abcddcba | ABCD | dcbaabcd</p><p id="82cc" class="kz la po lb b lc ld ju le lf lg jx lh pp lj lk ll pq ln lo lp pr lr ls lt lu im bi translated">' wrap': abcdabcd|abcd|abcdabcd</p></blockquote><p id="972f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我会让它们水平移动。<code class="fe pi pj pk oe b">cv2.copyMakeBorder</code>可用于灌装。它接受图像、顶部、底部、左侧、右侧和模式等参数。上、下、左、右是边框的大小。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="f71b" class="oi mf it oe b gy oj ok l ol om">import cv2<br/>from matplotlib import pyplot as plt</span><span id="330c" class="oi mf it oe b gy on ok l ol om">img = cv2.imread('arc_de_triomphe.jpg')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><span id="80ac" class="oi mf it oe b gy on ok l ol om">def fill_mode(img, left, right):<br/>    nearest = cv2.copyMakeBorder(img, 0, 0, left, right, cv2.BORDER_REPLICATE)<br/>    reflect = cv2.copyMakeBorder(img, 0, 0, left, right, cv2.BORDER_REFLECT)<br/>    wrap = cv2.copyMakeBorder(img, 0, 0, left, right, cv2.BORDER_WRAP)<br/>    constant= cv2.copyMakeBorder(img, 0, 0, left, right, cv2.BORDER_CONSTANT,value=(255, 0, 0))<br/>    <br/>    plt.subplot(221),plt.imshow(nearest,'gray'),plt.title('NEAREST'),plt.axis('off')<br/>    plt.subplot(222),plt.imshow(reflect,'gray'),plt.title('REFLECT'),plt.axis('off')<br/>    plt.subplot(223),plt.imshow(wrap,'gray'),plt.title('WRAP'),plt.axis('off')<br/>    plt.subplot(224),plt.imshow(constant,'gray'),plt.title('CONSTANT'),plt.axis('off')</span><span id="7682" class="oi mf it oe b gy on ok l ol om">def horizontal_shift_mode(img, ratio):<br/>    if ratio &gt; 1 or ratio &lt; 0:<br/>        print('Value for horizontal shift should be less than 1 and greater than 0')<br/>        return img<br/>    ratio = random.uniform(-ratio, ratio)<br/>    h, w = img.shape[:2]<br/>    to_shift = int(w*ratio)<br/>    if ratio &gt; 0:<br/>        img = img[:, :w-to_shift, :]<br/>        fill_mode(img, to_shift, 0)<br/>    if ratio &lt; 0:<br/>        img = img[:, -1*to_shift:, :]<br/>        fill_mode(img, 0, -1*to_shift)</span><span id="de23" class="oi mf it oe b gy on ok l ol om">horizontal_shift_mode(img, 0.8)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/5d7247116e0910dd69cc14b3913365a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*-MvR_SkwEsKqcLc1T3gdKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">填充模式</p></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="cd22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是这篇文章的全部内容。如果你想知道如何创建一个自定义的数据生成器，那么你可以看看我下面的文章。</p><div class="op oq gp gr or os"><a rel="noopener follow" target="_blank" href="/different-colorspaces-as-inputs-to-cnns-406ae62d1bd6"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">不同的色彩空间作为 CNN 的输入</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">找出通过自定义数据生成器在 CNN 中使用不同的色彩空间是否会导致更好的结果…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">towardsdatascience.com</p></div></div><div class="pb l"><div class="pt l pd pe pf pb pg ks os"/></div></div></a></div></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="b6c7" class="oi mf it bd mg pu pv dn mk pw px dp mo li py pz mq lm qa qb ms lq qc qd mu qe bi translated">编辑</h2><p id="aea2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">莱昂纳多·米兰达让我注意到了两个很棒的图像增强库，分别叫做<a class="ae ky" href="https://github.com/aleju/imgaug" rel="noopener ugc nofollow" target="_blank"> imagaug </a>和<a class="ae ky" href="https://github.com/albumentations-team/albumentations" rel="noopener ugc nofollow" target="_blank">albuminations</a>。它们可用于 pip 和 conda 安装。它们提供了从基础到非常高级的大量图像增强。我发现关于它们最好的部分是甚至对于分割和边界框也有增强。我鼓励每个人去看看他们的自述，他们太棒了。</p></div></div>    
</body>
</html>