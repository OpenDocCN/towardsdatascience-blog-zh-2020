<html>
<head>
<title>Build Apps Powered by Language with Semantic ML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用语义 ML 构建语言驱动的应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-apps-powered-by-language-with-semantic-ml-c6f01fdf0e94?source=collection_archive---------27-----------------------#2020-08-05">https://towardsdatascience.com/build-apps-powered-by-language-with-semantic-ml-c6f01fdf0e94?source=collection_archive---------27-----------------------#2020-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a48890b19cafa2cb8ac0cb66ac30cf1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PaxaSHT7IGu0hk6XPmO62w.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由戴尔·马科维茨拍摄</p></figure><div class=""/><p id="4f2c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇文章中，我将向你展示如何使用初学者友好的 ML 工具——Semantic Reactor 和 tensor flow . js——来构建一个基于自然语言的应用程序。</p><p id="8c00" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">更新:语义反应堆上线了！将它添加到 Google Sheets </em> <a class="ae lb" href="https://research.google.com/semanticexperiences/semantic-reactor.html" rel="noopener ugc nofollow" target="_blank"> <em class="la">这里</em> </a>。</p><p id="e453" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">大多数人更擅长用语言描述世界，而不是用代码描述世界(嗯……<em class="la">大多数</em>人)。那么，如果机器学习可以帮助弥合这两者之间的差距，那就太好了。</p><p id="8a09" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是“语义 ML”的用武之地，这是一个概括术语，用于描述捕捉单词或短语语义的机器学习技术。在这篇文章中，我将向您展示如何使用初学者友好的工具(Semantic Reactor 和 Tensorflow.js)快速构建基于语言的应用程序原型。</p><p id="56e7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">向下滚动以直接进入代码和工具，或者继续阅读一些背景知识:</p><h1 id="2fd5" class="lc ld jf bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">理解语义 ML</h1><h1 id="e59b" class="lc ld jf bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是嵌入？</h1><p id="73a5" class="pw-post-body-paragraph kc kd jf ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">语义 ML 帮助我们构建自然语言驱动的软件的一个简单(但强大)的方法是通过一种叫做嵌入的技术。</p><p id="c64e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在机器学习中，嵌入是一种在空间中表示数据(即绘制在 n 维网格上的点)的学习方法，使得点之间的距离是有意义的。单词向量是一个流行的例子:</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mf"><img src="../Images/86e36a7728e23bc2ff582a898081c19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bmtlOSc_O9aKbbGg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><em class="mk">单词嵌入的可视化。本图来自</em> <a class="ae lb" href="https://medium.com/analytics-vidhya/implementing-word2vec-in-tensorflow-44f93cf2665f" rel="noopener"> <em class="mk">本媒文章</em> </a> <em class="mk">。</em></p></figure><p id="1065" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上图显示了单词(“英格兰”、“他”、“快”)在空间中的排列，这样类似的单词(“狗”和“狗”、“意大利”和“罗马”、“女人”和“女王”)彼此靠近。每个单词都由一组坐标(或向量)表示，因此单词“queen”可能由坐标[0.38，0.48，0.99，0.48，0.28，0.38]表示。</p><p id="67a2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些数字从何而来？它们是由机器学习模型通过数据学习的。特别是，该模型学习哪些单词倾向于出现在句子的相同位置。考虑这两句话:</p><p id="d97f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我妈妈生了一个儿子。</p><p id="c439" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我妈妈生了一个女儿。</p><p id="4063" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为“女儿”和“儿子”这两个词经常在类似的上下文中使用，所以机器学习模型将学习到它们在空间中应该被表示为彼此靠近。</p><p id="8d80" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">单词嵌入在自然语言处理中非常有用。它们可以用于查找同义词(“语义相似性”)，进行聚类，或者作为更复杂的 nlp 模型的预处理步骤。</p><h1 id="fc40" class="lc ld jf bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">嵌入整个句子</h1><p id="7bef" class="pw-post-body-paragraph kc kd jf ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">事实证明，使用一种叫做<a class="ae lb" href="https://tfhub.dev/google/collections/universal-sentence-encoder/1" rel="noopener ugc nofollow" target="_blank">通用句子编码器</a>的模型，整个句子(甚至是短段落)也可以有效地嵌入空间。使用句子嵌入，我们可以判断两个句子是否相似。这很有用，例如，如果你正在构建一个聊天机器人，并且想知道用户是否问了一个问题(例如，“你什么时候叫醒我？”)在语义上类似于一个你——聊天机器人程序员——已经预料到的问题，并写了一个回答(“我的闹钟是几点？”).</p><h1 id="d1fb" class="lc ld jf bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">语义反应器:在 Google 表单中使用语义 ML 的原型</h1><p id="ece8" class="pw-post-body-paragraph kc kd jf ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">好了，现在开始有趣的部分——建造东西！</p><p id="d094" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，一些灵感:当<a class="ae lb" href="https://twitter.com/doubleanna" rel="noopener ugc nofollow" target="_blank">安娜·基普尼斯</a>(Double Fine 的前游戏设计师，现在 Stadia/Google)向我展示她如何使用语义 ML 来自动化视频游戏交互时，我最初对语义 ML 感到兴奋。使用句子编码器模型，她构建了一个视频游戏世界，该世界使用 ML 来推断环境应该如何对玩家输入做出反应。它让我大吃一惊。点击这里查看我们的聊天记录:</p><p id="1cbd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在安娜的游戏中，玩家通过问任何他们想到的问题来与虚拟狐狸互动:</p><p id="824a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">“福克斯，我能喝点咖啡吗？”</p><p id="e63c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，使用语义 ML，游戏引擎(或<a class="ae lb" href="https://en.wikipedia.org/wiki/Utility_system" rel="noopener ugc nofollow" target="_blank">实用系统</a>)考虑游戏可能做出反应的所有可能方式:</p><p id="0d27" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用句子编码器模型，游戏决定最佳反应是什么并执行它(在这种情况下，最佳反应是<em class="la">Fox brings you mug</em>，因此游戏动画显示 Fox bring you mug)。如果这听起来有点抽象，一定要看我上面链接的视频。</p><p id="dc42" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个项目最巧妙的一个方面是 Anna 使用一个叫做语义反应器的工具在 Google Sheet 中做了大量的原型。</p><p id="3419" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">语义反应器是 Google Sheets 的一个插件，允许你在一个工作表中对你自己的数据使用句子编码器模型。在这里访问它<a class="ae lb" href="https://research.google.com/semanticexperiences/semantic-reactor.html" rel="noopener ugc nofollow" target="_blank">。这是快速构建语义 ML 应用原型的一个非常好的方法，然后你可以使用</a><a class="ae lb" href="https://www.npmjs.com/package/@tensorflow-models/universal-sentence-encoder" rel="noopener ugc nofollow" target="_blank"> TensorFlow.js models </a>将它转化为代码(稍后会有更多相关内容)。</p><p id="60eb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是这个工具的一个小图片:</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/c9df59efb70bf67ba4ad05a29600f273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/0*NC0Jkd8DWfNLAejy.gif"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">Dale Markowitz 的使用语义反应器的 Gif。</p></figure><p id="126c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要使用语义反应器，创建一个新的谷歌表，并在第一列中写一些句子。在这里，我将松散地重现安娜的 fox 演示(对于所有的细节，查看她的<a class="ae lb" href="https://stadia.dev/intl/fr_ca/blog/creating-game-ai-using-mostly-english/" rel="noopener ugc nofollow" target="_blank">原始帖子</a>)。我把这些句子放在我的谷歌表单的第一列:</p><p id="cb7c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这里，你必须发挥你的想象力，想想潜在角色(例如聊天机器人或视频游戏中的演员)可能会采取的这些“行动”。</p><p id="bb8d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦你安装了语义反应器，你就可以通过点击“附加组件-&gt;语义反应器-&gt;启动”来启用它。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mm"><img src="../Images/9793e6c614bc9c966ae825a71e2ff223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FxesKutRuIcUTXoP.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">从附加组件下拉菜单中启用语义反应器(Dale Markowitz)</p></figure><p id="16c1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">单击“开始”将打开一个面板，允许您键入输入内容并点击“反应”:</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mn"><img src="../Images/686df6bd0b1d0dcb2e3154faef8700bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P7x-euHfPMJhyuDW.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">尝试输入/响应排名(戴尔·马科维茨)</p></figure><p id="74ea" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当你点击“React”时，Semantic Reactor 使用一个模型来嵌入你在第一列中写的所有响应，计算一个分数(这句话对查询的响应有多好？)，并对结果进行排序。例如，当我的输入是“我想要一些咖啡”时，我的电子表格中排名最高的响应是“我去拿杯子”和“我给你拿了杯子。”</p><p id="7e2a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您还会注意到，使用这个工具有两种不同的方式来排列句子:“输入/响应”和“语义相似度”顾名思义，前者根据句子对给定查询的<em class="la">响应</em>的好坏来对句子进行排序，而“语义相似度”只是对句子与查询的相似程度进行评级。</p><h1 id="b6fe" class="lc ld jf bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用 TensorFlow.js 从电子表格到代码</h1><p id="cac8" class="pw-post-body-paragraph kc kd jf ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">在引擎盖下，Semantic Reactor 由开源的 TensorFlow.js 模型提供支持。</p><p id="3798" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看如何在 JavaScript 中使用这些模型，这样您就可以将电子表格原型转换成一个工作应用程序。</p><ol class=""><li id="6cf1" class="mo mp jf ke b kf kg kj kk kn mq kr mr kv ms kz mt mu mv mw bi translated">创建一个新的节点项目并安装模块:</li></ol><pre class="mg mh mi mj gt mx my mz na aw nb bi"><span id="e696" class="nc ld jf my b gy nd ne l nf ng">npm init<br/>npm install @tensorflow/tfjs @tensorflow-models/universal-sentence-encoder</span></pre><p id="5642" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.创建一个新文件(<code class="fe nh ni nj my b">use_demo.js</code>)并要求库:</p><pre class="mg mh mi mj gt mx my mz na aw nb bi"><span id="51b9" class="nc ld jf my b gy nd ne l nf ng">require('@tensorflow/tfjs');<br/><strong class="my jg">const</strong> encoder = require('@tensorflow-models/universal-sentence-encoder');</span></pre><p id="83ff" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.加载模型:</p><pre class="mg mh mi mj gt mx my mz na aw nb bi"><span id="4d95" class="nc ld jf my b gy nd ne l nf ng"><strong class="my jg">const</strong> model = <strong class="my jg">await</strong> encoder.loadQnA();</span></pre><p id="b47f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4.对您的句子进行编码并查询:</p><pre class="mg mh mi mj gt mx my mz na aw nb bi"><span id="7090" class="nc ld jf my b gy nd ne l nf ng"><strong class="my jg">const</strong> input = {<br/>queries: ["I want some coffee"],<br/>responses: [<br/>"I grab a ball",<br/>"I go to you",<br/>"I play with a ball",<br/>"I go to school.",<br/>"I go to the mug.",<br/>"I bring you the mug."]<br/>};</span><span id="48dc" class="nc ld jf my b gy nk ne l nf ng"><strong class="my jg">const</strong> embeddings = <strong class="my jg">await</strong> model.embed(input);</span></pre><p id="3e63" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">5.瞧啊。您已经将您的回答和查询转换为向量。不幸的是，向量只是空间中的点。要对回答进行排序，您需要计算这些点之间的距离(您可以通过计算<a class="ae lb" href="https://www.mathsisfun.com/algebra/vectors-dot-product.html" rel="noopener ugc nofollow" target="_blank">点积</a>来完成，这将给出点之间的平方<a class="ae lb" href="https://en.wikipedia.org/wiki/Euclidean_distance#:\~:text=In%20mathematics%2C%20the%20Euclidean%20distance,metric%20as%20the%20Pythagorean%20metric." rel="noopener ugc nofollow" target="_blank">欧几里德距离</a>):</p><pre class="mg mh mi mj gt mx my mz na aw nb bi"><span id="631c" class="nc ld jf my b gy nd ne l nf ng">// zipWith :: (a -&gt; b -&gt; c) -&gt; \[a\] -&gt; \[b\] -&gt; \[c\]</span><span id="6269" class="nc ld jf my b gy nk ne l nf ng"><strong class="my jg">const</strong> zipWith =<br/>   (f, xs, ys) =&gt; {<br/>   <strong class="my jg">const</strong> ny = ys.length;<br/>   <strong class="my jg">return</strong> (xs.length &lt;= ny ? xs : xs.slice(<strong class="my jg">0</strong>, ny))<br/>   .map((x, i) =&gt; f(x, ys\[i\]));<br/>   }</span><span id="3096" class="nc ld jf my b gy nk ne l nf ng">   // Calculate the dot product of two vector arrays.<br/>   <strong class="my jg">const</strong> dotProduct = (xs, ys) =&gt; {<br/>   <strong class="my jg">const</strong> sum = xs =&gt; xs ? xs.reduce((a, b) =&gt; a + b, <strong class="my jg">0</strong>) : <strong class="my jg">undefined</strong>;</span><span id="797e" class="nc ld jf my b gy nk ne l nf ng">   <strong class="my jg">return</strong> xs.length === ys.length ?<br/>   sum(zipWith((a, b) =&gt; a * b, xs, ys))<br/>   : <strong class="my jg">undefined</strong>;<br/>   }</span></pre><p id="2837" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果运行这段代码，您应该会看到如下输出:</p><pre class="mg mh mi mj gt mx my mz na aw nb bi"><span id="87bd" class="nc ld jf my b gy nd ne l nf ng">[<br/>      { response: 'I grab a ball', score: <strong class="my jg">10.788130270345432</strong> },<br/>      { response: 'I go to you', score: <strong class="my jg">11.597091717283469</strong> },<br/>      { response: 'I play with a ball', score: <strong class="my jg">9.346379028479209</strong> },<br/>      { response: 'I go to school.', score: <strong class="my jg">10.130473646521292</strong> },<br/>      { response: 'I go to the mug.', score: <strong class="my jg">12.475453722603106</strong> },<br/>      { response: 'I bring you the mug.', score: <strong class="my jg">13.229019199245684</strong>}<br/>]</span></pre><p id="bf37" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">点击查看完整代码示例<a class="ae lb" href="https://github.com/google/making_with_ml/blob/master/semantic_ml/use_sample.js" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="aa08" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就是这样:这就是如何从语义 ML 电子表格快速编码！</p><p id="7707" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">很酷，对吧？如果你用这些工具做了些什么，一定要在下面的评论里或者在 Twitter 上让我知道。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="42e6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">发推文<a class="ae lb" href="https://twitter.com/dalequark" rel="noopener ugc nofollow" target="_blank"> @dalequark </a>或者在 Instagram 上关注<a class="ae lb" href="https://www.instagram.com/dale_on_ai/" rel="noopener ugc nofollow" target="_blank"> @dale_on_ai </a>。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="a632" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">原载于 2020 年 8 月 5 日 https://daleonai.com</em><em class="la"/><a class="ae lb" href="https://daleonai.com/semantic-ml" rel="noopener ugc nofollow" target="_blank"><em class="la">。</em></a></p></div></div>    
</body>
</html>