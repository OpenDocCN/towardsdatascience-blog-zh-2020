<html>
<head>
<title>Building and Deploying an Alphabet Recognition System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建和部署字母识别系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-and-deploying-an-alphabet-recognition-system-7ab59654c676?source=collection_archive---------14-----------------------#2020-07-09">https://towardsdatascience.com/building-and-deploying-an-alphabet-recognition-system-7ab59654c676?source=collection_archive---------14-----------------------#2020-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="051b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Anvil 将卷积神经网络(CNN)模型部署到网站中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/1677a9d1b73be5590b3661e2bae37414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*RNQrU8G99aYPmRNNQvUixw.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">部署后</p></figure><p id="0530" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将向您展示如何使用卷积神经网络(CNN)构建一个字母识别系统，并使用<a class="ae lq" href="https://anvil.works/" rel="noopener ugc nofollow" target="_blank"> nvil.works </a>部署它。在这篇文章的最后，你将能够创建一个如上所示的系统的精确复制品。</p><h1 id="760d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak">目录</strong></h1><p id="4376" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">卷积神经网络</p><p id="c1d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CNN 实施</p><p id="d317" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">砧座集成</p><h1 id="f2e0" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">卷积神经网络</h1><p id="3de1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们先来了解一下卷积神经网络到底是什么。卷积神经网络(CNN)是一种广泛用于图像识别和分类的神经网络。</p><p id="4ffa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CNN 是<a class="ae lq" href="https://en.wikipedia.org/wiki/Multilayer_perceptron" rel="noopener ugc nofollow" target="_blank">多层感知器</a>的规则版本。多层感知器通常意味着全连接网络，即一层中的每个神经元都与下一层中的所有神经元相连。</p><p id="9fee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CNN 由以下几层组成:</p><p id="8560" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">卷积层:</strong>一个大小为 3×3 或 5×5 的<em class="mo">“内核”</em>通过图像，并计算原始像素值与内核中定义的权重的点积。然后，该矩阵通过激活函数<em class="mo">“ReLu”</em>，该函数将矩阵中的每个负值转换为零。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/30e3d4345dabc5b397decf1a9c084fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFF-AMuNcJuvMvw9OeuuZw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由<a class="ae lq" href="https://stanford.edu/~shervine/teaching/cs-230/cheatsheet-convolutional-neural-networks" rel="noopener ugc nofollow" target="_blank"> Shervine Amidi </a>解释卷积层操作的图像</p></figure><p id="0451" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">汇集层:</strong>一个<strong class="kw iu"/><em class="mo"/>大小的“汇集矩阵”例如 2X2 或 4X4，经过矩阵以减小矩阵的大小，从而仅突出图像的重要特征。</p><p id="6b34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有两种类型的池操作:</p><ol class=""><li id="3f39" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated"><strong class="kw iu">最大汇集</strong> <em class="mo"> </em>是一种汇集类型，其中汇集矩阵中存在的最大值被放入最终矩阵中。</li><li id="9390" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated"><strong class="kw iu">平均池</strong>是一种池，计算池内核中所有值的平均值，并放入最终矩阵中。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a28dea867cd5ba5c7fbb02b888b40c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/0*mJZTFXB2bx1DeMxF.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">通过<a class="ae lq" href="https://stackoverflow.com/questions/44287965/trying-to-confirm-average-pooling-is-equal-to-dropping-high-frequency-fourier-co" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>解释最大和平均池的图像</p></figure><blockquote class="nj nk nl"><p id="0e1d" class="ku kv mo kw b kx ky ju kz la lb jx lc nm le lf lg nn li lj lk no lm ln lo lp im bi translated">(注意:在 CNN 架构中可以有多个卷积和池层的组合来提高其性能。)</p></blockquote><p id="248f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">全连通层:</strong>最后的矩阵再展平成一个<strong class="kw iu"> </strong>一维向量。这个向量然后被传递到神经网络中。最后，输出层是附加到图像的不同可能标签的概率列表(例如，字母 a、b、c)。获得最高概率的标签是分类决策。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi np"><img src="../Images/682964c8f14603da047b6a860e272154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pOmNn0MfnbGh1GzI"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由<a class="ae lq" href="https://stanford.edu/~shervine/teaching/cs-230/cheatsheet-convolutional-neural-networks" rel="noopener ugc nofollow" target="_blank"> Shervine Amidi </a>显示全连接层的图像</p></figure><h1 id="5dfe" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak"> CNN 实现</strong></h1><p id="dbe5" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们从导入 Jupyter 笔记本中的库开始实现，如下所示:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="7883" class="nv ls it nr b gy nw nx l ny nz"><strong class="nr iu">import</strong> <strong class="nr iu">numpy</strong> <strong class="nr iu">as</strong> <strong class="nr iu">np</strong><br/><strong class="nr iu">import</strong> <strong class="nr iu">matplotlib.pyplot</strong> <strong class="nr iu">as</strong> <strong class="nr iu">plt</strong><br/><strong class="nr iu">from</strong> <strong class="nr iu">keras.preprocessing.image</strong> <strong class="nr iu">import</strong> ImageDataGenerator<br/><strong class="nr iu">from</strong> <strong class="nr iu">keras.preprocessing</strong> <strong class="nr iu">import</strong> image<br/><strong class="nr iu">import</strong> <strong class="nr iu">keras</strong><br/><strong class="nr iu">from</strong> <strong class="nr iu">keras.models</strong> <strong class="nr iu">import</strong> Sequential<br/><strong class="nr iu">from</strong> <strong class="nr iu">keras.layers</strong> <strong class="nr iu">import</strong> Conv2D, MaxPooling2D, Flatten, Dense, Activation<br/><strong class="nr iu">import</strong> <strong class="nr iu">os</strong><br/><strong class="nr iu">import</strong> <strong class="nr iu">pickle</strong></span></pre><p id="e159" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，让我们导入包含从<strong class="kw iu"> a </strong>到<strong class="kw iu"> z </strong>的图像的 2 个数据集，用于训练和测试我们的模型。你可以从下面链接的我的 GitHub 库下载数据集。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="b54b" class="nv ls it nr b gy nw nx l ny nz">train_datagen = ImageDataGenerator(rescale = 1./255,<br/>                                   shear_range = 0.2,<br/>                                   zoom_range = 0.2,<br/>                                   horizontal_flip = <strong class="nr iu">True</strong>)<br/><br/>test_datagen = ImageDataGenerator(rescale = 1./255)<br/><br/>train_generator = train_datagen.flow_from_directory(<br/>    directory = 'Training',<br/>    target_size = (32,32),<br/>    batch_size = 32,<br/>    class_mode = 'categorical'<br/><br/>)<br/><br/>test_generator = test_datagen.flow_from_directory(<br/>    directory = 'Testing',<br/>    target_size = (32,32),<br/>    batch_size = 32,<br/>    class_mode = 'categorical'<br/><br/>)</span></pre><p id="0334" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> ImageDataGenerator </strong>生成批量的张量图像数据，通过使用<strong class="kw iu"> rescale </strong>以 1/255 的因子进行缩放，将 0–255 范围内的 RGB 系数转换为 0 到 1 之间的目标值。</p><p id="b958" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">剪切范围</strong>用于随机应用<a class="ae lq" href="https://en.wikipedia.org/wiki/Shear_mapping" rel="noopener ugc nofollow" target="_blank">剪切变换</a>。</p><p id="5905" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> zoom_range </strong>用于图片内部随机缩放。</p><p id="1eb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">水平翻转</strong>用于随机水平翻转一半图像。</p><p id="f7a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们使用<strong class="kw iu">从目录中一个接一个地导入图像。flow_from_directory </strong>并对其应用 ImageDataGenerator。</p><p id="e439" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将图像从其原始大小转换为我们的<strong class="kw iu"> target_size </strong>，并声明<strong class="kw iu"> batch_size </strong> count，其中<strong class="kw iu"> </strong>表示一次迭代中使用的训练样本的数量。</p><p id="7b76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将<strong class="kw iu"> class_mode </strong>设置为分类，表示我们有多个类(a 到 z)要预测。</p><p id="2e3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们建立我们的 CNN 架构。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="0280" class="nv ls it nr b gy nw nx l ny nz">model = Sequential()<br/>model.add(Conv2D(32, (3, 3), input_shape = (32,32,3), activation = 'relu'))<br/>model.add(MaxPooling2D(pool_size = (2, 2)))<br/><br/><br/>model.add(Conv2D(32, (3, 3), activation = 'relu'))<br/>model.add(MaxPooling2D(pool_size = (2, 2)))<br/><br/>model.add(Flatten())<br/>model.add(Dense(units = 128, activation = 'relu'))<br/>model.add(Dense(units = 26, activation = 'softmax'))<br/><br/><br/>model.compile(optimizer = 'adam', loss = 'categorical_crossentropy', metrics = ['accuracy'])<br/><br/>model.summary()</span></pre><p id="d297" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们首先创建一个<strong class="kw iu">顺序</strong>模型，允许我们使用<strong class="kw iu">逐层定义 CNN 架构。增加</strong>功能。</p><p id="f18f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们首先在输入图像上添加一个带有 32 个大小为 3X3 的过滤器的<strong class="kw iu">卷积层</strong>，并将其通过“relu”激活函数。</p><p id="a80b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们使用大小为 2X2 的池执行<strong class="kw iu"> MaxPooling </strong>操作。</p><p id="a66d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后再次重复这些层，以提高模型的性能。</p><p id="b23e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后我们<strong class="kw iu">展平</strong>我们的合成矩阵，并将其通过由 128 个节点组成的<strong class="kw iu">密集</strong>层。然后连接到由 26 个节点组成的输出层，每个节点代表一个字母表。我们使用<strong class="kw iu"> softmax </strong>激活将分数转换为归一化的概率分布，具有最高概率的节点被选为输出。</p><p id="b47f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们的 CNN 架构被定义，我们使用 adam optimizer 编译模型。</p><p id="e192" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们训练我们的模型如下。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="6271" class="nv ls it nr b gy nw nx l ny nz">model.fit_generator(train_generator,<br/>                         steps_per_epoch = 16,<br/>                         epochs = 3,<br/>                         validation_data = test_generator,<br/>                         validation_steps = 16)</span></pre><p id="9b8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模型训练后达到的准确率为:93.42%</p><p id="1dba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们试着测试我们的模型。但在此之前，我们需要定义一个函数，该函数为我们提供与结果相关联的字母表。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="7d5c" class="nv ls it nr b gy nw nx l ny nz"><strong class="nr iu">def</strong> get_result(result):<br/>    <strong class="nr iu">if</strong> result[0][0] == 1:<br/>        <strong class="nr iu">return</strong>('a')<br/>    <strong class="nr iu">elif</strong> result[0][1] == 1:<br/>        <strong class="nr iu">return</strong> ('b')<br/>    <strong class="nr iu">elif</strong> result[0][2] == 1:<br/>        <strong class="nr iu">return</strong> ('c')<br/>    <strong class="nr iu">elif</strong> result[0][3] == 1:<br/>        <strong class="nr iu">return</strong> ('d')<br/>    <strong class="nr iu">elif</strong> result[0][4] == 1:<br/>        <strong class="nr iu">return</strong> ('e')<br/>    <strong class="nr iu">elif</strong> result[0][5] == 1:<br/>        <strong class="nr iu">return</strong> ('f')<br/>    <strong class="nr iu">elif</strong> result[0][6] == 1:<br/>        <strong class="nr iu">return</strong> ('g')<br/>    <strong class="nr iu">elif</strong> result[0][7] == 1:<br/>        <strong class="nr iu">return</strong> ('h')<br/>    <strong class="nr iu">elif</strong> result[0][8] == 1:<br/>        <strong class="nr iu">return</strong> ('i')<br/>    <strong class="nr iu">elif</strong> result[0][9] == 1:<br/>        <strong class="nr iu">return</strong> ('j')<br/>    <strong class="nr iu">elif</strong> result[0][10] == 1:<br/>        <strong class="nr iu">return</strong> ('k')<br/>    <strong class="nr iu">elif</strong> result[0][11] == 1:<br/>        <strong class="nr iu">return</strong> ('l')<br/>    <strong class="nr iu">elif</strong> result[0][12] == 1:<br/>        <strong class="nr iu">return</strong> ('m')<br/>    <strong class="nr iu">elif</strong> result[0][13] == 1:<br/>        <strong class="nr iu">return</strong> ('n')<br/>    <strong class="nr iu">elif</strong> result[0][14] == 1:<br/>        <strong class="nr iu">return</strong> ('o')<br/>    <strong class="nr iu">elif</strong> result[0][15] == 1:<br/>        <strong class="nr iu">return</strong> ('p')<br/>    <strong class="nr iu">elif</strong> result[0][16] == 1:<br/>        <strong class="nr iu">return</strong> ('q')<br/>    <strong class="nr iu">elif</strong> result[0][17] == 1:<br/>        <strong class="nr iu">return</strong> ('r')<br/>    <strong class="nr iu">elif</strong> result[0][18] == 1:<br/>        <strong class="nr iu">return</strong> ('s')<br/>    <strong class="nr iu">elif</strong> result[0][19] == 1:<br/>        <strong class="nr iu">return</strong> ('t')<br/>    <strong class="nr iu">elif</strong> result[0][20] == 1:<br/>        <strong class="nr iu">return</strong> ('u')<br/>    <strong class="nr iu">elif</strong> result[0][21] == 1:<br/>        <strong class="nr iu">return</strong> ('v')<br/>    <strong class="nr iu">elif</strong> result[0][22] == 1:<br/>        <strong class="nr iu">return</strong> ('w')<br/>    <strong class="nr iu">elif</strong> result[0][23] == 1:<br/>        <strong class="nr iu">return</strong> ('x')<br/>    <strong class="nr iu">elif</strong> result[0][24] == 1:<br/>        <strong class="nr iu">return</strong> ('y')<br/>    <strong class="nr iu">elif</strong> result[0][25] == 1:<br/>        <strong class="nr iu">return</strong> ('z')</span></pre><p id="92f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，让我们按如下方式测试我们的模型:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="e5dc" class="nv ls it nr b gy nw nx l ny nz">filename = r'Testing\e\25.png'<br/>test_image = image.load_img(filename, target_size = (32,32))<br/>plt.imshow(test_image)<br/>test_image = image.img_to_array(test_image)<br/>test_image = np.expand_dims(test_image, axis = 0)<br/>result = model.predict(test_image)<br/>result = get_result(result)<br/>print ('Predicted Alphabet is: <strong class="nr iu">{}</strong>'.format(result))</span></pre><p id="9a58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">该模型正确预测输入图像字母为‘e’。</strong></p><h1 id="1af2" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak">砧座整合</strong></h1><p id="7b12" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><a class="ae lq" href="https://anvil.works/" rel="noopener ugc nofollow" target="_blank"> Anvil </a>是一个允许我们用 python 构建全栈 web 应用的平台。它让我们更容易将机器学习模型从 Jupyter 笔记本变成 web 应用程序。</p><p id="abb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从在 anvil 上创建一个帐户开始。完成后，用材料设计创建一个新的空白应用程序。</p><blockquote class="nj nk nl"><p id="b844" class="ku kv mo kw b kx ky ju kz la lb jx lc nm le lf lg nn li lj lk no lm ln lo lp im bi translated"><a class="ae lq" href="https://anvil.works/learn" rel="noopener ugc nofollow" target="_blank">点击此链接，了解如何使用 anvil 的分步指南。</a></p></blockquote><p id="76b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">右边的工具箱包含了所有可以拖动到网站上的组件。</p><p id="879f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所需组件:</p><ol class=""><li id="db01" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated">2 个标签(标题和副标题)</li><li id="dcc0" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">图像(显示输入图像)</li><li id="4346" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">文件加载器(上传输入图像)</li><li id="b3b9" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">突出显示的按钮(预测结果)</li><li id="8437" class="mu mv it kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">标签(查看结果)</li></ol><p id="f012" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">拖放这些组件，并根据您的要求进行排列。</p><p id="8920" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了添加标题和副标题，选择标签并在右侧的属性部分，转到名为“文本”的选项，如下所示(以红色突出显示)，并键入标题/副标题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi oa"><img src="../Images/9736e2796602bd796701207f83ffc308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hhC2VoB-UZWwhZTNaMIWvQ.png"/></div></div></figure><p id="ed3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成用户界面后，进入如上所示的代码部分(以绿色突出显示)，并创建一个新函数，如下所示</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="8c6c" class="nv ls it nr b gy nw nx l ny nz">def primary_color_1_click(self, **event_args):<br/>      file = self.file_loader_1.file<br/>      self.image_1.source = file<br/>      result = anvil.server.call('model_run',file)<br/>      self.label_3.text = result<br/>      pass</span></pre><p id="9a11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们按下预测按钮时，该功能将执行。它将从文件加载器上传输入图像，并将其传递给 jupyter 笔记本的“model_run”功能。该函数将返回通过标签组件(label_3)显示的预测字母表。</p><p id="57e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在剩下要做的就是将我们的 anvil 网站连接到 jupyter 笔记本上。</p><p id="154d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这需要实施如下两个步骤:</p><ol class=""><li id="0e66" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated">导入 Anvil 上行密钥:点击设置按钮然后点击上行，点击启用上行密钥并复制密钥。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ob"><img src="../Images/5599e35ef063cb345e2b2a8fb11caa8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DNaQVPjC9APTWOEJRgPzMQ.png"/></div></div></figure><p id="0809" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您的 jupyter 笔记本中粘贴以下内容:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="a676" class="nv ls it nr b gy nw nx l ny nz"><strong class="nr iu">import</strong> <strong class="nr iu">anvil.server</strong><br/><strong class="nr iu">import</strong> <strong class="nr iu">anvil.media</strong><br/>anvil.server.connect("paste your anvil uplink key here")</span></pre><p id="5659" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.创建一个函数“模型运行”,预测网站上传的图像。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="a7a3" class="nv ls it nr b gy nw nx l ny nz">@anvil.server.callable<br/><strong class="nr iu">def</strong> model_run(path):<br/>    <strong class="nr iu">with</strong> anvil.media.TempFile(path) <strong class="nr iu">as</strong> filename:<br/>        test_image = image.load_img(filename, target_size = (32,32))<br/>        test_image = image.img_to_array(test_image)<br/>        test_image = np.expand_dims(test_image, axis = 0)<br/>        result = model.predict(test_image)<br/>        result = get_result(result)<br/>        <strong class="nr iu">return</strong> ('Predicted Alphabet is: <strong class="nr iu">{}</strong>'.format(result))</span></pre><p id="b303" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而且，是的！！！！现在你可以回到 anvil，点击运行按钮，发现一个完全完成的字母识别系统。</p><p id="0b33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在我的 GitHub 资源库中找到源代码和数据集。</p><div class="oc od gp gr oe of"><a href="https://github.com/sakshibutala/CNN_AlphabetRecognition" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">sakshibutala/CNN _ 字母识别</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">该算法与 anvil 网站集成，anvil 网站识别给定输入图像中存在的字母表。…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ko of"/></div></div></a></div><h1 id="265f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">参考</h1><div class="oc od gp gr oe of"><a href="https://missinglink.ai/guides/convolutional-neural-networks/convolutional-neural-network-tutorial-basic-advanced/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">卷积神经网络教程:从基础到高级- MissingLink.ai</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">卷积神经网络卷积神经网络架构是深度学习的核心，它是…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">missinglink.ai</p></div></div><div class="oo l"><div class="ou l oq or os oo ot ko of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://stanford.edu/~shervine/teaching/cs-230/cheatsheet-convolutional-neural-networks" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">CS 230 -卷积神经网络说明书</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">你想看看你母语的备忘单吗？可以在 GitHub 上帮我们翻译一下！卷积…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">stanford.edu</p></div></div><div class="oo l"><div class="ov l oq or os oo ot ko of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://keras.io/api/preprocessing/image/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">Keras 文档:图像数据预处理</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">从目录中的图像文件生成 tf.data.Dataset。如果您的目录结构是:然后调用…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">keras.io</p></div></div><div class="oo l"><div class="ow l oq or os oo ot ko of"/></div></div></a></div></div></div>    
</body>
</html>