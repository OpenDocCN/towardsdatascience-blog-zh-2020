<html>
<head>
<title>Ten Reasons to Use StaticFrame Instead of Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 StaticFrame 代替熊猫的十大理由</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ten-reasons-to-use-staticframe-instead-of-pandas-f368cc81e50a?source=collection_archive---------35-----------------------#2020-09-13">https://towardsdatascience.com/ten-reasons-to-use-staticframe-instead-of-pandas-f368cc81e50a?source=collection_archive---------35-----------------------#2020-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="994c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在处理数据帧时，创建更易维护、更不易出错的 Python</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/18750677a1666a6834c7164299d64832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSRvssEINc3cNlgnXt92fA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="aed2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你用 Python 处理数据，你可能会用熊猫。Pandas 提供了近乎即时的满足:复杂的数据处理例程可以用几行代码实现。然而，如果你在大型项目中使用熊猫多年，你可能会遇到一些挑战。复杂的 Pandas 应用程序会产生难以维护且容易出错的 Python 代码。发生这种情况是因为 Pandas 提供了许多方法来做同样的事情，具有不一致的接口，并且广泛支持就地突变。对于那些来自熊猫的人来说，StaticFrame 提供了一个更加一致的界面，减少了出错的机会。这篇文章展示了使用 StaticFrame 代替 Pandas 的十个理由。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="1f81" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">为什么是静态框架</h1><p id="abcf" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在使用 Pandas 开发后端财务系统多年后，我清楚地认识到 Pandas 并不是这项工作的合适工具。Pandas 对标记数据和缺失值的处理，性能接近 NumPy，确实提高了我的生产率。然而，熊猫 API 中的大量不一致导致代码难以维护。此外，熊猫对原位突变的支持导致了严重的出错机会。因此，在 2017 年 5 月，我开始实施一个更适合关键生产系统的库。</p><p id="8715" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，经过多年的发展和完善，我们看到了用 StaticFrame 代替 Pandas 在我们的生产系统中取得的优异成绩。用 StaticFrame 编写的库和应用程序更容易维护和测试。我们经常看到 StaticFrame 在大规模、真实世界的用例中表现优于 panda，尽管对于许多独立的操作，StaticFrame 还没有 panda 快。</p><p id="d7a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是支持使用 StaticFrame 而不是 Pandas 的十个理由。作为 StaticFrame 的第一作者，我当然对这个演示有偏见。然而，从 2013 年开始与熊猫一起工作，我希望有一些观点可以分享。</p><p id="9cdf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有示例都使用 Pandas 1.0.3 和 StaticFrame 0.6.20。导入使用以下惯例:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="41ee" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; import pandas as pd<br/>&gt;&gt;&gt; import static_frame as sf</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="cb47" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">№ 1:一致且可发现的界面</h1><p id="722b" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">应用程序编程接口(API)可以在函数的位置、函数的命名方式以及这些函数接受的参数的名称和类型方面保持一致。StaticFrame 偏离了 Pandas 的 API，以在所有这些领域支持更大的一致性。</p><p id="ee10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要创建一个<code class="fe ni nj nk mz b">sf.Series</code>或<code class="fe ni nj nk mz b">sf.Frame</code>，你需要构造函数。Pandas 将其<code class="fe ni nj nk mz b">pd.DataFrame</code>构造函数放在两个地方:根名称空间(<code class="fe ni nj nk mz b">pd</code>，通常是导入的)和<code class="fe ni nj nk mz b">pd.DataFrame</code>类。</p><p id="51b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，JSON 数据是从<code class="fe ni nj nk mz b">pd</code>名称空间上的函数加载的，而记录数据(Python 序列的一个 iterable)是从<code class="fe ni nj nk mz b">pd.DataFrame</code>类加载的。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="7736" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; pd.read_json('[{"name":"muon", "mass":0.106},{"name":"tau", "mass":1.777}]')<br/>   name   mass<br/>0  muon  0.106<br/>1   tau  1.777</span><span id="a853" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; pd.DataFrame.from_records([{"name":"muon", "mass":0.106}, {"name":"tau", "mass":1.777}])<br/>   name   mass<br/>0  muon  0.106<br/>1   tau  1.777</span></pre><p id="7671" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管 Pandas 有专门的构造函数，默认的<code class="fe ni nj nk mz b">pd.DataFrame</code>构造函数接受多种多样的输入，包括许多与<code class="fe ni nj nk mz b">pd.DataFrame.from_records()</code>相同的输入。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="514c" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; pd.DataFrame([{"name":"muon", "mass":0.106}, {"name":"tau", "mass":1.777}])<br/>   name   mass<br/>0  muon  0.106<br/>1   tau  1.777</span></pre><p id="08a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于用户来说，这种多样性和冗余性没有什么好处。StaticFrame 将所有的构造函数放在它们构造的类上，并尽可能地集中它们的功能。因为显式的、专用的构造函数更容易维护，所以它们在 StaticFrame 中很常见。比如<code class="fe ni nj nk mz b">sf.Frame.from_json()</code>和<code class="fe ni nj nk mz b">sf.Frame.from_dict_records()</code>:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="c437" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; sf.Frame.from_json('[{"name":"muon", "mass":0.106}, {"name":"tau", "mass":1.777}]')<br/>&lt;Frame&gt;<br/>&lt;Index&gt; name  mass      &lt;&lt;U4&gt;<br/>&lt;Index&gt;<br/>0       muon  0.106<br/>1       tau   1.777<br/>&lt;int64&gt; &lt;&lt;U4&gt; &lt;float64&gt;</span><span id="6a56" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; sf.Frame.from_dict_records([{"name":"muon", "mass":0.106}, {"name":"tau", "mass":1.777}])<br/>&lt;Frame&gt;<br/>&lt;Index&gt; name  mass      &lt;&lt;U4&gt;<br/>&lt;Index&gt;<br/>0       muon  0.106<br/>1       tau   1.777<br/>&lt;int64&gt; &lt;&lt;U4&gt; &lt;float64&gt;</span></pre><p id="cd38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显式导致大量的构造函数。为了帮助您找到您正在寻找的东西，StaticFrame 容器公开了一个<code class="fe ni nj nk mz b">interface</code>属性，该属性将调用类或实例的整个公共接口作为一个<code class="fe ni nj nk mz b">sf.Frame</code>提供。我们可以通过使用一个<code class="fe ni nj nk mz b">sf.Frame.loc[]</code>选择来过滤这个表，只显示构造函数。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="177e" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; sf.Frame.interface.loc[sf.Frame.interface['group'] == 'Constructor', 'doc']<br/>&lt;Series: doc&gt;<br/>&lt;Index: signature&gt;<br/>__init__(data, *, index, columns,... Initializer. Args...<br/>from_arrow(value, *, index_depth,... Realize a Frame f...<br/>from_clipboard(*, delimiter, inde... Create a Frame fr...<br/>from_concat(frames, *, axis, unio... Concatenate multi...<br/>from_concat_items(items, *, axis,... Produce a Frame w...<br/>from_csv(fp, *, index_depth, inde... Specialized versi...<br/>from_delimited(fp, *, delimiter, ... Create a Frame fr...<br/>from_dict(mapping, *, index, fill... Create a Frame fr...<br/>from_dict_records(records, *, ind... Frame constructor...<br/>from_dict_records_items(items, *,... Frame constructor...<br/>from_element(element, *, index, c... Create a Frame fr...<br/>from_element_iloc_items(items, *,... Given an iterable...<br/>from_element_loc_items(items, *, ... This function is ...<br/>from_elements(elements, *, index,... Create a Frame fr...<br/>from_hdf5(fp, *, label, index_dep... Load Frame from t...<br/>from_items(pairs, *, index, fill_... Frame constructor...<br/>from_json(json_data, *, dtypes, n... Frame constructor...<br/>from_json_url(url, *, dtypes, nam... Frame constructor...<br/>from_overlay(containers, *, union...<br/>from_pandas(value, *, index_const... Given a Pandas Da...<br/>from_parquet(fp, *, index_depth, ... Realize a Frame f...<br/>from_records(records, *, index, c... Construct a Frame...<br/>from_records_items(items, *, colu... Frame constructor...<br/>from_series(series, *, name, colu... Frame constructor...<br/>from_sql(query, *, connection, in... Frame constructor...<br/>from_sqlite(fp, *, label, index_d... Load Frame from t...<br/>from_structured_array(array, *, i... Convert a NumPy s...<br/>from_tsv(fp, *, index_depth, inde... Specialized versi...<br/>from_xlsx(fp, *, label, index_dep... Load Frame from t...<br/>&lt;&lt;U94&gt;                               &lt;&lt;U83&gt;</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="a41c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">№ 2:一致且丰富多彩的显示屏</h1><p id="5720" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">熊猫以不同的方式展示它的容器。例如，<code class="fe ni nj nk mz b">pd.Series</code>显示了它的名称和类型，而<code class="fe ni nj nk mz b">pd.DataFrame</code>没有显示这两个属性。如果你显示一个<code class="fe ni nj nk mz b">pd.Index</code>或<code class="fe ni nj nk mz b">pd.MultiIndex</code>，你会得到第三种方法:一个适合<code class="fe ni nj nk mz b">eval()</code>的字符串，当它很大时是不可理解的。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="6428" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; df = pd.DataFrame.from_records([{'symbol':'c', 'mass':1.3}, {'symbol':'s', 'mass':0.1}], index=('charm', 'strange'))</span><span id="8674" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df<br/>        symbol  mass<br/>charm        c   1.3<br/>strange      s   0.1</span><span id="2420" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df['mass']<br/>charm      1.3<br/>strange    0.1<br/>Name: mass, dtype: float64</span><span id="2643" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df.index<br/>Index(['charm', 'strange'], dtype='object')</span></pre><p id="f955" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">StaticFrame 为所有容器提供了一致的、可配置的显示。<code class="fe ni nj nk mz b">sf.Series</code>、<code class="fe ni nj nk mz b">sf.Frame</code>、<code class="fe ni nj nk mz b">sf.Index</code>和<code class="fe ni nj nk mz b">sf.IndexHierarchy</code>的显示都共享一个公共的实现和设计。这种设计的一个优先考虑的问题是总是显式的容器类和底层数组类型。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="ee92" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; f = sf.Frame.from_dict_records_items((('charm', {'symbol':'c', 'mass':1.3}), ('strange', {'symbol':'s', 'mass':0.1})))</span><span id="627c" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f<br/>&lt;Frame&gt;<br/>&lt;Index&gt; symbol mass      &lt;&lt;U6&gt;<br/>&lt;Index&gt;<br/>charm   c      1.3<br/>strange s      0.1<br/>&lt;&lt;U7&gt;   &lt;&lt;U1&gt;  &lt;float64&gt;</span><span id="f8cb" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f['mass']<br/>&lt;Series: mass&gt;<br/>&lt;Index&gt;<br/>charm          1.3<br/>strange        0.1<br/>&lt;&lt;U7&gt;          &lt;float64&gt;</span><span id="78ec" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f.columns<br/>&lt;Index&gt;<br/>symbol<br/>mass<br/>&lt;&lt;U6&gt;</span></pre><p id="ad62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于大量的时间花费在可视化地探索这些容器的内容上，StaticFrame 提供了许多显示配置选项，所有这些都通过<code class="fe ni nj nk mz b">sf.DisplayConfig</code>类公开。对于持久的变更，<code class="fe ni nj nk mz b">sf.DisplayConfig</code>实例可以传递给<code class="fe ni nj nk mz b">sf.DisplayActive.set()</code>；对于一次性的更改，<code class="fe ni nj nk mz b">sf.DisplayConfig</code>实例可以传递给容器的<code class="fe ni nj nk mz b">display()</code>方法。</p><p id="9020" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然<code class="fe ni nj nk mz b">pd.set_option()</code>可以类似地用于设置熊猫显示特征，但 StaticFrame 提供了更广泛的选项来使类型可被发现。如这个<a class="ae nm" href="https://raw.githubusercontent.com/InvestmentSystems/static-frame/master/doc/images/animate-display-config.svg" rel="noopener ugc nofollow" target="_blank">终端动画</a>所示，特定类型可以被着色或者类型注释可以被完全移除。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="3ac4" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">№ 3:不可变数据:无需防御性副本的高效内存管理</h1><p id="1851" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Pandas 在数据输入和从容器中公开的数据的所有权方面表现出不一致的行为。在某些情况下，有可能在熊猫的“背后”变异 NumPy 阵列，暴露出不良副作用和编码错误的机会。</p><p id="e37d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果我们向一个<code class="fe ni nj nk mz b">pd.DataFrame</code>提供一个 2D 数组，数组的原始引用可以用来“远程”改变<code class="fe ni nj nk mz b">pd.DataFrame</code>中的值。在这种情况下，<code class="fe ni nj nk mz b">pd.DataFrame</code>不保护对其数据的访问，只作为一个共享的可变数组的包装器。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="774d" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; a1 = np.array([[0.106, -1], [1.777, -1]])</span><span id="8ce0" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df = pd.DataFrame(a1, index=('muon', 'tau'), columns=('mass', 'charge'))</span><span id="3272" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df<br/>       mass  charge<br/>muon  0.106    -1.0<br/>tau   1.777    -1.0</span><span id="7a72" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; a1[0, 0] = np.nan <em class="nn"># Mutating the original array.</em></span><span id="83ec" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df <em class="nn"># Mutation reflected in the DataFrame created from that array.</em><br/>       mass  charge<br/>muon    NaN    -1.0<br/>tau   1.777    -1.0</span></pre><p id="4294" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，有时从<code class="fe ni nj nk mz b">pd.Series</code>或<code class="fe ni nj nk mz b">pd.DataFrame</code>的<code class="fe ni nj nk mz b">values</code>属性中暴露出来的 NumPy 数组可能会发生变异，从而改变<code class="fe ni nj nk mz b">pd.DataFrame</code>中的值。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="f2b0" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; a2 = df['charge'].values</span><span id="565c" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; a2<br/>array([-1., -1.])</span><span id="9778" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; a2[1] = np.nan <em class="nn"># Mutating the array from .values.</em></span><span id="1a18" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df <em class="nn"># Mutation is reflected in the DataFrame.</em><br/>       mass  charge<br/>muon    NaN    -1.0<br/>tau   1.777     NaN</span></pre><p id="35b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了 StaticFrame，就没有了“幕后”变异的漏洞:因为 StaticFrame 管理不可变的 NumPy 数组，所以引用只保存到不可变的数组。如果在初始化时给定了一个可变数组，将会产生一个不可变的副本。不可变数组不能从容器或对底层数组的直接访问中变异。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="57b8" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; a1 = np.array([[0.106, -1], [1.777, -1]])</span><span id="9df2" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f = sf.Frame(a1, index=('muon', 'tau'), columns=('mass', 'charge'))</span><span id="fdcc" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; a1[0, 0] = np.nan <em class="nn"># Mutating the original array has no affect on the Frame</em></span><span id="6eeb" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f<br/>&lt;Frame&gt;<br/>&lt;Index&gt; mass      charge    &lt;&lt;U6&gt;<br/>&lt;Index&gt;<br/>muon    0.106     -1.0<br/>tau     1.777     -1.0<br/>&lt;&lt;U4&gt;   &lt;float64&gt; &lt;float64&gt;</span><span id="1d29" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f['charge'].values[1] = np.nan <em class="nn"># An immutable array cannot be mutated</em><br/>Traceback (most recent call last):<br/>  File "&lt;console&gt;", line 1, in &lt;module&gt;<br/>ValueError: assignment destination is read-only</span></pre><p id="607d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然不可变数据减少了出错的机会，但它也提供了性能优势。例如，当用<code class="fe ni nj nk mz b">sf.Frame.relabel()</code>替换列标签时，底层数据不会被复制。相反，对相同不可变数组的引用在新旧容器之间共享。这样的“无拷贝”操作因此是快速和轻量级的。这与在 Pandas 中做同样的事情时发生的情况形成了对比:相应的 Pandas 方法<code class="fe ni nj nk mz b">df.DataFrame.rename()</code>被强制对所有底层数据进行防御性复制。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="aa2a" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; f.relabel(columns=lambda x: x.upper()) <em class="nn"># Underlying arrays are not copied</em><br/>&lt;Frame&gt;<br/>&lt;Index&gt; MASS      CHARGE    &lt;&lt;U6&gt;<br/>&lt;Index&gt;<br/>muon    0.106     -1.0<br/>tau     1.777     -1.0<br/>&lt;&lt;U4&gt;   &lt;float64&gt; &lt;float64&gt;</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="bcf9" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">№ 4:赋值是一个函数</h1><p id="54b1" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">虽然 Pandas 允许就地赋值，但有时这种操作不能提供适当的派生类型，从而导致不良行为。例如，一个赋给整数<code class="fe ni nj nk mz b">pd.Series</code>的浮点数将在没有警告或错误的情况下截断它的浮点部分。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="ae5d" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; s = pd.Series((-1, -1), index=('tau', 'down'))<br/>&gt;&gt;&gt; s<br/>tau    -1<br/>down   -1<br/>dtype: int64</span><span id="89b4" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; s['down'] = -0.333 <em class="nn"># Assigning a float.</em></span><span id="ea1b" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; s <em class="nn"># The -0.333 value was truncated to 0</em><br/>tau    -1<br/>down    0<br/>dtype: int64</span></pre><p id="e61c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用 StaticFrame 的不可变数据模型，赋值是一个返回新容器的函数。这允许评估类型以确保结果数组可以完全包含赋值。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="94f9" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; s = sf.Series((-1, -1), index=('tau', 'down'))<br/>&gt;&gt;&gt; s<br/>&lt;Series&gt;<br/>&lt;Index&gt;<br/>tau      -1<br/>down     -1<br/>&lt;&lt;U4&gt;    &lt;int64&gt;</span><span id="5a8c" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; s.assign['down'](-0.333) <em class="nn"># The float is assigned without truncation</em><br/>&lt;Series&gt;<br/>&lt;Index&gt;<br/>tau      -1.0<br/>down     -0.333<br/>&lt;&lt;U4&gt;    &lt;float64&gt;</span></pre><p id="2fe8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">StaticFrame 使用一个特殊的<code class="fe ni nj nk mz b">assign</code>接口来执行赋值函数调用。在一个<code class="fe ni nj nk mz b">sf.Frame</code>上，这个接口公开了一个<code class="fe ni nj nk mz b">sf.Frame.assign.loc[]</code>接口，可以用来选择赋值的目标。选择之后，要分配的值通过函数调用传递。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="7b7f" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; f = sf.Frame.from_dict_records_items((('charm', {'charge':0.666, 'mass':1.3}), ('strange', {'charge':-0.333, 'mass':0.1})))</span><span id="aba6" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f<br/>&lt;Frame&gt;<br/>&lt;Index&gt; charge    mass      &lt;&lt;U6&gt;<br/>&lt;Index&gt;<br/>charm   0.666     1.3<br/>strange -0.333    0.1<br/>&lt;&lt;U7&gt;   &lt;float64&gt; &lt;float64&gt;</span><span id="acfa" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f.assign.loc['charm', 'charge'](Fraction(2, 3)) <em class="nn"># Assigning to a loc-style selection</em><br/>&lt;Frame&gt;<br/>&lt;Index&gt; charge   mass      &lt;&lt;U6&gt;<br/>&lt;Index&gt;<br/>charm   2/3      1.3<br/>strange -0.333   0.1<br/>&lt;&lt;U7&gt;   &lt;object&gt; &lt;float64&gt;</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="201c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">№ 5:迭代器用于迭代和函数应用</h1><p id="3059" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Pandas 具有独立的迭代和函数应用功能。对于<code class="fe ni nj nk mz b">pd.DataFrame</code>上的迭代，有<code class="fe ni nj nk mz b">pd.DataFrame.iteritems()</code>、<code class="fe ni nj nk mz b">pd.DataFrame.iterrows()</code>、<code class="fe ni nj nk mz b">pd.DataFrame.itertuples()</code>和<code class="fe ni nj nk mz b">pd.DataFrame.groupby()</code>；对于<code class="fe ni nj nk mz b">pd.DataFrame</code>上的功能应用，有<code class="fe ni nj nk mz b">pd.DataFrame.apply()</code>和<code class="fe ni nj nk mz b">pd.DataFrame.applymap()</code>。</p><p id="9829" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是由于函数应用需要迭代，因此将函数应用建立在迭代之上是明智的。StaticFrame 通过提供一系列迭代器(如<code class="fe ni nj nk mz b">Frame.iter_array()</code>或<code class="fe ni nj nk mz b">Frame.iter_group_items()</code>)来组织迭代和函数应用，通过对<code class="fe ni nj nk mz b">apply()</code>的链式调用，这些迭代器也可用于函数应用。迭代器上也有应用映射类型的函数(比如<code class="fe ni nj nk mz b">map_any()</code>和<code class="fe ni nj nk mz b">map_fill()</code>)。这意味着一旦你知道你想如何迭代，函数应用只是一个方法。</p><p id="f8ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们可以用<code class="fe ni nj nk mz b">sf.Frame.from_records()</code>创建一个<code class="fe ni nj nk mz b">sf.Frame</code>:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="193d" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; f = sf.Frame.from_records(((0.106, -1.0, 'lepton'), (1.777, -1.0, 'lepton'), (1.3, 0.666, 'quark'), (0.1, -0.333, 'quark')), columns=('mass', 'charge', 'type'), index=('muon', 'tau', 'charm', 'strange'))</span><span id="8dcb" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f<br/>&lt;Frame&gt;<br/>&lt;Index&gt; mass      charge    type   &lt;&lt;U6&gt;<br/>&lt;Index&gt;<br/>muon    0.106     -1.0      lepton<br/>tau     1.777     -1.0      lepton<br/>charm   1.3       0.666     quark<br/>strange 0.1       -0.333    quark</span></pre><p id="00bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以用<code class="fe ni nj nk mz b">sf.Series.iter_element()</code>遍历一列值。我们可以通过使用在从<code class="fe ni nj nk mz b">sf.Series.iter_element()</code>返回的对象上找到的<code class="fe ni nj nk mz b">apply()</code>方法，使用同一个迭代器做函数应用。在<code class="fe ni nj nk mz b">sf.Series</code>和<code class="fe ni nj nk mz b">sf.Frame</code>上都可以找到相同的界面。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="3b5f" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; tuple(f['type'].iter_element())<br/>('lepton', 'lepton', 'quark', 'quark')</span><span id="558e" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f['type'].iter_element().apply(lambda e: e.upper())<br/>&lt;Series&gt;<br/>&lt;Index&gt;<br/>muon     LEPTON<br/>tau      LEPTON<br/>charm    QUARK<br/>strange  QUARK<br/>&lt;&lt;U7&gt;    &lt;&lt;U6&gt;</span><span id="8283" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f[['mass', 'charge']].iter_element().apply(lambda e: format(e, '.2e'))<br/>&lt;Frame&gt;<br/>&lt;Index&gt; mass     charge    &lt;&lt;U6&gt;<br/>&lt;Index&gt;<br/>muon    1.06e-01 -1.00e+00<br/>tau     1.78e+00 -1.00e+00<br/>charm   1.30e+00 6.66e-01<br/>strange 1.00e-01 -3.33e-01<br/>&lt;&lt;U7&gt;   &lt;object&gt; &lt;object&gt;</span></pre><p id="c5ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于<code class="fe ni nj nk mz b">sf.Frame</code>上的行或列迭代，一系列方法允许指定用于迭代的行或列的容器类型，即，用数组、用<code class="fe ni nj nk mz b">NamedTuple</code>或用<code class="fe ni nj nk mz b">sf.Series</code>(分别为<code class="fe ni nj nk mz b">iter_array()</code>、<code class="fe ni nj nk mz b">iter_tuple()</code>、<code class="fe ni nj nk mz b">iter_series()</code>)。这些方法采用一个轴参数来确定迭代是按行还是按列，并且类似地为函数应用程序公开一个<code class="fe ni nj nk mz b">apply()</code>方法。要对列应用函数，我们可以执行以下操作。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="b702" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; f[['mass', 'charge']].iter_array(axis=0).apply(np.sum)<br/>&lt;Series&gt;<br/>&lt;Index&gt;<br/>mass     3.283<br/>charge   -1.667<br/>&lt;&lt;U6&gt;    &lt;float64&gt;</span></pre><p id="6ea5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将函数应用于行而不是列只需要更改轴参数。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="6b58" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; f.iter_series(axis=1).apply(lambda s: s['mass'] &gt; 1 and s['type'] == 'quark')<br/>&lt;Series&gt;<br/>&lt;Index&gt;<br/>muon     False<br/>tau      False<br/>charm    True<br/>strange  False<br/>&lt;&lt;U7&gt;    &lt;bool&gt;</span></pre><p id="7bce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Group-by 操作只是另一种形式的迭代，具有相同的迭代和函数应用接口。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="f71d" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; f.iter_group('type').apply(lambda f: f['mass'].mean())<br/>&lt;Series&gt;<br/>&lt;Index&gt;<br/>lepton   0.9415<br/>quark    0.7000000000000001<br/>&lt;&lt;U6&gt;    &lt;float64&gt;</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="1c98" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">№ 6:严格的仅增长框架</h1><p id="097a" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><code class="fe ni nj nk mz b">pd.DataFrame</code>的一个有效用途是加载初始数据，然后通过添加额外的列来生成派生数据。这种方法利用了类型和基础数组的列组织:添加新列不需要重新分配旧列。</p><p id="bc9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">StaticFrame 通过提供一个称为<code class="fe ni nj nk mz b">sf.FrameGO</code>的<code class="fe ni nj nk mz b">sf.Frame</code>的严格的、只增长的版本，使得这种方法不容易出错。例如，一旦创建了<code class="fe ni nj nk mz b">sf.FrameGO</code>，就可以添加新的列，而现有的列不能被覆盖或就地改变。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="d98f" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; f = sf.FrameGO.from_records(((0.106, -1.0, 'lepton'), (1.777, -1.0, 'lepton'), (1.3, 0.666, 'quark'), (0.1, -0.333, 'quark')), columns=('mass', 'charge', 'type'), index=('muon', 'tau', 'charm', 'strange'))</span><span id="f7c0" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f['positive'] = f['charge'] &gt; 0</span><span id="91d3" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f<br/>&lt;FrameGO&gt;<br/>&lt;IndexGO&gt; mass      charge    type   positive &lt;&lt;U8&gt;<br/>&lt;Index&gt;<br/>muon      0.106     -1.0      lepton False<br/>tau       1.777     -1.0      lepton False<br/>charm     1.3       0.666     quark  True<br/>strange   0.1       -0.333    quark  False</span></pre><p id="c745" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种有限形式的突变满足了实际需要。此外，从一个<code class="fe ni nj nk mz b">sf.Frame</code>到一个<code class="fe ni nj nk mz b">sf.FrameGO</code>的来回转换(使用<code class="fe ni nj nk mz b">Frame.to_frame_go()</code>和<code class="fe ni nj nk mz b">FrameGO.to_frame()</code>)是一个非复制操作:底层的不可变数组可以在两个容器之间共享。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="075e" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">№ 7:日期不是纳秒</h1><p id="92f5" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Pandas 将所有日期或时间戳值建模为 NumPy <code class="fe ni nj nk mz b">datetime64[ns]</code>(纳秒)数组，而不管纳秒级的分辨率是否实用或合适。这给熊猫制造了一个“Y2262 问题”:超过 2262-04-11 的日期不能被表达。虽然我可以创建一个最长为 2262–04–11 的<code class="fe ni nj nk mz b">pd.DatetimeIndex</code>,但再过一天，Pandas 就会引发一个错误。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="eb5e" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; pd.date_range('1980', '2262-04-11')<br/>DatetimeIndex(['1980-01-01', '1980-01-02', '1980-01-03', '1980-01-04',<br/>               '1980-01-05', '1980-01-06', '1980-01-07', '1980-01-08',<br/>               '1980-01-09', '1980-01-10',<br/>               ...<br/>               '2262-04-02', '2262-04-03', '2262-04-04', '2262-04-05',<br/>               '2262-04-06', '2262-04-07', '2262-04-08', '2262-04-09',<br/>               '2262-04-10', '2262-04-11'],<br/>              dtype='datetime64[ns]', length=103100, freq='D')</span><span id="525f" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; pd.date_range('1980', '2262-04-12')<br/>Traceback (most recent call last):<br/>pandas._libs.tslibs.np_datetime.OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 2262-04-12 00:00:00</span></pre><p id="2aa8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于索引通常用于粒度远小于纳秒的日期时间值(如日期、月份或年份)，StaticFrame 提供了所有 NumPy 类型的<code class="fe ni nj nk mz b">datetime64</code>索引。这允许精确的日期-时间类型规范，并避免了基于纳秒的单位的限制。</p><p id="6463" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然用 Pandas 不可能，但用 StaticFrame 创建一个扩展到 3000 年的年份或日期的索引是很简单的。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="8342" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; sf.IndexYear.from_year_range(1980, 3000).tail()<br/>&lt;IndexYear&gt;<br/>2996<br/>2997<br/>2998<br/>2999<br/>3000<br/>&lt;datetime64[Y]&gt;</span><span id="de0d" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; sf.IndexDate.from_year_range(1980, 3000).tail()<br/>&lt;IndexDate&gt;<br/>3000-12-27<br/>3000-12-28<br/>3000-12-29<br/>3000-12-30<br/>3000-12-31<br/>&lt;datetime64[D]&gt;</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7059" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">№ 8:层次索引的一致接口</h1><p id="65b6" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">分级索引允许将多个维度放入一个维度中。使用分级索引，<em class="nn"> n </em>维数据可以被编码到单个<code class="fe ni nj nk mz b">sf.Series</code>或<code class="fe ni nj nk mz b">sf.Frame</code>中。</p><p id="c6d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分级索引的一个关键特征是在任意深度的部分选择，由此选择可以由每个深度级别的选择的交集组成。熊猫提供了许多方式来表达那些内在的深度选择。</p><p id="fb52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一种方法是超载<code class="fe ni nj nk mz b">pd.DataFrame.loc[]</code>。当使用 Pandas 的层次索引(<code class="fe ni nj nk mz b">pd.MultiIndex</code>)时，<code class="fe ni nj nk mz b">pd.DataFrame.loc[]</code>选择中的位置参数的含义变成了动态的。正是这一点使得 Pandas 代码很难使用层次索引来维护。我们可以通过创建一个<code class="fe ni nj nk mz b">pd.DataFrame</code>并设置一个<code class="fe ni nj nk mz b">pd.MultiIndex</code>来看到这一点。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="1a45" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; df = pd.DataFrame.from_records([('muon', 0.106, -1.0, 'lepton'), ('tau', 1.777, -1.0, 'lepton'), ('charm', 1.3, 0.666, 'quark'), ('strange', 0.1, -0.333, 'quark')], columns=('name', 'mass', 'charge', 'type'))</span><span id="d5fa" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df.set_index(['type', 'name'], inplace=True)</span><span id="fcc0" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df<br/>                 mass  charge<br/>type   name<br/>lepton muon     0.106  -1.000<br/>       tau      1.777  -1.000<br/>quark  charm    1.300   0.666<br/>       strange  0.100  -0.333</span></pre><p id="c05d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似于 NumPy 中的 2D 数组，当给<code class="fe ni nj nk mz b">pd.DataFrame.loc[]</code>两个参数时，第一个参数是行选择器，第二个参数是列选择器。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="c9a0" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; df.loc['lepton', 'mass'] <em class="nn"># Selects "lepton" from row, "mass" from columns</em><br/>name<br/>muon    0.106<br/>tau     1.777<br/>Name: mass, dtype: float64</span></pre><p id="ff0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，与这种期望相反，有时 Pandas 不会将第二个参数用作列选择，而是用作<code class="fe ni nj nk mz b">pd.MultiIndex</code>内部深度的行选择。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="a4f9" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; df.loc['lepton', 'tau'] <em class="nn"># Selects lepton and tau from rows</em><br/>mass      1.777<br/>charge   -1.000<br/>Name: (lepton, tau), dtype: float64</span></pre><p id="beb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这种不确定性，Pandas 提供了两种选择。如果需要行和列选择，可以通过将分层行选择包装在<code class="fe ni nj nk mz b">pd.IndexSlice[]</code>选择修饰符中来恢复预期的行为。或者，如果不使用<code class="fe ni nj nk mz b">pd.IndexSlice[]</code>需要内部深度选择，可以使用<code class="fe ni nj nk mz b">pd.DataFrame.xs()</code>方法。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="8cfe" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; df.loc[pd.IndexSlice['lepton', 'tau'], 'charge']<br/>-1.0</span><span id="a5ea" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df.xs(level=1, key='tau')<br/>         mass  charge<br/>type<br/>lepton  1.777    -1.0</span></pre><p id="7530" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给予<code class="fe ni nj nk mz b">pd.DataFrame.loc[]</code>的位置参数的含义不一致是不必要的，这使得熊猫代码更难维护:使用<code class="fe ni nj nk mz b">pd.DataFrame.loc[]</code>的意图在没有<code class="fe ni nj nk mz b">pd.IndexSlice[]</code>的情况下变得不明确。此外，提供多种方法来解决这个问题也是一个缺点，因为在 Python 中最好有一种显而易见的方法来做事。</p><p id="41ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">StaticFrame 的<code class="fe ni nj nk mz b">sf.IndexHierarchy</code>提供了更加一致的行为。我们将创建一个等价的<code class="fe ni nj nk mz b">sf.Frame</code>并设置一个<code class="fe ni nj nk mz b">sf.IndexHierarchy</code>。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="dac9" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; f = sf.Frame.from_records((('muon', 0.106, -1.0, 'lepton'), ('tau', 1.777, -1.0, 'lepton'), ('charm', 1.3, 0.666, 'quark'), ('strange', 0.1, -0.333, 'quark')), columns=('name', 'mass', 'charge', 'type'))</span><span id="e0cd" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f = f.set_index_hierarchy(('type', 'name'), drop=True)</span><span id="c7d5" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f<br/>&lt;Frame&gt;<br/>&lt;Index&gt;                                    mass      charge    &lt;&lt;U6&gt;<br/>&lt;IndexHierarchy: ('type', 'name')&gt;<br/>lepton                             muon    0.106     -1.0<br/>lepton                             tau     1.777     -1.0<br/>quark                              charm   1.3       0.666<br/>quark                              strange 0.1       -0.333<br/>&lt;&lt;U6&gt;                              &lt;&lt;U7&gt;   &lt;float64&gt; &lt;float64&gt;</span></pre><p id="5276" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与 Pandas 不同，StaticFrame 在位置参数的含义上是一致的:第一个参数总是行选择器，第二个参数总是列选择器。对于在<code class="fe ni nj nk mz b">sf.IndexHierarchy</code>中的选择，需要<code class="fe ni nj nk mz b">sf.HLoc[]</code>选择修改器来指定层次中任意深度的选择。有一个显而易见的方法来选择内心深处。这种方法使得 StaticFrame 代码更容易理解和维护。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="04de" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; f.loc[sf.HLoc['lepton']]<br/>&lt;Frame&gt;<br/>&lt;Index&gt;                                  mass      charge    &lt;&lt;U6&gt;<br/>&lt;IndexHierarchy: ('type', 'name')&gt;<br/>lepton                             muon  0.106     -1.0<br/>lepton                             tau   1.777     -1.0<br/>&lt;&lt;U6&gt;                              &lt;&lt;U4&gt; &lt;float64&gt; &lt;float64&gt;</span><span id="43a5" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f.loc[sf.HLoc[:, ['muon', 'strange']], 'mass']<br/>&lt;Series: mass&gt;<br/>&lt;IndexHierarchy: ('type', 'name')&gt;<br/>lepton                             muon    0.106<br/>quark                              strange 0.1<br/>&lt;&lt;U6&gt;                              &lt;&lt;U7&gt;   &lt;float64&gt;</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="c343" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">№ 9:索引总是唯一的</h1><p id="2614" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">很自然地认为<code class="fe ni nj nk mz b">pd.DataFrame</code>上的索引和列标签是惟一标识符:它们的接口表明它们就像 Python 字典，其中的键总是惟一的。然而，熊猫指数并不局限于唯一值。在带有重复项的<code class="fe ni nj nk mz b">pd.DataFrame</code>上创建索引意味着，对于一些单标签选择，将返回一个<code class="fe ni nj nk mz b">pd.Series</code>，但是对于其他单标签选择，将返回一个<code class="fe ni nj nk mz b">pd.DataFrame</code>。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="ab2c" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; df = pd.DataFrame.from_records([('muon', 0.106, -1.0, 'lepton'), ('tau', 1.777, -1.0, 'lepton'), ('charm', 1.3, 0.666, 'quark'), ('strange', 0.1, -0.333, 'quark')], columns=('name', 'mass', 'charge', 'type'))</span><span id="aecc" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df.set_index('charge', inplace=True) # Creating an index with duplicated labels</span><span id="cc5d" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df<br/>           name   mass    type<br/>charge<br/>-1.000     muon  0.106  lepton<br/>-1.000      tau  1.777  lepton<br/> 0.666    charm  1.300   quark<br/>-0.333  strange  0.100   quark</span><span id="bd3c" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df.loc[-1.0] # Selecting a non-unique label results in a pd.DataFrame<br/>        name   mass    type<br/>charge<br/>-1.0    muon  0.106  lepton<br/>-1.0     tau  1.777  lepton</span><span id="d61e" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df.loc[0.666] # Selecting a unique label results in a pd.Series<br/>name    charm<br/>mass      1.3<br/>type    quark<br/>Name: 0.666, dtype: object</span></pre><p id="5969" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pandas 对非唯一索引的支持使得客户端代码变得更加复杂，因为它必须处理有时返回一个<code class="fe ni nj nk mz b">pd.Series</code>而有时返回一个<code class="fe ni nj nk mz b">pd.DataFrame</code>的选择。此外，索引的唯一性通常是对数据一致性的简单而有效的检查。</p><p id="9ce4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些 Pandas 接口，比如<code class="fe ni nj nk mz b">pd.concat()</code>和<code class="fe ni nj nk mz b">pd.DataFrame.set_index()</code>，提供了一个名为<code class="fe ni nj nk mz b">verify_integrity</code>的可选惟一性检查参数。令人惊讶的是，熊猫默认禁用了<code class="fe ni nj nk mz b">verify_integrity</code>。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="b896" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; df.set_index('type', verify_integrity=True)<br/>Traceback (most recent call last):<br/>ValueError: Index has duplicate keys: Index(['lepton', 'quark'], dtype='object', name='type')</span></pre><p id="df88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在 StaticFrame 中，索引总是唯一的。试图设置非唯一索引将引发异常。这个约束消除了在索引中错误引入重复的机会。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="4f8b" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; f = sf.Frame.from_records((('muon', 0.106, -1.0, 'lepton'), ('tau', 1.777, -1.0, 'lepton'), ('charm', 1.3, 0.666, 'quark'), ('strange', 0.1, -0.333, 'quark')), columns=('name', 'mass', 'charge', 'type'))</span><span id="1171" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f<br/>&lt;Frame&gt;<br/>&lt;Index&gt; name    mass      charge    type   &lt;&lt;U6&gt;<br/>&lt;Index&gt;<br/>0       muon    0.106     -1.0      lepton<br/>1       tau     1.777     -1.0      lepton<br/>2       charm   1.3       0.666     quark<br/>3       strange 0.1       -0.333    quark<br/>&lt;int64&gt; &lt;&lt;U7&gt;   &lt;float64&gt; &lt;float64&gt; &lt;&lt;U6&gt;</span><span id="0159" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; f.set_index('type')<br/>Traceback (most recent call last):<br/>static_frame.core.exception.ErrorInitIndex: labels (4) have non-unique values (2)</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="ae56" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">№ 10:去了又回来看熊猫</h1><p id="951b" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">StaticFrame 旨在与熊猫并肩工作。通过专门的构造器和导出器，例如<code class="fe ni nj nk mz b">Frame.from_pandas()</code>或<code class="fe ni nj nk mz b">Series.to_pandas()</code>，来回切换是可能的。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="c193" class="nd mc it mz b gy ne nf l ng nh">&gt;&gt;&gt; df = pd.DataFrame.from_records([('muon', 0.106, -1.0, 'lepton'), ('tau', 1.777, -1.0, 'lepton'), ('charm', 1.3, 0.666, 'quark'), ('strange', 0.1, -0.333, 'quark')], columns=('name', 'mass', 'charge', 'type'))</span><span id="f44e" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; df<br/>      name   mass  charge    type<br/>0     muon  0.106  -1.000  lepton<br/>1      tau  1.777  -1.000  lepton<br/>2    charm  1.300   0.666   quark<br/>3  strange  0.100  -0.333   quark</span><span id="f1e9" class="nd mc it mz b gy nl nf l ng nh">&gt;&gt;&gt; sf.Frame.from_pandas(df)<br/>&lt;Frame&gt;<br/>&lt;Index&gt; name     mass      charge    type     &lt;object&gt;<br/>&lt;Index&gt;<br/>0       muon     0.106     -1.0      lepton<br/>1       tau      1.777     -1.0      lepton<br/>2       charm    1.3       0.666     quark<br/>3       strange  0.1       -0.333    quark<br/>&lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt;</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7d80" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="14d2" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">“数据框”对象的概念在 2009 年 Pandas 0.1 发布之前很久就出现了:数据框的第一个实现可能早在 1991 年就出现在 r 的前身 S 语言中。今天，数据框在各种语言和实现中都有实现。熊猫将继续为广大用户提供优秀的资源。然而，对于正确性和代码可维护性至关重要的情况，StaticFrame 提供了一种替代方案，旨在更加一致并减少出错的机会。</p><p id="d5e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有关 StaticFrame 的更多信息，请参见<a class="ae nm" href="http://static-frame.readthedocs.io" rel="noopener ugc nofollow" target="_blank">文档</a>或<a class="ae nm" href="https://github.com/InvestmentSystems/static-frame" rel="noopener ugc nofollow" target="_blank">项目现场</a>。</p></div></div>    
</body>
</html>