<html>
<head>
<title>Twenty-five SQL practice exercises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二十五个 SQL 练习题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/twenty-five-sql-practice-exercises-5fc791e24082?source=collection_archive---------1-----------------------#2020-09-16">https://towardsdatascience.com/twenty-five-sql-practice-exercises-5fc791e24082?source=collection_archive---------1-----------------------#2020-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d596" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这些问题和示例解决方案将保持你的技能敏锐。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b3a8a9e7fefd2120150035ea9e7409a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvKRshweoXZAPbp3fPEb_A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://unsplash.com/photos/atSaEOeE8Nk" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h1 id="69b9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="6ff6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated">结构化查询语言(SQL)用于检索和操作存储在关系数据库中的数据。精通 SQL 是许多技术工作的重要先决条件，需要一些实践。</p><p id="a898" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">为了补充网上可用的 SQL 培训资源(<a class="ae ky" href="https://pgexercises.com/" rel="noopener ugc nofollow" target="_blank">pg exercise</a>、<a class="ae ky" href="https://leetcode.com/problemset/database/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>、<a class="ae ky" href="https://www.hackerrank.com/domains/sql" rel="noopener ugc nofollow" target="_blank"> HackerRank </a>、<a class="ae ky" href="https://mode.com/sql-tutorial/introduction-to-sql" rel="noopener ugc nofollow" target="_blank"> Mode </a>)，我整理了一个我最喜欢的问题列表，您可以手动解决这些问题，也可以用 PostgreSQL 实例来解决。</p><p id="cca1" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这些问题涵盖以下关键概念:</p><ul class=""><li id="cc02" class="nb nc it lt b lu mw lx mx ma nd me ne mi nf mm ng nh ni nj bi translated"><strong class="lt iu">基本检索</strong>(选择，从)</li><li id="5e54" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><strong class="lt iu">创建和别名</strong>(使用，AS，GENERATE_SERIES)</li><li id="cd31" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><strong class="lt iu">过滤</strong> (DISTINCT，WHERE，HAVING，AND，OR，IN，NOT IN)</li><li id="5aca" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><strong class="lt iu">聚合</strong>(分组依据，计数、总和、平均值)</li><li id="18cd" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><strong class="lt iu">连接</strong>(内连接、左连接、一个或多个等式上的全外连接、交叉连接、联合和联合所有)</li><li id="7d9f" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><strong class="lt iu">条件语句</strong><strong class="lt iu"/>(CASE-WHEN-THEN-ELSE-END)</li><li id="c226" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><strong class="lt iu">窗口函数</strong> (RANK，DENSE_RANK，ROW_NUMBER，SUM with PARTITION BY - ORDER BY)</li><li id="86fc" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><strong class="lt iu">格式化</strong>(限制、排序、整型、浮点型或日期型、串联、合并)</li><li id="1364" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><strong class="lt iu">算术</strong> <strong class="lt iu">运算和比较</strong> (+，-，*，/，//，^，&lt;，&gt;，=，！=)</li><li id="c63a" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><strong class="lt iu">日期时间操作</strong>(提取(月/日/年))</li></ul><h2 id="50ce" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">你自己试试</h2><p id="268f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">你可以下载<a class="ae ky" href="https://postgresapp.com/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>和<a class="ae ky" href="http://www.psequel.com/" rel="noopener ugc nofollow" target="_blank"> PSequel </a>(参见<a class="ae ky" href="https://www.youtube.com/watch?v=xaWlS9HtWYw" rel="noopener ugc nofollow" target="_blank">本教程</a>的分步安装指南)，然后运行下面文本中灰色框中显示的查询，自己尝试一下。PSequel 只适用于 Mac——如果你用的是 PC，你可以试试这些 Windows 替代品中的一个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/a59f941a09f83e50921fb730d13bd00a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QQZE3lDLjmaTu4l9ktI1WA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用<a class="ae ky" href="http://www.psequel.com/" rel="noopener ugc nofollow" target="_blank"> PSequel </a>和下面提供的输入表自己尝试这些查询。</p></figure><p id="38ea" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">下面显示的每个查询中的第一个文本块建立输入表，并遵循以下格式:</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="9462" class="np la it od b gy oh oi l oj ok">WITH input_table (column_1, column_2) <br/>AS (VALUES <br/>(1, 'A'), (2, 'B'))</span></pre><p id="df5b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">您可以使用 PSequel(如上所示)查询输入表，并使用该模板为您自己的问题轻松构建新表。</p><p id="f4d2" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">基于 Web 的 SQL 培训资源在几个方面存在不足。例如，LeetCode 不支持使用窗口功能，并将其最有趣的问题隐藏在付费墙之后。此外，在浏览器中运行 SQL 查询可能会非常慢，因为数据集很大，对于非高级用户来说，检索速度通常会受到限制。另一方面，本地执行查询是即时的，并允许通过语法错误和中间表进行快速迭代。我发现这是一次更令人满意的学习经历。</p><p id="c57a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">下面列出的问题包括证实在 PostgreSQL 中有效的示例解决方案。请记住，通常有多种方法可以获得 SQL 问题的正确答案。我更喜欢使用公共表表达式(<a class="ae ky" href="https://www.sqlservertutorial.net/sql-server-basics/sql-server-cte/" rel="noopener ugc nofollow" target="_blank">cte</a>)而不是嵌套子查询——cte 可以更线性地说明数据争论的顺序。然而，这两种方法可以产生相同的解决方案。我也喜欢遵循将 SQL 操作符全部大写的<a class="ae ky" href="https://www.sqlstyle.guide/" rel="noopener ugc nofollow" target="_blank">惯例</a>(SELECT、FROM、WHERE 等。)，小写的列名(user_id，date 等。)，以及简单的表别名(t1，t2 等。)可能的话。</p><p id="66f7" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">下面显示的代码片段可以按原样在 PSequel 中运行，以产生显示的结果。注意 Postgres 的一个怪癖:分数必须乘以 1.0 才能从整数转换成浮点格式。这在 SQL 的其他实现中是不需要的，在访谈中也是不期望的。</p><p id="a525" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">欢迎在评论中留下你的备选答案！</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><h1 id="cd2e" class="kz la it bd lb lc os le lf lg ot li lj jz ou ka ll kc ov kd ln kf ow kg lp lq bi translated">问题</h1><h2 id="261e" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">1.取消率</h2><p id="1fbb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">根据下表中的用户 id、操作和日期，编写一个查询来返回每个用户的发布率和取消率。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/33201a7613f2903911e60363ef63d368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6exQgk9ZzSy5mHMhSwGnBQ.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="5b15" class="np la it od b gy oh oi l oj ok">WITH users (user_id, action, date) <br/>AS (VALUES <br/>(1,'start', CAST('01-01-20' AS date)), <br/>(1,'cancel', CAST('01-02-20' AS date)), <br/>(2,'start', CAST('01-03-20' AS date)), <br/>(2,'publish', CAST('01-04-20' AS date)), <br/>(3,'start', CAST('01-05-20' AS date)), <br/>(3,'cancel', CAST('01-06-20' AS date)), <br/>(1,'start', CAST('01-07-20' AS date)), <br/>(1,'publish', CAST('01-08-20' AS date))),<br/></span><span id="94f4" class="np la it od b gy oy oi l oj ok"><em class="oz">-- retrieve count of starts, cancels, and publishes for each user</em></span><span id="cbe2" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT <br/>   user_id,<br/>   SUM(CASE WHEN action = 'start' THEN 1 ELSE 0 END) AS starts, <br/>   SUM(CASE WHEN action = 'cancel' THEN 1 ELSE 0 END) AS cancels, <br/>   SUM(CASE WHEN action = 'publish' THEN 1 ELSE 0 END) AS publishes<br/>FROM users<br/>GROUP BY 1<br/>ORDER BY 1)</span><span id="7260" class="np la it od b gy oy oi l oj ok"><em class="oz">-- calculate publication, cancelation rate for each user by dividing by number of starts, casting as float by multiplying by 1.0 (default floor division is a quirk of some SQL tools, not always needed)</em></span><span id="5192" class="np la it od b gy oy oi l oj ok">SELECT <br/>   user_id, <br/>   1.0*publishes/starts AS publish_rate, <br/>   1.0*cancels/starts AS cancel_rate<br/>FROM t1</span></pre><h2 id="2df5" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">2.净值的变化</h2><p id="db78" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从下面两个用户之间的交易表中，编写一个查询来返回每个用户的净值变化，按净变化递减排序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/0f3ef6f4f486735d32a7bdf17a39ef83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*47PasetI61lqJFEZk8JzLg.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="069a" class="np la it od b gy oh oi l oj ok">WITH transactions (sender, receiver, amount, transaction_date) <br/>AS (VALUES <br/>(5, 2, 10, CAST('2-12-20' AS date)),<br/>(1, 3, 15, CAST('2-13-20' AS date)), <br/>(2, 1, 20, CAST('2-13-20' AS date)), <br/>(2, 3, 25, CAST('2-14-20' AS date)), <br/>(3, 1, 20, CAST('2-15-20' AS date)), <br/>(3, 2, 15, CAST('2-15-20' AS date)), <br/>(1, 4, 5, CAST('2-16-20' AS date))),<br/></span><span id="af01" class="np la it od b gy oy oi l oj ok"><em class="oz">-- sum amounts for each sender (debits) and receiver (credits)</em></span><span id="5b31" class="np la it od b gy oy oi l oj ok">debits AS (<br/>SELECT <br/>   sender, <br/>   SUM(amount) AS debited<br/>FROM transactions<br/>GROUP BY 1 ),</span><span id="ee69" class="np la it od b gy oy oi l oj ok">credits AS (<br/>SELECT <br/>   receiver, <br/>   SUM(amount) AS credited<br/>FROM transactions<br/>GROUP BY 1 )</span><span id="b45f" class="np la it od b gy oy oi l oj ok"><em class="oz">-- full (outer) join debits and credits tables on user id, taking net change as difference between credits and debits, coercing nulls to zeros with coalesce()</em></span><span id="c7e8" class="np la it od b gy oy oi l oj ok">SELECT <br/>   COALESCE(sender, receiver) AS user, <br/>   COALESCE(credited, 0) - COALESCE(debited, 0) AS net_change <br/>FROM debits d<br/>FULL JOIN credits c<br/>ON d.sender = c.receiver<br/>ORDER BY 2 DESC</span></pre><h2 id="0ed7" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">3.最常见的项目</h2><p id="b52e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从包含日期和订购项目列表的下表中，编写一个查询以返回在每个日期订购的最频繁的项目。在平局的情况下返回多个项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/1221e1792a6c1b386af0bb4b64867c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JrGT9hwpKtOiqHDIJlhVrA.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="2367" class="np la it od b gy oh oi l oj ok">WITH items (date, item) <br/>AS (VALUES <br/>(CAST('01-01-20' AS date),'apple'), <br/>(CAST('01-01-20' AS date),'apple'), <br/>(CAST('01-01-20' AS date),'pear'), <br/>(CAST('01-01-20' AS date),'pear'), <br/>(CAST('01-02-20' AS date),'pear'), <br/>(CAST('01-02-20' AS date),'pear'), <br/>(CAST('01-02-20' AS date),'pear'), <br/>(CAST('01-02-20' AS date),'orange')),</span><span id="6163" class="np la it od b gy oy oi l oj ok"><em class="oz">-- add an item count column to existing table, grouping by date and item columns</em></span><span id="c1ca" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT <br/>   date, <br/>   item, <br/>   COUNT(*) AS item_count<br/>FROM items<br/>GROUP BY 1, 2<br/>ORDER BY 1),</span><span id="d132" class="np la it od b gy oy oi l oj ok"><em class="oz">-- add a rank column in descending order, partitioning by date</em></span><span id="2e38" class="np la it od b gy oy oi l oj ok">t2 AS (<br/>SELECT <br/>   *, <br/>   RANK() OVER (PARTITION BY date ORDER BY item_count DESC) AS date_rank<br/>FROM t1)</span><span id="6bd3" class="np la it od b gy oy oi l oj ok"><em class="oz">-- return all dates and items where rank = 1</em></span><span id="df7d" class="np la it od b gy oy oi l oj ok">SELECT <br/>   date, <br/>   item<br/>FROM t2<br/>WHERE date_rank = 1</span></pre><h2 id="8cf8" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">4.最新行动之间的时间差</h2><p id="4ed8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">根据下表中的用户操作，编写一个查询，按用户 ID 的升序为每个用户返回最后一个操作和倒数第二个操作之间经过的时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/05d277985f8a64549e96a625552dc889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V-H8ktf_ejaW5cY_uWuyMw.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="e971" class="np la it od b gy oh oi l oj ok">WITH users (user_id, action, action_date) <br/>AS (VALUES <br/>(1, 'start', CAST('2-12-20' AS date)), <br/>(1, 'cancel', CAST('2-13-20' AS date)), <br/>(2, 'start', CAST('2-11-20' AS date)), <br/>(2, 'publish', CAST('2-14-20' AS date)), <br/>(3, 'start', CAST('2-15-20' AS date)), <br/>(3, 'cancel', CAST('2-15-20' AS date)), <br/>(4, 'start', CAST('2-18-20' AS date)), <br/>(1, 'publish', CAST('2-19-20' AS date))),<br/></span><span id="3a84" class="np la it od b gy oy oi l oj ok"><em class="oz">-- create a date rank column, partitioned by user ID, using the ROW_NUMBER() window function </em></span><span id="f604" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT <br/>   *, <br/>   ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY action_date DESC) AS date_rank<br/>FROM users ),</span><span id="453b" class="np la it od b gy oy oi l oj ok"><em class="oz">-- filter on date rank column to pull latest and next latest actions from this table</em></span><span id="8fbe" class="np la it od b gy oy oi l oj ok">latest AS (<br/>SELECT *<br/>FROM t1 <br/>WHERE date_rank = 1 ),</span><span id="94e6" class="np la it od b gy oy oi l oj ok">next_latest AS (<br/>SELECT *<br/>FROM t1 <br/>WHERE date_rank = 2 )</span><span id="d652" class="np la it od b gy oy oi l oj ok"><em class="oz">-- left join these two tables, subtracting latest from second latest to get time elapsed </em></span><span id="e08a" class="np la it od b gy oy oi l oj ok">SELECT <br/>   l1.user_id, <br/>   l1.action_date - l2.action_date AS days_elapsed<br/>FROM latest l1<br/>LEFT JOIN next_latest l2<br/>ON l1.user_id = l2.user_id<br/>ORDER BY 1</span></pre><h2 id="c0d2" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">5.超级用户</h2><p id="ed52" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一家公司将其超级用户定义为至少进行过两次交易的用户。从下表中编写一个查询，为每个用户返回他们成为超级用户的日期，首先按最早的超级用户排序。不是超级用户的用户也应该出现在表中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/3328197967355faa32a350f7aef95912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vnj-R7Hm7b1WQgb5mymjDg.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="79cc" class="np la it od b gy oh oi l oj ok">WITH users (user_id, product_id, transaction_date) <br/>AS (VALUES <br/>(1, 101, CAST('2-12-20' AS date)), <br/>(2, 105, CAST('2-13-20' AS date)), <br/>(1, 111, CAST('2-14-20' AS date)), <br/>(3, 121, CAST('2-15-20' AS date)), <br/>(1, 101, CAST('2-16-20' AS date)), <br/>(2, 105, CAST('2-17-20' AS date)),<br/>(4, 101, CAST('2-16-20' AS date)), <br/>(3, 105, CAST('2-15-20' AS date))),<br/></span><span id="c097" class="np la it od b gy oy oi l oj ok"><em class="oz">-- create a transaction number column using ROW_NUMBER(), partitioning by user ID</em></span><span id="5aaa" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT <br/>   *, <br/>   ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY transaction_date) AS transaction_number<br/>FROM users),</span><span id="3d9f" class="np la it od b gy oy oi l oj ok"><em class="oz">-- filter resulting table on transaction_number = 2</em></span><span id="8e55" class="np la it od b gy oy oi l oj ok">t2 AS (<br/>SELECT <br/>   user_id, <br/>   transaction_date<br/>FROM t1<br/>WHERE transaction_number = 2 ),</span><span id="6229" class="np la it od b gy oy oi l oj ok"><em class="oz">-- left join super users onto full user table, order by date </em></span><span id="9df8" class="np la it od b gy oy oi l oj ok">t3 AS (<br/>SELECT DISTINCT user_id<br/>FROM users )</span><span id="f463" class="np la it od b gy oy oi l oj ok">SELECT <br/>   t3.user_id, <br/>   transaction_date AS superuser_date<br/>FROM t3<br/>LEFT JOIN t2<br/>ON t3.user_id = t2.user_id<br/>ORDER BY 2</span></pre><h2 id="62bb" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">6.内容推荐(硬)</h2><p id="06f7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用以下两个表，编写一个查询，根据社交媒体用户的朋友喜欢但尚未标记为喜欢的页面，向他们返回页面推荐。按用户 ID 升序排列结果。<a class="ae ky" href="https://www.glassdoor.com/Interview/Write-an-SQL-query-that-makes-recommendations-using-the-pages-that-your-friends-liked-Assume-you-have-two-tables-a-two-c-QTN_1413464.htm" rel="noopener ugc nofollow" target="_blank">来源</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/0641798a994fcdf3679194af42ca09a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v7XyMkp57-xuvFmzSpGFaA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/087a0f91a639847a7f1b85e0b2aed84d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9PEX-XH4SkdcxoNE_3KTA.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="6e34" class="np la it od b gy oh oi l oj ok">WITH friends (user_id, friend) <br/>AS (VALUES <br/>(1, 2), (1, 3), (1, 4), (2, 1), (3, 1), (3, 4), (4, 1), (4, 3)),</span><span id="6ad1" class="np la it od b gy oy oi l oj ok">likes (user_id, page_likes) <br/>AS (VALUES <br/>(1, 'A'), (1, 'B'), (1, 'C'), (2, 'A'), (3, 'B'), (3, 'C'), (4, 'B')),<br/></span><span id="65e5" class="np la it od b gy oy oi l oj ok"><em class="oz">-- inner join friends and page likes tables on user_id</em></span><span id="a71e" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT <br/>   l.user_id, <br/>   l.page_likes, <br/>   f.friend<br/>FROM likes l<br/>JOIN friends f<br/>ON l.user_id = f.user_id ),</span><span id="93d9" class="np la it od b gy oy oi l oj ok"><em class="oz">-- left join likes on this, requiring user = friend and user likes = friend likes </em></span><span id="586e" class="np la it od b gy oy oi l oj ok">t2 AS (<br/>SELECT <br/>   t1.user_id,<br/>   t1.page_likes, <br/>   t1.friend, <br/>   l.page_likes AS friend_likes<br/>FROM t1<br/>LEFT JOIN likes l<br/>ON t1.friend = l.user_id<br/>AND t1.page_likes = l.page_likes )</span><span id="a655" class="np la it od b gy oy oi l oj ok"><em class="oz">-- if a friend pair doesn’t share a common page like, friend likes column will be null - pull out these entries </em></span><span id="099b" class="np la it od b gy oy oi l oj ok">SELECT DISTINCT <br/>   friend AS user_id, <br/>   page_likes AS recommended_page<br/>FROM t2<br/>WHERE friend_likes IS NULL<br/>ORDER BY 1</span></pre><h2 id="cec2" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">7.移动和网络访问者</h2><p id="da1c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用下面的两个表，返回只访问移动设备、只访问 web 以及两者都访问的用户的比例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/d3aa62b659e1754cd3a4c2987ffbb250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eC638ZFO6ochPvfjfeZpfw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/3ca7708bef4b5a2861ee0a9dba85ae42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RikRSW5n70zlIVw9DGh2qQ.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="ef66" class="np la it od b gy oh oi l oj ok">WITH mobile (user_id, page_url) <br/>AS (VALUES <br/>(1, 'A'), (2, 'B'), (3, 'C'), (4, 'A'), (9, 'B'), (2, 'C'), (10, 'B')),</span><span id="ab67" class="np la it od b gy oy oi l oj ok">web (user_id, page_url) <br/>AS (VALUES <br/>(6, 'A'), (2, 'B'), (3, 'C'), (7, 'A'), (4, 'B'), (8, 'C'), (5, 'B')),</span><span id="6958" class="np la it od b gy oy oi l oj ok"><br/><em class="oz">-- outer join mobile and web users on user ID</em></span><span id="6638" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT DISTINCT <br/>   m.user_id AS mobile_user, <br/>   w.user_id AS web_user<br/>FROM mobile m<br/>FULL JOIN web w<br/>ON m.user_id = w.user_id)</span><span id="2ca7" class="np la it od b gy oy oi l oj ok"><em class="oz">-- calculate fraction of mobile-only, web-only, and both as average of values (ones and zeros) specified in case statement condition</em></span><span id="2691" class="np la it od b gy oy oi l oj ok">SELECT <br/>   AVG(CASE WHEN mobile_user IS NOT NULL AND web_user IS NULL THEN 1   ELSE 0 END) AS mobile_fraction,<br/>   AVG(CASE WHEN web_user IS NOT NULL AND mobile_user IS NULL THEN 1 ELSE 0 END) AS web_fraction,<br/>   AVG(CASE WHEN web_user IS NOT NULL AND mobile_user IS NOT NULL THEN 1 ELSE 0 END) AS both_fraction<br/>FROM t1</span></pre><h2 id="4936" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">8.按产品活动列出的升级率(硬)</h2><p id="e908" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">给定以下两个表，返回在注册后的前 30 天内访问功能二(事件表中的类型:F2)并升级到高级版的用户比例(四舍五入到两位小数)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/3d585cd8d22b51dd8dac64d0f7ef5ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*doulYV9_-C5x6JZVJNdZFg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/ec7a582b093336b7f9b430b79103d01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wG6-6Q7WOs5HI4Z1iqabZw.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="1241" class="np la it od b gy oh oi l oj ok">WITH users (user_id, name, join_date) <br/>AS (VALUES <br/>(1, 'Jon', CAST('2-14-20' AS date)), <br/>(2, 'Jane', CAST('2-14-20' AS date)), <br/>(3, 'Jill', CAST('2-15-20' AS date)), <br/>(4, 'Josh', CAST('2-15-20' AS date)), <br/>(5, 'Jean', CAST('2-16-20' AS date)), <br/>(6, 'Justin', CAST('2-17-20' AS date)),<br/>(7, 'Jeremy', CAST('2-18-20' AS date))),</span><span id="5bb2" class="np la it od b gy oy oi l oj ok">events (user_id, type, access_date) <br/>AS (VALUES <br/>(1, 'F1', CAST('3-1-20' AS date)), <br/>(2, 'F2', CAST('3-2-20' AS date)), <br/>(2, 'P', CAST('3-12-20' AS date)),<br/>(3, 'F2', CAST('3-15-20' AS date)), <br/>(4, 'F2', CAST('3-15-20' AS date)), <br/>(1, 'P', CAST('3-16-20' AS date)), <br/>(3, 'P', CAST('3-22-20' AS date))),</span><span id="250d" class="np la it od b gy oy oi l oj ok"><br/><em class="oz">-- get feature 2 users and their date of feature 2 access</em></span><span id="272e" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT <br/>   user_id, <br/>   type, <br/>   access_date AS f2_date<br/>FROM events<br/>WHERE type = 'F2' ),</span><span id="87c7" class="np la it od b gy oy oi l oj ok"><em class="oz">-- get premium users and their date of premium upgrade</em></span><span id="1512" class="np la it od b gy oy oi l oj ok">t2 AS (<br/>SELECT <br/>   user_id, <br/>   type, <br/>   access_date AS premium_date<br/>FROM events<br/>WHERE type = 'P' ),</span><span id="0ca0" class="np la it od b gy oy oi l oj ok"><em class="oz">-- for each feature 2 user, get time between joining and premium upgrade (or null if no upgrade) by inner joining full users table with feature 2 users on user ID and left joining premium users on user ID, then subtracting premium upgrade date from join date</em></span><span id="a85a" class="np la it od b gy oy oi l oj ok">t3 AS (<br/>SELECT t2.premium_date - u.join_date AS upgrade_time<br/>FROM users u<br/>JOIN t1<br/>ON u.user_id = t1.user_id<br/>LEFT JOIN t2<br/>ON u.user_id = t2.user_id )</span><span id="7a60" class="np la it od b gy oy oi l oj ok"><em class="oz">-- calculate fraction of users with upgrade time less than 30 days as average of values (ones and zeros) specified in case statement condition, rounding to two decimal places</em><br/> <br/>SELECT <br/>   ROUND(AVG(CASE WHEN upgrade_time &lt; 30 THEN 1 ELSE 0 END), 2) AS upgrade_rate<br/>FROM t3</span></pre><h2 id="4177" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">9.最友好的</h2><p id="bca4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">给定下表，返回用户列表及其相应的朋友计数。按照朋友数量降序排列结果，如果出现平局，则按照用户 ID 升序排列。假设只显示唯一的友谊<br/>(即【1，2】不会再次显示为【2，1】)。来自<a class="ae ky" href="https://leetcode.com/problems/friend-requests-ii-who-has-the-most-friends/" rel="noopener ugc nofollow" target="_blank">李码</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/e83ee654a7ace8dca3364a3c237a19d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RXFJFEmxdKq3K0oZSymi_Q.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="9b7f" class="np la it od b gy oh oi l oj ok">WITH friends (user1, user2) <br/>AS (VALUES (1, 2), (1, 3), (1, 4), (2, 3)),</span><span id="ba54" class="np la it od b gy oy oi l oj ok"><br/><em class="oz">-- compile all user appearances into one column, preserving duplicate entries with UNION ALL </em></span><span id="27d4" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT user1 AS user_id<br/>FROM friends<br/>UNION ALL<br/>SELECT user2 AS user_id<br/>FROM friends)</span><span id="3cad" class="np la it od b gy oy oi l oj ok"><em class="oz">-- grouping by user ID, count up all appearances of that user</em></span><span id="3323" class="np la it od b gy oy oi l oj ok">SELECT <br/>   user_id, <br/>   COUNT(*) AS friend_count<br/>FROM t1<br/>GROUP BY 1<br/>ORDER BY 2 DESC</span></pre><h2 id="3105" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">10.项目汇总(硬)</h2><p id="a13f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">“项目”表包含三列:“任务标识号”、“开始日期”和“结束日期”。表中每一行的结束日期和开始日期相差 1 天。如果任务结束日期是连续的，则它们是同一项目的一部分。项目不重叠。</p><p id="ea75" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">编写一个查询来返回每个项目的开始和结束日期，以及完成项目所用的天数。按项目持续时间升序排序，如果出现平局，则按开始日期升序排序。来自<a class="ae ky" href="https://www.hackerrank.com/challenges/sql-projects/problem" rel="noopener ugc nofollow" target="_blank">黑客排名</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/f36e16852b0c392c10516f11710e72ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCG_DvmIKANZu_q_SeYFUQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/40d11d626f0bec25b21ad656d8e90cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIlV-B0nT5TA_9G-5dcv1w.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="c023" class="np la it od b gy oh oi l oj ok">WITH projects (task_id, start_date, end_date) <br/>AS (VALUES <br/>(1, CAST('10-01-20' AS date), CAST('10-02-20' AS date)), <br/>(2, CAST('10-02-20' AS date), CAST('10-03-20' AS date)), <br/>(3, CAST('10-03-20' AS date), CAST('10-04-20' AS date)), <br/>(4, CAST('10-13-20' AS date), CAST('10-14-20' AS date)), <br/>(5, CAST('10-14-20' AS date), CAST('10-15-20' AS date)), <br/>(6, CAST('10-28-20' AS date), CAST('10-29-20' AS date)), <br/>(7, CAST('10-30-20' AS date), CAST('10-31-20' AS date))),<br/></span><span id="b4fa" class="np la it od b gy oy oi l oj ok"><em class="oz">-- get start dates not present in end date column (these are “true” project start dates) </em></span><span id="ba57" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT start_date<br/>FROM projects<br/>WHERE start_date NOT IN (SELECT end_date FROM projects) ),</span><span id="ccc0" class="np la it od b gy oy oi l oj ok"><em class="oz">-- get end dates not present in start date column (these are “true” project end dates) </em></span><span id="2808" class="np la it od b gy oy oi l oj ok">t2 AS (<br/>SELECT end_date<br/>FROM projects<br/>WHERE end_date NOT IN (SELECT start_date FROM projects) ),</span><span id="8617" class="np la it od b gy oy oi l oj ok"><em class="oz">-- filter to plausible start-end pairs (start &lt; end), then find correct end date for each start date (the minimum end date, since there are no overlapping projects)</em></span><span id="15a8" class="np la it od b gy oy oi l oj ok">t3 AS (<br/>SELECT <br/>   start_date, <br/>   MIN(end_date) AS end_date<br/>FROM t1, t2<br/>WHERE start_date &lt; end_date<br/>GROUP BY 1 )</span><span id="c54d" class="np la it od b gy oy oi l oj ok">SELECT <br/>   *, <br/>   end_date - start_date AS project_duration<br/>FROM t3<br/>ORDER BY 3, 1</span></pre><h2 id="a56a" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">11.生日出席率</h2><p id="a9ab" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">给定下面的两个表，编写一个查询来返回学生的分数，四舍五入到两位小数，他们在生日那天上学<br/>(出勤= 1)。<a class="ae ky" href="http://orhancanceylan.com/facebook/data/science/interview/2020/05/17/sql_facebook_student-attendance.html" rel="noopener ugc nofollow" target="_blank">来源</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/763ee990bb3d0ff367197e32cdd48caf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RLWKSnB9PH-ttqprg9KYQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/f772df097aa3ba09b21bac19111877a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ww_bNEqogrLPtIGIv5-P1w.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="d191" class="np la it od b gy oh oi l oj ok">WITH attendance (student_id, school_date, attendance)<br/>AS (VALUES<br/>(1, CAST('2020-04-03' AS date), 0),<br/>(2, CAST('2020-04-03' AS date), 1),<br/>(3, CAST('2020-04-03' AS date), 1), <br/>(1, CAST('2020-04-04' AS date), 1), <br/>(2, CAST('2020-04-04' AS date), 1), <br/>(3, CAST('2020-04-04' AS date), 1), <br/>(1, CAST('2020-04-05' AS date), 0), <br/>(2, CAST('2020-04-05' AS date), 1), <br/>(3, CAST('2020-04-05' AS date), 1), <br/>(4, CAST('2020-04-05' AS date), 1)),</span><span id="ad34" class="np la it od b gy oy oi l oj ok">students (student_id, school_id, grade_level, date_of_birth)<br/>AS (VALUES<br/>(1, 2, 5, CAST('2012-04-03' AS date)),<br/>(2, 1, 4, CAST('2013-04-04' AS date)),<br/>(3, 1, 3, CAST('2014-04-05' AS date)), <br/>(4, 2, 4, CAST('2013-04-03' AS date)))<br/></span><span id="0078" class="np la it od b gy oy oi l oj ok">-- join attendance and students table on student ID, and day and month of school day = day and month of birthday, taking average of attendance column values and rounding</span><span id="095d" class="np la it od b gy oy oi l oj ok">SELECT ROUND(AVG(attendance), 2) AS birthday_attendance<br/>FROM attendance a<br/>JOIN students s<br/>ON a.student_id = s.student_id <br/>AND EXTRACT(MONTH FROM school_date) = EXTRACT(MONTH FROM date_of_birth)<br/>AND EXTRACT(DAY FROM school_date) = EXTRACT(DAY FROM date_of_birth)</span></pre><h2 id="80b1" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">12.黑客得分</h2><p id="d023" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">给定以下两个表，编写一个查询来返回黑客 ID、姓名和总分(完成的每个挑战的最高分之和),按分数降序排序，在分数相等的情况下按黑客 ID 升序排序。不显示零分黑客的条目。来自<a class="ae ky" href="https://www.hackerrank.com/contests/simply-sql-the-sequel/challenges/full-score" rel="noopener ugc nofollow" target="_blank"> HackerRank </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/aaa841d59d20bc63f88764e608432702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTGAc7suy-DL-LrMlF8fxQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/7967502825546acdaad858a5ed707f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W8jd1hCJUDFVQixFfM6FhA.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="3595" class="np la it od b gy oh oi l oj ok">WITH hackers (hacker_id, name)<br/>AS (VALUES<br/>(1, 'John'),<br/>(2, 'Jane'),<br/>(3, 'Joe'),<br/>(4, 'Jim')),</span><span id="aa92" class="np la it od b gy oy oi l oj ok">submissions (submission_id, hacker_id, challenge_id, score)<br/>AS (VALUES<br/>(101, 1, 1, 10),<br/>(102, 1, 1, 12),<br/>(103, 2, 1, 11),<br/>(104, 2, 1, 9),<br/>(105, 2, 2, 13),<br/>(106, 3, 1, 9),<br/>(107, 3, 2, 12),<br/>(108, 3, 2, 15),<br/>(109, 4, 1, 0)),<br/></span><span id="c2b1" class="np la it od b gy oy oi l oj ok"><em class="oz">-- from submissions table, get maximum score for each hacker-challenge pair</em></span><span id="c040" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT <br/>   hacker_id, <br/>   challenge_id, <br/>   MAX(score) AS max_score<br/>FROM submissions <br/>GROUP BY 1, 2 )</span><span id="ad27" class="np la it od b gy oy oi l oj ok"><em class="oz">-- inner join this with the hackers table, sum up all maximum scores, filter to exclude hackers with total score of zero, and order result by total score and hacker ID</em></span><span id="155f" class="np la it od b gy oy oi l oj ok">SELECT <br/>   t1.hacker_id, <br/>   h.name, <br/>   SUM(t1.max_score) AS total_score<br/>FROM t1<br/>JOIN hackers h<br/>ON t1.hacker_id = h.hacker_id<br/>GROUP BY 1, 2<br/>HAVING SUM(max_score) &gt; 0<br/>ORDER BY 3 DESC, 1</span></pre><h2 id="0590" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">13.有等级无等级(硬)</h2><p id="7331" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">编写一个查询，在不使用窗口函数的情况下对下表中的分数进行排序。如果两个分数相等，则两者应该具有相同的等级。平局之后，下面的排名应该是下一个连续的整数值。来自<a class="ae ky" href="https://leetcode.com/problems/rank-scores/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/48e3d3e8e1b45960b0f3f5a2c9231ad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kErBcsLZRd7Z4RhdazhSjg.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="2a44" class="np la it od b gy oh oi l oj ok">WITH scores (id, score)<br/>AS (VALUES<br/>(1, 3.50),<br/>(2, 3.65),<br/>(3, 4.00),<br/>(4, 3.85),<br/>(5, 4.00),<br/>(6, 3.65))<br/></span><span id="de54" class="np la it od b gy oy oi l oj ok"><em class="oz">-- self-join on inequality produces a table with one score and all scores as large as this joined to it, grouping by first id and score, and counting up all unique values of joined scores yields the equivalent of DENSE_RANK()   [check join output to understand]</em></span><span id="8bfe" class="np la it od b gy oy oi l oj ok">SELECT <br/>   s1.score, <br/>   COUNT(DISTINCT s2.score) AS score_rank<br/>FROM scores s1 <br/>JOIN scores s2<br/>ON s1.score &lt;= s2.score<br/>GROUP BY s1.id, s1.score<br/>ORDER BY 1 DESC</span></pre><h2 id="9110" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">14.累计薪金总额</h2><p id="af2e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下表保存了几名雇员的月薪信息。编写一个查询，获取一名雇员在 3 个月内(不包括最近一个月)每月的工资总额。结果应该按雇员 ID 和月份升序排序。来自<a class="ae ky" href="https://leetcode.com/problems/find-cumulative-salary-of-an-employee/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/c8b429a1ddd669776f461abfec81d0f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i93tuq2qyL8y586I4QRpsw.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="ef7e" class="np la it od b gy oh oi l oj ok">WITH employee (id, pay_month, salary)<br/>AS (VALUES<br/>(1, 1, 20),<br/>(2, 1, 20),<br/>(1, 2, 30),<br/>(2, 2, 30),<br/>(3, 2, 40),<br/>(1, 3, 40),<br/>(3, 3, 60),<br/>(1, 4, 60),<br/>(3, 4, 70)),</span><span id="1548" class="np la it od b gy oy oi l oj ok"><br/><em class="oz">-- add column for descending month rank (latest month = 1) for each employee</em></span><span id="16b5" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT *, <br/>   RANK() OVER (PARTITION BY id ORDER BY pay_month DESC) AS month_rank<br/>FROM employee )</span><span id="515d" class="np la it od b gy oy oi l oj ok"><em class="oz">-- filter to exclude latest month and months 5+, create cumulative salary sum using SUM() as window function, order by ID and month</em></span><span id="0d44" class="np la it od b gy oy oi l oj ok">SELECT <br/>   id, <br/>   pay_month, <br/>   salary, <br/>   SUM(salary) OVER (PARTITION BY id ORDER BY month_rank DESC) AS cumulative_sum<br/>FROM t1 <br/>WHERE month_rank != 1<br/>AND month_rank &lt;= 4<br/>ORDER BY 1, 2</span></pre><h2 id="1c9c" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">15.团队排名</h2><p id="f9d5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">编写一个查询，在 matches 表中显示所有比赛之后，返回 teams 表中每个队的得分。计分如下:输了得零分，平了得一分，赢了得三分。结果应该包括球队名称和分数，并按分数递减排序。如果出现平局，按字母顺序排列球队名称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/dc04df559f9e73fdda8b51f3f87e54cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Funn7qRPgYU5CpXo_M15qQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/fba3e45069e93b9327aeb8579fc79762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbqwqZLkFGx2vafTgAF4CQ.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="88d8" class="np la it od b gy oh oi l oj ok">WITH teams (team_id, team_name)<br/>AS (VALUES<br/>(1, 'New York'),<br/>(2, 'Atlanta'),<br/>(3, 'Chicago'),<br/>(4, 'Toronto'),<br/>(5, 'Los Angeles'),<br/>(6, 'Seattle')),</span><span id="6350" class="np la it od b gy oy oi l oj ok">matches (match_id, host_team, guest_team, host_goals, guest_goals)<br/>AS (VALUES<br/>(1, 1, 2, 3, 0),<br/>(2, 2, 3, 2, 4),<br/>(3, 3, 4, 4, 3),<br/>(4, 4, 5, 1, 1),<br/>(5, 5, 6, 2, 1),<br/>(6, 6, 1, 1, 2)),</span><span id="6146" class="np la it od b gy oy oi l oj ok"><br/><em class="oz">-- add host points and guest points columns to matches table, using case-when-then to tally up points for wins, ties, and losses</em></span><span id="e58f" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT <br/>   *, <br/>   CASE WHEN host_goals &gt; guest_goals THEN 3 <br/>        WHEN host_goals = guest_goals THEN 1 <br/>        ELSE 0 END AS host_points, <br/>   CASE WHEN host_goals &lt; guest_goals THEN 3 <br/>   WHEN host_goals = guest_goals THEN 1 <br/>   ELSE 0 END AS guest_points<br/>FROM matches )</span><span id="10c0" class="np la it od b gy oy oi l oj ok"><em class="oz">-- join result onto teams table twice to add up for each team the points earned as host team and guest team, then order as requested</em></span><span id="1064" class="np la it od b gy oy oi l oj ok">SELECT <br/>   t.team_name, <br/>   a.host_points + b.guest_points AS total_points<br/>FROM teams t<br/>JOIN t1 a<br/>ON t.team_id = a.host_team<br/>JOIN t1 b<br/>ON t.team_id = b.guest_team<br/>ORDER BY 2 DESC, 1</span></pre><h2 id="44e1" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">16.没有购买产品的顾客</h2><p id="804e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">根据下表，编写一个查询来显示购买了产品 A 和 B 但没有购买产品 C 的客户的 ID 和姓名，按客户 ID 升序排序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/96608defd61737cdb82e2714355701a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJ0zJ8M7cV7TyLJTB-YJTA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/8b97d793fbeca4f99c90d6fdb33c2c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2juWrWRvGQJ105M2Ji_wWw.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="d926" class="np la it od b gy oh oi l oj ok">WITH customers (id, name)<br/>AS (VALUES<br/>(1, 'Daniel'),<br/>(2, 'Diana'),<br/>(3, 'Elizabeth'),<br/>(4, 'John')),</span><span id="f2cd" class="np la it od b gy oy oi l oj ok">orders (order_id, customer_id, product_name)<br/>AS (VALUES<br/>(1, 1, 'A'),<br/>(2, 1, 'B'),<br/>(3, 2, 'A'),<br/>(4, 2, 'B'),<br/>(5, 2, 'C'),<br/>(6, 3, 'A'), <br/>(7, 3, 'A'),<br/>(8, 3, 'B'),<br/>(9, 3, 'D'))</span><span id="9f35" class="np la it od b gy oy oi l oj ok"><br/><em class="oz">-- join customers and orders tables on customer ID, filtering to those who bought both products A and B, removing those who bought product C, returning ID and name columns ordered by ascending ID</em></span><span id="9f30" class="np la it od b gy oy oi l oj ok">SELECT DISTINCT <br/>   id, <br/>   name<br/>FROM orders o<br/>JOIN customers c<br/>ON o.customer_id = c.id<br/>WHERE customer_id IN (SELECT customer_id <br/>                      FROM orders <br/>                      WHERE product_name = 'A') <br/>AND customer_id IN (SELECT customer_id <br/>                    FROM orders <br/>                    WHERE product_name = 'B') <br/>AND customer_id NOT IN (SELECT customer_id <br/>                        FROM orders <br/>                        WHERE product_name = 'C')<br/>ORDER BY 1</span></pre><h2 id="2435" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">17.中纬度(硬)</h2><p id="9880" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">编写一个查询来返回下表中每个州气象站的中值纬度，四舍五入到最接近的十分之一度。注意，SQL 中没有 MEDIAN()函数！来自<a class="ae ky" href="https://www.hackerrank.com/challenges/weather-observation-station-20/problem" rel="noopener ugc nofollow" target="_blank">黑客排名</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/0342f9ea3007b2504601010fa192ab8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toYDUQAbD0UQQ1tkSWG4Eg.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="2c88" class="np la it od b gy oh oi l oj ok">WITH stations (id, city, state, latitude, longitude)<br/>AS (VALUES<br/>(1, 'Asheville', 'North Carolina', 35.6, 82.6),<br/>(2, 'Burlington', 'North Carolina', 36.1, 79.4),<br/>(3, 'Chapel Hill', 'North Carolina', 35.9, 79.1),<br/>(4, 'Davidson', 'North Carolina', 35.5, 80.8),<br/>(5, 'Elizabeth City', 'North Carolina', 36.3, 76.3),<br/>(6, 'Fargo', 'North Dakota', 46.9, 96.8),<br/>(7, 'Grand Forks', 'North Dakota', 47.9, 97.0),<br/>(8, 'Hettinger', 'North Dakota', 46.0, 102.6),<br/>(9, 'Inkster', 'North Dakota', 48.2, 97.6)),</span><span id="f1f1" class="np la it od b gy oy oi l oj ok"><br/><em class="oz">-- assign latitude-ordered row numbers for each state, and get total row count for each state</em></span><span id="8d28" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT <br/>   *, <br/>   ROW_NUMBER() OVER (PARTITION BY state ORDER BY latitude ASC) AS row_number_state, <br/>            count(*) OVER (PARTITION BY state) AS row_count<br/>FROM stations )</span><span id="4130" class="np la it od b gy oy oi l oj ok"><em class="oz">-- filter to middle row (for odd total row number) or middle two rows (for even total row number), then get average value of those, grouping by state</em></span><span id="214b" class="np la it od b gy oy oi l oj ok">SELECT <br/>   state, <br/>   AVG(latitude) AS median_latitude<br/>FROM t1<br/>WHERE row_number_state &gt;= 1.0*row_count/2 <br/>AND row_number_state &lt;= 1.0*row_count/2 + 1<br/>GROUP BY 1</span></pre><h2 id="9120" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">18.最大分隔城市</h2><p id="8f08" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从问题 17 的同一个表中，编写一个查询，返回每个州中相距最远的一对城市，以及这两个城市之间的相应距离(以度为单位，四舍五入到小数点后两位)。来自<a class="ae ky" href="https://www.hackerrank.com/challenges/weather-observation-station-19/problem" rel="noopener ugc nofollow" target="_blank">黑客排名</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/abf62339f94ed7d8ec62786bed09f211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gGA8R-1mvzC2uZDhMZ7F-A.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="c808" class="np la it od b gy oh oi l oj ok">WITH stations (id, city, state, latitude, longitude)<br/>AS (VALUES<br/>(1, 'Asheville', 'North Carolina', 35.6, 82.6),<br/>(2, 'Burlington', 'North Carolina', 36.1, 79.4),<br/>(3, 'Chapel Hill', 'North Carolina', 35.9, 79.1),<br/>(4, 'Davidson', 'North Carolina', 35.5, 80.8),<br/>(5, 'Elizabeth City', 'North Carolina', 36.3, 76.3),<br/>(6, 'Fargo', 'North Dakota', 46.9, 96.8),<br/>(7, 'Grand Forks', 'North Dakota', 47.9, 97.0),<br/>(8, 'Hettinger', 'North Dakota', 46.0, 102.6),<br/>(9, 'Inkster', 'North Dakota', 48.2, 97.6)),</span><span id="35bc" class="np la it od b gy oy oi l oj ok"><br/><em class="oz">-- self-join on matching states and city &lt; city (avoids identical and double-counted city pairs), pulling state, city pair, and latitude/longitude coordinates for each city</em></span><span id="8fd7" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT <br/>   s1.state, <br/>   s1.city AS city1, <br/>   s2.city AS city2, <br/>   s1.latitude AS city1_lat, <br/>   s1.longitude AS city1_long, <br/>   s2.latitude AS city2_lat, <br/>   s2.longitude AS city2_long<br/>FROM stations s1<br/>JOIN stations s2<br/>ON s1.state = s2.state <br/>AND s1.city &lt; s2.city ),</span><span id="4723" class="np la it od b gy oy oi l oj ok"><em class="oz">-- add a column displaying rounded Euclidean distance </em></span><span id="5aa5" class="np la it od b gy oy oi l oj ok">t2 AS (<br/>SELECT *, <br/>ROUND(( (city1_lat - city2_lat)^2 + (city1_long - city2_long)^2 ) ^ 0.5, 2) AS distance<br/>FROM t1 ),</span><span id="c87a" class="np la it od b gy oy oi l oj ok"><em class="oz">-- rank each city pair by descending distance for each state</em></span><span id="d412" class="np la it od b gy oy oi l oj ok">t3 AS (<br/>SELECT *, RANK() OVER (PARTITION BY state ORDER BY distance DESC) AS dist_rank<br/>FROM t2 )</span><span id="35de" class="np la it od b gy oy oi l oj ok"><em class="oz">-- return the city pair with maximium separation</em></span><span id="da54" class="np la it od b gy oy oi l oj ok">SELECT <br/>   state, <br/>   city1, <br/>   city2, <br/>   distance<br/>FROM t3<br/>WHERE dist_rank = 1</span></pre><h2 id="ad45" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">19.周期</h2><p id="0531" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">编写一个查询来返回每个月的平均周期时间。周期时间是一个用户加入和他们的被邀请者加入之间经过的时间。未经邀请而加入的用户在“邀请者”一栏中有一个零。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/c0eaf67093e06bc3f0cd62da5f5bcada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*McdfDxMnrXZcijlFN-SOHw.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="6d75" class="np la it od b gy oh oi l oj ok">WITH users (user_id, join_date, invited_by) <br/>AS (VALUES <br/>(1, CAST('01-01-20' AS date), 0), <br/>(2, CAST('01-10-20' AS date), 1), <br/>(3, CAST('02-05-20' AS date), 2), <br/>(4, CAST('02-12-20' AS date), 3), <br/>(5, CAST('02-25-20' AS date), 2), <br/>(6, CAST('03-01-20' AS date), 0), <br/>(7, CAST('03-01-20' AS date), 4),<br/>(8, CAST('03-04-20' AS date), 7)),</span><span id="aa7d" class="np la it od b gy oy oi l oj ok"><br/><em class="oz">-- self-join on invited by = user ID, extract join month from inviter join date, and calculate cycle time as difference between join dates of inviter and invitee</em></span><span id="ed4c" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT <br/>   CAST(EXTRACT(MONTH FROM u2.join_date) AS int) AS month,<br/>   u1.join_date - u2.join_date AS cycle_time<br/>FROM users u1<br/>JOIN users u2<br/>ON u1.invited_by = u2.user_id )</span><span id="9137" class="np la it od b gy oy oi l oj ok"><em class="oz">-- group by join month, take average of cycle times within each month</em></span><span id="21ef" class="np la it od b gy oy oi l oj ok">SELECT <br/>   month, <br/>   AVG(cycle_time) AS cycle_time_month_avg<br/>FROM t1<br/>GROUP BY 1<br/>ORDER BY 1</span></pre><h2 id="a835" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">20.连续三次</h2><p id="2611" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">出席表记录了每天举行活动时人群中的人数。编写一个查询来返回一个显示高出勤率时段的日期和访问者计数的表，高出勤率时段定义为三个连续的条目(不一定是连续的日期),访问者超过 100 人。来自<a class="ae ky" href="https://leetcode.com/problems/human-traffic-of-stadium/solution/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/7c8d2ef28f788902a1e75771d1874273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdOxbUUj1BD1xXnOCP5M6Q.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="ac64" class="np la it od b gy oh oi l oj ok">WITH attendance (event_date, visitors) <br/>AS (VALUES <br/>(CAST('01-01-20' AS date), 10), <br/>(CAST('01-04-20' AS date), 109), <br/>(CAST('01-05-20' AS date), 150), <br/>(CAST('01-06-20' AS date), 99), <br/>(CAST('01-07-20' AS date), 145), <br/>(CAST('01-08-20' AS date), 1455), <br/>(CAST('01-11-20' AS date), 199),<br/>(CAST('01-12-20' AS date), 188)),<br/></span><span id="3df6" class="np la it od b gy oy oi l oj ok"><em class="oz">-- add row numbers to identify consecutive entries, since date column has some gaps</em></span><span id="5006" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT *, <br/>   ROW_NUMBER() OVER (ORDER BY event_date) AS day_num<br/>FROM attendance ),</span><span id="82a2" class="np la it od b gy oy oi l oj ok"><em class="oz">-- filter this to exclude days with &gt; 100 visitors</em></span><span id="1840" class="np la it od b gy oy oi l oj ok">t2 AS (<br/>SELECT *<br/>FROM t1<br/>WHERE visitors &gt; 100 ),</span><span id="e329" class="np la it od b gy oy oi l oj ok"><em class="oz">-- self-join (inner) twice on offset = 1 day and offset = 2 days</em></span><span id="8b8c" class="np la it od b gy oy oi l oj ok">t3 AS (<br/>SELECT <br/>   a.day_num AS day1, <br/>   b.day_num AS day2, <br/>   c.day_num AS day3<br/>FROM t2 a<br/>JOIN t2 b<br/>ON a.day_num = b.day_num - 1<br/>JOIN t2 c<br/>ON a.day_num = c.day_num - 2 )</span><span id="71ce" class="np la it od b gy oy oi l oj ok"><em class="oz">-- pull date and visitor count for consecutive days surfaced in previous table</em></span><span id="9dc9" class="np la it od b gy oy oi l oj ok">SELECT <br/>   event_date, <br/>   visitors<br/>FROM t1<br/>WHERE day_num IN (SELECT day1 FROM t3)<br/>   OR day_num IN (SELECT day2 FROM t3)<br/>   OR day_num IN (SELECT day3 FROM t3)</span></pre><h2 id="af6e" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">21.通常一起购买</h2><p id="e831" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用下面两个表，编写一个查询来返回最常一起购买的前三对产品的名称和购买频率。两种产品的名称应该出现在一列中。<a class="ae ky" href="https://www.careercup.com/question?id=5759072822362112" rel="noopener ugc nofollow" target="_blank">来源</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/b9fdc0872cb5fb18457bb7908c3b1f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W0IcDOevBv-QiRB4LlQT8A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/8c773d91121124ebca59972187bcc560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDy7PrBGUncnPPhIuXv8og.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="a078" class="np la it od b gy oh oi l oj ok">WITH orders (order_id, customer_id, product_id) <br/>AS (VALUES <br/>(1, 1, 1),<br/>(1, 1, 2),<br/>(1, 1, 3),<br/>(2, 2, 1),<br/>(2, 2, 2),<br/>(2, 2, 4),<br/>(3, 1, 5)),</span><span id="8aaf" class="np la it od b gy oy oi l oj ok">products (id, name) <br/>AS (VALUES <br/>(1, 'A'),<br/>(2, 'B'),<br/>(3, 'C'),<br/>(4, 'D'),<br/>(5, 'E')),<br/></span><span id="43b9" class="np la it od b gy oy oi l oj ok"><em class="oz">-- get unique product pairs from same order by self-joining orders table on order ID and product ID &lt; product ID (avoids identical and double-counted product pairs)</em></span><span id="1067" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT <br/>   o1.product_id AS prod_1, <br/>   o2.product_id AS prod_2<br/>FROM orders o1<br/>JOIN orders o2<br/>ON o1.order_id = o2.order_id<br/>AND o1.product_id &lt; o2.product_id ),</span><span id="d38e" class="np la it od b gy oy oi l oj ok"><em class="oz">-- join products table onto this to get product names, concatenate to get product pairs in one column</em></span><span id="0eb7" class="np la it od b gy oy oi l oj ok">t2 AS (<br/>SELECT CONCAT(p1.name, ' ', p2.name) AS product_pair<br/>FROM t1<br/>JOIN products p1<br/>ON t1.prod_1 = p1.id<br/>JOIN products p2<br/>ON t1.prod_2 = p2.id )</span><span id="b141" class="np la it od b gy oy oi l oj ok"><em class="oz">-- grouping by product pair, return top 3 entries sorted by purchase frequency</em></span><span id="efe8" class="np la it od b gy oy oi l oj ok">SELECT *, <br/>   COUNT(*) AS purchase_freq<br/>FROM t2<br/>GROUP BY 1<br/>ORDER BY 2 DESC <br/>LIMIT 3</span></pre><h2 id="511d" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">22.平均治疗效果(硬)</h2><p id="6880" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从总结研究结果的下表中，计算平均治疗效果以及 95%置信区间的上限和下限。将这些数字四舍五入到小数点后 3 位。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/b07dfda2c4acf365826d5709a9dad00f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ZIODYqlupjh8tBVCOfNpg.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="407d" class="np la it od b gy oh oi l oj ok">WITH study (participant_id, assignment, outcome) <br/>AS (VALUES <br/>(1, 0, 0),<br/>(2, 1, 1),<br/>(3, 0, 1),<br/>(4, 1, 0),<br/>(5, 0, 1),<br/>(6, 1, 1),<br/>(7, 0, 0),<br/>(8, 1, 1),<br/>(9, 1, 1)),</span><span id="1028" class="np la it od b gy oy oi l oj ok"><br/>-- get average outcomes, standard deviations, and group sizes for control and treatment groups</span><span id="cbb7" class="np la it od b gy oy oi l oj ok">control AS (<br/>SELECT <br/>   AVG(outcome) AS avg_outcome, <br/>   STDDEV(outcome) AS std_dev, <br/>   COUNT(*) AS group_size<br/>FROM study<br/>WHERE assignment = 0 ),</span><span id="6a41" class="np la it od b gy oy oi l oj ok">treatment AS (<br/>SELECT <br/>   AVG(outcome) AS avg_outcome, <br/>   STDDEV(outcome) AS std_dev,<br/>   COUNT(*) AS group_size<br/>FROM study<br/>WHERE assignment = 1 ),</span><span id="cab7" class="np la it od b gy oy oi l oj ok">-- get average treatment effect size</span><span id="8824" class="np la it od b gy oy oi l oj ok">effect_size AS (<br/>SELECT t.avg_outcome - c.avg_outcome AS effect_size<br/>FROM control c, treatment t ),</span><span id="a176" class="np la it od b gy oy oi l oj ok">-- construct 95% confidence interval using z* = 1.96 and magnitude of individual standard errors [ std dev / sqrt(sample size) ]</span><span id="838e" class="np la it od b gy oy oi l oj ok">conf_interval AS (<br/>SELECT 1.96 * (t.std_dev^2 / t.group_size <br/>             + c.std_dev^2 / c.group_size)^0.5 AS conf_int<br/>FROM treatment t, control c )</span><span id="79e5" class="np la it od b gy oy oi l oj ok">SELECT round(es.effect_size, 3) AS point_estimate, <br/>        round(es.effect_size - ci.conf_int, 3) AS lower_bound, <br/>        round(es.effect_size + ci.conf_int, 3) AS upper_bound<br/>FROM effect_size es, conf_interval ci</span></pre><h2 id="6049" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">23.滚动工资总额</h2><p id="c782" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下表显示了给定年份中前九个月员工的月薪。在此基础上，编写一个查询来返回一个表，该表按时间顺序显示上半年每个月雇员当月和接下来两个月的工资总额。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/18c5bf47c29655ac526d93681eb16bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXbOBcBf4Efo2YAj8p7hTg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/72b70537effc9044dacbb79835a859fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eVEsUlv6Z9dKQ41VzLA13w.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="79be" class="np la it od b gy oh oi l oj ok">WITH salaries (month, salary) <br/>AS (VALUES <br/>(1, 2000),<br/>(2, 3000),<br/>(3, 5000),<br/>(4, 4000),<br/>(5, 2000),<br/>(6, 1000),<br/>(7, 2000),<br/>(8, 4000),<br/>(9, 5000))<br/></span><span id="edc9" class="np la it od b gy oy oi l oj ok">-- self-join to match month n with months n, n+1, and n+2, then sum salary across those months, filter to first half of year, and sort</span><span id="02de" class="np la it od b gy oy oi l oj ok">SELECT <br/>   s1.month, <br/>   SUM(s2.salary) AS salary_3mos<br/>FROM salaries s1<br/>JOIN salaries s2<br/>ON s1.month &lt;= s2.month <br/>AND s1.month &gt; s2.month - 3<br/>GROUP BY 1<br/>HAVING s1.month &lt; 7<br/>ORDER BY 1</span></pre><h2 id="ac18" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">24.出租车取消率</h2><p id="1cf4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从出租车服务的给定 trips 和 users 表中，编写一个查询，返回 10 月份前两天的取消率，四舍五入到两位小数，返回不涉及被禁乘客或司机的行程。来自<a class="ae ky" href="https://leetcode.com/problems/trips-and-users/description/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/5470150ded88db6523174ec2db4d2f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MH-Qvfi7U9q9nQUP12Z4lQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/fb97ab80a16adfb06b8ec70a3fc9c202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qiEcIbH5K9JehXuwSrhv7w.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="b66c" class="np la it od b gy oh oi l oj ok">WITH trips (trip_id, rider_id, driver_id, status, request_date)<br/>AS (VALUES<br/>(1, 1, 10, 'completed', CAST('2020-10-01' AS date)),<br/>(2, 2, 11, 'cancelled_by_driver', CAST('2020-10-01' AS date)),<br/>(3, 3, 12, 'completed', CAST('2020-10-01' AS date)),<br/>(4, 4, 10, 'cancelled_by_rider', CAST('2020-10-02' AS date)),<br/>(5, 1, 11, 'completed', CAST('2020-10-02' AS date)),<br/>(6, 2, 12, 'completed', CAST('2020-10-02' AS date)),<br/>(7, 3, 11, 'completed', CAST('2020-10-03' AS date))),</span><span id="24bc" class="np la it od b gy oy oi l oj ok">users (user_id, banned, type)<br/>AS (VALUES<br/>(1, 'no', 'rider'),<br/>(2, 'yes', 'rider'),<br/>(3, 'no', 'rider'),<br/>(4, 'no', 'rider'),<br/>(10, 'no', 'driver'),<br/>(11, 'no', 'driver'),<br/>(12, 'no', 'driver'))<br/></span><span id="2ee8" class="np la it od b gy oy oi l oj ok">-- filter trips table to exclude banned riders and drivers, then calculate cancellation rate as 1 - fraction of trips completed, filtering to first two days of the month<br/>SELECT <br/>   request_date, <br/>   1 - AVG(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) AS cancel_rate<br/>FROM trips<br/>WHERE rider_id NOT IN (SELECT user_id <br/>                       FROM users<br/>                       WHERE banned = 'yes' )<br/>AND driver_id NOT IN (SELECT user_id <br/>                      FROM users<br/>                      WHERE banned = 'yes' )<br/>GROUP BY 1<br/>HAVING EXTRACT(DAY FROM request_date) &lt;= 2</span></pre><h2 id="83ad" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">25.保留曲线(硬)</h2><p id="3acc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从下面的用户活动表中，编写一个查询来返回在加入后给定天数内保留(显示一些活动)的用户比例。按照惯例，用户在其加入日(第 0 天)被认为是活跃的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/17826fb45673a429ff8852a1e85462e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUYT90xXqbZVsuOluoB9Fg.png"/></div></div></figure><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="f522" class="np la it od b gy oh oi l oj ok">WITH users (user_id, action_date, action) <br/>AS (VALUES <br/>(1, CAST('01-01-20' AS date), 'Join'), <br/>(1, CAST('01-02-20' AS date), 'Access'), <br/>(2, CAST('01-02-20' AS date), 'Join'), <br/>(3, CAST('01-02-20' AS date), 'Join'), <br/>(1, CAST('01-03-20' AS date), 'Access'), <br/>(3, CAST('01-03-20' AS date), 'Access'),<br/>(1, CAST('01-04-20' AS date), 'Access')),<br/></span><span id="f1cd" class="np la it od b gy oy oi l oj ok"><em class="oz">-- get join dates for each user</em></span><span id="2aef" class="np la it od b gy oy oi l oj ok">join_dates AS (<br/>SELECT <br/>   user_id, <br/>   action_date AS join_date<br/>FROM users<br/>WHERE action = 'Join' ),</span><span id="516c" class="np la it od b gy oy oi l oj ok"><em class="oz">-- create vector containing all dates in date range</em></span><span id="d682" class="np la it od b gy oy oi l oj ok">date_vector AS (<br/>SELECT CAST(GENERATE_SERIES(MIN(action_date), MAX(action_date), <br/>            '1 day'::interval) AS date) AS dates<br/>FROM users ),</span><span id="df10" class="np la it od b gy oy oi l oj ok"><em class="oz">-- cross join to get all possible user-date combinations</em></span><span id="0f22" class="np la it od b gy oy oi l oj ok">all_users_dates AS (<br/>SELECT DISTINCT <br/>   user_id, <br/>   d.dates<br/>FROM users<br/>CROSS JOIN date_vector d ),</span><span id="7442" class="np la it od b gy oy oi l oj ok"><em class="oz">-- left join users table onto all user-date combinations on matching user ID and date (null on days where user didn't engage), join onto this each user's signup date, exclude user-date combinations falling before user signup</em></span><span id="224a" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT <br/>   a.dates - c.join_date AS day_no, <br/>   b.user_id<br/>FROM all_users_dates a<br/>LEFT JOIN users b<br/>ON a.user_id = b.user_id<br/>AND a.dates = b.action_date<br/>JOIN join_dates c<br/>ON a.user_id = c.user_id <br/>WHERE a.dates - c.join_date &gt;= 0 )</span><span id="12f6" class="np la it od b gy oy oi l oj ok"><em class="oz">-- grouping by days since signup, count (non-null) user IDs as active users, total users, and the quotient as retention rate</em></span><span id="f192" class="np la it od b gy oy oi l oj ok">SELECT <br/>   day_no, <br/>   COUNT(*) AS n_total, <br/>   COUNT(DISTINCT user_id) AS n_active, <br/>   ROUND(1.0*COUNT(DISTINCT user_id)/COUNT(*), 2) AS retention<br/>FROM t1<br/>GROUP BY 1</span></pre></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><h1 id="0f6e" class="kz la it bd lb lc os le lf lg ot li lj jz ou ka ll kc ov kd ln kf ow kg lp lq bi translated">附录</h1><p id="2765" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一个常见问题:如果您在使用 CTE 时看到语法错误，请检查 cte 之间是否有逗号，并且在最后一个 CTE 后面没有逗号。</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="2a1e" class="np la it od b gy oh oi l oj ok">WITH input_table (column_1, column_2) <br/>AS (VALUES <br/>(1, 'A'), (2, 'B')),     -- comma between CTEs</span><span id="2195" class="np la it od b gy oy oi l oj ok">t1 AS (<br/>SELECT *<br/>FROM input_table<br/>WHERE column_2 = 'A')    -- no comma after last CTE</span><span id="757e" class="np la it od b gy oy oi l oj ok">SELECT *<br/>FROM t1</span></pre></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="f446" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">感谢本·拉卡尔和叶敏婷。</p></div></div>    
</body>
</html>