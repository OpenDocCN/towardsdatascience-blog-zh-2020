<html>
<head>
<title>NumPy Crash Course — Zero to Hero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NumPy 速成班——从零到英雄</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/numpy-crash-course-zero-to-hero-c1788a8a48ac?source=collection_archive---------41-----------------------#2020-06-08">https://towardsdatascience.com/numpy-crash-course-zero-to-hero-c1788a8a48ac?source=collection_archive---------41-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="755d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对于那些有 Python 经验但想学习 NumPy 的人来说，这是你必须去的地方</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/850262146bf8e098e9c9fc3c30e96cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWvYScZmIplZkbTF9w_Y8Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尼克·希利尔在<a class="ae ky" href="https://unsplash.com/collections/10620294/medium-shortlist?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1cc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的目的是向任何具有 Python 知识的人提供一个关于 numPy 功能的快速速成课程，以及他们应该根据自己的用例详细阅读的内容。</p><h2 id="ff4f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">什么？怎么会？为什么？</h2><p id="28e7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我们开始探索 numPy 之前，让我们回答任何人都会想到的 3 个基本问题:</p><ul class=""><li id="8216" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">什么是 numPy？</li><li id="6b50" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">人们为什么使用 numPy？</li><li id="00b3" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">numPy 是怎么写的？</li></ul><h2 id="cf90" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">什么是 numPy？</h2><p id="2d7d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">numPy 或 numerical Python 是一个库，用于高级数学计算，同时保持高水平的性能。根据维基百科，“NumPy 是 Python 编程语言的库，增加了对大型多维数组和矩阵的支持，以及对这些数组进行操作的大量高级数学函数”</p><h2 id="e4b8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">人们为什么使用 numPy？</h2><p id="5f32" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">数字有很多不同的用途。让我们列出其中的一些:</p><ul class=""><li id="9204" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">与 Python 列表相比，它有一个高效的存储机制</li><li id="9a21" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">能够指定 numPy 数组的数据类型</li><li id="6a3d" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">更快的操作 numPy 数组上的操作比 Python 列表上的操作更快，主要是因为它的同质性</li><li id="0361" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">n 维数组的创建和操作——Python 列表在多维中是非常原始的，而 numPy 使这方面的工作变得非常容易</li><li id="552e" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">随机数据的创建——numPy 可以创建几乎符合所能想到的规范的随机数据，这在许多不同的情况下都非常有用</li></ul><h2 id="7b48" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">numPy 是怎么写的？</h2><ul class=""><li id="bd29" class="mt mu it lb b lc mo lf mp li nh lm ni lq nj lu my mz na nb bi translated">numPy 是用 C 编写的，是 SciPy 项目的一部分，但后来被分离出来，因为用户不希望仅仅为了 numPy 提供的数组操作而安装庞大的 SciPy 包</li></ul></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h2 id="2b26" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">设置 numPy</h2><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="d7df" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; import numpy as np</span></pre><p id="9eec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">numpy 作为<strong class="lb iu"> np </strong>进口的唯一原因是惯例。你可以自由地使用另一个别名，但不推荐使用，因为这是你在任何地方都能找到的别名，最好坚持使用标准</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="054d" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.__version__</span><span id="e678" class="lv lw it ns b gy oa nx l ny nz">'1.18.1'</span></pre><h2 id="c6f0" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">钕阵列</h2><p id="7429" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">numpy 速度快的主要原因是它使用 nd-array 类型来存储和操作数据</p><p id="4dd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ndarray 是同构数据的通用多维容器。它提供了矢量化的算术运算和复杂的广播功能。每个 ndarray 都有两个属性:shape 和 dtype。shape 是一个元组，提供数组的维度，dtype 提供数组的数据类型。</p><p id="0597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在定义数组时，也可以显式指定数组的 dtype，从而对数组进行微调控制。</p><p id="664d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一个数组创建一个 numpy 数组。这可以通过将数组作为输入传递给函数<em class="ob"> np.array </em>来实现</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="c1e9" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; nparray = np.array([1,2,3])</span><span id="d3c4" class="lv lw it ns b gy oa nx l ny nz">array([1, 2, 3])</span></pre><p id="5045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">numpy 数组有许多属性，这些属性提供了关于它们的更多信息。</p><p id="ec1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数组的数据类型</strong></p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="9c0c" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; nparray.dtype</span><span id="6d44" class="lv lw it ns b gy oa nx l ny nz">dtype('int32')</span></pre><p id="5eb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数组的大小</strong></p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="9679" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; nparray.size</span><span id="1203" class="lv lw it ns b gy oa nx l ny nz">3</span></pre><p id="24b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">阵列的形状</strong></p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="b3e3" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; nparray.shape</span><span id="65bf" class="lv lw it ns b gy oa nx l ny nz">(3,)</span></pre><p id="d60b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面两个单元的代码保证了详细的解释。<em class="ob"> itemsize </em>参数返回数组中单个项目的大小。在这种情况下，我们有一个整数数组，它为单个项目占用 32 位空间，这相当于 4 个字节(1 字节= 8 位)。下面的单元格展示了<em class="ob"> nbytes </em>参数，该参数返回整个数组的字节大小，从而提供了一个 12 字节的值(4 字节* 3 项)。</p><p id="0a3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之:<em class="ob"> itemsize </em>提供数组中单个项目的大小，而<em class="ob"> nbytes </em>返回整个数组的大小。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="ee7c" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; nparray.itemsize</span><span id="3b0f" class="lv lw it ns b gy oa nx l ny nz">4</span><span id="2fd6" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; nparray.nbytes</span><span id="9725" class="lv lw it ns b gy oa nx l ny nz">12</span></pre><p id="4935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">numpy 的 nd-array 比 Python 的原生 list 快是有原因的。让我们在下面的单元格中深入了解这一点</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="df3b" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; %timeit pythonList = [i for i in range(10000)]</span><span id="4437" class="lv lw it ns b gy oa nx l ny nz">545 µs ± 24 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span><span id="f6e7" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; %timeit npList = np.arange(10000)</span><span id="ffdc" class="lv lw it ns b gy oa nx l ny nz">7.82 µs ± 256 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</span></pre><p id="0655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">numpy 数组是同构的，在内存中处理速度更快。现在将它与 Python 列表进行比较，在 Python 列表中可以放入任何东西；Python 列表中的每个条目都是一个 Python 对象，这导致了计算开销。这是 numpy 数组比传统 Python 列表快得多的主要原因</p><p id="fdc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看使 numpy 成为一个灵活方便的库的一些函数。</p><h2 id="c4ba" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用 numpy 生成数据</h2><p id="8462" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><em class="ob"> arange </em>生成所传递数字范围内的数字列表</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="e76d" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.arange(10)</span><span id="996c" class="lv lw it ns b gy oa nx l ny nz">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></pre><p id="16eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ob"> linspace </em>返回作为输入传递的范围内的一组线性间隔的项目。在 linspace 中，起始位、结束位以及作为输入传递的所需位数。基本上，它返回一个数组，该数组具有指定间隔内所需的位数</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="c055" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.linspace(0, 10, 5)</span><span id="738c" class="lv lw it ns b gy oa nx l ny nz">array([ 0. ,  2.5,  5. ,  7.5, 10. ])</span></pre><p id="4b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">T21 创建了一个充满 1 的数组。作为输入传递的参数是所需数组的大小</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="c237" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.ones(5)</span><span id="2a83" class="lv lw it ns b gy oa nx l ny nz">array([1., 1., 1., 1., 1.])</span></pre><p id="b90d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ob">零</em>创建一个用零填充的数组。作为输入传递的参数是所需数组的大小</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="abea" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.zeros(5)</span><span id="d61c" class="lv lw it ns b gy oa nx l ny nz">array([0., 0., 0., 0., 0.])</span></pre><p id="b66d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ob"> zeros_like </em>创建一个与作为输入传递的数组大小相同的数组。生成的数组将以零作为元素</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="fbf2" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.zeros_like(np.arange(5))</span><span id="2358" class="lv lw it ns b gy oa nx l ny nz">array([0, 0, 0, 0, 0])</span></pre><p id="ae9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ob">眼</em>创建一个单位矩阵。生成的矩阵将是作为输入传递的整数的维数</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="8679" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.eye(5)</span><span id="46c6" class="lv lw it ns b gy oa nx l ny nz">array([[1., 0., 0., 0., 0.],<br/>       [0., 1., 0., 0., 0.],<br/>       [0., 0., 1., 0., 0.],<br/>       [0., 0., 0., 1., 0.],<br/>       [0., 0., 0., 0., 1.]])</span></pre><p id="a96c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个用垃圾值填充的数组，通常是零。作为输入传递的参数是所需数组的大小</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="a8b2" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.empty(5) </span><span id="5ad9" class="lv lw it ns b gy oa nx l ny nz">array([1., 1., 1., 1., 1.])</span></pre><h2 id="8632" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">索引</h2><p id="3a05" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在索引和切片方面，numpy 遵循 Python 的常规规则。我在下面列出了几个例子，你可以尝试一下:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="2fa2" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; nparray[1]</span><span id="16d1" class="lv lw it ns b gy oa nx l ny nz">2</span><span id="d62f" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; nparray[-1]</span><span id="99c3" class="lv lw it ns b gy oa nx l ny nz">3</span></pre><h2 id="c55c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">限幅</h2><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="d1d9" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; nparray[1:2]</span><span id="2f33" class="lv lw it ns b gy oa nx l ny nz">array([2])</span><span id="0342" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; nparray[:2]</span><span id="c6f2" class="lv lw it ns b gy oa nx l ny nz">array([1, 2])</span><span id="78e3" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; nparray[:]</span><span id="d2f0" class="lv lw it ns b gy oa nx l ny nz">array([1, 2, 3])</span><span id="4ee0" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; nparray[1:]</span><span id="462b" class="lv lw it ns b gy oa nx l ny nz">array([2, 3])</span><span id="a2aa" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; largeArray = np.arange(100)</span><span id="1150" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; largeArray[::20]</span><span id="0aeb" class="lv lw it ns b gy oa nx l ny nz">array([ 0, 20, 40, 60, 80])</span><span id="9e61" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; largeArray[1:10:2]</span><span id="1d81" class="lv lw it ns b gy oa nx l ny nz">array([1, 3, 5, 7, 9])</span><span id="44fb" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; largeArray[::-20]</span><span id="c9a8" class="lv lw it ns b gy oa nx l ny nz">array([99, 79, 59, 39, 19])</span><span id="3047" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; largeArray[10:1:-2]</span><span id="97dd" class="lv lw it ns b gy oa nx l ny nz">array([10,  8,  6,  4,  2])</span></pre><p id="d42b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 numpy 中使用切片时要记住的一件重要事情是，切片本质上是引用(视图),因此，您对切片数据所做的任何更改都会反映在父数据中。让我们看一个例子</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="9b9a" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; smallArray = largeArray[:10]</span><span id="1915" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; smallArray</span><span id="cc5b" class="lv lw it ns b gy oa nx l ny nz">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span><span id="3bf0" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; largeArray[:10]</span><span id="8560" class="lv lw it ns b gy oa nx l ny nz">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span><span id="fdfa" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; smallArray[0] = 666</span><span id="b862" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; smallArray</span><span id="4f2d" class="lv lw it ns b gy oa nx l ny nz">array([666,   1,   2,   3,   4,   5,   6,   7,   8,   9])</span><span id="2fd3" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; largeArray[:10]</span><span id="e759" class="lv lw it ns b gy oa nx l ny nz">array([666,   1,   2,   3,   4,   5,   6,   7,   8,   9])</span></pre><p id="4b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">copy()方法可以用来创建副本，而不是这样的视图</p><h2 id="ec60" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">轴线</h2><p id="4c1d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">numpy 数组可以是多维的。它还使您能够将现有数组更改为您喜欢的形状，前提是它满足多个约束</p><p id="c7f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ob">重塑</em>让你完全按照名字说的去做。它允许您将数组调整为作为输入传递的维度。如果您没有传递一个可以对数组进行整形的维度，那么该函数将返回一个错误。比方说，该数组有 10 个元素，您试图将其整形为形状为 3x5 的数组，那么整形将返回一个错误</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="e357" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.arange(1, 7).reshape((2, 3))</span><span id="9b1a" class="lv lw it ns b gy oa nx l ny nz">array([[1, 2, 3],<br/>       [4, 5, 6]])</span><span id="4190" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; np.arange(1, 4)</span><span id="67ca" class="lv lw it ns b gy oa nx l ny nz">array([1, 2, 3])</span><span id="c02b" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; np.arange(1, 4).reshape(1,3)</span><span id="b828" class="lv lw it ns b gy oa nx l ny nz">array([[1, 2, 3]])</span></pre><p id="201c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ob"> newaxis </em>用于在数据中创建新轴。它通常在研究建模技术时使用，因为模型要求数据以某种方式成形。如下图所示，如果<em class="ob"> newaxis </em>参数位于第一个位置，那么将会生成一个新的行向量。如果在第二个位置，那么将创建一个列，每个元素是一个单独的向量。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="d6a4" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.arange(1, 4)[np.newaxis, :]</span><span id="d3b5" class="lv lw it ns b gy oa nx l ny nz">array([[1, 2, 3]])</span><span id="e798" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; np.arange(1, 4)[:, np.newaxis]</span><span id="a8de" class="lv lw it ns b gy oa nx l ny nz">array([[1],<br/>       [2],<br/>       [3]])</span></pre><h2 id="2ed6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">数组串联</h2><p id="31ed" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">可以使用<em class="ob"> concatenate </em>方法在 numpy 中连接数组。要连接的数组列表将作为输入传递给 concatenate 函数。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="79d2" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.concatenate([smallArray, largeArray])</span><span id="9395" class="lv lw it ns b gy oa nx l ny nz">array([666,   1,   2,   3,   4,   5,   6,   7,   8,   9, 666,   1,   2,<br/>         3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,<br/>        16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,<br/>        29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,<br/>        42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,<br/>        55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,<br/>        68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,<br/>        81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,<br/>        94,  95,  96,  97,  98,  99])</span><span id="f060" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; np.concatenate([smallArray, largeArray, [888, 999]])</span><span id="f26b" class="lv lw it ns b gy oa nx l ny nz">array([666,   1,   2,   3,   4,   5,   6,   7,   8,   9, 666,   1,   2,<br/>         3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,<br/>        16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,<br/>        29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,<br/>        42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,<br/>        55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,<br/>        68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,<br/>        81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,<br/>        94,  95,  96,  97,  98,  99, 888, 999])</span></pre><h2 id="99cd" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">数字函数</h2><p id="d715" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Ufunc 的主要目的是能够加速对 numpy 数组中的值的重复操作。它既可以在一个标量值和一个数组之间工作，也可以在两个数组之间工作</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="fcf2" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; 3 * np.arange(0, 10)</span><span id="daf7" class="lv lw it ns b gy oa nx l ny nz">array([ 0,  3,  6,  9, 12, 15, 18, 21, 24, 27])</span><span id="d1b5" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; np.arange(0, 10) + np.arange(20, 30)</span><span id="0d5f" class="lv lw it ns b gy oa nx l ny nz">array([20, 22, 24, 26, 28, 30, 32, 34, 36, 38])</span></pre><p id="ade9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不仅在语法上更好更直观，而且速度更快。让我们在下面尝试一下</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="44ae" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; %timeit 3 * smallArray</span><span id="4969" class="lv lw it ns b gy oa nx l ny nz">1.22 µs ± 61.4 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)</span><span id="ae83" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; %%timeit<br/><br/>&gt;&gt; for i in range(len(smallArray)):<br/>       3 * smallArray[i]</span><span id="bcef" class="lv lw it ns b gy oa nx l ny nz">7.15 µs ± 182 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</span></pre><p id="29d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面可以看出，ufunc 比循环版本的代码快很多倍。随着所涉及的计算逻辑变得越来越复杂，这种差异变得越来越明显</p><h2 id="a6d0" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">聚合</h2><p id="336b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在这一节中，我们将探索 numpy 提供的各种聚合函数。numpy 附带了一个标准的<em class="ob"> sum() </em>函数，该函数返回数组中所有元素的总和。你可能会问，原生 Python 函数和 numpy 函数有什么区别！毕竟他们做的是同样的功能；提供元素的总和。下面就来看看吧</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="4dc1" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.sum(smallArray)</span><span id="1085" class="lv lw it ns b gy oa nx l ny nz">711</span><span id="b6dc" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; sum(smallArray)</span><span id="9f85" class="lv lw it ns b gy oa nx l ny nz">711</span><span id="6d6c" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; hugeArray = np.random.randint(100000, size=1000000)<br/>&gt;&gt; %timeit np.sum(hugeArray)<br/>&gt;&gt; %timeit sum(hugeArray)</span><span id="843a" class="lv lw it ns b gy oa nx l ny nz">526 µs ± 9.48 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)<br/>271 ms ± 11 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="2c6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的代码块可以明显看出，与原生函数相比，numpy 的速度有多快。这适用于 numpy 中可用的大多数(如果不是全部)聚合函数</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="4e8f" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.min(smallArray)</span><span id="2c13" class="lv lw it ns b gy oa nx l ny nz">1</span><span id="e300" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; np.max(smallArray)</span><span id="e62a" class="lv lw it ns b gy oa nx l ny nz">666</span><span id="a349" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; np.std(smallArray)</span><span id="2c25" class="lv lw it ns b gy oa nx l ny nz">198.31512801599376</span><span id="ac5d" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; np.mean(smallArray)</span><span id="e0a5" class="lv lw it ns b gy oa nx l ny nz">71.1</span><span id="8354" class="lv lw it ns b gy oa nx l ny nz">np.median(smallArray)</span><span id="b4b4" class="lv lw it ns b gy oa nx l ny nz">5.5</span></pre><p id="0ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用聚合函数时需要注意的一点是，在您使用它们时，这些函数容易出现 NaN 值，也就是说，如果您的数组中有 NaN 值，这些聚合函数将会失败。在这种情况下，您可以使用它们的 NaN 安全替代方案。给你一个例子:nansum()是 sum 函数的 NaN-safe 替代</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="ef5c" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.nanmean(np.array([1, 2, np.nan]))</span><span id="4d12" class="lv lw it ns b gy oa nx l ny nz">1.5</span><span id="f452" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; np.mean(np.array([1, 2, np.nan]))</span><span id="5590" class="lv lw it ns b gy oa nx l ny nz">nan</span></pre><h2 id="4111" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">广播</h2><p id="7305" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们现在要看一个你可能经常使用但没有概念上的理解的操作。在广播中，对具有不同形状/尺寸的实体执行操作。</p><p id="c4cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的例子是向 numpy 数组添加一个标量。基本上，您可以认为复制的值是为了匹配数组的维数，然后是要执行的操作。</p><p id="eee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">广播是一个可以详细阐述的操作，但这不是我这篇文章的目标</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="73ca" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; a = np.arange(1, 7)<br/>&gt;&gt; a</span><span id="b3b3" class="lv lw it ns b gy oa nx l ny nz">array([1, 2, 3, 4, 5, 6])</span><span id="d26d" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; a + 1</span><span id="44e1" class="lv lw it ns b gy oa nx l ny nz">array([2, 3, 4, 5, 6, 7])</span></pre><h2 id="8cbc" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">逻辑运算</h2><p id="4187" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">有时候，您会希望对一段数据执行逻辑检查。numpy 提供了您所期望的所有常规逻辑操作:大于、小于和等于检查。逻辑函数返回一组布尔值结果，表明它们是否满足条件</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="53b0" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; x = np.array([1, 2, 3, 4])</span><span id="e63f" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; x &gt; 2</span><span id="ad3d" class="lv lw it ns b gy oa nx l ny nz">array([False, False,  True,  True])</span><span id="0fa1" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; x == 2</span><span id="0e44" class="lv lw it ns b gy oa nx l ny nz">array([False,  True, False, False])</span></pre><p id="9cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">numpy 还提供了一些有用的函数，比如 any()和 all()，用于执行以下检查:是否有任何元素满足条件，或者是否所有元素都满足条件。它们提供一个布尔值作为输出来指示结果</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="052f" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.any(x == 2)</span><span id="66c2" class="lv lw it ns b gy oa nx l ny nz">True</span><span id="8e43" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; np.all(x == 2)</span><span id="7773" class="lv lw it ns b gy oa nx l ny nz">False</span></pre><p id="2d0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从以上两个代码块中；可以理解以下内容:</p><ul class=""><li id="d9df" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">any(x == 2):检查数组中的元素是否满足传递的条件</li><li id="c7c1" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">all(x == 2):它检查数组中的所有元素是否满足传递的条件</li></ul><p id="08d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们需要满足这个特定条件的值的计数，您可以使用 sum()方法，如下所示。它计算数组中真值的数量</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="eeed" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.sum(x == 2)</span><span id="41fd" class="lv lw it ns b gy oa nx l ny nz">1</span></pre><p id="a5a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也可以组合起来检查多种情况。对于<em class="ob">的任何</em>和<em class="ob">的所有</em>功能，也可以进行同样的操作</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="beba" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.sum((x == 2) | (x == 3))</span><span id="5473" class="lv lw it ns b gy oa nx l ny nz">2</span><span id="c9a1" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; np.any((x == 2) | (x == 3))</span><span id="5b7e" class="lv lw it ns b gy oa nx l ny nz">True</span></pre><h2 id="b336" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">掩饰</h2><p id="febd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您可能已经看到了上面的以布尔数组形式提供值的数组，并且想知道这有什么帮助，因为您仍然需要提供进一步的操作来理解输出。这就是掩蔽的用武之地；真/假数组可以通过<em class="ob">传入</em>数组，只提供那些满足条件的值</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="e1cc" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; x[x == 2]</span><span id="993c" class="lv lw it ns b gy oa nx l ny nz">array([2])</span><span id="0a32" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; x[x &gt; 2]</span><span id="6139" class="lv lw it ns b gy oa nx l ny nz">array([3, 4])</span></pre><h2 id="ce65" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">花式索引</h2><p id="244f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">花哨的索引不过是一次访问数组中多个元素的能力</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="48d4" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; x</span><span id="5891" class="lv lw it ns b gy oa nx l ny nz">array([1, 2, 3, 4])</span><span id="8888" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; x[[0, 2, 3]]</span><span id="15cd" class="lv lw it ns b gy oa nx l ny nz">array([1, 3, 4])</span></pre><p id="c5c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经猜到了，我们也可以将一个数组作为索引列表传入</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="5f59" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; indexList = [0, 2, 3]<br/>&gt;&gt; x[indexList]</span><span id="3ca8" class="lv lw it ns b gy oa nx l ny nz">array([1, 3, 4])</span></pre><p id="6834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当它与切片、索引和广播等技术相结合时，花式索引的真正威力就显现出来了</p><h2 id="44d4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">整理</h2><p id="1922" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">numpy 提供的排序算法非常高效。有两种方法可以对 numpy 数组进行排序；并通过调用返回排序数组的 numpy 排序函数</p><p id="116d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先打乱我们的数组，以便我们可以对它进行排序和处理</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="712e" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.random.shuffle(x)<br/>&gt;&gt; x</span><span id="0e4e" class="lv lw it ns b gy oa nx l ny nz">array([1, 3, 4, 2])</span></pre><p id="e735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数组上调用<em class="ob"> np.sort </em>将返回一个已排序的数组副本，但不会对数组进行排序，如下所示</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="2cd2" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; np.sort(x)</span><span id="be0c" class="lv lw it ns b gy oa nx l ny nz">array([1, 2, 3, 4])</span><span id="8f91" class="lv lw it ns b gy oa nx l ny nz">&gt;&gt; x</span><span id="a5c9" class="lv lw it ns b gy oa nx l ny nz">array([1, 3, 4, 2])</span></pre><p id="b554" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在数组上调用<em class="ob"> sort </em>，那么数组将被就地排序，没有必要保存到另一个数组。这两种方法执行相同的功能，并且根据所需的用例来使用</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="efa0" class="lv lw it ns b gy nw nx l ny nz">&gt;&gt; x.sort()<br/>&gt;&gt; x</span><span id="2d91" class="lv lw it ns b gy oa nx l ny nz">array([1, 2, 3, 4])</span></pre><h2 id="48d6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结束语</h2><p id="033a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">numPy 有更多的功能，尤其是在高维数据方面。numPy 可以轻松地处理和操作更高维度的数据。我还没有决定进入这样的细节，因为这将挫败这个职位的目的。</p><p id="fffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经用这个博客的全部内容编辑了一个笔记本。</p><p id="7edd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多事情我没有涉及，因为它超出了本博客的范围，但是，如果你有兴趣阅读更多关于 numpy 的内容，我强烈推荐以下资源:</p><ul class=""><li id="0e91" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><a class="ae ky" href="https://jakevdp.github.io/PythonDataScienceHandbook/" rel="noopener ugc nofollow" target="_blank"> Python 数据科学手册</a>——《数据科学手册》是 Dat 科学领域非常受欢迎的书籍，其电子书版本免费提供。它会让你更详细地了解 numpy，如果你感兴趣，还有 pandas，matplotlib &amp; scikit-learn</li><li id="c033" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="http://shop.oreilly.com/product/0636920023784.do" rel="noopener ugc nofollow" target="_blank">用于数据分析的 Python</a>——由熊猫的创造者撰写，你可以通过这本书深入了解 numpy 的用法示例</li><li id="6dab" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">当然，<a class="ae ky" href="https://numpy.org/doc/" rel="noopener ugc nofollow" target="_blank"> numpy 文档</a> —如果你是一个经验丰富的开发人员，并且确切地知道你在寻找什么，你可以直接去 numpy 文档，因为它有许多用户指南和教程，而不仅仅是一个托管参考文档的网站</li></ul></div></div>    
</body>
</html>