<html>
<head>
<title>Time Series analysis on multivariate data in Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tensorflow中多元数据的时间序列分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-analysis-on-multivariate-data-in-tensorflow-2f0591088502?source=collection_archive---------19-----------------------#2020-05-26">https://towardsdatascience.com/time-series-analysis-on-multivariate-data-in-tensorflow-2f0591088502?source=collection_archive---------19-----------------------#2020-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7a7b987b7c2b3792af34bc4943fa2336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*opqtvAndW8B2Klp_"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">杰森·布里斯科在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="7415" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是时间序列分析</h1><p id="7936" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">通俗地说，时间序列分析处理的是主要用于从过去的值预测未来值的时间序列数据。应用范围可以从预测股票、原油等商品的价格、汽车等产品的销售、洗发水等快速消费品的销售，到预测特定地区的空气质量指数。时间序列可以分为单变量和多变量时间序列。单变量时间序列数据仅由随时间记录的单个观察值组成，而多变量时间序列由与我们感兴趣的主题相关的多个观察值组成。本文的重点将放在多元数据上。</p><h1 id="bbeb" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">从Kaggle获取数据:</h1><p id="2cc3" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了执行时间序列分析，我们需要数据来构建我们的模型；为此我们将参考来自<a class="ae kc" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> kaggle </a>的公开可用数据集。对于本文，我们将使用<strong class="ld ir">印度主要城市过去五年的空气质量指数</strong>数据，在<a class="ae kc" href="https://www.kaggle.com/rohanrao/air-quality-data-in-india" rel="noopener ugc nofollow" target="_blank">链接</a>中提供。要将数据直接下载到Google Colab，您可以参考以下链接:</p><div class="lz ma gp gr mb mc"><a href="https://www.kaggle.com/general/74235" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">在Google Colab |数据科学和机器学习中下载kaggle数据的最简单方法</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">针对我们社区的活动和主题| Kaggle论坛</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">www.kaggle.com</p></div></div></div></a></div><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/setting-up-kaggle-in-google-colab-ebb281b61463"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">在Google Colab中设置Kaggle</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">一个简单的新手教程</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq jw mc"/></div></div></a></div><p id="00ea" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">如果您遵循了必要的步骤，您应该在下载的数据中看到以下文件。我们对city_day.csv文件感兴趣。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/43d071cb7686f6d04940ab959ac5e776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgQZpyLW5u50B71xlY8PhQ.png"/></div></div></figure><p id="df88" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">让我们选择分析所需的数据。我们将选择与德里市相对应的最近两年的数据。该数据有1948行和15列，包括我们想要为其建立模型的AQI。</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2e9c" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">通过检查数据，我们发现我们的数据包含缺失值。因此，在开始分析之前，我们用每一列的平均值填充缺失值，去掉不必要的列。</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="887c" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">现在我们已经有了数据，让我们进入下一部分。</p><h1 id="5e51" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">时间序列的组成部分</h1><p id="8a4f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">顾名思义，时间序列数据由单个或多个观测值/变量组成，这些观测值/变量是在一个确定的时间间隔内顺序记录的。时间序列数据有多个方面，我们将通过执行一些探索性数据分析来了解这些方面:</p><h2 id="0578" class="nd ke iq bd kf ne nf dn kj ng nh dp kn lm ni nj kr lq nk nl kv lu nm nn kz no bi translated">季节性</h2><p id="0d18" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在时间序列数据中，季节性是指数据中以固定间隔(通常少于一年)出现的周期性变化。一些例子是，圣诞节期间零售/电子商务销售的高峰，冬天期间保暖衣服销售的增加，等等。季节性可以通过查看图表本身来发现。下面的代码呈现了一个图表，看着它，我们可以说，尽管有几个波峰和波谷，但它们并不是以固定的间隔出现的，因此数据不是季节性的。</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/777019c3c2161a90305b4be79cdf32d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ntOhOZboZI9cGfqWqNUaQ.png"/></div></div></figure><h2 id="d0a4" class="nd ke iq bd kf ne nf dn kj ng nh dp kn lm ni nj kr lq nk nl kv lu nm nn kz no bi translated">趋势</h2><p id="b531" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在时间序列数据中，趋势是指数据的总体趋势，无论是随着时间的推移而增加还是减少(长期方向)。看上面的图表，我们可以说数据的总趋势是既不增加也不减少，而是一个恒定的趋势。</p><h2 id="e243" class="nd ke iq bd kf ne nf dn kj ng nh dp kn lm ni nj kr lq nk nl kv lu nm nn kz no bi translated">不规则</h2><p id="d132" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">不规则或随机成分是无法预测的。大多数情况下，它们持续时间短，不重复，并且由于不可预见的事件而发生。</p><h2 id="922f" class="nd ke iq bd kf ne nf dn kj ng nh dp kn lm ni nj kr lq nk nl kv lu nm nn kz no bi translated">周期性</h2><p id="af16" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当上升和下降模式存在，但不是在一个固定的时间间隔，然后它被称为周期性。一个例子可以是考虑一个国家的GDP数字，当绘制在一个相对于时间的图表上时，它会在衰退期间看到巨大的下降，如1929年、2000年和2008年，但这些间隔不是固定的。因此，从上图中，我们可以说我们的数据是周期性的。</p><h2 id="d8a7" class="nd ke iq bd kf ne nf dn kj ng nh dp kn lm ni nj kr lq nk nl kv lu nm nn kz no bi translated">自相关</h2><p id="9a6d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">它意味着当前值与其过去值的相关性。自相关函数衡量当前序列与其滞后序列(过去值)的相似程度。AQI指数的ACF图在蓝色区域上方显示尖峰，这表明该序列是自相关的。同样，您也可以检查数据集的其他系列的自相关。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/fdb12461091c7f1040c0b1398dc2b925.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*FeL_VxFWGE9V11HNjDC9ag.png"/></div></figure><h2 id="90d6" class="nd ke iq bd kf ne nf dn kj ng nh dp kn lm ni nj kr lq nk nl kv lu nm nn kz no bi translated">平稳性:</h2><p id="296f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果一个时间序列的相应统计特性(如均值、标准差和自相关)在整个时间内保持不变，则称该时间序列是平稳的。为了检验多元时间序列的平稳性，我们对以数组形式返回特征值的时间序列进行Johansen协整检验。如果特征值小于1，则称该级数是平稳的。</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/7496f624ae2ec67fcdf541bf85751673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6i_fREcN_S-8TVuCK4b1Cg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">johansen协整检验的特征值</p></figure><p id="e664" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">因为我们得到的值小于1，所以这个数列是平稳的。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="2548" class="kd ke iq bd kf kg nz ki kj kk oa km kn ko ob kq kr ks oc ku kv kw od ky kz la bi translated">LSTMs在时间序列数据建模中的应用</h1><p id="466c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">递归神经网络(RNNs)是一种用于建模时间序列和自然语言等数据序列的神经网络。常规神经网络将一些信息x作为输入，并输出一个值y。一层的输出不会馈入另一层。</p><p id="b68e" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">RNNs通过将一层的输出环回至另一层来克服这一缺点。</p><p id="bdaa" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">这意味着RNNs应该能够基于先前数据的上下文来预测接下来会发生什么，但是在实践中，RNNs仅在该上下文和预测之间的差距很小时才解决该问题，并且如果该差距变得很大，则表现很差。幸运的是，长短期记忆解决了这个问题，它是一种特殊类型的RNNs。</p><p id="f581" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">如上所述，RNNs记住了序列中的每个信息，这导致了消失梯度的问题。在反向传播期间，梯度变得如此之小，以至于隐藏层在更新时学习得非常少。LSTMs解决了这个问题，同时只记住相关信息并丢弃其他信息。rnn只有一个激活功能，而LSTMs有一系列激活功能和门，通过它们来执行这个任务。</p><p id="76cf" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">现在我们对LSTMs和它们的用途有了一些了解，让我们继续构建我们的模型。</p><h2 id="bfb5" class="nd ke iq bd kf ne nf dn kj ng nh dp kn lm ni nj kr lq nk nl kv lu nm nn kz no bi translated">数据准备</h2><p id="b9ba" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">到目前为止，我们已经将超过100个数据加载到我们的机器中进行建模.经过一些检查，我们发现我们的数据不包含任何NULL或NaN值。当我们通过机器学习建模执行时间序列分析时，我们需要将数据转换为因变量(y)和自变量(X)的形式。这里我们的因变量是空气质量指数和其他变量，如PM2.5、PM10、NO、NO2…..等等都是自变量。</p><p id="379c" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">我们将缩放数据以更快地处理它，并消除由于数据范围造成的偏差。现在我们需要按照80:20的比例将数据分为训练数据和测试数据。请注意，由于我们正在执行时间序列分析，我们不能将数据随机分为训练和测试，正如我们在建立其他机器学习模型时所做的那样，否则，该模型将找到最重要的本质，即时间。</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="e0f9" class="nd ke iq bd kf ne nf dn kj ng nh dp kn lm ni nj kr lq nk nl kv lu nm nn kz no bi translated">创建和拟合模型</h2><p id="87e9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们将使用Tensorflow库顶部的Keras API来构建我们的模型。下面是我们模型架构的蓝图。</p><pre class="mx my mz na gt oe of og oh aw oi bi"><span id="e367" class="nd ke iq of b gy oj ok l ol om">model.add(LSTM(hidden_nodes, input_shape=(timesteps, input_dim)))<br/>model.add(Dropout(dropout_value))<br/>model.compile(loss, optimizer)</span></pre><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/89cc32f29aeba36ee03533bbbf1a1868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*67pnczEj9yyYWQRveqwGSA.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">LSTM网络的输入形状</p></figure><p id="d0d0" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated"><strong class="ld ir"> hidden_nodes: </strong>隐藏层的神经元个数。我们将取出250个神经元</p><p id="22cc" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated"><strong class="ld ir">剔除:</strong>用于减少模型的过拟合。根据经验，它被设置为20%。</p><p id="d945" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated"><strong class="ld ir">编译:</strong>编译函数将接受损失和优化器等参数。这里我们将把<strong class="ld ir">平均绝对误差</strong>作为误差度量，把<strong class="ld ir"> Adam </strong>作为优化算法。</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/df41e3c735341a179dc520afca12afe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*n2cHDJWXF62VFwvr7t2U2w.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">历元期间的训练和测试损失</p></figure><h2 id="2326" class="nd ke iq bd kf ne nf dn kj ng nh dp kn lm ni nj kr lq nk nl kv lu nm nn kz no bi translated">预测并比较这些值:</h2><p id="2c67" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在拟合模型之后，我们将在测试数据上检查我们的模型的性能。由于我们在拟合模型之前先对数据进行了归一化处理，因此我们必须对其进行反向缩放，以恢复原始比例的值。</p><p id="e042" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">现在我们已经有了测试数据集和原始测试数据的预测值，让我们通过计算RMSE并将它们绘制在一起来比较两者。</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e32e" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">火车RMSE: 41.096</p><p id="6af9" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">测试RMSE: 30.493</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/b9911e2663a3940dcb3e3f1184eb647a.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*4-tX-LTcHhH4soa0RU39Hw.png"/></div></figure><p id="7148" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">对于我们的模型来说，训练和测试数据上的RMSE没有太大差异，这是一个很好的指标。请注意，每次构建和运行模型时，您可能会获得不同的RMSE值。</p><p id="0294" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">时间序列预测可以说是单步或多步预测，这取决于它能够预测未来的时间步数。基于从我们的训练数据训练的模型，我们预测对应于测试数据的时间框架的未来值，因此它是多步预测。还记得我们在文章开头看到的AQI的图表吗，根据模型的预测，图表看起来是这样的:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/8051b4dcc63a3bb124721cce0cf58a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kn5jxBN9yhGysxolYbj2cA.png"/></div></div></figure></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="3d62" class="kd ke iq bd kf kg nz ki kj kk oa km kn ko ob kq kr ks oc ku kv kw od ky kz la bi translated">结论:</h1><ol class=""><li id="2578" class="or os iq ld b le lf li lj lm ot lq ou lu ov ly ow ox oy oz bi translated">在本文中，我们看到了如何使用RNN-LSTM建立一个多元时间序列模型，因为他们擅长从序列数据中提取模式。</li></ol><p id="fc0f" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">2.时间序列数据不应该被随意划分为训练集和测试集，因为这样会失去其最重要的本质，即时间。</p><p id="5ad6" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">3.传统的时间序列预测方法如ARIMA方法有其局限性，因为它只能用于单变量数据和一步预测。</p><p id="c5be" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">4.在各种研究中观察到，深度学习模型在多元时间序列数据上优于传统的预测方法。</p><p id="ea26" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">5.由于提供的数据包含季节性，我们可以进一步降低数据的季节性，以便我们的模型可以专注于潜在的信号。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="2a50" class="pw-post-body-paragraph lb lc iq ld b le mr lg lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly ij bi translated">您可以在这里找到本文的完整代码</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div></div>    
</body>
</html>