<html>
<head>
<title>Serverless: Tweaking the Lambdas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器:调整 Lambdas</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/serverless-tweaking-the-lambdas-de13507793e4?source=collection_archive---------34-----------------------#2020-03-29">https://towardsdatascience.com/serverless-tweaking-the-lambdas-de13507793e4?source=collection_archive---------34-----------------------#2020-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="44c4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">调整 lambdas 以确保不可伸缩资源的高可伸缩性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2fe3a0a9607e01dbf1a6c672f65963be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W-T-yPS3mDFDj6hT1dOXzw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由来自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=362150" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kv" href="https://pixabay.com/users/RyanMcGuire-123690/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=362150" rel="noopener ugc nofollow" target="_blank"> Ryan McGuire </a>拍摄</p></figure><p id="b9da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无服务器编程很容易部署。无服务器的可伸缩性只受您指定的上限的限制(至少文档是这么说的)。然而，除非你做了正确的设计，否则整个系统可能会立刻失效。这是因为我们插入到<strong class="ky ir"> AWS </strong>部署中的大部分外部资源不像 lambda 函数那样可伸缩。此外，您的设计应该基于您正在为无服务器环境编写程序的想法。</p><p id="78f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将分享我在一个具有大并发性的大中型项目中工作时所面临的困难。我将使用<strong class="ky ir">节点。JS </strong>作为编程环境。</p><h1 id="3a3c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基础知识</h1><p id="0d38" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有几个事实你应该记住。</p><ul class=""><li id="2a44" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">您永远不应该假设同一个实例将用于处理请求，尽管我们可能会利用这种可能性来提高性能。</li><li id="fa88" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">没有用于数据序列化的永久存储。然而，您可以访问一个小的<strong class="ky ir"> <em class="nd"> /tmp </em> </strong>路径来在单个调用中进行序列化。因此，确保使用唯一的文件名以避免冲突，并在同一次调用中完成。</li><li id="22ec" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">不应对服务请求的顺序做出任何假设。</li><li id="e9ad" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">根据 CPU 小时数(和 RAM)收取使用费。所以要确保你的代码运行得很快，没有太多的颠簸。</li></ul><h1 id="7b80" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">处理瓶颈资源</h1><p id="fbb2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">几乎在所有场景中，web 应用程序都希望连接到数据库并读取/写入数据。然而，数据库的并发连接数是有限的，可以通过 lambda 函数的并发级别轻松通过。此外，您可以拥有多个独立的函数，这些函数都有数据库连接。例如，如果几乎同时调用 10 个函数，那么最少需要 10 个连接。然而，在高峰场景中，这很容易被乘以一个大到足以使数据库达到极限的因子。</p><h2 id="141a" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">降低可扩展性</h2><p id="6d85" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">大多数情况下，您不会达到希望有 1000 个并发调用的程度。您可以从<strong class="ky ir"> AWS 控制台<em class="nd"> </em> </strong>或在<strong class="ky ir"> <em class="nd"> serverless.yml </em> </strong>中更改此设置。(<a class="ae kv" rel="noopener" target="_blank" href="/serverless-a-painless-aws-boilerplate-e5ec3b4fb609">看看我的无服务器样板文章，了解更多关于组织无服务器项目的信息</a>)。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="ff75" class="ne lt iq nr b gy nv nw l nx ny">functions:<br/>  hello:<br/>    handler: handler.hello<br/>      events:<br/>        - http:<br/>            path: /hello<br/>          method: get<br/>    provisionedConcurrency: 5<br/>    reservedConcurrency: 5</span></pre><p id="107b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">保留的并发性</strong>将确保函数总是可以伸缩那么多倍，而<strong class="ky ir">提供的并发性</strong>决定最初将有多少实例是活动的。这确保了扩展时间不会增加服务延迟。在一个示例场景中，您可能希望在主页上设置多一点的并发性，而在用户管理服务上设置很少的并发性，因为它们不能应对高需求。</p><h2 id="6a64" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">缓存数据并避免数据库连接</h2><p id="f760" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在某些情况下，不要求数据一致。例如，博客网站可能不希望总是从数据库中获取数据。用户可能很乐意阅读一些陈旧的数据，但他们永远不会注意到。看看下面的函数。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="0cbb" class="ne lt iq nr b gy nv nw l nx ny">exports.main = (event, context, callback) =&gt; {<br/>    // connect to database, send data in callback(null, data);<br/>}</span></pre><p id="55b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将始终与数据库通信。然而，可以这样做。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="aa01" class="ne lt iq nr b gy nv nw l nx ny">// cache data in a variable and close DB<br/>exports.main = (event, context, callback) =&gt; {<br/>    // send data if event.queryParameters are same<br/>    // else: fetch data and send over<br/>}</span></pre><p id="8040" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种修改，很可能不再从数据库中一次又一次地寻找冗余数据。甚至可以使用时间戳来检查数据是否太陈旧。通过使用一个 chron 作业调用函数，可以有更多的技巧来保持函数的热度。如果负载分布随时间不均匀，则不应这样做。</p><h1 id="c47c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">保持功能温暖</h1><p id="cf39" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是 AWS 自己提出的一个著名的保持功能温暖的建议。我们可以简单地通过回调发送数据来做到这一点，而不必完成事件循环。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="ff88" class="ne lt iq nr b gy nv nw l nx ny">exports.main = (event, context, callback) =&gt; {<br/>    context.callbackWaitsForEmptyEventLoop = false;<br/>}</span></pre><p id="4ea8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以在<strong class="ky ir">上下文</strong>对象中将<strong class="ky ir"><em class="nd">callbackWaitsForEmptyEventLoop</em></strong>设置为假。这有助于维护数据库连接，同时在关闭数据库连接之前处理请求。这类似于在全局变量中缓存数据，但在这里，我们缓存整个连接。确保检查连接是否处于活动状态，因为它可能会被数据库服务本身中断。</p><p id="f7f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种方法中，有可能超出数据库连接限制。但是这可能是一个方便的技巧，因为建立数据库连接本身可能会增加一些延迟。</p><h1 id="b5f5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">处理 CPU 密集型任务</h1><p id="4ce5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">CPU 密集型任务主要是矩阵计算。然而，我们可以把<strong class="ky ir"> <em class="nd">水印</em> </strong>图像看作是这样一个任务。让我们看看下面的例子。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="d865" class="ne lt iq nr b gy nv nw l nx ny">const Jimp = require('jimp');</span><span id="e058" class="ne lt iq nr b gy nz nw l nx ny">create_watermarks = async (key) =&gt; {<br/>  // get the images from s3<br/>  const s3Obj = await s3.getObject(params).promise();<br/>  // read watermark image<br/>  // for each image from s3<br/>      watermarkImage = await Jimp.read(__dirname + '/wm.png');<br/>      const img = await Jimp.read(s3Obj.Body);<br/>      // add watermark<br/>}</span></pre><p id="62be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个函数中，我们多次读取图像。但是，添加以下内容可以节省大量时间，加快一切。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="cd5f" class="ne lt iq nr b gy nv nw l nx ny">const img = await Jimp.read(watermark);<br/>watermarkImage = await Jimp.read(__dirname + '/wm.png');<br/>// for each image from s3<br/>    const watermarkCopy = watermarkImage.clone();<br/>    // add watermakr</span></pre><p id="9371" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以通过在全局变量中缓存已经读取的水印图像来进一步优化。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="4029" class="ne lt iq nr b gy nv nw l nx ny">const Jimp = require('jimp');<br/>watermarkCache = null;</span><span id="9c02" class="ne lt iq nr b gy nz nw l nx ny">create_watermarks = async (key) =&gt; {<br/>    if watermarkCache==null &lt;- read and set variable<br/>    // copy watermark and add to each image<br/>}</span></pre><h1 id="ca1a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">管理函数内部的并发性</h1><p id="fb5a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">节点。JS </strong>有事件循环架构。在这种情况下，所有项目都在单个线程中调度和运行。这就是为什么我们在<strong class="ky ir">节点没有观察到任何竞争情况。JS </strong>并发。事件循环不断轮询异步任务以获得结果。所以有太多的并发任务会使事件循环更长。此外，如果并发任务使用衍生的进程，系统可能会被不必要的颠簸淹没。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="7b62" class="ne lt iq nr b gy nv nw l nx ny">add_watermark (img, wm) =&gt; {add watermark, return new image}</span></pre><p id="a57c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果你用下面的函数从 S3 和水印中加载 100 个潜在的图像键，会发生什么？</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="e767" class="ne lt iq nr b gy nv nw l nx ny">s3keys_list = [...100 keys...]<br/>await Promise.all(map(add_watermark, s3keys_list))</span></pre><p id="5482" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事件循环将发出 100 个并发的 S3 对象请求。这可能会使您超过内存限制，甚至可能会在 S3 或其他地方产生并发费用。我们如何解决这个问题？一个简单的解决方案如下。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="6d8a" class="ne lt iq nr b gy nv nw l nx ny">s3keys_list = [...100 keys...]<br/>tmp_list = []<br/>for(x = 0; x &lt; s3keys_list.length; x++)<br/>{<br/>   // s3keys_list[x] to tmp_list<br/>   // if tmp_list.length == 5<br/>   // await Promise.all(map(add_watermark, tmp_list))<br/>   tmp_list = []<br/>{<br/>// process any remaining items in tmp_list the same way</span></pre><p id="8590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种方法，可以保证有特定的并发性。你不会有一大群超过 RAM 的克隆水印。</p><p id="6b9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了我讨论的上述技巧之外，我们还可以根据领域和应用程序的知识使用许多其他的优化。此外，我们可以简单地观察日志，并使用它们来进一步调整并发性需求。有时，以牺牲并发性为代价增加一点内存甚至是值得的。这是因为很多人很少使用站点维护端点。</p><p id="73c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢阅读这篇文章。这些是我们在开发有许多用户的平台时使用的一些技巧。这有助于我们应对大范围促销活动期间的一次性高需求，在该活动中，许多用户进行了注册。</p></div></div>    
</body>
</html>