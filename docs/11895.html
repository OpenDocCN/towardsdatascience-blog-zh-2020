<html>
<head>
<title>Visualizing error log with pandas and Plotly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 pandas 和 Plotly 可视化错误日志</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visualize-error-log-with-pandas-and-plotly-d7796a629eaa?source=collection_archive---------39-----------------------#2020-08-17">https://towardsdatascience.com/visualize-error-log-with-pandas-and-plotly-d7796a629eaa?source=collection_archive---------39-----------------------#2020-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8473" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Plotly 和 pandas timedelta 在“数据帧&gt;重采样&gt;绘图”管道中的优势和问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/972a57823f8223c91bee9ced52c61234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*6ftKYeAwrij7aO9oyQq0Bw.gif"/></div></figure><p id="5914" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最近，我收到了一个来自性能测量的数据集，其中包含关于处理时间和错误的数据。简单看了一眼后，我想这可能是一个问题；我需要把它形象化，让每个人都看到。视觉化很简单，但是它可以教你一些关于熊猫的概念，以及你可能面临的困难。主要是:</p><ul class=""><li id="b969" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">与熊猫一起工作<code class="fe lv lw lx ly b">timedelta</code>列类型</li><li id="976f" class="lm ln it ks b kt lz kw ma kz mb ld mc lh md ll lr ls lt lu bi translated">熊猫<code class="fe lv lw lx ly b">resampling</code>(一分钟或 5 秒钟图表)</li><li id="10be" class="lm ln it ks b kt lz kw ma kz mb ld mc lh md ll lr ls lt lu bi translated">与<code class="fe lv lw lx ly b">Plotly.Express</code>一起制图</li><li id="1ff3" class="lm ln it ks b kt lz kw ma kz mb ld mc lh md ll lr ls lt lu bi translated">多么神秘。用<code class="fe lv lw lx ly b">subplots </code>表达斗争(或两轴绘图)</li><li id="6709" class="lm ln it ks b kt lz kw ma kz mb ld mc lh md ll lr ls lt lu bi translated">对齐 Plotly 的轴</li></ul><p id="03b2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">和往常一样，你可以在<a class="ae me" href="https://github.com/vaclavdekanovsky/data-analysis-in-examples/blob/master/Error%20Log%20with%20pandas%20and%20Plotly/Error%20Log%20Analysis.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub 笔记本</a>中看到框架、计算、情节背后的代码。它会带你经历:</p><p id="8b3b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">1.<a class="ae me" href="#2ff2" rel="noopener ugc nofollow">错误日志的 EDA</a></p><p id="1d55" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">2.<a class="ae me" href="#8971" rel="noopener ugc nofollow">剧情简介。快递</a></p><p id="e635" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">3.【timedelta 的优势和问题</p><p id="351d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">4.<a class="ae me" href="#416e" rel="noopener ugc nofollow">剧情支线剧情</a></p><p id="29c0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">5.<a class="ae me" href="#e0ac" rel="noopener ugc nofollow">共享轴的 Plotly 图表</a></p><h1 id="85fb" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">错误日志</h1><p id="2ca3" class="pw-post-body-paragraph kq kr it ks b kt mx ju kv kw my jx ky kz mz lb lc ld na lf lg lh nb lj lk ll im bi translated">我将错误简化为仅包含 3 列:</p><ul class=""><li id="6f9e" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><strong class="ks iu">陈述</strong> —结果或过程(好或错)</li><li id="ddad" class="lm ln it ks b kt lz kw ma kz mb ld mc lh md ll lr ls lt lu bi translated"><strong class="ks iu">开始时间</strong> —流程开始的时间</li><li id="2cf5" class="lm ln it ks b kt lz kw ma kz mb ld mc lh md ll lr ls lt lu bi translated"><strong class="ks iu">结束时间</strong> —流程结束的时间</li></ul><p id="f164" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我的例子中，应用程序试图将报告呈现到<code class="fe lv lw lx ly b">.pdf</code>中，但是类似的技术可以用于处理包含<code class="fe lv lw lx ly b">result</code>和<code class="fe lv lw lx ly b">duration.</code>的任何类型的错误日志</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="545a" class="ng mg it ly b gy nh ni l nj nk"># Example error log</span><span id="216b" class="ng mg it ly b gy nl ni l nj nk">State,StartTime,EndTime<br/>Ok,2020-08-13 19:55:22,2020-08-13 19:55:27<br/>Er,2020-08-13 19:55:22,2020-08-13 19:55:30<br/>Ok,2020-08-13 19:55:24,2020-08-13 19:55:30</span></pre><p id="9317" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">作为第一步，我必须解压日志(也包含在<a class="ae me" href="https://github.com/vaclavdekanovsky/data-analysis-in-examples/blob/master/Error%20Log%20with%20pandas%20and%20Plotly/log.zip" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中)。当然，您可以手动解压缩，但是如果您想要创建一个自动化管道，您应该学习如何用代码来完成。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="5feb" class="ng mg it ly b gy nh ni l nj nk">import zipfile</span><span id="b287" class="ng mg it ly b gy nl ni l nj nk"># first let's unzip the error log<br/>with zipfile.ZipFile("log.zip", 'r') as zip_ref:<br/>    zip_ref.extractall("")</span></pre><h1 id="2ff2" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">探索性数据分析</h1><p id="0b01" class="pw-post-body-paragraph kq kr it ks b kt mx ju kv kw my jx ky kz mz lb lc ld na lf lg lh nb lj lk ll im bi translated">无论数据看起来有多简单，都要花一点时间在 EDA 上，以确保不会出现诸如丢失值、意外范围或重复等意外情况。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="b136" class="ng mg it ly b gy nh ni l nj nk"># load the data into the pandas's dataframe<br/>df = pd.read_csv("error.log")</span><span id="93f7" class="ng mg it ly b gy nl ni l nj nk"># run predefined EDA function and optionally style the output<br/>[In]: data_frame_stats(df)\<br/>.style.format({"notnulls%": "{:,.2%}", "unique%": "{:,.2%}"})</span><span id="35ad" class="ng mg it ly b gy nl ni l nj nk">[Out]: <br/>          type   notnulls notnulls% unique unique%<br/>State     object 1725     100.00%    2     0.12%<br/>StartTime object 1725     100.00%    733   42.49%<br/>EndTime   object 1725     100.00%    586   33.97%</span></pre><p id="ccf6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">快速概览显示没有价值丢失。<code class="fe lv lw lx ly b">State</code>包含两个值，而时间戳是非常唯一的，即使有些发生在同一秒钟。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="d11b" class="ng mg it ly b gy nh ni l nj nk">[In]: list(df["State"].unique())<br/>[Out]: ['Ok', 'EndedWithError']</span></pre><p id="a702" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe lv lw lx ly b">State</code>的现有值为“Ok”和“EndedWithError”。知道我们可以通过将时间戳列转换为日期时间格式，并可选地将状态转换为分类列或 bool 列来润色数据帧。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="e2a9" class="ng mg it ly b gy nh ni l nj nk"># Convert strings to datetimes using `pd.to_datetime` and specifying the format<br/>df["StartTime"] = pd.to_datetime(df["StartTime"], <br/>                                 format="%Y-%m-%d %H:%M:%S")</span><span id="00f3" class="ng mg it ly b gy nl ni l nj nk"># convert the State column into categorical. Mainly to decrease dataframe's memory footprint<br/>df["State"] = df["State"].astype("category")</span><span id="dab7" class="ng mg it ly b gy nl ni l nj nk"># convert errro column to bool `.map()<br/>df["Error"] = df["State"].map({"Ok": False, "EndedWithError": True}).astype("bool")</span><span id="5fb6" class="ng mg it ly b gy nl ni l nj nk"># If there would be more error types, e.g. Error1, Error2 etc, we can apply if function through lambda expression<br/># df["Error"] = df["State"].apply(lambda x: False if x =="Ok" else True).astype("bool")</span><span id="4785" class="ng mg it ly b gy nl ni l nj nk"># let's have a look on the final sample<br/>df.sample(3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e14a90042e7cbc49ef58570c43936a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*Zb4NVtbrQ44CA0A4B3kpfA.jpeg"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">已分析错误日志中的示例行</p></figure><h1 id="ca72" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">持续时间</h1><p id="e908" class="pw-post-body-paragraph kq kr it ks b kt mx ju kv kw my jx ky kz mz lb lc ld na lf lg lh nb lj lk ll im bi translated">我们主要对<code class="fe lv lw lx ly b">StartTime</code>和<code class="fe lv lw lx ly b">EndTime</code>都不感兴趣，而是对记录事件的持续时间感兴趣。由于这两列都是 pandas 的数据时间，我们可以简单地将它们相减得到一个<code class="fe lv lw lx ly b">timedelta</code>列。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="2f26" class="ng mg it ly b gy nh ni l nj nk"># calculate the duration<br/>df["Duration"] = df["EndTime"]-df["StartTime"]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/63c7e1984d7de51931370c4352117125.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*vaZ138YYNBHWyovMtxYWow.jpeg"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">添加 timedelta 类型的持续时间列</p></figure><h1 id="8971" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">Plotly Express</h1><p id="e5a9" class="pw-post-body-paragraph kq kr it ks b kt mx ju kv kw my jx ky kz mz lb lc ld na lf lg lh nb lj lk ll im bi translated">看起来我们已经拥有了生成一些有趣情节所需的所有列。让我们研究一下错误的数量与事件的数量的对比。我们将使用 Plotly。Express，流行的<a class="ae me" href="https://plotly.com/" rel="noopener ugc nofollow" target="_blank"> Plotly 库</a>的高级 API，它创建交互式(使用 JavaScript)图表。普洛特利。Express 以数据帧作为输入非常强大。使用 Plotly express，生成一个简单的图表是一行程序。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="8f4f" class="ng mg it ly b gy nh ni l nj nk">import plotly.express as px</span><span id="2c75" class="ng mg it ly b gy nl ni l nj nk"># With Plotly express you can quickly review the counts of varibles in the dataframe, even though I'm not sure which plotly have picked such low contract for their standard chart.</span><span id="f6b0" class="ng mg it ly b gy nl ni l nj nk"><strong class="ly iu">px.bar(df, x="State", title="Count of states")</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ns"><img src="../Images/59292f8b82ebc030e33e05e363485792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CPW7kO7tFQYausZm2mwuqw.jpeg"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">Plotly express 图表。它可以缩放，平移，并提供悬停工具提示。</p></figure><p id="d18e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Plotly 图表提供了许多伟大的功能。它们可以缩放，您可以通过拖动鼠标来平移图表，并且每个元素的数据都会在工具提示中进行汇总，工具提示会在您将鼠标悬停在元素上后出现。不幸的是，闪光的并不都是金子，还有一些令人讨厌的细节。</p><blockquote class="nx ny nz"><p id="adc8" class="kq kr oa ks b kt ku ju kv kw kx jx ky ob la lb lc oc le lf lg od li lj lk ll im bi translated">Plotly 自动计算你的分类值，但是工具提示显示<code class="fe lv lw lx ly b">count=1</code>，并且这样的条形图的自动颜色与背景没有对比。<code class="fe lv lw lx ly b">px.pie</code> piechart 根本不会自动计算发生次数。</p></blockquote><h1 id="9c7e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">时间增量及其相关问题</h1><p id="aee6" class="pw-post-body-paragraph kq kr it ks b kt mx ju kv kw my jx ky kz mz lb lc ld na lf lg lh nb lj lk ll im bi translated">我们知道我们的错误日志包含相当多的错误。它们的总数是惊人的，但是这些错误会持续发生吗？它们会反映在处理时间中吗？为了表明我们可以利用熊猫的<code class="fe lv lw lx ly b">resample</code>功能，并计算每一分钟的事件。不幸的是，<code class="fe lv lw lx ly b">timedelta</code>列不容易平均。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="251a" class="ng mg it ly b gy nh ni l nj nk"># you can average time delta for full dataframe<br/>[In]: df["Duration"].mean()<br/>[Out]: Timedelta('0 days 00:01:01.371594')  # ~one minute </span></pre><p id="a4c0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是尝试在重新采样的数据帧上应用<code class="fe lv lw lx ly b">mean</code>:</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="ed03" class="ng mg it ly b gy nh ni l nj nk"># but you cannot average it `.mean()<br/>try:<br/>    df.set_index("StartTime")["Duration"]<strong class="ly iu">.resample("1min").mean()</strong><br/>except Exception as e:<br/>    print(e)</span><span id="15e0" class="ng mg it ly b gy nl ni l nj nk">[Out]: No numeric types to aggregate</span></pre><p id="4cf5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可以<code class="fe lv lw lx ly b">resample</code>和<code class="fe lv lw lx ly b">.sum()</code>、<code class="fe lv lw lx ly b">.count()</code>，但由于某种原因，您无法对重新采样的 timedelta 值求平均值。</p><blockquote class="nx ny nz"><p id="baf1" class="kq kr oa ks b kt ku ju kv kw kx jx ky ob la lb lc oc le lf lg od li lj lk ll im bi translated">编程带来了意想不到的问题，但也带来了简单的解决方案。</p></blockquote><ul class=""><li id="9aed" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">您可以将时间增量转换为秒，然后取平均值</li><li id="9341" class="lm ln it ks b kt lz kw ma kz mb ld mc lh md ll lr ls lt lu bi translated">因为你可以<code class="fe lv lw lx ly b">sum</code>和<code class="fe lv lw lx ly b">count</code>，你也可以平均为<code class="fe lv lw lx ly b">sum/count</code></li></ul><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="5656" class="ng mg it ly b gy nh ni l nj nk"># you can turn timedelta into int, which give nanosecond represantation of the time delta which you divide by 1 bilion<br/>df["duration_seconds"] = df["Duration"].astype('int64').divide(1000000000)</span><span id="dc3c" class="ng mg it ly b gy nl ni l nj nk"># or you can use timedelta's .to_seconds() method<br/>df["duration_seconds_2"] = df["Duration"].dt.total_seconds()</span></pre><h2 id="b420" class="ng mg it bd mh oe of dn ml og oh dp mp kz oi oj mr ld ok ol mt lh om on mv oo bi translated">用熊猫重新采样</h2><p id="8ec1" class="pw-post-body-paragraph kq kr it ks b kt mx ju kv kw my jx ky kz mz lb lc ld na lf lg lh nb lj lk ll im bi translated">为了对任何数据帧进行重新采样，最简单的方法是将日期时间列之一设置为索引。我们将为<code class="fe lv lw lx ly b">StartTime</code>做这件事。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="08f7" class="ng mg it ly b gy nh ni l nj nk">stats = df.set_index("StartTime")</span></pre><p id="2189" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们希望看到每分钟错误和成功的计数，以及成功和错误流程的处理时间(持续时间)。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="e2a8" class="ng mg it ly b gy nh ni l nj nk">stats = stats\<br/>        .groupby("State")\<br/>        .resample("1min")\<br/>        .agg({"State":"count", "duration_seconds": "mean", "Duration": ["sum","count"]})</span></pre><p id="4917" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一次执行多个聚合会产生多级列名，我们使用<code class="fe lv lw lx ly b">reset_index</code>将这些列名转换回一个级别，并根据每个级别对列进行重命名。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="0f01" class="ng mg it ly b gy nh ni l nj nk"># State appear in index (due to groupby) and in values, because we </span><span id="92ea" class="ng mg it ly b gy nl ni l nj nk">count states. We must rename the column before we reset the index<br/>stats = stats\<br/>       .rename(columns={"State":"Count"}) <br/>       .reset_index(level=[0,1])</span></pre><p id="4cc8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">将两级列名合并成一个:</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="a553" class="ng mg it ly b gy nh ni l nj nk"># two level column index turned into single level by joining zipped values from each level</span><span id="080b" class="ng mg it ly b gy nl ni l nj nk">stats.columns = ["_".join(z) for z in zip(stats.columns.get_level_values(0),<br/>    stats.columns.get_level_values(1))]</span></pre><p id="099a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，我们通过将<code class="fe lv lw lx ly b">sum</code>列除以<code class="fe lv lw lx ly b">count</code>列来计算平均持续时间</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="86bf" class="ng mg it ly b gy nh ni l nj nk"># calculate the average duration from the sum and count<br/>stats["duration_mean"] = stats["Duration_sum"]/stats["Duration_count"]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/35345e1e6806506904eb817ecd31e74a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*cL5JBerSy7IUMmDk8qY-Hg.jpeg"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">结果统计。每个状态的计数和每分钟的平均持续时间。</p></figure><p id="926c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">产生的数据帧<code class="fe lv lw lx ly b">stats</code>可以使用单线绘图表达式绘制。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="aac2" class="ng mg it ly b gy nh ni l nj nk">fig_count = px.bar(stats, x="StartTime", y="Count", barmode="group", color="State")<br/>fig_count.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oq"><img src="../Images/894ba3c7fa6f186d6a70bbee65699e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9S_hsqewjcqmmUPB9wr1BA.jpeg"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">每分钟的事件计数</p></figure><p id="6fe7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">同样，持续时间可以绘制成折线图。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="98b0" class="ng mg it ly b gy nh ni l nj nk">fig_duration = px.line(stats, x="StartTime", y="duration_mean", color="State")<br/>fig_duration.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi or"><img src="../Images/e83e56891076fba2db5bb8a8262e787e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5TGt177bd5J5j4cpbRN2w.jpeg"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">通过 Plotly 持续时间。用 y 轴上的 timedelta 列表示</p></figure><blockquote class="nx ny nz"><p id="1192" class="kq kr oa ks b kt ku ju kv kw kx jx ky ob la lb lc oc le lf lg od li lj lk ll im bi translated">注意 y 轴上的<code class="fe lv lw lx ly b">120B, 100B, etc.</code>值。<code class="fe lv lw lx ly b">timedelta</code>值的另一个弱点是许多库，包括 Plotly express 都很难正确使用它们。</p></blockquote><p id="e4df" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因为我知道这个问题，所以我已经提前创建了<code class="fe lv lw lx ly b">duration_seconds_mean</code>列，并将持续时间显示为<code class="fe lv lw lx ly b">float</code>。</p><h1 id="416e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">情节复杂的次要情节</h1><p id="69ca" class="pw-post-body-paragraph kq kr it ks b kt mx ju kv kw my jx ky kz mz lb lc ld na lf lg lh nb lj lk ll im bi translated">关于同一个问题的两个图表就像是分离的恋人。这可能行得通，但合在一起更理想。每个可视化库都可以创建支线剧情，Plotly 也不例外。不幸的是，它不适用于 Plotly。Express 而且你还得用更低级的<code class="fe lv lw lx ly b">go</code> API。</p><p id="1a75" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">尽管每个 Plotly 图表的背景都有一个数据字典:</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="db8f" class="ng mg it ly b gy nh ni l nj nk"># each Plotly chart stores a dictionary of date and settings <br/>[In]: fig_duration.to_dict()<br/>[Out]: <br/>{'data': [{'hovertemplate': 'State=EndedWithError&lt;br&gt;StartTime=%{x}&lt;br&gt;duration_seconds_mean=%{y}&lt;extra&gt;&lt;/extra&gt;',<br/>   'legendgroup': 'EndedWithError', <br/>...</span></pre><p id="1522" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这些字典不能被输入到 Plotly 的支线剧情中</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="3114" class="ng mg it ly b gy nh ni l nj nk">import plotly.graph_objects as go<br/>from plotly.subplots import make_subplots</span><span id="9579" class="ng mg it ly b gy nl ni l nj nk"># initialize the subplots<br/>fig = make_subplots(rows=2, cols=1, shared_xaxes=True)</span><span id="0bd0" class="ng mg it ly b gy nl ni l nj nk"># traying to add plotly express trace to the subplot will results in an error<br/>try: <br/>    fig.add_trace(fig_duration)<br/>    # neither the following would help<br/>    # fig.add_trace(fig_duration.to_dict())<br/>    # fig.add_trace(fig_duration.to_dict()["date"])<br/>except Exception as e:<br/>    print(e)</span><span id="7f03" class="ng mg it ly b gy nl ni l nj nk"><strong class="ly iu">[Out]: Invalid element(s) received for the 'data' property of ...</strong></span></pre><blockquote class="nx ny nz"><p id="e489" class="kq kr oa ks b kt ku ju kv kw kx jx ky ob la lb lc oc le lf lg od li lj lk ll im bi translated">另一个恼人的特点是你不能用 Plotly 制作支线剧情。Express(还没有),你必须回到较低级别的 API，它不能很好地处理数据帧。</p></blockquote><p id="883a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要制作一个子情节，你必须使用<code class="fe lv lw lx ly b">Plotly.graph_objects.go</code>并分别指定每个输入——例如<code class="fe lv lw lx ly b">x=df["StartTime"], y=df["duration]</code>。Plotly express 可以通过<code class="fe lv lw lx ly b">categorical</code>列分割数据，但是对于<code class="fe lv lw lx ly b">go</code> API，您必须手动将它们分开。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="d3c7" class="ng mg it ly b gy nh ni l nj nk">err = stats[stats["State"]=="EndedWithError"]<br/>ok = stats[stats["State"]=="Ok"]</span></pre><p id="6d86" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然后初始化子情节:</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="2381" class="ng mg it ly b gy nh ni l nj nk">from plotly.subplots import make_subplots<br/>fig = make_subplots(rows=2, cols=1)</span></pre><p id="efc6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">添加所有跟踪(图表项目)，同时您可以指定细节，如系列的颜色或名称:</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="ec50" class="ng mg it ly b gy nh ni l nj nk"># add scatter (which includes line charts as well) as the top chart containing duration of successful events<br/><strong class="ly iu">fig.add_trace</strong>(<br/>    go.Scatter(x=ok["StartTime"], <br/>               y=ok["duration_seconds_mean"], <br/>               name="success duration",<br/>               marker_color="Green",<br/>              ),<br/>    row=1, col=1<br/>)</span></pre><p id="dd9b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，您自定义图表的布局并显示它:</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="fed4" class="ng mg it ly b gy nh ni l nj nk">fig.update_layout(title="Processing speed and number of errors with missaligned x-axis",<br/>                  yaxis_tickformat = '.2f',<br/>                  xaxis_title="Time of Request",<br/>                  yaxis = {"title": "processing time"},<br/>                  yaxis2 = {"title": "number of requests"}</span><span id="2827" class="ng mg it ly b gy nl ni l nj nk">fig.show()</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">将所有这些放在一起，制作出普洛特利的围棋支线剧情</p></figure><p id="3279" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们再次面临一个令人不快的困难:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ou"><img src="../Images/0b767e118bf2c346f105033fef00a96f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHHhLAoM5-s5gXU4gktXqA.jpeg"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">即使 x 轴具有相同的范围，它们在折线图和条形图中也是不对齐的。</p></figure><blockquote class="nx ny nz"><p id="6b09" class="kq kr oa ks b kt ku ju kv kw kx jx ky ob la lb lc oc le lf lg od li lj lk ll im bi translated">即使 x 轴具有相同的范围，折线图的 x 轴也不会与条形图中的同一轴对齐。(参见<a class="ae me" href="https://github.com/vaclavdekanovsky/data-analysis-in-examples/blob/master/Error%20Log%20with%20pandas%20and%20Plotly/Error%20Log%20Analysis.ipynb" rel="noopener ugc nofollow" target="_blank">完整代码</a>获取证明)</p></blockquote><p id="98d7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">幸运的是，您可以使用<code class="fe lv lw lx ly b">shared_xaxes=True</code>迅速修复它。这带来了另一个好处，当你放大一个图表时，另一个也会放大。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="2bda" class="ng mg it ly b gy nh ni l nj nk">fig = make_subplots(rows=2, cols=1, <strong class="ly iu">shared_xaxes=True</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oq"><img src="../Images/c1939672f6d87abb130e2d25c9574ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fptXtAKlQNPZ1G7ivvg4Zg.jpeg"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">两个图被缩放在一起</p></figure><h1 id="e0ac" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">共享 y 轴的绘图</h1><p id="35cf" class="pw-post-body-paragraph kq kr it ks b kt mx ju kv kw my jx ky kz mz lb lc ld na lf lg lh nb lj lk ll im bi translated">这一初步探索表明:</p><ol class=""><li id="01ee" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll ov ls lt lu bi translated">最初，没有错误</li><li id="ebff" class="lm ln it ks b kt lz kw ma kz mb ld mc lh md ll ov ls lt lu bi translated">随着处理时间的增加，错误的数量开始增加</li><li id="2a55" class="lm ln it ks b kt lz kw ma kz mb ld mc lh md ll ov ls lt lu bi translated">错误数量下降并开始再次增长，而时间继续增加</li><li id="981f" class="lm ln it ks b kt lz kw ma kz mb ld mc lh md ll ov ls lt lu bi translated">有一段时间，处理时间减少了，但是成功的事件也减少了</li><li id="e2b0" class="lm ln it ks b kt lz kw ma kz mb ld mc lh md ll ov ls lt lu bi translated">然后会有更多的成功发生，但也需要更长的时间来处理它们</li><li id="a05a" class="lm ln it ks b kt lz kw ma kz mb ld mc lh md ll ov ls lt lu bi translated">最后，所有请求都以错误结束，开始时需要一些时间，但最终，所有事件都在一秒钟内以错误结束。</li></ol><p id="13f6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你没看到吗？也许我们可以用两个 y 轴一起绘制图表。</p><blockquote class="nx ny nz"><p id="c6c9" class="kq kr oa ks b kt ku ju kv kw kx jx ky ob la lb lc oc le lf lg od li lj lk ll im bi translated">带有主轴和副轴的图表也是子图，通过参数<code class="fe lv lw lx ly b">specs=[[{“secondary_y”: True}]]</code>组合。通过<code class="fe lv lw lx ly b">secondary_y=True</code>或<code class="fe lv lw lx ly b">secondary_y=False</code>将每个轨迹分配给相关轴</p></blockquote><p id="3741" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们尝试用两个轴绘制带有计数的条形图和显示持续时间的折线图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ow"><img src="../Images/644b7d618b962427d5e0c8cd0c771e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fhYYNwbLV7ws7kbgwDWWxg.jpeg"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">发生了什么，为什么我们的线藏在栅栏后面？</p></figure><blockquote class="nx ny nz"><p id="2125" class="kq kr oa ks b kt ku ju kv kw kx jx ky ob la lb lc oc le lf lg od li lj lk ll im bi translated">我最初将处理时间放在主轴上的决定是错误的，因为 Plotly 总是将副轴(条形图)显示在顶部，所以这条线在背景中消失了。</p></blockquote><p id="2ef1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">好了，普洛特利，让我们换一下轴。副轴为线，主轴为条。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ox"><img src="../Images/4b073c652e5ee55032e1da478408990b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9q1AJxU9cp_52rxBEtCYig.jpeg"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">尽管如此，图表并不理想。可以看到每个轴的网格线彼此之间只有几毫米的距离。</p></figure><p id="20c7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你希望现在有一个好的图表，你可能会失望。两个轴共享(意外地)非常相似的范围(~[0，130])，但是 Plotly 决定绘制每个网格线，只是稍微偏离另一个轴上的相应网格线。</p><p id="8be5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这种情况也有解决方法。只需强制两个轴使用相同的范围。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="1e87" class="ng mg it ly b gy nh ni l nj nk">fig.update_yaxes(range=[0, 130])</span></pre><p id="98d0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我已经把图表给开发者看了，他们很快就明白了这个问题。随着事件越积越多，处理它们需要更长的时间，并且越来越多的事件以错误告终。这个系统非常聪明，它决定偶尔终止部分进程，这样我们就不会有错误了。有一次，它甚至试图重新开始整个过程，但由于场景重复，最终，一切都被拒绝。</p><p id="870d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了确定模式，不使用<code class="fe lv lw lx ly b">1min</code>而是使用<code class="fe lv lw lx ly b">5s (seconds).</code>很容易重新采样数据</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="e71a" class="ng mg it ly b gy nh ni l nj nk">df.set_index("StartTime").groupby("State")<strong class="ly iu">.resample("5s")</strong>.agg(...)</span></pre><p id="fcec" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里，一个轴的事件范围为 0–30，而另一个轴的事件范围为 0–150。Plotly 不会对齐网格线，我们必须试验每个轴的设置，以获得两个轴的相同网格线。</p><pre class="kj kk kl km gt nc ly nd ne aw nf bi"><span id="b4c2" class="ng mg it ly b gy nh ni l nj nk"># you can specify the range and ticks of any axis<br/>fig.update_layout(yaxis={"range":[0,30]},<br/>                  yaxis2={"range":[0,150],<br/>                         "tickvals": [25,50, 75, 100, 125, 150]}<br/>                 )</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oy"><img src="../Images/76ba09d2bf11b4850c3a81ddd7060131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHoAwD_ETwTl4F_1rW6Gyg.jpeg"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">同样的情况样本由 5 秒钟与 Plotly 的美丽的工具提示</p></figure><p id="1672" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">由于 Plotly 的交互性，您可以放大图表并探索任何部分。使用单个参数<code class="fe lv lw lx ly b">fig.update_layout(hovermode=”x unified”)</code>创建了一个包含所有 4 个显示值的漂亮工具提示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/972a57823f8223c91bee9ced52c61234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*6ftKYeAwrij7aO9oyQq0Bw.gif"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">利用 Plotly 的交互性探索 5s 样品的细节</p></figure><h1 id="314a" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="7027" class="pw-post-body-paragraph kq kr it ks b kt mx ju kv kw my jx ky kz mz lb lc ld na lf lg lh nb lj lk ll im bi translated">在本文中，我们探讨了如何将一个简单的错误日志转换成图表，以帮助我们找到一个可以解释的模式。我们曾经和熊猫<code class="fe lv lw lx ly b">timedelta</code>和<code class="fe lv lw lx ly b">Plotly</code>斗争过。不要误解我，Plotly 是一个很棒的库，但有时简单的事情会很复杂。</p><blockquote class="nx ny nz"><p id="9744" class="kq kr oa ks b kt ku ju kv kw kx jx ky ob la lb lc oc le lf lg od li lj lk ll im bi translated">然而，大多数时候，你受益于把复杂的事情变得简单。</p></blockquote><p id="2a48" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你想了解股票市场公司的财务状况，请阅读:</p><div class="oz pa gp gr pb pc"><a rel="noopener follow" target="_blank" href="/stock-fundamental-analysis-eda-of-secs-quarterly-data-summary-455e62ff4817"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">股票基本面分析:SEC 季度数据汇总的 EDA</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">大熊猫 2020 SEC 申报的探索性数据分析</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">towardsdatascience.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq ko pc"/></div></div></a></div><p id="a471" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">或者用人工智能进行哲学思考</p><div class="oz pa gp gr pb pc"><a href="https://medium.com/@vaaasha/can-ai-teach-us-happiness-2629b600a4e0" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">AI 能教会我们快乐吗？</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">如何利用大脑的模式识别能力为我们造福？</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">medium.com</p></div></div><div class="pl l"><div class="pr l pn po pp pl pq ko pc"/></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ps"><img src="../Images/dc5ecd820e5c09a9dbb0b9df33a108c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLEI4oDtmCLn-QlFv3Pn3A.png"/></div></div></figure></div></div>    
</body>
</html>