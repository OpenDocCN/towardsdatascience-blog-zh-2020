<html>
<head>
<title>Scrapy: This is how to successfully login with ease</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scrapy:这就是如何轻松成功登录</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/scrapy-this-is-how-to-successfully-login-with-ease-ea980e2c5901?source=collection_archive---------1-----------------------#2020-02-22">https://towardsdatascience.com/scrapy-this-is-how-to-successfully-login-with-ease-ea980e2c5901?source=collection_archive---------1-----------------------#2020-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/881cb72a68d632436b6bd1cd010af82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GO4OcO9Of3GByOD9RnbHRA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@parachutel_" rel="noopener ugc nofollow" target="_blank">李晟</a>从没开过</p></figure><div class=""/><div class=""><h2 id="6cab" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">揭秘用 Scrapy 登录的过程。</h2></div><p id="c119" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦你理解了 Scrapy 的基本知识，第一个复杂的问题就是必须处理登录。要做到这一点，了解登录是如何工作的以及如何在浏览器中观察这个过程是很有用的。我们将在这篇文章中讨论这一点以及 scrapy 如何处理登录过程。</p><h1 id="da3b" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">在本文中，您将了解到</h1><ol class=""><li id="b3a5" class="mm mn jj la b lb mo le mp lh mq ll mr lp ms lt mt mu mv mw bi translated">如何将 FormRequest 类用于简单的登录过程</li><li id="dfb8" class="mm mn jj la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">如何使用<code class="fe nc nd ne nf b">fromresponse</code>方法进行更复杂的登录过程</li><li id="71c2" class="mm mn jj la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">如何实现基本的 XPATH 选择器</li><li id="188a" class="mm mn jj la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">了解会话和令牌浏览器身份验证之间的区别</li><li id="a9d2" class="mm mn jj la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">CSRF 是什么，为什么知道它很重要</li><li id="198c" class="mm mn jj la b lb mx le my lh mz ll na lp nb lt mt mu mv mw bi translated">如何处理 Scrapy 中的令牌认证</li></ol><h1 id="2c08" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">简单的登录程序</h1><p id="266c" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">当你输入数据到网站表单域时，这些数据被打包。浏览器将在标题中加入这一内容来执行 POST 请求。登录时可能会有许多 POST 和 redirect 请求。</p><p id="ccbd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要在 Scrapy 中做最简单的登录程序，我们可以使用 Scrapy 的 FormRequest 类。实际上，最好使用 FormRequests 方法之一来处理表单数据，但稍后会详细介绍！</p><p id="23eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们先看看它是如何工作的，然后在此基础上进行构建。为了在我们的 scrapy spider 中使用它，我们必须首先导入它。</p><pre class="nj nk nl nm gt nn nf no np aw nq bi"><span id="14e8" class="nr lv jj nf b gy ns nt l nu nv">from scrapy.http import FormRequest</span></pre><p id="e728" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们不再在蜘蛛的开头使用<code class="fe nc nd ne nf b">start_url</code>，而是使用<code class="fe nc nd ne nf b">start_requests()</code>方法。这允许我们使用与表单填充相关的方法。</p><p id="70c5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看 scrapy.spider 代码的底层，看看它是如何工作的。请记住，这是我们在启动蜘蛛时经常提到的地方。</p><p id="c688" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们从那个类中调用<code class="fe nc nd ne nf b">start_requests()</code>方法时，这就是隐藏的内容。</p><pre class="nj nk nl nm gt nn nf no np aw nq bi"><span id="9cc2" class="nr lv jj nf b gy ns nt l nu nv">def start_requests(self):<br/>    for url in self.start_urls:<br/>         yield self.make_requests_from_url(url)</span><span id="00bf" class="nr lv jj nf b gy nw nt l nu nv">def make_requests_from_url(self, url): <br/>    return Request(url, dont_filter=True)</span></pre><p id="e597" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们循环浏览<code class="fe nc nd ne nf b">start_urls</code>的每个网址。对于每个 url，我们使用<code class="fe nc nd ne nf b">scrapy.requests()</code>方法，并传递一个 URL 和一个名为 dont_filter 的关键字。现在<code class="fe nc nd ne nf b">dont_filter=True</code>意味着不过滤重复的请求。</p><p id="412d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用 FormRequest 子类，我们扩展了<code class="fe nc nd ne nf b">scrapy.http.Request</code>类。FormRequest 为我们提供了从响应中预填充表单字段的功能。我们扩展了<code class="fe nc nd ne nf b">scrapy.http.Request</code>,可以访问它所有的关键字参数。</p><p id="58f0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看这是什么样子。</p><pre class="nj nk nl nm gt nn nf no np aw nq bi"><span id="2ae6" class="nr lv jj nf b gy ns nt l nu nv">from scrapy.http import FormRequests<br/>import scrapy</span><span id="a871" class="nr lv jj nf b gy nw nt l nu nv">def start_requests(self):<br/>   return [<br/>      FormRequest("INSERT URL", formdata={"user":"user",   <br/>           "pass":"pass"}, callback=self.parse)]</span><span id="582f" class="nr lv jj nf b gy nw nt l nu nv">def parse(self,response):<br/>    pass</span></pre><p id="77fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">笔记</p><p id="9495" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1.默认的<code class="fe nc nd ne nf b">parse()</code>函数处理脚本的响应和规则，以获取您想要的数据。<br/> 2。对于函数<code class="fe nc nd ne nf b">start_request</code>，我们使用 FormRequest 类。我们向它提供一个 url 和关键字参数 formdata 以及我们的用户名和密码。</p><p id="dbef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.Scrapy 为我们处理饼干，而不需要我们在<code class="fe nc nd ne nf b">start_request</code>中具体说明。</p><p id="6c8f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.我们使用回调关键字参数将蜘蛛指向解析函数。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/881cb72a68d632436b6bd1cd010af82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GO4OcO9Of3GByOD9RnbHRA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@ambientpictures" rel="noopener ugc nofollow" target="_blank">莫哈末·阿拉姆</a>来自未喷涂</p></figure><h1 id="7c57" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">隐式数据</h1><p id="11a6" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">有些网站会要求您传递表单数据，这些数据乍一看似乎并不重要。登录，但有必要通过 cookies 认证网站。有时页面有一个隐藏的字段需要通过。获得该值的唯一方法是登录。</p><p id="98bd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这个问题，我们需要做两个请求，一个请求传递一些数据并捕获隐藏的字段数据。第二次请求登录。</p><p id="6003" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这次我们将使用一个<code class="fe nc nd ne nf b">start_request</code>函数，但是传递第一个请求。我们将处理回调以将信息传递给第二个函数。</p><p id="c773" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于第二个请求，我们将使用<code class="fe nc nd ne nf b">FormRequest.from_response()</code>方法。这个方法用我们指定的字段中填充的数据来模拟点击。返回一个新的 FormRequest 对象。这个对象的默认设置是模拟一个点击，这个点击有一个类型为<code class="fe nc nd ne nf b">&lt;input_type=submit&gt;</code>的可点击项目。</p><p id="72db" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在<code class="fe nc nd ne nf b">from_response()</code>方法中指定不同的方式。参考 scrapy 文档是明智的！例如，如果你不想让 scrapy 点击进入，你可以使用关键字<code class="fe nc nd ne nf b">dont_click=True</code>。来自<code class="fe nc nd ne nf b">from_response()</code>方法的所有参数都被传递给 FormRequest。</p><pre class="nj nk nl nm gt nn nf no np aw nq bi"><span id="85cd" class="nr lv jj nf b gy ns nt l nu nv">def start_requests():<br/>    return [<br/>       Request("URL", callback = self.parse_item)<br/>     ]</span><span id="afdf" class="nr lv jj nf b gy nw nt l nu nv">def parse_item(self,response):<br/>    return FormRequest.from_response(response, formdata= <br/>           {'user':'user', 'pass':'pass'})</span></pre><p id="ff42" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们从<code class="fe nc nd ne nf b">start_requests()</code>获取所需的头，然后将其传递给<code class="fe nc nd ne nf b">parse_item()</code></p><p id="bb9d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe nc nd ne nf b">FormRequest.from_response()</code>我们传递带有适当标题的表单数据。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/cd69d0c269604c24ac1db06c5db7e703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gf0-PGtZbPBYaJ0EB1h2eQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">特雷布雷·巴黑斯</p></figure><h1 id="3c68" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">浏览器认证基础知识</h1><p id="d9cd" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">HTTP 是一种无状态协议。这意味着从请求到响应，没有消息状态的记录。如果您作为一个请求登录，这将在另一个请求中被忘记。讨厌还是什么！</p><p id="543c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个解决方案是创建一个会话。当我们进行 POST 请求时，会在服务器数据库中创建一个会话。一个 cookie，它是一个字典，附加到带有会话 ID 的响应中。cookie 被返回给浏览器。</p><p id="18f6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们用这个 cookie 尝试另一个请求时，服务器会查找它并检查会话 ID。获取配置文件数据匹配，并将响应发送回浏览器。</p><p id="2bfa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Cookie 身份验证是有状态的。认证记录存储在客户端和服务器端。</p><p id="4f3e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了单页面应用程序，前端和后端的分离要复杂得多！当与另一个服务器联系时，我们从一个服务器获得的会话 cookie 将不起作用。这就是基于令牌的身份验证发挥作用的地方。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/ce0672e9d5a6f73a764baf3a78496c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i4TvKOxGXdb2NfTBsfrirQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@zenking" rel="noopener ugc nofollow" target="_blank">抢王</a>从未破土而出</p></figure><h1 id="7ea9" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">基于令牌的认证</h1><p id="6b5a" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">令牌是另一种浏览器身份验证方法。现在使用的标准令牌是 Json web 令牌(JWT)。</p><p id="392a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于令牌的认证的优点是它是无状态的。服务器不记录哪些用户登录。每个请求都有一个令牌，服务器用它来检查真实性。令牌通常在授权报头载体(JWT)中发送，但也可以在 POST 请求的主体中发送。</p><p id="9e7d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JWT 由三部分组成:报头、有效载荷和签名</p><pre class="nj nk nl nm gt nn nf no np aw nq bi"><span id="9efa" class="nr lv jj nf b gy ns nt l nu nv">###HEADER###<br/>{<br/>  "alg": "HS256",<br/>  "typ": "JWT"<br/>}</span><span id="9845" class="nr lv jj nf b gy nw nt l nu nv">###PAYLOAD###</span><span id="cc26" class="nr lv jj nf b gy nw nt l nu nv">{<br/>  "sub": "1234567890",<br/>  "name": "John Doe",<br/>  "iat": 1516239022<br/>}</span><span id="a640" class="nr lv jj nf b gy nw nt l nu nv">###SIGNATURE###</span><span id="15ed" class="nr lv jj nf b gy nw nt l nu nv">{<br/>  HMACSHA256(base64UrlEncode(header) + "." +           base64UrlEncode(payload),   <br/>secret)</span></pre><p id="0bee" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在 jwt 使用编码算法进行签名。例如 HMACSHA256，看起来像这样。</p><pre class="nj nk nl nm gt nn nf no np aw nq bi"><span id="b586" class="nr lv jj nf b gy ns nt l nu nv">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbyBLdWtpYyIsImFkbWluIjp0cnVlLCJpYXQiOjE0</span></pre><p id="14c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可以通过像<a class="ae jg" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank">这样的网站解码，知道数据没有加密是很重要的。</a></p><p id="fa03" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用户输入登录详细信息，令牌被附加。然后，服务器验证登录是否正确，然后发送的令牌被签名。这个令牌存储在客户端，但实际上可以存储为会话或 cookie。记住 cookie 是键和值的字典。</p><p id="7414" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对服务器的请求包括此令牌以进行身份验证。服务器对这个令牌进行解码，如果令牌有效，请求就会被发回。当用户注销时，令牌在客户端被销毁。不与服务器交互。这为我们提供了一些保障。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/dcd40ae7486b6f6a7a2e82458ab931ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGsRhR8cHM1AC-Ycxyyi_Q.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@zisun_word" rel="noopener ugc nofollow" target="_blank">孙富</a>从无到有</p></figure><h1 id="edfc" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">CSRF 是关于什么的？</h1><p id="7360" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">当谈到基于令牌的身份验证时，您会用到这个术语。所以了解它们是很有用的。这就是为什么基于令牌的认证变得流行的核心。</p><p id="2e5d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">CSRF 代表跨站点请求伪造，是一个网络安全漏洞。它允许攻击者让用户执行他们不想执行的操作。例如通过改变账户的电子邮件地址。</p><p id="f1b8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">CSRF 袭击的发生需要三个条件。首先是一个相关的动作，它是应用程序中有理由改变的东西。基于 cookie 的会话处理来进行身份验证，并且没有不可预测的请求参数。</p><p id="bdfe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这些，攻击者就可以创建一个带有表单的网页来更改电子邮件地址。用户输入数据，表单在对原始网站的请求中使用用户会话 cookie。而是使用新的电子邮件地址。</p><p id="7dce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了应对这种攻击，我们可以使用令牌来检查用户，而不是基于会话的 cookies。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nz"><img src="../Images/5c0e8b3d997bb6b0a398d812b8888982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECb78RQOAvMoHAJ-Ot3isg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">克林特·帕特森</p></figure><h1 id="a17e" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">使用 Scrapy 处理基于令牌的认证</h1><p id="40d0" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">为了确定是否有必要使用令牌，我们必须使用 chrome/firefox 开发工具。为此我们将刮掉 quotes.toscrape.com。我们模拟登录过程，看看发送了哪些报头。为此，我们在登录前滚动到网络选项卡，然后模拟一个登录过程。所有请求将出现在下面。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/571f323b9f45de0231e45e31399e188b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLTkfBLjAT04HePobS2nRA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Chrome 开发工具。红色方框显示登录过程</p></figure><p id="a81d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">选择左侧的登录名，我们可以看到下面的请求标题。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/1ca9c42c005faaf1e56794417a2a771b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESrmficQapEJTBr7OliGsw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">登录过程的请求标头。突出显示 CSRF 令牌</p></figure><p id="034d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您在表单数据中看到的,<code class="fe nc nd ne nf b">csrf_token</code>是存在的。</p><p id="1ffe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，当我们注销时，此令牌会被销毁。我们有必要在将它作为 POST 请求发送之前获取它。要做到这一点，我们必须看看 HTML。表单的 html 标签如下所示。</p><p id="8d7d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在这里看到表单字段&lt; 【T1】 </p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oc"><img src="../Images/45f2e3b33398f8dc23123bcd19baad75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uv51trCQYoxV8X62T6UzzQ.png"/></div></div></figure><h1 id="c3a5" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">XPATH Basics</h1><p id="f0b7" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">Now to do any scrapping it’s useful to go to the shell to see if the xpath selectors will work in your spider. So here we fetch the url and test out the xpath we need.</p><pre class="nj nk nl nm gt nn nf no np aw nq bi"><span id="12ff" class="nr lv jj nf b gy ns nt l nu nv">fetch("url")<br/>response.xpath('//*[@name='csrf_token']/@value').extract_first()</span></pre><p id="e629" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Output</p><pre class="nj nk nl nm gt nn nf no np aw nq bi"><span id="e271" class="nr lv jj nf b gy ns nt l nu nv">u'xUdwZpPyvkEJYTHOogcAaNFVzuhKtLejqBfbSXMQRCmWDrsinGlI'</span></pre><p id="ef2f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Lets break down the xpath selector.</p><p id="335d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">First xpath hands html documents as a tree and seperates the document out into nodes. The root node is parent to the document element  【T2】  . Element nodes represent html tags. Attribute nodes represent any attribute from an element node. Text nodes represent any text in the element nodes.</p><p id="0475" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">First  【T3】  is a  【T4】  which means it selects current node or any below it.  【T5】  means to select all nodes without comments or text nodes.</p><p id="782f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">We use  【T6】  to specify the attribute  【T7】  and  【T8】  after this to specify it’s value.  【T9】  will grab the first value it finds.</p><p id="6826" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">So we have our xpath selector to get the  【T10】 , we can then use this to pass onto the FormRequest</p><p id="251e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Now that we have that understanding we can look at the code for using it.</p><pre class="nj nk nl nm gt nn nf no np aw nq bi"><span id="b5f2" class="nr lv jj nf b gy ns nt l nu nv">import scrapy<br/>from scrapy.http import FormRequests</span><span id="08e8" class="nr lv jj nf b gy nw nt l nu nv">class LoginSpider(Scrapy.spider):<br/>    name = 'login'<br/>    allowed_domains = ['quotes.toscrape.com']<br/>    start_urls = ['<a class="ae jg" href="http://quotes.toscrape.com/login" rel="noopener ugc nofollow" target="_blank">http://quotes.toscrape.com/login</a>']</span><span id="3226" class="nr lv jj nf b gy nw nt l nu nv">def parse(self,response):<br/>        csrf_token = response.xpath('//*[@name='csrf_token']<br/>                     /@value').extract_first()')</span><span id="3c41" class="nr lv jj nf b gy nw nt l nu nv">        yield FormRequests.from_response(response, formdata={'csrf_token': csrf_token, 'user':'user', 'pass','pass'}, callback=self.parse_after_login)</span><span id="bd1a" class="nr lv jj nf b gy nw nt l nu nv">def parse_after_login(self,response):<br/>    pass</span></pre><p id="0207" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Notes <br/> 1。我们像以前一样导入 scrapy 和表单请求</p><p id="9dde" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.我们填充变量<code class="fe nc nd ne nf b">name</code>、<code class="fe nc nd ne nf b">allowed_domains</code>和<code class="fe nc nd ne nf b">start_urls</code>。</p><p id="fac8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.我们将<code class="fe nc nd ne nf b">csrf_token</code>分配给登录页面中令牌的 xpath 选择器值。</p><p id="72e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.使用 FormRequests 子类，我们指定响应，并输入我们想要的表单数据。在这种情况下，我们指定了<code class="fe nc nd ne nf b">csrf_token</code>以及用户名和密码。<br/> 5。登录成功后，使用回调将蜘蛛指向该函数。</p><p id="bdc2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唷！很难通过。希望让 Scrapy 的登录程序更易管理。下次见！</p><h1 id="b3b0" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">关于作者</h1><p id="e55e" class="pw-post-body-paragraph ky kz jj la b lb mo kk ld le mp kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">我是一名医学博士，对教学、python、技术和医疗保健有浓厚的兴趣。我在英国，我教在线临床教育以及运行 www.coding-medics.com<a class="ae jg" href="http://www.coding-medics.com./" rel="noopener ugc nofollow" target="_blank">网站。</a></p><p id="3e55" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过 asmith53@ed.ac.uk 或 twitter <a class="ae jg" href="https://twitter.com/AaronSm46722627" rel="noopener ugc nofollow" target="_blank">这里</a>联系我，欢迎所有意见和建议！如果你想谈论任何项目或合作，这将是伟大的。</p><p id="240e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更多技术/编码相关内容，请点击这里注册我的简讯<a class="ae jg" href="https://aaronsmith.substack.com/p/coming-soon?r=6yuie&amp;utm_campaign=post&amp;utm_medium=web&amp;utm_source=copy" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="c737" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">相关文章</h1><div class="is it gp gr iu od"><a rel="noopener follow" target="_blank" href="/how-to-download-files-using-python-ffbca63beb5c"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jk gy z fp oi fr fs oj fu fw ji bi translated">如何使用 Python 下载文件</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">了解如何使用 Python 下载 web 抓取项目中的文件</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdatascience.com</p></div></div><div class="om l"><div class="on l oo op oq om or ja od"/></div></div></a></div><div class="is it gp gr iu od"><a href="https://medium.com/swlh/5-python-tricks-you-should-know-d4a8b32e04db" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jk gy z fp oi fr fs oj fu fw ji bi translated">你应该知道的 5 个 Python 技巧</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">如何轻松增强 python 的基础知识</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="os l oo op oq om or ja od"/></div></div></a></div></div></div>    
</body>
</html>