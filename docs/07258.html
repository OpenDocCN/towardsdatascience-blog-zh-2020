<html>
<head>
<title>Selecting Rows with .loc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">选择行时使用。通信线路（LinesofCommunication）</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/selecting-rows-with-loc-276d217c4ea5?source=collection_archive---------33-----------------------#2020-06-02">https://towardsdatascience.com/selecting-rows-with-loc-276d217c4ea5?source=collection_archive---------33-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="21e3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据科学/ Python代码片段</h2><div class=""/><div class=""><h2 id="9cf4" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">从熊猫数据框架中选择数据子集的初学者指南。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/981f39ef262c54b43287cea15b7ca479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aZ_gSuliKZ2xakpBFBRIWQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@chuttersnap?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丘特尔斯纳普</a>在<a class="ae lh" href="https://unsplash.com/s/photos/organization?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="e878" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">作为数据科学家，我们大部分时间都在用熊猫处理数据。在本帖中，我们将关注。根据一些预定义的条件来选择行。</em></p><p id="7dcf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">我们打开Jupyter笔记本，我们来扯皮吧！</em></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="a4df" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">数据</h1><p id="f7de" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">我们将使用来自圣安东尼奥市开放数据网站<a class="ae lh" href="https://data.sanantonio.gov/dataset/service-calls" rel="noopener ugc nofollow" target="_blank">的311服务呼叫数据集来说明不同之处。锁定技术有效。</a></p><h1 id="4eb7" class="mm mn it bd mo mp nj mr ms mt nk mv mw ki nl kj my kl nm km na ko nn kp nc nd bi translated">家政</h1><p id="4aff" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">在我们开始之前，让我们先做一点家务。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3931" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里没什么特别的。我们只是导入强制的Pandas库并设置显示选项，这样当我们检查数据帧时，列和行就不会被Jupyter截断。我们将它设置为显示单个单元格中的每个输出，而不仅仅是最后一个。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6638" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码中，我们定义了一个函数，它将向我们显示缺失值或空值的数量及其百分比。</p><h1 id="c3e3" class="mm mn it bd mo mp nj mr ms mt nk mv mw ki nl kj my kl nm km na ko nn kp nc nd bi translated">获取数据</h1><p id="26fc" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">让我们将数据加载到数据帧中。</p><p id="5362" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">快速浏览一下<code class="fe nq nr ns nt b">df.head()</code>,我们将看到前五行数据:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nu"><img src="../Images/4eb2e14f8ffc94d4c1aa12cbc334a8d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFmM96QTAa506DkYxXRdaQ.png"/></div></div></figure><p id="b3ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">而<code class="fe nq nr ns nt b">df.info()</code>将让我们看到列的数据类型。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nv"><img src="../Images/a2dcb8ac32ff4f804b982e74d8efa355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ysXUWQOBTKK3COAOBjW2lQ.png"/></div></div></figure><p id="9db8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，<code class="fe nq nr ns nt b">show_missing(df)</code>向我们显示数据中是否有丢失的值。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/304eec4175770dda52b82e60aef778df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-E42wm8b89TzZo1G-BTEWQ.png"/></div></div></figure><h1 id="cb7d" class="mm mn it bd mo mp nj mr ms mt nk mv mw ki nl kj my kl nm km na ko nn kp nc nd bi translated">选择列是否为空的行。</h1><p id="eacb" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">让我们选择<code class="fe nq nr ns nt b">'Dept'</code>列有空值的行，并过滤排除了空值的数据帧。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ddfb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们对“Dept”列进行了值计数。方法<code class="fe nq nr ns nt b">.value_counts()</code>返回一个熊猫系列，列出指定列的所有值及其频率。默认情况下，该方法忽略NaN值，并且不会列出它。但是，如果您包含参数<code class="fe nq nr ns nt b">dropna=False</code>，它将在结果中包含任何NaN值。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5cceefd0b5fce456e52bb52dc9d6e0ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*5gf2JO6aqeD_wB-EB3GHXQ.png"/></div></figure><p id="23f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，行<code class="fe nq nr ns nt b">df_null = df.loc[df['Dept'].isnull()]</code>告诉计算机选择<code class="fe nq nr ns nt b">df</code>中列<code class="fe nq nr ns nt b">'Dept'</code>为空的行。产生的数据帧被分配给<code class="fe nq nr ns nt b">df_null</code>，它的所有行将作为“Dept”列中的值。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ny"><img src="../Images/d90ca68369d5fb54089d14afecb9e24f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l77B_3qBps3S0S9hb6nMiQ.png"/></div></div></figure><p id="6ab5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类似地，行<code class="fe nq nr ns nt b">df_notnull = df.loc[df['Dept'].notnull()]</code>告诉计算机选择<code class="fe nq nr ns nt b">df</code>中列<code class="fe nq nr ns nt b">'Dept'</code>不为空的行。产生的数据帧被分配给<code class="fe nq nr ns nt b">df_notnull</code>，并且它的所有行在‘Dept’列中没有任何NaN值。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/79b0282521cacae809b8861950abcd34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hcDuQzuWKNjS8JDkWHfoYg.png"/></div></div></figure><p id="c73d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这两种技术的一般语法如下:</p><pre class="ks kt ku kv gt oa nt ob oc aw od bi"><span id="b90b" class="oe mn it nt b gy of og l oh oi">df_new = df_old.loc[df_old['Column Name'].isnull()]<br/>df_new = df_old.loc[df_old['Column Name'].notnull()]</span></pre><h1 id="aa63" class="mm mn it bd mo mp nj mr ms mt nk mv mw ki nl kj my kl nm km na ko nn kp nc nd bi translated">选择列为特定值的行。</h1><p id="0f06" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated"><code class="fe nq nr ns nt b">'Late (Yes/No)'</code>专栏看起来很有趣。让我们来看看吧！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b11c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，我们对<code class="fe nq nr ns nt b">'Late (Yes/No)'</code>列进行了快速的数值计算。然后，我们过滤掉那些晚于<code class="fe nq nr ns nt b">df_late = df.loc[df['Late (Yes/No)'] == 'YES']</code>的案例。类似地，我们反其道而行之，将<code class="fe nq nr ns nt b">'YES'</code>改为<code class="fe nq nr ns nt b">'NO'</code>，并将其分配给不同的数据帧<code class="fe nq nr ns nt b">df_notlate</code>。</p><p id="52f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了在列和我们想要比较的值之间增加了一个<code class="fe nq nr ns nt b">==</code>符号之外，语法和前面的例子没有太大的不同。它基本上是针对每一行，询问特定列(左侧)上的值是否与我们指定的值(右侧)相匹配。如果匹配为真，则在结果中包含该行。如果匹配是假的，它忽略它。</p><p id="6013" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是<code class="fe nq nr ns nt b">df_late</code>的结果数据帧:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/47a8947d02b74418095835719dadf802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0RgPoEcglOPDQivP6n7Usg.png"/></div></div></figure><p id="ed03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是给<code class="fe nq nr ns nt b">df_notlate</code>的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ny"><img src="../Images/42f13431fc8f256d51c9d9743deb62a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XYmFVZaoEMt93C4o6GqD6A.png"/></div></div></figure><p id="973b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种技术的一般语法是:</p><pre class="ks kt ku kv gt oa nt ob oc aw od bi"><span id="2d75" class="oe mn it nt b gy of og l oh oi">df_new = df_old.loc[df_old['Column Name'] == 'some_value' ]</span></pre><h1 id="44a3" class="mm mn it bd mo mp nj mr ms mt nk mv mw ki nl kj my kl nm km na ko nn kp nc nd bi translated">选择列不是特定值的行。</h1><p id="0e0d" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">我们已经学习了如何基于“是”和“否”来选择行，但是如果值不是二进制的呢？例如，让我们看看“类别”列:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/85d047e4ff03fda57ac8ee7feeeb8059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*uPcBWxg9qwEmFZhFeuRgCg.png"/></div></figure><p id="ac71" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">192，197行或记录没有分配类别，但是我们得到的不是NaN、empty或null值，而是类别本身。如果我们想过滤掉这些呢？回车:<code class="fe nq nr ns nt b">!=</code>操作符。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1873" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">像往常一样，我们对<code class="fe nq nr ns nt b">'Category'</code>列进行了常规值计数，以查看我们正在处理的内容。然后，我们创建了<code class="fe nq nr ns nt b">df_categorized</code>数据帧，以包含<code class="fe nq nr ns nt b">df</code>数据帧中任何在<code class="fe nq nr ns nt b">'Category'</code>列中没有<code class="fe nq nr ns nt b">'No Category'</code>值的记录。</p><p id="94c5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是对<code class="fe nq nr ns nt b">df_categorized</code>数据帧的<code class="fe nq nr ns nt b">'Category'</code>列进行数值计算的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/8cba9c4eb560b460d98ae9d94615e675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*AFIB9lKc2tkWiSadgFFu2w.png"/></div></figure><p id="04be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上面的截图所示，值计数保留了除“无类别”之外的所有内容。</p><p id="5be4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种技术的一般语法是:</p><pre class="ks kt ku kv gt oa nt ob oc aw od bi"><span id="ee09" class="oe mn it nt b gy of og l oh oi">df_new = df_old.loc[df_old['Column Name'] != 'some_value' ]</span></pre><h1 id="a710" class="mm mn it bd mo mp nj mr ms mt nk mv mw ki nl kj my kl nm km na ko nn kp nc nd bi translated">基于多个条件选择行。</h1><p id="86d3" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">让我们考虑下面的列，<code class="fe nq nr ns nt b">'Late (Yes/No)'</code>和<code class="fe nq nr ns nt b">'CaseStatus':</code></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/6150fe90f66f601f629457019e180334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xrDTqOWi9bevm1bd0WIEeQ.png"/></div></div></figure><p id="68b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们想知道现在哪些打开的案例已经通过了SLA(服务级别协议),该怎么办？我们需要使用多个条件来过滤新数据框架中的案例或行。输入<code class="fe nq nr ns nt b">&amp;</code>符。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="06a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">语法与前面的相似，除了在括号中引入了<code class="fe nq nr ns nt b">&amp;</code>操作符。在<code class="fe nq nr ns nt b">df_late_open = df.loc[(df[‘Late (Yes/No)’] == ‘YES’) &amp; (df[‘CaseStatus’] == ‘Open’)]</code>这条线上，有两个条件:</p><ol class=""><li id="bbe3" class="on oo it lk b ll lm lo lp lr op lv oq lz or md os ot ou ov bi translated"><code class="fe nq nr ns nt b">(df[‘Late (Yes/No)’] == ‘YES’)</code></li><li id="b5c8" class="on oo it lk b ll ow lo ox lr oy lv oz lz pa md os ot ou ov bi translated"><code class="fe nq nr ns nt b">(df[‘CaseStatus’] == ‘Open’)</code></li></ol><p id="4ba0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们希望这两个都为真来匹配一行，所以我们在它们之间包含了操作符<code class="fe nq nr ns nt b">&amp;</code>。简单地说，<code class="fe nq nr ns nt b">&amp;</code>位操作符就是AND的意思。其他按位运算符包括表示or的管道符号<code class="fe nq nr ns nt b">|</code>和表示NOT的波浪号<code class="fe nq nr ns nt b">~</code>。我鼓励您尝试使用这些按位运算符，以便更好地了解它们能做什么。只要记住将每个条件用括号括起来，这样就不会混淆Python。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pb"><img src="../Images/1b4df24d76c4f1b9d2d3f6af739a474d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yirIanjIwpZ9EUj83w4VQg.png"/></div></div></figure><p id="e3a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种技术的一般语法是:</p><pre class="ks kt ku kv gt oa nt ob oc aw od bi"><span id="b938" class="oe mn it nt b gy of og l oh oi">df_new = df_old.loc[(df_old['Column Name 1'] == 'some_value_1') &amp; (df['Column Name 2'] == 'some_value_2')]</span></pre><h1 id="465c" class="mm mn it bd mo mp nj mr ms mt nk mv mw ki nl kj my kl nm km na ko nn kp nc nd bi translated">选择列值属于某个值列表的行。</h1><p id="1d38" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">让我们看看<code class="fe nq nr ns nt b">'Council District'</code>列的值计数:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/da28efd092fc10faa7ea05be3be8e8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovpfjZ9HerkxdE_wLuaAvQ.png"/></div></div></figure><p id="2f68" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们想把重点放在第2区、第3区、第4区和第5区，因为它们位于圣安东尼奥南部，并且以城市服务质量差而闻名，会怎么样？(顺便说一句，这完全是我瞎编的！)在这种情况下，我们可以像这样使用<code class="fe nq nr ns nt b">.isin()</code>方法:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="68bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">记得在<code class="fe nq nr ns nt b">.isin()</code>方法中像<code class="fe nq nr ns nt b">['choice1', 'choice2', 'choice3']</code>一样传递你的选择，否则会导致错误。对于我们例子中的整数，没有必要包含引号，因为引号只适用于字符串值。</p><p id="0914" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我们新数据框架<code class="fe nq nr ns nt b">df_south</code>的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pd"><img src="../Images/947995249434ae81577a5d73a3862a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3v8dfsxiEUzvFTBAwvJwRw.png"/></div></div></figure><p id="e349" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种技术的一般语法是:</p><pre class="ks kt ku kv gt oa nt ob oc aw od bi"><span id="3e87" class="oe mn it nt b gy of og l oh oi">df_new = df_old.loc[df_old[Column Name'].isin(['choice1', 'choice2', 'choice3'])]</span></pre><h1 id="cdc5" class="mm mn it bd mo mp nj mr ms mt nk mv mw ki nl kj my kl nm km na ko nn kp nc nd bi translated">结论</h1><p id="46a0" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">就是这样！在本文中，我们将311服务调用数据加载到一个数据帧中，并使用<code class="fe nq nr ns nt b">.loc</code>方法创建了数据子集。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="4f11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读！我希望你喜欢今天的帖子。数据争论，至少对我来说，是一项有趣的练习，因为这是我第一次了解数据的阶段，它给了我一个机会来磨练我在面对真正混乱的数据时解决问题的技能。快乐的争吵的人们！</p><p id="fec4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">敬请期待！</em></p><p id="7772" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以通过推特或T2【LinkedIn】联系我。</p><p id="af0f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[1]圣安东尼奥市公开数据。(2020年5月31日)。<em class="me"> 311服务电话。</em><a class="ae lh" href="https://data.sanantonio.gov/dataset/service-calls" rel="noopener ugc nofollow" target="_blank">https://data.sanantonio.gov/dataset/service-calls</a></p></div></div>    
</body>
</html>