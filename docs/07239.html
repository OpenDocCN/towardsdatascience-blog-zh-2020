<html>
<head>
<title>JavaScript Charts on Jupyter Notebooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jupyter 笔记本上的 JavaScript 图表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/javascript-charts-on-jupyter-notebooks-dd25f794cf6a?source=collection_archive---------14-----------------------#2020-06-02">https://towardsdatascience.com/javascript-charts-on-jupyter-notebooks-dd25f794cf6a?source=collection_archive---------14-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d34e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用漂亮的 JavaScript 可视化将 Jupyter 推向新的高度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/055b22acf957224a8546cb22c30ebeb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*haad755DmUeVX3Zu8n8tqA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片是我的</p></figure><p id="2fe3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">作为一名专业人士，我喜欢把自己想象成数据科学家和前端开发人员的混合体。我在工作中真正喜欢的，是处理涉及这两个部分的项目。<strong class="la iu">然而，很多时候，我们没有时间去设计和实现一个完整的 web 应用程序，一个可靠的客户端-服务器架构和一个超级可重用的用户界面:在这种情况下，我们需要回到更快的东西。</strong></p><p id="065f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在接下来的文章中，我将向你展示如何给 Jupyter 笔记本加类固醇，实现<strong class="la iu">，一个交互式的可过滤的可视化，只需要几行 JavaScript </strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/b5da6d4bae9be17f1bd8a0aca9833556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*udNM68PHun6hFown.gif"/></div></div></figure><h1 id="93d3" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">工具</h1><p id="4cc5" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">我们需要为数据可视化选择一个 JS 库。我们有几乎无限的选择；对于本指南，我们希望选择一些易于使用的东西。一些例子包括<a class="ae nb" href="https://www.highcharts.com/demo/" rel="noopener ugc nofollow" target="_blank"> Highcharts </a>、<a class="ae nb" href="https://echarts.apache.org/en/index.html" rel="noopener ugc nofollow" target="_blank"> ECharts </a>或<a class="ae nb" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> d3.js </a>，</p><p id="229d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">我们将使用 ECharts </strong>，这是一个允许毫不费力地创建超级花哨的可视化效果的框架。该库最初是在百度开发的，但现在在 Apache 孵化器中。它是根据 Apache-2.0 许可的。</p><p id="d6b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> JavaScript 可能并不总是数据科学家的武器库</strong>(我发现这种语言的知识在具有计算机科学/编程背景的人中更常见)。<strong class="la iu">如果你不知道 JavaScript，那么考虑一下这些库使图表的生成变得非常容易</strong>(如果你正在寻找非常复杂的交互，可能还需要做更多的工作)。ECharts 网站包含了<strong class="la iu">大量复制粘贴的例子，展现了几乎所有的特性</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/6f04c6d06955f5c4affb8950fb103dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PAAzdTRSCPFjM8OYcITcNw.png"/></div></div></figure><p id="f38f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用这些工具，唯一的“硬”工作就是处理数据，将它们转换成适合我们选择的特定图表类型的格式。</p><h2 id="9010" class="nd mf it bd mg ne nf dn mk ng nh dp mo lh ni nj mq ll nk nl ms lp nm nn mu no bi translated">数据</h2><p id="d309" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">我们将使用<a class="ae nb" href="https://www.google.com/covid19/mobility/data_documentation.html?hl=en" rel="noopener ugc nofollow" target="_blank"> <em class="np">谷歌新冠肺炎社区移动报告</em> </a> <em class="np"> * </em>数据<em class="np">。</em>这个数据集包含了每个国家在一个地理区域[<a class="ae nb" href="https://www.google.com/covid19/mobility/data_documentation.html?hl=en" rel="noopener ugc nofollow" target="_blank"><em class="np">1</em></a><em class="np">]，【T25 内去杂货店和公园等地方的百分比变化，它是由谷歌设计来帮助抗击新冠肺炎的。让我们来看一段摘录并描述一下这些列:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="109c" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">country_region_code</code>:国家代码。我们将从分析中过滤掉这个字段。</li><li id="f47e" class="ns nt it la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">country_region</code>:国家名称。</li><li id="7af4" class="ns nt it la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">sub_region_1</code>和<code class="fe ob oc od oe b">sub_region_2</code>:地理区域的两个更精细的视图。对于我们想要实现的图表，我们可以过滤掉这些。我们将只考虑<code class="fe ob oc od oe b">sub_region_1</code>为<code class="fe ob oc od oe b">null</code>的行(因此我们只考虑汇总数据，而不考虑每个子区域的信息)</li><li id="5fa0" class="ns nt it la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">date</code>:简单的日期。</li><li id="d628" class="ns nt it la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">retail_and_recreation_percent_change_from_baseline</code> : <em class="np">餐馆、咖啡馆、购物中心、主题公园、博物馆、图书馆和电影院等场所的移动趋势。【</em><a class="ae nb" href="https://www.google.com/covid19/mobility/data_documentation.html?hl=en" rel="noopener ugc nofollow" target="_blank"><em class="np">2</em></a><em class="np">】</em></li><li id="135e" class="ns nt it la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">grocery_and_pharmacy_percent_change_from_baseline</code> : <em class="np">杂货店、食品仓库、农贸市场、特色食品店、药店和药房等场所的移动趋势。【</em><a class="ae nb" href="https://www.google.com/covid19/mobility/data_documentation.html?hl=en" rel="noopener ugc nofollow" target="_blank"><em class="np">2</em></a><em class="np">】</em></li><li id="2872" class="ns nt it la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">parks_percent_change_from_baseline</code> : <em class="np">当地公园、国家公园、公共海滩、码头、狗公园、广场和公园等地的移动趋势。【</em><a class="ae nb" href="https://www.google.com/covid19/mobility/data_documentation.html?hl=en" rel="noopener ugc nofollow" target="_blank"><em class="np">2</em></a><em class="np">】</em></li><li id="06db" class="ns nt it la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">transit_stations_percent_change_from_baseline</code> : <em class="np">地铁、公交、火车站等公共交通枢纽的移动趋势。【</em><a class="ae nb" href="https://www.google.com/covid19/mobility/data_documentation.html?hl=en" rel="noopener ugc nofollow" target="_blank"><em class="np">2</em></a><em class="np">】</em></li><li id="b542" class="ns nt it la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">workplaces_percent_change_from_baseline</code> : <em class="np">工作场所的移动趋势。【</em><a class="ae nb" href="https://www.google.com/covid19/mobility/data_documentation.html?hl=en" rel="noopener ugc nofollow" target="_blank"><em class="np">2</em></a><em class="np">】</em></li><li id="673a" class="ns nt it la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">residential_percent_change_from_baseline</code> : <em class="np">居住地流动趋势。【</em><a class="ae nb" href="https://www.google.com/covid19/mobility/data_documentation.html?hl=en" rel="noopener ugc nofollow" target="_blank"><em class="np">2</em></a><em class="np">】</em></li></ul><p id="4af0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了，我们需要的东西都有了，让我们开始研究代码吧！</p><blockquote class="ok ol om"><p id="07bf" class="ky kz np la b lb lc ju ld le lf jx lg on li lj lk oo lm ln lo op lq lr ls lt im bi translated">*谷歌有限责任公司<em class="it">“谷歌新冠肺炎社区移动性报告”</em>。<br/>https://www.google.com/covid19/mobility/访问:&lt;日期&gt;。</p></blockquote><h1 id="d3dc" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">你好世界！</h1><p id="f6fd" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">本文的主题不是用 ECharts 创建一个超级漂亮的图表，而是展示如何在 Jupyter 笔记本上启用这个功能。<strong class="la iu">出于这个原因，我们将只实现一个可视化:一个多线图，显示数据集</strong>中可用的每个 KPI 的时间序列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/312b11d757b1b50173e673aaedbf2efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0Mh3sHhkFCFC2RsdD2cQw.png"/></div></div></figure><p id="48c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Jupyter 单元可以解释各种类型的内容，从 Python 代码到 Markdown。注入 JavaScript 代码有多难？幸运的是，对我们来说，这就像使用一个<a class="ae nb" href="https://ipython.readthedocs.io/en/stable/interactive/magics.html" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">Jupyter magic</strong></a><strong class="la iu">一样简单！</strong>通过单元格魔术，我们可以指示笔记本以特定的方式读取单元格内容，对于 JavaScript 我们可以使用<code class="fe ob oc od oe b">%%javascript</code>魔术。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="71c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太棒了。<strong class="la iu">我们知道如何在单元格中写 JS。工作流程应该如下</strong>:</p><ol class=""><li id="f234" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt or ny nz oa bi translated">我们<strong class="la iu">使用 Pandas </strong>读取 CSV，并根据需要对数据集进行预处理。</li><li id="5135" class="ns nt it la b lb of le og lh oh ll oi lp oj lt or ny nz oa bi translated"><strong class="la iu">虽然仍然在 Python 代码中，但我们将数据转换成 JSON 字符串</strong>，这样我们就可以很容易地在 JavaScript 中操作它。</li><li id="822d" class="ns nt it la b lb of le og lh oh ll oi lp oj lt or ny nz oa bi translated"><strong class="la iu">我们<em class="np">将 JSON </em>传递给 JavaScript 代码</strong>来生成可视化。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/fe4c694785567cdfea6956f61010ccee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RY-rLZhTIpBRq3vOWK4wqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">只是一个模式来了解数据流</p></figure><p id="545d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">最简单的方法是将所有的 Python 代码组织在一个函数</strong>中，在我们的例子中称为<code class="fe ob oc od oe b">get_data()</code>。对于这个<strong class="la iu">第一个</strong>示例，我们将只显示与<code class="fe ob oc od oe b">retail_and_recreation_percent_change_from_baseline</code>指示器相关的时间序列。</p><p id="0d43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将提供给 JavaScript 的 JSON 将具有以下形式:</p><pre class="kj kk kl km gt ot oe ou ov aw ow bi"><span id="c428" class="nd mf it oe b gy ox oy l oz pa">{<br/>  "dates":[&lt;array of all the dates (sorted)&gt;],<br/>  "country_data":[<br/>     {"name":"Country Name 1",<br/>      "data":[&lt;array of all the KPI's values, sorted by date&gt;]<br/>     }, <br/>     ...<br/>     {"name":"Country Name N-1",<br/>      "data":[&lt;array of all the KPI's values, sorted by date&gt;]<br/>     }, {"name":"Country Name N",<br/>      "data":[&lt;array of all the KPI's values, sorted by date&gt;]<br/>     },<br/>   ]<br/>}</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e70a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此时，我们有了数据:<strong class="la iu">我们只需要在 JavaScript 单元格</strong>中访问它们。首先，我们需要导入 ECharts:为此，我们可以使用一个名为<code class="fe ob oc od oe b">requirejs</code>的模块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d826" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">稍后，我们将能够使用上面的方法在<code class="fe ob oc od oe b">ech</code>变量中存储 ECharts 对象。</p><p id="1668" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">为了让 JS 和 Python 交流，我们必须在某个地方存储</strong> <code class="fe ob oc od oe b"><strong class="la iu">get_data()</strong></code> <strong class="la iu">函数</strong>的结果。让所有其他单元格都可以访问数据的一个非常简单的方法是将输出保存在一个<code class="fe ob oc od oe b">window</code>属性中:也就是说，我们将把 JSON 字符串保存在全局变量<code class="fe ob oc od oe b">window.outputVar</code>中。<strong class="la iu">虽然在</strong> <code class="fe ob oc od oe b"><strong class="la iu">window</strong></code> <strong class="la iu">中存储东西几乎从来都不是 JavaScript 开发的最佳实践，但我认为我们可以接受这种妥协来保持代码简单一点</strong>。</p><p id="408c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe ob oc od oe b">%%javascript</code>单元格中，我们可以使用<code class="fe ob oc od oe b">IPython.notebook.kernel.execute()</code>函数执行 Python 代码。没有深入研究细节(<a class="ae nb" href="https://github.com/jupyter/notebook/issues/2219" rel="noopener ugc nofollow" target="_blank">不幸的是，这个函数似乎缺少好的文档</a>)，这个函数接受一个字符串作为第一个参数:<strong class="la iu">这个字符串是将要执行的实际 Python 代码(因此我们将所有内容存储在一个函数中，以使这部分更简洁)</strong>。<br/>第二个参数描述 Python 之后需要执行哪些 JavaScript 回调。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7f62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae nb" href="https://codeburst.io/javascript-what-the-heck-is-a-callback-aba4da2deced" rel="noopener" target="_blank">我们之所以不能“简单地返回”</a> <code class="fe ob oc od oe b"><a class="ae nb" href="https://codeburst.io/javascript-what-the-heck-is-a-callback-aba4da2deced" rel="noopener" target="_blank">get_data()</a></code> <a class="ae nb" href="https://codeburst.io/javascript-what-the-heck-is-a-callback-aba4da2deced" rel="noopener" target="_blank">结果，而是需要一个“回调”和一个全局外部变量，这是我在本文中不谈论的，以免偏离实际主题。然而，上面发生的事情简单如下:</a></p><ol class=""><li id="f666" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt or ny nz oa bi translated">执行<code class="fe ob oc od oe b">get_data()</code>功能。</li><li id="fb34" class="ns nt it la b lb of le og lh oh ll oi lp oj lt or ny nz oa bi translated">执行之后，一个 JavaScript 函数读取结果，删除一些不需要的字符(快速而肮脏的解决方案，抱歉)，<strong class="la iu">将字符串转换为 JSON 对象，并将 JSON 保存在一个变量中，这个变量现在可以在页面</strong>中全局访问。</li></ol><p id="343d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">最后，好玩的部分！让我们深入到 ECharts 示例中，找到一个适合我们需要的可视化效果</strong>(想法是只复制-粘贴-编辑一些代码):<a class="ae nb" href="https://echarts.apache.org/examples/en/editor.html?c=line-stack" rel="noopener ugc nofollow" target="_blank">堆积折线图应该是一个很好的起点</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/4d02fc68ae4623e40f48c2ff62c92642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vd7xMGK_afE8tg_OZCyKow.png"/></div></div></figure><p id="4f67" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简单来说，<strong class="la iu">ECharts viz 生成分三步进行</strong>:</p><ol class=""><li id="cc0d" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt or ny nz oa bi translated">创建将包含可视化效果的 HTML 元素。</li><li id="ba5f" class="ns nt it la b lb of le og lh oh ll oi lp oj lt or ny nz oa bi translated">在元素上初始化 ECharts 对象</li><li id="53b3" class="ns nt it la b lb of le og lh oh ll oi lp oj lt or ny nz oa bi translated">通过<code class="fe ob oc od oe b">setOption</code>方法设置图表选项。“选项”只是一个 JSON 对象，指示 ECharts 做什么。</li></ol><p id="fd04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了所有视觉上的细微差别(颜色、工具提示等。)，<strong class="la iu">最重要的部分在于从上面</strong>的 JSON 开始生成数据。我们需要创建两个对象:一个用于 x 轴，另一个用于 y 轴。</p><p id="5523" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">x 轴数值<br/> </strong>这将包含我们想要显示的所有日期。<strong class="la iu">该列表需要保存在图表选项</strong>的 <code class="fe ob oc od oe b"><strong class="la iu">xAxis</strong></code> <strong class="la iu">属性中:</strong></p><pre class="kj kk kl km gt ot oe ou ov aw ow bi"><span id="6ef2" class="nd mf it oe b gy ox oy l oz pa">xAxis: {<br/>        type: 'category',<br/>        data: [&lt;array with all the dates (sorted)&gt;]<br/>       },</span></pre><p id="4efb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">系列<br/> </strong>这将包含我们想要显示的实际数据。<strong class="la iu"/><code class="fe ob oc od oe b"><strong class="la iu">series</strong></code><strong class="la iu">属性由一个对象数组组成，其中每个元素都是图表</strong>中的一行:</p><pre class="kj kk kl km gt ot oe ou ov aw ow bi"><span id="eee1" class="nd mf it oe b gy ox oy l oz pa">series: [<br/>    {<br/>            name: 'Country 1',<br/>            type: 'line',<br/>            data: [&lt;Array with values for each date&gt;]<br/>    },<br/>        ...<br/>    {<br/>            name: 'Country N',<br/>            type: 'line',<br/>            data: [&lt;Array with values for each date&gt;]<br/>        },<br/>]</span></pre><p id="9e37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成 viz 的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="351a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，所有代码都保存在一个函数中，这个函数存储在<strong class="la iu">中，同样，在<code class="fe ob oc od oe b">window</code>全局对象中:(</strong>；<strong class="la iu">最后一步是做最后的调用</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8ab4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，在上面的例子中，我们将<code class="fe ob oc od oe b">element</code>变量传递给了<code class="fe ob oc od oe b">buildChart()</code>函数。<strong class="la iu">EChart 可视化将追加到</strong> <code class="fe ob oc od oe b"><strong class="la iu">element</strong></code> <strong class="la iu">(即执行</strong> <code class="fe ob oc od oe b"><strong class="la iu">buildChart()</strong></code> <strong class="la iu">功能的单元格)</strong>。输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/9f2b1223760b590616b2a70358ad02d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NEWXAde1fqnVyKYRf--nFA.gif"/></div></div></figure><h1 id="a647" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">添加过滤器</h1><p id="37c8" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">两个问题:<strong class="la iu">第一，图表不可读——线太多——第二，我们只能看到其中一个指标</strong>。我们真的希望有两个 HTML 元素来选择想要显示的国家和 KPI。有多种方法可以做到这一点，我们将选择最简单的一种！</p><p id="38ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">我们需要稍微修改</strong> <code class="fe ob oc od oe b"><strong class="la iu">build_data()</strong></code> <strong class="la iu">来返回所有的 KPI</strong>。让我们将该功能重命名为<code class="fe ob oc od oe b">build_data_all()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6dce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的 JSON 结构如下:</p><pre class="kj kk kl km gt ot oe ou ov aw ow bi"><span id="c6bc" class="nd mf it oe b gy ox oy l oz pa">{<br/>   "dates": [&lt;Dates&gt;],<br/>   "country_data": [<br/>      {<br/>       "name": "&lt;Country Name&gt;",<br/>       "retail_and_recreation_percent_change_from_baseline": [&lt;Array of values for this KPI&gt;],<br/>       "parks_percent_change_from_baseline": [Array of values for this KPI],<br/>       "transit_stations_percent_change_from_baseline": [Array of values for this KPI],<br/>       "workplaces_percent_change_from_baseline": [Array of values for this KPI],<br/>       "residential_percent_change_from_baseline": [Array of values for this KPI]<br/>       },<br/>      ...<br/>   ]<br/>}</span></pre><p id="cc5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想法是在页面<strong class="la iu">中插入两个 HTML 选择元素</strong>:</p><ul class=""><li id="5c8f" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated"><strong class="la iu">一个包含国家列表</strong>(这将是一个多选，以便我们可以同时显示多个国家)。</li><li id="beda" class="ns nt it la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><strong class="la iu">一个包含 KPI 列表</strong>。</li></ul><p id="4719" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">和前面代码唯一的区别就是我们需要 e 根据用户选择</strong>过滤 JSON。每当用户更改一个选项时，UI 都需要更新图表。</p><blockquote class="ok ol om"><p id="5bf4" class="ky kz np la b lb lc ju ld le lf jx lg on li lj lk oo lm ln lo op lq lr ls lt im bi translated">虽然对于 JavaScript 开发来说，在<code class="fe ob oc od oe b">window</code>中存储东西几乎从来都不是最佳实践，但我认为我们可以接受这种妥协，让代码简单一点。</p></blockquote><p id="d718" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的代码片段创建了两个 HTML <code class="fe ob oc od oe b">select</code>元素，并将它们附加到单元格中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3fef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意，我们将事件监听器附加到了选择框</strong>，这样每当选择被修改时，viz 就会被刷新<strong class="la iu">。此外，注意所有的函数都存储在<code class="fe ob oc od oe b">window</code>对象中，使它们可以全局访问。</strong></p><p id="cc38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">我们已经准备好实现新的函数来生成图表</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="104a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们就要结束了，让我们写一个函数，当一个输入改变时，它进行刷新:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c2c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，<strong class="la iu">让我们调用单独单元格中的所有内容</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/159349146153c2f074f95ee99a9f6225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZsoyEvWw8tyeeoa7.gif"/></div></div></figure><p id="dd74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里找到完整的笔记本。</p><p id="df92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望你喜欢<a class="ae nb" href="https://medium.com/@andrea.ialenti" rel="noopener">随时关注我的 Medium！</a></p><h1 id="126a" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">外卖食品</h1><ul class=""><li id="304f" class="ns nt it la b lb mw le mx lh pc ll pd lp pe lt nx ny nz oa bi translated"><strong class="la iu"> JavaScript 可以成为 Matplotlib 或其他图表库的有效替代品</strong>；这项技术的主要优点之一是有大量的资源和选择。</li><li id="4de4" class="ns nt it la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><strong class="la iu"> Jupyter 笔记本可以包含不同类型的代码，包括 JavaScript </strong>:使用魔法命令(在本例中为<code class="fe ob oc od oe b">%%javascript</code>`)可以非常容易地实现这一点</li><li id="59ca" class="ns nt it la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated">可以包含任何 JS 库，理论上，可以只与独立的笔记本交互(没有外部文件)</li><li id="4c49" class="ns nt it la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><strong class="la iu">没有任何调整，笔记本需要在每次页面刷新时重新运行</strong></li></ul><h1 id="d5b3" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">看看这些其他的文章！</h1><div class="pf pg gp gr ph pi"><a rel="noopener follow" target="_blank" href="/the-art-of-joining-in-spark-dcbd33d693c"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">火花中加入的艺术</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">Spark 中加速连接的实用技巧</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">towardsdatascience.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw ks pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a rel="noopener follow" target="_blank" href="/clustering-pollock-1ec24c9cf447"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">聚类波洛克</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">杰森·布拉克绘画的聚类分析——如何利用 k-means 进行色彩分组</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">towardsdatascience.com</p></div></div><div class="pr l"><div class="px l pt pu pv pr pw ks pi"/></div></div></a></div></div></div>    
</body>
</html>