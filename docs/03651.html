<html>
<head>
<title>Pandas Cheat Sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫小抄</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-cheat-sheet-4c4eb6802a4b?source=collection_archive---------12-----------------------#2020-04-06">https://towardsdatascience.com/pandas-cheat-sheet-4c4eb6802a4b?source=collection_archive---------12-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="067e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Python 与熊猫一起行动</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b88897301a569e528dacd72661f22d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-UaYclCOjB4kH5AQgs3Aw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@diana-silaraja-794257?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">戴安娜·西拉瑞亚</a>从<a class="ae ky" href="https://www.pexels.com/photo/photo-of-panda-and-cub-playing-1661535/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</p></figure><blockquote class="kz"><p id="9a12" class="la lb it bd lc ld le lf lg lh li lj dk translated">掌握一项技能的 10000 小时法则</p></blockquote><p id="a0d8" class="pw-post-body-paragraph lk ll it lm b ln lo ju lp lq lr jx ls lt lu lv lw lx ly lz ma mb mc md me lj im bi translated">在他的名著《局外人》中，马尔科姆·格拉德威尔曾经说过，一个人需要投入 10000 个小时才能成为任何技能的真正大师。这背后的想法是熟能生巧，这是另一个已经铭刻在一些人心中的流行说法。</p><p id="95ee" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">虽然我当然同意，随着时间的推移，一项新技能的不断练习和重复会形成一致的习惯和表现，但很难想象有人在任何时候都知道一切。如果你曾经对熊猫进行过任何数据分析，有一些基本的功能是你不需要的。</p><p id="82bb" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">这是熊猫基本功能的备忘单。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="554d" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">入门指南</h1><p id="0d30" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">对于这个小抄，我们将创建一个学校不同科目的<strong class="lm iu">成绩</strong>的小型数据框架。先从进口熊猫说起吧。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="8c5a" class="nu mt it nq b gy nv nw l nx ny"># import the package<br/>import pandas as pd</span><span id="41e9" class="nu mt it nq b gy nz nw l nx ny"># creating a dataframe with all the grades and subjects<br/>grades = pd.DataFrame(<br/>                 {'Math'     : [80, 89, 93,66, 84, 85,74,64],<br/>                  'Science'  : [94, 76, 88, 78, 88, 92, 60, 85],<br/>                  'English'  : [83, 76, 93, 96, 77, 85, 92, 60],<br/>                  'History'  : [96, 66, 76, 85, 78, 88, 69, 99]})</span></pre><h2 id="30ac" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">头</h2><p id="99b9" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">为了显示数据框的顶部，我们可以使用<em class="mf"> head </em>功能。默认情况下，我们将获得前 5 行。如果我们想要另一个数字，我们可以将一个特定的数字作为<em class="mf"> n </em>传递。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b437" class="nu mt it nq b gy nv nw l nx ny"># first 5 rows<br/>grades.head()</span><span id="5878" class="nu mt it nq b gy nz nw l nx ny"># first 10 rows<br/>grades.head(n = 10)</span></pre><h2 id="1f2d" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">尾巴</h2><p id="8cb9" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">类似地，我们可以通过调用数据帧上的 tail 来获得最后 5 行，并传递<em class="mf"> n </em>作为参数来更改显示的数字，从而获得与<code class="fe ol om on nq b">head</code>相反的结果。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="f53f" class="nu mt it nq b gy nv nw l nx ny"># last 5 rows<br/>grades.tail()</span><span id="e81b" class="nu mt it nq b gy nz nw l nx ny"># last 10 rows<br/>grades.tail(n = 10)</span></pre><h2 id="af23" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">列</h2><p id="41f7" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">如果我们只想用数据帧的<em class="mf">命名</em>，我们可以使用<code class="fe ol om on nq b">.columns</code>函数</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="48e2" class="nu mt it nq b gy nv nw l nx ny"># column names<br/>grades.columns</span></pre><p id="76ed" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">输出如下→ <em class="mf"> Index(['数学'，'科学'，'英语'，'历史']，dtype= '对象')</em></p><h2 id="5a6e" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">形状</h2><p id="50c7" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">如果您正在处理大型数据框，并且很难手动计算行数或列数，我们使用<code class="fe ol om on nq b">.shape</code>来查找维度。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="4be5" class="nu mt it nq b gy nv nw l nx ny"># size of the dataframe<br/>grades.shape</span></pre><h2 id="4f96" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">信息</h2><p id="85de" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">在开始任何分析之前，了解您正在处理的数据类型是很重要的。使用<code class="fe ol om on nq b">.info()</code>您可以了解您拥有的数据类型的概况。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="410a" class="nu mt it nq b gy nv nw l nx ny"># data types<br/>grades.info()</span></pre><p id="01b5" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">在我们的例子中，所有的数据都是整数类型，因为我们对每个年级都使用整数。</p><h2 id="c89f" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">形容</h2><p id="5239" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">和<code class="fe ol om on nq b">.info()</code>一样，您很可能想知道数据报的描述性统计数据。使用<code class="fe ol om on nq b">.describe()</code>可以观察<em class="mf">计数、平均值、标准偏差、数量、最小值、</em>和<em class="mf">最大值</em>。在这个例子中，我使用了<code class="fe ol om on nq b">.round(2)</code>来清理输出。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="946d" class="nu mt it nq b gy nv nw l nx ny"># descriptive statistics with chained round<br/>grades.describe().round(2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/54c195985e20a2045fb26768f672cf61.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*KovcR4KcIzIi3CAa03MDoA.png"/></div></figure><h2 id="9afa" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">分位数</h2><p id="4108" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">使用<code class="fe ol om on nq b">.describe()</code>函数，我们自动获得了 25、50 和 75 的分位数。我们也可以陈述我们自己的分位数。下面我选了 10%、40%、70%。注意——我们可以在下面的公式中传递尽可能多的分位数。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="7e30" class="nu mt it nq b gy nv nw l nx ny"># quantitles<br/>grades.quantile([0.1,0.4,0.7, 0.8, 0.9])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/29e8682ea74ae29394776fff6f5dc1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*YMUvUygCR-FtaeY1ZALoRg.png"/></div></figure><h2 id="b2b5" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">平均值、标准差、方差、计数、中值、最小值和最大值</h2><p id="13eb" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">我们可以在数据帧上使用各种函数来获得聚合结果。您也可以传入一个列名，以便只检索该列的值。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="ec5b" class="nu mt it nq b gy nv nw l nx ny"># mean<br/>grades.mean()<br/>grades['Math'].mean()</span><span id="834d" class="nu mt it nq b gy nz nw l nx ny"># standard deviation<br/>grades.std()<br/>grades['Math'].std()</span><span id="ff38" class="nu mt it nq b gy nz nw l nx ny"># variance<br/>grades.var()<br/>grades['Math'].var()</span><span id="b222" class="nu mt it nq b gy nz nw l nx ny"># count<br/>grades.count()<br/>grades['Math'].count()</span><span id="9696" class="nu mt it nq b gy nz nw l nx ny"># median<br/>grades.median()<br/>grades['Math'].median()</span><span id="5a76" class="nu mt it nq b gy nz nw l nx ny"># min<br/>grades.min()<br/>grades['Math'].min()</span><span id="f0e4" class="nu mt it nq b gy nz nw l nx ny"># max<br/>grades.max()<br/>grades['Math'].max()</span></pre><h2 id="5751" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">重命名列</h2><p id="addf" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">如果我们要重命名列，例如，将列名改为大写的<em class="mf"/>。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="06c4" class="nu mt it nq b gy nv nw l nx ny"># using inplace means making change to itself. <br/>grades.rename(columns = {'Math':'MATH'}, inplace = True)</span><span id="f991" class="nu mt it nq b gy nz nw l nx ny"># if we don't state inplace as True we need to save it back to itself manually<br/>grades = grades.rename(columns = {'Math':'MATH'})</span></pre><p id="7ade" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">上面两段代码将返回相同的结果。<code class="fe ol om on nq b">inplace = True</code>利用这个论证，我们告诉它要把它保存到自身中去，并记住结果。如果我们不声明<code class="fe ol om on nq b">inplace = True</code>，我们将不得不在<code class="fe ol om on nq b">=</code>中编码，以声明我们希望将值保存回<em class="mf">等级</em>数据帧中。</p><h2 id="ef33" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">索引子集设置— iloc</h2><p id="cfe2" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">使用代表<em class="mf">索引位置的 iloc，</em>我们可以根据索引位置找到数据帧的子集。我们可以通过多种方式建立索引，因此了解使用下面的<em class="mf"> iloc </em>的不同变化非常重要。iloc 的第一部分代表行，第二部分代表列。</p><p id="d257" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">如果你以前在 Python 中不知道这一点，索引从 0 开始。这意味着第一个数字将是索引<strong class="lm iu"> 0 </strong>，而不是索引<strong class="lm iu"> 1。</strong></p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="096d" class="nu mt it nq b gy nv nw l nx ny"># iloc - indexing</span><span id="2f40" class="nu mt it nq b gy nz nw l nx ny">grades.iloc[0]           # first column<br/>grades.iloc[[0]]         # frist row<br/>grades.iloc[:, 1]        # all rows second column<br/>grades.iloc[3, 1]        # 4th row second column only<br/>grades.iloc[[1,3], :]    # row 1 and 3, with all columns<br/>grades.iloc[:, 1:3]      # all rows and columns 1 to 3 (*not                              including 3)<br/>grades.iloc[4:, : 3]     # from row 5 till last row, and first col to 4th col (not including 4th)</span></pre><p id="4867" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">注意我们在某些情况下包含了一个<code class="fe ol om on nq b">:</code>。<code class="fe ol om on nq b">:</code>代表范围符号，<code class="fe ol om on nq b">:</code>左边的数字表示起始位置，右边的数字表示索引到的位置，但<strong class="lm iu">不包括</strong>。例如<code class="fe ol om on nq b">grades.iloc[:, 1:3]</code>它被分成两部分。</p><ol class=""><li id="94bf" class="oq or it lm b ln mg lq mh lt os lx ot mb ou lj ov ow ox oy bi translated">第一个<code class="fe ol om on nq b">:</code> →所有行，因为它前面没有开始索引，后面也没有结束索引</li><li id="07eb" class="oq or it lm b ln oz lq pa lt pb lx pc mb pd lj ov ow ox oy bi translated">第二个<code class="fe ol om on nq b">1:3</code> →从第<strong class="lm iu">栏 1 </strong>起，但<strong class="lm iu">不包括第</strong>栏 3。这意味着在本例中，结果将只返回第 1 列和第 2 列。</li></ol><h2 id="04cb" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">位置子集 loc</h2><p id="b3bf" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">与子集化相反，我们有基于位置的子集化。这里我们引用我们需要的变量的名字，而不是索引。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="fb51" class="nu mt it nq b gy nv nw l nx ny">grades.loc[:, 'Math']                  # all rows in Math column<br/>grades.loc[2:3, ['Math', 'English']]   # rows 3 and 4, for Math and English<br/>grades.loc[4:, 'Math': 'English']      # row 5 onwards, and Math TO English<br/>grades.loc[:5, 'Science': ]</span></pre><p id="e3b5" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">对于我们的数据，我们只有列的位置子集名称。如果我们有行标签，我们也可以引用它们。我们将在后面看到这个例子。</p><h2 id="8844" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">排序值</h2><p id="34e1" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">如果我们想根据特定的值对数据帧进行排序，我们可以使用<code class="fe ol om on nq b">sort_values()</code>默认情况下，值按<strong class="lm iu">升序</strong>排序，我们可以传入一个 False 参数，将其更改为<strong class="lm iu">降序</strong>。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="a89e" class="nu mt it nq b gy nv nw l nx ny"># sort by a column - default asc<br/>grades.sort_values('Math')<br/>grades.sort_values('Math', ascending = False)</span></pre><h2 id="b524" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">串联</h2><p id="7b65" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">使用 concat，我们可以基于一个轴将两个数据框合并在一起。例如，我们可以在两种情况下向数据帧添加新值。</p><ol class=""><li id="7616" class="oq or it lm b ln mg lq mh lt os lx ot mb ou lj ov ow ox oy bi translated">添加更多行—轴= 0</li><li id="e8cd" class="oq or it lm b ln oz lq pa lt pb lx pc mb pd lj ov ow ox oy bi translated">添加更多列—轴= 1</li></ol><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="6081" class="nu mt it nq b gy nv nw l nx ny"># concat<br/>grades2 = pd.DataFrame(<br/>                        {'Math'     : [77,55,93,76],<br/>                         'Science'  : [88,60,90,74],<br/>                         'English'  : [84,76,66,90],<br/>                         'History'  : [77,69,92,81]})</span><span id="2510" class="nu mt it nq b gy nz nw l nx ny"># attach dataframes together, reset index and drop the index col<br/>pd.concat([grades, grades2], axis = 0).reset_index(drop=True)</span></pre><p id="37a1" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">首先，我们创建了第二个包含附加等级值的数据框，称为<strong class="lm iu">等级 2 </strong>。然后我们把新的数据帧放到旧的数据帧上。我们将轴标为 0，因为我们添加了更多的行。如果我们要添加一个全新的主题，比如<em class="mf"> Geography，</em>，那么我们希望使用 axis = 1。</p><p id="37f3" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">如果我们没有添加<code class="fe ol om on nq b">reset_index</code>，指数就不会排成一行。下面是它的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/64fd617e3af34f765f5573920ebb7bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*FHnwUjIj9rirB7kktEUWTA.png"/></div></figure><p id="b9db" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">使用<code class="fe ol om on nq b">reset_index(drop=True)</code>我们正在做两件事。让指数组织起来，回到一个连续的形式。我们删除索引是因为 pandas 会自动创建一个额外的索引列，这是我们不需要的——所以我们删除了它。</p><h2 id="f834" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">布尔索引</h2><p id="fcb4" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">熊猫中一个有用的技术叫做布尔索引。它本质上是一种基于布尔条件(即真或假)查找值的过滤技术。布尔索引的一般语法如下。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="cc87" class="nu mt it nq b gy nv nw l nx ny">dataframe[dataframe['column_name'] == 'filter_objective']</span></pre><p id="bf11" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">使用布尔索引，我们需要在括号内重述数据帧。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="d07c" class="nu mt it nq b gy nv nw l nx ny"># boolean subseting<br/>grades[grades['Math'] &gt; 80]</span><span id="21b3" class="nu mt it nq b gy nz nw l nx ny"># subsetting but only calling a column<br/>grades[grades['Math'] &gt; 80]['Science']</span><span id="6dcc" class="nu mt it nq b gy nz nw l nx ny"># subsetting but only calling a column using iloc<br/>grades[grades['Math'] &gt; 80].iloc[:, 3]</span><span id="6b21" class="nu mt it nq b gy nz nw l nx ny"># AND  conditions<br/>grades[(grades['Math'] &gt; 80) &amp; (grades['Science'] &lt; 80)]</span><span id="fb66" class="nu mt it nq b gy nz nw l nx ny"># OR conditions but only want History score<br/>grades[(grades['Math'] &gt; 80) | (grades['Science'] &lt; 80)]['History']</span></pre><p id="975d" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">如上所述，我们可以组合多个布尔条件来深化过滤能力。使用<code class="fe ol om on nq b">&amp;</code>和<code class="fe ol om on nq b">|</code>我们可以陈述条件。如果两个条件都满足，<code class="fe ol om on nq b">&amp;</code> (AND)将返回结果。如果条件的任何一方得到满足，<code class="fe ol om on nq b">|</code> (OR)将返回结果。</p><p id="239e" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">观察上面的代码。我们可以看到，添加 iloc 或列名可以为我们提供一个结果，如果满足条件，则只返回所选的列。</p><h2 id="5931" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">子集化列</h2><p id="5156" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">您可以将 pandas 中的列子集化为一个系列或一个数据框架。</p><p id="0ce5" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/python-pandas-series/" rel="noopener ugc nofollow" target="_blank">系列</a>是 pandas 中的一种列表类型，可以接受整数值、字符串值、双精度值等等。但是在<a class="ae ky" href="https://www.geeksforgeeks.org/python-pandas-series/" rel="noopener ugc nofollow" target="_blank">熊猫系列</a>中，我们以列表的形式返回一个对象，索引从<em class="mf"> 0 </em>到<em class="mf"> n </em>，其中<em class="mf"> n </em>是系列中值的长度。系列只能包含一个带索引的列表，而数据帧可以由多个系列组成，或者我们可以说数据帧是可用于分析数据的系列的集合。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="3397" class="nu mt it nq b gy nv nw l nx ny"># subseting a column as a series<br/>grades['Math']</span><span id="089a" class="nu mt it nq b gy nz nw l nx ny"># subseting as a dataframe<br/>grades[['Math']]</span><span id="aaae" class="nu mt it nq b gy nz nw l nx ny"># multiple columns<br/>grades[['Math', 'History']]</span></pre><h2 id="7be7" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">添加列</h2><p id="2527" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">向 dataframe 中添加更多的列就像创建一个新的列名并设置与之相等的值一样简单。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="bae2" class="nu mt it nq b gy nv nw l nx ny"># new columns<br/>grades['Student']   = ['Tom', 'Jane', 'Mike', 'Jason', 'Kim', 'Stephanie', 'Mary', 'Jack']<br/>grades['Gender']    = ['M','F', 'M', 'M', 'F', 'F', 'F', 'M']<br/>grades['Class']     = ['A', 'A', 'C', 'B', 'C', 'A', 'B', 'C']</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/73ea65036b84a4819a1a0e1c690b73f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*WlXxTkrVbZhXo1TCmiNrJw.png"/></div></figure><h2 id="0a5b" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">重新排列列</h2><p id="95ba" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">如果是上面的例子，将学生作为第一列会更有意义。如果我们想对列进行重新排序，我们可以创建一个我们希望数据帧列的顺序列表，并在数据帧上对它们进行索引。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="3916" class="nu mt it nq b gy nv nw l nx ny"># reorder columns - pass a list as a list and index</span><span id="17b9" class="nu mt it nq b gy nz nw l nx ny">#order we want<br/>cols = ['Student', 'Class','Gender', 'Math', 'Science', 'English','History']</span><span id="da90" class="nu mt it nq b gy nz nw l nx ny"># overwrite the old dataframe with the same dataframe but new column order<br/>grades = grades[cols]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/a23e481ddbfac3a6700f6a1fd8c02347.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*trz_3MXyHkCLCxv4fFP87w.png"/></div></figure><h2 id="b02d" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">数据透视表</h2><p id="a82c" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Pivot_table" rel="noopener ugc nofollow" target="_blank">数据透视表</a>是一个统计表，它汇总了一个更大的表(例如来自数据库、电子表格或商业智能程序)的数据。该汇总可能包括总和、平均值或其他统计数据，数据透视表以一种有意义的方式将它们组合在一起。</p><p id="e196" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">数据透视表是<a class="ae ky" href="https://en.wikipedia.org/wiki/Data_processing" rel="noopener ugc nofollow" target="_blank">数据处理</a>中的一项技术。他们安排和重新安排(或“旋转”)统计数据，以引起对有用信息的注意。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="adc3" class="nu mt it nq b gy nv nw l nx ny"># pivot tables<br/>grades.pivot_table(index= ['Class','Gender'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/e2a0ff2e1ab2ff17efc68748e081b1bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*6Y6SyytpLMkKdAgdbvlUuw.png"/></div></div></figure><p id="296d" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">我们可以看到，我们首先根据值的<em class="mf">类别</em>对值进行分组，然后根据性别进行分组。这提供了数据帧的聚合结果。</p><h2 id="242f" class="nu mt it bd mu oa ob dn my oc od dp nc lt oe of ne lx og oh ng mb oi oj ni ok bi translated">分组依据</h2><p id="7b98" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">一个<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html" rel="noopener ugc nofollow" target="_blank"> groupby </a>操作包括分割对象、应用函数和组合结果的某种组合。这可用于对大量数据进行分组，并对这些组进行计算操作。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="0a72" class="nu mt it nq b gy nv nw l nx ny"># groupby combined with aggreagate function<br/>grades.groupby(by ='Gender').mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/7c1f3f0443bd8cebcbb7822ad5c5157e.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*rFwHxUUSlUQO_w-wyRqY9Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按性别分组，平均值</p></figure><p id="b657" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">pandas 中的<code class="fe ol om on nq b">groupby</code>函数的伟大之处在于使用<code class="fe ol om on nq b">agg</code>函数链接了几个聚合函数。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b01e" class="nu mt it nq b gy nv nw l nx ny"># groupby and adding several funcitons with agg<br/>grades.groupby(by ='Class').agg(['sum', 'mean']).round(2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/973aa0510688246772c48f1045ba4708.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*2ghBxL4_uJ9gdN8US1MNNw.png"/></div></figure><h1 id="26bb" class="ms mt it bd mu mv pk mx my mz pl nb nc jz pm ka ne kc pn kd ng kf po kg ni nj bi translated">概观</h1><p id="2fa4" class="pw-post-body-paragraph lk ll it lm b ln nk ju lp lq nl jx ls lt nm lv lw lx nn lz ma mb no md me lj im bi translated">我希望这能给你提供在熊猫身上使用的新工具，或者刷新你对已有知识的记忆。记住，要坚持练习，如果你能达到所谓的“大师”水平，马尔科姆·格拉德威尔说，也许有一天，你将不再需要小抄来参考。</p><p id="bc61" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me lj im bi translated">在<a class="ae ky" href="https://www.linkedin.com/in/jasonmchlee/" rel="noopener ugc nofollow" target="_blank"> <strong class="lm iu"> Linkedin </strong> </a>或<a class="ae ky" href="https://github.com/jasonmchlee" rel="noopener ugc nofollow" target="_blank"> <strong class="lm iu"> Github </strong> </a>上与我联系</p></div></div>    
</body>
</html>