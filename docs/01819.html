<html>
<head>
<title>Dataset Manipulation with Open Refine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Open Refine操作数据集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dataset-manipulation-with-open-refine-a5043b7294a7?source=collection_archive---------29-----------------------#2020-02-19">https://towardsdatascience.com/dataset-manipulation-with-open-refine-a5043b7294a7?source=collection_archive---------29-----------------------#2020-02-19</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><div class=""/><figure class="gm go ju jv jw jx gi gj paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gi gj jt"><img src="../Images/d85f6146ae115ba132965bd85ee3f14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o25PlNUavxToyjb2rTcs-w.jpeg"/></div></div><p class="ke kf gk gi gj kg kh bd b be z dk translated">图片由<a class="ae ki" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5744621" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>的Gerd Altmann 提供</p></figure><p id="a287" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">Open Refine是一个用于清理、转换和丰富数据集的web应用程序。可以在以下地址下载:【http://openrefine.org<a class="ae ki" href="http://openrefine.org" rel="noopener ugc nofollow" target="_blank"/>。在下载部分，您可以下载适用于Windows、Linux和Mac OS的最新稳定版本。下载安装程序后，就可以运行了。一旦执行，该应用程序就可以在以下地址由浏览器使用:<a class="ae ki" href="http://127.0.0.1:3333" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:3333 </a>。</p><p id="b066" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">Open Refine允许您执行各种操作。在本教程中，我们将只看到以下内容:</p><ol class=""><li id="22a0" class="lh li iw kl b km kn kq kr ku lj ky lk lc ll lg lm ln lo lp bi translated">上传CSV格式的数据集(也支持其他格式)</li><li id="ea98" class="lh li iw kl b km lq kq lr ku ls ky lt lc lu lg lm ln lo lp bi translated">对列的操作</li><li id="b60e" class="lh li iw kl b km lq kq lr ku ls ky lt lc lu lg lm ln lo lp bi translated">在现有列的基础上添加新列</li><li id="b35a" class="lh li iw kl b km lq kq lr ku ls ky lt lc lu lg lm ln lo lp bi translated">从柱中提取元素</li><li id="b6b4" class="lh li iw kl b km lq kq lr ku ls ky lt lc lu lg lm ln lo lp bi translated">用外部数据丰富数据集</li></ol><p id="3619" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">对于数据操作，Open Refine使用GREL(通用精炼表达式语言)。</p><h1 id="ba38" class="lv lw iw bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">数据集的上传</h1><p id="f610" class="pw-post-body-paragraph kj kk iw kl b km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc mx le lf lg ip bi translated">例如，我们采用包含2015年托斯卡纳地区<a class="ae ki" href="http://dati.toscana.it/dataset/rt-proded-2015" rel="noopener ugc nofollow" target="_blank">编辑作品的数据集</a>。在数据集下载之后，运行Open Refine并从左侧的菜单中选择Create Project项。然后选择我们要从计算机导入的文件，并按下一步按钮。此时，会出现项目的预览。在下半部分，出现另一个菜单(见下图)，从中可以选择一些选项，如CSV字段的分隔字符(由标题<em class="my">指示，列由</em>分隔)和右侧的其他选项(ad示例<em class="my">将下一行解析为setnames的下一列标题列</em>)。位于左上角的另一个选项提供了设置编码的可能性。在我们的例子中，预览中的数据集存在一些编码问题，因此我们可以从选项<em class="my">字符编码</em>中选择utf8编码。至此，我们的数据集的编码问题应该解决了。</p><figure class="na nb nc nd gu jx gi gj paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gi gj mz"><img src="../Images/ee8c2966da289704645e6748ab536304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J19P9dXCXJQOThZZ"/></div></div><p class="ke kf gk gi gj kg kh bd b be z dk translated">作者图片</p></figure><p id="70b7" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">此时，在页面的右上部分，我们可以更改项目的名称(在<em class="my">项目名称</em>下)，然后按下按钮<em class="my">创建项目</em>。应用程序屏幕应该如下图所示:</p><figure class="na nb nc nd gu jx gi gj paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gi gj mz"><img src="../Images/82d1ff8e091cb170d3f7f58e1fed09ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eCwbfX9rUpv2tJQl"/></div></div><p class="ke kf gk gi gj kg kh bd b be z dk translated">作者图片</p></figure><h1 id="cc80" class="lv lw iw bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">列操作</h1><p id="6c32" class="pw-post-body-paragraph kj kk iw kl b km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc mx le lf lg ip bi translated">首先，我们希望在Author列中分离作者，并为每个作者创建一个列。为此，根据作者列的标题，单击箭头，从打开的下拉菜单中(见下图)，选择编辑列，然后拆分为几列。</p><figure class="na nb nc nd gu jx gi gj paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gi gj ne"><img src="../Images/1a1c933032dcffbdc036c31fd8c04eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WpWK_j1T9RAffB-U"/></div></div><p class="ke kf gk gi gj kg kh bd b be z dk translated">作者图片</p></figure><p id="a902" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">在打开的窗口中(见下图)，您可以选择各种选项，包括如何划分列。在我们的例子中，默认选项就可以了，即使用逗号作为字段分隔符。我们按下ok按钮，我们看到我们的表已经改变。原来的列已经被删除，并且创建了许多列，每一列都以该列的旧名称作为名称，后跟一个渐进的数字。</p><figure class="na nb nc nd gu jx gi gj paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gi gj nf"><img src="../Images/21ba12b03dd401337d1bb7d57867d7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_YL2i5vF7xC926y5"/></div></div><p class="ke kf gk gi gj kg kh bd b be z dk translated">作者图片</p></figure><p id="1ccb" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">现在让我们删除所有添加的列，除了第一列。这样我们就只有每篇编辑作品的第一作者了。为此，对于要删除的每一列，始终从列名旁边的箭头中选择“编辑列”选项，然后删除该列(见下图)。</p><figure class="na nb nc nd gu jx gi gj paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gi gj ng"><img src="../Images/33de5a2e4ad7c19aa0cb8fa5c842c269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BNjTrH8DLtdCMF64"/></div></div><p class="ke kf gk gi gj kg kh bd b be z dk translated">作者图片</p></figure><p id="b410" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">此时，我们只有一个列有第一作者的名字。我们把专栏改名为“第一作者”吧。为此，我们从列名旁边的箭头选择编辑列，然后重命名该列:</p><figure class="na nb nc nd gu jx gi gj paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gi gj nh"><img src="../Images/df7f463d75af129000d67758de199032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7xcZvwqfwXe3Z3fJ"/></div></div><p class="ke kf gk gi gj kg kh bd b be z dk translated">作者图片</p></figure><p id="479d" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">现在，假设我们想要创建两个新列，一个包含第一作者的姓名，另一个包含第一作者的姓氏。为此，从箭头中选择编辑列，然后基于此列添加列:</p><figure class="na nb nc nd gu jx gi gj paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gi gj ni"><img src="../Images/c9c4a74f6448b3296870bda5246c5dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YATXI-aGGFaGF40U"/></div></div><p class="ke kf gk gi gj kg kh bd b be z dk translated">作者图片</p></figure><p id="6836" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">在打开的窗口中，您必须指明要创建的列的名称，然后用GREL语言指定表达式来操作该列。让我们来插一句GREL语。在GREL，你可以使用变量、控件和函数。变量代表表中的行。有不同类型的变量:</p><ul class=""><li id="8177" class="lh li iw kl b km kn kq kr ku lj ky lk lc ll lg nj ln lo lp bi translated">值—表示对应于选定列的单元格值</li><li id="1c52" class="lh li iw kl b km lq kq lr ku ls ky lt lc lu lg nj ln lo lp bi translated">单元格—表示对应于选定列的单元格。可以对该变量执行两个操作:执行cell.value(对应于value)和cell.recon(允许获得与外部数据的协调过程的结果)</li><li id="68ba" class="lh li iw kl b km lq kq lr ku ls ky lt lc lu lg nj ln lo lp bi translated">单元格—表示整行。若要访问列的值，必须使用以下语法:cells ["column name"]。价值。</li></ul><p id="9d38" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">至于控件，有不同的类型，包括if和foreach。有关更多详细信息，请参见文档。最后是函数，可以是不同的类型。其中最重要的是字符串操作。有关更多详细信息，请参见文档。</p><p id="553d" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">让我们回到我们的数据集。我们说过要创建两个新列，一个包含作者的名字，另一个包含作者的名字。为此，我们可以使用之前使用的拆分列，但是我们会丢失原始列。要保留起始列，我们可以使用添加列。在为GREL表达式保留的字段中，我们可以使用substring函数创建包含姓名的第一列，该函数从传递的字符串中提取一个子字符串。我们将substring函数应用于当前单元格的值(由value变量表示)，它接收子字符串的极值(起始索引，到达索引)。起始索引为0，而到达索引由空格字符的位置给出，可通过<code class="fe nk nl nm nn b">indexOf function</code>识别，始终应用于变量值:</p><pre class="na nb nc nd gu no nn np nq aw nr bi"><span id="b686" class="ns lw iw nn b gz nt nu l nv nw">value.substring (0, value.indexOf (“”))</span></pre><p id="8386" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">这样我们就知道了作者的名字。要获得姓氏，您需要创建一个新列，然后再次选择add column based on this column，然后通过GREL以如下方式操作字符串:您必须从字符空格+ 1的位置开始从value变量中提取一个子字符串:</p><pre class="na nb nc nd gu no nn np nq aw nr bi"><span id="a98e" class="ns lw iw nn b gz nt nu l nv nw">value .substring (value.indexOf (““))</span></pre><p id="a4d4" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">此时，结果应该如下图所示:</p><figure class="na nb nc nd gu jx gi gj paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gi gj mz"><img src="../Images/465c70ad6f6b6650ebf1f7864d7015f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q4HlcO_Fntfp_hL4"/></div></div><p class="ke kf gk gi gj kg kh bd b be z dk translated">作者图片</p></figure><p id="979d" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">要向左或向右移动列，您可以从箭头中选择“编辑列”菜单，然后向左或向右移动列(见下图)。</p><figure class="na nb nc nd gu jx gi gj paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gi gj nx"><img src="../Images/89ac614749800f7f3a2c6d6b9f995cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NbpjeplYWLNlhmH9"/></div></div><p class="ke kf gk gi gj kg kh bd b be z dk translated">作者图片</p></figure><h1 id="5a59" class="lv lw iw bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">丰富数据集</h1><p id="1023" class="pw-post-body-paragraph kj kk iw kl b km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc mx le lf lg ip bi translated">现在假设我们要为带有ISBN码的图书添加标识码。为此，我们可以查询opac.sbn.it网站，该网站提供了一个API，用于接收输入的ISBN代码并返回一系列信息。API可以按如下方式调用:</p><p id="6776" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated"><a class="ae ki" href="http://opac.sbn.it/opacmobilegw/search.json?isbn=numeroisbn" rel="noopener ugc nofollow" target="_blank">http://opac.sbn.it/opacmobilegw/search.json?isbn=numeroisbn</a></p><p id="96b0" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">结果是一个json，其中还包含图书的识别码。在我们的例子中，我们选择对应于ISBN的列，然后编辑列，然后通过获取URL添加列:</p><figure class="na nb nc nd gu jx gi gj paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gi gj ny"><img src="../Images/63827d2c72d1d0c074c55cb370934de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nFrtDHUTUUYaL9rW"/></div></div><p class="ke kf gk gi gj kg kh bd b be z dk translated">作者图片</p></figure><p id="f1b3" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">在与GREL语言相对应的方框中，我们必须区分包含ISBN的行和不包含ISBN的行。我们可以将不包含ISBN的行识别为长度为1的行。因此，我们可以使用IF类型控件来检查该行是否包含ISBN。if检查的工作方式如下:</p><pre class="na nb nc nd gu no nn np nq aw nr bi"><span id="8da6" class="ns lw iw nn b gz nt nu l nv nw">if (condition, true expression, false expression)</span></pre><p id="94cf" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">如果条件出现，则执行真表达式，否则执行假表达式。在我们的案例中:</p><pre class="na nb nc nd gu no nn np nq aw nr bi"><span id="f2e3" class="ns lw iw nn b gz nt nu l nv nw">if (value.length () == 1, null, <em class="my">load_identification_code</em>)</span></pre><p id="5575" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">要加载标识码，您需要调用API。为此，只需输入带引号的API URL，并使用+运算符添加任何变量。在我们的例子中，有必要指定ISBN，它有时会等于当前行的值(value):</p><pre class="na nb nc nd gu no nn np nq aw nr bi"><span id="697c" class="ns lw iw nn b gz nt nu l nv nw">“http://opac.sbn.it/opacmobilegw/search.json?isbn=" + value</span></pre><p id="93a9" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">那么要插入GREL盒的完整代码是这样的:</p><pre class="na nb nc nd gu no nn np nq aw nr bi"><span id="4131" class="ns lw iw nn b gz nt nu l nv nw">if (value.length () == 1, null, “http://opac.sbn.it/opacmobilegw/search.json?isbn=" + value)</span></pre><p id="8248" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">让我们为新列命名(例如JSON ),然后点击ok。我们等待结果。当系统完成这个过程时，会出现一个名为JSON的新列，其中包含一个JSON，包含从API中提取的所有信息。现在要提取标识码字段，我们需要解析JSON。我们选择JSON列，并从菜单“编辑列”中选择“基于此列添加列”。我们插入新列的名称(标识代码)，并在与GREL语言相关的空间中插入代码来操作JSON。首先，我们需要检查:如果字段为null，我们不需要做任何事情，否则我们必须解析JSON。我们使用isNull函数来检查变量是否为空:</p><pre class="na nb nc nd gu no nn np nq aw nr bi"><span id="c5b1" class="ns lw iw nn b gz nt nu l nv nw">if (isNull (value), null, <em class="my">parsing_del_json</em>)</span></pre><p id="13eb" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">现在让我们来处理JSON的解析。我们将parseJson()函数应用于value变量，该变量将Json转换为一个数组，因此我们可以直接访问数组的字段。识别码位于简要记录阵列的第一个位置。因此，我们可以按如下方式访问它:</p><pre class="na nb nc nd gu no nn np nq aw nr bi"><span id="b3c3" class="ns lw iw nn b gz nt nu l nv nw">value.parseJson () [“briefRecords”] [0] [“Identification”]</span></pre><p id="a6c5" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">代码将插入为GREL语言保留的空间中的完整代码如下:</p><pre class="na nb nc nd gu no nn np nq aw nr bi"><span id="4bb1" class="ns lw iw nn b gz nt nu l nv nw">if (isNull (value), null, value.parseJson () [“briefRecords”] [0] [“Identification code”])</span></pre><p id="8415" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">现在按ok按钮，我们将看到一个新的列出现，它带有与ISBN代码行相对应的识别码。</p><h1 id="b11e" class="lv lw iw bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">摘要</h1><p id="0a22" class="pw-post-body-paragraph kj kk iw kl b km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc mx le lf lg ip bi translated">在本教程中，我演示了如何使用Open Refine提供的基本功能，这是一个非常强大的数据集操作工具。Open Refine结合了图形操作和用GREL语言执行的高级操作。</p><p id="7f49" class="pw-post-body-paragraph kj kk iw kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ip bi translated">如果你想了解我的研究和其他活动的最新情况，你可以在<a class="ae ki" href="https://twitter.com/alod83" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ki" href="https://www.youtube.com/channel/UC4O8-FtQqGIsgDW_ytXIWOg?view_as=subscriber" rel="noopener ugc nofollow" target="_blank"> Youtube </a>和<a class="ae ki" href="https://github.com/alod83" rel="noopener ugc nofollow" target="_blank"> Github </a>上关注我。</p></div></div>    
</body>
</html>