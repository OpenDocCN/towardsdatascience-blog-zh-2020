<html>
<head>
<title>Malware Analysis with Visual Pattern Recognition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有视觉模式识别的恶意软件分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/malware-analysis-with-visual-pattern-recognition-5a4d087c9d26?source=collection_archive---------25-----------------------#2020-05-27">https://towardsdatascience.com/malware-analysis-with-visual-pattern-recognition-5a4d087c9d26?source=collection_archive---------25-----------------------#2020-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fe63" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">快速逆向工程二进制文件的秘密</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d13cd14d7ff5acc32febaa18bda6c42b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GdCEaV0CR3-YJ0dk1wdu3A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">以 Hiew 文本模式显示的 32 位 PE 文件</p></figure><h1 id="35f7" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">第 1 部分:简介和基本模式</h1><p id="9caf" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我最初写这篇文章是为了让恶意软件分析人员受益，当时我在赛门铁克的安全响应团队工作，每天分析和分类 20 多个文件。“扩展 ASCII 分析”是一种通过模式识别快速获得对文件的高级理解的技术。这种技术对于不能在每个文件上花很多时间的分析师来说是非常有益的。对于许多类型的恶意软件，它可以在几秒钟内准确分类。这项技术包括训练你的视觉系统来识别原始二进制文件特有的模式。本文旨在作为介绍和参考，但可能需要检查数百或数千个文件才能熟悉这项技术。它还旨在为在恶意软件分类中使用卷积神经网络提供直观的理由，卷积神经网络通常在与人类视觉系统相同的任务中表现良好。我认为这种类型的领域知识对于构建对输入分布的变化具有鲁棒性的模型是必不可少的(更多信息请参见<a class="ae mj" rel="noopener" target="_blank" href="/covariate-shift-in-malware-classification-77a523dbd701">https://towardsdatascience . com/co variate-shift-in-malware-classification-77a 523 DBD 701</a>)。我在 2014 年写了这篇文章的原始版本，所以一些特定的恶意软件截图可能已经过时了，但基本概念仍然适用。</p><p id="afc9" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">有些文章假设读者熟悉 windows 二进制逆向工程，特别是熟悉<a class="ae mj" href="https://en.wikipedia.org/wiki/Portable_Executable" rel="noopener ugc nofollow" target="_blank">可移植可执行文件</a>(PE):windows 的文件格式。exe 和。dll 文件。该技术也可以提供对其他文件格式的洞察，但是考虑到 windows 可执行恶意软件(和良性文件)的数量，它们是一个很好的起点。然而，即使你不熟悉逆向工程，我希望这篇文章能够展示在其他类型的原始数据上训练/应用你的视觉系统的价值。原始数据之所以难以解释，可能只是因为你没有对其进行足够的观察，以找出模式:一旦你开始认识到模式，你可能会注意到一些被更多处理过的可视化所遗漏的东西。</p><h1 id="2f8a" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">问题是</h1><p id="1bbe" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">有许多二进制分析工具可以显示文件各部分的具体信息。例如，<a class="ae mj" href="http://www.angusj.com/resourcehacker/" rel="noopener ugc nofollow" target="_blank"> Resource Hacker </a>显示 PE 文件中的资源，string dumpers 显示字符串，<a class="ae mj" href="https://www.aldeid.com/wiki/PEiD" rel="noopener ugc nofollow" target="_blank"> PEID </a>显示 PE/packer 信息等。运行大量工具并组合它们的输出以形成结论可能需要相当多的时间。因为这些工具中的大部分都提供了一个经过处理的表示，集中在二进制文件的特定方面，所以有些字节可能会被完全忽略。大多数工具也依赖于文件类型，因此依赖它们意味着分析不熟悉的格式很有挑战性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/f32f92b21436b819184bd0567d157bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tChZA1iZczJ_gxW-nm_AAg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">不同的工具为一个文件提供了不同的视图，但通常不会提供一个既全面又能快速消化的概述</p></figure><p id="7bec" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">虽然<a class="ae mj" href="https://www.hex-rays.com/products/ida/" rel="noopener ugc nofollow" target="_blank">IDA</a>——业内最流行的交互式反汇编器/反编译器——允许对大多数可执行文件进行相当完整的分析，但识别文件的加密/压缩区域需要时间。因为 IDA 侧重于分析代码，所以识别加密数据通常涉及识别解密代码。同样，这可能非常耗时，并且识别加密数据对于恶意文件来说是至关重要的。大多数常见的恶意软件都是使用低熵定制打包程序打包的，旨在避开防病毒软件。像 PEID 这样的识别打包的可执行文件的工具不能始终如一地工作，因为许多打包程序检查是基于已知的打包程序或文件熵。PEID 也不能将一个特定的打包程序与一个特定的威胁联系起来:如果可以的话，那么它本身就可以成为一个伟大的反病毒引擎。获取文件中所有字节信息的更快方法对于形成第一印象是理想的。</p><h1 id="d9bb" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">解决办法</h1><p id="bac6" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">滚动浏览 Hiew 的文本视图(或在十六进制编辑器中打开文件，甚至是 notepad.exe ),显示二进制文件中的所有数据，每个字节由一个扩展的 ASCII 符号表示。不同的数据模式导致不同的符号模式。因为人类的大脑非常善于识别视觉模式，它可以非常快速地对数据进行分类。常见的数据类型包括:</p><ul class=""><li id="ee1b" class="mq mr iq lp b lq mk lt ml lw ms ma mt me mu mi mv mw mx my bi translated">原生代码(x86、x64、ARM 等。)</li><li id="219b" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">微软中间语言(MSIL)</li><li id="08eb" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">加密很差的数据</li><li id="1da8" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">高熵数据(压缩/加密良好/随机数据)</li><li id="1cb7" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">形象</li><li id="dfe8" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">搬迁科</li><li id="421b" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">字符串(包括非罗马字母)。</li></ul><p id="f9e9" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">识别加密较差的数据可能非常有帮助，因为这通常表明是用于避免抗病毒的自定义打包程序，而不是可能用于压缩和保护的商业打包程序。</p><p id="8945" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">例如，许多木马。Asprox.B 样本(见下图)以一种非常一致的字节模式加密。这意味着有可能在不到一秒钟的时间内识别它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/703c45aabf7aea6ba107541dc6d7ae38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3nR6w9wlyZ9r7UnEjAElmA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">特洛伊木马的加密部分。Asprox.B:即使数据被加密，许多重复的模式也是可见的(表明加密是脆弱的)</p></figure><p id="0d96" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">虽然这在技术上给出了文件中(几乎)每个字节的信息，但它并不适合所有类型的分析。</p><h1 id="a649" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">限制</h1><p id="e0ef" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这种方法侧重于广泛的理解而不是深刻的理解:</p><ul class=""><li id="6881" class="mq mr iq lp b lq mk lt ml lw ms ma mt me mu mi mv mw mx my bi translated">它可以用来识别代码，但是理解代码仍然需要一个反汇编器/反编译器</li><li id="7052" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">它可以用来识别嵌入在 PE 文件中的图像，但是查看实际的图像仍然需要图像查看程序</li><li id="3339" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">它可用于识别加密/压缩的数据，但您必须先解密/解压缩数据，然后才能对其进行进一步分析</li></ul><p id="879c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">将数据视为符号而非十六进制数字，可以使人类模式识别更快、更容易。</p><h1 id="450a" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">ASCII 背景</h1><p id="5db1" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这种方法的关键是将文件中的每个字节映射到 256 种不同符号中的一种，然后使用大脑的模式识别能力来解释结果。正式 ASCII 仅使用 7 位:0x00 至 0x7F。这仅包括所有可能符号的一半，其中大部分是“可打印”符号，如字母数字字符。为了使用这种技术，我们需要一种方法来为每个字节打印一个符号，然而不同的计算机系统对第 8 位的处理是不同的。Windows 将不同的字符映射称为“代码页”，两种常见的代码页是 ANSI 和 OEM。</p><p id="a277" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">ANSI 是指 Windows 代码页；默认名为“Windows-1252”。这个代码页没有映射每个字节:0x81，0x8c，0x8f，0x90，0x9D 没有映射到任何符号，通常显示为“.”或者呢？。因此，它们是不可能区分的，这就隐藏了信息。</p><p id="de89" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">OEM 指的是控制台/DOS 应用程序。来自 IBM PC 的代码页被称为代码页 437。它将所有字节映射到符号；但是，它将 0x00、0xFF 和 0x20 映射到同一个符号，即一个空格。这在实践中很少引起问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/809c2c10d9a6a25c9fab07eaa07ebaf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*ByfujIUQwl04d4GWQMjrOg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">每个字节到一个符号的映射</p></figure><p id="949f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">您可以在标准文本编辑器(如记事本)中使用这种技术。但是，这造成了一些控制字符的问题，并且缺少功能。我个人用的是十六进制编辑器“Hiew”。</p><h1 id="af81" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">模式和高熵数据背景</h1><p id="699c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如前所述，快速识别模式是这种技术的主要目的。识别良性模式以关注潜在恶意模式的能力对于恶意软件分析至关重要。更定量地考虑模式的一种简化方法是计算某些字符和字符序列在一个数据块中出现的频率。通常，一些字符/序列是普遍存在的，而另一些字符/序列是罕见的。例外是高熵数据，其中大多数字符出现的次数大致相等。请注意，在安全行业中，“熵”通常计算为分类分布的熵，其中每个字节都是其自己的类别，一个字节的概率由它在我们考虑的数据块中的频率给出。由于这是一个单变量分布，它没有捕获与字节的相对位置相关的结构。然而，在这里我将使用术语“高熵”来指看起来均匀随机的数据，即使是字节序列。下图是高熵数据的一个例子</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/f6a3f9bb0d5b3be7450f14aedf61f139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUFFxM8ECPgB6fMZS6c1IQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">高熵数据</p></figure><p id="868e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">高熵数据通常表示以下四种情况之一:</p><ul class=""><li id="d45b" class="mq mr iq lp b lq mk lt ml lw ms ma mt me mu mi mv mw mx my bi translated">压缩数据</li><li id="b88c" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">加密良好的数据</li><li id="f2bb" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">随机数据</li><li id="fe31" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">加密计算中使用的常数。</li></ul><p id="1fe4" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在一个完美的高熵文件中，每个字节平均每 256 个字节出现一次，或者大约 0.39%的时间。下图显示了高熵文件(在本例中是一个. zip 文件的块)中最常见的字符和两个字符的序列的出现频率。虽然前 20 个最频繁出现的字符中没有一个出现的概率是 0.39%，但它们都相当接近。这种差异可以用抽样误差来解释。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/984adb4112ff63ffa94c1ac91bd7830c.png" data-original-src="https://miro.medium.com/v2/resize:fit:170/format:webp/1*OFm44nUzLxHug_Z_IfY01g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">高熵数据样本中最常见的一元和二元模型出现的频率</p></figure><p id="62e7" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在这一节中，我将讨论如何识别标准编译代码产生的模式。这显然是可执行文件中的常见模式。</p><h1 id="ce81" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">x86 (32 位)代码</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/616c012d38e4741288413074f23bb7d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*EmquD6EGzgIGDac18xTJpg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">x86 代码的示例</p></figure><p id="2f6d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我从大约 7kb 的 x86 代码中生成了下面的图像。它显示了代码中一些最常见的字符/序列，以及(非常)粗略地显示了它们对应的操作码。这个例子并不代表所有可能的 x86 代码，因为不同的编译器/源代码会生成不同外观的编译代码。例如，一些编译器/编译器选项在 16 字节边界上对齐函数，一些在 4 字节边界上对齐，一些不对齐。有些编译器用 nop 填充，有些用 int3。显然不同的源文件会产生不同的编译文件。然而，在训练你的视觉系统之后，通常很容易识别所有类型的 x86 代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/6abfa7cfbae4a9980b6eba7e9b2e76bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAVRgTn3w33oD58GpFg-mw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">x86 代码中最常见的序列如何映射到操作</p></figure><p id="202f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">有几点需要注意:0x00 和 0xFF 是最常见的，通常以偏移量的形式出现(例如，jmp 指令中使用的偏移量)。这些字节映射到空格，并在 x86 代码中产生可见的间隙。在这段代码中，编译器使用 int3 (CC)指令作为函数之间的填充。函数开始/结束所涉及的序列是普遍的(padding，push ebp，mov ebp esp 用于开始，ret，padding 用于结束)。在对这样的序列进行一些定位练习后，立即识别 x86 数据变得容易多了。</p><h1 id="38ff" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">结论</h1><p id="0a14" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">不幸的是，要熟悉这种技术可能需要检查成百上千个恶意和良性样本。如果您经常对文件进行逆向工程，我强烈建议您尝试一下，即使最初需要一段时间来获得有用的信息。长期以来，使用弱加密的恶意打包程序一直是恶意软件作者用来隐藏其攻击的主要工具之一，但仿真等现代技术可以通过拆开有效负载(比打包的文件更容易识别)来帮助发现这些攻击。了解文件结构还可以帮助启发和指导恶意软件检测模型，如用于恶意软件检测的神经网络<a class="ae mj" href="https://medium.com/ai-ml-at-symantec/deep-learning-for-malware-classification-dc9d7712528f" rel="noopener">https://medium . com/ai-ml-at-Symantec/deep-learning-for-malware-classification-dc9d 7712528 f</a>。</p><h1 id="2307" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">第 2 部分:模式图谱</h1><p id="9525" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在这一部分，我回顾了我经常遇到的大量模式。如果你想学习这项技术，这可以作为一个参考。</p><h1 id="a3b6" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">x64 代码</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/afc1b26c80c17d05f0ce1380f1cf2f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*ynOSZf20jmKDlgxzQQDSug.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">x64 代码示例</p></figure><p id="4205" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">64 位代码与 32 位代码有许多相似之处:偏移量和填充仍然存在，并且许多操作映射到相同的字节。最明显的区别因素是“H”字符在 64 位代码中出现的频率。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/223bd015acc057111280598420905d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*v2tA1QMoWZVU92Y_9Z2Nbw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">x64 代码示例中最常见的 1–4 个程序</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/b6d8344130e382a6779ff33eada2dfc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vyP6ZeaVaefGex2AMe0ghw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">x86 和 x64 代码的直接对比。注意，在这种情况下，x64 代码在函数之间没有填充，而 x86 代码有，但情况并非总是如此。如果你数一下每一部分中 H 字符的数量，很明显底部更多</p></figure><h1 id="3534" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">MSIL 电码</h1><p id="923d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">MSIL 字节码与 x86 非常不同。几乎 25%的字节是 0x00，因此会有许多明显的间隙。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9c23215225162a15644e3acdbb8b5ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*ZTWd6exT_Xz0F_l-TqWtWQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">MSIL 电码的样本</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/77ba9c259be1e06616a017b61076f482.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*njlmKf9Ugh7wlbcMf6Bscw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">MSIL 电码中最常见的 1–4g 内存</p></figure><h1 id="b2b3" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">可移植可执行(PE)文件</h1><p id="9b83" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在 windows 中，前面讨论的代码几乎总是出现在 PE 文件的上下文中(通常被视为带有。exe 和。dll 扩展)，它有几种可识别的模式</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/9bba0af71d4eb29c21efbbd2f6c63675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nVrKfOp6Y2RlCwaBv-s3yw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">PE 文件的各个部分</p></figure><p id="e4e5" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">因为 PE 文件不仅仅包含代码，所以熟悉不同部分中出现的模式是有好处的。普通文件可能包含:</p><ul class=""><li id="01f3" class="mq mr iq lp b lq mk lt ml lw ms ma mt me mu mi mv mw mx my bi translated">. text 部分中的代码</li><li id="ba16" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">. rdata 节中的导入/导出/字符串</li><li id="093d" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">. data 节中的字符串</li><li id="eef7" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">. rsrc 部分中的图像/版本信息</li><li id="324e" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">. reloc 节中的重定位数据</li><li id="1e51" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">附在末尾的签名</li></ul><p id="fea9" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">能够区分常见的良性数据(如重新定位数据)和潜在的恶意数据(加密不良、未知等)以快速分析文件非常重要。</p><p id="ebfa" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">以下是大量位置调整数据的示例</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/9250c47f27d85cf5dc5a7da5081ecb44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dZ6Wr6O5ZlxBE8-2wkk9gQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">重新定位数据。在反汇编视图中，Hiew 突出显示了当文件加载到内存中时需要修改的全局地址对应的字节</p></figure><p id="794c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下面是一个图标文件的例子，通常在资源部分找到并显示在资源管理器中</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/ffec5e510d6b2e02989f248f9471acf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNchy4o14D9Lb14TKJFu-w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">。ico 文件</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/7db9e0ac6eb51900efa2c740234435b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QQK5ja2oBhKbci62_2YkfA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">可能出现在 PE 文件中的图标。显然，带有 PDF 图标的 PE 文件非常可疑，因为它会欺骗用户，使其认为这是一个文档而不是可执行文件</p></figure><p id="9458" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">以下是附加到文件末尾的签名示例</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/569290ec1cdc1d3250b78ae1ac44f0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bzhep1RQi_4IM39OX_1Qcg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">PE 文件数字签名</p></figure><p id="e369" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">可以在资源管理器中查看和验证这些类型的签名:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/1f24a356f592e7440a4ef943b5d0f478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MAel7bpsOcuSUY55wX546w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">浏览器中的签名详细信息</p></figure><p id="8891" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">当检查干净的或恶意的 PE 文件时，遇到高熵数据区域是正常的。下一节将讨论一些快速了解这些数据用途的方法，这些数据通常是出于合理的原因出现的。</p><h1 id="39df" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">高熵数据</h1><p id="2fb5" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">由于压缩，许多图像格式包含高熵数据:</p><p id="9353" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">巴布亚新几内亚:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/6f0d6ff1ff4f298385c54909f0c73d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbCFqHeEEshumjKoU5x2wQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">png 文件:大多数扩展名为. PNG 图像看起来像这样</p></figure><p id="4298" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">GIF 格式</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/307c164fc2d2aefa2ddebe233c1df633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*hGAVE53CLDtRbe8kNOLAYQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GIF 格式</p></figure><p id="3c17" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">联合图像专家组</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/35a78c28a8d73a42776df065c74c22a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXDsRuTFG6cn5D1SZOWvfQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">联合图象专家组</p></figure><p id="f2a6" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">压缩存档使用压缩(很明显)，下面是一个. zip 文件的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/3d4eeaeb4c8479332243b14313293167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kpm4NStPND0qy6ffA8WiEw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">压缩文件</p></figure><p id="86e8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在信息论中，熵可以用来衡量随机性。除了简单地识别，人类从高熵数据中提取信息是不切实际的，因为它看起来是均匀随机的(没有重复序列之类的模式，所有字节出现的次数都相似)。然而，有时有更简单的方法来了解它。大多数高熵数据是压缩的，并且在顶部带有指示其用途的头字节。以下是一些使用压缩数据的标准格式</p><p id="0fa2" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">形象</p><ul class=""><li id="d8a6" class="mq mr iq lp b lq mk lt ml lw ms ma mt me mu mi mv mw mx my bi translated">联合图象专家组</li><li id="8fcf" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">可交换的图像格式</li><li id="bad5" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">png(使用 zlib)</li></ul><p id="2b5e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">档案</p><ul class=""><li id="8f55" class="mq mr iq lp b lq mk lt ml lw ms ma mt me mu mi mv mw mx my bi translated">活力</li><li id="2c6f" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">rar</li><li id="ffa1" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">. tar.gz</li></ul><p id="bdd7" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">安装人员</p><ul class=""><li id="03d9" class="mq mr iq lp b lq mk lt ml lw ms ma mt me mu mi mv mw mx my bi translated">Nullsoft</li><li id="efc0" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">Inno</li><li id="dc43" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">自解压档案</li></ul><p id="3a7e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">自动编辑脚本</p><p id="8ddc" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">zlib 库</p><p id="c845" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下图显示了附加到 PE 文件末尾的压缩数据。在每种情况下，都有一个标题，表明数据的用途(安装包、autoit 脚本)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/16d75469635a953e5268c473ef903683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*30jWhNwDoh3BR_3SaU6IBA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Nullsoft 安装程序(从 NullsoftInst 开始)</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/0c973bfe98fa18480979ef50118fa065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zv_UNX_VlkyMc8bH-2sXKw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Inno 安装程序(从 zlb 开始)</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/0c107f35076c41469bcb6d8450e82211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2GlExUyzL2vyedh9WIiiQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Autoit 脚本(有 AU3！)</p></figure><p id="3e48" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">以下是一个压缩闪存文件(CWS)的示例。它使用 zlib，几乎总是以 0x78 ('x ')开头。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/de602c6cd9aca660b14101f83468be3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*E_MzVhDh5xEff-lv7OYA1g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用 zlib 的 CWS 文件</p></figure><p id="c961" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">png 和 pdf 也可能使用 zlib。</p><p id="9f03" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">高熵数据也可以是加密/压缩常数。PEID 的“Krypto Analyzer”(KANAL)插件可以定位常见加密常量的偏移量/虚拟地址，然后可以使用 IDA 进行进一步的研究。一旦将数据识别为加密常数，就知道了它的用途，不需要进一步研究。</p><p id="54e8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下面是一些单独加密的字符串，它们看起来熵值很高(加上字符串之间的间隙)，因为数据不多。您可能会注意到底部有一个以“<strong class="lp ir">或</strong> 0”开头的块</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/d81ec9ee19dd4ef2b8434f3e8bcdeed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hh0wCFiNY9Gjyun63dk0Ug.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">后跟 CRC 常量的加密字符串</p></figure><p id="c121" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">PEID 的 KANAL 扩展可用于研究该数据块，结果在 CRC 计算中使用了该数据块(使用原始偏移量而不是虚拟地址进行图像交叉引用)。通过实践，KANAL 不再需要寻找像 CRC 常量或 Rijndael S-box 这样的加密常量</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/7d735770fce16f289445b5d8fc5081ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yg97FHqu-9AjDDYpsyK-Qw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">KANAL 显示 CRC 常数的偏移</p></figure><p id="787b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">同时，IDA 可以用来研究字符串以找到解密函数</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/7500c93ea3d57c35034b42fa4ebef310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6k4G3olgaZ8xsacJIQrj0g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">IDA 可用于查找引用加密字符串的代码(sub_1400EF84)</p></figure><p id="408b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">PE 文件中数据的位置可以提供额外的提示。如果在参考资料部分，我总是检查 PNG 文件头，因为文件有时会将它们的高分辨率图标存储为 PNG。如果附加到 PE 映像，文件可能是安装程序、autoit 脚本或签名文件(签名中有可识别的字符串)。PE 文件之外没有明显标题的高熵数据可能是某种自定义格式。有时在开头有一个长度指示器或神奇的数字，这可能会给出一些关于布局的提示。</p><p id="c22b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">有时，恶意软件将恶意数据隐藏在具有标准报头的高熵数据中。下面是一个例子，一个 PNG 文件有一个加密的 MZ 文件，这是显而易见的解压缩后的 PNG 的数据。查看文件中的 png 以确保它们不包含恶意数据通常是一个好主意(根据我的经验，这种情况很少见)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a975ef8ed67097fb9c69c3fcace89842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*P9fplrz5vHuWUF8Nhej3Uw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">包含恶意数据的 PNG 文件</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/fb8ba04596c164363b3bfac18c580fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-rzXh6ZTgQRrbz3PiIIW4g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">UPX 收拾好文件。PE 头后面跟着高熵数据，后面跟着 x86 解密存根。</p></figure><p id="3484" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">安全加密是高熵的，与随机/压缩数据无法区分。然而，恶意文件使用的大部分加密是脆弱的，并且包含容易识别的模式。下一节讨论弱加密中出现的数据模式。</p><h1 id="9aed" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">弱加密</h1><p id="3b1f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">弱加密是任何容易被现代密码分析破解的加密，在实践中，它可以转化为几乎任何不为人所知且未经测试的加密方案。在复杂的攻击中，密钥可能存储在远程服务器上，或者以特定于机器的方式动态生成，除此之外，解密打包程序有效负载的加密密钥必须是二进制的，因此安全加密提供的防止密码分析的保护没有帮助。因此，大多数恶意软件打包程序的目标不是安全加密，甚至不是防止分析，而是躲避反病毒软件。因此，加密较差的数据表明该数据可能被用于恶意目的。弱加密方案的一个例子是短的 xor 密钥，在这种情况下，有时可以通过简单地查看加密数据来识别算法和密钥。请注意，使用加密来保护文件不被分析是有正当理由的:例如，知识产权保护。然而，确实有任何合法的理由来躲避反病毒产品(只要这些产品恰当地反映了用户的兴趣)。</p><p id="d56f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下面是一个 PE 文件开头的 1 字节 xor 加密的例子。因为 0x00 与任何字节异或都是同一个字节，而且我们知道 PE 报头在报头和代码之间有 0x00 填充，所以很清楚密钥是什么:0xFE(方框符号)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c227b4446a0a63faf126b329f3f21493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*FKusqI8_irkPnFsSKTr8yg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">PE 文件的 1 字节异或加密</p></figure><p id="cd5f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在这个 PE 文件被加密之后，任何可以用来检测原始 PE 文件的字节序列将不再工作。现代反病毒功能，如模拟器和动态分析，是为了防止这种类型的逃避而发明的。1 字节的 xor 密钥在实践中很少见，因为打包程序每次打包新的可执行文件时都会更改加密密钥，以避免被检测到加密数据。1 字节的 xor 密钥只允许 255 种变化(与 0 字节的 xor 不加密)。</p><p id="ec53" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这是同一个文件，用一个 4 字节的 xor 密钥进行 xor 运算，仍然很容易识别这个密钥</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/a03b72cb2e35309f95b897b2fd8ed7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*52YshwdwwmSDC9p6E3XM0g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">PE 文件的 4 字节异或加密。红色方框中的钥匙</p></figure><p id="4b5b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下面是用 16 字节 xor 密钥进行 xor 的同一个文件</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/ae18d8a9626fc116d3feee9a5baa50f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*i6BAc2bVCi-xsfl8hkL7lA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">PE 文件的 16 字节异或加密</p></figure><p id="4a7d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">最后，这是用 64 字节 xor 密钥进行 xor 运算的同一个文件。虽然仍然有可能通过一些努力看到模式，但是看到密钥不再是微不足道的了(尽管使用标准的密码分析可能仍然很容易)。如果文件是用一个等于其长度的随机 xor 密钥加密的，那么它将是完美加密的，并且具有完美的高熵(这种“完美”类型的加密被称为一次一密)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/3e31c92d8dbc4b0c9b9a3f2ec62f225c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*G8_b0gi8PsMWwSlhLxNw1w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">PE 文件的 64 字节异或加密</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/c317833affdafabfae8d49510bf09065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*vyFtHiMd3wRiQ9IJkfD_5g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一些重复序列在 64 字节版本中仍然可见</p></figure><p id="08c8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这里有一个使用 1 字节 xor 密钥的实际例子。下图显示了一个. jar 文件中使用的字符串集合，该集合已经过模糊处理。看到 xor 密钥并不容易，但是简单的密码分析就能轻易破解(想想字符串中出现最多的字符)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/4456fcb48595693ac512adb8c3116310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*llOPTa4Lj71mqrn_aiu0ew.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用 JShrink 混淆</p></figure><p id="bce3" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这是未加密的版本</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/11d85743c68ce303b5c835e1c862b464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oE5Zc2crIhAJh6taWRoVLw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">未加密的 JShrink 数据</p></figure><p id="1a53" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下一节将展示一些初看起来像弱加密的数据示例，但这是一种不同类型的数据。在实践这种技术时，在 IDA 中查找代码如何使用您不认识的数据是很有用的。</p><h1 id="c83b" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">不是弱加密</h1><p id="c7c2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">区分可疑数据和良性数据需要一些实践，例如。非罗马字母语言的 ico 文件、重定位数据和字符串(如简体中文字符的 GB 2312 字符集)。</p><p id="0a06" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这是一个图标。即使采用弱加密，加密数据的熵也很少低于未加密数据。因此，我不会觉得这些数据太可疑，因为大多数潜在的恶意数据(代码、字符串)的熵都比这高。换句话说，存在如此多可预测的重复这一事实意味着，这部分数据可能无法在相同数量的字节中编码与普通 x86 代码一样多的信息。取决于加密算法有多疯狂，也有例外。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/44133d02ac2f748166a2af389f65d301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZHudOBSEOB1-45RJOaOAg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">。ico 文件</p></figure><p id="3e88" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这里有一些中国琴弦。乍一看，它们可能是加密不良的 ASCII 字符串。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/82bce1b153b2fc19b46902066eeb5adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gY0TDk1fai9eQh2aNzr-9w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从 Hiew 和 IDA 看中国弦乐</p></figure><p id="02a4" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">以下是各种语言/编码的字符串。有些比其他的更容易区分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/d01de27ac1dd4511e23a235b08ff64a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*gvaTc9D1rJMEOZD7z87Nmg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">编码不同语言的各种方法</p></figure><p id="ffe2" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">熟悉什么是加密不良的数据和什么不是加密不良的数据的最好方法是查看许多干净的和恶意的文件的例子，并检查看起来可疑的数据是如何在代码中使用的。下一节展示了使用弱加密来躲避防病毒软件的实际恶意软件的例子。</p><h1 id="d1f3" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">恶意软件示例</h1><p id="aabb" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">常见的 x86 恶意软件往往具有与一个或多个打包层相结合的解密代码存根。熟悉 x86 模式意味着识别代码存根通常很简单，有时甚至可以区分不同的加密层。如果 PE 文件中有很大区域的数据看起来很奇怪，那么检查内存转储中已知的恶意字符串通常是个好主意。这个过程可以让您快速确定文件的威胁，甚至不需要打开 IDA(有时比 IDA 加载文件的时间还要短)。在下面所有的例子中，如果你用同一个打包器打包任何一个文件，它看起来都差不多，尽管具体的字节会有所不同。</p><p id="fb5d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下面是木马的图片。它包括顶部的解包存根和底部的打包数据</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/6022fc7cfc19be665be6a8b4a0909e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipX0_HoOIUcV6L0yvG75CA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Trojan.Asprox.B. x86 解包存根，后跟加密不良的数据</p></figure><p id="8f9e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下面是 Trojan.Tracur 的图像，可以看到三个不同的部分:红色轮廓是 x86 解包代码，绿色轮廓是第一层，橙色轮廓是最后一层的顶部(这是一个加密的 MZ 文件)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/d83ad225c35222efc02c8df92136f958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N7ay2UbiAb1iEYiCG8KXOA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Trojan.Tracur. x86 解包存根，后跟加密不良的数据，再后跟不同类型的加密不良的数据</p></figure><p id="e52c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">以下是特洛伊木马中的一些加密部分。Zbot 样本:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/959e35c2598e3473382a52fd977c257b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2FDeO2uOaaWsnwVGYZYKjg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">木马。Zbot 加密很差的数据</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/769aed16c6dae97e62692bd794430a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vCDSRynOJQLGndnvyUVueA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">木马。带有 PE 头的 Zbot 数据加密不佳</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/3b8cea40ea8782d3c23ddd3ee9e95bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7bbG4VFkjO4EuWOQQUNmQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">木马。带有 PE 头的 Zbot 数据加密不佳</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/aac3f03dff3ca427b805b05da2057922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*ZsA0ZUN9xUR4qhSvOQD7wQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">木马。Zbot 加密很差的数据</p></figure><p id="3f52" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">弱加密可以产生大量的模式，所以需要大量的练习才能一般地识别它。下一节有一些使用这种技术的技巧。</p><h1 id="4e6e" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">附加注释</h1><ul class=""><li id="f84f" class="mq mr iq lp b lq lr lt lu lw ot ma ou me ov mi mv mw mx my bi translated">对代码的熟悉使查找外壳代码变得更容易，参见下面的韩文文字处理程序利用(在开始时很容易看到“push ebp mov ebp，esp”的字节)</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/31ccf4838eecbcd50f4c9e09d94dab08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyxBpe5y3bxQrQeqPCKrvg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">韩文文字处理器漏洞。一个绿框包含对应于函数开始的字节，另一个包含用于加载/引用 kernel32.dll 的数据。这些在文档文件的上下文中是非常可疑的。</p></figure><ul class=""><li id="50ef" class="mq mr iq lp b lq mk lt ml lw ms ma mt me mu mi mv mw mx my bi translated">这种技术可以应用于任何二进制文件，对于转储尤其有用</li><li id="8a52" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">当使用完整的 ASCII 视图时，它还可以用于在类似于<a class="ae mj" href="http://www.ollydbg.de/" rel="noopener ugc nofollow" target="_blank"> ollydbg </a>的调试器中浏览内存。不幸的是，许多调试器会将正常 ASCII 范围以上的字符映射到“.”</li><li id="de96" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">有时不同的 IDEs 编译器会创建不同的文件结构，这种技术可以帮助识别/分析这些文件。下面的例子是 Delphi。在 Delphi 文件中快速获得大量信息的一个快捷方法是进入入口点(非文本模式下的 f8 f5)，然后向上滚动查看自定义字符串。在 Delphi 中，字符串与代码混合在一起，库字符串更靠近顶部。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/89532013c6f38022cd82c44838c77fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*880WzImO1eqh4AcW2uHRZg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Delphi 文件</p></figure><h1 id="dd08" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">Hiew 背景</h1><p id="e01a" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Hiew 是一个全功能的十六进制编辑器，设计时考虑了 PE 分析，非常适合这种技术。它有三种视图模式:文本、十六进制和反汇编。这种技术主要使用文本视图。虽然熟悉 Hiew 的所有功能/热键是件好事，但这里最重要的是“Enter”切换视图，“Pageup/Pagedown”滚动，F2 切换环绕/展开(确保“展开”显示在左下方“2”旁边)。文本模式下的 F8 可用于字符编码之间的切换；如果设置正确，该表应该保持“原样”(如果您看到许多“？”可能意味着它是以 Unicode 模式打开的)。</p><p id="3747" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">感谢 Mircea Ciubotariu 向我介绍了这种分析文件的方法，并创建了本文中使用的字体。感谢 Geoffrey So 和 Andrew Gardner 为本文提供建议和反馈。</p></div></div>    
</body>
</html>