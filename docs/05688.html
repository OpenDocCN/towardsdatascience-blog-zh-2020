<html>
<head>
<title>NLP goes hand in hand with graphs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自然语言处理与图形密切相关</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/nlp-and-graphs-go-hand-in-hand-with-neo4j-and-apoc-e57f59f46845?source=collection_archive---------6-----------------------#2020-05-12">https://towardsdatascience.com/nlp-and-graphs-go-hand-in-hand-with-neo4j-and-apoc-e57f59f46845?source=collection_archive---------6-----------------------#2020-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e5ac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用Neo4j设置NLP管道并分析其结果</h2></div><p id="4a5f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">准备好，因为今天我们将角色扮演《黑客帝国》中的<a class="ae lb" href="https://miro.medium.com/max/1400/1*WZZ9OWp3QJjcswTITitJKw.jpeg" rel="noopener"> Neo。在他得到启示的时刻之后，Neo意识到，尽管这个世界看起来非常混乱无序，但在所有这些混乱背后隐藏着一个结构化的绿色代码。我们将利用他在混乱中寻找隐藏结构的知识，并将其应用于文本。一旦我们戴上</a><a class="ae lb" href="https://imgur.com/a/eR1t5Sk" rel="noopener ugc nofollow" target="_blank"> Neo4j眼镜</a>，起初可能看起来只是无组织的混乱，很快就会变得非常结构化，充满洞察力。</p><h1 id="1e1e" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">议程</h1><ol class=""><li id="9a21" class="lu lv iq kh b ki lw kl lx ko ly ks lz kw ma la mb mc md me bi translated">设置Neo4j桌面</li><li id="a47e" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">图形导入</li><li id="d13f" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">文本分类</li><li id="9059" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">命名实体识别</li><li id="5d99" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">情感分析</li><li id="fe96" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">二部网络的单部投影</li><li id="1eb0" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">社区检测</li><li id="d7c3" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la mb mc md me bi translated">数据丰富</li></ol><h1 id="4df5" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">设置Neo4j桌面环境</h1><p id="c4e6" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这是我们第一次在博客中使用<a class="ae lb" href="https://neo4j.com/developer/neo4j-desktop/" rel="noopener ugc nofollow" target="_blank"> Neo4j桌面</a>。可以在<a class="ae lb" href="https://neo4j.com/download-center/" rel="noopener ugc nofollow" target="_blank"> Neo4j下载中心</a>获得。这是一个GUI应用程序，它使本地Neo4j数据库的管理更加舒适和方便，因为它提供了只需几次点击就可以启动数据库实例等功能。由于这也可能是您第一次与它交互，我准备了一个简短的指南，介绍如何设置Neo4j环境并做好一切准备。</p><p id="a978" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">成功安装Neo4j桌面后，您应该能够在显示器上看到图形界面。我们将通过点击<strong class="kh ir">添加数据库</strong>按钮来创建一个新的数据库实例。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/e2bbe8628395f777f403ae07f0433a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/0*oW5A6mNAiSLEJo8B.png"/></div></figure><p id="8426" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择<strong class="kh ir">创建本地图形，</strong>设置密码，按<strong class="kh ir">创建</strong>。我们现在已经成功地实例化了一个新的数据库。下一步是向数据库实例添加插件。单击数据库实例右上角的三个点，并选择<strong class="kh ir">管理</strong>。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/69223264cc500b5c30542ee298df753e.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/0*BOUYFFYsh1wZa8TY.png"/></div></div></figure><p id="1722" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">转到<strong class="kh ir">插件</strong>选项卡，安装您需要的插件。对于这篇博文，你将需要<a class="ae lb" href="https://github.com/neo4j-contrib/neo4j-apoc-procedures" rel="noopener ugc nofollow" target="_blank"> APOC </a>和<a class="ae lb" href="https://github.com/neo4j/graph-data-science" rel="noopener ugc nofollow" target="_blank">图形数据科学</a>插件。</p><p id="4978" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="na">附言:是的，GDS图书馆现已推出Neo4j 4.x版本</em></p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/2a1841f54254edfcb89875fa60fb33d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/0*nTuGikqFUuPRXl0h.png"/></div></figure><p id="0d99" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://neo4j.com/docs/labs/apoc/current/nlp/" rel="noopener ugc nofollow" target="_blank"> APOC NLP程序</a>存储在一个单独的文件中，因此，我们必须手动安装它们。我们可以安装任何自定义插件，只需将其复制到插件文件夹。打开如下所示的插件文件夹，将<a class="ae lb" href="https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases" rel="noopener ugc nofollow" target="_blank"> APOC NLP依赖关系</a>复制到那里。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/4ea78eed00ab28cf925e4627b8215444.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*x1KCbul-R4YLFGr9.png"/></div></figure><h1 id="798d" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">APOC静态值存储器</h1><p id="8f86" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">APOC允许我们在<a class="ae lb" href="https://neo4j.com/docs/labs/apoc/current/misc/static-values/" rel="noopener ugc nofollow" target="_blank">静态值存储器</a>中存储敏感信息，比如JDBC凭证或API密钥。可以把它看作是Neo4j的环境文件，我们在其中定义了以后可以用cypher轻松访问的变量。我们将把GCP和AWS凭证存储在静态值存储中。第一步是获取API凭证:</p><ul class=""><li id="2940" class="lu lv iq kh b ki kj kl km ko nd ks ne kw nf la ng mc md me bi translated"><a class="ae lb" href="https://developers.google.com/places/web-service/get-api-key" rel="noopener ugc nofollow" target="_blank">如何获得谷歌证书</a></li><li id="b167" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated"><a class="ae lb" href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys" rel="noopener ugc nofollow" target="_blank">如何获取AWS凭证</a></li></ul><p id="a6e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获得凭证后，我们继续在<code class="fe nh ni nj nk b">$Neo4j/conf</code>文件夹中创建<code class="fe nh ni nj nk b">apoc.conf</code>。将这三行存储在文件中。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="30fd" class="np ld iq nk b gy nq nr l ns nt">apoc.static.aws.apiKey=$yourAwsApiKey<br/>apoc.static.aws.apiSecret=$yourAwsApiSecret<br/>apoc.static.gcp.apiKey=$yourGcpApiKey</span></pre><p id="f43c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以启动Neo4j实例，并调查静态存储是否按照查询的预期工作。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="1404" class="np ld iq nk b gy nq nr l ns nt">RETURN apoc.static.getAll("aws") AS aws;</span></pre><p id="d2f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该会看到类似这样的内容:</p><p id="6d43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">美国焊接协会</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="a3fa" class="np ld iq nk b gy nq nr l ns nt">{<br/>  "apiKey": "$yourapiKey",<br/>  "apiSecret": "$yourapiSecret"<br/>}</span></pre><p id="9a89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果到目前为止您已经成功地完成了所有步骤，那么您应该有一个添加了APOC NLP和GDS库的Neo4j实例在运行。如果您不想设置静态值存储，只需将您的云凭证直接复制并粘贴到查询中即可。</p><h1 id="36d4" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">图形导入</h1><p id="d1c4" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们将使用由Kevin Toms提供的新闻数据集。它包含大约10000篇新闻文章的内容。该数据集于2019年1月编制。不幸的是，作者没有提供关于数据集的来源和时间线的信息。在开始之前，我们必须下载数据集并将其复制到导入文件夹。您可以从Neo4j桌面访问导入文件夹，如下所示。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e300f5028818b3662741b4cd86e29e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*o9C-Huje4ACZJ2gn.png"/></div></figure><p id="e5a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将每篇文章作为一个单独的节点导入，标题和内容作为节点的属性存储。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="5ea5" class="np ld iq nk b gy nq nr l ns nt">LOAD CSV WITH HEADERS FROM "file:///text_summarizer_data.csv" as row<br/>CREATE (a:Article{title:row.title, content: row.content})</span></pre><h1 id="b498" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">用谷歌进行文本分类</h1><p id="0c0a" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们将从由谷歌的<a class="ae lb" href="https://cloud.google.com/natural-language/docs" rel="noopener ugc nofollow" target="_blank">自然语言API </a>支持的<a class="ae lb" href="https://neo4j.com/docs/labs/apoc/current/nlp/gcp/#nlp-gcp-classify" rel="noopener ugc nofollow" target="_blank"> APOC文本分类程序</a>开始我们的分析。它将输入文本分为不同的内容类别。据我所知，它对新闻文章最有效，但对虚构文学不太有效。谷歌每月提供30，000个免费分类请求，所以这足够启动一个爱好项目了。</p><p id="b822" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们需要处理10.000篇文章，我们将使用<code class="fe nh ni nj nk b">apoc.periodic.iterate </code>过程来处理批处理过程。在<a class="ae lb" href="https://neo4j.com/docs/labs/apoc/current/graph-updates/periodic-execution/#commit-batching" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多信息。这个过程需要几分钟，所以在你等待的时候，请随意喝杯咖啡或者做你最喜欢的瑜伽姿势。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="ea37" class="np ld iq nk b gy nq nr l ns nt">CALL apoc.periodic.iterate("<br/>   // get all articles<br/>   MATCH (node:Article) RETURN node<br/>  ","<br/>   // classify each article<br/>   CALL apoc.nlp.gcp.classify.graph(node, {<br/>       // we retrieve gcp api key from static value storage<br/>       key: apoc.static.get('gcp.apiKey'),<br/>       // node property that contains the text<br/>       nodeProperty: 'content',<br/>       write:true<br/>    }) YIELD graph RETURN distinct 'done'",<br/>    {batchSize:10})</span></pre><p id="f9a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你啜饮美味的咖啡时，我们可以看看分类的结果。让我们从查看一些类别名称的例子开始，这样我们就知道我们在处理什么了。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="cb6b" class="np ld iq nk b gy nq nr l ns nt">MATCH (n:Category)<br/>RETURN n.name as category<br/>LIMIT 5</span></pre><p id="5d07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e0ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类别名称的深度在一至三层之间。级别由斜杠字符(<code class="fe nh ni nj nk b">/</code>)分隔。比如<em class="na">"/新闻"</em>只包含一级，而<em class="na">"/金融/保险"</em>包含两级类别。我们将提取每个分类名称的顶级类别，并将其存储回我们的图中。这将使我们能够更直接地根据顶级类别进行筛选和分组。新的图表模式将如下所示:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nw"><img src="../Images/1b34b8fcba4c15c48a5f57298b9099e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vMM7TDEVl8cCBo1g.png"/></div></div></figure><p id="3b16" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Neo4j 中处理<a class="ae lb" href="https://tbgraph.wordpress.com/2017/04/01/neo4j-location-trees/" rel="noopener ugc nofollow" target="_blank">层次树时，我学到了一些规则，可以帮助我们简化和优化查询。其中之一是我们应该在整个树中只有一个单一的关系类型。这样，我们可以很容易地查询一个或两个层次的深度，正如我们将看到的。</a></p><p id="f460" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们为顶级类别节点定义一个惟一的约束。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="a184" class="np ld iq nk b gy nq nr l ns nt">CREATE CONSTRAINT ON (t:TopCategory) ASSERT t.name IS UNIQUE;</span></pre><p id="0b4e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过拆分分类名称来提取和存储顶级类别。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="337f" class="np ld iq nk b gy nq nr l ns nt">MATCH (n:Category)<br/>WITH n, split(n.name,'/')[1] as top_level<br/>MERGE (t:TopCategory{name:top_level})<br/>MERGE (n)-[:CATEGORY]-&gt;(t)</span></pre><p id="de14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过顶级类别来查看文章的数量。您可以观察到，由于我们在类别树中只处理一种关系类型，所以遍历两个层次非常简单。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="f19c" class="np ld iq nk b gy nq nr l ns nt">MATCH (t:TopCategory)<br/>RETURN t.name as category, <br/>       size((t)&lt;-[:CATEGORY*2..2]-()) as number_of_articles<br/>ORDER BY number_of_articles DESC LIMIT 10</span></pre><p id="ed84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d880" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的一点是，查询结果显示的文章比图表中实际显示的要多。这是因为有些文章有不止一个分类。我们将通过查看来自科学类别的两篇文章的内容来快速检查结果。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="8b04" class="np ld iq nk b gy nq nr l ns nt">MATCH (t:TopCategory{name:"Science"})&lt;-[:CATEGORY*2..2]-(article)<br/>RETURN article.content as text LIMIT 2</span></pre><p id="7bf3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1be1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两篇文章似乎都非常关注科学和技术。我们并没有对结果进行深入的分析，但是我们会假设自然语言API很好地完成了对新闻文章进行分类的工作。</p><h1 id="985c" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">命名实体识别</h1><p id="857c" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">本质上，NER是一个识别文本中各种实体并将它们按类别(如人员、组织、位置等)分组的过程。我们寻找的实体类型完全取决于用例。有时我们想知道在给定的文章中提到了哪些人和组织，而其他时候我们可能更有兴趣知道提到了哪些基因和蛋白质。有很多预先训练好的模型可供你使用，如果没有一个适合你，你可以训练你自己的NER模型，但是这超出了这篇博文的范围。让我们看一个在上面的科学文章中找到的命名实体的例子。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nx"><img src="../Images/3db25a0cb83dca030978d3b526dad922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nDcwR8NM0W198rTv.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">用<a class="ae lb" href="https://explosion.ai/demos/displacy-ent?text=%22The%20SI%20unit%20of%20mass%20is%20redefined%20using%20the%20Planck%20constant%20as%20the%20129-year-old%20physical%20prototype%20of%20the%20kilogram%20retires.%20The%20new%20system%20uses%20a%20Kibble%20balance%20where%20weight%20is%20balanced%20against%20an%20electromagnetic%20force.%20Conceptualised%20in%201975%20by%20late%20British%20physicist%20Bryan%20Kibble%2C%20the%20latest%20Kibble%20balance%20can%20measure%20Planck%20constant%20with%20uncertainties%20in%20a%20few%20parts%20per%20billion.%22&amp;model=en_core_web_sm&amp;ents=person%2Corg%2Cgpe%2Cloc%2Cproduct%2Cnorp%2Cdate%2Cper%2Cmisc%2Cevent%2Cwork_of_art%2Clanguage%2Ctime%2Cpercent" rel="noopener ugc nofollow" target="_blank">显示</a>可视化</p></figure><p id="da5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以观察到，该模型善于发现文本中的人物和组织，但并不完美。我们真的不能怪它给“Kibble”贴上组织的标签。该模型被训练来识别新闻文章中的人和组织，而不是真正被设计来阅读科学文章。AWS和GCP都在其云API组合中提供了自己的NER模型。我们将在两个随机的故事中比较它们，并选择更适合我们的用例。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="0f34" class="np ld iq nk b gy nq nr l ns nt">MATCH (node:Article)<br/>WITH node LIMIT 2<br/>RETURN node.content as text</span></pre><p id="da16" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="3b34" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">NER和GCP</h1><p id="6203" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们将从使用Google的自然语言API识别命名实体开始。有一个专用的APOC过程<code class="fe nh ni nj nk b">apoc.nlp.gcp.entities.*</code>，这使得与API的交互非常容易。该程序有两种不同的模式:</p><ul class=""><li id="3327" class="lu lv iq kh b ki kj kl km ko nd ks ne kw nf la ng mc md me bi translated">串流:串流结果</li><li id="f3a8" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">图形:创建一个虚拟图形，并选择性地存储结果</li></ul><p id="a35a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用程序的<strong class="kh ir">图形</strong>模式。如上所述，图形模式创建了一个虚拟图形，我们可以用Neo4j浏览器来可视化它。通过设置参数<code class="fe nh ni nj nk b">write:false</code>，我们不会将结果存储回Neo4j。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="2ad0" class="np ld iq nk b gy nq nr l ns nt">MATCH (node:Article)<br/>WITH node LIMIT 2<br/>CALL apoc.nlp.gcp.entities.graph(node, {<br/>    // Your api key<br/>    key: apoc.static.get('gcp.apiKey'),<br/>    // Property of the node that<br/>    // contains the text<br/>    nodeProperty: 'content',<br/>    // do not store results in graph<br/>    write:false<br/>}) YIELD graph as g<br/>RETURN g</span></pre><p id="bfd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/5b26a01d5de0bf7a6b4e0c1c25eb9946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/0*EISjbiQvOjWhq34o.png"/></div></figure><p id="9be2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实体类型:</p><ul class=""><li id="59aa" class="lu lv iq kh b ki kj kl km ko nd ks ne kw nf la ng mc md me bi translated">绿色:人</li><li id="f2cc" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">蓝色:数字</li><li id="3b3c" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">橙色:位置</li><li id="5c7b" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">红色:其他</li><li id="4459" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">黄色:事件</li></ul><p id="dbef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GCP发现了五种不同类型的实体。如果我们看看实体类型的人，我们会注意到，在“艾琳·麦肯”之上，GCP也把“母亲”和“女人”这样的词作为一个人。有趣的是，它将“搜索”识别为一个事件。在我看来，GCP试图给尽可能多的词贴上标签，这可能是一件好事，也可能是一件坏事，取决于用例。</p><h1 id="42b4" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">带AWS的NER</h1><p id="1b24" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">与GCP类似，我们也有专门的APOC程序<code class="fe nh ni nj nk b">apoc.nlp.aws.entities.*</code>用于AWS NER请求。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="bcbf" class="np ld iq nk b gy nq nr l ns nt">MATCH (n:Article)<br/>WITH n LIMIT 2<br/>CALL apoc.nlp.aws.entities.graph(n, {<br/>    // AWS api key<br/>    key: apoc.static.get('aws.apiKey'),<br/>    // AWS api secret<br/>    secret: apoc.static.get('aws.apiSecret'),<br/>    // Property of the node<br/>    // that contains the text<br/>    nodeProperty: 'content',<br/>    write:false<br/>}) YIELD graph as g<br/>RETURN g</span></pre><p id="9b14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi od"><img src="../Images/5d5877ec64850eaafd1e650a341e4496.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/0*3rIC6SefuFIOVNme.png"/></div></figure><p id="ab57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实体类型:</p><ul class=""><li id="9b8d" class="lu lv iq kh b ki kj kl km ko nd ks ne kw nf la ng mc md me bi translated">绿色:人</li><li id="5604" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">布朗:组织</li><li id="b0e3" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">橙色:日期</li><li id="99e0" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">红色:位置</li><li id="0e87" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">黄色:数量</li><li id="5583" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">蓝色:商业项目</li></ul><p id="c18b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乍一看，我们可以观察到AWS找到的实体比GCP少。它也不包括人实体下的“女人”和“母亲”这样的词。我的观点是，如果你试图做某种主题建模，那么GCP可能更适合，而对于创建知识图，AWS可能更好。我们将使用AWS来分析和提取数据库中所有文章的实体。因为我们需要批处理我们的NER过程，我们将使用<code class="fe nh ni nj nk b">apoc.periodic.iterate</code>过程。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="e301" class="np ld iq nk b gy nq nr l ns nt">CALL apoc.periodic.iterate("<br/>    MATCH (n:Article)<br/>    WITH collect(n) as total<br/>    // Create a batch of 25 articles<br/>    CALL apoc.coll.partition(total,25) <br/>    YIELD value as nodes<br/>    RETURN nodes<br/>    ","<br/>    CALL apoc.nlp.aws.entities.graph(nodes, {<br/>       key: apoc.static.get('aws.apiKey'),<br/>       secret: apoc.static.get('aws.apiSecret'),<br/>       nodeProperty: 'content',<br/>       relationshipType: 'AWS_ENTITY',<br/>       // store the results to Neo4j<br/>       write:true<br/>    }) YIELD graph<br/>     RETURN distinct 'done'", {batchSize:1})</span></pre><p id="4725" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你抓紧时间，在NER结束之前，你还有时间做另一个伟大的瑜伽姿势。让我知道进展如何。好了，我们现在可以检查NER进程的结果了。我们将从调查文章中提到最多的人开始。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="58a9" class="np ld iq nk b gy nq nr l ns nt">MATCH (n:PERSON) <br/>RETURN n.text as person, <br/>       size((n)&lt;-[:AWS_ENTITY]-()) as mentions<br/>ORDER BY mentions DESC LIMIT 10</span></pre><p id="4378" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="964f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们选择AWS是因为它不包括person type下的“orphan”或“genealogist”这样的词。我想没有一个模型是完美的，因为我们可以看到“项目经理”、“首席执行官”和“总裁”是作为人实体出现的。解决这个问题的一个方法是添加<a class="ae lb" href="https://nlp.stanford.edu/projects/coref.shtml" rel="noopener ugc nofollow" target="_blank">共指解析</a>作为NER管道的一个步骤，但是由于我们正在处理第三方NLP管道，我们没有这个闲心。现在让我们看看体育文章中提到最多的人。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="cd1d" class="np ld iq nk b gy nq nr l ns nt">MATCH (n:PERSON) <br/>RETURN n.text as person,  <br/>    size((n)&lt;-[:AWS_ENTITY]-()-[:CATEGORY*2..2]-&gt;({name:'Sports'})) as mentions<br/>ORDER BY mentions DESC LIMIT 10</span></pre><p id="8200" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d9ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有十大提及的体育名人都是印度板球运动员。Virat Kohli确实很突出，所以我猜他是队长。这种NER提取法的一个弱点是Virat Kohli和Kohli被视为两个独立的实体。这可以解释，他有时被提到全名，其他时候只提到姓。另一个有趣的用例是查看哪些位置和事件共享了最多的文章。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="608d" class="np ld iq nk b gy nq nr l ns nt">MATCH (a:Article)-[:AWS_ENTITY]-&gt;(event:EVENT),<br/>      (a)-[:AWS_ENTITY]-&gt;(location:LOCATION)<br/>RETURN location.text as location,<br/>       event.text as event,<br/>       count(*) as mentions<br/>ORDER BY mentions DESC<br/>LIMIT 10</span></pre><p id="720f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d797" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果看起来相当不错。看起来像CES 2019在拉斯维加斯举行，联合印度在加尔各答举行集会，20国集团在阿根廷举行论坛，世界经济论坛在达沃斯举行。除此之外，英国和欧盟还在讨论英国退出欧盟问题。</p><h1 id="cc7f" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">情感分析</h1><p id="e9b8" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">AWS还在其<a class="ae lb" href="https://aws.amazon.com/comprehend/" rel="noopener ugc nofollow" target="_blank">理解</a> API包中提供<a class="ae lb" href="https://en.wikipedia.org/wiki/Sentiment_analysis" rel="noopener ugc nofollow" target="_blank">情绪分析</a>。它将文本分为四个不同的情感组:</p><ul class=""><li id="b761" class="lu lv iq kh b ki kj kl km ko nd ks ne kw nf la ng mc md me bi translated">积极的</li><li id="a463" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">中立的</li><li id="f652" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">否定的；消极的；负面的；负的</li><li id="ec77" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">混合的</li></ul><p id="9ae6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将对所有文章进行情感分析。我认为新闻应该或多或少是中性的，除了体育。有一个特殊的APOC程序<code class="fe nh ni nj nk b">apoc.nlp.aws.sentiment.*</code>使用与NER处理程序相同的两种模式(流&amp;图)处理AWS情绪API请求。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="c401" class="np ld iq nk b gy nq nr l ns nt">CALL apoc.periodic.iterate("<br/>    MATCH (n:Article)<br/>    WITH collect(n) as total<br/>    CALL apoc.coll.partition(total,25) <br/>    YIELD value as nodes<br/>    RETURN nodes<br/>    ","<br/>    CALL apoc.nlp.aws.sentiment.graph(nodes, {<br/>       key: apoc.static.get('aws.apiKey'),<br/>       secret: apoc.static.get('aws.apiSecret'),<br/>       nodeProperty: 'content',<br/>       write:true<br/>    }) YIELD graph<br/>     RETURN distinct 'done'", {batchSize:1})</span></pre><p id="210c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将看看体育文章中被AWS理解为积极的人和事件的共同提及。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="9572" class="np ld iq nk b gy nq nr l ns nt">MATCH (a:Article)<br/>WHERE a.sentiment = 'Positive' AND <br/>      (a)-[:CATEGORY*2..2]-&gt;({name:'Sports'})<br/>MATCH (a)-[:AWS_ENTITY]-&gt;(person:PERSON),<br/>      (a)-[:AWS_ENTITY]-&gt;(event:EVENT)<br/>RETURN person.text as person,<br/>       event.text as event,<br/>       count(*) as mentions<br/>ORDER BY mentions DESC LIMIT 10</span></pre><p id="5c97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c333" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来网球运动员正在赢得网球比赛。由Virat Kohli担任队长的印度板球队赢得了2011年世界杯和墨尔本测试赛。从结果来看，我大概是这么想的。</p><h1 id="e762" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">图形数据科学图书馆</h1><p id="858b" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">如果你读过我的博客文章，你就会知道我喜欢写关于<a class="ae lb" href="https://github.com/neo4j/graph-data-science" rel="noopener ugc nofollow" target="_blank">图形数据科学库</a>的文章。这个博客也不例外。首先，我们将借助<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/current/algorithms/node-similarity/" rel="noopener ugc nofollow" target="_blank">节点相似性算法</a>将一个二分网络投影到一个一分网络。在下一步中，我们将使用<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/" rel="noopener ugc nofollow" target="_blank"> Louvain算法</a>在投影的单分图中搜索社区。</p><h1 id="a6fc" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">二部网络的单部投影</h1><p id="b581" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">二分网络只是一种奇特的说法，即图包含两组不同的节点，同样，一个一分网络只包含一组节点。在我们的例子中，我们将从一个包含文章和NER实体的双向网络开始。下一步，我们将借助GDS 的<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/current/algorithms/similarity/" rel="noopener ugc nofollow" target="_blank">相似性算法，把它投射到一个单片式网络上。这里有一个图表，显示了幕后实际发生的事情。</a></p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oe"><img src="../Images/1344ff890dcc205bef917e1a44a22860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hL4v_JqeVl9VJhsc.png"/></div></div></figure><p id="85b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把单向投射看作是把间接关系转化为直接关系的过程。相似性算法之间的区别只是用于计算相似性得分或权重的度量。例如，节点相似性算法使用<a class="ae lb" href="https://en.wikipedia.org/wiki/Jaccard_index" rel="noopener ugc nofollow" target="_blank"> Jaccard相似性分数</a>。它被定义为交集的大小除以并集的大小。如果我们愿意，我们也可以投射一个由文章而不是人组成的单部分网络，并检查相似的文章是如何基于其中提到的实体的。</p><p id="08dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们运行任何算法之前，让我们快速回顾一下GDS图书馆是如何工作的。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi of"><img src="../Images/6cb17720937e204f0b2438e54a74316f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8xULK19_FixWaNor.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated"><em class="og">这个形象是善意地借用了</em> <a class="ae lb" href="https://neo4j.com/docs/graph-data-science/current/common-usage/" rel="noopener ugc nofollow" target="_blank"> <em class="og">官方文件</em> </a></p></figure><p id="e848" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图表分析管道由三个主要部分组成。在第一部分中，图形加载器从Neo4j中读取存储的图形，并将其作为内存中的投影图形加载。我们可以使用<a class="ae lb" rel="noopener" target="_blank" href="/exploring-the-graph-catalog-feature-of-neo4j-graph-data-science-plugin-on-a-lord-of-the-rings-d2de0d0a023">本机投影</a>或<a class="ae lb" rel="noopener" target="_blank" href="/how-to-use-cypher-projection-in-neo4j-graph-data-science-library-on-a-lord-of-the-rings-social-b3459138c4f1"> cypher投影</a>来加载投影图。第二步，我们按顺序执行图算法。我们可以使用一个图算法的结果作为另一个图算法的输入。最后但同样重要的是，我们将结果存储或流回Neo4j。</p><p id="b3e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用cypher投影来加载内存中的图形。如果你需要快速复习一下它是如何工作的，我建议你看一下官方文档。在node语句中，我们将描述顶级新闻类别中的所有文章以及所有person实体。在关系陈述中，我们将描述新闻文章和人实体之间的所有链接。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="a87b" class="np ld iq nk b gy nq nr l ns nt">CALL gds.graph.create.cypher("person_similarity",<br/> // match articles that are in the 'News' category<br/> "MATCH (a:Article) WHERE (a)-[:CATEGORY*2..2]-&gt;({name:'News'})<br/>  RETURN id(a) as id, labels(a) as labels<br/>  UNION<br/>  // match all person entities<br/>  MATCH (p:PERSON) RETURN id(p) as id, labels(p) as labels<br/>  ","<br/>  // match all links between news articles and person entities<br/>  MATCH (a:Article)-[r:AWS_ENTITY]-&gt;(p:PERSON) <br/>  WHERE (a)-[:CATEGORY*2..2]-&gt;({name:'News'})<br/>  RETURN id(p) as source, id(a) as target, type(r) as type")</span></pre><p id="34d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是在节点相似性算法的帮助下推断人实体之间的相似性网络。我们可以用以下三个参数来影响相似性网络的稀疏或密集程度:</p><ul class=""><li id="a29b" class="lu lv iq kh b ki kj kl km ko nd ks ne kw nf la ng mc md me bi translated">DegreeCutoff:算法必须考虑的节点的最少链接数</li><li id="cbcb" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">similarityCutoff:仍被视为相似的一对节点之间的最小相似性得分</li><li id="0380" class="lu lv iq kh b ki mf kl mg ko mh ks mi kw mj la ng mc md me bi translated">topK:对每个节点相似关系数量的限制</li></ul><p id="c673" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，我们很少或根本不知道图会有多稀疏。我们绝对不想以一个<a class="ae lb" href="https://en.wikipedia.org/wiki/Complete_graph" rel="noopener ugc nofollow" target="_blank">完整的图</a>结束。我们可以用算法的<code class="fe nh ni nj nk b">stats</code>模式来评价相似度网络。这样，在对上述三个参数进行微调之前，我们不会存储或改变任何结果。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="4fb4" class="np ld iq nk b gy nq nr l ns nt">CALL gds.nodeSimilarity.stats('person_similarity')<br/>YIELD nodesCompared, similarityDistribution<br/>RETURN nodesCompared as nodes,<br/>       apoc.math.round(similarityDistribution.min,2) as min, <br/>       apoc.math.round(similarityDistribution.p25,2) as p25, <br/>       apoc.math.round(similarityDistribution.p50,2) as p50,<br/>       apoc.math.round(similarityDistribution.p75,2) as p75,<br/>       apoc.math.round(similarityDistribution.p90,2) as p90,<br/>       apoc.math.round(similarityDistribution.mean,2) as mean</span></pre><p id="a973" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="cf70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乍一看，节点似乎不是很相似。这很好。我们想推断一个稀疏网络，因为社区检测算法在非常密集的图上表现不佳。确定最佳的相似性参数值需要艺术和科学的结合，但是有了一些经验，你会变得很擅长。我们将把<code class="fe nh ni nj nk b">similarityCutoff</code>设置为0.6，同时将<code class="fe nh ni nj nk b">degreeCutoff</code>和<code class="fe nh ni nj nk b">topK</code>参数保留为默认值。使用<code class="fe nh ni nj nk b">mutate</code>模式，我们将算法的结果存储回内存中的投影图。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="6c80" class="np ld iq nk b gy nq nr l ns nt">CALL gds.nodeSimilarity.mutate('person_similarity', <br/>    {degreeCutoff:1, similarityCutoff:0.6, topK:10,<br/>     mutateRelationshipType: 'SIMILAR', mutateProperty: 'score'})</span></pre><h1 id="81c4" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">社区检测</h1><p id="0d12" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">社区检测算法旨在帮助我们理解复杂网络的结构。最明显的应用是在社交网络中寻找朋友群体。我们认为社区是一组紧密相连的节点，类似于一群朋友是如何高度互联的。让我们看看一些社区结构的可视化，以获得更好的理解。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oh"><img src="../Images/77195ada34e24bcd559659fc3c1807b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xSCHArOuz7Sk8Hu9.png"/></div></div></figure><p id="a5c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我几年前做的一个可视化，当时我正在分析漫威宇宙中的社区结构。节点的颜色表示组从属关系。我们可以观察到，社区由高度互连的节点组成，这些节点与其他集群的链接较少。在这篇博文中，我们将使用<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/" rel="noopener ugc nofollow" target="_blank"> Louvain算法</a>来检查我们推断的相似性网络的社区结构。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="854b" class="np ld iq nk b gy nq nr l ns nt">CALL gds.louvain.stream('person_similarity', <br/>    {nodeLabels:['PERSON'], relationshipTypes:['SIMILAR']})<br/>YIELD nodeId, communityId<br/>RETURN communityId, <br/>        collect(gds.util.asNode(nodeId).text) as members<br/>ORDER BY size(members) DESC LIMIT 5</span></pre><p id="ae20" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="550c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发现的社区相对较小。这是<code class="fe nh ni nj nk b">similarityCutoff</code>参数值的直接结果。如果我们选择一个较低的阈值，更多的节点将被认为是相似的，我们可能会得到更大的社区。同样，如果我们增加数据集的规模，多处理几千篇文章，我们也会得到更大的社区。也就是说，是时候进入数据丰富的章节，为我们的实体添加一些上下文了。</p><h1 id="af21" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">数据丰富</h1><p id="0c43" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们在图表中发现了几个小社区。有些人相当有名，不难找到社区成员之间的共同点。例如，我知道哈里森·福特、哈莉·贝瑞和吉姆·帕森斯都是演员，所以我会假设其他人也是演员。我们可以去谷歌一下。一个更好的想法是，使用外部数据提供者，如<a class="ae lb" href="https://developers.google.com/knowledge-graph" rel="noopener ugc nofollow" target="_blank"> Google Knowledge Graph </a>或<a class="ae lb" href="https://www.wikidata.org/wiki/Wikidata:Main_Page" rel="noopener ugc nofollow" target="_blank"> WikiData </a>，有计划地丰富我们图表中的实体。这正是我们下一步要做的。</p><p id="2ce0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将只充实在前一个查询中返回的人员(前五个最大社区的成员)。为了避免多次运行社区检测，我们将首先把Louvain算法的结果存储回Neo4j。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="0941" class="np ld iq nk b gy nq nr l ns nt">CALL gds.louvain.write('person_similarity', <br/>    {nodeLabels:['PERSON'], relationshipTypes:['SIMILAR'], <br/>     writeProperty:'louvain'})</span></pre><h1 id="98f8" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">谷歌知识图</h1><p id="9193" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">很久以前我已经在我的一篇<a class="ae lb" href="https://tbgraph.wordpress.com/2017/03/07/neo4j-apoc-triggers-and-web-apis/" rel="noopener ugc nofollow" target="_blank">博客文章</a>中使用了谷歌知识图API。我写作的原因之一是我有一个有用的cypher查询库，我可以从中复制粘贴并在以后的分析中使用。</p><p id="9375" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用知识图API通过描述和详细描述属性来丰富最大社区的成员。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="1ec5" class="np ld iq nk b gy nq nr l ns nt">// get the members of the top five communities<br/>MATCH (p:PERSON)<br/>WITH p.louvain as communityId, collect(p) as members <br/>ORDER BY size(members) DESC LIMIT 5<br/>UNWIND members as member<br/>WITH member, apoc.text.urlencode(member.text) as name, <br/>     apoc.static.get('gcp.apiKey') as key<br/>// send a request to KG API<br/>CALL apoc.load.json("https://kgsearch.googleapis.com/v1/entities:search?query=" + <br/>     name + "&amp;key=" + key + "&amp;limit=1&amp;indent=True")  YIELD value<br/>WITH member, value['itemListElement'][0]['result'] as results<br/>// store results back to Neo4j<br/>SET member.kg_description = results.description,<br/>    member.kg_detailed_description = results.detailedDescription.articleBody</span></pre><p id="b491" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来看看最大的五个人群，包括他们的知识图表描述。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="b294" class="np ld iq nk b gy nq nr l ns nt">MATCH (p:PERSON)<br/>RETURN p.louvain as communityId, <br/>       collect(p.text) as members,<br/>       collect(DISTINCT p.kg_description) as description <br/>ORDER BY size(members) DESC LIMIT 5</span></pre><p id="7244" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="6d47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着丰富描述的增加，我们对谁是社区成员有了更好的认识。我们可以观察到最大的集群由网球运动员组成。知识图表没有识别第二大组的任何成员。然而，它知道“乌鲁比亚”实际上是印度的一个城市，而不是一个人。</p><h1 id="c7b4" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">维基数据浓缩</h1><p id="f86c" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我订阅每周一期的twin4j开发者简讯的主要原因是我可以从其他人那里复制粘贴密码查询。马克·李约瑟做了一个关于如何用密码查询维基数据的系列。他做了所有的艰苦工作，所以我们可以通过复制粘贴他的密码查询来享受他的劳动成果。他还开发了我们刚刚使用的APOC NLP程序，这是对Mark的称赞！</p><p id="ed62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于那些以前从未听说过<a class="ae lb" href="https://www.wikidata.org/wiki/Wikidata:Main_Page" rel="noopener ugc nofollow" target="_blank"> Wikidata </a>的人来说，他们将自己描述为一个自由开放的知识库，可以被人类和机器阅读和编辑。检查了一下之后，我可以说它的信息非常丰富，绝对值得一看。我们将向最大社区的成员添加出生日期、职业和国籍信息。查看<a class="ae lb" href="https://query.wikidata.org/" rel="noopener ugc nofollow" target="_blank">维基数据查询服务</a>了解更多关于数据丰富选项的细节。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="368c" class="np ld iq nk b gy nq nr l ns nt">CALL apoc.periodic.iterate(<br/>  // get all persons from the biggest five communities<br/>  "MATCH (p:PERSON) <br/>   WITH p.louvain as communityId, <br/>          collect(p) as members <br/>          ORDER BY size(members) DESC LIMIT 5<br/>   UNWIND members as member<br/>   RETURN member<br/>   ","<br/>    // prepare a sparql query<br/>    WITH 'SELECT *<br/>    WHERE { ?person<br/>                  rdfs:label \"' + member.text + '\"@en ;<br/>                  wdt:P569 ?dateOfBirth ;                <br/>                  wdt:P106 [ rdfs:label ?occupation ] ;<br/>                  wdt:P27 [ rdfs:label ?countryName ] .<br/>           filter(lang(?countryName) = \"en\" &amp;&amp; lang(?occupation) = \"en\")<br/>           }' AS sparql, member<br/>    // make a request to wikidata<br/>    CALL apoc.load.jsonParams(<br/>      \"https://query.wikidata.org/sparql?query=\" + apoc.text.urlencode(sparql),<br/>      { Accept: \"application/sparql-results+json\"},<br/>      null<br/>    )<br/>    YIELD value</span><span id="331f" class="np ld iq nk b gy oi nr l ns nt">    CALL apoc.do.when(<br/>      // if there are any results<br/>      size(value.results.bindings) &gt; 0,<br/>      // store results<br/>      'WITH value.results.bindings[0] AS result, member<br/>       SET member.dateOfBirth = date(datetime(result.dateOfBirth.value)),<br/>           member.wikidataImportDone = true<br/>       // store nationality<br/>       MERGE (c:Country {name: result.countryName.value })<br/>       MERGE (member)-[:NATIONALITY]-&gt;(c)<br/>       // store occupation<br/>       MERGE (o:Occupation {name: result.occupation.value})<br/>       MERGE (member)-[:HAS_OCCUPATION]-&gt;(o)<br/>       RETURN member',<br/>      // else if no results <br/>      'SET member.wikidataImportDone = true RETURN member',<br/>      {value: value, member: member})<br/>    YIELD value AS result<br/>    RETURN count(*)",<br/>  {batchSize: 20})</span></pre><p id="2497" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来看看最大的社区，包括我们从维基数据获得的额外信息。</p><pre class="mo mp mq mr gt nl nk nm nn aw no bi"><span id="6cc0" class="np ld iq nk b gy nq nr l ns nt">MATCH (p:PERSON) <br/>RETURN p.louvain as communityId,<br/>       collect(p.text) as members,<br/>       apoc.math.round(avg(duration.inMonths(p.dateOfBirth, date()).years),2) as average_age,<br/>       collect(distinct [(p)-[:NATIONALITY]-&gt;(n) | n.name][0]) as nationalities,<br/>       collect(distinct [(p)-[:HAS_OCCUPATION]-&gt;(o) | o.name][0]) as occupations<br/>ORDER BY size(members) DESC LIMIT 5</span></pre><p id="1241" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oj"><img src="../Images/5ef523896e649cb17a516b06f87e047d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XSiknUYWe5MdIXnl.png"/></div></div></figure><p id="2205" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果看起来令人印象深刻。我打赌你不知道至少有两个人叫吉姆·帕森斯。其中一个是演员，另一个是赛车手。我们只是触及了维基数据API提供的信息的表面。</p><h1 id="f79a" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">结论</h1><p id="0a52" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">如果你还在这里，我向你致敬。这是我迄今为止最长的一篇博文。尽管有时感觉就像我在写一本迷你书或我那本不存在的书的一个章节，但我很高兴，因为我认为它真的很好，我在这个过程中学到了很多。我希望你也是。如果你喜欢它，并希望我写更长的帖子，请让我知道。同时，你可以下载<a class="ae lb" href="https://neo4j.com/" rel="noopener ugc nofollow" target="_blank"> Neo4j </a>并开始开发你自己的NLP管道。别忘了订阅<a class="ae lb" href="https://neo4j.com/tag/twin4j/" rel="noopener ugc nofollow" target="_blank"> Twin4j简讯</a>。</p><p id="ce31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码可在<a class="ae lb" href="https://github.com/tomasonjo/blogs/blob/master/apoc_nlp_procedures/APOC%20NLP%20procedures.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>