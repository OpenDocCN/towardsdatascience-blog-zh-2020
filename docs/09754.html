<html>
<head>
<title>Building Dashboards using Dash (&lt; 200 lines of code)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Dash ( &lt; 200 lines of code)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-dashboards-using-dash-200-lines-of-code-ae0be08d805b?source=collection_archive---------5-----------------------#2020-07-11">https://towardsdatascience.com/building-dashboards-using-dash-200-lines-of-code-ae0be08d805b?source=collection_archive---------5-----------------------#2020-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/d88121ba85774268a46910b5ba62875b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*uoRI0zobzzrhjHcIbWnm9w.png"/></div><p class="iy iz gj gh gi ja jb bd b be z dk translated">Image credits: Clipartmax.com</p></figure><div class=""/><p id="483d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">构建仪表板仪表板是以有组织的方式可视化数据的用户界面(ui)。业务仪表板通常包含与特定目标或业务流程相关的关键绩效指标(KPI)的信息。仪表板是一个“快照”报告，它允许我们借助图表以有意义的方式显示给定时刻的数据，以便于参考和快速推断。</em></p><p id="5150" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有用的仪表板的一些属性包括:</p><ul class=""><li id="4e34" class="la lb je kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><strong class="kd jf">可定制</strong>:一个优秀的仪表盘工具必须允许用户根据需要定制。</li><li id="0604" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd jf">可访问的</strong>:应该可以在各种媒体格式，如网络，移动等。适合在旅途中观看。</li><li id="1683" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd jf">可伸缩</strong>:应该有添加/更改 KPI 和添加/更改数据源的能力。</li></ul><p id="afd8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如今仪表板有各种形状和大小。许多公司推出现成的仪表板服务，如 SaaS。该软件通常有工作区，用户可以在其中拖放数据列和 KPI。最重要的仪表板工具之一是 Tabealu，它是一个独立的软件，允许用户构建强大的仪表板。然而，如果一个人想要构建他们的仪表板工具，他必须学习很多可视化、数据库管理和脚本的技术。下面是对所涉及的一些技术的简要概述(注意，这并不详尽):</p><p id="b970" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">仪表板的组件</strong>技术<strong class="kd jf">技术</strong></p><ol class=""><li id="704f" class="la lb je kd b ke kf ki kj km lc kq ld ku le ky lo lg lh li bi translated">可视化 D3，React JavaScript</li><li id="42ae" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lo lg lh li bi translated">数据库管理 SQL、AWS、MongoDB</li><li id="f977" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lo lg lh li bi translated">脚本语言 R-shiny，Python，Java，Cpp</li></ol><p id="61e0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用 Python，我们有几个选择:</p><p id="a7bc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae lp" href="https://plot.ly/dash" rel="noopener ugc nofollow" target="_blank"> <strong class="kd jf"> Dash </strong> </a> : Dash 是一个强大的开源库，可以帮助使用 Plotly、Flask 和 React 构建交互式和实时的基于 web 的仪表盘。</p><p id="6e36" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae lp" href="https://github.com/jupyter/dashboards" rel="noopener ugc nofollow" target="_blank"> <strong class="kd jf"> Jupyter 仪表板:</strong> </a>仪表板布局扩展是 Jupyter 笔记本的附加组件。它允许用户在表格或报告中安排笔记本输出，就像格式一样，并保存这种布局。其他用户需要安装该扩展才能查看此报告。</p><p id="16f8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae lp" href="https://pyxley.readthedocs.io/en/latest/why.html" rel="noopener ugc nofollow" target="_blank"><strong class="kd jf">Pyxley</strong></a>:Pyxlex 是构建仪表板的另一个绝佳选择。它利用 React 和 Flask。然而，对此的支持和文档是有限的。</p><p id="6dea" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae lp" href="https://demo.bokehplots.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd jf"> Bokeh </strong> </a>:使用 D3 和 Tornado 的 web dashboard 工具可能需要一些 JavaScript 知识。</p><p id="46c8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">几更</strong> : <a class="ae lp" href="https://github.com/jwkvam/bowtie" rel="noopener ugc nofollow" target="_blank">蝴蝶结</a>，<a class="ae lp" href="https://dataspyre.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Spyre </a>，<a class="ae lp" href="https://superset.incubator.apache.org/installation.html" rel="noopener ugc nofollow" target="_blank">超集</a></p><p id="30ac" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用<strong class="kd jf">破折号</strong>是因为:</p><ul class=""><li id="4e02" class="la lb je kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><strong class="kd jf">易于使用:</strong>构建于 Plotly 和 React 之上，因此它易于编码，并且有许多可用的小部件。你只需要知道 Python 不需要学习 React 或者 D3。但是，如果您了解 React，那么 Dash 允许您通过一个包含的工具集将 React 组件打包成 Dash 可用的组件，从而插入 React 的广泛生态系统。</li><li id="ba87" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd jf">文档</strong> : Dash 有很好的文档记录，在 Stack Overflow 和 Github 上有一个很好的响应社区。</li></ul></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="d3e1" class="lx ly je bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">MVC 中的仪表板</h1><p id="1ab3" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">大多数用户界面遵循 MVC 框架，MVC 是指模型-视图-控制器。每个相互连接的组件都是为承担开发过程中的特定任务而构建的。</p><p id="7ae9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">型号</strong>:型号是仪表盘的心脏。该模型从数据库中获取数据，对其进行操作，并将其存储在对象中，这些对象稍后可以被视图使用。</p><p id="4c0f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">控制器</strong>:控制器是用户与仪表板交互的方式。它通常从模型中请求数据，并将其呈现给视图。</p><p id="1808" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">视图</strong>:视图是数据呈现给用户或前端的地方。视图监视仪表板的可视部分。</p><p id="ff36" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">MVC 框架降低了应用程序的复杂性，使其更易于维护；例如，开发人员可以选择更改 UI，而不需要更改任何支持代码。为了更基本的理解，我们将从 MVC 的角度来看 Dash。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi na"><img src="../Images/9029d9112bd89fa6dce0ca77b7d83109.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*NAGSMb_45A7w3YzqvtMt_g.png"/></div></div><p class="iy iz gj gh gi ja jb bd b be z dk translated">图 1 MVC 图表</p></figure><h1 id="da54" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">Dash 入门</h1><p id="7f08" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">如前所述，Dash 是一个简单的 Python 工具，可以帮助我们快速构建美观且响应迅速的 web 仪表盘。它同时支持 R 和 Python，由 Plotly 维护。它使用 React 作为控制器和视图，使用 Plotly 和 Flask 作为 MVC 设置中的模型。我们构建了一个 flask 应用程序，它在 web 浏览器上创建了一个仪表板，可以调用后端来重新呈现 web 页面的某些部分。</p><h1 id="137e" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">装置</h1><p id="b127" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">使用<code class="fe no np nq nr b">pip</code>可以非常容易地安装<code class="fe no np nq nr b">Dash</code>和<code class="fe no np nq nr b">Plotly</code>。建议使用虚拟环境管理器(如<code class="fe no np nq nr b">Conda</code>)。</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="662e" class="nw ly je nr b gy nx ny l nz oa">pip install dash==0.26.3  # The core dash backend<br/>pip install dash-renderer==0.13.2  # The dash front-end<br/>pip install dash-html-components==0.11.0  # HTML components<br/>pip install dash-core-components==0.28.1  # Supercharged components<br/>pip install dash_table_experiments #for tables<br/>pip install plotly --upgrade # Plotly graphing library</span></pre><p id="0af1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于数据操作，我们安装了<code class="fe no np nq nr b">pandas</code>。</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="bdcb" class="nw ly je nr b gy nx ny l nz oa">pip install pandas</span></pre><p id="e16d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请查看<a class="ae lp" href="https://dash.plot.ly/installation" rel="noopener ugc nofollow" target="_blank">仪表板安装指南</a>以获取这些工具的最新版本。</p><p id="e6f3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们转到问题陈述。</p><h1 id="dc1c" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">问题陈述</h1><p id="5c92" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">在之前的帖子中，我们谈到了使用 Scrapy 构建我们自己的<a class="ae lp" rel="noopener" target="_blank" href="/byod-build-your-own-dataset-for-free-67133840dc85?source=---------6------------------">数据集，这教会了我们如何使用网络抓取来下载数据。我们从</a><a class="ae lp" href="http://www.metacritic.com/" rel="noopener ugc nofollow" target="_blank">Metacritic.com</a>图书馆下载了有史以来的前 500 张专辑。以下是数据集的快照:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ob"><img src="../Images/1ba3cfa88ded3c75979c8877538a8de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgFSofDMUlbHQNrQxiVYnQ.png"/></div></div></figure><p id="4185" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们看到每张专辑都有流派、艺术家、发行日期、元评分和用户评分。</p><p id="46b7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将构建一个包含以下四个组件的仪表板:</p><ol class=""><li id="0da7" class="la lb je kd b ke kf ki kj km lc kq ld ku le ky lo lg lh li bi translated">类型的交互式气泡图</li><li id="0e05" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lo lg lh li bi translated">每个流派十年流行度直方图(条形图)</li><li id="d192" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lo lg lh li bi translated">元得分/用户得分趋势(折线图)</li><li id="93dd" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lo lg lh li bi translated">按元评分/用户评分列出的前 10 位最受欢迎的艺术家列表</li></ol><p id="4d75" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用户可以通过下拉菜单与条形图进行交互，根据平均元分数或平均用户分数获得前 10 名艺术家。用户还可以与气泡图进行交互；在悬停时，它会改变条形图，给出该流派每十年出版的专辑数量。</p><h1 id="7791" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">实体模型</h1><p id="4ef3" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">在纸上或使用软件(Adobe Illustrator 和 Balsamiq 是专业人士使用的很好的工具)建立一个小的仪表板模型是一个很好的实践。</p><p id="f11f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，我们使用 MS PowerPoint 构建了一个简单的静态视图。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oc"><img src="../Images/003366e0f94f45086a7d9c8cd92f5321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P71Y83faU7vqVBKtQLRGew.png"/></div></div><p class="iy iz gj gh gi ja jb bd b be z dk translated"><em class="od">图 2 仪表板模型</em></p></figure><h1 id="16c8" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">MVC 框架中的 Dash</h1><p id="e9e1" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">我们将把我们的 dash 组件分成三个部分:</p><ol class=""><li id="b4f5" class="la lb je kd b ke kf ki kj km lc kq ld ku le ky lo lg lh li bi translated"><strong class="kd jf">数据操作(模型):</strong>执行从文件中读取数据的操作，并操作数据进行显示</li><li id="b2a4" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lo lg lh li bi translated"><strong class="kd jf">仪表板布局(视图):</strong>在网页上直观地呈现数据</li><li id="f3fe" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lo lg lh li bi translated"><strong class="kd jf">组件(控制器)之间的交互:</strong>将用户输入转换为数据操作和重新渲染的命令。</li></ol><h1 id="70b7" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">初始化</h1><p id="ad04" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">这里我们导入相关的库。</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="3c27" class="nw ly je nr b gy nx ny l nz oa">import dash<br/>import dash_core_components as dcc<br/>import dash_html_components as html<br/>import dash_table_experiments as dt<br/>import pandas as pd<br/>import plotly.graph_objs as go<br/>from dash.dependencies import Input, Output, State, Event<br/>import random</span></pre><h1 id="e127" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">数据操作(模型)</h1><p id="bdce" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">这里我们在一个<code class="fe no np nq nr b">csv</code>中有数据，所以我们可以使用<code class="fe no np nq nr b">pandas</code>简单地导入它。然而，如果数据在一个<code class="fe no np nq nr b">SQL</code>数据库或者某个地方的服务器上，我们需要建立一个数据连接，将数据连接到我们后端的熊猫数据框架，剩下的过程将是相同的。</p><h2 id="6ed4" class="nw ly je bd lz oe of dn md og oh dp mh km oi oj ml kq ok ol mp ku om on mt oo bi translated">熊猫的数据操作</h2><p id="ad60" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">我们假设读者有关于熊猫的基本知识，并且能够理解数据操作。基本上，我们为每个仪表板组件创建了 4 个主表:</p><ol class=""><li id="e9fe" class="la lb je kd b ke kf ki kj km lc kq ld ku le ky lo lg lh li bi translated"><strong class="kd jf"> df_linechart </strong>:该表按年份对数据进行分组，给出了专辑数量、平均元评分和平均用户评分。我们还将用户分数乘以 10，以得到与元分数相同的分数。这将用于绘制分数趋势图。</li><li id="4ce5" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lo lg lh li bi translated"><strong class="kd jf"> df_table </strong>:该表按艺术家对数据进行分组，并给出专辑数量、总元评分和总用户评分。generate_table 函数使用这个表获得按用户得分或元得分排序的前 10 行。这是用来画表的。</li><li id="8e1e" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lo lg lh li bi translated"><strong class="kd jf"> df_bubble: </strong>此表按流派对数据进行分组，并给出专辑数量、平均元评分和平均用户评分。专辑的数量成为我们气泡的大小，平均分数成为坐标轴。这是用来画气泡图的。</li><li id="a059" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lo lg lh li bi translated"><strong class="kd jf"> df2_decade: </strong>此表按流派和十年对数据进行分组，并返回每个十年中每个流派的专辑数量。这是用来画条形图的。</li></ol><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="f417" class="nw ly je nr b gy nx ny l nz oa">##############################################################<br/>#DATA MANIPULATION (model)<br/>##############################################################</span><span id="9f09" class="nw ly je nr b gy op ny l nz oa">df= pd.read_csv("top500_albums_clean.csv")<br/>df['userscore'] = df['userscore'].astype(float)<br/>df['metascore'] = df['metascore'].astype(float)<br/>df['releasedate']=pd.to_datetime(df['releasedate'], format='%b %d, %Y')<br/>df['year']=df["releasedate"].dt.year<br/>df['decade']=(df["year"]//10)*10<br/>#cleaning Genre<br/>df['genre'] = df['genre'].str.strip()<br/>df['genre'] = df['genre'].str.replace("/", ",")<br/>df['genre'] = df['genre'].str.split(",")<br/>#year trend<br/>df_linechart= df.groupby('year')  .agg({'album':'size', 'metascore':'mean', 'userscore':'mean'})  .sort_values(['year'], ascending=[True]).reset_index()<br/>df_linechart.userscore=df_linechart.userscore*10<br/>#table<br/>df_table= df.groupby('artist').agg({'album':'size', 'metascore':'sum', 'userscore':'sum'})<br/>#genrebubble<br/>df2=(df['genre'].apply(lambda  x: pd.Series(x)) .stack().reset_index(level=1, drop=True).to_frame('genre').join(df[['year', 'decade', 'userscore', 'metascore']], how='left') )<br/>df_bubble=  df2.groupby('genre')  .agg({'year':'size', 'metascore':'mean', 'userscore':'mean'})  .sort_values(['year'], ascending=[False]).reset_index().head(15)<br/>df2_decade=df2.groupby(['genre', 'decade']).agg({'year':'size'}) .sort_values(['decade'], ascending=[False]).reset_index()</span></pre><h1 id="c33c" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">仪表板布局(视图)</h1><p id="e26f" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">布局决定了仪表板在部署后的外观。Dash 为所有组件提供了 Python 类。组件保存在<code class="fe no np nq nr b">dash_core_components</code>和<code class="fe no np nq nr b">dash_html_components</code>库中。你也可以用<code class="fe no np nq nr b">JavaScript</code>和<code class="fe no np nq nr b">React</code>构建自己的组件。</p><h2 id="0f9a" class="nw ly je bd lz oe of dn md og oh dp mh km oi oj ml kq ok ol mp ku om on mt oo bi translated">响应式布局简介</h2><p id="82a3" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">我们为我们的仪表板使用了一个<a class="ae lp" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank">引导</a>布局。简单地说，Bootstrap 通过在网格中包含组件来标准化组件的位置。它将屏幕分成 12 列，我们可以定义任意多的行。</p><p id="5b06" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们的仪表板将看起来像这样:</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="ae6b" class="nw ly je nr b gy nx ny l nz oa">Row<br/>    Column-12 (title)<br/>Row<br/>    Column-6 (Table of most top 10 popular artist)<br/>    Column-6 (Meta-score/User-score trends- line chart)</span><span id="3645" class="nw ly je nr b gy op ny l nz oa">Row<br/>    Column-6 (Interactive Bubble chart of genres)<br/>    Column-6 (Histogram of decade popularity (bar chart)</span></pre><p id="41c3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是模型的另一个可视化:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi oq"><img src="../Images/9dd9d1ac4f57bbea3612b63141686ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lUkEvsxnLxIIeYtUcNA2-Q.png"/></div></div><p class="iy iz gj gh gi ja jb bd b be z dk translated">图 3 带有引导网格的实体模型</p></figure><h2 id="0468" class="nw ly je bd lz oe of dn md og oh dp mh km oi oj ml kq ok ol mp ku om on mt oo bi translated">添加样式</h2><p id="a5fc" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">我们可以使用<code class="fe no np nq nr b">.append.css</code>命令将自定义的<code class="fe no np nq nr b">CSS</code>添加到我们的仪表板中。</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="0d25" class="nw ly je nr b gy nx ny l nz oa">app = dash.Dash()<br/>app.css.append_css({<br/>"external_url": "  https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"<br/>})</span></pre><p id="78ee" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还添加了引导所需的<code class="fe no np nq nr b">JavaScript</code>库。最新版本请参考<a class="ae lp" href="https://getbootstrap.com/docs/4.0/getting-started/introduction/" rel="noopener ugc nofollow" target="_blank">引导页面</a>:</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="034e" class="nw ly je nr b gy nx ny l nz oa"># Bootstrap Javascript.<br/>app.scripts.append_script({<br/>"external_url": "https://code.jquery.com/jquery-3.2.1.slim.min.js"<br/>})<br/>app.scripts.append_script({<br/>"external_url": "https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"<br/>})</span></pre><h2 id="3bd0" class="nw ly je bd lz oe of dn md og oh dp mh km oi oj ml kq ok ol mp ku om on mt oo bi translated">布局基础</h2><p id="a074" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">布局骨架可以定义为</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="4edc" class="nw ly je nr b gy nx ny l nz oa">html.Div(  <br/>[  <br/>SOME_DASH_OR_HTML_COMPONENT(  <br/>	id,  <br/>	content (data),  <br/>	style (a dictionary with the properties))  <br/>], className (name of the Bootstrap Class)  <br/>)</span></pre><p id="c450" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe no np nq nr b">classname</code>将是引导类名，可以是行或列。</p><p id="69b6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">多亏了<code class="fe no np nq nr b">core components</code>，Dash 使得绘制图形变得非常容易。我们可以使用函数来绘制组件，也可以内联编写代码。</p><p id="cfee" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">添加表</strong></p><p id="d117" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用<code class="fe no np nq nr b">html.Table</code>标签或者导入<code class="fe no np nq nr b">Plotly</code>表格。这里我们使用 html 原生表。</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="884c" class="nw ly je nr b gy nx ny l nz oa">def  generate_table(dataframe, max_rows=10):</span><span id="c8e1" class="nw ly je nr b gy op ny l nz oa">'''Given dataframe, return template generated using Dash components<br/>'''</span><span id="4cc5" class="nw ly je nr b gy op ny l nz oa">return html.Table(<br/># Header<br/>[html.Tr([html.Th(col) for col in dataframe.columns])] +<br/># Body<br/>[html.Tr([<br/>	html.Td(dataframe.iloc[i][col]) for col in dataframe.columns<br/>]) for i in  range(min(len(dataframe), max_rows))],</span><span id="7733" class="nw ly je nr b gy op ny l nz oa">style={'width': '100%', 'display': 'inline-block', 'vertical-align': 'middle'}<br/>)</span></pre><p id="61e9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简单地说，该函数获取一个<code class="fe no np nq nr b">pandas</code>数据帧，并将其强制转换为一个表。</p><p id="69a8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">图表</strong></p><p id="753e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Dash 使用<a class="ae lp" href="https://plot.ly/python/line-charts/#simple-line-plot" rel="noopener ugc nofollow" target="_blank"> Plotly 图形布局</a>。我们在一个<code class="fe no np nq nr b">dcc.Graph</code>组件中定义一个图形，在一个图形对象(定义为<code class="fe no np nq nr b">go</code>)中定义这个图形。在这个图形对象中，我们设置数据、样式和布局。每种类型的图表都有不同的相关组成部分。我们在这里讨论三种类型的图形:</p><p id="77f5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">添加线图</strong></p><p id="1394" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于线图，我们必须选择带有<code class="fe no np nq nr b">go.Scatter</code>的<code class="fe no np nq nr b">Scatter</code>类型的图，在模式中，我们定义<code class="fe no np nq nr b">lines</code>，如下所示。我们还需要为每条线定义<code class="fe no np nq nr b">x</code>和<code class="fe no np nq nr b">y</code>的数据。</p><p id="f05a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在布局部分，我们可以选择显示图例、标题和其他样式元素。</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="4f67" class="nw ly je nr b gy nx ny l nz oa">html.Div(<br/>[ #Line Chart<br/>dcc.Graph(id='line-graph',<br/>figure=go.Figure(<br/>	data = [<br/>	go.Scatter(<br/>		x = df_linechart.year,<br/>		y = df_linechart.userscore,<br/>		mode = 'lines',<br/>		name = 'user score'<br/>		),<br/>	go.Scatter(<br/>		x = df_linechart.year,<br/>		y = df_linechart.metascore,<br/>		mode = 'lines',<br/>		name = 'meta score'<br/>		),<br/>	],<br/>	layout=go.Layout(title="Score trends")<br/>)),], className = "col-md-6"</span></pre><p id="dd36" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加气泡图</p><p id="0c0f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类似地，对于气泡图，我们定义了一个<code class="fe no np nq nr b">go.Scatter</code>，但是使用了<code class="fe no np nq nr b">mode = markers</code>。我们还可以定义一个文本组件，当鼠标悬停在标记上时，它会给出文本。稍后在我们的动态视图中将使用此文本填充我们的第四个条形图“<strong class="kd jf">十年流行度</strong>”。</p><p id="4a75" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe no np nq nr b">Markers</code>是图表上的点或气泡，我们可以通过传递带有各种选项的字典对象来进一步定制标记:</p><p id="e247" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">颜色</strong>:用于<code class="fe no np nq nr b">markers</code>的<code class="fe no np nq nr b">colors</code>列表，可以是颜色的名称，也可以是色标的数字列表。这里我传递了一个 0 到 100 之间的随机数字列表。</p><p id="72bc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">尺寸</strong> : <code class="fe no np nq nr b">Size</code>指定气泡的尺寸。这里我们把专辑的数量作为大小。所以专辑数量越多的流派泡沫越大。通过尺寸，我们可以通过传递<code class="fe no np nq nr b">sizemode</code>、<code class="fe no np nq nr b">sizeref</code>和<code class="fe no np nq nr b">sizemin</code>组件来进一步定制尺寸。</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="cf04" class="nw ly je nr b gy nx ny l nz oa">html.Div([<br/>dcc.Graph(id='bubble-chart',<br/>	figure=go.Figure(<br/>		data=[<br/>			go.Scatter(<br/>				x=df_bubble.userscore,<br/>				y=df_bubble.metascore,<br/>				mode='markers',<br/>				text=df_bubble.genre,<br/>				marker=dict(<br/>					color= random.sample(range(1,200),15),<br/>					size=df_bubble.year,<br/>					sizemode='area',<br/>					sizeref=2.*max(df_bubble.year)/(40.**2),<br/>					sizemin=4<br/>))],<br/>layout=go.Layout(title="Genre poularity")<br/>))], className = "col-md-6"<br/>),</span></pre><p id="a209" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">添加条形图</strong></p><p id="135f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们使用一个函数绘制一个条形图。注意，我们可以直接把这个部分粘贴到 html <code class="fe no np nq nr b">div</code>中，但是因为我们希望这个图形是交互式的，所以我们使用了一个可以在回调中使用的函数。我们用<code class="fe no np nq nr b">go.Bar</code>。</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="f60e" class="nw ly je nr b gy nx ny l nz oa">def  bar(results):<br/>gen =results["points"][0]["text"]<br/>figure = go.Figure(<br/>	data=[<br/>	go.Bar(x=df2_decade[df2_decade.genre==gen].decade, 	y=df2_decade[df2_decade.genre==gen].year)<br/>	],<br/>	layout=go.Layout(<br/>	title="Decade popularity of " + gen<br/>))<br/>return figure</span></pre><p id="2e20" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们已经线框应用程序下一步，我们填充数据和添加控件。整个布局代码:</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="72b4" class="nw ly je nr b gy nx ny l nz oa">#generate table<br/>def  generate_table(dataframe, max_rows=10):<br/>'''Given dataframe, return template generated using Dash components<br/>'''<br/>return html.Table(<br/># Header<br/>	[html.Tr([html.Th(col) for col in dataframe.columns])] +<br/># Body<br/>	[html.Tr([html.Td(dataframe.iloc[i][col]) for col in dataframe.columns]) for i in  range(min(len(dataframe), max_rows))],</span><span id="b69a" class="nw ly je nr b gy op ny l nz oa">	style={'width': '100%', 'display': 'inline-block', 'vertical-align': 'middle'}<br/>)</span><span id="e5e9" class="nw ly je nr b gy op ny l nz oa">#generate bar chart<br/>def  bar(results):<br/>	gen =results["points"][0]["text"]<br/>	figure = go.Figure(<br/>		data=[<br/>			go.Bar(x=df2_decade[df2_decade.genre==gen].decade, y=df2_decade[df2_decade.genre==gen].year)<br/>		],<br/>	layout=go.Layout(<br/>		title="Decade popularity of " + gen<br/>	))<br/>	return figure</span><span id="a363" class="nw ly je nr b gy op ny l nz oa"># Set up Dashboard and create layout<br/>app = dash.Dash()<br/># Bootstrap CSS.<br/>app.css.append_css({<br/>"external_url": "https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"<br/>})<br/># Bootstrap Javascript.<br/>app.scripts.append_script({<br/>"external_url": "https://code.jquery.com/jquery-3.2.1.slim.min.js"<br/>})<br/>app.scripts.append_script({<br/>"external_url": "https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"<br/>})<br/>#define app layout<br/>app.layout =  html.Div([<br/>	html.Div([<br/>		html.Div([<br/>			html.H1("Music Dashboard", className="text-center", id="heading")<br/>			], className = "col-md-12"<br/>			),<br/>		],className="row"),<br/>	html.Div(<br/>		[ #dropdown and score<br/>		html.Div([<br/>			html.Div(<br/>				[<br/>				dcc.Dropdown(<br/>				options=[<br/>					{'label': 'userscore', 'value': 'userscore'},<br/>					{'label': 'metascore', 'value': 'metascore'},<br/>				],<br/>				id='score-dropdown'<br/>				)<br/>		], className="col-md-12"),</span><span id="6be7" class="nw ly je nr b gy op ny l nz oa">	html.Div(<br/>		html.Table(id='datatable', className = "table col-md-12")),<br/>		],className="col-md-6"),<br/>	html.Div(<br/>		[ #Line Chart<br/>		dcc.Graph(id='line-graph',<br/>	figure=go.Figure(<br/>		data = [<br/>		go.Scatter(<br/>			x = df_linechart.year,<br/>			y = df_linechart.userscore,<br/>			mode = 'lines',<br/>			name = 'user score'<br/>			),<br/>		go.Scatter(<br/>			x = df_linechart.year,<br/>			y = df_linechart.metascore,<br/>			mode = 'lines',<br/>			name = 'meta score'<br/>			),<br/>		],<br/>		layout=go.Layout(title="Score trends")<br/>		)<br/>		),<br/>		], className = "col-md-6"<br/>	),<br/>	], className="row"),<br/>	html.Div(<br/>		[<br/>		html.Div(<br/>			[<br/>			dcc.Graph(id='bubble-chart',<br/>			figure=go.Figure(<br/>			data=[<br/>				go.Scatter(<br/>				x=df_bubble.userscore,<br/>				y=df_bubble.metascore,<br/>				mode='markers',<br/>				text=df_bubble.genre,<br/>			marker=dict(<br/>				color= random.sample(range(1,200),15),<br/>				size=df_bubble.year,<br/>				sizemode='area',<br/>				sizeref=2.*max(df_bubble.year)/(40.**2),<br/>				sizemin=4<br/>				)<br/>			)<br/>		],<br/>	layout=go.Layout(title="Genre poularity")<br/>	)<br/>	)<br/>	], className = "col-md-6"<br/>	),<br/>	html.Div(<br/>		[<br/>		dcc.Graph(id='bar-chart',<br/>			style={'margin-top': '20'})<br/>		], className = "col-md-6"<br/>		),<br/>		], className="row"),<br/>], className="container-fluid")</span></pre><p id="fac5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不要被代码的大小吓到。代码以这种方式格式化，以便于理解。注意每个 div 组件是如何定义一个类的。</p><h1 id="6229" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">组件之间的交互(控制器)</h1><p id="fe77" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">现在我们已经了解了布局，让我们来看看控制器。在这个控制面板中，我们有两个交互式组件，一个是根据分数类型变化的表格，另一个是根据所选类型填充的条形图，气泡图中的气泡。</p><p id="c454" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的控制器框架将看起来像:</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="6176" class="nw ly je nr b gy nx ny l nz oa">@app.callback(<br/>	Output(component_id='selector-id', component_property='figure'),<br/>		[<br/>		Input(component_id='input-selector-id',component_property='value')<br/>		]<br/>	)<br/>def ctrl_func(input_selection)</span></pre><p id="86e9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们有 4 个部分:</p><p id="d403" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">回调</strong> : <code class="fe no np nq nr b">@app.callback</code>是处理<strong class="kd jf">输入</strong>和<strong class="kd jf">输出</strong>的回调函数。我们的应用程序的<strong class="kd jf">输入</strong>和<strong class="kd jf">输出</strong>是特定组件的属性。</p><p id="a3c3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf"> Input </strong>:这将组件使用的<code class="fe no np nq nr b">id</code>作为输入，以及我们需要捕获的那个组件的属性。这可以是值、<code class="fe no np nq nr b">hoverData</code>、<code class="fe no np nq nr b">clickData</code>等等。</p><p id="dead" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">输出</strong>:输出获取要更改的组件的 id，以及通常会更改的属性，这可以是图形，也可以是子图形。</p><p id="24c4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">控制功能</strong> : <code class="fe no np nq nr b">cltr_function</code>定义了<strong class="kd jf">输出</strong>的 html 将如何变化。</p><p id="56f7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除此之外，我们还有<strong class="kd jf">状态</strong>，它允许我们添加除<strong class="kd jf">输入</strong>和<strong class="kd jf">输出</strong>之外的附加信息。</p><p id="ad08" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简而言之，应用回调自动捕捉输入中的任何变化，并根据<code class="fe no np nq nr b">cltr_function</code>定义更新输出。我们可以在一个回调中有多个输入和多个输出。</p><p id="b7b2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的例子中，回调的代码如下所示:</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="d3f7" class="nw ly je nr b gy nx ny l nz oa">##############################################################<br/>#DATA CONTROL (CONTROLLER)<br/>##############################################################</span><span id="bea1" class="nw ly je nr b gy op ny l nz oa">@app.callback(<br/>	Output(component_id='datatable', component_property='children'),<br/>	[Input(component_id='score-dropdown', component_property='value')]<br/>	)</span><span id="bbf9" class="nw ly je nr b gy op ny l nz oa">def  update_table(input_value):<br/>	return generate_table(df_table.sort_values([input_value], ascending=[False]).reset_index())</span><span id="826f" class="nw ly je nr b gy op ny l nz oa">@app.callback(<br/>	Output(component_id='bar-chart', component_property='figure'),<br/>	[Input(component_id='bubble-chart', component_property='hoverData')]<br/>	)</span><span id="8e38" class="nw ly je nr b gy op ny l nz oa">def  update_graph(hoverData):<br/>	return bar(hoverData)</span></pre><p id="315b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一次回调中，我们从下拉列表中给出输入。回调捕获下拉列表的值，并将其传递给生成给定表的函数更新表。然后，它将表格 html 数据传递给 datatable 组件，我们可以在仪表板中看到相关的表格。</p><p id="261d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第二次回调中，数据在悬停时从气泡图组件传递到条形函数。这个数据是一个字典，所以我们使用 text 键提取相关的流派细节，然后将数据传递给 bar 函数。条形图功能对给定流派的<code class="fe no np nq nr b">df_decade</code>数据进行子集划分，并绘制条形图。请注意这里涉及了多少不同的组件，而它只需要 10 行代码！</p><h1 id="54f8" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">初始化</h1><p id="c15b" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">需要在代码中添加以下两行来运行应用程序</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="b2c9" class="nw ly je nr b gy nx ny l nz oa">if  __name__ == '__main__':</span><span id="f58f" class="nw ly je nr b gy op ny l nz oa">app.run_server(debug=True)</span></pre><h1 id="8b79" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">运行应用程序</h1><p id="84d9" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">该应用程序可以通过以下方式运行:</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="6568" class="nw ly je nr b gy nx ny l nz oa">python app.py</span></pre><p id="34d6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们完事了。</p><p id="2c1c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您将看到如下消息:</p><blockquote class="or os ot"><p id="e2c7" class="kb kc kz kd b ke kf kg kh ki kj kk kl ou kn ko kp ov kr ks kt ow kv kw kx ky im bi translated"><em class="je">服务 Flask app“songsapp”(惰性加载)<br/>环境:生产<br/>警告:不要在生产环境中使用开发服务器。<br/>使用生产 WSGI 服务器。<br/>调试模式:在<br/>上运行</em><a class="ae lp" href="http://127.0.0.1:8050/" rel="noopener ugc nofollow" target="_blank"><em class="je">http://127 . 0 . 0 . 1:8050/</em></a><em class="je">(按 CTRL+C 退出)<br/>重启 stat <br/>调试器处于活动状态！<br/>调试器引脚:282–940–165</em></p></blockquote><p id="2d4b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仪表板在链接上可用(可在执行时更改参考您自己的代码执行中的链接):</p><pre class="nb nc nd ne gt ns nr nt nu aw nv bi"><span id="5bf6" class="nw ly je nr b gy nx ny l nz oa"><a class="ae lp" href="http://127.0.0.1:8050/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8050/</a></span></pre><p id="dea7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的仪表板看起来像:</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ox"><img src="../Images/f50d6c356ddb528ca8ca6bcaa90dec21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uoXjSDDRQjE8t2uvGfikOg.png"/></div></div><p class="iy iz gj gh gi ja jb bd b be z dk translated">图 4 运行中的仪表板</p></figure><h1 id="e646" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">后续步骤—托管</h1><p id="7d52" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">最后，我们的仪表板准备好了。下一步是将代码托管在服务器上，以便可以从任何设备访问它。虽然托管很容易，但涉及的步骤需要对托管有深入的理解。我们没有给读者增加新概念的负担，而是留给她一些主机教程的快速链接。这对经验丰富的开发人员和新手都有用。</p><p id="2478" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一些流行的托管选项有:</p><p id="8911" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf"> Heroku </strong> : Dash 有一个关于在 Heroku 上托管应用的<a class="ae lp" href="https://dash.plot.ly/deployment" rel="noopener ugc nofollow" target="_blank">简短教程</a>。或者，这里是 Heroku 的<a class="ae lp" href="https://devcenter.heroku.com/articles/getting-started-with-python#deploy-the-app" rel="noopener ugc nofollow" target="_blank">教程，用于部署 python 应用程序。</a></p><p id="6254" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">亚马逊关于部署 python 应用的教程。</p><h1 id="446e" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">结论</h1><p id="3cfd" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">这就是我们如何在&lt; 200 lines of code. To really understand the real power of dash, do check out the <a class="ae lp" href="https://dash.plot.ly/gallery/" rel="noopener ugc nofollow" target="_blank"> dash gallery </a>中构建一个简单而又互动的仪表板，以及人们用它完成的令人惊奇的事情。这篇文章的完整代码可以在这个<a class="ae lp" href="https://github.com/rra94/dash_dataquest" rel="noopener ugc nofollow" target="_blank"> git repo 中找到。</a></p><h1 id="d554" class="lx ly je bd lz ma nj mc md me nk mg mh mi nl mk ml mm nm mo mp mq nn ms mt mu bi translated">有用的资源</h1><p id="efdd" class="pw-post-body-paragraph kb kc je kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated"><a class="ae lp" href="https://dash.plot.ly/getting-started" rel="noopener ugc nofollow" target="_blank"> Dash 教程</a> <br/> <a class="ae lp" href="https://github.com/plotly/dash-core-components" rel="noopener ugc nofollow" target="_blank"> Dash 核心组件库</a> <br/> <a class="ae lp" href="https://dash.plot.ly/plugins" rel="noopener ugc nofollow" target="_blank">使用 Dash 编写自己的组件</a><br/><a class="ae lp" href="https://www.youtube.com/watch?v=J_Cy_QjG6NE&amp;list=PLQVvvaa0QuDfsGImWNt1eUEveHOepkjqt" rel="noopener ugc nofollow" target="_blank">Dash 视频教程</a></p></div></div>    
</body>
</html>