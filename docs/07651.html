<html>
<head>
<title>Pyro Top-Down Forecasting | Application-case</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pyro自上而下预测|应用案例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pyro-top-down-forecasting-application-case-4781eb2c8485?source=collection_archive---------48-----------------------#2020-06-08">https://towardsdatascience.com/pyro-top-down-forecasting-application-case-4781eb2c8485?source=collection_archive---------48-----------------------#2020-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d6fd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">将一段时间内的点连接起来，满怀信心地进行预测(-区间)。</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi kg"><img src="../Images/4b402011062da110d255ea9329210dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*qzzzC7L_DZrkeQRa3zKLLQ.jpeg"/></div><p class="ko kp gj gh gi kq kr bd b be z dk translated"><strong class="bd ks"> <em class="kf">跨越时间的连接点— </em> </strong> <em class="kf">照片由伊斯雷尔·帕拉西奥在Unsplash上拍摄</em></p></figure><p id="c268" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">你有没有想过如何解释时间序列预测中的不确定性？你有没有想过应该有一种方法从以前看到的数据中生成数据点，并对确定性做出判断？我知道我有。 <br/>如果你想建立捕捉概率并保持信心的模型，我们建议使用概率编程框架，如<a class="ae lq" href="https://pyro.ai/" rel="noopener ugc nofollow" target="_blank"> Pyro </a>。<br/>在之前的一篇<a class="ae lq" href="http://laplaceml.com/ngboost-incremental-forecasting/" rel="noopener ugc nofollow" target="_blank">文章</a>中，我们研究了NGBoosting，并将其应用于Kaggle上的M5预测挑战。简单回顾一下——M5预测挑战要求我们预测沃尔玛商品的销售将如何发展。它提供了来自不同州的不同商店的不同类别的商品的大约4-5年的数据，并要求我们预测我们没有信息的28天。作为对挑战和数据集的概述，我们仍然推荐这款<a class="ae lq" href="https://www.kaggle.com/headsortails/back-to-predict-the-future-interactive-m5-eda" rel="noopener ugc nofollow" target="_blank">令人惊叹的笔记本</a>。上次我们总结说，我们用Pyro得到了更好的结果，这里是一个简单的演示我们是如何做到这一点的。</p><p id="3578" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">随着时间的推移，有不同的方法来建模和预测数据。有<em class="lp">自顶向下模型</em>、<em class="lp">状态空间模型</em>和<em class="lp">层次模型</em>——仅举几个例子。在这篇文章中，我们看到了如何通过一个非常粗糙和基本的自顶向下的模型进行预测。我们充分利用了Pyro中现有的<strong class="kv ir">预测器</strong>对象。我们只是告诉模型如何做出明智的预测。之后，我们将所有数据转储到其中。就是这样——很简单！没有花哨的先验，没有花哨的潜在分布假设，只有数据和概率框架。我们还需要做一些假设，我们会带你经历这些。</p><pre class="kh ki kj kk gt lr ls lt lu aw lv bi"><span id="6a4f" class="lw lx iq ls b gy ly lz l ma mb">Sidenote: One more elegant way to do forecasting is with hierarchical models. These models allow accounting for different distributions over different categories in your data. You can assign individual priors and make use of information that you have about your model. The elegance of such an approach will be covered in another post.</span></pre><p id="6dbe" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">最后，我们将所有的时间序列信息转储到模型中，这是一段时间内的<em class="lp">销售</em>，同时将销售作为独立的随机事件保存。我们不用别的。<br/>Pyro编程框架，特别是<a class="ae lq" href="http://docs.pyro.ai/en/stable/contrib.forecast.html" rel="noopener ugc nofollow" target="_blank"> ForecastingModel </a>，是我们模型的引擎，我们还需要一个驱动程序。<br/>推动我们的模型朝着正确方向发展的因素是:</p><pre class="kh ki kj kk gt lr ls lt lu aw lv bi"><span id="79fc" class="lw lx iq ls b gy ly lz l ma mb">prediction = regressor + trend + seasonal + motion + bias</span></pre><p id="7a71" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">这一行简单的代码结合了我们随时间采样的Pyro对象。现在，让我们看看所有这些部分的含义:</p><h1 id="4b22" class="mc lx iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">构建模型</h1><p id="25d3" class="pw-post-body-paragraph kt ku iq kv b kw mt jr ky kz mu ju lb lc mv le lf lg mw li lj lk mx lm ln lo ij bi translated">实际模型零件由<strong class="kv ir">回归器</strong>捕获。这一部分寻找合适的模型权重，并将它们与直接来自数据输入的特征进行比较。每个权重都位于经典的高斯曲线上。这意味着我们从以零为中心、标准差为1 (μ=0，σ =1)的正态分布中采样。</p><pre class="kh ki kj kk gt lr ls lt lu aw lv bi"><span id="1512" class="lw lx iq ls b gy ly lz l ma mb">weight = pyro.sample("weight", dist.Normal(0, 1).expand(<br/>        [feature.size(-1)]).to_event(1))<br/> regressor = (weight * feature).sum(-1)</span></pre><p id="2e86" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">第二个参数是<strong class="kv ir">趋势</strong>。我们参考我们的概率窥镜，然后决定它应该来自对数正态分布，例如l∞LN，μ=-2，σ =1。一个关键的因素是我们考虑了我们提供给模型的时间特征。</p><pre class="kh ki kj kk gt lr ls lt lu aw lv bi"><span id="c431" class="lw lx iq ls b gy ly lz l ma mb">trend_coef = pyro.sample("trend", dist.LogNormal(-2, 1))<br/>trend = trend_coef * time</span></pre><p id="633d" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">现在没有<strong class="kv ir">季</strong>的趋势是什么？潮流来来去去，但季节是我们可以依靠的。我们知道基础数据描述了一段时间内的购买情况。我们认为销售额的变化是通过一周中的某一天来捕捉的。因此我们说</p><pre class="kh ki kj kk gt lr ls lt lu aw lv bi"><span id="a485" class="lw lx iq ls b gy ly lz l ma mb">with pyro.plate("day_of_week", 7, dim=-1):<br/>    seasonal = pyro.sample("seasonal", dist.Normal(0, 5))<br/>seasonal = periodic_repeat(seasonal, duration, dim=-1)</span></pre><p id="4ce6" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">这里我们使用了另一个简洁的烟火物体:<a class="ae lq" href="http://docs.pyro.ai/en/0.3.0-release/_modules/pyro/primitives.html#plate" rel="noopener ugc nofollow" target="_blank">盘子</a>。这种结构用于模拟随机事件的独立性。这意味着我们正在观察一个实例的发生。这个观察来自我们数据的每个时间步。彻底的解释可以在<a class="ae lq" href="https://pyro.ai/examples/svi_part_ii.html" rel="noopener ugc nofollow" target="_blank">烟火SVI教程</a>中找到。出于简单的目的，我们将其分解，并说我们认为数据在七天的窗口内上升和下降。我们将其转化为独立采样的事件。最后但并非最不重要的是，不仅仅有一个七天的间隔，但是我们<em class="lp">在我们所有给定的时间输入aka上周期性地重复</em>这个。我们的持续时间是时间张量的大小。</p><p id="b1d8" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">最后，每一个专业的ML模型都需要一些可训练的参数，以说明有时事情并不像你期望的那样好——我们称之为<strong class="kv ir">偏差</strong>。我们决定我们的偏差(b)来自一个正态分布，这样b∞N其中μ=0和σ =10或loc=0和scale=10，如果你想谈论Pyro。</p><pre class="kh ki kj kk gt lr ls lt lu aw lv bi"><span id="e898" class="lw lx iq ls b gy ly lz l ma mb">bias = pyro.sample("bias", dist.Normal(0, 10))</span></pre><p id="3031" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">在我们继续之前，让我们看看参数的分布。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi my"><img src="../Images/0b352c7f2cf47e920640395b8ef314bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*canWyoLfCSpNcBwpG23jKw.png"/></div><p class="ko kp gj gh gi kq kr bd b be z dk translated"><em class="kf">图1——根据颜色绘制的所有采样参数的密度图。y轴被截断，趋势对数正态分布的最大值为&gt; 2.5。</em></p></figure><p id="d576" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">你，细心的读者，可能会在这一点上得出结论。你有你需要的一切，我们同意。我们现在所拥有的足以给我们一个估计，并对未来几天做出预测。不过我们可以做得更好。到目前为止，我们预测的是一个非常僵硬的表达。模型被告知要符合输入，但我们不允许留有余地。为了便于讨论，让我们假设加州的所有人都决定在周四下午而不是周六去购物；或者危机发生，每个人都去为世界末日做准备。我们的模型可能已经正确预测了所有以前的星期六，但是那个星期四真的把它打乱了。为了解决这个问题，我们引入了一个叫做重新参数化的东西。有关该主题的详细概述，请参见[2]。<br/>为了使它更加健壮，我们通过另一个重新参数化来进行重新参数化——我们这样做的原因在这里<a class="ae lq" href="http://pyro.ai/examples/forecasting_i.html" rel="noopener ugc nofollow" target="_blank">解释</a>。<br/>将所有东西打包在一起，我们得到一个漂移，它定义了我们模型的<strong class="kv ir">运动</strong>。这就翻译成了烟火:</p><pre class="kh ki kj kk gt lr ls lt lu aw lv bi"><span id="ba56" class="lw lx iq ls b gy ly lz l ma mb">drift_stability = pyro.sample("drift_stability", dist.Uniform(1, 2))<br/>drift_scale = pyro.sample("drift_scale", dist.LogNormal(-17, 5))<br/>with self.time_plate:<br/>   with poutine.reparam(config={"drift": LocScaleReparam()}):<br/>      with poutine.reparam(config={"drift": SymmetricStableReparam()}):<br/>         drift = pyro.sample("drift", dist.Stable(drift_stability, 0, drift_scale))<br/>motion = drift.cumsum(dim=-1)</span></pre><p id="00c5" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">现在我们有了模型运行所需的一切。</p><h1 id="c6e5" class="mc lx iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">你的工作模型</h1><p id="d935" class="pw-post-body-paragraph kt ku iq kv b kw mt jr ky kz mu ju lb lc mv le lf lg mw li lj lk mx lm ln lo ij bi translated">对于实际的模型拟合部分，我们使用Pyro的随机变量推理机或SVI。这个算法允许我们在合理的时间内有效地计算后验分布。在我们的例子中，这样做是为了最大化证据下限或<a class="ae lq" href="https://pyro.ai/examples/svi_part_iii.html" rel="noopener ugc nofollow" target="_blank"> ELBO </a>。考虑ELBO的一个简单方法是观察两个不同的分布，一个当前分布和一个先前分布。如果分布相差很大，我们会得到一个低的ELBO值。另一方面，如果我已经拟合了一个好的分布，我的下一个可能也一样好，与已经观察到的一个很好地对齐，并且我得到一个高的ELBO值。有些人甚至会说两种分布的<em class="lp">差异被最小化</em>。要详细阅读它，我们可以参考SVI的原始论文(见<a class="ae lq" href="http://jmlr.org/papers/v14/hoffman13a.html" rel="noopener ugc nofollow" target="_blank">【3】</a>)。现在让我们假设这是可行的，因为聪明的研究人员已经充分实现了它。</p><pre class="kh ki kj kk gt lr ls lt lu aw lv bi"><span id="bdac" class="lw lx iq ls b gy ly lz l ma mb">We will go into the interplay of Stochastic Variational Inference and ELBO (or minimizing KL) in another article.</span></pre><p id="fb4a" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">现在，我们已经建立了一个工作模型，选择了我们的算法来计算我们的后验分布，我们必须设置超参数，加载数据并开始训练。对于数据处理，我们广泛关注github 上的<a class="ae lq" href="https://github.com/pyro-ppl/Pyro-M5-Starter-Kit" rel="noopener ugc nofollow" target="_blank"> M5初学者工具包实现，这是Pyro PPL团队慷慨提供的。这是一种简单的方法，可以对销售数据等进行汇总。请自行实现。这是了解张量的可靠方法。对于我们的初学者模型，我们只关心一段时间内的销售数据。<br/>我们现在设置参数并实例化预测器，如下所示:</a></p><pre class="kh ki kj kk gt lr ls lt lu aw lv bi"><span id="e34b" class="lw lx iq ls b gy ly lz l ma mb">forecaster_opt = {<br/>    "learning_rate": 0.1,<br/>    "learning_rate_decay": 0.1,<br/>    "clip_norm": 10,<br/>    "num_steps": 3501,<br/>    "log_every": 100,<br/>}<br/>forecaster = Forecaster(TopDownModel(), data, covariates[:-28], **forecaster_opt)<br/>samples = forecaster(data, covariates, num_samples=1000).exp().squeeze(-1).cpu()<br/>pred = samples.mean(0)</span></pre><p id="a38a" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">在上面的代码中，我们安装了预测器，它使用了一个<a class="ae lq" href="http://docs.pyro.ai/en/stable/optimization.html#pyro.optim.optim.DCTAdam" rel="noopener ugc nofollow" target="_blank"> DCTAdam </a>优化器。我们提供了培训的协变量，并保留了28天，我们在下面的行中将其用于实际预测。实际的预测是样本的平均值，但是我们不要在这里妄下结论。当我们运行上述代码并正确实现我们的模型时，我们应该得到以下输出—实际训练:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/9ebd2e65a4b57152a160ccc38330fb33.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*02jFVPUANWdfEUUw45f-Kw.png"/></div><p class="ko kp gj gh gi kq kr bd b be z dk translated"><em class="kf">预测者训练过程用指定的模型结束了3501步的所有训练数据。随着时间的推移，损耗被最小化。</em></p></figure><p id="1336" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">我们看到我们的损失减少了。这很好，它告诉我们，随着时间的推移，我们预测的计算分布会变得更好。这里的损失是相对于数据和部分预测者文档的负ELBO的商(见<a class="ae lq" href="http://docs.pyro.ai/en/stable/contrib.forecast.html" rel="noopener ugc nofollow" target="_blank">【4】</a>)。</p><h1 id="a599" class="mc lx iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">真正不确定的事情——自信和一切</h1><p id="f4b9" class="pw-post-body-paragraph kt ku iq kv b kw mt jr ky kz mu ju lb lc mv le lf lg mw li lj lk mx lm ln lo ij bi translated">我们现在在记忆中保存了一个最终模型。我们可以用它来计算损失，用它来对抗新数据，戳戳它，看看它会产生什么。<br/>例如，我们可以对一段时间内的销售额进行采样，如下图所示:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi na"><img src="../Images/82ed46c488a249084a53c26cbd6ad401.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*uhAsCa0MTKAMhdsCHbZxTA.png"/></div><p class="ko kp gj gh gi kq kr bd b be z dk translated"><em class="kf">图2 —真实数据和随时间推移从拟合模型中采样的数据。红线表示最近可用(真实)的14天，而模型的抽样预测为浅绿色。报告的预测值是所有样本的平均值(绿线)。我们可以预测所需的28天。每个时间步长10%-90%的置信区间用红色阴影显示。请参考下面的代码。</em></p></figure><p id="09d2" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">为了计算各个步骤的置信度，我们要求我们的模型有100个样本，并计算这些样本的分位数(0.1和0.9)。这就是你在图2中看到的红色区域。既然这个模型由你支配，如果你想使它更精确，你可以要求更多的样品。为了更好地拟合模型，图中的销售额是累计的记录值。要获得更真实范围内的值，请使用numpy的exp转换这些值。</p><h1 id="8f42" class="mc lx iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">总结</h1><p id="5ef6" class="pw-post-body-paragraph kt ku iq kv b kw mt jr ky kz mu ju lb lc mv le lf lg mw li lj lk mx lm ln lo ij bi translated">我们已经展示了如何构建Pyro模型并使用预测器实现。您可以使用您所知道的关于问题的事实来设置模型参数并找到合适的分布。Pyro附带了很多功能。其中之一是SVI，一种计算后验概率的算法，这使得模型训练首先成为可能。在我们拟合我们的模型后，我们可以从中取样，预测数据点并计算我们预测的置信区间。总而言之，概率编程和Pyro之类的框架提供了一个强大的工具集，在处理不确定性和对现实世界数据建模时可以使用。</p><h1 id="4a5c" class="mc lx iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">完整的型号代码</h1><pre class="kh ki kj kk gt lr ls lt lu aw lv bi"><span id="03dd" class="lw lx iq ls b gy ly lz l ma mb">class TopDownModel(ForecastingModel):<br/>  """<br/>  Top-Down Hierarchical Forecasting Model<br/>  """<br/>  def model(self, zero_data, covariates):<br/>    # check univariate data<br/>    assert zero_data.size(-1) == 1 <br/>    duration = zero_data.size(-2)</span><span id="0324" class="lw lx iq ls b gy nb lz l ma mb">    time, feature = covariates[..., 0], covariates[..., 1:]</span><span id="5245" class="lw lx iq ls b gy nb lz l ma mb">    bias = pyro.sample("bias", dist.Normal(0, 10))<br/>    trend_coef = pyro.sample("trend", dist.LogNormal(-2, 1))<br/>    trend = trend_coef * time</span><span id="3ddb" class="lw lx iq ls b gy nb lz l ma mb">    weight = pyro.sample("weight", dist.Normal(0, 1).expand(<br/>        [feature.size(-1)]).to_event(1))<br/>    regressor = (weight * feature).sum(-1)</span><span id="7e69" class="lw lx iq ls b gy nb lz l ma mb">    # weekly seasonality as independent events<br/>    with pyro.plate("day_of_week", 7, dim=-1):<br/>      seasonal = pyro.sample("seasonal", dist.Normal(0, 5))<br/>    seasonal = periodic_repeat(seasonal, duration, dim=-1)</span><span id="e5e2" class="lw lx iq ls b gy nb lz l ma mb">    drift_stability = pyro.sample("drift_stability", dist.Uniform(1, 2))<br/>    drift_scale = pyro.sample("drift_scale", dist.LogNormal(-17, 5))</span><span id="7aab" class="lw lx iq ls b gy nb lz l ma mb">    # introduce drift<br/>    with self.time_plate:<br/>          # We combine two different reparameterizers: the inner SymmetricStableReparam<br/>          # is needed for the Stable site, and the outer LocScaleReparam improves inference.<br/>          with poutine.reparam(config={"drift": LocScaleReparam()}):<br/>              with poutine.reparam(config={"drift": SymmetricStableReparam()}):<br/>                  drift = pyro.sample("drift",<br/>                                      dist.Stable(drift_stability, 0, drift_scale))<br/>    motion = drift.cumsum(dim=-1)</span><span id="0f2a" class="lw lx iq ls b gy nb lz l ma mb">    # predict<br/>    prediction = regressor + trend + seasonal + motion + bias<br/>    # Pyro Forecast is multivariate - univariate timeseries is needed<br/>    prediction = prediction.unsqueeze(-1)</span><span id="ad91" class="lw lx iq ls b gy nb lz l ma mb">    # heavy tail nose to account for outliers<br/>    stability = pyro.sample("noise_stability", dist.Uniform(1, 2).expand([1]).to_event(1))<br/>    skew = pyro.sample("noise_skew", dist.Uniform(-1, 1).expand([1]).to_event(1))<br/>    scale = pyro.sample("noise_scale", dist.LogNormal(-5, 5).expand([1]).to_event(1))<br/>    noise_dist = dist.Stable(stability, skew, scale)<br/>    with poutine.reparam(config={"residual": StableReparam()}):<br/>      self.predict(noise_dist, prediction)</span></pre><h1 id="e404" class="mc lx iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">抽样和绘制置信区间</h1><pre class="kh ki kj kk gt lr ls lt lu aw lv bi"><span id="0dd1" class="lw lx iq ls b gy ly lz l ma mb"># sample from the fitted model to forecast data<br/>samples = forecaster(data[T0:T1], covariates[T0:T2], num_samples=100)<br/>samples.clamp_(min=0)</span><span id="3f9e" class="lw lx iq ls b gy nb lz l ma mb">p10, p50, p90 = quantile(samples[:, :], (0.1, 0.5, 0.9)).squeeze(-1)</span><span id="2093" class="lw lx iq ls b gy nb lz l ma mb">fig, ax = plt.subplots()</span><span id="9f45" class="lw lx iq ls b gy nb lz l ma mb">ax.set_title("aggregated (log1p) sales over 42 days")<br/>ax.plot(data[T1:T2].squeeze(-1).cpu().numpy(), "r-",lw=4, label="truth")<br/>ax.fill_between(np.arange(0, (T2-T1)), p10.cpu().numpy(), p90.cpu().numpy(), alpha=0.3, color="red", label="confidence")<br/>ax.plot(samples.squeeze(-1).T.cpu().numpy()[:, 10:13], color="green", alpha=0.35, label="sample")<br/>ax.plot(np.mean(samples.squeeze(-1).T.cpu().numpy()[:, :], axis=1),color="green", lw=2, alpha=0.75, label="mean")<br/>ax.set_xlabel("t in days")<br/>ax.set_ylabel("aggregated sales")<br/>labels = np.arange(len(covariates)-42, len(covariates), step=8)<br/>ax.set_xticklabels(labels)<br/>plt.ylim((9.5, 11.2))<br/>plt.legend(loc='lower right')<br/>plt.show()</span></pre><h2 id="bc51" class="lw lx iq bd md nc nd dn mh ne nf dp ml lc ng nh mn lg ni nj mp lk nk nl mr nm bi translated">承认</h2><p id="4377" class="pw-post-body-paragraph kt ku iq kv b kw mt jr ky kz mu ju lb lc mv le lf lg mw li lj lk mx lm ln lo ij bi translated">非常感谢Pyro文档和开发团队。GitHub上关于主题和实现的全面写作确实使Pyro用户能够立即投入使用。我们的模型是不同模型的混合实验，我们测试了哪些部分可以很好地协同工作。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="91d1" class="mc lx iq bd md me nu mg mh mi nv mk ml jw nw jx mn jz nx ka mp kc ny kd mr ms bi translated">参考</h1><ol class=""><li id="66c4" class="nz oa iq kv b kw mt kz mu lc ob lg oc lk od lo oe of og oh bi translated">Pyro文档—预测教程<a class="ae lq" href="http://pyro.ai/examples/forecasting_i.html" rel="noopener ugc nofollow" target="_blank"> I </a>、<a class="ae lq" href="https://pyro.ai/examples/forecasting_ii.html" rel="noopener ugc nofollow" target="_blank"> II </a>和<a class="ae lq" href="http://pyro.ai/examples/forecasting_iii.html" rel="noopener ugc nofollow" target="_blank"> III </a></li><li id="5110" class="nz oa iq kv b kw oi kz oj lc ok lg ol lk om lo oe of og oh bi translated">米（meter的缩写））戈里诺瓦，d .摩尔，m .霍夫曼。概率程序的自动重新参数化。2019发表于<a class="ae lq" href="https://arxiv.org/pdf/1906.03028.pdf" rel="noopener ugc nofollow" target="_blank"> ArXiv </a></li><li id="e7ed" class="nz oa iq kv b kw oi kz oj lc ok lg ol lk om lo oe of og oh bi translated">米（meter的缩写））霍夫曼等人在<em class="lp">随机变分推理。</em> 2013年。在<a class="ae lq" href="http://jmlr.org/papers/v14/hoffman13a.html" rel="noopener ugc nofollow" target="_blank"> JMLR </a></li><li id="d31c" class="nz oa iq kv b kw oi kz oj lc ok lg ol lk om lo oe of og oh bi translated">优步技术公司。2018.烟火预报员见<a class="ae lq" href="http://docs.pyro.ai/en/stable/contrib.forecast.html" rel="noopener ugc nofollow" target="_blank">文件</a></li></ol></div></div>    
</body>
</html>