<html>
<head>
<title>Top Coding Algorithms — Breadth First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">顶级编码算法—广度优先搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/top-coding-algorithms-breadth-first-search-af2cce54c69c?source=collection_archive---------54-----------------------#2020-04-24">https://towardsdatascience.com/top-coding-algorithms-breadth-first-search-af2cce54c69c?source=collection_archive---------54-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d3ba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们直接进入主题。</h2></div><h1 id="3565" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">伪码</h1><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="3a0e" class="lj kj it lf b gy lk ll l lm ln">procedure BFS(G, start_v) is<br/>      let Q be a queue<br/>      label start_v as discovered<br/>      Q.enqueue(start_v)<br/>      while Q is not empty do<br/>          v := Q.dequeue()<br/>          if v is the goal then<br/>              return v<br/>          for all edges from v to w in G.adjacentEdges(v) do<br/>             if w is not labeled as discovered then<br/>                 label w as discovered<br/>                 w.parent := v<br/>                 Q.enqueue(w)</span></pre><p id="7d85" class="pw-post-body-paragraph lo lp it lq b lr ls ju lt lu lv jx lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">广度优先搜索的实现使用<strong class="lq iu">队列</strong>和<strong class="lq iu">，而循环</strong>与其表亲相比，深度优先搜索使用递归，记住这一点，我相信，至少可以在你的编码面试中帮助你建立结构。</p><h1 id="e3ab" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">履行</h1><p id="1ba8" class="pw-post-body-paragraph lo lp it lq b lr mk ju lt lu ml jx lw lx mm lz ma mb mn md me mf mo mh mi mj im bi translated">想想最基本的任务:</p><figure class="la lb lc ld gt mq gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/a66aedc169878e5dc05af43370d537a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*RvDjumj5C1nWiNYUrZzVyg.png"/></div></figure><p id="f681" class="pw-post-body-paragraph lo lp it lq b lr ls ju lt lu lv jx lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">找到从 0 到 6 的所有路径。</p><p id="0efd" class="pw-post-body-paragraph lo lp it lq b lr ls ju lt lu lv jx lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">请注意 1 和 4 的双向箭头，这意味着如果我们在搜索过程中没有跟踪被访问的节点，路径会向后走。</p><figure class="la lb lc ld gt mq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0f08" class="pw-post-body-paragraph lo lp it lq b lr ls ju lt lu lv jx lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">这里有几点需要注意:</p><ul class=""><li id="e753" class="mv mw it lq b lr ls lu lv lx mx mb my mf mz mj na nb nc nd bi translated"><em class="ne">注意队列包含 2 个元素，当前节点和当前路径。</em>根据你遇到的问题，可以是深度或者其他。</li><li id="4038" class="mv mw it lq b lr nf lu ng lx nh mb ni mf nj mj na nb nc nd bi translated"><code class="fe nk nl nm lf b">queue.pop(0)</code>确保我们总是考虑队列中的第一个元素，这使得它是广度优先的。</li><li id="2560" class="mv mw it lq b lr nf lu ng lx nh mb ni mf nj mj na nb nc nd bi translated">如果我们碰到一个没有子节点的离开节点，那么我们继续下一个</li></ul><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="58e6" class="lj kj it lf b gy lk ll l lm ln">if curr_node not in self.graph.keys():                <br/>     continue</span></pre><ul class=""><li id="26ae" class="mv mw it lq b lr ls lu lv lx mx mb my mf mz mj na nb nc nd bi translated"><code class="fe nk nl nm lf b">if child not in curr_path</code>检查我们是否在后退，避免了两次访问一个节点。</li><li id="4286" class="mv mw it lq b lr nf lu ng lx nh mb ni mf nj mj na nb nc nd bi translated"><code class="fe nk nl nm lf b">curr_path.copy()</code>一定要去，否则不同孩子的路会被缠住。</li></ul><h1 id="ae62" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">编码问题</h1><p id="98db" class="pw-post-body-paragraph lo lp it lq b lr mk ju lt lu ml jx lw lx mm lz ma mb mn md me mf mo mh mi mj im bi translated">让我们看看如何灵活应用它。</p><p id="7f54" class="pw-post-body-paragraph lo lp it lq b lr ls ju lt lu lv jx lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><em class="ne">给定一棵二叉树，求其最小深度。最小深度是从根节点向下到最近的叶节点的最短路径上的节点数。</em></p><p id="c7de" class="pw-post-body-paragraph lo lp it lq b lr ls ju lt lu lv jx lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><strong class="lq iu">注:</strong> <em class="ne">叶子是没有子代的节</em></p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="6119" class="lj kj it lf b gy lk ll l lm ln">    3<br/>   / \<br/>  9  20<br/>    /  \<br/>   15   7</span></pre><p id="6f84" class="pw-post-body-paragraph lo lp it lq b lr ls ju lt lu lv jx lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><em class="ne">返回其最小深度= 2。(这是 leetcode 的一个问题)</em></p><figure class="la lb lc ld gt mq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="61a8" class="pw-post-body-paragraph lo lp it lq b lr ls ju lt lu lv jx lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">这里的主要变化是，根据问题的要求，我们的道路被深度所取代。</p><p id="41f1" class="pw-post-body-paragraph lo lp it lq b lr ls ju lt lu lv jx lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">现在问题来了，如果我们想要最大深度呢？去试试吧。</p></div></div>    
</body>
</html>