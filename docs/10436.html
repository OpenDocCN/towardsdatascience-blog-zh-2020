<html>
<head>
<title>Every Complex DataFrame Manipulation, Explained and Visualized Intuitively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每一个复杂的数据帧操作，直观地解释和可视化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/every-dataframe-manipulation-explained-visualized-intuitively-dbeea7a5529e?source=collection_archive---------13-----------------------#2020-07-22">https://towardsdatascience.com/every-dataframe-manipulation-explained-visualized-intuitively-dbeea7a5529e?source=collection_archive---------13-----------------------#2020-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/16ab9bc7cd056d3a60168e92ef89ff30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1p1WoRK7p1TIJbLT8zZw3A.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片作者。</p></figure><div class=""/><div class=""><h2 id="9757" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">熔化、旋转、连接、爆炸等</h2></div><p id="81b7" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Pandas 提供了各种各样的数据帧操作，但其中许多都很复杂，可能看起来不容易实现。本文将介绍 8 种基本的数据帧操作方法，几乎涵盖了数据科学家需要了解的所有操作功能。每种方法都包括解释、可视化、代码和记住它的技巧。</p><p id="ddb6" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">所有图片由作者提供。</em></p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="fa63" class="mb mc ji bd md me mf dn mg mh mi dp mj lg mk ml mm lk mn mo mp lo mq mr ms mt bi translated">在枢轴上转动</h2><p id="00af" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">透视一个表会创建一个新的“透视表”,它将数据中的现有列作为新表的元素进行投影，即索引、列和值。将成为索引的初始数据帧中的列和列显示为唯一值，这两个列的组合将显示为值。这意味着透视不能处理重复值。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/1eed9b18b9032d4d299eb1491f56fede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FGqEaHi4rm2RwFqeHsxOyw.png"/></div></div></figure><p id="031a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">透视名为<code class="fe ne nf ng nh b">df</code>的数据帧的代码如下:</p><pre class="na nb nc nd gt ni nh nj nk aw nl bi"><span id="05b0" class="mb mc ji nh b gy nm nn l no np">df.pivot(index='foo', columns='bar', values='baz')</span></pre><p id="52df" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">记住</em>:轴心是——在数据处理领域之外——围绕某种对象的旋转。在运动中，一个人可以绕着他们的脚“旋转”:熊猫的枢轴是类似的。原始数据帧的状态围绕一个数据帧的中心元素旋转成一个新的数据帧。有些元素确实是旋转或变换的(如列'<code class="fe ne nf ng nh b">bar</code>')。</p><h2 id="573c" class="mb mc ji bd md me mf dn mg mh mi dp mj lg mk ml mm lk mn mo mp lo mq mr ms mt bi translated">熔化</h2><p id="9146" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">熔化可以被认为是一种“逆透视”，因为它将基于矩阵的数据(有两个维度)转换为基于列表的数据(列表示值，行表示唯一的数据点)，而透视则相反。考虑一个二维矩阵，其中一个维度为“<code class="fe ne nf ng nh b">B</code>”和“<code class="fe ne nf ng nh b">C</code>”(列名)，另一个维度为“<code class="fe ne nf ng nh b">a</code>”、“<code class="fe ne nf ng nh b">b</code>”和“<code class="fe ne nf ng nh b">c</code>”(行索引)。</p><p id="4491" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们选择一个 ID、一个维度和一列或多列来包含值。包含值的列被转换为两列:一列用于变量(值列的名称)，另一列用于值(其中包含的数字)。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/85f48415ca30bc9b2f0fee15bfdec406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EvpoxUh_ycXCCeryflf_ZA.png"/></div></div></figure><p id="7630" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">结果是 ID 列的值(<code class="fe ne nf ng nh b">a</code>、<code class="fe ne nf ng nh b">b</code>、<code class="fe ne nf ng nh b">c</code>)和值列(<code class="fe ne nf ng nh b">B</code>、<code class="fe ne nf ng nh b">C</code>)的每个组合，以及相应的值，以列表格式组织。</p><p id="8515" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">熔化操作可以在数据框<code class="fe ne nf ng nh b">df</code>中这样执行:</p><pre class="na nb nc nd gt ni nh nj nk aw nl bi"><span id="cc9f" class="mb mc ji nh b gy nm nn l no np">df.melt(id_vars=['A'], value_vars=['B','C'])</span></pre><p id="bcd2" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">记忆</em>:熔化像蜡烛一样的东西，就是把一个固化的、复合的物体变成几个小得多的、单独的元素(蜡滴)。熔化一个二维数据帧解包它的固化结构，并将它的片段作为单个条目记录在一个列表中。</p><h2 id="0123" class="mb mc ji bd md me mf dn mg mh mi dp mj lg mk ml mm lk mn mo mp lo mq mr ms mt bi translated">激增</h2><p id="50ee" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">分解是去除数据中列表的有用方法。当一列展开时，其中的所有列表都作为新行列在同一个索引下(为了避免这种情况，只需随后调用<code class="fe ne nf ng nh b">.reset_index()</code>)。字符串或数字之类的非列表项不受影响，空列表是 NaN 值(您可以使用<code class="fe ne nf ng nh b">.dropna()</code>清除这些值)。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nr"><img src="../Images/6fce71d4d5dc144a3c5b74524c49b062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIgtU7yIwVhvQgugmCdGSA.png"/></div></div></figure><p id="e188" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在 DataFrame <code class="fe ne nf ng nh b">df</code>中分解一列<code class="fe ne nf ng nh b">‘A’</code>非常简单:</p><pre class="na nb nc nd gt ni nh nj nk aw nl bi"><span id="508c" class="mb mc ji nh b gy nm nn l no np">df.explode(‘A’)</span></pre><p id="5331" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">记住</em>:分解一个东西会释放它所有的内部内容——分解一个列表会分离它的元素。</p><h2 id="7ad5" class="mb mc ji bd md me mf dn mg mh mi dp mj lg mk ml mm lk mn mo mp lo mq mr ms mt bi translated">堆</h2><p id="f82d" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">堆叠采用任意大小的数据帧，并将列“堆叠”为现有索引的子索引。因此，得到的数据帧只有一列和两级索引。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/d879766914f9529b9c483c323d0e81fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xcdye2CPT_jRYFEMGqkdw.png"/></div></div></figure><p id="3a2e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">堆叠一个名为 df 的表就像<code class="fe ne nf ng nh b">df.stack()</code>一样简单。</p><p id="1e65" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了访问比如狗的身高，只需调用两次基于索引的检索，比如<code class="fe ne nf ng nh b">df.loc[‘dog’].loc[‘height’]</code>。</p><p id="bfd6" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">要记住</em>:从视觉上来说，stack 取一个表的二维度，可以将列堆叠成多级索引。</p><h2 id="f420" class="mb mc ji bd md me mf dn mg mh mi dp mj lg mk ml mm lk mn mo mp lo mq mr ms mt bi translated">出栈</h2><p id="be30" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">拆分采用多索引数据帧并将其拆分，将指定级别中的索引转换为新数据帧的列及其相应的值。在一个表上调用一个 stack 后跟一个 unstack 不会改变它(原谅一个'【T6]'的存在)。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/f10cda9134f69e3c7727b12bb2fea0eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gj_4TxXqERXubC867Sn-qQ.png"/></div></div></figure><p id="7891" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">拆分中的一个参数是它的级别。在列表索引中，索引为-1 将返回最后一个元素；关卡也是如此。级别-1 表示最后一个索引级别(最右边的一个)将被拆分。作为另一个例子，当级别被设置为 0(第一索引级别)时，其中的值变成列，并且随后的索引级别(第二索引级别)变成转换的数据帧的索引。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/39c7be8b993e7997cc0f2a91d5a45486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKm3r6rzcjEKquznIf03og.png"/></div></div></figure><p id="f502" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">拆垛可以和堆垛一样进行，但是使用水平参数:<code class="fe ne nf ng nh b">df.unstack(level=-1)</code>。</p><p id="be03" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">记住</em> : Unstack 的意思是“撤销一个堆栈”。</p><h2 id="9c0b" class="mb mc ji bd md me mf dn mg mh mi dp mj lg mk ml mm lk mn mo mp lo mq mr ms mt bi translated">合并</h2><p id="df6c" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">合并两个数据帧就是在一个共享的“键”中按列(水平)组合它们。这个键允许表的组合，即使它们的顺序不同。默认情况下，完成的合并数据帧会将后缀<code class="fe ne nf ng nh b">_x</code>和<code class="fe ne nf ng nh b">_y</code>添加到值列。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nv"><img src="../Images/29c9838264e6f361328cce94c2c1bf3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTzkUWUQTaAU348YQLJJ_Q.png"/></div></div></figure><p id="16cd" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了合并两个数据帧<code class="fe ne nf ng nh b">df1</code>和<code class="fe ne nf ng nh b">df2</code>(其中<code class="fe ne nf ng nh b">df1</code>包含<code class="fe ne nf ng nh b">leftkey</code>，<code class="fe ne nf ng nh b">df2</code>包含<code class="fe ne nf ng nh b">rightkey</code>)，调用:</p><pre class="na nb nc nd gt ni nh nj nk aw nl bi"><span id="6ce1" class="mb mc ji nh b gy nm nn l no np">df1.merge(df2, left_on='leftkey', right_on='rightkey')</span></pre><p id="b7f7" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">合并不是 pandas 的功能，而是附属于数据帧。通常假设合并所附加到的数据帧是“左表”,而在函数中作为参数调用的数据帧是“右表”,并带有相应的键。</p><p id="4136" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">默认情况下，merge 函数执行所谓的内部连接:如果每个数据帧都有一个键没有在另一个数据帧中列出，则它不会包含在合并的数据帧中。另一方面，如果一个键在同一个数据帧中列出两次，则相同键的值的每个组合都会在合并的表中列出。例如，如果键<code class="fe ne nf ng nh b">foo</code>的<code class="fe ne nf ng nh b">df1</code>有 3 个值，而同一个键的<code class="fe ne nf ng nh b">df2</code>有 2 个值，那么在最终的数据帧中将有 6 个带有<code class="fe ne nf ng nh b">leftkey=foo</code>和<code class="fe ne nf ng nh b">rightkey=foo</code>的条目。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/4d409747c543030821bc0dc8530ab1f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*efCmFOV08ctxUCO3dIleoQ.png"/></div></div></figure><p id="95cf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">记住</em>:你合并数据帧就像你横向驾驶时合并车道一样。想象每根柱子都是高速公路上的一条车道；为了合并，它们必须水平合并。</p><h2 id="d480" class="mb mc ji bd md me mf dn mg mh mi dp mj lg mk ml mm lk mn mo mp lo mq mr ms mt bi translated">加入</h2><p id="7569" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">联接通常优于合并，因为它在水平联接两个数据帧时具有更清晰的语法和更广泛的可能性。联接的语法如下:</p><pre class="na nb nc nd gt ni nh nj nk aw nl bi"><span id="0985" class="mb mc ji nh b gy nm nn l no np">df1.join(other=df2, on='common_key', how='join_method')</span></pre><p id="3254" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">使用联接时，公共键列(类似于 merge 中的<code class="fe ne nf ng nh b">right_on</code>和<code class="fe ne nf ng nh b">left_on</code>)必须命名为相同的名称。<code class="fe ne nf ng nh b">how</code>参数是引用四种方法之一的字符串<code class="fe ne nf ng nh b">join</code>可以组合两个数据帧:</p><ul class=""><li id="c7ad" class="nx ny ji kz b la lb ld le lg nz lk oa lo ob ls oc od oe of bi translated"><code class="fe ne nf ng nh b">‘left’</code>:包含<code class="fe ne nf ng nh b">df1</code>的所有元素，只有当<code class="fe ne nf ng nh b">df2</code>的元素的键是<code class="fe ne nf ng nh b">df1</code>的键时，才会伴随<code class="fe ne nf ng nh b">df2</code>的元素。否则，<code class="fe ne nf ng nh b">df2</code>的合并数据帧的缺失部分将被标记为 NaN。</li><li id="f821" class="nx ny ji kz b la og ld oh lg oi lk oj lo ok ls oc od oe of bi translated"><code class="fe ne nf ng nh b">‘right’</code> : <code class="fe ne nf ng nh b">‘left’,</code>但是在另一个数据框架上。包含<code class="fe ne nf ng nh b">df2</code>的所有元素，只有当<code class="fe ne nf ng nh b">df1</code>的元素的键是<code class="fe ne nf ng nh b">df2</code>的键时，才会伴随<code class="fe ne nf ng nh b">df1</code>的元素。</li><li id="fd5c" class="nx ny ji kz b la og ld oh lg oi lk oj lo ok ls oc od oe of bi translated"><code class="fe ne nf ng nh b">‘outer’</code>:包含两个数据帧中的所有元素，即使一个键在另一个数据帧中不存在——缺少的元素标记为 NaN。</li><li id="1030" class="nx ny ji kz b la og ld oh lg oi lk oj lo ok ls oc od oe of bi translated"><code class="fe ne nf ng nh b">‘inner’</code>:仅包括其键同时出现在两个数据帧键中的元素(交集)。默认为合并。</li></ul><p id="8daf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">记住</em>:如果你使用过 SQL，单词‘join’应该立即与列相加联系起来。如果没有，“加入”和“合并”在定义上有非常相似的含义。</p><h2 id="7181" class="mb mc ji bd md me mf dn mg mh mi dp mj lg mk ml mm lk mn mo mp lo mq mr ms mt bi translated">串联</h2><p id="26db" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">尽管合并和连接是水平工作的，但串联或简称为串联，是按行方式(垂直)附加数据帧。例如，考虑两个具有相同列名的数据帧<code class="fe ne nf ng nh b">df1</code>和<code class="fe ne nf ng nh b">df2</code>，用<code class="fe ne nf ng nh b">pandas.concat([df1, df2])</code>连接起来:</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/83bea0cd1a5d412f12b9c4869f0fbb3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sc3wG3m8RgU3EAIkB42j7w.png"/></div></div></figure><p id="f008" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">虽然您可以通过将 axis 参数设置为<code class="fe ne nf ng nh b">1</code>来使用 concat 进行列连接，但是使用 join 会更简单。</p><p id="7a56" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">请注意，concat 是一个 pandas 函数，而不是 DataFrame 中的一个。因此，它接受一个要连接的数据帧列表。</p><p id="342e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果一个 DataFrame 有一个列没有包含在另一个 data frame 中，默认情况下它将被包含在内，缺少的值列为 NaN。为了防止这种情况，添加一个额外的参数<code class="fe ne nf ng nh b">join=’inner’</code>，它将只连接两个数据帧共有的列。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/339789cdbbd7aec9db728114321b32be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOE_LKKAzNGwybP5jAJktA.png"/></div></div></figure><p id="e40e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lt">记住</em>:在列表和字符串中，额外的条目可以连接起来。串联是对现有主体的附加元素，而不是新信息的添加(就像按列连接一样)。因为每个索引/行都是一个单独的项，所以串联会向数据帧添加额外的项，数据帧可以看作是一个行列表。</p><p id="069a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Append 是组合两个数据帧的另一种方法，但它执行的功能与 concat 相同，但效率较低且通用性较差。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="6d62" class="on mc ji bd md oo op oq mg or os ot mj ko ou kp mm kr ov ks mp ku ow kv ms ox bi translated">有时候内置函数是不够的。</h1><p id="ff5f" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">尽管这些函数涵盖了您可能需要操作数据的广泛内容，但有时所需的数据操作对于一个甚至一系列函数来说过于复杂。探索复杂的数据操作方法，如解析器函数、迭代投影、高效解析等，请点击此处:</p><div class="is it gp gr iu oy"><a href="https://medium.com/analytics-vidhya/tips-tricks-techniques-to-take-your-data-wrangling-skills-to-the-next-level-c912c23b20cb" rel="noopener follow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd jj gy z fp pd fr fs pe fu fw jh bi translated">将您的数据辩论技能提升到一个新水平的提示、技巧和技术</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">带有图表、代码和示例</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">medium.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ja oy"/></div></div></a></div></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="3b1d" class="on mc ji bd md oo op oq mg or os ot mj ko ou kp mm kr ov ks mp ku ow kv ms ox bi translated">感谢阅读！</h1><p id="00f1" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">如果你对最新的文章感兴趣，可以考虑订阅<a class="ae pn" href="https://andre-ye.medium.com/subscribe" rel="noopener">。如果你想支持我的写作，通过我的推荐链接加入 Medium 是一个很好的方式。干杯！</a></p></div></div>    
</body>
</html>