# 想象一下，你的“数据”文件夹里没有…混乱！

> 原文：<https://towardsdatascience.com/imagine-theres-no-mess-in-your-data-folder-859135bd1262?source=collection_archive---------61----------------------->

## 如果你尝试，它是容易的。想办法改善你与数据集的互动。

![](img/7bc6b17bf5f7901011c3490a12704c23.png)

有时很难在你自己的数据中导航。艾萨克·奎萨达在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

首先我将介绍狐猴先生，他将伴随我们的思考过程。

![](img/d846fa0519847349d8dd45f7b550f00c.png)

狐猴先生已经准备好冒险了！[杜安·斯美塔纳](https://unsplash.com/@veverkolog?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

# 我们走吧！

假设你和你的团队成员一直在做一个名字很酷的项目**“客户流失探测器 X”**。剩下的就是用一个合适的数据集来拟合我们同样酷的模型，然后部署它。

你看着“数据”目录，它立刻让你充满困惑。

> 你的项目某处:
> data/
> ├──user _ activity _ April _ 2020 . CSV
> ├──user _ activity _ may _ 2020 . CSV
> ├──user _ activity _ April _ 2020 _ cleaned _ df _ v1 . CSV
> ├──user _ activity _ may _ 2020 _ broken . CSV
> ├──user _ activity _ may _ 2020 _ v2 . CSV
> ├──user _ activity _ may _ 2020
> 
> 看着眼熟？我知道那种感觉，兄弟。

想象一下这样一个美好的世界，在那里再也不会出现如此混乱的局面。即使你只对四月份的数据集感兴趣，在过滤掉其他数据后，你会得到:

> data/
> ├──user _ activity _ April _ 2020 . CSV
> ├──user _ activity _ April _ 2020 _ cleaned _ df _ v1 . CSV
> ├──user _ activity _ April _ 2020 _ cleaned _ df _ the _ best . CSV
> ├──user _ activity _ April _ 2020 _ cleaned _ df . CSV
> └──user _ activity _ April _ 2020 _ cleaned _ df _ improved . CSV

现在清楚该选哪一个了吗？嘿，狐猴先生，你说呢？

![](img/5042b38156f4d983f20c71e673302bee.png)

别担心，狐猴先生，我们会解决的！Amy Reed 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# 混乱的根源。

嗯，通常我们在做令人兴奋的事情时总是很匆忙。有一天，你向自己承诺，记住哪个数据集是哪个数据集是很容易的。尽管如此，时间飞逝，你知道！截止日期已经悄悄逼近你了。

绝对必要的是，必须使用正确的生产数据。垃圾进——垃圾出，记得吗？你现在做什么？

## 那么…哪个数据集是正确的呢？

首先，你检查所有的笔记本，比较指标或其他计算，你花一些时间，然后再多一点..咻！你**几乎 100%确定**那个**user _ activity _ April _ 2020 _ cleaned _ df _ improved . CSV**数据集就是你要找的那个。

## 没那么难。哦，等一下…

您刚刚想起需要使用最新的可用数据重新生成数据集。唯一的障碍是找到你使用的代码。谢天谢地，你一直在使用 **git** 并且只花了**大约一个小时**就找到了根并测试了一切。是的，我是在讽刺。最坏的情况——您在 **git** 历史中没有任何相关内容。

# 有哪些不同的做法？

![](img/c8d4fb050e359a96235231a0c38e79ff.png)

狐猴先生也在寻找答案。[布兰登·泰特](https://unsplash.com/@travelingtater?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

我已经介绍了两个问题:

*   *很难理解不同的变换数据集实际上代表了什么*
*   *毕竟很难跟踪这些数据集是如何生成的*

作为奖励:*如何使从任何文件或笔记本中读取数据集变得容易？*

有一种简单的方法可以解决第一个问题，那就是提供一个详细的文件名。

第二个要棘手得多。显然，负责转换的代码总是分离的，数据本身无法告诉我们在哪里可以找到它。

我们将在本文的剩余部分尝试找到所有这些问题的解决方案。

# 做一个数据集的小梦。

你可能会说我是一个梦想家，但让我们想出摆脱这种状态的选择:

呀，看起来真恶心…太不可移植了，太容易出错了。但是:我们可以做得更好！

我呼吁大家集思广益！现在重要的是接口，而不是实现。

## 我不想直接处理文件路径。

我们通过隐藏所有获取数据集的逻辑来指定我们正在处理的项目和文件名。感觉好多了，虽然我仍然需要知道确切的文件名。不太方便。

## 去掉文件名。

文件名暗示数据集与**user _ activity _ April _ 2020 . CSV**数据集相关。的确，**user _ activity _ April _ 2020 _ cleaned _ df _ improved . CSV**只是它的一个改造版本。在签名中把它们分开是个好主意。

## 我不想关心文件格式！

很公平。

这么一件小事，却造成了如此大的差别！现在，我可以左右阅读数据集，一切都会正常工作。

## 普通函数不是一个可伸缩的解决方案。我需要一张“脸”来代表它！我们需要一些神奇的东西…

最后，我们来到了这里:

在我的想象中，勇敢的魔术师来拯救我们的时间和理智了！看起来像魔术，真的。在项目中，我不想处理存储数据集的绝对或相对路径，我不关心使用哪种格式保存它。我只是需要它留在记忆里。我现在就需要！从存储库中的任何位置。当在同一个存储库中与许多团队成员一起工作时，这是特别需要的。注意**转换 id** 参数的值。是**“model _ ready”**，比**“cleaned _ df _ improved”**更直观。

不可避免的时刻已经到来。是时候回到现实，考虑一个可能的实现了。

## 它怎么知道从哪里获取数据？

如果我是 **MagicDfReader** ，我更希望有一些描述数据和相关转换的配置文件。配置是伟大的，他们可以记住任何事情，让我们有时间做更重要的事情。

它能包含什么有用的信息呢？稍加思考后，我可以勾勒出以下几点:

**df_id** 这里只是提醒一下配置属于哪个数据集。然后我们可以在**元数据**部分放置任何东西。知道谁创建了配置以及何时收集了数据是非常有价值的。 **initial_df_format** 信息将被 **MagicDfReader** 用来知道如何读取它。

我们谈了很多转变，不是吗？它们也必须在配置中找到。我一般能想到两种类型的转换:

*   内存中的——每当我们想要访问数据时，它们就会运行
*   **永久** —它们运行一次，对磁盘进行以下序列化

例如，我们可能希望在每次读取数据集时将日期列转换为日期时间类型，但是也有一些列我们希望永久删除。它在配置中会是什么样子？

你觉得怎么样？看起来不言自明。

我们可以通过添加注释来澄清所有字段，使其更加详细:

如果在某个时间点，您想知道数据集是如何生成的——只需查看相关的配置文件。你想让它重生？没问题，只需删除旧文件并让 **MagicDfReader** 为您获取即可。它将遵循您在配置中提供的配方。如果你的同事负责一些转变，你甚至不需要知道它是如何完成的。 **MagicDfReader** 送来，宝贝。然而，仍有差距需要填补。比如具体有哪些动作？ **to_date** 和 **drop_cols，**在哪里实现？

# 是的，我承认…是时候进行无耻而谦逊的自我宣传了！

![](img/8ae5fb08ceef2731a68ec64fb645cfb7.png)

我就像这里的狐猴先生一样谦逊。照片由[乌列尔·索伯兰斯](https://unsplash.com/@soberanes?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

一旦我的想象力最终引导我找到了键盘，我就做了一个几乎按照我描述的方式工作的库。我准备了一个[相当详细的 Jupyter 笔记本](https://github.com/ityutin/df-and-order/blob/master/examples/How-To.ipynb)，里面有它的内部细节，所以我不想在这里用很多代码打扰你。

这个库叫做 [df-and-order](https://github.com/ityutin/df-and-order) 。就像法律&命令一样。你知道，我喜欢各种形式的有序，我的“数据”文件夹中的有序是必须的，因为我有这样一个库。

让我向您展示这个库的主要组件以及真正的配置是什么样子的。

## DfReader

真正的 **DfReader** 也很不起眼，名字里没有任何与魔法相关的东西。

创建 **DfReader 的实例需要两个参数。**如你所见，它对你的项目一无所知，它期望得到一个**【数据】**的文件夹路径。但是不要担心，没有什么比创建自己的 **DfReader** 子类更容易的了，它可以动态地生成 **dir_path** 。这么几行代码和你得到的 **MagicDfReader** 我们前面讲过的！ **format_to_cache_map** 参数引出另一个类。

## **DfCache**

应该被子类化，包含一个如何读取和保存特定格式的数据帧的逻辑。只要看一看示例子类，一切就都清楚了！

是的，它最终成为了熊猫的内置方法的简单包装。下面是一个**格式 _ 到 _ 缓存 _ 映射**参数值的例子:

现在 **DfReader** 知道如何处理这些格式。

lib 的真实配置如何？

看起来几乎和以前一样！ **module_path** 是对具有负责转换的代码的文件的引用。您编写一些代码，然后将所有需要的参数暴露给配置文件，一切都变得清晰和可重复。[查看上述深度笔记本了解详情](https://github.com/ityutin/df-and-order/blob/master/examples/How-To.ipynb)。

lib 是用熊猫写的。DataFrame 记住了，但是如果需要的话，它可以很容易地成为与框架无关的工具。也可以对其进行修改，以处理非本地文件。 **DfCache** 子类可以访问一些外部资源等。

lib 正处于发展的早期阶段，所以旅程才刚刚开始。

# 重要提示:

[**df-and-order**](https://github.com/ityutin/df-and-order)**是关于组织你的数据文件并使用基本转换简化对它们的访问，而不是一个真正的数据管道框架。**

**良好做法:**

*   您有一个庞大的原始数据框架，并且希望保留它的预处理版本，以便能够快速适应模型。您使用 [df-and-order](https://github.com/ityutin/df-and-order) 来描述所有需要的转换。
*   您希望在后台将所有日期列从 **str** 转换为 **datetime** 类型。
*   您希望对类型进行优化以满足数据需求(比如对小范围数据使用 8 位整数而不是 64 位整数)。类型优化可以作为单独的转换来实现。
*   您希望为同一个数据集计算不同的目标。例如，您想从二元分类切换到多分类。

**不良做法:**

*   你使用 [df 和 order](https://github.com/ityutin/df-and-order) 进行缩放、虚拟编码等操作。没人能阻止你这么做，但是这样的操作有更好的选择。
*   您在转换中编写一些复杂的逻辑，如发出请求、获取和推送数据等。
*   您在转换中安排了一些外部依赖项。**所有的参数都应该放在配置文件中，以保持可再现性。**

# 结论

![](img/4c9f66c647e31df818a9d1cb2554fff0.png)

该冷静了，狐猴先生！拉明·尼乌文休斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

即使你不愿意尝试我试图驯服混乱的结果，也许这篇文章能帮助你正确看待事情。再现性在数据业务中非常重要，所以不要忽视这个方面，否则就太晚了。

我希望有一天你会加入回购！随时留下评论，开放的问题等！我很乐意与你交流。

# 注意安全，祝你好运！