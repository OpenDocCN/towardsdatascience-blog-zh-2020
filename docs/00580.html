<html>
<head>
<title>Perceptron Learning and its implementation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">感知机学习及其在Python中的实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/perceptron-and-its-implementation-in-python-f87d6c7aa428?source=collection_archive---------4-----------------------#2020-01-17">https://towardsdatascience.com/perceptron-and-its-implementation-in-python-f87d6c7aa428?source=collection_archive---------4-----------------------#2020-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d532" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本博客涵盖以下主题:</p><ol class=""><li id="d19f" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">什么是感知器？</li><li id="a0e4" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">算法。</li><li id="72c6" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">实施。</li><li id="dcd2" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">局限性。</li></ol></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="eb7a" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">什么是感知器？</h1><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/7395e56c1cf5bc8f89404250810b6e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qJzhrN1oHt2WFNBdSNnPQ.jpeg"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">生物神经元示意图</p></figure><p id="7653" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感知器的概念类似于大脑的基本处理单元——神经元的工作原理。神经元由树突、细胞体携带的许多输入信号和轴突携带的一个输出信号组成。当细胞达到特定阈值时，神经元会发出一个动作信号。这个动作要么发生，要么不发生；神经元的“部分”放电是不存在的。</p><p id="93f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，感知器有许多输入(通常称为特征)，这些输入被送入一个线性单元，产生一个二进制输出。因此，感知器可以应用于解决二元分类问题，其中样本将被识别为属于预定义的两个类别之一。</p></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="8e53" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">该算法</h1><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/8ab02dd6700a37754c60f7556ba6b083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*UGSVZ_Xq19x_wQeVlz76dQ.jpeg"/></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">感知器示意图</p></figure><p id="ac8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于感知器是二元分类器(0/1)，我们可以将它们的计算定义如下:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/2298d10097b40b6398181bc000593872.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*mK-el8z35NQEsWpdtpJ2Hw.png"/></div></figure><p id="7a0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回忆一下，两个长度为n (1≤i≤n)的向量的点积是</p><blockquote class="mw"><p id="b981" class="mx my iq bd mz na nb nc nd ne nf kk dk translated">w。x = ∑ᵢ wᵢ。xᵢ</p></blockquote><p id="4bfe" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">函数f(x)=<em class="nl">b+</em><strong class="jp ir"><em class="nl">w</em></strong><em class="nl">。</em> <strong class="jp ir"> <em class="nl"> x </em> </strong>是权重和特征向量的线性组合。<strong class="jp ir"> </strong>因此，感知器是一种线性分类器——一种使用线性预测函数进行预测的算法。</p><p id="41a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">权重表示<strong class="jp ir"> x </strong>中每个特征xᵢ对模型行为的有效性。要素xᵢ的权重wᵢ越高，其对输出的影响就越大。另一方面，偏差“b”就像线性方程中的截距。这是一个帮助模型以最适合数据的方式进行调整的常数。偏置项假设输入特征系数x₀=1.为虚数</p><p id="b93e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以使用以下算法来训练该模型:</p><pre class="mf mg mh mi gt nm nn no np aw nq bi"><span id="6ee5" class="nr lh iq nn b gy ns nt l nu nv">1. set b = w = 0<br/>2. for N iterations, or until weights do not change<br/>       (a) for each training example xᵏ with label yᵏ<br/>           i. if yᵏ — f(xᵏ) = 0, continue<br/>           ii. else, update wᵢ, △wᵢ = (yᵏ — f(xᵏ)) xᵢ</span></pre></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="af2c" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">履行</h1><p id="4729" class="pw-post-body-paragraph jn jo iq jp b jq nw js jt ju nx jw jx jy ny ka kb kc nz ke kf kg oa ki kj kk ij bi translated">我们考虑用于实现感知器的数据集是<a class="ae ob" href="https://www.kaggle.com/anthonyhills/classifying-species-of-iris-flowers" rel="noopener ugc nofollow" target="_blank">虹膜花数据集</a>。该数据集包含4个描述花的特征，并将它们分类为属于3个类中的一个。我们去除属于类‘Iris-virginica’的数据集的最后50行，并且仅使用2个类‘Iris-setosa’和‘Iris-versicolor ’,因为这些类是线性可分的，并且算法通过最终找到最优权重而收敛到局部最小值。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="04a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可视化包含其中两个要素的数据集，我们可以看到，通过在它们之间画一条直线，可以清楚地将数据集分开。</p><p id="b0f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的目标是编写一个算法，找到那条线，并正确分类所有这些数据点。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c3120aca066555f189843ce82e88d35e.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*9GL3Pj8K5-0XbLjzE-bgqQ.png"/></div></figure><p id="e45e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们实现上面提到的算法，看看它是如何工作的。我们有4个特征，因此每个特征有4个权重。请记住，我们定义了一个偏差项w₀，它假设x₀=1总共有5个权重。</p><p id="c0bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将迭代次数定义为10次。这是<em class="nl">超参数</em>之一，与算法学习的w等系统参数相反。在每次迭代中，该算法计算所有数据点的类别(0或1 ),并随着每次错误分类更新权重。</p><p id="aee7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果样本被错误分类，则权重通过向相反方向移动的增量来更新。所以如果再对样本进行分类，结果是“错的少”。我们将任何≤0的标签归类为‘0’(Iris-setosa)，其他任何标签归类为‘1’(Iris-versicolor)。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="8f0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们画出每次迭代中错误分类样本的数量。我们可以看到，该算法在第4次迭代中收敛。即，所有样本在第四次通过数据时被正确分类。</p><blockquote class="of og oh"><p id="b6f3" class="jn jo nl jp b jq jr js jt ju jv jw jx oi jz ka kb oj kd ke kf ok kh ki kj kk ij bi translated">感知器的一个属性是，如果数据集是线性可分的，那么算法保证收敛到某个点！</p></blockquote><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/5dbba9f995f3f0b3098b7aff8bfb5cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*ELGBczYQwK5V0eCNKnhMxQ.png"/></div></figure></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><h1 id="21f8" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">限制</h1><ol class=""><li id="0c8e" class="kl km iq jp b jq nw ju nx jy om kc on kg oo kk kq kr ks kt bi translated">单层感知器只有在数据集是线性可分的情况下才能工作。</li><li id="1b92" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">该算法仅用于二元分类问题。然而，我们可以通过为每个类引入一个感知器来扩展该算法以解决多类分类问题。即，每个感知器产生0或1，表示样本是否属于该类。</li></ol></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><p id="62d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想过来打个招呼，请在<a class="ae ob" href="https://www.linkedin.com/in/pallavirbharadwaj" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ob" href="https://twitter.com/pallavibharadwj" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ob" href="https://github.com/pallavibharadwaj" rel="noopener ugc nofollow" target="_blank">Github</a>上与我联系。</p><p id="332f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[1]尤金·查尔尼亚克，《深度学习导论》(2018)。</p><p id="a127" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2] R.A. Fisher，<a class="ae ob" href="http://dx.doi.org/10.1111/j.1469-1809.1936.tb02137.x" rel="noopener ugc nofollow" target="_blank">分类问题中多重测量的使用</a> (1936)。</p></div></div>    
</body>
</html>