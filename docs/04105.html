<html>
<head>
<title>The Seven Key Things You Need To Know About dplyr 1.0.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于 dplyr 1.0.0，您需要了解的七件重要事情</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-you-need-to-know-about-the-new-dplyr-1-0-0-7eaaaf6d78ac?source=collection_archive---------9-----------------------#2020-04-15">https://towardsdatascience.com/what-you-need-to-know-about-the-new-dplyr-1-0-0-7eaaaf6d78ac?source=collection_archive---------9-----------------------#2020-04-15</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="ed1a" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">这次更新有很多你应该知道的非常强大的新特性</h2></div><p id="cae8" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">用 R 编码的都知道<code class="fe lg lh li lj b">dplyr</code>。它实际上是 R 的定义包，旨在让那些相信“整洁数据”原则的人(我怀疑是大多数数据科学家)对数据帧的操作更加直观。事实上，很多人用<code class="fe lg lh li lj b">dplyr</code>编码比用 R base 编码更好。这就是为什么<code class="fe lg lh li lj b">dplyr</code>在 R 生态系统中变得如此重要，连同其他目前组成<code class="fe lg lh li lj b">tidyverse</code>的包。</p><p id="b42d" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">所以新版本的发布对于大多数 R 用户来说是令人兴奋的。事实上，它的版本 1.0.0 意味着它是一个真实的事件。Hadley Wickham 和 T4 背后的开源开发者团队不会轻易给出这个版本号。通过使其更强大，通过将许多以前不同的功能统一在一个更抽象的保护伞下，最重要的是试图为用户提供更多日常解决他们最常见的数据框架争论问题的解决方案，大量的努力被投入到超能力<code class="fe lg lh li lj b">dplyr</code>的功能中。</p><p id="c789" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated"><code class="fe lg lh li lj b">dplyr 1.0.0</code>现在可以使用<code class="fe lg lh li lj b">install.packages("dplyr")</code>进行安装。您可能需要更新您的 R 版本，以确保安装此更新。我无论如何都推荐升级到 R 4.0.0。</p><p id="2f3c" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">在这篇文章中，我将按照我所认为的复杂性递增的顺序来介绍主要的新特性。我将使用内置的数据集——主要是<code class="fe lg lh li lj b">mtcars</code>——来演示我的意思。</p><h2 id="d2e2" class="lk ll iv bd lm ln lo dn lp lq lr dp ls kt lt lu lv kx lw lx ly lb lz ma mb mc bi translated">1.内置于 tidyselect</h2><p id="4e00" class="pw-post-body-paragraph kk kl iv km b kn md jw kp kq me jz ks kt mf kv kw kx mg kz la lb mh ld le lf io bi translated">您现在可以在某些<code class="fe lg lh li lj b">dplyr</code>动词中使用<code class="fe lg lh li lj b">tidyselect</code>辅助函数。例如:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="0f86" class="lk ll iv lj b gy mq mr l ms mt">library(dplyr)</span><span id="bdc1" class="lk ll iv lj b gy mu mr l ms mt">mtcars %&gt;% <br/>  select(starts_with("c")) %&gt;% <br/>  head(3)</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mv"><img src="../Images/47036a99a39cddb6937c23ed274765a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ncH41FSGHAYTZ1RThz251Q.png"/></div></div></figure><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="5438" class="lk ll iv lj b gy mq mr l ms mt">mtcars %&gt;% <br/>  select(any_of(c("mpg", "cyl", "trash"))) %&gt;% <br/>  head(3)</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nd"><img src="../Images/1d68e6f0f66271502374d9fb4983d118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ykEqoSogJMs1Uclpt4ksg.png"/></div></div></figure><p id="4163" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated"><code class="fe lg lh li lj b">tidyselect</code>像这样的帮助函数可以在任何选择函数中工作，包括一些我们稍后会看到的新函数。你可以在这里找到<code class="fe lg lh li lj b">tidyselect</code>功能<a class="ae ne" href="https://tidyselect.r-lib.org/reference/select_helpers.html" rel="noopener ugc nofollow" target="_blank">的全部内容</a>。</p><h2 id="45cb" class="lk ll iv bd lm ln lo dn lp lq lr dp ls kt lt lu lv kx lw lx ly lb lz ma mb mc bi translated">2.简单但非常有用 relocate()函数</h2><p id="09cb" class="pw-post-body-paragraph kk kl iv km b kn md jw kp kq me jz ks kt mf kv kw kx mg kz la lb mh ld le lf io bi translated">人们通常希望数据帧中的列有一个特定的顺序，而以前唯一的方法是在一个<code class="fe lg lh li lj b">select()</code>动词中对列进行排序，如果涉及到很多列，这就很繁琐了。</p><p id="0da0" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">默认情况下，relocate 会将您的一列或多列移动到数据框的左侧。如果你想把它们移动到一个特定的地方，你可以使用<code class="fe lg lh li lj b">.before</code>或者<code class="fe lg lh li lj b">.after</code>参数。例如:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="b7aa" class="lk ll iv lj b gy mq mr l ms mt">mtcars %&gt;% <br/>  dplyr::relocate(disp) %&gt;% <br/>  head(3)</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nf"><img src="../Images/e777c9ef629f75e4d40b7e34a8e8a6fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kNkZ-A3NtuZLP7FTy3ttVg.png"/></div></div></figure><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="067a" class="lk ll iv lj b gy mq mr l ms mt">mtcars %&gt;% <br/>  relocate(starts_with("c"), .after = disp)  %&gt;% <br/>  head(3)</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ng"><img src="../Images/a8a7c77d46051d818332d42045abe1ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNVTRmH_6w1R_3Aoz4ZOMQ.png"/></div></div></figure><h2 id="0aa5" class="lk ll iv bd lm ln lo dn lp lq lr dp ls kt lt lu lv kx lw lx ly lb lz ma mb mc bi translated">3.summarise()函数极其强大的扩展</h2><p id="1451" class="pw-post-body-paragraph kk kl iv km b kn md jw kp kq me jz ks kt mf kv kw kx mg kz la lb mh ld le lf io bi translated">总结——<code class="fe lg lh li lj b">dplyr</code>的原始工具——在这个新版本中变得更加灵活。首先，它现在可以返回向量以在输出中形成多行。其次，它可以返回数据帧以在输出中形成多行和多列。对于一些人来说，这可能有点令人费解，所以我将在这里花一点时间来说明这是如何工作的。</p><p id="8766" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">如果你想总结出一个能产生矢量输出的函数，这很容易。例如，你可以简单概括一个系列:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="885f" class="lk ll iv lj b gy mq mr l ms mt">mtcars %&gt;% <br/>  group_by(cyl) %&gt;% <br/>  summarise(range = range(mpg))</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nh"><img src="../Images/13bb2c6866cfaf1c6964c8c87059d0c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s0L3hOj_rqE34iBcQ_sOSA.png"/></div></div></figure><p id="cde4" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">如果您愿意，您可以与<code class="fe lg lh li lj b">tidyr::pivot_wider()</code>结合:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="acc8" class="lk ll iv lj b gy mq mr l ms mt">library(tidyr)</span><span id="1044" class="lk ll iv lj b gy mu mr l ms mt">mtcars %&gt;% <br/>  group_by(cyl) %&gt;% <br/>  summarise(range = range(mpg)) %&gt;% <br/>  mutate(name = rep(c("min", "max"), length(unique(cyl)))) %&gt;% <br/>  pivot_wider(names_from = name, values_from = range)</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ni"><img src="../Images/8ec78b1e8662c1021e9575cab2627dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3PROCh9qr5jb3c9b6ub-A.png"/></div></div></figure><p id="45aa" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这相当于:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="7017" class="lk ll iv lj b gy mq mr l ms mt">mtcars %&gt;% <br/>  group_by(cyl) %&gt;% <br/>  summarise(min = min(mpg), max = max(mpg))</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ni"><img src="../Images/8ec78b1e8662c1021e9575cab2627dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3PROCh9qr5jb3c9b6ub-A.png"/></div></div></figure><p id="a8c2" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">在这种情况下，第二个选项要简单得多，但是这在输出较长的情况下会很有用。这里有一个计算十分位数的简单方法:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="e975" class="lk ll iv lj b gy mq mr l ms mt">decile &lt;- seq(0, 1, 0.1)</span><span id="2644" class="lk ll iv lj b gy mu mr l ms mt">mtcars %&gt;% <br/>  group_by(cyl) %&gt;% <br/>  summarise(deciles = quantile(mpg, decile)) %&gt;% <br/>  mutate(name = rep(paste0("dec_", decile), length(unique(cyl)))) %&gt;% <br/>  pivot_wider(names_from = name, values_from = deciles)</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nj"><img src="../Images/ab4042352b732de934bfcc3f1f68db98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mIKJrU1SPlOzdrAUHCjUEA.png"/></div></div></figure><p id="5675" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在你总结输出可以是一个数据框架。让我们看一个简单的例子。最近我写了一个函数，可以识别一个向量中所有唯一的无序元素对。现在我想应用它来绘制出<em class="nk">朋友</em>的角色之间的联系网络，基于出现在同一个场景中。</p><p id="530a" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这是我可能正在使用的数据框架的一个简单版本:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="5a64" class="lk ll iv lj b gy mq mr l ms mt">friends_episode &lt;- data.frame(<br/>  scene = c(1, 1, 1, 2, 2, 2),<br/>  character = c("Joey", "Phoebe", "Chandler", "Joey", "Chandler", "Janice")<br/>)</span><span id="07ae" class="lk ll iv lj b gy mu mr l ms mt">friends_episode</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nl"><img src="../Images/81c479de6d7b48e21d4d9c61c6de30e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eadwR6cN17KW3zwz-wA6Eg.png"/></div></div></figure><p id="dc18" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在，我将编写我的函数，该函数接受一个矢量并产生一个两列数据帧，并按场景应用它:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="606e" class="lk ll iv lj b gy mq mr l ms mt">unique_pairs &lt;- function(char_vector = NULL) {</span><span id="5cc7" class="lk ll iv lj b gy mu mr l ms mt">  vector &lt;- as.character(unique(char_vector))</span><span id="c630" class="lk ll iv lj b gy mu mr l ms mt">  df &lt;- data.frame(from = character(), to = character(), stringsAsFactors = FALSE)</span><span id="fb7f" class="lk ll iv lj b gy mu mr l ms mt">  if (length(vector) &gt; 1) {<br/>    for (i in 1:(length(vector) - 1)) {<br/>      from &lt;- rep(vector[i], length(vector) - i) <br/>      to &lt;- vector[(i + 1): length(vector)]</span><span id="aa9d" class="lk ll iv lj b gy mu mr l ms mt">      df &lt;- df %&gt;% <br/>        dplyr::bind_rows(<br/>          data.frame(from = from, to = to, stringsAsFactors = FALSE) <br/>        )<br/>    }<br/>  }</span><span id="5520" class="lk ll iv lj b gy mu mr l ms mt">  df</span><span id="f72e" class="lk ll iv lj b gy mu mr l ms mt">}<br/></span><span id="db91" class="lk ll iv lj b gy mu mr l ms mt">friends_episode %&gt;% <br/>  group_by(scene) %&gt;% <br/>  summarise(unique_pairs(character))</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nl"><img src="../Images/03561c410a501777132a792dfb21953b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ar2UOt66J_6l0JpmWzI8OA.png"/></div></div></figure><p id="c3ae" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">正如您可能看到的，dataframe 是我的<code class="fe lg lh li lj b">summarise()</code>函数的输出，它已经被解包并在最终输出中形成了两列。如果我们命名我们的<code class="fe lg lh li lj b">summarise()</code>函数的输出会发生什么？</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="338b" class="lk ll iv lj b gy mq mr l ms mt">friends_pairs &lt;- friends_episode %&gt;% <br/>  group_by(scene) %&gt;% <br/>  summarise(pairs = unique_pairs(character))</span><span id="87bf" class="lk ll iv lj b gy mu mr l ms mt">friends_pairs</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nh"><img src="../Images/b12caf1ffb09e1f182e147a564e0b652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7PllF-Xi2DNwRPPuLyaI2A.png"/></div></div></figure><p id="6792" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">所以这是一个重要的警戒。如果您希望您的<code class="fe lg lh li lj b">summarise()</code>输出解包，不要命名它。</p><h2 id="aaf3" class="lk ll iv bd lm ln lo dn lp lq lr dp ls kt lt lu lv kx lw lx ly lb lz ma mb mc bi translated">4.与 cross 的更强大的 colwise 争论()</h2><p id="bc9f" class="pw-post-body-paragraph kk kl iv km b kn md jw kp kq me jz ks kt mf kv kw kx mg kz la lb mh ld le lf io bi translated">有了这些更强大的汇总功能，再加上内置的<code class="fe lg lh li lj b">tidyselect</code>工具包，我们就有了更强大、更抽象的功能来处理我们的数据列，并形成更广泛的任务。新副词<code class="fe lg lh li lj b">across()</code>的引入实现了这一点。</p><p id="6671" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">简而言之，新函数<code class="fe lg lh li lj b">across()</code>在现有的<code class="fe lg lh li lj b">dplyr</code>动词(如<code class="fe lg lh li lj b">summarise()</code>或<code class="fe lg lh li lj b">mutate()</code>)中跨多个列和多个函数进行操作。这使得<em class="nk">极其</em>强大且省时。现在不再需要作用域变量，如<code class="fe lg lh li lj b">summarise_at()</code>、<code class="fe lg lh li lj b">mutate_if()</code>等。</p><p id="be3a" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">首先，您可以通过手动定义一组列来复制<code class="fe lg lh li lj b">summarise_at()</code>,使用列名的字符向量进行总结，或者使用列号:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="fc59" class="lk ll iv lj b gy mq mr l ms mt">library(dplyr)</span><span id="6e35" class="lk ll iv lj b gy mu mr l ms mt">mtcars %&gt;% <br/>  group_by(cyl) %&gt;% <br/>  summarise(across(c("mpg", "hp"), mean))</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nm"><img src="../Images/6a989b67d30758c142348e6cd1908b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UA44c0JdHzmaKSZC.png"/></div></div></figure><p id="466c" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated"><code class="fe lg lh li lj b">across()</code>是一个选择函数，因此您可以在其中使用<code class="fe lg lh li lj b">tidyselect</code>语法。您可以通过使用一个函数选择您的列来复制<code class="fe lg lh li lj b">mutate_if()</code>。这里我们将<code class="fe lg lh li lj b">dplyr::storms</code>数据集中的<code class="fe lg lh li lj b">name</code>和<code class="fe lg lh li lj b">status</code>列从字符转换为因子。</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="297c" class="lk ll iv lj b gy mq mr l ms mt">storms %&gt;% <br/>  dplyr::mutate(across(is.character, as.factor)) %&gt;% <br/>  dplyr::select(name, status)</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ni"><img src="../Images/ad8c100fd2a4462eebc05740cfbfee44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jxwvnIPN2rOpeYMZ.png"/></div></div></figure><p id="49cb" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">还可以通过使用列表将多个命名函数应用于多个列。默认情况下,<code class="fe lg lh li lj b">across()</code>函数会用下划线将函数名和列名粘在一起:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="d2bb" class="lk ll iv lj b gy mq mr l ms mt">mtcars %&gt;% <br/>  group_by(cyl) %&gt;% <br/>  summarise(across(c("mpg", "hp"), list(mean = mean, median = median, sd = sd)))</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nn"><img src="../Images/cd6c39ed9123e985a3cb582936375956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fTWcW7vpfu4grW6i.png"/></div></div></figure><p id="7b28" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">如果您想使用不同的粘合公式，可以使用粘合语法:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="54bc" class="lk ll iv lj b gy mq mr l ms mt">mtcars %&gt;% <br/>  group_by(cyl) %&gt;% <br/>  summarise(across(starts_with("d"), <br/>                   list(mean = mean, sd = sd), <br/>                   .names = "{col}_{fn}_summ"))</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi no"><img src="../Images/33d24e37142da9359f58745394aea614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kHjHp-gBbhF6UGsXUqqT-A.png"/></div></div></figure><p id="d587" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">如果需要在函数中添加可选参数，可以使用公式:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="fcd2" class="lk ll iv lj b gy mq mr l ms mt">mtcars %&gt;% <br/>  group_by(cyl) %&gt;% <br/>  summarise(across(c("mpg", "hp"), <br/>                   list(mean = ~mean(.x, na.rm = T), <br/>                        median = ~median(.x, na.rm = T), <br/>                        sd = ~sd(.x, na.rm = T)), <br/>                   .names = "{col}_{fn}_summ"))</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi np"><img src="../Images/28690092ab552b7e1ad059652039dbe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*grVLo0Tk_bB0yXlW.png"/></div></div></figure><p id="8d6b" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">同样，您可以使用公式来组合函数，以避免不必要的额外变异:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="55bc" class="lk ll iv lj b gy mq mr l ms mt">mtcars %&gt;% <br/>  group_by(cyl) %&gt;% <br/>  summarise(across(mpg, <br/>                   list(minus_sd = ~(mean(.x) - sd(.x)), <br/>                        mean = mean, <br/>                        plus_sd = ~(mean(.x) + sd(.x)))<br/>                   ))</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nm"><img src="../Images/9a26da9baaf9f0c44ab5546f99c72761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*O_199GWbuqWBtvBw.png"/></div></div></figure><h2 id="f8a4" class="lk ll iv bd lm ln lo dn lp lq lr dp ls kt lt lu lv kx lw lx ly lb lz ma mb mc bi translated">5.rowwise()在新的 dplyr 中变得生动起来</h2><p id="e1d1" class="pw-post-body-paragraph kk kl iv km b kn md jw kp kq me jz ks kt mf kv kw kx mg kz la lb mh ld le lf io bi translated"><code class="fe lg lh li lj b">dplyr</code>以前对跨行工作的友好程度有限。以前，当您想要对同一行中的值求和或求平均值时，它的行为有些违背直觉。这里有一个例子，你们中的一些人可能会认为这是以前头痛的根源:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="c0e2" class="lk ll iv lj b gy mq mr l ms mt">WorldPhones_df &lt;- WorldPhones %&gt;% <br/>  as.data.frame() </span><span id="7a19" class="lk ll iv lj b gy mu mr l ms mt"># mutate an average column</span><span id="dcbe" class="lk ll iv lj b gy mu mr l ms mt">WorldPhones_df %&gt;% <br/>  dplyr::mutate(avg = mean(N.Amer:Mid.Amer))</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ni"><img src="../Images/ee111bf5c19400cd0c710237c231211c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGJgEVWV3cAOVZXuSVaheg.png"/></div></div></figure><p id="748a" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这返回了数据帧中每一列的平均值，这当然不是我们想要的。</p><p id="5154" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">以前，解决这个问题的唯一方法是使用手动计算，并避免以这种方式使用函数，所以你会写<code class="fe lg lh li lj b">(N.Amer + Europe + Asia + S.Amer + Oceania + Africa + Mid.Amer)/7</code>，这是相当乏味的。</p><p id="32e3" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated"><code class="fe lg lh li lj b">rowwise()</code>创建了一个名为<code class="fe lg lh li lj b">rowwise_df</code>的不同结构，它准备你的数据来执行跨行操作——它基本上按行对你的数据进行分组。</p><p id="f58e" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">新的<code class="fe lg lh li lj b">c_across()</code>副词赋予了<code class="fe lg lh li lj b">rowwise()</code>强大的功能，允许您以类似于使用<code class="fe lg lh li lj b">across()</code>副词的方式工作。现在你可以写:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="4356" class="lk ll iv lj b gy mq mr l ms mt">WorldPhones_df %&gt;% <br/>  rowwise() %&gt;% <br/>  dplyr::mutate(avg = mean(c_across(N.Amer:Mid.Amer)))</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nj"><img src="../Images/11689519a6a84b1b06655a801a4c8a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSZJ2ifJai7llNmMH1H4xg.png"/></div></div></figure><h2 id="9c0d" class="lk ll iv bd lm ln lo dn lp lq lr dp ls kt lt lu lv kx lw lx ly lb lz ma mb mc bi translated">6.在数据框架中运行不同的模型</h2><p id="d09b" class="pw-post-body-paragraph kk kl iv km b kn md jw kp kq me jz ks kt mf kv kw kx mg kz la lb mh ld le lf io bi translated">新的<code class="fe lg lh li lj b">rowwise_df</code>对象设计用于列表列，它允许在数据帧的列中存储任何类型的数据。我发现这个特别有价值的地方是，你想根据某些变量的值对你的数据子集运行不同的模型。这里有一个例子，说明如何将不同的<code class="fe lg lh li lj b">mtcars</code>子集存储在一个行方式的数据帧中，然后在它们上面运行一个模型。</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="68da" class="lk ll iv lj b gy mq mr l ms mt">model_coefs &lt;- function(formula, data) {<br/>  coefs &lt;- lm(formula, data)$coefficients<br/>  data.frame(coef = names(coefs), value = coefs)<br/>}</span><span id="c5e8" class="lk ll iv lj b gy mu mr l ms mt">mtcars %&gt;% <br/>  dplyr::group_by(cyl) %&gt;% <br/>  tidyr::nest() %&gt;% <br/>  dplyr::rowwise() %&gt;% <br/>  dplyr::summarise(model_coefs(mpg ~ wt + disp + hp, data = data)) %&gt;% <br/>  tidyr::pivot_wider(names_from = coef, values_from = value)</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nq"><img src="../Images/6a9a78d9a82d3ccf201e710712a7b696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjljklnfqNC8dcpwEuxwjw.png"/></div></div></figure><h2 id="de68" class="lk ll iv bd lm ln lo dn lp lq lr dp ls kt lt lu lv kx lw lx ly lb lz ma mb mc bi translated">7.<code class="fe lg lh li lj b">nest_by()</code>功能</h2><p id="24f1" class="pw-post-body-paragraph kk kl iv km b kn md jw kp kq me jz ks kt mf kv kw kx mg kz la lb mh ld le lf io bi translated">当然，<code class="fe lg lh li lj b">dplyr 1.0.0</code>背后的开发人员注意到了这种行方式建模能力的强大，因此创建了<code class="fe lg lh li lj b">nest_by()</code>函数作为上面代码的快捷方式。<code class="fe lg lh li lj b">nest_by(x)</code>相当于:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="9685" class="lk ll iv lj b gy mq mr l ms mt">dplyr::group_by(x) %&gt;% <br/>  tidyr::nest() %&gt;% <br/>  dplyr::rowwise()</span></pre><p id="c204" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">因此，现在您可以使用以下方法进行上述建模:</p><pre class="mi mj mk ml gt mm lj mn mo aw mp bi"><span id="e772" class="lk ll iv lj b gy mq mr l ms mt">mtcars %&gt;% <br/>  nest_by(cyl) %&gt;% <br/>  dplyr::summarise(model_coefs(mpg ~ wt + disp + hp, data = data)) %&gt;% <br/>  tidyr::pivot_wider(names_from = coef, values_from = value)</span></pre><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ni"><img src="../Images/356f39c0c9955a6af20cfad63ec33d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4GlHgpmPkESchcX1yKQ-g.png"/></div></div></figure></div><div class="ab cl nr ns hz nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="io ip iq ir is"><p id="6b24" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">最初我是一名纯粹的数学家，后来我成为了一名心理计量学家和数据科学家。我热衷于将所有这些学科的严谨性应用到复杂的人的问题上。我也是一个编码极客和日本 RPG 的超级粉丝。在 <a class="ae ne" href="https://www.linkedin.com/in/keith-mcnulty/" rel="noopener ugc nofollow" target="_blank"> <em class="nk"> LinkedIn </em> </a> <em class="nk">或</em><a class="ae ne" href="https://twitter.com/dr_keithmcnulty" rel="noopener ugc nofollow" target="_blank"><em class="nk">Twitter</em></a><em class="nk">上找我。也可以看看我在</em><a class="ae ne" href="http://drkeithmcnulty.com/" rel="noopener ugc nofollow" target="_blank"><em class="nk">drkeithmcnulty.com</em></a><em class="nk">的博客。</em></p><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ny"><img src="../Images/8347d3d6222f3158c01db2502b45c85f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yq3z66olonxyvnQFoIhuGA.png"/></div></div></figure></div></div>    
</body>
</html>