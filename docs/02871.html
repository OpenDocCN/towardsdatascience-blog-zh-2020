<html>
<head>
<title>.NET Core API — Dive into C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。NET核心API —深入研究C#</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/net-core-api-dive-into-c-27dcd4170066?source=collection_archive---------23-----------------------#2020-03-19">https://towardsdatascience.com/net-core-api-dive-into-c-27dcd4170066?source=collection_archive---------23-----------------------#2020-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b11d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为英雄角之旅教程构建一个后端web服务器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2aa4a2c7661e3cc7b1c43ab02b4a4682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3H93QReCh8ZOBKnR3BBCA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@archaique?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">张</a>在<a class="ae ky" href="https://unsplash.com/s/photos/dive?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="067a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你一直跟随<a class="ae ky" href="https://medium.com/@richardpeterson320/net-core-api-for-the-angular-tour-of-heroes-app-5895a36d2129" rel="noopener">系列大纲</a>，并且有一个<a class="ae ky" href="https://medium.com/@richardpeterson320/net-core-api-for-the-angular-tour-of-heroes-app-5895a36d2129" rel="noopener">工作数据库</a>，一个<a class="ae ky" href="https://angular.io/tutorial" rel="noopener ugc nofollow" target="_blank">角游英雄App </a>，一个<a class="ae ky" href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-3.1&amp;tabs=visual-studio" rel="noopener ugc nofollow" target="_blank">通用。我们现在已经进入了这个系列的核心部分，为我们的。NET API。</a></p><p id="7488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要继续学习，您可以下载。NET API+Docker MSSQL DB+Angular app来自<a class="ae ky" href="https://github.com/rchardptrsn/TourOfHeroes-dotNETCore" rel="noopener ugc nofollow" target="_blank">我的GitHub repo。</a></p><p id="492b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中我们将遵循的流程是:</p><ol class=""><li id="5002" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">连接字符串和Startup.cs</li><li id="37dc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">模型</li><li id="807b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">脚手架控制器</li><li id="6641" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">控制器路由</li><li id="4466" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">邮递员测试</li><li id="cf84" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">克-奥二氏分级量表</li><li id="ac1b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">修改角度应用程序</li></ol><h1 id="4589" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">我们开始吧！</h1><p id="1a04" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如果你没有看过这个系列的<a class="ae ky" href="https://medium.com/@richardpeterson320/net-core-api-for-the-angular-tour-of-heroes-app-5895a36d2129" rel="noopener">介绍</a>，我强烈推荐。如果你刚入门，已经有了一个通用的API，那太好了！如果从头开始，只需从命令行运行:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ec79" class="nl mk it nh b gy nm nn l no np">dotnet new webapi -n Heroes.API</span></pre><p id="6254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个样本。用假天气预报数据的NET核心API。我有<strong class="lb iu">。NET Core 3.0.2 </strong>安装在我的机器上，所以所有的依赖项都将针对3.0.2。</p><p id="be4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从示例API中，删除<code class="fe nq nr ns nh b">WeatherForecast.cs</code>和<code class="fe nq nr ns nh b">WeatherForecastController.cs</code>。</p><h1 id="62c2" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">导入包</h1><p id="8355" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们需要几个包裹来装我们的。NET核心应用程序来工作。您可以使用NuGet软件包管理器或从命令行安装这些软件包:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="7654" class="nl mk it nh b gy nm nn l no np">dotnet add package Microsoft.EntityFrameworkCore --version 3.0.2<br/>dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 3.0.2<br/>dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design --version 3.0.0<br/>dotnet add package Microsoft.EntityFrameworkCore.Design --version 3.0.2</span></pre><h1 id="0e33" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">模型</h1><p id="5fd5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在名为Model的目录下新建一个文件夹，在Model文件夹下新建一个名为<code class="fe nq nr ns nh b">Hero.cs</code>的C#类。</p><p id="cf23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模型将定义数据库和应用程序中数据的属性，因此我们只需添加<code class="fe nq nr ns nh b">id</code>和<code class="fe nq nr ns nh b">name</code>的值。</p><h2 id="d617" class="nl mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">英雄。API/Model/Hero.cs</h2><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="b853" class="nl mk it nh b gy nm nn l no np">namespace Heroes<em class="oe">.</em>API<em class="oe">.</em>Model</span><span id="547d" class="nl mk it nh b gy of nn l no np">{<br/>    <em class="oe">public</em> class HeroValue<br/>    {<br/>        <em class="oe">public</em> int id { get; set; }<br/>        <em class="oe">public</em> string name { get; set; }<br/>    }<br/>}</span></pre><p id="0037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要添加一个数据库上下文来管理。NET核心数据模型和数据库。我们将我们的上下文类命名为<code class="fe nq nr ns nh b">HeroesContext</code>，它将从DbContext继承。<code class="fe nq nr ns nh b">HeroesContext</code>将包含一个DbSet <code class="fe nq nr ns nh b">HeroValues</code>，它对应于我们在SQL中的表名。</p><p id="79ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<code class="fe nq nr ns nh b">Data</code>的文件夹，并添加一个名为<code class="fe nq nr ns nh b">HeroesContext.cs</code>的新C#文件。将以下代码添加到您的<code class="fe nq nr ns nh b">HeroesContext.cs</code>中。</p><h2 id="ee8d" class="nl mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">英雄。API/Data/HeroesContext.cs</h2><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="3a00" class="nl mk it nh b gy nm nn l no np">using Microsoft.EntityFrameworkCore;<br/>using Heroes.API.Model;</span><span id="b8e3" class="nl mk it nh b gy of nn l no np">namespace Heroes.API.Data<br/>{</span><span id="48de" class="nl mk it nh b gy of nn l no np">    public class HeroesContext : DbContext<br/>    {<br/>        public HeroesContext (DbContextOptions&lt;HeroesContext&gt; options)<br/>            : base(options)<br/>        {<br/>        }</span><span id="824a" class="nl mk it nh b gy of nn l no np">        public DbSet&lt;HeroValue&gt; HeroValue { get; set; }<br/>    }<br/>}</span></pre><p id="7f9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要在我们的<code class="fe nq nr ns nh b">Startup.cs</code>文件中添加一个对DbSet的引用，这样。NET知道使用<code class="fe nq nr ns nh b">HeroesContext</code>作为与数据库交互的上下文。我们还将把数据库的连接字符串添加到我们的<code class="fe nq nr ns nh b">appsettings.json</code>文件中。</p><p id="308c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这个添加到您的<code class="fe nq nr ns nh b">public void ConfigureServices</code>下的<code class="fe nq nr ns nh b">Startup.cs</code>文件中。在我们的例子中，我们使用<a class="ae ky" rel="noopener" target="_blank" href="/build-a-mssql-docker-container-800166ecca21"> Docker MSSQL数据库</a>进行测试和开发。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="db32" class="nl mk it nh b gy nm nn l no np">services.AddDbContext&lt;HeroesContext&gt;(options =&gt;<br/>options.UseSqlServer(Configuration.GetConnectionString("DockerDB")));</span></pre><p id="8e25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将“DockerDB”连接字符串添加到<code class="fe nq nr ns nh b">appsettings.json</code>。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="122d" class="nl mk it nh b gy nm nn l no np">"ConnectionStrings": {<br/>    "DockerDB": "Server=localhost,1433;Database=heroes;User ID=SA;Password=Password1!"<br/>  }</span></pre><h1 id="67a3" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">脚手架控制器</h1><p id="9b9f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了创建<code class="fe nq nr ns nh b">HeroesController</code>，我们将使用aspnet-codegenerator工具为我们搭建控制器。</p><p id="f001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们必须从命令行安装该工具。然后，从项目的根目录中，运行<code class="fe nq nr ns nh b">aspnet-codegenerator</code>。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="63bf" class="nl mk it nh b gy nm nn l no np"># Install the tool</span><span id="f4ea" class="nl mk it nh b gy of nn l no np">dotnet tool install --global dotnet-aspnet-codegenerator --version 3.0.0</span><span id="e863" class="nl mk it nh b gy of nn l no np"># Run the aspnet-codegenerator</span><span id="fcc7" class="nl mk it nh b gy of nn l no np">dotnet aspnet-codegenerator controller -name HeroesController -async -api -m HeroValue -dc HeroesContext -outDir Controllers</span></pre><p id="8d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，您将看到在控制器文件夹下创建了一个名为HeroesController的新文件。打开它可以看到为您创建的基本控制器。这个工具对于把你的控制器的基本结构安排到位是非常有用的。现在，让我们编辑控制器，以匹配来自我们的Angular应用程序。</p><p id="b2d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用代码生成器有一个意想不到的副作用。它为DbContext名称的<strong class="lb iu">configure services:</strong><code class="fe nq nr ns nh b">services.AddDbContext</code>中的连接字符串的<code class="fe nq nr ns nh b">Startup.cs</code>添加了一个值，这是有意义的，但不是我们想要在这个开发环境中用于连接字符串的值。替换“HeroesContext”的连接字符串值，使您的<code class="fe nq nr ns nh b">services.AddDbContext</code>再次看起来像这样:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="7485" class="nl mk it nh b gy nm nn l no np">services.AddDbContext&lt;HeroesContext&gt;(options =&gt;<br/>options.UseSqlServer(Configuration.GetConnectionString("DockerDB")));</span></pre><p id="908f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到这里，在<code class="fe nq nr ns nh b">Startup.cs</code>的<strong class="lb iu">配置</strong>方法中，让我们将<strong class="lb iu">注释掉</strong> <em class="oe"> app。usehttps redirection()；。我们的应用程序不需要它。</em></p><h1 id="5308" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">控制器方法</h1><p id="3fc3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在我们的控制器中，我们将有5个基本方法来与数据库交互，并将值返回给Angular应用程序。这5个方法由从Angular到。NET app。搞什么。NET app寻找的是带有提供的路由的HTTP请求。这些路线是:</p><ol class=""><li id="a275" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><em class="oe"> GET: api/Heroes — </em>这个方法将返回数据库中的所有英雄</li><li id="2bcd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="oe"> GET: api/Heroes/5 — </em>这个方法将从数据库中返回一个特定的英雄。在这种情况下，它将返回Id为5的英雄。</li><li id="f3c3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="oe"> PUT: api/Heroes/5 — </em>这个方法会更新一个特定英雄的信息。</li><li id="b579" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="oe"> POST: api/Heroes — </em>这个方法会向数据库发布一个新的英雄。</li><li id="ab73" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="oe"> DELETE: api/Heroes/5— </em>这个方法将从数据库中删除一个特定的英雄。</li></ol><p id="ebf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从头开始。</p><h2 id="52da" class="nl mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">获取:API/英雄</h2><p id="57cf" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Angular app会用这个路由从. NET中获取所有英雄的IEnumerable列表对象，这个方法对应Angular' <code class="fe nq nr ns nh b">hero.service.ts</code>中的<code class="fe nq nr ns nh b">getHeroes()</code>方法。</p><p id="d1a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用下面的代码替换第一个GET方法，这在很大程度上得益于微软文档为控制器添加了一个<a class="ae ky" href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/search?view=aspnetcore-3.1" rel="noopener ugc nofollow" target="_blank">搜索功能。</a>记住，Angular应用程序对几个不同的组件使用GET: api/Heroes请求。它需要能够返回英雄仪表板，英雄列表页面的列表，也可以在仪表板上的搜索框中搜索英雄。</p><p id="e081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过一个异步ActionResult <ienumerable>来实现这一点，它从GET请求中的查询字符串获得信息。该查询可以是no information，返回所有英雄，也可以是search string，只返回名字中包含该字符串的英雄。</ienumerable></p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="6d49" class="nl mk it nh b gy nm nn l no np">//<em class="oe"> GET: api/Heroes</em></span><span id="9f77" class="nl mk it nh b gy of nn l no np">[HttpGet]<br/>public async Task&lt;ActionResult&lt;IEnumerable&lt;HeroValue&gt;&gt;&gt; GetHeroValue([FromQuery] string name)<br/>{<br/>    // Define a LINQ query<br/>    var heroquery = from h in _context.HeroValue select h;<br/>    <br/>    // If the string is not empty, find items 'h' whose name contains the query string<br/>    if (!String.IsNullOrEmpty(name))<br/>    {<br/>        heroquery = heroquery.Where(<br/>            h =&gt; h.name.Contains(name));<br/>    }</span><span id="0c33" class="nl mk it nh b gy of nn l no np">// Return an asynchronous list of heroes that satisfy query<br/>    return await heroquery<em class="oe">.OrderBy</em>(num =&gt; num<em class="oe">.id</em>).<em class="oe">ToListAsync</em>();<br/>}</span></pre><p id="3ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用Postman测试GET控制器方法。Postman提供了一种用户友好的方式来测试您的API。首先，启动你的Docker数据库。运行您的。NET核心API，方法是从API的根目录运行<code class="fe nq nr ns nh b">dotnet watch run</code>。当API启动并监听端口5000时，在Postman中，我们将发送2个请求来测试我们想要的结果:</p><ol class=""><li id="df87" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">向<code class="fe nq nr ns nh b"><a class="ae ky" href="http://localhost:5000/api/Heroes," rel="noopener ugc nofollow" target="_blank">http://localhost:5000/api/Heroe</a>s</code>发出<code class="fe nq nr ns nh b">GET</code>请求。观察返回状态为<code class="fe nq nr ns nh b">200 OK</code>的JSON数组。这将满足我们的仪表板和英雄列表的GET请求。</li><li id="a6f4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对<code class="fe nq nr ns nh b"><a class="ae ky" href="http://localhost:5000/api/Heroes/?name=wonder" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/api/Heroes/?name=wonde</a>r</code>的<code class="fe nq nr ns nh b">GET</code>请求。观察<code class="fe nq nr ns nh b">"id": 1, "name": "Wonder Woman\r"</code>的返回值</li></ol><p id="beec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你。您有一个工作的API！我们建出来按Id找英雄吧。</p><h2 id="e97b" class="nl mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated"><em class="og"> GET: api/Heroes/5 </em></h2><p id="a7a0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这是我们的aspnet-codegenerator真正闪光的地方。我们不需要对这个控制器方法做任何改动。它已经准备就绪，代码已经生成。它只是在路线中找到传递给它的具有匹配id的英雄。你的方法应该是:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ee74" class="nl mk it nh b gy nm nn l no np">[HttpGet("{id}")]<br/>public async Task&lt;ActionResult&lt;HeroValue&gt;&gt; GetHeroValue(int id)<br/>{<br/>    var heroValue = await _context.HeroValue.FindAsync(id);</span><span id="0abc" class="nl mk it nh b gy of nn l no np">    if (heroValue == null)<br/>    {<br/>        return NotFound();<br/>    }</span><span id="49ac" class="nl mk it nh b gy of nn l no np">    return heroValue;<br/>}</span></pre><p id="c019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在邮递员中测试:</p><ul class=""><li id="1cef" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oh mb mc md bi translated">对<code class="fe nq nr ns nh b"><a class="ae ky" href="http://localhost:5000/api/Heroes/2" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/api/Heroes/2</a></code>运行一个<code class="fe nq nr ns nh b">GET</code>请求，观察一个JSON结果“id”:5，“name”:“Bat Man \ r”。</li></ul><h2 id="2c12" class="nl mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated"><em class="og"> PUT: api/Heroes/5 </em></h2><p id="e7bd" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这也是aspnet-codegenerator为我们完美搭建的一个方法。只需运行一个邮差测试来进行测试:</p><ul class=""><li id="5c5d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oh mb mc md bi translated">向<code class="fe nq nr ns nh b"><a class="ae ky" href="http://localhost:5000/api/Heroes/5" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/api/Heroes/5</a></code>运行一个<code class="fe nq nr ns nh b">PUT</code>请求。在请求的Body下，将TEXT更改为JSON，并填写请求正文，如下所示:</li></ul><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="fa8c" class="nl mk it nh b gy nm nn l no np">{<br/>    "id": 5,<br/>    "name": "Dr. Strange"<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/dedd19a6cfa722582bb2623cfc62c22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qu2ESIvOzCMhZqDmS3AyKA.png"/></div></div></figure><p id="a80c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果成功，您将收到请求状态<code class="fe nq nr ns nh b">204 No Content</code>。</p><h2 id="100c" class="nl mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated"><em class="og">岗位:API/英雄</em></h2><p id="d69d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">你需要能够发布新的英雄到数据库。此外，您的API需要为新英雄创建Id，Angular只提供名称。您的API使用DbSet <code class="fe nq nr ns nh b">_context.HeroValue</code>的当前上下文来访问数据库中的值。使用。Max找到数据库中最高的Id，用1枚举，并将这个新Id分配给<code class="fe nq nr ns nh b">herovalue.id</code>。然后用<code class="fe nq nr ns nh b">.Add</code>和<code class="fe nq nr ns nh b">.SaveChangesAsync</code>将新的保存到数据库，并返回一个<em class="oe"> CreatedAtAction </em>结果，产生一个状态201 Created响应。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a284" class="nl mk it nh b gy nm nn l no np">[HttpPost]<br/>public async Task&lt;ActionResult&lt;HeroValue&gt;&gt; PostHeroValue(HeroValue heroValue)<br/>{<br/>    <br/>    if (heroValue == null)<br/>    {<br/>        return BadRequest();<br/>    }</span><span id="08b4" class="nl mk it nh b gy of nn l no np">    // Generate Hero Id<br/>    //<a class="ae ky" href="https://github.com/lohithgn/blazor-tour-of-heroes/blob/master/src/BlazorTourOfHeroes/BlazorTourOfHeroes.Server/Controllers/HeroesController.cs" rel="noopener ugc nofollow" target="_blank">https://github.com/lohithgn/blazor-tour-of-heroes/blob/master/src/BlazorTourOfHeroes/BlazorTourOfHeroes.Server/Controllers/HeroesController.cs</a><br/>    // Grab the current context of the DbSet HeroValue<br/>    // Find the max id<br/>    // increase by 1<br/>    heroValue.id = _context.HeroValue.Max(h =&gt; h.id) + 1;<br/>    _context.HeroValue.Add(heroValue);<br/>    await _context.SaveChangesAsync();</span><span id="89ca" class="nl mk it nh b gy of nn l no np">    return CreatedAtAction("GetHeroValue", new { id = heroValue.id }, heroValue);<br/>}</span></pre><p id="f5fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在邮递员中测试:</p><p id="076d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向<code class="fe nq nr ns nh b"><a class="ae ky" href="http://localhost:5000/api/Heroes/" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/api/Heroes/</a></code>发送一个<code class="fe nq nr ns nh b">POST</code>请求，JSON主体为:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="0d50" class="nl mk it nh b gy nm nn l no np">{<br/> "name": "Poison Ivy"<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/a09aba2540d07153922db37efccfdb17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vS56grg12arCco7HK-0BqQ.png"/></div></div></figure><p id="3c18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观察<code class="fe nq nr ns nh b">Status: 201 Created</code>。成功！</p><h2 id="664f" class="nl mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated"><em class="og">删除:api/Heroes/5 </em></h2><p id="42e3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">最后，你需要能够删除英雄。这是在angular向API发送一个HTTP DELETE请求时完成的，该请求带有要删除的hero Id。幸运的是，我们的DELETE方法是由aspnet-codegenerator完美地生成的。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f1d8" class="nl mk it nh b gy nm nn l no np">[HttpDelete("{id}")]<br/>public async Task&lt;ActionResult&lt;HeroValue&gt;&gt; DeleteHeroValue(int id)<br/>{<br/>    var heroValue = await _context.HeroValue.FindAsync(id);<br/>    if (heroValue == null)<br/>    {<br/>        return NotFound();<br/>    }</span><span id="20b8" class="nl mk it nh b gy of nn l no np">    _context.HeroValue.Remove(heroValue);<br/>    await _context.SaveChangesAsync();</span><span id="e79c" class="nl mk it nh b gy of nn l no np">    return heroValue;<br/>}</span></pre><h2 id="9b19" class="nl mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">关于控制器方法的思考</h2><p id="b917" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">aspnet-codegenerator确实帮了我们大忙。我们真正需要考虑的方法只有<code class="fe nq nr ns nh b">GET: api\Heroes</code>中的搜索功能和<code class="fe nq nr ns nh b">POST: api\Heroes</code>的Id生成器。现在我们有了一个可以从Postman测试的功能控制器，我们将添加代码来允许跨源资源共享，更好的说法是CORS。</p><h1 id="4ca3" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">跨产地资源共享— CORS</h1><p id="7969" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Mozilla文档给了我们一个关于CORS的很好的定义。</p><blockquote class="ok ol om"><p id="94f5" class="kz la oe lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated"><strong class="lb iu">跨源资源共享</strong> ( <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>)是一种机制，它使用额外的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP" rel="noopener ugc nofollow" target="_blank"> HTTP </a>头来告诉浏览器，让运行在一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/origin" rel="noopener ugc nofollow" target="_blank">源</a>的web应用程序访问来自不同源的选定资源。</p></blockquote><p id="88c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个angular应用程序运行在一个端口上。NET API运行在另一个端口上。NET不喜欢另一个应用程序未经许可访问它的资源。我们需要使它能够接收来自特定位置的请求，即angular应用程序的本地主机端口。</p><p id="424d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ConfigureServices类上方，创建一个只读字符串:</p><p id="8a3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nq nr ns nh b"><em class="oe">readonly</em> string MyAllowSpecificOrigins = “_myAllowSpecificOrigins”;</code></p><p id="8263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ConfigureServices类中，添加<code class="fe nq nr ns nh b">AddCors</code>服务。您的ConfigureServices类应该如下所示:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="b0c0" class="nl mk it nh b gy nm nn l no np">public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddCors(options =&gt;<br/>    {<br/>        options.AddPolicy(MyAllowSpecificOrigins,<br/>        builder =&gt;<br/>        {<br/>            builder.WithOrigins("<a class="ae ky" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank">http://localhost:4200</a>")<br/>                                .AllowAnyHeader()<br/>                                .AllowAnyMethod();<br/>        });<br/>    });<br/>    services.AddControllers();<br/>    services.AddDbContext&lt;HeroesContext&gt;(options =&gt;<br/>            options.UseSqlServer(Configuration.GetConnectionString("DockerDB")));<br/>}</span></pre><p id="cb14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在创建一个构建器，只允许来自<code class="fe nq nr ns nh b"><a class="ae ky" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank">http://localhost:4200</a></code>的请求，我们的angular应用程序正在该端口运行。此外，从该端口，我们允许任何头和任何方法访问我们的可用资源。NET API。</p><p id="ae8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要为CORS做的最后一件事是将我们刚刚创建的服务添加到我们在<code class="fe nq nr ns nh b">Startup.cs</code>中的<strong class="lb iu"> Configure </strong>方法中。将此添加到您的配置方法中:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="82a0" class="nl mk it nh b gy nm nn l no np">app<em class="oe">.UseCors</em>(MyAllowSpecificOrigins);</span></pre><p id="3b32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的API完成了！现在我们只需将angular应用指向您的API端点。</p><h1 id="00de" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">回到Angular应用程序</h1><p id="796b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们已经非常接近完成了！只需要对angular应用程序进行一些更改，它就可以从我们的API请求数据。</p><h1 id="11c8" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">应用程序模块</h1><p id="fdd4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们需要禁用您在英雄之旅教程中构建的内存web api。在<code class="fe nq nr ns nh b">app.module.ts</code>中注释掉这些导入</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="bdc3" class="nl mk it nh b gy nm nn l no np">//<em class="oe">import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';</em></span><span id="349c" class="nl mk it nh b gy of nn l no np">//<em class="oe">import { InMemoryDataService }  from './in-memory-data.service';</em></span></pre><p id="4d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，注释掉<code class="fe nq nr ns nh b">@ngModule() imports</code>下的导入</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8cd3" class="nl mk it nh b gy nm nn l no np">//<em class="oe"> HttpClientInMemoryWebApiModule.forRoot(InMemoryDataService, { dataEncapsulation: false })</em></span></pre><h1 id="14c8" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">hero.service.ts</h1><p id="a650" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们的公共HeroService类包含我们的angular应用程序与。NET API。我们应该首先更改heroesURL以匹配我们的API正在监听的端点:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4d5c" class="nl mk it nh b gy nm nn l no np"><em class="oe">private</em> <em class="oe">heroesUrl</em> = 'http://localhost:5000/api/Heroes';</span></pre><p id="7c59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我必须更改HeroService类的另一件事是为updateHero添加一个const URL。传递的URL不正确，导致405方法不允许错误。将URL添加到updateHero类中，使您的类如下所示:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="735e" class="nl mk it nh b gy nm nn l no np">updateHero (hero: Hero): Observable&lt;any&gt; {</span><span id="b8e9" class="nl mk it nh b gy of nn l no np">    // Create the route - getting 405 Method not allowed errors<br/>    const url = `${this.heroesUrl}/${hero.id}`;</span><span id="2fd0" class="nl mk it nh b gy of nn l no np">    return this.http.put(url, hero, this.httpOptions).pipe(<br/>        tap(_ =&gt; this.log(`updated hero id=${hero.id}`)),<br/>        catchError(this.handleError&lt;any&gt;(`updateHero`))<br/>    );<br/>}</span></pre><p id="1e95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在从Angular应用程序的根目录运行<code class="fe nq nr ns nh b">ng serve --open</code>。成功！</p><p id="dd2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，您已经构建了一个. NET API！</p><p id="ab84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以下载完整版本的。NET API+Docker MSSQL DB+Angular app来自<a class="ae ky" href="https://github.com/rchardptrsn/TourOfHeroes-dotNETCore" rel="noopener ugc nofollow" target="_blank">我的GitHub repo。</a></p><p id="ad1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>