<html>
<head>
<title>The Pruning Radix Trie — a Radix Trie on steroids</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修剪基数Trie——类固醇上的基数Trie</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-pruning-radix-trie-a-radix-trie-on-steroids-412807f77abc?source=collection_archive---------42-----------------------#2020-05-28">https://towardsdatascience.com/the-pruning-radix-trie-a-radix-trie-on-steroids-412807f77abc?source=collection_archive---------42-----------------------#2020-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/24b44bd36313899d68d14c031e34ea90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iv8KIzoWvOC6tSNOi0RS3w.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@niko_photos" rel="noopener ugc nofollow" target="_blank"> niko photos </a></p></figure><p id="20a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">修剪基数三叉树是一种新的数据结构，从基数三叉树派生而来，但是速度快了3个数量级。</strong></p><p id="831e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我发表了<a class="ae kc" href="https://github.com/wolfgarbe/SymSpell" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> SymSpell </strong> </a>(一种非常快速的拼写纠正算法)之后，我经常被问到它是否也可以用于自动补全。不幸的是，尽管速度很快，SymSpell并不是自动完成的好选择。基数Trie似乎是自动完成的自然选择。但是在大字典中查找一个小前缀——导致大量的候选字——速度不够快。因此，我设计了修剪基数Trie -一个自动完成的解决方案的速度与SymSpell。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="9404" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<a class="ae kc" href="https://en.wikipedia.org/wiki/Radix_tree" rel="noopener ugc nofollow" target="_blank">基数Trie </a>或Patricia Trie是一个空间优化的Trie(前缀树)。运行基数trie的P<br/>算法<strong class="kf ir">是一种新的基数trie算法，它允许<strong class="kf ir">修剪基数trie的</strong>和<strong class="kf ir">提前终止查找的</strong>。</strong></p><p id="ddbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在基数Trie中，<strong class="kf ir">查找是O(k) </strong>，其中k是密钥的长度。虽然这非常快，但不幸的是，这仅适用于单个术语查找。查找给定前缀的所有术语(或最相关的前k个)是<strong class="kf ir">更昂贵的</strong>——这是自动完成所需的操作。</p><p id="639b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特别是对于短前缀，我们必须遍历整个树的重要部分，以便<strong class="kf ir">找到所有的</strong>或<strong class="kf ir">识别前k个最相关的</strong>候选。</p><p id="89ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">包含数百万条短前缀建议的完整结果集对自动补全毫无帮助。这就是为什么在大多数情况下，我们对给定前缀的所有子词的完整集合不感兴趣，而只对最相关的前k个词感兴趣。我们可以利用这一事实来实现top-k结果的查找时间的<strong class="kf ir">大幅减少。通过用关于所有其子节点的最大等级的附加信息来扩充trie节点数据结构，我们可以实现trie遍历的修剪和提前终止。</strong></p><blockquote class="li lj lk"><p id="540f" class="kd ke ll kf b kg kh ki kj kk kl km kn lm kp kq kr ln kt ku kv lo kx ky kz la ij bi translated">通过在每个节点中存储其所有子节点的最大等级来实现查找加速。通过将该最大子等级与迄今检索到的结果的最低等级进行比较，我们可以<strong class="kf ir">大量修剪trie </strong>并对具有低子等级的无希望分支进行<strong class="kf ir">提前终止查找</strong>。</p></blockquote><p id="a17f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更新:<em class="ll">在一个</em> <a class="ae kc" href="https://www.reddit.com/r/programming/comments/gum6v4/pruningradixtrie_1000x_faster_radix_trie_for/" rel="noopener ugc nofollow" target="_blank"> <em class="ll"> Reddit评论</em> </a> <em class="ll">有一种误解，认为对于前10条建议，人们只需要在字典中查找10次。小心，没那么简单！为了获得前10个最相关的自动完成建议，仅仅在600万条目字典中进行10次查找是不够的。在trie的默认教科书实现中，对于作为输入的单字符前缀“m ”,我们必须遍历整个树的重要部分，并且</em> <strong class="kf ir"> <em class="ll">评估以“m”开头的所有459，735个候选项</em> </strong> <em class="ll">,因为</em> <strong class="kf ir"> <em class="ll">我们不想要仅仅10个随机建议</em></strong><em class="ll"/><strong class="kf ir"><em class="ll">而是那些具有最高等级的</em></strong><em class="ll">(T24)这就是修剪基数trie的改进之处。通过存储和利用一个节点的所有子节点的最大等级，我们可以大规模地修剪trie并进行提前终止。这使我们可以减少我们必须遍历的节点数，我们可以减少候选节点数，从459，735，T34，T36到T37，T38，T39，110，T40，T41，T42！</em></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="5298" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">词典</h1><p id="8e41" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">Terms.txt包含600万个来源于英文维基百科标题的<strong class="kf ir">单字母词</strong>和<strong class="kf ir">双字母词</strong>，使用术语频率计数进行排名。但是你可以为你选择的任何语言和领域使用任何频率字典。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="0809" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">表演</h1><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/03972f8eda97dd3cd6ed3443be815714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HauBPEDRiwyQJ77OuJOj3g.png"/></div></div></figure><blockquote class="li lj lk"><p id="fe70" class="kd ke ll kf b kg kh ki kj kk kl km kn lm kp kq kr ln kt ku kv lo kx ky kz la ij bi translated"><strong class="kf ir">修剪基数Trie </strong>比普通基数Trie<strong class="kf ir">快1000倍</strong>。</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="0697" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">应用:</h1><p id="f7a7" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">PruningRadixTrie非常适合自动完成或查询完成。</p><p id="a858" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然对于一个<strong class="kf ir">单用户</strong>来说，37毫秒的自动完成时间似乎足够快了，但如果我们必须并行地为数以千计的<strong class="kf ir">用户提供服务，例如在<strong class="kf ir"> </strong>搜索引擎和<a class="ae kc" href="https://seekstorm.com" rel="noopener ugc nofollow" target="_blank">搜索API </a>中，情况就完全不同了。那么大型字典中的自动完成查找只有在比普通的基数trie快得多的情况下才变得可行。</strong></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="889d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">自动完成与拼写纠正</h1><p id="e200" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">这两个概念是相关的，而且有些相似。这就是为什么有时很容易使用一种旨在解决拼写纠正的数据结构来实现自动完成，反之亦然。但这不是个好主意。</p><p id="302b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">滥用拼写纠正来实现自动完成</strong></p><p id="bf68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，我们期望从<strong class="kf ir">自动完成的</strong>中为任何给定的前缀找到最可能的单词，即使<strong class="kf ir">前缀是短的</strong>，而<strong class="kf ir">完成的单词是长的</strong>。然后输入和输出之间的<strong class="kf ir">编辑距离</strong>变大——当试图使用自动完成的拼写校正算法时，这会导致两个问题:</p><ol class=""><li id="3db2" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated"><strong class="kf ir">查找时间变得不可行巨大</strong>，因为用<strong class="kf ir"> Levenshtein算法</strong>计算大编辑距离非常耗时。即使是像<a class="ae kc" rel="noopener" target="_blank" href="/symspell-vs-bk-tree-100x-faster-fuzzy-string-search-spell-checking-c4f10d80a078"> SymSpell </a>这样速度极快的拼写纠正算法，也很难在合理的时间内返回“Microsoft Windows”作为“mi”前缀，并且不会用数千个无意义的候选项稀释返回的建议。</li><li id="8b28" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">对于一个大的最大编辑距离，返回的候选人数量<strong class="kf ir">压倒性</strong>违背了提供帮助的目的。由于最大编辑距离将大于给定输入前缀的长度，<strong class="kf ir">大多数返回的候选项甚至没有一个与输入前缀相同的字母。</strong></li></ol><p id="8407" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">滥用自动完成功能进行拼写纠正</strong></p><p id="2b49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，从<strong class="kf ir">拼写纠正，</strong>我们期望纠正所有错误，直到最大编辑距离，甚至<strong class="kf ir">如果错误出现在第一个字母</strong>中。则根本没有公共前缀，使得使用trie(前缀树)进行拼写纠正变得不可能。</p><p id="4287" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">拼写纠正自动完成的组合</strong></p><p id="03d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终，我们可以将两种算法结合起来，例如在SeekStorm 这样的<a class="ae kc" href="https://seekstorm.com" rel="noopener ugc nofollow" target="_blank">搜索引擎的查询领域。但如何有效地做到这一点，那是另一回事。</a></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="6383" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">其他选项</h1><p id="9d95" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">除了使用修剪基数Trie之外，还有其他方法可以加速自动建议:</p><ul class=""><li id="d50c" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nl nd ne nf bi translated">仅在前缀长度阈值(例如≥3)以上时启用自动完成，因为在trie中查找短前缀的时间特别长，并且候选建议的精度很低。</li><li id="9be2" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nl nd ne nf bi translated">对低于前缀长度阈值(例如≤3)的每个前缀使用具有预先计算的top-k建议的哈希映射，因为短前缀的查找时间特别长，并且前缀的数量有限，并且哈希映射中的存储器消耗是可管理的</li></ul></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="5034" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">源代码</h1><p id="b2e8" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在Github<a class="ae kc" href="https://github.com/wolfgarbe/PruningRadixTrie" rel="noopener ugc nofollow" target="_blank">Github</a>的MIT许可下，C#代码已经作为开源代码发布</p></div></div>    
</body>
</html>