# 用 PySpark 解决组合问题

> 原文：<https://towardsdatascience.com/solving-combinatorial-problems-with-pyspark-fad433b1fca0?source=collection_archive---------47----------------------->

![](img/a4ac4dffca1b16d97dad592e017ed228.png)

乔·奇恰雷利在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

## 用二进制表示划分组合问题

让我们考虑问题陈述。给定 *n* 个实数 *x1* ， *x2* ， *xn* ，选择任意一组不同的数，使得函数 *f* 对这些选择的数给出最大值。函数 *f* 可以接受任意数量的输入，因此可以选择任意数量的数字。

期望输出:一组数字 S = { *xi* ， *xj* ，…， *xm* }或 *f(xi，xj，…，xm)的最大值。*

解决这个问题的一个强力策略是对数字进行置换，首先从 n 个数字中选择 1，然后是 2，3，依此类推。如果我们不知道函数 *f* ，那么我们就不知道输入参数的顺序是否重要。因此我们需要排列和组合。如果顺序不重要，那么我们可以使用组合。

# 组合的总和

> 所有 *k* 的 *k* 组合数是一组 *n* 元素的子集数。有几种方法可以看出这个数字是 2^n.
> 
> 来源:[https://en.wikipedia.org/wiki/Combination](https://en.wikipedia.org/wiki/Combination)

很容易看出是否有 n 个数字可能的方法来选择不同的 k 个数字，因为所有的 k 都非常接近 2^n.的二进制表示。n 位二进制向量可以表示从 0 到 2^n-1.的数字如果这个向量的每个索引代表 n 个数字中的一个，如果那个索引的比特是开的，我们可以选择那个数字。这样，我们可以从 0 到 2^n-1 遍历数字，将它们表示为一个 n 位的二进制向量，然后根据哪些位是开的来选择数字。

方法 *get_data* 将 num 转换为二进制表示，并根据返回的数据中哪些位在该索引上。

```
Output:
000 []
001 [1]
010 [4]
011 [4, 1]
100 [3]
101 [3, 1]
110 [3, 4]
111 [3, 4, 1]
```

从上面的输出可以看出，二进制字符串 010 将在索引 1 处获得值 4，而 011 将在索引 1 和 2 处获得[4，1]。一旦我们有了这些值，我们就可以很容易地计算函数 *f* 的值，并最终得到最大值。

# 负载的平均分配

现在，为了对来自数据集的各种组合的函数 *f* 的计算进行并行化，我们希望将所有组合 2^n 的数量以相等的比例划分。

以上方法将数量*计数*分成相等数量的桶(除法)。 *num_per_division* 是除法运算中的数，而 *spill* 是余数，它被加到初始除法运算中，直到它变为零。上述方法用于将 2^n 划分为多个桶，然后在每个桶上并行进行函数 *f* 的计算。

# 计算所有组合的 f

*process_combination* 方法处理一组由等分计算出的数字。它对所有这些数字执行函数 *f* 并返回最大值。

*solve_combination* 把所有东西放在一起。首先，它计算组合的数量，然后将它们分成相等的桶。然后使用 *process_combination* 方法将这些桶并行化以计算所有桶的函数 *f* 。

# 功能 *f* 的一些例子

在各种情况下，函数 *f* 的知识可以极大地减少搜索空间。

## 平均

假设函数 *f* 计算所有输入参数(数字)的平均值。

如果从所有输入数据中选择最大的数字，其平均值将是最大的。因此，在这种情况下，我们可以选择最高的数字，而不是使用 spark。

## 总和

类似于均值 if 函数 *f* 计算所有输入参数(数字)的和。

我们可以对输入数据中的所有数字求和，因为这是最高的。

## 正弦

如果函数 f 计算所有输入参数之和的正弦，那么我们宁愿使用 spark 解。可能有一个更复杂的函数 *f* ,在这个函数中，spark 解决方案非常有用。

# 单元测试

上面我讨论了如何在没有 spark 解决方案的情况下轻松计算平均值和总和。我使用相同的范例来做单元测试。在均值的情况下，我将 spark 的输出与输入数据的最大值进行比较。对于总和，我将火花输出与所有输入数据的总和进行比较。

# 结论

在这篇文章中，我提出了一个简单的框架，说明如何使用一个简单的函数 *f，*来解决组合问题，尽管解决方案并不局限于此，而是可以应用于无数的问题。希望你喜欢它！