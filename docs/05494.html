<html>
<head>
<title>XGBoost Python Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">XGBoost Python示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/xgboost-python-example-42777d01001e?source=collection_archive---------4-----------------------#2020-05-09">https://towardsdatascience.com/xgboost-python-example-42777d01001e?source=collection_archive---------4-----------------------#2020-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/733104c9782c26e2eb072bc140888c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y1vE1Hdlri6XkDGL.jpg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank">杰拉尔特</a>T2】皮克斯贝</p></figure><div class=""/><p id="8d5b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">XGBoost是Extreme Gradient Boost的缩写(我写过一篇文章提供了渐变提升的要点<a class="ae jg" rel="noopener" target="_blank" href="/machine-learning-part-18-boosting-algorithms-gradient-boosting-in-python-ef5ae6965be4">这里</a>)。与渐变增强不同，XGBoost利用正则化参数来帮助防止过度拟合。</p><p id="bf59" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们想要构建一个模型来预测给定平方英尺的房子的价格。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi le"><img src="../Images/3f3ead88baf078227c8b0fce9ab086d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*CznsYocUz_-NzlTPFEGSgA.png"/></div></figure><p id="4055" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从一个任意的初始预测开始。在回归的情况下，这可以是平均值，在分类的情况下，这可以是0.5。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/b436cd879c778366698a965f63b82f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*fSgadaWhxNuBE9yX29qPpg.png"/></div></figure><p id="8db0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于每个样本，我们用下面的公式计算残差。</p><blockquote class="lk ll lm"><p id="7b37" class="kg kh ln ki b kj kk kl km kn ko kp kq lo ks kt ku lp kw kx ky lq la lb lc ld im bi translated"><em class="jj">残差=实际值—预测值</em></p></blockquote><p id="0b2f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设，应用公式后，我们最终得到以下残差，从左到右开始采样。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/7f96c58508d5ef1f350fbd7c6409411d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*mynM3RNnGAc2Ur-ReHyvXQ.png"/></div></figure><p id="bfba" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们使用线性扫描来决定沿给定特征(平方英尺)的最佳分割。线性扫描意味着我们在第一对点(它们的平均值)之间选择一个阈值，然后在下一对点(它们的平均值)之间选择一个阈值，以此类推，直到我们探索了所有的可能性。</p><p id="cb41" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的例子中，我们从选择阈值500开始。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/5870deb93e32e5f86acd0845b22a9370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*ltBjEWuxhWbjrdmp3vpNKw.png"/></div></figure><p id="8745" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对应的树是:</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/c86dbf393be21c1de391794b289b7820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*kZBStLI44hfjzgleOpdjNw.png"/></div></figure><p id="b306" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意每片叶子中的值是怎样的残差。也就是自变量的预测值和实际值之差，而不是给定样本的房价。</p><p id="85f6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了比较分割，我们引入了<em class="ln">增益</em>的概念。增益是由分割带来的精度提高。增益计算如下。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/9e7f960af9e89268ed92a0e96d4da46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*XnpRXiSy9ayq6w-daeS9RQ.png"/></div></figure><p id="78c0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在哪里</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/9ef132db448da475acea3bc61a920cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*RH1-h5eTJB0XoJPu3wlxMA.png"/></div></figure><p id="aca8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">λ和γ都是超参数。Lambda是一个正则化参数，可降低预测对单个观测值的敏感度，而Gamma是在树的叶节点上进行进一步划分所需的最小损失减少量。</p><p id="2331" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比方说，我们任意地将λ和γ设置为如下。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lv"><img src="../Images/4eb49b7951d48f9a26f9836ac7684c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*TE2pPIVsFiCMUiu-EAk_Yg.png"/></div></div></figure><p id="3922" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以继续计算初始分割的增益。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/9e7f960af9e89268ed92a0e96d4da46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*XnpRXiSy9ayq6w-daeS9RQ.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/4c80dea3000afb7a0d3d3ec9ded41ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*2YIQAquP_EtL_6i-N6BlFg.png"/></div></figure><p id="7356" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们继续计算对应于剩余排列的增益。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/2b0db6e8e790888a43443e65c95aafdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*lcIydfnM7S6mhACZE3PUCA.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/25e63e6f36339dc5b0cd8dae597b8466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*rxncLCvKjlJNnyL2EdnF9A.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/9e7f960af9e89268ed92a0e96d4da46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*XnpRXiSy9ayq6w-daeS9RQ.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/30f788ab537f67bf8facc4cbfcdc1266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*YY-_IglOMnMUFX_J8uRQRQ.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/eea0c3904dcc18bdc15bd8f897503693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*E2zKoHXgJvciKRxCfMPcRQ.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/29d2e917d99c8ffb9c6ed5fe49f80521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*fEYAQC21BbUF-d8iu51bEQ.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/9e7f960af9e89268ed92a0e96d4da46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*XnpRXiSy9ayq6w-daeS9RQ.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/194665dc4cd6edc545aed53a41c6c933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*SzFvHNbnV5Gdzv5JTVUxMw.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi md"><img src="../Images/7a449a316518743f7e0fde89c7830698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*IFGNacm-Nr1UbDF5-COSgQ.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi me"><img src="../Images/19eedc8ace102dbe85373d1337d80f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*wKLXLmhrGazFQVAmuc8zKg.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/9e7f960af9e89268ed92a0e96d4da46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*XnpRXiSy9ayq6w-daeS9RQ.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/eaa0763da3c99665d1813dc8b7732e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*r8vurgf8Si0hQRwMB_mNpg.png"/></div></figure><p id="d805" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们使用产生最大增益的阈值。在这种情况下，最佳阈值是<strong class="ki jk">平方英尺&lt; 1000 </strong>。因此，我们以下面的树结束。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/25e63e6f36339dc5b0cd8dae597b8466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*rxncLCvKjlJNnyL2EdnF9A.png"/></div></figure><p id="4d2f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们对每片叶子重复这个过程。也就是说，我们选择一个阈值来</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mg"><img src="../Images/7b375c4bd9c0e18564a3acda4ad339d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmbQEQjtv3WcSUXBJi9USw.png"/></div></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mh"><img src="../Images/d8d5424e24a1704fc551bf5f1cfb3560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*1JZaqBqnbdFUxfK6bncc-Q.png"/></div></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/9e7f960af9e89268ed92a0e96d4da46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*XnpRXiSy9ayq6w-daeS9RQ.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/0900fcdc1e3ac96a5e66f6efa97898b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*Bw5yMS70ONZYPYCBgk9BrA.png"/></div></figure><p id="b591" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当增益为负时，这意味着分割不会产生比我们让树保持原样的情况下更好的结果。</p><p id="40e4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们仍然需要检查在分割树叶时使用的不同阈值不会提高模型的准确性。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/c752e06ec700d9e6732f901ece569e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*dC5G3rz1-BCtdaVNlRahYw.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/d88e52e0ce2891579be4fd872eed187a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*0rTxl9z7tqGH1lpzhPKanA.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/9e7f960af9e89268ed92a0e96d4da46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*XnpRXiSy9ayq6w-daeS9RQ.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/86d9f73c82a37c5ab43f35b3c1ced5c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*8j6Hup_hp869PrQVkUXx0g.png"/></div></figure><p id="38ba" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">增益为正。因此，我们仍然受益于进一步拆分树。这样做，我们得到了下面的树。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/d88e52e0ce2891579be4fd872eed187a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*0rTxl9z7tqGH1lpzhPKanA.png"/></div></figure><p id="1c98" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们检验了将样本面积在1，000平方英尺和1，600平方英尺之间的进行拆分是否有益。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/a0a5304c307152ccf494e35a2578dd12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/0*CNpI0vCAGseL51Cd"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/9e7f960af9e89268ed92a0e96d4da46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*XnpRXiSy9ayq6w-daeS9RQ.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/6e32228d2f74901cf95da1ca736b74ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*VNeaukvsqRnvJl3pklBxWw.png"/></div></figure><p id="c1c7" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">增益为负。因此，我们让这棵树保持原样。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/d88e52e0ce2891579be4fd872eed187a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*0rTxl9z7tqGH1lpzhPKanA.png"/></div></figure><p id="8399" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们仍然需要检查是否应该分割左边的叶子(平方英尺&lt; 1000)。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/74ace542312b009689d0b38ddf32ed48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*-IIEF55klogdhmsJ5AG8Cg.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/9e7f960af9e89268ed92a0e96d4da46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*XnpRXiSy9ayq6w-daeS9RQ.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/c696c5622daa42b555f04963b32fd961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*SUn4Kq1SWXXvuEYePI7sQA.png"/></div></figure><p id="5dac" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，增益为负。因此，最终的决策树是:</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/d88e52e0ce2891579be4fd872eed187a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*0rTxl9z7tqGH1lpzhPKanA.png"/></div></figure><p id="5ff0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当提供样本时，决策树必须返回单个标量值。因此，我们使用下面的公式，该公式考虑了单个叶节点中的多个残差。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/3db5f4a1b1893148202d06c7379d7495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*jbDCA_yMZV09iqB3D4h2YA.png"/></div></figure><p id="297a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个预测是初始预测和树的预测之和乘以学习率。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/f01961b62532273c18bcabdd6da4bcf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*fBTA5v15LCY1zXFjeyVN6w.png"/></div></figure><p id="2c15" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设学习率为0.5，该模型做出以下预测。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/cf83ff11950e3a5e1d326dc9a880dc5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*T0c9h2p6KUKTvbR-YmzZ_A.png"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/2e0aee7d3daa2d161eb580cdd1277dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*W_IpXlXFGoacE67IaRZpDQ.png"/></div></div></figure><p id="26f1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">新的残差是:</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/59873922af2674bab06ffbeb58a33c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*UTpWtMxvb_wLWbPvYakeUA.png"/></div></figure><p id="155f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们使用这些残差构建另一个决策树，并重复这个过程，直到我们达到最大估计数(默认为100)。一旦我们完成了模型的训练，XGBoost模型作为一个整体所做的预测就是初始预测和每个决策树所做的预测之和乘以学习率。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/16e68bafae9277f7c176821209227124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*h3xLi7va8slBliCiSrHaBw.png"/></div></figure><h1 id="50ac" class="mu mv jj bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">Python代码</h1><p id="e633" class="pw-post-body-paragraph kg kh jj ki b kj ns kl km kn nt kp kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">与其他机器学习模型不同，XGBoost不包含在Scikit-Learn包中。因此，</p><p id="4f08" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">XGBoost库有很多依赖项，这使得安装它成为一场噩梦。你很幸运，我经历了那个过程，所以你不必经历。到目前为止，安装XGBoost最简单的方法是安装Anaconda(如果您还没有安装)并运行以下命令。</p><pre class="lf lg lh li gt nx ny nz oa aw ob bi"><span id="2116" class="oc mv jj ny b gy od oe l of og">conda install -c conda-forge xgboost</span><span id="cef3" class="oc mv jj ny b gy oh oe l of og">conda install -c anaconda py-xgboost</span></pre><p id="5ebf" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦安装了XGBoost，我们就可以继续导入所需的库。</p><pre class="lf lg lh li gt nx ny nz oa aw ob bi"><span id="27af" class="oc mv jj ny b gy od oe l of og">import pandas as pd<br/>import xgboost as xgb<br/>from sklearn.datasets import load_boston<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import mean_squared_error</span></pre><p id="32fc" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就像上面的例子一样，我们将使用XGBoost模型来预测房价。我们使用Scikit-Learn API将波士顿房价数据集加载到笔记本中。</p><pre class="lf lg lh li gt nx ny nz oa aw ob bi"><span id="c479" class="oc mv jj ny b gy od oe l of og">boston = load_boston()<br/>X = pd.DataFrame(boston.data, columns=boston.feature_names)<br/>y = pd.Series(boston.target)</span></pre><p id="a1dc" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用head函数来检查数据。</p><pre class="lf lg lh li gt nx ny nz oa aw ob bi"><span id="edfd" class="oc mv jj ny b gy od oe l of og">X.head()</span></pre><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/d5e5313e567b7b93b29b734d19807dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*6xaebRLsTWdFc7hNG_Z6bA.png"/></div></figure><p id="2e07" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是不同特性及其缩写的列表。</p><ul class=""><li id="537e" class="oj ok jj ki b kj kk kn ko kr ol kv om kz on ld oo op oq or bi translated">按城镇分列的人均犯罪率</li><li id="865a" class="oj ok jj ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">ZN面积超过25，000平方英尺的住宅用地比例</li><li id="4dc9" class="oj ok jj ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">每个城镇非零售商业英亩数的比例</li><li id="7f16" class="oj ok jj ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">CHAS Charles River虚拟变量(= 1，如果区域边界为河流；否则为0)</li><li id="7b10" class="oj ok jj ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">氮氧化物浓度(百万分之一)</li><li id="73de" class="oj ok jj ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">RM每个住宅的平均房间数</li><li id="46fa" class="oj ok jj ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">1940年以前建造的自有住房的年龄比例</li><li id="5514" class="oj ok jj ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">DIS加权到五个波士顿就业中心的距离</li><li id="9f64" class="oj ok jj ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">放射状公路可达性指数</li><li id="da83" class="oj ok jj ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">每10，000美元征收全价值财产税</li><li id="82eb" class="oj ok jj ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">按城镇分列的师生比例</li><li id="64e0" class="oj ok jj ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">B 1000(Bk — 0.63)，其中Bk是按城镇划分的黑人比例</li><li id="e954" class="oj ok jj ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">LSTAT %较低的人口地位</li><li id="df2b" class="oj ok jj ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">以千美元为单位的MEDV自有住房中值</li></ul><p id="b448" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了评估我们模型的性能，我们将数据分为训练集和测试集。</p><pre class="lf lg lh li gt nx ny nz oa aw ob bi"><span id="4311" class="oc mv jj ny b gy od oe l of og">X_train, X_test, y_train, y_test = train_test_split(X, y)</span></pre><p id="ab4b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们初始化XGBRegressor类的一个实例。我们可以选择λ和γ的值，以及估计器的数量和最大树深度。</p><pre class="lf lg lh li gt nx ny nz oa aw ob bi"><span id="1e06" class="oc mv jj ny b gy od oe l of og">regressor = xgb.XGBRegressor(<br/>    n_estimators=100,<br/>    reg_lambda=1,<br/>    gamma=0,<br/>    max_depth=3<br/>)</span></pre><p id="2f6e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使我们的模型适合训练集。</p><pre class="lf lg lh li gt nx ny nz oa aw ob bi"><span id="a799" class="oc mv jj ny b gy od oe l of og">regressor.fit(X_train, y_train)</span></pre><p id="efe2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在决定房价时，我们可以检查每个特征的相对重要性。</p><pre class="lf lg lh li gt nx ny nz oa aw ob bi"><span id="43e0" class="oc mv jj ny b gy od oe l of og">pd.DataFrame(regressor.feature_importances_.reshape(1, -1), columns=boston.feature_names)</span></pre><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/1a27a7863dfab579000ed518d413b4fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xf1HrpPvKT2hd1jFy7xuZg.png"/></div></div></figure><p id="f32c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，低阶层人口的比例是房价的最大预测因素。</p><p id="bc7f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们用我们的模型预测了波士顿的一所房子的价格。</p><pre class="lf lg lh li gt nx ny nz oa aw ob bi"><span id="1099" class="oc mv jj ny b gy od oe l of og">y_pred = regressor.predict(X_test)</span></pre><p id="ebbc" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用均方差来评估模型的性能。均方误差是预测值和实际值的平方之差的平均值。</p><pre class="lf lg lh li gt nx ny nz oa aw ob bi"><span id="9ce7" class="oc mv jj ny b gy od oe l of og">mean_squared_error(y_test, y_pred)</span></pre><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/6563b10720e698cadb7bd15c4fe415b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*4amfO2Ojfuofyg2BeMvqIQ.png"/></div></figure></div></div>    
</body>
</html>