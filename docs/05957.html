<html>
<head>
<title>Democratizing image classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">民主化图像分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/democratizing-image-classification-d578854a6c19?source=collection_archive---------50-----------------------#2020-05-15">https://towardsdatascience.com/democratizing-image-classification-d578854a6c19?source=collection_archive---------50-----------------------#2020-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="88ad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Kubernetes构建基于网络的迁移学习门户</h2></div><p id="2831" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">作者:</em> <a class="ae lf" href="https://www.linkedin.com/in/jeffchenhr/" rel="noopener ugc nofollow" target="_blank"> <em class="le">【陈明杰】</em></a><em class="le"/><a class="ae lf" href="https://www.linkedin.com/in/ajrharris/" rel="noopener ugc nofollow" target="_blank"><em class="le">安迪·哈里斯</em></a><em class="le"/><a class="ae lf" href="https://www.linkedin.com/in/martinaapillay/" rel="noopener ugc nofollow" target="_blank"><em class="le">玛蒂娜·皮莱</em> </a></p><p id="9a82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建定制的图像分类模型需要详细了解TensorFlow或其他类似的深度学习框架。它还需要大量的CPU。虽然存在更高级的工具，如苹果的桌面应用程序，<a class="ae lf" href="https://developer.apple.com/machine-learning/create-ml/" rel="noopener ugc nofollow" target="_blank"> CreateML </a>，但它们要求你在本地机器上运行软件，这可能会很慢且效率低下。</p><p id="4026" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的项目旨在使机器学习民主化，并使任何软件工程师都可以建立图像分类模型，不管他们的ML知识如何。</p><h1 id="553e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">站在巨人的肩膀上</h1><p id="f13a" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">我们在几个现有资源的基础上开发了一个web服务，它可以无缝地接收图像并输出定制的图像分类模型。</p><ul class=""><li id="a106" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld mi mj mk ml bi translated">基本模型:使用的基本模型来自Google开发的MobileNet v2模型。这是在ImageNet数据集上预先训练的，这是一个由1.4 M图像和1000个类组成的大型数据集</li><li id="d961" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">迁移学习:我们利用MobileNet基础模型为用户训练定制的图像分类模型</li><li id="29be" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">Docker:我们将迁移学习模型容器化，这样它就可以部署在GCP的实例中</li><li id="a234" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">Kubernetes:利用Kubernetes，我们可以在创建每个分类模型时自动扩展和管理工作</li><li id="0dc8" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">GitHub:我们服务前端和后端的所有代码都在GitHub repo中维护</li></ul><h1 id="3637" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">产品组件和基础设施</h1><p id="4328" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">我们的产品包含三个不同的组件:用于管理用户上传的部署和服务，用于管理模型训练的作业定义，以及用于在训练期间存储数据的持久性存储。组件已连接，如下所示。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/62f85ae5729ecd116ee54ee5c3a8e56a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KITk4rkAzo8JyiXr"/></div></div></figure><p id="f71b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">在谷歌云上部署到Kubernetes</strong></p><p id="c294" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这个项目，我们需要动态的计算能力来应对需求高峰。Kubernetes自动管理可伸缩的容器化应用程序，是一个完美的选择。<a class="ae lf" href="https://cloud.google.com" rel="noopener ugc nofollow" target="_blank">谷歌云</a>让快速建立新的Kubernetes集群变得简单<a class="ae lf" href="https://console.cloud.google.com/kubernetes/add" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nd"><img src="../Images/735ee9808b8b7b0e1765126892b43bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zaHv4llXSiKLK0OO"/></div></div></figure><p id="8c0f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们需要设置持久存储，以便上传图像，然后供培训作业使用。Kubernetes Pods可以使用永久卷共享文件。永久卷有三种<a class="ae lf" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes" rel="noopener ugc nofollow" target="_blank">访问模式</a> : ReadWriteOnce、ReadOnlyMany和ReadWriteMany(这些名称表明了每种卷类型的使用方式)。对于这个项目，我们需要前端能够将文件写入存储；然后，相应的培训工作需要能够读取这些文件。因此，我们需要一个支持读写的卷。</p><p id="1aa1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们选择使用<a class="ae lf" href="https://cloud.google.com/filestore/" rel="noopener ugc nofollow" target="_blank"> Filestore </a>，这是一个托管的谷歌服务，其工作方式类似于NAS服务器。Filestore至少需要1Tb的磁盘空间，并且有些昂贵，因此对于长期项目来说，它可能不是一个理想的选择，除非您计划存储大量数据。但是对于一个短期项目(并且有学分)，它很容易建立并且对我们的用例有意义。为了建立一个文件存储实例，<a class="ae lf" href="https://console.cloud.google.com/filestore/locations/-/instances/new" rel="noopener ugc nofollow" target="_blank">创建了一个新实例</a>，并跟踪<strong class="kk iu">文件共享名</strong>和<strong class="kk iu"> IP地址</strong>。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nd"><img src="../Images/a1ffae3df4f6beec38fed86b6e3337b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BKr0Eeo5YlMQXE1O"/></div></div></figure><p id="ef9f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们使用该文件存储信息创建了一个持久卷。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f06c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们创建了一个持久的卷声明，可以由前端和各种作业共享。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c0b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">版本管理和自动部署</strong></p><p id="bbd6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个项目发生在新冠肺炎，所以我们不得不远程合作，因为庇护所的订单。因此，使用源代码控制和协作工具甚至更加重要。我们将代码存储在GitHub中，并使用<a class="ae lf" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>管理我们所有的部署。设置autodeploy需要首先在Google Cloud 中创建一个<a class="ae lf" href="https://console.cloud.google.com/iam-admin/serviceaccounts/create" rel="noopener ugc nofollow" target="_blank">服务帐户。</a></p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nd"><img src="../Images/176f6a29a7ee4f0192afc5793c41b826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QIU1amuXWAdUT0Xr"/></div></div></figure><p id="21dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">服务帐户角色需要设置为<strong class="kk iu">编辑器</strong>，这样GitHub才能向Google Cloud发送命令。在最后阶段，我们为服务帐户生成并下载了一个密钥。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nd"><img src="../Images/e34950e151a5d230d6fc880daeb9bb53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GuyXTtGgZX1nwSgX"/></div></div></figure><p id="50cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将<a class="ae lf" href="https://github.com/actions/starter-workflows/blob/master/ci/google.yml" rel="noopener ugc nofollow" target="_blank">构建并部署到GKE </a>工作流添加到GitHub项目中。默认模板使用Github secrets作为GKE_EMAIL、GKE_KEY和GKE_PROJECT环境变量。GKE电子邮件和GKE项目分别对应于服务帐户电子邮件地址和项目ID。GitHub在这里<a class="ae lf" href="https://github.com/GoogleCloudPlatform/github-actions/tree/docs/service-account-key/setup-gcloud#inputs" rel="noopener ugc nofollow" target="_blank">提供指令</a>生成GKE _密钥(使用你上面下载的服务账号密钥JSON文件)。</p><p id="aa33" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们对动作文件做了一些修改。首先，为了避免为每个部署削减一个新的发布，我们在每次有新的提交到主分支时触发工作流。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d099" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其次，我们构建了两个Docker容器，而不是一个——一个用于主服务，一个用于作业(下面将详细介绍)。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="b2e5" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">建立核心服务和工作岗位</h1><p id="e1de" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated"><strong class="kk iu">设置前端</strong></p><p id="8f2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用Flask和Bootstrap设置前端。前端服务被打包成一个容器，并部署在Kubernetes集群中。</p><p id="92fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了帮助用户完成这个过程，我们设计了一个如下所示的3步表单(尽管你可以随意定制！).第一步，我们收集一个. zip文件，其中包含用户希望模型学习的不同新类的图片。的内容。zip文件必须匹配<a class="ae lf" href="https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/image/ImageDataGenerator#flow_from_directory" rel="noopener ugc nofollow" target="_blank">keras . preprocessing . images . imagedata generator . flow _ from _ directory</a>使用的结构。然后，我们要求用户输入他们希望接收训练模型的电子邮件。最后，我们向用户提供一个摘要和通知，以检查所有细节是否正确。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ng"><img src="../Images/b86c293d94af71cc3ff659044e4def3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3idz1mJ0axX22I5ujrW9Q.png"/></div></div></figure><p id="b312" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">与作业共享图像数据</strong></p><p id="6ec6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上传. zip文件后，我们使用<a class="ae lf" href="https://github.com/kubernetes-client/python" rel="noopener ugc nofollow" target="_blank"> Kubernetes Python包</a>创建一个作业。我们使用<a class="ae lf" href="https://docs.python.org/3/library/uuid.html#uuid.uuid4" rel="noopener ugc nofollow" target="_blank"> UUID生成器</a>包给每个作业一个唯一的UUID。作为环境变量的zip文件路径。请注意，创建作业时会附加永久卷声明。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9010" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">前端需要特殊权限才能创建作业。对于这个项目，我们给默认角色Admin访问权限。在生产环境中，前端的访问应该仅限于必要的权限。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="587a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">(重新)教授模型</strong></p><p id="f53f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了创建定制的图像分类模型，我们在预训练的神经网络上使用了迁移学习技术。文章<a class="ae lf" rel="noopener" target="_blank" href="/transfer-learning-using-mobilenet-and-keras-c75daf7ff299">Transfer Learning using Mobilenet and Keras</a>非常有用，并被用作这项工作的框架。</p><p id="daf3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在图像分类的背景下，迁移学习的理论是，已经在大量图像上训练过的预训练模型可以有效地充当大多数图像的通用模型。我们可以利用神经网络的大多数层，只在新图像上重新训练最后几层。这使我们能够减少开发定制图像分类模型所需的时间和计算资源。它还减少了我们添加新类所需的新图像的数量。</p><p id="a883" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个项目中，我们使用Google开发的MobileNet v2的基本模型。该网络在ImageNet数据集(由140万幅图像和1000个类组成)上进行预训练。我们冻结了第一批预训练层的大部分，只重新训练最后几个密集层。然后，我们打开分类图像的zip文件，重新训练模型。模型被保存为一个. h5文件，并保存到一个dropbox文件中，然后通过电子邮件发送回给用户。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3e2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">集装化的转移学习</strong></p><p id="3ed9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将我们的机器学习模型产品化的第一步是将其放入Docker容器中，以便我们可以将其部署为微服务。利用Docker，我们可以维护统一的环境、库需求，并使用Kubernetes在云中扩展模型。</p><p id="704e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Dockerfile本质上是一个命令文档，存储在启动容器映像的文本文件中。在我们的token文件中，我们安装了python和requirements.txt中定义的所有包。我们还实例化了几个可以传递到main.py文件中的环境变量:图像的zip文件位置、用户电子邮件以及dropbox密钥和令牌。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a670" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建docker文件后，我们构建映像并进行测试，以确保输入和输出在本地工作。最后，我们将图像推送到Google云平台，在那里它可以被我们的Kubernetes集群部署。</p><p id="a62f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">共享模型并通知用户</strong></p><p id="2e86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于Google Drive存储昂贵，我们决定使用Dropbox API来临时存储重新训练的模型。训练完成后，模型被上传到Dropbox，并生成一个可共享的链接。</p><p id="8c7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该链接随后被传递给SendGrid API，以生成一封通知电子邮件供用户检索。下面可以看到这封漂亮邮件的样本！</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nh"><img src="../Images/1ac5dcc4bbe1c222e82ad70c2d406230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vvwHVTd7dFVfNhaYyUr1cw.png"/></div></div></figure><h1 id="835d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">后续步骤</h1><p id="3263" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">我们所创造的服务只是这个产品未来发展的一个起点。为了更好地满足那些希望利用分类模型的人的需求，可以结合以下特征:</p><p id="719a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">进一步产品化</strong></p><ul class=""><li id="2e1e" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld mi mj mk ml bi translated">改进web应用程序，为用户提供更多指导</li><li id="0cd9" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">关于培训状态、后端如何工作等更多信息。</li><li id="89b7" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">提供更多基本型号的选择(目前只有MobileNet)</li><li id="6d2b" class="md me it kk b kl mm ko mn kr mo kv mp kz mq ld mi mj mk ml bi translated">让用户选择超参数</li></ul><p id="81d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">合并模型蒸馏和压缩</strong></p><ul class=""><li id="234e" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld mi mj mk ml bi translated">模型文件相当大；输出可用于移动电话的版本可能有用</li></ul><p id="82c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">提高用户测试能力</strong></p><ul class=""><li id="ac19" class="md me it kk b kl km ko kp kr mf kv mg kz mh ld mi mj mk ml bi translated">提供一个界面，允许用户测试模型的准确性</li></ul><h1 id="42bb" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">承认</h1><p id="6cb1" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">我们要感谢Pavlos Protopapas和<a class="ae lf" href="https://harvard-iacs.github.io/2020-AC295/" rel="noopener ugc nofollow" target="_blank">哈佛应用计算295课程</a>的其他教学人员的指导和支持。</p></div></div>    
</body>
</html>