<html>
<head>
<title>Bokeh, Bokehjs, and Observablehq</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">散景、散景和可观察总部</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bokeh-bokehjs-and-observablehq-6ddf0c5ffe8a?source=collection_archive---------66-----------------------#2020-05-18">https://towardsdatascience.com/bokeh-bokehjs-and-observablehq-6ddf0c5ffe8a?source=collection_archive---------66-----------------------#2020-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7cf7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">脱离朱庇特轨道的冒险</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c208f84f78e5b07c762743973c056fb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNN3rtMpIznQ3GNKYD_0ZA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">2019年11月朱诺号拍摄的木星北纬(图片来源:<a class="ae kv" href="https://photojournal.jpl.nasa.gov/catalog/PIA23442" rel="noopener ugc nofollow" target="_blank">美国宇航局/JPL加州理工</a></p></figure><p id="748e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在jupyter笔记本中使用python时，<a class="ae kv" href="https://bokeh.org" rel="noopener ugc nofollow" target="_blank">散景</a>可视化库已经成为我最喜欢的显示数据的工具之一。散景功能强大，易于使用，具有可访问的交互功能，并生成美丽的图形。然而，随着我在过去几个月中使用Bokeh，并对其内部有了更多的了解，我开始意识到jupyter中用于Bokeh的python API只是整个Bokeh包的一小部分。除了这个API，Bokeh还包括一个服务器包和一个名为bokehjs的javascript库。事实上，Bokeh的python“绘图”包根本不做任何绘图；相反，它是一种描述绘图的语言，这些绘图被序列化到json包中，并传递给bokehjs以在浏览器中呈现。随着我尝试在我的情节中添加更多的交互性，我逐渐清楚地知道，了解一些JavaScript——我并不知道——并对散景有更清晰的理解会让我用散景做更多的事情。</p><p id="faab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与此同时，出于完全不同的原因，我遇到了<a class="ae kv" href="https://observablehq.com" rel="noopener ugc nofollow" target="_blank"> Observablehq </a>。Observablehq是由javascript <a class="ae kv" href="https://d3js.org" rel="noopener ugc nofollow" target="_blank"> D3 </a>可视化包的开发者<a class="ae kv" href="https://bost.ocks.org/mike/" rel="noopener ugc nofollow" target="_blank"> Mike Bostock </a>领导的团队创建的。乍一看，它非常像一个基于javascript的云托管jupyter笔记本。考虑到我探索bokehjs和学习一些javascript的目标，我天真地认为Observablehq是最适合我的工具。嗯，这并不那么简单，因为Observablehq不仅仅是jupyter笔记本的javascript版本，它是一个非常不同的东西，并且以自己的方式非常漂亮；bokehjs并不完全适合Observablehq世界。尽管如此，在尝试将这些世界融合在一起的过程中，我学到了很多关于bokehjs和Observablehq的知识，并且我看到了很多进一步发展的潜力。这里有一份简短的进度报告和一些提示，如果你也想开始这段旅程的话。</p><h1 id="cd81" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Observablehq不是Javascript的Jupyter</h1><p id="fd08" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如我上面提到的，当我查看Observablehq用户界面时，我的第一反应是<em class="mp">这只是javascript的Jupyter</em>！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/c3a2ea52e55f7b2fa5ae31d336f095fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bstZUvw352N289WoHn1-DA.gif"/></div></div></figure><p id="4f30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上面的小动画所示，Observable有笔记本，有单元格，你在单元格里输入javascript(或者markdown)；按shift-enter键，单元格就会被求值。听起来像朱庇特，对吧？但是可观察的笔记本是完全不同的——每个单元格都有一个值，并且这些单元格根据引用组合成一个图表。当一个单元格的值发生变化时，所有依赖于该单元格的单元格都会被重新计算。这有点像小javascript程序的电子表格。这种设计意味着可观察笔记本以一种自然的方式支持高度的交互性，远远超过jupyter笔记本的能力。如果你感兴趣，你最好的选择是阅读Observablehq网站上的优秀文章。除了<a class="ae kv" href="https://observablehq.com/@observablehq/user-manual" rel="noopener ugc nofollow" target="_blank">的介绍性文章</a>，尤其值得一提的是:</p><ul class=""><li id="d98f" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">【jupyter用户可观察到的</li><li id="6fd4" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated"><a class="ae kv" href="https://observablehq.com/@observablehq/how-observable-runs" rel="noopener ugc nofollow" target="_blank">如何观察运行</a></li></ul><h1 id="545e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在Observable中加载Bokehjs</h1><p id="74a2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在可观察的笔记本中试验散景的第一步是加载库。对于这一步，我得到了布莱恩·陈的<a class="ae kv" href="https://observablehq.com/@bryangingechen/hello-bokeh-js" rel="noopener ugc nofollow" target="_blank">你好，Bokehjs </a>笔记本的帮助。将下面的代码放入一个可观察到的笔记本单元格中，然后按Shift-Enter键，就可以实现这个目的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">正在将Bokehjs库加载到Observablehq中</p></figure><p id="d958" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不必在细节上花费太多时间，值得指出的是，加载Bokeh的代码被括在大括号中，以便作为一个单元执行。正如我前面提到的，可观察笔记本中的每个单元格就像一个自包含的javascript程序，单元格的执行和重新执行取决于它们引用之间的依赖图。这段代码中至关重要的<code class="fe nh ni nj nk b">require</code>语句通过副作用起作用，而不是通过返回值。这意味着Observable不理解这些语句之间的依赖关系；如果放在不同的牢房里，它们可以按任何顺序执行。更一般地说，Observable不是为了处理通过副作用起作用的函数而建立的，人们需要小心使用它们。</p><p id="fb67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个特殊的单元格是一个<code class="fe nh ni nj nk b">viewof</code>构造，它的作用是将引用赋予变量<code class="fe nh ni nj nk b">Bokeh</code>到附加bokehjs javascript库的<code class="fe nh ni nj nk b">window.Bokeh</code>，同时显示变量<code class="fe nh ni nj nk b">message</code>的内容，这是一个表示正在发生什么的<code class="fe nh ni nj nk b">html</code>字符串。</p><p id="813d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以节省一些输入，而不是包含上面的代码，利用Observable跨笔记本导入单元格的能力，只需使用:</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="0306" class="np lt iq nk b gy nq nr l ns nt">import {Bokeh} from "@jeremy9959/bokeh-experiments"</span></pre><h1 id="6b89" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用散景打印</h1><p id="a334" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们已经加载了库，让我们画一个图。我将遵循bokehjs发行版中的<a class="ae kv" href="https://github.com/bokeh/bokeh/tree/master/bokehjs/examples/hierarchical" rel="noopener ugc nofollow" target="_blank">分层条形图的示例。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/a6bce3c42c37d2f5de4b43355ab2d01f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RaqetVs26KiOQ9nqOj9eCA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Bokehjs水果地块示例</p></figure><p id="8432" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以<a class="ae kv" href="https://observablehq.com/@jeremy9959/bokehjs-in-observable" rel="noopener ugc nofollow" target="_blank">直接看我画这个图</a>的可观察笔记本。笔记本的第一部分只是通过创建对应于<code class="fe nh ni nj nk b">fruits</code>和<code class="fe nh ni nj nk b">years</code>数据的单元格来设置数据，以及对应的逐年计数。例如，逐年计数存储在直接声明的变量<code class="fe nh ni nj nk b">data</code>中:</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="613d" class="np lt iq nk b gy nq nr l ns nt">// help the parser out by putting {} in ()<br/>data = ({<br/>  2015: [2,1,4,3,2,4] ,<br/>  2016:[5,3,3,2,4,6],<br/>  2017: [ 3,2,4,4,5,3],<br/>})</span></pre><p id="e1cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，javascript显式对象创建中使用的括号需要括号来帮助可观察解析器。</p><p id="8a1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建这个图的Bokeh代码直接取自bokehjs发行版中的文件(尽管我把这个图做得更宽了一点):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4367" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们使用Bokehjs的嵌入函数将绘图渲染到observable notebook中的一个单元格中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c63e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果就是我上面画的图。</p><h1 id="59d1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">那又怎样？</h1><p id="a48a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">到目前为止，这还不太令人满意，因为我们完全可以使用python API在jupyter笔记本上绘制相同的图形。为了说明为什么这种方法是有趣的，让我指出我们通过在observable中工作得到的两个主要好处。</p><ol class=""><li id="705b" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr nv mx my mz bi translated"><strong class="ky ir">我们可以检查javascript对象。</strong>我最初对Observable感兴趣的原因之一是，我正试图学习javascript，并试图理解bokehjs的内部工作原理。当然可以使用浏览器的javascript控制台来探究bokehjs的内部，但是observable给出了一个优雅的界面。例如，在制作情节时，我们构建了一个名为<code class="fe nh ni nj nk b">P</code>的<code class="fe nh ni nj nk b">Figure</code>对象。下图显示了可观察到的关于这个图形的信息，使用小三角形你可以打开这个物体并探索它的内部结构。(注意:如果你想这样做的话，加载非缩小的bokehjs包是很重要的，否则在这个输出中类ID将是不可理解的。)</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/444e87fb9fa1255a75b041e16e13c33d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BrEY6HLbVDAsQCysIQ5JrA.png"/></div></div></figure><p id="bdfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<strong class="ky ir">可观察是互动的！</strong>在Observable中做这件事的真正不同和有趣之处在于它是交互式的。如果我去定义变量<code class="fe nh ni nj nk b">data</code>的单元格，并更改数字，只要我一进入单元格，图形就会更新:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/56780855a5665b8785d2cd518a2e3b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*V9T8uk_uQpOZ_qEGwWluGQ.gif"/></div></div></figure><p id="6384" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为Observable的执行图知道水果图依赖于数据变量，当该变量改变时，该图得到重新计算。</p><p id="9287" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一句，Observable的另一个特性是，由于执行顺序与文档中单元格的物理顺序无关，所以我可以将图表移到紧靠<code class="fe nh ni nj nk b">data</code>单元格的位置，这样我就可以清楚地看到发生了什么。</p><p id="2c97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是在Observable中可能实现的交互性水平的一小部分——例如，在笔记本上添加小部件甚至制作动画是非常容易的。这篇文章不是深入探讨这个问题的地方，但是在可观察的主页上有许多漂亮的例子。</p><h1 id="efbd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">返回木星轨道时的讲话</h1><p id="94c1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最后，我认为重要的是要指出，有比使用散景更自然的方式来绘制可观察图像。特别是，使用<a class="ae kv" href="https://vega.github.io/vega/" rel="noopener ugc nofollow" target="_blank">织女星</a>有一个紧密集成的API，非常强大的<a class="ae kv" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> D3 </a>包实际上是内置在Observable中的。但是对于像我这样熟悉bokeh的python接口并希望了解更多关于bokehjs的知识的人来说——特别是考虑到虽然python API被广泛而细致地记录，但bokehjs API基本上是一个黑盒——Observable提供了一个有趣的机会。有更多的事情可以尝试，我期待着超越Jupyter轨道的进一步冒险。</p></div></div>    
</body>
</html>