<html>
<head>
<title>Fibonacci series in BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery 中的斐波那契数列</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fibonacci-series-with-user-defined-functions-in-bigquery-f72e3e360ce6?source=collection_archive---------75-----------------------#2020-06-01">https://towardsdatascience.com/fibonacci-series-with-user-defined-functions-in-bigquery-f72e3e360ce6?source=collection_archive---------75-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fa20" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在 BigQuery 中使用用户定义的 JavaScript 函数来计算 Fibonacci</h2></div><p id="ead1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">BigQuery 有一些很好的功能来支持用 SQL 和 JavaScript 编写的用户定义函数，所以我想我会很乐意用 Fibonacci 数来解决这个问题。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/24839f9b2c70567ce81660b1dd29e0aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5mwJnnzsB8v7T-Kly9ggg.jpeg"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">自然界中的斐波那契数列——图片来源:<a class="ae lu" href="https://www.pxfuel.com/en/free-photo-qqlvf" rel="noopener ugc nofollow" target="_blank"> pxfuel </a></p></figure><p id="9a51" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我很确定我在<a class="ae lu" href="https://projecteuler.net" rel="noopener ugc nofollow" target="_blank"> Project Euler </a>或者类似的地方看到过这个挑战，所以请不要用这个来作弊。挑战在于:</p><p id="9f74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">找出前 1000 个斐波那契数列的最后 6 个 6 位数的总和。现在，这听起来可能有点复杂，所以我们将从计算完整的斐波纳契数开始，然后从那里开始。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4f87" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是斐波那契数列？</h1><p id="267f" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">该序列被定义为:</p><ul class=""><li id="bae6" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated">a(0) = 0</li><li id="a0f5" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">a(1) = 1</li><li id="db65" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">a(n) = a(n-2) + a(n-1)</li></ul><p id="ce78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以每个元素都是前面 2 个的和。这就是它的作用:</p><p id="c33f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 0，1，1，2，3，5，8，13，21… </strong></p><p id="4cb9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以想象这些数字会很快变大。例如，第 50 个数字是<em class="nn"> 12，586，269，025 </em>，即超过 120 亿，带 b！(第 100 个号码是:354224848179261915075😬)</p><h1 id="0fff" class="mc md it bd me mf no mh mi mj np ml mm jz nq ka mo kc nr kd mq kf ns kg ms mt bi translated">在 BigQuery 中我们到底是如何做到这一点的？</h1><p id="8eae" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">现在我们知道了什么是斐波那契数列，显而易见的问题是我们如何在 BigQuery 中进行循环。嗯，有很多方法可以通过 BigQuery 脚本来实现，但是这里我将使用 JavaScript 用户定义的函数来代替。</p><p id="d0fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是计算第 n 个斐波那契数列的 JavaScript 函数:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="57e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我对 JavaScript 一无所知，所以如果我在这里做了什么傻事，请在评论中指出我！</p><p id="e9b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想玩玩它，这里是它的行动。</p><h1 id="4514" class="mc md it bd me mf no mh mi mj np ml mm jz nq ka mo kc nr kd mq kf ns kg ms mt bi translated">使用该功能的时间</h1><p id="1204" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">为了在 BigQuery 中创建这个函数，我们需要使用<code class="fe nv nw nx ny b">CREATE TEMP FUNCTION</code>声明:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2f63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用与上面相同的 JavaScript 函数体。我们需要做的就是从 JavaScript 位中删除<code class="fe nv nw nx ny b">function fib(n)</code>位，并将输入和输出类型添加到 SQL 位。请注意我们如何使用<code class="fe nv nw nx ny b">fibonacci(n INT64)</code>来声明输入必须是整数，使用<code class="fe nv nw nx ny b">RETURNS INT64</code>来指定输出类型。</p><p id="aad5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在大查询中得到一些数字:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e1cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你不知道数组生成器和<code class="fe nv nw nx ny b">with</code>语句中的 unnesting 发生了什么，那么看看我关于<a class="ae lu" href="https://medium.com/@niczky12/fizzbuzz-in-bigquery-e0c4fbc1d195" rel="noopener"> FizzBuzz 和 BigQuery </a>的文章🍾—都在那解释了。</p><p id="cc5a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果如下:</p><pre class="lf lg lh li gt nz ny oa ob aw oc bi"><span id="230a" class="od md it ny b gy oe of l og oh">╔═════╦═════╦═════════════╗<br/>║ Row ║ num ║    fib_n    ║<br/>╠═════╬═════╬═════════════╣<br/>║   1 ║   0 ║           0 ║<br/>║   2 ║   1 ║           1 ║<br/>║   3 ║   2 ║           1 ║<br/>║   4 ║   3 ║           2 ║<br/>║   5 ║   4 ║           3 ║<br/>║   6 ║   5 ║           5 ║<br/>║   7 ║   6 ║           8 ║<br/>║   8 ║   7 ║          13 ║<br/>║   9 ║   8 ║          21 ║<br/>║  10 ║   9 ║          34 ║<br/>║  11 ║  10 ║          55 ║<br/>║  12 ║  20 ║        6765 ║<br/>║  13 ║  30 ║      832040 ║<br/>║  14 ║  40 ║   102334155 ║<br/>║  15 ║  50 ║ 12586269025 ║<br/>╚═════╩═════╩═════════════╝</span></pre><p id="df3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这花了 0.5s 运行。不算太差，而且看起来工作得很好，因为我们得到了与上面相同的第 50 个元素。</p><h1 id="e28e" class="mc md it bd me mf no mh mi mj np ml mm jz nq ka mo kc nr kd mq kf ns kg ms mt bi translated">现在是真正的挑战</h1><p id="7e5f" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">如果你回到顶部，你可以看到最初的挑战是计算前 1000 个斐波那契数的最后 6 位数的总和。现在这样做很容易。这里的技巧是要认识到，为了精确计算最后 6 位数字，你只需要最后 6 位数字，所以我们可以通过使用模运算符来丢弃其余的数字。我们需要这个技巧，否则我们的<code class="fe nv nw nx ny b">INT64</code>会变得太大而溢出。</p><p id="3a27" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只需要在我们的 JavaScript 函数中添加:<code class="fe nv nw nx ny b">var new_num = (numbers[0] + numbers[1]) % 1000000;</code>，然后对所有结果求和。以下是用于此目的的 SQL:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a309" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这用了 0.9 秒，所以 BigQuery 现在真的是汗流浃背…结果是:</p><pre class="lf lg lh li gt nz ny oa ob aw oc bi"><span id="cdf5" class="od md it ny b gy oe of l og oh">╔═════╦═══════════╗<br/>║ Row ║  result   ║<br/>╠═════╬═══════════╣<br/>║   1 ║ 477632375 ║<br/>╚═════╩═══════════╝</span></pre><p id="3ee9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我建议您更改上面的 SQL，并查看第 100 个斐波那契数列的最后 6 位数字，看看是否正确！</p><h1 id="df99" class="mc md it bd me mf no mh mi mj np ml mm jz nq ka mo kc nr kd mq kf ns kg ms mt bi translated">包扎</h1><p id="6cd9" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">总的来说，JavaScript 函数很容易添加到 BigQuery 中，您可以一起破解一些有趣的计算。更好的是，如果您在 Google 云存储桶中包含了<code class="fe nv nw nx ny b">.js</code>文件，您甚至可以使用<a class="ae lu" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions#including-javascript-libraries" rel="noopener ugc nofollow" target="_blank"> JavaScript 库</a>。多棒啊。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><div class="lf lg lh li gt oi"><a rel="noopener follow" target="_blank" href="/load-files-faster-into-bigquery-94355c4c086a"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">将文件更快地加载到 BigQuery 中</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">针对摄取的 CSV、GZIP、AVRO 和拼花文件类型进行基准测试</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow lo oi"/></div></div></a></div><div class="ox oy gp gr oz oi"><a rel="noopener follow" target="_blank" href="/loops-in-bigquery-db137e128d2d"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">BigQuery 中的循环</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">了解如何使用 BigQuery 脚本来计算斐波那契数</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="pa l ot ou ov or ow lo oi"/></div></div></a></div></div></div>    
</body>
</html>