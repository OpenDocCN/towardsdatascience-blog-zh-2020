<html>
<head>
<title>QR Matrix Factorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">QR矩阵分解</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/qr-matrix-factorization-15bae43a6b2?source=collection_archive---------5-----------------------#2020-02-27">https://towardsdatascience.com/qr-matrix-factorization-15bae43a6b2?source=collection_archive---------5-----------------------#2020-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4d65" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最小二乘法和计算(用R和C++)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9ac8b2278c63de3669944c9d20911925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pnfy8X-3SzIal9RbGcFNSw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">本·丹尼斯·谢弗</p></figure><h1 id="88f0" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">数据科学和矩阵分解</h1><p id="bfe7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">有几种矩阵分解，也称为分解，每个数据科学家都应该非常熟悉。这些很重要，因为它们有助于为我们使用的模型和算法找到实际计算和估计结果的方法。在某些情况下，因式分解的一种特殊形式是算法(例如PCA和SVD)。在所有情况下，矩阵分解都有助于发展直觉和分析能力。</p><p id="eb66" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu"> <em class="mr"> QR </em> </strong>因式分解就是这些矩阵因式分解中非常有用的一种，在数据科学、统计学和数据分析中有非常重要的应用。这些应用之一是计算最小二乘(LS)问题的解。</p><h1 id="25b9" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">议程</h1><ul class=""><li id="9d47" class="ms mt it ls b lt lu lw lx lz mu md mv mh mw ml mx my mz na bi translated">重述最小二乘问题</li><li id="dd36" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated">介绍QR矩阵分解</li><li id="74b3" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated">使用QR求解LS</li><li id="a0f9" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated">用R和C++实现QR计算并比较。</li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="32e5" class="ky kz it bd la lb nn ld le lf no lh li jz np ka lk kc nq kd lm kf nr kg lo lp bi translated">LS问题</h1><p id="9122" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu"> <em class="mr"> QR </em> </strong>矩阵分解允许我们<em class="mr">计算</em>最小二乘问题的解。我强调<em class="mr">计算</em>是因为<a class="ae ns" href="https://en.wikipedia.org/wiki/Ordinary_least_squares" rel="noopener ugc nofollow" target="_blank"> OLS </a>给出了正规方程形式的封闭解。这很好，但是当你想找到实际的数值解时，它们并不真的有用。</p><p id="409c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">以下是最小二乘问题的概述。我们想解下面的方程</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/8ff2fcabf8f8136886817e1f78db45b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*w6AFnPvn7hpCM9Xo-Jc_Fg.png"/></div></figure><p id="1639" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">问题是我们无法求解<strong class="ls iu"> <em class="mr"> β </em> </strong>因为通常情况下如果我们的观测值多于变量<strong class="ls iu"><em class="mr"/></strong>X没有一个逆，下面就不能做了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/9f0ab17be2444e1c4c0acf9b01acae33.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*paIa-WIFWBTV9xUOMKOSqg.png"/></div></figure><p id="067d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">相反，我们试图找到一些<strong class="ls iu"> <em class="mr"> β̂ </em> </strong>来解这个方程，虽然不完美，但误差尽可能小。一种方法是最小化下面的目标函数，它是<strong class="ls iu"> <em class="mr"> β̂ </em> </strong>的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/6c4bea40a3b84f4123dd9d4802707f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*QaV0mibQVWdEXj6yIoSgBw.png"/></div></figure><p id="3788" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">最小化这个<em class="mr">平方</em>偏差的和就是为什么这个问题被称为<em class="mr">最小平方</em>问题。对<strong class="ls iu"> <em class="mr"> β̂ </em> </strong>求导并设为零将会引导你到正规方程并为你提供一个封闭形式的解。</p><p id="b7ab" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这是做这件事的一种方法。但是我们也可以只用线性代数。这就是<strong class="ls iu"> <em class="mr"> QR </em> </strong>矩阵分解的用武之地。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="f00f" class="ky kz it bd la lb nn ld le lf no lh li jz np ka lk kc nq kd lm kf nr kg lo lp bi translated">QR分解</h1><p id="149e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">首先，让我们继续描述这个分解是什么。<strong class="ls iu"> <em class="mr"> QR </em> </strong>矩阵分解允许将矩阵表示为两个独立矩阵<strong class="ls iu"> <em class="mr"> Q </em> </strong>和<strong class="ls iu"> <em class="mr"> R </em> </strong>的乘积。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/6cc480d45d2c94167c8894a3829953f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*X818h5TF_oCPPYhyByDvNA.png"/></div></figure><p id="af38" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu"> <em class="mr"> Q </em> </strong>中的一个<a class="ae ns" href="https://en.wikipedia.org/wiki/Orthogonal_matrix" rel="noopener ugc nofollow" target="_blank">正交矩阵</a>和<strong class="ls iu"> <em class="mr"> R </em> </strong>是一个正方形<a class="ae ns" href="https://en.wikipedia.org/wiki/Triangular_matrix" rel="noopener ugc nofollow" target="_blank">的上/右三角矩阵</a>。</p><p id="c6f7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这意味着</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/40f6d88a113dde13fc6ffa59d43d2480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jiaV0v-u07EPw7SaVmQGrg.png"/></div></div></figure><p id="c4b0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">而且由于<strong class="ls iu"> <em class="mr"> R </em> </strong>是正方形，只要对角线上的条目没有零，也是可逆的。如果<strong class="ls iu"> <em class="mr"> X </em> </strong> <em class="mr"> </em>的列是<a class="ae ns" href="https://en.wikipedia.org/wiki/Linear_independence" rel="noopener ugc nofollow" target="_blank">线性独立的</a>，那么情况将总是如此。尽管如果数据中存在共线性，问题仍然会出现。撇开这个不谈，这个<strong class="ls iu"> <em class="mr"> QR </em> </strong>因式分解意味着一个矩形且不可逆的<strong class="ls iu"> <em class="mr"> X </em> </strong>可以表示为两个可逆矩阵！这一定会有用的。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="45f6" class="ky kz it bd la lb nn ld le lf no lh li jz np ka lk kc nq kd lm kf nr kg lo lp bi translated">利用QR分解求解LS问题。</h1><p id="9bd4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">既然我们已经知道了<strong class="ls iu"> <em class="mr"> QR </em> </strong>因式分解，一旦我们能够实际找到它，我们将能够以下面的方式解决LS问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/80ec6156c6c32f4e512b8b6b716ffb08.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*vSVeMrcmOEeP3HNvMIvsEw.png"/></div></figure><p id="1d3f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">因此</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/bffe91be996594494cfa4b76b15b5fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*omZLR407JP6S-Jh-VVcVXQ.png"/></div></figure><p id="821f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这意味着我们需要做的就是找到<strong class="ls iu"> <em class="mr"> R </em> </strong>的逆，转置<strong class="ls iu"> <em class="mr"> Q </em> </strong>，取乘积。这将产生OLS系数。我们甚至不需要计算方差-协方差矩阵及其逆，这是OLS解通常是如何提出的。</p><h1 id="5836" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">执行QR分解。</h1><p id="1af6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">求一个矩阵的<strong class="ls iu"> <em class="mr"> QR </em> </strong>因子的方法是使用<a class="ae ns" href="https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process" rel="noopener ugc nofollow" target="_blank"> Gram-Schmidt过程</a>先求<em class="mr"> </em> <strong class="ls iu"> <em class="mr"> Q </em> </strong>。然后要求<strong class="ls iu"> <em class="mr"> R </em> </strong>我们只要把原矩阵乘以<strong class="ls iu"> <em class="mr"> Q </em> </strong>的转置即可。让我们继续使用在<code class="fe oa ob oc od b">R</code>和<code class="fe oa ob oc od b">C++</code>中实现的函数来执行<strong class="ls iu"> <em class="mr"> QR </em> </strong>。稍后我们可以查看这些函数的内部，以便更好地了解正在发生的事情。</p><h1 id="b9de" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">计算系数</h1><p id="32d3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我正在加载两个函数。<code class="fe oa ob oc od b">myQRR</code>和<code class="fe oa ob oc od b">myQRCpp</code>使用格拉姆-施密特过程进行<strong class="ls iu"> <em class="mr"> QR </em> </strong>因式分解。一个函数写在<code class="fe oa ob oc od b">R</code>中，另一个写在<code class="fe oa ob oc od b">C++</code>中，并通过<code class="fe oa ob oc od b">Rcpp</code>加载到<code class="fe oa ob oc od b">R</code>环境中。稍后我会比较他们的表现。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="8346" class="oi kz it od b gy oj ok l ol om">library(Rcpp)<br/>library(tidyverse)<br/>library(microbenchmark)</span><span id="07fb" class="oi kz it od b gy on ok l ol om">sourceCpp("../source-code/myQRC.cpp")<br/>source("../source-code/myQRR.R")</span></pre><p id="5639" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让我们从一个小例子开始，我们模拟<strong class="ls iu"> y </strong>和<strong class="ls iu"> X </strong>，然后使用<strong class="ls iu"> <em class="mr"> QR </em> </strong>分解来解决它。我们还可以仔细检查一下<strong class="ls iu"> <em class="mr"> QR </em> </strong>分解是否真的有效，并返回我们模拟的<strong class="ls iu"> <em class="mr"> X </em> </strong> <em class="mr"> </em>。</p><p id="ab9b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这是我们模拟的反应变量。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="4f66" class="oi kz it od b gy oj ok l ol om">y = rnorm(6)<br/>y</span><span id="beb4" class="oi kz it od b gy on ok l ol om">## [1] 0.6914727 2.4810138 0.4049580 0.3117301 0.6084374 1.4778950</span></pre><p id="0c62" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这是我们将用来求解LS系数的数据。我们有3个变量可以支配。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="dfae" class="oi kz it od b gy oj ok l ol om">X = matrix(c(3, 2, 3, 2, -1, 4,<br/>             5, 1, -5, 4, 2, 1,<br/>             9, -3, 2 , -1, 8, 1), ncol = 3)<br/>X</span><span id="a3d4" class="oi kz it od b gy on ok l ol om">##      [,1] [,2] [,3]<br/>## [1,]    3    5    9<br/>## [2,]    2    1   -3<br/>## [3,]    3   -5    2<br/>## [4,]    2    4   -1<br/>## [5,]   -1    2    8<br/>## [6,]    4    1    1</span></pre><p id="f665" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在我将使用<code class="fe oa ob oc od b">myQRCpp</code>找到<code class="fe oa ob oc od b">Q</code>和<code class="fe oa ob oc od b">R</code>。</p><ol class=""><li id="8e57" class="ms mt it ls b lt mm lw mn lz oo md op mh oq ml or my mz na bi translated">可以看到<strong class="ls iu"> <em class="mr"> R </em> </strong>确实是上三角。</li></ol><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="1430" class="oi kz it od b gy oj ok l ol om">Q = myQRCpp(X)$Q<br/>R = t(Q) %*% X %&gt;% round(14)</span><span id="022b" class="oi kz it od b gy on ok l ol om">R</span><span id="b65d" class="oi kz it od b gy on ok l ol om">##          [,1]     [,2]      [,3]<br/>## [1,] 6.557439 1.829983  3.202470<br/>## [2,] 0.000000 8.285600  4.723802<br/>## [3,] 0.000000 0.000000 11.288484</span><span id="7f17" class="oi kz it od b gy on ok l ol om">Q</span><span id="651c" class="oi kz it od b gy on ok l ol om">##            [,1]        [,2]        [,3]<br/>## [1,]  0.4574957  0.50241272  0.45724344<br/>## [2,]  0.3049971  0.05332872 -0.37459932<br/>## [3,]  0.4574957 -0.70450052  0.34218986<br/>## [4,]  0.3049971  0.41540270 -0.34894183<br/>## [5,] -0.1524986  0.27506395  0.63684585<br/>## [6,]  0.6099943 -0.01403387 -0.07859294</span></pre><p id="6f4b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">2.这里我们可以验证<strong class="ls iu"> <em class="mr"> Q </em> </strong>事实上是正交的。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="3e9d" class="oi kz it od b gy oj ok l ol om">t(Q)%*%Q %&gt;% round(14)</span><span id="1bf0" class="oi kz it od b gy on ok l ol om">##      [,1] [,2] [,3]<br/>## [1,]    1    0    0<br/>## [2,]    0    1    0<br/>## [3,]    0    0    1</span></pre><p id="2878" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">3.而那个<strong class="ls iu"> <em class="mr"> QR </em> </strong>确实把原来的<strong class="ls iu"> <em class="mr"> X </em> </strong>矩阵给还原了。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="91db" class="oi kz it od b gy oj ok l ol om">Q %*% R</span><span id="b9a6" class="oi kz it od b gy on ok l ol om">##      [,1] [,2] [,3]<br/>## [1,]    3    5    9<br/>## [2,]    2    1   -3<br/>## [3,]    3   -5    2<br/>## [4,]    2    4   -1<br/>## [5,]   -1    2    8<br/>## [6,]    4    1    1</span></pre><p id="6a9f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在，让我们计算实际系数。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="6713" class="oi kz it od b gy oj ok l ol om">beta_qr = solve(R) %*% t(Q) %*% y</span><span id="33dc" class="oi kz it od b gy on ok l ol om">beta_qr</span><span id="389f" class="oi kz it od b gy on ok l ol om">##             [,1]<br/>## [1,]  0.32297414<br/>## [2,]  0.07255123<br/>## [3,] -0.02764668</span></pre><p id="3fb1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为了检查这是否是正确的解，我们可以将计算出的<strong class="ls iu"> <em class="mr"> β̂ </em> </strong>与<code class="fe oa ob oc od b">lm</code>函数给出的结果进行比较。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="c1cd" class="oi kz it od b gy oj ok l ol om">coef(lm(y ~ -1 + ., data = data.frame(cbind(y,X))))</span><span id="b21c" class="oi kz it od b gy on ok l ol om">##          V2          V3          V4 <br/>##  0.32297414  0.07255123 -0.02764668</span></pre><p id="9917" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">显然，对于估计的系数，我们得到了完全相同的解。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="3406" class="ky kz it bd la lb nn ld le lf no lh li jz np ka lk kc nq kd lm kf nr kg lo lp bi translated">实施快速反应计划</h1><h2 id="d028" class="oi kz it bd la os ot dn le ou ov dp li lz ow ox lk md oy oz lm mh pa pb lo pc bi translated">格拉姆-施密特过程</h2><p id="745c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><em class="mr">Gram–Schmidt过程</em>是一种计算正交矩阵<strong class="ls iu"><em class="mr"/></strong>的方法，该矩阵由正交/独立的单位向量组成，并且跨越与原始矩阵<strong class="ls iu"> <em class="mr"> X </em> </strong>相同的空间。</p><ul class=""><li id="9068" class="ms mt it ls b lt mm lw mn lz oo md op mh oq ml mx my mz na bi translated">这种算法包括选择一个列向量<strong class="ls iu"> <em class="mr"> X </em> </strong>，比如说<strong class="ls iu"> <em class="mr"> x1 = u1 </em> </strong>作为初始步骤。</li><li id="b7ec" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated">然后，我们通过将<em class="mr"> </em> <strong class="ls iu"> <em class="mr"> X </em> </strong>的下一列投影到它上面，比如说<strong class="ls iu"> x2 </strong>并从中减去投影<strong class="ls iu"><em class="mr">U2 = x2 proj u1 x2</em></strong>，找到一个与<strong class="ls iu"> <em class="mr"> u1 </em> </strong>正交的向量。现在我们有了一组两个正交的向量。在之前的一篇文章中，我详细介绍了这种方法的工作原理。</li><li id="3afc" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated">下一步以同样的方式进行，但是减去正交向量组中每个向量的投影和<strong class="ls iu"> <em class="mr">英国</em> </strong>。</li></ul><p id="0450" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们可以这样表达:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/a1baba58a8619493d3bf1cece00fb8c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*xfCuGdlllu4HYyU2_KoC8A.png"/></div></figure><p id="7112" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><a class="ae ns" href="https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process" rel="noopener ugc nofollow" target="_blank">参考</a>。一旦我们有了完整的正交向量集，我们只需将每个向量除以其范数，然后将它们放入一个矩阵中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/dedd4e990efeb1c2ffbb3b578a6b4c03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YzTHBXdHeHrf4R-mdixqA.png"/></div></div></figure><p id="08a9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">一旦我们有了<strong class="ls iu"> <em class="mr"> Q </em> </strong>我们就可以很容易地解出<strong class="ls iu"> <em class="mr"> R </em> </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/d8d48eecfd45e16ff8ba1f054bee1c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*3yiNZLW5Duog3RG0xRy0qA.png"/></div></figure><h1 id="c795" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">用R和C++实现</h1><p id="ed59" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当然，<code class="fe oa ob oc od b">R</code>中有一个内置函数会帮你做<strong class="ls iu"> <em class="mr"> QR </em> </strong>矩阵分解。因为上面的GS算法本质上是迭代的，所以我决定在<code class="fe oa ob oc od b">C++</code>中实现它，这是一个很好的工具，并将其与一个等价的<code class="fe oa ob oc od b">R</code>函数进行比较。下面是我的<code class="fe oa ob oc od b">R</code>版本的样子:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="fc2d" class="oi kz it od b gy oj ok l ol om">myQR = function(A){<br/>  dimU = dim(A)<br/>  U = matrix(nrow = dimU[1], ncol = dimU[2])<br/>  U[,1] = A[,1]<br/>  for(k in 2:dimU[2]){<br/>    subt = 0<br/>    j = 1<br/>    while(j &lt; k){<br/>      subt = subt + proj(U[,j], A[,k])<br/>      j = j + 1<br/>    }<br/>    U[,k] = A[,k] - subt<br/>  }<br/>  Q = apply(U, 2, function(x) x/sqrt(sum(x^2)))<br/>  R = round(t(Q) %*% A, 10)<br/>  return(list(Q = Q, R = R, U = U))<br/>}</span></pre><p id="77dd" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它是非常字面的。for循环里面有一个while循环，被调用的投影函数也是用<code class="fe oa ob oc od b">R</code>写的函数。</p><p id="6b1f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这是我的<code class="fe oa ob oc od b">C++</code>版本的样子。逻辑基本上是相同的，只是有另一个for循环来规范化正交列。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="80a2" class="oi kz it od b gy oj ok l ol om">// [[Rcpp::export]]<br/>List myQRCpp(NumericMatrix A) {<br/>  int a = A.rows();<br/>  int b = A.cols();<br/>  NumericMatrix U(a,b);<br/>  NumericMatrix Q(a,b);<br/>  NumericMatrix R(a,b);<br/>  NumericMatrix::Column Ucol1 = U(_ , 0);<br/>  NumericMatrix::Column Acol1 = A(_ , 0);<br/>  <br/>  Ucol1 = Acol1;<br/>  <br/>  for(int i = 1; i &lt; b; i++){<br/>    NumericMatrix::Column Ucol = U(_ , i);<br/>    NumericMatrix::Column Acol = A(_ , i);<br/>    NumericVector subt(a);<br/>    int j = 0;<br/>    while(j &lt; i){<br/>      NumericVector uj = U(_ , j);<br/>      NumericVector ai = A(_ , i);<br/>      subt = subt + projC(uj, ai);<br/>      j++;<br/>    }<br/>    Ucol = Acol - subt;<br/>  }<br/>  for(int i = 0; i &lt; b; i++){<br/>    NumericMatrix::Column ui = U(_ , i);<br/>    NumericMatrix::Column qi = Q(_ , i);<br/>    <br/>    double sum2_ui = 0;<br/>    for(int j = 0; j &lt; a; j++){<br/>      sum2_ui = sum2_ui + ui[j]*ui[j];<br/>    }<br/>    qi = ui/sqrt(sum2_ui);<br/>  }<br/>  <br/>  List L = List::create(Named("Q") = Q , _["U"] = U);<br/>  return L;<br/>}</span></pre><h1 id="7dfa" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">比较R与C++的实现</h1><p id="82a4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">除了上面的两个函数之外，我还有第三个函数，除了它调用了<code class="fe oa ob oc od b">projC</code>而不是<code class="fe oa ob oc od b">proj</code>之外，它和<code class="fe oa ob oc od b">R</code>完全相同。我把这个函数命名为<code class="fe oa ob oc od b">myQRC</code>。(<code class="fe oa ob oc od b">projC</code>写在<code class="fe oa ob oc od b">C++</code>，而<code class="fe oa ob oc od b">proj</code>写在<code class="fe oa ob oc od b">R</code>)。否则，我们有一个纯<code class="fe oa ob oc od b">C++</code>函数<code class="fe oa ob oc od b">myQRCpp</code>和一个纯<code class="fe oa ob oc od b">R</code>函数<code class="fe oa ob oc od b">myQR</code>。</p><p id="dda5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为了比较这三个函数执行<strong class="ls iu"> <em class="mr"> QR </em> </strong>因式分解的速度，我将它们放在一个函数<code class="fe oa ob oc od b">QR_comp</code>中，用相同的矩阵参数调用和计时。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="f217" class="oi kz it od b gy oj ok l ol om">QR_comp = function(A){<br/>  t0 = Sys.time()<br/>  myQR(A)<br/>  tQR = Sys.time() - t0<br/>  t0 = Sys.time()<br/>  myQRC(A)<br/>  tQRC = Sys.time() - t0<br/>  t0 = Sys.time()<br/>  myQRCpp(A)<br/>  tQRCpp = Sys.time() - t0<br/>  <br/>  return(data.frame(tQR = as.numeric(tQR), <br/>                    tQRC = as.numeric(tQRC),<br/>                    tQRCpp = as.numeric(tQRCpp)))<br/>}</span></pre><p id="f5a3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们可以通过<code class="fe oa ob oc od b">m</code>随机矩阵在<code class="fe oa ob oc od b">n</code>的网格上比较它们的性能。这些矩阵是在调用<code class="fe oa ob oc od b">QR_comp</code>函数时生成的。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="4908" class="oi kz it od b gy oj ok l ol om">grid = expand.grid(n = seq(10, 3010, 500), <br/>                   m = seq(50, 600, 50))</span><span id="60a0" class="oi kz it od b gy on ok l ol om">tvec = map2(grid$n, <br/>            grid$m, <br/>            ~QR_comp(matrix(runif(.x*.y), ncol = .y)))</span></pre><p id="5b9c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">最后，我们可以直观地评估这些变化。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="ed87" class="oi kz it od b gy oj ok l ol om">plotly::ggplotly(<br/>bind_rows(tvec) %&gt;%<br/>  gather("func","time") %&gt;%<br/>  mutate(n = rep(grid$n, 3),<br/>         m = rep(grid$m, 3)) %&gt;%<br/>  ggplot(aes(m, n, fill = time)) + <br/>  geom_tile() + <br/>  facet_grid(.~func) +<br/>  scale_fill_gradientn(colours = rainbow(9)) +<br/>  theme(panel.background = element_blank(),<br/>        axis.ticks.y = element_blank(),<br/>        axis.text.y = element_text(angle = 35, size = 5),<br/>        axis.text.x = element_text(angle = 30, size = 5)), width = 550, heigh = 400)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/2bdd517245793702c2fb1e5b7e09b4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXcNyuwxnhRqIe5RRWG-Rw.png"/></div></div></figure><p id="2c3e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">显然，涉及的<code class="fe oa ob oc od b">C++</code>越多，计算<strong class="ls iu"> <em class="mr"> QR </em> </strong>因式分解的速度就越快。all <code class="fe oa ob oc od b">C++ </code>函数在不到一分钟的时间内求解最多有<code class="fe oa ob oc od b">250</code>列和<code class="fe oa ob oc od b">3000</code>行或<code class="fe oa ob oc od b">600</code>列和<code class="fe oa ob oc od b">500</code>行的矩阵。<code class="fe oa ob oc od b">R</code>功能慢2-3倍。</p><h1 id="9447" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="1f8b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">QR只是一种矩阵分解，LS只是QR的一种应用。希望上面的讨论证明了线性代数对于数据科学是多么重要和有用。在未来，我将讨论QR分解的另一个应用，并讨论一些其他重要的分解，如特征值和SVD分解。</p><p id="99f2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">另外，你可以看出我正在使用<code class="fe oa ob oc od b">R</code>和<code class="fe oa ob oc od b">C++</code>来计算实现这些方法。我希望这是有用的，并将激励像我一样的其他<code class="fe oa ob oc od b">R</code>用户学习<code class="fe oa ob oc od b">C++</code>和<code class="fe oa ob oc od b">Rcpp</code>,并在他们的工具包中放入它们，使他们的<code class="fe oa ob oc od b">R</code>工作得更加强大。</p><p id="3755" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">感谢阅读！</p></div></div>    
</body>
</html>