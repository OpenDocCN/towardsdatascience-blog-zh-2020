<html>
<head>
<title>A Bayesian Approach to Linear Mixed Models (LMM) in R/Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R/Python中线性混合模型(LMM)的贝叶斯方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-bayesian-approach-to-linear-mixed-models-lmm-in-r-python-b2f1378c3ac8?source=collection_archive---------6-----------------------#2020-06-22">https://towardsdatascience.com/a-bayesian-approach-to-linear-mixed-models-lmm-in-r-python-b2f1378c3ac8?source=collection_archive---------6-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1318" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/video-tutorial" rel="noopener" target="_blank">视频教程</a></h2><div class=""/><div class=""><h2 id="7ae5" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">实现这些比你想象的要简单</h2></div><p id="2ecf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">似乎有一种普遍的误解，认为贝叶斯方法比T4的方法更难实现。有时这是真的，但是更多的时候现有的R和Python库可以帮助简化这个过程。</p><blockquote class="lo"><p id="d6f1" class="lp lq it bd lr ls lt lu lv lw lx lm dk translated">更简单的实现≠扔进一些数据，看看有什么坚持。(我们已经有了这方面的机器学习。:P)</p></blockquote><p id="8074" class="pw-post-body-paragraph kr ks it kt b ku ly kd kw kx lz kg kz la ma lc ld le mb lg lh li mc lk ll lm im bi translated">人们让贝叶斯方法听起来比实际更复杂，主要是因为其中涉及了很多术语(例如<em class="md">弱先验、后验预测分布、</em>等)。)这并不直观，除非您以前使用过这些方法。</p><p id="77d8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">意识形态的冲突加剧了这种误解——“频繁主义者与贝叶斯主义者之争。”(如果你以前不知道，现在你知道了。)问题是人们，尤其是统计学家，通常会争论哪种方法更有效，而事实上答案是“视情况而定”</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/f9edd8dc5cd86466f0f793b62d434883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FS2Penq1JruETwVIGs26sw.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">证据一:这是一个温和的例子，说明为什么这场争吵毫无意义<a class="ae ln" href="https://twitter.com/RevBayes/status/506577193804111872" rel="noopener ugc nofollow" target="_blank">https://twitter.com/RevBayes/status/506577193804111872</a></p></figure><blockquote class="lo"><p id="398f" class="lp lq it bd lr ls mu mv mw mx my lm dk translated">贝叶斯方法，像其他任何方法一样，只是我们使用的工具。它们有优点也有缺点。</p></blockquote><p id="b642" class="pw-post-body-paragraph kr ks it kt b ku ly kd kw kx lz kg kz la ma lc ld le mb lg lh li mc lk ll lm im bi translated">因此，随着一些个人的“热点”的方式，让我们继续有趣的东西，并实现一些贝叶斯线性混合(LMM)模型！</p><h1 id="bcfa" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">一眼</h1><p id="adec" class="pw-post-body-paragraph kr ks it kt b ku nr kd kw kx ns kg kz la nt lc ld le nu lg lh li nv lk ll lm im bi translated">以下是我将要介绍的内容(包括R和Python):</p><ol class=""><li id="f1f7" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated">选择先验的实用方法(<em class="md">需要定义贝叶斯模型</em></li><li id="9502" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">如何使用R和Python实现贝叶斯LMM的分步指南(分别使用<code class="fe ok ol om on b">brms</code>和<code class="fe ok ol om on b">pymc3</code>)</li><li id="ec8a" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">快速MCMC诊断有助于您在流程早期发现潜在问题</li></ol><p id="3c2b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">贝叶斯模型检查、比较和评估方法不在本文讨论范围内。(评价一个模特的方式比RMSE多。)我已经发表了一篇</strong> <a class="ae ln" rel="noopener" target="_blank" href="/evaluating-bayesian-mixed-models-in-r-python-27d344a03016"> <strong class="kt jd">的后续文章，更详细地介绍了这些</strong> </a> <strong class="kt jd">。</strong></p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="oo op l"/></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">Python教程</p></figure><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="oq op l"/></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">r教程</p></figure><h1 id="b56a" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">设置</h1><p id="f927" class="pw-post-body-paragraph kr ks it kt b ku nr kd kw kx ns kg kz la nt lc ld le nu lg lh li nv lk ll lm im bi translated"><em class="md">如果你对混动车型不熟悉我推荐你先</em> <a class="ae ln" rel="noopener" target="_blank" href="/when-mixed-effects-hierarchical-models-fail-pooling-and-uncertainty-77e667823ae8"> <em class="md">复习一下这里覆盖的一些基础</em> </a> <em class="md">。同样，如果你对贝叶斯推论不是很熟悉的话我推荐</em> <a class="or os ep" href="https://medium.com/u/1d8994ad0efc?source=post_page-----b2f1378c3ac8--------------------------------" rel="noopener" target="_blank"> <em class="md">艾林金</em></a><em class="md"/><a class="ae ln" rel="noopener" target="_blank" href="/bayesian-inference-intuition-and-example-148fd8fb95d6?source=---------8------------------"><em class="md">的惊人文章</em> </a> <em class="md">向前看。</em></p><p id="0abd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们回到我在上一篇文章中提到的营销例子。简而言之，我们的数据集由模拟的网站反弹时间(即客户在网站上花费的时间长度)组成，而<strong class="kt jd">的总体目标是找出年轻人在网站上花费的时间是否比老年人多。</strong></p><p id="6e94" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该数据集有613个观察到的“反弹时间”(<code class="fe ok ol om on b">bounce_time</code>，秒)，这些时间是在8个位置(<code class="fe ok ol om on b">county</code>)收集的，每个位置都有一个关联的<code class="fe ok ol om on b">age</code>，该关联的【】后来被中心缩放(<code class="fe ok ol om on b">std_age</code>)。但是，每个位置的观测值数量各不相同(例如，一个位置有150个观测值，而另一个位置只有7个)。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ot"><img src="../Images/ff0f83fb27f1a0fd92ebfd13f298778b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAgllJ-Jsbb106yVqLcj7w.png"/></div></div></figure><h1 id="cbfa" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">步骤1:探索性数据分析(EDA)</h1><p id="68f9" class="pw-post-body-paragraph kr ks it kt b ku nr kd kw kx ns kg kz la nt lc ld le nu lg lh li nv lk ll lm im bi translated">EDA是数据分析的无名英雄，你不应该认为它只是绘制数据。</p><p id="a579" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">(我会远离那些暗示它是“无聊的东西”的帖子，或者那些只是希望自动化它以便你可以直接进入建模的帖子，即使你使用的是ML算法。如果你这样做，你就错过了一个非常强大的工具。)就个人而言，我认为这是你的分析工作流程中最关键的步骤之一。它可以作为一个迭代工具来帮助你调整你的建模策略，特别是当你的策略是从简单的开始，逐步建立更复杂的模型时。</p><blockquote class="lo"><p id="cc29" class="lp lq it bd lr ls lt lu lv lw lx lm dk translated">EDA不仅仅是绘制数据，它还是一种迭代工具，可以帮助您调整建模策略。</p></blockquote><p id="cd54" class="pw-post-body-paragraph kr ks it kt b ku ly kd kw kx lz kg kz la ma lc ld le mb lg lh li mc lk ll lm im bi translated">例如，在我们的例子中，我们可以拟合的最简单的模型是使用<code class="fe ok ol om on b">sklearn</code> (Python)或<code class="fe ok ol om on b">lm</code> (R)的基本线性回归，并看看它如何捕捉我们数据中的可变性。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ou"><img src="../Images/cfcf6129b9d9eb9fb3e055ee6d6142be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*seCvDxPCCzl93Ppz7v8rsw.png"/></div></div></figure><p id="ad9e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">我们也可以考虑更复杂的模型，比如线性混合效应模型。</strong>同样，通过一些EDA，我们看到这种模型可以更好地捕捉群体可变性，因此可能是更好的策略。我们可以使用<code class="fe ok ol om on b">seaborn.lmplot</code>或ggplot2的<code class="fe ok ol om on b">geom_smooth</code>快速构建一些直观的EDA图。这里<strong class="kt jd">看起来变截距和变截距/变斜率模型可能是很好的研究对象。</strong>(我们的EDA还揭示了一个<a class="ae ln" href="https://en.wikipedia.org/wiki/Simpson%27s_paradox" rel="noopener ugc nofollow" target="_blank">辛普森悖论</a>的例子，其中一条全局回归线与单个县的趋势不匹配。)</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ov"><img src="../Images/00b83b8ceba8bfcd9886324fa5f68019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CNrCfZ4JqiGytCcg0tEm4Q.png"/></div></div></figure><p id="e34e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将继续进行<strong class="kt jd">三个候选模型:线性回归、随机截距模型和随机截距+斜率模型。</strong> <br/>(简单的线性模型被视为基线，有助于举例说明建模过程。)</p><h1 id="667b" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">步骤2:在一些虚假数据的帮助下选择先验</h1><blockquote class="ow ox oy"><p id="de01" class="kr ks md kt b ku kv kd kw kx ky kg kz oz lb lc ld pa lf lg lh pb lj lk ll lm im bi translated">注意:在这一点上，我假设你熟悉贝叶斯推理，不会深入到它的主要组成部分。如果你不是，停下来，去看看上面推荐的阅读材料。</p></blockquote><p id="3b8b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">贝叶斯推理要求我们在完全定义我们的模型之前为我们的参数选择<em class="md">先验分布(“先验”)</em>。与其使用<strong class="kt jd"><em class="md"/><em class="md"/><strong class="kt jd"><strong class="kt jd"><em class="md">先验信息，还不如选择<em class="md"/><strong class="kt jd"><em class="md"/></strong><em class="md"/><strong class="kt jd"><em class="md">先验信息。</em> </strong></em></strong></strong></strong></p><p id="e95e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但是你如何定义什么是“弱”先验呢？</p><blockquote class="lo"><p id="910d" class="lp lq it bd lr ls lt lu lv lw lx lm dk translated">好的弱信息先验考虑了你的数据和被问到的问题，以生成可信的数据集。</p></blockquote><p id="eec3" class="pw-post-body-paragraph kr ks it kt b ku ly kd kw kx lz kg kz la ma lc ld le mb lg lh li mc lk ll lm im bi translated">定义弱信息先验的一个常用策略是根据你的可能性和先验组合创建一个模拟数据的“活页本”。(该程序被称为<em class="md">预先预测检查</em>。)不要将先验视为独立的(边缘)实体，用它们模拟数据可以让我们了解它们如何与可能性相互作用，以及这对先验是否会生成<strong class="kt jd">似是而非的数据点。</strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi pc"><img src="../Images/ab77afa0e6b24e9920b380f15be6db55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4dDF2rp5-reevMLIp7M-Q.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">我们的变截距模型和先验的概率定义</p></figure><p id="e354" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例如，让我们尝试为我们的<em class="md">随机截距模型参数</em> (β0、β1、B0、τ0和σ)选择弱先验，并模拟一些数据。</p><p id="bd7c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我通过一种迭代策略选择了上述先验，这种策略将EDA步骤中关于人口和群体趋势的信息与特定群体的经验均值和方差估计相结合(见下文)。你必须根据你自己的数据和正在考虑的问题来探索一些选择。</p><p id="6f07" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> R模拟</strong></p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="pd op l"/></div></figure><h2 id="8af6" class="pe na it bd nb pf pg dn nf ph pi dp nj la pj pk nl le pl pm nn li pn po np iz bi translated"><strong class="ak"> Python模拟</strong></h2><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="pd op l"/></div></figure><blockquote class="lo"><p id="ded0" class="lp lq it bd lr ls mu mv mw mx my lm dk translated"><strong class="ak">定义弱信息先验的常用策略是创建模拟数据的“翻页书”(也称为先验预测检查)。</strong></p></blockquote><p id="fe78" class="pw-post-body-paragraph kr ks it kt b ku ly kd kw kx lz kg kz la ma lc ld le mb lg lh li mc lk ll lm im bi translated">下面是一本电子书的例子(<strong class="kt jd"> <em class="md">左动画</em> </strong>)。<strong class="kt jd">我们看到大多数模拟数据点都是“合理的”，</strong>这意味着我们看到大多数假数据点都在我们当前的反弹率范围内(≈160–250)。其他数据超出了我们的数据范围，但仍在可信范围内(例如，高达500–600秒)。相反，如果我们使用<strong class="kt jd">通用<em class="md">弱先验</em></strong>[例如N(0，100)和Inv-Gamma(1，100)]，我们会看到许多模拟的反弹率&lt; 100秒。甚至是&lt; 0，这显然是概率较小的(<strong class="kt jd"> <em class="md">右</em> </strong>)。</p><div class="mf mg mh mi gt ab cb"><figure class="pp mj pq pr ps pt pu paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/0fa4b574b0fc6e0916c8d1bb90f8a1f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/1*rDbqw8rtKG4jkUoFMs_SSg.gif"/></div></figure><figure class="pp mj pv pr ps pt pu paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/b89df0cb65207a31731ac8f13049f58b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*D0NRLVLV5CFr4kEPKQv3_Q.png"/></div></figure></div><p id="fc22" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你有兴趣了解更多关于如何选择优先<a class="ae ln" href="https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations" rel="noopener ugc nofollow" target="_blank">的信息，请查看Stan开发团队的资源页面。</a></p><h1 id="5a46" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">步骤3:拟合贝叶斯模型</h1><p id="4e1e" class="pw-post-body-paragraph kr ks it kt b ku nr kd kw kx ns kg kz la nt lc ld le nu lg lh li nv lk ll lm im bi translated">在前面的步骤中已经选择了一些合理的<em class="md">弱先验</em>，我们现在可以专注于从步骤1构建我们的候选模型。正如我在本文开头提到的，R和Python中有<strong class="kt jd">现有的库可以大大简化拟合贝叶斯线性混合模型。</strong></p><h2 id="002d" class="pe na it bd nb pf pg dn nf ph pi dp nj la pj pk nl le pl pm nn li pn po np iz bi translated"><strong class="ak"> 1) </strong> <code class="fe ok ol om on b"><a class="ae ln" href="https://paul-buerkner.github.io/brms/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="ak">brms</strong></a><strong class="ak">: an </strong></code> <strong class="ak">运行在</strong> <a class="ae ln" href="https://mc-stan.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> Stan </strong> </a>上的R包</h2><p id="4f29" class="pw-post-body-paragraph kr ks it kt b ku nr kd kw kx ns kg kz la nt lc ld le nu lg lh li nv lk ll lm im bi translated">如果你熟悉<code class="fe ok ol om on b">lme4</code>和<code class="fe ok ol om on b">lmer</code>函数的公式生成器，那么你已经成功了90%。是的，就这么简单！除了一些指定贝叶斯设置的附加选项，<code class="fe ok ol om on b">brms</code>提供了简单明了的功能。如果你深入了解它的所有功能——拟合gam，模拟高斯过程，甚至通过<code class="fe ok ol om on b">mice</code>输入数据，这是一个出色的库。我不会在这里讨论这些，但是我鼓励你多读一些。</p><p id="6d53" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下面是使用我们的反弹时间数据，用<code class="fe ok ol om on b">brms</code>实现变截距模型的例子。首先，该软件包通过内置函数<code class="fe ok ol om on b">prior</code>使定义先验变得容易，该函数将分布分配给选定的模型参数类、组或系数(<code class="fe ok ol om on b">prior(distribution(...), class=..., group=..., coef=...)</code>)。例如，我们可以将截距的法线先验设置为<code class="fe ok ol om on b">prior(normal(...), class=Intercept)</code>。您可以使用内置函数<code class="fe ok ol om on b">get_prior()</code>来了解如何设置这些标志。类似地，您可以从<a class="ae ln" href="http://mc-stan.org/rstanarm/reference/priors.html" rel="noopener ugc nofollow" target="_blank">广泛的可用分布</a>中选择先验。</p><p id="eac5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">接下来，您可以用<code class="fe ok ol om on b">brm</code>函数拟合模型，该函数提供了与<code class="fe ok ol om on b">lmer</code>类似的公式生成器和选项。你可以进一步<a class="ae ln" href="https://paul-buerkner.github.io/brms/reference/brm.html" rel="noopener ugc nofollow" target="_blank">修改贝叶斯方法特有的选项</a>比如要运行的MCMC链的数量和运行长度。</p><p id="4dbf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从模型中提取基本信息很简单。该库提供打印与模型拟合<code class="fe ok ol om on b">summary()</code>和后验估计<code class="fe ok ol om on b">posterior_summary()</code>相关的模型概要的功能。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="pd op l"/></div></figure><blockquote class="ow ox oy"><p id="4679" class="kr ks md kt b ku kv kd kw kx ky kg kz oz lb lc ld pa lf lg lh pb lj lk ll lm im bi translated"><strong class="kt jd">注:</strong>使用<strong class="kt jd"> </strong> <code class="fe ok ol om on b">bounce_time ~ 1 + std_age</code>公式时，BRMS假设预测值为<strong class="kt jd">均值居中</strong>。如果你的预测不是以均值为中心，你应该使用<code class="fe ok ol om on b">bounce_time ~ 0 + intercept + std_age</code>来代替。你可以<a class="ae ln" href="https://cran.r-project.org/web/packages/brms/brms.pdf" rel="noopener ugc nofollow" target="_blank">在这里</a>(第38-39页)阅读更多内容</p></blockquote><h2 id="6cf2" class="pe na it bd nb pf pg dn nf ph pi dp nj la pj pk nl le pl pm nn li pn po np iz bi translated">2)运行在<a class="ae ln" href="https://docs.pymc.io/PyMC3_and_Theano.html" rel="noopener ugc nofollow" target="_blank">和</a>上的PyMC3 <code class="fe ok ol om on b">: a Python library </code></h2><p id="8803" class="pw-post-body-paragraph kr ks it kt b ku nr kd kw kx ns kg kz la nt lc ld le nu lg lh li nv lk ll lm im bi translated">尽管有多种库适合贝叶斯模型，但PyMC3无疑提供了Python中最用户友好的语法。虽然新版本正在开发中(PyMC4现在运行在Tensorflow上)，但这个库中的大多数功能将在未来的版本中继续工作。</p><blockquote class="lo"><p id="db4d" class="lp lq it bd lr ls lt lu lv lw lx lm dk translated"><strong class="ak">与R中的</strong> <code class="fe ok ol om on b"><strong class="ak">brms</strong></code> <strong class="ak">包相比，P </strong> <code class="fe ok ol om on b"><strong class="ak">yMC3</strong></code> <strong class="ak">要求你显式地陈述模型的每个单独的组件——从先验到似然。</strong></p></blockquote><figure class="pw px py pz qa mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi pc"><img src="../Images/ab77afa0e6b24e9920b380f15be6db55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4dDF2rp5-reevMLIp7M-Q.png"/></div></div></figure><p id="e188" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">完整的规范并不像听起来那么糟糕。一旦您指定了模型(如左图所示),使用上下文管理器来构建就变得简单了。</p><p id="3c0e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">嗯，大部分时间😉。</p><blockquote class="lo"><p id="6025" class="lp lq it bd lr ls lt lu lv lw lx lm dk translated">对这个包唯一的警告是你的模型的参数化会对它的采样效率有很大的影响。</p></blockquote><p id="cedb" class="pw-post-body-paragraph kr ks it kt b ku ly kd kw kx lz kg kz la ma lc ld le mb lg lh li mc lk ll lm im bi translated">例如，下面的模型代码使用了与上面所示模型略有不同的参数化(即<a class="ae ln" href="https://twiecki.io/blog/2017/02/08/bayesian-hierchical-non-centered/" rel="noopener ugc nofollow" target="_blank">居中参数化</a>)。</p><p id="92d7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先，我们用上下文管理器和<code class="fe ok ol om on b">pm.Model()</code>方法初始化模型。这将基本上封装一个模型的变量和可能性因素。接下来，我们可以开始使用<a class="ae ln" href="https://docs.pymc.io/api/distributions.html" rel="noopener ugc nofollow" target="_blank">多种内置分布</a>为我们的每个组件(先验、超先验和似然)分配分布。</p><p id="c02e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">建立模型分布很简单。首先通过<code class="fe ok ol om on b">pm.your_distribution_class()</code>定义你想要使用的分布类，然后给它分配一个标签并修改它的分布参数，最后把它分配给一个<em class="md">上下文变量<br/> </em>(例如<code class="fe ok ol om on b">beta1=pm.Normal('std_age', mu=mu0, sigma=tau0)</code>用标签<code class="fe ok ol om on b">std_age</code>和参数<code class="fe ok ol om on b">mu0</code>和<code class="fe ok ol om on b">tau0</code>把<code class="fe ok ol om on b">beta1</code>定义为普通的)。</p><p id="67d1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦你的模型组件被设置好，你只需要设置<code class="fe ok ol om on b">pm.trace()</code>函数来存储你的后验样本。与<code class="fe ok ol om on b">brms</code>类似，您还可以进一步<a class="ae ln" href="https://docs.pymc.io/api/backends.html" rel="noopener ugc nofollow" target="_blank">修改贝叶斯方法的特定选项</a>，例如要运行的MCMC链的数量和运行长度。</p><p id="9931" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">由于PyMC3依赖于<code class="fe ok ol om on b">arviz</code>进行事后可视化，因此有必要将模型输出保存为<code class="fe ok ol om on b">InferenceData</code>类型，以便以后在模型诊断和事后检查中使用。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="pd op l"/></div></figure><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi qb"><img src="../Images/ab7069919f8f72d5d33f9ac8e404a839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdFdaO8wf1mqHwTtGWQiPA.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">上述随机截距模型的输出；alpha表示特定于县的拦截</p></figure><h1 id="8d11" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">步骤3.a: MCMC诊断</h1><p id="d59a" class="pw-post-body-paragraph kr ks it kt b ku nr kd kw kx ns kg kz la nt lc ld le nu lg lh li nv lk ll lm im bi translated">唷！这是很多信息。然而，没有一些好的诊断，任何建模努力都是不完整的。(注意:模型检查、评估和比较也是这个过程的一部分，但是我会在另一篇文章<a class="ae ln" rel="noopener" target="_blank" href="/evaluating-bayesian-mixed-models-in-r-python-27d344a03016"><strong class="kt jd"/></a>中更详细地介绍它们。)</p><p id="ebd0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">传统上，两种诊断可视化方法——MCMC迹线图和自相关函数(ACF)图——有助于我们了解采样是否存在问题。换句话说，我们的样本以及我们的推论有多可靠？这些工具诉诸于马尔可夫链的一些理论属性，并且是理解马尔可夫链性能的良好的检查。然而，<code class="fe ok ol om on b">brms</code>和<code class="fe ok ol om on b">pymc3</code>使用先进的MCMC方法，这些方法提供了额外的诊断，可以更精确地了解它们的性能。</p><blockquote class="lo"><p id="b1ad" class="lp lq it bd lr ls lt lu lv lw lx lm dk translated">除了常规诊断之外，其他方法也可用于高级技术，如<a class="ae ln" href="https://en.wikipedia.org/wiki/Hamiltonian_Monte_Carlo" rel="noopener ugc nofollow" target="_blank">哈密尔顿蒙特卡罗</a> (HMC)，可以提供更详细的马尔可夫链性能图。</p></blockquote><p id="7844" class="pw-post-body-paragraph kr ks it kt b ku ly kd kw kx lz kg kz la ma lc ld le mb lg lh li mc lk ll lm im bi translated">让我们深入了解一个实施传统和HMC相关诊断的示例。</p><h2 id="c244" class="pe na it bd nb pf pg dn nf ph pi dp nj la pj pk nl le pl pm nn li pn po np iz bi translated">传统MCMC诊断</h2><p id="9ef4" class="pw-post-body-paragraph kr ks it kt b ku nr kd kw kx ns kg kz la nt lc ld le nu lg lh li nv lk ll lm im bi translated">上面强调的两个常见的可视化帮助我们理解</p><ol class=""><li id="c860" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated">马尔可夫链具有<a class="ae ln" href="https://en.wikipedia.org/wiki/Markov_chain_mixing_time" rel="noopener ugc nofollow" target="_blank">良好的混合</a>(即似乎已经收敛到稳态分布)</li><li id="f58a" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">样本不违反<a class="ae ln" href="https://en.wikipedia.org/wiki/Markov_property#:~:text=A%20stochastic%20process%20has%20the,is%20called%20a%20Markov%20process." rel="noopener ugc nofollow" target="_blank">马尔可夫特性</a>(例如自相关在滞后1之后消失)</li></ol><p id="acef" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">在R </strong>中，您可以使用适合您的模型使用<code class="fe ok ol om on b">bayesplot</code>中的<code class="fe ok ol om on b">mcmc_trace</code>和<code class="fe ok ol om on b">mcmc_acf</code>功能轻松生成这些。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="pd op l"/></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">线性回归示例</p></figure><div class="mf mg mh mi gt ab cb"><figure class="pp mj qc pr ps pt pu paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/94b9bef75c514fb9f99adb2be21dcbfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*ibO6eHWy0DYPCOIMBZTCyg.png"/></div></figure><figure class="pp mj qd pr ps pt pu paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/a2e4f23003e209ecc6bfc938c4905564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*fSiRj5looWYrMNWYoUflYQ.png"/></div><p class="mq mr gj gh gi ms mt bd b be z dk qe di qf qg translated">R中线性回归模型的跟踪图(左)和自相关图(右)</p></figure></div><p id="951d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">Python  <code class="fe ok ol om on b">pymc3</code>中的<strong class="kt jd">有一个内置的集成，通过<code class="fe ok ol om on b">arviz</code>来可视化这些，你只需要模型中指定的trace对象。</strong></p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="pd op l"/></div></figure><div class="mf mg mh mi gt ab cb"><figure class="pp mj qh pr ps pt pu paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/cecfd98ba21f8e94337dc3842df86ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*nomahIgYZ14W2d9XXhdpHw.png"/></div></figure><figure class="pp mj qi pr ps pt pu paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/a3f24f1a2c657e7963cd09e95950672b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*5grjM2Y187B6rc6ejZud5w.png"/></div><p class="mq mr gj gh gi ms mt bd b be z dk qj di qk qg translated">Python中线性回归模型的追踪图(左)和自相关图(右)</p></figure></div><h2 id="48fb" class="pe na it bd nb pf pg dn nf ph pi dp nj la pj pk nl le pl pm nn li pn po np iz bi translated">哈密尔顿蒙特卡罗诊断</h2><p id="96ad" class="pw-post-body-paragraph kr ks it kt b ku nr kd kw kx ns kg kz la nt lc ld le nu lg lh li nv lk ll lm im bi translated">如上所述，哈密顿蒙特卡罗提供了我们可以使用的额外诊断。<code class="fe ok ol om on b">pymc3</code>和<code class="fe ok ol om on b">brms</code>都运行在一个叫做<a class="ae ln" href="http://www.stat.columbia.edu/~gelman/research/published/nuts.pdf" rel="noopener ugc nofollow" target="_blank">不掉头采样</a>的非常高效的HMC采样器上。</p><p id="a79f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里粗一句话，高级总结:</p><blockquote class="lo"><p id="bb22" class="lp lq it bd lr ls lt lu lv lw lx lm dk translated">HMC使用一阶梯度来指导有用方向上的采样，这有助于它比传统的MCMC方法更快地收敛到后验，并且NUTS动态更新可以影响HMC性能的参数(即，步长ε和步数L)。</p></blockquote><p id="8fca" class="pw-post-body-paragraph kr ks it kt b ku ly kd kw kx lz kg kz la ma lc ld le mb lg lh li mc lk ll lm im bi translated">坚果，对不对？！(希望大家能原谅不好的双关语)。为了澄清最后一点，考虑一下在类似梯度的更新方面发生了什么，例如，如果你选择的步长太小或步长数太高，你可能会浪费计算时间。虽然这是一个有用的类比，但该算法如何工作的细节更加复杂和优雅。</p><p id="7b60" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">回到“那又怎样，伙计？”嗯，在链没有混合或者ACF显示出对样本的更高依赖性的情况下，很难诊断发生了什么。</p><p id="a031" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然而，如果你使用HMC或坚果，你可以看看<a class="ae ln" href="https://mc-stan.org/docs/2_21/reference-manual/divergent-transitions.html" rel="noopener ugc nofollow" target="_blank"><strong class="kt jd"/></a><strong class="kt jd">发散过渡，这可以帮助你了解你的后臀的几何形状(！！)</strong>。当建议的下一步偏离采样器设定的最有效路径时，就会出现这些问题。</p><blockquote class="lo"><p id="cbc7" class="lp lq it bd lr ls lt lu lv lw lx lm dk translated">发散是强有力的诊断，它允许你理解后几何。</p></blockquote><p id="8b7e" class="pw-post-body-paragraph kr ks it kt b ku ly kd kw kx lz kg kz la ma lc ld le mb lg lh li mc lk ll lm im bi translated">想象这些可以<strong class="kt jd">在两个方面有所帮助:</strong></p><ol class=""><li id="b6d3" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated"><strong class="kt jd">检测您的采样器在穿越后部“景观”时遇到困难的“位置”</strong>(可能是由于局部高度可变性或弯曲的几何形状)。在这种情况下，您可以考虑重新参数化您的模型，以“平滑”那些高曲率区域。</li><li id="c93e" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated"><strong class="kt jd">排除“假阳性”偏差</strong>(标记的偏差转换与非偏差转换表现相同)</li></ol><p id="0fec" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下面的例子说明了发散如何帮助识别链被“卡住”或被错误标记为发散<strong class="kt jd"> <em class="md">(绿色)</em> </strong>。在左图和右图中，绿色点或线高度集中的区域表明存在收敛问题(即，您可以在下面的<code class="fe ok ol om on b">tau</code>中看到这种漏斗状集中)。在这里，采样器不能充分探索由<code class="fe ok ol om on b">tau</code>定义的后部区域，因此我们对<code class="fe ok ol om on b">tau</code>的推断是不可靠的。相反，在轨迹被错误地标记为发散但表现得像非发散轨迹的情况下，我们也可以获得其他参数推断的置信度(例如<code class="fe ok ol om on b">theta1,...,theta8</code>)。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ql"><img src="../Images/d3d15f7779d0e563f2da67fa23bb86e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MykYiBAR5mp5MFKB3-qy6g.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">Gabry，Jonah等人(2019年)</p></figure><p id="ab4c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">要了解更多关于解释这些强有力的诊断图的信息，请查看迈克尔·贝当古的这篇文章。要在<strong class="kt jd"> R中运行该诊断，使用<code class="fe ok ol om on b">bayesplot</code>中的</strong> <code class="fe ok ol om on b"><strong class="kt jd">mcmc_scatter</strong></code> <strong class="kt jd">功能</strong>。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="pd op l"/></div></figure><p id="9bf1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在<strong class="kt jd"> Python </strong>中你可以使用<code class="fe ok ol om on b">plot_parallel</code> PyMC3内置函数。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="pd op l"/></div></figure><p id="ec67" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这种情况下，我们可以看到没有任何像上面看到的发散轨迹，因此我们的链毫无困难地探索了后面的几何形状(即收敛)。</p><div class="mf mg mh mi gt ab cb"><figure class="pp mj qm pr ps pt pu paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/5d1690870bbb2b2842da948a8e4e9dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*J1FH_Ok8AkjEPaDKoKJh8w.png"/></div></figure><figure class="pp mj qn pr ps pt pu paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/41785f0094a4bfed858230160a648a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*mL_Sgj0NHMAq1YsHlD0GXg.png"/></div><p class="mq mr gj gh gi ms mt bd b be z dk qo di qp qg translated">Python(左)和R(右)中的不同诊断</p></figure></div><h1 id="4ba5" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated"><strong class="ak">结论</strong></h1><p id="9568" class="pw-post-body-paragraph kr ks it kt b ku nr kd kw kx ns kg kz la nt lc ld le nu lg lh li nv lk ll lm im bi translated">像<code class="fe ok ol om on b">pymc3</code>和<code class="fe ok ol om on b">brms</code>这样的软件包极大地简化了贝叶斯模型的拟合。然而，实现更简单并不意味着我们应该忘记建模过程中的关键步骤，这些步骤可以帮助我们构建更好的模型。</p><p id="179c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我希望你已经学会了一些选择好的先验分布的新方法，如何对贝叶斯混合模型进行故障诊断，以及为什么EDA可以是一个强大的工具(不仅仅是在贝叶斯设置中)。</p><p id="85bc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，我的希望是让人们不要因为“它们听起来很难”而回避贝叶斯方法，而是为他们提供可以添加到他们的工具集中的新方法。</p><h1 id="9c45" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">参考</h1><ol class=""><li id="e87d" class="nw nx it kt b ku nr kx ns la qq le qr li qs lm ob oc od oe bi translated">Gelman，a .，Carlin，J. B .，Stern，H. S .，Dunson，D. B .，Vehtari，a .，和Rubin，D. B. (2013年)。贝叶斯数据分析。CRC出版社。</li><li id="0c76" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">盖布里、乔纳等人，《贝叶斯工作流程中的可视化》<em class="md">英国皇家统计学会杂志:A辑(社会中的统计学)</em>182.2(2019):389–402。</li></ol></div><div class="ab cl qt qu hx qv" role="separator"><span class="qw bw bk qx qy qz"/><span class="qw bw bk qx qy qz"/><span class="qw bw bk qx qy"/></div><div class="im in io ip iq"><p id="b4a0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你喜欢这篇文章，请随意分享！如果您有任何问题，或者您看到任何不正确/有问题的内容，请发表评论或发推文(<a class="ae ln" href="https://twitter.com/ecoronado92" rel="noopener ugc nofollow" target="_blank"> @ecoronado92 </a>)。</p><p id="c7b6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所有的R代码都可以在<a class="ae ln" href="https://htmlpreview.github.io/?https://github.com/ecoronado92/towards_data_science/blob/master/hierarchical_models/bayes_lmm/R/bayesian_linear_mixed_model.html" rel="noopener ugc nofollow" target="_blank">这里找到</a></p><p id="72ef" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所有的Python代码都可以在<a class="ae ln" href="https://github.com/ecoronado92/towards_data_science/blob/master/hierarchical_models/bayes_lmm/python/bayesian_linear_mixed_effects.ipynb" rel="noopener ugc nofollow" target="_blank">这里找到</a></p><div class="ra rb gp gr rc rd"><a href="https://github.com/ecoronado92/towards_data_science/tree/master/hierarchical_models/bayes_lmm" rel="noopener  ugc nofollow" target="_blank"><div class="re ab fo"><div class="rf ab rg cl cj rh"><h2 class="bd jd gy z fp ri fr fs rj fu fw jc bi translated">ecoronado 92/走向_数据_科学</h2><div class="rk l"><h3 class="bd b gy z fp ri fr fs rj fu fw dk translated">报告包含的材料和例子实施贝叶斯线性混合效应(层次模型)模拟…</h3></div><div class="rl l"><p class="bd b dl z fp ri fr fs rj fu fw dk translated">github.com</p></div></div><div class="rm l"><div class="rn l ro rp rq rm rr mo rd"/></div></div></a></div><div class="ra rb gp gr rc rd"><a rel="noopener follow" target="_blank" href="/when-mixed-effects-hierarchical-models-fail-pooling-and-uncertainty-77e667823ae8"><div class="re ab fo"><div class="rf ab rg cl cj rh"><h2 class="bd jd gy z fp ri fr fs rj fu fw jc bi translated">当混合效应(分层)模型失败时:汇集和不确定性</h2><div class="rk l"><h3 class="bd b gy z fp ri fr fs rj fu fw dk translated">一个直观和可视化的指南，其中部分池变得麻烦，贝叶斯方法可以帮助量化…</h3></div><div class="rl l"><p class="bd b dl z fp ri fr fs rj fu fw dk translated">towardsdatascience.com</p></div></div><div class="rm l"><div class="rs l ro rp rq rm rr mo rd"/></div></div></a></div><div class="ra rb gp gr rc rd"><a rel="noopener follow" target="_blank" href="/evaluating-bayesian-mixed-models-in-r-python-27d344a03016"><div class="re ab fo"><div class="rf ab rg cl cj rh"><h2 class="bd jd gy z fp ri fr fs rj fu fw jc bi translated">在R/Python中评估贝叶斯混合模型</h2><div class="rk l"><h3 class="bd b gy z fp ri fr fs rj fu fw dk translated">了解“后验预测检查”的含义以及如何直观地评估模型性能</h3></div><div class="rl l"><p class="bd b dl z fp ri fr fs rj fu fw dk translated">towardsdatascience.com</p></div></div><div class="rm l"><div class="rt l ro rp rq rm rr mo rd"/></div></div></a></div></div></div>    
</body>
</html>