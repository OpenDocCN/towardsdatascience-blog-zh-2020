<html>
<head>
<title>Homebrewing DBSCAN in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的自制 DBSCAN</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/homebrewing-dbscan-in-python-dcae23f6010?source=collection_archive---------55-----------------------#2020-09-01">https://towardsdatascience.com/homebrewing-dbscan-in-python-dcae23f6010?source=collection_archive---------55-----------------------#2020-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e5e7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何实现最具弹性的聚类算法之一的快速指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/213a95b0557881c26a526a1c539259f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gnzte7DlIXYZT1Fr"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马丁·桑切斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f25d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于有噪声应用的基于密度的空间聚类 DBSCAN 是一种很难理解的聚类算法。它创建于 1996 年，经受住了时间的考验，至今仍是对数据点进行聚类的最有用的方法之一。为了好玩，也为了拓宽我的视野，我尝试用 python 编写了自己的 DBSCAN 类。如果你是那种想直接跳到书的结尾的人，你可以在这里看到我的整个项目<a class="ae ky" href="https://github.com/jpeone/dbscan-from-scratch" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="ce20" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">它是如何工作的？</h1><p id="6401" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">DBSCAN 中的聚类是通过根据点与其相邻点的关系将数据点分为三种类型来确定的。三种类型的点是核心点、边界点和噪声点。通过识别核心点、确定其相邻点是核心点还是边界点来形成聚类。当相邻点本身是核心点时，聚类仅扩展到单个点的邻域之外。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/bfb87fa8ff0c884bc59208c852ae9fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*cjsN4pn79HERay-WNhaXIw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者 Chire-Own 作品，CC BY-SA 3.0，<a class="ae ky" href="https://commons.wikimedia.org/w/index.php?curid=17045963" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=17045963</a></p></figure><p id="5c73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑上面的二维点。点 A 是核心点的一个例子。在这种情况下，当总共 4 个点在邻域内时，形成核心点。B 点和 C 点是边界点的例子。边界点可能在核心点的邻域内，但是在它们自己的邻域内总共少于 4 个点。点 N 是噪声点的一个例子。它不属于某个聚类，或者在其邻域中没有足够多的点。</p><h1 id="b962" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">更深刻的理解</h1><p id="a8e2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了充分理解一个问题，我尝试定义一个关键概念的列表，写一些流程的松散伪代码，花一点时间识别时间和空间复杂度。</p><h2 id="9829" class="mt lw it bd lx mu mv dn mb mw mx dp mf li my mz mh lm na nb mj lq nc nd ml ne bi translated">定义</h2><blockquote class="nf ng nh"><p id="8b32" class="kz la ni lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">最小样本-用户定义的最小点数</p><p id="e106" class="kz la ni lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">ε-用户定义的两点之间的距离</p><p id="df5f" class="kz la ni lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">邻域——在ε距离内围绕中心点的空间。</p><p id="1cec" class="kz la ni lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">核心点-在其邻域内具有最小点样本的点。</p><p id="ab75" class="kz la ni lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">边界点-至少属于一个核心点的邻域，但在其自己的邻域内没有点的最小样本的点。</p><p id="e994" class="kz la ni lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">噪声点-既不属于核心点的邻域，也不具有其自身邻域内的点的最小样本的点。</p></blockquote><h2 id="ce52" class="mt lw it bd lx mu mv dn mb mw mx dp mf li my mz mh lm na nb mj lq nc nd ml ne bi translated">伪代码</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">估价</p></figure><h2 id="0fcd" class="mt lw it bd lx mu mv dn mb mw mx dp mf li my mz mh lm na nb mj lq nc nd ml ne bi translated">时间复杂度</h2><p id="e77e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">每个点都与我们数据集中的其他点进行比较，所以我预计时间复杂度为 O(n)。因为我只为每个点添加了两个新的特征，即聚类和点类型，所以我们的空间复杂度是 O(2n)四舍五入到 O(n)。</p><h2 id="e78d" class="mt lw it bd lx mu mv dn mb mw mx dp mf li my mz mh lm na nb mj lq nc nd ml ne bi translated">主要观察结果</h2><p id="2116" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">聚类由核心点的邻域组成。所以我知道我需要一些最近邻搜索功能的修改。下面是我修改过的最近邻搜索的一个片段，我是从自己的类实现中选择的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">距离对于计算一个点的邻域是至关重要的。大多数数据集都有两个以上的要素，您可能希望在聚类时考虑这些要素。因为我想处理 n 维数据点，所以我创建了一个距离辅助方法，以允许我灵活地处理多个距离公式。使用 L2 范数开启了我的邻域法，从严格的二维到完全的多维。</p><h1 id="a8b0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用单元测试定义行为</h1><p id="b143" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当开始任何新代码时，我喜欢设置一组单元测试来帮助定义我的用户契约。当我发现我做的任何不好的假设时，这些可以被修改，但是一般来说，我定义一个测试，然后离开它。这有助于保持我的一致性，并确保我履行我对用户的承诺。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我不能预测用户使用我的类的每一种方式，但我至少可以确定一些我不想让用户做的事情。前三个测试都是关于塑造用法的。第一个确保用户不会用不可能的值或中断的值实例化我的 DBSCAN 类。第二个测试是确保同质数字数据是唯一传入的数据。第三是确保用户在数据传入之前不会试图调用方法。最后，第四个测试是非常基本的功能测试，确保我所做的任何更改都不会破坏基本功能。</p><p id="2389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我实现时，我倾向于同时增加我的单元测试。你可以在这里看到我选择的所有单元测试。</p><h1 id="ee58" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">履行</h1><p id="8e7d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有了定义良好的单元测试和伪代码，这无疑是最快和最容易的部分。如果有一个逻辑问题，就像我的第一次尝试一样，通过失败的测试和伪代码中的大缺口，它变得很明显。在我最初的尝试中，我一直在重写集群，但是由于我最初的基础工作和在投入太多时间之前改变方向，我能够很快地弄清楚。<a class="ae ky" href="https://github.com/jpeone/dbscan-from-scratch/blob/master/cluster/algorithm.md" rel="noopener ugc nofollow" target="_blank">你可以在这里看到对我最初尝试的更深入的报道，以及它的不足之处。</a></p><h1 id="f635" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">估价</h1><p id="1827" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">至此，所有测试都通过了，我自制的 DBSCAN 工作正常。对于实现 MVP 来说，这已经足够好了。但这对我来说永远不够，所以我决定将它与一个流行的、普遍可用的库进行比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1b51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哎唷，这比通常可用的库慢 800 多倍。很难看出这种程度的差异，更不用说公开承认了。但是经过一些研究，我的实现与其他数组索引类型的实现不相上下。我还可以探索其他一些技术来提高 DBSCAN 的性能:空间索引和批量邻域计算。听起来像是后续文章的好主题。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="9290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ni">我的全部实现可以在我的</em> <a class="ae ky" href="https://github.com/jpeone/dbscan-from-scratch" rel="noopener ugc nofollow" target="_blank"> <em class="ni"> Github </em> </a> <em class="ni">上找到。想聊聊吗？在</em><a class="ae ky" href="https://www.linkedin.com/in/jessegenepeone/" rel="noopener ugc nofollow" target="_blank"><em class="ni">Linkedin</em></a><em class="ni">上联系我。</em></p></div></div>    
</body>
</html>