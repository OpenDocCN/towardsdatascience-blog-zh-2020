<html>
<head>
<title>Blazing Fast Data Wrangling With R data.table</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与 R data.table 进行极快的数据争论</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/blazing-fast-data-wrangling-with-r-data-table-de5045cc4b4d?source=collection_archive---------9-----------------------#2020-01-16">https://towardsdatascience.com/blazing-fast-data-wrangling-with-r-data-table-de5045cc4b4d?source=collection_archive---------9-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a52" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">谁有时间用慢代码做数据科学？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9997ec6bc45120a82d7f11fc596ab8c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7LbIDASm2zIi2rtu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="15a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">更新 2020 年 3 月:</em> </strong>在这里你可以找到一个很有意思的<code class="fe lw lx ly lz b">data.table</code>和<code class="fe lw lx ly lz b">dplyr</code> <a class="ae ky" href="https://atrebas.github.io/post/2019-03-03-datatable-dplyr/" rel="noopener ugc nofollow" target="_blank">的对比。</a></p><h1 id="3a4d" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">介绍</h1><p id="3263" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我最近注意到我写的每个 R 脚本都以<code class="fe lw lx ly lz b">library(data.table)</code>开头。这似乎是我写这篇文章的一个非常有说服力的理由。</p><p id="f0ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经看到，随着机器学习社区的发展，Python 获得了巨大的人气，因此，熊猫图书馆自动成为许多人的主食。</p><p id="7334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果我有选择的话，我肯定更喜欢使用 R <a class="ae ky" href="https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html" rel="noopener ugc nofollow" target="_blank"> data.table </a>进行相对较大的数据集数据操作、深入探索和特别分析。为什么？因为它太快了，优雅而美丽(抱歉我太热情了！).但是，嘿，处理数据意味着你必须把代码颠倒过来，塑造它，清理它，也许…嗯…一千次，然后你才能真正建立一个机器学习模型。事实上，数据预处理通常占用数据科学项目 80–90%的时间。这就是为什么我不能承受缓慢而低效的代码(作为一名数据专家，我认为任何人都不应该这样)。</p><p id="e935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们深入了解什么是<code class="fe lw lx ly lz b">data.table</code>以及为什么<a class="ae ky" href="https://www.reddit.com/r/rstats/comments/ca90nk/why_i_love_datatable/" rel="noopener ugc nofollow" target="_blank">许多人</a>成为它的忠实粉丝。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="7eee" class="ma mb it bd mc md ne mf mg mh nf mj mk jz ng ka mm kc nh kd mo kf ni kg mq mr bi translated">1.那么 data.table 到底是什么？</h1><p id="f34d" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lw lx ly lz b">data.table</code> <a class="ae ky" href="https://cran.r-project.org/web/packages/data.table/data.table.pdf" rel="noopener ugc nofollow" target="_blank">包</a>是 r 中<code class="fe lw lx ly lz b">data.frame</code>包的扩展，广泛用于大型数据集的快速聚合、低延迟的列添加/更新/删除、更快的有序连接以及快速的文件读取器。</p><p id="605f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">听起来不错，对吧？你可能觉得很难接，但实际上 a <code class="fe lw lx ly lz b">data.table</code>也是<code class="fe lw lx ly lz b">data.frame</code>的一种。所以请放心，您为<code class="fe lw lx ly lz b">data.frame</code>使用的任何代码也将同样适用于<code class="fe lw lx ly lz b">data.table</code>。但是相信我，一旦你使用了<code class="fe lw lx ly lz b">data.table</code>，你就再也不想使用 base R <code class="fe lw lx ly lz b">data.frame</code>语法了。想知道为什么就继续读下去。</p><h1 id="02aa" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">2.Data.table 非常快</h1><p id="e7d1" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">从我自己的经验来看，使用快速代码确实可以提高数据分析过程中的思维流程。速度在数据科学项目中也非常重要，在这个项目中，你通常必须快速地将一个想法原型化。</p><p id="10e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到速度，<code class="fe lw lx ly lz b">data.table</code>让 Python 和许多其他语言的所有其他包都相形见绌。这个<a class="ae ky" href="https://h2oai.github.io/db-benchmark/" rel="noopener ugc nofollow" target="_blank">基准</a>显示了这一点，它比较了来自 R、Python 和 Julia 的工具。在一个 50GB 的数据集上进行五次数据操作，<code class="fe lw lx ly lz b">data.table</code>平均只用了 123 秒，而 Spark 用了 381 秒，(py)datatable 用了 712 秒，<code class="fe lw lx ly lz b">pandas</code>由于内存不足无法完成任务。</p><p id="b6e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">data.table 包中最强大的函数之一是<code class="fe lw lx ly lz b">fread()</code>，它与<code class="fe lw lx ly lz b">read.csv()</code>类似地导入数据。但它已经过优化，速度快得多。让我们看看这个例子:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="87ee" class="nn mb it lz b gy no np l nq nr">require("microbenchmark")<br/>res &lt;- microbenchmark(<br/>  read.csv = read.csv(url("<a class="ae ky" href="https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data" rel="noopener ugc nofollow" target="_blank">https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data</a>"), header=FALSE),<br/>  fread = data.table::fread("<a class="ae ky" href="https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data" rel="noopener ugc nofollow" target="_blank">https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data</a>", header=FALSE),<br/>  times = 10)<br/>res</span></pre><p id="7789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果将显示，平均而言，<code class="fe lw lx ly lz b">fread()</code>将比<code class="fe lw lx ly lz b">read.csv()</code>函数快 3-4 倍。</p><h1 id="084d" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">3.它直观而优雅</h1><p id="b425" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">几乎所有使用<code class="fe lw lx ly lz b">data.table</code>的数据操作都是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/f444a9fecc52fd6d059fbb8f1e853ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odc8US0simd-2Le1OHwlhw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:https://github.com/Rdatatable/data.table/wiki<a class="ae ky" href="https://github.com/Rdatatable/data.table/wiki" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="db4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，您编写的代码将非常一致且易于阅读。让我们以美国人口普查收入数据集为例进行说明:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="3068" class="nn mb it lz b gy no np l nq nr">dt &lt;- fread("<a class="ae ky" href="https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data" rel="noopener ugc nofollow" target="_blank">https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data</a>", header=FALSE)<br/>names(dt) &lt;- c("age", "workclass", "fnlwgt", "education", "education_num", "marital_status", "occupation", "relationship", "race", "sex", "capital_gain", "capital_loss","hours_per_week", "native_country", "label")</span></pre><p id="4464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我将比较 base R、Python 和 data.table 中的代码，以便您可以轻松地比较它们:</p><ol class=""><li id="443d" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">计算所有“技术支持”人员的平均<em class="lv"/><code class="fe lw lx ly lz b">age</code><em class="lv">:</em></li></ol><p id="b7dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> &gt; </strong>在<strong class="lb iu"> base R </strong>中你大概会写出这样的东西:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="7412" class="nn mb it lz b gy no np l nq nr">mean(dt[dt$occupation == 'Tech-support', 'age'])</span></pre><p id="d586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">&gt;在<strong class="lb iu"> Python </strong>中:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="d667" class="nn mb it lz b gy no np l nq nr">np.mean(dt[dt.occupation == 'Tech-support'].age)</span></pre><p id="3a28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据表</strong>中<strong class="lb iu"> &gt;与</strong>:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="5649" class="nn mb it lz b gy no np l nq nr">dt[occupation == 'Tech-support', mean(age)]</span></pre><p id="fcbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在这个简单的例子中看到的，与 Python 和 base R 相比，<code class="fe lw lx ly lz b">data.table</code>消除了所有重复<code class="fe lw lx ly lz b">dt</code>的冗余。这反过来减少了犯打字错误的机会(记住编码原则 DRY —不要重复自己！)</p><p id="a431" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.到<em class="lv">所有男性工人按职业分类的总年龄</em>:</p><p id="48f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> &gt; </strong>在<strong class="lb iu">基地 R </strong>你大概会写:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="e03f" class="nn mb it lz b gy no np l nq nr">aggregate(age ~ occupation, dt[dt$sex == 'Male', ], sum)</span></pre><p id="361f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">&gt;在<strong class="lb iu"> Python </strong>中:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="d40e" class="nn mb it lz b gy no np l nq nr">dt[dt.sex == 'Male'].groupby('occupation')['age'].sum()</span></pre><p id="da32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据表</strong>中<strong class="lb iu">与&gt;对比</strong>:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="e759" class="nn mb it lz b gy no np l nq nr">dt[sex == 'Male', .(sum(age)), by = occupation]</span></pre><p id="07ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">by =</code>术语定义了您希望在哪个(哪些)列上聚合数据。这种<code class="fe lw lx ly lz b">data.table</code>语法一开始可能看起来有点吓人，但是一旦你习惯了，你就再也不会费心输入“groupby(…)”了。</p><p id="2bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.为了<em class="lv">有条件地修改列中的</em>值，例如将所有技术支持人员的<code class="fe lw lx ly lz b">age</code>增加<code class="fe lw lx ly lz b">5</code>(我知道这是一个愚蠢的例子，但只是为了说明:)。</p><p id="6f08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">&gt;在<strong class="lb iu"> base R </strong>中，你可能不得不写下这可怕的一行(谁有时间写这么多次<code class="fe lw lx ly lz b">dt$</code>！):</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="6fad" class="nn mb it lz b gy no np l nq nr">dt$age[dt$occupation == <!-- -->'Tech-support'<!-- -->] &lt;- dt$age[dt$occupation == <!-- -->'Tech-support'<!-- -->] + 5</span></pre><p id="dcaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">&gt;在<strong class="lb iu"> Python </strong>中(有几个备选方案同样长):</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="2907" class="nn mb it lz b gy no np l nq nr">mask = dt['occupation'] == <!-- -->'Tech-support'<br/>dt.loc[mask, 'age'] = dt.loc[mask, 'age'] + 5</span></pre><p id="8652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者使用<code class="fe lw lx ly lz b">np.where</code>:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="2d10" class="nn mb it lz b gy no np l nq nr">dt['age'] = np.where(<!-- -->dt['occupation'] == <!-- -->'Tech-support', dt.age + 5, dt.age]</span></pre><p id="de2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">&gt;与<strong class="lb iu">数据表</strong>中的比较:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="08fd" class="nn mb it lz b gy no np l nq nr">dt[occupation == 'Tech-support', age := age + 5]</span><span id="b135" class="nn mb it lz b gy oc np l nq nr"># and the ifelse function does just as nicely:<br/>dt[, age := ifelse(occupation == 'Tech-support', age + 5, age)]</span></pre><p id="e184" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这几乎就像一个魔术，不是吗？没有更多繁琐的重复代码，它让你保持干爽。您可能已经注意到了<code class="fe lw lx ly lz b">data.table</code>语法中奇怪的操作符<code class="fe lw lx ly lz b">:=</code>。该操作符用于向现有列分配新值，就像在 Python 中使用参数<code class="fe lw lx ly lz b">inplace=True</code>一样。</p><p id="089f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.<em class="lv">重命名列</em>在 data.table 中轻而易举。如果我想将<code class="fe lw lx ly lz b">occupation </code>列重命名为<code class="fe lw lx ly lz b">job</code>:</p><p id="d30c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">&gt;在<strong class="lb iu"> base R </strong>中，您可以写:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="e802" class="nn mb it lz b gy no np l nq nr">colnames(dt)[which(names(dt) == "occupation")] &lt;- "job"</span></pre><p id="0ec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">&gt;而在<strong class="lb iu"> Python </strong>中:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="8c44" class="nn mb it lz b gy no np l nq nr">dt = dt.rename(columns={'occupation': 'job'})</span></pre><p id="732f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">&gt;相对于<strong class="lb iu">数据表</strong>:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="1e6a" class="nn mb it lz b gy no np l nq nr">setnames(dt, 'occupation', 'job')</span></pre><p id="49a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.如何将函数应用到几列？假设您想将<code class="fe lw lx ly lz b">capital_gain</code>和<code class="fe lw lx ly lz b">capital_loss</code>乘以 1000:</p><p id="7bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">&gt;在<strong class="lb iu">底座 R: </strong></p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="9bf5" class="nn mb it lz b gy no np l nq nr">apply(dt[,c('capital_gain', 'capital_loss')], 2, function(x) x*1000)</span></pre><p id="1cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">&gt;在<strong class="lb iu"> Python </strong>中:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="e7a6" class="nn mb it lz b gy no np l nq nr">dt[['capital_gain', 'capital_loss']].apply(lambda x : x*1000)</span></pre><p id="55df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">&gt;相对于<strong class="lb iu">数据表</strong>:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="02bf" class="nn mb it lz b gy no np l nq nr">dt[, lapply(.SD, function(x) x*1000), .SDcols = c("capital_gain", "capital_loss")]</span></pre><p id="48c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会发现 data.table 中的语法有点古怪，但是<code class="fe lw lx ly lz b">.SDcols</code>参数在许多情况下非常方便，data.table 语法的一般形式就是这样保留下来的。</p><h1 id="377a" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结论:</h1><p id="3cbc" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">从上面几个简单的例子可以看出，R <code class="fe lw lx ly lz b">data.table</code>中的代码在很多情况下比 base R 和 Python 中的代码更快、更干净、更高效。<code class="fe lw lx ly lz b">data.table</code>代码的形式非常一致。你只需要记住:</p><pre class="kj kk kl km gt nj lz nk nl aw nm bi"><span id="3173" class="nn mb it lz b gy no np l nq nr">DT[i, j, by]</span></pre><p id="7e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为补充说明，通过<em class="lv">键入</em>和<code class="fe lw lx ly lz b">data.table</code>使用<code class="fe lw lx ly lz b">i</code>设置数据子集甚至允许更快的子集、连接和排序，你可以在这个<a class="ae ky" href="https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html" rel="noopener ugc nofollow" target="_blank">文档</a>或这个非常有用的<a class="ae ky" href="https://www.beoptimized.be/pdf/R_Data_Transformation.pdf" rel="noopener ugc nofollow" target="_blank">备忘单</a>中了解更多信息。</p><p id="a3c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果你喜欢这篇文章，我会在以后的文章中写更多关于如何与 R 和 Python 进行高级数据辩论的内容。</p></div></div>    
</body>
</html>