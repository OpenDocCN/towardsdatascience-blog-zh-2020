<html>
<head>
<title>How to Search Data with KDTree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 KDTree 搜索数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-search-data-with-kdtree-aad5c82ebd99?source=collection_archive---------38-----------------------#2020-05-09">https://towardsdatascience.com/how-to-search-data-with-kdtree-aad5c82ebd99?source=collection_archive---------38-----------------------#2020-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3516" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">给你一个任务，在一个巨大的数据集中查找某个范围内的数据，你能快速有效地找到它吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/44ec002153f8935c6e7c20db2862f58b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*II5WqfDhXDsopqpV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯托夫·鲁舍夫在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="9619" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">动机</h1><p id="a33e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">想象一下，你记录了你所在地区每天的游客数量。要求你报告从 2 月 2 日到 3 月 2 日的旅客人数。假设这些数据被排序，你<strong class="lt iu">如何在短时间</strong>内找到这个范围内的数据？这是一个范围搜索问题的陈述。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/e77af64977d731872fb125611482491c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*JE7WQ5tn8EjgbPRtX5cwbw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="9348" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这似乎是一个简单的问题。我们能从左到右检查所有数据吗？是的，但是如果我们有大量的<strong class="lt iu">大数据</strong>，这将花费大量的时间，还没有考虑到我们的数据可能是 k 维的<strong class="lt iu"/>。</p><p id="6c6d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这个问题可以像 2D 地图一样推广到二维。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/c3d03e7cef2c23200adcf4e1731362fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*mt89jgz2kkKGWCNXjl63_A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="c63e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们可以将这个空间分成一个规则的网格 MxM，而不是在这个空间中搜索每一厘米。然后确定<strong class="lt iu">完全落在范围</strong>内的单元格和<strong class="lt iu">与范围</strong>相交的单元格。</p><p id="0a7c" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们将<strong class="lt iu">包括完全落在范围</strong>内的单元格的所有数据，并检查所有未完全包括的单元格的单个数据。这种方法的伟大之处在于，我们可以<strong class="lt iu">快速排除不在范围内的数据</strong>并缩小搜索范围。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/817c4318d34586631e163d434e14c766.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*Y1z5VK0eMS3iF5MMaq_i8Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="9963" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">但是，如果我们的数据是不一致的，这意味着在一些地区有数据的<strong class="lt iu">簇</strong>而在其他地区只有很少的数据，那该怎么办呢？</p><ul class=""><li id="4bf7" class="mv mw it lt b lu mo lx mp ma mx me my mi mz mm na nb nc nd bi translated">如果我们选择的网格太少(M 小)，我们将在一个单元格中有许多数据点。性能将接近顺序搜索之一。</li><li id="5fb0" class="mv mw it lt b lu ne lx nf ma ng me nh mi ni mm na nb nc nd bi translated">如果我们选择许多网格(M 大)，我们可能会有太多的空单元格和空间浪费。</li></ul><p id="3190" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">由于在现实生活中，我们经常需要处理像地图这样的非均匀数据，我们需要一种更好的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/712e727adb329f07ad659a7c312a0404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*wnt0vDa2z0sh-BUCUMyIhQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从<a class="ae ky" href="http://achenubis.blogspot.com/" rel="noopener ugc nofollow" target="_blank">阿切努比斯</a>取回</p></figure><p id="0d6f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">当处理如上所述的集群数据时，使用规则的网格会导致糟糕的行为。这就是为什么保持预先分割数据的想法是理想的，但是要根据<strong class="lt iu">数据密度</strong>进行分割！</p><p id="b218" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">一个你可能不知道的小秘密:我将介绍的数据结构是从 sklearn 创建对<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> KNearest 邻居</strong>的健壮性的实现，而不是众所周知的 KNearest 邻居算法的实现。</a></p><h1 id="0323" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">空间划分树</h1><p id="6280" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在考虑 k 维之前，我们先从 2 维开始。我们得到这样的数据点</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/66625671bf9670b6de291ced79e72298.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*_mAtuOBW8LxLSY7XqT9b2w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="b5e6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们将在轴(x 或 y)上的<strong class="lt iu">中值</strong>处分割数据，而不是将数据分割成等宽的网格。我们可以从沿着 y 轴的中间值开始，将平面分成两半。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/b4070c3a3bb9eaf9c4c18a3550edc8e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*k3yv0BPMf8xRmQIMOs9mYg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="3563" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">然后在平面的每一半中，通过选择穿过每个细分中的<strong class="lt iu">中值</strong>的垂直线，继续将细分分成两个相等的细分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/aa1bcdc5f59dc5068cc2b9a2918d853a.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*OC4iIp8ZTqH8mRv58FdgdA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="7a09" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们在两个区域中递归地重复相同的过程，直到在相应的分割元素中不再有点(或者我们决定的点数)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/ff5d86a6404f46d2e1262a71d7d9d6c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*uThvD-9Ozi6WXXzsPl1nqw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="6a4d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">使用这种方法，我们将能够根据数据的密度对其进行分区！那么这个方法的底层数据结构是什么呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/79e2b1693b548c73457370dcef357d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*EuFHDB8vFVG2maGAebRKfw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="5206" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">它与二叉查找树非常相似，但又不完全相同。</p><ul class=""><li id="a935" class="mv mw it lt b lu mo lx mp ma mx me my mi mz mm na nb nc nd bi translated">由于数据首先在 y 轴上拆分，因此 y 是根节点。</li><li id="49db" class="mv mw it lt b lu ne lx nf ma ng me nh mi ni mm na nb nc nd bi translated">子对象是 x，因为每个半平面都在 x 轴上分割。</li><li id="589f" class="mv mw it lt b lu ne lx nf ma ng me nh mi ni mm na nb nc nd bi translated">左侧子树节点的所有 x 值都低于根节点的 x 值。</li><li id="14ac" class="mv mw it lt b lu ne lx nf ma ng me nh mi ni mm na nb nc nd bi translated">右边的子树节点的所有 x 值都高于根节点的 x 值。</li><li id="e4cd" class="mv mw it lt b lu ne lx nf ma ng me nh mi ni mm na nb nc nd bi translated">在两个轴之间交替，直到我们到达极限。</li></ul><h1 id="6f33" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">查找范围内的数据</h1><p id="6648" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">目前为止听起来不错。但是我们如何使用这种数据结构来搜索特定范围内的数据呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/6a4ffc328a1772f88e006c5dae1743d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*jfjzFhvdDI6wVZMjHuw2CQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="474a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">好消息是，一旦我们创建了一个二维树，查找数据就变得简单多了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/448282e102d47c26d877be28621ff1aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*OWa4Awfn21w9lhSDDzef5A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="a075" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们从树根开始访问树节点:</p><ul class=""><li id="3fdb" class="mv mw it lt b lu mo lx mp ma mx me my mi mz mm na nb nc nd bi translated">如果节点在查询范围内<strong class="lt iu">，则将其添加到答案中</strong></li><li id="a0f9" class="mv mw it lt b lu ne lx nf ma ng me nh mi ni mm na nb nc nd bi translated">如果查询的范围<strong class="lt iu">与左子树定义的区域</strong>相交，则探索它</li><li id="c4a1" class="mv mw it lt b lu ne lx nf ma ng me nh mi ni mm na nb nc nd bi translated">如果查询的范围<strong class="lt iu">与左子树定义的区域</strong>相交，则探索它</li></ul><h1 id="4fec" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">KdTree 示例</h1><p id="1038" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设我们有一个 ECOBICI 站点(墨西哥城市自行车公共共享系统)位置的数据集。我们的任务是找到一定范围内的数据。正如我们所看到的，一些地区的站点比其他地区更密集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6da20a6a000075f83a94ac025cfc1f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*_u7wmTMAS3ES5QGfreLJbg.png"/></div></figure><p id="de73" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">要查看如何使用 Kdtree 拆分上面的数据，克隆这个<a class="ae ky" href="https://github.com/khuyentran1401/kdtree-implementation" rel="noopener ugc nofollow" target="_blank"> repo </a></p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="05d1" class="nx la it nt b gy ny nz l oa ob">git clone <a class="ae ky" href="https://github.com/khuyentran1401/kdtree-implementation" rel="noopener ugc nofollow" target="_blank">https://github.com/khuyentran1401/kdtree-implementation</a></span></pre><p id="9e46" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">然后 cd 到本地机器中的 kdtree-implementation 目录并运行</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="8652" class="nx la it nt b gy ny nz l oa ob">python ecobi.py</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/86d2cb940f85b6795f79a01e47716597.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*XoosIkfM79vuRXzJx6_kfA.png"/></div></figure><p id="d590" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">您应该看到上面数据的 kd 树表示。线条越多的区域表示该区域的集群越密集。</p><p id="8b69" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">要查找特定区域的范围，请运行</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="d83c" class="nx la it nt b gy ny nz l oa ob">python findrange.py</span></pre><p id="1594" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">您应该会看到输入范围的提示。假设您在 x 轴上选择了-1 到 1 之间的范围，在 y 轴上选择了-1 到 1 之间的范围，您应该会看到该范围内的数据坐标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/af3bb8b50877c997672bb18244f5750b.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*3ubqpWX4WXsyzsEfejihmg.png"/></div></figure><p id="17ce" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">厉害！使用 KdTree，您可以在几秒钟内找到特定范围内的数据。尽管我们没有介绍如何使用 KdTree 搜索最近点，但是 KdTree 也可以有效地用于 Sklearn 的 KNearestNeighbor。</p><h1 id="f718" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="b6dd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">恭喜你！你已经学习了什么是 KdTree 及其应用。要了解如何实现它并将其用于您的数据，请查看我的<a class="ae ky" href="https://github.com/khuyentran1401/kdtree-implementation" rel="noopener ugc nofollow" target="_blank"> Github repo </a>。</p><p id="fb73" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我喜欢写一些基本的数据科学概念，并尝试不同的算法和数据科学工具。你可以通过<a class="ae ky" href="https://www.linkedin.com/in/khuyen-tran-1401/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae ky" href="https://twitter.com/KhuyenTran16" rel="noopener ugc nofollow" target="_blank"> Twitter </a>与我联系。</p><p id="81f6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">如果你想查看我写的所有文章的代码，请点击这里。在 Medium 上关注我，了解我的最新数据科学文章，例如:</p><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/convex-hull-an-innovative-approach-to-gift-wrap-your-data-899992881efc"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">凸包:包装数据的创新方法</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">如何利用包装算法实现数据可视化</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/how-to-organize-your-data-science-articles-with-github-b5b9427dad37"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">如何用 Github 组织你的数据科学文章</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">被新信息淹没？现在，您可以轻松地跟踪文章并为其创建自定义注释</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/how-to-create-an-elegant-website-for-your-data-science-portfolio-in-10-minutes-577f77d1f693"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">如何在 10 分钟内为您的数据科学产品组合创建一个优雅的网站</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">你需要做的就是编辑</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ow l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/how-to-visualize-social-network-with-graph-theory-4b2dc0c8a99f"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">如何用图论可视化社交网络</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">找出《权力的游戏》中的影响者</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ox l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/how-to-solve-analogies-with-word2vec-6ebaf2354009"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">如何用 Word2Vec 解决类比问题</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">美国之于加拿大，就像汉堡之于 _？</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oy l or os ot op ou ks og"/></div></div></a></div></div></div>    
</body>
</html>