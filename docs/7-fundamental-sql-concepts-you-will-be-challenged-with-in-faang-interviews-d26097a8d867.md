# 下一次编码面试前要掌握的 7 个基本 SQL 概念

> 原文：<https://towardsdatascience.com/7-fundamental-sql-concepts-you-will-be-challenged-with-in-faang-interviews-d26097a8d867?source=collection_archive---------8----------------------->

## [编程](https://towardsdatascience.com/tagged/programming) | [面试](https://towardsdatascience.com/tagged/interviewing) | [办公时间](https://towardsdatascience.com/tagged/office-hours)

## 通过解决取自真实编码面试的 SQL 习题来练习，最终得到你应得的工作。

![](img/da0651e09ec0bb296b9652faf22d96fc.png)

照片由[阿兹哈鲁尔·伊斯拉姆](https://unsplash.com/@azhar93?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

## *我的读者请注意*

*你们中的许多人联系我，要求我提供宝贵的资源来* ***练习更高级的 SQL 概念，以编写面试代码，包括真实的面试问题。*** *下面我分享 4 个我个人推荐的平台/课程:*

*   [***SQL 高级编码问题(StrataScratch)***](https://platform.stratascratch.com/coding?via=antonello)***→****目前为止我找到的准备 SQL 编码面试的最好平台！比 LeetCode 更好更便宜。*
*   [**学习 SQL 进行大数据分析(纳米程度)**](https://imp.i115008.net/e41vB1) **→** *优质课程进行更长期的承诺。*
*   [***SQL 汇总统计&窗口函数(DataCamp)***](https://datacamp.pxf.io/a1ezzR)
*   [***SQL(Data camp)中操作数据的函数***](https://datacamp.pxf.io/7mMVVg)

***>>>****还不是中等成员？考虑与我的* [***推荐链接***](https://anbento4.medium.com/membership) *签约，以获得 Medium 提供的一切服务，费用低至****【5 美元一个月*** *！*

# **停止低估 SQL 面试**

当面试顶级科技公司的数据科学、数据工程或软件工程职位时，很可能技术环节会包括一个或多个现场代码会话，以测试你对 SQL 和你选择的编程语言的了解。

尽管练习用 Python 或 JAVA 来解决算法通常是很费力的，而且可能会占用你大量的时间(*,因为几乎有无限多的问题存在！*)、**FAANG 面试中你要尽量不要低估 SQL 问题的难度**。

[](/10-algorithms-to-solve-before-your-python-coding-interview-feb74fb9bc27) [## Python 编码面试前要解决的 10 个算法

### 在这篇文章中，我介绍并分享了 FAANG 中经常出现的一些基本算法的解决方案

towardsdatascience.com](/10-algorithms-to-solve-before-your-python-coding-interview-feb74fb9bc27) 

科技公司的数据库中存储了大量数据，他们希望应聘者能够使用复杂的 SQL 查询以高效的方式提取和处理数据，然后再进行更高级的分析。由于对这些角色来说，良好的 SQL 知识几乎是理所当然的，所以面试官通常希望你能出色地解决这些挑战“*”并且不太会提示你或忽略明显的错误。*

举一个突出的例子，几年前，一名招聘人员联系我，希望在伦敦一家新兴的电子商务公司谋得一个职位，就在编码屏幕前，他打电话问我对解决定时 SQL 问题有多大信心。我告诉他，作为一名 BI 开发人员，我每天都使用 SQL 来编写复杂的查询，因此我对通过测试充满信心。我至今记得他的回答:

> *“SQL 编码面试可能会变得棘手。你不知道有多少有经验的候选人声称准备好了，然后在这个阶段失败了。”*

就像预言一样，这正是发生在我身上的事情:我通过了 Python 编码筛选，却没有通过 SQL 测试。起初，我感到非常羞愧，我一直对自己说:*“我是一名 BI 开发人员，却没有通过 SQL 面试……你能相信吗？”*。

然而，不久之后，我意识到，在解决*边缘案例*的技术面试中，很多 SQL 问题并不罕见，这些问题在日常工作中并不常见，因此需要特别的准备。

为了帮助您在下一轮现场编码或带回家的定时 SQL 测试中评估自己的准备情况，在下一节课中，我将讨论一些**面试练习问题** ( *和解决方案*)，涵盖以下 7 个基本概念:

*   ***SQL 概念#1 :*** *使用子查询的高级过滤*
*   ***SQL 概念# 2:****HAVING 子句的正确使用*
*   ***SQL 概念#3 :*** *聚合 With CASE WHEN 子句*
*   ***SQL 概念#4 :*** *排名函数的正确使用*
*   ***SQL 概念#5 :*** *正确使用 UNION vs UNION ALL*
*   ***SQL 概念#6 :*** *处理空值*
*   ***SQL 概念#7 :*** *计算累计总和*

[](/6-sql-window-functions-coding-problems-on-ranking-interview-countdown-p1-9be0ccf66453) [## 排名上的 6 个 SQL 窗口函数编码问题——采访倒计时 P1

### SQL 面试即将来临，您正在寻找一些具有挑战性的练习来测试您的准备情况？你是…

towardsdatascience.com](/6-sql-window-functions-coding-problems-on-ranking-interview-countdown-p1-9be0ccf66453) 

# ***SQL 概念# 1:高级过滤***

*编写一个 SQL 查询来报告购买了产品“A”、“B”但没有购买产品“C”的客户的* `*customer_id*` *和* `*customer_name*` *，因为我们想推荐他们购买该产品。返回结果表按* `*customer_id*` *排序。*

```
CUSTOMERS table:
+-------------+---------------+
| customer_id | customer_name |
+-------------+---------------+
| 1           | Daniel        |
| 2           | Diana         |
| 3           | Elizabeth     |
| 4           | Jhon          |
+-------------+---------------+ORDERS TABLE table:
+----------+-------------+--------------+
| order_id | customer_id | product_name |
+----------+-------------+--------------+
| 10       |     1       |     A        |
| 20       |     1       |     B        |
| 30       |     1       |     D        |
| 40       |     1       |     C        |
| 50       |     2       |     A        |
| 60       |     3       |     A        |
| 70       |     3       |     B        |
| 80       |     3       |     D        |
| 90       |     4       |     C        |
+----------+-------------+--------------+Expected OUTPUT Structure:
|Customer_id | Customer_Name
```

# 解决方案:

注意这个查询有多紧凑:它通过利用`WHERE()`子句中的子查询只选择购买了产品 A 和 B 而没有购买 c 的客户，避免了使用多个 cte(*节省了现场编码会话*中的大量输入工作。在过滤时，请记住，如果子查询返回多个值，您可以使用`IN()`或`NOT IN()`运算符来检查成员资格。

# SQL 概念# 2:HAVING 子句的正确使用

编写一个 SQL 查询，报告拥有最多员工的所有项目。

```
PROJECT table:
+-------------+-------------+
| project_id  | employee_id |
+-------------+-------------+
| 1           | 1           |
| 1           | 2           |
| 1           | 3           |
| 2           | 1           |
| 2           | 4           |
+-------------+-------------+EMPLOYEE table:
+-------------+--------+------------------+
| employee_id | name   | experience_years |
+-------------+--------+------------------+
| 1           | Khaled | 3                |
| 2           | Ali    | 2                |
| 3           | John   | 1                |
| 4           | Doe    | 2                |
+-------------+--------+------------------+Expected OUTPUT Structure:
|project_id|
```

# 解决方案:

问题基本上是要求返回涉及*最多*名员工的项目。为了实现这一目标:

*   首先创建一个子查询，以便在按`project_id`分组时只检索最大数量的雇员(`LIMIT 1`)，
*   然后结合使用`HAVING()`子句和`COUNT(DISTINCT)`函数来过滤主查询，以便只选择在子查询中找到的雇员数量最多的项目。

如您所见，当涉及某种聚合时，`HAVING()`应该用于过滤数据集(*准备好解释* `HAVING()`和`WHERE()` *之间的区别，因为这是一个非常受欢迎的问题，特别是对于入口角色*)。

# SQL 概念# 3:聚合时的情况

*编写一个 SQL 查询来重新格式化表格，这样每个月都有一个* `*department_id*` *列和一个* `*revenue*` *列。结果表应该有 13 列(1 列表示部门 id + 12 列表示月份)。*

```
DEPARTMENT table:
+------+---------+-------+
| id   | revenue | month |
+------+---------+-------+
| 1    | 8000    | Jan   |
| 2    | 9000    | Jan   |
| 3    | 10000   | Feb   |
| 1    | 7000    | Feb   |
| 1    | 6000    | Mar   |
+------+---------+-------+Expected OUTPUT Structure:
|id | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... |
```

## 解决方案:

在某些情况下，面试官希望测试你处理数据的能力，例如，会要求你通过水平扩展来取消旋转表格。对于这个问题，我们的目标是去掉`month`维度，创建与月数一样多的事实列。这可以很容易地通过使用一个`CASE WHEN()`子句来识别特定的月份并生成新的聚合列来实现。

# SQL 概念# 4:排名函数的使用

*编写一个 SQL 查询，为每个客户返回第二早的* `*order_id*` *，每个日期他们至少下了两个订单。*

```
Extract from ORDERS table
+------------+--------------+----------------------+------------ +
| order_id   | customer_id  |    order_datetime    |   item_id   |
+------------+--------------+----------------------+-------------+
| C-001      |    62456     | 2018-12-15 09:15:22  |    A000     | 
| C-005      |    21376     | 2019-01-14 09:28:35  |    A001     | 
| C-005      |    88956     | 2019-01-14 09:28:35  |    A005     |
| C-006      |    42491     | 2019-01-14 03:53:08  |    A008     |
+------------+--------------+----------------------+-------------+Expected Output Structure:
Customer_id | Order_date | Second_order_id
```

## 解决方案:

涉及使用排名函数(*和一般窗口函数*)的问题在 SQL 技术回合中极为常见。例如，在这种情况下，`RANK() OVER()`函数用于通过`customer_id`和`order_date`对分区中的每个订单进行排序。注意分区是如何使用`order_date`的，而等级是通过`order_datetime`以升序排列的。这样，第一个订单将得到`order_rank = 1`，第二个最早的订单将得到`order_rank = 2`。然后使用`WHERE order_rank = 2`子句只保留第二早的订单。上面的过滤器会自动排除客户下少于两个订单的日期，因此无需添加任何其他内容。

[](/8-popular-sql-window-functions-replicated-in-python-e17e6b34d5d7) [## Python 中复制的 8 个流行的 SQL 窗口函数

### 关于如何利用业务分析中的 Pandas 高效复制最常用的 SQL 窗口的教程…

towardsdatascience.com](/8-popular-sql-window-functions-replicated-in-python-e17e6b34d5d7) 

# SQL 概念 5:UNION 与 UNION ALL 的使用

*写一条 SQL，求出 2019–08–16 所有产品的价格，假设修改前所有产品价格都是 10。*

```
# PRODUCTS table:
+------------+-----------+-------------+
| product_id | new_price | change_date |
+------------+-----------+-------------+
| 1          | 20        | 2019-08-14  |
| 2          | 50        | 2019-08-14  |
| 1          | 30        | 2019-08-15  |
| 1          | 35        | 2019-08-16  |
| 2          | 65        | 2019-08-17  |
| 3          | 20        | 2019-08-18  |
+------------+-----------+-------------+Expected Output Structure:
product_id | price
```

# 解决方案:

这个问题有点挑战性:它要求您识别每个`product_id`在*2019–08–16*的最近价格变化。如果某个产品的价格仅在该日期后发生变化，您应该假设*2019–08–16*的价格为 10。为此，您可以应用上述问题中介绍的两个概念:

*   首先，您可以使用`DENSE RANK()`函数来查找每种产品在*2019–08–16 的最新价格变化。* `DENSE_RANK()`函数在分区中分配连续的等级，因此没有出现平局然后重复的风险。*该数据集不包括在阈值日期后发生价格变化的产品。*
*   然后，您可以创建第二个数据集，包括 2019 年 8 月 16 日之后发生最早价格变化的所有产品，并将它们的价格设置为 10。为了实现这一点，请注意带有`MIN()`函数的`HAVING()`子句的使用。
*   最后一步是用`UNION ALL`连接两个数据集，这样所有的`product_id`都会出现在解决方案中。

如果被问到，请记住`UNION ALL`比`UNION`更有效、更快，原因是第一个操作符不会检查重复值。

# SQL 概念# 6:处理空值

*编写一个 SQL 查询，查找在过去 7 天内每个类别订购了多少台。考虑总共七个日历日期，包括今天。还要考虑所有品类，甚至是零订单的品类。*

```
Extract from ORDERS table:
+------------+----------------------+------------------------------+
| order_id   | order_datetime       |   item_id   | order_quantity |
+------------+----------------------+------------------------------+
| C-001      | 2018-12-15 09:15:22  |    A000     |       5        |
| C-005      | 2019-01-14 09:28:35  |    A001     |       1        |
| C-005      | 2019-01-14 09:28:35  |    A005     |       1        |
| C-006      | 2019-01-14 03:53:08  |    A008     |       3        |
+------------+--------------+---------------------+----------------+Extract from ITEMS table:
+-------------+---------------+
| item_id     | item_category |
+-------------+---------------+
| A000        | Outdoors      |
| A001        | Outdoors      |
| A002        | Outdoors      |
| A003        | Kitchen       |
| A004        | Kitchen       |
+-------------+---------------+Expected Output Structure:
Category | Units
```

# 解决方案:

这个问题需要找到每个类别的*和每个*类别的*的总单位数，这意味着在这种情况下`items`表应该被用作前导表，并与`orders`保持连接，以保留所有的`item_category`值，甚至是那些与从未订购的项目相关联的值。一般来说，当你在真实的面试问题中读到单词 *"each"* 和 *"every"* 时，你可能需要对连接和一些空值采取一些行动，这些需要在过滤器中处理(`OR o.item_id IS NULL`)*

# SQL 概念# 7:计算累积和

*编写一个 SQL 语句来获得一个雇员三个月的工资总额，但不包括最近一个月。结果应该按“Id”升序显示，然后按“Month”降序显示。*

```
EMPLOYEE table:| Id | Month | Salary |
|----|-------|--------|
| 1  | 1     | 20     |
| 2  | 1     | 20     |
| 1  | 2     | 30     |
| 2  | 2     | 30     |
| 3  | 2     | 40     |
| 1  | 3     | 40     |
| 3  | 3     | 60     |
| 1  | 4     | 60     |
| 3  | 4     | 70     |
+---------------------+Expected Output Structure:
id | month | salary
```

在 SQL 技术访谈中，被要求计算累计总和是一个非常经典的问题，因此对于这个问题，我提供了两个潜在的解决方案。

# 解决方案 1:

在这种情况下，`ROW_NUMBER()`函数用于识别和排除支付给每个雇员的最后一笔工资。一旦排除了最后一笔工资，就会对前三行进行累计求和(`SUM() OVER()`)。

# 解决方案 2:

在这个备选解决方案中，不是使用窗口函数来对月工资进行排序，而是通过编写一个查找并排除每个雇员最近一个月(`MAX(month)`)工资支付(`WHERE e1.id = e2.id`)的子查询来过滤掉最后一笔工资。然后，与解决方案 1 完全一样地计算累积和。

# **结论**

在这篇文章中，我提出了 7 个基本的 SQL 概念，您应该在下一次 FAANGs 技术面试之前掌握它们。我希望你在下一个 SQL 编码屏幕或定时测试中使用上面的问题进行练习。

涉及日期转换的解决方案使用 PostgreSQL 作为语法(*以节省一点打字……*)，但可以很容易地转换成 MySQL。我的解决方案也只是每个问题的潜在解决方案之一，所以请在评论中分享你的解决方案。请注意，本文中出现的所有 SQL 问题都摘自[*leet code*](https://leetcode.com/problemset/all/)*，其中混合了官方问题和订户在讨论区*中直接报告的问题。

给我的读者一个提示:这篇文章包含了附属链接，如果你购买的话，我可以免费给你一点佣金。