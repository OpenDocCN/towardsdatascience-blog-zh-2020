<html>
<head>
<title>Pandas — Save Memory with These Simple Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫——用这些简单的技巧节省记忆</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-save-memory-with-these-simple-tricks-943841f8c32?source=collection_archive---------14-----------------------#2020-04-27">https://towardsdatascience.com/pandas-save-memory-with-these-simple-tricks-943841f8c32?source=collection_archive---------14-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5b72" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在内存使用方面更高效地使用熊猫</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f18febb37defe750984f05e6cfd03cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ZkK00dGBsUm2gIvlAaeZg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@danielkcheung?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">张家瑜</a>在<a class="ae ky" href="https://unsplash.com/s/photos/small?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="2760" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理小型数据时，内存不是一个大问题。然而，当涉及到大型数据集时，有效地使用内存就变得势在必行。我将介绍一些非常简单的技巧来减小熊猫数据帧的大小。我将使用Kaggle上关于<a class="ae ky" href="https://www.kaggle.com/jessevent/all-crypto-currencies" rel="noopener ugc nofollow" target="_blank">加密货币市场</a>价格的相对较大的数据集。让我们从将数据读入熊猫数据帧开始。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1686" class="ma mb it lw b gy mc md l me mf">import pandas as pd<br/>import numpy as np</span><span id="0885" class="ma mb it lw b gy mg md l me mf">df = pd.read_csv("crypto-markets.csv")<br/>df.shape<br/>(942297, 13)</span></pre><p id="0f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据帧有将近一百万行和13列。它包括加密货币的历史价格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/be3adfeee571bb3655619fe92f605eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bg3Q6MspG6dKxcczZGEUmQ.png"/></div></div></figure><p id="e073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下这个数据帧的大小:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f118" class="ma mb it lw b gy mc md l me mf">df.memory_usage()<br/>Index               80<br/>slug           7538376<br/>symbol         7538376<br/>name           7538376<br/>date           7538376<br/>ranknow        7538376<br/>open           7538376<br/>high           7538376<br/>low            7538376<br/>close          7538376<br/>volume         7538376<br/>market         7538376<br/>close_ratio    7538376<br/>spread         7538376<br/>dtype: int64</span></pre><p id="e5d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">memory_usage()返回每行使用多少内存(以字节为单位)。我们可以通过几个数学运算来检查完整数据帧的内存使用情况，单位为兆字节:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ec6e" class="ma mb it lw b gy mc md l me mf">df.memory_usage().sum() / (1024**2) #converting to megabytes<br/>93.45909881591797</span></pre><p id="7c3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以总大小是93.46 MB。</p><p id="431c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下数据类型，因为在某些情况下，我们可以用更易于存储的数据类型来表示相同数量的信息。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9365" class="ma mb it lw b gy mc md l me mf">df.dtypes<br/>slug            object<br/>symbol          object<br/>name            object<br/>date            object<br/>ranknow          int64<br/>open           float64<br/>high           float64<br/>low            float64<br/>close          float64<br/>volume         float64<br/>market         float64<br/>close_ratio    float64<br/>spread         float64<br/>dtype: object</span></pre><p id="048c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先想到的应该是“对象”数据类型。如果我们有分类数据，最好使用“类别”数据类型而不是“对象”,尤其是当类别的数量与行数相比非常低的时候。“slug”、“symbol”和“name”列就是这种情况:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="be78" class="ma mb it lw b gy mc md l me mf">df.slug.value_counts().size<br/>2071</span></pre><p id="4036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有2072个类别，相对于100万行是非常低的。让我们将这些列转换为“category”数据类型，并查看内存使用的减少情况:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="785d" class="ma mb it lw b gy mc md l me mf">df[['slug','symbol','name']] = df[['slug','symbol', 'name']].astype('category')</span><span id="d2d4" class="ma mb it lw b gy mg md l me mf">df[['slug','symbol','name']].memory_usage()<br/>Index          80<br/>slug      1983082 #previous: 7538376<br/>symbol    1982554<br/>name      1983082<br/>dtype: int64</span></pre><p id="a4a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此每列的内存使用减少了%74。让我们看看我们总共存了多少钱:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="395c" class="ma mb it lw b gy mc md l me mf">df.memory_usage().sum() / (1024**2) #converting to megabytes<br/>77.56477165222168</span></pre><p id="2f63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总大小从93.46 MB减少到77.56 MB。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="1bb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“ranknow”列显示不同货币类别之间的排名。既然有2072个类别，那么最大值应该是2072。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="93ac" class="ma mb it lw b gy mc md l me mf">df.ranknow.max()<br/>2072</span></pre><p id="bcee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“ranknow”列的数据类型是int64，但是我们也可以使用int16表示从1到2072的范围。int16可以表示的范围是-32768到+32767。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="722a" class="ma mb it lw b gy mc md l me mf">df["ranknow"] = df["ranknow"].astype("int16")</span><span id="706a" class="ma mb it lw b gy mg md l me mf">df["ranknow"].memory_usage()<br/>1884674 #previous: 7538376</span></pre><p id="179c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们从int64降低到int16，所以内存使用如预期的那样减少了%75。</p><p id="4004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据集中的浮点数用“float64”表示，但我可以用“float32”表示这些数字，这样我们就可以有6位数的精度。我认为6位数就足够了，除非你是在做高灵敏度的测量。</p><ul class=""><li id="46fd" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated">float32(等效C类型:float): 6位精度</li><li id="2527" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">float64(等效C类型:double): 15位精度</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="13c7" class="ma mb it lw b gy mc md l me mf">floats = df.select_dtypes(include=['float64']).columns.tolist()</span><span id="6d20" class="ma mb it lw b gy mg md l me mf">df[floats] = df[floats].astype('float32')</span><span id="00a5" class="ma mb it lw b gy mg md l me mf">df[floats].memory_usage()<br/>Index               80<br/>open           3769188 #previous: 7538376<br/>high           3769188<br/>low            3769188<br/>close          3769188<br/>volume         3769188<br/>market         3769188<br/>close_ratio    3769188<br/>spread         3769188<br/>dtype: int64</span></pre><p id="8b81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从“float64”到“float32”的转换如预期的那样将这些列的内存使用量减少了%50。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/5cff5badf9278098d8d5715e76e01a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*0pQNc-3hsbfg9ubE0KHcwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">float32有6位精度</p></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="b1a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，数据帧可能有冗余列。让我们看一下现有的数据框架:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/bfe76876eb5c37993fbc6d1898518bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_Len-pMMxCbfX7fRgkVTw.png"/></div></div></figure><p id="4958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“slug”、“symbol”、“name”等栏目以不同的格式表示同一事物。这三列中只有一列就足够了，所以我可以删除两列。您拥有的数据帧可能没有这样的列，但寻找冗余或不必要的列总是一个好的做法。例如，数据帧可能包括“计数”、“值”和“总和”列。我们可以很容易地获得总数乘以计数和值，所以总和列是不必要的。有些列可能与你想完成的任务完全无关，所以只需寻找这些列。在我的例子中，我将删除“符号”和“名称”列，并使用“slug”列:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c67f" class="ma mb it lw b gy mc md l me mf">df.drop(['symbol','name'], axis=1, inplace=True)</span></pre><p id="1868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查最终数据帧的大小:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3a1b" class="ma mb it lw b gy mc md l me mf">df.memory_usage().sum() / (1024*1024)<br/>39.63435745239258</span></pre><p id="48a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总大小从93.46 MB减少到36.63 MB，我认为这是一个伟大的成就。我们能够节省56，83 MB的内存。</p><p id="42ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">减小尺寸的另一个优点是简化计算。使用float32进行计算比使用float64花费的时间少。</p><p id="0154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该尽可能地寻找减小尺寸的方法。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="7d69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>