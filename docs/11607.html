<html>
<head>
<title>Columnar Stores — When/How/Why?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">柱状商店——何时/如何/为什么？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/columnar-stores-when-how-why-2d6759914319?source=collection_archive---------1-----------------------#2020-08-12">https://towardsdatascience.com/columnar-stores-when-how-why-2d6759914319?source=collection_archive---------1-----------------------#2020-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d5c4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">揭开行与列大数据存储的神秘面纱(Parquet、Postgres、Avro 等)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/49a204a3fb7261f8b84fe53f32a12308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dr4Mo2OLLctBUUhU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@skylergeraldphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Skyler Gerald </a>拍摄</p></figure><p id="f8b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很久以前，数据存储很简单——堆文件和 b 树，仅此而已。今天的选择是压倒性的——ORC、Parquet、HDFS 或 S3 上的 Avro 或者像 Postgresql、MariaDB 这样的 RDBMS 解决方案，或者像 Oracle 和 DB2 这样的商业解决方案。甚至在 RDBMS 引擎和云服务中也有很多选择！</p><p id="ce1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本指南是对广阔的存储领域的“随机漫步”。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eed1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">样本数据集</strong></h1><p id="2616" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我调出了芝加哥公务员的工资信息。你知道公务员的工资是以每个人的真实姓名公布的吗？查找你最喜欢的警察或专员的工资(不幸的是，它不包括加班、津贴或贿赂)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/3ef9f088b256b13138425837337a7475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSurpF9FD3LMuZNCu0hwLw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我添加了一些虚拟的人——Foo &amp; Bar 家族。否则它的真实数据。</p></figure><h1 id="4183" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">面向列与面向行</h1><p id="fd56" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先是数据的基本存储机制。<em class="nf">行列</em>方向。</p><p id="e4bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">面向行</strong>将每个单独的记录存储在一起，Doug Foo 的完整记录，然后是 Jane Foo 的完整记录，依此类推。</p><blockquote class="ng nh ni"><p id="c9f8" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">[Doug，Foo，Foostack，程序员，M，120000] [Jane，Foo，Foostack，程序员，F，110000] [Doug，Bar，…]..</p></blockquote><p id="f1a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">列</strong>或<strong class="lb iu"> <em class="nf">列</em> </strong>将所有列数据存储在一起—因此所有的名字(Doug、Jane 等)，然后是所有的姓氏、头衔等等，最后是所有的薪水。</p><blockquote class="ng nh ni"><p id="7724" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">[道格、简、道格、简……][福、福、吧、吧……][程序员、程序员……][M、F、M、F……][120000、110000、100000、130000……]..</p></blockquote><p id="0ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据通常以 KB(或 MB/GB)为单位从磁盘中读取，因此对 1 条记录的单次读取会带来比您想要的更多的数据。</p><h2 id="e735" class="nm md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">典型块大小[*1]:</h2><ul class=""><li id="e8b6" class="ny nz it lb b lc mu lf mv li oa lm ob lq oc lu od oe of og bi translated">HDFS: 128MB(块)</li><li id="408a" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">谷歌文件系统:64MB(块)</li><li id="2593" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">亚马逊 AWS S3: 128KB</li><li id="c328" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">Oracle 数据仓库:32KB</li><li id="143e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">Postgres 数据库:8KB</li><li id="a4f0" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">Linux 和 Windows 文件系统:4KB</li></ul><p id="aeb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">薪水记录非常小~ 50chars ( &lt;50 bytes). An 8KB block with metadata could easily store 100+ <strong class="lb iu"> <em class="nf">行导向</em> </strong>记录【8192 / 50 = 163】)。因此，对包含“Doug Foo”的记录的块的一次读取包括更多内容。</p><p id="b0d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<strong class="lb iu">列</strong>块读取—读取因列大小而异。例如，对于 8KB 数据块:</p><ul class=""><li id="12c1" class="ny nz it lb b lc ld lf lg li om lm on lq oo lu od oe of og bi translated">名字可能平均为 10 个字节，意味着大约 800 个以上的名字。</li><li id="10d5" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">薪水可以放入一个 32 位的 Int(4 字节)中，产生大约 2000 个条目！</li><li id="08cf" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">性别是 M/F/？—可以存储为 1 个字节，甚至半个半字节~ 8000！</li></ul><p id="79f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们稍后进行更多分析时，记住这一点非常重要。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f9ca" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据转换</h1><p id="7126" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我想添加一个 M/F 属性，所以我合并到一个婴儿名字数据库中，然后写出各种熊猫支持的格式(JSON、CSV 和 Parquet)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本熊猫性别数据</p></figure><p id="dec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意同等磁盘格式的文件大小差异</strong> <em class="nf"> (38k 记录)</em> <strong class="lb iu"> : </strong></p><ul class=""><li id="728e" class="ny nz it lb b lc ld lf lg li om lm on lq oo lu od oe of og bi translated"><strong class="lb iu">不带头文件的 CSV </strong>为 2.526 MB</li><li id="4e6b" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">压缩后的拼花</strong>(柱状)为 606 KB(CSV 的 1/4)</li><li id="79ae" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu"> JSON </strong>为 4.615 MB(比 CSV 大 90%，比 Parquet 大 700%)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/1cb622961f2710062ad02dbb19b9d94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6yliuukdg3BAt7alck000g.png"/></div></div></figure><p id="8436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">拼花地板</strong>是一种二进制压缩格式，因此需要一些努力来快速浏览——稍后将讨论细节。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/2f53a801f0b8fee2b7ac2f580aab316c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTDK_poS9oPDRtvFZPvsuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">注意一些奇怪的事情，它只显示了道格和简一次，尽管我们有两个道格和两个简。名字聚集在一起。</p></figure><h1 id="52c0" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">为什么不存储为 CSV 或 JSON？</h1><p id="e534" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">显而易见，但让我们把它拼出来:</p><ul class=""><li id="b95c" class="ny nz it lb b lc ld lf lg li om lm on lq oo lu od oe of og bi translated">空间利用率差(字符串形式的数字浪费空间)</li><li id="2b68" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">没有类型或结构检查(字符可能会出现在数字字段中)</li><li id="a2d8" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">CSV —无元数据/标题信息，JSON —重复的元/格式</li><li id="5efb" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">没有重复值的本机压缩</li><li id="dda8" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">没有本地索引/搜索能力</li></ul><p id="3823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意 CSV 和 JSON 具有非常容易阅读的明显优势，因此有时是很好的交换格式。</p><h1 id="f8ca" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">深入探究 Postgres 格式(RDBMS)</h1><p id="bd64" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Postgres 是一个全功能的开源数据库，既有传统的基于行的存储(有时称为“堆文件”)，也有列存储扩展(cstore_fdw)。</p><p id="84a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了一个模式并将工资数据加载到两个变量中，一个是标准的行和列版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="95cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询 38k 记录时两者之间的一些基本统计/比较:</p><ol class=""><li id="2bad" class="ny nz it lb b lc ld lf lg li om lm on lq oo lu ot oe of og bi translated"><strong class="lb iu">选择计数(*) </strong> →列存储略快(7.9 毫秒对 10.9 毫秒)，并且“成本”较低(480 毫秒对 873 毫秒)(假设这是估计操作/读取的指标)。理论上，我们使用列存储读取<strong class="lb iu">少于<em class="nf">的</em>块，因为您只需要扫描一列来获得计数，并且它是压缩的。</strong></li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/77090a692cd3fe74e5582734262e44c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yodPRwJvGXRWwqUGl1Zwcw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">count(*)测试，只是在列上快一点</p></figure><p id="f745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<strong class="lb iu"> Select sum(salary) </strong> →这应该是柱形图的一个经典案例，我们只需要扫描一列或一系列块，而基于行的需要扫描所有块，以便从每行中提取薪金。但是没有我们预期的那么快。成本便宜了 493 vs 873，但是计时是 14.1ms vs 17.1ms。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/bfc2d88b1676ed032966f2d1e2f07ea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-PeWZ8Owt7vUIi5JtrnJw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">38k 行，即使在一个单独的列上，速度也快不了多少。</p></figure><p id="51ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<strong class="lb iu">更大的数据集— </strong>我将它提升到 380 万行，并重新运行 sum 查询。变化不大——有点令人惊讶！理论上，这应该比 20-30%的涨幅要快得多。其实柱状往往是缓存 生效后<strong class="lb iu"> <em class="nf">变慢！(公平地说，您确实需要比您的内存缓存更大的 GB 到 TB 数据集才能获得真正的收益)<strong class="lb iu"> [*2] </strong>。</em></strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/7c9c4f64469b4898301a5b0e85b59467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4odu1nhh3gdw3C93i-k2Sw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">3.8 米的行，还是没有快很多。</p></figure><p id="056d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在阅读了一些<a class="ae ky" href="https://github.com/citusdata/cstore_fdw/issues/75" rel="noopener ugc nofollow" target="_blank"> bug </a>报告和开发者<a class="ae ky" href="https://www.citusdata.com/blog/2014/06/14/columnar-store-benchmarks-ssds/" rel="noopener ugc nofollow" target="_blank">笔记</a>之后，我可以猜测作为一个扩展，它不如标准行存储健壮。例如，本机行格式提供多核处理和缓冲区缓存。我可能应该与本地列存储数据库进行比较…</p><p id="ac94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意我加载 3.8m 行时的文件大小:</p><ul class=""><li id="f530" class="ny nz it lb b lc ld lf lg li om lm on lq oo lu od oe of og bi translated">标准行格式:<strong class="lb iu"> 321 MB </strong></li><li id="f4ae" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">柱状/压缩格式:<strong class="lb iu"> 72 MB </strong></li></ul><p id="e435" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">巨大的空间节省(几乎 4 倍)！注意磁盘上的行和列的原始数据转储(在 linux/wsl2 上使用“xxd -c 32”):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/e1537ffad736ff8e0526cac93e031e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_VRXXAToI95xSIPzwQr15g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">行方向非常简单</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/d7c0e76b4d6d2871f13f691f2306a51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_dLf9QP0OHQ02bdydU6HQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">纵列由带有压缩子串的纵列展开</p></figure><h1 id="a4b5" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">镶木地板——最受欢迎的？</h1><p id="3f53" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Parquet 来自 Twitter 和 Cloudera (Hadoop ),作为 Apache 项目维护。这是 Spark 的实际格式，因此最受欢迎。(之前流行的格式包括 ORC 和 RCFile)。</p><p id="283b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python/Pandas 本身也支持它，并提供多种压缩格式。基本的文件格式是一个由行组成的列，存储一个中央模式&amp;组级元数据，以允许并行和部分读取。</p><p id="f69f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对原始文件的适度深入研究显示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/1002f0f5cbaca46af29d11b0538072c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PN9q1NBXZfwqfAGZpa8v_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类似于 Postgres CStore —列被分批分组并压缩，这样 Doug，Jane 在整个文件中只出现一次。</p></figure><h1 id="b14e" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">AVRO —面向行的模式进化</h1><p id="c729" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与 Parquet 竞争激烈的是 Avro，它不仅仅是一种存储格式，但我们将只关注存储方面。这也是一个 Apache 项目。<strong class="lb iu"> [*3] </strong>拼花地板的两个主要区别:</p><ol class=""><li id="e545" class="ny nz it lb b lc ld lf lg li om lm on lq oo lu ot oe of og bi translated">更好的模式进化</li><li id="7cf4" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu ot oe of og bi translated">面向行的存储</li></ol><p id="afd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模式和更改(新行和旧行的默认值)嵌入到文件中。添加新列只需要定义默认值，这使得渐变维度(SCD)和更改更容易处理。</p><p id="76b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，它是面向行的，因此您不会获得像使用 Parq 那样的一些优势，例如压缩和性能——假设您的用例更多地是关于列聚合，而不是逐记录处理。</p><p id="b662" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Avro 代码和数据文件示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/6bcad9c590b7ec4f33b219eb6bbf8718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_0QJtOGLMmPITMYUkWcLw.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0ac6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">其他存储选项(MongoDB、Kafka、KDB 等)</h1><p id="a526" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><strong class="lb iu"> NoSQL — </strong>像 MongoDB、AWS Dynamo 和 Cassandra 这样的名值对象存储通过不同的键存储整个 JSON(或任意)对象。该 API 使用基本的键值存储(put/get)语义，非常简单。高水平+/-:</p><ul class=""><li id="f0dd" class="ny nz it lb b lc ld lf lg li om lm on lq oo lu od oe of og bi translated">+简单的编程接口</li><li id="17f8" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">+快速启动并运行您的应用</li><li id="9e6a" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">-加载多个或复杂数据的效率低下</li><li id="0c11" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">-索引和查询/搜索不灵活</li><li id="06bb" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">-模式演变挑战</li></ul><p id="c21f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">日志结构化商店(和日志结构化合并树)</strong>和它们的创新用途是一个迷人的领域——<strong class="lb iu">卡夫卡</strong>是领导者和创新者(不要被愚弄了，它不仅仅是消息传递，它真正关于<a class="ae ky" href="https://www.confluent.io/ebook/i-heart-logs-event-data-stream-processing-and-data-integration/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="nf">日志</em></strong></a><strong class="lb iu"><em class="nf"/></strong><em class="nf">根据联合创作者 Jay Kreps </em>。<strong class="lb iu"> [*4] </strong></p><ul class=""><li id="4207" class="ny nz it lb b lc ld lf lg li om lm on lq oo lu od oe of og bi translated">+简单的编程接口</li><li id="65a8" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">+实时消息存储和数据库的可扩展替代方案</li><li id="4a64" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">-复杂的集群管理</li></ul><p id="970d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">最后，KDB </strong>值得一提，他是列式、实时和时序内存数据库的先驱。最初编写于 90 年代，即使在今天也拥有无与伦比的单核性能。不幸的是，这是一种昂贵的利基产品，因此最近被出售给一级衍生品，很可能会失血而死…</p><ul class=""><li id="d79e" class="ny nz it lb b lc ld lf lg li om lm on lq oo lu od oe of og bi translated">+超快和低占用空间(800kb)适合 L1/L2 缓存</li><li id="8af3" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">+利用矢量/SIMD CPU 指令</li><li id="5fdf" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">-不超过 1 台机器(不需要？)</li><li id="b28e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">-成本和晦涩的语言(K/Q)使大多数消费者望而却步。</li></ul><p id="6f0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Apache Arrow(内存列格式和串行器)和 OLAP 理工大学也是值得研究的两个领域。</p><h1 id="8181" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated"><strong class="ak">总结:首要考虑事项</strong></h1><ol class=""><li id="75df" class="ny nz it lb b lc mu lf mv li oa lm ob lq oc lu ot oe of og bi translated">列式是否适合您的典型用例(在几列上频繁聚合)？</li><li id="7b51" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu ot oe of og bi translated">您现有的数据库是否提供像列存储这样的存储选项？</li><li id="d818" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu ot oe of og bi translated">模式演变/改变是常见的，也是一个关键的考虑因素吗？</li><li id="2671" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu ot oe of og bi translated">存储空间/容量是一个关键考虑因素吗？</li></ol><p id="b4da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仔细考虑一下，试运行一下。关系数据库在缓存和索引方面已经有了很大的改进，这在某些情况下可能会降低其必要性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="04e4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">参考资料、脚注和灵感</strong></h1><ul class=""><li id="cb5f" class="ny nz it lb b lc mu lf mv li oa lm ob lq oc lu od oe of og bi translated">对于文件系统/操作系统、数据库和大数据存储，如 S3/GFS，块大小在概念上是不同的。在每种情况下，它都是一个逻辑单元。AWS EBS 使用 4K，S3 是一个对象存储，但它的最小分配是 128KB。</li><li id="733b" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">【2】-</strong>列性能仅在冷启动/清除缓存时更快。一旦数据库填满了它的缓存，Postgres 上的传统行存储总是更快。但是，列存储适用于大数据~TB 大小的数据集，这些数据集大于内存，会表现出冷缓存行为。</li><li id="4585" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">【3】</strong>——更混乱的是，Avro 的序列化代码可以写入 Parquet 文件格式。它既是竞争对手，也是合作者。</li><li id="298c" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">【4】</strong>——大多数人认为 Kafka 只是下一个 MQ，但它是一个根本不同的方法，以<strong class="lb iu">提交/事务日志</strong>为中心，这是一个伪数据库。</li><li id="5c1b" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">Postgres c store</strong>——【https://github.com/citusdata/cstore_fdw T2】</li><li id="5edb" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">Parquet 上的好读物</strong>—<a class="ae ky" href="https://medium.com/swlh/insights-into-parquet-storage-ac7e46b94ffe" rel="noopener">https://medium . com/swlh/insights-into-Parquet-storage-AC 7 e 46 b 94 FFE</a></li><li id="6556" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">Avro</strong>—<a class="ae ky" href="https://www.perfectlyrandom.org/2019/11/29/handling-avro-files-in-python/" rel="noopener ugc nofollow" target="_blank">https://www . perfectlyrandom . org/2019/11/29/handling-Avro-files-in-python/</a></li><li id="4df5" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu"> LSM 树 vs B 树</strong>—<a class="ae ky" href="https://blog.yugabyte.com/a-busy-developers-guide-to-database-storage-engines-the-basics/" rel="noopener ugc nofollow" target="_blank">https://blog . yugabyte . com/a-busy-developers-guide-to-database-storage-engines-the-basics/</a></li><li id="2199" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">关于 LSM 树的更多信息—</strong><a class="ae ky" href="https://www.slideshare.net/ConfluentInc/power-of-the-loglsm-append-only-data-structures" rel="noopener ugc nofollow" target="_blank">https://www . slide share . net/ConfluentInc/power-of-the-log LSM-append-only-data-structures</a></li><li id="a0ee" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">克雷普斯</strong> ♥ <strong class="lb iu">日志(卡夫卡)</strong>—<a class="ae ky" href="https://www.confluent.io/ebook/i-heart-logs-event-data-stream-processing-and-data-integration/" rel="noopener ugc nofollow" target="_blank">https://www . confluent . io/ebook/I-heart-logs-event-data-stream-processing-and-data-integration/</a></li><li id="6f31" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">阿瑟·惠特尼对 KDB &amp;的完整改写</strong>——<a class="ae ky" href="https://queue.acm.org/detail.cfm?id=1531242" rel="noopener ugc nofollow" target="_blank">https://kx.com/blog/small-core-code-and-hp-apl/</a></li><li id="3bb0" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">源数据集</strong>—<a class="ae ky" href="https://data.cityofchicago.org/Administration-Finance/Current-Employee-Names-Salaries-and-Position-Title/aned-ke5c" rel="noopener ugc nofollow" target="_blank">https://Data . cityofchicago . org/Administration-Finance/Current-Employee-Names-salary-and-Position-Title/aned-ke5c</a></li><li id="1476" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">本文 GitHub</strong>——<a class="ae ky" href="https://github.com/dougfoo/fileformats" rel="noopener ugc nofollow" target="_blank">https://github.com/dougfoo/fileformats</a></li></ul></div></div>    
</body>
</html>