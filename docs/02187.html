<html>
<head>
<title>A Step-By-Step tutorial to build and deploy an image classification API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建和部署影像分类 API 的分步教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-step-by-step-tutorial-to-build-and-deploy-an-image-classification-api-95fa449f0f6a?source=collection_archive---------7-----------------------#2020-03-02">https://towardsdatascience.com/a-step-by-step-tutorial-to-build-and-deploy-an-image-classification-api-95fa449f0f6a?source=collection_archive---------7-----------------------#2020-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9183" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从使用 Labelme 的数据注释到使用 FastApi+Docker 的部署的所有步骤</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9727664ce47b497491672869e76fb3b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SRBUtXfU8PD7WLmKRM2YhA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图恩·nguyễn·明在<a class="ae kv" href="https://unsplash.com/s/photos/build?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="49b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个小项目中，我们的目标是从头开始构建一个图像分类 API。<br/>我们将经历实现这一目标所需的所有步骤:</p><ul class=""><li id="7cc6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">数据注释(使用 Unsplash API + Labelme)</li><li id="f58b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">模型训练(使用 Tensorflow)</li><li id="3926" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">制作 API(使用 Uvicorn 和 FastApi)</li><li id="27d5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在远程服务器上部署 API(使用 Docker 和 Google 云平台)</li></ul><h1 id="b8f4" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">数据注释:</h1><p id="12fb" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">任何机器学习项目最重要的部分之一是注释数据的质量和数量。这是部署 API 时影响预测质量的关键因素之一。</p><p id="f2db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个项目中，我们将尝试将输入图像分为四类:</p><ul class=""><li id="8b31" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">城市</li><li id="988a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">海滩</li><li id="402d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">日落</li><li id="a362" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">树木/森林</li></ul><p id="de3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我选择这些课程是因为很容易在网上找到大量代表它们的图片。我们使用这些类来定义多标签分类问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/d80fd5c8dcb28ced2f4ad8048bc1b3a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*buGA2Qk4KXqJMq5Xu5gffg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/</a>的输入和目标/图像示例</p></figure><p id="45b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经定义了我们想要解决的问题，我们需要获得足够数量的标记样本来进行训练和评估。<br/>为了做到这一点，我们将首先使用<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a> API 来获取给定多个搜索查询的图像的 URL。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="7a63" class="nj mh iq nf b gy nk nl l nm nn"># First install <a class="ae kv" href="https://github.com/yakupadakli/python-unsplash" rel="noopener ugc nofollow" target="_blank">https://github.com/yakupadakli/python-unsplash</a><br/># Unsplash API <a class="ae kv" href="https://unsplash.com/documentation" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/documentation</a><br/>import json<br/>import os</span><span id="5e6e" class="nj mh iq nf b gy no nl l nm nn">from unsplash.api import Api<br/>from unsplash.auth import Auth</span><span id="ce68" class="nj mh iq nf b gy no nl l nm nn">with open('tokens.json', 'r') as f:<br/>    data = json.load(f)</span><span id="24c0" class="nj mh iq nf b gy no nl l nm nn">client_id = data['client_id']<br/>client_secret = data['client_secret']</span><span id="d02d" class="nj mh iq nf b gy no nl l nm nn">redirect_uri = ""<br/>code = ""</span><span id="4ec2" class="nj mh iq nf b gy no nl l nm nn">keyword = 'beach'</span><span id="f60c" class="nj mh iq nf b gy no nl l nm nn">auth = Auth(client_id, client_secret, redirect_uri, code=code)<br/>api = Api(auth)</span><span id="225d" class="nj mh iq nf b gy no nl l nm nn">photos = api.search.photos(keyword, per_page=1000, page=i)['results']</span><span id="4318" class="nj mh iq nf b gy no nl l nm nn">for photo in photos:<br/>    print(photo)<br/>    print(photo.id)<br/>    print(photo.urls)<br/>    print(photo.urls.small)</span></pre><p id="5ee3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将尝试获取与我们的目标类相关的图像 URL，加上一些其他随机图像，作为反面例子。</p><p id="e9db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是遍历所有的图像，并给每一个图像分配一组标签，如上图所示。为此，使用专为此任务设计的注释工具总是更容易，例如<a class="ae kv" href="https://github.com/wkentaro/labelme" rel="noopener ugc nofollow" target="_blank"> LabelMe，</a>它是一个 python 库，您可以从命令行轻松运行:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="3148" class="nj mh iq nf b gy nk nl l nm nn">labelme . -flags labels.txt</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/cc11b0576554fbb287cad79b62a8d2e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4iIY7gR7ZYEc-qEW3HJmLg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Labelme 用户界面</p></figure><p id="c1d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用 Labelme 我标记了大约一千张图片，并在这里提供了 urls 标签:<a class="ae kv" href="https://github.com/CVxTz/ToyImageClassificationDataset" rel="noopener ugc nofollow" target="_blank">https://github.com/CVxTz/ToyImageClassificationDataset</a></p><h1 id="80dd" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">模型</h1><p id="3e93" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在我们有了标记的样本，我们可以尝试使用 Tensorflow 构建一个分类器。我们将使用 MobileNet_V2 作为分类器的主干，因为它速度快，而且不太可能过度拟合。鉴于我们只有少量的标记样本，您可以通过从 keras_applications 导入它来轻松使用它:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="fcbe" class="nj mh iq nf b gy nk nl l nm nn">from tensorflow.keras.applications import MobileNetV2</span><span id="41e1" class="nj mh iq nf b gy no nl l nm nn">base_model = MobileNetV2(include_top=False, input_shape=input_shape, weights=weights)</span></pre><p id="6204" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这是一个具有四个类别的多标签分类问题，我们将有一个具有 Sigmoid 激活的四个神经元的输出层(给定一个示例，我们可以将多个神经元激活或没有神经元激活作为目标)</p><h2 id="11ae" class="nj mh iq bd mi nq nr dn mm ns nt dp mq lf nu nv ms lj nw nx mu ln ny nz mw oa bi translated">迁移学习</h2><p id="bc46" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">解决标记样本缺乏的一个常用技巧是使用迁移学习。它是当你把从源任务(像带有不同标签集的图像分类)中学到的一些权重转移到你的目标任务，作为你训练的起点。与从随机开始相比，这允许更好的初始化，并且允许为我们的多标签分类重用在源任务上学习的一些表示。</p><p id="42f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们将转移在 ImageNet 中训练得到的权重。在为 MobileNet_V2 使用 Tensorflow+Keras 时，做到这一点非常容易，您只需要在创建 MobileNetV2 的实例时指定 weights="imagenet "</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="d314" class="nj mh iq nf b gy nk nl l nm nn">base_model = MobileNetV2(include_top=False, input_shape=input_shape, weights="imagenet")</span></pre><h2 id="4d87" class="nj mh iq bd mi nq nr dn mm ns nt dp mq lf nu nv ms lj nw nx mu ln ny nz mw oa bi translated">数据扩充</h2><p id="9669" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">当有一小组带注释的样本时，提高性能的另一个技巧是进行数据扩充。应用随机扰动的过程保留了标签信息(扰动后的城市图片看起来仍然像一个城市)。一些常见的变换是垂直镜像、椒盐噪声或模糊。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/50bef742c6828c287203bf7eb8107f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BNhj5p5uTfwF9yaeRDuBUQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据扩充示例/图片来自<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/</a></p></figure><p id="0191" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现这一点，我们使用了一个名为 imgaug 的 python 包，并定义了一系列变换及其幅度:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="33b4" class="nj mh iq nf b gy nk nl l nm nn">sometimes = <strong class="nf ir">lambda </strong>aug: iaa.Sometimes(0.1, aug)<br/>seq = iaa.Sequential(<br/>    [<br/>        sometimes(iaa.Affine(scale={<strong class="nf ir">"x"</strong>: (0.8, 1.2)})),<br/>        sometimes(iaa.Fliplr(p=0.5)),<br/>        sometimes(iaa.Affine(scale={<strong class="nf ir">"y"</strong>: (0.8, 1.2)})),<br/>        sometimes(iaa.Affine(translate_percent={<strong class="nf ir">"x"</strong>: (-0.2, 0.2)})),<br/>        sometimes(iaa.Affine(translate_percent={<strong class="nf ir">"y"</strong>: (-0.2, 0.2)})),<br/>        sometimes(iaa.Affine(rotate=(-20, 20))),<br/>        sometimes(iaa.Affine(shear=(-20, 20))),<br/>        sometimes(iaa.AdditiveGaussianNoise(scale=0.07 * 255)),<br/>        sometimes(iaa.GaussianBlur(sigma=(0, 3.0))),<br/>    ],<br/>    random_order=<strong class="nf ir">True</strong>,<br/>)</span></pre><h2 id="413c" class="nj mh iq bd mi nq nr dn mm ns nt dp mq lf nu nv ms lj nw nx mu ln ny nz mw oa bi translated">培养</h2><p id="0673" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们将数据集分为两部分，训练和验证，并使用 binary_crossentropy 作为我们的目标，binary_accuracy 作为评估度量。</p><p id="1977" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在更新一些配置文件后，我们从命令行运行培训:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="c3cb" class="nj mh iq nf b gy nk nl l nm nn"># data_config.yaml for defnining the classes and input size<strong class="nf ir"><br/>input_shape</strong>: [null, null, 3]<br/><strong class="nf ir">resize_shape</strong>: [224, 224]<br/><strong class="nf ir">images_base_path</strong>: <strong class="nf ir">'../example/data/'<br/>targets</strong>: [<strong class="nf ir">'beach'</strong>, <strong class="nf ir">'city'</strong>, <strong class="nf ir">'sunset'</strong>, <strong class="nf ir">'trees'</strong>]<br/><strong class="nf ir">image_name_col</strong>: <strong class="nf ir">'name'</strong></span><span id="4569" class="nj mh iq nf b gy no nl l nm nn"># training_config.yaml for defining some training parameters<strong class="nf ir"><br/>use_augmentation</strong>: true<br/><strong class="nf ir">batch_size</strong>: 32<br/><strong class="nf ir">epochs</strong>: 1000<br/><strong class="nf ir">initial_learning_rate</strong>: 0.0001<br/><strong class="nf ir">model_path</strong>: <strong class="nf ir">"image_classification.h5"</strong></span></pre><p id="041a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后运行训练脚本:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="1e09" class="nj mh iq nf b gy nk nl l nm nn"><strong class="nf ir">export PYTHONPATH=$PYTHONPATH:~/PycharmProjects/FastImageClassification/</strong></span><span id="16ea" class="nj mh iq nf b gy no nl l nm nn"><strong class="nf ir">python train.py --csv_path "../example/data.csv" \<br/>       --data_config_path "../example/data_config.yaml" \<br/>       --training_config_path "../example/training_config.yaml"</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/f1ab1c03c5fbc7457d09c5e76f6a0dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*azNZV0IqtYNajUzboMaYDw.gif"/></div></div></figure><p id="e735" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们最终得到的二进制验证准确率为<strong class="ky ir"> 94% </strong></p><h1 id="5868" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">制作 API</h1><p id="c0ca" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们将使用 FastAPI 通过一个易于使用的 API 来公开一个预测器，该 API 可以将一个图像文件作为输入，并输出一个包含每个类的分类分数的 JSON。</p><p id="9065" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要编写一个预测器类，它可以轻松地加载 tensorflow.keras 模型，并有一个方法来对文件对象形式的图像进行分类。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="2f15" class="nj mh iq nf b gy nk nl l nm nn"><strong class="nf ir">class </strong>ImagePredictor:<br/>    <strong class="nf ir">def </strong>__init__(<br/>        self, model_path, resize_size, targets, pre_processing_function=preprocess_input<br/>    ):<br/>        self.model_path = model_path<br/>        self.pre_processing_function = pre_processing_function<br/>        self.model = load_model(self.model_path)<br/>        self.resize_size = resize_size<br/>        self.targets = targets</span><span id="1bac" class="nj mh iq nf b gy no nl l nm nn">    @classmethod<br/>    <strong class="nf ir">def </strong>init_from_config_path(cls, config_path):<br/>        <strong class="nf ir">with </strong>open(config_path, <strong class="nf ir">"r"</strong>) <strong class="nf ir">as </strong>f:<br/>            config = yaml.load(f, yaml.SafeLoader)<br/>        predictor = cls(<br/>            model_path=config[<strong class="nf ir">"model_path"</strong>],<br/>            resize_size=config[<strong class="nf ir">"resize_shape"</strong>],<br/>            targets=config[<strong class="nf ir">"targets"</strong>],<br/>        )<br/>        <strong class="nf ir">return </strong>predictor</span><span id="f256" class="nj mh iq nf b gy no nl l nm nn">    @classmethod<br/>    <strong class="nf ir">def </strong>init_from_config_url(cls, config_path):<br/>        <strong class="nf ir">with </strong>open(config_path, <strong class="nf ir">"r"</strong>) <strong class="nf ir">as </strong>f:<br/>            config = yaml.load(f, yaml.SafeLoader)</span><span id="e41b" class="nj mh iq nf b gy no nl l nm nn">        download_model(<br/>            config[<strong class="nf ir">"model_url"</strong>], config[<strong class="nf ir">"model_path"</strong>], config[<strong class="nf ir">"model_sha256"</strong>]<br/>        )</span><span id="058f" class="nj mh iq nf b gy no nl l nm nn">        <strong class="nf ir">return </strong>cls.init_from_config_path(config_path)</span><span id="acc0" class="nj mh iq nf b gy no nl l nm nn">    <strong class="nf ir">def </strong>predict_from_array(self, arr):<br/>        arr = resize_img(arr, h=self.resize_size[0], w=self.resize_size[1])<br/>        arr = self.pre_processing_function(arr)<br/>        pred = self.model.predict(arr[np.newaxis, ...]).ravel().tolist()<br/>        pred = [round(x, 3) <strong class="nf ir">for </strong>x <strong class="nf ir">in </strong>pred]<br/>        <strong class="nf ir">return </strong>{k: v <strong class="nf ir">for </strong>k, v <strong class="nf ir">in </strong>zip(self.targets, pred)}</span><span id="d56f" class="nj mh iq nf b gy no nl l nm nn">    <strong class="nf ir">def </strong>predict_from_file(self, file_object):<br/>        arr = read_from_file(file_object)<br/>        <strong class="nf ir">return </strong>self.predict_from_array(arr)</span></pre><p id="ce1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用一个配置文件来实例化一个 predictor 对象，该对象具有进行预测的所有参数，并将从项目的 GitHub 存储库中下载模型:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="66ee" class="nj mh iq nf b gy nk nl l nm nn"><strong class="nf ir"># config.yaml<br/>resize_shape</strong>: [224, 224]<br/><strong class="nf ir">targets</strong>: [<strong class="nf ir">'beach'</strong>, <strong class="nf ir">'city'</strong>, <strong class="nf ir">'sunset'</strong>, <strong class="nf ir">'trees'</strong>]<br/><strong class="nf ir">model_path</strong>: <strong class="nf ir">"image_classification.h5"<br/>model_url</strong>: <strong class="nf ir">"https://github.com/CVxTz/FastImageClassification/releases/download/v0.1/image_classification.h5"<br/>model_sha256</strong>: <strong class="nf ir">"d5cd9082651faa826cab4562f60e3095502286b5ea64d5b25ba3682b66fbc305"</strong></span></pre><p id="6b67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成所有这些之后，当使用 FastAPI 时，我们的 API 的主文件变得微不足道:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="fd78" class="nj mh iq nf b gy nk nl l nm nn"><strong class="nf ir">from </strong>fastapi <strong class="nf ir">import </strong>FastAPI, File, UploadFile</span><span id="baa6" class="nj mh iq nf b gy no nl l nm nn"><strong class="nf ir">from </strong>fast_image_classification.predictor <strong class="nf ir">import </strong>ImagePredictor</span><span id="f211" class="nj mh iq nf b gy no nl l nm nn">app = FastAPI()</span><span id="1ca3" class="nj mh iq nf b gy no nl l nm nn">predictor_config_path = <strong class="nf ir">"config.yaml"</strong></span><span id="93ef" class="nj mh iq nf b gy no nl l nm nn">predictor = ImagePredictor.init_from_config_url(predictor_config_path)<br/></span><span id="ea4e" class="nj mh iq nf b gy no nl l nm nn">@app.post(<strong class="nf ir">"/scorefile/"</strong>)<br/><strong class="nf ir">def </strong>create_upload_file(file: UploadFile = File(...)):<br/>    <strong class="nf ir">return </strong>predictor.predict_from_file(file.file)</span></pre><p id="b7cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以用一个命令运行应用程序:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="f6b8" class="nj mh iq nf b gy nk nl l nm nn">uvicorn main:app --reload</span></pre><p id="cf0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使我们能够访问 Swagger UI，在那里我们可以在一个新文件上尝试我们的 API。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/ffedd949d574947a8d7bd48abb1e1adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ka58fs87P-ptDS8aciP4Gw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="http://127.0.0.1:8000/docs" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8080/docs</a></p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/15fa93b24d20cba1a7262586b9db05ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uPdQuS0Y4Esz5vYZk13Npw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@antonioresendiz_?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Antonio Resendiz </a>在<a class="ae kv" href="https://unsplash.com/s/photos/city?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ebfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上传上面的图像会产生以下输出:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="d177" class="nj mh iq nf b gy nk nl l nm nn">{<strong class="nf ir"><br/>  </strong>"beach":<strong class="nf ir"> 0</strong>,<strong class="nf ir"><br/>  </strong>"city":<strong class="nf ir"> 0</strong>.<strong class="nf ir">999</strong>,<strong class="nf ir"><br/>  </strong>"sunset":<strong class="nf ir"> 0</strong>.<strong class="nf ir">005</strong>,<strong class="nf ir"><br/>  </strong>"trees":<strong class="nf ir"> 0<br/></strong>}</span></pre><p id="844a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是预期的输出！</p><p id="5ff7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以通过 curl 发送请求并计时:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="df6f" class="nj mh iq nf b gy nk nl l nm nn">time curl -X POST "<a class="ae kv" href="http://127.0.0.1:8000/scorefile/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080/scorefile/</a>" -H  "accept: application/json" -H  "Content-Type: multipart/form-data" -F "file=<a class="ae kv" href="http://twitter.com/antonio" rel="noopener ugc nofollow" target="_blank">@antonio</a>-resendiz-VTLqQe4Ej8I-unsplash.jpg;type=image/jpeg"</span><span id="0794" class="nj mh iq nf b gy no nl l nm nn">&gt;&gt; {"beach":0.0,"city":0.999,"sunset":0.005,"trees":0.0}<br/>&gt;&gt; real 0m0.209s<br/>&gt;&gt; user 0m0.012s<br/>&gt;&gt; sys 0m0.008s</span></pre><h1 id="66ac" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">部署应用程序</h1><h2 id="fecc" class="nj mh iq bd mi nq nr dn mm ns nt dp mq lf nu nv ms lj nw nx mu ln ny nz mw oa bi translated">码头工人</h2><p id="2adf" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">如果一个应用在 Docker 这样的容器中，部署起来会更容易。</p><p id="43c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在安装正确的环境后，我们将创建一个 docker 文件，其中包含运行我们的应用程序所需的所有说明:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="4d14" class="nj mh iq nf b gy nk nl l nm nn"><strong class="nf ir">FROM</strong> python:3.6-slim<br/><strong class="nf ir">COPY</strong> app/main.py /deploy/<br/><strong class="nf ir">COPY</strong> app/config.yaml /deploy/<br/><strong class="nf ir">WORKDIR</strong> /deploy/<br/><strong class="nf ir">RUN</strong> apt update<br/><strong class="nf ir">RUN</strong> apt install -y git<br/><strong class="nf ir">RUN</strong> apt-get install -y libglib2.0-0<br/><strong class="nf ir">RUN</strong> pip install git+https://github.com/CVxTz/FastImageClassification<br/><strong class="nf ir">EXPOSE</strong> 8080</span><span id="4e4a" class="nj mh iq nf b gy no nl l nm nn"><strong class="nf ir">ENTRYPOINT</strong> uvicorn main:app --host 0.0.0.0 --port 8080</span></pre><p id="c1b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装 Docker:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="2031" class="nj mh iq nf b gy nk nl l nm nn">sudo apt install docker.io</span></pre><p id="f4a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以运行 Docker 构建:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="b079" class="nj mh iq nf b gy nk nl l nm nn">sudo docker build -t img_classif .</span></pre><p id="56d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们最后运行容器，同时将容器的端口 8080 映射到主机的端口:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="fcb0" class="nj mh iq nf b gy nk nl l nm nn">sudo docker run -p 8080:8080 img_classif .</span></pre><h2 id="28a6" class="nj mh iq bd mi nq nr dn mm ns nt dp mq lf nu nv ms lj nw nx mu ln ny nz mw oa bi translated">在远程服务器上部署</h2><p id="9c8f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我试图在 AWS 的 ec2 实例上这样做，但是 ssh 命令行很笨拙，终端在最后一个命令时会死机，不知道为什么。所以我决定使用谷歌云平台的应用引擎进行部署。点击链接到关于这个主题的更详细的教程<a class="ae kv" href="https://blog.machinebox.io/deploy-docker-containers-in-google-cloud-platform-4b921c77476b" rel="noopener ugc nofollow" target="_blank">。</a></p><ul class=""><li id="fc9d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">创建一个谷歌云平台账户</li><li id="0c53" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">安装 gcloud</li><li id="ff72" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">创建项目 project_id</li><li id="b32e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">克隆<a class="ae kv" href="https://github.com/CVxTz/FastImageClassification" rel="noopener ugc nofollow" target="_blank">https://github.com/CVxTz/FastImageClassification</a>并叫:</li></ul><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="67da" class="nj mh iq nf b gy nk nl l nm nn">cd FastImageClassification</span><span id="9d31" class="nj mh iq nf b gy no nl l nm nn">gcloud config set project_id</span><span id="b248" class="nj mh iq nf b gy no nl l nm nn">gcloud app deploy app.yaml -v v1</span></pre><p id="53a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一个命令需要一段时间，但是…瞧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/97346d2e00cfbca4cdc3201c27a375e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcHnFytWaAIpeM-ZL_3Dng.png"/></div></div></figure><h1 id="ca0c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="2ddb" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在这个项目中，我们使用 Tensorflow、Docker、FastAPI 和谷歌云平台的应用引擎，从头开始构建和部署了机器学习支持的图像分类 API。所有这些工具使整个过程简单明了，相对容易。下一步是探索处理大量查询时与安全性和性能相关的问题。</p><p id="2be1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重现结果的代码可从这里获得:<a class="ae kv" href="https://github.com/CVxTz/FastImageClassification" rel="noopener ugc nofollow" target="_blank">https://github.com/CVxTz/FastImageClassification</a></p></div></div>    
</body>
</html>