<html>
<head>
<title>Getting Started with AutoKeras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AutoKeras入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-autokeras-8c5332b829?source=collection_archive---------8-----------------------#2020-02-17">https://towardsdatascience.com/getting-started-with-autokeras-8c5332b829?source=collection_archive---------8-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8946" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用几行代码利用神经结构搜索的能力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9537d4ca16d9fe325cc406e533b78ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9fgb9BS5GNdFeS0A7LR6w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/keras-team/autokeras" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="3dfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在<a class="ae ky" rel="noopener" target="_blank" href="/the-state-of-ai-in-2020-1f95df336eb0"> <em class="lv">中提到的2020年人工智能的状态</em> </a> <em class="lv"> </em>中最强大的即将到来的概念之一是<a class="ae ky" href="https://en.wikipedia.org/wiki/Neural_architecture_search" rel="noopener ugc nofollow" target="_blank">神经架构搜索(NAS) </a>。关于NAS有很多东西需要了解，但是为了理解本教程，我只做一个总结。简而言之，NAS本质上是一种将人类设计的局限性从神经网络架构中去除的方法。为了实现这一点，许多不同的架构被并行考虑、训练和评估。接下来，可以基于所选择的算法来调整每一个，以尝试另一种架构。最终结果是在每个尝试的模型上模型损失的一种梯度下降(可能是几千个！)，而不是每一步。表现最好的模型是赢家，数据科学家可以在晚上睡得很好，因为他们知道他们可能没有使用低劣的算法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/c064890f363c4037e24d0f06715946a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Rux4vC-GJbAA_CQi8qXD9g.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动画来自<a class="ae ky" href="https://github.com/carpedm20/ENAS-pytorch" rel="noopener ugc nofollow" target="_blank"> ENAS PyTorch实现</a></p></figure><p id="5412" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过去，要实现成功的NAS，需要非常复杂的Tensorflow、PyTorch或Keras脚本实现。除此之外，企业级的计算硬件要求。输入<a class="ae ky" href="https://autokeras.com" rel="noopener ugc nofollow" target="_blank"> AutoKeras </a>。德克萨斯州A &amp; M实验室的数据分析开发了一个用Keras构建的开源框架，为任何狂热的Keras + python用户带来NAS。在一年的预发布版本之后，1.0版本于2019年1月刚刚发布，这使它可以随时投入使用。对于年轻的数据科学家和小公司来说，这是一个非常好的工具，因为它允许他们跟上大型竞争对手发誓要采用的技术。</p><p id="7ea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该库使用最先进的NAS算法，以及现有的预处理模块，以确保NAS培训会议顺利进行。这在<a class="ae ky" href="https://dl.acm.org/doi/10.1145/3292500.3330648" rel="noopener ugc nofollow" target="_blank"> AutoKeras论文</a>中有详细阐述。这对于小型研究操作来说非常令人兴奋的部分原因是，他们已经优化了动态GPU内存的算法，以避免我们都习惯的邪恶的OOM异常。鉴于所有这些，AutoKeras预装了以下功能:</p><ul class=""><li id="4a30" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated"><strong class="lb iu">图像分类/回归</strong></li><li id="ac59" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><strong class="lb iu">文本分类/回归</strong></li><li id="cc5f" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><strong class="lb iu">结构化数据分类/回归(典型的行x列数据类型)</strong></li><li id="ee62" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><strong class="lb iu">多任务学习</strong></li></ul><p id="b63d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将首先简要介绍一下设置和简单的实现，然后深入介绍定制实现和“块”的概念</p><h1 id="7019" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated"><strong class="ak">设置</strong></h1><p id="de20" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">AutoKeras在Tensorflow之上的Keras上运行时有以下要求，特别是版本2.1.0。</p><ul class=""><li id="6689" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">Python3</li><li id="4e97" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">点</li><li id="f2af" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">TensorFlow ≥ 2.1.0(重要！)</li></ul><p id="a352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦这些都就绪，这个简单的pip命令就应该安装AutoKeras了</p><p id="1687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">pip3 install autokeras</code></p><p id="4102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果安装没有任何问题，你就可以开始了！</p><h1 id="b3ff" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated"><strong class="ak">简单用例</strong></h1><p id="447e" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">如果你的唯一目标是为一个分类任务训练最好的架构，那么代码是相当少的。使用内置的mnist数据集，您可以如下加载</p><p id="bd67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">x_train, y_train = mnist.load_data()</code></p><p id="5335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了想要拟合的数据，我们可以创建<code class="fe ni nj nk nl b">ImageClassifier</code>对象:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="5a66" class="nq mm it nl b gy nr ns l nt nu">import autokeras as ak<br/>model = ak.ImageClassifier(max_trial = 100)</span></pre><p id="1155" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这为我们的培训课程创建了结构。max_trials指的是将尝试多少不同的模型。AutoKeras已经实现了像ResNet、Xception、可分离CNN这样的模型，这些模型必然是强大的。</p><p id="2fcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要拟合模型。这个极其复杂和漫长的过程取决于您的硬件，可以通过以下方式触发:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="8ee7" class="nq mm it nl b gy nr ns l nt nu">model.fit(x_train, y_train)</span></pre><p id="eadd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">附加选项也有助于理解拟合方法:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="4bc5" class="nq mm it nl b gy nr ns l nt nu">ImageClassifier.fit(x=None, y=None, epochs=None, callbacks=None, validation_split=0.2, validation_data=None, **kwargs )</span></pre><p id="db35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里可以看到，我们还可以选择设置时期的数量，并根据我们的选择进行验证分割。这对于验证数据来说很好，因为它不需要我们自己去分割它。</p><p id="b0e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦模型完成了最大数量的试验，将选择具有最佳“分数”的模型。现在，您可以输入一个新的图像并保存模型，如下所示。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="280c" class="nq mm it nl b gy nr ns l nt nu">x = load_some_image()<br/>model.predict(x) #Returns a softmax array<br/>model.export_model()</span></pre><p id="cd7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导出方法的输出将是TensorFlow模型文件类型。这可以用来做典型的张量流模型可以用来做的任何事情。对于其他两种模型类型(文本、结构化),过程几乎是相同的。例如，文本分类器甚至可以接受一个字符串作为输入，并自己执行嵌入！</p><h1 id="d021" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated"><strong class="ak">自动建模和模块</strong></h1><p id="1556" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">如果AutoKeras被用于生产级软件，那么基本用例可能就不够用了。幸运的是，AutoModel和Blocks允许用户构建他们可能需要的任何管道和潜在架构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/725ebc1e3eb812d9b74fa2b384acab65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0A4YttiJG3f_PWmAYpe9vQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://autokeras.com/tutorial/customized/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="8f03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图是一个AutoModel，它是上面列出的分类器对象的基类。建造一个这样的可以完成同样的任务，但是对管道有更多的控制。图中的每一步称为一个块。这些范围从预处理到完整的神经网络，并按顺序串在一起。初始模块(输入、标准化等。)很容易理解，但是网络可能会令人困惑。例如，当谈到卷积块时，我们不是在顺序网络中使用单个卷积，而是使用整个CNN。上面的CNN和ResNet模块将把每种网络类型的完整架构添加到要尝试的网络列表中。与回归输出相反，合并块仅意味着将分类头信号视为相等，以执行分类(softmax/binary)。</p><p id="af91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe ni nj nk nl b">fit</code>和<code class="fe ni nj nk nl b">predict</code>步骤来说，完成类似任务的代码是相同的，但是每个程序块需要一行代码。下面是我创建的一个自动模型的例子:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="dcc6" class="nq mm it nl b gy nr ns l nt nu">input_node = ak.ImageInput()<br/>out_node = ak.Normalization()(input_node)<br/>out_node1 = ak.ConvBlock()(out_node)<br/>out_node2 = ak.XceptionBlock()(out_node)<br/>out_node3 = ak.ResNetBlock()(out_node)</span><span id="76fa" class="nq mm it nl b gy nw ns l nt nu">out_node = ak.Merge()([out_node1, out_node2, out_node3])<br/>out_node_c = ak.ClassificationHead()(out_node)</span><span id="5cd5" class="nq mm it nl b gy nw ns l nt nu">auto_model = ak.AutoModel(inputs=input_node, outputs=[out_node_c], max_trials=20)</span><span id="99ed" class="nq mm it nl b gy nw ns l nt nu">auto_model.fit(x=x_train, y=y_train, epochs=100)</span></pre><p id="0f6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当这个NAS开始时，AutoKeras将尝试CNN、类Xception和类ResNet架构的变体，平均分布在我指定的20个试验中。同样重要的是要注意，这些块不是连续的，即使它们在代码中看起来是这样的。它们可以被认为是添加到每一行的AutoModel的服务。</p><p id="80d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了网络模块之外，还有许多其他模块可以添加到流水线中。例如，在<code class="fe ni nj nk nl b">ImageInput()</code>方法之后添加这个函数可以在搜索期间执行一系列的增强:</p><p id="d155" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">ak.ImageAugmentation(percentage=0.25, rotation_range=180, random_crop=True)</code></p><p id="a876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在反馈到网络之前，AutoKeras现在会对我们的图像进行所有这些放大。</p><p id="0d6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果我们需要切换到回归任务(图像质量从0到1)，那么<code class="fe ni nj nk nl b">ak.ClassificationHead()(out_node)</code>可以转换为:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="e017" class="nq mm it nl b gy nr ns l nt nu">ak.RegressionHead()(out_node)</span></pre><p id="f302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还可以举出更多关于块提供的适应性的例子。这同样适用于其他两种类型的任务，文本的自定义单词嵌入和结构数据的特征工程。</p><h1 id="9267" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated"><strong class="ak">多任务学习</strong></h1><p id="0cc9" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我想介绍的最后一个复杂特性是多任务学习。神经网络体系结构的底层通常需要多种输出类型。例如，我最近为一个客户做的实现需要图像类别和质量输出。渴望在AutoKeras中实现这一点，我研究了如何用多任务框架来实现这一点。下面的代码实现了这一点。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="447c" class="nq mm it nl b gy nr ns l nt nu">input_node = ak.ImageInput()<br/>out_node = ak.Normalization()(input_node)<br/>out_node1 = ak.ConvBlock()(out_node)<br/>out_node2 = ak.XceptionBlock()(out_node)<br/>out_node3 = ak.ResNetBlock()(out_node)</span><span id="d9ab" class="nq mm it nl b gy nw ns l nt nu">out_node = ak.Merge()([out_node1, out_node2, out_node3])<br/>out_node_t = ak.ClassificationHead()(out_node)<br/><br/>out_node_q = ak.RegressionHead()(out_node)<br/><br/>auto_model = ak.AutoModel(inputs=input_node, outputs=[out_node_t, out_node_q], max_trials=20)<br/>auto_model.fit(x=im_in, y=[ty_y, qual_y], epochs=100)</span></pre><p id="e366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模型同时创建softmax数组和原始浮点输出。您可能注意到的主要变化是在ClassificationHead旁边添加了RegressionHead。接下来，在AutoModel的构造函数中描述这两个输出。最后，两个输出数据集被输入到<code class="fe ni nj nk nl b">y=[ty_y, qual_y]</code>，这样模型就知道对每个头部进行什么样的训练。这总体上创建了初始块的两个独立的网络分支。来自CNN的相同输出被传递给每个分支，但是从每个分支接收所需的质量分数和分类数组。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="75af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AutoKeras的附加功能几乎是无穷无尽的。除了给予任何数据科学家构建最佳的、强大的架构的能力之外；它还允许初学者获得新应用程序所需的张量流模型。我很高兴看到AutoKeras扩展到哪里，他们已经宣布了时间序列和其他功能即将推出。我希望这有助于你看到这项伟大技术的潜力，我期待着听到你可能已经能够使用它！</p><p id="4c11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">参考文献</strong></p><p id="b912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]<a class="ae ky" href="https://github.com/keras-team/autokeras" rel="noopener ugc nofollow" target="_blank">https://github.com/keras-team/autokeras</a></p><p id="109b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]<a class="ae ky" href="https://en.wikipedia.org/wiki/Neural_architecture_search" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Neural_architecture_search</a></p><p id="1bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://autokeras.com" rel="noopener ugc nofollow" target="_blank">https://autokeras.com</a></p><p id="5f2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/carpedm20/ENAS-pytorch" rel="noopener ugc nofollow" target="_blank">https://github.com/carpedm20/ENAS-pytorch</a></p><p id="868e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[5]<a class="ae ky" href="https://dl.acm.org/doi/10.1145/3292500.3330648" rel="noopener ugc nofollow" target="_blank">https://dl.acm.org/doi/10.1145/3292500.3330648</a></p><p id="6468" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[6]<a class="ae ky" href="https://autokeras.com/tutorial/customized/" rel="noopener ugc nofollow" target="_blank">https://autokeras.com/tutorial/customized/</a></p></div></div>    
</body>
</html>