<html>
<head>
<title>How to Build And Publish Command-Line Applications With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python构建和发布命令行应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-and-publish-command-line-applications-with-python-96065049abc1?source=collection_archive---------9-----------------------#2020-06-09">https://towardsdatascience.com/how-to-build-and-publish-command-line-applications-with-python-96065049abc1?source=collection_archive---------9-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bbeefa2a07adb1a394d51b268b01ff4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OCqNrVk8uOkz-rz2"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">戴维·克洛德在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="c61f" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated"><em class="ky">关于如何用Python构建和发布命令行应用程序的全面指南。</em></h2></div><p id="a87e" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令行应用程序基本上是您在终端上运行的程序，并且您很可能已经尝试或考虑过构建一个。</p><p id="9c5d" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建命令行应用程序是一回事，将它发布到像PyPI这样的开放公共代码库是另一回事，不应该被视为一项困难的任务或过程。</p><p id="5094" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我以前写过一篇<a class="ae jg" href="https://codeburst.io/building-beautiful-command-line-interfaces-with-python-26c7e1bb54df" rel="noopener" target="_blank">文章</a>，其中我深入解释了用Python构建命令行应用程序的各种方式和方法。</p><p id="0e6f" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将解释如何用Python构建一个简单的CLI并将其发布到PyPI。</p><h1 id="f911" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">入门指南</h1><p id="0dd5" class="pw-post-body-paragraph kz la jj lb b lc mn kk le lf mo kn lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最近我一直在做一些关于<a class="ae jg" href="https://www.darkreading.com/edge/theedge/the-truth-about-vulnerabilities-in-open-source-code/b/d-id/1335187" rel="noopener ugc nofollow" target="_blank">开源漏洞</a>的研究，我想有一个命令行工具，我可以用它来搜索和查找终端上的漏洞。开源漏洞通常发布在公共数据库中，可以在类似<a class="ae jg" href="https://cve.mitre.org/" rel="noopener ugc nofollow" target="_blank"> CVE </a>、<a class="ae jg" href="https://nvd.nist.gov/" rel="noopener ugc nofollow" target="_blank"> NVD </a>、<a class="ae jg" href="http://vuln.whitesource.com" rel="noopener ugc nofollow" target="_blank">白源漏洞</a>等网站上找到。</p><p id="5683" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将构建一个简单的刮刀来搜索和查找CVE网站上的漏洞，将其包装成一个简单的命令行应用程序，并将其发布到PyPI。</p><p id="440f" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷吧？</p><p id="ff8e" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始，您需要设置您的<a class="ae jg" href="https://siitgo.com/pages/lpythontz-3/1511/python-3-environment-setup" rel="noopener ugc nofollow" target="_blank">开发环境</a>并安装所需的模块。我建议建立一个虚拟环境，因为它使事情变得更容易，并有助于避免模块版本的冲突。</p><p id="495f" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个虚拟环境，你可以使用python3命令<code class="fe ms mt mu mv b">python -m venv &lt;path/name&gt;</code>或者使用<code class="fe ms mt mu mv b">pip install virtualenvwrapper</code>安装<code class="fe ms mt mu mv b">virtualenvwrapper</code>并使用<code class="fe ms mt mu mv b">mkvirtualenv -p /path/topython &lt;path/name&gt;</code>创建一个虚拟环境</p><p id="3a61" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置并激活virtualenv后，您可以创建项目文件夹并安装所需的模块:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="f101" class="ne lw jj mv b gy nf ng l nh ni">mkvirtualenv -p /usr/bin/python cvecli-env<br/>mkdir cvecli &amp;&amp; cd cvecli<br/>mkdir cver &amp;&amp; touch setup.py &amp;&amp; touch README.md &amp;&amp; touch cver/__init__.py &amp;&amp; touch .gitignore<br/>pip install requests beautifulsoup4 lxml twine click<br/>pip freeze &gt; requirements.txt</span></pre><p id="ce8e" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦一切运行成功，您可以在任何代码编辑器中打开该项目，您应该会看到如下所示的结构:</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/cb712edee0150ae95be2744ed578c59f.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*Lw6CGHPnxfIquecJ9G0AyA.png"/></div></figure><h1 id="313e" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">编写我们的网页抓取器</h1><p id="5ecd" class="pw-post-body-paragraph kz la jj lb b lc mn kk le lf mo kn lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了能够在CVE网站上搜索和查找漏洞，我们需要一个网页抓取器来帮助抓取漏洞细节。我们将根据要求制造铲运机和Beautifulsoup，铲运机能够:</p><ol class=""><li id="d62d" class="nk nl jj lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">搜索漏洞</li><li id="2b4f" class="nk nl jj lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">使用漏洞的CVE名称获取漏洞详细信息</li></ol><p id="5a0b" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在<code class="fe ms mt mu mv b">cver</code>文件夹中，创建一个名为<code class="fe ms mt mu mv b">cve_scraper</code>的文件，基本设置如下:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="0258" class="ne lw jj mv b gy nf ng l nh ni">import requests<br/>from bs4 import BeautifulSoup</span><span id="451f" class="ne lw jj mv b gy ny ng l nh ni">SEARCH_URL = "<a class="ae jg" href="https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=python" rel="noopener ugc nofollow" target="_blank">https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=</a>"</span><span id="8031" class="ne lw jj mv b gy ny ng l nh ni">CVE_URL = "<a class="ae jg" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8492" rel="noopener ugc nofollow" target="_blank">https://cve.mitre.org/cgi-bin/cvename.cgi?name=</a>"</span><span id="8bcf" class="ne lw jj mv b gy ny ng l nh ni">def get_html(url):<br/>    request = requests.get(url)<br/>    if request.status_code == 200:<br/>        return request.content<br/>    else:<br/>        raise Exception("Bad request")</span><span id="ae70" class="ne lw jj mv b gy ny ng l nh ni">def search(s):<br/>    pass</span><span id="522e" class="ne lw jj mv b gy ny ng l nh ni">def lookup_cve(name):<br/>    pass</span></pre><h2 id="419b" class="ne lw jj bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">搜索漏洞</h2><p id="074c" class="pw-post-body-paragraph kz la jj lb b lc mn kk le lf mo kn lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在CVE网站上搜索漏洞，URL格式如下:<code class="fe ms mt mu mv b"><a class="ae jg" href="https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=python" rel="noopener ugc nofollow" target="_blank">https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword</a>=&lt;keyword&gt;</code>。这样，您应该能够用关键字，</p><p id="1cfd" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以使用URL来获取所有与python相关的漏洞:</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/aa0047933f8aeb96db1c617bc6553063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUtnvAof6TCjL0SZ9b-mTA.png"/></div></div></figure><p id="53a5" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提取数据，让我们打开开发人员控制台，检查呈现上述数据的DOM元素。您可以右键单击页面的任何部分，然后单击<code class="fe ms mt mu mv b">inspect element</code>或按Ctrl + F12。</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/29cb3cfb1b8abc489203177db3c31897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5yyEkEYfn3NLCP8xE9Qlxg.png"/></div></div></figure><p id="0702" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您看一下上图中的DOM结构，您会注意到结果显示在一个表格中，每个结果都是表格下的一行。数据可以很容易地提取如下:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="1736" class="ne lw jj mv b gy nf ng l nh ni">def search(s):</span><span id="ca42" class="ne lw jj mv b gy ny ng l nh ni">    url = f"{SEARCH_URL}{s}"<br/>    results=[]    <br/>    html = get_html(url)<br/>    soup = BeautifulSoup(html, "lxml")<br/>    result_rows = soup.select("#TableWithRules table tr")</span><span id="fd98" class="ne lw jj mv b gy ny ng l nh ni">    for row in result_rows: <br/>        _row = {}    <br/>        name = row.select_one("td a")<br/>        description = row.select_one("td:nth-child(2)")</span><span id="a5fc" class="ne lw jj mv b gy ny ng l nh ni">        if all([name, description]):</span><span id="c044" class="ne lw jj mv b gy ny ng l nh ni">            _row["name"] = name.text<br/>            _row["url"] = name.get("href")<br/>            _row["description"] = description.text</span><span id="f939" class="ne lw jj mv b gy ny ng l nh ni">            results.append(_row)<br/>    <br/>    return results</span></pre><p id="0761" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们:</p><ol class=""><li id="e75d" class="nk nl jj lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">使用请求向SEARCH_URL发送请求并获取DOM内容</li><li id="8781" class="nk nl jj lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">将dom内容转换成漂亮的组对象，我们可以使用CSS选择器和其他类似XPATH的方法来选择DOM元素。</li><li id="bf0b" class="nk nl jj lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">选择<code class="fe ms mt mu mv b">#TableWithRules</code>表格下的所有<code class="fe ms mt mu mv b">tr</code>，选择该行的第一列作为名称，第二列作为描述，然后提取文本。</li></ol><h2 id="cac4" class="ne lw jj bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">查找漏洞详细信息</h2><p id="b698" class="pw-post-body-paragraph kz la jj lb b lc mn kk le lf mo kn lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要查找漏洞详细信息，您需要提供漏洞的CVE ID，并将其传递到以下URL:<a class="ae jg" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8315" rel="noopener ugc nofollow" target="_blank">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-</a>ID</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/8c14ce84298d979edd221563f35e7b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_x3XrVIIxLwM3xdZZMRKgA.png"/></div></div></figure><p id="60bf" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开您的开发人员控制台，让我们检查一下DOM结构。</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/cc50f259f2b571005ce96c515795e628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVm6gCEkGKNeBN8vLz0OqQ.png"/></div></div></figure><p id="ebc1" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看上面的结构有点复杂，因为表行没有用类名或id标识。我们需要遍历每一行，检查它是否是一个副标题，如果是，那么我们把下一个元素作为子内容。每个字幕在<code class="fe ms mt mu mv b">th</code>中呈现，而内容在<code class="fe ms mt mu mv b">td</code>中呈现</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="26d2" class="ne lw jj mv b gy nf ng l nh ni">def lookup_cve(name):<br/>    url = f"{CVE_URL}{name}"<br/>    html = get_html(url)<br/>    soup = BeautifulSoup(html, "lxml")<br/>    result_rows = soup.select("#GeneratedTable table tr")</span><span id="6f43" class="ne lw jj mv b gy ny ng l nh ni">subtitle = ""<br/>    description = ""</span><span id="80c8" class="ne lw jj mv b gy ny ng l nh ni">raw_results = {}</span><span id="2589" class="ne lw jj mv b gy ny ng l nh ni">for row in result_rows:<br/>        head = row.select_one("th")<br/>        if head:<br/>           subtitle = head.text<br/>        else:<br/>            body = row.select_one("td")<br/>            description = body.text.strip().strip("\n")<br/>            raw_results[subtitle.lower()] = description   <br/>            <br/>    return raw_results</span></pre><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oo"><img src="../Images/a4d80203ddbe0284d1f3ae48c6ffc3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-a7IJOT4epoMrWhL7ZC2EA.png"/></div></div></figure><p id="810f" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Tada！我们已经成功地创建了我们的CVE网络刮刀。你现在可以用两个函数(search和lookup_sve)来搜索漏洞，并使用漏洞的CVE ID来获取漏洞的详细信息。</p><figure class="mw mx my mz gt iv"><div class="bz fp l di"><div class="op oq l"/></div></figure><h1 id="983c" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">构建我们的命令行应用程序</h1><p id="d263" class="pw-post-body-paragraph kz la jj lb b lc mn kk le lf mo kn lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下一步是使用Click库构建我们的命令行应用程序。</p><p id="306c" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Click是一个Python包，用于以可组合的方式用尽可能少的代码创建漂亮的命令行界面。这是创建CLI的最佳python包之一，并且易于入门</p><p id="57fd" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Click，您可以构建任何类型的简单或企业级CLI，如Heroku CLI。</p><p id="6a95" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的CLI中，我们将实现两个命令:</p><ol class=""><li id="a1de" class="nk nl jj lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">搜索漏洞</li><li id="258f" class="nk nl jj lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">查找漏洞</li></ol><p id="8b5e" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ms mt mu mv b">cver</code>文件夹中创建一个名为<code class="fe ms mt mu mv b">__main__.py</code>的文件，并输入以下基本代码:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d676" class="ne lw jj mv b gy nf ng l nh ni">import sys<br/>import click</span><span id="e0ed" class="ne lw jj mv b gy ny ng l nh ni"><a class="ae jg" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>.group()<br/><a class="ae jg" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>.version_option("1.0.0")<br/>def main():<br/>    """A CVE Search and Lookup CLI"""<br/>    print("Hye")<br/>    pass</span><span id="785a" class="ne lw jj mv b gy ny ng l nh ni"><a class="ae jg" href="http://twitter.com/main" rel="noopener ugc nofollow" target="_blank">@main</a>.command()<br/><a class="ae jg" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>.argument('keyword', required=False)<br/>def search(**kwargs):<br/>    """Search through CVE Database for vulnerabilities"""<br/>    click.echo(kwargs)<br/>    pass</span><span id="1522" class="ne lw jj mv b gy ny ng l nh ni"><a class="ae jg" href="http://twitter.com/main" rel="noopener ugc nofollow" target="_blank">@main</a>.command()<br/><a class="ae jg" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>.argument('name', required=False)<br/>def look_up(**kwargs):<br/>    """Get vulnerability details using its CVE-ID on CVE Database"""<br/>    click.echo(kwargs)<br/>    pass</span><span id="ea84" class="ne lw jj mv b gy ny ng l nh ni">if __name__ == '__main__':<br/>    args = sys.argv<br/>    if "--help" in args or len(args) == 1:<br/>        print("CVE")<br/>    main()</span></pre><h2 id="943f" class="ne lw jj bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">搜索漏洞</h2><p id="9a64" class="pw-post-body-paragraph kz la jj lb b lc mn kk le lf mo kn lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了实现这一点，我们将从web scraper导入搜索功能，并从命令行向其传递关键字参数，以搜索与该关键字匹配的漏洞:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="8241" class="ne lw jj mv b gy nf ng l nh ni">from scraper import search as cve_search, lookup_cve</span><span id="4866" class="ne lw jj mv b gy ny ng l nh ni"><a class="ae jg" href="http://twitter.com/main" rel="noopener ugc nofollow" target="_blank">@main</a>.command()<br/><a class="ae jg" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>.argument('keyword', required=False)<br/>def search(**kwargs):<br/>    """Search through CVE Database for vulnerabilities"""<br/>    results = cve_search(kwargs.get("keyword"))<br/>    for res in results:<br/>        click.echo(f'{res["name"]} - {res["url"]} \n{res["description"]}')</span></pre><p id="722c" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行此命令:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="b32c" class="ne lw jj mv b gy nf ng l nh ni">python cver/__main__.py search python</span></pre><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oo"><img src="../Images/07dcbd377d228ec74f5856105ee49632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I3iF2M_BQJavu1HK0SmpVQ.png"/></div></div></figure><h2 id="4c36" class="ne lw jj bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">查找漏洞</h2><p id="95a4" class="pw-post-body-paragraph kz la jj lb b lc mn kk le lf mo kn lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">同样的事情在这里，我们将使用来自web scraper的<code class="fe ms mt mu mv b">lookup_cve</code>,并从<code class="fe ms mt mu mv b">look_up</code>命令传递给它name参数。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="03f2" class="ne lw jj mv b gy nf ng l nh ni"><a class="ae jg" href="http://twitter.com/main" rel="noopener ugc nofollow" target="_blank">@main</a>.command()<br/><a class="ae jg" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>.argument('name', required=False)<br/>def look_up(**kwargs):<br/>    """Get vulnerability details using its CVE-ID on CVE Database"""<br/>    details = lookup_cve(kwargs.get("name"))<br/>    click.echo(f'CVE-ID \n\n{details["cve-id"]}\n')<br/>    click.echo(f'Description \n\n{details["description"]}\n')<br/>    click.echo(f'References \n\n{details["references"]}\n')<br/>    click.echo(f'Assigning CNA \n\n{details["assigning cna"]}\n')<br/>    click.echo(f'Date Entry \n\n{details["date entry created"]}')</span></pre><p id="b1ba" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行此命令:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c26a" class="ne lw jj mv b gy nf ng l nh ni">python cver/__main__.py look-up CVE-2013-4238</span></pre><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/045fe93957c70b1f87c0174a1fa6bcb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6l8aNTUgLxXtbaCtMDSKTg.png"/></div></div></figure><p id="6a0c" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Tada！我们已经成功构建了CVE查找命令行工具。</p><figure class="mw mx my mz gt iv"><div class="bz fp l di"><div class="op oq l"/></div></figure><h1 id="4278" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">向PyPI发布我们的命令行应用程序</h1><p id="9401" class="pw-post-body-paragraph kz la jj lb b lc mn kk le lf mo kn lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们已经成功地构建了命令行应用程序，一切都运行良好，我们可以将它发布到PyPI供公众使用和安装。</p><p id="6432" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyPI是python包的软件仓库，它保存了我们使用<code class="fe ms mt mu mv b">pip</code>命令工具安装的大多数Python包。要在PyPI上发布一个包，你需要<a class="ae jg" href="https://pypi.org/account/register/" rel="noopener ugc nofollow" target="_blank">创建一个账户</a>，这样你就可以去网站创建一个新账户，如果你已经有了一个，那么你就可以开始了。</p><h2 id="6368" class="ne lw jj bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">配置我们的包</h2><p id="cb1c" class="pw-post-body-paragraph kz la jj lb b lc mn kk le lf mo kn lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一旦你完成了这些，下一件事就是使用<code class="fe ms mt mu mv b">setup.py</code>配置我们的Python包。为了将您的包上传到PyPI，您需要提供一些关于包的基本信息。该信息通常在setup.py文件中提供。</p><p id="ff4f" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，打开项目基本目录中的<code class="fe ms mt mu mv b">setup.py</code>,并将它放在文件的开头:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="914d" class="ne lw jj mv b gy nf ng l nh ni">from setuptools import setup, find_packages<br/>from io import open<br/>from os import path</span><span id="c932" class="ne lw jj mv b gy ny ng l nh ni">import pathlib<br/># The directory containing this file<br/>HERE = pathlib.Path(__file__).parent</span><span id="27b7" class="ne lw jj mv b gy ny ng l nh ni"># The text of the README file<br/>README = (HERE / "README.md").read_text()</span><span id="4f74" class="ne lw jj mv b gy ny ng l nh ni"># automatically captured required modules for install_requires in requirements.txt and as well as configure dependency links<br/>with open(path.join(HERE, 'requirements.txt'), encoding='utf-8') as f:<br/>    all_reqs = f.read().split('\n')</span><span id="93a8" class="ne lw jj mv b gy ny ng l nh ni">install_requires = [x.strip() for x in all_reqs if ('git+' not in x) and (<br/>    not x.startswith('#')) and (not x.startswith('-'))]<br/>dependency_links = [x.strip().replace('git+', '') for x in all_reqs \<br/>                    if 'git+' not in x]</span></pre><p id="42fb" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们将<code class="fe ms mt mu mv b">README.md</code>文件的内容转换成字符串供以后使用。我们还从<code class="fe ms mt mu mv b">requirements.txt</code>中捕获了所有需要的模块，并生成了它们的依赖链接。</p><p id="24e6" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的requirements.txt文件应该如下所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c9e1" class="ne lw jj mv b gy nf ng l nh ni">click<br/>requests<br/>beautifulsoup4<br/>lxml<br/>twine</span></pre><p id="37bb" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看我们的设置配置:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="deca" class="ne lw jj mv b gy nf ng l nh ni">setup (<br/> name = 'cver',<br/> description = 'A simple commandline app for searching and looking up opensource vulnerabilities',<br/> version = '1.0.0',<br/> packages = find_packages(), # list of all packages<br/> install_requires = install_requires,<br/> python_requires='&gt;=2.7', # any python greater than 2.7<br/> entry_points='''<br/>        [console_scripts]<br/>        cver=cver.__main__:main<br/>    ''',<br/> author="Oyetoke Toby",<br/> keyword="cve, vuln, vulnerabilities, security, nvd",<br/> long_description=README,<br/> long_description_content_type="text/markdown",<br/> license='MIT',<br/> url='<a class="ae jg" href="https://github.com/CITGuru/cver/'" rel="noopener ugc nofollow" target="_blank">https://github.com/CITGuru/cver'</a>,<br/> download_url='<a class="ae jg" href="https://github.com/CITGuru/cver/archive/1.0.0.tar.gz'" rel="noopener ugc nofollow" target="_blank">https://github.com/CITGuru/cver/archive/1.0.0.tar.gz'</a>,<br/>  dependency_links=dependency_links,<br/>  <a class="ae jg" href="mailto:author_email='oyetoketoby80@gmail.com" rel="noopener ugc nofollow" target="_blank">author_email='oyetoketoby80@gmail.com</a>',<br/>  classifiers=[<br/>        "License :: OSI Approved :: MIT License",<br/>        "Programming Language :: Python :: 2.7",<br/>        "Programming Language :: Python :: 3",<br/>        "Programming Language :: Python :: 3.7",<br/>    ]<br/>)</span></pre><p id="9fd0" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们添加了一些选项，这里我们将只介绍设置中可用的一些选项。<a class="ae jg" href="https://setuptools.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">设置工具文档很好地研究了所有细节。</a></p><ol class=""><li id="d40a" class="nk nl jj lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">name:将出现在PyPI上的包的名称</li><li id="7183" class="nk nl jj lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">版本:您的软件包的当前版本</li><li id="f771" class="nk nl jj lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">包:包含源代码的包和子包。我们正在使用设置中的<code class="fe ms mt mu mv b">find_packages</code>模块来帮助我们自动找到我们的子包。</li><li id="c938" class="nk nl jj lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">install_requires:这是用来列出你的包拥有的任何依赖项或第三方库。在<code class="fe ms mt mu mv b">cver</code>中，我们使用了requests、beautifulsoup4和click。它们必须包含在install_requires安装程序中。我们不需要手动放置它，因为我们已经阅读了<code class="fe ms mt mu mv b">requirements.txt</code>来获取它们。</li><li id="97f9" class="nk nl jj lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">entry_points:这用于创建调用包内函数的脚本。在我们的设置中，我们创建了一个新的脚本<code class="fe ms mt mu mv b">cver</code>，它在cver/__main__中调用main()。py文件。我们的主入口是<code class="fe ms mt mu mv b">__main__.py</code>，它调用<code class="fe ms mt mu mv b">main()</code>函数来启动click。</li></ol><p id="4856" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在向PyPI或公众发布您的包之前，您应该添加一些文档。如何记录包取决于您的项目。这可能是一个简单的<code class="fe ms mt mu mv b">README.md</code>文件或<code class="fe ms mt mu mv b">Readme.rst</code>文件，完全取决于你。</p><p id="1f16" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个典型的好听的<code class="fe ms mt mu mv b">README.md</code>:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="e4d1" class="ne lw jj mv b gy nf ng l nh ni"># CVER</span><span id="e305" class="ne lw jj mv b gy ny ng l nh ni">A simple commandline app for searching and looking up opensource vulnerabilities</span><span id="cc45" class="ne lw jj mv b gy ny ng l nh ni"># Installation</span><span id="2cac" class="ne lw jj mv b gy ny ng l nh ni">## Using Pip</span><span id="bdc5" class="ne lw jj mv b gy ny ng l nh ni">```bash<br/>  $ pip install cver<br/>```</span><span id="4ee7" class="ne lw jj mv b gy ny ng l nh ni">## Manual</span><span id="285f" class="ne lw jj mv b gy ny ng l nh ni">```bash<br/>  $ git clone <a class="ae jg" href="https://github.com/citguru/cevr" rel="noopener ugc nofollow" target="_blank">https://github.com/citguru/cevr</a><br/>  $ cd cver<br/>  $ python setup.py install<br/>```</span><span id="9aff" class="ne lw jj mv b gy ny ng l nh ni"># Usage</span><span id="cc14" class="ne lw jj mv b gy ny ng l nh ni">```bash<br/>$ cver<br/>```</span><span id="3be2" class="ne lw jj mv b gy ny ng l nh ni">## Search</span><span id="e06e" class="ne lw jj mv b gy ny ng l nh ni">`search &lt;keyword&gt;`</span><span id="c101" class="ne lw jj mv b gy ny ng l nh ni">```bash<br/>$ cver search python<br/>```<br/>## Lookup</span><span id="ce64" class="ne lw jj mv b gy ny ng l nh ni">`search &lt;name&gt;`</span><span id="af0d" class="ne lw jj mv b gy ny ng l nh ni">```bash<br/>$ cver look-up CVE-2020-2121<br/>```</span></pre><p id="23bd" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，创建一个<code class="fe ms mt mu mv b">.gitignore</code>文件:</p><figure class="mw mx my mz gt iv"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="b4f8" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。</p><figure class="mw mx my mz gt iv"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="a5e9" class="ne lw jj bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">发布到PyPI</h2><p id="b363" class="pw-post-body-paragraph kz la jj lb b lc mn kk le lf mo kn lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一旦一切都成功完成，这个包就可以公开发布了，并发布在<a class="ae jg" href="https://pypi.org" rel="noopener ugc nofollow" target="_blank"> PyPI </a>上。确保你已经创建了一个我前面提到的帐户，你还需要在<a class="ae jg" href="https://test.pypi.org" rel="noopener ugc nofollow" target="_blank"> PyPI测试服务器</a>上创建一个测试帐户，以便在发布到实时服务器之前测试包。</p><p id="e95b" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用一个叫做<a class="ae jg" href="https://packaging.python.org/tutorials/packaging-projects/" rel="noopener ugc nofollow" target="_blank"> Twine </a>的工具来上传你的python包到PyPI。它应该在前面的步骤中安装，但是如果你没有安装，你可以只做<code class="fe ms mt mu mv b">pip install twine</code>。</p><h2 id="d157" class="ne lw jj bd lx nz oa dn mb ob oc dp mf li od oe mh lm of og mj lq oh oi ml oj bi translated">在本地和测试服务器上构建和测试包</h2><p id="8cc6" class="pw-post-body-paragraph kz la jj lb b lc mn kk le lf mo kn lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">PyPI上发布的Python包不是以普通源代码的形式发布的，而是被打包成发布包。Python wheels和源代码档案是分发Python包时最常见的格式。</p><p id="5d1e" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python wheels本质上是一个包含您的代码的zip存档，并且包括任何可以使用的扩展。Source Archives由您的源代码和任何支持文件组成，打包到一个tar文件中。</p><p id="cb83" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在本地测试我们的包，我们只需要运行:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="0f2c" class="ne lw jj mv b gy nf ng l nh ni">python setup.py install</span></pre><p id="4d22" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们现在可以把它当作:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="fe2d" class="ne lw jj mv b gy nf ng l nh ni">cver search python</span></pre><p id="edc5" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在<a class="ae jg" href="https://pypi.org" rel="noopener ugc nofollow" target="_blank"> PyPI </a>测试服务器上测试我们的包，我们需要为本地测试生成一个构建。创建一个构建将同时生成python wheel和源档案。</p><p id="f2aa" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建构件:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="f4ba" class="ne lw jj mv b gy nf ng l nh ni">python setup.py sdist bdist_wheel</span></pre><p id="f186" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在<code class="fe ms mt mu mv b">dist</code>目录中生成两个文件:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c3d9" class="ne lw jj mv b gy nf ng l nh ni">cvecli/<br/>│<br/>└── dist/<br/>    ├── cver-1.0.0-py3-none-any.whl<br/>    └── cver-1.0.0.tar.gz</span></pre><p id="6e8e" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后使用twine，我们现在可以上传到服务器:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="905c" class="ne lw jj mv b gy nf ng l nh ni">twine upload --repository-url https://test.pypi.org/legacy/ dist/*</span></pre><p id="afde" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将要求您输入用户名和密码，因此请确保输入正确。</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/9b27172e277a5066a22a53645a30b425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PMwdGMMQZfvzXOgVsiQqzg.png"/></div></div></figure><p id="221d" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果上传成功，没有任何问题，这意味着我们可以在服务器上发布。你可以在这里查看<a class="ae jg" href="https://test.pypi.org/project/cver/1.0.0/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="6a14" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要从<a class="ae jg" href="https://test.pypi.org" rel="noopener ugc nofollow" target="_blank"> TestPyPI </a>安装，运行以下命令:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="12c4" class="ne lw jj mv b gy nf ng l nh ni">pip install -i <a class="ae jg" href="https://test.pypi.org/simple/" rel="noopener ugc nofollow" target="_blank">https://test.pypi.org/simple/</a> cver==1.0.0</span></pre><p id="68c9" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里你可以尝试所有的命令，看看在我们发布到服务器之前是否一切顺利。</p><p id="6fd6" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试完所有命令并准备好发布到live server后:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="e571" class="ne lw jj mv b gy nf ng l nh ni">twine upload dist/*</span></pre><p id="ca85" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出现提示时，输入您的用户名和密码。就是这样！</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/bb97104a7efea5c75d694642498d19bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YWI4hRGO61vNW-twI3iQYw.png"/></div></div></figure><p id="caf9" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以使用以下方式安装它:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="b11d" class="ne lw jj mv b gy nf ng l nh ni">pip install cver</span></pre><p id="8a58" class="pw-post-body-paragraph kz la jj lb b lc ld kk le lf lg kn lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！你的包发布在PyPI上，你可以在这里查看<a class="ae jg" href="https://pypi.org/project/cver/1.0.0/" rel="noopener ugc nofollow" target="_blank"/>！</p><h1 id="bf56" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">结论</h1><p id="735e" class="pw-post-body-paragraph kz la jj lb b lc mn kk le lf mo kn lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我解释了如何用Python构建和发布下一个命令行应用程序的逐步过程。</p></div></div>    
</body>
</html>