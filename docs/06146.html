<html>
<head>
<title>End-to-End Machine Learning Project: Part-1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">端到端机器学习项目:第1部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/end-to-end-machine-learning-project-part-1-806d04da8deb?source=collection_archive---------50-----------------------#2020-05-18">https://towardsdatascience.com/end-to-end-machine-learning-project-part-1-806d04da8deb?source=collection_archive---------50-----------------------#2020-05-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/acbef8b1de4e0bd380fbdd0b121b4440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uO2f1jAU78B-C7lD"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">比约恩·斯内尔德斯在<a class="ae jh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><p id="78ab" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><strong class="kj jl"> <em class="lf">端到端机器学习</em> </strong> <em class="lf">关注的是准备你的数据，在上面训练一个模型，然后部署那个模型</em>。这两部分系列的目标是展示如何为图像分类模型开发和部署端到端的机器学习项目，并使用<em class="lf">迁移学习</em>。</p><p id="4b7d" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">尽管有大量的其他在线资源向您详细展示了如何构建您自己的模型，但是很少有资源深入研究如何部署这些模型。本文是第二部分的前身，第二部分将展示部署步骤。如果你已经熟悉构建这样一个模型，并且正在寻找如何部署它的方法，那么我建议你浏览一下这篇文章，看看<a class="ae jh" rel="noopener" target="_blank" href="/end-to-end-machine-learning-project-627ed48f8109">第2部分</a>。</p><blockquote class="lg lh li"><p id="7c4a" class="kh ki lf kj b kk kl km kn ko kp kq kr lj kt ku kv lk kx ky kz ll lb lc ld le in bi translated">第一部分(本文):准备数据并训练图像分类模型<br/> <a class="ae jh" rel="noopener" target="_blank" href="/end-to-end-machine-learning-project-627ed48f8109">第二部分</a>:使用Flask和Docker部署构建好的模型</p></blockquote><p id="e07f" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><strong class="kj jl"> <em class="lf">机器学习</em> </strong>模型目前被广泛用于构建聊天机器人、语音助手、无人驾驶汽车等。一个具体的进步是在图像识别和分类领域。<a class="ae jh" href="https://en.wikipedia.org/wiki/Convolutional_neural_network" rel="noopener ugc nofollow" target="_blank">卷积神经网络(CNN)</a>尤其被证明在从图像中学习方面非常有帮助，这导致了在创建最先进模型方面的重大突破，如<a class="ae jh" href="https://arxiv.org/abs/1512.03385" rel="noopener ugc nofollow" target="_blank"> Resnet </a>、<a class="ae jh" href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" rel="noopener ugc nofollow" target="_blank"> Alexnet </a>、<a class="ae jh" href="https://arxiv.org/abs/1409.4842" rel="noopener ugc nofollow" target="_blank"> Inception </a>等。这已经被证明在<a class="ae jh" href="http://www.image-net.org/" rel="noopener ugc nofollow" target="_blank"> Imagenet数据集</a>上对图像进行分类时非常有效。</p><p id="0d49" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在这篇文章中，我们将看到如何从头开始训练一个图像分类模型，并使用Resnet模型中预先训练好的权重。这种技术称为<strong class="kj jl"><em class="lf"/></strong>迁移学习，非常受欢迎，因为它有助于使用使用大得多的数据集和计算资源训练的权重，以最小的变化应用于另一个数据集。通常，您只需根据数据集更改输出图层，就可以从这些预训练的权重中获益。这个项目中模型的目标是<em class="lf">对不同的美钞</em>进行分类，并使用<strong class="kj jl"> <em class="lf"> Tensorflow 2.x </em> </strong>和<strong class="kj jl"> <em class="lf"> Keras构建。</em>T13】</strong></p><h1 id="cbc0" class="lm ln jk bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">要求</h1><p id="4577" class="pw-post-body-paragraph kh ki jk kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le in bi translated">第一个挑战是收集数据。由于找不到任何适合这个项目的数据集，我最终拍摄了不同美钞的照片来创建我自己的数据集。该最终数据集包含大约<em class="lf"> 180幅图像</em>，其中包括一些负图像，即没有任何美钞的图像，因此当图像中有美钞时，模型可以更好地区分。</p><p id="12fd" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我使用<a class="ae jh" href="https://gradient.paperspace.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kj jl"><em class="lf">paper space Gradient</em></strong></a><strong class="kj jl"><em class="lf"/></strong>来训练模型，这非常类似于Google Colab，并提供免费的GPU和基于Jupyter笔记本的环境来训练模型。<em class="lf">在我看来，这上面的免费GPU比Google Colab里面提供的好一点</em>。</p><h1 id="153d" class="lm ln jk bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">数据准备和加载</h1><p id="e2e3" class="pw-post-body-paragraph kh ki jk kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le in bi translated">由于这些图像的大小都不同，第一步是做一些数据准备，并将它们的大小调整为相同的大小。Resnet期望输入图像大小为<strong class="kj jl"> 224x224 </strong>，因此我调整了数据集中图像的大小以匹配。我还使用<em class="lf">数据扩充</em>技术来补充我的数据集，这也有助于<em class="lf">减少过度拟合</em>。</p><blockquote class="lg lh li"><p id="133d" class="kh ki lf kj b kk kl km kn ko kp kq kr lj kt ku kv lk kx ky kz ll lb lc ld le in bi translated"><strong class="kj jl"> <em class="jk">数据扩充</em> </strong>通过应用产生看起来可信的图像的随机变换，帮助从现有训练样本生成更多训练数据。<em class="jk">目标是在训练时，你的模特永远不会两次看到完全相同的图片。这将模型暴露给数据的更多方面，从而允许它更好地进行归纳。</em></p></blockquote><p id="03a7" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如下图1所示，对图像进行了处理和加载。</p><figure class="mq mr ms mt gu iw gi gj paragraph-image"><div class="gi gj mp"><img src="../Images/d01a9d1f1d60a16ef40c6a85e967ade6.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*l4uB4c10hg5gA2jjgF5CDw.jpeg"/></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图片-1:数据准备步骤(作者提供图片)</p></figure><p id="e4f3" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">20%的可用图像，没有增强，被留在一边用于<strong class="kj jl"> <em class="lf">验证</em> </strong>。</p><blockquote class="mu"><p id="3bdc" class="mv mw jk bd mx my mz na nb nc nd le dk translated"><em class="ne">重要的是保持验证集不变，以便更好地评估您训练的模型。</em></p></blockquote><p id="8e37" class="pw-post-body-paragraph kh ki jk kj b kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la nj lc ld le in bi translated">剩余的图像用于训练模型。类别标签采用<em class="lf">一键编码。</em></p><figure class="mq mr ms mt gu iw gi gj paragraph-image"><div class="gi gj nk"><img src="../Images/adfd5153fb8d391bfcc186380b7e5de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*LK1ZAJuqtQORMoabpEokDw.jpeg"/></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图片-2:班级指数(作者照片)</p></figure><figure class="mq mr ms mt gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nl"><img src="../Images/b4b8313f9b18cc93131766db7d54183d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ODm7Y191y5WiRXbQD9YffA.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图3:可视化数据集(作者照片)</p></figure><h1 id="48e4" class="lm ln jk bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">训练一个简单的CNN模型</h1><p id="a13c" class="pw-post-body-paragraph kh ki jk kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le in bi translated">既然我已经加载并扩充了数据集，下一步就是训练模型。我首先创建一个简单的CNN模型，它有一个由4个卷积层和最大池层组成的集合，然后是一个带有T2激活函数的输出层。</p><figure class="mq mr ms mt gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nm"><img src="../Images/840db64e86eacc6608ca8d7e792091d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xKTSsb9kZbGD-JqTqHtWA.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图4:简单的CNN模型架构(作者拍摄)</p></figure><p id="c533" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我把这个模型设定为<em class="lf"> 100个</em> <a class="ae jh" href="https://machinelearningmastery.com/difference-between-a-batch-and-an-epoch/" rel="noopener ugc nofollow" target="_blank"> <em class="lf">纪元</em> </a> <em class="lf">。</em>我还为<a class="ae jh" href="https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/EarlyStopping" rel="noopener ugc nofollow" target="_blank"> <strong class="kj jl"> <em class="lf">使用了一个回调函数，提前停止</em></strong></a><strong class="kj jl"><em class="lf"/></strong><em class="lf">(</em><a class="ae jh" href="https://machinelearningmastery.com/how-to-stop-training-deep-neural-networks-at-the-right-time-using-early-stopping/" rel="noopener ugc nofollow" target="_blank"><em class="lf">more info</em></a><em class="lf">)</em><strong class="kj jl"><em class="lf">，</em> </strong>当它看到模型没有进一步改进并且开始<a class="ae jh" href="https://machinelearningmastery.com/overfitting-and-underfitting-with-machine-learning-algorithms/" rel="noopener ugc nofollow" target="_blank">过拟合</a>时，就停止训练。对于该模型训练，<em class="lf">验证损失</em>在第30个时期附近停止下降，并且由于提前停止，训练在第40个时期停止。使用另一个回调函数— <a class="ae jh" href="https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/ModelCheckpoint" rel="noopener ugc nofollow" target="_blank"> <strong class="kj jl"> <em class="lf">模型检查点</em> </strong> </a>保存第30时段的<em class="lf">最佳模型—</em>。</p><figure class="mq mr ms mt gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nn"><img src="../Images/5bf2e0f2419da382e1656ff4dcebf79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Grq2SA9-JRak-zReDEyN0w.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图5:简单的CNN模型图(作者照片)</p></figure><h1 id="9931" class="lm ln jk bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">使用迁移学习训练模型</h1><p id="1184" class="pw-post-body-paragraph kh ki jk kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le in bi translated">简单的CNN模型在验证集上表现不太好，所以尝试创建更好的模型的下一步是使用迁移学习。我选择了<em class="lf"> Resnet50v2作为基础模型</em>的imagenet权重。感谢Keras，它使得使用<a class="ae jh" href="https://www.tensorflow.org/api_docs/python/tf/keras/applications" rel="noopener ugc nofollow" target="_blank"><em class="lf">TF . Keras . applications</em></a>包在一行中获得这些权重变得容易得多，拥有一个模型架构列表，如resnet、inception等。用他们预先训练好的重量。</p><blockquote class="lg lh li"><p id="602d" class="kh ki lf kj b kk kl km kn ko kp kq kr lj kt ku kv lk kx ky kz ll lb lc ld le in bi translated">在开始编译和训练基础模型之前，<strong class="kj jl">冻结</strong>(防止训练期间体重更新)是很重要的。您可以通过设置<code class="fe no np nq nr b">layer.trainable = False</code>来冻结模型的单层。一个模型可以有许多层，所以将整个模型的可训练标志设置为<strong class="kj jl">假</strong>将冻结所有层。</p></blockquote><p id="33be" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在冻结了基本Resnet50v2模型的层之后，我添加了一个<a class="ae jh" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/GlobalAveragePooling2D" rel="noopener ugc nofollow" target="_blank"> GlobalAveragePooling </a>层，然后是一个激活了softmax的密集层，以获得所有类的预测值。</p><figure class="mq mr ms mt gu iw gi gj paragraph-image"><div class="gi gj ns"><img src="../Images/7873ac390faab507f969acfa1017ff86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*KDvy0mVIaOUHikZPwIIfsQ.jpeg"/></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图片-6:迁移学习模型架构(作者提供图片)</p></figure><p id="f31e" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><em class="lf">注意，在图6中，大约2350万个参数(对应于基本Resnet50v2模型)被冻结并标记为不可训练参数。我们只训练大约14000个与最终输出层相关的参数。</em></p><p id="abf8" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">下一步是使用<em class="lf"> adam optimizer </em>编译和训练模型，其中<em class="lf">分类_交叉熵损失</em>是根据<em class="lf">准确性度量计算的。</em></p><blockquote class="lg lh li"><p id="d87b" class="kh ki lf kj b kk kl km kn ko kp kq kr lj kt ku kv lk kx ky kz ll lb lc ld le in bi translated">注意这里使用的categorical _ crossentropy，因为每个标签都由一个独热向量表示。如果单个值(类的索引)代表每个标签，应该使用sparse _ categorical _ crossentropy。</p></blockquote><p id="9a67" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">与简单的CNN模型类似，我将这个模型设置为使用相同的两个回调函数训练100个纪元，但这个模型的性能甚至更差。<em class="lf">验证损失</em>在仅仅4个时期后开始增加，这非常糟糕，但这可能是因为基础模型的预训练imagenet权重不直接与我的数据集一起工作，并且可能我必须重新训练基础模型的一些层，以帮助它学习特定于我的数据集的特征。</p><h1 id="797d" class="lm ln jk bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">使用迁移学习对模型进行微调和训练</h1><p id="cd4b" class="pw-post-body-paragraph kh ki jk kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le in bi translated">预先训练的基础Resnet50v2模型在这个现成的数据集上表现不太好，但仍有一些希望，以<strong class="kj jl"> <em class="lf">微调</em> </strong> <em class="lf">的形式。</em></p><blockquote class="lg lh li"><p id="2271" class="kh ki lf kj b kk kl km kn ko kp kq kr lj kt ku kv lk kx ky kz ll lb lc ld le in bi translated"><strong class="kj jl">微调</strong>基础模型是迁移学习中的一个过程，在这个过程中，你训练模型的最上面几层，保持这些层的权重不变。这将强制将权重从通用要素映射调整为与这些顶层的当前数据集特定关联的要素。</p></blockquote><p id="ab01" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在使用了几次之后，我发现调整基本模型的前70层在这个数据集上工作得非常好。您可能需要经过几轮讨论才能得出适合您的特定数据集的数字。<em class="lf"> Resnet50v2模型总共有190层</em>，不包括输出层，所以我保持前120层的权重<em class="lf">冻结，并在我的数据集</em>上重新训练后70层的权重。</p><figure class="mq mr ms mt gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nt"><img src="../Images/ab6abbe13184ff19c68aad50925d38de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W697U-VINswp_YcsoOfNAw.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图7:微调的模型架构(作者提供照片)</p></figure><figure class="mq mr ms mt gu iw gi gj paragraph-image"><div class="gi gj ns"><img src="../Images/324945d83768237b3e98d778126cb707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*IJtIEVdUYg9m0loIA2NucQ.jpeg"/></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图8:微调后的模型拱门(作者拍摄)</p></figure><p id="59c6" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果你仔细观察图8，你会发现这个微调模型有超过1800万个可训练参数，相比之下，当我保持基本模型的所有权重不变时，只有大约14000个可训练参数(参见图6)。</p><p id="cf13" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">与其他两个模型类似，我将这个经过微调的模型设置为使用相同的两个回调函数运行100个时期。在第24代左右，<em class="lf">验证损失</em>开始非常缓慢地增加，这表明模型从这一点开始<em class="lf">缓慢地过度拟合</em>。最佳模型在这一瞬间被保存。</p><figure class="mq mr ms mt gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nu"><img src="../Images/0055b2146e307702a6d9e85d47392c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tLSEH3r5c4TutfHZ4dU-9g.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">图9:微调后的模型图(作者提供照片)</p></figure><h1 id="b0f5" class="lm ln jk bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="a111" class="pw-post-body-paragraph kh ki jk kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le in bi translated">在使用不同的模型进行了几次迭代之后，我能够训练一个在我的数据集上表现良好的模型。迁移学习肯定很有帮助，并且是一种在你自己的数据集上快速建立模型的巧妙技术，同时获得预先训练的成功模型的好处。</p><p id="fcbc" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">改进该模型的下一步将是添加更多数据，并尝试使用<a class="ae jh" href="http://cnnlocalization.csail.mit.edu/" rel="noopener ugc nofollow" target="_blank">类激活图(CAMs) </a>来了解模型关注图像的哪些部分。</p><p id="82eb" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><em class="lf">你可以在这里</em>  <em class="lf">找到用来训练这三个型号</em> <a class="ae jh" href="https://github.com/impiyush/Projects/blob/master/Recognize_US_Bills/model/US-Bills-TF2_v2.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="lf">的笔记本和代码。</em></a></p><p id="8b62" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在本系列的下一部分中，我们将看到如何使用<em class="lf"> Flask和Docker部署训练好的模型。</em>现在就来看看吧，享受创建新数据集、训练模型和部署它们的乐趣。</p><p id="2e11" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><em class="lf">下次见……</em></p></div></div>    
</body>
</html>