<html>
<head>
<title>Productivity Booster: Interactive visualisation of composite estimator and pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生产力助推器:复合估算器和管道的交互式可视化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/productivity-booster-interactive-visualisation-of-composite-estimator-and-pipeline-407ab780671a?source=collection_archive---------75-----------------------#2020-08-31">https://towardsdatascience.com/productivity-booster-interactive-visualisation-of-composite-estimator-and-pipeline-407ab780671a?source=collection_archive---------75-----------------------#2020-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2d33" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener" target="_blank" href="https://towardsdatascience.com/data-visualization/home">内部 AI </a></h2><div class=""/><div class=""><h2 id="9d92" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Scikit-Learn 0.23 版本中的前处理步骤的可视化是生产力的助推器。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e6b9bca255cc8ecb65aca5a963fd555a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oAuUQ8ZEMTypSlDZRlNDww.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">管道和估计器可视化——文章中讨论的代码的输出</p></figure><p id="0d1c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">根据我的经验，在现实生活中的机器学习项目中，最大的工作份额是数据预处理。使用适当的预处理数据训练模型是稍后获得准确预测的先决条件。</p><p id="cece" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通常，由于连续的预处理和转换，它变得非常复杂，以至于解开它变得非常繁琐和耗时。如果您的同事已经完成了部分预处理逻辑，而您需要完成剩余的部分，这将变得更具挑战性。</p><p id="72b4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Scikit-Learn 在 2020 年 5 月的 0.23 版本中引入了丰富的复合估值器和管道结构的交互式可视化。</p><p id="d7c3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，我将说明如何使用这个主要的新特性来改进我们对复杂的顺序预处理步骤的理解，并在出现任何问题时指出错误的步骤。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="894e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，我们将使用 Seaborn 包中著名的“Titanic”数据集。现实世界中大多数收集的数据都有缺失值。这里，我们将使用 SimpleImputer，KNNImputer 来填充样本 Titanic 数据集中缺失的值。我们需要 ColumnTransformer 对不同的列执行一组不同的转换。</p><pre class="ks kt ku kv gt mk ml mm mn aw mo bi"><span id="57c9" class="mp mq it ml b gy mr ms l mt mu"><strong class="ml jd">import seaborn as sns<br/>from sklearn.pipeline import Pipeline<br/>from sklearn.impute import SimpleImputer ,KNNImputer<br/>from sklearn.preprocessing import StandardScaler, OneHotEncoder<br/>from sklearn.compose import ColumnTransformer<br/>from sklearn.decomposition import PCA<br/>from sklearn.ensemble import RandomForestClassifier</strong></span></pre><p id="b1e2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，我们将下载样本 titanic 数据集，并从完整的可用要素集中选择一些要素作为自变量。<br/>如下面的代码所示，大写的“X”通常用于表示自变量，小写的“y”表示因变量。</p><pre class="ks kt ku kv gt mk ml mm mn aw mo bi"><span id="2faa" class="mp mq it ml b gy mr ms l mt mu"><strong class="ml jd">TitanicDataset=sns.load_dataset("titanic")</strong></span><span id="7e69" class="mp mq it ml b gy mv ms l mt mu"><strong class="ml jd">X=TitanicDataset[["sex","age","fare","embarked","who","pclass",<br/>"sibsp"]].copy()<br/>y=TitanicDataset[["survived"]].copy()</strong></span></pre><p id="7cce" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因为特性“fare”没有任何记录的空白值，所以我们不需要估算器。在下面的代码中，根据要应用的一组预处理和变换对功能进行了分组。</p><pre class="ks kt ku kv gt mk ml mm mn aw mo bi"><span id="9fd2" class="mp mq it ml b gy mr ms l mt mu"><strong class="ml jd">numeric_independent_variables1= ['fare']<br/>numeric_independent_variables2= [ 'age', 'pclass','sibsp']</strong></span><span id="5eb1" class="mp mq it ml b gy mv ms l mt mu"><strong class="ml jd">categorical_independent_variables=["who","embarked","sex"]</strong></span></pre><p id="f256" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们为三组特征定义了三种不同的管线。第一个管道只涉及缩放，而在第二个管道中依次提到输入和缩放。对于分类特征，使用最频繁策略填充缺失值，然后使用 OneHotEncoder 将分类值转换为数值。</p><pre class="ks kt ku kv gt mk ml mm mn aw mo bi"><span id="8b43" class="mp mq it ml b gy mr ms l mt mu"><strong class="ml jd">numeric_pipeline1=Pipeline([('scaler', StandardScaler())])</strong></span><span id="e4e9" class="mp mq it ml b gy mv ms l mt mu"><strong class="ml jd">numeric_pipeline2=Pipeline([('imputer', KNNImputer(n_neighbors=7)),('scaler', StandardScaler())])</strong></span><span id="d204" class="mp mq it ml b gy mv ms l mt mu"><strong class="ml jd">categorical_pipeline=Pipeline([('imputer',SimpleImputer(strategy='most_frequent')),('onehot', OneHotEncoder(handle_unknown='error'))])</strong></span></pre><p id="32a3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将使用 column transformer，因为我们将对不同的列组使用一组不同的预处理和转换。</p><pre class="ks kt ku kv gt mk ml mm mn aw mo bi"><span id="584c" class="mp mq it ml b gy mr ms l mt mu"><strong class="ml jd">consolidated_pipeline= ColumnTransformer([('num1', numeric_pipeline1, numeric_independent_variables1),('num2', numeric_pipeline2, numeric_independent_variables2),('cat', categorical_pipeline, categorical_independent_variables)])</strong></span></pre><p id="2408" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在前面的步骤中，在一个列变压器中，提到了三条管线。</p><p id="db61" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，我们有一个嵌套的管道，将更早的“合并 _ 管道<strong class="lj jd">”、“</strong> pca <strong class="lj jd">”、</strong>和“分类器”放入新的管道“clf”。</p><pre class="ks kt ku kv gt mk ml mm mn aw mo bi"><span id="1f14" class="mp mq it ml b gy mr ms l mt mu"><strong class="ml jd">clf = Pipeline([('consolidated_pipeline', consolidated_pipeline),('pca',PCA(n_components=5)),('classifier',RandomForestClassifier(max_depth=5))])</strong></span></pre><p id="051b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">解释转换的顺序已经变得相当复杂，即使与实际项目相比，预处理和转换顺序相对简单</p><p id="e515" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在 0.19 版本中，Scikit-Learn 引入了 set_config 包。在 2020 年 5 月发布的 0.23 版本中，添加了“显示”参数，以实现复合估算器和管道的交互式可视化。</p><pre class="ks kt ku kv gt mk ml mm mn aw mo bi"><span id="18ca" class="mp mq it ml b gy mr ms l mt mu"><strong class="ml jd">from sklearn import set_config<br/>from sklearn.utils import estimator_html_repr</strong></span><span id="e02a" class="mp mq it ml b gy mv ms l mt mu"><strong class="ml jd">set_config(display='diagram')<br/>diaplay(clf) # for</strong> <strong class="ml jd">Jupyter Notebook and Google Collab</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e6b9bca255cc8ecb65aca5a963fd555a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oAuUQ8ZEMTypSlDZRlNDww.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">管道和估计器可视化——文章中讨论的代码的输出</p></figure><p id="5817" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你正在运行 Jupyter 笔记本和 Google Collab 中的代码，那么上面的代码将带来管道的结构和其他复合估算器。点击各个方框显示参数。</p><p id="9d65" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你正在使用 IDLE，那么你可以用下面的代码在你的本地机器上下载完整的结构。由于我们没有在下面的代码中提供任何文件夹路径，因此 HTML 文件将保存在与主 python 程序相同的位置。</p><pre class="ks kt ku kv gt mk ml mm mn aw mo bi"><span id="164d" class="mp mq it ml b gy mr ms l mt mu"><strong class="ml jd">with open('estimator.html', 'w') as f:<br/>    f.write(estimator_html_repr(clf)) # for saving the HTML file</strong></span></pre><p id="a2da" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们不需要浏览所有的预处理和转换编码，只需看一眼，就可以通过这种树形结构的可视化来了解管道和转换序列。对于冗长复杂的嵌套管道和预处理步骤，它有助于我们快速确定问题区域，是真正的生产力助推器。</p></div></div>    
</body>
</html>