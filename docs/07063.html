<html>
<head>
<title>Host Polynote Notebooks With Basic Authentication on AWS Fargate With Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在AWS Fargate上使用Terraform进行基本身份验证的主机Polynote笔记本</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/host-polynote-notebooks-with-basic-authentication-on-aws-fargate-with-terraform-65d4ff3ba730?source=collection_archive---------48-----------------------#2020-05-30">https://towardsdatascience.com/host-polynote-notebooks-with-basic-authentication-on-aws-fargate-with-terraform-65d4ff3ba730?source=collection_archive---------48-----------------------#2020-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f7a5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">本文将帮助您使用Terraform在ECS上轻松部署安全的Polynote环境。</h2></div><p id="e395" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近我发布了一篇关于旋转Jupyter笔记本的文章。本文描述了如何使用Terraform轻松启动Jupyter笔记本环境。这篇文章将大致相同，但然后与Polynote笔记本。</p><div class="lc ld gp gr le lf"><a rel="noopener follow" target="_blank" href="/spinning-up-jupyter-notebooks-as-ecs-service-in-aws-with-terraform-805ac111d74b"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">使用Terraform在AWS中将Jupyter笔记本电脑升级为ECS服务</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">在这篇文章中，我将解释如何使用Terraform在几秒钟内在AWS上运行Jupyter笔记本。</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">towardsdatascience.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt lu lf"/></div></div></a></div><p id="b211" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么我发表了两篇有些相同的文章？嗯，Jupyter笔记本有一个问题，对我们(我所在的团队)来说，这个问题使它无法工作。问题是当你刷新页面时输出会丢失，这是一个<a class="ae lb" href="https://github.com/jupyter/jupyter/issues/83" rel="noopener ugc nofollow" target="_blank">已知的问题</a>。根据我在互联网上搜索后的理解，这只是一个可视化/表示错误，你的脚本实际上会在后台继续运行，但输出会发送到浏览器会话，当你刷新页面或在另一个设备上打开它时，输出会丢失。除了这个问题，Jupyter并不是最适合我们的需求，设置需要一些额外的步骤，这些步骤与上一篇文章无关:</p><ul class=""><li id="bc2e" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la ma mb mc md bi translated">Polynote需要一个配置文件，该文件需要包含在定制的Docker映像中。</li><li id="0f9a" class="lv lw iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">Polynote环境不能像Jupyter笔记本一样用令牌或密码来保护，所以我们需要为此添加一个额外的层(先睹为快:将使用NGINX)。</li></ul><h2 id="2cea" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">先决条件</h2><p id="207a" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">要使这个设置工作起来，有一些先决条件，让我们从已经启动并运行的AWS服务开始(设置这些不在本文的讨论范围之内):</p><ul class=""><li id="c155" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la ma mb mc md bi translated">ECS集群</li><li id="44ee" class="lv lw iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">应用程序负载平衡器</li><li id="9b5e" class="lv lw iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">Route53内的托管区域和域</li></ul><p id="bdf3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将与Terraform合作，所以你也需要<a class="ae lb" href="https://learn.hashicorp.com/terraform/getting-started/install.html" rel="noopener ugc nofollow" target="_blank">在你的设备上安装那个</a>。Terraform使您能够以代码的形式组织和管理您的(云)服务和基础设施。您还需要一个像<a class="ae lb" href="https://aws.amazon.com/cli/" rel="noopener ugc nofollow" target="_blank"> AWS命令行界面</a> (CLI)这样的工具，配置一个概要文件，这样我们就可以，或者说是Terraform，与您的AWS环境进行通信。或者，您可以在您的设备上安装<a class="ae lb" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> Docker </a>，以防您想要更改Polynote配置文件并重建Docker映像，或者更改NGINX映像并重建它。</p><h1 id="6de6" class="nh mk iq bd ml ni nj nk mo nl nm nn mr jw no jx mu jz np ka mx kc nq kd na nr bi translated">下载或克隆文件</h1><p id="babb" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">现在，我假设您已经设置了所需的AWS服务，并且已经在您的计算机上安装了所需的软件。出于本文的目的，我已经建立了<a class="ae lb" href="https://github.com/sschrijver/spawn-polynote-notebooks-fargate" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>，在这里你可以找到我们在这里讨论的代码片段的所有最终文件。为了避免可能的错误，我建议将存储库克隆到您的计算机上/从repo下载文件，而不是复制并粘贴本文中的所有代码片段(有些部分将不讨论，因此它们不包含在本文中)。</p><h1 id="7cc4" class="nh mk iq bd ml ni nj nk mo nl nm nn mr jw no jx mu jz np ka mx kc nq kd na nr bi translated">知识库结构</h1><p id="0c1a" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">如您所见，存储库包含3个文件夹:</p><ul class=""><li id="473e" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la ma mb mc md bi translated">多项式码头</li><li id="7b2e" class="lv lw iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">nginx</li><li id="7408" class="lv lw iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">将（行星）地球化（以适合人类居住）</li></ul><p id="a4e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ns"> polynote-docker </em>文件夹包含创建官方Polynote docker映像的Docker映像所需的所有文件。简而言之；通常，当你想运行Polynote Docker映像时，你需要一个<em class="ns"> config.yml </em>文件。我已经将该文件包含在自定义映像中，因此我们不必在ECS中添加卷。我们不会进一步讨论Docker映像，因为我已经将一个映像推送到Docker Hub，它将在本设置中使用。我还创建了自己的NGINX映像，基于这个映像:<a class="ae lb" href="https://github.com/dtan4/nginx-basic-auth-proxy" rel="noopener ugc nofollow" target="_blank">dtan 4/NGINX-basic-auth-proxy</a>。这张图片向我们的NGINX添加了基本的auth，并且我为websockets添加了一个额外的路径，这是Polynote工作所必需的。<em class="ns"> terraform </em>文件夹包含在AWS上设置整个环境所需的所有文件，该文件夹由以下三个文件组成:</p><ul class=""><li id="8dd3" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la ma mb mc md bi translated">main.tf(“魔法”发生的地方)</li><li id="39a2" class="lv lw iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">vars.tf(在<em class="ns"> main.tf </em>中使用的变量声明)</li><li id="93ae" class="lv lw iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">vars.tfvars(为变量赋值)</li></ul><h1 id="cc41" class="nh mk iq bd ml ni nj nk mo nl nm nn mr jw no jx mu jz np ka mx kc nq kd na nr bi translated">编辑变量. tfvars</h1><p id="cbe5" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">我们将从编辑<em class="ns"> vars.tfvars </em>文件开始，因为这些变量值将在后面的<em class="ns">main . TF</em><strong class="kh ir"><em class="ns"/></strong>文件中使用。您必须重新访问除了<code class="fe nt nu nv nw b">cpu</code>和<code class="fe nt nu nv nw b">memory</code>之外的所有变量值，当然，除非您想要增加或减少资源。</p><p id="e762" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">变量. tfvars </strong></p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="a6cf" class="mj mk iq nw b gy of og l oh oi">vpc_id = "YOUR_VPC"<br/>region = "eu-west-1"<br/>profile_name = "LOCAL_PROFILE_NAME"<br/>ecs_cluster_name = "CLUSTER_NAME"<br/>loadbalancer_arn = "LOAD_BALANCER_ARN"<br/>hosted_zone_id = "HOSTED_ZONE_ID"<br/>fargate_subnets = [  <br/>    "PRIVATE_SUBNET_1",  <br/>    "PRIVATE_SUBNET_2",  <br/>    "PRIVATE_SUBNET_3"<br/>]<br/>cpu = 1024<br/>memory = 2048<br/>domain = "mydomainname.com"</span></pre><p id="ec09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有信息都可以在AWS控制台中找到，除了配置文件名称，这将是您在本地计算机上用来配置AWS CLI的AWS配置文件名称，例如通过<br/> <code class="fe nt nu nv nw b">aws configure --profile=test</code>，这里的“测试”是配置文件名称。如果您没有设置配置文件名，它可能会设置为“默认”。</p><h1 id="9e23" class="nh mk iq bd ml ni nj nk mo nl nm nn mr jw no jx mu jz np ka mx kc nq kd na nr bi translated"><code class="fe nt nu nv nw b">Gain Insight Into the Working of The main.tf File</code></h1><p id="ea2f" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">现在，让我们看一下<em class="ns"> main.tf </em>文件，正如我之前所说的，所有的“魔法”都发生在这里。这个文件包含了我们需要的所有资源来使这个设置工作。幸运的是，如果我们做得很好，我们唯一要做的就是运行一个命令，Terraform会完成剩下的工作，所以知道文件中有什么是很好的。我不会深入研究地形的概念。</p><h2 id="496f" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">获取现有ECS集群</h2><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="1bcd" class="mj mk iq nw b gy of og l oh oi">data "aws_ecs_cluster" "ecs_cluster" {<br/>  cluster_name = var.ecs_cluster_name<br/>}</span></pre><p id="e53e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的块中，将检索现有的ECS集群，稍后将在脚本中使用该集群。</p><h2 id="6981" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">生成唯一标识符</h2><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="3fdd" class="mj mk iq nw b gy of og l oh oi">resource "random_string" "random_string" {<br/>  length = 8<br/>  special = false<br/>}</span></pre><p id="9ecc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能非常令人困惑，为什么要生成随机字符串呢？因为我们希望能够同时启动多个环境，所以我们需要给一些资源名称添加一个独特的部分。我们正在创建的某些资源不能与现有的同类型资源同名。如果我们不添加这个独特的部分，并且人员A已经有了一个正在运行的Polynote环境，那么人员B就不能创建一个新的环境，因为AWS中已经存在一个具有该特定名称的特定资源。</p><h2 id="ae4c" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">添加任务执行角色</h2><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="643c" class="mj mk iq nw b gy of og l oh oi">resource "aws_iam_role" "ecs_task_execution_role" {<br/>  name = "ecsTaskExecutionRole-polynote-${random_string.random_string.result}"<br/>  assume_role_policy = &lt;&lt;ASSUME_ROLE_POLICY<br/>{<br/>"Version": "2012-10-17",<br/>"Statement": [<br/>    {<br/>      "Sid": "",<br/>      "Effect": "Allow",<br/>      "Principal": {<br/>        "Service": "ecs-tasks.amazonaws.com"<br/>      },<br/>      "Action": "sts:AssumeRole"<br/>    }<br/>  ]<br/>}<br/>ASSUME_ROLE_POLICY<br/>}</span><span id="6f6c" class="mj mk iq nw b gy oj og l oh oi">data "aws_iam_policy" "amazon_ecs_task_execution_role_policy" {<br/>  arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"<br/>}</span><span id="ad05" class="mj mk iq nw b gy oj og l oh oi">resource "aws_iam_role_policy_attachment" "policy_role_attachment" {<br/>  role = aws_iam_role.ecs_task_execution_role.name<br/>  policy_arn = data.aws_iam_policy.amazon_ecs_task_execution_role_policy.arn<br/>}</span></pre><p id="58f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码行将创建一个任务执行角色，并将已经存在的<em class="ns">amazonectaskexecutionrolepolicy</em>(由Amazon提供)附加到该角色，这允许您将容器的日志发送到CloudWatch。如果您需要访问Polynote笔记本中的其他AWS服务，您需要编写必要的策略，并将它们附加到一个新角色(任务角色)上，并将其作为<code class="fe nt nu nv nw b">task_role_arn</code>添加到<code class="fe nt nu nv nw b">polynote_task_definition</code>中。我们不会在本文中讨论这个问题，但是所需的部分可以在Git存储库中找到，并且现在已经被注释了。</p><h2 id="7cbf" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">添加云观察日志组</h2><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="038d" class="mj mk iq nw b gy of og l oh oi">resource "aws_cloudwatch_log_group" "polynote_ecs_log_group" {<br/>  name = "/aws/ecs/polynote-${random_string.random_string.result}"<br/>}</span></pre><p id="6d25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于日志记录的目的，我们还创建了一个日志组。</p><h2 id="1e98" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">生成密码以访问笔记本</h2><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="9dc6" class="mj mk iq nw b gy of og l oh oi">resource "random_string" "password" {<br/>  length = 24<br/>  special = false<br/>}</span></pre><p id="de02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们想用至少一个密码来保护Polynote笔记本环境，所以我们生成了一个随机字符串。这一步需要重新考虑，因为在当前的设置中，密码将作为纯文本环境变量传递给容器。最好在秘密管理器中设置一个秘密，并使用任务定义中的<code class="fe nt nu nv nw b">secrets</code>属性来解决这个问题。</p><h2 id="1477" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">创建ECS任务定义</h2><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="4595" class="mj mk iq nw b gy of og l oh oi">resource "aws_ecs_task_definition" "polynote_task_definition" {<br/>  family = "polynote-${random_string.random_string.result}"<br/>  requires_compatibilities = [<br/>    "FARGATE"]<br/>  network_mode = "awsvpc"<br/>  cpu = var.cpu<br/>  memory = var.memory<br/>  execution_role_arn = aws_iam_role.ecs_task_execution_role.arn</span><span id="9cdb" class="mj mk iq nw b gy oj og l oh oi">container_definitions = &lt;&lt;TASK_DEFINITION<br/>  [<br/>    {<br/>        "essential": true,<br/>        "image": "registry.hub.docker.com/sschrijver/polynote-basic-config:latest",<br/>        "name": "polynote",<br/>        "portMappings": [<br/>            {<br/>                "containerPort": 8192,<br/>                "hostPort": 8192<br/>            }<br/>        ],<br/>        "logConfiguration": {<br/>                "logDriver": "awslogs",<br/>                "options": {<br/>                  "awslogs-region": "${var.region}",<br/>                  "awslogs-group": "${aws_cloudwatch_log_group.polynote_ecs_log_group.name}",<br/>                  "awslogs-stream-prefix": "polynote-${random_string.random_string.result}"<br/>            }<br/>        }<br/>    },<br/>    {<br/>        "essential": true,<br/>        "image": "registry.hub.docker.com/sschrijver/polynote-nginx:latest",<br/>        "name": "nginx",<br/>        "dependsOn": [<br/>            {<br/>                "containerName": "polynote",<br/>                "condition": "START"<br/>            }<br/>        ],<br/>        "portMappings": [<br/>            {<br/>                "containerPort": 8080,<br/>                "hostPort": 8080<br/>            }<br/>        ],<br/>        "logConfiguration": {<br/>                "logDriver": "awslogs",<br/>                "options": {<br/>                  "awslogs-region": "${var.region}",<br/>                  "awslogs-group": "${aws_cloudwatch_log_group.polynote_ecs_log_group.name}",<br/>                  "awslogs-stream-prefix": "nginx-${random_string.random_string.result}"<br/>            }<br/>        },<br/>        "environment": [<br/>            {<br/>                "name": "SERVER_NAME",<br/>                "value": "127.0.0.1"<br/>            },<br/>            {<br/>                "name": "PORT",<br/>                "value": "8080"<br/>            },<br/>            {<br/>                "name": "BASIC_AUTH_USERNAME",<br/>                "value": "polynote"<br/>            },<br/>            {<br/>                "name": "BASIC_AUTH_PASSWORD",<br/>                "value": "${random_string.password.result}"<br/>            },<br/>            {<br/>                "name": "PROXY_PASS",<br/>                "value": "<a class="ae lb" href="http://127.0.0.1:8192" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8192</a>"<br/>            }<br/>        ]<br/>    }<br/>  ]<br/>  TASK_DEFINITION<br/>}</span></pre><p id="bf9e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个很长的片段，但是在上面你看到了我们将要运行的ECS/Fargate服务的任务定义(蓝图)，如果你熟悉<em class="ns"> docker-compose.yml </em>文件，它看起来有点像下面这样(没有<code class="fe nt nu nv nw b">logConfiguration</code>):</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="f2c9" class="mj mk iq nw b gy of og l oh oi">version: '3.4'<br/>services:<br/>  polynote:<br/>    image: registry.hub.docker.com/sschrijver/polynote-basic-config:latest<br/>    expose:<br/>      - 8192<br/>  nginx:<br/>    image: registry.hub.docker.com/sschrijver/polynote-nginx:latest<br/>    depends_on:<br/>      - polynote<br/>    ports:<br/>      - 8080:8080<br/>    environment:<br/>      - SERVER_NAME=127.0.0.1<br/>      - PORT=8080<br/>      - BASIC_AUTH_USERNAME=polynote<br/>      - BASIC_AUTH_PASSWORD=${random_string.password.result}<br/>      - PROXY_PASS=<a class="ae lb" href="http://polynote:8192" rel="noopener ugc nofollow" target="_blank">http://polynote:8192</a></span></pre><p id="cf8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，请注意<code class="fe nt nu nv nw b">PROXY_PASS</code>中的不同，Fargate不会像<code class="fe nt nu nv nw b">docker-compose</code>那样处理解析主机，我们必须在任务定义中通过127.0.0.1进行连接。</p><h2 id="e60c" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">NGINX</h2><p id="57ce" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">您可以看到任务定义中有两个容器。这是因为我们还需要在服务中运行NGINX。这个NGINX实际上会被暴露，并会增加一个额外的基本认证层，这样陌生人就无法访问我们的笔记本电脑，或者更糟；访问我们的AWS环境。感谢景岛乐·藤田发布了<a class="ae lb" href="https://github.com/dtan4/nginx-basic-auth-proxy" rel="noopener ugc nofollow" target="_blank">dtan 4/nginx-basic-auth-proxy</a>库及其代码，我的图片就是基于这些代码。我更新了映像中NGINX的版本，还添加了一个websocket路径。就我个人而言，我会建议您分叉他或我的存储库，进行一些调整，并将您自己的Docker映像推/用到ECR/Docker Hub，因为在安全性和Docker映像标签方面，有些东西肯定可以改进/重新访问。</p><p id="f4bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们进一步走到<em class="ns"> main.tf </em>文件。</p><h2 id="cdac" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">获取现有的VPC、负载平衡器和负载平衡器侦听器</h2><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="f893" class="mj mk iq nw b gy of og l oh oi">data "aws_vpc" "vpc" {<br/>  id = var.vpc_id<br/>}</span><span id="945a" class="mj mk iq nw b gy oj og l oh oi">data "aws_lb" "lb" {<br/>  arn = var.loadbalancer_arn<br/>}</span><span id="f0ae" class="mj mk iq nw b gy oj og l oh oi">data "aws_lb_listener" "lb_listener" {<br/>  load_balancer_arn = var.loadbalancer_arn<br/>  port = 443<br/>}</span></pre><p id="a47e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将收到关于现有VPC、应用程序负载平衡器和负载平衡器监听器的信息。如果您使用端口80作为负载平衡器上的监听器，您应该将443改为80。</p><h2 id="067c" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">创建负载平衡器目标组</h2><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="97a2" class="mj mk iq nw b gy of og l oh oi">resource "aws_lb_target_group" "polynote_target_group" {<br/>  name = "polynote-${random_string.random_string.result}"<br/>  port = 80<br/>  protocol = "HTTP"<br/>  vpc_id = data.aws_vpc.vpc.id<br/>  target_type = "ip"<br/>  health_check {<br/>    matcher = "200,302,401"<br/>  }<br/>}</span></pre><p id="99ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想要将ECS服务附加到负载平衡器(或者将负载平衡器规则指向ECS服务，这取决于您如何看待它)，您还需要一个目标组。这将在稍后定义服务时使用。如您所见，HTTP响应代码401 <strong class="kh ir"> <em class="ns"> </em> </strong>也包含在健康检查中，因为我们的NGINX服务将返回401(未授权)响应代码，因为我们已经包含了一个基本的身份验证层。</p><h2 id="8f5d" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">创建安全组</h2><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="f3e9" class="mj mk iq nw b gy of og l oh oi">resource "aws_security_group" "polynote_security_group" {<br/>    name = "polynote_${random_string.random_string.result}"<br/>    vpc_id = data.aws_vpc.vpc.id</span><span id="6269" class="mj mk iq nw b gy oj og l oh oi">ingress {<br/>      description = "Incoming 8080"<br/>      from_port = 8080<br/>      to_port = 8080<br/>      protocol = "tcp"<br/>      security_groups = data.aws_lb.lb.security_groups<br/>    }</span><span id="d5f9" class="mj mk iq nw b gy oj og l oh oi">egress {<br/>      from_port = 0<br/>      to_port = 0<br/>      protocol = "-1"<br/>      cidr_blocks = [<br/>        "0.0.0.0/0"]<br/>    }</span><span id="cd89" class="mj mk iq nw b gy oj og l oh oi">tags = {<br/>      Name = "polynote_${random_string.random_string.result}"<br/>    }<br/>  }</span></pre><p id="1a70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">负载平衡器需要访问ECS服务，因此我们向安全组添加了一个入口规则，该规则稍后将附加到ECS服务。这个入口规则允许我们的负载平衡器与运行在端口8080上的NGINX通信。</p><h2 id="34e7" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">创建ECS服务</h2><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="107e" class="mj mk iq nw b gy of og l oh oi">resource "aws_ecs_service" "polynote_service" {<br/>  name = "polynote-${random_string.random_string.result}"<br/>  cluster = data.aws_ecs_cluster.ecs_cluster.id<br/>  task_definition = aws_ecs_task_definition.polynote_task_definition.id<br/>  desired_count = 1<br/>  launch_type = "FARGATE"</span><span id="e6ba" class="mj mk iq nw b gy oj og l oh oi">network_configuration {<br/>    subnets = var.fargate_subnets<br/>    security_groups = [<br/>      aws_security_group.polynote_security_group.id]<br/>  }</span><span id="b964" class="mj mk iq nw b gy oj og l oh oi">load_balancer {<br/>    target_group_arn = aws_lb_target_group.polynote_target_group.arn<br/>    container_name = "nginx"<br/>    container_port = 8080<br/>  }<br/>  depends_on = [<br/>    aws_lb_target_group.polynote_target_group]<br/>}</span></pre><p id="bdcb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们已经准备好了创建ECS/Fargate服务的所有构件。我猜上面的片段是不言自明的。</p><h2 id="a710" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">创建负载平衡器侦听器规则</h2><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="3ab5" class="mj mk iq nw b gy of og l oh oi">resource "aws_lb_listener_rule" "polynote_lb_listener_rule" {<br/>  listener_arn = data.aws_lb_listener.lb_listener.arn<br/>  priority = null</span><span id="4455" class="mj mk iq nw b gy oj og l oh oi">action {<br/>    type = "forward"<br/>    target_group_arn = aws_lb_target_group.polynote_target_group.arn<br/>  }</span><span id="6952" class="mj mk iq nw b gy oj og l oh oi">condition {<br/>    host_header {<br/>      values = [<br/>        "polynote-${random_string.random_string.result}.${var.domain}"]<br/>    }<br/>  }</span><span id="70c5" class="mj mk iq nw b gy oj og l oh oi">depends_on = [<br/>    aws_lb_target_group.polynote_target_group]<br/>}</span></pre><p id="198f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望我们的ECS服务可以公开访问，所以我们添加了一个负载平衡器侦听器规则。如您所见，我定义了一个主机头条件，这是因为我将把Route53子域指向负载均衡器DNS(参见下面的参考资料)。如果您想直接使用负载平衡器DNS，您可能需要稍微调整一下这个资源，并使用<code class="fe nt nu nv nw b">path_pattern</code>条件，就像在<a class="ae lb" href="https://www.terraform.io/docs/providers/aws/r/lb_listener_rule.html" rel="noopener ugc nofollow" target="_blank"> Terraform文档</a>中所述的那样。如果您这样做，请注意，它将影响脚本中稍后的输出和资源，所以在您进行更改时，请重新访问这些块。</p><h2 id="e528" class="mj mk iq bd ml mm mn dn mo mp mq dp mr ko ms mt mu ks mv mw mx kw my mz na nb bi translated">创建Route53记录</h2><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="7595" class="mj mk iq nw b gy of og l oh oi">resource "aws_route53_record" "polynote_cname" {<br/>  zone_id = var.hosted_zone_id<br/>  name = "polynote-${random_string.random_string.result}.${var.domain}"<br/>  type = "CNAME"<br/>  records = [<br/>    data.aws_lb.lb.dns_name]<br/>  ttl = 300<br/>}</span><span id="b078" class="mj mk iq nw b gy oj og l oh oi">output "url" {<br/>  value = "https://${aws_route53_record.polynote_cname.name}"<br/>}<br/><br/>output "username" {<br/>  value = "polynote"<br/>}<br/><br/>output "password" {<br/>  value = random_string.password.result<br/>}</span></pre><p id="57e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我已经说过的，我在Route53中设置了一个指向负载均衡器的子域。毕竟，我将输出完整的URL来访问环境，这将在触发正确的Terraform命令后最多大约5分钟内在线。</p><h1 id="dcce" class="nh mk iq bd ml ni nj nk mo nl nm nn mr jw no jx mu jz np ka mx kc nq kd na nr bi translated">运行Terraform脚本</h1><p id="405e" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">现在我们已经(基本)了解了脚本的功能，我们可以执行Terraform脚本了。确保您已经编辑了<em class="ns"> vars.tfvars </em>，使其符合您的AWS环境，并确保您已经安装了Terraform，并在您的设备上配置了正确的AWS配置文件。</p><p id="e28f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，您必须在包含。tf文件，方法是在终端中执行以下命令:</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="012c" class="mj mk iq nw b gy of og l oh oi">terraform init</span></pre><blockquote class="ok"><p id="f8e0" class="ol om iq bd on oo op oq or os ot la dk translated"><code class="fe nt nu nv nw b">terraform init</code>命令用于初始化包含Terraform配置文件的工作目录。这是在编写新的Terraform配置或从版本控制中克隆现有配置后应该运行的第一个命令。多次运行该命令是安全的。<br/> <strong class="ak">来源</strong> : <a class="ae lb" href="https://www.terraform.io/docs/commands/init.html" rel="noopener ugc nofollow" target="_blank"> terraform.io </a></p></blockquote><p id="7d11" class="pw-post-body-paragraph kf kg iq kh b ki ou jr kk kl ov ju kn ko ow kq kr ks ox ku kv kw oy ky kz la ij bi translated">然后，您希望应用带有<em class="ns"> vars.tfvars </em>文件的Terraform配置文件，这样您就不必手动输入这些信息。您可以通过运行以下命令来实现这一点:</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="dad9" class="mj mk iq nw b gy of og l oh oi">terraform apply -var-file=vars.tfvars</span></pre><p id="16f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也将输出Terraform将对您的AWS环境采取的操作，并要求您确认。仔细阅读Terraform将采取的行动，并通过键入<code class="fe nt nu nv nw b">yes</code>确认(随后按Enter)。现在将在您的环境中创建资源。</p><p id="21f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当脚本完成时，它将输出一个URL和凭证，您可以使用它们来访问Polynote环境，如下所示:</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="df71" class="mj mk iq nw b gy of og l oh oi">Outputs:</span><span id="2822" class="mj mk iq nw b gy oj og l oh oi">password = ZoG2ZMzFxY3aUNCImstvXfYM<br/>url = <a class="ae lb" href="https://polynote-py11kxuq.pondatalab.com" rel="noopener ugc nofollow" target="_blank">https://polynote-py11kxuq.mydomainname.com</a><br/>username = polynote</span></pre><p id="6f6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">容器实际运行需要一些时间，所以请耐心等待(大约5分钟)。一旦它启动并运行，您进入该网站，将显示一个弹出窗口，您可以在其中输入凭据。当您提供正确的凭证时，您将被转到Polynote环境。现在您可以在Polynote环境中做任何您想做的事情:-)！我建议创建一个新的笔记本，而不是使用<em class="ns"> Blank.ipynb </em>，因为它会因为任何原因导致内核问题。</p><figure class="nx ny nz oa gt pa gh gi paragraph-image"><div role="button" tabindex="0" class="pb pc di pd bf pe"><div class="gh gi oz"><img src="../Images/4668b62e3b150993418891122165caf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8vCNMu8_RWWPiRi7SSnRA.png"/></div></div><p class="pg ph gj gh gi pi pj bd b be z dk translated">多项式界面</p></figure><h1 id="3f22" class="nh mk iq bd ml ni nj nk mo nl nm nn mr jw no jx mu jz np ka mx kc nq kd na nr bi translated">破坏Polynote环境</h1><p id="eed8" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">完成后，您可以通过执行以下Terraform命令来轻松破坏Polynote环境:</p><pre class="nx ny nz oa gt ob nw oc od aw oe bi"><span id="2428" class="mj mk iq nw b gy of og l oh oi">terraform destroy -var-file=vars.tfvars</span></pre><p id="e0d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它会再次要求确认，键入<code class="fe nt nu nv nw b">yes</code>来销毁所有资源。</p><h1 id="f591" class="nh mk iq bd ml ni nj nk mo nl nm nn mr jw no jx mu jz np ka mx kc nq kd na nr bi translated">待办事项</h1><p id="93ba" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">我已经在这篇文章中提到了一些要做的事情。当然还有很多需要改进的地方，但我想确保您了解以下几点:</p><ul class=""><li id="dc9d" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la ma mb mc md bi translated">Polynote密码目前是一个环境变量，Secrets Manager可能是一个更好的选择。</li><li id="b2e1" class="lv lw iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">重新访问安全NGINX层。这个解决方案真的安全吗？至少它提供了某种保护，而默认情况下Polynote笔记本没有密码或令牌保护。</li><li id="a4fd" class="lv lw iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated">如果取消对任务角色策略的注释，请注意，它目前没有限制，这意味着它可以访问您的所有AWS资源。您不希望这样，所以请确保您进行了更改，以便该服务只能访问它需要访问的资源。</li></ul><h1 id="7bd6" class="nh mk iq bd ml ni nj nk mo nl nm nn mr jw no jx mu jz np ka mx kc nq kd na nr bi translated">问题或反馈</h1><p id="490e" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">如果您对本文有任何问题或反馈；请让我知道！</p></div></div>    
</body>
</html>