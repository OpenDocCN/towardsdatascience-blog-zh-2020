# MonetDB 如何利用现代 CPU 性能

> 原文：<https://towardsdatascience.com/how-monetdb-x100-exploits-modern-cpu-performance-9b3a395b5a2b?source=collection_archive---------31----------------------->

## 现代 CPU 经历了重大的发展。但是 MonetDB 如何利用这种发展来最大化其性能呢？

在过去的三十年里，计算机处理器有了显著的发展。这种发展不仅包括它所拥有的晶体管数量的增加，还包括架构的演变。因此，应用程序需要适应 CPU 的工作方式，以最大限度地发挥其潜力。与 CPU 本身一样古老，数据库系统一直是现代工业的支柱。但是数据库社区已经设法将 CPU 能力发挥到极限了吗？

![](img/807baa2fba9a3ef24d091bb3a601c1c1.png)

克里斯蒂安·威迪格在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

尽管 CPU 得到了积极的发展，但现有的数据库系统无法利用这一优势，因为它们只能实现*低指令/周期* (IPC)效率。他们主要使用一个*火山*查询执行模型，这是造成这种低效率的原因。volcano 模型使用一种称为“一次一个元组”的处理模型，它在一个 CPU 周期内执行一个元组。因此，它引入了解释开销，并通过执行*循环流水线*阻碍了 CPU 执行并行执行的能力。在 MySQL 数据库系统中的观察表明，实际计算只占总执行时间的 10%[2]。剩下的 90%是解释开销，比如创建和查找哈希表，获取 MySQL 数据的第 n 个字段，复制数据进行处理。

# 解决这些效率低下的问题

记住这些背景，现在让我们深入了解 MonetDB 如何处理这些低效问题。MonetDB 是一个列式数据库，它试图通过消除数据库系统中存在的开销并使用不同的记录处理模型来利用最大的 CPU 能力。一般来说，MonetDB 一次执行多个记录，这样既能实现循环流水线，又能减少太多的开销。

## 按列执行

MonetDB 引入了一种称为二进制关联表(BAT)的列式数据布局。单个 BAT 数组在单个数据库列中保存所有值。通过这样做，我们现在可以将操作符应用到这个 BAT 数组中，而不是单独应用到每个数据项。此外，在数据阵列上运行相同的操作，CPU 现在可以应用循环流水线。

我们在这篇文章中讨论了很多循环流水线。但是什么是循环流水线呢？请看下图。

![](img/ea544a819f1e44c831cb1b88cd95148c.png)

图片来自:[https://www . Xilinx . com/support/documentation/SW _ manuals/Xilinx 2015 _ 2/SD SOC _ doc/topics/calling-coding-guidelines/concept _ piping _ loop _ unrolling . html](https://www.xilinx.com/support/documentation/sw_manuals/xilinx2015_2/sdsoc_doc/topics/calling-coding-guidelines/concept_pipelining_loop_unrolling.html)

在一个过于简单的定义中，我们可以看到一个 CPU 指令由三个阶段组成:读取、计算和写入(查看这个[维基百科页面](https://en.wikipedia.org/wiki/Central_processing_unit#Parallelism)中关于 CPU 周期的详细解释)。正如我们所见，循环流水线使 CPU 能够开始执行下一次迭代，而无需等待上一次迭代完成。放入数据处理的上下文中，循环流水线将使 CPU 能够开始读取下一个数据项，同时仍然计算当前数据的结果。因此，整个环路将具有更低的延迟。

当我们使用 BAT 数组时，这种循环流水线是可能的，因为我们有一个数组的概念来循环。然而，如果我们一次计算一个元组，这是不可能的，因为在一个元组上循环是没有意义的！在这种情况下，执行将按顺序进行，其中一个元组需要等待前一个元组完成后才能执行。

## MIL 代数

MonetDB 为其查询语言引入了 MIL (MonetDB 指令语言)代数。它可以是 RDBMS 方面的关系代数。然而，与关系代数相反，密耳代数没有自由度。在 MIL 代数中，操作员有固定的参数和数据布局来处理数据。MIL 上的操作员将把该操作员的功能映射到 BAT 中的整个数据项。

## X100 发动机

到目前为止，看起来 MonetDB 实现已经解决了我们指出的所有问题。但是，我们需要注意，MonetDB 是通过执行全列具体化来执行查询的。这意味着它将首先尝试在 CPU 缓存中具体化输入。但是，随着正在处理的数据的大小不断增加，CPU 缓存将无法容纳这一完整的列具体化，而将使用主内存。这使得系统现在受到内存带宽的限制，因此它将无法保持它所获得的高 CPU 效率。

![](img/99d598e969de3e66f6edadac86c5f3a1.png)

图片来自:[https://semi engineering . com/enabling-higher-system-performance-with-NV DIMM-n/](https://semiengineering.com/enabling-higher-system-performance-with-nvdimm-n/)

为了解决这个问题，MonetDB 开发了一款名为 X100 的改进型引擎。它引入了一种平衡的方法，避免了一次一个元组的处理，但管理了物化，使其不会占用内存带宽。这是通过仅根据向量而不是整个列来实现的。向量是整个列项目的片段。应该设置向量的大小，使其适合 CPU 缓存。通过这样做，内存带宽限制将不会阻碍高 CPU 效率的实现。

# 技术性能分析

为了分析矢量化查询处理的性能优势，我们将看到在 MonetDB/X100 到 MonetDB/MIL 和 MySQL 上执行的 TPC-H 基准测试的实验结果。

![](img/32405d39081554d101374f3a69d6dd42.png)

图片来自:彼得·A·邦茨、马钦·祖科夫斯基和尼尔斯·内斯。2005.MonetDB/X100:超级流水线查询执行。在 CIDR，第 5 卷。225–237.

从实验中我们可以得到的第一个观察结果是 MonetDB/X100 能够在每个元组很少的 CPU 周期内运行所有原语。例如，乘法原语每个元组只运行 2.2 个周期，而 MySQL 上每个元组运行 49 个周期。每个执行原语所需的周期越少，整体性能越快。

第二个观察是关于内存基准限制。由于 MonetDB/X100 仅体现为向量，因此将由图元处理的数据从 CPU 缓存中检索，而不是从主内存中检索。这使得 MonetDB/X100 能够实现 7.5GB/s 的带宽。另一方面，MonetDB/MIL 达到了仅 500MB/s 的内存带宽限制，因为图元需要从主内存中检索数据。作者还提到 MonetDB/X100 应该对缓存的数据进行操作，而列向量布局的实现并不意味着优化内存布局。

最后，作者指出了向量大小对整体性能的影响。向量的大小应该相对较小，以便可以放入缓存中。但是，如果我们把它设置得太小，我们将失去 CPU 并行性，并增加解释开销。在极端情况下，将向量大小设置为 1 将导致一次一个元组的操作。另一方面，作者还报告了当向量大小太大，即 CPU 缓存无法容纳时的性能下降。

# 结论

我们看到精心设计的数据库如何能够最大限度地发挥现代处理器的潜力，并比没有解决这个问题的数据库性能好得多。MonetDB 通过以一次一个向量的方式执行数据来利用循环流水线功能。不仅增加了 CPU 中的并行执行，而且通过根据向量而不是整列来执行具体化，避免了内存带宽瓶颈。

MonetDB 是一个长期的研究课题。如果你有兴趣了解更多关于 MonetDB 的知识，你可以在 google scholar 上查看他们的出版物。您也可以查看[主页](https://www.monetdb.org/)查看其当前状态。这也是一个开源项目，你也可以在其中做出贡献。你可以在[Github 页面](https://github.com/MonetDB/MonetDB)访问他们的镜像库。

**参考文献:**

[1]彼得·亚历山大·邦茨等人，2002 年。Monet:面向查询密集型应用的下一代 DBMS 内核。阿姆斯特丹大学[东道主]。

[2]彼得·邦茨、马尔钦·祖科夫斯基和尼尔斯·内斯。2005.MonetDB/X100:超级流水线查询执行..Cidr，第 5 卷。225–237.