<html>
<head>
<title>Community Detection in R Using Communities of Friends Characters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于朋友社区特征的R语言社区检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/community-detection-in-r-using-communities-of-friends-characters-2161e845c198?source=collection_archive---------39-----------------------#2020-06-15">https://towardsdatascience.com/community-detection-in-r-using-communities-of-friends-characters-2161e845c198?source=collection_archive---------39-----------------------#2020-06-15</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="691f" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">每个角色都有自己的迷你网络，但是它是什么样子的呢？</h2></div><p id="3950" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">在本文中，我将使用R中的<code class="fe lg lh li lj b">igraph</code>包中的社区检测功能来展示如何检测网络中的社区。在文章结束时，我们将能够看到Louvain社区检测算法如何将<em class="lk">朋友</em>角色分成不同的社区(忽略六个主要角色的明显社区)，如果你是该剧的粉丝，你可以决定这个分析对你是否有意义。</p><p id="544d" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated"><strong class="km iw"> <em class="lk">读者注意:</em> </strong> <em class="lk">如果你发现在中等格式的环境中很难理解代码，你也可以在这里</em>  <em class="lk">以降价格式</em> <a class="ae ll" href="https://github.com/keithmcnulty/friends_analysis/blob/master/Rmd/friends_character_networks.md" rel="noopener ugc nofollow" target="_blank"> <em class="lk">重新阅读。</em></a></p><h1 id="dd48" class="lm ln iv bd lo lp lq lr ls lt lu lv lw kb lx kc ly ke lz kf ma kh mb ki mc md bi translated">用于组合朋友角色网络的数据</h1><p id="3657" class="pw-post-body-paragraph kk kl iv km b kn me jw kp kq mf jz ks kt mg kv kw kx mh kz la lb mi ld le lf io bi translated">在我之前的文章中，我展示了如何使用迭代编程为《老友记》的整个系列生成一个网络边缘列表。网络边列表是一个简单的数据集，包含以下内容:</p><ol class=""><li id="90a8" class="mj mk iv km b kn ko kq kr kt ml kx mm lb mn lf mo mp mq mr bi translated"><code class="fe lg lh li lj b">from</code>和<code class="fe lg lh li lj b">to</code>列为了确定我们的(无向)网络中字符对之间的连接，每个字符将是一个节点，每个连接将是一条边。</li><li id="af43" class="mj mk iv km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated">一个<code class="fe lg lh li lj b">weight</code>列(这是边的一个属性),表示线对之间的连接强度。在这种情况下，这是由这对搭档一起出现在不同场景中的次数决定的。</li></ol><p id="3876" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我使用的edgelist是使用前两篇文章中的技术生成的，并在这个项目的<a class="ae ll" href="https://github.com/keithmcnulty/friends_analysis" rel="noopener ugc nofollow" target="_blank"> repo </a>中加载到Github。我现在将所有十个季节的数据集拉下来，我们可以看看它。</p><pre class="mx my mz na gt nb lj nc nd aw ne bi"><span id="2661" class="nf ln iv lj b gy ng nh l ni nj">library(tidyverse) <br/>library(readr) <br/>library(igraph) </span><span id="6041" class="nf ln iv lj b gy nk nh l ni nj"># get friends full series edgelist <br/>edgefile_url &lt;- "https://github.com/keithmcnulty/friends_analysis/blob/master/data/friends_full_series_edgelist.RDS?raw=true" </span><span id="bcc9" class="nf ln iv lj b gy nk nh l ni nj">download.file(edgefile_url, "edgelist.RDS") <br/>edgelist &lt;- readRDS("edgelist.RDS") </span><span id="2d20" class="nf ln iv lj b gy nk nh l ni nj">knitr::kable(edgelist %&gt;% head(10))</span></pre><figure class="mx my mz na gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nl"><img src="../Images/5a1f1c8cda33ae1566771e2058dc3540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rGrYtuY26AGaJf62AQHcIQ.png"/></div></div></figure><p id="009a" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这看起来和我们预期的一样。所以我们准备开始一些工作。</p><h1 id="bfae" class="lm ln iv bd lo lp lq lr ls lt lu lv lw kb lx kc ly ke lz kf ma kh mb ki mc md bi translated">在<code class="fe lg lh li lj b">igraph</code>使用鲁文算法寻找社区</h1><p id="39d1" class="pw-post-body-paragraph kk kl iv km b kn me jw kp kq mf jz ks kt mg kv kw kx mh kz la lb mi ld le lf io bi translated">现在，首先，我们要假装六个主要人物彼此不认识，并删除我们网络中他们之间的所有边。这是因为我们对其他角色如何围绕主要角色形成社区感兴趣。如果我们让主要角色的联系保持完整，我们知道他们会在他们之间形成一个非常强大的社区，这当然是这部剧的全部意义。</p><pre class="mx my mz na gt nb lj nc nd aw ne bi"><span id="4005" class="nf ln iv lj b gy ng nh l ni nj">friends &lt;- c("Phoebe", "Monica", "Rachel", "Joey", "Ross", "Chandler") </span><span id="78f4" class="nf ln iv lj b gy nk nh l ni nj">edgelist_without &lt;- edgelist %&gt;% <br/>  dplyr::filter(!(from %in% friends &amp; to %in% friends))</span></pre><p id="d961" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在，我们将把新的edgelist转换成一个矩阵，然后用它来构建一个graph对象，该对象将<code class="fe lg lh li lj b">weight</code>列作为边的属性:</p><pre class="mx my mz na gt nb lj nc nd aw ne bi"><span id="72d6" class="nf ln iv lj b gy ng nh l ni nj">edgelist_matrix &lt;- as.matrix(edgelist_without[ ,c("from", "to")]) </span><span id="4c99" class="nf ln iv lj b gy nk nh l ni nj">friends_graph &lt;- igraph::graph_from_edgelist(edgelist_matrix, directed = FALSE) %&gt;% <br/>  igraph::set.edge.attribute("weight", value = edgelist_without$weight)</span></pre><p id="3aa5" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们现在可以快速浏览一下我们的<em class="lk">朋友</em>图表:</p><figure class="mx my mz na gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nt"><img src="../Images/ccfdf25fbfeec466e49fdae45c2f7500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fW0RGREL6eJJBbgE"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">真是一团糟</p></figure><p id="fe89" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">好吧，真是一团糟——考虑到这个网络中有650个顶点(字符)和2961条边(连接)，这并不奇怪。我们将不得不在稍后为一些好的情节做一些格式化。但是现在我们准备要求Louvain算法将这个网络分成不同的社区。该算法将尝试最大化社区内部的连接强度，并最小化不同社区之间的连接。</p><pre class="mx my mz na gt nb lj nc nd aw ne bi"><span id="6d8d" class="nf ln iv lj b gy ng nh l ni nj"># run louvain with edge weights <br/>louvain_partition &lt;- igraph::cluster_louvain(friends_graph, weights = E(friends_graph)$weight) </span><span id="7026" class="nf ln iv lj b gy nk nh l ni nj"># assign communities to graph <br/>friends_graph$community &lt;- louvain_partition$membership </span><span id="5d6b" class="nf ln iv lj b gy nk nh l ni nj"># see how many communities there are <br/>unique(friends_graph$community) </span><span id="be34" class="nf ln iv lj b gy nk nh l ni nj">## [1] 4 6 1 7 3 8 5 2</span></pre><p id="e5d3" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">看起来算法找到了8个社区。但是我们不知道谁在里面。我们可以做一些事情来更好地了解每个社区。</p><ol class=""><li id="150b" class="mj mk iv km b kn ko kq kr kt ml kx mm lb mn lf mo mp mq mr bi translated">我们可以看看每个社区有多大。有时，社区可能很小，代表着网络中几乎完全不相连的部分(就像一些角色之间的随机场景，再也不会出现)。</li><li id="486c" class="mj mk iv km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated">我们可以看看每个社区中“最重要”的人(顶点)。这样做的一种方式是寻找具有最高中间中心性的顶点，即连接该社区中最多角色的人。</li></ol><pre class="mx my mz na gt nb lj nc nd aw ne bi"><span id="e15f" class="nf ln iv lj b gy ng nh l ni nj">communities &lt;- data.frame() </span><span id="596c" class="nf ln iv lj b gy nk nh l ni nj">for (i in unique(friends_graph$community)) { </span><span id="db15" class="nf ln iv lj b gy nk nh l ni nj"># create subgraphs for each community subgraph &lt;- induced_subgraph(friends_graph, v = which(friends_graph$community == i)) </span><span id="ce09" class="nf ln iv lj b gy nk nh l ni nj"># get size of each subgraph <br/>size &lt;- igraph::gorder(subgraph) </span><span id="973d" class="nf ln iv lj b gy nk nh l ni nj"># get betweenness centrality <br/>btwn &lt;- igraph::betweenness(subgraph) </span><span id="3fc2" class="nf ln iv lj b gy nk nh l ni nj">communities &lt;- communities %&gt;% <br/>  dplyr::bind_rows(data.frame(<br/>    community = i, <br/>    n_characters = size, <br/>    most_important = names(which(btwn == max(btwn))) <br/>    ) <br/>  ) <br/>} </span><span id="cc89" class="nf ln iv lj b gy nk nh l ni nj">knitr::kable(<br/>  communities %&gt;% <br/>    dplyr::select(community, n_characters, most_important)<br/>)</span></pre><figure class="mx my mz na gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ny"><img src="../Images/f13e0ed913ac68babb66f4e8d4897485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zaJgUokMlTod0tYW"/></div></div></figure><p id="74c2" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">好的——我们看到有几个社区看起来很小，可能很不相关(我们将在附录中查看这些社区),但主要的六个社区都围绕着六个朋友，这是我们所期望的。这证实了六个角色中的每一个，尽管他们彼此很接近，但也在整个系列中培养了相当独立的社区。</p><p id="1b8a" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们可以通过查看每个社区(不包括小社区)中最重要的五个角色来了解这些社区。这一次，我们将着眼于一个更简单的性能指标——每个角色拥有的连接数，或者他们在网络中的<em class="lk">度</em>。</p><pre class="mx my mz na gt nb lj nc nd aw ne bi"><span id="93bd" class="nf ln iv lj b gy ng nh l ni nj">top_five &lt;- data.frame() </span><span id="d2fa" class="nf ln iv lj b gy nk nh l ni nj">for (i in unique(friends_graph$community)) { </span><span id="058c" class="nf ln iv lj b gy nk nh l ni nj">  # create subgraphs for each community <br/>  subgraph &lt;- induced_subgraph(friends_graph, v =       which(friends_graph$community == i)) </span><span id="217e" class="nf ln iv lj b gy nk nh l ni nj">  # for larger communities <br/>  if (igraph::gorder(subgraph) &gt; 20) { </span><span id="b001" class="nf ln iv lj b gy nk nh l ni nj">    # get degree <br/>    degree &lt;- igraph::degree(subgraph) </span><span id="53e1" class="nf ln iv lj b gy nk nh l ni nj">    # get top five degrees <br/>    top &lt;- names(head(sort(degree, decreasing = TRUE), 5)) </span><span id="fe5b" class="nf ln iv lj b gy nk nh l ni nj">    result &lt;- data.frame(community = i, rank = 1:5, character = top) <br/>  } else { <br/>    result &lt;- data.frame(community = NULL, rank = NULL, character = NULL) <br/>  } </span><span id="c281" class="nf ln iv lj b gy nk nh l ni nj">  top_five &lt;- top_five %&gt;% <br/>    dplyr::bind_rows(result) <br/>} </span><span id="c81a" class="nf ln iv lj b gy nk nh l ni nj">knitr::kable(<br/>top_five %&gt;% <br/>  tidyr::pivot_wider(names_from = rank, values_from = character) <br/>)</span></pre><figure class="mx my mz na gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nt"><img src="../Images/8fa3d9dc4970176e183dbd3fefc35993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gDtq0_4te7JOTQaB"/></div></div></figure><p id="1ef4" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们在这里看到一些通用的角色名字，如“男”或“女”。如果我们忽略这些，我们可以看到以下人物群体:</p><ul class=""><li id="b8fb" class="mj mk iv km b kn ko kq kr kt ml kx mm lb mn lf nz mp mq mr bi translated">菲比和她生命中的男人:她最终的丈夫迈克，她吸毒成瘾的按摩客户史蒂夫，以及她同父异母的弟弟弗兰克(也是她父亲的名字)</li><li id="fc94" class="mj mk iv km b kn ms kq mt kt mu kx mv lb mw lf nz mp mq mr bi translated">莫妮卡，她的父母和男朋友们:钱德勒在这里失踪了，当然是因为施工！</li><li id="3d8f" class="mj mk iv km b kn ms kq mt kt mu kx mv lb mw lf nz mp mq mr bi translated">钱德勒和珍妮丝:在《六人行》之外，钱德勒限制了与珍妮丝之外的重复角色的联系。</li><li id="c30f" class="mj mk iv km b kn ms kq mt kt mu kx mv lb mw lf nz mp mq mr bi translated"><strong class="km iw">乔伊和他的演艺人脉</strong>:除了巩特尔——他属于乔伊的圈子——乔伊大部分时间都和导演和经纪人在一起。</li><li id="3f08" class="mj mk iv km b kn ms kq mt kt mu kx mv lb mw lf nz mp mq mr bi translated"><strong class="km iw">瑞秋，她的孩子和她的妹妹</strong>:瑞秋的社区主要围绕着她在第八季的孩子的出生。</li><li id="4b9d" class="mj mk iv km b kn ms kq mt kt mu kx mv lb mw lf nz mp mq mr bi translated">罗斯、卡罗尔和苏珊:罗斯的社区被他的前妻卡罗尔和她的女友苏珊，以及他的古生物学教授女友查理·惠勒的场景所占据。</li></ul><h1 id="535d" class="lm ln iv bd lo lp lq lr ls lt lu lv lw kb lx kc ly ke lz kf ma kh mb ki mc md bi translated">可视化社区</h1><p id="0fc5" class="pw-post-body-paragraph kk kl iv km b kn me jw kp kq mf jz ks kt mg kv kw kx mh kz la lb mi ld le lf io bi translated">我们现在可以试着把这些社区想象成整个网络的一部分。为了更容易理解，我们将去掉除了六个朋友以外的所有人的标签，然后我们将按社区对顶点和边进行颜色编码。</p><pre class="mx my mz na gt nb lj nc nd aw ne bi"><span id="f8ea" class="nf ln iv lj b gy ng nh l ni nj"># give our nodes some properties, incl scaling them by degree and coloring them by community </span><span id="9618" class="nf ln iv lj b gy nk nh l ni nj">V(friends_graph)$size &lt;- 3 V(friends_graph)$frame.color &lt;- "white" V(friends_graph)$color &lt;- friends_graph$community V(friends_graph)$label &lt;- V(friends_graph)$name V(friends_graph)$label.cex &lt;- 1.5 </span><span id="343c" class="nf ln iv lj b gy nk nh l ni nj"># also color edges according to their starting node </span><span id="b4b0" class="nf ln iv lj b gy nk nh l ni nj">edge.start &lt;- ends(friends_graph, es = E(friends_graph), names = F)[,1] <br/>E(friends_graph)$color &lt;- V(friends_graph)$color[edge.start] E(friends_graph)$arrow.mode &lt;- 0 # only label central characters v_labels &lt;- which(V(friends_graph)$name %in% friends) </span><span id="a4be" class="nf ln iv lj b gy nk nh l ni nj">for (i in 1:length(V(friends_graph))) { <br/>  if (!(i %in% v_labels)) { V(friends_graph)$label[i] &lt;- "" } <br/>}</span></pre><p id="b88f" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在我们可以绘制图表了。“最漂亮”的地块可能是球形布局:</p><pre class="mx my mz na gt nb lj nc nd aw ne bi"><span id="6a6c" class="nf ln iv lj b gy ng nh l ni nj">l1 &lt;- layout_on_sphere(friends_graph)<br/>plot(friends_graph, rescale = T, layout = l1, main = "'Friends' Network - All Seasons")</span></pre><figure class="mx my mz na gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ny"><img src="../Images/1c5b645329986946561b4f0c8b3ac1cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z0WX4_oucVmgIpkU"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">球形布局</p></figure><p id="2e32" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">但是为了更好地从视觉上区分社区，武力导向的情节是合适的:</p><pre class="mx my mz na gt nb lj nc nd aw ne bi"><span id="1978" class="nf ln iv lj b gy ng nh l ni nj">l2 &lt;- layout_with_mds(friends_graph) <br/>plot(friends_graph, rescale = T, layout = l2, main = "'Friends' Network - All Seasons")</span></pre><figure class="mx my mz na gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ny"><img src="../Images/0af1b0003a037e8ea657615ca9ae9c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6D0PrQwPgXoYHHIc"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">力导向布局</p></figure><p id="99bc" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">第二张图片更有帮助，因为它暗示乔伊和罗斯可能会过着更“独立”的生活，与其他四个角色相比，他们有更多自己的社区，因为力导向算法使他们与其他人的距离更远。</p><h1 id="3c96" class="lm ln iv bd lo lp lq lr ls lt lu lv lw kb lx kc ly ke lz kf ma kh mb ki mc md bi translated">附录:谁是较小的社区？</h1><p id="c70a" class="pw-post-body-paragraph kk kl iv km b kn me jw kp kq mf jz ks kt mg kv kw kx mh kz la lb mi ld le lf io bi translated">让我们看看在我们之前的分析中出现的两个较小的社区。我们来看看这些社区都有哪些人。</p><pre class="mx my mz na gt nb lj nc nd aw ne bi"><span id="7051" class="nf ln iv lj b gy ng nh l ni nj">small_communities &lt;- data.frame() </span><span id="8469" class="nf ln iv lj b gy nk nh l ni nj">for (i in unique(friends_graph$community)) { </span><span id="3a7e" class="nf ln iv lj b gy nk nh l ni nj">  # create subgraphs for each community <br/>  subgraph &lt;- induced_subgraph(friends_graph, v =   which(friends_graph$community == i)) </span><span id="d1a1" class="nf ln iv lj b gy nk nh l ni nj">  # for larger communities <br/>  if (igraph::gorder(subgraph) &lt; 20) { <br/>    # get degree <br/>    degree &lt;- igraph::degree(subgraph) </span><span id="b449" class="nf ln iv lj b gy nk nh l ni nj">    # get top ten degrees <br/>    top &lt;- names(sort(degree, decreasing = TRUE)) </span><span id="98b0" class="nf ln iv lj b gy nk nh l ni nj">    result &lt;- data.frame(community = i, rank = 1:length(top), character = top) <br/>  } else { <br/>    result &lt;- data.frame(community = NULL, rank = NULL, character = NULL) <br/>  } </span><span id="1963" class="nf ln iv lj b gy nk nh l ni nj">  small_communities &lt;- small_communities %&gt;%  <br/>    dplyr::bind_rows(result) <br/>} </span><span id="5dd9" class="nf ln iv lj b gy nk nh l ni nj">knitr::kable( <br/>  small_communities %&gt;% <br/>    tidyr::pivot_wider(names_from = rank, values_from = character) <br/>)</span></pre><figure class="mx my mz na gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ny"><img src="../Images/6f536c02cbbbef981c077bc538b8c55b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A9Pj7Q8eEf8ALF3F"/></div></div></figure><p id="c724" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">有趣的是，我们的算法似乎已经选取了几个特定的剧集，并将其中的场景视为它们自己的断开网络。</p><ul class=""><li id="1e98" class="mj mk iv km b kn ko kq kr kt ml kx mm lb mn lf nz mp mq mr bi translated">第一个社区似乎来自<em class="lk">雷莫尔博士去世的地方</em></li><li id="5e7d" class="mj mk iv km b kn ms kq mt kt mu kx mv lb mw lf nz mp mq mr bi translated">第二个似乎是来自<em class="lk">在我做</em>之后的那个</li></ul></div><div class="ab cl oa ob hz oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="io ip iq ir is"><p id="96b1" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">最初我是一名纯粹的数学家，后来我成为了一名心理计量学家和数据科学家。我热衷于将所有这些学科的严谨性应用到复杂的人的问题上。我也是一个编码极客和日本RPG的超级粉丝。在<a class="ae ll" href="https://www.linkedin.com/in/keith-mcnulty/" rel="noopener ugc nofollow" target="_blank"><em class="lk">LinkedIn</em></a><em class="lk">或</em><a class="ae ll" href="https://twitter.com/dr_keithmcnulty" rel="noopener ugc nofollow" target="_blank"><em class="lk">Twitter</em></a><em class="lk">上找我。也可以看看我在</em><a class="ae ll" href="http://drkeithmcnulty.com/" rel="noopener ugc nofollow" target="_blank"><em class="lk">drkeithmcnulty.com</em></a><em class="lk">上的博客。</em></p></div></div>    
</body>
</html>