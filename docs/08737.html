<html>
<head>
<title>Introducing GeneAl: a Genetic Algorithm Python Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍 GeneAl:一个遗传算法 Python 库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introducing-geneal-a-genetic-algorithm-python-library-db69abfc212c?source=collection_archive---------10-----------------------#2020-06-24">https://towardsdatascience.com/introducing-geneal-a-genetic-algorithm-python-library-db69abfc212c?source=collection_archive---------10-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="51d4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在这篇文章中，我将介绍<a class="ae kf" href="https://github.com/diogomatoschaves/geneal" rel="noopener ugc nofollow" target="_blank"> GeneAl </a>，这是一个用遗传算法(GA)解决优化问题的 python 库。在这个过程中，我们将了解它们背后的理论，并通过 python 示例了解它们是如何工作的。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/0870b4ce753e6f9eab417453cf05a9e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8Xtpd1mp2QHvmWrnP28VQ.jpeg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">图片由<a class="ae kf" href="https://pixabay.com/users/qimono-1962238/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1811955" rel="noopener ugc nofollow" target="_blank">阿雷克索查</a>通过<a class="ae kf" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1811955" rel="noopener ugc nofollow" target="_blank">皮克斯巴伊</a></p></figure><p id="c4ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遗传算法(GA)是一种基于遗传学和自然选择原理的优化和搜索技术，本质上是模仿我们在生活中观察到的自然进化过程。他们的一般原则是基于这样的概念，即拥有一个由几个个体组成的初始群体，每个个体代表问题的一个特定解决方案，并允许它进化到一个最大化其整体适应度的状态，使用三个主要算子:<strong class="ky ir">选择</strong>、<strong class="ky ir">交叉</strong>和<strong class="ky ir">变异</strong>。我们将在下面更详细地研究这些方面。</p><p id="bce5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遗传算法简直不可思议，因为它们可以应用于多种优化问题，并找到我们没有数学表达式的复杂函数的解决方案。然而，这是以计算复杂性为代价的，因为对于庞大的群体，我们必须评估每一代所有个体的适应度。如果适应度函数是昂贵的，算法运行将是缓慢的。</p><p id="6323" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遗传算法可以分为<em class="ls">二元</em>和<em class="ls">连续</em>，这取决于我们正在优化的问题的类型。潜在地，所有问题都可以被分解为用二进制串表示它们的变量(<em class="ls">基因)</em>，但是一般来说，如果输入空间是实值的，那么使用<em class="ls">连续</em> GA 更有意义。</p><p id="c666" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于连续 GA 的例子很少，这里显示的例子是针对 GA 版本的。</p><p id="ec59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">初始化</strong></p><p id="b861" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">搜索从随机的 N 个个体开始。这些个体中的每一个都对应于一条<em class="ls">染色体</em>，它编码了一个基因序列，代表着我们试图优化的问题的特定解决方案。根据手头的问题，代表解决方案的基因可以是位(0 和 1)或连续的(实值)。下面显示了一个实值<em class="ls">染色体</em>的例子，它代表了一个具有 9 个变量(<em class="ls">基因</em>)的给定问题的解决方案。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi lt"><img src="../Images/67da13cb05456073a3ba5788d27a2ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3X7QtogVmtWnguQMsYpPTg.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">个体染色体的例子</p></figure><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="84da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">健身</strong></p><p id="6bcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个个体<em class="ls"> </em>的<em class="ls">适应度</em>定义了我们要优化的内容，因此，给定一个编码特定问题解决方案的<em class="ls">染色体</em>，其适应度将对应于特定个体作为问题解决方案的表现。因此，其适应值越高，该解决方案就越最优。</p><p id="1bcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">毕竟，个体的适应度分数是经过计算的，它们是经过排序的，因此可以选择最适应的个体进行交叉。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="16a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">选择</strong></p><p id="0ae4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">选择是选择一定比例的个体相互交配并创造新后代的过程。就像现实生活中的自然选择一样，更健康的个体有更高的机会存活下来，因此，将他们的基因传递给下一代。虽然存在有更多个体的版本，但是通常选择过程匹配两个个体，创建成对的个体。有四种主要策略:</p><p id="b73b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">配对</em>:这可能是最直接的策略，因为它只包括将最适合的染色体两两配对(将奇数行与偶数行配对)。</p><p id="7257" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随机:这种策略包括从交配池中随机选择个体。</p><p id="23e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">轮盘</em>:这种策略也遵循随机原则，但是更健康的个体被选中的概率更高。</p><p id="2db7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">锦标赛</em>:采用这种策略，算法先选出几个个体作为候选(通常是 3 个)，然后选出最适合的个体。该选项的优点在于，它不需要首先按照适合度对个体进行分类。</p><p id="fce3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码片段显示了<em class="ls">轮盘</em>策略的 python 实现。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="cb1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">交叉</strong></p><p id="c0c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是产生新后代的步骤，新后代将取代种群中最不适合的个体。杂交个体背后的想法是，通过组合不同的基因，我们可能会产生更健康的个体，这将是我们问题的更好解决方案。或者没有，在这种情况下，这些解决方案不会延续到下一代。</p><p id="86ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了执行实际的交叉，来自选择步骤的每一对被组合以产生两个新个体，这两个新个体都具有来自父母中每一个的遗传物质。执行交叉有几种不同的策略，所以为了简洁起见，我们只讨论其中一种。</p><p id="94b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一个由 9 个变量定义的问题，如果我们有 2 个父母，我们随机选择交叉基因作为索引 3，那么每个后代将是每个父母的组合，如下图所示。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi lw"><img src="../Images/3b16b4c2ae44992ed44ba707e35a1b4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76lEcLZ2ayCxvaKg-wXJbg.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">显示双亲如何杂交产生新后代的图表</p></figure><p id="e803" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个后代的交叉基因根据以下规则计算:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi lx"><img src="../Images/ad522051eb703763e9666a25c16676cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ZWo8Cctykxaa99ASX9MNQ.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">计算新交叉基因的方程式</p></figure><p id="8431" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<em class="ls"> β </em>将是 0 和 1 之间的随机数。下面给出了交叉的 python 代码。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="a103" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">突变</strong></p><p id="fa8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">变异是我们在群体中引入新的遗传物质的过程，允许算法搜索更大的空间。如果没有突变，群体中现有的遗传物质多样性不会增加，而且由于一些个体在世代之间“死亡”,实际上会减少，个体倾向于非常快地变得非常相似。</p><p id="924b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就优化问题而言，这意味着在没有新的遗传物质的情况下，该算法可以在探索足够大的输入空间以确保我们可以达到全局最优之前收敛到局部最优。因此，变异在保持种群多样性方面发挥着重要作用，并使其进化为更适合问题解决方案的<em class="ls">。</em></p><p id="1162" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以做到这一点的最简单的方法是，给定一定的<em class="ls">突变率</em>，随机选择一些个体和一些基因，并为这些位置分配一个新的随机数。下面的图表和代码片段对此进行了举例说明。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ly"><img src="../Images/9d7cd59c66e13a4af7de2aeabce9cf0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWhlDik-dgaCUwPyxp739A.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">个体中两个基因的突变</p></figure><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8d7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解算器</strong></p><p id="2a7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是时候把这一切联系起来了。使用我们上面定义的操作符，该算法现在可以解决这个问题，只需几行代码就可以实现该算法的实际主循环。该算法的流程图以及 python 中的示例实现如下所示。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi lz"><img src="../Images/a6a24f448e1d7fff71c5407123abde71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMTie35Nnnxciazxek66Qw.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">遗传算法的流程图</p></figure><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="lu lv l"/></div></figure><h1 id="0fb0" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">介绍通用</h1><p id="c9f1" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><a class="ae kf" href="https://github.com/diogomatoschaves/geneal" rel="noopener ugc nofollow" target="_blank"> GeneAl </a>是一个实现遗传算法的 python 库，可以用来解决许多优化问题。您可以使用提供的现成解算器类—<strong class="ky ir">binarygenalsolver</strong>和<strong class="ky ir">continuousgenalsolver</strong>——或者创建一个从其中一个继承的自定义类，并实现覆盖内置方法的方法。它还支持解决著名的旅行推销员问题。</p><p id="2286" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简洁起见，我们将只看到如何使用连续版本——与本文保持一致——但是要了解更多细节，请查看该项目的自述文件。</p><p id="41c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一件事是安装软件包，这可以通过<code class="fe mx my mz na b">pip</code>完成，如下所示:</p><pre class="kh ki kj kk gt nb na nc nd aw ne bi"><span id="d5bf" class="nf mb iq na b gy ng nh l ni nj">pip install geneal </span></pre><p id="8190" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装完成后，就可以开始使用了。所以让我们看看如何使用<strong class="ky ir">continuousgenalsolver</strong>类。</p><p id="5be8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为最低要求，该类要求用户提供问题中存在的基因数量，以及提供自定义的适应度函数。为了方便起见，该库提供了一些可用于测试的默认适应度函数。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="78d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成上述初始化后，该类将使用所有参数的默认值来解决问题。如果我们希望对算法运行有更多的控制，我们将希望调整这些，这可以如下所示:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="c58b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，这个类允许用户指定问题的类型(如果可能的值是整数或浮点数)以及变量的限制，以便限制搜索空间。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="59fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就完成了对这个库的简短介绍。如果你想知道更多，查看一下<a class="ae kf" href="https://github.com/diogomatoschaves/geneal" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>，那里有更多的信息:)</p><p id="dc04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>