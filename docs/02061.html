<html>
<head>
<title>SQL — Practical Details Cheat Sheet for Data Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL —用于数据分析的实用细节备忘单</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-practical-details-cheat-sheet-for-data-analysis-f98406a71a09?source=collection_archive---------9-----------------------#2020-02-27">https://towardsdatascience.com/sql-practical-details-cheat-sheet-for-data-analysis-f98406a71a09?source=collection_archive---------9-----------------------#2020-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d03a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">所有语言中最被忽视却又最重要的一种</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6e9013251796ee3a89a79b5b86e5e609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-tQZy0K6oABGixmifaOVgw.jpeg"/></div></div></figure><p id="f1c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di"> D </span>数据被认为比石油更有价值，因为可以从中提取洞察力和知识，因此数据分析非常重要。而这一切都是从查询数据库开始的，以SQL为核心。有大量的SQL教程和备忘单。因此，我将避免讨论基础知识，而将更多地关注我从自己的经验中学到的最重要的方面或实际细节。</p><ol class=""><li id="49da" class="lw lx iq kt b ku kv kx ky la ly le lz li ma lm mb mc md me bi translated">SELECT语句语法—数据查询语言</li><li id="6ac7" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm mb mc md me bi translated">SELECT语句的逻辑处理顺序</li><li id="6ef0" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm mb mc md me bi translated">连接与集合—区分的实际类比</li><li id="190e" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm mb mc md me bi translated">子查询—查询中的查询</li></ol></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="d94b" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">1.SELECT语句语法— <strong class="ak">数据查询语言</strong></h1><p id="dd68" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">在本节中，将介绍SELECT语句的MySQL语法以及最常用的子句及其实用细节。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="719c" class="nt ms iq np b gy nu nv l nw nx"><strong class="np ir">SELECT </strong>[select_option]<br/>{select_expression}<br/>[<br/>  <strong class="np ir">FROM</strong><br/>    <strong class="np ir">JOIN<br/>    ON<br/>    WHERE<br/>    GROUP BY<br/>    HAVING<br/>    ORDER BY<br/>    LIMIT<br/>    INTO</strong><br/>]</span></pre><h2 id="7bc5" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">其中—不能使用别名和聚合函数</h2><p id="cf16" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">不允许在WHERE子句中引用<a class="ae oj" href="https://dev.mysql.com/doc/refman/8.0/en/problems-with-alias.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">列别名</strong> </a>，因为在执行WHERE子句时可能还没有确定列值(下一节将对此进行解释)。</p><p id="63d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不允许在WHERE子句中引用<strong class="kt ir">聚合函数</strong>，因为WHERE子句不能访问整个集合，而是在提交给db引擎时应用于每一行。而<strong class="kt ir">聚合函数</strong>(例如SUM())处理数据集。</p><p id="69da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">WHERE子句至少需要一个条件。如果有多个条件，使用And或or逻辑运算符将它们连接起来。</p><blockquote class="ok ol om"><p id="5c9c" class="kr ks on kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated"><strong class="kt ir">良好实践</strong> : <br/>在生产环境中，始终使用WHERE子句来补充更新和删除查询<strong class="kt ir">，以避免意外的更新和/或删除</strong>。</p></blockquote><h2 id="b3f9" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">有—工作原理类似，但要谨慎使用</h2><p id="0ed3" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">与WHERE子句相比，HAVING子句的一个优点是它过滤聚合数据，而后者过滤基本数据。换句话说，WHERE子句充当<strong class="kt ir">前置过滤器</strong>，而HAVING子句充当<strong class="kt ir">后置过滤器</strong>。因此，<strong class="kt ir">聚合函数</strong>可以与HAVING子句一起使用。</p><p id="d3f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">注意</strong>:HAVING子句中的别名:令人惊讶的是，对于“列别名”查询成功执行，而对于“聚合函数”别名查询失败。<br/>最佳实践是<strong class="kt ir">避免</strong>在HAVING子句中也使用<strong class="kt ir">别名</strong>。</p><p id="9fd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要对应该在WHERE子句中的项目使用HAVING，因为WHERE比<strong class="kt ir">更优化</strong>。</p><h2 id="c32a" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">分组依据—应包括聚合函数</h2><p id="599d" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">选择列表应包括汇总数据的函数(如SUM()、COUNT())。<a class="ae oj" href="https://dev.mysql.com/doc/refman/8.0/en/group-by-modifiers.html" rel="noopener ugc nofollow" target="_blank"> WITH ROLLUP </a>修饰符可用于包含表示更高级(即超级聚合)汇总操作的额外行。<br/> <code class="fe or os ot np b"><strong class="kt ir">SELECT </strong>cat, <strong class="kt ir">COUNT</strong>(*) <strong class="kt ir">AS </strong>total ... <strong class="kt ir">GROUP BY</strong> category <strong class="kt ir">WITH ROLLUP</strong>;</code></p><h2 id="ba0b" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">排序依据和限制</h2><p id="4dda" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">ORDER BY子句应至少包含一个列名或别名。如果包含多个列，用逗号分隔，则这些列按它们被提及的顺序排序。</p><p id="817c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">利用LIMIT子句的<strong class="kt ir">【offset，】</strong>修饰符(缺省值= 0)来指示从哪一行之后开始行计数。例如，<code class="fe or os ot np b">LIMIT 10, 5</code>从第10行开始计数，返回5行—第11行、第12行、第15行。</p><h2 id="64af" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">INTO —使选择作为DML(数据操作语言)工作</h2><p id="a9f7" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated"><a class="ae oj" href="https://dev.mysql.com/doc/refman/8.0/en/select-into.html" rel="noopener ugc nofollow" target="_blank"> SELECT … INTO </a>表单被认为是DML，因为它操纵(即修改)数据。例如，您有一个空表<code class="fe or os ot np b">`table`</code>，并想从表<code class="fe or os ot np b">`backup`</code>中插入数据。那么下面的查询将作为DML: <br/> <code class="fe or os ot np b"><strong class="kt ir">SELECT</strong> * <strong class="kt ir">INTO</strong> backup <strong class="kt ir">FROM </strong>table;</code></p><h2 id="2bed" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">变量—在客户端会话持续之前一直可用</h2><p id="ce8d" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">在给变量赋值时，如果WHERE子句返回多个值，那么只有WHERE子句返回的最后一个<strong class="kt ir">值会被赋给变量。例如，如果以下查询中的WHERE子句返回(恐怖、喜剧、浪漫)，则将“浪漫”赋给变量:<br/> <code class="fe or os ot np b"><strong class="kt ir">SELECT </strong>@category := category <strong class="kt ir">FROM </strong>films <strong class="kt ir">WHERE </strong>rating &gt; 3;</code></strong></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="3edb" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">2.SELECT语句的逻辑处理顺序</h1><p id="1b26" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">这一部分是根据博客“<a class="ae oj" href="https://www.eversql.com/sql-order-of-operations-sql-query-order-of-execution/" rel="noopener ugc nofollow" target="_blank"> SQL操作的顺序MySQL以什么顺序执行查询？</a>”作者Tomer Shay @ EverSQL。<br/>我希望这将使你能够用很少的点击和尝试来编写优化的查询。</p><p id="3668" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:语句的实际物理执行由<strong class="kt ir">查询处理器</strong>决定，顺序可能与下表不同。尽管如此，它给出的结果与查询以低于(默认)执行顺序运行时的结果是一样的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/7b24cb75b9c64937274e2a470e7fcee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DzSUHg0vrC7Sp6Krrrd7bA.png"/></div></div></figure><h2 id="fc6d" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">顺序1-从和连接</h2><blockquote class="ok ol om"><p id="1061" class="kr ks on kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">确定整个工作集，即根据子句和子查询的连接来自所有表的数据</p></blockquote><h2 id="5e85" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">订单2 — WHERE子句</h2><blockquote class="ok ol om"><p id="29f5" class="kr ks on kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">根据条件过滤数据</p></blockquote><h2 id="2a80" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">顺序3-GROUP BY子句</h2><blockquote class="ok ol om"><p id="6ce6" class="kr ks on kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">根据一列或多列聚合数据。将数据拆分到不同的块或桶中，其中每个桶有一个键和一个与该键匹配的行列表</p></blockquote><h2 id="2d83" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">订单4 — HAVING子句</h2><blockquote class="ok ol om"><p id="c7d0" class="kr ks on kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">过滤聚集的数据，即用于过滤掉由GROUP BY子句创建的一些存储桶</p></blockquote><h2 id="36bf" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">订单5 — <a class="ae oj" href="https://mysqlserverteam.com/mysql-8-0-2-introducing-window-functions/" rel="noopener ugc nofollow" target="_blank">窗口功能</a></h2><blockquote class="ok ol om"><p id="ffa3" class="kr ks on kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">就像分组一样:对一组行执行计算，但每一行都保持自己的身份，不会被分组到其他类似行的桶中</p></blockquote><h2 id="ccbf" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">顺序6 —选择子句</h2><blockquote class="ok ol om"><p id="ce45" class="kr ks on kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">筛选和分组后选择数据。在其中使用列名、聚合和子查询</p></blockquote><h2 id="4624" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">顺序7 —独特的关键字</h2><blockquote class="ok ol om"><p id="ea16" class="kr ks on kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">从筛选和聚合后剩下的行中丢弃具有重复值的行</p></blockquote><h2 id="774f" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">顺序8 — UNION关键字</h2><blockquote class="ok ol om"><p id="121c" class="kr ks on kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">将两个查询的结果集合并成一个结果集</p></blockquote><h2 id="8bfd" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">Order 9 — ORDER BY子句</h2><blockquote class="ok ol om"><p id="c7a6" class="kr ks on kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">使用列、别名、聚合函数对整个结果集进行排序，即使它们不是所选数据的一部分。<br/>注意:使用DISTINCT可以防止按未选择的列排序</p></blockquote><h2 id="d7aa" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">订单10 —限制条款</h2><blockquote class="ok ol om"><p id="9341" class="kr ks on kt b ku kv jr kw kx ky ju kz oo lb lc ld op lf lg lh oq lj lk ll lm ij bi translated">丢弃查询结果中除前X行之外的所有行</p></blockquote></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="6173" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">3.连接与集合—区分的实际类比</h1><p id="1aa8" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">希望您熟悉各种连接语句，我想就如何区分连接和集合设置一个非常实用的类比。</p><h2 id="8fc8" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">连接-将表可视化为圆形</h2><p id="a23c" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">圆只有一维——半径。<br/>也就是说，在执行JOIN语句时，我们只需要<em class="on">一个公共字段</em>(半径)来组合来自<em class="on">两个或多个表</em>(圆)的数据或行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/6adf6a23dc4b89b93ab1f98c5ff7adce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fx4wEDv8RpImMxgFnYmyvA.jpeg"/></div></div><p class="ow ox gj gh gi oy oz bd b be z dk translated">阿贝克/抄送人(<a class="ae oj" href="https://creativecommons.org/licenses/by/3.0" rel="noopener ugc nofollow" target="_blank">https://creativecommons.org/licenses/by/3.0</a>)</p></figure><p id="ef18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae oj" href="https://blog.jooq.org/2016/07/05/say-no-to-venn-diagrams-when-explaining-joins/" rel="noopener ugc nofollow" target="_blank">注意:不要将SQL连接视觉模拟与维恩图混淆</a></p><h2 id="f5ba" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">集合—将表格(来自select语句)可视化为矩形</h2><p id="b327" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">矩形有两个维度——长和宽。<br/>也就是说，在执行SET语句时，<em class="on"> select语句</em>(矩形)中使用的<em class="on">字段</em>(长度和宽度)必须具有相同的顺序、相同的编号和相同的数据类型，以便组合并生成结果集，作为单独select语句的UNION、UNION ALL、EXCEPT或INTERSECT。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/1710f105686a5d19de05491fda6b2090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gGAIfOtAOBtorsldixiVyA.png"/></div></div></figure><ul class=""><li id="d7be" class="lw lx iq kt b ku kv kx ky la ly le lz li ma lm pb mc md me bi translated">注意上面表格的图示方向确保<em class="on">字段</em>具有相同的顺序、相同的数字和相同的数据类型。</li><li id="cfac" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm pb mc md me bi translated">UNION子句在结果集中产生不同的值。若要获取重复值，请使用UNION ALL。</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="1a49" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">4.子查询—查询中的查询</h1><h2 id="d790" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">标量子查询—必须只返回一条记录</h2><p id="e9fb" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">选择列表中的子查询:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="31a8" class="nt ms iq np b gy nu nv l nw nx"><strong class="np ir">SELECT</strong><br/>    Category.CategoryName,<br/>    ( <strong class="np ir">SELECT MAX</strong>(DVDPrice) <strong class="np ir">FROM </strong>Films<br/>            <strong class="np ir">WHERE </strong>Films.CategoryID = <em class="on">Category</em>.CategoryID ),<br/>    Category.CategoryID<br/><strong class="np ir">FROM </strong><em class="on">Category</em></span></pre><ul class=""><li id="77f4" class="lw lx iq kt b ku kv kx ky la ly le lz li ma lm pb mc md me bi translated">理解内部查询(<code class="fe or os ot np b"><em class="on">Category</em>.CategoryID</code>)与外部查询(<code class="fe or os ot np b"><strong class="kt ir">FROM </strong><em class="on">Category</em></code>)之间的<strong class="kt ir"/>链接非常重要</li><li id="b21f" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm pb mc md me bi translated">而且因为这个<strong class="kt ir">链接</strong> —聚合函数<code class="fe or os ot np b"><strong class="kt ir">MAX</strong>(DVDPrice)</code> — <strong class="kt ir">只返回一个值</strong>，那就是max。<code class="fe or os ot np b">Category</code>表中每个类别的价格</li></ul><h2 id="f383" class="nt ms iq bd mt ny nz dn mx oa ob dp nb la oc od nd le oe of nf li og oh nh oi bi translated">子查询-返回多个值</h2><p id="b1b9" class="pw-post-body-paragraph kr ks iq kt b ku nj jr kw kx nk ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">当在WHERE子句中使用和/或与in、NOT IN、ANY / SOME、ALL、EXISTS、NOT EXISTS比较条件结合使用时，子查询非常强大。</p><p id="2ba2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">任何或某些</strong></p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="61b4" class="nt ms iq np b gy nu nv l nw nx"><strong class="np ir">SELECT </strong>s1 <strong class="np ir">FROM </strong>t1 <strong class="np ir">WHERE </strong>s1 &gt; <strong class="np ir">ANY </strong>(<strong class="np ir">SELECT</strong> s1 <strong class="np ir">FROM</strong> t2);</span></pre><ul class=""><li id="e3d8" class="lw lx iq kt b ku kv kx ky la ly le lz li ma lm pb mc md me bi translated">如果子查询返回的列或<strong class="kt ir">值列表中的<code class="fe or os ot np b">ANY</code>的<code class="fe or os ot np b"><strong class="kt ir"><em class="on">s1</em></strong></code>比较结果为<code class="fe or os ot np b">TRUE</code>，则返回<code class="fe or os ot np b">TRUE</code></strong></li><li id="1739" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm pb mc md me bi translated">任何一个比较运算符都必须跟在<strong class="kt ir">后面</strong> ( =，&gt;，&lt;，&gt; =，&lt; =，&lt;，&gt;，！=)，即在列名<code class="fe or os ot np b">s1</code>和比较条件<code class="fe or os ot np b">ANY</code>之间</li></ul><p id="8d2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如:假设<code class="fe or os ot np b">t1</code>中有一行包含<code class="fe or os ot np b">(10)</code>，则表达式为:</p><ul class=""><li id="8a05" class="lw lx iq kt b ku kv kx ky la ly le lz li ma lm pb mc md me bi translated"><code class="fe or os ot np b">TRUE</code>如果<code class="fe or os ot np b">t2</code>包含<code class="fe or os ot np b">(21,14,7)</code></li><li id="ee24" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm pb mc md me bi translated"><code class="fe or os ot np b">FALSE</code>如果<code class="fe or os ot np b">t2</code>包含<code class="fe or os ot np b">(20,10)</code>或者<code class="fe or os ot np b">t2</code>为空</li><li id="98cc" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm pb mc md me bi translated"><em class="on">未知</em>(即<code class="fe or os ot np b">NULL</code>)如果<code class="fe or os ot np b">t2</code>包含<code class="fe or os ot np b">(NULL,NULL,NULL)</code></li></ul><p id="c772" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">全部</strong></p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="2002" class="nt ms iq np b gy nu nv l nw nx"><strong class="np ir">SELECT </strong>s1 <strong class="np ir">FROM </strong>t1 <strong class="np ir">WHERE </strong>s1 &gt; <strong class="np ir">ALL</strong> (<strong class="np ir">SELECT </strong>s1 <strong class="np ir">FROM </strong>t2);</span></pre><ul class=""><li id="54ff" class="lw lx iq kt b ku kv kx ky la ly le lz li ma lm pb mc md me bi translated">如果子查询返回的列或<strong class="kt ir">值列表</strong>中的值<code class="fe or os ot np b">ALL</code>的比较<code class="fe or os ot np b"><strong class="kt ir"><em class="on">s1</em></strong></code>为<code class="fe or os ot np b">TRUE</code>，则返回<code class="fe or os ot np b">TRUE</code></li><li id="f99a" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm pb mc md me bi translated">所有还必须跟随着<strong class="kt ir">一个比较运算符</strong> ( =，&gt;，&lt;，&gt; =，&lt; =，&lt;，&gt;，！=)，即在列名<code class="fe or os ot np b">s1</code>和比较条件<code class="fe or os ot np b">SOME</code>之间</li></ul><p id="f95e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如:假设<code class="fe or os ot np b">t1</code>中有一行包含<code class="fe or os ot np b">(10) </code>，则表达式为:</p><ul class=""><li id="0ca0" class="lw lx iq kt b ku kv kx ky la ly le lz li ma lm pb mc md me bi translated"><code class="fe or os ot np b">TRUE</code>如果<code class="fe or os ot np b">t2</code>包含<code class="fe or os ot np b">(-5,0,5)</code>或者如果表格<code class="fe or os ot np b">t2</code>为空</li><li id="efe1" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm pb mc md me bi translated"><code class="fe or os ot np b">FALSE</code>如果<code class="fe or os ot np b">t2</code>包含<code class="fe or os ot np b">(12,6,NULL,-100)</code>，则为12 &gt; 10</li><li id="ce4d" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm pb mc md me bi translated"><em class="on">未知</em>(即<code class="fe or os ot np b">NULL</code>)如果<code class="fe or os ot np b">t2</code>包含<code class="fe or os ot np b">(0,NULL,1)</code></li></ul><p id="a6d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">在和不在</strong></p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="c377" class="nt ms iq np b gy nu nv l nw nx"><strong class="np ir">SELECT </strong>s1 <strong class="np ir">FROM </strong>t1 <strong class="np ir">WHERE </strong>s1 <strong class="np ir">IN </strong>(<strong class="np ir">SELECT </strong>s1 <strong class="np ir">FROM </strong>t2);</span></pre><ul class=""><li id="71d7" class="lw lx iq kt b ku kv kx ky la ly le lz li ma lm pb mc md me bi translated">如果<code class="fe or os ot np b"><strong class="kt ir"><em class="on">s1</em></strong></code>等于子查询返回的<code class="fe or os ot np b">IN()</code> <strong class="kt ir">列表</strong>中值的任意一个，则返回<code class="fe or os ot np b">1</code> (true)，否则返回<code class="fe or os ot np b">0</code> (false)。不要颠倒逻辑</li><li id="0cd9" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm pb mc md me bi translated"><code class="fe or os ot np b">IN</code>比较条件的执行是不是听起来有点耳熟——没错，关键字<code class="fe or os ot np b">IN</code>就是<code class="fe or os ot np b">= ANY</code>的别名。但是，<code class="fe or os ot np b">NOT IN</code>不是<code class="fe or os ot np b">&lt;&gt; ANY</code>的别名，而是<code class="fe or os ot np b">&lt;&gt; ALL</code>的别名</li><li id="205e" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm pb mc md me bi translated"><strong class="kt ir">没有比较运算符</strong> ( =，&gt;，&lt;，&gt; =，&lt; =，&lt; &gt;，！列名<code class="fe or os ot np b">s1</code>和比较条件<code class="fe or os ot np b">IN</code>之间允许有=)</li></ul><p id="2cc5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">存在与不存在</strong></p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="406e" class="nt ms iq np b gy nu nv l nw nx"><strong class="np ir">SELECT </strong>column1 <strong class="np ir">FROM </strong>t1 <strong class="np ir">WHERE EXISTS </strong>(<strong class="np ir">SELECT </strong>* <strong class="np ir">FROM</strong> t2);</span></pre><ul class=""><li id="77fc" class="lw lx iq kt b ku kv kx ky la ly le lz li ma lm pb mc md me bi translated">如果a <code class="fe or os ot np b"><strong class="kt ir"><em class="on">subquery</em></strong></code> (SELECT * FROM t2)返回任何行，则条件<code class="fe or os ot np b">EXISTS <strong class="kt ir"><em class="on">subquery</em></strong></code>为<code class="fe or os ot np b">TRUE</code>，条件<code class="fe or os ot np b">NOT EXISTS <strong class="kt ir"><em class="on">subquery</em></strong></code>为<code class="fe or os ot np b">FALSE</code></li><li id="4b8f" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm pb mc md me bi translated">也就是说，如果<code class="fe or os ot np b">t2</code>包含任何行，甚至只包含<code class="fe or os ot np b">NULL</code>值的行，则<code class="fe or os ot np b">EXISTS</code>条件为<code class="fe or os ot np b">TRUE</code></li></ul><p id="fac3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为<code class="fe or os ot np b">[NOT] EXISTS</code>子查询几乎总是<strong class="kt ir">包含相关性</strong>。一个现实的例子是下面的查询回答“在一个或多个城市有什么样的商店？”具有相关性<code class="fe or os ot np b">cities_stores.store_type = stores.store_type</code></p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="9899" class="nt ms iq np b gy nu nv l nw nx"><strong class="np ir">SELECT DISTINCT </strong>store_type <strong class="np ir">FROM </strong>stores <br/>  <strong class="np ir">WHERE EXISTS </strong>(<strong class="np ir">SELECT </strong>* <strong class="np ir">FROM </strong>cities_stores<br/>    <strong class="np ir">WHERE </strong>cities_stores.store_type = stores.store_type);</span></pre><p id="4b5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae oj" href="https://dev.mysql.com/doc/refman/8.0/en/exists-and-not-exists-subqueries.html" rel="noopener ugc nofollow" target="_blank">更多例子</a></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="ac75" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">参考</h1><ul class=""><li id="9fd7" class="lw lx iq kt b ku nj kx nk la pc le pd li pe lm pb mc md me bi translated"><a class="ae oj" href="https://dev.mysql.com/doc/refman/8.0/en/" rel="noopener ugc nofollow" target="_blank"> MySQL 8.0参考手册</a></li><li id="5062" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm pb mc md me bi translated">Tomer Shay @ EverSQL写的博客</li><li id="71cd" class="lw lx iq kt b ku mf kx mg la mh le mi li mj lm pb mc md me bi translated"><a class="ae oj" href="https://commons.wikimedia.org/wiki/File:SQL_Joins.svg" rel="noopener ugc nofollow" target="_blank">加入https://creativecommons.org/licenses/by/3.0的图片ar beck/CC</a></li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="c0ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您的阅读！如果你觉得这有帮助或者没有帮助，请在评论中告诉我。如果这篇文章有帮助，<em class="on">分享一下</em>。</p><p id="1d2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">领英</strong></p><div class="pf pg gp gr ph pi"><a href="https://www.linkedin.com/in/eklavyasaxena/" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd ir gy z fp pn fr fs po fu fw ip bi translated">Eklavya Saxena -大纽约市地区|职业简介| LinkedIn</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">精通数据的分析师和有抱负的数据科学家，拥有2年以上的销售或客户行业经验…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">www.linkedin.com/in/EklavyaSaxena</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw kp pi"/></div></div></a></div></div></div>    
</body>
</html>