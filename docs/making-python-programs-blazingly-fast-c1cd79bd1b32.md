# 让 Python 程序快得惊人

> 原文：<https://towardsdatascience.com/making-python-programs-blazingly-fast-c1cd79bd1b32?source=collection_archive---------0----------------------->

## 让我们看看我们的 Python 程序的性能，看看如何使它们的速度提高 30%！

讨厌 Python 的人总是说，他们不想使用它的原因之一是它太慢了。不管使用何种编程语言，特定程序的速度是快还是慢在很大程度上取决于编写该程序的开发人员以及他们编写*优化*和*快速*程序的技能和能力。

所以，让我们证明一些人是错的，让我们看看如何提高我们的 *Python* 程序的性能，让它们变得非常快！

![](img/e3e80cc0a51ed8433fa43107ae728cf2.png)

由 unsplash 上的 [@veri_ivanova](https://unsplash.com/@veri_ivanova)

# 计时和分析

在我们开始优化任何东西之前，我们首先需要找出我们的代码的哪些部分实际上减慢了整个程序。有时程序的瓶颈可能很明显，但如果您不知道它在哪里，那么您可以通过以下方法找到它:

*注意:这是我将用于演示目的的程序，它计算*`*e*`*`*X*`*(取自 Python 文档):**

## *最懒的“侧写”*

*首先，最简单也是非常懒惰的解决方案——Unix`time`命令:*

*如果你只是想为你的整个程序计时，这是可行的，但通常是不够的…*

## *最详细的剖析*

*光谱的另一端是`cProfile`，它会给你*太多的*信息:*

*在这里，我们使用`cProfile`模块和`time`参数运行测试脚本，这样代码行按照内部时间(`cumtime`)排序。这给了我们很多信息，你在上面看到的线大约是实际输出的 10%。由此，我们可以看到`exp`函数是罪魁祸首(*意外，意外*)，现在我们可以得到更多关于计时和分析的细节...*

## *定时特定功能*

*既然我们知道了应该把注意力放在哪里，我们可能想要对慢速函数计时，而不需要测量代码的其余部分。为此，我们可以使用简单的装饰器:*

*然后，可以将这个装饰器应用于测试中的函数，如下所示:*

*这给了我们这样的输出:*

*需要考虑的一件事是我们实际(想要)测量的是什么样的时间。时间包提供`time.perf_counter`和`time.process_time`。这里的区别是`perf_counter`返回绝对值，其中包括 Python 程序进程不运行的时间，因此可能会受到机器负载的影响。另一方面，`process_time`只返回*用户时间*(不包括*系统时间*)，这只是你的进程的时间。*

# *让它更快*

*现在，有趣的是。让我们让你的 Python 程序运行得更快。我(大部分)不会向您展示一些能够神奇地解决您的性能问题的技巧、诀窍和代码片段。这更多的是关于一般的想法和策略，当使用时，可以对性能产生巨大的影响，在某些情况下可以提高 30%。*

## *使用内置数据类型*

*这个很明显。内置数据类型非常快，尤其是与我们的自定义类型如树或链表相比。那主要是因为内置是用 *C* 实现的，用 Python 编码的时候我们在速度上确实比不上。*

## *使用 lru_cache 进行缓存/记忆*

*我已经在之前的博客文章[中展示过这一点，但是我认为有必要用一个简单的例子来重复一下:](https://martinheinz.dev/blog/4)*

*上面的函数使用`time.sleep`模拟繁重的计算。当用参数`1`第一次调用时，它等待 2 秒，然后才返回结果。再次调用时，结果已经被缓存，所以它跳过函数体并立即返回结果。更多现实生活中的例子请看之前的博文[这里](https://martinheinz.dev/blog/4)。*

## *使用局部变量*

*这与在每个作用域中查找变量的速度有关。我正在编写每个作用域的*，因为这不仅仅是关于使用局部变量还是全局变量。实际上，查找速度甚至在函数中的局部变量(最快)、类级属性(例如`self.name` -较慢)和全局变量(例如像`time.time`(最慢)之间也有差异。**

*您可以通过使用看似不必要的(直接无用的)赋值来提高性能，如下所示:*

## *使用功能*

*这可能看起来与直觉相反，因为调用函数会将更多的东西放入堆栈，并从函数返回中产生开销，但这与前一点有关。如果你只是把你的整个代码放在一个文件中，而没有把它放入函数中，那么会因为全局变量而慢很多。因此，您可以通过将整个代码包装在`main`函数中并调用一次来加速您的代码，就像这样:*

## *不要访问属性*

*另一个可能降低程序速度的是*点运算符* ( `.`)，它在访问对象属性时使用。该操作符使用`__getattribute__`触发字典查找，这会在代码中产生额外的开销。那么，如何才能真正避免(限制)使用它呢？*

## *当心绳子*

*当使用例如*模数* ( `%s`)或`.format()`在循环中运行时，字符串上的操作会变得相当慢。我们还有什么更好的选择？根据 Raymond Hettinger 最近的[推文，我们唯一应该使用的是 *f-string* ，这是最易读、最简洁和最快的方法。所以，根据那条微博，这是你可以使用的方法列表——从最快到最慢:](https://twitter.com/raymondh/status/1205969258800275456)*

*生成器并不是天生就更快，因为它们是为惰性计算而设计的，惰性计算节省了内存而不是时间。然而，节省下来的内存可能会导致程序实际上运行得更快。怎么会？嗯，如果你有一个大的数据集，并且你没有使用生成器(迭代器)，那么数据可能会溢出 CPU*L1 缓存*，这将大大降低在内存中查找值的速度。*

*就性能而言，非常重要的一点是，CPU 可以尽可能接近地保存它正在处理的所有数据，这些数据位于缓存中。你可以观看 Raymond Hettingers 的演讲，他在演讲中提到了这些问题。*

# *结论*

*优化的第一条规则是*不做*。但是，如果你真的不得不这样做，那么我希望这几条建议能帮到你。然而，在优化你的代码时要小心，因为它可能最终使你的代码难以阅读，从而难以维护，这可能超过优化的好处。*

**注:此文最初发布于*[*martinheinz . dev*](https://martinheinz.dev/blog/13)*