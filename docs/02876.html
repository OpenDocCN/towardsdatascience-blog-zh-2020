<html>
<head>
<title>Top 3 Numpy Functions You Don’t Know About (Probably)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不知道(可能)的前3个Numpy函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/top-3-numpy-functions-you-dont-know-about-probably-f3f49299a749?source=collection_archive---------28-----------------------#2020-03-19">https://towardsdatascience.com/top-3-numpy-functions-you-dont-know-about-probably-f3f49299a749?source=collection_archive---------28-----------------------#2020-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="65a8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不是每个操作指南都包括的</h2></div><p id="d82a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为最受欢迎的科学计算Python库之一，Numpy当然不缺乏有用和有趣的函数，值得深入探索。本文将探讨一些最有趣但鲜为人知的内容，希望能鼓励您自己进一步探索。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/efcba3cfacc6e38ed018ffa83cb7d4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X5LaFRktrsXZlOWA"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">尼克·希利尔在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="740e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一名数据科学家，我每天都使用Numpy库，主要用于<strong class="kk iu">在各种操作中处理数组</strong>——乘法、连接、整形、比较等。</p><p id="2aeb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是本文将涉及的功能:</p><ol class=""><li id="eb1c" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated"><code class="fe me mf mg mh b">isclose()</code></li><li id="a4c6" class="lv lw it kk b kl mi ko mj kr mk kv ml kz mm ld ma mb mc md bi translated"><code class="fe me mf mg mh b">intersect1d()</code></li><li id="8088" class="lv lw it kk b kl mi ko mj kr mk kv ml kz mm ld ma mb mc md bi translated"><code class="fe me mf mg mh b">stack()</code></li></ol><p id="f02e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">进口方面，您只需要Numpy:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/39d691e2968d6d962da760519e52eda5.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*Jnu2VuJMCIts5bv_0GNX1Q.png"/></div></figure><p id="214e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以事不宜迟，我们开始吧！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="0d5a" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">isclose()</h1><p id="058b" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">有多少次你查看数据帧中的条目，看到0的值，然后决定过滤掉0，却发现你的代码没有做它应该做的事情？</p><p id="0884" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你的代码(某种程度上)没有问题，问题在于数字如何被<strong class="kk iu">四舍五入</strong>以在你的屏幕上占据更少的空间。以此为例:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/11ada5edc33c224a95c20593ffc93d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:224/format:webp/1*oLzJ_pwQT4e2LVUPgY_MqA.png"/></div></figure><p id="fb3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量<code class="fe me mf mg mh b">x</code>和<code class="fe me mf mg mh b">y</code>虽然非常接近，但并不相同，测试相等将导致<code class="fe me mf mg mh b">False</code>:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/e3a4ac3da8deaf7b32267c21712426ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:214/format:webp/1*peiQo2cdJ0pRn8q_w-SSUA.png"/></div></figure><p id="5edd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但在大多数情况下，低至这个数字可以认为是0。问题依然存在，<strong class="kk iu">如何在代码中实现这一点？</strong></p><p id="5df7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，Numpy有一个<code class="fe me mf mg mh b">isclose()</code>函数可以帮助我们。它将在一个容差内测试两个数是否相等，缺省情况下是<code class="fe me mf mg mh b">1e-8</code>。让我们来看看实际情况:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/53cb7c2f22d26c37fac8e49efe3acd63.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*ODRhs1ElzOk_0hPFk7MWRg.png"/></div></figure><p id="59cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，给定的数字在阈值内是相同的，因此函数返回<code class="fe me mf mg mh b">True</code>。如果出于某种原因，您想要调整阈值，以下是操作方法:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/f9bc9fef8ba13b5a27a55d71d291981a.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*xdLrhwuInytQwRtDuW-tcw.png"/></div></figure><p id="bb29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了，我们继续。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="1ab2" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">交叉1d()</h1><p id="3784" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">该函数的主要思想是将两个数组作为输入，并返回包含在两个数组中的<strong class="kk iu">元素。把它想成一个集合交集，但是你知道，不用把数组转换成集合，计算交集。</strong></p><p id="e773" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了演示，让我们声明两个数组:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/4a7f658f6c56aa591607aa54a8668530.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*CZ6YgkzAGflBo-T-IXLAgg.png"/></div></figure><p id="4ef8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，为了查看两者中存在哪些元素，我们需要做这样的事情:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/c5bb54bb553c916a7c81f4808e84c71e.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*JgYxCGdg_gS68GzI_q-X1w.png"/></div></figure><p id="fda1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了！另一种方法，前面提到的那种，写起来会有点长，而且会包含更多的括号:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/df5e34a189d28477df5a4f8c67939f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*yLbUPW9HPgWz2csdZZ-rMg.png"/></div></figure><p id="0c2c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">两个都可以，但我更喜欢第一个。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="fdf4" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">堆栈()</h1><p id="6b70" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">现在，这是我在为预测建模准备数据集时经常使用的方法——更准确地说，是在<strong class="kk iu">分类变量嵌入</strong>的过程中。</p><p id="134b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您已经嵌入了一些变量，并希望将它们放入一个矩阵形式中，其中每个变量都是一个单独的列—唯一符合逻辑的做法是沿着列轴堆叠变量。</p><p id="ca9a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我有点想太多了。</p><p id="d2c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于演示目的，我们将处理之前的相同阵列:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/4a7f658f6c56aa591607aa54a8668530.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*CZ6YgkzAGflBo-T-IXLAgg.png"/></div></figure><p id="9d51" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了。现在让我们使用<code class="fe me mf mg mh b">stack()</code>函数沿着行轴堆叠数组:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b7df70170bdb9051a2909c2daeb50eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*KY_qpQAuuJfDDVH4mJcGZQ.png"/></div></figure><p id="13af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，<code class="fe me mf mg mh b">axis=0</code>在这里是可选的，因为它是执行堆叠的默认轴，但是我已经将它指定得更明确了。</p><p id="91ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实践中更常见的例子是沿着列轴堆叠(至少在我的工作中是这样的):</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/744c650ab4e181c7652085f32ebf0ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*Wv0CPZT9lI4r9iN-QFlTnw.png"/></div></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="05f5" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">在你走之前</h1><p id="d075" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">我希望你能在作为数据分析师/科学家的日常工作中利用这三个功能——它们是很好的时间节省工具。</p><p id="3b6e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和往常一样，如果你有一些日常使用的<strong class="kk iu">附加</strong>功能，不要犹豫，在评论区分享吧。</p><p id="682b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="cb2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ob">喜欢这篇文章吗？成为</em> <a class="ae lu" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="ob">中等会员</em> </a> <em class="ob">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="oc od gp gr oe of"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">通过我的推荐链接加入Medium-Dario rade ci</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot lo of"/></div></div></a></div></div></div>    
</body>
</html>