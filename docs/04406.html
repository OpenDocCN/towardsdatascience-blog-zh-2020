<html>
<head>
<title>List Comprehension and Beyond — Understand 4 Key Related Techniques in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">列表理解和超越——理解Python中的4个关键相关技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/list-comprehension-and-beyond-understand-4-key-related-techniques-in-python-3bff0f0a3ccb?source=collection_archive---------44-----------------------#2020-04-20">https://towardsdatascience.com/list-comprehension-and-beyond-understand-4-key-related-techniques-in-python-3bff0f0a3ccb?source=collection_archive---------44-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5ed0" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">中级Python知识</h2><div class=""/><div class=""><h2 id="f92c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">它们比你想象的要简单</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/25946530420dda20c75058f478e50dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BqV8T5yr5l4ZkYOB"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@filbertmang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">费尔伯特·曼贡达普</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7d27" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们学习Python时，列表理解是一项棘手的技术，需要花一些时间才能完全理解它。在我们学会它之后，我们喜欢使用它，因为它是展示我们在Python中的编码专业知识的一种简洁的方式。特别是，当我们有机会让初学者阅读我们的代码时，他们会惊讶地发现Python中存在如此简洁的创建列表的方法。实际上，他们可能不知道的是，理解list comprehension的语法对他们理解其他一些关键的Python技术是有用的。在本文中，让我们一起来探索它们。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="a142" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">1.列表理解</h2><p id="023b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我们先来复习一下什么是列表理解。它有以下基本语法:<code class="fe ni nj nk nl b">[expression for item in iterable]</code>。本质上，它遍历一个iterable，执行创建一个项的特定操作，并返回由这些项组成的列表。考虑下面的例子。</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="20ed" class="ml mm it nl b gy nq nr l ns nt">&gt;&gt;&gt; # create a list of words<br/>&gt;&gt;&gt; words = ["quixotic", "loquacious", "epistemology", "liminal"]<br/>&gt;&gt;&gt; # create a list of numbers counting the letters<br/>&gt;&gt;&gt; letter_counts = [len(x) for x in words]<br/>&gt;&gt;&gt; letter_counts<br/>[8, 10, 12, 7]</span></pre><p id="a7ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码中，我们创建了一个名为<code class="fe ni nj nk nl b">letter_counts</code>的数字列表，每个数字都是<code class="fe ni nj nk nl b">words</code>列表中每个单词的字母数。很简单，对吧？</p><p id="9280" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们做一些更有趣的东西。在下面的代码中，我们通过使用<code class="fe ni nj nk nl b">if</code>语句过滤<code class="fe ni nj nk nl b">words</code>列表来创建一个大写单词列表。</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="c521" class="ml mm it nl b gy nq nr l ns nt">&gt;&gt;&gt; # create a list of uppercased words with letter count &gt; 8<br/>&gt;&gt;&gt; uppercased = [x.upper() for x in words if len(x) &gt; 8]<br/>&gt;&gt;&gt; uppercased<br/>['LOQUACIOUS', 'EPISTEMOLOGY']</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="0fc4" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">2.词典理解</h2><p id="b23b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">除了列表理解，Python还有一种类似的创建字典的技术，称为字典理解。它有以下基本语法:<code class="fe ni nj nk nl b">{exp_key: exp_value for item in iterable}</code>。如您所见，该表达式与list comprehension相似，都有迭代部分(即<code class="fe ni nj nk nl b">for item in iterable</code>)。</p><p id="7cb7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有两个区别。首先，我们使用花括号进行字典理解，而不是方括号进行列表理解。第二，字典理解有两个表达式，一个表示键，另一个表示值，与列表理解中的一个表达式相反。</p><p id="c5e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看下面的例子。我们有一个元组列表，每个元组保存学生的姓名和分数。接下来，我们使用字典理解技术创建一个字典，其中名称是键，分数是值。</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="68a9" class="ml mm it nl b gy nq nr l ns nt">&gt;&gt;&gt; # create a list of tuples having student names and scores<br/>&gt;&gt;&gt; scores = [("John", 88), ("David", 95), ("Aaron", 94)]<br/>&gt;&gt;&gt; # create a dictionary using name as key as score as value<br/>&gt;&gt;&gt; dict_scores = {x[0]: x[1] for x in scores}<br/>&gt;&gt;&gt; dict_scores<br/>{'John': 88, 'David': 95, 'Aaron': 94}</span></pre><p id="b08d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了使我们的例子更有趣(从而可以学到更多)，我们可以将条件赋值与字典理解(实际上也包括列表理解)结合起来。考虑下面仍然使用<code class="fe ni nj nk nl b">scores</code>列表的例子。</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="660b" class="ml mm it nl b gy nq nr l ns nt">&gt;&gt;&gt; # create the dictionary using name as key as grade as value<br/>&gt;&gt;&gt; dict_grades = {x[0]: 'Pass' if x[1] &gt;= 90 else "Fail" for x in scores}<br/>&gt;&gt;&gt; dict_grades<br/>{'John': 'Fail', 'David': 'Pass', 'Aaron': 'Pass'}</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="f1e0" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">3.集合理解</h2><p id="fab5" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我们都知道Python中有三种主要的内置集合数据结构:列表、字典和集合。既然有列表和字典理解，很惊讶的知道还有集合理解。</p><p id="e713" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">集合理解的语法如下:<code class="fe ni nj nk nl b">{expression for item in iterable}</code>。语法与list comprehension几乎相同，只是它使用了花括号而不是方括号。让我们通过下面的例子来看看它是如何工作的。</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="bbd5" class="ml mm it nl b gy nq nr l ns nt">&gt;&gt;&gt; # create a list of words of random letters<br/>&gt;&gt;&gt; nonsenses = ["adcss", "cehhe", "DesLs", "dddd"]<br/>&gt;&gt;&gt; # create a set of words of unique letters for each word<br/>&gt;&gt;&gt; unique_letters = {"".join(set(x)) for x in nonsenses}<br/>&gt;&gt;&gt; unique_letters<br/>{'d', 'cdas', 'eLsD', 'ceh'}</span></pre><p id="78c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码中，我们用随机字母创建了一个名为<code class="fe ni nj nk nl b">nonsenses</code>的无意义单词列表。然后我们创建一组名为<code class="fe ni nj nk nl b">unique_letters</code>的单词，每个单词都由单词的唯一字母组成。</p><p id="04be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">需要注意的一点是，在Python中，集合不能有重复值的项，因此set comprehension会自动为我们删除重复项。请查看该特性的代码。</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="d26f" class="ml mm it nl b gy nq nr l ns nt">&gt;&gt;&gt; # create a list of numbers<br/>&gt;&gt;&gt; numbers = [(12, 20, 15), (11, 9, 15), (11, 13, 22)]<br/>&gt;&gt;&gt; # create a set of odd numbers<br/>&gt;&gt;&gt; unique_numbers = {x for triple in numbers for x in triple}<br/>&gt;&gt;&gt; unique_numbers<br/>{9, 11, 12, 13, 15, 20, 22}</span></pre><p id="e1f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码中，我们从列表<code class="fe ni nj nk nl b">numbers</code>中创建了一个名为<code class="fe ni nj nk nl b">unique_numbers</code>的集合，其中包含元组项。如您所见，列表中的重复数字(例如11)在集合中只有一个副本。</p><p id="16e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里的一个新东西是我们使用了一个嵌套的理解，它的语法如下:<code class="fe ni nj nk nl b">expression for items in iterable for item in items</code>。这种技术在iterable包含其他集合的情况下很有用(例如<code class="fe ni nj nk nl b">list</code>中的<code class="fe ni nj nk nl b">list</code>或<code class="fe ni nj nk nl b">list</code>中的<code class="fe ni nj nk nl b">tuple</code>)。值得注意的是，我们可以将这种嵌套理解用于列表、字典和集合理解。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="8a0d" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">4.生成器表达式</h2><p id="a1ac" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我们知道我们用花括号来表示集合理解，用方括号来表示列表理解。如果我们使用圆括号，比如<code class="fe ni nj nk nl b">(expression for item in iterable)</code>，会怎么样？好问题，由此引出生成器表达式的讨论，也有人称之为生成器理解。</p><p id="9fdc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">换句话说，当我们使用括号时，我们实际上是在声明一个生成器表达式，它创建了一个生成器。<strong class="lk jd">生成器是Python中的“懒惰”迭代器。</strong>这意味着生成器可以用在需要迭代器的地方，但它会提供所需的项，直到它被请求(这就是为什么它被称为“懒惰”，<a class="ae lh" href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="noopener ugc nofollow" target="_blank">一个编程术语</a>)。让我们看看下面的例子。</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="ea17" class="ml mm it nl b gy nq nr l ns nt">&gt;&gt;&gt; # create the generator and get the item<br/>&gt;&gt;&gt; squares_gen = (x*x for x in range(3))<br/>&gt;&gt;&gt; next(squares_gen)<br/>0<br/>&gt;&gt;&gt; next(squares_gen)<br/>1<br/>&gt;&gt;&gt; next(squares_gen)<br/>4<br/>&gt;&gt;&gt; next(squares_gen)<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>StopIteration</span></pre><p id="ed9f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码中，我们使用生成器表达式创建了一个名为<code class="fe ni nj nk nl b">squares_gen</code>的生成器。使用内置的<code class="fe ni nj nk nl b">next()</code>方法，我们能够从生成器中检索下一个项目。但是，当生成器用完物品时，会引发一个<code class="fe ni nj nk nl b">StopIteration</code>异常，表示所有物品已经用完。</p><p id="a47f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于它的惰性求值特性，生成器是一种内存高效的技术，可以迭代一个巨大的条目列表，而不需要首先创建iterable。例如，我们处理一个非常大的文件，将整个文件读入内存可能会耗尽计算机的RAM，导致它无法响应。相反，我们可以使用生成器表达式技术，就像这个<code class="fe ni nj nk nl b">(row for row in open(filename))</code>，它允许我们逐行读取文件以最小化内存使用。</p><p id="305d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了说明生成器表达式是如何工作的，让我们考虑一个简化的例子。在下面的代码中，我们创建了一个包含1亿个数字的列表和生成器，每个数字都是一个正方形。显然，当我们检查它们的大小时，生成器使用的内存比列表少得多。</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="7046" class="ml mm it nl b gy nq nr l ns nt">&gt;&gt;&gt; # a list of 100 million numbers<br/>&gt;&gt;&gt; numbers_list = [x*x for x in range(100000000)]<br/>&gt;&gt;&gt; numbers_list.__sizeof__()<br/>859724448<br/>&gt;&gt;&gt; # a generator of 100 million numbers<br/>&gt;&gt;&gt; numbers_gen = (x*x for x in range(100000000))<br/>&gt;&gt;&gt; numbers_gen.__sizeof__()<br/>96</span></pre><p id="bdb1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们的目标是计算这些数字的总和，那么两种选择都会得到相同的结果。但是重要的是，在计算出总和之后，生成器不会产生任何额外的项，如下所述。如果您确实需要多次使用iterable，您可以在每次需要时创建一个列表或创建一个生成器，后者是一种更节省内存的方式。</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="ddd2" class="ml mm it nl b gy nq nr l ns nt">&gt;&gt;&gt; # calculate the sum<br/>&gt;&gt;&gt; sum(numbers_list)<br/>333333328333333350000000<br/>&gt;&gt;&gt; sum(numbers_gen)<br/>333333328333333350000000</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="8e7e" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">结论</h2><p id="a754" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在本文中，我们研究了Python中的四种重要技术，所有这些技术在语法上都包含相同的组件。下面是这些技术的快速回顾和它们用例的亮点。</p><ul class=""><li id="3a38" class="nu nv it lk b ll lm lo lp lr nw lv nx lz ny md nz oa ob oc bi translated"><strong class="lk jd">列表理解</strong> : <code class="fe ni nj nk nl b">[expression for item in iterable]</code> —创建列表的简明方法</li><li id="0773" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated"><strong class="lk jd">词典理解</strong> : <code class="fe ni nj nk nl b">{exp_key: exp_value for item in iterable}</code> —一种创建词典的简明方法</li><li id="70b2" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated"><strong class="lk jd">集合理解</strong> : <code class="fe ni nj nk nl b">{expression for item in iterable}</code> —创建集合的简明方法(无重复项)</li><li id="5a94" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated"><strong class="lk jd">生成器表达式</strong> : <code class="fe ni nj nk nl b">(expression for item in iterable)</code> —创建生成器的简洁方法(内存高效)</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="1ade" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">关于作者</h2><p id="a450" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我写关于Python和数据处理与分析的博客。万一你错过了我以前的一些博客，这里有一些与当前文章相关的文章链接。</p><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/30-simple-tricks-to-level-up-your-python-coding-5b625c15b79a" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd jd gy z fp oq fr fs or fu fw jc bi translated">提升Python编码水平的30个简单技巧</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">更好的Python</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz lb ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/9-things-to-know-to-master-list-comprehensions-in-python-8bc0411ec2ed" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd jd gy z fp oq fr fs or fu fw jc bi translated">掌握Python中列表理解的9件事</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">本教程将帮助你学习Python中列表理解的最常见用法</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz lb ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://medium.com/swlh/understand-pythons-iterators-and-iterables-and-create-custom-iterators-633939eed3e7" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd jd gy z fp oq fr fs or fu fw jc bi translated">理解Python的迭代器和可迭代对象，并创建自定义迭代器</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">迭代是Python中最重要的概念之一。与迭代相关的两个术语是迭代器和…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pb l ow ox oy ou oz lb ol"/></div></div></a></div></div></div>    
</body>
</html>