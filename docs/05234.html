<html>
<head>
<title>How to Implement Dynamic Components on Vuejs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Vuejs上实现动态组件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dynamic-components-vuejs-13c3e70431cc?source=collection_archive---------30-----------------------#2020-05-04">https://towardsdatascience.com/dynamic-components-vuejs-13c3e70431cc?source=collection_archive---------30-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0095" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解轻松创建模块化应用程序的解决方案</h2></div><p id="c8b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单页应用程序现在是大多数情况下的标准。从表现中分离业务逻辑在效率和质量方面带来了巨大的优势。事实上，大多数框架构建了一组静态文件，这是降低托管或部署复杂性的一个额外好处。这些特征对于企业应用程序来说是很好的，但是当我开始开发RawCMS的前端时，我发现这些特征非常有限。事实上，我需要一个模块化的系统，贡献者可以在没有任何限制或构建任何东西的情况下向界面添加功能。在这篇文章中，我将回顾我提出最终解决方案的步骤。</p><p id="0ed2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">剧透:</strong>我用Vuex和普通javascript结束了VueJs。结果是一个从任何公共URL加载组件的动态引擎，如果我可以从头开始，我会再次做出同样的决定😆</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/5c434430863cd948e834a71fdf055b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0FF1pBzqHXsTEOL4gzH-CQ.jpeg"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">foto di<a class="ae lu" href="https://pixabay.com/it/users/PIRO4D-2707530/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3127504" rel="noopener ugc nofollow" target="_blank">piro 4d</a>da<a class="ae lu" href="https://pixabay.com/it/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3127504" rel="noopener ugc nofollow" target="_blank">pix abay</a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a3a2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我需要的</h1><p id="d266" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">在像headless cms这样的产品上工作，你想让人们扩展平台开发他们自己的模块是一个挑战。在前端部分，我被说服使用水疗方法，我习惯了玩角，但有一个挑战。构建完成后，动态加载组件、扩展UI(如添加菜单项或路由)并不容易。</p><p id="b972" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是为什么当我和莱昂纳多·马库奇开始着手这项工作时，我们记录了一些市场提供的技术机会。</p><p id="4d20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们发现了三种主要的解决方案，每一种都有利弊。</p><h2 id="f995" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">使用Iframes</h2><p id="0b15" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">此解决方案包括部署多个SPA，并使用一个中央SPA来管理外壳。因此它可以根据模块的数量(SPA部署)加载菜单项。我放弃了这个解决方案，因为我害怕iframe的局限性和模块之间的交互。我担心像这样的解决方案只不过是一个链表。</p><h2 id="290c" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">Web组件</h2><p id="464e" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我发现了一些关于web组件的好观点。对于我所寻找的，web组件是一个很好的解决方案，但我会使用易于使用的技术解决方案，并广泛用于防止来自社区的拒绝，在我做出这个选择的时候，像StencilJs这样的解决方案还很年轻。</p><h2 id="8e40" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">利用我们所拥有的来玩</h2><p id="8520" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">最终的解决方案是使用广泛使用的库，让我不用构建就可以开发一个SPA，并且可以动态加载新的插件。这非常简单，只需要使用VueJs天生给我们的东西。不信？只看下一章。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="10bf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们如何制作VueJs水疗模块</h1><p id="8ba2" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">最后的决定是使用普通VueJs，因为它允许我们在没有构建过程的情况下做伟大的事情。限制一点浏览器兼容性，我们可以使用ES6，利用许多强大的功能，如承诺、阵列自动化等。在我们的例子中，该产品是为开发人员设计的，所以我们认为强迫他们使用Chrome、Firefox或Edge等现代浏览器并不是一个很大的限制。此外，如果一个开发者想继续使用IE6，我们可能有一个比安装一个使用这个无头cms的浏览器更大的问题要解决。</p><p id="a106" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，VueJs是被选中的框架，然后我们有一系列的挑战来使它工作。在这一章中，我试图重新回顾所有将我们带到最终版本的步骤。</p><h2 id="bb57" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">第一块砖:动态文件加载</h2><p id="2073" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我们首先使用的是动态加载javascript模块的机会。基本上，以下选项是等效的:</p><pre class="lf lg lh li gt nl nm nn no aw np bi"><span id="bfb4" class="mz md it nm b gy nq nr l ns nt">import {MyDefaultComponent} from '/MyDefaultComponentFile.js'</span><span id="4094" class="mz md it nm b gy nu nr l ns nt">//or</span><span id="a5ff" class="mz md it nm b gy nu nr l ns nt">const filePath='/MyDefaultComponentFile.js';<br/>import(filePath).then(x =&gt; x.default());</span></pre><p id="bde2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中,<strong class="kk iu"> MyDefaultComponent </strong>是这样声明的:</p><pre class="lf lg lh li gt nl nm nn no aw np bi"><span id="6111" class="mz md it nm b gy nq nr l ns nt">import { XanderCage} from '/xxx.js'; <br/>const _myComponentInstance = function(){<br/>//Declare your component here<br/>};</span><span id="9024" class="mz md it nm b gy nu nr l ns nt">export default _myComponentInstance;</span></pre><p id="0021" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">import语句也可以以编程方式调用，使整个解决方案动态化，如下所示:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d841" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码片段是RawCMS引导模块调用API返回注册模块列表的地方。在这个特定的例子中，我将它们都添加到一个列表中，然后我一起解析所有的承诺，以确保在init阶段之前加载所有的承诺。可以对他的原始代码进行改进或优化，但这是我稍后将讲述的所有内容的基础。</p><h2 id="64d6" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">组件集成</h2><p id="035d" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">正如您在上一段中看到的，导入仅限于名为“config.js”的文件。这个文件必须放在插件文件夹的根目录下，并且将包含一个带有模块配置的json对象。为此，我使用了Vuex，VueJs的状态管理框架。这使得事情很容易管理。在主机应用程序上集成所有动态组件的代码只有几行代码:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9a6f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们通过解析承诺加载了所有模块(第一个模块是宿主应用程序，单独处理)。其他模块通过初始化(使用标准方法)和获取路线集成到应用程序中。</p><p id="942f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一步之后，我们的模块是主应用程序的一部分，可以使用了。</p><h2 id="5b03" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">路线</h2><p id="b8b1" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">通过将来自模块的单个路由添加到Vue路由引擎中，可以自动管理路由。我们只需要一个额外的步骤来管理国际化。这需要根据我们正在访问的路由来加载翻译，因此我们在路由管道上添加了一个链。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a9e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码加载所有来自模块的翻译，并将其合并。c核心标签用作故障转移。</p><h2 id="8e2a" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">菜单整合</h2><p id="46ad" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">基于模块的定义添加菜单项是一件非常简单的事情，只是一个渲染问题。组件的js端只是将来自插件的信息放在一个属性中，以便在模板端进行简单的管理。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="7e22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在模板上，我们只需要使用材料设计组件来呈现元素。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="8751" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">模块间的通信</h2><p id="1441" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">两种基本机制允许模块之间的通信</p><ol class=""><li id="03fb" class="nx ny it kk b kl km ko kp kr nz kv oa kz ob ld oc od oe of bi translated">事件</li><li id="bc83" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld oc od oe of bi translated">Vuex状态</li></ol><p id="3249" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过事件，我们可以通知所有模块有事情发生。因为事件系统是中心的，所有的事件名称都是按名称引用的，所以不存在物理依赖性。所有想要列出给定事件的模块都可以基于它来做和反应，即使它们在模块之外。基于这一原则，当用户登录时，登录组件会通知显示用户徽章的组件，但是您也可以附加您的组件。剩下的由Vuex库完成。在下一个代码片段中，登录的例子被翻译成了代码。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1ff0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">什么是<em class="ol"> RawCMS.eventBus </em>？只不过是一个Vue组件。看看RawCMS的定义就知道了。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="cfbf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一点是关于Vuex的用法。我将定义Vuex模块以及如何从Vuex存储器读取/写入数据的代码段添加到代码片段中。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9117" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">带什么回家</h1><p id="69b5" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">创建模块化SPA应用程序是可能的，并且在某些情况下是必需的。我的用例是一个开源的可扩展产品，并不常见，但是你可能会遇到类似的情况。试想一个应用程序太大，无法由一个团队或公司开发。使用事件总线和强大的约定将应用程序分解成模块，使之成为可能。我提出的解决方案是可行的，并且易于实现。使用几个月后，我对它的看法。</p><h2 id="8d06" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated"><strong class="ak">亲</strong></h2><ul class=""><li id="fd8c" class="nx ny it kk b kl mu ko mv kr om kv on kz oo ld op od oe of bi translated">易于设置</li><li id="8e6d" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld op od oe of bi translated">易于管理</li><li id="cd95" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld op od oe of bi translated">容易理解</li><li id="65c6" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld op od oe of bi translated">可以与后端代码集成</li><li id="faa3" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld op od oe of bi translated">易于包装和移动</li></ul><h2 id="e2e0" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">面向连接的网络服务(Connection Oriented Network Service)</h2><ul class=""><li id="4bca" class="nx ny it kk b kl mu ko mv kr om kv on kz oo ld op od oe of bi translated">不容易防止js错误(没有构建过程)</li><li id="0b48" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld op od oe of bi translated">难以优化(没有构建，谁能负责压缩或最小化javascript)？</li><li id="da67" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld op od oe of bi translated">不要在旧的浏览器上工作，因为没有任何填充或传输。</li></ul><p id="8473" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在RawCMS案例中，一个对开发人员进行评估的产品，UI只是用来让技术人员建立一个无头CMS，与采用智能解决方案的好处相比，它的局限性是微不足道的。在企业案例或具有不同类型用户的其他产品中，您可能需要一些额外的工作(可能在DevOps方面)来克服实际解决方案的限制。</p><h1 id="0721" class="mc md it bd me mf oq mh mi mj or ml mm jz os ka mo kc ot kd mq kf ou kg ms mt bi translated">参考</h1><ul class=""><li id="dbaa" class="nx ny it kk b kl mu ko mv kr om kv on kz oo ld op od oe of bi translated"><a class="ae lu" href="https://github.com/arduosoft/RawCMS/" rel="noopener ugc nofollow" target="_blank">raw CMS项目(Git Hub源代码)</a></li><li id="497c" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld op od oe of bi translated">(电子书)<a class="ae lu" href="https://www.amazon.com/Vuex-Quick-Start-Guide-applications/dp/1788999932" rel="noopener ugc nofollow" target="_blank">来自Andrea Koutifaris的Vuex快速入门指南</a></li><li id="9266" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld op od oe of bi translated"><a class="ae lu" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> VueJs </a>主页</li><li id="b482" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld op od oe of bi translated">RawCMS UI的主要撰稿人Leonardo Marcucci </li></ul></div></div>    
</body>
</html>