<html>
<head>
<title>Building an End-to-End Defect Classifier Application for Printed Circuit Boards</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为印刷电路板构建端到端缺陷分类器应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232?source=collection_archive---------9-----------------------#2020-02-04">https://towardsdatascience.com/building-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232?source=collection_archive---------9-----------------------#2020-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8fb2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用图像处理和深度学习检测、提取和分类电路板缺陷</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5ed24c1cbd38130a8400408a40bc0572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OQnQr3fFDCMkAEy_8MY6yA.png"/></div></div></figure><p id="7f4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://en.wikipedia.org/wiki/Printed_circuit_board" rel="noopener ugc nofollow" target="_blank">印刷电路板</a> (PCB)在大多数电子产品中，沿着导电轨道机械地支撑和连接元件。它们的流行是现代电子工业的基础，其全球市场超过600亿美元。</p><p id="d10d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">多氯联苯容易出现各种各样的<strong class="kt ir">缺陷</strong>，阻碍正常生产，给公司造成损失。短路、杂散、鼠咬和针孔等缺陷会导致电流泄漏和开路等问题，迅速降低性能或使PCB变得无用。PCB制造商必须努力发运无缺陷产品，以保持竞争力并确保客户满意度。</p><p id="ed5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">雇用故障分析师以确保缺陷保持在最低水平。但是手工检查和诊断缺陷是具有挑战性的。有多种缺陷需要检测，对错误的容忍度极低，并且可靠地识别和处理有缺陷的单元需要大量的专业知识。考虑到培训新分析师的时间以及确保可靠性所需的认知负荷，需要一种自动检测和分类PCB缺陷的解决方案。</p><p id="e3b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我们将建立一个<em class="lo">全</em> PCB缺陷分类器，自动检测和分类印刷电路板中的缺陷。我总是鼓励人工智能从业者构建完整的产品，而不是把模型扔给开发人员和其他工程师。你的机器学习必须和一个完整的应用协同存在；因此，只有通过它在整体产品中的生存，你才能确定你是在为用户而不是工程师建造。</p><p id="0747" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">播放下面的<strong class="kt ir">视频</strong>来看看我们将在本文中构建的应用程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="2042" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将检查应用程序的<em class="lo">后端</em>和<em class="lo">前端</em>代码<em class="lo">。</em>我将遍历<strong class="kt ir">所有与缺陷<em class="lo">检测</em>、<em class="lo">提取</em>和<em class="lo">预测</em>相关的代码</strong>。因此，机器学习方面将被完全覆盖。然而，为了使本文保持合理的篇幅，我将只回顾实际应用程序管道代码和前端代码的高级方面。请注意，<strong class="kt ir">整个应用程序</strong>及其代码都可以在<a class="ae ln" href="https://github.com/sean-mcclure/defect_classifier" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得，因此读者可以访问所有内容。我鼓励其他人在他们认为合适的时候克隆和参与这个项目。</p><p id="7f33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这永远是最好的学习方法。我欢迎需要支持的人在<strong class="kt ir">评论</strong> <strong class="kt ir">版块</strong>提问(你也可以在<a class="ae ln" href="https://twitter.com/sean_a_mcclure" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> Twitter </strong> </a>上@我，这样支持更公开地惠及他人)。</p><p id="7c35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们开始吧。</p><h1 id="4207" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">这些碎片</h1><h2 id="37ef" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">编码环境</h2><ul class=""><li id="6c77" class="mv mw iq kt b ku mx kx my la mz le na li nb lm nc nd ne nf bi translated"><a class="ae ln" href="https://colab.research.google.com/notebooks/intro.ipynb" rel="noopener ugc nofollow" target="_blank">谷歌Colab </a></li></ul><h2 id="09dc" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">网络服务</h2><ul class=""><li id="ccef" class="mv mw iq kt b ku mx kx my la mz le na li nb lm nc nd ne nf bi translated"><a class="ae ln" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank">烧瓶</a></li></ul><h2 id="ce2f" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated"><strong class="ak">图书馆</strong></h2><ul class=""><li id="1d04" class="mv mw iq kt b ku mx kx my la mz le na li nb lm nc nd ne nf bi translated"><strong class="kt ir">深度学习</strong> : <a class="ae ln" href="https://www.fast.ai/" rel="noopener ugc nofollow" target="_blank"> fastai </a></li><li id="6467" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">图像处理</strong> : <a class="ae ln" href="https://www.notes2tree.com//published_tree/?publish_tree=Qjb4gOndye" rel="noopener ugc nofollow" target="_blank">蚱蜢</a></li><li id="0ca2" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">用户界面</strong> : <a class="ae ln" href="https://azlejs.com" rel="noopener ugc nofollow" target="_blank"> Azle </a></li></ul><h2 id="3888" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated"><strong class="ak">笔记本</strong></h2><ul class=""><li id="8f40" class="mv mw iq kt b ku mx kx my la mz le na li nb lm nc nd ne nf bi translated"><strong class="kt ir">笔记本</strong>:<a class="ae ln" href="https://github.com/sean-mcclure/defect_classifier/blob/master/notebooks/PCB_Defect_Extraction_and_Classification.ipynb" rel="noopener ugc nofollow" target="_blank">PCB _ Defect _ Extraction _ and _ class ification . ipynb</a></li></ul><h2 id="971e" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">产品(我们将构建这些产品)</h2><ul class=""><li id="ef55" class="mv mw iq kt b ku mx kx my la mz le na li nb lm nc nd ne nf bi translated"><a class="ae ln" href="https://github.com/sean-mcclure/defect_turker" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"/></a>:(f<em class="lo">或创建标签图像数据</em></li><li id="0c87" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><a class="ae ln" href="https://github.com/sean-mcclure/defect_classifier" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> PCB缺陷分类器</strong> </a> : ( <em class="lo">自动视觉检测系统和分类器</em>)</li></ul><h1 id="f0c8" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">挑战</h1><p id="f5b0" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">当试图自动化缺陷检测和分类时，我们面临许多挑战。其中一些已经在导言中提到。更完整的列表包括:</p><ul class=""><li id="ab64" class="mv mw iq kt b ku kv kx ky la no le np li nq lm nc nd ne nf bi translated"><strong class="kt ir">单位缺陷低容差</strong>；</li><li id="2aa6" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">多种缺陷类型</strong>来说明；</li><li id="b2bd" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">自动化解决方案所需的低推理时间</strong>；</li><li id="68b5" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">ML模型的训练数据</strong><strong class="kt ir">受限</strong>(通常是窄的、特定领域的、小的)；</li><li id="3b82" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">传统系统<strong class="kt ir">依赖手工制作的功能</strong>和重要的<strong class="kt ir">专业知识</strong>；</li><li id="4851" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">别人经常使用的方法<strong class="kt ir">私人</strong>。</li></ul><p id="0ec3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要一种方法来应对这些挑战，同时支持现实世界中的应用，有效地检测、提取和预测PCB中的缺陷类型。</p><h1 id="f487" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">方法</h1><p id="67b3" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">考虑到我们面临的挑战，使用一种<strong class="kt ir">混合</strong> <strong class="kt ir">方法</strong>来构建我们的分类器应用程序是有意义的，它结合了<em class="lo">引用方法</em>和<em class="lo">非引用方法</em>。</p><p id="4506" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">参考方法</strong>:将检查过的<strong class="kt ir"> </strong> PCB板(测试板)<em class="lo">与没有缺陷的参考模板图像(模板板)</em>进行比较，以允许分析人员识别差异。</p><p id="bb83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">非基准法</strong> : <strong class="kt ir"> </strong>检查<strong class="kt ir"> </strong> PCB板是否符合设计原则，不依赖模板图像。</p><p id="aab7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">参考方法实现起来相对简单，但是有很大的存储需求(保存所有图像)。非参考方法没有存储问题，但是在发现缺陷的数量上受到限制。</p><blockquote class="nr ns nt"><p id="31ac" class="kr ks lo kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated">构建一个<em class="iq">自动化</em>参比和非参比方法的产品可能不会减少存储和计算需求，但如果人工检测和分类错误减少，我们将从增加和可靠的通量中获得巨大收益。</p></blockquote><h2 id="8c76" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">使缺陷分类成为可能</h2><p id="ba9b" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">虽然我们可以尝试训练我们的深度学习模型来对整个电路板上存在的缺陷进行分类，但这将是一个挑战。看一下下面的例子<strong class="kt ir">测试</strong>和<strong class="kt ir">模板</strong> PCB板:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/685ba70b11702ad265fd0e7aff00dc56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MF4HYs2tG1BdG5xsOtBzCg.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated"><strong class="bd oc">图1 </strong>参考方法中使用测试和模板图像来识别缺陷。请注意左侧图像相对于右侧图像的差异。</p></figure><p id="e5a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">左边的板子是我们的模型需要分类的。通过与模板进行比较，我们可以看到单个缺陷。但是我们的模型能够可靠地对缺陷组合进行分类的可能性有多大呢？这门课叫什么？存在多少独特的缺陷组合？</p><p id="23ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了减轻模型的负担，我们将首先从测试图像中提取单个缺陷。这可以通过创建<strong class="kt ir">差分图像</strong>和<em class="lo">提取</em>图像的不同部分来实现。</p><p id="fc97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是我们可以使用Python中的图像处理生成的差分图像:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/589b1d2af69dc1bc8a4b07aaccc6a011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PoAjoVCZfXT_LjkqBacRQw.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated"><strong class="bd oc">图2 </strong>通过图像相减生成的差分图像。我们使用图像差分来自动突出测试图像中的缺陷。</p></figure><p id="0d34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意缺陷在<strong class="kt ir">红色</strong>中突出显示。上图没有显示所有的缺陷，因为在本文中我们只关注提取3种类型。捕获其他类型的缺陷是相当琐碎的，我将在后面讨论这个问题。</p><p id="ee9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我们有一个突出测试图像中缺陷的差分图像，我们也可以使用图像处理来<strong class="kt ir">提取</strong>图像的彩色部分:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/971eb16a1ca02c6ae56f6fad8529f3aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CgLxz0RxnpqdBG3nkQn0Rg.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated"><strong class="bd oc">图3 </strong>缺陷提取。我们将使用图像处理来提取差分图像中突出显示的部分。</p></figure><p id="13d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这大大降低了我们深度学习分类器的负担。通过提取单个缺陷，我们将问题从复杂的识别问题转化为类似于数字识别的问题(这个问题已经在深度学习中得到了很好的解决)。这也意味着我们使用<a class="ae ln" href="https://en.wikipedia.org/wiki/Transfer_learning" rel="noopener ugc nofollow" target="_blank">迁移学习</a>更有可能成功，因为在OCR领域有许多成功的模型。稍后我会更详细地讨论迁移学习。</p><p id="03bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用这种方法我们可以概括出<strong class="kt ir">5</strong>T8】的主要努力:</p><ol class=""><li id="6d29" class="mv mw iq kt b ku kv kx ky la no le np li nq lm of nd ne nf bi translated">缺陷提取</li><li id="4dd1" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm of nd ne nf bi translated">缺陷标签</li><li id="ceca" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm of nd ne nf bi translated">缺陷分类</li><li id="f0fc" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm of nd ne nf bi translated">构建PCB缺陷分类器应用程序</li><li id="56a7" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm of nd ne nf bi translated">运行/测试应用程序</li></ol><h1 id="b44f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">设置</h1><p id="4c3b" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">前往<a class="ae ln" href="https://colab.research.google.com" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">Google Colab</strong></a><strong class="kt ir"/>开始一个新的Python 3笔记本。这将是我们的建模环境。这是一个完全在云端运行的<strong class="kt ir"> Jupyter </strong> <strong class="kt ir">笔记本</strong>环境。</p><blockquote class="nr ns nt"><p id="b7ec" class="kr ks lo kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated">Google Colab允许免费访问能够运行GPU的环境。Colab还使安装和导入库变得轻而易举。这就是后端即服务(BaaS ),它对快速原型制作有很大的帮助。</p></blockquote><p id="fb9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你有两种选择将笔记本电脑放入你自己的谷歌实验室环境。</p><ol class=""><li id="1ccb" class="mv mw iq kt b ku kv kx ky la no le np li nq lm of nd ne nf bi translated">你可以简单的<strong class="kt ir">上传</strong>GitHub项目中包含的<a class="ae ln" href="https://github.com/sean-mcclure/defect_classifier/blob/master/notebooks/PCB_Defect_Extraction_and_Classification.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>:</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/4afb83e5ea44e794c52fd5270aae9d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*lWMD2ny7DPOdKmORh8QMeA.gif"/></div></figure><p id="f713" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.或者你可以<strong class="kt ir">在Google Colab中挂载一个驱动器</strong>，克隆<a class="ae ln" href="https://github.com/sean-mcclure/defect_classifier" rel="noopener ugc nofollow" target="_blank"> defect_classifier </a> repo，从你的Google drive中打开笔记本。</p><p id="3b7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 2.1打开新的Python3笔记本</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/f39948b623e797156a1108ece1d6c13a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mEY_y51QVSJEzyajiTbsgg.png"/></div></div></figure><p id="da46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 2.2在Google Colab上挂载一个驱动</strong></p><p id="5487" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">在第一个单元格中运行</strong>(<em class="lo">播放按钮，或Mac上的shift-return</em>):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/a13abe225c08442ea6b168914b033ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8D0icIBZewhDYal4A85Iw.png"/></div></div></figure><p id="6650" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您将看到一个<strong class="kt ir"> URL </strong>。点击它，获得<strong class="kt ir">授权码</strong>，回到你的笔记本并输入。您现在可以在Colab中访问您的Google Drive:</p><p id="fdd8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 2.3克隆回购</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/7fef8342ffcd78ca1e0e1521b09b329b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zvGydYNC4GiUI8cNlbUwAw.png"/></div></div></figure><p id="3f53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…然后<strong class="kt ir">将克隆的笔记本复制</strong>到您安装的驱动器中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/bed332b45606e1b85d0c10d813b05015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aBHv8N__kXSu315uEE-QIA.png"/></div></div></figure><p id="5165" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 2.4从驱动器打开笔记本</strong></p><p id="60ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在在你的Google drive中找到这个笔记本，就像你找到其他文件一样，右键点击，然后选择open with Google Colab。</p><h2 id="0e69" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">设置硬件加速</h2><p id="a11d" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们将要求<a class="ae ln" href="https://en.wikipedia.org/wiki/Graphics_processing_unit" rel="noopener ugc nofollow" target="_blank">图形处理单元</a> ( <strong class="kt ir"> GPU </strong>)在合理的时间内训练我们的深度学习模型。我们可以通过点击顶部的<em class="lo">运行时</em>，选择<em class="lo">更改运行时类型</em>，选择硬件加速器下的<em class="lo"> GPU </em>，点击保存，在Colab中设置<em class="lo">硬件加速</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/e053f3d6917d00e9c5c03ba055e263e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*RblP3Fmz-bBZq1pVwBDFFA.gif"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/7c98879a314f20ae74a719ea8f351a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uxw2Ps0YbMBfKV0u7Y-wRw.png"/></div></div></figure><h1 id="322a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">第1部分:缺陷提取</h1><p id="7747" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">首先，我们需要构建缺陷提取管道。为了使用更少的代码，我创建了一个小的库，它将抽象大部分的图像处理。我计划继续添加到这个库中，以保持关注。关于用R和Python创建库的直观而详细的教程，请看这里的<a class="ae ln" rel="noopener" target="_blank" href="/step-by-step-guide-to-creating-r-and-python-libraries-e81bbea87911"/>。</p><p id="b227" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们导入库:</p><h2 id="c859" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">安装并导入tetryonai</h2><p id="c23a" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">该库可以在GitHub上免费获得。我们可以使用pip 从GitHub安装库，如下所示:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="8f99" class="mj ls iq on b gy or os l ot ou">!pip install git+https://github.com/sean-mcclure/tetryon_ai.git</span></pre><p id="210f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意！在通常的pip命令之前。这是做交互计算时常用的“bang”符号。它允许我们的Google Colab环境访问底层shell。</p><p id="4597" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以<strong class="kt ir">导入</strong>库:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="217b" class="mj ls iq on b gy or os l ot ou">from tetryonai.main import *</span></pre><p id="1265" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您也可以点击左侧的<strong class="kt ir">文件</strong>图标，这样我们就可以看到我们正在处理的文件(根据需要点击<em class="lo">刷新</em>):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/143c23732fefd0b61bfd9f365b05ef94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*4DSNZ7i1y6Qbu02fBWp0bA.gif"/></div></figure><h2 id="7339" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">创建文件夹</h2><p id="90b5" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">让我们创建文件夹来保存我们的差异图像、提取的缺陷以及测试我们的模型所需的保留图像。我们将使用tetryonai的<strong class="kt ir">目录</strong> <strong class="kt ir">函数</strong>:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="2315" class="mj ls iq on b gy or os l ot ou"><strong class="on ir">directory</strong>(**{<br/>    "choice" : "make",<br/>    "directory_path" : "difference_img"<br/>})</span><span id="eb16" class="mj ls iq on b gy ov os l ot ou"><strong class="on ir">directory</strong>(**{<br/>    "choice" : "make",<br/>    "directory_path" : "extracted_defects"<br/>})</span><span id="be24" class="mj ls iq on b gy ov os l ot ou"><strong class="on ir">directory</strong>(**{<br/>    "choice" : "make",<br/>    "directory_path" : "hold_out"<br/>})</span></pre><h2 id="9dc8" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">克隆PCB数据集</h2><p id="a909" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们将需要访问大量的测试和模板PCB板图像。这些都可以通过<strong class="kt ir"> DeepPCB </strong>项目在<a class="ae ln" href="https://github.com/tangsanli5201/DeepPCB" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。这为我们提供了从线性扫描CCD获得的大量图像。有关更多详细信息，请查看此项目。</p><p id="d31d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">通过在下一个单元中运行以下命令，将DeepPCB项目克隆到您的Colab环境中:</strong></p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="4c88" class="mj ls iq on b gy or os l ot ou">!git clone https://github.com/tangsanli5201/DeepPCB.git</span></pre><p id="e8fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">点击文件窗格中的<em class="lo">刷新</em>来查看新的DeepPCB文件夹。您可以展开文件夹，查看有多少图像可用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/a6e10a1e860cad9435b59aa1093527d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g63B9OhevWoLjjhTlWhMiw.png"/></div></div></figure><p id="546a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这个项目，我们将只使用如上所示的<strong class="kt ir">组临时和测试图像。这些是先前在图1-3中描述的图像。</strong></p><h2 id="764c" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">将PCB温度和测试图像路径存储在Dict中</h2><p id="fabc" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">让我们写一些Python来存储来自我们的DeepPCB文件夹的<strong class="kt ir"> group00041 </strong> temp和测试图像路径，放在一个<strong class="kt ir"> dict中。</strong>我们将在下一步中使用它来区分我们的图像:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><h2 id="dd9b" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">所有PCB图像的差异</h2><p id="6642" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">现在我们将使用图像处理来<strong class="kt ir">区分</strong>每对临时和测试图像，使用我们刚刚创建的dict中指定的路径。我们还需要<strong class="kt ir">展示</strong>一组这些图像，以便在我们的应用程序中进行测试。为了方便起见，我将这些操作合并到一个代码块中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><p id="bd24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用tetryonai的<strong class="kt ir"> copy_files </strong>函数将必要的文件复制到我们之前创建的名为<strong class="kt ir"> hold_out </strong>的<code class="fe oy oz pa on b">target_directory</code>中。我使用20%的<code class="fe oy oz pa on b">split_percentage</code>作为坚持集。在上面的代码中，一旦20%的图像被保留，剩下的就用tetryonai的<strong class="kt ir"> subtract_images </strong>函数减去。</p><p id="34a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们<em class="lo">刷新</em>我们的文件窗格并检查我们的<strong class="kt ir"> difference_img </strong>和<strong class="kt ir"> hold_out </strong>文件夹，我们将看到已检查的图像。您也可以打开<em class="lo"> difference_img </em>中的一些图像来确认减影过程有效(如<em class="lo">图2 </em>所示):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/957b7ac590a811801d899ad87e25a023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*3Fsl2hRBGOeSye-lqSQZag.gif"/></div></figure><h2 id="7091" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">从差异图像中提取缺陷</h2><p id="0ed8" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们现在准备好<strong class="kt ir">提取</strong>出现在差异图像中的高亮缺陷。我们将使用tetryonai的<strong class="kt ir">extract _ contours _ from _ image</strong>函数来<em class="lo">读入</em>每幅差分图像，<em class="lo">提取每幅图像的</em>缺陷，<em class="lo">将</em>缺陷保存到我们在开始时创建的<strong class="kt ir"> extracted_defects </strong>文件夹中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><p id="9098" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">损坏/不可读的图像将被<strong class="kt ir">跳过</strong>提取_轮廓_来自_图像功能。这仍然给我们留下了大量的图像来训练我们的模型。</p><blockquote class="nr ns nt"><p id="7d3b" class="kr ks lo kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated"><strong class="kt ir">extract _ contours _ from _ image</strong>函数使用<strong class="kt ir">轮廓</strong>提取差分图像的高亮部分。将轮廓视为连接所有具有相同颜色或强度的连续点(沿边界)的曲线。轮廓是形状分析和物体检测/识别的有用工具。你可以在<a class="ae ln" href="https://docs.opencv.org/trunk/d4/d73/tutorial_py_contours_begin.html" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>上阅读更多关于轮廓的内容。</p></blockquote><p id="cc8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">刷新文件窗格并检查<strong class="kt ir"> extracted_defects </strong>文件夹。您会注意到，已经为从每个差分图像中提取的每组轮廓创建了单独的文件夹。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c25c588310a906f4cc18ac57439d1a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*MkrLQn0wNZaHtm0URLmj6A.gif"/></div></figure><p id="248a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在将所有提取的缺陷合并到一个名为<strong class="kt ir"> all_extracts </strong>的目录中。现在让我们创建目录:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="3061" class="mj ls iq on b gy or os l ot ou"><strong class="on ir">directory</strong>(**{<br/>    "choice" : "make",<br/>    "directory_path" : "all_extracts"<br/>})</span></pre><p id="3b6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们编写一些Python来<em class="lo">遍历</em>提取的_缺陷目录，并且<strong class="kt ir">使用tetryonai的<strong class="kt ir"> move_files </strong>函数移动</strong>任何PNG文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><p id="d5f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">刷新文件窗格并检查<strong class="kt ir"> all_extracts </strong>文件夹将显示所有提取的缺陷。</p><h2 id="2166" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">为土耳其语压缩提取的缺陷</h2><p id="6436" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">在第2部分中，我们将把<em class="lo">标签</em>应用到我们提取的缺陷上(“突化”)。因此，我们需要下载所有提取的缺陷图像，以便与我们接下来创建的标签应用程序一起使用。所以让我们<strong class="kt ir">压缩</strong>所有提取的缺陷以便于下载:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="7a34" class="mj ls iq on b gy or os l ot ou">!zip -r /content/extracted_defects.zip /content/all_extracts/</span></pre><p id="b12d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你<em class="lo">刷新</em>你的文件面板，你会看到一个新的<strong class="kt ir"> extracted_defects.zip </strong>文件被创建。</p><p id="0283" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的标签应用程序还需要一个<strong class="kt ir"> JSON </strong>文件，其中包含我们zip文件夹中图像的文件名。让我们写一些Python来抓取<strong class="kt ir"> all_extracts </strong>目录中的所有<strong class="kt ir">文件名</strong>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><p id="f2a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">保存我们刚刚创建的JSON文件:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="5c2f" class="mj ls iq on b gy or os l ot ou">with open('extracted_defects.json', 'w') as outfile:<br/>    json.dump(file_names_and_sizes, outfile)</span></pre><p id="6b91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lo">刷新</em>文件窗格，下载<strong class="kt ir"> extracted_defects.zip </strong>和<strong class="kt ir"> extracted_defects.json </strong>文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/acf8589c61c74631fab54e7460b7b99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*tYtMs5166rGro4IPnOTZMg.gif"/></div></figure><p id="af24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">暂时将这些文件保存到你的<strong class="kt ir">桌面</strong>。</p><p id="384e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第一部分中，我们区分了一大组测试和模板PCB图像，使用轮廓提取了差异图像中的缺陷，并创建了2个文件，我们需要使用我们接下来创建的标签应用程序。让我们现在做那件事。</p><h1 id="24d1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">第2部分:缺陷标签</h1><p id="f772" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">有了我们提取的缺陷图像集，我们就有了一个相当大的数据集来用于训练图像分类的深度学习模型。但是像任何有监督的机器学习方法一样，我们的训练数据需要<strong class="kt ir">标签</strong>。因为我们提取了我们的图像，我们显然没有这些标签可用。</p><p id="21c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">图像分类需要大量的标注数据，使得手工标注成为一项艰巨的任务。但是图像分类的庞大数据先决条件通常并不妨碍节目。这是因为有大量公开可用的模型已经在大型基准图像集上进行了训练。只要领域<em class="lo">不是太不同</em>我们可以使用少得多的数据来训练预训练模型。我们能使用更少的标记数据，结合现有的图像分类器，成功地对提取的缺陷进行分类吗？</p><p id="332f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的打赌是肯定的，但只有一种方法可以找到答案。这是一个制造新的通用产品的好机会。该产品将允许我们<strong class="kt ir">为一组图像</strong>创建标签。</p><h2 id="ac4b" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">产品:缺陷Turker</h2><p id="96b7" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi pb translated"><span class="l pc pl bm di pm"> <img alt="T" class="kp pn po pp pq pr fc n ie dh bf" src="../Images/131b01b676ca611806dc4b27494376f0.png" width="87" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:174/1*4ADAqXZdUw-GDaQgO_lWWQ.png"/> <span class="l pc pd pe bm pf pg ph pi pj di pk"> T </span> </span>由于这篇文章已经够长了，所以我就不详细介绍创建缺陷图克尔的步骤了。这是一个简单的应用程序，允许我们将标签应用到它的<code class="fe oy oz pa on b">img</code>文件夹中的任何图像。</p><blockquote class="nr ns nt"><p id="d08b" class="kr ks lo kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated">太多时候，人们急于寻找现有的解决方案，而产品并不能解决他们真正的需求。大量的时间(和金钱)最终被浪费在试图迫使现有产品应对特定的挑战上。定制软件开发是非常强大的，但只有当它不被人员过多的项目和过度设计的解决方案所抑制时。快速原型制作是一项非常有益的技能。</p></blockquote><p id="871f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们不会在Colab上做标记，因为它目前没有明显的方法在其环境中托管web应用程序。因此，我们将在本地运行缺陷检测器<strong class="kt ir"/>。</p><p id="f740" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">缺陷Turker可在<a class="ae ln" href="https://github.com/sean-mcclure/defect_turker" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。<strong class="kt ir">通过在<strong class="kt ir">终端</strong>会话中运行以下命令，将</strong>应用程序克隆到您的本地机器上:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="f203" class="mj ls iq on b gy or os l ot ou">git clone <a class="ae ln" href="https://github.com/sean-mcclure/defect_turker.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sean-mcclure/defect_turker.git</a></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/caed49f0a71bf24e117b61731761beac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*WfeYXBRNbxn_an7nXA-NaQ.gif"/></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">使用一个<strong class="bd oc">终端</strong>会话来克隆<strong class="bd oc">缺陷生成器</strong>应用程序并启动一个简单的<strong class="bd oc"> web服务</strong>。</p></figure><p id="1926" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还使用下面的代码行启动了一个简单的web服务<strong class="kt ir"/>:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="1511" class="mj ls iq on b gy or os l ot ou">python3 -m http.server</span></pre><p id="093d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的浏览器打开应用程序之前，让我们<strong class="kt ir">添加</strong>我们之前创建的提取的缺陷图像(<strong class="kt ir">extracted _ defects . zip</strong>)<strong class="kt ir"/>和JSON文件(<strong class="kt ir">extracted _ defects . JSON</strong>)<strong class="kt ir"/>到应用程序中。这些文件在我的桌面上，所以我双击ZIP文件来解压缩它的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/72025a80b35a1eaa9ded971bc256f872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*E4nmeRKX1xd9UqNwa1zrnw.gif"/></div></figure><p id="7494" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">..并在<strong class="kt ir">终端</strong>中的<strong class="kt ir">新标签</strong>中运行以下代码行，从defect_turker目录中:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="f1b2" class="mj ls iq on b gy or os l ot ou">mv ../content/all_extracts/* ../defect_turker/img/</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/f9d3782de12c327e701a281241d16bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ZJw3WdG2lyVotoYZhJhExg.gif"/></div></figure><p id="5c71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">确认我们提取的缺陷图像在应用程序的<strong class="kt ir"> img </strong>文件夹中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/03a2d9d4ca7092ba6bab53117cd98ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*6OIzyeLqd7Ivc0RUaOR5jQ.gif"/></div></figure><p id="1857" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还需要包含所有图像名称的<strong class="kt ir"> JSON </strong> <strong class="kt ir">文件</strong>。现在移动这些:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="53cf" class="mj ls iq on b gy or os l ot ou">mv ../extracted_defects.json ../defect_turker/img/</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/c752b19e21cf1cb269acb1ba8bccc360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*G40IK0e00su7P3LVoeRp2g.gif"/></div></div></figure><p id="3e8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在准备给我们的图像贴标签。让我们<strong class="kt ir">启动应用程序</strong>。由于我们的web服务器已经启动并运行，我们只需将浏览器指向<code class="fe oy oz pa on b"><a class="ae ln" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/</a></code>。</p><blockquote class="nr ns nt"><p id="97ee" class="kr ks lo kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated">如果需要更改web服务器上的端口号，只需将端口添加到完整命令的末尾即可(例如python3 -m http.server 5555)</p></blockquote><p id="ae38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您应该看到以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/70d832fa2f1cc73840203539c24b5995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OV6YT_b6wraCJt8niGfEg.png"/></div></div></figure><p id="953a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你的第一张图片可能不是这里显示的。我们可以看到总共有<strong class="kt ir"> 1333张图片</strong>。标签太多了。我决定把这一天分开，一次做几百个。理想情况下，我们会将这项任务分配给团队中的几个人。</p><blockquote class="nr ns nt"><p id="1e0a" class="kr ks lo kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated"><strong class="kt ir">产品创意</strong>:创建这个应用程序的一个版本，允许多人完成标记，然后将结果重组到一个CSV文件中。</p></blockquote><p id="c4e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一个图标是显示每种缺陷类型的<strong class="kt ir">标签的图例。参考这个来了解哪个缺陷有什么标签。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/b4555abec0866a4b136ef5742284804f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*0GWOJhnJob64r8fLtWph0g.gif"/></div></figure><p id="fa39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">原来我们的图像差分只提取了<strong class="kt ir"> 3种类型的缺陷</strong>:</p><ul class=""><li id="bc4c" class="mv mw iq kt b ku kv kx ky la no le np li nq lm nc nd ne nf bi translated">马刺</li><li id="eba1" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">假铜</li><li id="c57e" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">短的</li></ul><blockquote class="nr ns nt"><p id="deb4" class="kr ks lo kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated">只提取了3种类型的原因与我们的图像差异是如何建立的有关。我们也可以很容易地检测到其他类型的缺陷，但是在本文中，我将把我们的应用保持在这三种缺陷类型上。详情见最后的注释。</p></blockquote><p id="4334" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以<strong class="kt ir">开始</strong>标签<strong class="kt ir">标签</strong>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/8c1a054e1241848a21359254c812d90e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*9YepCNRVx7jZqUBURNinpw.gif"/></div></figure><p id="3139" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只需点击与所展示图像的标签相对应的按钮。一旦我们标记了所有的图像(或者你想要多少就有多少)，我们就点击右上角的图标<strong class="kt ir">下载一个CSV文件</strong>，该文件可用于训练我们的深度学习模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/aee35772494c3fc72ce4c17838b98ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*uEvb9Udxpjhsj40znpFkEw.gif"/></div></figure><p id="a051" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">CSV文件包含我们应用的每个图像名称和标签。将该文件保存为<strong class="kt ir"> image_labels.csv </strong>，并将其保存在您的桌面上，用于第3部分。</p><p id="f3cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在准备好训练我们的深度学习PCB分类器。</p><h1 id="a6fa" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">第3部分:缺陷分类</h1><p id="2d79" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们回到Colab笔记本，使用我们用Defect Turker创建的CSV文件来训练我们的深度学习模型。我们将使用<strong class="kt ir"/><a class="ae ln" href="https://www.fast.ai/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">fastai</strong></a>来训练我们的深度学习模型。</p><p id="031b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">研究机构fast.ai致力于通过他们的<a class="ae ln" href="https://course.fast.ai/" rel="noopener ugc nofollow" target="_blank">课程</a>、<a class="ae ln" href="https://www.fast.ai/2018/10/02/fastai-ai/" rel="noopener ugc nofollow" target="_blank">软件</a>、<a class="ae ln" href="https://www.theverge.com/2018/5/7/17316010/fast-ai-speed-test-stanford-dawnbench-google-intel" rel="noopener ugc nofollow" target="_blank">研究</a>和<a class="ae ln" href="https://forums.fast.ai/" rel="noopener ugc nofollow" target="_blank">社区</a>，让深度学习变得更加容易。他们的库<strong class="kt ir"> fastai </strong>是一个强大的开源API，位于<strong class="kt ir"> PyTorch </strong>之上。深度学习领域的最新研究突破被嵌入到fastai库，这意味着我们可以访问尖端的深度学习模型，这些模型比许多其他DL库更准确、更快；同时编写更少的代码。</p><h2 id="dbf9" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">安装fastai</h2><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="eb0f" class="mj ls iq on b gy or os l ot ou">!pip install http://download.pytorch.org/whl/cpu/torch-1.0.0-cp36-cp36m-linux_x86_64.whl</span><span id="04c6" class="mj ls iq on b gy ov os l ot ou">!pip install fastai</span></pre><p id="d4d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">和<strong class="kt ir">导入</strong>:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="de1b" class="mj ls iq on b gy or os l ot ou">from fastai.vision import *</span></pre><h2 id="57f4" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">上传带标签的数据(CSV文件)</h2><p id="4788" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们将上传用第2部分中的缺陷图创建的<strong class="kt ir"> image_labels.csv </strong>文件。在Colab中运行下面一行来上传文件:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="40fc" class="mj ls iq on b gy or os l ot ou">from google.colab import files<br/>files.upload()</span></pre><p id="9c47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能需要运行两次，因为第一次运行通常会失败。</p><p id="e337" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在将使用tetryonai的<strong class="kt ir"> csv_to_dataframe </strong>函数将<strong class="kt ir"> image_labels.csv </strong>转换为数据帧:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="a9d3" class="mj ls iq on b gy or os l ot ou">image_labels_frame = <strong class="on ir">csv_to_dataframe</strong>(**{<br/>    "path_to_csv" : "image_labels.csv"<br/>})</span></pre><p id="25c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们检查一下我们标签之间的<strong class="kt ir">等级平衡</strong>。首先，我们将使用tetryonai的<strong class="kt ir"> get_feature_counts </strong>函数获得每个标签的示例数:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="c191" class="mj ls iq on b gy or os l ot ou">labelled_counts = <strong class="on ir">get_feature_counts</strong>(**{<br/>    "data_frame" : image_labels_frame,<br/>    "feature" : "label"<br/>})</span></pre><p id="136e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…然后使用<strong class="kt ir"> Matplotlib </strong>创建我们的情节:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><p id="b4d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…这提供了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/5b565bae46af6e9687d16255d7a14424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qQKoEbKN3EvOkMDtGJ3fQ.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated"><strong class="bd oc">类别平衡</strong>缺陷类型标签之间。</p></figure><blockquote class="nr ns nt"><p id="59b5" class="kr ks lo kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated"><strong class="kt ir">注意</strong>:如果“标签”出现在图表中，在创建视觉之前在单元格中运行<code class="fe oy oz pa on b">del labelled_counts[‘label’]</code>。</p></blockquote><p id="2945" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的“多数类”不是，而3种缺陷类型相当平衡。我们可以<a class="ae ln" href="https://en.wikipedia.org/wiki/Oversampling_and_undersampling_in_data_analysis" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">下采样</strong> </a>多数类，但是可能不需要。我们将继续使用我们的标签数据，并且仅在需要时重新调整我们的训练数据的平衡。</p><h2 id="9647" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">为培训CSV创建新目录</h2><p id="bd7d" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们将使用的fastai训练方法需要为我们想要预测的<strong class="kt ir">每个类别</strong>单独标记CSV文件。让我们创建一个名为<code class="fe oy oz pa on b">training_csvs</code>的文件夹来保存这些单独的文件:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="7dde" class="mj ls iq on b gy or os l ot ou"><strong class="on ir">directory</strong>(**{<br/>    "choice" : "make",<br/>    "directory_path" : "training_csvs"<br/>})</span></pre><p id="341b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…现在让我们<strong class="kt ir">使用我们从上传的<strong class="kt ir"> image_labels.csv </strong>文件创建的<code class="fe oy oz pa on b">image_labels_frame</code>数据框架，为每个类创建单独的CSV文件</strong>。</p><p id="61e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们为每个班级创建<strong class="kt ir">个人列表</strong>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><p id="ca8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…然后我们<strong class="kt ir">将这些列表转换成每个类的数据帧</strong>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><p id="0bc4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们<strong class="kt ir">为CSV文件创建单独的文件夹</strong>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><p id="6fd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以<strong class="kt ir">将各个CSV文件</strong>移动到相应的文件夹中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><h2 id="8ff8" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">将提取的缺陷图像添加到CSV文件夹:</h2><p id="d2d4" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们显然需要<strong class="kt ir">图像</strong>来训练我们的图像分类器。这些将是我们在第1部分中提取的缺陷图像，压缩到名为<strong class="kt ir"> extracted_defects.zip </strong>的文件中，并添加到我们的缺陷分类器中进行标记。</p><blockquote class="nr ns nt"><p id="ceea" class="kr ks lo kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated">我们可以只使用当前在我们的Colab环境中的<code class="fe oy oz pa on b">extracted_defects.zip</code>文件，但是如果我们在几天内完成这个项目，我们可能已经从第1部分重新开始并重新运行我们的管道。这显然会重新创建我们的<em class="iq">压缩图像</em>文件<em class="iq"> </em>，使得我们之前标记的CSV文件(<strong class="kt ir"> image_labels.csv </strong>)中的文件名与我们的压缩图像文件名不匹配。</p></blockquote><p id="f150" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">鉴于以上所述，让我们<strong class="kt ir">删除</strong>当前在Colab中的<strong class="kt ir"> </strong> <code class="fe oy oz pa on b">extracted_defects.zip</code>文件，并<strong class="kt ir">上传</strong>我们知道我们与缺陷Turker一起使用的<strong class="kt ir"> extracted_defects.zip </strong>文件。</p><p id="2cdd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从Colab中删除压缩图像:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="097c" class="mj ls iq on b gy or os l ot ou">!rm extracted_defects.zip</span></pre><p id="6bb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">上传</strong>用于贴标:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="36a3" class="mj ls iq on b gy or os l ot ou">files.upload()</span></pre><p id="359b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">将</strong> extracted_defects.zip移动到<strong class="kt ir"> training_csvs </strong>文件夹中:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="46d6" class="mj ls iq on b gy or os l ot ou"><strong class="on ir">move_files</strong>(**{<br/>    "file_paths" : ["extracted_defects.zip"],<br/>    "target_directory" : "training_csvs"<br/>})</span></pre><p id="d14a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">从<strong class="kt ir"> extracted_defects.zip </strong>中提取</strong>所有图像到<strong class="kt ir"> training_csvs </strong>文件夹中:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="cdc6" class="mj ls iq on b gy or os l ot ou">import zipfile</span><span id="c01e" class="mj ls iq on b gy ov os l ot ou">with zipfile.ZipFile("training_csvs/extracted_defects.zip", 'r') as zip_ref:<br/>    zip_ref.extractall("training_csvs/")</span></pre><p id="67df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以<strong class="kt ir">使用<strong class="kt ir"> image_labels.csv </strong>文件将所有提取的缺陷图像</strong>移动到它们适当的训练文件夹中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><p id="9f53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了清理，让我们<strong class="kt ir">删除</strong>任何未被标记的剩余PNG文件(缺陷图像):</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="f0ad" class="mj ls iq on b gy or os l ot ou"><strong class="on ir">directory</strong>(**{<br/>    "choice" : "remove",<br/>    "directory_path" : "training_csvs/content",<br/>    "force" : True<br/>})</span></pre><h2 id="49bc" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">读入用于训练分类器的图像数据</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><p id="84b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们应该<strong class="kt ir">检查</strong>到<strong class="kt ir">的图像数据以确认</strong>它们被正确读入:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="1ee6" class="mj ls iq on b gy or os l ot ou">data.show_batch(rows=4, figsize=(7, 8))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pu"><img src="../Images/ccbef5e2303654311235ac56c818deb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lf4Nz98lDGsFS8SZOqS_pA.png"/></div></div></figure><p id="e32c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以看到标签与图像匹配(杂散、杂散、短路和非缺陷图像都与所示标签匹配)。</p><h2 id="ece3" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">下载预先训练好的分类器:迁移学习</h2><p id="cb38" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们现在准备训练我们的分类器。如果我们想要得到足够好的结果来创造人们使用的产品，我们需要一个相当深入的架构。深层网络(大量堆叠的层)允许比其浅层对应物更深的表示，并且已经显示出在图像识别任务中表现得非常好。</p><p id="815c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将从<a class="ae ln" href="https://pytorch.org/docs/stable/torchvision/models.html" rel="noopener ugc nofollow" target="_blank">火炬视觉</a>下载一个<strong class="kt ir">预训练的</strong> PyTorch模型<strong class="kt ir"> </strong>。我们想使用一个预先训练好的模型来减少训练时间和CPU需求。预训练模型已经在大型基准数据集上进行了训练，以解决与我们类似的问题。这叫做<a class="ae ln" href="https://en.wikipedia.org/wiki/Transfer_learning" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">迁移学习</strong> </a>。</p><p id="67d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下图显示了我们将使用的<strong class="kt ir"> ResNet34 </strong>架构。该架构基于本文中讨论的研究。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pv"><img src="../Images/1bedfcf45fc989ba5461d6b48b80b001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gBIeSuRRBwuljbpRvrhw1Q.png"/></div></div></figure><p id="1848" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了<strong class="kt ir">从fastai下载</strong>预训练的ResNet34模型，我们运行以下程序:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="dbb0" class="mj ls iq on b gy or os l ot ou">from fastai.metrics import error_rate # 1 - accuracy<br/>learn = create_cnn(data, models.resnet34, metrics=error_rate)</span></pre><p id="f0e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们根据缺陷数据来训练我们的模型。</p><h2 id="80df" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">关于缺陷数据的培训</h2><p id="6922" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">通过使用预训练模型，这意味着在我们实施之前，所有的权重都已经被训练。我们称这种设置为<strong class="kt ir">冻结</strong>模型，默认情况下所有<em class="lo">层都冻结</em>(除了最后一层)。冻结防止训练有素的重量被修改，这正是我们想要的，因为我们正在寻求实施<strong class="kt ir">迁移学习</strong>。</p><blockquote class="nr ns nt"><p id="442b" class="kr ks lo kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated">我们在大量超参数中使用默认值。用最少的工作量来看看我们的模型能有多好是有意义的。</p><p id="3794" class="kr ks lo kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated">我们需要确保我们的笔记本电脑正在利用<strong class="kt ir"> GPU硬件加速</strong>。我们在一开始将硬件加速器设置为GPU时就这样做了。如果您在本文开始后重新启动了笔记本电脑，请确保它仍处于设置状态。</p></blockquote><p id="54d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们通过Nvidia的<a class="ae ln" href="https://en.wikipedia.org/wiki/CUDA" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> CUDA </strong> </a> API访问<strong class="kt ir"> GPU </strong>硬件。这使得我们能够在合理的时间内利用并行计算来训练我们的模型。</p><p id="7d1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">fastai的<code class="fe oy oz pa on b">fit_one_cycle</code>方法使用了Leslie Smith的<strong class="kt ir"> 1cycle policy </strong>，为我们提供了一种更快速的训练复杂模型的方法。你可以在这里了解更多关于这项政策的信息。</p><p id="6184" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将为<strong class="kt ir"> 10个时期</strong>训练我们的模型。一个“时期”是我们的学习算法在整个<em class="lo">训练数据集中工作的次数(训练数据中的每个例子都有机会更新模型参数)。</em></p><blockquote class="nr ns nt"><p id="a861" class="kr ks lo kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated">Epoch与<strong class="kt ir">批量</strong>不同，后者是模型更新前处理的样本数。</p></blockquote><p id="a219" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们通过调用fastai的<code class="fe oy oz pa on b">fit_one_cycle</code>方法，指定10个时期，开始只训练模型的最后一层<strong class="kt ir">:</strong></p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="7a16" class="mj ls iq on b gy or os l ot ou">defaults.device = torch.device('cuda')<br/>learn.fit_one_cycle(10)</span></pre><p id="de09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面显示了训练期间的前3个时期:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/4ce63a47625e5b359907b2a23d425adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Jhjq7HnvHkrpOh-3ulINEQ.gif"/></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">PyTorch的ResNet34深度学习模型的前3个<strong class="bd oc">时代</strong>(为清晰起见加速)。</p></figure><p id="03ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">全部训练大约需要<strong class="kt ir"> 40分钟</strong>。请记住，该培训将离线执行<em class="lo"/>，因此培训时间对我们的产品来说并不重要(而推理时间才是)。</p><p id="0d3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您的<strong class="kt ir">最终结果</strong>应该与此类似:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pw"><img src="../Images/7d014423841424f2008605fc3a8a357f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_4VLnNbkMv8Mve8NrtU7Q.png"/></div></div></figure><p id="7c72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的错误率相当低，这很好。对于使用默认超参数的冻结模型来说还不错。但是让我们看看我们是否能改进结果。</p><h2 id="b6fd" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">解冻模型</h2><p id="4161" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">现在我们将<strong class="kt ir">解冻</strong>网络，这意味着<em class="lo">我们的模型<em class="lo">中的所有权重</em>现在都可以更新</em>。我们可以在我们学习对象中调用fastai的unfreeze()方法:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="57c5" class="mj ls iq on b gy or os l ot ou">learn.unfreeze()</span></pre><p id="a1c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们已经“解冻”了我们的模型，所以在所有层上使用相同的学习速率不再有意义。深度模型中的不同层受益于所谓的“差异”学习率，其中根据它们在网络中的应用位置来使用不同的速率。要使用不同的学习率，我们首先需要找到一个合适的范围。</p><h2 id="aa7f" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">找到一个好的学习率范围</h2><p id="72f2" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">为了找到一个合适的学习率范围，我们将绘制模型的<strong class="kt ir">损失</strong>与增加的<strong class="kt ir">率</strong>的关系图。我们可以这样做，首先运行:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="f111" class="mj ls iq on b gy or os l ot ou">learn.lr_find()</span></pre><blockquote class="nr ns nt"><p id="f456" class="kr ks lo kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated"><em class="iq">我们试图观察和理解</em> <strong class="kt ir"> <em class="iq">线索</em> </strong> <em class="iq">这些线索有时会在训练中出现。通过这样做，我们可以通过其超参数潜在地</em> <strong class="kt ir"> <em class="iq">调整</em> </strong> <em class="iq">我们的架构，从而减少</em> <strong class="kt ir"> <em class="iq">所需的时期</em> </strong> <em class="iq">。这使我们能够</em> <strong class="kt ir"> <em class="iq">避免</em> </strong> <em class="iq">运行完整的</em>网格<em class="iq">和</em>随机搜索<em class="iq">以找到好的超参数。</em></p></blockquote><p id="b463" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以<strong class="kt ir">通过运行以下程序来绘制</strong>学习率与损失的关系图:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="57e4" class="mj ls iq on b gy or os l ot ou">learn.recorder.plot()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi px"><img src="../Images/b81d9a6d36c81fc7b1cc47107268dd87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j44nJhgd7M7-X1gOsddwZw.png"/></div></div></figure><p id="d894" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">典型的方法是在误差变得更糟之前，取正好低于最低点的值。我们将使用在<strong class="kt ir"> 3个10^–5和3个10^e-4 </strong>之间的<strong class="kt ir">范围</strong>。</p><h2 id="cb82" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">以D <strong class="ak">不同的学习率进行训练</strong></h2><p id="581e" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们现在将再次运行<code class="fe oy oz pa on b">fit_one_cycle</code>，使用<code class="fe oy oz pa on b">max_lr</code>参数来指定学习率的范围。让我们使用不同的学习速率跨4个时期训练我们的解冻模型:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="7d85" class="mj ls iq on b gy or os l ot ou">learn.fit_one_cycle(4, max_lr=slice(3e-5, 3e-4))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi py"><img src="../Images/1cab5191ed61bb3a97521b1014c134ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xR0WVK3tSreI60MEG9cbIA.png"/></div></div></figure><p id="f7aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，我们实现了更低的<strong class="kt ir">误差</strong>。当然，如果不首先检验预测的质量，这几乎毫无意义。</p><h2 id="2106" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">检查混淆矩阵</h2><p id="7f51" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">像往常一样，我们检查混淆矩阵(CM ),看看是否有任何关于<strong class="kt ir">错误分类</strong>的危险信号。我们的模型可能会遇到某些类型的缺陷。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/30d1eba27f94acf69803ebd5e3f967f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B83SPl1ryaua2-edyoyVbQ.png"/></div></div></figure><p id="6bb1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们看到大多数值位于CM的特征对角线上。看起来我们的模型在预测缺陷方面相当有效。我们将在我们的产品中使用这种模式。</p><h2 id="88f6" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">保存并导出训练好的模型以进行推理</h2><p id="c17f" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">现在我们已经有了一个具有合理精确度的训练模型，我们想要<strong class="kt ir">下载</strong>它作为一个对象，可以用于<em class="lo">推理</em>(对真实数据的预测)<em class="lo"> : </em></p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="e03c" class="mj ls iq on b gy or os l ot ou">learn.<strong class="on ir">save</strong>('defect_classifier')<br/>learn.<strong class="on ir">load</strong>('defect_classifier')<br/>learn.<strong class="on ir">export</strong>('defect_classifier.pkl')</span></pre><p id="eeee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">的。<strong class="kt ir"> pkl </strong>文件应该出现在<strong class="kt ir"> training_csvs文件夹</strong>中。<strong class="kt ir">下载</strong>这个:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/4000ce50c984955439a875d7ca19a47c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*GfOEGAiiSNJJNVMH8yNp3w.gif"/></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">正在下载<strong class="bd oc">。pkl </strong>文件</p></figure><p id="df3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大小大约是84MB 。</p><h2 id="3161" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">用保留的文件名创建JSON文件</h2><p id="b7e4" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">回想一下，在第1部分中，我们创建了<strong class="kt ir"> extracted_defects.json </strong>文件，并将它上传到Defect Turker进行标记。我们现在将为我们构建的实际应用程序创建一个文件名为第4部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><p id="643b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…并保存这个文件<strong class="kt ir"> test_temps.json </strong>:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="df25" class="mj ls iq on b gy or os l ot ou">with open('test_temps.json', 'w') as outfile:<br/>    json.dump(test_temps, outfile)</span></pre><p id="737f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">和<strong class="kt ir">下载</strong>文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/a69f95a16545a962cebf0f6dc6890c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*exrgNYk7IkiOKPlXjK-fLw.gif"/></div></figure><p id="e1b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，让我们<strong class="kt ir">压缩</strong>和<strong class="kt ir">下载</strong>用于PCB缺陷分类器的展示图像:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><p id="3fd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">..，而<strong class="kt ir">照常从</strong> <strong class="kt ir"> Colab </strong>下载 <strong class="kt ir">:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/e89d2ba5a7b22697702379129824357f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*aNGGcv_HfJv7HTAIc3dfhQ.gif"/></div></figure><p id="1f72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将在第4部分中使用这些文件。</p><p id="05db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在准备构建我们的PCB缺陷分类器应用程序。</p><h1 id="a904" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">第4部分:构建PCB缺陷分类器应用程序</h1><p id="dda0" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们已经达到了这个项目(以及任何真实项目)的最终目标，那就是为最终用户创建一个真正的应用程序。正如我在介绍中所说的，围绕我们的机器学习创造产品是唯一真正的测试，我们的工作是否有超越一群工程师的效用。</p><p id="c76f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还声明，为了保持这篇文章的合理篇幅，我不会涵盖所有的管道和前端编码。</p><h2 id="d12c" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">产品:PCB缺陷分类器</h2><p id="0107" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi pb translated">这是我们在本文中想要创建的主要应用程序。我们研究了这种产品对印刷电路板领域的最终用户有用的原因。让我们来看看制作这款产品所需的主要部件，构建后端和前端组件。</p><h2 id="3e37" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">用户流程和主要功能</h2><ul class=""><li id="3d53" class="mv mw iq kt b ku mx kx my la mz le na li nb lm nc nd ne nf bi translated">用户<strong class="kt ir">获取</strong>下一组PCB图像(测试和模板)；</li><li id="0187" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">用户<strong class="kt ir">检查</strong> PCB图像；</li><li id="24b0" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">用户<strong class="kt ir">运行</strong>差分/提取/预测流水线；</li><li id="8637" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">用户<strong class="kt ir">检查</strong>预测；</li><li id="8a78" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">用户<strong class="kt ir">查看</strong>记录的费用。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pz"><img src="../Images/34515a97f200fc1cae9657d9e1e524ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAKkhqteaD9s_dC8a9A1mw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qa"><img src="../Images/6ebf706b8fbb839740e66e5b7d042879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FBX0rJL-DDH1gHDRsUdcDg.png"/></div></div></figure><p id="82dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用户也可以根据其组织的制造情况设置<strong class="kt ir">缺陷成本</strong>。</p><h2 id="adbf" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">创建Web服务</h2><p id="71eb" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们将使用<strong class="kt ir"> Flask </strong>来创建一个轻量级的web服务。在Flask和Azle之间，在后端调用我们的Python函数将会很容易。有很多关于如何创建Flask web服务的教程，所以我不会在这里详述这些步骤。同样，所有代码都可以在GitHub上获得。</p><h2 id="cdc2" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">管道</h2><p id="9e0f" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们将使用Colab环境中使用的主要管道功能来创建产品管道的后端。</p><p id="a9cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从上面的数字中，我们知道我们需要:</p><ul class=""><li id="6a93" class="mv mw iq kt b ku kv kx ky la no le np li nq lm nc nd ne nf bi translated">图像差分</li><li id="7103" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">图像提取</li><li id="584e" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">缺陷预测</li></ul><p id="c194" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用<a class="ae ln" href="https://azlejs.com" rel="noopener ugc nofollow" target="_blank"> Azle </a>来调用<code class="fe oy oz pa on b">classifier.py</code>、<code class="fe oy oz pa on b">image_differencing.py</code>和<code class="fe oy oz pa on b">utility.py</code>中包含的函数(通过<code class="fe oy oz pa on b">app.py</code>)。</p><p id="bb7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是需要的<strong class="kt ir">主要</strong> <strong class="kt ir">功能:</strong></p><p id="3a29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">图像差分</strong>:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="0924" class="mj ls iq on b gy or os l ot ou"><strong class="on ir">subtract_images</strong>(**{<br/>    "image_path_1": image_path_1,<br/>    "image_path_2": image_path_2,<br/>    "write_path": "diff_img/diff_" + id + ".png"<br/>})</span></pre><p id="1966" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">缺陷提取</strong>:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="c172" class="mj ls iq on b gy or os l ot ou"><strong class="on ir">extract_contours_from_image</strong>(**{<br/>    "image_path": path_to_diff,<br/>    "write_path": "contours/" + id + "/",<br/>    "hsv_lower": [0, 150, 50],<br/>    "hsv_upper": [10, 255, 255]<br/>})</span></pre><p id="4270" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">缺陷预测</strong>:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="cf2b" class="mj ls iq on b gy or os l ot ou"><strong class="on ir">def classifier</strong>(image_path):<br/>    learn = load_learner('model')<br/>    img = open_image(image_path)<br/>    prediction = learn.predict(img)<br/>    return(str(prediction))<br/><br/><strong class="on ir">def predict</strong>(image_path):<br/>    prediction = classifier(image_path)<br/>    return(prediction)</span></pre><p id="6967" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">前两个是我们在Colab环境中用于处理测试和模板图像的相同的<strong class="kt ir"> tetryonai </strong>函数。</p><p id="9dca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将创建一个名为api的目录，保存主Flask文件(<code class="fe oy oz pa on b">app.py</code>)和与我们的管道相关的文件:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="3fb8" class="mj ls iq on b gy or os l ot ou"><strong class="on ir">api<br/></strong>└── app.py<br/>└── classifier.py<br/>└── image_differencing.py<br/>└── utility.py</span></pre><p id="d69e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oy oz pa on b">utility.py</code>内的实用函数只是帮助应用运行所需的一些基本操作。</p><h2 id="9fb7" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">UI元素</h2><p id="7968" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">在Azle中创建应用程序支持快速原型开发。这里是主要部分:</p><p id="6578" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">添加</strong> <strong class="kt ir">按钮</strong>:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="53ae" class="mj ls iq on b gy or os l ot ou">az.<strong class="on ir">add_button</strong>("target_class", target_instance, {<br/>    "this_class": "my_button",<br/>    "text": "FETCH BOARDS"<br/>})</span></pre><p id="b349" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">显示</strong>画面<strong class="kt ir">画面</strong>:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="0280" class="mj ls iq on b gy or os l ot ou">az.<strong class="on ir">add_image</strong>("target_class", target_instance, {<br/>    "this_class": "my_image",<br/>    "image_path": "https://bit.ly/1L574po"<br/>})</span></pre><p id="b5bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">调用</strong><strong class="kt ir">API</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox lq l"/></div></figure><p id="7bbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">滑块</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/673438579c9911d81d50e8c2c9713c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*SfclTx2I8fUBZPpVeoGD6g.gif"/></div></figure><h2 id="2244" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">获取应用程序</h2><p id="8786" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">通过在终端中运行以下命令，从GitHub克隆应用程序:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="73ab" class="mj ls iq on b gy or os l ot ou">git clone <a class="ae ln" href="https://github.com/sean-mcclure/defect_classifier.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sean-mcclure/defect_classifier.git</a></span></pre><p id="d3ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要添加以下文件:</p><ul class=""><li id="1142" class="mv mw iq kt b ku kv kx ky la no le np li nq lm nc nd ne nf bi translated">新的PCB板<strong class="kt ir">图像</strong>在模型训练期间没有使用；</li><li id="c68c" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">包含所有新板名的JSON文件；</li><li id="398d" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">经过训练的PCB缺陷分类器<strong class="kt ir">型号</strong>。</li></ul><h2 id="7c45" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">将图像文件添加到缺陷分类器应用程序</h2><p id="fe20" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">回想一下在第3部分中，我们创建并下载了文件<strong class="kt ir"> test_temps.json </strong>和<strong class="kt ir"> hold_out.zip </strong>。将这些文件放在你的桌面上(如果还没有的话),然后<strong class="kt ir">解压</strong>hold _ out . zip文件夹。</p><p id="5e03" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以<strong class="kt ir">添加</strong>所有的保留图像到我们的应用程序中，方法是将它们移动到<strong class="kt ir"> test_temps </strong>文件夹中。从克隆的应用程序内部(假设应用程序被克隆到桌面):</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="5a48" class="mj ls iq on b gy or os l ot ou">mv ../Desktop/hold_out/* test_temps/</span></pre><p id="9e23" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…以及<strong class="kt ir"> test_temps.json </strong>文件:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="0074" class="mj ls iq on b gy or os l ot ou">mv ../Desktop/test_temps.json test_temps/</span></pre><p id="8df9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="b415" class="mj ls iq on b gy or os l ot ou"><strong class="on ir">test_temps<br/>    </strong>└── 000410009_temp.jpg<br/>    └── 000410009_test.jpg<br/>    └── 00041012_temp.jpg<br/>    └── 00041012_test.jpg<br/>    ...<br/>    └── test_temps.json</span></pre><p id="74e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的应用程序现在可以访问我们在PCB板制造场景中预期的图像。</p><h2 id="5e55" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">将模型添加到应用程序</h2><p id="bb5a" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">在第3部分，我们保存了。<strong class="kt ir"> pkl </strong>文件。这是我们训练过的缺陷分类器模型。让我们将它添加到应用程序的<strong class="kt ir">模型文件夹</strong>中:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="55b6" class="mj ls iq on b gy or os l ot ou">mv ../Desktop/<strong class="on ir">defect_classifier.pkl</strong> model/</span></pre><p id="b5d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要<strong class="kt ir">重命名</strong>我们的模型对象，因为fastai的<code class="fe oy oz pa on b">load_learner</code>方法期望该对象被称为“export.pkl”:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="9a5b" class="mj ls iq on b gy or os l ot ou">mv model/defect_classifier.pkl model/<strong class="on ir">export.pkl</strong></span></pre><p id="5227" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看看我们的PCB缺陷分类器是如何工作的！</p><h1 id="79b3" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">第5部分:运行/测试应用程序</h1><h2 id="32a5" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">启动服务</h2><p id="6843" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们在Flask中构建了web服务。我们像往常一样称之为:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="3c1c" class="mj ls iq on b gy or os l ot ou">python api/app.py</span></pre><p id="590c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您应该在您的<strong class="kt ir">终端</strong>中看到以下内容:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="f700" class="mj ls iq on b gy or os l ot ou">* Serving Flask app "app" (lazy loading)<br/>* Environment: production<br/>   WARNING: This is a development server.<br/> * Debug mode: on<br/> * Running on <a class="ae ln" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/</a> (Press CTRL+C to quit)<br/> * Restarting with stat<br/> * Debugger is active!<br/> * Debugger PIN: 622-284-701</span></pre><p id="65bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以看到我们正在调试器模式下运行。这是理想的，因为我们对Python所做的任何更改都会导致服务自动重启。这对<em class="lo">原型</em>非常有利。</p><p id="10de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们需要<strong class="kt ir">启动一个web服务</strong>来显示应用程序的前端。在您的终端中运行以下命令:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="e237" class="mj ls iq on b gy or os l ot ou">python3 -m http.server</span></pre><p id="a750" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后<strong class="kt ir">打开您的浏览器</strong>以:</p><pre class="kg kh ki kj gt om on oo op aw oq bi"><span id="5a75" class="mj ls iq on b gy or os l ot ou"><a class="ae ln" href="http://localhost:8000/app/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/app/</a></span></pre><p id="6da1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的第一个屏幕如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qb"><img src="../Images/4d88cdfc0ae2b4825b7a54fda14c7abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8V489xka6s_K-6aW7mpVYg.png"/></div></div></figure><p id="12e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用户的第一步是运行<strong class="kt ir">获取电路板</strong>，这将引入存储在test_temps中的PCB图像(我们的保持图像)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/7e51afb609ae34c1efa60c4ad987aaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*RjsqDJFokhA4DuCoDSiQeA.gif"/></div></figure><p id="2f0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将获取测试图像和模板图像。制造商需要对这些PCB板进行测试，以确定是否存在任何缺陷。</p><h2 id="e53a" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">运行管道</h2><p id="8019" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">现在，用户运行管道，这将:</p><ul class=""><li id="c751" class="mv mw iq kt b ku kv kx ky la no le np li nq lm nc nd ne nf bi translated"><strong class="kt ir">减去</strong>图像以创建差分图像；</li><li id="8049" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">提取</strong>差分图像中包含的缺陷；</li><li id="1b19" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><strong class="kt ir">预测</strong>每个提取缺陷的缺陷类别；</li><li id="1239" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">将<strong class="kt ir"> </strong>预测<strong class="kt ir">成本</strong>添加到成本汇总中。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/e81ea3cb27978765f7c19fa8339e86df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*wncSzAfSEmcylZBSh0bACg.gif"/></div></figure><p id="3136" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们在开始时看到的更完整的视频，展示了我们如何针对我们的管道进行多次运行，每次都能获得准确的预测:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="37b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">太美了。我们可以看到，差异和缺陷提取几乎是瞬间完成的。对于每个提取的缺陷，预测被设置为1000毫秒，这对于我们的演示来说似乎是合理的。这对PCB制造商来说够快了吗？</p><p id="7573" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi pb translated"><span class="l pc pl bm di qc"> <img alt="F" class="kp pn po pp pq pr fc n ie dh bf" src="../Images/40866dd90001ceddcfaaefa4de0bde15.png" width="79" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:158/1*mpotCd6VE2rQiuuILRqbOw.png"/> <span class="l pc pd pe bm pf pg ph pi pj di pk"> F </span> </span> <strong class="kt ir">特色创意</strong>:可以向用户呈现一个滑块来设置预测时间。基于制造吞吐量，设置一个更低的预测时间可能是有意义的。当然，这必须与我们预先训练好的模型(推理时间)做出预测的速度相平衡。建立一个显示最佳推理时间的图表是一个很好的实验，可以运行并展示给客户。</p><h1 id="df9d" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">提高</h1><p id="35fb" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">我们可以做很多事情来改进我们的产品。虽然模型的准确性已经很好了，但是我们没有尝试其他的缺陷类型。在这些缺陷上模型性能会一样好吗？如果这个产品需要以高得多的速度预测呢？牺牲一些来之不易的准确性，使用运行更快推理的浅层网络值得吗？</p><p id="50c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是我们可以尝试的一些事情:</p><ul class=""><li id="d3f3" class="mv mw iq kt b ku kv kx ky la no le np li nq lm nc nd ne nf bi translated">数据扩充</li><li id="0fa2" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">其他超参数设置</li><li id="cd0b" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">更多数据</li><li id="3f85" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">不同的架构</li></ul><p id="a190" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过不同的/额外的产品功能，我们还可以构建各种用户体验。让用户选择将糟糕的预测标记为不正确是否有意义(将此信息反馈给模型)。除了成本之外，计算关于预测缺陷的额外信息怎么样？也许是创造有趣的可视化总结。通过拥抱快速原型，我们不需要预先知道这些问题的答案；我们可以用真正的产品来构建、展示和按需改变。</p><h1 id="26a1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">摘要</h1><p id="4032" class="pw-post-body-paragraph kr ks iq kt b ku mx jr kw kx my ju kz la nl lc ld le nm lg lh li nn lk ll lm ij bi translated">在本文中，我们创建了一个端到端的PCB缺陷分类器应用程序。我们使用图像处理来区分测试和模板PCB图像集，使用轮廓提取缺陷，并使用深度学习对提取的缺陷进行分类。然后，我们创建了一个前端应用程序，允许用户运行我们的机器学习管道并查看模型预测。</p><p id="01b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">像这样的应用程序有助于自动执行手动、耗时且容易出现人为错误的任务。目的不是取代人类专家，而是增加他们的努力，以便他们可以专注于工作中更具战略性和创造性的方面。</p><p id="d488" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您有任何问题/需要支持，请使用评论部分。我可以帮助其他人<strong class="kt ir">为他们的特定目的修改这些应用</strong>。<strong class="kt ir"> Azle </strong>问题可以上<a class="ae ln" href="https://stackoverflow.com/questions/ask?tags=azle+javascript" rel="noopener ugc nofollow" target="_blank">问<strong class="kt ir">栈溢出</strong>问</a>。</p><h2 id="faa9" class="mj ls iq bd lt mk ml dn lx mm mn dp mb la mo mp md le mq mr mf li ms mt mh mu bi translated">您可能还喜欢:</h2><div class="qd qe gp gr qf qg"><a rel="noopener follow" target="_blank" href="/learn-to-build-machine-learning-services-prototype-real-applications-and-deploy-your-work-to-aa97b2b09e0c"><div class="qh ab fo"><div class="qi ab qj cl cj qk"><h2 class="bd ir gy z fp ql fr fs qm fu fw ip bi translated">学习建立机器学习服务，原型真实的应用程序，并部署您的工作…</h2><div class="qn l"><h3 class="bd b gy z fp ql fr fs qm fu fw dk translated">在这篇文章中，我将向读者展示如何将他们的机器学习模型公开为RESTful web服务，原型真实…</h3></div><div class="qo l"><p class="bd b dl z fp ql fr fs qm fu fw dk translated">towardsdatascience.com</p></div></div><div class="qp l"><div class="qq l qr qs qt qp qu kp qg"/></div></div></a></div><div class="qd qe gp gr qf qg"><a rel="noopener follow" target="_blank" href="/step-by-step-guide-to-creating-r-and-python-libraries-e81bbea87911"><div class="qh ab fo"><div class="qi ab qj cl cj qk"><h2 class="bd ir gy z fp ql fr fs qm fu fw ip bi translated">创建R和Python库的分步指南(在JupyterLab中)</h2><div class="qn l"><h3 class="bd b gy z fp ql fr fs qm fu fw dk translated">r和Python是当今机器学习语言的支柱。r提供了强大的统计数据和快速…</h3></div><div class="qo l"><p class="bd b dl z fp ql fr fs qm fu fw dk translated">towardsdatascience.com</p></div></div><div class="qp l"><div class="qv l qr qs qt qp qu kp qg"/></div></div></a></div><div class="qd qe gp gr qf qg"><a rel="noopener follow" target="_blank" href="/gui-fying-the-machine-learning-workflow-towards-rapid-discovery-of-viable-pipelines-cab2552c909f"><div class="qh ab fo"><div class="qi ab qj cl cj qk"><h2 class="bd ir gy z fp ql fr fs qm fu fw ip bi translated">机器学习工作流的GUI化:快速发现可行的流水线</h2><div class="qn l"><h3 class="bd b gy z fp ql fr fs qm fu fw dk translated">前言</h3></div><div class="qo l"><p class="bd b dl z fp ql fr fs qm fu fw dk translated">towardsdatascience.com</p></div></div><div class="qp l"><div class="qw l qr qs qt qp qu kp qg"/></div></div></a></div><div class="qd qe gp gr qf qg"><a rel="noopener follow" target="_blank" href="/creating-web-applications-with-d3-observable-d5c53467ff12"><div class="qh ab fo"><div class="qi ab qj cl cj qk"><h2 class="bd ir gy z fp ql fr fs qm fu fw ip bi translated">用D3 Observable创建Web应用程序</h2><div class="qn l"><h3 class="bd b gy z fp ql fr fs qm fu fw dk translated">什么是D3可观测？</h3></div><div class="qo l"><p class="bd b dl z fp ql fr fs qm fu fw dk translated">towardsdatascience.com</p></div></div><div class="qp l"><div class="qx l qr qs qt qp qu kp qg"/></div></div></a></div><div class="qd qe gp gr qf qg"><a rel="noopener follow" target="_blank" href="/combining-d3-with-kedion-graduating-from-toy-visuals-to-real-applications-92bf7c3cc713"><div class="qh ab fo"><div class="qi ab qj cl cj qk"><h2 class="bd ir gy z fp ql fr fs qm fu fw ip bi translated">用D3.js从玩具视觉过渡到真实应用</h2><div class="qn l"><h3 class="bd b gy z fp ql fr fs qm fu fw dk translated">我们经常孤立地学习技术和方法，与数据科学的真正目标脱节；至…</h3></div><div class="qo l"><p class="bd b dl z fp ql fr fs qm fu fw dk translated">towardsdatascience.com</p></div></div><div class="qp l"><div class="qy l qr qs qt qp qu kp qg"/></div></div></a></div><h1 id="8a29" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">笔记</h1><ol class=""><li id="7568" class="mv mw iq kt b ku mx kx my la mz le na li nb lm of nd ne nf bi translated">你会注意到我们只得到3种缺陷类型。这是因为差异的工作方式。它只挑选黑色差异的缺陷。其他缺陷，如老鼠咬，等等。需要进行白色差分。这可以通过简单地<strong class="kt ir">改变差分函数中图像路径的顺序</strong>来实现。因此，如果您想要检测、提取和预测<em class="lo">所有的</em>缺陷，那么运行两个版本。</li><li id="0424" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm of nd ne nf bi translated">如果您想删除轮廓中的文件夹，请在终端中运行<code class="fe oy oz pa on b"> rm -r contours/*</code>。如果你想删除diff_img中的所有图像，运行<code class="fe oy oz pa on b">rm diff_img/*</code>。</li></ol><h1 id="fc60" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">参考</h1><ol class=""><li id="6d85" class="mv mw iq kt b ku mx kx my la mz le na li nb lm of nd ne nf bi translated"><a class="ae ln" href="http://www.iconnect007.com/index.php/article/92973/world-pcb-production-in-2014-estimated-at-602b/92976/?skin=pcb" rel="noopener ugc nofollow" target="_blank">2014年全球PCB产量估计为602亿美元</a></li><li id="a241" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm of nd ne nf bi translated"><a class="ae ln" href="https://arxiv.org/pdf/1901.08204.pdf" rel="noopener ugc nofollow" target="_blank">用于缺陷检测和分类的PCB数据集</a></li><li id="2596" class="mv mw iq kt b ku ng kx nh la ni le nj li nk lm of nd ne nf bi translated"><a class="ae ln" href="https://github.com/tangsanli5201/DeepPCB" rel="noopener ugc nofollow" target="_blank">GitHub上的唐三里5201/deep PCB</a></li></ol></div></div>    
</body>
</html>