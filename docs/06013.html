<html>
<head>
<title>CNN Approach for Predicting Movie Genre from Posters!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从海报预测电影类型的 CNN 方法！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cnn-approach-for-predicting-movie-genre-from-posters-95f122f88bc2?source=collection_archive---------35-----------------------#2020-05-16">https://towardsdatascience.com/cnn-approach-for-predicting-movie-genre-from-posters-95f122f88bc2?source=collection_archive---------35-----------------------#2020-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="94a4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">深度学习</h2><div class=""/><div class=""><h2 id="e0e3" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">卷积神经网络是一类深度神经网络，用于图像或视频识别和分类任务。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/85f50fb15ec10931a25fa412b738f86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ODjuaS5Z8dqSApgTm9Fs5g.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://pixabay.com/users/Sky_Mane-8294708/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3706529" rel="noopener ugc nofollow" target="_blank">天鬃</a>发自<a class="ae lh" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3706529" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="bb6b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们能建立一个模型来了解是什么让一种类型的电影海报与其他类型的不同吗？电影海报描绘了关于这部电影的许多事情。它对激发观众对电影的兴趣起着至关重要的作用。在上面的例子中，颜色主要是红色和黑色，因此在训练时，我们的模型可以学习将这种类型的图像分类为“恐怖”或“惊悚”。这将是一项有趣的任务。当你看不同类型的海报时，你会注意到它们在某些方面是不同的。比如看下面的海报。<em class="me">本文使用的所有电影海报图片均收集自</em> <a class="ae lh" href="https://www.imdb.com" rel="noopener ugc nofollow" target="_blank"> <em class="me"> IMDB </em> </a> <em class="me">。</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/a331d2c6fa4fc9eda020c4230d28507b.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*SzpE8ENTl83G6tpTJZMfgQ.jpeg"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://www.imdb.com/title/tt1723121/mediaviewer/rm1869129472" rel="noopener ugc nofollow" target="_blank">我们是米勒夫妇(2013) </a></p></figure><p id="65d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它代表了一部喜剧电影。现在看看下面的动作片海报。我们可以看到海报代表了电影类型的一个重要方面。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/9faf9deee6c1f5cb86dc6ab5a664d163.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*Fxg7_KwTnRwJS6nv0lBfNA.jpeg"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://www.imdb.com/title/tt0830515/" rel="noopener ugc nofollow" target="_blank">量子的慰藉(2008) </a></p></figure><p id="cde9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个项目中，我们将建立一个神经模型，可以区分三种电影类型的海报，并预测任何随机海报的类型。我们将从零开始一步一步建立这个模型！本项目使用的数据集是在<a class="ae lh" href="https://www.imdb.com" rel="noopener ugc nofollow" target="_blank"> IMDB </a>的帮助下自行创建的。它包含超过 3900 张各种类型的海报图片——动作片、喜剧片、戏剧片。</p><p id="f60e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们进入编码部分。</p><h1 id="e66a" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">1.使用数据集</h1><p id="b32d" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">我们的数据集结构如下所示。我们将训练图像和测试图像保存在不同的目录中。每个目录包含三个子目录——动作、喜剧和戏剧。这些子目录进一步包含我们的电影海报的图像。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/6021734a53a6677008c03175f9af327a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-s5dPCNum0i4vw0NKUm7Xw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数据集的目录组织</p></figure><p id="67da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将使用 ImageDataGenerator 进行标记。来自<em class="me"> Keras API </em>的 ImageDataGenerator 通过自动标记数据来帮助我们。在代码中实现数据扩充时，这也很有用。让我们看看这是如何在编码中实现的。</p><pre class="ks kt ku kv gt ne nf ng nh aw ni bi"><span id="9c46" class="nj mh it nf b gy nk nl l nm nn">import tensorflow as tf<br/>import keras_preprocessing<br/>from keras_preprocessing import image<br/>from keras_preprocessing.image import ImageDataGenerator</span><span id="8fd0" class="nj mh it nf b gy no nl l nm nn">TRAINING_DIR = "/images2/Training"</span><span id="1d46" class="nj mh it nf b gy no nl l nm nn">training_datagen = ImageDataGenerator(rescale = 1./255,<br/>    width_shift_range=0.2,<br/>    height_shift_range=0.2,<br/>    zoom_range=0.2,<br/>    horizontal_flip=True,<br/>    fill_mode='nearest')</span><span id="7331" class="nj mh it nf b gy no nl l nm nn">VALIDATION_DIR = "/images2/Validation"</span><span id="fe65" class="nj mh it nf b gy no nl l nm nn">validation_datagen = ImageDataGenerator(rescale = 1./255)</span><span id="d9b6" class="nj mh it nf b gy no nl l nm nn">train_generator = training_datagen.flow_from_directory(<br/>    TRAINING_DIR,<br/>    target_size=(150,150),<br/>    class_mode='categorical',<br/>    batch_size = 256<br/>)</span><span id="4501" class="nj mh it nf b gy no nl l nm nn">validation_generator = validation_datagen.flow_from_directory(<br/>    VALIDATION_DIR,<br/>    target_size=(150,150),<br/>    class_mode='categorical',<br/>    batch_size= 64<br/>)</span></pre><p id="5385" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将首先创建一个 ImageDataGenerator 实例，用于训练和验证目的。由于像素值的范围是从 0 到 255，我们将在 0 到 1 的范围内对它们进行归一化。为此，我们将传入参数(<em class="me"> rescale = 1)。/255) </em>创建 ImageDataGenerator 的实例时。在这之后，我们将使用<em class="me">。实例的 flow_from_directory() </em>方法来标记两个目录的图像，并将结果存储在<em class="me"> train_generator </em>和<em class="me"> validation_generator </em>中，用于训练和验证目的。调用该方法时，我们将传入<em class="me"> target_size </em>属性，以确保数据集中的图像大小相同。这里我们有 3 个类，所以我们必须传入<em class="me"> class_mode </em>参数作为<em class="me">分类。</em>训练和验证的批量大小取决于我们数据集中的图像数量。</p><p id="26ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将数据分为三类——动作片、喜剧片和剧情片。现在我们可以继续创建我们的 CNN 模型。</p><h1 id="f0ff" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">2.创建 CNN 模型</h1><p id="e6e5" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">我们将使用 Keras 的序列模型来构建我们的模型。我们将添加 3 对 Conv2D 和 MaxPooling2D 层。然后我们将添加扁平化层，使我们有我们的数据在一个维度。最后，我们将添加一个具有 1024 个隐藏单元的完全连接的密集层，后跟一个 softmax 层。下面是实现这一点的代码。</p><pre class="ks kt ku kv gt ne nf ng nh aw ni bi"><span id="af49" class="nj mh it nf b gy nk nl l nm nn">from tensorflow.keras.optimizers import RMSprop</span><span id="f1b3" class="nj mh it nf b gy no nl l nm nn">model = tf.keras.models.Sequential([<br/>    tf.keras.layers.Conv2D(16, (3,3), activation='relu', input_shape=(150, 150, 3)),<br/>    tf.keras.layers.MaxPooling2D(2,2),<br/>    tf.keras.layers.Conv2D(32, (3,3), activation='relu'),<br/>    tf.keras.layers.MaxPooling2D(2,2),<br/>    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),<br/>    tf.keras.layers.MaxPooling2D(2,2),<br/>    tf.keras.layers.Flatten(),<br/>    tf.keras.layers.Dense(1024, activation='relu'),<br/>    tf.keras.layers.Dense(3, activation='softmax')<br/>])</span><span id="a770" class="nj mh it nf b gy no nl l nm nn">model.compile(loss='categorical_crossentropy',<br/>    optimizer=RMSprop(lr=0.001),<br/>    metrics=['acc'])</span></pre><p id="2110" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">创建模型后，我们将在编译模型时使用 RMSprop 优化器，它允许我们根据需要调整学习速率。这里，学习率是在用模型进行多次测试之后选择的。我们需要传递<em class="me">分类交叉熵</em>作为我们的损失函数，因为我们有两个以上的类。</p><p id="69c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的模型可以开始训练了。让我们用之前标注的数据来训练它。</p><h1 id="921e" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">3.训练模型</h1><p id="ba15" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">我们将传入我们之前创建的带有正确值的<em class="me"> train_generator </em>和<em class="me"> validation_generator </em>变量。</p><pre class="ks kt ku kv gt ne nf ng nh aw ni bi"><span id="2d01" class="nj mh it nf b gy nk nl l nm nn">history = model.fit(<br/>    train_generator,<br/>    steps_per_epoch = 36,<br/>    epochs = 100,<br/>    validation_data = validation_generator,<br/>    validation_steps = 36<br/>)</span></pre><p id="5898" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 100 个时期之后，我们的模型给出了 69.8%的训练准确度，而验证准确度仍然是 53.3%。下面是为两个准确性指标绘制的图表。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi np"><img src="../Images/5f4322a9c9d59c5011bdf20d183fbec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*taI-8Y819RbqYoYSO0dchw.png"/></div></figure><p id="db64" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们可以看到的，最高验证精度约为 0.53，训练精度约为 0.70。现在让我们在一些图像上尝试我们的模型。</p><h1 id="90c7" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">4.测试我们的模型</h1><p id="10f6" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">我们将使用 Google Colab 的内置库来上传图像，然后我们将它们传递给我们的模型，看看是否可以获得正确的类型。</p><pre class="ks kt ku kv gt ne nf ng nh aw ni bi"><span id="1668" class="nj mh it nf b gy nk nl l nm nn"># predicting for random images<br/>import numpy as np<br/>from google.colab import files<br/>from keras.preprocessing import image</span><span id="e5b7" class="nj mh it nf b gy no nl l nm nn">uploaded = files.upload()</span><span id="3740" class="nj mh it nf b gy no nl l nm nn">for fn in uploaded.keys():<br/>    path = '/content/' + fn<br/>    img = image.load_img(path, target_size=(150, 150))<br/>    x = image.img_to_array(img)<br/>    x = np.expand_dims(x, axis=0)<br/>    images = np.vstack([x])<br/>    classes = model.predict(images, batch_size=256)<br/>    print(classes)</span></pre><p id="8b67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将传递三种不同类型的电影海报—动作片、喜剧片和剧情片。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/6c8ed6e8811ea21b2506e6c160a0992b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*MppOF-OER98xVkPGZL-p2Q.png"/></div></figure><p id="3180" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面代码的输出如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/a45f81afba2b98ce9f581d13cffe4150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/1*QL0jIkebEv6ZLVFn3A_81g.gif"/></div></figure><p id="8b4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们正在对这三种情况进行正确分类，但这不会每次都发生。请记住，我们的验证准确率仍然在 53%左右，所以在一半的情况下，我们的预测可能会出错。</p><p id="b375" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在 GitHub 的这里找到所有的代码<a class="ae lh" href="https://github.com/jackfrost1411/Genre-prediction-from-posters" rel="noopener ugc nofollow" target="_blank">，在 LinkedIn 的这里</a>找到我<a class="ae lh" href="https://www.linkedin.com/in/dhruvilshah28/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="0ad2" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">未来的范围和限制</h1><p id="5f54" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">这里使用了非常小的数据集，因此精度较低。在未来，一个更大的数据集可能被用来提高准确性，甚至预测同一部电影的多个流派。这里，该模型仅预测 3 种类型的流派，但在未来，可以使用 ResNet 建立一个更复杂的模型，预测超过 10 或 20 种类型的流派。机器学习算法 K-最近邻也可以用于此目的。</p><h1 id="05d6" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">结论</h1><p id="eb63" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">上面我们看到了如何建立一个模型，从海报中预测电影类型。还有一些海报会很难归类。比如下面这个。下面展示的海报是一部剧情片。我们可以看到它只包含文本。因此，我们的模型很难预测正确的类型。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/26bc16cba66e9d00bb3c8ea9d3c302c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*ORHKmM89Lc5En3S2BC52KQ.jpeg"/></div></figure><p id="4c30" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类型预测领域还没有被完全探索。使用 CNN 进行图像识别任务可以证明对于从电影海报的图像中预测类型是有用的。CNN 可能会发现喜剧电影海报与动作电影海报的不同之处。</p></div></div>    
</body>
</html>