<html>
<head>
<title>Docker + TensorFlow + Google Cloud Platform = Love</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker + TensorFlow + Google 云平台=爱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/docker-tensorflow-google-cloud-platform-love-87c026f08cc7?source=collection_archive---------44-----------------------#2020-04-13">https://towardsdatascience.com/docker-tensorflow-google-cloud-platform-love-87c026f08cc7?source=collection_archive---------44-----------------------#2020-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8956" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">记录你的张量流，让你的生活更轻松</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/86dcd5b1609afa1ded9bcc4360017d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H-l9PgB0Q6hcxYgG.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe kv kw kx ky b">Docker, TensorFlow and Google Cloud Platform logos. Heart by Bohdan Burmich from the Noun Project.</code></p></figure><p id="f78a" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">Docker 改变了我的工程生活。我已经学会爱那条鲸鱼了！</p><p id="2b4e" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">几年前，当我第一次在 Windows 笔记本电脑上安装支持 GPU 的 TensorFlow 时，我对这个过程的复杂和脆弱感到震惊。当我在笔记本电脑上启动双引导 Ubuntu 时，我不得不重复这个可怕的过程。当我的桌面有了 GPU 后，我不得不重温过去的创伤。</p><blockquote class="lv"><p id="5500" class="lw lx iq bd ly lz ma mb mc md me lu dk translated"><em class="mf">如果有一种与操作系统无关的运行 TensorFlow 的方式，可以让您在几分钟内启动并运行，那会怎么样？</em></p></blockquote><p id="f81c" class="pw-post-body-paragraph kz la iq lb b lc mg jr le lf mh ju lh li mi lk ll lm mj lo lp lq mk ls lt lu ij bi translated">这是本帖的重点！我们将使用一个<code class="fe kv kw kx ky b">Google Cloud Platform (GCP)</code>计算引擎虚拟机作为我们的机器。但是你可以很容易地用你自己的带有<code class="fe kv kw kx ky b">NVIDIA GPU</code>的笔记本电脑/台式机替换这个虚拟机。</p><p id="e314" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="lb ir">注意:我将假设您已经安装了</strong> <code class="fe kv kw kx ky b"><strong class="lb ir">GCP account</strong></code> <strong class="lb ir">和</strong> <code class="fe kv kw kx ky b"><strong class="lb ir">GCP SDK</strong></code> <strong class="lb ir">，这样您就可以从您的终端运行 GCP 命令。</strong></p><h1 id="a3e2" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">我们将访问的主题</h1><p id="1b04" class="pw-post-body-paragraph kz la iq lb b lc nd jr le lf ne ju lh li nf lk ll lm ng lo lp lq nh ls lt lu ij bi translated">以下是本文将涉及的主题的概述:</p><ul class=""><li id="8269" class="ni nj iq lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><code class="fe kv kw kx ky b">GPU quotas</code>在 GCP</li><li id="8a97" class="ni nj iq lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">GCP 计算引擎<code class="fe kv kw kx ky b">VM startup scripts</code></li><li id="a038" class="ni nj iq lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">我们支持 GPU 的<code class="fe kv kw kx ky b">TensorFlow Dockerfile</code></li><li id="c050" class="ni nj iq lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">GCP <code class="fe kv kw kx ky b">Cloud Build</code>在云中构建我们的 Docker 映像</li><li id="1f8b" class="ni nj iq lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">GCP，GCP 的码头中心</li><li id="1e70" class="ni nj iq lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">测试我们是否可以从 Docker 容器中访问我们的 GPU</li></ul><p id="d064" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们开始吧！</p><h1 id="492f" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">你有 GPU 配额吗？</h1><p id="d0ea" class="pw-post-body-paragraph kz la iq lb b lc nd jr le lf ne ju lh li nf lk ll lm ng lo lp lq nh ls lt lu ij bi translated">当你第一次在 GCP 开始时，你不会被分配一个 GPU 来玩。如果你试图让一个虚拟机的 GPU 配额不足，你会得到一个错误，告诉你你的配额已经超过。所以让我们现在就解决这个问题。</p><p id="62dd" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">转到<code class="fe kv kw kx ky b">IAM &amp; Admin -&gt; Quotas</code>。</p><p id="2a5c" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在<code class="fe kv kw kx ky b">Metrics</code>下拉列表中，首先点击<code class="fe kv kw kx ky b">None</code>。</p><p id="4410" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在文本框中搜索<code class="fe kv kw kx ky b">GPUs (all regions)</code>并点击出现的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/8b101f041d23b901a8555453ae9b0457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vm-gqN9XnTVM_93X.jpg"/></div></div></figure><p id="2473" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">勾选下面列表中的方框，然后点击<code class="fe kv kw kx ky b">EDIT QUOTAS</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/62db4dc55677f6da66c3ade8b725dd1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/0*1ZKpoPCztsLGvTYG.jpg"/></div></div></figure><p id="c13e" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">填写屏幕右侧出现的表格，并请求至少一个 GPU:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/fd1ca3b2693322ac0563f7b93c05c93f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mkOvIEqbHHcyhcVu.jpg"/></div></div></figure><p id="4274" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在我们等待我们的批准。这应该很快——我不到两分钟就被批准了！</p><h1 id="9c39" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">构建虚拟机</h1><p id="05ac" class="pw-post-body-paragraph kz la iq lb b lc nd jr le lf ne ju lh li nf lk ll lm ng lo lp lq nh ls lt lu ij bi translated">一旦我们增加了配额，我们就可以开始构建至少有一个 GPU 的虚拟机。为了做到这一点，我们可以进入 UI 中的<code class="fe kv kw kx ky b">Compute Engine</code>，或者我们可以学习如何使用 GCP 的<code class="fe kv kw kx ky b">Cloud SDK</code>。还是做后者吧！</p><p id="64c1" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">假设我们想在名为<code class="fe kv kw kx ky b">deep-docker</code>的区域<code class="fe kv kw kx ky b">us-west-1b</code>中创建一个虚拟机。假设我们已经安装了 Cloud SDK，我们可以在终端中发出这个命令:</p><pre class="kg kh ki kj gt nz ky oa ob aw oc bi"><span id="8cd2" class="od mm iq ky b gy oe of l og oh">gcloud compute instances create deep-docker \<br/>	--zone=us-west1-b \<br/>	--accelerator="type=nvidia-tesla-k80,count=1" \<br/>	--image-family "ubuntu-1804-lts" \<br/>	--image-project "ubuntu-os-cloud" \<br/>	--boot-disk-device-name="persistent-disk" \<br/>	--boot-disk-size=100GB \<br/>	--boot-disk-type=pd-standard \<br/>	--machine-type=n1-standard-4 \<br/>	--maintenance-policy=TERMINATE \<br/>	--metadata-from-file startup-script=./startup.sh</span></pre><p id="4c2a" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在不要担心<code class="fe kv kw kx ky b">metadata-from-file startup-script=...</code>的争论。我们将在下一节探讨这一点。</p><p id="0eaa" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">当我们可以使用<code class="fe kv kw kx ky b">gcloud compute instances create-with-container</code>创建一个带有容器的 VM 时，为什么我们选择了 Ubuntu？好问题！这个命令创建了一个基于 Chromium OS 的带有<code class="fe kv kw kx ky b">Container-Optimized OS</code>的虚拟机。在这样的虚拟机上安装 NVIDIA 驱动程序要复杂得多，所以我们选择 Ubuntu，让我们的生活变得更轻松。如果你热衷于使用容器优化的操作系统，那么请看<a class="ae oi" href="https://github.com/GoogleCloudPlatform/cos-gpu-installer" rel="noopener ugc nofollow" target="_blank">这份报告</a>中的 GPU 驱动程序安装解决方案。</p><p id="7a9d" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在发出这个命令之前，我们需要在当前目录中有一个启动脚本。让我们来看看这个启动脚本是怎么回事！</p><h1 id="1689" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">启动脚本</h1><p id="0122" class="pw-post-body-paragraph kz la iq lb b lc nd jr le lf ne ju lh li nf lk ll lm ng lo lp lq nh ls lt lu ij bi translated"><a class="ae oi" href="https://github.com/eustin/docker-tf-gcp/blob/master/startup.sh" rel="noopener ugc nofollow" target="_blank">这里的</a>是完整的启动脚本。</p><p id="6b8e" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">启动脚本会处理一些棘手的事情:</p><ul class=""><li id="f319" class="ni nj iq lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">它安装 Docker 并将<code class="fe kv kw kx ky b">gcloud</code>设置为 Docker 凭证助手。这将允许我们从 GCP 的<code class="fe kv kw kx ky b">Container Registry</code>中提取我们稍后将构建的 Docker 图像。</li><li id="f5a0" class="ni nj iq lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">它将 NVIDIA 驱动程序安装到虚拟机上。</li><li id="346b" class="ni nj iq lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">它安装了 NVIDIA 容器工具包，这将允许我们的 Docker 容器访问我们虚拟机上的 GPU。</li></ul><p id="bf56" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们最后发出命令，等待我们的 VM 完成构建。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/35be1113607bd23eb8910209c5fd5df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6JxK1bDRt5bmWSvF.jpg"/></div></div></figure><p id="f964" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">您可以通过 SSH 进入您的机器来跟踪启动脚本的进度:</p><pre class="kg kh ki kj gt nz ky oa ob aw oc bi"><span id="9f0d" class="od mm iq ky b gy oe of l og oh">gcloud compute ssh whale@deep-docker --zone=us-west1-b</span></pre><p id="4cef" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">进入虚拟机后，发出以下命令并查看您的日志流:</p><pre class="kg kh ki kj gt nz ky oa ob aw oc bi"><span id="b6cf" class="od mm iq ky b gy oe of l og oh">tail -f /var/log/syslog</span></pre><p id="f9b5" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在某些时候，您应该会看到类似这样的内容:</p><pre class="kg kh ki kj gt nz ky oa ob aw oc bi"><span id="496a" class="od mm iq ky b gy oe of l og oh">Apr 12 08:09:49 deep-docker startup-script: INFO Finished running startup scripts.</span></pre><p id="ddcb" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在这里你可以跳一小段庆祝舞。这个过程最难的部分已经过去了！</p><h1 id="8368" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">让启动脚本运行一次</h1><p id="dd97" class="pw-post-body-paragraph kz la iq lb b lc nd jr le lf ne ju lh li nf lk ll lm ng lo lp lq nh ls lt lu ij bi translated">我们的启动脚本的一个问题是，它在每次虚拟机启动时运行。如果我们频繁重启我们的虚拟机，这将变得不必要的耗时。</p><p id="502d" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">确保我们的脚本只运行一次的一种方法是使用<code class="fe kv kw kx ky b">gcloud</code> CLI 将它从虚拟机的元数据中删除:</p><pre class="kg kh ki kj gt nz ky oa ob aw oc bi"><span id="9929" class="od mm iq ky b gy oe of l og oh">gcloud compute instances remove-metadata deep-docker --keys=startup-script</span></pre><p id="8d49" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">另一种方法是遵循此处<a class="ae oi" href="https://googlecloudplatform.uservoice.com/forums/302595-compute-engine/suggestions/32030122-ability-to-run-startup-script-only-once" rel="noopener ugc nofollow" target="_blank">的建议。这是我采取的方法。在</a><a class="ae oi" href="https://github.com/eustin/docker-tf-gcp/blob/master/startup.sh" rel="noopener ugc nofollow" target="_blank">启动脚本</a>中，您会看到它的大部分被包含在一个<code class="fe kv kw kx ky b">if</code>语句中:</p><pre class="kg kh ki kj gt nz ky oa ob aw oc bi"><span id="5f73" class="od mm iq ky b gy oe of l og oh">if test ! -f "$STARTUP_SUCCESS_FILE"; then<br/>	...<br/>	touch /home/$LOGIN_USER/.ran-startup-script<br/>else<br/>	echo "$STARTUP_SUCCESS_FILE exists. not running startup script!"<br/>fi</span></pre><p id="a24a" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们根据特定位置是否存在名为<code class="fe kv kw kx ky b">.ran-startup-script</code>的文件来决定是否运行启动脚本的主体。在第一次引导时，那个文件不存在，所以执行了<code class="fe kv kw kx ky b">if</code>语句的主体。如果我们的虚拟机第一次启动一切顺利，上面的<code class="fe kv kw kx ky b">touch</code>行将创建<code class="fe kv kw kx ky b">.ran-startup-script</code>。在第二次启动时，启动脚本中所有耗时的部分都不会被执行。我们可以检查<code class="fe kv kw kx ky b">/var/log/syslog</code>以确认这是事实:</p><pre class="kg kh ki kj gt nz ky oa ob aw oc bi"><span id="c909" class="od mm iq ky b gy oe of l og oh">Apr 12 09:05:58 deep-docker startup-script: INFO startup-script: /home/whale/.ran-startup-script exists. not running startup script!<br/>Apr 12 09:05:58 deep-docker startup-script: INFO startup-script: Return code 0.</span></pre><h1 id="eefb" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">文档文件</h1><p id="83e2" class="pw-post-body-paragraph kz la iq lb b lc nd jr le lf ne ju lh li nf lk ll lm ng lo lp lq nh ls lt lu ij bi translated">这里的是我们的 Dockerfile。超级简单！</p><ul class=""><li id="52a3" class="ni nj iq lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">我们在 Python 3 中使用 TensorFlow GPU 基础映像。在编写时，该图像是<code class="fe kv kw kx ky b">tensorflow/tensorflow:2.1.0-gpu-py3</code>图像。</li><li id="11ee" class="ni nj iq lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">我们安装 JupyterLab。</li><li id="40fe" class="ni nj iq lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">我们安装了一些其他的 Python 包。</li></ul><p id="715c" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们现在将建立这个图像。</p><h1 id="8aaa" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">在云中构建 Docker 映像</h1><p id="0ebf" class="pw-post-body-paragraph kz la iq lb b lc nd jr le lf ne ju lh li nf lk ll lm ng lo lp lq nh ls lt lu ij bi translated">我们使用的 TensorFlow 图像大小约为 2GB。我们将利用 GCP 的强大功能，在云中构建 Docker 映像，而不是在本地构建并从本地机器推送到<code class="fe kv kw kx ky b">Container Registry</code>。</p><p id="9965" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们将建立的形象将位于<code class="fe kv kw kx ky b">gcr.io/GCP_PROJECT_NAME/SOME_IMAGE_NAME</code>。我的项目叫<code class="fe kv kw kx ky b">learning-deeply</code>。我想把图像叫做<code class="fe kv kw kx ky b">tf-2.1.0-gpu</code>。因此，我将在我的终端中发出以下命令:</p><pre class="kg kh ki kj gt nz ky oa ob aw oc bi"><span id="e7c3" class="od mm iq ky b gy oe of l og oh">REMOTE_IMAGE_NAME=gcr.io/learning-deeply/tf-2.1.0-gpu \<br/>	&amp;&amp; gcloud builds submit --tag $(REMOTE_IMAGE_NAME) \<br/>        --timeout=15m</span></pre><p id="2d11" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我指定了一个更长的超时来解决我遇到的超时问题。让我们发出命令，看着我们的构建发生吧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/5d30ba03de892c18b97e8bf289a9fa89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gZ-MqPHWIw-ubMsM.jpg"/></div></div></figure><p id="2d15" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们可以在 GCP 控制台的<code class="fe kv kw kx ky b">Cloud Build</code>部分监控我们的构建进度:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/e29ba3d5a1031e3a56eb58f546f7e6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sZk7gOloA5HmPxuM.jpg"/></div></div></figure><p id="3778" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">一旦完成，让我们前往<code class="fe kv kw kx ky b">Container Registry</code>部分，我们应该在那里看到我们美丽的形象！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/72f9ebceb5200d98fa9eafc02e05b28e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SuzRy5yUIlFHvI5y.jpg"/></div></div></figure><h1 id="2944" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">点燃我们的容器，检查图形处理器</h1><p id="f4b6" class="pw-post-body-paragraph kz la iq lb b lc nd jr le lf ne ju lh li nf lk ll lm ng lo lp lq nh ls lt lu ij bi translated">这太令人兴奋了！我看到你期待地搓着手掌。让我们看看我们的努力是否有回报。</p><p id="f05d" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">首先，让我们 SSH 进入我们的 VM(参见<code class="fe kv kw kx ky b">startup script</code>部分了解如何操作)。</p><p id="3efd" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们将 Docker 映像放入我们的虚拟机中！发出与此类似的命令，用您在前面发出<code class="fe kv kw kx ky b">gcloud builds submit</code>时提供的内容替换对图像位置的引用:</p><pre class="kg kh ki kj gt nz ky oa ob aw oc bi"><span id="4be9" class="od mm iq ky b gy oe of l og oh">docker pull gcr.io/learning-deeply/tf-2.1.0-gpu:latest</span></pre><p id="a276" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">由于我们已经在启动脚本中处理了容器注册认证，这应该会从<code class="fe kv kw kx ky b">Container Registry</code>中提取您的图像。</p><p id="20ba" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">接下来，让我们启动我们的容器。注意，我们有一个<code class="fe kv kw kx ky b">--gpus</code>参数，它将我们虚拟机上的所有 GPU 暴露给我们的容器:</p><pre class="kg kh ki kj gt nz ky oa ob aw oc bi"><span id="1243" class="od mm iq ky b gy oe of l og oh">docker run -it -d --name tf --gpus all gcr.io/learning-deeply/tf-2.1.0-gpu</span></pre><p id="4f38" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">问题<code class="fe kv kw kx ky b">docker ps</code>我们应该看到我们的容器运行！</p><p id="267f" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在让我们在容器上执行一个交互式 Bash shell:</p><pre class="kg kh ki kj gt nz ky oa ob aw oc bi"><span id="8bc2" class="od mm iq ky b gy oe of l og oh">docker exec -it tf bash</span></pre><p id="25ca" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">你应该会看到像这样美丽的东西:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/9e32b9afd14d528da5ca37cb049a8104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S8Z2nH7jZHBw8tTo.jpg"/></div></div></figure><p id="18dc" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在交叉手指运行这个来检查我们是否可以访问我们的 GPU:</p><pre class="kg kh ki kj gt nz ky oa ob aw oc bi"><span id="db5d" class="od mm iq ky b gy oe of l og oh">python3 -c "import tensorflow as tf;print(tf.config.list_physical_devices('GPU'))"</span></pre><p id="816c" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">将打印一串文本。但是如果你最后看到这样的东西，你就知道你成功了，我的朋友们:</p><pre class="kg kh ki kj gt nz ky oa ob aw oc bi"><span id="2b65" class="od mm iq ky b gy oe of l og oh">[PhysicalDevice(name='/physical_device:GPU:0', device_type='GPU')]</span></pre><h1 id="23b3" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">结论</h1><p id="e775" class="pw-post-body-paragraph kz la iq lb b lc nd jr le lf ne ju lh li nf lk ll lm ng lo lp lq nh ls lt lu ij bi translated">Docker 改变了我的工作方式。我不仅将它用于我的机器学习工作，还将它用于我的常规数据分析工作和构建我的博客。</p><p id="0102" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果你的职称以“数据”开头，那就帮自己一个忙，学会使用它。你也可以学会爱鲸鱼！</p><p id="d98a" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">直到下一次，</p><p id="2462" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">贾斯廷</p></div><div class="ab cl oo op hu oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ij ik il im in"><p id="2f74" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><em class="ov">原载于 2020 年 4 月 13 日</em><a class="ae oi" href="https://embracingtherandom.com/deep-learning/cloud/tensorflow/docker/dockerise-your-tf/" rel="noopener ugc nofollow" target="_blank"><em class="ov"/></a><em class="ov">。</em></p></div></div>    
</body>
</html>