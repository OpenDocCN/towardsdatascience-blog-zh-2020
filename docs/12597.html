<html>
<head>
<title>Data Science Quick Tip #004: Using Custom Transformers in Scikit-Learn Pipelines!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学快速提示#004:在 Scikit 中使用自定义转换器-学习管道！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-quick-tip-004-using-custom-transformers-in-scikit-learn-pipelines-89c28c72f22a?source=collection_archive---------37-----------------------#2020-08-30">https://towardsdatascience.com/data-science-quick-tip-004-using-custom-transformers-in-scikit-learn-pipelines-89c28c72f22a?source=collection_archive---------37-----------------------#2020-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e23a790849d2a19366fe76a1b313f950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYkhezJ0OELuP3OjYEDj3Q.png"/></div></div></figure><div class=""/><div class=""><h2 id="161a" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">了解如何在同一个 Scikit-Learn 管道中使用定制数据转换器</h2></div><p id="fc8a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">大家好。关于如何创建 Scikit-Learn 管道，我们又回来了，这是上一篇文章的后续文章。如果你错过了，你现在可以点击链接查看<a class="ae lp" rel="noopener" target="_blank" href="/data-science-quick-tip-003-using-scikit-learn-pipelines-66f652f26954">。(它现在正式发布到《走向数据科学》。w00t！)和往常一样，如果你想直接跟随这篇文章的代码，你可以在我的个人 GitHub </a>找到<a class="ae lp" href="https://github.com/dkhundley/ds-quick-tips/tree/master/004_pipeline_custom_transformers" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c70f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了快速结束上一篇文章，我们已经成功地创建了一个 Scikit-Learn 管道，它在一个干净的小包中完成了所有的数据转换、缩放和推理。但是到目前为止，我们不得不在我们的管道中使用 Scikit-Learn 的默认转换器。虽然这些变形金刚很棒，但是如果我们可以利用自己的自定义变形，那不是很棒吗？当然了！我认为这不仅很棒，而且很有必要。如果你还记得上周的帖子，我们建立了一个基于单一特征的模型。那可不太好预测啊！</p><p id="1cf0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">因此，我们将通过添加两个转换器来转换训练数据集中的两个额外字段，从而解决这一问题。(我知道，从 1 个功能增加到 3 个功能仍然不是很好。但是，嘿，至少我们增加了 300%？)我们开始时的原始变量是“性别”(又名性别)，现在我们将为适当的“年龄”列和“上船”列添加 transformers。</p><p id="87e3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在我们开始新的定制变形金刚之前，让我们先导入库。你可能还记得上一篇文章中的许多内容，但是我们增加了一些额外的内容。不要太担心它们现在是什么，因为我们将在后面的文章中进一步讨论。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="9b43" class="lz ma je lv b gy mb mc l md me"># Importing the libraries we’ll be using for this project<br/>import pandas as pd<br/>import joblibfrom sklearn.preprocessing import OneHotEncoder, StandardScaler, FunctionTransformer<br/>from sklearn.impute import SimpleImputer<br/>from sklearn.compose import ColumnTransformer<br/>from sklearn.pipeline import Pipeline<br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import roc_auc_score, accuracy_score, confusion_matrix</span></pre><p id="468a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将继续快速导入我们的培训数据。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="ddcd" class="lz ma je lv b gy mb mc l md me"># Importing the training dataset<br/>raw_train = pd.read_csv(‘../data/titanic/train.csv’)</span><span id="6c08" class="lz ma je lv b gy mf mc l md me"># Splitting the training data into appropriate training and validation sets<br/>X = raw_train.drop(columns = [‘Survived’])<br/>y = raw_train[[‘Survived’]]</span><span id="146e" class="lz ma je lv b gy mf mc l md me">X_train, X_val, y_train, y_val = train_test_split(X, y, random_state = 42)</span></pre><p id="86db" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">好了，从现在开始，我们实际上不会改变 Scikit-Learn 管道本身。当然，我们会对其进行添加，但是请记住，我有意将我的数据预处理器设计成易于添加的方式。简单回顾一下上一篇文章，下面是构建原始管道的代码。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="7adb" class="lz ma je lv b gy mb mc l md me"># Creating a preprocessor to transform the ‘Sex’ column<br/>data_preprocessor = ColumnTransformer(transformers = [<br/>   (‘sex_transformer’, OneHotEncoder(), [‘Sex’])<br/>])</span><span id="31cf" class="lz ma je lv b gy mf mc l md me"># Creating our pipeline that first preprocesses the data, then scales the data, then fits the data to a RandomForestClassifier<br/>rfc_pipeline = Pipeline(steps = [<br/>   (‘data_preprocessing’, data_preprocessor),<br/>   (‘data_scaling’, StandardScaler()),<br/>   (‘model’, RandomForestClassifier(max_depth = 10,<br/>                                    min_samples_leaf = 3,<br/>                                    min_samples_split = 4,<br/>                                    n_estimators = 200))<br/>])</span></pre><p id="ed10" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当然，在将自定义转换器添加到管道之前，我们可以做的第一件事是创建函数转换器！因此，正如您可能已经猜到的那样，定制转换器是建立在常规函数之上的，因此您可以为转换器编写任何您想要的 Python 函数。****(我们稍后将讨论所有这些星号……)</p><p id="6261" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">好了，我们讨论了为两个新变量添加两个转换器，现在让我们开始创建两个自定义 Python 函数吧！首先触及“年龄”列，我们将对这个变量有一点额外的乐趣。现在，我真的不知道年龄本身是否是一个预测变量，但我猜想，如果“年龄”可以以任何有意义的方式预测，它将是年龄类别/年龄箱。也就是说，我将年龄划分为“儿童”、“成人”、“老人”等类别。同样，我不知道这是否会比使用直接整数更有性能，但它让我们可以做一些有趣的事情！下面是这样的代码:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="adae" class="lz ma je lv b gy mb mc l md me"># Creating a function to appropriately engineer the ‘Age’ column<br/>def create_age_bins(col):<br/>    ‘’’Engineers age bin variables for pipeline’’’<br/> <br/>    # Defining / instantiating the necessary variables<br/>    age_bins = [-1, 12, 18, 25, 50, 100]<br/>    age_labels = [‘child’, ‘teen’, ‘young_adult’, ‘adult’, ‘elder’]<br/>    age_imputer = SimpleImputer(strategy = ‘median’)<br/>    age_ohe = OneHotEncoder()<br/> <br/>    # Performing basic imputation for nulls<br/>    imputed = age_imputer.fit_transform(col)<br/>    ages_filled = pd.DataFrame(data = imputed, columns = [‘Age’])<br/> <br/>    # Segregating ages into age bins<br/>    age_cat_cols = pd.cut(ages_filled[‘Age’], bins = age_bins, labels = age_labels)<br/>    age_cats = pd.DataFrame(data = age_cat_cols, columns = [‘Age’])<br/> <br/>    # One hot encoding new age bins<br/>    ages_encoded = age_ohe.fit_transform(age_cats[[‘Age’]])<br/>    ages_encoded = pd.DataFrame(data = ages_encoded.toarray())<br/> <br/>    return ages_encoded</span></pre><p id="2ebb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">好了，接下来是“上船”专栏。现在，这已经*几乎*准备好进行直接的热编码了，但是我们不能直接跳到那里的原因是因为这个列中有一些空值。这些需要首先解决，所以这里是我们将在这里使用的自定义转换器。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="52d2" class="lz ma je lv b gy mb mc l md me"># Creating function to appropriately engineer the ‘Embarked’ column<br/>def create_embarked_columns(col):<br/>    ‘’’Engineers the embarked variables for pipeline’’’<br/> <br/>    # Instantiating the transformer objects<br/>    embarked_imputer = SimpleImputer(strategy = ‘most_frequent’)<br/>    embarked_ohe = OneHotEncoder()<br/> <br/>    # Performing basic imputation for nulls<br/>    imputed = embarked_imputer.fit_transform(col)<br/>    embarked_filled = pd.DataFrame(data = imputed, columns = [‘Embarked’])<br/> <br/>    # Performing OHE on the col data<br/>    embarked_columns = embarked_ohe.fit_transform(embarked_filled[[‘Embarked’]])<br/>    embarked_columns_df = pd.DataFrame(data = embarked_columns.toarray())<br/> <br/> return embarked_columns_df</span></pre><p id="2d8c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">既然我们已经编写了自定义函数，我们终于可以将它们添加到管道中了。你可能不知道，但是 Scikit-Learn 有一个特殊的方法来处理这些特殊的自定义转换器，叫做<strong class="kv jf"> FunctionTransformer </strong>。这很容易实现，所以让我们看看当我们把它添加到我们原来的管道时是什么样子。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="a1fd" class="lz ma je lv b gy mb mc l md me"># Creating a preprocessor to transform the ‘Sex’ column<br/>data_preprocessor = ColumnTransformer(transformers = [<br/>    (‘sex_transformer’, OneHotEncoder(), [‘Sex’]),<br/>    (‘age_transformer’, FunctionTransformer(create_age_bins, validate = False), [‘Age’]),<br/>    (‘embarked_transformer’, FunctionTransformer(create_embarked_columns, validate = False), [‘Embarked’])<br/>])</span><span id="88da" class="lz ma je lv b gy mf mc l md me"># Creating our pipeline that first preprocesses the data, then scales the data, then fits the data to a RandomForestClassifier<br/>rfc_pipeline = Pipeline(steps = [<br/>    (‘data_preprocessing’, data_preprocessor),<br/>    (‘data_scaling’, StandardScaler()),<br/>    (‘model’, RandomForestClassifier(max_depth = 10,<br/>                                     min_samples_leaf = 3,<br/>                                     min_samples_split = 4,<br/>                                     n_estimators = 200))<br/>])</span></pre><p id="5143" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">很简单，对吧？使用 Scikit-Learn function transformer 指向正确的自定义函数，并在指定的列上使用它，这很简单。从现在开始，这是模型的简单导出。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="9cb2" class="lz ma je lv b gy mb mc l md me"># Fitting the training data to our pipeline<br/>rfc_pipeline.fit(X_train, y_train)</span><span id="babd" class="lz ma je lv b gy mf mc l md me"># Saving our pipeline to a binary pickle file<br/>joblib.dump(rfc_pipeline, ‘model/rfc_pipeline.pkl’)</span></pre><p id="0ff3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">* * * *回到星号时代！！！</strong></p><p id="bfda" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所以……..使用定制变压器也有不好的一面…</p><p id="3da8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">序列化模型不存储任何自定义 Python 函数的代码本身。(至少…不是以我还没想出来的方式。)也就是说，<strong class="kv jf"> <em class="mg">为了利用这个反序列化的模型，pickle 必须能够引用为其自身二进制值</em> </strong>之外的函数转换器编写的相同代码。或者通俗地说，您需要将您的定制 Python 函数添加到您为这样的模型编写的任何部署脚本中。</p><p id="c7e7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，这是不是有点烦人？是的。但是这给了我一个不使用定制转换的理由吗？这是一个简单而坚定的答案。我知道为管道运行提供额外的定制代码不太方便，但代价是进行转换，这可能会使模型的性能比其他情况好得多。</p><p id="2695" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所以，是的，这有点糟糕，但嘿，我会选择包括自定义变形金刚每次最有可能。大多数数据集包含广泛的特征，这些特征肯定不会分解成简单的转换，如插补或一次热编码。真实的数据是杂乱的，经常需要大量的特殊清理，而这些定制的转换器正好适合这项工作。</p><p id="1792" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这就是这篇文章的全部内容！希望你喜欢。如果你想让我在以后的帖子中涉及任何具体的内容，请告诉我！我脑子里还有更多的想法，所以请继续关注。😃</p></div></div>    
</body>
</html>