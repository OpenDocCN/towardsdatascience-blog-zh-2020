<html>
<head>
<title>Analyzing Twitter Relationships in Python without an API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在没有API的情况下用Python分析Twitter关系</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/analyzing-twitter-relationships-in-python-without-an-api-a35b5b502cb?source=collection_archive---------14-----------------------#2020-01-09">https://towardsdatascience.com/analyzing-twitter-relationships-in-python-without-an-api-a35b5b502cb?source=collection_archive---------14-----------------------#2020-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fb80" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用一些著名的Twitter账户进行关系分析的简单方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2938adc70457c104804fc1235282441a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AHOM9wSrpQpxt37_v8E5bQ.png"/></div></div></figure><p id="eb21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">社交媒体分析是数据科学的热门话题之一。人们喜欢这些分析，并对它们感兴趣，因为每个人都熟悉这个世界。我们大部分时间都花在了推特、Instagram、脸书和其他一些社交媒体应用上。</p><p id="79ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一名数据爱好者，这个话题引起我的注意并不奇怪。然而，访问官方的Twitter API是非常具有挑战性的。于是，我搜索了另一种解决方案，找到了<a class="ae ln" href="https://github.com/twintproject/twint" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> twint </strong> </a>。这是一个python库，使你能够在没有API访问的情况下废弃twitter数据。</p><p id="6453" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将简要介绍如何借助twint收集twitter数据，并基于一组Twitter用户之间的关注和提及来分析一些关系。</p><h2 id="a058" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">初始化Python代码</h2><p id="ef1f" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我们需要<strong class="kt ir"> twint </strong>库来抓取数据，需要<a class="ae ln" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">pandas</strong></a><strong class="kt ir"/>来创建dataframes，需要<a class="ae ln" href="https://docs.python.org/3/library/collections.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">集合</strong> </a> <strong class="kt ir"> </strong>来获取列表中的分组值计数。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="d314" class="lo lp iq mn b gy mr ms l mt mu">import twint<br/>import pandas as pd<br/>from collections import Counter</span></pre><p id="0536" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们开始创建一个包含twitter账户的用户列表。我们的分析将包括这些用户的关系。由于代码运行时间较长，我不建议将拥有超过<strong class="kt ir"> 5K </strong>追随者的用户添加到此列表中。类似地，一个很长的列表可能也会出现同样的问题。</p><p id="9925" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我选择了一些大家都知道的热门Twitter用户，让我们的分析更有趣。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="bf60" class="lo lp iq mn b gy mr ms l mt mu">users = [<br/><strong class="mn ir">    'shakira',<br/>    'KimKardashian',<br/>    'rihanna',<br/>    'jtimberlake',<br/>    'KingJames',<br/>    'neymarjr',</strong><br/>]</span></pre><h2 id="37f9" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">跟踪关系分析</h2><p id="879c" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">让我们从关系分析开始，并为此编写一个名为<strong class="kt ir">get _ followers</strong>的函数，用用户名向twint库发送请求。该函数将返回我们的输入用户关注的用户列表。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="8faa" class="lo lp iq mn b gy mr ms l mt mu">def get_followings(username):<br/><br/>    c = twint.Config()<br/>    c.Username = username<br/>    c.Pandas = True<br/><br/>    twint.run.Following(c)<br/>    list_of_followings = twint.storage.panda.Follow_df<br/><br/>    return list_of_followings['following'][username]</span></pre><p id="a092" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<strong class="kt ir"> get_followings </strong>函数，我们将为用户列表中的每个人获取不同的列表，并将结果存储到一个字典(<strong class="kt ir"> followings </strong>)和一个列表(<strong class="kt ir"> following_list </strong>)。following_list是所有following的联合版本，我们将在下一节使用它来计算最受关注的Twitter帐户。</p><p id="4779" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面的for循环创建了这两个变量。有时Twitter不响应我们的请求，在这种情况下，我们会得到一个<strong class="kt ir">索引错误。对于这种情况，我在代码中添加了一个例外来跳过这些用户。</strong></p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="d7a4" class="lo lp iq mn b gy mr ms l mt mu">followings = {}<br/>following_list = []<br/>for person in users:<br/>    print('#####\nStarting: ' + person + '\n#####')<br/>    try:<br/>        followings[person] = get_followings(person)<br/>        following_list = following_list + followings[person]<br/>    except KeyError:<br/>        print('IndexError')</span></pre><h2 id="da93" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">我们的用户关注最多的是谁？</h2><p id="b31b" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">在获得以下所有列表后，我们可以简单地计算following_list变量中最常见的值，以获得用户中最受欢迎的帐户。为了获得最受关注的<strong class="kt ir"> 10个</strong>账户，我们将使用收藏库中的<strong class="kt ir">计数器</strong>函数。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="e4f6" class="lo lp iq mn b gy mr ms l mt mu">Counter(following_list).most_common(10)</span></pre><p id="b76e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该函数的结果如下所示。蕾哈娜似乎被所有其他人追随，在我们的用户群中，她绝对是最受欢迎的一个。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="a9ba" class="lo lp iq mn b gy mr ms l mt mu"><strong class="mn ir">[('rihanna', 5),<br/> ('RyanSeacrest', 3),<br/> ('BarackObama', 3),<br/> ('Oprah', 3),<br/> ('TheEllenShow', 3),<br/> ('kendricklamar', 3),<br/> ('KDTrey5', 3),<br/> ('Drake', 3),<br/> ('Nike', 3),<br/> ('NBA', 3)]</strong></span></pre><h2 id="6a51" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">遵循用户之间的关系</h2><p id="72b2" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">如果我们想知道我们的用户组中谁在关注谁呢？为了研究这个问题，我编写了一个for循环来检查用户中是否有人在另一个人的列表中。因此，它创建了一个列表字典，显示由真和假表示的以下状态。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="0095" class="lo lp iq mn b gy mr ms l mt mu">follow_relations ={}<br/>for following_user in followings.keys():<br/>    follow_relation_list = []<br/>    for followed_user in followings.keys():<br/>        if followed_user in followings[following_user]:<br/>            follow_relation_list.append(True)<br/>        else:<br/>            follow_relation_list.append(False)<br/>    follow_relations[following_user] = follow_relation_list</span></pre><p id="4c4f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下面的代码中，结果字典被转换成一个pandas数据帧，以实现更加用户友好的可视化。数据帧的行显示跟随的用户，而列指示被跟随的用户。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="25d5" class="lo lp iq mn b gy mr ms l mt mu">following_df = pd.DataFrame.from_dict(follow_relations, orient='index', columns=followings.keys())</span></pre><p id="8e5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以在下面看到分析的输出。我们再次确认<strong class="kt ir">蕾哈娜</strong>在这张表中的受欢迎程度。所有其他人都跟着她。但是，对于<strong class="kt ir">金·卡戴珊</strong>，我们不能用类似的方式说话，根据分析，我们的用户群中只有<strong class="kt ir">贾斯汀·汀布莱克</strong>追随她。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/bf0a80b01be150502c3e53ff888659fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6n7Jmp-0mJvqymRLFUSESQ.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">以下关系表</p></figure><h2 id="eb43" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">提及次数分析</h2><p id="999a" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">提及次数是Twitter用户之间的另一个强有力的关系指标。下面的函数(<strong class="kt ir">get _ note _ count</strong>)就是为此而编写的，它返回两个用户之间的单向提及次数。我们应该将提到的用户名放在<strong class="kt ir">提词</strong>中，在函数中，为了更精确地分离提词，在它的开头添加了一个“<strong class="kt ir"> @ </strong>”字符。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="1ff6" class="lo lp iq mn b gy mr ms l mt mu">def get_mention_count(user, mention_word):<br/><br/>    c = twint.Config()<br/>    c.Username = user<br/>    c.Search = '@' + mention_word<br/>    c.Store_object = True<br/><br/>    twint.run.Search(c)<br/>    tweets = twint.output.tweets_list<br/>    mention_count = len(tweets)<br/>    tweets.clear()<br/><br/>    return mention_count</span></pre><p id="38c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在分析中，我们将使用两个嵌套的for循环来检索每个用户对我们组中所有其他用户的提及次数。因此，我们将得到<strong class="kt ir">提_关系</strong>字典。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="7d30" class="lo lp iq mn b gy mr ms l mt mu">mention_relations = {}<br/>for mentioning_user in users:<br/>    print('#####\nStarting: ' + mentioning_user + '\n#####')<br/>    mention_count_list = []<br/>    for mentioned_user in users:<br/>        mention_count = get_mention_count(mentioning_user, mentioned_user)<br/>        mention_count_list.append(mention_count)<br/>    mention_relations[mentioning_user] = mention_count_list</span></pre><p id="cb63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们把这本字典转换成一个熊猫的数据框架，它变成了一个可理解的和更容易解释的表格。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="99f1" class="lo lp iq mn b gy mr ms l mt mu">mention_df = pd.DataFrame.from_dict(mention_relations, orient='index', columns=mention_relations.keys())</span></pre><p id="de1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以看到下面提到次数表的输出。同样，行显示提到的用户，列显示提到的用户。对角线值显示了用户提到自己的次数，这些是由转发引起的。如果我们忽略这些值，我们会看到<strong class="kt ir">勒布朗·詹姆斯</strong>被小组中的每个人提及，而<strong class="kt ir">蕾哈娜</strong>看起来被除了<strong class="kt ir">内马尔</strong>之外的每个人提及。另一方面，这个团体中没有人在他们的推文中提到过内马尔。另一个有趣的推论可能是，夏奇拉在她的推文中提到蕾哈娜52次，然而蕾哈娜只提到她7次。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/bcf612b5e8b32c6ec2c35d0008c59280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lysOnZCqvI1X_x0OJsdQww.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">提及次数表</p></figure><p id="4303" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">结论</strong></p><p id="bb9c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我试着在著名的Twitter用户上解释一些基本的社交媒体分析，只是为了好玩，同时也是为了在不复杂的python代码的帮助下做好准备。我希望它们对你有所帮助。最后，可以肯定的是，这些分析有待改进，如果您对本文有任何建议或补充，请不要犹豫，与我们分享。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/3b8c4c863b1b2c1ffa90dbb175b7d1f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*KrPbXyuNZ52-kACD.jpg"/></div></figure></div></div>    
</body>
</html>