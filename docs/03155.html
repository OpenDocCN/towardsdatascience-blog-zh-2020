<html>
<head>
<title>How to Use Decorators in Python, by example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">举例说明如何在 Python 中使用装饰器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-decorators-in-python-by-example-b398328163b?source=collection_archive---------1-----------------------#2020-03-26">https://towardsdatascience.com/how-to-use-decorators-in-python-by-example-b398328163b?source=collection_archive---------1-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/92307bf29dca5d7c7f5640d3beca85a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7N-rVxZSnPtcZGSjh2DUA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图片由<a class="ae kf" href="https://unsplash.com/photos/MzSqFPLo8CE" rel="noopener ugc nofollow" target="_blank">王思然·哈德逊通过 Unsplash </a>提供</p></figure><h1 id="c5ea" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Python 中的装饰者</h1><p id="d170" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Python 中的装饰器是一个函数，它将另一个函数作为其参数，并返回另一个函数。装饰器非常有用，因为它们允许对现有函数进行扩展，而无需对原始函数源代码进行任何修改。</p><p id="f78a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">考虑下面的例子:</p><h2 id="3eb1" class="mh kh it bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">1.相加函数</h2><p id="ccfd" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">简单的 add_together 函数将 2 个整数作为参数，并返回传递的 2 个整数值的总和。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/9481857d27455d269a3f662e4cc11ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*I1y8XbUZTN7hTJ1i9mDzrA.png"/></div></figure><h2 id="6cff" class="mh kh it bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">1.1.用装饰器扩展 add _ 的功能</h2><p id="1b3b" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们提出下面的场景。我们希望 add_together 能够将 2 个元素元组的列表作为其参数，并返回一个整数列表，该列表表示它们的值的总和。我们可以通过使用装饰器来实现这一点。</p><p id="da39" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">首先，我们给装饰者一个明智的名字，暗示它的预期目的是什么。这里的 decorator，称为 decorator_list，只是一个将另一个函数作为参数的函数。这个函数在 decorator_list 的参数列表中被命名为‘fnc’。</p><p id="3a86" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在 decoratored 函数中，我们定义了一个名为 inner 的局部函数。inner 函数将一个 2 元素元组列表作为其参数。内部函数循环遍历这个 2 个元素元组的列表，并对每个元组应用原始函数 add_together，其中元组的索引位置 0 是 add_together 中 a 的参数，索引位置 1 是 add_together 中 b 的参数。内部函数返回这些值的汇总列表。decorator_list 函数最后返回内部函数。</p><p id="5402" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在，让我们应用这个逻辑，看看装饰函数是如何工作的。</p><p id="6ee1" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">为了应用装饰器，我们使用语法@，后面是装饰器的函数名，位于正在装饰的函数<em class="my">的上方。这在语法上与以下内容相同:</em></p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="mz na l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">从语法上来说，@decorator_list 等同于将函数 add_together 传递给 decorator_list，并重新赋值给 add_together</p></figure><p id="5cff" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这里，我们将函数 add_together 传递给 decorator_list 函数，该函数返回内部函数，我们将该函数赋给变量名 add_together。由于 add_together 现在指向内部函数，该函数需要一个包含 2 个元素元组的列表，因此我们可以调用 add_together，并将一个元组列表作为参数。</p><p id="ca26" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">控制台的标准输出显示，我们现在已经扩展了原始 add_together 函数的功能，因此它现在可以接受一个元组列表。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/d99c07b37fe5317635962008100d7209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1BuUEGSHxDiQMKcUWfSiA.png"/></div></div></figure><p id="dd56" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">修饰函数的完整源代码可从以下网址获得:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="80ea" class="mh kh it bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">2.可以自己接受参数的装饰者</h2><p id="f84b" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">装饰者自己获取参数也可能是有用的。在这里稍微修改的例子中，我们将一个整数参数传递给装饰器。元组中的两个值相加后，该整数值用作指数。这里，值 2 对每个值进行平方，因此对于第一个元组，返回 16(即 1 + 3 的平方)。</p><p id="2582" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">为了在装饰器中使用参数，我们只需要定义一个<em class="my">装饰器</em>本身。在下面的例子中，2 是传递给 meta_decorator 的参数。这个 meta_decorator 函数返回 decorator_list 函数，2 作为参数传递给 power。然后，这个 decorator_list decorator 以普通方式使用，即，它接受 add_together 函数并返回 inner，然后我们可以用元组列表调用它。</p><p id="6ebb" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在我们有了一个返回的元组列表，它们被加在一起并平方。对于立方或四倍，我们只需在 meta_decorator 的参数中添加 3 或 4。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/33cd77a48834283c21100873372be716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFrnWCghZ7ygoSQFqYFlSQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">当我们想要创建接受参数本身的 decorators 时，就增加了一个额外的函数层。</p></figure><p id="5a51" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">该示例的源代码如下所示:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="8175" class="mh kh it bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">3.装饰器中的默认参数</h2><p id="48e2" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在我们已经看到，我们可以为装饰器指定参数，也可以不为装饰器指定参数，这样就会设置一个默认值。</p><p id="90c8" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果我们不向装饰器传递任何参数，就像我们对@meta_decorator 所做的那样，args 就被认为是一个函数。</p><p id="17f0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">由于传递了函数的内置可调用函数将返回布尔值 True，因此 power 被赋值为 2，我们可以立即直接调用将返回 inner 的 decorated_list 函数。</p><p id="7b69" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果 arg <em class="my">不是</em>一个函数，而是一个整数，那么它是不可调用的(就像被注释掉的代码中会发生的那样)。然后我们转到 else 语句，该语句执行相应的块。无论我们传递哪个值，都会分配给 Power，然后我们创建 decorator_list 函数，该函数最终返回 inner。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/797135c8b0d9871a8a6774e8fcb37aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dZH2KCZs8xi_uQ8fCZFZGg.png"/></div></div></figure><p id="252b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">该代码片段的源代码如下所示:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="a505" class="mh kh it bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">4.摘要</h2><p id="a45c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">装饰器是一种优雅的方式来扩展我们的原始函数的功能，而不改变它们的源代码。此外，我们定义的装饰器可以接受参数，或者返回到一组预定义的默认参数。这篇文章展示了装饰者的基本知识，以及如何将它们整合到我们的功能设计中。</p></div></div>    
</body>
</html>