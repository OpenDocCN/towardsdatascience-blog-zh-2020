<html>
<head>
<title>DevOps for Data Science with GCP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与GCP合作开发数据科学</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/devops-for-data-science-with-gcp-3e6b5c3dd4f6?source=collection_archive---------17-----------------------#2020-02-17">https://towardsdatascience.com/devops-for-data-science-with-gcp-3e6b5c3dd4f6?source=collection_archive---------17-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/63587ca50147dd320a19937f6b17ecbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZeAmaJs9Xg2YMBROJJriQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://pixabay.com/photos/dock-ship-container-port-boat-1277744/" rel="noopener ugc nofollow" target="_blank">https://pix abay . com/photos/dock-ship-container-port-boat-1277744/</a></p></figure><div class=""/><div class=""><h2 id="f76c" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">为模型服务部署生产级容器</h2></div><p id="245c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据科学团队的职能之一是建立机器学习(ML)模型，为产品和个性化提供预测信号。虽然DevOps并不总是被视为数据科学团队的核心职责，但随着这些团队开始更多地负责运行和维护数据产品，它变得越来越重要。数据科学家不再将代码或模型交给工程团队进行部署，而是在生产中拥有系统，这种情况越来越普遍。虽然我之前写过一本关于用Python构建可伸缩ML管道的<a class="ae jg" href="https://www.amazon.com/dp/165206463X" rel="noopener ugc nofollow" target="_blank">书</a>，但是我并没有太关注构建数据产品的维护方面。这篇文章的目标是通过一个示例ML系统，它涵盖了数据科学DevOps的一些方面。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/d2ae96cc2ca1fcfd8ae8afe83c801283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*Ai8mcdOAoM9GkumaVS_OZQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">【https://www.amazon.com/dp/165206463X T4】</p></figure><p id="5d5b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模型服务是指托管其他服务可以调用的端点，以便从机器学习模型中获得预测。这些系统通常是实时预测，其中关于用户或web会话的状态被传递到端点。设置端点的一些方法包括使用web服务，如Flask和Gunicorn，使用无服务器功能，如GCP云功能，以及使用消息协议，如GCP PubSub。如果您希望建立一个需要以最小的延迟为大量请求提供服务的系统，那么您可能希望使用容器化的方法，而不是无服务器的功能，因为您将对系统的运行时环境有更多的控制，并且成本可以显著降低。在这篇文章中，我们将展示如何在谷歌云平台(GCP)上使用Flask和Docker结合谷歌Kubernetes引擎(GKE)构建一个可扩展的ML系统。Kubernetes是一种越来越受DevOps欢迎的技术，也是一种越来越需要数据科学家的技能。</p><p id="19c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了使用这些工具来构建一个能够以低延迟扩展到大量请求的数据产品之外，我们还将探讨模型服务的以下开发运维关注点:</p><ol class=""><li id="6162" class="lz ma jj la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">如何部署具有高可用性的ML模型？</li><li id="16f3" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">如何扩展您的部署以满足需求？</li><li id="3cd7" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">您如何设置警报和跟踪事件？</li><li id="9f6a" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">您如何推出系统的新部署？</li></ol><p id="a052" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我们将重点关注能够部署和监控ML模型的工具，而不是触及其他数据科学问题，如模型训练。在本帖中，我们将探讨以下主题:</p><ol class=""><li id="9853" class="lz ma jj la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">为GCP建立发展环境</li><li id="a758" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">为本地模型服务开发Flask应用程序</li><li id="51c3" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">用Docker将应用程序容器化</li><li id="3a00" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">将容器发布到GCP容器注册中心</li><li id="b8f5" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">使用GKE在一个机器集群上托管服务</li><li id="7bad" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">使用负载平衡器分发请求</li><li id="9873" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">使用Stackdriver进行分布式日志记录和度量跟踪</li><li id="9cfd" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">使用带有滚动更新的GKE部署新版本的服务</li><li id="30ee" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">使用Stackdriver为警报设置警报</li></ol><p id="1de9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将从一个烧瓶应用程序开始，并使用GCP将其扩展到生产级应用程序。在此过程中，我们将使用Gunicorn、Docker、Kubernetes和Stackdriver来解决大规模部署此端点时的DevOps问题。这篇文章的完整代码清单可以在<a class="ae jg" href="https://github.com/bgweber/DS_Production/blob/master/Stackdriver.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h2 id="4544" class="mn mo jj bd mp mq mr dn ms mt mu dp mv lh mw mx my ll mz na nb lp nc nd ne nf bi translated">1.GCP发展环境</h2><p id="8a2c" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">在开始之前，你需要建立一个<a class="ae jg" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> GCP </a>账户，该账户提供300美元的免费积分。这些信用提供了足够的资金来启动和运行各种GCP工具。您还需要创建一个新的GCP项目，如下图所示。我们将创建一个项目，其名称为<code class="fe nl nm nn no b">serving</code>，完整的项目id为<code class="fe nl nm nn no b">serving-268422</code>。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/72c0b953fcea3268ac14835f797bca5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*iwFR4VhSB1Ff5XZ44I8-7w.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">在GCP创建一个新项目。</p></figure><p id="0e1e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我推荐使用Linux环境来开发Python应用程序，因为Docker和Gunicorn最适合这些环境。如果您安装了以下应用程序并设置了命令行访问，您应该能够理解:</p><ul class=""><li id="b983" class="lz ma jj la b lb lc le lf lh mb ll mc lp md lt nq mf mg mh bi translated"><a class="ae jg" href="https://www.python.org/downloads/release/python-380/" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> python </strong> </a>:我们将用于模型服务的语言运行时。</li><li id="8235" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt nq mf mg mh bi translated"><a class="ae jg" href="https://pip.pypa.io/en/stable/installing/" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> pip </strong> </a>:我们将安装额外的GCP python客户端库。</li><li id="04af" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt nq mf mg mh bi translated"><a class="ae jg" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> docker </strong> </a>:用于封装我们的模型服务端点。</li><li id="525e" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt nq mf mg mh bi translated"><a class="ae jg" href="https://cloud.google.com/deployment-manager/docs/step-by-step-guide/installation-and-setup" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> gcloud </strong> </a> : GCP命令行工具。</li></ul><p id="b886" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不会深究安装这些应用程序的细节，因为安装会因您的计算环境而有很大的不同。需要注意的一点是，gcloud工具会在幕后安装Python 2.7，因此请确保您的命令行Python版本不会受到此安装的影响。设置好<code class="fe nl nm nn no b">glcoud</code>之后，您可以使用以下命令创建一个凭证文件，用于对GCP的编程访问:</p><pre class="lv lw lx ly gt nr no ns nt aw nu bi"><span id="6920" class="mn mo jj no b gy nv nw l nx ny">gcloud config set project serving-268422<br/>gcloud auth login<br/>gcloud init<br/>gcloud iam service-accounts create serving<br/>gcloud projects add-iam-policy-binding serving-268422 --member   <br/>    "serviceAccount:<a class="ae jg" href="mailto:serving@serving-268420.iam.gserviceaccount.com" rel="noopener ugc nofollow" target="_blank">serving@serving-268422.iam.gserviceaccount.com</a>" <br/>    --role "roles/owner"<br/>gcloud iam service-accounts keys create serving.json <br/>    --iam-account <a class="ae jg" href="mailto:serving@serving-268420.iam.gserviceaccount.com" rel="noopener ugc nofollow" target="_blank">serving@serving-268422.iam.gserviceaccount.com</a></span></pre><p id="65a6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该脚本将创建一个名为<code class="fe nl nm nn no b">serving</code>的新服务帐户，可以访问您的GCP资源。最后一步创建了一个名为<code class="fe nl nm nn no b">serving.json</code>的凭证文件，我们将用它来连接Stackdriver之类的服务。接下来，我们将使用pip在Google Cloud中安装用于日志记录和监控的Python库，以及使用Python作为端点托管ML模型的标准库。</p><pre class="lv lw lx ly gt nr no ns nt aw nu bi"><span id="2c48" class="mn mo jj no b gy nv nw l nx ny">pip install google-cloud-logging<br/>pip install google-cloud-monitoring</span><span id="0228" class="mn mo jj no b gy nz nw l nx ny">pip install pandas<br/>pip install scikit-learn<br/>pip install flask <br/>pip install gunicorn</span></pre><p id="91a9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在已经设置好了构建和监控服务于ML模型的web服务所需的工具。</p><h2 id="0799" class="mn mo jj bd mp mq mr dn ms mt mu dp mv lh mw mx my ll mz na nb lp nc nd ne nf bi translated">2.模特服务用烧瓶</h2><p id="954d" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">为了演示如何将预测模型作为端点，我们将使用scikit-learn训练一个逻辑回归模型，然后使用Flask公开该模型。接下来，我们将使用Gunicorn使我们的服务成为多线程的，并扩展到更大的请求量。</p><p id="eee6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">服务于模型请求的示例web应用程序的完整代码如下面的代码片段所示。代码首先直接从GitHub获取一个训练数据集，然后用scikit-learn构建一个逻辑回归模型。接下来，<code class="fe nl nm nn no b">predict</code>函数用于定义服务模型请求的端点。传入的参数(<em class="oa"> G1，G2，G3，…，G10 </em>)从JSON表示转换成一个只有一行的Pandas dataframe。这些变量中的每一个都跟踪客户过去是否购买过特定的产品，并且输出是客户购买新产品的倾向。dataframe被传递给fitted模型对象以生成倾向得分，该倾向得分作为JSON有效载荷被返回给发出模型服务请求的客户机。关于这段代码的更多细节，请参考我之前关于将<a class="ae jg" rel="noopener" target="_blank" href="/models-as-web-endpoints-162cb928a9e6">模型作为web端点</a>的文章。</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8915" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设这个文件被命名为<code class="fe nl nm nn no b">serving.py</code>，我们可以通过运行下面的命令来测试这个应用程序:<code class="fe nl nm nn no b">python serving.py</code>。为了测试服务是否正常工作，我们可以使用Python中的请求模块:</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="623a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行该代码块的输出如下所示。结果显示web请求是成功的，并且模型为样本客户提供了<em class="oa"> 0.0673 </em>的倾向得分。</p><pre class="lv lw lx ly gt nr no ns nt aw nu bi"><span id="420f" class="mn mo jj no b gy nv nw l nx ny"><strong class="no jk">&gt;&gt;&gt; print(result)<br/></strong>&lt;Response [200]&gt;</span><span id="9bd2" class="mn mo jj no b gy nz nw l nx ny"><strong class="no jk">&gt;&gt;&gt; print(result.json())<br/></strong>{'response': '0.06730006696024807', 'success': True}</span></pre><p id="702c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Flask使用单个进程来服务web请求，这限制了端点可以服务的流量。为了扩展到更多的请求，我们可以将Flask与一个WSGI服务器(比如Gunicorn)结合使用。要使用Gunicorn运行模型服务，我们只需将文件名传递给Gunicorn，如下所示。</p><pre class="lv lw lx ly gt nr no ns nt aw nu bi"><span id="1c37" class="mn mo jj no b gy nv nw l nx ny">gunicorn --bind 0.0.0.0 serving:app</span></pre><p id="9cca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行此命令后，您将在端口8000上运行一个服务。为了测试服务是否正常工作，您可以更改上面的请求片段，使用端口8000而不是端口5000。</p><h2 id="d484" class="mn mo jj bd mp mq mr dn ms mt mu dp mv lh mw mx my ll mz na nb lp nc nd ne nf bi translated">3.集装箱模型</h2><p id="c399" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">我们现在有了一个在本地机器上运行的模型服务应用程序，但是我们需要一种分发服务的方法，以便它可以扩展到大量的请求。虽然可以使用云提供商提供硬件来手动分发模型服务，但Kubernetes等工具提供了完全托管的方法来设置机器以服务请求。我们将使用Docker来封装应用程序，然后使用GKE托管服务。</p><p id="536f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">容器化应用程序的docker文件如下所示。我们从Ubuntu环境开始，首先安装Python和pip。接下来，我们安装所需的库，并复制应用程序代码和凭证文件。最后一个命令运行Gunicorn，在端口8000上公开模型服务应用程序。</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3a6b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的命令说明了如何构建容器，在您的机器上查看生成的Docker图像，并以交互模式在本地运行容器。在本地测试容器以确保您在应用程序中使用的服务按预期工作是很有用的。要测试应用程序是否工作，请将上面的请求片段更新为使用端口80。</p><pre class="lv lw lx ly gt nr no ns nt aw nu bi"><span id="c785" class="mn mo jj no b gy nv nw l nx ny">sudo docker image build -t "model_service" .<br/>sudo docker images<br/>sudo docker run -it -p 80:8000 model_service</span></pre><h2 id="3d6d" class="mn mo jj bd mp mq mr dn ms mt mu dp mv lh mw mx my ll mz na nb lp nc nd ne nf bi translated">4.发布到容器注册表</h2><p id="dfce" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">要在Kubernetes中使用我们的容器，我们需要将图像推送到Docker注册中心，Kubernetes pods可以从那里提取图像。GCP提供了一种叫做容器注册的服务来提供这种功能。要将我们的容器推到注册表中，运行下面要点中显示的命令。</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="901d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面代码片段中的第一个命令将凭证文件传递给<code class="fe nl nm nn no b">docker login</code>命令，以便登录到容器注册中心。下一个命令用您的GCP帐户ID标记图像，最后一个命令将图像推送到注册表。运行这些命令后，您可以浏览到GCP控制台的容器注册表部分，验证映像是否已成功推送。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/fe7b62a6aac83fb3501dc4d416b17157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m2YV6sg03baueqFDEkJoBQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">集装箱注册中的模型服务图像。</p></figure><h2 id="1ca5" class="mn mo jj bd mp mq mr dn ms mt mu dp mv lh mw mx my ll mz na nb lp nc nd ne nf bi translated">5.与GKE一起部署</h2><p id="abb4" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">我们现在可以启动Kubernetes集群，在分布式环境中托管模型服务应用程序。第一步是通过浏览GCP控制台中的“Kubernetes Engine”选项卡并单击“create cluster”来设置集群。将<code class="fe nl nm nn no b">model-serving</code>指定为集群名称，选择2个节点的池大小，并将<em class="oa"> g1-small </em>实例类型用于节点池。这将创建一个小集群，我们可以使用它进行测试。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/75033b3b32800c0adab55f51093b9055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSg1AbKyEgs6ZfsApJ1y3Q.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">与GKE一起创造了一个库伯内特集群。</p></figure><p id="1096" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦集群启动，我们就可以使用我们的容器创建一个工作负载。要将我们的映像作为应用程序在GKE上运行，请执行以下步骤:</p><ol class=""><li id="dbe8" class="lz ma jj la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">从“Kubernetes引擎”中点击“工作负载”</li><li id="8f4b" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">单击“部署”</li><li id="8366" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">点击“图像路径”下的“选择”</li><li id="cef4" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">选择带有最新标签的<em class="oa">型号_服务</em>图像</li><li id="fce4" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">点击“继续”</li><li id="518b" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">分配一个应用程序名称“serving”</li><li id="d26d" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在“集群”下，选择您新创建的集群</li><li id="45b9" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">单击“部署”</li></ol><p id="532d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个过程可能需要几分钟才能完成。完成后，您可以单击工作负载来浏览管理工作负载的pod的状态。该映像应该部署到三个单元，如下所示。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi of"><img src="../Images/82938771357c7c9fc38692fbc3b42bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ne17Ynm47jEZQQZAJFexNg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">模型在GKE应用的三个实例。</p></figure><h2 id="6e09" class="mn mo jj bd mp mq mr dn ms mt mu dp mv lh mw mx my ll mz na nb lp nc nd ne nf bi translated">6.公开服务</h2><p id="316b" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">我们现在有了在分布式环境中运行的服务，但是还没有一种与服务交互的方法。我们需要设置一个负载平衡器来将模型服务公开给开放的web。执行以下步骤为服务设置负载平衡器:</p><ol class=""><li id="ec95" class="lz ma jj la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">选择“服务”工作负载</li><li id="9d83" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">点击“操作”,然后点击“暴露”</li><li id="a793" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">为“端口”选择80，为“目标端口”选择8000</li><li id="b796" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在“服务类型”下，选择“负载平衡器”</li><li id="ed1c" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">点击“暴露”</li></ol><p id="99a4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要使用负载平衡器，请单击您的工作负载并浏览到“公开服务”一节。您现在应该看到一个负载平衡器设置了一个公开服务的公共IP地址。您可以通过修改请求片段以使用负载平衡器的IP来测试服务。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi og"><img src="../Images/47ff377b794e0118b74577a4bfcd580b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*hxApZmwTq813OJdOjZeUAQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">服务工作负载的负载平衡器。</p></figure><p id="3c65" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在已经具备了可扩展模型托管服务的许多要素。如果需要，系统现在可以扩展到更多的单元，我们可以增加节点池大小和副本数量，以使用GKE处理大流量。此外，如果在系统中检测到故障，新的pod将会启动，因此GKE为我们的服务提供高可用性。我们在该系统的开发操作中缺少的关键部分是警报和监控。我们需要知道系统何时出现故障或异常，并快速做出响应。</p><h2 id="4765" class="mn mo jj bd mp mq mr dn ms mt mu dp mv lh mw mx my ll mz na nb lp nc nd ne nf bi translated">7.使用Stackdriver进行监控</h2><p id="aabd" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">GCP现在提供了Stackdriver的托管版本，这是一种提供日志记录、监控、警报和事件跟踪的服务。我们将使用日志功能来记录服务器状态更新，我们将使用监控功能来跟踪系统的请求量。为了实现这个功能，我们将使用Stackdriver的<a class="ae jg" href="https://cloud.google.com/python/docs/stackdriver" rel="noopener ugc nofollow" target="_blank"> Python接口</a>。</p><p id="ddd3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的代码片段展示了如何为Stackdriver设置一个日志客户端，并向服务记录一条文本消息。要在本地工作时设置日志客户端，您需要提供一个凭证文件，但是在GCP的计算实例或GKE上工作时，这一步可能不是必需的。</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="4feb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要浏览应用程序的日志，请在GCP控制台中搜索“日志”，然后选择“日志查看器”选项卡。选择“Global”作为资源，您应该会看到如下所示的日志消息。在下一节中，我们将使用日志记录来跟踪新的服务器实例何时启动，并记录导致异常的模型请求。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/ab783ff112a3a75bf751e6c954c99437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_esKmrpU1Wm3Y3ll6-W7A.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">在Stackdriver中查看服务日志。</p></figure><p id="fe45" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Stackdriver提供了记录定制指标的能力，比如记录每分钟模型服务请求的数量。要使用定制指标，您需要首先创建一个定制指标，如下面的代码片段所示。该代码首先设置一个监控客户机，为记录定义一个新的度量，然后提供一个样本数据点。一旦设置了新的指标，您就可以在每台服务器上每分钟记录一条记录。</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="0b8b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要查看自定义指标，请在GCP控制台中搜索“Stakdriver Monitoring API ”,然后选择“Metrics explorer”。通过搜索“custom”并选择“Global”作为资源来选择指标。您应该会看到一个图表，它绘制了一段时间内自定义指标的值。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/841aeae0d0a39596e9f528bba52d6128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ITap_F-fMDYmTxXlLMOmjA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用Stackdriver监控功能跟踪每分钟的请求数。</p></figure><p id="3a86" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下一节中，我们将使用定制的指标来记录每分钟有多少模型请求被处理。在最后一节中，我们将展示如何使用自定义指标来设置警报。</p><h2 id="2806" class="mn mo jj bd mp mq mr dn ms mt mu dp mv lh mw mx my ll mz na nb lp nc nd ne nf bi translated">8.执行滚动更新</h2><p id="02b3" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">现在，我们已经拥有了为模型服务应用程序设置警报和监控所需的所有组件。Flask应用程序的完整代码清单如下所示。</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="42fc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是最初应用程序的主要变化:</p><ol class=""><li id="2aee" class="lz ma jj la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">我们为日志记录和监控引入了额外的库</li><li id="5ff2" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">我们根据IP和一个随机值为服务创建一个唯一的ID</li><li id="46d7" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">我们设置了日志记录和监控客户端，并记录服务器启动消息</li><li id="8832" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">我们创建一个计数器变量来跟踪请求计数</li><li id="f2ef" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">我们定义了一个函数来编写自定义指标</li><li id="99cc" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">我们定义一个每秒运行一次的函数，将请求计数作为自定义指标传递给Stackdriver并重置计数</li><li id="0867" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">我们用导致失败的try/except块和日志请求来包装Flask请求</li><li id="e55b" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">我们为每个web请求更新计数器值</li></ol><p id="472e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们在本地测试完脚本，我们将需要重新构建容器，并向集群推送一个新版本。第一步是重新构建容器，并将更新后的映像推送到容器注册表，如下所示:</p><pre class="lv lw lx ly gt nr no ns nt aw nu bi"><span id="10ca" class="mn mo jj no b gy nv nw l nx ny">sudo docker image build -t "model_service" .<br/>sudo docker tag model_service us.gcr.io/serving-268422/model_service<br/>sudo docker push us.gcr.io/serving-268422/model_service</span><span id="dc73" class="mn mo jj no b gy nz nw l nx ny"><strong class="no jk"># Output<br/></strong>latest: digest: sha256:<strong class="no jk">286fe62e19368d37afd792b5bc6196dd5b223eada00e992d32ed6f66a4de939d</strong> size: 3048</span></pre><p id="4ddd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更新映像后，push命令将输出一个摘要，我们可以用它在GKE上推出容器的新版本。第一步是选择上面显示的摘要的粗体部分。接下来，选择您的工作负载，单击“ACTIONS”，然后单击“Rolling update”。用新的容器摘要替换“图像”下的摘要，然后按更新。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/2abe807a0199b56369999e1445c2de45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*E6-v-CHFUnt2-gO8bNHO3g.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">用滚动更新来更新容器。</p></figure><p id="ad1c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用滚动更新的目的是防止在执行系统更新时服务出现任何停机。下图显示了GKE如何在运行旧版本的同时为新的服务版本构建新的pod。一旦单元被加速旋转以匹配当前的工作负载，旧的单元版本将被删除。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/b3a2f9bc63fbd748831ebbb3154d3dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*e2HqiUa0xYg1l6q8eRuu4w.png"/></div></figure><p id="5cf7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">GKE为执行滚动更新提供了强大的功能，降低了GCP上基于容器的数据产品开发运维的复杂性。</p><h2 id="9a84" class="mn mo jj bd mp mq mr dn ms mt mu dp mv lh mw mx my ll mz na nb lp nc nd ne nf bi translated">9.使用Stackdriver进行事件跟踪</h2><p id="1db7" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">我们将在本文中讨论的最后一个DevOps问题是设置警报和响应事件。使用Stackdriver记录定制指标的一个主要好处是，我们可以为不同的问题设置警报，例如缺少检测到的数据或太多的传入请求。我们将通过执行以下步骤，设置一个当系统每分钟收到10个以上请求时触发的警报:</p><ol class=""><li id="3c40" class="lz ma jj la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">在GCP控制台中搜索“Stakdriver Monitoring API”</li><li id="65af" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">单击“警报”选项卡</li><li id="635a" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">单击“创建策略”</li><li id="fd96" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">分配一个名称，“太多请求”</li><li id="2b4f" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">点击“添加条件”</li><li id="3116" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在“目标”下，选择自定义指标和“全局”作为资源</li><li id="8fac" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在“配置”下，将阈值设置为10</li><li id="f8ce" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">选择持续时间的“最近值”</li><li id="74c5" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">点击“添加”</li><li id="d147" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在“通知”下，单击“添加通知频道”</li><li id="fc1d" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">选择电子邮件并输入您的电子邮件地址</li><li id="8858" class="lz ma jj la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">点击“添加”，然后点击“保存”。</li></ol><p id="d999" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在设置了一个警报，如果自定义指标值超过每秒10个请求，就会触发一个事件。我们现在可以通过向负载平衡器URL发送10个以上的请求来生成警报。向端点发送过多流量的示例如下所示。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/a4f76fdb6ee7c7dae555109d29429942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEqzqONLiVdERhJ5tkCU-g.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">超过警报策略的请求计数。</p></figure><p id="f044" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几分钟后，Stackdriver将检测到违反了警报策略，并触发一个事件。您将收到为警报设置的每个频道的通知。通过电子邮件发送的通知示例如下所示。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/eb02829de27aa67a74790033e7747bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcH6TEw_MJViCt2eSgPwow.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">警报策略违规的电子邮件通知</p></figure><p id="87c0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果触发了警报，您可以浏览Stackdriver中的“alerting”选项卡，查看状态更新并提供事件的附加注释。对于这个事件，我们可能会决定更改工作负载的自动缩放设置。对于其他类型的实例，比如停机，我们可能会部署一个新版本，或者为当前版本设置新的副本。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/8c1b628c5e89e1055171ddc29cbe7d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FdSboDCPBDhewBQ0pDB5EQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">在堆栈驱动程序警报选项卡中查看事件。</p></figure><p id="2a62" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Stackdriver中的警报功能提供了许多有助于数据科学家拥有更多数据管道的功能。除了电子邮件提醒之外，您还可以使用其他渠道(如Slack、PagerDuty或SMS)向团队通知提醒。</p><h2 id="b623" class="mn mo jj bd mp mq mr dn ms mt mu dp mv lh mw mx my ll mz na nb lp nc nd ne nf bi translated">结论</h2><p id="93c6" class="pw-post-body-paragraph ky kz jj la b lb ng kk ld le nh kn lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">在这篇文章中，我们介绍了数据科学团队承担更多将ML模型投入生产的DevOps责任所必需的许多构建模块。我们在这篇文章中提到的关键特性是滚动更新和提醒。当使用GKE时，GCP提供了开箱即用的功能，这使得数据科学团队能够拥有更多部署预测模型的流程。</p><p id="6c6b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">借助这些工具，数据科学团队可以构建在出现问题时触发警报的数据产品，调查日志以确定问题的根源，并部署新的模型版本，同时最大限度地减少停机时间。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="aedb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本·韦伯是Zynga的一名杰出的数据科学家。我们正在<a class="ae jg" href="https://www.zynga.com/job-listing-category/data-analytics-user-research/" rel="noopener ugc nofollow" target="_blank">招聘</a>！</p></div></div>    
</body>
</html>