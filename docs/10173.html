<html>
<head>
<title>Simple Little Tables with Matplotlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Matplotlib 的简单小表格</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/simple-little-tables-with-matplotlib-9780ef5d0bc4?source=collection_archive---------1-----------------------#2020-07-18">https://towardsdatascience.com/simple-little-tables-with-matplotlib-9780ef5d0bc4?source=collection_archive---------1-----------------------#2020-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7155" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何创建一个漂亮的 Pyplot 表的注释示例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/85d20751660c3ef15b113e3fa4fe70e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALunX6D3tSlatdprOzKS8g.png"/></div></div></figure><p id="b3de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有时，我需要为包含几行和几列数据的文档创建一个图像。像大多数人一样，我将只使用屏幕截图来创建图像，但这种方法不太适合自动化任务，需要手工调整才能呈现。荒谬的是，我正在用熊猫和 Matplotlib 在我的 Jupyter 笔记本上工作，我正在截图以捕捉幻灯片和书面报告的表格。Matplotlib 呈现漂亮的图形。为什么不是漂亮的小桌子？</p><p id="f9df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一种替代方法是使用 LaTeX 生成报告，LaTeX 具有强大的表格功能。采用 LaTeX 进行报告，只是为了渲染一个小表格，这种做法有些矫枉过正，而且常常是徒劳的。我真的很想用 Matplotlib 生成我的小网格，标题居中；没有无关文字；漂亮、干净的边框；可能还有一个小小的日期页脚。</p><p id="b377" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于 Jupyter 的输出单元渲染，熊猫可以在 Jupyter 笔记本上输出看起来不错的数据帧。它甚至可以使用<code class="fe ln lo lp lq b">pandas.Dataframe.style</code>库来设计这些熊猫数据帧的样式。使用这些工具构建样式化表格的挑战在于它们以 HTML 呈现输出。将文件转换成图像格式需要调用其他外部工具的工作流，比如<code class="fe ln lo lp lq b"><a class="ae lr" href="https://wkhtmltopdf.org" rel="noopener ugc nofollow" target="_blank">wkhtmltoimage</a></code>，将 HTML 转换成图像。</p><p id="0d35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Matplotlib 可以将图表保存为图像。如果你搜索 Matplotlib 文档，你会发现它有一个<code class="fe ln lo lp lq b">matplotlib.pyplot.table</code>包，看起来很有希望。它是有用的。事实上，我在这篇文章中使用了它。挑战在于<code class="fe ln lo lp lq b">matplotlib.pyplot.table</code>创建的表格通常挂在堆叠的条形图下面，以向读者提供对上面数据的洞察。您希望只显示图表，并且希望图表看起来很漂亮。</p><p id="1f40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当试图使用<code class="fe ln lo lp lq b">matplotlib.pyplot.table</code>时，你可能会注意到的第一件事是，表格相当难看，并且不能很好地管理垂直单元格填充。第二，如果您试图隐藏图形，只显示表格网格，对齐问题就会暴露出来，使您永远无法得到您想要的漂亮的小表格。让桌子看起来漂亮需要一些工作，我将与你分享我自己做这项工作的心得。</p><h1 id="6972" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Matplotlib 表示例</h1><p id="8f15" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">Matplotlib <code class="fe ln lo lp lq b">pyplot.table</code>示例代码创建了一个表，但是没有展示如何用一个简单的表来显示数据。它生成一个表格，用作堆叠条形图的扩展。如果你跟随你的直觉，只隐藏图表，你会得到一个格式很差的图像，不适合你的文章或幻灯片演示。</p><p id="a1f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将带您一步一步地将 Matplotlib 示例编写器提供的示例转换为您项目的一些简单表格代码。我解释了我在这一过程中所做的更改，这应该有助于您进行改进。我在文章的最后提供了完整的代码。</p><p id="8298" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从<a class="ae lr" href="https://matplotlib.org/3.1.1/gallery/misc/table_demo.html#sphx-glr-gallery-misc-table-demo-py" rel="noopener ugc nofollow" target="_blank">示例</a>中，您可以看到表格功能用于显示与相关堆积条形图相关的数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/628557e65b1e7d9e00671e9426c811b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EorrJ1Zd19X8lYBMD_y_kg.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">Matplotlib 表格演示示例(图片由作者提供)</p></figure><p id="c8ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例的源代码(来自 Matplotlib <a class="ae lr" href="https://matplotlib.org/3.1.1/gallery/misc/table_demo.html#sphx-glr-gallery-misc-table-demo-py" rel="noopener ugc nofollow" target="_blank">表格演示</a>):</p><pre class="kg kh ki kj gt mu lq mv mw aw mx bi"><span id="907e" class="my lt iq lq b gy mz na l nb nc">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="b2cb" class="my lt iq lq b gy nd na l nb nc">data = [[ 66386, 174296,  75131, 577908,  32015],<br/>        [ 58230, 381139,  78045,  99308, 160454],<br/>        [ 89135,  80552, 152558, 497981, 603535],<br/>        [ 78415,  81858, 150656, 193263,  69638],<br/>        [139361, 331509, 343164, 781380,  52269]]</span><span id="36d7" class="my lt iq lq b gy nd na l nb nc">columns = ('Freeze', 'Wind', 'Flood', 'Quake', 'Hail')<br/>rows = ['%d year' % x for x in (100, 50, 20, 10, 5)]</span><span id="6e9f" class="my lt iq lq b gy nd na l nb nc">values = np.arange(0, 2500, 500)<br/>value_increment = 1000</span><span id="b80b" class="my lt iq lq b gy nd na l nb nc"># Get some pastel shades for the colors<br/>colors = plt.cm.BuPu(np.linspace(0, 0.5, len(rows)))<br/>n_rows = len(data)</span><span id="adef" class="my lt iq lq b gy nd na l nb nc">index = np.arange(len(columns)) + 0.3<br/>bar_width = 0.4</span><span id="b81c" class="my lt iq lq b gy nd na l nb nc"># Initialize the vertical-offset for the stacked bar chart.<br/>y_offset = np.zeros(len(columns))</span><span id="3a7d" class="my lt iq lq b gy nd na l nb nc"># Plot bars and create text labels for the table<br/>cell_text = []<br/>for row in range(n_rows):<br/>    plt.bar(index, data[row], bar_width, bottom=y_offset, color=colors[row])<br/>    y_offset = y_offset + data[row]<br/>    cell_text.append(['%1.1f' % (x / 1000.0) for x in y_offset])<br/># Reverse colors and text labels to display the last value at the top.<br/>colors = colors[::-1]<br/>cell_text.reverse()</span><span id="dfcd" class="my lt iq lq b gy nd na l nb nc"># Add a table at the bottom of the axes<br/>the_table = plt.table(cellText=cell_text,<br/>                      rowLabels=rows,<br/>                      rowColours=colors,<br/>                      colLabels=columns,<br/>                      loc='bottom')</span><span id="c187" class="my lt iq lq b gy nd na l nb nc"># Adjust layout to make room for the table:<br/>plt.subplots_adjust(left=0.2, bottom=0.2)</span><span id="870c" class="my lt iq lq b gy nd na l nb nc">plt.ylabel("Loss in ${0}'s".format(value_increment))<br/>plt.yticks(values * value_increment, ['%d' % val for val in values])<br/>plt.xticks([])<br/>plt.title('Loss by Disaster')</span><span id="46b7" class="my lt iq lq b gy nd na l nb nc"># plt.show()</span><span id="b7ee" class="my lt iq lq b gy nd na l nb nc"># Create image. plt.savefig ignores figure edge and face colors, so map them.<br/>fig = plt.gcf()<br/>plt.savefig('pyplot-table-original.png',<br/>            bbox_inches='tight',<br/>            dpi=150<br/>            )</span></pre><h1 id="8113" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">整理数据代码并删除图形生成</h1><p id="81d8" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">现在，让我们开始工作吧。首先，我将打破表的图表。我根据自己的喜好重新格式化了图表数据，并删除了特定于堆积条形图的数据。这一步对你来说是可选的。当我从代码中的 Python 列表加载少量数据时，我更喜欢在数据数组中包含标签，并在适当的时候弹出它们。当我几个月后回来时，我可以更容易地阅读它。您可能会从外部 CSV 文件或数据库导入数据，并在 Pandas 数据框架中对其进行操作。将数据放在一个二维列表中使这个例子变得简单。</p><p id="f114" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还删除了<code class="fe ln lo lp lq b">plt.show()</code>指令，并添加了将图像写入 png 文件的代码。如果在调用<code class="fe ln lo lp lq b">plt.savefig()</code>之前调用<code class="fe ln lo lp lq b">plt.show()</code>，图像将会是空白的，因为<code class="fe ln lo lp lq b">plt.show()</code>重置了 pyplot 图形对象引用。记住<code class="fe ln lo lp lq b">plt.savefig()</code>可以通过检测你提供的文件扩展名来输出其他图像类型(jpeg，svg，eps 等。).</p><p id="a1a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">注意:</strong>在我的实验中，我还对一些数据和标签做了微小的改动。为了与原始代码保持一致，我忘记在发布之前回滚它们。例如，“100 年”变成了“40 年”</p><pre class="kg kh ki kj gt mu lq mv mw aw mx bi"><span id="5cb6" class="my lt iq lq b gy mz na l nb nc">data =  [<br/>            [         'Freeze', 'Wind', 'Flood', 'Quake', 'Hail'],<br/>            [ '5 year',  66386, 174296,   75131,  577908,  32015],<br/>            ['10 year',  58230, 381139,   78045,   99308, 160454],<br/>            ['20 year',  89135,  80552,  152558,  497981, 603535],<br/>            ['30 year',  78415,  81858,  150656,  193263,  69638],<br/>            ['40 year', 139361, 331509,  343164,  781380,  52269],<br/>        ]</span><span id="d0ab" class="my lt iq lq b gy nd na l nb nc"># Pop the headers from the data array<br/>column_headers = data.pop(0)<br/>row_headers = [x.pop(0) for x in data]</span><span id="f6c4" class="my lt iq lq b gy nd na l nb nc"># Table data needs to be non-numeric text. Format the data<br/># while I'm at it.<br/>cell_text = []<br/>for row in data:<br/>    cell_text.append([f'{x/1000:1.1f}' for x in row])</span><span id="762b" class="my lt iq lq b gy nd na l nb nc">...</span><span id="3cf1" class="my lt iq lq b gy nd na l nb nc">fig = plt.gcf()<br/>plt.savefig('pyplot-table-original.png',<br/>            bbox_inches='tight',<br/>            dpi=150<br/>            )</span></pre><h1 id="e489" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">修复问题</h1><p id="d78b" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">让我们开始隔离和整理桌子。这需要几个步骤。我会带你穿过它们。</p><h2 id="4ffb" class="my lt iq bd lu ne nf dn ly ng nh dp mc la ni nj me le nk nl mg li nm nn mi no bi translated">隐藏 x 和 y 轴</h2><p id="cbfd" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">首先，让我们隐藏 x 和 y 轴，以及它们所有的刻度和标签。</p><pre class="kg kh ki kj gt mu lq mv mw aw mx bi"><span id="b327" class="my lt iq lq b gy mz na l nb nc">ax = plt.gca()<br/>ax.get_xaxis().set_visible(False)<br/>ax.get_yaxis().set_visible(False)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/22fe793d94c1b68cb616837f3b0f9c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6fmezzgfnCyoqx-RTDDDA.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">x 轴和 y 轴已移除(图片由作者提供)</p></figure><h2 id="4dab" class="my lt iq bd lu ne nf dn ly ng nh dp mc la ni nj me le nk nl mg li nm nn mi no bi translated">隐藏轴边框</h2><p id="182a" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">坐标轴消失了，但我们留下了一个围绕条形图的边界。我们可以很容易地关掉它。</p><pre class="kg kh ki kj gt mu lq mv mw aw mx bi"><span id="9021" class="my lt iq lq b gy mz na l nb nc">plt.box(on=None)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/8e8529e649d2ae6511025270e65d2448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0nf1wQMIuFgkvB9JKQeTQ.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">条形图边框已禁用(图片由作者提供)</p></figure><h2 id="3528" class="my lt iq bd lu ne nf dn ly ng nh dp mc la ni nj me le nk nl mg li nm nn mi no bi translated">把桌子放在图的中央</h2><p id="2269" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">它越来越清晰，但是我们看到标题和表格之间有大量的空白。我们所要做的就是将现有的<code class="fe ln lo lp lq b">bottom</code>校准改为<code class="fe ln lo lp lq b">center</code>。这将使表格在隐藏轴区域居中。我们也应该从例子中去掉支线剧情的位置调整。</p><p id="7ddb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">删除此行:</p><pre class="kg kh ki kj gt mu lq mv mw aw mx bi"><span id="08de" class="my lt iq lq b gy mz na l nb nc">plt.subplots_adjust(left=0.2, bottom=0.2)</span></pre><p id="e36b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并将<code class="fe ln lo lp lq b">plt.table</code>线改为居中<code class="fe ln lo lp lq b">loc</code>:</p><pre class="kg kh ki kj gt mu lq mv mw aw mx bi"><span id="6811" class="my lt iq lq b gy mz na l nb nc">the_table = plt.table(cellText=cell_text,<br/>                      rowLabels=row_headers,<br/>                      rowColours=rcolors,<br/>                      colLabels=column_headers,<br/>                      loc='center')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/670350f5962bbc3ed797a1e6775f9a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cgExMqB6XFmknBjUctUW1w.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">将表格居中(图片由作者提供)</p></figure><h2 id="b3c9" class="my lt iq bd lu ne nf dn ly ng nh dp mc la ni nj me le nk nl mg li nm nn mi no bi translated">缩放单元格以获得更多填充</h2><p id="444a" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">这一改变很好地把桌子向上拉。现在，让我们解决单元格内过于紧凑的垂直空间。<code class="fe ln lo lp lq b">pylot.table</code>不允许指定单元格的填充，但是我们可以用<code class="fe ln lo lp lq b">scale(x, y)</code>函数的<code class="fe ln lo lp lq b">y</code>参数将高度缩放 1.5 倍。这给了我们的细胞数据一点喘息的空间。您可以根据自己的喜好使用<code class="fe ln lo lp lq b">x</code>和<code class="fe ln lo lp lq b">y</code>值。</p><pre class="kg kh ki kj gt mu lq mv mw aw mx bi"><span id="47e2" class="my lt iq lq b gy mz na l nb nc">the_table.scale(1, 1.5)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/f264c4759e4300c01578c6e399e91e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCrMlGLx8b9hvVK6NoSljA.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">缩放表格(图片由作者提供)</p></figure><h2 id="c662" class="my lt iq bd lu ne nf dn ly ng nh dp mc la ni nj me le nk nl mg li nm nn mi no bi translated">设置列标题和行标题的样式</h2><p id="7be9" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">让我们设置列颜色，并将行标题水平对齐设置为<code class="fe ln lo lp lq b">right</code>。我们将填充两个颜色列表，一个用于每个行标题单元格，另一个用于每个列标题单元格。我们将只使用示例中使用的<code class="fe ln lo lp lq b">plt.cm.BuPm</code>颜色图，尽管对于装饰颜色来说，有比线性颜色图更好的选择。我们将在创建表格时设置行和列标签的颜色和对齐方式。</p><pre class="kg kh ki kj gt mu lq mv mw aw mx bi"><span id="5e28" class="my lt iq lq b gy mz na l nb nc">rcolors = plt.cm.BuPu(np.full(len(row_headers), 0.1))<br/>ccolors = plt.cm.BuPu(np.full(len(column_headers), 0.1))</span><span id="af31" class="my lt iq lq b gy nd na l nb nc">...</span><span id="5d7d" class="my lt iq lq b gy nd na l nb nc">the_table = plt.table(cellText=cell_text,<br/>                      rowLabels=row_headers,<br/>                      rowColours=rcolors,<br/>                      rowLoc='right',<br/>                      colColours=ccolors,<br/>                      colLabels=column_headers,<br/>                      loc='center')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/73d4566d6a15ac460d4e59d5f3b9bab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FwnjBhS8oJALMobASpqgAw.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">样式行和列标题(按作者排列的图像)</p></figure><h2 id="385c" class="my lt iq bd lu ne nf dn ly ng nh dp mc la ni nj me le nk nl mg li nm nn mi no bi translated">给人物造型</h2><p id="b700" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">我们可以显式声明图形，以便轻松控制其边框和背景颜色。我将在这里使用一些标记的颜色作为这种方法的例子，与上面使用的颜色图形成对比。我通常只使用白色作为背景，但是天蓝色很适合演示如何设置它的颜色。</p><pre class="kg kh ki kj gt mu lq mv mw aw mx bi"><span id="8618" class="my lt iq lq b gy mz na l nb nc">fig_background_color = 'skyblue'<br/>fig_border = 'steelblue'</span><span id="d1cc" class="my lt iq lq b gy nd na l nb nc">...</span><span id="466d" class="my lt iq lq b gy nd na l nb nc">plt.figure(linewidth=2,<br/>           edgecolor=fig_border,<br/>           facecolor=fig_background_color<br/>          )</span><span id="7229" class="my lt iq lq b gy nd na l nb nc">...</span><span id="70de" class="my lt iq lq b gy nd na l nb nc">plt.savefig('pyplot-table-figure-style.png',<br/>            bbox_inches='tight',<br/>            edgecolor=fig.get_edgecolor(),<br/>            facecolor=fig.get_facecolor(),<br/>            dpi=150<br/>            )</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/e981ffe5b5d86fc79b75c51556c12a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwrHkM0FZVkXo7gnNib61Q.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">样式边框和背景(图片由作者提供)</p></figure><h2 id="d795" class="my lt iq bd lu ne nf dn ly ng nh dp mc la ni nj me le nk nl mg li nm nn mi no bi translated">在图形上居中标题</h2><p id="6397" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">漂亮。像夏天一样。您可能注意到标题集中在轴数据上，不包括行标题。我们需要把它放在图的中心，修改三个代码。这些变化也提高了图中表格的居中一致性。</p><ol class=""><li id="a6ab" class="nr ns iq kt b ku kv kx ky la nt le nu li nv lm nw nx ny nz bi translated">使用<code class="fe ln lo lp lq b">plt.suptitle()`.</code>在图形上设置标题，而不是轴</li><li id="9f08" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">在图形声明中为<code class="fe ln lo lp lq b">tight_layout</code>设置一个小的填充值。既然我们现在在这里声明一个紧凑的布局，我们应该从<code class="fe ln lo lp lq b">savefig</code>中移除<code class="fe ln lo lp lq b">bbox='tight'</code>。把它留在里面似乎会破坏桌子在图中的居中。如果您在图像生成过程中对中有困难，可以尝试此<code class="fe ln lo lp lq b">bbox</code>设置。(实验人员:注意在<code class="fe ln lo lp lq b">save_fig</code>中设置<code class="fe ln lo lp lq b">pad_inches=1</code>与图形声明中调用的<code class="fe ln lo lp lq b">tight_layout={'pad':1}</code>效果不一样。总有一天，我会找出原因。)</li><li id="8621" class="nr ns iq kt b ku oa kx ob la oc le od li oe lm nw nx ny nz bi translated">可选地，在保存图形之前调用<code class="fe ln lo lp lq b">plt.draw()</code>。这可以解决图像渲染过程中图形边界裁剪和标题居中的问题。有时候没什么效果。</li></ol><pre class="kg kh ki kj gt mu lq mv mw aw mx bi"><span id="74da" class="my lt iq lq b gy mz na l nb nc">title_text = 'Loss by Disaster'</span><span id="cd26" class="my lt iq lq b gy nd na l nb nc">...</span><span id="5716" class="my lt iq lq b gy nd na l nb nc">plt.figure(linewidth=2,<br/>           edgecolor=fig_border,<br/>           facecolor=fig_background_color,<br/>           tight_layout={'pad':1}<br/>          )</span><span id="e35f" class="my lt iq lq b gy nd na l nb nc">...</span><span id="55a8" class="my lt iq lq b gy nd na l nb nc">plt.suptitle(title_text)</span><span id="130b" class="my lt iq lq b gy nd na l nb nc">...</span><span id="6721" class="my lt iq lq b gy nd na l nb nc">plt.draw()</span><span id="0dc6" class="my lt iq lq b gy nd na l nb nc">...</span><span id="b981" class="my lt iq lq b gy nd na l nb nc">plt.savefig('pyplot-table-tighten-figsize.png',<br/>            #bbox_inches='tight',<br/>            edgecolor=fig.get_edgecolor(),<br/>            facecolor=fig.get_facecolor(),<br/>            dpi=150<br/>            )</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/cd4e0c4ac01737aebbe435e7638801cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4KD44h6RZNRbgu8zVY8jQ.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">将标题居中(图片由作者提供)</p></figure><h1 id="633d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">添加页脚</h1><p id="74c8" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">我们将使用图形文本来创建一个页脚，并调整位置值，直到它看起来合适为止。</p><pre class="kg kh ki kj gt mu lq mv mw aw mx bi"><span id="9866" class="my lt iq lq b gy mz na l nb nc">footer_text = 'June 24, 2020'</span><span id="34cb" class="my lt iq lq b gy nd na l nb nc">...</span><span id="a095" class="my lt iq lq b gy nd na l nb nc">plt.figtext(0.95, 0.05, footer_text, horizontalalignment='right', size=6, weight='light')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/939f4f27ad3615c27115ec4ed11db8f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOWzm6WJ_fef_R_eF9UOYA.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">添加页脚(作者图片)</p></figure><h1 id="3ba6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">可选:使用明确的 figsize 缩小空间</h1><p id="0101" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">表格图像看起来很好，但是自动布局并不总是产生我喜欢的空白。玩一个明确的数字大小往往可以拨入这个。猜测数字大小需要实验，并且可以改善或降低您的表格图像。</p><p id="e47c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能还需要在<code class="fe ln lo lp lq b">bbox_inches='tight'</code>中添加回<code class="fe ln lo lp lq b">savefig</code>来重新计算边界框。否则，图像可能没有正确的左右填充。您可能会发现图像在 Jupyter 笔记本输出单元格中看起来很好，但在您保存的图像中没有对齐。让所有渲染者满意是一种平衡行为。您应该经常检查最终的输出图像，即使它们在 IDE 的预览中看起来很棒。</p><pre class="kg kh ki kj gt mu lq mv mw aw mx bi"><span id="9e2c" class="my lt iq lq b gy mz na l nb nc">plt.figure(linewidth=2,<br/>           edgecolor=fig_border,<br/>           facecolor=fig_background_color,<br/>           tight_layout={'pad':1},<br/>           figsize=(5,3)<br/>          )</span><span id="4d34" class="my lt iq lq b gy nd na l nb nc">...</span><span id="73df" class="my lt iq lq b gy nd na l nb nc">plt.savefig('pyplot-table-tighten-figsize.png',<br/>            bbox_inches='tight',<br/>            edgecolor=fig.get_edgecolor(),<br/>            facecolor=fig.get_facecolor(),<br/>            dpi=150<br/>            )</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/1e698d8ff7f1fa7f0487077410667aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kE2JfP2aIKIPnHl0X2IEug.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">带有明确 figsize 的更紧凑的空白(图片由作者提供)</p></figure><h1 id="e7c2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最终源代码</h1><p id="0fe1" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">这个最终源代码不包括明确的图形大小声明。我喜欢更宽敞的外观。</p><pre class="kg kh ki kj gt mu lq mv mw aw mx bi"><span id="dfb5" class="my lt iq lq b gy mz na l nb nc">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="e866" class="my lt iq lq b gy nd na l nb nc">title_text = 'Loss by Disaster'<br/>footer_text = 'June 24, 2020'<br/>fig_background_color = 'skyblue'<br/>fig_border = 'steelblue'</span><span id="add1" class="my lt iq lq b gy nd na l nb nc">data =  [<br/>            [         'Freeze', 'Wind', 'Flood', 'Quake', 'Hail'],<br/>            [ '5 year',  66386, 174296,   75131,  577908,  32015],<br/>            ['10 year',  58230, 381139,   78045,   99308, 160454],<br/>            ['20 year',  89135,  80552,  152558,  497981, 603535],<br/>            ['30 year',  78415,  81858,  150656,  193263,  69638],<br/>            ['40 year', 139361, 331509,  343164,  781380,  52269],<br/>        ]</span><span id="4cd7" class="my lt iq lq b gy nd na l nb nc"># Pop the headers from the data array<br/>column_headers = data.pop(0)<br/>row_headers = [x.pop(0) for x in data]</span><span id="4004" class="my lt iq lq b gy nd na l nb nc"># Table data needs to be non-numeric text. Format the data<br/># while I'm at it.<br/>cell_text = []<br/>for row in data:<br/>    cell_text.append([f'{x/1000:1.1f}' for x in row])</span><span id="4b6f" class="my lt iq lq b gy nd na l nb nc"># Get some lists of color specs for row and column headers<br/>rcolors = plt.cm.BuPu(np.full(len(row_headers), 0.1))<br/>ccolors = plt.cm.BuPu(np.full(len(column_headers), 0.1))</span><span id="d6b2" class="my lt iq lq b gy nd na l nb nc"># Create the figure. Setting a small pad on tight_layout<br/># seems to better regulate white space. Sometimes experimenting<br/># with an explicit figsize here can produce better outcome.<br/>plt.figure(linewidth=2,<br/>           edgecolor=fig_border,<br/>           facecolor=fig_background_color,<br/>           tight_layout={'pad':1},<br/>           #figsize=(5,3)<br/>          )</span><span id="acea" class="my lt iq lq b gy nd na l nb nc"># Add a table at the bottom of the axes<br/>the_table = plt.table(cellText=cell_text,<br/>                      rowLabels=row_headers,<br/>                      rowColours=rcolors,<br/>                      rowLoc='right',<br/>                      colColours=ccolors,<br/>                      colLabels=column_headers,<br/>                      loc='center')</span><span id="1a3d" class="my lt iq lq b gy nd na l nb nc"># Scaling is the only influence we have over top and bottom cell padding.<br/># Make the rows taller (i.e., make cell y scale larger).<br/>the_table.scale(1, 1.5)</span><span id="794e" class="my lt iq lq b gy nd na l nb nc"># Hide axes<br/>ax = plt.gca()<br/>ax.get_xaxis().set_visible(False)<br/>ax.get_yaxis().set_visible(False)</span><span id="7427" class="my lt iq lq b gy nd na l nb nc"># Hide axes border<br/>plt.box(on=None)</span><span id="b48e" class="my lt iq lq b gy nd na l nb nc"># Add title<br/>plt.suptitle(title_text)</span><span id="ea43" class="my lt iq lq b gy nd na l nb nc"># Add footer<br/>plt.figtext(0.95, 0.05, footer_text, horizontalalignment='right', size=6, weight='light')</span><span id="c75f" class="my lt iq lq b gy nd na l nb nc"># Force the figure to update, so backends center objects correctly within the figure.<br/># Without plt.draw() here, the title will center on the axes and not the figure.<br/>plt.draw()</span><span id="fd6d" class="my lt iq lq b gy nd na l nb nc"># Create image. plt.savefig ignores figure edge and face colors, so map them.<br/>fig = plt.gcf()<br/>plt.savefig('pyplot-table-demo.png',<br/>            #bbox='tight',<br/>            edgecolor=fig.get_edgecolor(),<br/>            facecolor=fig.get_facecolor(),<br/>            dpi=150<br/>            )</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/b221c9d3a5409fcafbe2285732583540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0oAvvYfNwARXfLc-Tq25IQ.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">简单的小桌子(图片作者)</p></figure><h1 id="e5f5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="566e" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">我分享了 Matplotlib <code class="fe ln lo lp lq b">pyplot.tables</code>示例到一个简单、整洁的小表格的一步一步的转换，没有附带图表。表格排列整齐，适合您的出版物或演示文稿。这些步骤包括隐藏图表、使表格居中、设置颜色、插入页脚的代码更改，以及改进最终图像文件的对齐和间距的提示。也许有一天这些步骤会节省你的时间。</p></div></div>    
</body>
</html>