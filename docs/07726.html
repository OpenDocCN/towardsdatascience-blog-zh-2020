<html>
<head>
<title>Github Recommender System using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 Python 的 Github 推荐系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/github-recommender-system-python-c8ff64dc83f4?source=collection_archive---------34-----------------------#2020-06-09">https://towardsdatascience.com/github-recommender-system-python-c8ff64dc83f4?source=collection_archive---------34-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ad47" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们分析用户相似性，并使用二分图的概念向用户推荐存储库。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e4cd231ef966532bd27c1b5e516656fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jaQFnDGY3ZJ8m9zHNDVsvw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 Canva 设计。</p></figure><p id="ca29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个<strong class="la iu">网络</strong>或者一个<strong class="la iu">图</strong>是节点和边的组合。我们经常把图画成由边组合而成的节点，其中节点代表一些现实生活中的实体，比如脸书的用户，而边代表实体之间的关系，比如脸书的朋友。在我之前的<a class="ae lu" rel="noopener" target="_blank" href="/applied-network-analysis-using-python-25021633a702?source=your_stories_page---------------------------">文章</a>中阅读更多关于图表的内容。我们将在本文中使用<strong class="la iu">二分图</strong>和<strong class="la iu"> NetworkX </strong>包的概念。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1d8c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">二部图</h1><p id="8826" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">定义二分图有两个条件。首先，它是一个节点被分成两组的图。第二，一组中的节点不能相互连接；它们只能连接到另一组中的节点。让我们举个例子来更具体地说明这一点。</p><p id="46a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以亚马逊购物网站为例。客户使用亚马逊网站/应用程序购买产品。假设我们正在为这个模型创建一个图表。让我们将节点分成两组，客户分区和产品分区。边缘表示客户已经购买了特定的产品。在这种情况下，产品不能连接到产品是完全合理的，因为一个产品不能购买另一个产品。顾客也一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/f2ae3202f8989381bd38cb8d108d9051.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*Z456u-x2KrlHsIfprg_zhg.png"/></div></figure><p id="f098" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用 NetworkX 包创建一个二分图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="291d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们在传入参数<code class="fe nc nd ne nf b">data=True</code>时检查图的节点，我们将看到存储的分区信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/c62dc99902cc3c7f4214b8589e94dc22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LES8f8NQWrDHDnPDLpWexw.png"/></div></div></figure><h2 id="b650" class="nh md it bd me ni nj dn mi nk nl dp mm lh nm nn mo ll no np mq lp nq nr ms ns bi translated">过滤</h2><p id="11f0" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">NetworkX 没有提供显式的<strong class="la iu">二分图</strong>类，我们需要显式地编写代码来过滤掉不同的节点集。这可以使用列表理解来完成。现在，让我们试着从上图中只检索“客户”集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/a13ba2a9a60298685b2be3574d37639f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QgQuBzoTZIrpiyPYiyePBg.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="719f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">推荐系统</h1><p id="159f" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">让我们尝试并理解如何将二分图应用于推荐系统问题。</p><blockquote class="nt nu nv"><p id="ff0c" class="ky kz nw la b lb lc ju ld le lf jx lg nx li lj lk ny lm ln lo nz lq lr ls lt im bi translated">二分图是协同过滤方法中使用的底层数据结构，这种方法在许多推荐系统如网飞和亚马逊中被广泛使用。</p></blockquote><p id="bb00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在 Github 上，用户在存储库上互相开发代码。正如文章标题所示，我们将向用户推荐在一个集合中使用高度相似节点概念的存储库。假设我们有一个二分图，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/171ee4c13753b8727965e2b15830fba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*qs0vWnpZI-nea2TuHQdESQ.png"/></div></figure><p id="42a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用户 1 连接到 repo2，我们想推荐用户 1 可能有兴趣使用的存储库。现在，我们可以尝试分析连接到 repo2 而不是 User1 的所有其他用户。在这种情况下，用户 2 和用户 3 连接到 repo2。此外，请注意 User3 还连接到另一个存储库 repo1。因此，我们可能希望向用户 1 推荐 repo1 进行贡献。像亚马逊、YouTube 和网飞这样的大多数网站使用协同过滤作为推荐系统的一部分，根据相似用户的好恶向用户提供建议。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="a4cc" class="nh md it bd me ni nj dn mi nk nl dp mm lh nm nn mo ll no np mq lp nq nr ms ns bi translated">资料组</h2><p id="f35c" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们有一个存储库和用户的邻接表。我们有用户和存储库的编号，而不是名称。根据 NetworkX 文档，邻接表格式由带有节点标签的行组成。一行中的第一个标签是源节点。线中的其他标签被视为目标节点，并与源节点和目标节点之间的边一起添加到图中。例子—</p><p id="4b2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">a b c ( 'a '是源节点，' b '，' c '是目标节点)</p><p id="98f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">表示在 a-b 和 a-c 之间有一条边的图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/85c128b6867966144e39771534a72a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*UnO264ae9pz7260XIa_uFA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“u”代表用户,“p”代表存储库。</p></figure><p id="031b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，一个用户可以连接到许多存储库，反之亦然。带有单个标签的线表示没有边的节点。我们可以使用下面的命令从上面的文件创建一个图表。</p><pre class="kj kk kl km gt oc nf od oe aw of bi"><span id="81ab" class="nh md it nf b gy og oh l oi oj">G=nx.read_adjlist("/content/Github.txt")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/ceb37632e4b10251d552f4afc2d37d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*JONTOLYM9cQUYi1odnav-w.png"/></div></figure><p id="8d30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以注意到有 22，000 个节点(用户+存储库)和 20，000 条边。现在让我们将节点分成 2 组，即<strong class="la iu">用户</strong>组和<strong class="la iu">项目</strong>组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4a43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们找出用户节点的数量和项目节点的数量。我们可以通过遍历节点列表、检查二分属性并查找生成的列表长度来完成这项任务，就像我们对上面的 customers 和 product 节点所做的那样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="59b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在执行上述代码时，找到了 10721 个用户节点和 11632 个项目节点。</p><h2 id="ff25" class="nh md it bd me ni nj dn mi nk nl dp mm lh nm nn mo ll no np mq lp nq nr ms ns bi translated">使用集合交点重叠</h2><p id="e38c" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们假设 2 个人，A 和 B，A 连接到 repo2，B 连接到 repo2 和 repo3。如何才能找到 A 和 B 的共享存储库(repo2)？</p><pre class="kj kk kl km gt oc nf od oe aw of bi"><span id="bb96" class="nh md it nf b gy og oh l oi oj">A_n = G.neighbors(A) will return ['repo2']<br/>B_n = G.neighbors(B) will return ['repo2', 'repo3']</span><span id="b1cc" class="nh md it nf b gy ol oh l oi oj">overlap = set(A_n).intersection(B_n) will return ['repo2']<br/></span></pre><p id="d32c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">交集方法将返回 2 个或更多集合中的公共元素。借助上述逻辑，我们可以找到 2 个用户的相似度得分。</p><h2 id="c446" class="nh md it bd me ni nj dn mi nk nl dp mm lh nm nn mo ll no np mq lp nq nr ms ns bi translated">寻找相似的用户</h2><p id="ec9b" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated"><strong class="la iu">2 个用户的相似性度量=共享项目数/项目总数。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="184a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用上述逻辑，对于给定的用户 A，我们可以通过计算 A 与所有其他用户的相似性度量，并提取得分最高的用户，来找到最相似的用户。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="1d27" class="nh md it bd me ni nj dn mi nk nl dp mm lh nm nn mo ll no np mq lp nq nr ms ns bi translated">推荐存储库</h2><p id="ce5f" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在上述用户“u4560”的代码中，最相似的用户是“u5453”和“u17446”。现在，如果我们发现“u5453”和“u17446”组合在一起与“u4560”的存储库不同，我们可以将它们推荐给“u4560”。</p><p id="464f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例—假设有两个人，A 和 B。A 连接到 repo2，B 连接到 repo2 和 repo3。我们如何才能发现 A 和 B 的存储库之间的区别呢？</p><p id="da72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nc nd ne nf b">B.difference(A)</code>将返回回购 3。<code class="fe nc nd ne nf b">difference()</code>方法将返回出现在第一组中而不出现在第二组中的节点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="586b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据集和完整代码可以在 Github <a class="ae lu" href="https://github.com/kurasaiteja/Github-Recommender-System" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="b628" class="mc md it bd me mf om mh mi mj on ml mm jz oo ka mo kc op kd mq kf oq kg ms mt bi translated">一个脑筋急转弯！</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/6e363af69e959a82d8085a1715bd22ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*2Xa2GqNRXffLdvozSVxolA.png"/></div></figure><p id="aa46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面哪个是二分图？也试着回答一下节点集！期待您的回复。请务必检查答案，找出正确答案。</p><h1 id="4a87" class="mc md it bd me mf om mh mi mj on ml mm jz oo ka mo kc op kd mq kf oq kg ms mt bi translated">结论</h1><p id="a120" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在本文中，我们了解了二分图的概念及其在推荐系统中的使用。我们还使用 NetworkX 包创建了一个 Github 存储库推荐系统。推荐系统中使用了更多的指标和方法，这些将在以后的文章中讨论。我希望你今天学到了新东西！</p><p id="f95a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">欢迎分享反馈。</p></div></div>    
</body>
</html>