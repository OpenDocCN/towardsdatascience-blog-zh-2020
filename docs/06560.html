<html>
<head>
<title>How To Automate Julia Documentation With Documenter.jl</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 Documenter.jl 自动化 Julia 文档</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-automate-julia-documentation-with-documenter-jl-21a44d4a188f?source=collection_archive---------32-----------------------#2020-05-24">https://towardsdatascience.com/how-to-automate-julia-documentation-with-documenter-jl-21a44d4a188f?source=collection_archive---------32-----------------------#2020-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7385" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">没有文档，软件是没有用的，所以用 Documenter.jl 把文档的痛苦去掉吧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f2c76fede03d59879159c5d3e14ab430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AtTFJ353BduHctyh0Gl6qw.png"/></div></div></figure><p id="0187" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">不管喜欢还是讨厌，文档创建在任何软件的创建中都是相当关键的一步。您可以构建人类已知的最伟大的模块，但是没有文档，没有人会知道如何使用它。当涉及到编程时，创建文档常常是事后的想法。制作模块和应用程序既费时又困难，还会让人非常沮丧。因为一般来说，编程通常是一个非常棘手的过程，并且可能比预期的要长得多，所以文档通常是编程过程中非常冗长、乏味的一部分。</p><p id="02df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对 Julia 开发者来说幸运的是，有 Documenter.jl. Documenter.jl 是一个模块，可以用来从代码中提取 Julia 文档字符串，并将它们编译成元信息、markdown 和 HTML。Documenter 不仅能够自动创建文档网站，而且还具有一些功能，可用于轻松地将文档推入存储库，以自动完成在 web 上加速文档的整个过程。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d962" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Julia 文档</h1><p id="3974" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">像大多数其他语言一样，Julia 以文档字符串为特色，文档字符串记录了实际软件本身内部的代码。然而，与大多数其他语言不同，Julia 有一种非常酷的方式来研究这种文档，这使得使用模块变得轻而易举。首先，Julia 包含了一个帮助函数？()，它可以用在语言中的任何模块、类型、宏或函数上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/2cd191bf5f75d0a615ff74b47b2116b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2IEVI1FkAeOQTCQKoRUlg.png"/></div></div></figure><p id="3662" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这本身就非常有帮助，如果你的模块有一个文档图，比如 Lathe，那么你就不需要去网站查看 Julia 语言的文档。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/be338375f3770a4bf5d99b927578072c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynX111KOCpq-utqc9e_ahA.png"/></div></div></figure><p id="36f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最重要的是，如果您碰巧使用 Juno 在中开发 Julia，那么您就可以利用出色的文档窗格。使用 documentation 窗格，您可以在文本编辑器中将 Julia 模块文档预编译到一个漂亮的 GUI 中，然后查看所有包的文档。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/dd2098e1497527ef10f6303332037198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1o8HrLIT7QQkHw3mOcKLg.png"/></div></div></figure><p id="fa5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要在 Julia 中记录一个函数，只需在函数上方添加一个 docstring 即可。或者，您也可以使用@doc 宏来记录一些东西。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c570" class="nl mh it nh b gy nm nn l no np">@doc"""<br/>This is my docstring!\n<br/>I like pizza.<br/>"""<br/>function thisisdocumented()<br/>    continue</span><span id="38bb" class="nl mh it nh b gy nq nn l no np">end</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ef1a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">设置您的文件系统</h1><p id="c672" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">为了用 Documenter.jl 创建文档，我们首先需要设置一些目录供模块使用。我们将首先创建一个根目录来存储我们的文档。这通常是在 Julia 包的/doc 目录中完成的，但是，重要的是要记住，Documenter 使用的是您的全局 Julia 包，而不是您的本地包。因此记住这一点，您不一定需要将这些文件放入存储库的位置。但是，这有一个条件，因为为了构建文档，您必须有一个源目录。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="83fe" class="nl mh it nh b gy nm nn l no np">cd Projects<br/>mkdir HoneDox<br/>cd HoneDox</span></pre><p id="7dd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们在一个空的目录中，我们需要为 Documenter 创建一个基本的文件结构。在此过程中，我想创建的第一个文件是“index.md”。如果没有 Index markdown 文件，Documenter 将无法创建文档，因此该文件非常重要，并且不会自动生成。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5225" class="nl mh it nh b gy nm nn l no np">touch index.md</span></pre><p id="8d09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将创建一个文件。您可以将它放在一个名为 Doc 的新目录中，或者放在几乎任何地方。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="918e" class="nl mh it nh b gy nm nn l no np">mkdir doc</span><span id="5c59" class="nl mh it nh b gy nq nn l no np">cd doc<br/>nano make.jl</span></pre><p id="d39d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个文件中，我们首先要做的是导入文档管理器。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="d347" class="nl mh it nh b gy nm nn l no np">using Documenter</span></pre><p id="8dce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们想要导入我们想要为其制作文档的模块。对于这个例子，我将使用 Hone.jl。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="6007" class="nl mh it nh b gy nm nn l no np">using Hone</span></pre><p id="b2c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想要文档化的包没有导出您想要文档化的函数，那么您也必须添加作为该模块的子模块的任何模块。当使用 auto-doc 时，这将使您更容易将不同模块的文档分开。我不会这样做，因为 Hone 的所有功能都包含在内，并且不需要使用任何附加模块就可以导出。</p><p id="9567" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们需要从文档管理器中调用 makedocs()方法。这个函数需要很多参数，所以我将逐一介绍:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="7fd0" class="nl mh it nh b gy nm nn l no np">root - Root will determine where the file-system root is for this project. This is equivalent to the top of the repository in Github, and most of the time is going to be "./"</span><span id="8ff7" class="nl mh it nh b gy nq nn l no np">source - Source is the directory of your source files from the root directory.</span><span id="fe94" class="nl mh it nh b gy nq nn l no np">build - Build is the directory where you want Documenter to put your new HTML site from the root directory.</span><span id="2029" class="nl mh it nh b gy nq nn l no np">clean - This is a boolean that will determine whether or not Documenter is going to clean the build after finishing.</span><span id="07be" class="nl mh it nh b gy nq nn l no np">doctest - Doc test is another boolean that will determine whether or not Documenter will let you know of any problems with your module's docstrings, e.g. undocumented functions.</span><span id="20c1" class="nl mh it nh b gy nq nn l no np">modules - These are the modules that we imported before, they will be put into a list here for Documenter to process.</span><span id="e68a" class="nl mh it nh b gy nq nn l no np">repo - Repo will determine where your " edit on github" link will go. We will be ignoring this for now.</span><span id="427d" class="nl mh it nh b gy nq nn l no np">sitename - Just a name for your site, this will appear in the title of your HTML document, as well as the upper left-hand corner of the default style documentation site.</span><span id="cb0c" class="nl mh it nh b gy nq nn l no np">expandfirst - This parameter will take a page and expand it in the left side context menu. I usually leave this blank, as your current page will always be expanded.</span><span id="9115" class="nl mh it nh b gy nq nn l no np">pages - This will be a mapped dictionary of all your documentation files (e.g. index.md) and their corresponding titles. The titles will fill into the menu (on the left with the default style.)</span></pre><p id="b8e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我的文件看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/40a2754b4c26491ec6f302e8398c0f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*N8U7sFwc2BNC806s4K-I_g.png"/></div></figure><p id="3106" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们需要用 ctrl + x 关闭 nano，我们可以继续创建我们的源目录。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a22c" class="nl mh it nh b gy nm nn l no np">mkdir src</span></pre><p id="de23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将把源文件复制到该目录中。接下来，我们将把 index.md 移动到 src 目录中。之后，我们可以继续运行 make.jl:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4dbd" class="nl mh it nh b gy nm nn l no np">mv index.md src<br/>cd doc<br/>julia make.jl</span></pre><p id="ed0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">过一会儿，一个新目录将出现在我们的根文件夹中，名为“build”如果我们打开那个文件夹，我们会看到一个绝对的文件巨兽。现在唯一对我们重要的是 index.html。如果您现在在浏览器中打开该文件，您可能会看到类似以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/658016c4299b3f118fbe13c044a3a0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6i620hZ8nor9y19d3MlyJA.png"/></div></div></figure><blockquote class="nt"><p id="d2d6" class="nu nv it bd nw nx ny nz oa ob oc lp dk translated">厉害！</p></blockquote></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8113" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建文档</h1><p id="9fce" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">现在我们终于可以开始处理 index.md 文件了。这个文件当然只是简单的 Github markdown，所以我们可以添加一个带有标签的标题。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="d1a8" class="nl mh it nh b gy nm nn l no np"># This is an example title<br/>## This is a smaller title<br/>### This is an even smaller title</span></pre><p id="2200" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我们再次运行 make.jl 文件并刷新页面，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/1a7f76075a84db488b1beca566c68079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjYvkw8ukHjPbpMh6NiJ9Q.png"/></div></div></figure><p id="ef01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，右边的菜单现在已被填充。现在我们可以开始讨论一些宏，我们可以用它们来自动填充文档。宏的使用方式总是与 Github Markdown 中的代码使用方式相似，其中有三种方式:</p><blockquote class="nt"><p id="4054" class="nu nv it bd nw nx oe of og oh oi lp dk">`</p></blockquote><p id="dc6a" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated">打开，还有三个要关闭。</p><p id="d01a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先我们要看一下@meta 宏。这个宏用于界定需要由 Julia 运行的代码。这主要用于设置当前模块，如下例所示:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="cedd" class="nl mh it nh b gy nm nn l no np">```<a class="ae oo" href="http://twitter.com/meta" rel="noopener ugc nofollow" target="_blank">@meta</a><br/>CurrentModule = ourmodule<br/>DocTestSetup = quote<br/>    using ourmodule<br/>end<br/>```</span></pre><p id="ef54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一个重要的宏是@doc 宏，它将完成您可能会想到的功能。@doc 宏后面是您想要记录的函数、模块、宏或类型。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="aa50" class="nl mh it nh b gy nm nn l no np">```@doc<br/>examplemodule.function<br/>```</span></pre><p id="b1ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有一个没有参数的上下文宏，它将为您的文档创建一个目录。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="9d4b" class="nl mh it nh b gy nm nn l no np">```<a class="ae oo" href="http://twitter.com/contents" rel="noopener ugc nofollow" target="_blank">@contents</a><br/>```</span></pre><p id="b5a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我要演示的最后一个重要的宏是@autodoc 宏，它是这个列表中最酷的一个。@autodoc 采用单个参数。这个参数只是一个为其创建文档的模块列表。对于这个例子，我将使用@contents 和@autodoc。首先，我将把@autodoc 添加到 Hone 模块的 index.md 中。</p><h1 id="479e" class="mg mh it bd mi mj op ml mm mn oq mp mq jz or ka ms kc os kd mu kf ot kg mw mx bi translated">页</h1><p id="f4db" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">对于我的索引页面组合，我决定将所有文档存储在一个页面中。这是因为从 0.0.3 版本开始，Hone 中确实没有太多需要处理的事情，所以不需要太多的组织。如果你想查看更复杂的文档，你可以在这里查看车床的文档:</p><div class="ou ov gp gr ow ox"><a href="http://lathe.ai/doc" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">索引</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">车床可以使用 Pkg 添加。julia &gt;使用 Pkg julia&gt; Pkg.add("Lathe ")解析包版本...正在更新…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">车床. ai</p></div></div></div></a></div><p id="51c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我的最后一份文件:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4891" class="nl mh it nh b gy nm nn l no np"># Adding Hone<br/>## Pkg Registry<br/>```<a class="ae oo" href="http://twitter.com/repl" rel="noopener ugc nofollow" target="_blank">@repl</a><br/>using Pkg<br/>Pkg.add("Lathe")<br/>```<br/>## Unstable<br/>```<a class="ae oo" href="http://twitter.com/example" rel="noopener ugc nofollow" target="_blank">@example</a><br/>julia&gt; ]<br/>pkg&gt; add Hone#Unstable<br/>```<br/>## Specified Versions</span><span id="3772" class="nl mh it nh b gy nq nn l no np">```<a class="ae oo" href="http://twitter.com/example" rel="noopener ugc nofollow" target="_blank">@example</a><br/>julia&gt; ]<br/>pkg&gt; add Hone#0.0.1<br/>```</span><span id="bfbe" class="nl mh it nh b gy nq nn l no np">```<a class="ae oo" href="http://twitter.com/autodocs" rel="noopener ugc nofollow" target="_blank">@autodocs</a><br/>Modules = [Hone]<br/>```</span></pre><p id="f866" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再次运行 make.jl 并刷新页面后:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/fbba8569ac116eed8299b5161b6cd4f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iy4kmGZRl4iyUB3SQSxIWw.png"/></div></div></figure><blockquote class="nt"><p id="c2f8" class="nu nv it bd nw nx ny nz oa ob oc lp dk translated">很酷，对吧？</p></blockquote><p id="59a3" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated">回到我们的源目录，让我们添加另一个 markdown 文件。对于这个例子，由于我的模块的文档已经非常完整，我将制作另一个页面来展示 contents 宏。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="d0c0" class="nl mh it nh b gy nm nn l no np">nano toc.md</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/fb561ee42ef799900a3539e987c4efcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*m60fWh7uAoVI27a1q2Ol7w.png"/></div><p class="pi pj gj gh gi pk pl bd b be z dk translated">(忽略我不小心把它命名为 toc.jl 的事实，我做了一个 oopsie。)</p></figure><p id="1461" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们只需将该文件添加到 make.jl 文件中的 pages dictionary 参数中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/511563e7e6fa03f592424872d7c355bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*cDcQn7stFwprcAMmXvvYKg.png"/></div></figure><p id="a3d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后再次运行 make 文件:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4b16" class="nl mh it nh b gy nm nn l no np">julia make.jl</span></pre><p id="f97f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们将在左侧的导航栏上提供多个页面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/1e224f7c94c1eb59ff3ca049d44a624f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2yw1YtEy9HDskeF9HF_A8w.png"/></div></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b9b3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="f6c1" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">Documenter.jl 就不用说了，牛逼！我喜欢不用手动创建文档！创建网站以提供带有适当搜索的文档可能需要几个小时甚至几天，并且需要更多的工作来维护。拥有一个可以自动完成这项工作的包，甚至可以把你的新构建推送到一个存储库，这绝对是一个巨大的祝福！</p></div></div>    
</body>
</html>