<html>
<head>
<title>Feature Engineering on Date-Time Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">日期时间数据的特征工程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/feature-engineering-on-date-time-data-90f6e954e6b8?source=collection_archive---------8-----------------------#2020-08-16">https://towardsdatascience.com/feature-engineering-on-date-time-data-90f6e954e6b8?source=collection_archive---------8-----------------------#2020-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e578d0f7d722f9b665e4366a40e6834b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rproQdENpkYMKGXHDd-GSw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@esteejanssens?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">埃斯特扬森斯</a>在<a class="ae jg" href="https://unsplash.com/s/photos/calendar?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="15fa" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">以及如何使用梯度推进回归在您的预测模型中实现它</h2></div><p id="1595" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">根据维基百科，特征工程是指利用领域知识通过数据挖掘技术从原始数据中提取特征的过程。然后，这些特征可以用于提高机器学习算法的性能。</p><p id="e373" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管如此，特征工程并不一定非要花里胡哨。特征工程的一个简单但普遍的用例是时间序列数据。特征工程在这一领域的重要性是由于(原始)时间序列数据通常只包含一个单独的列来表示时间属性，即日期-时间(或时间戳)。</p><p id="b12b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于该日期-时间数据，<strong class="la jk">特征工程可视为从这些数据中提取有用的信息，作为独立的(独特的)特征</strong>。例如，从日期时间数据“2020–07–01 10:21:05”中，我们可能希望从中提取以下特征:</p><ol class=""><li id="d57c" class="me mf jj la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">月份:7</li><li id="50e0" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">一月中的第几天:1</li><li id="6ecc" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">日期名称:星期三(2020 年 7 月 1 日是星期三)</li><li id="a9ce" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">小时:10 分钟</li></ol><p id="c87a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从日期时间数据中提取这类特征正是本文的目标。之后，我们将整合我们的工程特征作为梯度推进回归模型的预测器。具体来说，我们将预测地铁州际交通量。</p><h1 id="8565" class="ms mt jj bd mu mv mw mx my mz na nb nc kp nd kq ne ks nf kt ng kv nh kw ni nj bi translated">快速小结</h1><p id="9c87" class="pw-post-body-paragraph ky kz jj la b lb nk kk ld le nl kn lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">本文将涵盖以下内容。</p><p id="b14f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">从日期-时间列中提取以下特征的分步指南。</strong></p><ol class=""><li id="b8aa" class="me mf jj la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">月</li><li id="3674" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">一月中的某一天</li><li id="218d" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">日期名称</li><li id="2d8c" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">小时</li><li id="83c3" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">白天(上午、下午等)</li><li id="0d71" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated">周末标志(如果是周末，则为 1，否则为 0)</li></ol><p id="87a2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">如何将这些特征整合到梯度推进回归模型中，以预测地铁州际交通量。</strong></p><h1 id="e3a1" class="ms mt jj bd mu mv mw mx my mz na nb nc kp nd kq ne ks nf kt ng kv nh kw ni nj bi translated">数据</h1><p id="6a60" class="pw-post-body-paragraph ky kz jj la b lb nk kk ld le nl kn lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">在整篇文章中，我们使用<strong class="la jk">地铁州际交通量数据集，</strong>可以在 UCI 机器学习知识库<a class="ae jg" href="https://archive.ics.uci.edu/ml/datasets/Metro+Interstate+Traffic+Volume" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="1231" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">引用其摘要，该数据是关于明尼苏达州明尼阿波利斯-圣保罗西行 I-94 的每小时交通量，包括 2012 年至 2018 年的天气和假日特征。这 48204 行数据包含以下属性。</p><ol class=""><li id="5a50" class="me mf jj la b lb lc le lf lh mg ll mh lp mi lt mj mk ml mm bi translated">美国国家法定假日加上地区假日，明尼苏达州博览会</li><li id="bf0e" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated"><code class="fe np nq nr ns b">temp</code>:以开尔文为单位的数字平均温度</li><li id="1f41" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated"><code class="fe np nq nr ns b">rain_1h</code>:一小时内降雨量的数值，单位为毫米</li><li id="5195" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated"><code class="fe np nq nr ns b">snow_1h</code>:一小时内降雪的数值，单位为毫米</li><li id="2459" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated"><code class="fe np nq nr ns b">clouds_all</code>:云量百分比</li><li id="f4ca" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated"><code class="fe np nq nr ns b">weather_main</code>:当前天气的分类简短文本描述</li><li id="148a" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated"><code class="fe np nq nr ns b">weather_description</code>:对当前天气的分类更长的文本描述</li><li id="49a5" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated"><code class="fe np nq nr ns b"><strong class="la jk">date_time</strong></code>:当地 CST 时间采集的数据的日期时间小时</li><li id="0226" class="me mf jj la b lb mn le mo lh mp ll mq lp mr lt mj mk ml mm bi translated"><code class="fe np nq nr ns b">traffic_volume:</code>每小时 I-94 ATR 301 报告的西行交通量(目标值)</li></ol><p id="c59b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们加载数据。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="3e40" class="ob mt jj ns b gy oc od l oe of"># import libraries<br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="30fe" class="ob mt jj ns b gy og od l oe of"># load the data<br/>raw = pd.read_csv('Metro_Interstate_Traffic_Volume.csv')</span><span id="c7ba" class="ob mt jj ns b gy og od l oe of"># display first five rows<br/>raw.head()</span><span id="4ac1" class="ob mt jj ns b gy og od l oe of"># display details for each column<br/>raw.info()</span></pre><figure class="nt nu nv nw gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/57e29357ee732560368bfdce08c0bf59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*4P_fxNt05ty9Y86vXDvl2g.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">raw.head()</p></figure><figure class="nt nu nv nw gt iv gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/d1bc831a5a4f7dae43cd7d7478a2c34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*xxqKMWpR-0u_KzUw4t0UYQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">raw.info()</p></figure><p id="6279" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面的<code class="fe np nq nr ns b">info</code>方法的输出中，我们知道<code class="fe np nq nr ns b">date_time</code>列仍然是<code class="fe np nq nr ns b">object</code>类型。所以我们需要将其转换为<code class="fe np nq nr ns b">datetime</code>类型。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="0793" class="ob mt jj ns b gy oc od l oe of"># convert date_time column to datetime type<br/>raw.date_time = pd.to_datetime(raw.date_time)</span></pre><h1 id="f7f0" class="ms mt jj bd mu mv mw mx my mz na nb nc kp nd kq ne ks nf kt ng kv nh kw ni nj bi translated">开始特征工程</h1><p id="2368" class="pw-post-body-paragraph ky kz jj la b lb nk kk ld le nl kn lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">从上面 info 方法的输出中，我们知道除了<code class="fe np nq nr ns b">date_time</code>列之外还有分类特性。但是由于本文的主题，我们将把重点放在我们的<code class="fe np nq nr ns b">date_time</code>专栏的特性工程上。</p><p id="b635" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">月</strong></p><p id="9368" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实证明，Pandas 有许多方便的方法来处理<code class="fe np nq nr ns b">datetime</code>类型的数据。要提取时间/日期组件，我们需要做的就是调用<code class="fe np nq nr ns b">pd.Series.dt</code>属性族。<code class="fe np nq nr ns b">pd.Series.dt.month</code>是我们需要提取的月份成分。这将产生一系列<code class="fe np nq nr ns b">int64</code>格式的月份数字(例如 1 代表一月，10 代表十月)。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="c83b" class="ob mt jj ns b gy oc od l oe of"># extract month feature<br/>months = raw.date_time.dt.month</span></pre><p id="d61f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">一个月中的某一天</strong></p><p id="0060" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和之前很像，我们只需要调用<code class="fe np nq nr ns b">pd.Series.dt.day</code>。例如，使用此属性，日期时间 2012–10–27 09:00:00 将产生 27。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="0a03" class="ob mt jj ns b gy oc od l oe of"># extract day of month feature<br/>day_of_months = raw.date_time.dt.day</span></pre><p id="6b31" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">小时</strong></p><p id="7a0a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个也是琐碎的。属性<code class="fe np nq nr ns b">pd.Series.dt.hour</code>将产生一系列小时数字，范围从 0 到 23。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="1d2e" class="ob mt jj ns b gy oc od l oe of"># extract hour feature<br/>hours = raw.date_time.dt.hour</span></pre><p id="0173" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">日名</strong></p><p id="df54" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个越来越有趣了。我们的目标是提取<code class="fe np nq nr ns b">raw.date_time</code>系列中每个日期时间的日期名称。它包括两个步骤。首先是使用<code class="fe np nq nr ns b">pd.Series.dt.day_name()</code>方法提取日名称文字。之后，我们需要使用<code class="fe np nq nr ns b">pd.get_dummies()</code>方法对第一步的结果进行一次性编码。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="c700" class="ob mt jj ns b gy oc od l oe of"># first: extract the day name literal<br/>to_one_hot = raw.date_time.dt.day_name()</span><span id="c0f1" class="ob mt jj ns b gy og od l oe of"># second: one hot encode to 7 columns<br/>days = pd.get_dummies(to_one_hot)</span><span id="aae5" class="ob mt jj ns b gy og od l oe of">#display data<br/>days</span></pre><figure class="nt nu nv nw gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e6afd296461fd7948786a7bd64b70fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*HSCLFdgzZxG3NTuM5vrpMQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">一键编码的日期名称</p></figure><p id="c353" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">日间部分</strong></p><p id="1d91" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这一部分中，我们将根据小时数字创建一个分组。在高层次上，我们希望有六个组来代表每一天。它们是黎明(02.00-05.59)、早晨(06.00-09.59)、中午(10.00-13.59)、下午(14.00-17.59)、晚上(18.00-21.59)和午夜(第+1 天的 22.00-01.59)。</p><p id="f182" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们创建了一个标识函数，稍后我们将使用它来提供一个系列的<code class="fe np nq nr ns b">apply</code>方法。之后，我们对产生的日部分执行一键编码。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="bb09" class="ob mt jj ns b gy oc od l oe of"># daypart function<br/>def daypart(hour):<br/>    if hour in [2,3,4,5]:<br/>        return "dawn"<br/>    elif hour in [6,7,8,9]:<br/>        return "morning"<br/>    elif hour in [10,11,12,13]:<br/>        return "noon"<br/>    elif hour in [14,15,16,17]:<br/>        return "afternoon"<br/>    elif hour in [18,19,20,21]:<br/>        return "evening"<br/>    else: return "midnight"</span><span id="1d5d" class="ob mt jj ns b gy og od l oe of"># utilize it along with apply method<br/>raw_dayparts = hours.apply(daypart)</span><span id="e146" class="ob mt jj ns b gy og od l oe of"># one hot encoding<br/>dayparts = pd.get_dummies(raw_dayparts)</span><span id="7d89" class="ob mt jj ns b gy og od l oe of"># re-arrange columns for convenience<br/>dayparts = dayparts[['dawn','morning','noon','afternoon','evening','midnight']]</span><span id="5b86" class="ob mt jj ns b gy og od l oe of">#display data<br/>dayparts</span></pre><figure class="nt nu nv nw gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/7880b814dd914fd47882364adbee64a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*cpK3RYmTiMVrjJTizPABfg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">日部分，一键编码</p></figure><p id="3d81" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">周末旗帜</strong></p><p id="7d77" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从<code class="fe np nq nr ns b">date_time</code>栏设计的最后一个特征是<code class="fe np nq nr ns b">is_weekend</code>。该列指示给定的日期时间是否在周末(周六或周日)。为了实现这个目标，我们将利用之前的<code class="fe np nq nr ns b">pd.Series.dt.day_name()</code>方法，并在其上应用一个简单的 lambda 函数。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="572d" class="ob mt jj ns b gy oc od l oe of"># is_weekend flag <br/>day_names = raw.date_time.dt.day_name()<br/>is_weekend = day_names.apply(lambda x : 1 if x in ['Saturday','Sunday'] else 0)</span></pre><p id="71b4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">节日旗帜&amp;天气</strong></p><p id="1e69" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，该数据还包含公共假期信息。信息是精细的，因为它提到了每个公共假日的名称。尽管如此，我认为对这些节日进行编码并没有明显的好处。因此，让我们创建一个二元特征来表示相应的日期是否是假日。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="77a1" class="ob mt jj ns b gy oc od l oe of"># is_holiday flag<br/>is_holiday = raw.holiday.apply(lambda x : 0 if x == "None" else 1)</span></pre><p id="e7c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要注意的最后一个分类特性是<code class="fe np nq nr ns b">weather</code>列(我的假设在这里再次出现，我做<em class="md">不</em>包括<code class="fe np nq nr ns b">weather_description</code>特性)。正如您可能猜到的，我们只是一次性地将该特性编码如下。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="9436" class="ob mt jj ns b gy oc od l oe of"># one-hot encode weather<br/>weathers = pd.get_dummies(raw.weather_main)</span><span id="715d" class="ob mt jj ns b gy og od l oe of">#display data<br/>weathers</span></pre><figure class="nt nu nv nw gt iv gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/6d8826925160f3ce1cbbf38c5f3ddc00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*SB03adyQqb5IL1wcDt0qIQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">天气，一键式编码</p></figure><p id="f0de" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">最终数据</strong></p><p id="f016" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">万岁！我们终于有了最终的数据，可以开始训练了！让我们创建一个名为<code class="fe np nq nr ns b">features</code>的全新数据框架，它包含所有的特征，既有数字特征(我们按原样从原始数据中提取)，也有分类特征(我们设计的特征)。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="6298" class="ob mt jj ns b gy oc od l oe of"># features table</span><span id="1bd6" class="ob mt jj ns b gy og od l oe of">#first step: include features with single column nature<br/>features = pd.DataFrame({<br/>    'temp' : raw.temp,<br/>    'rain_1h' : raw.rain_1h,<br/>    'snow_1h' : raw.snow_1h,<br/>    'clouds_all' : raw.clouds_all,<br/>    'month' : months,<br/>    'day_of_month' : day_of_months,<br/>    'hour' : hours,<br/>    'is_holiday' : is_holiday,<br/>    'is_weekend' : is_weekend<br/>})</span><span id="36a4" class="ob mt jj ns b gy og od l oe of">#second step: concat with one-hot encode typed features<br/>features = pd.concat([features, days, dayparts, weathers], axis = 1)</span><span id="4afb" class="ob mt jj ns b gy og od l oe of"># target column<br/>target = raw.traffic_volume</span></pre><p id="7f02" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在将数据输入模型之前，我们需要分割数据(训练和测试数据)。请注意下面我们做的是<em class="md">而不是</em>打乱我们的数据，这是由于数据的时间序列性质。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="303c" class="ob mt jj ns b gy oc od l oe of">#split data into training and test data<br/>X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.1, shuffle = False)</span></pre></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><h1 id="61ac" class="ms mt jj bd mu mv ot mx my mz ou nb nc kp ov kq ne ks ow kt ng kv ox kw ni nj bi translated">建模零件</h1><p id="9476" class="pw-post-body-paragraph ky kz jj la b lb nk kk ld le nl kn lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">现在我们准备建立我们的模型来预测地铁州际交通量。在这项工作中，我们将使用梯度推进回归模型。</p><p id="2403" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该模型的细节超出了本文的范围，但是在较高的层次上，梯度推进模型属于集成模型家族，其采用梯度下降算法来最小化顺序(附加)弱学习器模型(决策树)中的错误。</p><p id="5a58" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">模特培训</strong></p><p id="c47c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们在训练数据上实例化和训练模型！</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="3d9e" class="ob mt jj ns b gy oc od l oe of">from sklearn import datasets, ensemble</span><span id="f946" class="ob mt jj ns b gy og od l oe of"># define the model parameters<br/>params = {'n_estimators': 500,<br/>          'max_depth': 4,<br/>          'min_samples_split': 5,<br/>          'learning_rate': 0.01,<br/>          'loss': 'ls'}</span><span id="9d15" class="ob mt jj ns b gy og od l oe of"># instantiate and train the model<br/>gb_reg = ensemble.GradientBoostingRegressor(**params)<br/>gb_reg.fit(X_train, y_train)</span></pre><p id="1e50" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请稍等片刻，直到训练结束。</p><p id="4bd4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">模型评估</strong></p><p id="7a46" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了评估该模型，我们使用两个指标:MAPE(平均绝对百分比误差)和 R2 分数。我们将根据测试数据计算这些指标。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="f19c" class="ob mt jj ns b gy oc od l oe of"># define MAPE function<br/>def mape(true, predicted):        <br/>    inside_sum = np.abs(predicted - true) / true<br/>    return round(100 * np.sum(inside_sum ) / inside_sum.size,2)</span><span id="4809" class="ob mt jj ns b gy og od l oe of"># import r2 score<br/>from sklearn.metrics import r2_score</span><span id="b263" class="ob mt jj ns b gy og od l oe of"># evaluate the metrics<br/>y_true = y_test<br/>y_pred = gb_reg.predict(X_test)</span><span id="eb26" class="ob mt jj ns b gy og od l oe of">#print(f"GB model MSE is {round(mean_squared_error(y_true, y_pred),2)}")<br/>print(f"GB model MAPE is {mape(y_true, y_pred)} %")<br/>print(f"GB model R2 is {round(r2_score(y_true, y_pred)* 100 , 2)} %")</span></pre><figure class="nt nu nv nw gt iv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/a39f82272bfd40ac09246bbf9ff13e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*SMT_3IwSFtwM7WzK5VDalQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">测试数据的度量性能</p></figure><p id="384b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到我们的模型在性能上相当不错。我们的 MAPE 不到 15%，而 R2 的分数是 95%多一点。</p><p id="92b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">图形结果</strong></p><p id="29d2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了直观地理解我们的模特表演，让我们来点剧情吧！</p><p id="86e4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于我们测试数据的长度(4820 个数据点)，我们只绘制了最后 100 个数据点的实际值与模型预测值。此外，我们还包括另一个模型(在下面的绘图代码中称为<code class="fe np nq nr ns b">gb_reg_lite</code>)，该模型的<em class="md">而不是</em>包含日期-时间工程特征作为其预测器(它只包含非日期-时间列作为特征，包括<code class="fe np nq nr ns b">temp</code>、<code class="fe np nq nr ns b">weather</code>等)。</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="a7dc" class="ob mt jj ns b gy oc od l oe of">fig, ax = plt.subplots(figsize = (12,6))</span><span id="6a3f" class="ob mt jj ns b gy og od l oe of">index_ordered = raw.date_time.astype('str').tolist()[-len(X_test):][-100:]</span><span id="5097" class="ob mt jj ns b gy og od l oe of">ax.set_xlabel('Date')<br/>ax.set_ylabel('Traffic Volume') </span><span id="e347" class="ob mt jj ns b gy og od l oe of"># the actual values<br/>ax.plot(index_ordered, y_test[-100:].to_numpy(), color='k', ls='-', label = 'actual')</span><span id="688a" class="ob mt jj ns b gy og od l oe of"># predictions of model with engineered features<br/>ax.plot(index_ordered, gb_reg.predict(X_test)[-100:], color='b', ls='--', label = 'predicted; with date-time features')</span><span id="bfb9" class="ob mt jj ns b gy og od l oe of"># predictions of model without engineered features<br/>ax.plot(index_ordered, gb_reg_lite.predict(X_test_lite)[-100:], color='r', ls='--', label = 'predicted; w/o date-time features')</span><span id="b965" class="ob mt jj ns b gy og od l oe of">every_nth = 5<br/>for n, label in enumerate(ax.xaxis.get_ticklabels()):<br/>    if n % every_nth != 0:<br/>        label.set_visible(False)</span><span id="daf4" class="ob mt jj ns b gy og od l oe of">ax.tick_params(axis='x', labelrotation= 90)</span><span id="28ea" class="ob mt jj ns b gy og od l oe of">plt.legend()<br/>plt.title('Actual vs predicted on the last 100 data points')<br/>plt.draw()</span></pre><figure class="nt nu nv nw gt iv gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/32f5f975a71d430742d8598433ebd7c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*NJASCamQHENfrCsvMVuJ1Q.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">我们对最后 100 个数据点的预测性能</p></figure><p id="a287" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该图支持我们之前对该模型获得的良好评估指标的调查结果，因为蓝色虚线与黑色实线非常接近。也就是说，我们的梯度推进模型可以很好地预测地铁交通。</p><p id="c6df" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同时，我们看到不使用<em class="md">而不使用</em>日期-时间工程功能的模型在性能上有所下降(红色虚线)。为什么会出现这种情况？因为目标(交通流量)确实取决于我们刚刚创建的特征。交通流量在周末趋于降低，但在高峰时段会达到峰值(见上图)。因此，如果我们不对日期-时间列执行特征工程，我们将会错过这些声音预测器！</p><h1 id="efbf" class="ms mt jj bd mu mv mw mx my mz na nb nc kp nd kq ne ks nf kt ng kv nh kw ni nj bi translated">在你走之前</h1><p id="a495" class="pw-post-body-paragraph ky kz jj la b lb nk kk ld le nl kn lg lh nm lj lk ll nn ln lo lp no lr ls lt im bi translated">恭喜你已经阅读了这么多！</p><p id="199c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在简单回顾一下。在本文中，我们学习了如何对日期时间数据执行特征工程。之后，我们结合工程特征建立了一个强大的梯度推进回归模型，以预测地铁交通量。</p><p id="2ecd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，感谢您的阅读，让我们通过<a class="ae jg" href="https://www.linkedin.com/in/pararawendy-indarjo-5b87bab7" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>与我联系吧！</p></div></div>    
</body>
</html>