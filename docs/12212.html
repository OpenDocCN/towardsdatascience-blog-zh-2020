<html>
<head>
<title>SQL Tricks For Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的 SQL 技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-tricks-for-data-scientists-53298467dd5?source=collection_archive---------14-----------------------#2020-08-23">https://towardsdatascience.com/sql-tricks-for-data-scientists-53298467dd5?source=collection_archive---------14-----------------------#2020-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c38" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用 SQL 赢得胜利</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/690380880f54a5b5a346637e6061232a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k5GkbM9BUemA6uYVZB1CTg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">递归 CTE</p></figure><p id="10a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我发现自己被公司内部各个团队要求的 cron jobs 和 CSV 文件淹没了。不断有人要求导出新数据或更新这些导出数据。任何时候任何人想要添加一个字段，我都是这个任务的失败点。我必须首先记住哪个服务生成了该报告，以及该报告的要点。然后，我必须调查所需的新字段是否可用，是否可以从其他列派生，或者是否需要新的数据库连接。</p><p id="291d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我需要找到一个应用程序，它可以帮助我跟踪所有的报告，管理所有不同的数据库连接，并允许某人自己维护通知。最后一个重要的功能是卸载我的一些报告生成，并允许人们自助服务所有数据。</p><p id="ac5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我选择了<a class="ae lu" href="https://www.metabase.com/" rel="noopener ugc nofollow" target="_blank">元数据库</a>,因为它符合我一直在寻找的所有标准。它是开源的，支持各种不同的数据源，具有用户/权限管理、许多图表/仪表板选项和各种不同类型的通知。</p><p id="494a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只有一个问题—元数据库完全基于 SQL。我使用简单的选择来查询数据库并将数据转换成 CSV 的工作流将不可用。我不得不使用原始 SQL。我怎样才能在 SQL 中插入逻辑呢？我如何循环结果？如何生成日期范围？我如何使用滚动窗口？这些类型的问题听起来好像只有 SQL 的工作流不能解决问题。</p><p id="d2c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果这些手术实际上是可能的呢？如果 SQL 实际上是一种<a class="ae lu" href="https://simple.wikipedia.org/wiki/Turing_complete#:~:text=Turing%20complete%20is%20a%20term,programming%20languages%20are%20Turing%2Dcomplete." rel="noopener ugc nofollow" target="_blank">图灵</a>-带有递归的完整语言会怎样？如果有一种透视数据或使用窗口的方法会怎么样？下面我将介绍一些我在旅途中发现的技巧，以充分利用 SQL 的强大功能。</p><h1 id="abd4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置</h1><p id="616f" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><em class="ms">如果你想自己执行这些例子，你可以遵循下面的指令。如果你只是想阅读，跳到下一节。</em></p><p id="1871" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用 MySQL 8 和 sample <a class="ae lu" href="https://dev.mysql.com/doc/sakila/en/" rel="noopener ugc nofollow" target="_blank"> Sakila </a>数据库作为示例。如果你安装了 Docker，我已经提供了几行代码来运行 MySQL 8 服务器。</p><p id="42b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面启动 docker 容器。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="497f" class="my lw it mu b gy mz na l nb nc">docker run -d --publish=3307:3306 --name=mysql_test -e MYSQL_ROOT_PASSWORD=root mysql/mysql-server:latest</span></pre><p id="622f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据库示例数据库可以通过下载示例文件并提取它们来加载。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7f58" class="my lw it mu b gy mz na l nb nc">#enter the shell<br/>docker exec -it mysql_test bin/bash</span><span id="f811" class="my lw it mu b gy nd na l nb nc">#install wget<br/>yum install wget</span><span id="f2a0" class="my lw it mu b gy nd na l nb nc">#get file<br/>wget <a class="ae lu" href="https://downloads.mysql.com/docs/sakila-db.tar.gz" rel="noopener ugc nofollow" target="_blank">https://downloads.mysql.com/docs/sakila-db.tar.gz</a></span><span id="e0a6" class="my lw it mu b gy nd na l nb nc">#install tar<br/>yum install tar</span><span id="8ce6" class="my lw it mu b gy nd na l nb nc">#extract files<br/>tar xvzf sakila-db.tar.gz</span><span id="e561" class="my lw it mu b gy nd na l nb nc">#start the mysql console, the password was set in the docker run cmd<br/>mysql -u root -p</span><span id="8d9e" class="my lw it mu b gy nd na l nb nc">#import the schema<br/>SOURCE sakila-db/sakila-schema.sql</span><span id="9252" class="my lw it mu b gy nd na l nb nc">#import the data<br/>SOURCE sakila-db/sakila-data.sql</span><span id="29e9" class="my lw it mu b gy nd na l nb nc">#use the newly created database<br/>use sakila;</span><span id="e072" class="my lw it mu b gy nd na l nb nc">#if all went well, the following cmd should show all the tables<br/>show tables;</span></pre><p id="cc9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">设置完成后，您可以自己尝试这些示例。</p><h1 id="7b25" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">查找重复事件</h1><p id="0e7e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我将从一个更简单但仍然强大的例子开始。如果一个表与另一个表具有一对多或多对多的关系，则该表与该表的联接会导致交叉(或笛卡尔)联接。我们可以使用子查询将结果集缩小到每个表中的一行。</p><p id="2ed7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，假设我们想按字母顺序查找每个演员和他们出现的最后一部电影。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6dec" class="my lw it mu b gy mz na l nb nc">SELECT a.first_name, a.last_name, f.title <br/>FROM actor a <br/>JOIN film_actor fa ON fa.actor_id = a.actor_id <br/>JOIN film f ON f.film_id = fa.film_id;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/111731bb7bd1097812c6b8406c25c2a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*iUft7FvHEtHpWmib3BNIwg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上一个查询的输出示例</p></figure><p id="56db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的查询将列出所有演员和所有电影。但是如果您只想列出一部电影——最后一部——我们需要添加一个子查询，以便只使用我们想要的电影。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ec72" class="my lw it mu b gy mz na l nb nc">SELECT a.first_name, fa.film_id, f.title <br/>FROM actor a <br/>LEFT JOIN (<br/>  SELECT actor_id, MAX(film_id) as film_id <br/>  FROM film_actor group by actor_id<br/>) fa ON fa.actor_id = a.actor_id <br/>LEFT JOIN film f ON f.film_id = fa.film_id ;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/540177dce211b9aa91c93410eded0b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*wsPeQafdtHAigyDbB-LHng.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">仅列出一部电影时的示例响应</p></figure><p id="a928" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于具有重复事件(如登录和创建对象)的表格，您可以查找第一个或最后一个事件，或者第一个和最后一个事件之间的差异。下面是查找客户寿命的 SQL 语句，其中寿命定义为他们第一次和最后一次租赁日期之间的差异(天数)。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="b54a" class="my lw it mu b gy mz na l nb nc">SELECT c.customer_id,c.first_name, c.last_name, r.first_rental, r.last_rental, DATEDIFF(r.last_rental, r.first_rental) as customer_longevity <br/>FROM customer c <br/>LEFT JOIN (<br/>  SELECT customer_id, MIN(rental_date) as first_rental, MAX(rental_date) AS last_rental <br/>  FROM rental GROUP BY customer_id<br/>) r ON r.customer_id = c.customer_id;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/896da770a1743dcd8b627ed4d6bf067e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-AhfNMLVJKtwXqRjdRC7Xw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">租金差异的样本响应</p></figure><h1 id="dced" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">绕轴旋转</h1><p id="b5d3" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">您希望将行转换为列以用于演示和/或图表制作的数据可以根据需要进行透视和汇总。以下面的查询和示例输出为例。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9ff3" class="my lw it mu b gy mz na l nb nc">SELECT MONTHNAME(r.rental_date), c.name, count(r.rental_id) <br/>FROM rental r <br/>LEFT JOIN film f ON f.film_id = r.inventory_id <br/>LEFT JOIN film_category fc ON fc.film_id = f.film_id <br/>LEFT JOIN category c ON c.category_id = fc.category_id <br/>GROUP BY MONTHNAME(r.rental_date),c.name;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/2fcd0466f15501f7edbae8889d48376c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*c3i4aoP_GrBtC7f4ejmSzQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按月份和类型分组的示例响应</p></figure><p id="553f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们可以将每月细分移动到每月一行，而不是每个类别每月一行时的用例。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2b56" class="my lw it mu b gy mz na l nb nc">SELECT MONTHNAME(r.rental_date), <br/>COUNT(CASE WHEN c.name = ‘Horror’ THEN r.rental_id ELSE NULL END) AS HorrorCount, <br/>COUNT(CASE WHEN c.name = ‘Action’ THEN r.rental_id ELSE NULL END) AS ActionCount, <br/>COUNT(CASE WHEN c.name = ‘Comedy’ THEN r.rental_id ELSE NULL END) AS ComedyCount, <br/>COUNT(CASE WHEN c.name = ‘Sci-Fi’ THEN r.rental_id ELSE NULL END) AS ScifiCount <br/>FROM rental r <br/>LEFT JOIN film f ON f.film_id = r.inventory_id <br/>LEFT JOIN film_category fc ON fc.film_id = f.film_id <br/>LEFT JOIN category c ON c.category_id = fc.category_id <br/>GROUP BY MONTHNAME(r.rental_date);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/47f00c7b85bac6a6aeaac5704f5fe02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*UZWwXm0Dhf4Z8BW1cItUAw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将行旋转到列</p></figure><p id="f716" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我没有使用所有类别来避免一页 SQL 语句，但是您可以添加其他列来完成查询。MySQL 没有一种内置的方法来动态创建每一列，但是有能力使用一个准备好的语句来避免必须拼出每一列。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9842" class="my lw it mu b gy mz na l nb nc">SET <a class="ae lu" href="http://twitter.com/sql" rel="noopener ugc nofollow" target="_blank">@sql</a> = NULL;<br/>SELECT<br/> GROUP_CONCAT(DISTINCT<br/> CONCAT(<br/> ‘COUNT(CASE WHEN c.name = ‘’’,<br/> name,<br/> ‘’’ THEN r.rental_id ELSE NULL END) AS `’,<br/> name,<br/> ‘`’<br/> )<br/> ) INTO <a class="ae lu" href="http://twitter.com/sql" rel="noopener ugc nofollow" target="_blank">@sql</a><br/>FROM category;<br/>SET <a class="ae lu" href="http://twitter.com/sql" rel="noopener ugc nofollow" target="_blank">@sql</a> = CONCAT(‘SELECT MONTHNAME(r.rental_date), ‘, <a class="ae lu" href="http://twitter.com/sql" rel="noopener ugc nofollow" target="_blank">@sql</a> ,’ FROM rental r LEFT JOIN film f ON f.film_id = r.inventory_id LEFT JOIN film_category fc ON fc.film_id = f.film_id LEFT JOIN category c ON c.category_id = fc.category_id GROUP BY MONTHNAME(r.rental_date)’);</span><span id="78a7" class="my lw it mu b gy nd na l nb nc">PREPARE stmt FROM <a class="ae lu" href="http://twitter.com/sql" rel="noopener ugc nofollow" target="_blank">@sql</a>;<br/>EXECUTE stmt;<br/>DEALLOCATE PREPARE stmt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/a6321624a22bcc4b6d3506c7003db651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GU4YYT9HD-sxzDAdZ7M-6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">所有的流派列</p></figure><p id="fac7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意</strong>:group _ concat _ max _ len 变量需要足够长，足以容纳所有可能的类别。默认值为 1024，但是如果您在尝试运行上述 SQL 语句时遇到任何错误，则可以根据会话进行更改。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9ae5" class="my lw it mu b gy mz na l nb nc">SET SESSION group_concat_max_len = 1000000;</span></pre><h1 id="74d2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">滚动窗户</h1><p id="a9df" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">继续聚合数据的主题，我们还可以使用窗口函数来创建滚动聚合。前面我们使用了一个查询来按类型和月份列出所有的租赁。我们如何添加另一列来显示每月的运行总数，以及该月每种类型的租赁百分比？</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c139" class="my lw it mu b gy mz na l nb nc">SELECT MONTHNAME(r.rental_date), c.name, count(r.rental_id),     SUM(count(r.rental_id)) over(PARTITION BY MONTHNAME(r.rental_date)) as rental_month_total, count(rental_id) / SUM(count(r.rental_id)) over(PARTITION BY MONTHNAME(r.rental_date)) * 100 as percentage_of_rentals <br/>FROM rental r <br/>LEFT JOIN film f ON f.film_id = r.inventory_id <br/>LEFT JOIN film_category fc ON fc.film_id = f.film_id <br/>LEFT JOIN category c ON c.category_id = fc.category_id <br/>GROUP BY MONTHNAME(r.rental_date),c.name;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/7a1bb34d59b4d2788f69048b8c267146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Rf7cly6vFkWmAcNMMGdcA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">租赁类型百分比的示例结果</p></figure><p id="2435" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nl nm nn mu b">Over</code>关键字允许您定义如何对数据进行分区。在这种情况下，我们使用租赁日期月份。</p><h1 id="dc9e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">生成数据</h1><p id="98ce" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我经常会遇到我想要长期跟踪的数据。问题是有些情况下数据很稀疏，可能没有我想要显示的每个时间单位的值。例如，以下面的查询为例:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c732" class="my lw it mu b gy mz na l nb nc">SELECT DATE_FORMAT(r.rental_date,"%Y-%M") as rental_date, count(r.rental_id) as rental_count FROM rental r  <br/>LEFT JOIN film f ON f.film_id = r.inventory_id  <br/>LEFT JOIN film_category fc ON fc.film_id = f.film_id  <br/>LEFT JOIN category c ON c.category_id = fc.category_id  <br/>GROUP BY DATE_FORMAT(r.rental_date,"%Y-%M");</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/91f364b73d1106223ce1ae318ae0227a.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*pKZ1OsYWCf3NDe36RCSwlw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">现有数据的年份和月份</p></figure><p id="39cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前面的查询按月显示了计数，但是如果我想看到其他列的计数为 0，该怎么办呢？</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="29c5" class="my lw it mu b gy mz na l nb nc">WITH RECURSIVE t(v) as (   <br/>  SELECT  DATE('2005-03-01')   <br/>  UNION ALL   <br/>  SELECT v + INTERVAL 1 MONTH   <br/>  FROM t    <br/>  LIMIT 12 <br/>) <br/>SELECT DATE_FORMAT(t.v,"%Y-%M") as rental_date, count(r.rental_id) as rental_count FROM rental r  <br/>LEFT JOIN film f ON f.film_id = r.inventory_id   <br/>LEFT JOIN film_category fc ON fc.film_id = f.film_id   <br/>LEFT JOIN category c ON c.category_id = fc.category_id   <br/>RIGHT JOIN t on DATE_FORMAT(t.v,"%Y-%M")  = DATE_FORMAT(r.rental_date,"%Y-%M") <br/>GROUP BY DATE_FORMAT(t.v,"%Y-%M");</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/5a663b86ce8bf2b56a293223efa840b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*kxxjlxKpUV_Cz-FHRYQcIQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">12 个月零灌装</p></figure><p id="08b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">递归 cte 看起来比实际情况更吓人。在这个问题上，一个比我能提供的更好的解释可以在这里找到。</p><h1 id="11b3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="18ec" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">SQL 提供了一种强大的语言来提取数据。我介绍了一些技巧，关于如何使用 SQL 来处理更复杂的过滤和聚合，而不需要在数据库之外执行这些操作。</p><p id="bf79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ms">我向那些希望为组织添加商业智能报告引擎的人推荐</em> <a class="ae lu" href="https://www.metabase.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ms">元数据库</em> </a> <em class="ms">。唯一需要满足的标准是让我的同事自助生成报告。但这可能是我对所有报告请求说“是”的一个功能。</em></p></div></div>    
</body>
</html>