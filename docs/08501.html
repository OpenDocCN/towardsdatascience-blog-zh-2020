<html>
<head>
<title>Download a Flask template ready to plug in your business logic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下载一个 Flask 模板，准备插入您的业务逻辑</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/download-a-flask-template-ready-to-plug-in-your-business-logic-bb9375e1be09?source=collection_archive---------32-----------------------#2020-06-20">https://towardsdatascience.com/download-a-flask-template-ready-to-plug-in-your-business-logic-bb9375e1be09?source=collection_archive---------32-----------------------#2020-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d70f82092d2ec69122919595ad3d0c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3v-YHq-a22mjXl4F"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="59ed" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">可用于日志记录、配置设置、URL 参数验证的预配置设置</h2></div><p id="2220" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们假设，经过大量艰苦的工作，你已经有了你的机器学习模型，它应该运行的方式。这种模型可以响应用户的请求，对推文情感进行分类，或识别图像中的对象，或推荐产品或其他符合您需求的算法。您现在想要快速部署这个模型。下面这篇文章解释了我创建的模板，它可以让你快速上手。</p><p id="58d2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Flask micro 服务是一种部署应用程序的简单方法。然而，人们很快意识到，你不希望创建一个大的单片单文件程序。该计划应该是模块化的，以支持未来的增强，它应该是可配置的帮助下配置文件。这些配置参数不仅适用于 Flask，也适用于您的业务应用程序(还记得您创建的 tweet 分类应用程序)。理想情况下，服务器应该适当地记录一切。大多数应用程序还需要连接到数据库，最后，在调用模型 api(或返回错误)之前，需要验证入站请求参数。</p><p id="8ef7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">听起来很多，对吧？这实际上是相当多的，人们可以很容易地花相当多的时间来构建一个提供这些特性的健壮框架。在这里，我提供了一个到<a class="ae jg" href="https://github.com/alsm6169/flask_server_template" rel="noopener ugc nofollow" target="_blank"> github </a>的链接，它在一个模块化的应用程序中提供了所有上面提到的特性。</p><p id="3077" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您应该能够克隆这个 Flask 服务器模板，并简单地运行它。一旦你让它运行起来，你就可以开始调整它来满足你的特定需求。</p><div class="is it gp gr iu lu"><a href="https://github.com/alsm6169/flask_server_template" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">alsm 6169/flask _ 服务器 _ 模板</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">Flask 服务器模板准备插入业务逻辑。该模板的特点是:烧瓶配置模块…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">github.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi ja lu"/></div></div></a></div><p id="45cd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="mj">在本文中，</em> <em class="mj">我将只解释为您的项目</em>定制这个烧瓶模板可能需要更改的部分。</strong>我的基本假设是对 Flask、SQLAlchemy、Marshmallow 有一定程度的熟悉。只要足够熟悉，如果某些部分没有意义，可以谷歌一下。请在评论中自由提问，我可以回答/更新文章以涵盖要点。</p><p id="6330" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您希望先安装并运行服务器，那么请跳过中间的解释部分，按照下面的命令顺序操作。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="0777" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从代码组织开始</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/12fac7b4ee02c0160ee23643969fadf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*RfX9K13colEG9BVFIt7rsw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Flask 服务器模板代码结构</p></figure><p id="f005" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在解释代码文件</p><p id="253c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面我将解释每个文件的用途以及你可能需要根据你的要求修改的相关代码部分(如果有的话)。T3】</p><blockquote class="mw mx my"><p id="9a94" class="ky kz mj la b lb lc kk ld le lf kn lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated"><strong class="la jk">base _ dir/flask _ server _ template→</strong>主模板目录</p></blockquote><p id="3db6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">flask _ server _ template/main . py</strong></p><p id="bebd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是服务器的入口点。它读取应用程序配置文件(run_params.json)，初始化记录器，初始化 flask 服务器并运行服务器。</p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="b65c" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### flask_server_template/main.py ###</strong></span><span id="0523" class="nh ni jj nd b gy nn nk l nl nm"><em class="mj">To use the template no changes are needed in this file.</em></span></pre><p id="921e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">flask _ server _ template/main _ config . py</strong></p><p id="9da1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个模块有两个作用。</p><p id="570f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1.读取应用程序配置文件，并创建一个可由应用程序的另一部分使用的字典。</p><p id="843f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.创建数据库连接字符串。这个连接字符串利用了配置文件中的参数。该连接字符串因基础数据库而异。用于创建连接字符串的 SQLAlchemy 文档在这里是<a class="ae jg" href="https://docs.sqlalchemy.org/en/13/core/engines.html" rel="noopener ugc nofollow" target="_blank"/>。</p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="8d2a" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### flask_server_template/main_config.py ###<br/></strong>def get_db_con_str():<br/><em class="mj">    </em>pwd = os.getenv(<strong class="nd jk">'DB_PWD'</strong>)  <em class="mj"># get password from environment variable DB_PWD<br/>    </em>db_con_str = <strong class="nd jk">f'postgresql://' </strong>\<br/>                 <strong class="nd jk">f'</strong>{run_conf_data[<strong class="nd jk">"DB_USER"</strong>]}<strong class="nd jk">:' </strong>\<br/>                 <strong class="nd jk">f'</strong>{pwd}<strong class="nd jk">@' </strong>\<br/>                 <strong class="nd jk">f'</strong>{run_conf_data[<strong class="nd jk">"DB_SERVER"</strong>]}<strong class="nd jk">:' </strong>\<br/>                 <strong class="nd jk">f'</strong>{run_conf_data[<strong class="nd jk">"DB_PORT"</strong>]}<strong class="nd jk">/' </strong>\<br/>                 <strong class="nd jk">f'</strong>{run_conf_data[<strong class="nd jk">"DB_NAME"</strong>]}<strong class="nd jk">'<br/>    </strong>os.environ[<strong class="nd jk">'SQLALCHEMY_DATABASE_URI'</strong>] = db_con_str<br/>    return db_con_str</span></pre><blockquote class="mw mx my"><p id="1cdc" class="ky kz mj la b lb lc kk ld le lf kn lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated"><strong class="la jk"><em class="jj">flask _ server _ template/config</em>→</strong>以下是记录器和业务逻辑应用程序的配置文件</p></blockquote><p id="cdfb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> config/logger.conf </strong></p><p id="9a5a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有两个日志处理程序。“handler_consoleHandler”记录到屏幕，而“handler_fileHandler”记录到文件 run_log.log 中。每次服务器运行时，该文件都会被覆盖。但是，如果您想更改这一点并创建带有时间戳的新文件，您可以取消对第二行的注释，并对第一行进行注释</p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="e3a1" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### config/logger.conf ###<br/></strong>...<br/>...<br/>[handler_fileHandler]<br/>class=FileHandler<br/>level=DEBUG<br/>formatter=simpleFormatter<br/>args=('logs/run_log.log','w')<br/><em class="mj">#args=('../logs/' + time.strftime('%%Y%%m%%d_%%HH%%MM') +'.log','a')</em></span><span id="db14" class="nh ni jj nd b gy nn nk l nl nm">[handler_consoleHandler]<br/>class=StreamHandler<br/>level=INFO<br/>formatter=simpleFormatter<br/>args=(sys.stdout,)<br/>...<br/>...</span></pre><p id="7e9c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> config/run_params.json </strong></p><p id="3581" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“run_params”具有应用程序级配置，包含数据库服务器、用户名、运行 flask 的模式(开发/生产)等信息</p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="96a2" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### config/run_params.json ###<br/></strong>{<br/>  "LOGGER_CONFIG": "config/logger.conf",<br/>  "FLASK_CONFIG": "flask_config.DevelopmentConfig",<br/>  "DB_SERVER": "localhost",<br/>  "DB_PORT": "5432",<br/>  "DB_NAME": "dvdrental",<br/>  "DB_USER": "dvdrental"<br/>}</span></pre><blockquote class="mw mx my"><p id="0684" class="ky kz mj la b lb lc kk ld le lf kn lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated"><strong class="la jk"><em class="jj">flask _ server _ template/logs→</em></strong>创建运行日志的目录</p></blockquote><p id="0cde" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mj">要使用该模板，不需要对该目录进行任何更改。</em></p><blockquote class="mw mx my"><p id="b960" class="ky kz mj la b lb lc kk ld le lf kn lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated"><strong class="la jk"><em class="jj">flask _ server _ template/test→</em></strong>您的测试脚本</p></blockquote><p id="2bb0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> test/flask_client.py </strong></p><p id="9434" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个模板是一个工作模板，理想情况下，人们应该能够简单地下载和运行。测试客户端将测试这些功能。</p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="d8c0" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### test/flask_client.py ###</strong></span><span id="9880" class="nh ni jj nd b gy nn nk l nl nm"><em class="mj">To use the template no changes are needed in this file. New additional test cases can be written in this file or new test file created in this test folder.</em></span></pre><blockquote class="mw mx my"><p id="4475" class="ky kz mj la b lb lc kk ld le lf kn lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated"><strong class="la jk"><em class="jj">flask _ server _ template/flask _ server _ template→</em></strong><em class="jj"/>包含 flask 初始化代码、配置设置以及适当功能的路径重定向的主 flask 目录。</p></blockquote><p id="da63" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">flask _ server _ template/_ _ init _ _。py </strong></p><p id="62dd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">__init__。py 包含 flask_server_template 包的初始化函数。它有一个主要功能“create_app”，创建 Flask 对象，设置 Flask 配置，初始化数据库并注册路线(其功能的 URL)</p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="bc4c" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### flask_server_template/__init__.py ###</strong></span><span id="787d" class="nh ni jj nd b gy nn nk l nl nm"><em class="mj">To use the template no changes are needed in this file.</em></span></pre><p id="d232" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">flask _ server _ template/flask _ config . py</strong></p><p id="3589" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">' flask_config.py '包含 flask 的配置设置。它提供了开发和生产环境的一般配置。</p><p id="2d4e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大部分常用参数都已经设置好了。如需更多设置选项，请查看官方文档。</p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="2840" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### flask_server_template/flask_config.py ###</strong></span><span id="fd20" class="nh ni jj nd b gy nn nk l nl nm"><em class="mj">To use the template no changes are needed in this file.However, for quick reference, the default configurations</em></span><span id="7bfa" class="nh ni jj nd b gy nn nk l nl nm">class Config(object):<br/>    DEBUG = False<br/>    TESTING = False<br/>    CSRF_ENABLED = True<br/>    SECRET_KEY = <strong class="nd jk">'this-really-needs-to-be-changed'<br/>    </strong>SQLALCHEMY_DATABASE_URI = os.getenv(<strong class="nd jk">'SQLALCHEMY_DATABASE_URI'</strong>)<br/><em class="mj">    </em>SQLALCHEMY_TRACK_MODIFICATIONS = False<br/>    SQLALCHEMY_ECHO = False<br/><br/>class ProductionConfig(Config):<br/>    DEBUG = False<br/><br/><br/>class DevelopmentConfig(Config):<br/>    DEVELOPMENT = True<br/>    DEBUG = True</span></pre><p id="9e78" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">flask _ server _ template/flask _ routes . py</strong></p><p id="999b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“flask_routes.py”包含 URL 到其相应实现的映射。</p><p id="d2bb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">注意:</strong>有一个调用对数据库进行适当的设置。@ routes . before _ app _ first _ request。如果我们希望使用<a class="ae jg" href="https://docs.sqlalchemy.org/en/13/orm/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy ORM </a>特性，这是必需的。在下面对 flask_server_template/db 的描述中有更多的细节。</p><p id="b1f5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">对于每个需要迎合的 REST API，都需要有一个到函数的映射。这里描述了映射到 URL 的单个函数的示例。</strong></p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="ef83" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### flask_server_template/flask_routes.py ###<br/></strong>...<br/>...<br/>@routes.route('/module/v01/functions/film_info_orm', methods=['GET']) <strong class="nd jk"><em class="mj">#TODO:</em></strong><em class="mj"> change URL</em><br/>def get_film_info_orm(): <strong class="nd jk"><em class="mj">#TODO</em></strong><em class="mj">: change function name</em><br/>    try:<br/>        log.debug('inside get_film_info_orm') <strong class="nd jk"><em class="mj">#TODO:</em></strong><em class="mj"> change logging</em><br/>        film_df = bm.get_film_info_orm(request) <strong class="nd jk"><em class="mj">#TODO:</em></strong><em class="mj"> change business logic function here</em><br/>        response_code = 200<br/>        response_msg = film_df.to_json(orient='records') <strong class="nd jk"><em class="mj">#TODO:</em></strong><em class="mj"> change response</em><br/><em class="mj">    </em>except RuntimeError as err:<br/>        response_code = 700 <em class="mj"><br/>        </em>response_msg = jsonify(str(err))<br/>    return make_response(response_msg, response_code)<br/>...<br/>...</span></pre><blockquote class="mw mx my"><p id="5c67" class="ky kz mj la b lb lc kk ld le lf kn lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated"><strong class="la jk"><em class="jj">flask _ server _ template/model→</em></strong><em class="jj"/>业务逻辑代码驻留在这里</p></blockquote><p id="4a3b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">model/business _ model . py</strong></p><p id="2764" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在模块“business_model.py”中添加了所需的业务逻辑。一般流程如下:验证输入参数，从数据库获取数据，执行所需的业务逻辑应用程序并返回结果。</p><p id="c799" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="mj"> PS: </em> </strong> <em class="mj">目前，我没有任何业务逻辑。我只是从数据库返回熊猫数据帧格式的数据。</em></p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="a030" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### model/business_model.py ###<br/></strong>...<br/>...</span><span id="04a1" class="nh ni jj nd b gy nn nk l nl nm">def get_film_info_orm(in_request): <strong class="nd jk"><em class="mj">#TODO</em></strong><em class="mj">: appropriate function name</em><br/>    try:<br/>        <em class="mj"># validate the URL parameters<br/>        </em>title_schema_obj = TitleValidator() <strong class="nd jk"><em class="mj">#TODO</em></strong><em class="mj">: appropriate validation object</em><br/>        title_schema_obj.load(in_request.args)<br/>        <em class="mj"># verification passed, hence flask_server_template comes here else it would have gone to exception<br/>        </em>title = in_request.args[<strong class="nd jk">'title'</strong>]<br/>        log.debug(<strong class="nd jk">'title: ' </strong>+ title)<br/>        <em class="mj"># get your data in pandas data frame format<br/>        </em>df = queries_orm.get_film_info(title) <strong class="nd jk"><em class="mj">#TODO</em></strong><em class="mj">: appropriate function call here</em><br/>        <em class="mj"># apply business logic (if any)<br/>        </em>return df<br/>    except ValidationError as error:<br/>        log.error(<strong class="nd jk">f'get_all_film_df: </strong>{error}<strong class="nd jk">'</strong>)<br/>        raise RuntimeError(<strong class="nd jk">'Invalid Request Parameter: ' </strong>+ str(error))<br/>...<br/>...</span></pre><p id="c02f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">model/request _ validator . py</strong></p><p id="e867" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模块' business_model.py '使用<a class="ae jg" href="https://marshmallow.readthedocs.io/en/stable/marshmallow.validate.html" rel="noopener ugc nofollow" target="_blank">棉花糖</a>来验证 URL 参数。与手动编写 if then else 语句来验证 URL 参数的每个组成部分相比，这是一种首选的验证方式。验证包括数据类型检查(整数、字符串)、数值范围或特定列表和/或一些完全定制的检查。</p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="6b94" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### model/request_validator.py ###<br/></strong>...<br/>...<br/>def some_custom_check(data): <strong class="nd jk"><em class="mj">#TODO</em></strong><em class="mj">: common checks</em><br/>    <em class="mj">'''can be replaced with customised check'''<br/>    </em>if not data:<br/>        raise ValidationError(<strong class="nd jk">'some_custom_check for title failed'</strong>)</span><span id="9f8f" class="nh ni jj nd b gy nn nk l nl nm">class TitleValidator(Schema): <strong class="nd jk"><em class="mj">#TODO</em></strong><em class="mj">: appropriate class name</em><br/><strong class="nd jk"><em class="mj"># URL should have title of type string between length 1 and 50. After that call your custom check</em></strong><em class="mj"><br/>    </em>title = fields.Str(required=True, validate=[validate.Length(min=1, max=50), some_custom_check])</span><span id="488e" class="nh ni jj nd b gy nn nk l nl nm">...<br/>...</span></pre><blockquote class="mw mx my"><p id="3f14" class="ky kz mj la b lb lc kk ld le lf kn lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated"><strong class="la jk"><em class="jj">flask _ server _ template/db→</em></strong><em class="jj"/>数据库的查询和操作都在这个文件夹里</p></blockquote><p id="1029" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我详细介绍之前，我必须澄清几件事:</p><ul class=""><li id="406f" class="no np jj la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">我使用了来自<a class="ae jg" href="https://www.postgresqltutorial.com/postgresql-sample-database/" rel="noopener ugc nofollow" target="_blank">postgresql 教程</a>的 PostgreSQL 教程数据库</li><li id="5422" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">出于演示目的，这里只有三个相关的表 a .电影 b .演员 c .电影 _ 演员</li></ul><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/749a00d5a890ac12027fd19e02824141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*06go-lGnMOhT4LJWt8xM-w.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">数据库模式</p></figure><ul class=""><li id="2137" class="no np jj la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">由于不需要用户进行额外的安装就无法发布 postgresql db，所以我在 sqlite 中创建了这 3 个表，并将其与该模板一起发布(在目录 flask _ server _ template/db/dvdrental . db 中)。</li><li id="44f7" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">虽然上面我强调了 postgresql 连接，但是在 Github 上也有 sqlite 连接字符串，有了这个连接字符串，整个模板就可以开箱即用了。(简而言之，如果你从他们的网站上安装了 postgresql 和数据库，你可以使用 postgresql，否则你可以简单地使用 sqlite)。</li><li id="7ae3" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">由于大多数数据科学家使用表格，查询返回熊猫数据框。</li><li id="8212" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">我有两种格式的所有查询 a .使用 SQLAlchemy 核心，即原始 SQL(select * from…)b . SQLAlchemy ORM 将表反映到 python 对象中，并以 python 方式执行查询。这让人们可以根据自己的喜好自由选择。</li></ul><p id="030b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唷！现在我解释代码文件</p><p id="6ec1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> db/dvdrental.db </strong></p><p id="5b58" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是包含三个表的 sqlite 数据库</p><ul class=""><li id="c42f" class="no np jj la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">电影:存储电影数据，如标题，发行年份，长度，评级等。</li><li id="b591" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">actor:存储 actor 数据，包括名字和姓氏。</li><li id="a5cd" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">film_actor:存储电影和演员之间的关系。</li></ul><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="4635" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### db/dvdrental.db ###</strong></span><span id="711f" class="nh ni jj nd b gy nn nk l nl nm"><em class="mj">To use the template no changes are needed in this file.</em></span></pre><p id="7a8a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">数据库/数据库 _ 扩展. py </strong></p><p id="4cb5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模块“db_extensions.py”具有数据库连接对象、数据库元数据、包含数据库反射(即数据库表到 python 对象的转换)的对象以及初始化对象关系映射的代码。</p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="91d2" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### db/db_extensions.py ###</strong></span><span id="876f" class="nh ni jj nd b gy nn nk l nl nm"><em class="mj">To use the template no changes are needed in this file.</em></span><span id="8ac9" class="nh ni jj nd b gy nn nk l nl nm">def orm_init():<br/>...<br/>Base.prepare(db_obj.engine, reflect=True) #IMPORTANT for reflecting database into python objects</span></pre><p id="99f0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">db/query s _ ORM . py</strong></p><p id="457e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模块“queries_orm.py”包含使用 SQLAlchemy ORM 的查询，即访问数据库的 pythonic 方式。</p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="2e12" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### db/queries_orm.py ###</strong></span><span id="ad65" class="nh ni jj nd b gy nn nk l nl nm">def get_film_info(title):<br/>    film_orm = Base.classes.film <strong class="nd jk"><em class="mj">#TODO</em></strong><em class="mj">: refer to correct table</em><br/>    qry = db_obj.session.query(film_orm).\<br/>         filter(film_orm.title == title) <strong class="nd jk"><em class="mj">#TODO</em></strong><em class="mj">: your query</em><br/>    film_df = pd.read_sql(qry.statement, db_obj.session.bind)<br/>    return film_df</span><span id="445e" class="nh ni jj nd b gy nn nk l nl nm"><strong class="nd jk"><em class="mj">#TODO</em></strong><em class="mj">: Another sample query below with multiple joins and filter</em><br/>def get_film_actors(title):<br/>    film_orm = Base.classes.film<br/>    actor_orm = Base.classes.actor<br/>    film_actor_orm = Base.classes.film_actor<br/><em class="mj">    </em>qry = db_obj.session.query(actor_orm).\<br/>            join(film_actor_orm,film_orm).\<br/>            filter(film_orm.title == title)<br/>    actor_df = pd.read_sql(qry.statement, db_obj.session.bind)<br/>    return actor_df</span></pre><p id="ebe4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> db/queries_rawsql.py </strong></p><p id="a474" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模块“queries_rawsql.py”包含原始 sql 查询。</p><p id="b39d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mj">免责声明:在 queries_rawsql.py 中有示例参数化查询(where 子句带有参数)。但是，这种格式不适用于 sqlite。它在 postgresql 和 oracle 上都能很好地工作。</em></p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="1561" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### db/queries_rawsql.py ###</strong></span><span id="fc17" class="nh ni jj nd b gy nn nk l nl nm">def get_all_films():<br/>    query = <strong class="nd jk">'''<br/>    SELECT * FROM film<br/>    '''  <em class="mj">#TODO</em></strong><em class="mj">: your query</em><strong class="nd jk"><br/></strong>    film_df = pd.read_sql(query, db_obj.session.bind)<br/>    return film_df</span><span id="2036" class="nh ni jj nd b gy nn nk l nl nm">def get_film_actors(title):<br/>    query = <strong class="nd jk">'''<br/>        SELECT a.first_name, a.last_name FROM actor a <br/>        INNER JOIN film_actor fa on fa.actor_id = a.actor_id <br/>        INNER JOIN film f on f.film_id = fa.film_id <br/>        WHERE f.title = %(title)s<br/>        ''' <em class="mj">#TODO</em></strong><em class="mj">: your query</em><strong class="nd jk"><br/></strong>    actor_df = pd.read_sql(sql=query, params={<strong class="nd jk">'title'</strong>: title}, con=db_obj.session.bind)<br/>    return actor_df</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="04ab" class="od ni jj bd oe of og oh oi oj ok ol om kp on kq oo ks op kt oq kv or kw os ot bi translated">安装和运行</h1><p id="737a" class="pw-post-body-paragraph ky kz jj la b lb ou kk ld le ov kn lg lh ow lj lk ll ox ln lo lp oy lr ls lt im bi translated">我认为快速启动并运行的最好方法是执行以下步骤</p><ul class=""><li id="ee2a" class="no np jj la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">克隆存储库</li><li id="95df" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">创建虚拟环境</li><li id="476f" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">激活虚拟环境</li><li id="7984" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">在需求文本中安装库</li><li id="6232" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">运行服务器</li></ul><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="8a9e" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### Terminal ###</strong></span><span id="d9ce" class="nh ni jj nd b gy nn nk l nl nm">$mkdir base<br/>$cd base<br/>$git clone <a class="ae jg" href="https://github.com/alsm6169/flask_server_template.git" rel="noopener ugc nofollow" target="_blank">https://github.com/alsm6169/flask_server_template.git</a><br/>$cd flask_server_template/<br/>$conda create --name ptest<br/>$conda activate ptest<br/>$conda install --file requirements.txt<br/>$python main.py</span></pre><ul class=""><li id="2fbe" class="no np jj la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">在另一个 shell 中运行测试文件。或者可选地，</li><li id="e4b7" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">打开浏览器运行请求</li></ul><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="2814" class="nh ni jj nd b gy nj nk l nl nm"><strong class="nd jk">### Browser ###</strong></span><span id="da32" class="nh ni jj nd b gy nn nk l nl nm">http://127.0.0.1:5000</span><span id="eb27" class="nh ni jj nd b gy nn nk l nl nm"><em class="mj">http://127.0.0.1:5000/module/v01/functions/film_list_orm</em></span><span id="4652" class="nh ni jj nd b gy nn nk l nl nm"><em class="mj">http://127.0.0.1:5000/module/v01/functions/film_actors_orm?title=Alaska Phantom</em></span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="3baa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就把我带到了这篇文章的结尾。希望你会发现它很容易理解和使用。如果您有任何反馈/改进，请告诉我。</p></div></div>    
</body>
</html>