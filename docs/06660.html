<html>
<head>
<title>Image Classification using GluonCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 GluonCV 的图像分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-classification-using-gluoncv-f6ae5401d6ae?source=collection_archive---------59-----------------------#2020-05-25">https://towardsdatascience.com/image-classification-using-gluoncv-f6ae5401d6ae?source=collection_archive---------59-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="47a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 GluonCV 的预训练图像分类网络实现网球检测器</h2></div><p id="33c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae le" rel="noopener" target="_blank" href="/object-detection-using-gluoncv-b7940670ba54">的上一篇文章</a>中，我们讨论了使用 GluonCV 的物体检测。在本文中，我们将讨论如何实现一个二值图像分类器，使用 GluonCV 的预训练图像分类网络对给定图像是否是网球进行分类。我们一步一步地实现机器学习管道，从加载和转换输入图像，到加载和使用预训练的模型。</p><ol class=""><li id="2122" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated"><strong class="kk iu">导入库</strong></li></ol><p id="67e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了开始一些初始设置，我们将导入包并设置数据的路径。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="5701" class="lx ly it lt b gy lz ma l mb mc">import mxnet as mx<br/>import gluoncv as gcv<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>import os<br/>from pathlib import Path</span></pre><p id="b037" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 2。加载图像</strong></p><p id="d881" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了加载图像，让我们实现一个函数，在给定文件路径的情况下从磁盘加载图像。该函数应该返回一个 8 位图像数组，这是在 MXNet 的 NDArray 格式和 HWC 布局(即高度，宽度，然后通道)。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="5fdf" class="lx ly it lt b gy lz ma l mb mc">def <strong class="lt iu">load_image</strong>(filepath):<br/>    image = mx.image.imread(filepath)<br/>    return image</span></pre><p id="5c67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 3。变换图像</strong></p><p id="9778" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">加载图像后，我们应该转换图像，以便它可以用作预训练网络的输入。我们计划在<strong class="kk iu"> ImageNet 上使用预先训练好的网络。</strong>因此，图像转换应遵循用于<strong class="kk iu"> ImageNet </strong>预训练的相同步骤。图像应通过以下方式进行转换:</p><ol class=""><li id="b023" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated">将最短尺寸调整为 224。例如(448，1792) -&gt; (224，896)。</li><li id="f322" class="lf lg it kk b kl md ko me kr mf kv mg kz mh ld lk ll lm ln bi translated">裁剪到尺寸为(224，224)的中心正方形。</li><li id="c893" class="lf lg it kk b kl md ko me kr mf kv mg kz mh ld lk ll lm ln bi translated">将图像从 HWC 布局转换为 CHW 布局。</li><li id="54da" class="lf lg it kk b kl md ko me kr mf kv mg kz mh ld lk ll lm ln bi translated">使用 ImageNet 统计数据标准化图像(即每个颜色通道的平均值和方差)。</li><li id="89ff" class="lf lg it kk b kl md ko me kr mf kv mg kz mh ld lk ll lm ln bi translated">创建一批 1 个图像。</li></ol><p id="4e66" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以使用下面的函数来实现。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="4459" class="lx ly it lt b gy lz ma l mb mc">def <strong class="lt iu">transform_image</strong>(array):<br/>    image = gcv.data.transforms.presets.imagenet.transform_eval(array)<br/>    return image</span></pre><p id="791f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 4。加载模型</strong></p><p id="8c1e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用已经在 ImageNet 上预先训练好的<strong class="kk iu"> MobileNet 1.0 </strong>图像分类模型。该模型可以从 GluonCV 模型动物园加载，如下所示:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="373f" class="lx ly it lt b gy lz ma l mb mc">def <strong class="lt iu">load_pretrained_classification_network</strong>():<br/>    model = gcv.model_zoo.get_model('MobileNet1.0', pretrained=True, root = M3_MODELS)<br/>    return model</span></pre><p id="6e99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 5。使用型号</strong></p><p id="6cdd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">加载图像后，下一个任务是通过预训练的网络传递变换后的图像，以获得所有 ImageNet 类的预测概率(现在忽略网球类)。</p><p id="6656" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提示 1 :不要忘记你通常是在处理一批图像，即使你只有一张图像。</p><p id="a3e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提示 2:记住我们网络的直接输出不是概率。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="f9fa" class="lx ly it lt b gy lz ma l mb mc">def <strong class="lt iu">predict_probabilities</strong>(network, data):<br/>    prediction = network(data)<br/>    prediction = prediction[0]<br/>    probability = mx.nd.softmax(prediction)<br/>    return probability</span></pre><p id="f57c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 6。查找类别标签</strong></p><p id="435b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 imageNet 中有 1000 个类。对于网球分类，我们需要找到与网球相关的概率(在 1000 个类别中)。这可以通过实现返回给定类标签的索引的函数来完成(例如，<code class="fe mi mj mk lt b">admiral</code>是索引<code class="fe mi mj mk lt b">321</code>)。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="b2a5" class="lx ly it lt b gy lz ma l mb mc">def <strong class="lt iu">find_class_idx</strong>(label):<br/>    for i in range(len(network.classes)):<br/>        if label == network.classes[i]:<br/>            return i</span></pre><p id="9cf7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用上面的函数来查找网球的正确索引，您应该实现一个函数来从网络计算的 1000 个类概率中分割网球的计算概率。它还应该将概率从 MXNet <code class="fe mi mj mk lt b">NDArray</code>转换为 NumPy <code class="fe mi mj mk lt b">float32</code>。我们将使用它作为图像是一个网球的置信度得分。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="4f56" class="lx ly it lt b gy lz ma l mb mc">def <strong class="lt iu">slice_tennis_ball_class</strong>(pred_probas):<br/>    tennis_prob = pred_probas[find_class_idx('tennis ball')]<br/>    return tennis_prob.astype('float32').asscalar()</span></pre><p id="f38d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 7。网球图像分类</strong></p><p id="ffb6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">把所有的碎片放在一起，我们就可以对一个图像进行分类，可以分辨出一个图像是不是网球。这可以通过创建一个名为<code class="fe mi mj mk lt b">TennisBallClassifier</code>的类来实现整个分类管道来实现。您应该注意到，预训练模型在初始化期间被加载一次，然后它应该在<code class="fe mi mj mk lt b">classify</code>方法中使用。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ce28" class="lx ly it lt b gy lz ma l mb mc">class <strong class="lt iu">TennisBallClassifier</strong>():<br/>    def <strong class="lt iu">__init__</strong>(self):<br/>        self._network = load_pretrained_classification_network()<br/>        <br/>    def <strong class="lt iu">classify</strong>(self, filepath):<br/>        image = <strong class="lt iu">load_image</strong>(filepath)<br/>        transformed_image = <strong class="lt iu">transform_image</strong>(image)<br/>        self._visualize(transformed_image)<br/>        probabilities = <strong class="lt iu">predict_probabilities</strong>(self._network, transformed_image)<br/>        pred_proba = <strong class="lt iu">slice_tennis_ball_class</strong>(probabilities)   <br/>        print('{0:.2%} confidence that image is a tennis ball.'.format(pred_proba))<br/>        return pred_proba<br/>    <br/>    def <strong class="lt iu">_visualize</strong>(self, transformed_image):<br/>        chw_image = transformed_image[0].transpose((1,2,0))<br/>        chw_image = ((chw_image * 64) + 128).clip(0, 255).astype('uint8')<br/>        plt.imshow(chw_image.asnumpy())</span><span id="613f" class="lx ly it lt b gy ml ma l mb mc">classifier = TennisBallClassifier()<br/>filepath = Path(M3_IMAGES, 'erik-mclean-D23_XPbsx-8-unsplash.jpg')<br/>pred_proba = classifier.classify(filepath)<br/>np.testing.assert_almost_equal(pred_proba, 2.0355723e-05, decimal=3)</span></pre><figure class="lo lp lq lr gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mm"><img src="../Images/b8c2d6fc10089497ccec1dc7613f7571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ljdUGfoH8tL3Fv7M5lbOLA.png"/></div></div></figure><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="50a3" class="lx ly it lt b gy lz ma l mb mc">filepath = Path(M3_IMAGES, 'marvin-ronsdorf-CA998Anw2Lg-unsplash.jpg')<br/>pred_proba = classifier.classify(filepath)<br/>np.testing.assert_almost_equal(pred_proba, 0.9988895, decimal=3)</span></pre><figure class="lo lp lq lr gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mu"><img src="../Images/1950498b51e0a57357e885ad9d8b404f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IDJ4PwtzlAE4g_u2w2EUXQ.png"/></div></div></figure><p id="7db2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，使用预先训练的模型，我们可以正确地分类图像是否是网球。如上所示，在对足球进行分类时，我们看到该模型给出了 0%的置信度认为它是网球，而对网球图像进行了 99.9%置信度的正确分类。</p><blockquote class="mv mw mx"><p id="8fcd" class="ki kj my kk b kl km ju kn ko kp jx kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">成为媒体会员<a class="ae le" href="https://medium.com/@rmesfrmpkr/membership" rel="noopener">这里</a>支持独立写作，每月 5 美元，获得媒体上的所有故事。</p></blockquote></div></div>    
</body>
</html>