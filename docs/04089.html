<html>
<head>
<title>Working with Anonymous Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用匿名函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/working-with-anonymous-functions-d985003edb3d?source=collection_archive---------40-----------------------#2020-04-14">https://towardsdatascience.com/working-with-anonymous-functions-d985003edb3d?source=collection_archive---------40-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="058a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这些简单的操作快捷方式节省您的时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c311df544e17d2d02c4ee8e41401176d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lTYjGIU-D006hH74"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">塔里克·黑格在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e90d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们处理数据时，我们很少会让它保持原样、不被转换或不被聚集。必须以高效的方式清理、转换、总结和描述数据，以便为实现准备数据。创建函数是一种标准且可靠的做法，在对数据应用预定义的操作时可以节省时间。然而，尽管定义自己的函数有时非常重要，但有时却完全没有必要。我们可以对一个特定的级数使用特殊类型的函数来加速这个过程，而不牺牲计算效率或精度。</p><h1 id="978f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">匿名函数</h1><p id="5fac" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们在 Python 中实现了一些函数，但没有给它们命名(因此，匿名)。这些函数只能在数据操作过程的特定时刻使用一次。<strong class="lb iu">介绍，λ函数:</strong></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5ae9" class="mx lw it mt b gy my mz l na nb">lambda &lt;arguments&gt;: &lt;expression&gt;</span></pre><p id="5e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是 lambda 函数的一般语法。我们稍后将进一步深入，但首先让我们定义语法。</p><ul class=""><li id="54a9" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">Lambda 函数可以有任意数量的参数(将要操作的内容)，但只能有一个表达式(将要计算和返回的内容)</li><li id="6ad8" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">lambda 函数可以应用于任何需要函数对象的地方</li><li id="c871" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">仅限于单一表达式</li></ul><p id="c1b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来比较一下匿名 lambda 函数和传统定义的 function 对象在试图将一个列表的所有内容加倍时的情况:</p><p id="6763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">繁体:</strong></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1dee" class="mx lw it mt b gy my mz l na nb">list1 = [1, 2, 3]</span><span id="5c78" class="mx lw it mt b gy nq mz l na nb">def double_items(list1):</span><span id="1180" class="mx lw it mt b gy nq mz l na nb">     list2 = []    <br/>     for x in list1:<br/>          list2.append(x*2)</span><span id="d76d" class="mx lw it mt b gy nq mz l na nb">     return list2</span></pre><p id="ca97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它返回:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0761" class="mx lw it mt b gy my mz l na nb">double_items(list1)</span><span id="2c0d" class="mx lw it mt b gy nq mz l na nb">Output: [2,4,6]</span></pre><p id="f72c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">兰巴:</strong></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e7e7" class="mx lw it mt b gy my mz l na nb">list1 = [1,2,3]<br/>list2 = list(map(lambda x: x*2, list1))</span></pre><p id="8ed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它返回:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="13e6" class="mx lw it mt b gy my mz l na nb">print(list2)</span><span id="d86b" class="mx lw it mt b gy nq mz l na nb">Output: [2,4,6]</span></pre><p id="2665" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以清楚地看到，第二个 lambda 函数允许我们在一行代码中完成相同的计算，而不需要定义不必要的代码块。</p><h1 id="6f31" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Lambda 场景:</h1><p id="3c74" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">lambda 匿名函数可以应用于三种主要场景:filter()、map()和 reduce()。</p><h2 id="28f3" class="mx lw it bd lx nr ns dn mb nt nu dp mf li nv nw mh lm nx ny mj lq nz oa ml ob bi translated">过滤器()</h2><p id="5c87" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个函数将一个列表作为它的参数，然后过滤掉列表中的元素，为表达式返回“true”。我们下面看到的函数将只返回<em class="oc">偶数</em>列表项(使用了“%”模数运算符)。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="515d" class="mx lw it mt b gy my mz l na nb">ex_list = [33, 2, 42, 1, 47, 430, 23, 98, 12]<br/>final = list(filter(lambda x: (x%2 == 0), ex_list))</span></pre><p id="76c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ed41" class="mx lw it mt b gy my mz l na nb">print(final)</span><span id="ccf9" class="mx lw it mt b gy nq mz l na nb">[2, 42, 430, 98, 12]</span></pre><h2 id="f774" class="mx lw it bd lx nr ns dn mb nt nu dp mf li nv nw mh lm nx ny mj lq nz oa ml ob bi translated"><strong class="ak">地图()</strong></h2><p id="3b77" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我处理数据的经验中，这个函数是目前使用最多的匿名函数。我们已经在最初的例子中使用了 map。当与熊猫系列对象结合使用时，贴图功能也非常有效。Map 是一个带两个参数的函数:函数名(或函数本身)和序列(一个列表、一个熊猫系列等)。).因此，map 函数与 lambda 函数一起将<em class="oc">映射</em>序列中所有元素的函数。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9367" class="mx lw it mt b gy my mz l na nb">a = [1, 2, 3, 4]<br/>b = [5, 6, 7, 8]</span><span id="adc3" class="mx lw it mt b gy nq mz l na nb">sum_a_b = map(lambda x, y: x + y, a, b)</span></pre><p id="1224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="44b3" class="mx lw it mt b gy my mz l na nb">print(sum_a_b)</span><span id="9bf5" class="mx lw it mt b gy nq mz l na nb">[6, 8, 10, 12]</span></pre><p id="35b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例 map/lambda 组合采用函数<em class="oc"> x + y，</em>以及序列 a 和 b。它将每个序列中的各个项目分别视为函数的 x 和 y，以返回结果。</p><h2 id="b16e" class="mx lw it bd lx nr ns dn mb nt nu dp mf li nv nw mh lm nx ny mj lq nz oa ml ob bi translated">减少()</h2><p id="a300" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个函数也将一个列表作为参数，然后，你猜对了，通过对列表对的重复操作来减少列表。我们可以在“functools”模块中找到这个函数，我们必须首先导入它。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0ee7" class="mx lw it mt b gy my mz l na nb">from functools import reduce</span><span id="a7dd" class="mx lw it mt b gy nq mz l na nb">ex_list = [24, 5, 6, 45, 96, 123, 69]<br/>difference = reduce(lambda x: y: x - y, ex_list)</span></pre><p id="0cae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5f67" class="mx lw it mt b gy my mz l na nb">print(difference)</span><span id="4bb5" class="mx lw it mt b gy nq mz l na nb">-320</span></pre><p id="69eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数取列表中第一项和第二项的差，然后继续下去，直到列表的最后一个元素被求差。类似地，它将 lambda 函数作为要执行的操作，将 ex_list 作为执行函数的序列。</p></div></div>    
</body>
</html>