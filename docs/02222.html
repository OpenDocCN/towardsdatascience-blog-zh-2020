<html>
<head>
<title>Building an Incremental Recommender System: Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建增量推荐系统:第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-an-incremental-recommender-system-part-ii-2d0e782b2cf6?source=collection_archive---------42-----------------------#2020-03-02">https://towardsdatascience.com/building-an-incremental-recommender-system-part-ii-2d0e782b2cf6?source=collection_archive---------42-----------------------#2020-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8680" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">自信地超越最先进的技术！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1387cf1b310dad82dc24ac9032ec3936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_TV_r0qDi2jtVqmpojosQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/netflix?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@thibaultpenin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Thibault Penin </a>拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="0bc0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">克里斯·安德森在他 2004 年题为《长尾理论》的文章中说，我们正在离开信息时代，进入推荐时代。<strong class="li iu">除非我们有办法过滤我们每天吸收的过量信息，只保留对我们重要的信息，否则可能的选择会变成噪音。</strong></p><p id="97b8" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在本系列的第一部分<a class="ae ky" rel="noopener" target="_blank" href="/building-an-incremental-recommender-system-8836e30afaef">中，我们讨论了推荐系统应该理想地适应变化。为此，我们使用 Pytorch 上构建的 python 库</a><a class="ae ky" href="https://pypi.org/project/cf-step/" rel="noopener ugc nofollow" target="_blank"> CF Step </a>实现了一个推荐系统，它方便了增量推荐系统的编译。</p><div class="mc md gp gr me mf"><a rel="noopener follow" target="_blank" href="/building-an-incremental-recommender-system-8836e30afaef"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">构建一个增量推荐系统</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">理想情况下，推荐系统应该能够适应发生的变化。</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt ks mf"/></div></div></a></div><p id="f808" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们将我们的模型应用于<a class="ae ky" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank"> Movielens 1m </a>数据集，我们能够重现相关出版物的结果；<a class="ae ky" href="https://s3.amazonaws.com/academia.edu.documents/41648623/Fast_Incremental_Matrix_Factorization_fo20160127-32666-jb2771.pdf?response-content-disposition=inline%3B%20filename%3DFast_Incremental_Matrix_Factorization_fo.pdf&amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWOWYYGZ2Y53UL3A%2F20200227%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20200227T172248Z&amp;X-Amz-Expires=3600&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=170da994bc340a019e3b20bfb688d2b9ef85e6d040dba9aa697e0c941f481cf9" rel="noopener ugc nofollow" target="_blank">Joao vina GRE 等人提出的用于推荐的快速增量矩阵分解，仅提供正面反馈</a>。</p><p id="01eb" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这个故事中，我们的目标是走得更远，获得更好的结果。以前，我们能够得到平均召回率@10 ≈ 0.05，这是论文中展示的结果。让我们看看我们能否用一个简单的技巧战胜它！</p><blockquote class="mu mv mw"><p id="47cd" class="lg lh mx li b lj lk ju ll lm ln jx lo my lq lr ls mz lu lv lw na ly lz ma mb im bi translated"><a class="ae ky" href="https://mailchi.mp/d2d2d4a109b5/learning-rate-newsletter" rel="noopener ugc nofollow" target="_blank"> Learning Rate </a>是一份时事通讯，面向那些对 AI 和 MLOps 世界感到好奇的人。你会在每周五收到我关于最新人工智能新闻和文章的更新和想法。订阅<a class="ae ky" href="https://mailchi.mp/d2d2d4a109b5/learning-rate-newsletter" rel="noopener ugc nofollow" target="_blank">这里</a>！</p></blockquote><h1 id="b72a" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">充满信心地建设</h1><p id="7c5f" class="pw-post-body-paragraph lg lh it li b lj nt ju ll lm nu jx lo lp nv lr ls lt nw lv lw lx nx lz ma mb im bi translated">为了获得更好的结果，我们需要使用整个数据集。这样做有望给我们提供更多的信息，特别是在训练过程中包含负面例子的方法。在本系列的第一部分中，我们只利用了 Movielens 数据集中的正面例子。这些是用户与电影的互动，用户给电影打了 5 颗星。</p><blockquote class="ny"><p id="84c4" class="nz oa it bd ob oc od oe of og oh mb dk translated">为了在我们的指标上获得更好的性能，我们需要使用整个数据集，并专门开发一种方法，以某种方式允许我们包括负面评级。</p></blockquote><p id="c353" class="pw-post-body-paragraph lg lh it li b lj oi ju ll lm oj jx lo lp ok lr ls lt ol lv lw lx om lz ma mb im bi translated"><strong class="li iu">然而，根据我们的隐式反馈假设，我们应该有办法将表示<em class="mx">偏好</em>的评级值转换为表示<em class="mx">置信度</em> </strong>的数字。换句话说，我们必须用数学来表达，如果用户<code class="fe on oo op oq b">u</code>给电影<code class="fe on oo op oq b">i</code>打了一颗星，我们肯定用户<code class="fe on oo op oq b">u</code>绝对讨厌电影<code class="fe on oo op oq b">i</code>。另一方面，我们有点确信用户喜欢一部评分为 4 星的电影。三星级这个棘手的案例又是怎么回事呢？</p><h2 id="f6ba" class="or nc it bd nd os ot dn nh ou ov dp nl lp ow ox nn lt oy oz np lx pa pb nr pc bi translated">置信函数</h2><p id="2c23" class="pw-post-body-paragraph lg lh it li b lj nt ju ll lm nu jx lo lp nv lr ls lt nw lv lw lx nx lz ma mb im bi translated"><em class="mx">置信度函数</em>只是一个试探，它将某个用户-项目交互的评级作为输入，并产生一个新的实数值。</p><p id="8734" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们传递给函数的评级可以是我们拥有的任何隐含信息。例如，它可以是消费者购买特定产品的次数、观众观看电影的时间或任何其他对问题有意义的提示。我们的工作就是设计这样一个函数。</p><h2 id="c338" class="or nc it bd nd os ot dn nh ou ov dp nl lp ow ox nn lt oy oz np lx pa pb nr pc bi translated">损失函数</h2><p id="16c3" class="pw-post-body-paragraph lg lh it li b lj nt ju ll lm nu jx lo lp nv lr ls lt nw lv lw lx nx lz ma mb im bi translated">在我们在<a class="ae ky" rel="noopener" target="_blank" href="/building-an-incremental-recommender-system-8836e30afaef">第一部分</a>中讨论的例子中，我们针对我们的问题优化了一个损失函数；只有正面的反馈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/1b5b563ee72449213740c5ffa5522407.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*5B_Wkg5Pu4NmAG7vRWsFVw.png"/></div></figure><p id="0f30" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">目标总是 1(由于仅正的假设),并且预测评级来自对应于活动用户的向量与对应于活动项目的向量的点积。</p><p id="065c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu">既然我们想包含整个数据集，目标并不总是等于</strong> <code class="fe on oo op oq b"><strong class="li iu">1</strong></code> <strong class="li iu">。可以是正反馈的</strong> <code class="fe on oo op oq b"><strong class="li iu">1</strong></code> <strong class="li iu">和负反馈的</strong> <code class="fe on oo op oq b"><strong class="li iu">0</strong></code> <strong class="li iu">。因此，我们首先定义返回目标的偏好函数。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/da29ecc98de52db5c8b19cd81acb50e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*p2VGRT7iKCl5b2ADJlCmDg.png"/></div></figure><p id="f36e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因此，就像之前我们在数据集中定义一个新的<em class="mx">偏好</em>列，如果评级大于<code class="fe on oo op oq b">3</code>则取值<code class="fe on oo op oq b">1</code>，否则取值<code class="fe on oo op oq b">0</code>。</p><p id="a5a4" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">最后，损失函数也应该改变以说明二进制目标。因此，我们将使用的是一个加权变量的二元交叉熵函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/fc22ca6037ee1b92afaff1f1cdb4219a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1n6Nww6k49wca5qWEnVzEg.png"/></div></div></figure><p id="b85c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果偏好是<code class="fe on oo op oq b">1</code>，那么括号内等式的第一部分仍然有效，它乘以我们的置信水平。因此，如果偏好是<code class="fe on oo op oq b">0</code>，括号内的第二部分保留下来，并乘以置信度函数的结果。</p><p id="7793" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu">直觉上，我们对损失函数说，如果我们对自己通过偏好函数(</strong> <code class="fe on oo op oq b"><strong class="li iu">0</strong></code> <strong class="li iu">或</strong> <code class="fe on oo op oq b"><strong class="li iu">1</strong></code> <strong class="li iu">)分配的目标非常有信心，而你弄错了，请多注意这个错误，这很重要！另一方面，如果我们对我们作为目标值传递的</strong> <code class="fe on oo op oq b"><strong class="li iu">1</strong></code> <strong class="li iu">或</strong> <code class="fe on oo op oq b"><strong class="li iu">0</strong></code> <strong class="li iu">不那么确信，无论如何都要使用它，但是如果你弄错了也不要太担心。</strong>想象一下我们之前看到的 3 星评级的案例。我们将<code class="fe on oo op oq b">0</code>作为目标，但是我们非常怀疑这是真的。</p><p id="28cc" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为此，让我们设计一个支持我们直觉的简单置信函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/80a4c997fca2c7744da17640a042147d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*bL50FCZKAwlCrcQQ13lnjA.png"/></div></figure><p id="c09a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们想通过这个函数传达的是，如果我们得到的评分是<code class="fe on oo op oq b">1</code>或<code class="fe on oo op oq b">5</code>，那么我们分别是对目标有信心的<code class="fe on oo op oq b">α</code>分、<code class="fe on oo op oq b">0</code>分或<code class="fe on oo op oq b">1</code>分。然而，当我们有一个额定值<code class="fe on oo op oq b">3</code>时，我们对我们计算为偏好的<code class="fe on oo op oq b">0</code>没有任何信心，因此我们用<code class="fe on oo op oq b">0.1α</code>乘以损失。数字<code class="fe on oo op oq b">α</code>只是我们适应数据的一个超参数。现在，让我们看看所有这些措施的实施情况，并获得结果。</p><h1 id="270b" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">实施和评估</h1><p id="c88f" class="pw-post-body-paragraph lg lh it li b lj nt ju ll lm nu jx lo lp nv lr ls lt nw lv lw lx nx lz ma mb im bi translated">该实现与第一部分中的<a class="ae ky" rel="noopener" target="_blank" href="/building-an-incremental-recommender-system-8836e30afaef">相似，因此我们将在此强调其变化。</a></p><p id="c177" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这种情况下，我们希望创建 preference 列，但是使用整个数据集，而不仅仅是正面的例子。此外，我们现在认为 4 级也是正面例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/b39a71effdb0574d62692c7fdc2ecf9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*nfmUbfBZ57BeH9EVBy1ttg.png"/></div></figure><p id="fd85" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">接下来，我们需要在代码中定义我们在上一节中设计的简单置信函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="be3e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">接下来，我们需要定义我们的模型，以便利用置信度函数。幸运的是，CF Step 的 API 已经接受了这样的函数。默认情况下，它定义了一个总是返回<code class="fe on oo op oq b">1</code>的<code class="fe on oo op oq b">lamda</code>函数，所以没有权重。现在我们将传递我们指定的函数。此外，我们将<code class="fe on oo op oq b">True</code>传递给<code class="fe on oo op oq b">SimpleCF</code>网络的<code class="fe on oo op oq b">binary</code>关键字，告诉它在输出上使用 sigmoid 激活。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="8fd8" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">传递给<code class="fe on oo op oq b">SimpleCF</code>的<code class="fe on oo op oq b">a</code>和<code class="fe on oo op oq b">b</code>关键字参数只是我们用于嵌入初始化的均匀分布的开始和结束限制。</p><p id="1b2d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">其他一切与第一部分相同。为了比较这两种方法，我们将一起绘制结果。蓝线代表我们仅使用正例得到的结果，橙线显示使用置信度函数的整个数据集的结果。显然，第二种方法更优越。我们刚刚超越了出版物中呈现的结果！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/c83ad64aa751157b800c65124bbdfb11.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*BX4gHRCuT2i0VkYdjhflEQ.png"/></div></figure><h1 id="e508" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">结论</h1><p id="5949" class="pw-post-body-paragraph lg lh it li b lj nt ju ll lm nu jx lo lp nv lr ls lt nw lv lw lx nx lz ma mb im bi translated">这个故事从我们在第一部分中离开的地方开始了构建一个增量推荐系统的主题。我们提出了一个置信函数的概念，它允许我们使用整个数据集并包含负面评价。我们展示了如何使用 CF Step 库，最重要的是，我们超越了<a class="ae ky" rel="noopener" target="_blank" href="/building-an-incremental-recommender-system-8836e30afaef">第一部分</a>的结果。</p><p id="a55c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">有许多方法可以设计一个置信度函数，算法的性能显然取决于我们的选择。此外，我们还可以使用其他方法来获得更好的结果。如果我们能在下面的故事中用 NMF 学的电影嵌入，那么迁移学习呢？这留给读者作为练习，因为 CF Step 支持加载预先计算的嵌入矩阵并冻结它们，所以它们不能被进一步训练。</p><div class="mc md gp gr me mf"><a rel="noopener follow" target="_blank" href="/extract-a-films-inherent-vice-from-its-plot-f43525abf0dd"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">从电影情节中提取性本恶</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">如何使用非负矩阵分解得到不仅仅是你的电影摘要？</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mo l"><div class="pl l mq mr ms mo mt ks mf"/></div></div></a></div><blockquote class="mu mv mw"><p id="a3e2" class="lg lh mx li b lj lk ju ll lm ln jx lo my lq lr ls mz lu lv lw na ly lz ma mb im bi translated"><strong class="li iu">我叫 Dimitris Poulopoulos，是希腊比雷埃夫斯大学<em class="it"/></strong><a class="ae ky" href="https://bigdatastack.eu/" rel="noopener ugc nofollow" target="_blank"><strong class="li iu">BigDataStack</strong></a><strong class="li iu"><em class="it"/>的机器学习研究员和博士(c)。我曾为欧洲委员会、欧盟统计局、国际货币基金组织、欧洲中央银行、经合组织和宜家等主要客户设计和实施人工智能和软件解决方案。如果你有兴趣阅读更多关于机器学习、深度学习和数据科学的帖子，请在 twitter 上关注我的</strong><a class="ae ky" href="https://medium.com/@dpoulopoulos" rel="noopener"><strong class="li iu"/></a><strong class="li iu"/><a class="ae ky" href="https://www.linkedin.com/in/dpoulopoulos/" rel="noopener ugc nofollow" target="_blank"><strong class="li iu">LinkedIn</strong></a><strong class="li iu">或</strong><a class="ae ky" href="https://twitter.com/james2pl" rel="noopener ugc nofollow" target="_blank"><strong class="li iu">@ james2pl</strong></a><strong class="li iu">。</strong></p></blockquote></div></div>    
</body>
</html>