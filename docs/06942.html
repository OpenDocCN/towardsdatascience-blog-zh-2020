<html>
<head>
<title>Optimizing Your Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化您的Python代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimizing-your-python-code-156d4b8f4a29?source=collection_archive---------4-----------------------#2020-05-29">https://towardsdatascience.com/optimizing-your-python-code-156d4b8f4a29?source=collection_archive---------4-----------------------#2020-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dc58" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python处理大量数据的基本技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5c63acf00277c662fb96b2ff7fafea0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1X0-98EiQNkwBJj2vnTTqQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cdr6934?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="9ed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然您只是偶尔需要运行一个分析器来分析您的代码并找到<a class="ae ky" href="https://annaeastori.medium.com/profiling-in-python-83415daa844c" rel="noopener">瓶颈</a>，但是养成编写高效代码的习惯并找出您可以立即改进的地方绝对是一个好主意。</p><p id="5b3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在寻找优化代码的方法时，要记住的一件重要事情是，很可能总会有一些折衷要接受。例如，它要么是一段运行更快的代码，要么是一段更简单的代码。这里的简单不仅仅指“看起来不那么酷的代码”(想想著名的Python“一行程序”)。更简单的代码意味着更容易维护和测试。</p><p id="7abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，关于如何优化Python代码的每一个技巧都需要根据您的情况进行严格的检查。当然，有一般性的观察，但是你也可能有一个上下文，在这个上下文中那些观察是不相关的，或者甚至产生相反的结果。所以你需要了解“幕后”发生了什么，以及它将如何在你的案例中起作用。</p><p id="1758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在某些情况下，你确实需要给你的代码一点提升，这里是我在学习Python时发现的一些有用的地方。</p><h2 id="cb20" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">1.列出理解</h2><p id="c77e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Python中，一个伟大的语法结构是<a class="ae ky" href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noopener ugc nofollow" target="_blank"> list comprehensions </a>，它在创建列表时比传统的循环计算效率更高。因此，如果您需要一个二进制特征向量作为数据点，其中所有负数将被分配0，其余的将被分配1，而不是:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f7e9" class="lv lw it mu b gy my mz l na nb">&gt;&gt;&gt; input_list = [1, 2, -3]<br/>&gt;&gt;&gt; output_list = []</span><span id="b2e4" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;&gt; for x in input_list:<br/>...    if x &gt;= 0:</span><span id="cda2" class="lv lw it mu b gy nc mz l na nb">...        output_list.append(1)</span><span id="0529" class="lv lw it mu b gy nc mz l na nb">...    else:</span><span id="ee31" class="lv lw it mu b gy nc mz l na nb">...        output_list.append(0)</span><span id="e7e3" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;&gt; output_list</span><span id="baf3" class="lv lw it mu b gy nc mz l na nb">[1, 1, 0]</span></pre><p id="5e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2cd1" class="lv lw it mu b gy my mz l na nb">&gt;&gt;&gt; output_list = [1 if x &gt;= 0 else 0 for x in input_list]</span><span id="e3a6" class="lv lw it mu b gy nc mz l na nb">&gt;&gt;&gt; output_list</span><span id="d5db" class="lv lw it mu b gy nc mz l na nb">[1, 1, 0]</span></pre><p id="17f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以尝试使用<code class="fe nd ne nf mu b"><a class="ae ky" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank">timeit</a></code>模块来比较哪种实现运行得更快。</p><p id="65d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以像嵌套循环一样使用嵌套列表理解，但是通常不鼓励这样做，因为这样会使代码更难阅读、维护和测试。</p><h2 id="f638" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">2.尽可能避免for循环和列表理解</h2><p id="3d33" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">事实上，在前面的例子中，如果您创建一个只有一个初始化值的向量，而不是使用低效的for循环甚至列表理解，您可以这样做:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="923e" class="lv lw it mu b gy my mz l na nb">&gt;&gt;&gt; my_list2 = [0] * len(my_list1)<br/>&gt;&gt;&gt; my_list2<br/>[0, 0, 0]</span></pre><h2 id="8ab1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">3.避免不必要的功能</h2><p id="89a5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">一个很好的例子是函数调用，这种方法可以帮助减少大量的运行时复杂性，但需要仔细考虑权衡。虽然您确实希望函数提供良好的抽象性、可扩展性和可重用性，但是您可能不希望为每一件事情都提供一个函数，因为在Python中函数调用是非常昂贵的(如果您感兴趣，在这篇<a class="ae ky" href="https://ilovesymposia.com/2015/12/10/the-cost-of-a-python-function-call/" rel="noopener ugc nofollow" target="_blank">文章</a>中有一些有趣的观察)。所以有时候，你可能想要牺牲，例如，写一个getter和/或setter。另一方面，函数越少，代码的可测试性越差。因此，最终的决定实际上取决于您的具体应用。</p><h2 id="7f39" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">4.尽可能使用内置的</h2><p id="4eb6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">另一个与函数相关的提示是选择<a class="ae ky" href="https://docs.python.org/3/library/functions.html" rel="noopener ugc nofollow" target="_blank">内置函数</a>，如<code class="fe nd ne nf mu b">max()</code>、<code class="fe nd ne nf mu b">sum()</code>、<code class="fe nd ne nf mu b">map()</code>、<code class="fe nd ne nf mu b">reduce()</code>等。而不是自己完成这些计算——它们通常用C语言编写，运行速度会更快。此外，如果您使用内置函数——您需要为自己编写的测试代码会更少。因此，举例来说，如果您想要一个包含所有<code class="fe nd ne nf mu b">input_list</code>绝对值的集合，您可以这样做:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a38b" class="lv lw it mu b gy my mz l na nb">&gt;&gt;&gt; output_set = set(map(abs, input_list))<br/>&gt;&gt;&gt; output_set<br/>{1, 2, 3}</span></pre><p id="dc32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在处理文本数据，用于字符串连接，而不是<code class="fe nd ne nf mu b">+=</code>:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7711" class="lv lw it mu b gy my mz l na nb">&gt;&gt;&gt; sentence_list = ['This ', 'is ', 'a ', 'sentence.']<br/>&gt;&gt;&gt; sentence = ''<br/>&gt;&gt;&gt; for i in sentence_list:<br/>...     sentence += i<br/>&gt;&gt;&gt; sentence<br/>'This is a sentence.'</span></pre><p id="0188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nd ne nf mu b"><a class="ae ky" href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="noopener ugc nofollow" target="_blank">str.join()</a></code>:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3e1c" class="lv lw it mu b gy my mz l na nb">&gt;&gt;&gt; sentence = ''.join(sentence_list)<br/>&gt;&gt;&gt; sentence<br/>'This is a sentence.'</span></pre><p id="7c42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nd ne nf mu b">+=</code>，Python为每个中间字符串分配内存，如果使用了<code class="fe nd ne nf mu b">str.join()</code>，则只分配一次。</p><p id="c4cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nd ne nf mu b"><a class="ae ky" href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="noopener ugc nofollow" target="_blank">operator.itemgetter</a></code>进行分类。例如，如果您有一个名和姓的元组列表，如下所示:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="35c6" class="lv lw it mu b gy my mz l na nb">&gt;&gt;&gt; my_tuples =[('abbie', 'smith'), ('jane', 'adams'), ('adam', 'johnson')]</span></pre><p id="16ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认排序将返回以下内容:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a83e" class="lv lw it mu b gy my mz l na nb">&gt;&gt;&gt; sorted(my_tuples)<br/>[('abbie', 'smith'), ('adam', 'johnson'), ('jane', 'adams')]</span></pre><p id="0b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想按姓氏而不是名字来排序，你可以这样做:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="d055" class="lv lw it mu b gy my mz l na nb">&gt;&gt;&gt; sorted(my_tuples, key=operator.itemgetter(1))<br/>[('jane', 'adams'), ('adam', 'johnson'), ('abbie', 'smith')]</span></pre><h2 id="41ca" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">5.避开圆点</h2><p id="67fe" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果您有一个对象，并且正在使用它的一些属性，请先将它们赋给局部变量:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="fb53" class="lv lw it mu b gy my mz l na nb">rectangle_height = rectangle.height</span><span id="7f89" class="lv lw it mu b gy nc mz l na nb">rectangle_width = rectangle.width</span></pre><p id="cd6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以如果你在代码的后面计算，比如说，它的表面，你会做:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="214f" class="lv lw it mu b gy my mz l na nb">surface = rectangle_height * rectangle_width</span></pre><p id="2018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果以后你也计算它的周长，你将重复使用相同的变量:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c47d" class="lv lw it mu b gy my mz l na nb">perimeter = 2 * rectangle_height + 2 * rectangle_width</span></pre><p id="4a95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以再次使用<code class="fe nd ne nf mu b">timeit</code>模块来验证它为您节省了对矩形对象及其属性的每个引用的查找时间。</p><p id="a100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于同样的原因，通常不鼓励使用全局变量——你不希望浪费时间首先查找全局变量本身，然后查找你可能引用的它的每个属性。</p><p id="6f01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也适用于函数引用。例如，如果您正在处理一个数据点序列，并且正在将每个结果项追加到一个列表中，您可以执行以下操作:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c9ba" class="lv lw it mu b gy my mz l na nb">push_item = my_list.append</span></pre><p id="19b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后将其应用于每个结果项目:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3c4a" class="lv lw it mu b gy my mz l na nb">push_item(item)</span></pre><h2 id="d804" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">6.了解您的数据结构，并了解它们在您的Python版本中是如何工作的</h2><p id="0b14" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">除了每个典型数据结构的一般属性之外，例如，从链表中检索一个条目的复杂性，了解Python数据结构是如何实现的以及哪里可以节省一些CPU或内存也是很好的。例如，如果你在字典中查找一个键，你甚至不需要引用<code class="fe nd ne nf mu b">dict.keys()</code>，这在Python 3中会慢一点。你可以简单地做:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8d33" class="lv lw it mu b gy my mz l na nb">&gt;&gt;&gt; if k in dict:</span><span id="7b39" class="lv lw it mu b gy nc mz l na nb">...    do_something(k)</span></pre><p id="a1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python 2中，<code class="fe nd ne nf mu b">dict.keys()</code>甚至用来创建一个额外的键列表！</p><h2 id="6986" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">7.明智地选择一种方法</h2><p id="5b0c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">同时，不要忘记看一看更大的画面。如果您有一个要处理的项目列表，并且您知道在集合中查找是O(1)对列表中的O(n ),那么您可能会尝试将列表转换为集合:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7258" class="lv lw it mu b gy my mz l na nb">&gt;&gt;&gt; my_set = set(my_list)</span></pre><p id="b361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果你只是查找列表中的一项，如果你先把列表变成一个集合，你可能会让事情变得更糟。在幕后，Python将遍历整个列表，并将每个项目添加到一个新创建的集合中。创建集合的开销会使您失去在集合中查找的优势。</p><p id="2761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果您想有效地从列表中删除重复项，将它转换为set可能是一个不错的选择(尽管Python中还有其他选项可能更适合您的情况)。</p><p id="2aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，正如我之前提到的，有一些一般性的观察，但是你需要仔细检查它们，以了解它们如何在你的案例中起作用。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="3548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多更高级的方法来管理您的代码，以便使它更有效和执行得更快——从并行性或并发性到不同的技巧，如设计更小的对象，以便它们适合堆内存的缓存层而不是主缓存层。对于某些任务，您可能能够使用实际上为优化这些任务而设计的库。然而，以上是我在学习Python时不得不开始注意的第一件事。你在使用什么技巧和方法？</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="b705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在数据科学领域使用Python，请随意查看我关于Python 3.9中的<a class="ae ky" rel="noopener" target="_blank" href="/dictionary-union-operators-and-new-string-methods-in-python-3-9-4688b261a417">新特性</a>和Python中的<a class="ae ky" href="https://annaeastori.medium.com/concurrency-and-parallelism-in-python-bbd7af8c6625" rel="noopener">并发性</a>的文章！</p></div></div>    
</body>
</html>