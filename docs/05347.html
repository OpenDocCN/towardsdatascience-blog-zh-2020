<html>
<head>
<title>Creating fractals with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python创建分形</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-fractals-with-python-d2b663786da6?source=collection_archive---------2-----------------------#2020-05-06">https://towardsdatascience.com/creating-fractals-with-python-d2b663786da6?source=collection_archive---------2-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bdd7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在这个帖子里自己试试吧！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7ae232e601a3513c7dfcb873d7095ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIHFFDeWXisrZWN77tl6pQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分形艺术— <a class="ae ky" href="https://pixabay.com/illustrations/fractal-red-brown-glass-fantasy-2133856/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="96c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，什么是几何分形？几何分形是一种在不同尺度上具有重复结构的几何形状:无论你是否靠近图像，你都会看到相同的图案。或者，正如<a class="ae ky" href="https://en.wikipedia.org/wiki/Benoit_Mandelbrot" rel="noopener ugc nofollow" target="_blank">伯努瓦·曼德尔布罗</a>所定义的，“一个粗糙或支离破碎的几何形状，它可以被分割成多个部分，每个部分(至少近似地)是整体的缩小版”。</p><p id="927e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们如何在Python中构建一个分形？假设我们在不同的尺度上重复一个结构，我们将需要应用一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" rel="noopener ugc nofollow" target="_blank">递归解决方案</a>。此外，我们将使用<a class="ae ky" href="https://docs.python.org/3/library/turtle.html" rel="noopener ugc nofollow" target="_blank"> turtle </a>来绘制分形。在这篇文章中，我们将同时绘制分形树和科赫雪花。</p><h1 id="9436" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">绘制分形树</h1><p id="55a4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了创建一棵树，我们将每个分支分成两个子分支(左和右),并缩短新的子分支，直到达到我们自己定义的最小分支长度:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7e79" class="mx lw it mt b gy my mz l na nb">import turtle</span><span id="6a4a" class="mx lw it mt b gy nc mz l na nb">MINIMUM_BRANCH_LENGTH = 5</span><span id="1190" class="mx lw it mt b gy nc mz l na nb">def build_tree(t, branch_length, shorten_by, angle):<br/>  pass</span><span id="9599" class="mx lw it mt b gy nc mz l na nb">tree = turtle.Turtle()<br/>tree.hideturtle()<br/>tree.setheading(90)<br/>tree.color('green')</span><span id="1226" class="mx lw it mt b gy nc mz l na nb">build_tree(tree, 50, 5, 30)<br/>turtle.mainloop()</span></pre><p id="3e10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们只是定义了基础。我们导入了turtle并创建了turtle的一个实例。Turtle()，它将是在画布上移动并绘制我们的树的对象。然后我们用<a class="ae ky" href="https://docs.python.org/3/library/turtle.html#turtle.setheading" rel="noopener ugc nofollow" target="_blank"> setheading() </a>让它面朝上。我们还定义了递归函数的签名，如下所示:</p><ul class=""><li id="9eba" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">t:我们的海龟实例。</li><li id="54b5" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">branch_length:分支的当前长度，以像素为单位。</li><li id="b477" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">shorten_by:决定子分支比父分支短多少像素。</li><li id="0368" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">角度:子分支从父分支出现的角度。</li></ul><p id="07b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们已经定义了MINIMUM_BRANCH_LENGTH(以像素为单位)，它设置了创建更多子分支的最小阈值。</p><p id="386c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们构建递归函数的主体:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="fced" class="mx lw it mt b gy my mz l na nb">import turtle</span><span id="9f3f" class="mx lw it mt b gy nc mz l na nb">MINIMUM_BRANCH_LENGTH = 5</span><span id="a06a" class="mx lw it mt b gy nc mz l na nb">def build_tree(t, branch_length, shorten_by, angle):<br/>  if branch_length &gt; MINIMUM_BRANCH_LENGTH:<br/>    t.forward(branch_length)<br/>    new_length = branch_length - shorten_by</span><span id="c4f2" class="mx lw it mt b gy nc mz l na nb">    t.left(angle)<br/>    build_tree(t, new_length, shorten_by, angle)</span><span id="166d" class="mx lw it mt b gy nc mz l na nb">    t.right(angle * 2)<br/>    build_tree(t, new_length, shorten_by, angle)</span><span id="6e03" class="mx lw it mt b gy nc mz l na nb">    t.left(angle)<br/>    t.backward(branch_length)</span><span id="66a1" class="mx lw it mt b gy nc mz l na nb">tree = turtle.Turtle()<br/>tree.hideturtle()<br/>tree.setheading(90)<br/>tree.color('green')</span><span id="689a" class="mx lw it mt b gy nc mz l na nb">build_tree(tree, 50, 5, 30)<br/>turtle.mainloop()</span></pre><p id="bd25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，如果branch_length小于MINIMUM_BRANCH_LENGTH，我们就达到了基本情况。否则，我们绘制分支并继续创建子分支，方法是计算它们的长度，向左和向右旋转“角度”度，并用新值再次调用build_tree。最后，我们向后移动到我们分支的根。</p><p id="6604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您执行该代码，应该会得到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/9011a336c7337ffdf2673627b4a6c4dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*yoNIc16fB6RTr6X2IWrykA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的分形树</p></figure><p id="0d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，您可以随意使用这里的代码(和参数)!</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="75eb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">画科赫雪花</h1><p id="0d3e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这篇文章的第二部分，我们将绘制一个更复杂的结构:<a class="ae ky" href="https://en.wikipedia.org/wiki/Koch_snowflake" rel="noopener ugc nofollow" target="_blank">科赫雪花</a>。</p><p id="3554" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要创建一个递归函数来创建<a class="ae ky" href="http://larryriddle.agnesscott.org/ifs/kcurve/kcurve.htm" rel="noopener ugc nofollow" target="_blank">科赫曲线</a>，然后我们将连接其中的3条曲线来创建一个雪花。让我们从定义递归函数的参数开始:</p><ul class=""><li id="2133" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">t:我们的海龟实例。</li><li id="80d1" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">iterations:表示列表下方图像中n的值(注意，n=0表示一条平坦的线，这是我们递归函数的基本情况)。</li><li id="321a" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">长度:我们当前(子)雪花中每条边的长度。</li><li id="474f" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">shortening_factor:确定创建新子雪花时边长除以的因子。</li><li id="7dc2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">角度:确定新边出现的角度。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/da94994fb059b86f544879116e730e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RkUWF3mTNtOXlc3l14NcSA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">科赫曲线构建— <a class="ae ky" href="https://en.wikipedia.org/wiki/File:Koch_curve_construction.svg" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="b5fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们定义了我们的递归函数的基本结构，我们可能会达到以下几点:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a011" class="mx lw it mt b gy my mz l na nb">import turtle</span><span id="e0fb" class="mx lw it mt b gy nc mz l na nb">def koch_curve(t, iterations, length, shortening_factor, angle):<br/>  pass</span><span id="3894" class="mx lw it mt b gy nc mz l na nb">t = turtle.Turtle()<br/>t.hideturtle()</span><span id="273a" class="mx lw it mt b gy nc mz l na nb">for i in range(3):<br/>  koch_curve(t, 4, 200, 3, 60)<br/>  t.right(120)</span><span id="321c" class="mx lw it mt b gy nc mz l na nb">turtle.mainloop()</span></pre><p id="894d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们只需实现递归函数。如果我们已经达到我们的基本情况，我们将只是画一条线。否则，我们将更新我们的参数(特别是迭代次数和长度)并调用我们的递归函数4次。在这些函数调用之间，我们会先向左，然后向右，最后再向左。让我们看看完整的实现是怎样的:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="bed1" class="mx lw it mt b gy my mz l na nb">import turtle</span><span id="c653" class="mx lw it mt b gy nc mz l na nb">def koch_curve(t, iterations, length, shortening_factor, angle):</span><span id="c2f8" class="mx lw it mt b gy nc mz l na nb">  if iterations == 0:<br/>    t.forward(length)<br/>  else:<br/>    iterations = iterations - 1<br/>    length = length / shortening_factor</span><span id="c2af" class="mx lw it mt b gy nc mz l na nb">    koch_curve(t, iterations, length, shortening_factor, angle)<br/>    t.left(angle)<br/>    koch_curve(t, iterations, length, shortening_factor, angle)<br/>    t.right(angle * 2)<br/>    koch_curve(t, iterations, length, shortening_factor, angle)<br/>    t.left(angle)<br/>    koch_curve(t, iterations, length, shortening_factor, angle)</span><span id="a3a3" class="mx lw it mt b gy nc mz l na nb">t = turtle.Turtle()<br/>t.hideturtle()</span><span id="2685" class="mx lw it mt b gy nc mz l na nb">for i in range(3):<br/>  koch_curve(t, 4, 200, 3, 60)<br/>  t.right(120)</span><span id="e7ca" class="mx lw it mt b gy nc mz l na nb">turtle.mainloop()</span></pre><p id="6933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您执行上面的代码，您应该会获得以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/222d291770f260900fa02ca2c5a731db.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*1dqgpU-hqCjmzKuQthkI6Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的科赫雪花</p></figure><p id="db7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，您可以随意使用这里的代码(和参数)!</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div></div>    
</body>
</html>