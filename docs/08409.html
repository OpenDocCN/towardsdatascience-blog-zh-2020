<html>
<head>
<title>A simple yet useful data visualization library for your EDA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个简单而有用的EDA数据可视化库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-simple-yet-useful-data-visualization-library-for-your-eda-76c41a46d63b?source=collection_archive---------76-----------------------#2020-06-18">https://towardsdatascience.com/a-simple-yet-useful-data-visualization-library-for-your-eda-76c41a46d63b?source=collection_archive---------76-----------------------#2020-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="cbd6" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">探索性数据分析/双变量分析/数据科学</h2><div class=""/><div class=""><h2 id="5ef6" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">以有意义的方式可视化因变量和任何特征之间的关系</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3dc462ef1bead85c93219a6c2b881705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7l93T2L21b30UtP_dqQZ6w.png"/></div></div></figure><p id="2318" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">探索性数据分析(EDA)尤其适用于包含表格数据的项目。在EDA过程中，谨慎的数据科学家通常会通过寻找异常值或检查某些列是否有异常数量的缺失值来评估数据集的质量。EDA也是初步了解预测变量和因变量之间的二元关系的理想平台。</p><p id="52fb" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">对于连续数据，传统的线性相关系数通常表现不错，可以快速显示最具预测性的特征。然而，对于分类数据，事情变得有点复杂。</p><p id="fa42" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">令我惊讶的是，我找不到一个python库*可以让你快速理解目标和任何预测器之间的关系，不管它们是什么类型(连续的还是分类的)。因此，我决定按照以下要求编写自己的工具:</p><ul class=""><li id="c4a9" class="lw lx iq lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">提供与数据类型无关的统一接口</li><li id="05e4" class="lw lx iq lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">生成易于传达给非技术受众(如业务利益相关者)的视觉输出</li></ul><p id="27d7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这篇文章的目的是提供一个图书馆主要功能的游览。这个库被命名为tprojection，它可以在<a class="ae mk" href="https://github.com/greghor/tprojection" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得，并且可以很容易地用pip安装</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="db12" class="mq mr iq mm b gy ms mt l mu mv">pip install tprojection</span></pre><p id="0806" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我将使用流行的Titanic数据集来说明该库的主要功能。</p><h1 id="ac5a" class="mw mr iq bd mx my mz na nb nc nd ne nf kf ng kg nh ki ni kj nj kl nk km nl nm bi translated">案例1:目标和预测都是分类的</h1><p id="9cab" class="pw-post-body-paragraph la lb iq lc b ld nn ka lf lg no kd li lj np ll lm ln nq lp lq lr nr lt lu lv ij bi translated">构建预测模型时，您通常会寻找允许您定义与目标值有很大差异的部分的特征。这些都是很好的预测。</p><p id="d608" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当目标和预测器都是分类的时，您可以通过将目标投影到每个设备上来评估预测器的质量。这可以通过一个熊猫声明来实现:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="b5da" class="mq mr iq mm b gy ms mt l mu mv">df.groupby(predictor).agg({target: [“mean”, “count”]})</span></pre><p id="e224" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果我们对预测值“性别”应用此命令，并且目标从Titanic数据集中“幸存”,我们将获得类似的结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/81d2bbe37df7bed8c56d1bc2194f6fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*WSAYbDOtHZshjcT69npU8Q.png"/></div></figure><p id="4c6e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">从这个结果来看，很明显男性比女性更不容易存活。在其最基本的用途中，库投影将简单地提供一种可视的方式来携带上述信息。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/a41b07b0e66e541f9aaa5f4b4339a7c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUyzZ376bp7dqMZgOk-J6A.png"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">此图表显示了目标“存活”和预测值“性别”之间的关系。蓝色条表示每种设备的观察次数(左侧y轴)。红线代表每个设备的目标平均值(右侧y轴)。黑色虚线表示目标在整个数据集上的平均值(右侧y轴)。红色阴影区域是通过引导数据估计的置信区间。</p></figure><p id="4476" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">上面的图表可以用几行代码生成:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="260b" class="mq mr iq mm b gy ms mt l mu mv">from tprojection import Tprojection<br/>from tprojection.datasets import load_data</span><span id="b73a" class="mq mr iq mm b gy ny mt l mu mv">df = load_data("titanic")<br/>target = "survived"<br/>predictor = "sex"</span><span id="40ae" class="mq mr iq mm b gy ny mt l mu mv">tproj = Tprojection(df, target, predictor, target_type=”categorical”, feature_type=”categorical”, n_estimators=100)<br/>tproj.plot()</span></pre><p id="5be7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">首先，用所需的参数和选项创建一个Tprojection实例。然后，调用方法<code class="fe nz oa ob mm b">plot</code>并绘制图表。标题中提供了情节的完整描述。请注意，图表坐标轴存储为属性(<code class="fe nz oa ob mm b">tproj.ax1</code>和<code class="fe nz oa ob mm b">tproj.ax2</code>)，因此您可以轻松地更改图表的属性。</p><p id="c907" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当观察数量变小时，置信区间(红色阴影区域)特别有用。在这种情况下，我们可能会观察到条件平均值与基线概率的较大偏差，这表明该模态适用于分割目标。然而，当置信区间很大时，这种解释必须小心。事实上，这意味着预测值和目标值之间的关系可能在不同的引导样本中有很大差异，这表明存在过度拟合的风险。</p><p id="9879" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这种影响在下图中可以清楚地看到，该图分析了该目标对父母/子女人数的依赖性。对于模式<code class="fe nz oa ob mm b">parch = 3</code>和<code class="fe nz oa ob mm b">parch = 5</code>，我们观察到存活率相对较高，而相关的置信区间跨越基线概率的两侧。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oc"><img src="../Images/9c482210910a1009440cdd8a23287f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BxlzzWbhvEIX-lnRetyEaA.png"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">目标“存活”和预测值“烤焦”之间的关系。</p></figure><p id="a870" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">有趣的是，与<code class="fe nz oa ob mm b">parch = 4 </code>和<code class="fe nz oa ob mm b">parch = 6</code>相关联的置信区间的宽度等于零，即使相应的观察数量很小。当目标和模态之间存在一对一的关系时，就会发生这种情况。换句话说，在载有4或6名父母/儿童的乘客群体中没有幸存者。</p><p id="b7f9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">该库还可以处理具有高基数的预测器。在这种情况下，显示设备的完整列表会使图表变得非常模糊。为了解决这一点，您可以向tprojection传递一个可选参数，该参数允许您根据最大值<code class="fe nz oa ob mm b">nb_buckets</code>对设备进行分组。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="6f84" class="mq mr iq mm b gy ms mt l mu mv">tproj = Tprojection(df, target, “parch”, target_type=”categorical”, feature_type=”categorical”, n_estimators=100, nb_modalities=10)<br/>tproj.plot()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi od"><img src="../Images/97d0981eaefac21990f7637f8ec03564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IDPLoN-4WroLbDuX0mcmUw.png"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">预测者“小屋”和目标“幸存”之间的关系。左图显示原始设备，右图显示分时段设备。</p></figure><p id="7d25" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">上面的图表清楚地显示了这种方法的好处。左图显示了原始模态的预测值“舱室”和目标值之间的关系，无法阅读。右边的图更清晰，因为它只显示了一些编码的模态。可以通过一个属性来访问原始设备和编码设备之间的映射:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="6afa" class="mq mr iq mm b gy ms mt l mu mv">print(tproj.encoding)</span></pre><p id="f4fc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当其他模态被分组时，投影将试图“按原样”保存具有足够数量观察值的模态。t投影旨在构建包含大约相同数量观察值的<code class="fe nz oa ob mm b">nb_buckets</code>组。然而，这并不总是可能的，特别是如果模式的分布严重倾斜。而实际情况往往如此。在上面的例子中，我们最初需要10个桶，但最终只需要3个桶。这是因为模态<code class="fe nz oa ob mm b">cabin = nan</code>构成了几乎80%的观察结果。因此，剩余的观察值仅分布在3个桶上。桶<code class="fe nz oa ob mm b">g1</code>和<code class="fe nz oa ob mm b">g2</code>各包含大约10%的观测值，其余的分配给<code class="fe nz oa ob mm b">g3</code>。</p><h1 id="5bc3" class="mw mr iq bd mx my mz na nb nc nd ne nf kf ng kg nh ki ni kj nj kl nk km nl nm bi translated">情况2:目标是连续的，而预测值是分类的。</h1><p id="3d7e" class="pw-post-body-paragraph la lb iq lc b ld nn ka lf lg no kd li lj np ll lm ln nq lp lq lr nr lt lu lv ij bi translated">这在某种程度上是第一种情况的变体。除了目标平均值之外，我还添加了一个箱线图，描述目标在每种设备上的分布。置信区间的计算和显示已被禁用，以保持viz可读。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="559d" class="mq mr iq mm b gy ms mt l mu mv">tproj = Tprojection(df, "fare", “cabin”, nb_modalities=10)<br/>tproj.plot()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/4a2e9db04cf66b97b0489edf4272be6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5daGOl4Z9b4I1uWMklGogA.png"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">预测“舱位”(分桶)和目标“票价”之间的关系。</p></figure><p id="dbaa" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在上面的代码片段中，没有指定选项<code class="fe nz oa ob mm b">target_type</code>和<code class="fe nz oa ob mm b">predictor_type</code>。在这种情况下，库使用经验法则来评估变量是连续的还是分类的。</p><h1 id="8eae" class="mw mr iq bd mx my mz na nb nc nd ne nf kf ng kg nh ki ni kj nj kl nk km nl nm bi translated">情况3:目标是分类的，而预测值是连续的</h1><p id="466e" class="pw-post-body-paragraph la lb iq lc b ld nn ka lf lg no kd li lj np ll lm ln nq lp lq lr nr lt lu lv ij bi translated">在这种情况下，我们简单地比较由目标值决定的预测值的分布。为了便于比较，直方图被归一化。图例中提供了每个目标值的计数。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="e528" class="mq mr iq mm b gy ms mt l mu mv">tproj = Tprojection(df, "survived", “fare")<br/>tproj.plot()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/f88d4bbdf443a3b7211db411ab2192b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QyPpWg9_wCdf_YV7YXCWyA.png"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">预测值“票价”和目标值“存活”之间的关系。</p></figure><p id="3298" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">默认情况下，正类对应于二进制目标的少数类。您可以通过用可选参数<code class="fe nz oa ob mm b">target_modality</code>指定所需的值来改变这种行为。在这个阶段，tprojection还不能真正处理多类问题，但是请注意，您可以通过使用<code class="fe nz oa ob mm b">target_modality</code> kwarg来模拟一种以一敌众的方法。</p><h1 id="98d9" class="mw mr iq bd mx my mz na nb nc nd ne nf kf ng kg nh ki ni kj nj kl nk km nl nm bi translated">情况4:预测值和特征都是连续的</h1><p id="8339" class="pw-post-body-paragraph la lb iq lc b ld nn ka lf lg no kd li lj np ll lm ln nq lp lq lr nr lt lu lv ij bi translated">包含这个案例是为了详尽，但它肯定不是项目带来最大价值的地方。该库只显示两个变量的散点图以及线性相关系数。还显示了从seaborn <code class="fe nz oa ob mm b">regplot</code>方法得出的最佳回归线。没有额外的特殊功能，因为有许多好的工具提供高级功能来分析两个连续变量之间的相关性。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="e801" class="mq mr iq mm b gy ms mt l mu mv">tproj = Tprojection(df, "fare", “age")<br/>tproj.plot()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/7f363a6c5baeff133ada38f766450370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzEnCtYZyHVU-rwMmo2e8A.png"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">预测值“年龄”和目标值“票价”之间的关系。</p></figure><p id="04e4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">那都是乡亲们！我希望你会发现这个简单的库很有用。随意派生出<a class="ae mk" href="https://github.com/greghor/tprojection" rel="noopener ugc nofollow" target="_blank"> repo </a>，破解代码，并使其适应您的需求。</p><p id="b6ec" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="oe">*免责声明:我在发布这个帖子之前发现了伟大的</em> <a class="ae mk" rel="noopener" target="_blank" href="/powerful-eda-exploratory-data-analysis-in-just-two-lines-of-code-using-sweetviz-6c943d32f34"> <em class="oe"> sweetviz </em> </a> <em class="oe">库。尽管sweetviz包括类似的功能和更多功能，我仍然认为tprojection带来了有趣的特性。尤其是关于置信区间的内置估计或它处理高基数预测值的方式。</em></p></div></div>    
</body>
</html>