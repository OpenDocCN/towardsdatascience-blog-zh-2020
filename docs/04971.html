<html>
<head>
<title>Circular Queue or Ring Buffer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">循环队列或环形缓冲区</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/circular-queue-or-ring-buffer-92c7b0193326?source=collection_archive---------3-----------------------#2020-04-30">https://towardsdatascience.com/circular-queue-or-ring-buffer-92c7b0193326?source=collection_archive---------3-----------------------#2020-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="90b2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak"> Python和C实现。</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/47459046184937a9b0d1f4a47f784a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J9K866QWpLC9OkmLLn3nEA.png"/></div></div></figure><h2 id="3475" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">介绍</h2><p id="ee77" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">循环队列有许多不同的实现方式，它们都可能更适合特定的应用。这篇博文旨在帮助理解循环队列的工作原理及其用途和优点。</p><h2 id="6fe2" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">环形队列</h2><p id="20b1" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">队列是一种简单的数据结构，它实现了FIFO(先进先出)排序。这仅仅意味着添加到队列中的第一个项目是第一个出来的。就像在熟食店排队一样，第一个排队的顾客是最先被服务的。一个<strong class="lp ir">循环队列</strong>本质上是一个具有最大大小或容量的队列，它将继续以循环运动的方式返回自身。</p><h2 id="5e5c" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">应用程序</h2><p id="1e13" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">当数据流的输入和输出以不同的速率发生时，环形缓冲区是常用的数据结构。</p><ul class=""><li id="9281" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">缓冲数据流</li><li id="9f7e" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">计算机控制的交通信号系统</li><li id="7824" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">内存管理</li><li id="9777" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">CPU调度</li></ul><h2 id="a3c4" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">优势</h2><p id="3b63" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">循环队列提供了一种快速、干净的方式来存储最大大小的FIFO数据。</p><ul class=""><li id="c437" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">不使用动态内存→没有内存泄漏</li><li id="4be0" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">节省内存，因为我们只存储我们的容量(相反，如果输入超过输出，队列可能会继续增长。)</li><li id="33d4" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">简单实施→易于信任和测试</li><li id="95b0" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">从不需要重新组织/复制数据</li><li id="f258" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">所有操作都发生在常数时间O(1)中</li></ul><h2 id="6030" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">不足之处</h2><p id="ee4c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">循环队列只能存储预先确定的最大数量的元素。</p><ul class=""><li id="be70" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">必须事先知道最大尺寸</li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h2 id="206a" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">它是如何工作的？</strong>(数组实现)</h2><p id="684e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">循环队列中有两个主要操作:</p><p id="d293" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la nd lx ly le ne ma mb li nf md me mf ij bi translated">1: <strong class="lp ir">入队(项目):</strong>将项目添加到队列中。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="17ff" class="kr ks iq nh b gy nl nm l nn no">if Queue.isfull()<br/>    print "Queue is Full"<br/>else <br/>    increase tail by 1<br/>    Queue[tail] = item<br/>    size++</span></pre><p id="2b1c" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la nd lx ly le ne ma mb li nf md me mf ij bi translated">2: <strong class="lp ir"> Dequeue() </strong>:返回行前(头)的项，并将其移除。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="60d9" class="kr ks iq nh b gy nl nm l nn no">if Queue.isEmpty()<br/>    print "Queue is Empty"<br/>else <br/>    tmp = Queue[head]<br/>    increase head by 1<br/>    size--<br/>    return tmp</span></pre><p id="93c6" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la nd lx ly le ne ma mb li nf md me mf ij bi translated"><strong class="lp ir"> <em class="np">注意</em> </strong> <em class="np">:我们实际上并没有从数组中移除任何东西，我们只是增加了</em> <strong class="lp ir"> <em class="np">头</em> </strong> <em class="np">来指向下一个“in line”项目。</em></p><p id="981c" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la nd lx ly le ne ma mb li nf md me mf ij bi translated">让我们看看这些操作在大小为6的数组上是如何进行的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="dfc3" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">请注意当我们将第七个项目(35)排队时,<strong class="lp ir">尾</strong>如何绕回零。</li><li id="ebe4" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">注意<strong class="lp ir">头</strong>是如何随着我们出列而增加的，但是没有值从数组中移除，它们只是在Enqueue()到达数组中的那个位置时被覆盖。</li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h2 id="523f" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">模运算符</strong></h2><p id="e48d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">如果我们应该将数组中的<strong class="lp ir">头</strong>和<strong class="lp ir">尾</strong>增加1个点，那么当我们到达末尾时，如何将它设置回零，以确保我们继续遍历数组？</p><p id="74d1" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la nd lx ly le ne ma mb li nf md me mf ij bi translated">我们可以这样做:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="1fe6" class="kr ks iq nh b gy nl nm l nn no">if (head + 1) = capacity <br/>    head = 0<br/>else <br/>    head = head + 1</span></pre><p id="1fe5" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la nd lx ly le ne ma mb li nf md me mf ij bi translated">这真的没有错，但是，有一个更好的方法使用模操作符。模运算符<strong class="lp ir"> (%) </strong>给出除法后的余数。在看两个整数<strong class="lp ir"> a </strong>和<strong class="lp ir"> b的关系时；a </strong>将是<strong class="lp ir"> b </strong>乘以某个整数<strong class="lp ir"> q </strong>加上某个整数<strong class="lp ir"> r : </strong>的乘积</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="8fcd" class="kr ks iq nh b gy nl nm l nn no">a = b x q + r<br/>    q : quotient = a div b<br/>    r : remainder = a mod b</span></pre><p id="4e74" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la nd lx ly le ne ma mb li nf md me mf ij bi translated">让我们看一些简单的例子:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="3455" class="kr ks iq nh b gy nl nm l nn no">a = b x q + r                    a % b = r<br/>5 = 3 x 1 + 2                    5 % 3 = 2<br/>2 = 5 x 0 + 2                    2 % 5 = 2<br/>9 = 3 x 3 + 0                    9 % 3 = 0<br/>9 = 2 X 4 + 1                    9 % 2 = 1</span></pre><p id="2c9e" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la nd lx ly le ne ma mb li nf md me mf ij bi translated"><em class="np">注:这是欧几里德算法确定GCD的基础。</em></p><p id="4b37" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la nd lx ly le ne ma mb li nf md me mf ij bi translated">让我们将它应用于我们的循环队列实现:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="87f4" class="kr ks iq nh b gy nl nm l nn no">self.head = (self.head + 1) % self.capacity</span></pre><ul class=""><li id="7ef0" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">现在，每当我们到达数组的末尾时，我们将自动从零开始。漂亮！让我们看看大小为6的循环队列会是什么样子:</li></ul><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="de29" class="kr ks iq nh b gy nl nm l nn no">0 % 6 = 0<br/>1 % 6 = 1<br/>2 % 6 = 2<br/>3 % 6 = 3<br/>4 % 6 = 4<br/>5 % 6 = 5<br/>6 % 6 = 0<br/>...</span></pre></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h2 id="af6f" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Python实现</h2><p id="a044" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">这是一个简单的实现，其中我们只有两个主要方法，Enqueue(item)、Dequeue()和display()方法，我认为这有助于理解。许多其他实现也可能包括:</p><ul class=""><li id="572f" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">isFull():如果队列已满，则为true，否则为false。</li><li id="d3ae" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">isEmpty():如果队列为空，则为true，否则为false。</li><li id="d3a9" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">peek():查看队列最前面的内容，而不“删除”它。</li><li id="b5b2" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">等等..</li></ul><p id="241d" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la nd lx ly le ne ma mb li nf md me mf ij bi translated">许多其他实现不会存储当前大小，而是通过简单地比较头部和尾部来确定isFull()和isEmpty()。我认为存储大小可以更容易地跟踪正在发生的事情。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/13a039b3cc91832f05f9ab51b008c5fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*brdDG-iCZWDQ411D00M5wQ.png"/></div></figure><h2 id="bec7" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">实施情况</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nr l"/></div></figure><p id="93e9" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la nd lx ly le ne ma mb li nf md me mf ij bi translated">您可以看到C实现与Python实现非常相似，只是增加了有趣的C元素，如结构和内存分配。这里我们还需要一个create_queue()函数，因为我们使用了structs。我们还使用了一些我们之前讨论过的辅助函数，比如isFull()、isEmpty()等..</p><h2 id="8786" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">思考者</h2><ul class=""><li id="8baa" class="mg mh iq lp b lq lr lt lu la nu le nv li nw mf mn mo mp mq bi translated">有哪些边界情况？</li><li id="0f1f" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">我们在做什么假设？</li><li id="d87a" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">我们如何实现循环队列来动态改变容量呢？这将如何影响循环队列的优点和缺点？</li><li id="588f" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">如果队列已满，这两种实现都不允许您将新项目加入队列。你能想到循环队列的一些应用程序中这可能是不好的吗？我们如何改变实现以允许重写？</li></ul><h2 id="9df7" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h2><p id="a0fe" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">我鼓励阅读这篇文章的人看看web上的其他实现，比较它们，并思考循环队列的不同应用。我自己还是个学生，还有很多东西要学。然而，我希望这可能对第一次学习循环队列的人有所帮助。感谢阅读！</p></div></div>    
</body>
</html>