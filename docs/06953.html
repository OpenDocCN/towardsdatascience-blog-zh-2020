<html>
<head>
<title>3 Great Design Patterns for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的 3 大设计模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-great-design-patterns-for-data-science-workflows-d3bf162d74e6?source=collection_archive---------15-----------------------#2020-05-29">https://towardsdatascience.com/3-great-design-patterns-for-data-science-workflows-d3bf162d74e6?source=collection_archive---------15-----------------------#2020-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9f56" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">想学习如何写出更好的数据科学代码？使用设计模式编写干净、可维护、可测试的代码。</h2></div><h1 id="9763" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">介绍</h1><p id="b345" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当作为数据科学家编写代码时，您的目标通常是快速编写代码，这样您就可以在走得太远之前检查某个东西是否是个好主意。没有人喜欢在一个项目上工作了几个月却发现它是垃圾。</p><p id="c712" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">因此，在构建原型时，您要尽可能快地编写代码。但是，当您的刚刚开始工作的代码不再有效，并且您的代码需要更加健壮和可维护时，会发生什么呢？这就是设计模式派上用场的地方。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/02bef88f0ccca605c7d6ddeccbd62932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_4aHzvLgf7UWmP1qqiN37Q.jpeg"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">由<a class="ae mo" href="https://medium.com/@iamrichiefrost" rel="noopener">里奇·弗罗斯特</a>创造的迷因，使用<a class="ae mo" href="https://www.mematic.net/" rel="noopener ugc nofollow" target="_blank">的迷因</a></p></figure><h1 id="8252" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">什么是设计模式？</h1><p id="84f9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">简单来说，设计模式是编写软件时常见问题的常见解决方案。它们之所以如此伟大，是因为它们如此普遍适用，但你必须知道如何应用它们。你可以在这里更深入地了解一些常见的设计模式<a class="ae mo" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="b06f" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">为什么要使用设计模式？</h1><p id="2f5f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我能想到一些我喜欢使用它们的原因。</p><ul class=""><li id="3b5e" class="mp mq iq kz b la lt ld lu lg mr lk ms lo mt ls mu mv mw mx bi translated">编码时减少认知负荷</li><li id="175b" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated">花更少的时间调试</li><li id="4844" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated">代码更容易测试</li><li id="5ea3" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated">更容易构建可重用的工具</li></ul><p id="f3e7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">因此，事不宜迟，让我们来了解一下数据科学工作流的 3 种优秀设计模式。</p><h1 id="b09f" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">1.构建器模式</h1><h2 id="b099" class="nd kg iq bd kh ne nf dn kl ng nh dp kp lg ni nj kr lk nk nl kt lo nm nn kv no bi translated">这是什么？</h2><p id="7094" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">构建器模式是一种创建复杂对象的灵活方式，尤其是当这些对象有很多相似之处但有很多可选参数时。构建器模式将对象构造逻辑从对象本身中取出，并动态地为对象创建相关属性——通常使用<a class="ae mo" href="https://www.tutorialspoint.com/Explain-Python-class-method-chaining" rel="noopener ugc nofollow" target="_blank">方法链接技术</a>。启用方法链接的关键是从用于构建所需对象的方法中返回对象本身，以便链接的方法可以修改同一个对象。</p><h2 id="c9e3" class="nd kg iq bd kh ne nf dn kl ng nh dp kp lg ni nj kr lk nk nl kt lo nm nn kv no bi translated">示例:生成 SQL 查询</h2><p id="4af7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我每天都写大量的 SQL 查询，并且发现我的大多数查询在结构上有很多相似之处。然而，手工编写它们是一个非常容易出错的过程，并且会产生大量重复的代码。因此，我使用 builder 模式为自己生成查询，而不是编写许多单独的查询。当我用嵌套的 select 语句和多个连接编写大型的、令人讨厌的查询时，这也很方便，在手工编写查询时，很容易迷失方向并出错。更不用说这种方法很容易测试，而手工编写 SQL 查询更难测试！</p><p id="17d5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们编写一个简单的查询构建器来说明这个模式是如何有用的。</p><p id="1b2c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我首先用我将从中选择元组的基表初始化构建器。然后，我可以根据需要添加要选择的列、“group by”子句、连接和“where”子句。对于一个简单的“SELECT * FROM foo”类型的查询来说，这是多余的，但是这些构建块使得构建越来越复杂的查询变得更加容易。</p><p id="fbf0" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">下面是一个使用 builder 模式制作简单 SQL 查询生成器的示例:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="np nq l"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">使用构建器模式生成 SQL 查询</p></figure><h1 id="5f87" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">2.依赖注入</h1><h2 id="038b" class="nd kg iq bd kh ne nf dn kl ng nh dp kp lg ni nj kr lk nk nl kt lo nm nn kv no bi translated">这是什么？</h2><p id="714e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最简单的形式是，依赖注入就是将依赖的东西作为参数插入。不知道用哪个数据库类？你的函数不需要知道数据库类是如何工作的，只要知道就行了。将数据库类实例作为参数传入使得维护更容易——您可以使用遵循相同接口的任何类型的数据库类。</p><p id="88ce" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果不使用依赖注入，您将很难维护像数据库类这样的关键基础设施。</p><p id="2c5d" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">使用依赖注入的另一个好处是你的代码更容易编写测试。例如，只需编写一个模拟类(即模拟数据库类)并在测试中使用它，而不必使用运行 HTTP 请求和降低测试速度的代码。</p><h2 id="ddb1" class="nd kg iq bd kh ne nf dn kl ng nh dp kp lg ni nj kr lk nk nl kt lo nm nn kv no bi translated">示例:数据库类</h2><p id="574e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我的团队使用 SQL Server 和 Cosmos DB，以及其他数据源。将数据库类作为参数传入，可以很容易地将不同的数据库换成不同的想法，并使编写可测试的代码变得容易得多，因为数据库类很容易被模仿。</p><p id="3660" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">下面是一个使用依赖注入的简单例子:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="np nq l"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">使用依赖注入模式从数据库获取数据</p></figure><h1 id="4742" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">3.装饰图案</h1><h2 id="b49b" class="nd kg iq bd kh ne nf dn kl ng nh dp kp lg ni nj kr lk nk nl kt lo nm nn kv no bi translated">这是什么？</h2><p id="128b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当您想在函数之前和/或之后做一些事情，但不想修改函数本身时，装饰器模式非常有用。本质上，你所做的是在函数运行前捕捉一些状态，然后在函数运行后捕捉一些状态。当你有几十个函数需要以同样的方式修改，但又无力单独修改时，这一点就变得非常明显了。</p><h2 id="2f6e" class="nd kg iq bd kh ne nf dn kl ng nh dp kp lg ni nj kr lk nk nl kt lo nm nn kv no bi translated">示例:日志记录函数元数据</h2><p id="2ad6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我发现有用的东西是函数运行多长时间，函数的名称，以及有时关于输出的不同特性。幸运的是，Python 函数是对象，所以您可以对这种模式使用' @ '修饰语法。您需要做的就是创建一个包装内部函数的函数，然后将@my_decorator_name decorator 放在您想要装饰的函数之前。</p><p id="fd7f" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">看例子比用通俗易懂的英语解释容易:)</p><p id="414a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我不会深入探究装饰者如何在 Python 中工作，但是 RealPython 有一篇很棒的文章,我强烈推荐作为入门读物。</p><p id="0d02" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">重用依赖注入示例中的一些代码，我们可以计算数据库事务需要多长时间:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="np nq l"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">使用装饰模式来计时函数</p></figure><h1 id="82aa" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">把它放在一起</h1><p id="f979" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">设计模式产生了非常可重用的代码，您可以像构建模块一样将各个部分组合在一起，使您作为数据科学家的工作变得容易得多。例如，我经常将这三种模式结合起来编写数据库查询，并查看查询需要多长时间，以便知道是否需要优化。</p><h1 id="e335" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">结论</h1><p id="78ad" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本文中，我展示了作为数据科学家使用设计模式的三种方法，以获得更健壮、可维护的代码。当您在数据科学中使用设计模式时，您的代码质量会提高，您的维护会更容易，您的结果也更容易重现和共享。</p></div></div>    
</body>
</html>