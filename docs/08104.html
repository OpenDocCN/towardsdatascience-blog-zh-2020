<html>
<head>
<title>ML from Scratch-Multinomial Logistic Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ML 从零开始-多项式逻辑回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ml-from-scratch-multinomial-logistic-regression-6dda9cbacf9d?source=collection_archive---------13-----------------------#2020-06-15">https://towardsdatascience.com/ml-from-scratch-multinomial-logistic-regression-6dda9cbacf9d?source=collection_archive---------13-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2dffb73d7a24da2e9ec8c6d9879445de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UfvJRMAf0qNBApc95WML9w.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来源-Unsplash.com</p></figure><div class=""/><div class=""><h2 id="1271" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">你的多项逻辑回归完全指南，又名 Softmax 回归</h2></div><p id="5acd" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当涉及到现实世界的机器学习时，大约有<em class="lt"> 70% </em>的问题是基于分类的，在可用的特征集的基础上，你的模型试图预测在一组给定的类别(离散的可能结果)中，你的目标变量可能属于哪个类别。<strong class="kz jj">今天，在本文中，我们将了解多项逻辑回归，这是一种经典的监督机器学习算法，能够进行<em class="lt">多类分类</em>、</strong>，即当有两个以上可能的离散结果类时，预测目标变量的结果。</p><p id="e36b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这是一个基于项目的指南，在其中我们将看到如何从头开始编写 MLR 模型，同时理解允许模型进行预测的数学方法。</p><p id="f51d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">对于这个项目，我们将致力于著名的<a class="ae lu" href="https://archive.ics.uci.edu/ml/datasets/Heart+Disease" rel="noopener ugc nofollow" target="_blank"> <em class="lt"> UCI 克利夫兰心脏病数据集</em> </a>。<strong class="kz jj">我们将从头开始创建一个 ML 模型，该模型使用多项逻辑回归，能够预测患者心脏病的严重程度。</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d70e" class="mc md ji bd me mf mg mh mi mj mk ml mm ko mn kp mo kr mp ks mq ku mr kv ms mt bi translated">多项式逻辑回归基础</h1><p id="c1ca" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">在我们开始实际的项目之前，让我们首先熟悉 MLR 背后的基本思想——它是什么，它做什么，以及它是如何操作的？</p><h2 id="57f7" class="mz md ji bd me na nb dn mi nc nd dp mm lg ne nf mo lk ng nh mq lo ni nj ms nk bi translated">到底什么是多项逻辑回归？</h2><p id="5de3" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">你可以把多项逻辑回归看作是类固醇上的逻辑回归(更具体地说，是二元逻辑回归)。而二进制逻辑回归可以预测二进制结果(例如，是或否，垃圾邮件或非垃圾邮件，0 或 1 等。)，MLR 可以预测 k 个可能结果中的一个，其中 k 可以是任意正整数。</p><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nl"><img src="../Images/9e5aa7e507cad3c306a4fa34beed7959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVsfG6i-Y93prmLgTcxRwA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">为特征集预测的结果是 k 个可能结果之一</p></figure><h2 id="8466" class="mz md ji bd me na nb dn mi nc nd dp mm lg ne nf mo lk ng nh mq lo ni nj ms nk bi translated">MLR 是如何工作的？</h2><p id="368b" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">多项式回归函数<em class="lt"> </em>是一种<em class="lt"> </em> <strong class="kz jj"> <em class="lt">统计分类算法</em> </strong>。这意味着，一旦我们为函数提供了一组要素，模型就会执行一系列数学运算，将输入值归一化为遵循概率分布的值向量。</p><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/d31481f52a9c5e27828a73fe4952ea82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*23H-Vwy_p43ai0Qvz9d6Pg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">MLR 函数根据给定的特征集计算可能的目标类的概率</p></figure><ul class=""><li id="f8a3" class="nr ns ji kz b la lb ld le lg nt lk nu lo nv ls nw nx ny nz bi translated">我们给模型的输入是一个特征向量，<strong class="kz jj"> X </strong>，包含特征<strong class="kz jj">X</strong>T24】1，<strong class="kz jj"> x </strong> <em class="lt"> 2 </em>，<strong class="kz jj"> x </strong> <em class="lt"> 3 </em> …..<strong class="kz jj">x</strong>T36】n。</li><li id="67b9" class="nr ns ji kz b la oa ld ob lg oc lk od lo oe ls nw nx ny nz bi translated">我们得到的输出是一个概率向量<strong class="kz jj"> Y </strong>，包含<strong class="kz jj"> y </strong> <em class="lt"> 1 </em>，<strong class="kz jj"> y </strong> <em class="lt"> 2 </em>，<strong class="kz jj">Y</strong><em class="lt">3</em>…<strong class="kz jj">Y</strong><em class="lt">k</em>对于<strong class="kz jj"> k </strong>目标类的概率。</li><li id="ad71" class="nr ns ji kz b la oa ld ob lg oc lk od lo oe ls nw nx ny nz bi translated">这里，<strong class="kz jj">y</strong><em class="lt">1</em>+<strong class="kz jj">y</strong><em class="lt">2</em>+<strong class="kz jj">y</strong><em class="lt">3</em>…+<strong class="kz jj">y</strong><em class="lt">k</em>= 1，由于一个系统中所有可能事件的总概率总是 1。</li></ul><p id="b42b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">最后，概率最高的结果将是给定特征集的预测结果。</p><p id="06f1" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在的问题是，MLR 函数到底是如何将特征集转换成概率值的？在我们的项目中，我们会努力理解这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0068" class="mc md ji bd me mf mg mh mi mj mk ml mm ko mn kp mo kr mp ks mq ku mr kv ms mt bi translated">导入项目依赖关系</h1><p id="8aec" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">在我们开始这个项目之前，让我们首先导入所有必要的模块和包。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="57bb" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，我们将导入数据集。根据<a class="ae lu" href="https://archive.ics.uci.edu/ml/datasets/Heart+Disease" rel="noopener ugc nofollow" target="_blank">数据源</a>，数据集没有列名。因此，我们将把 header 属性设置为 None，然后根据源上的可用信息手动设置列名。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/82b54cdc6cb14c16711f9dda95509058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ybh-Qf0CQ2SZ543L3dvYuA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">显示数据集的屏幕截图</p></figure><h2 id="8aff" class="mz md ji bd me na nb dn mi nc nd dp mm lg ne nf mo lk ng nh mq lo ni nj ms nk bi translated">理解数据</h2><p id="2430" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">现在我们已经导入了数据集，让我们试着理解每一列的含义。</p><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/ea7e52e0446496db1daccb2d806caae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A03KDT7F2GRpSQq4OHVd5Q.jpeg"/></div></div></figure><p id="e530" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这里，<strong class="kz jj"> num </strong>列是我们的目标变量，值的范围从 0(没有疾病)到 4(心脏病的高几率)。</p><p id="b530" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">既然我们已经确切地知道了我们的数据集代表什么，让我们继续下一步。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a348" class="mc md ji bd me mf mg mh mi mj mk ml mm ko mn kp mo kr mp ks mq ku mr kv ms mt bi translated">数据预处理</h1><p id="d785" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">现在，让我们分析数据，看看是否需要清理或修改。作为数据预处理的第一步，我们将检查是否有任何空值需要处理。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="nm nn no np gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/4d6674018cbdb91b419f212ef6443cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*KyLHG3_DsmEfGzyNotTx_g.jpeg"/></div></figure><p id="9a61" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">正如我们所看到的，列<strong class="kz jj"> ca </strong>和<strong class="kz jj"> thal </strong>有 4 个和 2 个<strong class="kz jj">'？'</strong>分别取值。这些是我们需要处理的空值。由于这两列都由分类值组成，我们将用各自列的中值替换空值。我们还将把这两列类型转换为<em class="lt">‘float 64’值。</em></p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/f31aaff00529f104a3c4fcb4768733cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*aHPWImM0aO75Km29cFpOeQ.png"/></div></div></figure><p id="f150" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在我们已经清理了数据，让我们看看数据集的统计分析。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/290719f953b200ba91b45ab1c1123058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RIv3oT-sKZ79oF_0lPzPg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">数据集的统计分析</p></figure><p id="4c8f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">观察数据后，我们可以看到数据需要缩放，因为我们的值在范围<em class="lt"> (1，1e+2)内。我们缩放数据的主要原因是，由于我们将使用随机梯度下降来优化我们的模型参数，缩放可以显著提高我们的优化器的速度和准确性。</em></p><p id="9d78" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这里，我们将使用标准比例来标准化数据。<strong class="kz jj"> <em class="lt">标准化</em> </strong>通常是指重新调整数据，使平均值为 0，标准差为 1(单位方差)。以下是标准缩放的数学公式。</p><figure class="nm nn no np gt iv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/b95ea7dd27d67dbb51ff0d74ad2d8bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*sn2lNhtSyj1wLDPoNHfihw.jpeg"/></div></figure><p id="6f75" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这里，</p><ul class=""><li id="b822" class="nr ns ji kz b la lb ld le lg nt lk nu lo nv ls nw nx ny nz bi translated"><strong class="kz jj"> μ =一列中所有值的平均值</strong></li><li id="e11f" class="nr ns ji kz b la oa ld ob lg oc lk od lo oe ls nw nx ny nz bi translated"><strong class="kz jj"> σ =列的标准偏差</strong></li></ul><p id="7b31" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，让我们在代码中实现它。第一步是将数据集分为目标数组和要素数组。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="nm nn no np gt iv gh gi paragraph-image"><div class="gh gi on"><img src="../Images/3b0923b78b42f3247a2f16259103e12f.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*Iuy2aS4BxRa7nIQa1vAuwQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">特征矩阵和目标向量的形状</p></figure><p id="54b3" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，让我们定义标准缩放的函数。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3987" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们现在将对我们的特性集执行标准化。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="nm nn no np gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/430b1c09143d872170b94e004030f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*cPt569_V3kLM41JGADw7sw.png"/></div></figure><p id="d75d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">正如我们所看到的，每个特性列的标准偏差现在是 1，正如标准缩放所预期的那样。我们已经成功地标准化了我们的功能集。</p><p id="481e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这样，我们就完成了数据争论的过程。随着数据的清理和标准化，现在让我们开始研究我们的模型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="72c4" class="mc md ji bd me mf mg mh mi mj mk ml mm ko mn kp mo kr mp ks mq ku mr kv ms mt bi translated">从头开始构建模型</h1><p id="a617" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">正如我们前面看到的，MLR 模型将特征向量作为输入，然后根据这些特征计算可能结果的概率。那么 MLR 模型到底是怎么做到的呢？让我们在这一节中找出 MLR 模型的编码位置。</p><p id="40b5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">多项式回归函数由两个功能层组成</p><ol class=""><li id="95db" class="nr ns ji kz b la lb ld le lg nt lk nu lo nv ls op nx ny nz bi translated">线性预测函数(也称为逻辑层)</li><li id="6491" class="nr ns ji kz b la oa ld ob lg oc lk od lo oe ls op nx ny nz bi translated">Softmax 函数(也称为 softmax 层)</li></ol><p id="3220" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">首先，让我们看看线性预测函数的作用。下面给出了线性预测函数的公式。</p><div class="nm nn no np gt ab cb"><figure class="oq iv or os ot ou ov paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/1ce1127c6fa07abc1a8aab0ca1f2a9a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*-sM-0yXmTTbBNZ0cF0rbaA.jpeg"/></div></figure><figure class="oq iv ow os ot ou ov paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/ac8f82bc76c75277b43a1fe2f061ec5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*qPJHnD0Z9x9Wb2lQ6JqVkA.jpeg"/></div></figure></div><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/2fd58d68ba56cd007ad3ea538f66c721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iw6tUEi05dAtlJNZl4anbQ.jpeg"/></div></div></figure><p id="5933" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果你仔细观察，这类似于我们用于线性回归模型的函数。它基本上做的是在范围(- <strong class="kz jj"> ∞，</strong> + <strong class="kz jj"> ∞ </strong>)内映射我们的目标变量的每个可能结果的分数。</p><p id="851b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这有点类似于 log odds( <a class="ae lu" href="https://en.wikipedia.org/wiki/Logit" rel="noopener ugc nofollow" target="_blank"> logit function </a>)，将一个事件的赔率映射到范围(- <strong class="kz jj"> ∞，</strong> + <strong class="kz jj"> ∞ </strong>)。因此，线性预测函数也称为 logit 函数。</p><p id="9f9f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，我们将看到线性预测函数的代码。</p><p id="0180" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">步骤 1 </strong> -为我们的模型创建随机权重和偏差(因为我们有 5 个可能的目标结果和 13 个特征，k = 5，m = 13)。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="6a70" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">第 2 步</strong> -定义线性预测函数。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="835b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，让我们测试一下特征矩阵的功能。最终输出应该是一个 303 x 5 的矩阵，因为我们的数据集中有 303 个特征集，目标变量有 5 个可能的结果。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="nm nn no np gt iv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/bfd3108765d5f2419bbac94688c4dcd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:196/format:webp/1*X2gzWEXuZ7GiBJ-mgcyDuw.png"/></div></figure><p id="46df" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">正如我们所看到的，这个函数工作得很好。现在进入下一步，将 logit 分数转换成概率值。这就是 softmax 函数发挥作用的地方。下面给出了 softmax 算法的公式。</p><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/8d6e61381863621fe62e9ef78d02a90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*InhXRZP0QQjxNE6NXaxGkw.jpeg"/></div></div></figure><p id="27e7" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">softmax 函数的作用是对每个可能结果的 logit 分数进行归一化，使得归一化的输出遵循概率分布。</p><p id="af1c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">通俗地说，softmax 函数将一个特性集的可能结果的 logit 得分转换为概率值。</p><p id="3219" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，让我们为我们的模型定义 softmax 函数。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e6d9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">既然我们已经定义了 softmax 函数，那么让我们将这两个函数合并成一个多项式函数用于我们的模型。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="23ca" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，让我们对我们的特征集执行逻辑回归。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/11d37e65b8528eda471d65de0b984eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXDJg7nnc3C4QbQEfvmkvg.png"/></div></div></figure><p id="d127" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在让我们检查我们的模型的准确性。由于权重和偏差是随机生成的，我们不能指望我们的模型在此刻非常准确。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="nm nn no np gt iv gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/8896fdb260fae1e49c86be9d1a65afbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*vOcowJAJU6szCNuP1GwYyw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">初始模型精度</p></figure><p id="36e3" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">正如我们所看到的，初始模型精度只有 16%左右，这是非常差的，甚至不能考虑这个模型在现实生活中进行任何心脏病预测。</p><p id="4f78" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">因此，我们需要优化我们的模型参数，以提高其准确性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ebca" class="mc md ji bd me mf mg mh mi mj mk ml mm ko mn kp mo kr mp ks mq ku mr kv ms mt bi translated">模型优化</h1><p id="7490" class="pw-post-body-paragraph kx ky ji kz b la mu kj lc ld mv km lf lg mw li lj lk mx lm ln lo my lq lr ls im bi translated">在我们进一步优化我们的模型之前，我们应该首先将数据集分成测试集和训练集。<strong class="kz jj">在同一个数据集上进行训练和测试被认为是一种不好的做法</strong>，因为它会严重影响模型的真实性能。</p><p id="76ef" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们定义 train_test_split 函数，将数据集分成训练和测试数据。然后，我们将在数据集上运行它。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="nm nn no np gt iv gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/cb1d2f81c9d2094e4ba34153993c2de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*dCRL5-ta9YuFiEHhMG-H7g.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">训练特征、训练目标、测试特征和测试目标的大小</p></figure><p id="e371" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">现在我们有了独立的训练和测试数据集，我们将把测试数据集放在一边，只用于测试目的。所有的训练和优化都将在训练数据集上执行。</strong></p><p id="f1c5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在我们离优化模型只有一步之遥了。在开始优化之前，我们有几个问题要回答。<em class="lt">我们计划优化模型的标准到底是什么？甚至优化的目的到底是什么？</em></p><p id="86e4" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">答案是——我们希望优化模型，以减少模型产生的信息损失。由于优化的标准是信息损失，我们需要为我们的模型定义一个损失函数。</p><p id="47a5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">对于多项式回归函数，通常我们使用<strong class="kz jj">交叉熵损失</strong>函数。下面给出了交叉熵损失函数的公式。</p><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pd"><img src="../Images/f0a1416ef4d578173f2e4d3798d6aec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wLgdoEMbD6R-ImiRJ10m9Q.jpeg"/></div></div></figure><p id="c287" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在让我们定义交叉熵损失函数。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c71d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">既然我们已经定义了损失函数，我们将最终定义优化器算法。下面给出了随机梯度下降运算的公式。</p><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/6f9c880f1b85e269402930a4c4d5a66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Gw-TmJoBunjsesykp1pbg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae lu" href="https://madalinabuzau.github.io/2016/11/29/gradient-descent-on-a-softmax-cross-entropy-cost-function.html" rel="noopener ugc nofollow" target="_blank">图像来源</a></p></figure><p id="b313" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">关于这方面的更多细节，请参考<a class="ae lu" href="http://machinelearningmechanic.com/deep_learning/2019/09/04/cross-entropy-loss-derivative.html" rel="noopener ugc nofollow" target="_blank">这个来源。下面给出的是 SGD 算法的代码。</a></p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="00d5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在我们已经准备好了优化器函数，我们将为我们的模型运行它。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8052" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们现在已经到了项目的最后一步。</p><p id="a7d4" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">“我们已经到了最后阶段！”</strong></p><p id="3ee5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，我们将使用通过运行优化器函数获得的更新权重和偏差来测试我们的多项式逻辑回归模型。</p><p id="68f9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">注意——测试将在测试数据集上进行，而不是在训练数据集上进行。</strong></p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="nm nn no np gt iv gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/91aecb83538648bcc4b7d98b6904b76f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*E_Q-VF-ykuJBFhFRKPw1wg.png"/></div></figure><p id="2d48" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">正如我们所看到的，我们的模型在测试数据上显示了大约 67%的准确性。虽然这比我们最初获得的 16%有了显著的提高，但仍有足够的改进空间。</p><p id="e424" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">您可以通过调整超参数(学习率、训练次数等)来进一步提高精确度。)或者通过使用不同的缩放或优化算法来尝试该过程。记住，你尝试的越多，你学到的就越多！</p><p id="3eaa" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这样，我们的项目就结束了。</p><h2 id="4456" class="mz md ji bd me na nb dn mi nc nd dp mm lg ne nf mo lk ng nh mq lo ni nj ms nk bi translated">以下是关键要点-</h2><ul class=""><li id="1e1c" class="nr ns ji kz b la mu ld mv lg pg lk ph lo pi ls nw nx ny nz bi translated">从头开始编写多项式逻辑回归模型。</li><li id="39b9" class="nr ns ji kz b la oa ld ob lg oc lk od lo oe ls nw nx ny nz bi translated">MLR 模型中涉及的数学。</li></ul><p id="817c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">更多像这样有趣的项目，请查看<a class="ae lu" href="https://medium.com/@amansharma2910" rel="noopener">我的简介</a>。</p><p id="707b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我只是机器学习和数据科学领域的新手，所以任何建议和批评都将真正帮助我提高。</p><p id="3716" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">点击以下链接，继续关注更多 ML 内容！</p><p id="1ef8" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz jj">数据集和 Jupyter 笔记本的 GitHub repo 链接- </strong></p><div class="is it gp gr iu pj"><a href="https://github.com/amansharma2910/MultinomialLogisticRegression-Scratch_HeartDiseasePrediction" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd jj gy z fp po fr fs pp fu fw jh bi translated">aman Sharma 2910/多项式回归-Scratch _ heart disease prediction</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">在这个项目中，我从头开始编写了一个 MLR 模型，可以用来预测心脏的存在(和严重程度)。</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">github.com</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px ja pj"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b63c" class="mc md ji bd me mf mg mh mi mj mk ml mm ko mn kp mo kr mp ks mq ku mr kv ms mt bi translated">参考</h1><ul class=""><li id="a405" class="nr ns ji kz b la mu ld mv lg pg lk ph lo pi ls nw nx ny nz bi translated">多项逻辑回归— <a class="ae lu" href="https://en.wikipedia.org/wiki/Multinomial_logistic_regression" rel="noopener ugc nofollow" target="_blank">维基百科</a></li><li id="bab0" class="nr ns ji kz b la oa ld ob lg oc lk od lo oe ls nw nx ny nz bi translated">Logit 函数— <a class="ae lu" href="https://en.wikipedia.org/wiki/Logit#:~:text=In%20statistics%2C%20the%20logit%20(%2F,." rel="noopener ugc nofollow" target="_blank">维基百科</a></li><li id="4276" class="nr ns ji kz b la oa ld ob lg oc lk od lo oe ls nw nx ny nz bi translated">Softmax 函数— <a class="ae lu" href="https://en.wikipedia.org/wiki/Softmax_function" rel="noopener ugc nofollow" target="_blank">维基百科</a></li><li id="4d4a" class="nr ns ji kz b la oa ld ob lg oc lk od lo oe ls nw nx ny nz bi translated">交叉熵函数-<a class="ae lu" href="http://machinelearningmechanic.com/deep_learning/2019/09/04/cross-entropy-loss-derivative.html" rel="noopener ugc nofollow" target="_blank">MachineLeariningMechanic.com</a></li></ul></div></div>    
</body>
</html>