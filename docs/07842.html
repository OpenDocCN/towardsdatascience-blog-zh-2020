<html>
<head>
<title>Comparing Pandas Dataframes To One Another</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较熊猫的数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/comparing-pandas-dataframes-to-one-another-c26853d7dda7?source=collection_archive---------3-----------------------#2020-06-11">https://towardsdatascience.com/comparing-pandas-dataframes-to-one-another-c26853d7dda7?source=collection_archive---------3-----------------------#2020-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0de435ce252e8a3a165c4eb2a4bea11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UMuLtLmnZfR1dkHz"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">伊洛娜·弗罗利希在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="598e" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">我将演示几种方法，并解释每种方法的优缺点</h2></div><p id="4be9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">数据框架是数据科学的主力。虽然它们不是该领域最迷人的方面，但如果你让我挑选一个数据科学家掌握的最重要的东西，那就是熟练构建和操作数据框架的能力。</p><p id="b333" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在过去的一篇文章中，我将数据帧描述为部分Excel电子表格和部分SQL表，但是具有Python的所有通用性和分析能力。老实说，我还不是一个专业的熊猫用户，但我的目标是成为一个。这就是为什么每当我学到一些新的有用的东西，我都会试着把它记录在这里。</p><p id="8dcf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天的主题是比较平等(或不平等)的数据框架。通常，当处理存储在数据帧中的数据时，我们需要知道它们是否相同。如果不是，则突出显示差异。使用案例包括:</p><ul class=""><li id="7599" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">根据主拷贝快速检查您的数据帧。</li><li id="4f7a" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">如果您下载了现有数据集的更新版本，您可能希望标识任何新行或更新的单元格。</li></ul></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="cc6a" class="my mz jj bd na nb nc nd ne nf ng nh ni kp nj kq nk ks nl kt nm kv nn kw no np bi translated">方法1:使用。eq方法</h1><p id="e2a2" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">熊猫数据框自带便利<strong class="la jk">。eq </strong>法。它可以让您快速比较两个数据帧，并突出显示任何不同的单元格。例如，假设我们有一些NBA球员的数据和他们赢得的冠军数(戒指)。</p><p id="fdd4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们假设一个朋友正在做一个关于篮球的研究项目，并要求我们检查他的数据(他比我们更少是一个NBA球迷)。我们的数据在array_1和df_1，朋友让我们查的数据在array_2和df_2:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="cf95" class="oe mz jj oa b gy of og l oh oi"><em class="oj"># Our data</em><br/>array_1 = np.array([['LeBron',3],<br/>                    ['Kobe',5],<br/>                    ['Michael',6,],<br/>                    ['Larry',3],<br/>                    ['Magic',5],<br/>                    ['Tim',4]])<br/>df_1 = pd.DataFrame(array_1, <br/>                    columns=['Player','Rings'])</span><span id="9b1d" class="oe mz jj oa b gy ok og l oh oi"><em class="oj"># Data from friend</em><br/>array_2 = np.array([['LeBron',3],<br/>                    ['Kobe',3],<br/>                    ['Michael',6,],<br/>                    ['Larry',5],<br/>                    ['Magic',5],<br/>                    ['Tim',4]])<br/>df_2 = pd.DataFrame(array_2, <br/>                    columns=['Player','Rings'])</span></pre><p id="1cfb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用。快速比较数据帧的eq方法。的产量。eq列出了每个单元格位置，并告诉我们该单元格位置的值在两个数据帧之间是否相等(注意第1行和第3行包含错误)。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="b6d2" class="oe mz jj oa b gy of og l oh oi"><strong class="oa jk">In:</strong><br/>df_1.eq(df_2)</span><span id="23b0" class="oe mz jj oa b gy ok og l oh oi"><strong class="oa jk">Out:<br/></strong>   Player  Rings<br/>0    True   True<br/>1    True  False<br/>2    True   True<br/>3    True  False<br/>4    True   True<br/>5    True   True</span></pre><p id="6a9f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用<strong class="la jk">布尔索引</strong>和<strong class="la jk">。all </strong>方法打印出有错误的行。布尔索引使用一组条件来决定打印哪些行(布尔索引等于True的行被打印)。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="0fb6" class="oe mz jj oa b gy of og l oh oi"><strong class="oa jk">In:<br/></strong><em class="oj"># .all returns True for a row if all values are True</em></span><span id="75a6" class="oe mz jj oa b gy ok og l oh oi">df_1.eq(df_2).all(axis=1)</span><span id="d375" class="oe mz jj oa b gy ok og l oh oi"><strong class="oa jk">Out:<br/></strong>0     True<br/>1    False<br/>2     True<br/>3    False<br/>4     True<br/>5     True</span><span id="b9f3" class="oe mz jj oa b gy ok og l oh oi"><em class="oj"># Above the rows marked True are the ones where all values equal.<br/># We actually want the rows marked False</em></span><span id="c606" class="oe mz jj oa b gy ok og l oh oi"><strong class="oa jk">In:<br/></strong><em class="oj"># Note that we specify the axis to let Pandas know that we care<br/></em># <em class="oj">about equality across all the columns in a row</em></span><span id="11d9" class="oe mz jj oa b gy ok og l oh oi">df_2[df_1.eq(df_2).all(axis=1)==False]</span><span id="2079" class="oe mz jj oa b gy ok og l oh oi"><strong class="oa jk">Out:<br/></strong>  Player Rings<br/>1   Kobe     3<br/>3  Larry     5</span></pre><p id="d354" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们发现我们朋友关于科比和拉里的数据都是错的(科比其实就是5环的那个)。因为我们正在寻找值不相等的单元格，所以我们实际上可以使用<strong class="la jk">更简洁地完成这项工作。ne </strong>方法(。ne代表不相等)和<strong class="la jk">。任何</strong>:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="379a" class="oe mz jj oa b gy of og l oh oi"><strong class="oa jk">In:<br/></strong># <em class="oj">.any returns true for row if any of the row's values are True</em></span><span id="a7a2" class="oe mz jj oa b gy ok og l oh oi">df_2[df_1.ne(df_2).any(axis=1)]</span><span id="0082" class="oe mz jj oa b gy ok og l oh oi"><strong class="oa jk">Out:<br/></strong>  Player Rings<br/>1   Kobe     3<br/>3  Larry     5</span></pre><p id="d4f8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">突出的一点是。情商和。当我们比较相同维数的数据帧时，效果更好。但是如果他们不是呢？比如说我们朋友的dataframe行数比我们多(加了KG和Charles)。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="5684" class="oe mz jj oa b gy of og l oh oi"><em class="oj"># Data from friend</em><br/>array_3 = np.array([['LeBron',3],<br/>                    ['Kobe',3],<br/>                    ['Michael',6,],<br/>                    ['Larry',5],<br/>                    ['Magic',5],<br/>                    ['Tim',4],<br/>                    ['KG',1],<br/>                    ['Charles',0]])<br/>df_3 = pd.DataFrame(array_3, <br/>                    columns=['Player','Rings'])</span></pre><p id="9ce4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们使用。需要找出不同之处。的。ne方法已确定第1、3、6和7行中的差异。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="1ed7" class="oe mz jj oa b gy of og l oh oi"><strong class="oa jk">In:</strong><br/>df_1.ne(df_3)</span><span id="a545" class="oe mz jj oa b gy ok og l oh oi"><strong class="oa jk">Out:</strong><br/>   Player  Rings<br/>0   False  False<br/>1   False   True<br/>2   False  False<br/>3   False   True<br/>4   False  False<br/>5   False  False<br/>6    True   True<br/>7    True   True</span></pre><p id="550c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们试图在df_1上使用布尔索引来打印差异，Python会给我们一个警告(因为我们的布尔索引比df_1长)，并且只打印Kobe和Larry的行(我们最初识别的差异)。它没有打印出KG和Karl，因为它们不在df_1中。为了打印所有的文件，我们需要在df_3上使用布尔索引:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="99c6" class="oe mz jj oa b gy of og l oh oi"><strong class="oa jk">In:</strong><br/>df_3[df_1.ne(df_3).any(axis=1)]</span><span id="f51a" class="oe mz jj oa b gy ok og l oh oi"><strong class="oa jk">Out:</strong><br/>    Player Rings<br/>1     Kobe     3<br/>3    Larry     5<br/>6       KG     1<br/>7  Charles     0</span></pre><h2 id="38fe" class="oe mz jj bd na ol om dn ne on oo dp ni lh op oq nk ll or os nm lp ot ou no ov bi translated">如果指数不同呢？</h2><p id="3f59" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">所以当数据帧长度不同时，它也能工作。但是如果指数不同呢？索引是数据帧的关键部分，它基本上是一行的名称，以及我们需要获取数据时如何引用该行。<strong class="la jk">当两个数据帧之间的索引不同时(即使单元格中的实际内容相同)，则。eq方法将它们视为不同的实体。</strong>让我们用字母索引代替数字索引来创建一个新的数据框架:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="221d" class="oe mz jj oa b gy of og l oh oi"><strong class="oa jk">In:</strong><br/># Array with alphabetical index<br/>df_4 = pd.DataFrame(array_3,<br/>                    index=['a','b','c','d','e','f','g','h'],<br/>                    columns=['Player','Rings'])<br/>print(df_4)</span><span id="cf23" class="oe mz jj oa b gy ok og l oh oi"><strong class="oa jk">Out:<br/></strong>    Player Rings<br/>a   LeBron     3<br/>b     Kobe     3<br/>c  Michael     6<br/>d    Larry     5<br/>e    Magic     5<br/>f      Tim     4<br/>g       KG     1<br/>h  Charles     0</span></pre><p id="26ca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们试试。eq。输出是一个长而无用的数据帧。它的行数与我们的两个数据帧df_1 (6行)和df_2 (8行)的总和一样多。这样做是因为即使单元格内容相同，索引也不相同。等式假设两个数据帧之间没有什么是相同的。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="83cb" class="oe mz jj oa b gy of og l oh oi"><strong class="oa jk">In:</strong><br/>df_1.eq(df_4)</span><span id="4970" class="oe mz jj oa b gy ok og l oh oi"><strong class="oa jk">Out:</strong><br/>   Player  Rings<br/>0   False  False<br/>1   False  False<br/>2   False  False<br/>3   False  False<br/>4   False  False<br/>5   False  False<br/>a   False  False<br/>b   False  False<br/>c   False  False<br/>d   False  False<br/>e   False  False<br/>f   False  False<br/>g   False  False<br/>h   False  False</span></pre><p id="9dfd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看如何解决这个问题。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="166d" class="my mz jj bd na nb nc nd ne nf ng nh ni kp nj kq nk ks nl kt nm kv nn kw no np bi translated">比较具有不同索引的数据帧</h1><p id="71cb" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">最简单的方法就是<strong class="la jk">重置</strong>索引。在这种情况下，我们只需要重置df_3的索引(它将从字母回到从0开始的数字)。不要忘记删除索引，这样在重置后就不会出现额外的列。</p><p id="da0b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你所看到的，由于重置了索引，输出回到了错误的条目(科比和拉里)以及新的条目(KG和查尔斯)。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="a8bb" class="oe mz jj oa b gy of og l oh oi"><strong class="oa jk">In:</strong><br/><em class="oj"># Reset index first and drop the original index</em><br/>df_3_reset = df_3.reset_index(drop=True)</span><span id="e690" class="oe mz jj oa b gy ok og l oh oi"><em class="oj"># Use boolean indexing and .ne method on reset index</em><br/>df_3_reset[df_1.ne(df_3_reset).any(axis=1)]</span><span id="619a" class="oe mz jj oa b gy ok og l oh oi"><strong class="oa jk">Out:</strong><br/>    Player Rings<br/>1     Kobe     3<br/>3    Larry     5<br/>6       KG     1<br/>7  Charles     0</span></pre><p id="08e5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不算太糟吧？这种方法的一个问题是，它要求第二个数据帧的索引(post reset)与第一个数据帧的对齐。换句话说，df_1和df_3中重叠的球员一定是相同的(而且顺序相同)，他们是——勒布朗、科比、迈克尔、拉里、魔术师、蒂姆。</p><p id="6116" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但如果他们不是呢？相反，假设我们下载了一些新数据，我们希望将它们合并到我们的数据集中。不幸的是，新的数据与我们现有的数据有一些冗余，即勒布朗，迈克尔和魔术师。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="61e4" class="oe mz jj oa b gy of og l oh oi"><em class="oj"># New data to add to our dataset</em><br/>array_new = np.array([['LeBron',3],<br/>                      ['Michael',6,],<br/>                      ['Magic',5],<br/>                      ['KG',1],<br/>                      ['Charles',0],<br/>                      ['Stephen',3],<br/>                      ['Patrick',0]])<br/>df_new = pd.DataFrame(array_new, <br/>                      columns=['Player','Rings'])</span></pre><p id="e48e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新数据如下所示。注意迈克尔的指数在df_1里是2但是在这里是1，魔术师的指数在df_1里是4但是在这里是2。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="ea3c" class="oe mz jj oa b gy of og l oh oi">    Player Rings<br/>0   LeBron     3<br/>1  Michael     6<br/>2    Magic     5<br/>3       KG     1<br/>4  Charles     0<br/>5  Stephen     3<br/>6  Patrick     0</span></pre><p id="3f6a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用之前的方法来比较数据帧。eq和. ne .首先让我们用。eq(和。all)来查看新数据和现有数据之间的相同之处:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="4674" class="oe mz jj oa b gy of og l oh oi"><strong class="oa jk">In:</strong><br/>df_new[df_1.eq(df_new).all(axis=1)]</span><span id="65bb" class="oe mz jj oa b gy ok og l oh oi"><strong class="oa jk">Out:<br/></strong>   Player Rings<br/>0  LeBron     3</span></pre><p id="d0cd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它说只有勒布朗的条目是相同的，即使迈克尔和魔术师的数据也是一样的。正如我们已经知道的，问题在于不同的指数。如果我们使用。ne(和。any)来标识新的或不同的行，我们会得到一个很长的列表，其中包括我们不想放在那里的行—我们不想错误地将多余的Michael和Magic条目插入到我们的数据中。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="d4c3" class="oe mz jj oa b gy of og l oh oi"><strong class="oa jk">In:</strong><br/>df_new[df_1.ne(df_new).any(axis=1)]</span><span id="451b" class="oe mz jj oa b gy ok og l oh oi"><strong class="oa jk">Out:<br/></strong>    Player Rings<br/>1  Michael     6<br/>2    Magic     5<br/>3       KG     1<br/>4  Charles     0<br/>5  Stephen     3<br/>6  Patrick     0</span></pre><h2 id="6938" class="oe mz jj bd na ol om dn ne on oo dp ni lh op oq nk ll or os nm lp ot ou no ov bi translated">使用合并</h2><p id="bb3a" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">在这种情况下，最好的方法(据我所知)是使用<strong class="la jk">。合并</strong>方法(<a class="ae jg" rel="noopener" target="_blank" href="/pandas-join-vs-merge-c365fd4fbf49">我在这里写了一篇关于合并的文章，所以如果你需要背景知识，可以看看这篇文章。合并</a>。这有点绕弯，但是<strong class="la jk">通过使用merge，我们可以只比较每个条目的值，而不考虑索引。</strong></p><p id="1631" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用Player和Rings列进行合并允许我们匹配现有数据帧和新数据帧中具有相同值的行(同时忽略数据帧索引中的差异)。我们需要重命名新数据帧中的Rings列，使它作为两个独立的列输出(旧的Rings和新的Rings_new)。一旦我们检查了输出，您就会明白为什么。</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="f98a" class="oe mz jj oa b gy of og l oh oi"># Need to rename Rings since we are merging on it but we want<br/># it to show as different columns post-merge<br/>temp = df_new.rename({'Rings': 'Rings_new'}, axis=1)</span><span id="801b" class="oe mz jj oa b gy ok og l oh oi">merged = temp.merge(df_1, how='left', <br/>                    left_on=['Player','Rings_new'],<br/>                    right_on=['Player','Rings'])</span></pre><p id="9f05" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经打印了名为“合并”的数据框的内容。NaN就是我们要找的东西(这也是为什么我们需要两栏都显示)。因为我们进行了左连接，所以输出包括df_new中的每一行——我们在df_1中已经有数据的球员在Rings列中有数值。<strong class="la jk">新玩家在“环”列中用NaN值表示，这是我们唯一想添加到数据集的玩家。</strong></p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="7d5a" class="oe mz jj oa b gy of og l oh oi">    Player Rings_new Rings<br/>0   LeBron         3     3<br/>1  Michael         6     6<br/>2    Magic         5     5<br/>3       KG         1   NaN<br/>4  Charles         0   NaN<br/>5  Stephen         3   NaN<br/>6  Patrick         0   NaN</span></pre><p id="e898" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过对数据帧进行切片来分离出新的条目，只对环中具有NaN值的行进行切片:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="82ef" class="oe mz jj oa b gy of og l oh oi"><strong class="oa jk">In:</strong><br/>df_new[merged['Rings'].isna()]</span><span id="18c4" class="oe mz jj oa b gy ok og l oh oi"><strong class="oa jk">Out:</strong><br/>    Player Rings<br/>3       KG     1<br/>4  Charles     0<br/>5  Stephen     3<br/>6  Patrick     0</span></pre><p id="5cbf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并像这样连接到我们的数据帧:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="a001" class="oe mz jj oa b gy of og l oh oi">final_df = pd.concat([df_1,<br/>                      df_new[merged['Rings'].isna()]],<br/>                     axis=0)</span></pre><p id="d260" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们得到了我们想要的。final_df的内容如下所示:</p><pre class="nv nw nx ny gt nz oa ob oc aw od bi"><span id="1669" class="oe mz jj oa b gy of og l oh oi">    Player Rings<br/>0   LeBron     3<br/>1     Kobe     5<br/>2  Michael     6<br/>3    Larry     3<br/>4    Magic     5<br/>5      Tim     4<br/>3       KG     1<br/>4  Charles     0<br/>5  Stephen     3<br/>6  Patrick     0</span></pre><p id="0f72" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，如果在新数据中有一个现有球员(如[LeBron，0])的错误条目，它也会被插入，因为我们合并了球员和戒指(因此，为了匹配条目，姓名和戒指数需要相同)。如果我们不想要这种行为，那么我们可以只在玩家列合并。这也可能引起问题，因为可能会有另一个同名但戒指数不同的球员(比如迈克尔·库帕有5枚戒指，而迈克尔·乔丹只有6枚)。当然，对于一个真实的数据集，我们将包括足够多的字段，以便我们可以唯一地识别每个球员(例如，名字，姓氏，出生日期)。</p><p id="c84f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望这是有见地的，祝你的数据框架好运！干杯！</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="1e04" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你总体上喜欢这篇文章和我的写作，请考虑通过我的推荐链接注册Medium来支持我的写作。谢谢！  </p></div></div>    
</body>
</html>