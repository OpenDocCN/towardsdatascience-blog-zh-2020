<html>
<head>
<title>3 Steps to Forecast Time Series: LSTM with TensorFlow Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测时间序列的三个步骤:LSTM与张量流Keras</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-steps-to-forecast-time-series-lstm-with-tensorflow-keras-ba88c6f05237?source=collection_archive---------4-----------------------#2020-03-22">https://towardsdatascience.com/3-steps-to-forecast-time-series-lstm-with-tensorflow-keras-ba88c6f05237?source=collection_archive---------4-----------------------#2020-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6fc4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中的一个实用示例，提供了有用的技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/05e68045cc47f928099ba34d63eb7520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mySrc8kG-CxEe4pO.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://stock.adobe.com/ca/images/black-retro-alarm-clock-on-yellow-background-top-view-flat-lay-copy-space-minimalistic-background-concept-of-time-deadline-time-to-work-morning/246199883?asset_id=246199883" rel="noopener ugc nofollow" target="_blank"> Adobe股票</a></p></figure><p id="fa27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们用<strong class="lb iu"> Python </strong>呈现一个深度学习时间序列分析实例。你会看到:</p><ul class=""><li id="721f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如何<strong class="lb iu">预处理/转换</strong>用于时间序列预测的数据集。</li><li id="1010" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当我们的计算机内存有限时，如何处理<strong class="lb iu">大型时间序列数据集</strong>。</li><li id="aa47" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何用<strong class="lb iu">tensor flow</strong><strong class="lb iu">Keras</strong>神经网络模型拟合<a class="ae ky" href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="noopener ugc nofollow" target="_blank">长短期记忆(<strong class="lb iu"> LSTM </strong> ) </a>。</li><li id="15d7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">还有更多。</li></ul><p id="ac87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想用机器学习技术分析大型时间序列数据集，你会喜欢这个带有<em class="mj">实用提示</em>的指南。</p><p id="c174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们现在开始吧！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="0cd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi mr translated">我们正在使用的数据集是来自Kaggle的<a class="ae ky" href="https://www.kaggle.com/uciml/electric-power-consumption-data-set" rel="noopener ugc nofollow" target="_blank">家庭用电量</a>。它以一分钟的采样率测量一个家庭的电力消耗。</p><p id="0fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在4年内收集了2，075，259个测量值。不同的电量和一些分计量值是可用的。但是我们将只关注三个特性:</p><ul class=""><li id="e57a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><em class="mj">日期</em>:日/月/年格式的日期</li><li id="5781" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj">时间</em>:时间格式为hh:mm:ss</li><li id="c72e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj">全局有功功率</em>:家庭全局分钟平均有功功率(千瓦)</li></ul><p id="d5c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个项目中，我们将预测10分钟后Global_active_power的电量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/3eb55a60d61efaa08f330486f0f75106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qDzPeUBkWEoywoMP.png"/></div></div></figure><h1 id="7e48" class="nd ne it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">步骤#1:为时间序列分析预处理数据集</h1><p id="875d" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">首先，让我们处理数据集，为时间序列分析做好准备。</p><p id="9bc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过以下方式转换数据集<em class="mj"> df </em>:</p><ul class=""><li id="953b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">通过组合日期和时间以日期时间格式创建特征<em class="mj">日期时间</em>。</li><li id="67a9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将Global_active_power转换为数字并删除缺失值(1.25%)。</li><li id="4da5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在新数据集中按时间对要素进行排序。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="93d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有一个数据集df如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/f54ab96fa36af382db77cba1a50ac717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/0*s9xjDJpOLDVxF2e4.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/d2239109801f79726a7090ba26bb964b.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*9sCLvEhxjHlW9OaL.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d27da93b4bf8ff531901c2768ef68da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/0*GpWo7DyoHtZTqPsG.png"/></div></figure><p id="53c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将数据集分为训练、验证和测试数据集。</p><p id="294a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj"> df_test </em>保存原始数据集中最近7天的数据。<em class="mj"> df_val </em>有测试数据集前14天的数据。<em class="mj"> df_train </em>有剩余的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/46e45fd6cfbf4dd3f1c3f77f62d91e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/0*YC5nDSlnanqQG2wk.png"/></div></figure><p id="2326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">相关文章</strong> : <a class="ae ky" rel="noopener" target="_blank" href="/time-series-analysis-visualization-forecasting-with-lstm-77a905180eba">时间序列分析，可视化&amp;与LSTM </a> <br/>预测本文仅比历史数据提前1分钟预测Global_active_power。<br/>但实际上，我们希望在更长的时间内进行预测，我们将在本文中这样做。</p><h1 id="7d1f" class="nd ne it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">步骤2:为TensorFlow Keras转换数据集</h1><p id="dfc3" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">在我们可以拟合张量流Keras LSTM之前，还有其他过程需要完成。</p><p id="f27c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一点一点地对付他们！</p><h2 id="e27c" class="oe ne it bd nf of og dn nj oh oi dp nn li oj ok np lm ol om nr lq on oo nt op bi translated">将数据集分成更小的数据帧</h2><p id="b6c7" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">如前所述，我们希望预测未来10分钟的Global_active_power。</p><p id="4ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图将问题可视化:使用滞后数据(从t-n到t-1)来预测目标(t+10)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/0c54616df7e8bfc323594952f7bceca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/0*s254H0RJvqRwYhfe.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单位:分钟</p></figure><p id="26f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在训练模型时遍历数据集是没有效率的。因此，我们希望用代表历史数据和目标的每一行来转换数据集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/746dd68a55836dff9b8443c6ca04d9c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/0*aGbeG_lf-qxCED3a.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单位:分钟</p></figure><p id="3747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们只需要使用上述矩阵的每一行来训练模型。</p><p id="c75a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在挑战来了:</p><ul class=""><li id="e92c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们如何将数据集转换成新的结构？</li><li id="eb5f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当我们的计算机内存有限时，我们如何处理这个更大的新数据结构呢？</li></ul><p id="19ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，函数<em class="mj"> create_ts_files </em>被定义为:</p><ul class=""><li id="e954" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将原始数据集转换为上面的新数据集。</li><li id="49d2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">同时，将新数据集分成更小的文件，这样更容易处理。</li></ul><p id="c79b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在该函数中，我们定义了以下参数:</p><ul class=""><li id="23da" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><em class="mj"> start_index </em>:包含在<em class="mj">所有</em>历史数据中进行预测的最早时间。<br/>在本练习中，我们希望从一开始就包含历史记录，因此我们将其默认值设置为0。</li><li id="c83e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj"> end_index </em>:被纳入<em class="mj">所有</em>历史数据进行预测的最晚时间。<br/>在本练习中，我们希望包括所有历史记录，因此我们将其默认值设置为无。</li><li id="2fdf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj"> history_length </em>:这是前面提到的n，是每次预测要回顾的时间步数。</li><li id="5762" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj"> step_size </em>:历史窗口的步幅。随着时间的推移，Global_active_power不会快速变化。所以为了更有效率，我们可以让step_size = 10。这样，我们下采样使用过去每10分钟的数据来预测未来的量。我们只看t-1，t-11，t-21直到t-n来预测t+10。</li><li id="aca1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj"> target_step </em>:未来要预测的期数。<br/>如前所述，我们试图提前10分钟预测global_active_power。所以这个特性= 10。</li><li id="4fa4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj"> num_rows_per_file </em>:放入每个文件的记录数。<br/>这是将大型新数据集分割成较小文件所必需的。</li><li id="fe0c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj"> data_folder </em>:包含所有文件的单一文件夹。</li></ul><p id="a619" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那是一大堆复杂的参数！</p><p id="a3ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后只要知道这个函数创建一个文件夹里面有文件就行了。<br/>每个文件包含一个熊猫数据帧，看起来像上面图表中的新数据集。<br/>每个数据帧都有列:</p><ul class=""><li id="ae12" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><em class="mj"> y </em>，这是要预测的目标。这将是t + target_step (t + 10)时的值。</li><li id="5cbf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj"> x_lag{i} </em>，时间t + target_step — i的值(t+10–11，t+10–21等等)，即相对于y的滞后值。</li></ul><p id="a937" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，该函数还返回数据帧中的滞后数(len(col_names)-1)。稍后为张量流模型定义形状时，将需要此数字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e99e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用create_ts_files函数之前，我们还需要:</p><ul class=""><li id="6944" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">缩放global_active_power以与神经网络一起工作。</li><li id="21d6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将历史记录长度n定义为7天(7*24*60分钟)。</li><li id="11b0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将历史数据中的步长定义为10分钟。</li><li id="6d78" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将target_step设置为10，这样我们就可以预测历史数据10分钟后的global_active_power。</li></ul><p id="e8b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们将创建ts文件应用于:</p><ul class=""><li id="8963" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在文件夹<em class="mj"> ts_data </em>中创建158个文件(每个文件包括一个熊猫数据帧)。</li><li id="3d40" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">返回<em class="mj"> num_timesteps </em>作为滞后数。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当函数运行时，它打印每10个文件的名称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/df54cbc682a8a805de890651b2a8e3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/0*UDYMs8qOS40MlYjh.png"/></div></figure><p id="bcb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ts_data文件夹大约有16 GB，我们仅使用过去7天的数据进行预测。现在，您可以看到为什么需要将数据集分成更小的数据帧了！</p><h2 id="cb79" class="oe ne it bd nf of og dn nj oh oi dp nn li oj ok np lm ol om nr lq on oo nt op bi translated">定义时间序列对象类</h2><p id="fdbd" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">在这个过程中，我们创建一个类<em class="mj"> TimeSeriesLoader </em>来转换数据帧并将其输入到模型中。</p><p id="8328" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有来自Keras的内置函数比如Keras Sequence，tf.data API。但是它们在这方面效率不高。</p><p id="209c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个类别中，我们定义:</p><ul class=""><li id="8b4b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><em class="mj"> __init__ </em>:对象的初始设置，包括:<br/> - <em class="mj"> ts_folder </em>，这将是我们刚刚创建的ts_data。<br/> - <em class="mj"> filename_format </em>，ts_folder中文件名的字符串格式。<br/>例如，当文件为ts_file0.pkl、ts_file1.pkl、…、ts_file100.pkl时，格式为ts _ file { }。pkl。</li><li id="719a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj"> num_chunks </em>:文件总数(块)。</li><li id="cfdb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj"> get_chunk </em>:这个方法从一个文件中取出数据帧，对其进行处理，为训练做准备。</li><li id="2d41" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj"> shuffle_chunks </em>:这个方法打乱了get_chunk中返回的块的顺序。这对于建模来说是一个很好的实践。</li></ul><p id="f40d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些定义可能看起来有点混乱。但是请继续阅读，您将在下一步中看到这个对象的作用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="31ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义之后，我们将这个TimeSeriesLoader应用到ts_data文件夹。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在对象tss指向了我们的数据集，我们终于为LSTM做好了准备！</p><h1 id="55a0" class="nd ne it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">步骤3:创建LSTM模型</h1><blockquote class="ot ou ov"><p id="b866" class="kz la mj lb b lc ld ju le lf lg jx lh ow lj lk ll ox ln lo lp oy lr ls lt lu im bi translated"><strong class="lb iu">长短期记忆</strong> ( <a class="ae ky" href="https://en.wikipedia.org/wiki/Long_short-term_memory" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> LSTM </strong> </a>)是一种用于深度学习领域的人工递归神经网络(RNN)架构。</p><p id="c8af" class="kz la mj lb b lc ld ju le lf lg jx lh ow lj lk ll ox ln lo lp oy lr ls lt lu im bi translated">LSTM网络非常适合基于时间序列数据进行分类、处理和预测，因为时间序列中的重要事件之间可能存在未知持续时间的滞后。</p></blockquote><p id="ad21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，我们将基于TensorFlow Keras库构建一个LSTM模型。</p><p id="efb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我们的<a class="ae ky" href="https://www.justintodata.com/hyperparameter-tuning-with-python-complete-step-by-step-guide/" rel="noopener ugc nofollow" target="_blank">指南</a>，我们都知道超参数调整的重要性。但是在本文中，我们只是简单地演示了没有调整的模型拟合。</p><p id="b9c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序如下:</p><ul class=""><li id="4cc8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">定义输入数据集的形状:<br/> - <em class="mj"> num_timesteps </em>，我们在步骤#2中设置的数据帧中的滞后数。<br/> -时间序列的<em class="mj">号</em>为1。因为我们只使用了global_active_power的一个功能。</li><li id="0de5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">定义<em class="mj">的数量单位</em>，4 *单位*(单位+2)是LSTM的参数数量。<br/>数字越高，模型中的参数越多。</li><li id="f31d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">定义<em class="mj">下降</em>率，用于防止过拟合。</li><li id="e310" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">指定<em class="mj">输出层</em>具有线性<em class="mj">激活功能</em>。</li><li id="acdd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">定义<em class="mj">型号</em>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="70ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们还定义了优化函数和损失函数。同样，调整这些超参数以找到最佳选项将是一种更好的做法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="eaed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在运行之前查看一下我们刚刚定义的模型，我们可以打印出摘要。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/ec3edb6764b445596619733944da3349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/0*KG0uDTnIKAtSJyHn.jpg"/></div></figure><p id="8736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以看到输出形状看起来不错，是n / step_size (7*24*60 / 10 = 1008)。需要训练的参数数量看起来也很合适(4 *单位*(单位+2) = 480)。</p><p id="8470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始建模吧！</p><p id="5294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们分批训练每个组块，只运行一个<a class="ae ky" href="https://deepai.org/machine-learning-glossary-and-terms/epoch" rel="noopener ugc nofollow" target="_blank">历元</a>。理想情况下，你可以为神经网络训练多个时期。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/046813fdf90c8aef34e83942b144c2e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AZ6pZvM7kLICRbJ8.png"/></div></div></figure><p id="10d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在拟合模型之后，我们还可以使用验证数据集来评估模型性能。</p><p id="b1c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与训练数据集相同，我们还创建了一个验证数据文件夹，为模型拟合准备验证数据集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/85ccca596dfaeecdef77e4d9d6a2e79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/0*LHcM76A7hhVov_Rc.png"/></div></figure><p id="0b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了使用验证数据集进行测试，我们还使用最近的历史点(t+10–11)对基线模型进行测试。</p><p id="a212" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是详细的Python代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用LSTM的验证数据集给出的均方误差(MSE)为0.418。而基线模型的MSE为0.428。LSTM的表现略好于基线。</p><p id="501d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过超参数调整和更多的纪元做得更好。此外，一些其他重要的时间序列分析技巧，如季节性，也会有所帮助。</p><p id="c4e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">相关文章</strong> : <a class="ae ky" href="https://www.justintodata.com/hyperparameter-tuning-with-python-complete-step-by-step-guide/" rel="noopener ugc nofollow" target="_blank">用Python调优超参数:完整分步指南</a></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="c2c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p><p id="72e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你能在本指南中找到有用的东西。如果你有任何问题，请留言。</p><p id="7d67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在离开之前，别忘了<a class="ae ky" href="https://www.justintodata.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mj">报名参加刚刚进入数据快讯</em> </a>！或者通过<a class="ae ky" href="https://twitter.com/JustintoData" rel="noopener ugc nofollow" target="_blank">推特</a>、<a class="ae ky" href="https://www.facebook.com/justintodata/" rel="noopener ugc nofollow" target="_blank">脸书</a>与我们联系。<br/>因此，您<em class="mj">不会</em>错过我们的任何新数据科学文章！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="0d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">原载于2020年3月22日</em><a class="ae ky" href="https://www.justintodata.com/forecast-time-series-lstm-with-tensorflow-keras/" rel="noopener ugc nofollow" target="_blank"><em class="mj">https://www.justintodata.com</em></a><em class="mj">。</em></p><div class="pc pd gp gr pe pf"><a href="https://www.justintodata.com/how-to-learn-data-science-online-all-you-need-to-know/" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">如何在线学习数据科学:你需要知道的一切——进入数据</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">这是利用在线资源进入数据科学的完整路线图/课程。你是否想学习…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">www.justintodata.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt ks pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://www.justintodata.com/coronavirus-death-rate-with-hyperparameter-tuning/" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">什么是冠状病毒死亡率与超参数调整-只是进入数据</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">我们用Python给出了一个深度学习时间序列分析的例子。您将看到:-如何预处理/转换…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">www.justintodata.com</p></div></div><div class="po l"><div class="pu l pq pr ps po pt ks pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://www.justintodata.com/use-nlp-in-python-practical-step-by-step-example/" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">如何在Python中使用NLP:一个实用的分步示例——只进入数据</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">在这篇文章中，我们展示了一个分步的NLP应用程序。这是对…的技术解释</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">www.justintodata.com</p></div></div><div class="po l"><div class="pv l pq pr ps po pt ks pf"/></div></div></a></div></div></div>    
</body>
</html>