<html>
<head>
<title>Sentinel-2 image clustering in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python 中的 Sentinel-2 图像聚类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sentinel-2-image-clustering-in-python-58f7f2c8a7f6?source=collection_archive---------23-----------------------#2020-06-09">https://towardsdatascience.com/sentinel-2-image-clustering-in-python-58f7f2c8a7f6?source=collection_archive---------23-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="202f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何在 python 中使用 scikit-learn 和 rasterio 执行无监督分类的分步教程</h2></div><div class="ki kj kk kl gt ab cb"><figure class="km kn ko kp kq kr ks paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/82f69f83109b387bede146521dce61ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*aduRGA-diO8NZl6GnkSEcg.jpeg"/></div></figure><figure class="km kn ko kp kq kr ks paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/c5d0066c16b2ac369eebafc2a24459b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*zPAfaYHdjpuSUPIlJoO2fg.jpeg"/></div><p class="kz la gj gh gi lb lc bd b be z dk ld di le lf translated">左图:苏丹杰济拉州 Elhasaheesa 地区的 Sentinel-2 图像。右图:Elhasaheesa 聚类图像(4 类)。</p></figure></div><p id="951c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu">聚类或无监督分类</strong>是根据统计相似性将图像的像素值分组或聚集成一定数量的自然类(组)的过程。在本教程中，我们将在<a class="ae md" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> jupyter 笔记本</a>中使用<em class="mc"> rasterio </em>进行<a class="ae md" href="http://www.esa.int/Applications/Observing_the_Earth/Copernicus/Sentinel-2" rel="noopener ugc nofollow" target="_blank"> sentinel-2 </a>图像操作，并使用 power full<em class="mc">scikit-learn</em>python 包进行聚类。</p><blockquote class="me mf mg"><p id="6ae7" class="lg lh mc li b lj lk ju ll lm ln jx lo mh lq lr ls mi lu lv lw mj ly lz ma mb im bi translated"><a class="ae md" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> <strong class="li iu"> Scikit-learn </strong> </a>是一个针对 Python 编程语言的免费软件机器学习库，包含各种分类、回归和聚类算法。要安装此软件包:</p></blockquote><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="f6ff" class="mp mq it ml b gy mr ms l mt mu">conda install -c anaconda scikit-learn</span></pre><blockquote class="me mf mg"><p id="8121" class="lg lh mc li b lj lk ju ll lm ln jx lo mh lq lr ls mi lu lv lw mj ly lz ma mb im bi translated"><a class="ae md" href="https://rasterio.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> <strong class="li iu"> Rasterio </strong> </a>是一个开源的 python 库，可以读写不同格式的栅格数据集，如卫星影像和地形模型，如 GEOTIFF 和 JP2。</p></blockquote><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="08a5" class="mp mq it ml b gy mr ms l mt mu">conda install -c conda-forge rasterio</span></pre><p id="b2f7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu">算法:</strong> Scikit-learn 有不同的聚类算法，这些算法可以直接从聚类子库中导入。<a class="ae md" href="https://en.wikipedia.org/wiki/K-means_clustering" rel="noopener ugc nofollow" target="_blank"> <strong class="li iu"> K-Means </strong> </a>算法简单，是聚类中使用最多的算法之一。它基本上将 n 个观察值(在我们的例子中是像素值)分成 k 个簇(由用户预先定义的类的数量)，其中每个观察值属于具有最近平均值的簇。本教程将基于 K-means，但你可以很容易地切换到尝试其余的，代码将几乎保持不变，但你只需要改变算法。</p><blockquote class="me mf mg"><p id="1ff1" class="lg lh mc li b lj lk ju ll lm ln jx lo mh lq lr ls mi lu lv lw mj ly lz ma mb im bi translated"><strong class="li iu">本教程将分别使用苏丹杰济拉州 El-hasaheesa 和 Elmanagel 地区的 Sentinel-2 图像进行训练和预测。这个数据和本教程的完整代码可以在</strong> <a class="ae md" href="https://github.com/wathela/Sentinel2-clustering" rel="noopener ugc nofollow" target="_blank"> <strong class="li iu"> github 上找到。</strong>T29】</a></p></blockquote><p id="b1ff" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">要开始这项工作，首先要导入所有需要的包:</p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="745b" class="mp mq it ml b gy mr ms l mt mu">import rasterio as rio<br/>from rasterio.plot import show<br/>from sklearn import cluster<br/>import matplotlib.pyplot as plt<br/>import numpy as np</span></pre><p id="2d8a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">然后将使用<em class="mc"> rasterio 打开图像并读入其元数据</em></p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="5ff2" class="mp mq it ml b gy mr ms l mt mu"># Open the image <br/>elhas_raster = rio.open("Elhasaheesa.tif")</span><span id="03f7" class="mp mq it ml b gy mv ms l mt mu">print(elhas_raster.meta)</span></pre><figure class="ki kj kk kl gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mw"><img src="../Images/bad79ba1816723bac19c81f3311feb8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwjE3V7TeYVbMxpmuHXJWw.png"/></div></div></figure><p id="0b0c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">元数据为我们提供了有关图像的信息，如数据类型、大小(宽度、高度)、计数(波段数)和坐标参考系统。为了更好地可视化这张图像，首先需要通过拉伸来调整它的对比度，你可以在这里  <strong class="li iu">阅读更多关于图像增强的内容<a class="ae md" href="https://seos-project.eu/remotesensing/remotesensing-c05-p02.html" rel="noopener ugc nofollow" target="_blank"> <strong class="li iu">。</strong></a></strong></p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="c9a9" class="mp mq it ml b gy mr ms l mt mu"># Read, enhance and show the image<br/>elhas_arr = elhas_raster.read() # read the opened image<br/>vmin, vmax = np.nanpercentile(elhas_arr, (5,95))  # 5-95% contrast stretch</span><span id="2b28" class="mp mq it ml b gy mv ms l mt mu"># show the enhanced image<br/>plt.figure(figsize=[20,20])<br/>show(elhas_raster, cmap='gray', vmin=vmin, vmax=vmax)<br/>plt.show()</span></pre><figure class="ki kj kk kl gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mx"><img src="../Images/3e3ee553357fa058d2cc63e4d2142308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aduRGA-diO8NZl6GnkSEcg.jpeg"/></div></div></figure><p id="acd8" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果我们打印此图像的形状，我们会看到它的顺序为(带、高、宽)，这需要首先更改为形状顺序(高、宽、带)。我们将通过以下方式改革这一模式:</p><ul class=""><li id="b121" class="my mz it li b lj lk lm ln lp na lt nb lx nc mb nd ne nf ng bi translated">使用元数据中的图像大小、计数和数据类型创建一个空数组。</li><li id="842b" class="my mz it li b lj nh lm ni lp nj lt nk lx nl mb nd ne nf ng bi translated">使用一个 for 循环来分割每个波段，并在我们的空数组中重组它。</li></ul><p id="c9d3" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这个循环的最后，我们将得到一个具有所需形状顺序的新数组，它具有相同的大小和带数。</p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="e767" class="mp mq it ml b gy mr ms l mt mu"># create an empty array with same dimension and data type<br/>imgxyb = np.empty((elhas_raster.height, elhas_raster.width, elhas_raster.count), elhas_raster.meta['dtype'])</span><span id="72d2" class="mp mq it ml b gy mv ms l mt mu"># loop through the raster's bands to fill the empty array<br/>for band in range(imgxyb.shape[2]):<br/>    imgxyb[:,:,band] = elhas_raster.read(band+1)</span></pre><figure class="ki kj kk kl gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nm"><img src="../Images/31801601164d0186525dee508061a545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YjGwxUwwWIW5pTeQGDqVPg.png"/></div></div></figure><p id="6990" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在，我们几乎准备好训练我们的分类器，但首先，我们需要将我们的 X(宽度)和 Y(高度)维度转换为 1 维，因此要有一个 2d 数组而不是 3d 数组，然后我们可以将它提供给 K-means 分类器。</p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="c68f" class="mp mq it ml b gy mr ms l mt mu"># convert to 1d array<br/>img1d=imgxyb[:,:,:3].reshape((imgxyb.shape[0]*imgxyb.shape[1],imgxyb.shape[2]))</span></pre><figure class="ki kj kk kl gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nm"><img src="../Images/7a094a8e467565a7116269ce34c715ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2lN_Kb-UoMPSr0gWUmC87A.png"/></div></div></figure><p id="0143" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu">训练:</strong>要设置的最重要的参数是<em class="mc"> n_clusters </em>，它表示我们要将像素分组到的簇的数量，在我们的图像中，我们可以直观地看到它有三个主要类别(建筑区、裸地和耕地)，但我们还有一个额外的类别，即感兴趣区域之外的黑色区域，其像素也可以分组到一个组中。K-means 有一些其他参数，如最大迭代次数和初始化次数，但在本教程中我们将把它们保留为默认值。</p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="3218" class="mp mq it ml b gy mr ms l mt mu">cl = cluster.KMeans(n_clusters=4) # create an object of the classifier<br/>param = cl.fit(img1d) # train it</span><span id="d64f" class="mp mq it ml b gy mv ms l mt mu">img_cl = cl.labels_ # get the labels of the classes<br/>img_cl = img_cl.reshape(imgxyb[:,:,0].shape) # reshape labels to a 3d array (one band only)</span></pre><p id="72da" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为了显示结果图像，我想使用一个自定义的颜色图，我可以控制每个类的颜色。我们将保持外部区域为黑色，其余的类使用红色、绿色和黄色。</p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="e0d6" class="mp mq it ml b gy mr ms l mt mu"># Create a custom color map to represent our different 4 classes<br/>cmap = mc.LinearSegmentedColormap.from_list("", ["black","red","green","yellow"])</span><span id="d207" class="mp mq it ml b gy mv ms l mt mu"># Show the resulting array and save it as jpg image<br/>plt.figure(figsize=[20,20])<br/>plt.imshow(img_cl, cmap=cmap)<br/>plt.axis('off')<br/>plt.savefig("elhas_clustered.jpg", bbox_inches='tight')<br/>plt.show()</span></pre><figure class="ki kj kk kl gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mx"><img src="../Images/fa9425680058ee66783b74b1cef15f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPAfaYHdjpuSUPIlJoO2fg.jpeg"/></div></div></figure><p id="60a6" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu">预测:</strong>一旦训练了分类器，就可以用它来预测任何看不见的图像中的相同的学习聚类。我们将使用 Elmanagel locality(与 Elhasaheesa 相邻)的图像来预测上面的 4 个类。</p><p id="e20e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">要使用 Elmanagel 的图像进行预测，我们需要对之前的图像进行所有的预处理(重新调整形状并重新形成 2d 数组)，然后才能将其提供给分类器。此外，还需要前面相同的步骤来显示得到的预测聚类。</p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="b8fd" class="mp mq it ml b gy mr ms l mt mu"># open the raster image<br/>elmanagel = rio.open(‘elmanagel.tif’)</span><span id="50a8" class="mp mq it ml b gy mv ms l mt mu"># create an empty array with same dimensions and data type <br/>elman_xyb = np.empty((elmanagel.height, elmanagel.width,elmanagel.count), elmanagel.meta['dtype'])</span><span id="5403" class="mp mq it ml b gy mv ms l mt mu"># loop through the raster bands and fill the empty array in x-y-bands order<br/>for band in range(elman_xyb.shape[2]):<br/>    elman_xyb[:,:,band] = elmanagel.read(band+1)</span><span id="c01c" class="mp mq it ml b gy mv ms l mt mu"># convert to 1d array<br/>elman_1d = elman_xyb[:,:,:3].reshape(elman_xyb.shape[0]*elman_xyb.shape[1], elman_xyb.shape[2])</span><span id="3281" class="mp mq it ml b gy mv ms l mt mu"># predict the clusters in the image <br/>pred = cl.predict(elman_1d)</span><span id="9a8c" class="mp mq it ml b gy mv ms l mt mu"># reshape the 1d array predictions to x-y-bands shape order (only one band)<br/>elman_cul = pred<br/>elman_cul = elman_cul.reshape(elman_xyb[:,:,0].shape)</span></pre><p id="3658" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在让我们在子图中显示原始图像和结果预测图像，但首先，我们将通过对比度拉伸来增强原始图像，以便更好地查看。</p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="229a" class="mp mq it ml b gy mr ms l mt mu">elman_arr = elmanagel.read() # Read the image<br/>vmin, vmax = np.nanpercentile(elman_arr, (5,95)) # 5–95% contrast stretch</span><span id="1fe5" class="mp mq it ml b gy mv ms l mt mu"># show the original and predicted image<br/>fig, (ax1,ax2) = plt.subplots(figsize=[15,15], nrows=1,ncols=2, sharey=False,)<br/>show(elmanagel, cmap='gray', vmin=vmin, vmax=vmax, ax=ax1)<br/>show(elman_cul, cmap=cmap, ax=ax2)<br/>ax1.set_axis_off()<br/>ax2.set_axis_off()<br/>fig.savefig("pred.png", bbox_inches='tight')<br/>plt.show()</span></pre><figure class="ki kj kk kl gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nn"><img src="../Images/6d28f6dc889e0e568e035b3a78e6b60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BF2-rNmOPGZHfvpbA3BSSg.png"/></div></div><p class="kz la gj gh gi lb lc bd b be z dk translated">左图:原图。右图:集群图像。</p></figure><h2 id="c1ad" class="mp mq it bd no np nq dn nr ns nt dp nu lp nv nw nx lt ny nz oa lx ob oc od oe bi translated"><strong class="ak">参考文献</strong></h2><div class="of og gp gr oh oi"><a href="https://link.springer.com/chapter/10.1007/978-981-13-6424-2_3" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">卫星图像聚类</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">应用科学与技术丛书(BRIEFSAPPLSCIENCES)遥感的一部分</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">link.springer.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow kx oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://scikit-learn.org/stable/" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">sci kit-学习</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">“我们使用 scikit-learn 来支持前沿基础研究[...]" "我认为这是我设计过的最棒的 ML 套装…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">scikit-learn.org</p></div></div><div class="or l"><div class="ox l ot ou ov or ow kx oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://rasterio.readthedocs.io/en/latest/" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">Rasterio:访问地理空间栅格数据- rasterio 文档</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">编辑描述</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">rasterio.readthedocs.io</p></div></div></div></a></div><div class="of og gp gr oh oi"><a href="https://seos-project.eu/remotesensing/remotesensing-c05-p02.html" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">遥感概论</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">为什么我们要增强卫星图像？使用不同的图像增强方法来准备“原始数据”,以便…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">seos-project.eu</p></div></div><div class="or l"><div class="oy l ot ou ov or ow kx oi"/></div></div></a></div></div></div>    
</body>
</html>