<html>
<head>
<title>Reshaping Pandas DataFrames</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重塑熊猫数据框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reshaping-pandas-dataframes-9812b3c1270e?source=collection_archive---------13-----------------------#2020-04-20">https://towardsdatascience.com/reshaping-pandas-dataframes-9812b3c1270e?source=collection_archive---------13-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1552" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">熔化、堆叠和旋转功能</h2></div><p id="b5a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Pandas 是一个非常强大的 Python 数据分析库，可以加速项目的预处理步骤。Pandas 的核心数据结构是<strong class="kk iu"> DataFrame </strong>，它以表格的形式表示数据，带有标记的行和列。在这篇文章中，我将尝试解释如何通过修改行列结构来重塑数据帧。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/60d18a42830ac0efcd6b4c683d75c16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1P7cmuEvd_C-c6euhFdIuw.jpeg"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">由<a class="ae lu" href="https://unsplash.com/@pawelskor?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">保罗·斯科鲁普斯卡斯</a>在<a class="ae lu" href="https://unsplash.com/s/photos/view?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="44e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有多种方法可以重塑数据帧。我们可以选择最适合手头任务的一个。重塑数据帧的函数:</p><ul class=""><li id="64a4" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated"><strong class="kk iu">融化</strong></li><li id="15cd" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><strong class="kk iu">堆叠和拆分</strong></li><li id="3a00" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><strong class="kk iu">枢轴</strong></li></ul><p id="4de1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一如既往，我们从进口熊猫开始:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="d1a0" class="mo mp it mk b gy mq mr l ms mt">import pandas as pd<br/>import numpy as np</span></pre><h1 id="a8cb" class="mu mp it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated"><strong class="ak">融化</strong></h1><p id="2ea2" class="pw-post-body-paragraph ki kj it kk b kl nl ju kn ko nm jx kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated">Melt 用于将宽数据帧转换为窄数据帧。我所说的宽是指具有大量列的数据帧。一些数据帧的结构是连续的测量值或变量用列来表示。在某些情况下，将这些列表示为行可能更适合我们的任务。</p><p id="0280" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑以下数据帧:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="ab8e" class="mo mp it mk b gy mq mr l ms mt">df1 = pd.DataFrame({'city':['A','B','C'],<br/>                   'day1':[22,25,28],<br/>                   'day2':[10,14,13],<br/>                   'day3':[25,22,26],<br/>                   'day4':[18,15,17],<br/>                   'day5':[12,14,18]})</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/43bedbb8012abfa63889d7efc6dc804c.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*NtPfshzMXGu7bX9oSao5Hw.png"/></div></figure><p id="8c8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有三个不同的城市，在不同的日子进行测量。我们决定用一列中的行来表示这些日子。还会有一列显示测量结果。我们可以通过使用<strong class="kk iu">熔化</strong>功能轻松实现这一点:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="d935" class="mo mp it mk b gy mq mr l ms mt">df1.melt(id_vars=['city'])</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/60432f8ea1cad7a30c595c690d4725cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*LdFW-Y1x5mqZdgsaO0WwPw.png"/></div></figure><p id="3d71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，变量和值列的名称是给定的。我们可以使用 melt 函数的参数<strong class="kk iu"> var_name </strong>和<strong class="kk iu"> value_name </strong>来指定新的列名。如果我们按城市列对数据进行排序，效果会更好:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="e8a4" class="mo mp it mk b gy mq mr l ms mt">df1.melt(id_vars=['city'], var_name = 'date', value_name = 'temperature').sort_values(by='city').reset_index(drop=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/01b016954f55e9918f6c432cd43cde44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*cxb3v4KxgttSGdNc5xdHKQ.png"/></div></figure></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="8243" class="mu mp it bd mv mw oa my mz na ob nc nd jz oc ka nf kc od kd nh kf oe kg nj nk bi translated"><strong class="ak">堆叠和拆分</strong></h1><p id="56fc" class="pw-post-body-paragraph ki kj it kk b kl nl ju kn ko nm jx kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated">堆栈函数增加了数据帧的索引级别。我所说的提高水平是指:</p><ul class=""><li id="cad5" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">如果 dataframe 有一个简单的列索引，stack 返回一个系列，其索引由原始 dataframe 的行列对组成。</li><li id="778b" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">如果数据帧有多级索引，stack 增加索引级别。</li></ul><p id="745c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用例子解释更好。考虑以下数据帧:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi of"><img src="../Images/a535625f6b364f037a7a8160a72f4985.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*Kho1z7qRaz4hFL4gkM105A.png"/></div></div></figure><p id="a69e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">df1 有 3 行 6 列，具有简单的整数列索引。如果将 stack 函数应用于 df1，它将返回 3 x 6 = 18 行的序列。序列的索引将是[(0，'城市')，(0，'第 1 天')，…，(2，'第 5 天')]。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi og"><img src="../Images/0007d70cdb339e0b3e81fe6f9cfb16c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*XRdY-1IKZ2i8wXm1gwnq6w.png"/></div></figure><p id="b457" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们也检查一下形状和指数:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="79ec" class="mo mp it mk b gy mq mr l ms mt">df1.shape<br/>(3,6)</span><span id="8466" class="mo mp it mk b gy oh mr l ms mt">df1.stack().shape<br/>(18,)</span><span id="e47f" class="mo mp it mk b gy oh mr l ms mt">df1.stack().index[0] #multilevel index<br/>(0, 'city')</span></pre><p id="fc9b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">栈和非栈功能更常用于具有多级索引的数据帧。让我们创建一个具有多级索引的数据框架:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="543d" class="mo mp it mk b gy mq mr l ms mt">tuples = [('A',1),('A',2),('A',3),('B',1),('A',2)]</span><span id="779d" class="mo mp it mk b gy oh mr l ms mt">index = pd.MultiIndex.from_tuples(tuples, names=['first','second'])</span><span id="07ab" class="mo mp it mk b gy oh mr l ms mt">df2 = pd.DataFrame(np.random.randint(10, size=(5,2)), <br/>                   index=index, columns=['column_x', 'column_y'])</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/4f47c70a009b847b2d8a27f5651848a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*abGJDOi2IuTyvRfaDBz9ww.png"/></div></figure><p id="ca3c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们对该数据帧应用堆栈功能，索引级别将会增加:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="8ed5" class="mo mp it mk b gy mq mr l ms mt">df_stacked = df2.stack().to_frame()<br/>df_stacked</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/5a47a329fd4a3628cba9080d81829cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*VRAN1q-P741md2PsZrXhGA.png"/></div></figure><p id="6210" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，列名(column_x 和 column_y)是多级索引的一部分。因此得到的数据帧有一列和一个 3 级多索引。</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="31d0" class="mo mp it mk b gy mq mr l ms mt">len(df_stacked.index.levels)<br/>3</span><span id="c9f3" class="mo mp it mk b gy oh mr l ms mt">len(df2.index.levels)<br/>2</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/48c31b1b2403b2fcce33431afcb73d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*D7A1Vf3xCYZd13P9WSoX9w.png"/></div></figure><p id="fbce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">拆垛</strong>与<strong class="kk iu">垛</strong>正好相反。如果我们对堆叠的数据帧应用拆分，我们将得到原始的数据帧:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/91ea29df0387dbaecf5884d5e0daa4b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*Oq_ARDg6JzgSL-p0SO3Hsg.png"/></div></figure><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="0646" class="mo mp it mk b gy mq mr l ms mt">df_stacked.unstack().index<br/>MultiIndex(levels=[['A', 'B'], [1, 2, 3]],<br/>           codes=[[0, 0, 0, 1, 1], [0, 1, 2, 0, 1]],<br/>           names=['first', 'second'])</span><span id="bbdf" class="mo mp it mk b gy oh mr l ms mt">df2.index<br/>MultiIndex(levels=[['A', 'B'], [1, 2, 3]],<br/>           codes=[[0, 0, 0, 1, 1], [0, 1, 2, 0, 1]],<br/>           names=['first', 'second'])</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi om"><img src="../Images/575872d31b6fd43bcb80964e141224bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*szBs075TTWqTF4BdFBC3uA.png"/></div></figure></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="fef2" class="mu mp it bd mv mw oa my mz na ob nc nd jz oc ka nf kc od kd nh kf oe kg nj nk bi translated"><strong class="ak">支点</strong></h1><p id="1558" class="pw-post-body-paragraph ki kj it kk b kl nl ju kn ko nm jx kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated">Pivot 函数也可以被认为是从不同的角度看待数据帧的一种方式。它通过允许以不同的格式表示数据来探索变量之间的关系。</p><p id="fb0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑以下数据帧:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi on"><img src="../Images/6f0cfcdcc369e9f63f2fb583a2cd137a.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*GFhktSKbIHQaUkKFg7pfAQ.png"/></div></figure><p id="40fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们想看看城市名对的值是如何变化的。我们可以用城市名称和列的索引来创建这个数据帧的新表示。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oo"><img src="../Images/4ab03ae6c680d787f04ac5e9e5d861c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*tKTnmL-LbDNEWWqMuotYMw.png"/></div></div></figure><p id="88c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果城市名对不存在，则用 NaN 填充相应的单元格。</p><p id="0ad7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不必一次看到所有的值。可使用<strong class="kk iu">值</strong>参数过滤数据框中的值:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi op"><img src="../Images/4334e6551fa2411f67e5be255697892d.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*9-sv6wAAUtPXU5SZ7rhbjg.png"/></div></figure></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="056a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为熊猫的成功和流行来自于其多功能、强大且易于使用的操作和分析数据的功能。和熊猫一起完成一项任务几乎总是有多种方式。由于花在数据科学项目上的大部分时间都花在数据清理和预处理步骤上，所以非常鼓励学习 Pandas。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="2c92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>