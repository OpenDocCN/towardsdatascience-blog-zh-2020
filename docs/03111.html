<html>
<head>
<title>Sample Load balancing solution with Docker and Nginx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Docker 和 Nginx 的负载平衡解决方案示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sample-load-balancing-solution-with-docker-and-nginx-cf1ffc60e644?source=collection_archive---------0-----------------------#2020-03-25">https://towardsdatascience.com/sample-load-balancing-solution-with-docker-and-nginx-cf1ffc60e644?source=collection_archive---------0-----------------------#2020-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/98be09705718b99e6b11af2dc07cc25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LbwakX5-sJNsP-Gbxku75w.png"/></div></div></figure><h2 id="2532" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">当今大多数业务应用程序都使用负载平衡在不同资源之间分配流量，避免单个资源过载。</h2><p id="32d5" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm kh ln lo lp kl lq lr ls kp lt lu lv lw ij bi translated">负载平衡架构的一个明显优势是提高了应用程序的可用性和可靠性，因此，如果一定数量的客户端向后端请求一定数量的资源，负载平衡器会留在它们之间，并将流量路由到满足大多数路由标准(不太忙、最健康、位于给定区域)的后端..等等)。</p><p id="e87a" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated">有很多路由标准，但我们将把本文的重点放在固定的循环标准上——这意味着每个后端接收固定量的流量——我认为这很少被记录下来:)。</p><p id="3b47" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated">为了简化，我们将基于 flask Python 文件创建两个后端“应用程序”。我们将使用 NGINX 作为负载平衡器，将 60%的流量分配给应用 1，40%的流量分配给应用 2。</p><p id="9075" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated">让我们开始编码，以下是我们项目的完整架构:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/73925cd0957d44b33685d29466312ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*YETE6N8dZoakzh1yh5UiJQ.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">负载平衡项目树</p></figure><p id="db3a" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated"><strong class="le ir"> app1/app1.py </strong></p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="0b10" class="jy jz iq mm b gy mq mr l ms mt">from flask import request, Flask<br/>import json</span><span id="946c" class="jy jz iq mm b gy mu mr l ms mt">app1 = Flask(__name__)<br/>@app1.route('/')</span><span id="2a46" class="jy jz iq mm b gy mu mr l ms mt">def hello_world():<br/>return 'Salam alikom, this is App1 :) '</span><span id="1af8" class="jy jz iq mm b gy mu mr l ms mt">if __name__ == '__main__':<br/>app1.run(debug=True, host='0.0.0.0')</span></pre><p id="4d85" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated"><strong class="le ir"> app2/app2.py </strong></p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="4389" class="jy jz iq mm b gy mq mr l ms mt">from flask import request, Flask<br/>import json</span><span id="7b9e" class="jy jz iq mm b gy mu mr l ms mt">app1 = Flask(__name__)<br/>@app1.route('/')</span><span id="f6fd" class="jy jz iq mm b gy mu mr l ms mt">def hello_world():<br/>return 'Salam alikom, this is App2 :) '</span><span id="ddf8" class="jy jz iq mm b gy mu mr l ms mt">if __name__ == '__main__':<br/>app1.run(debug=True, host='0.0.0.0')</span></pre><p id="7b58" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated">然后，我们必须通过添加 requirements.txt 文件来对两个应用程序进行 dockerize。它将只包含 flask 库，因为我们使用的是 python3 映像。</p><p id="7dae" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated"><strong class="le ir">app 1/requirements . txt</strong><br/>您可以为 app2 创建相同的。</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="8ba0" class="jy jz iq mm b gy mq mr l ms mt">Flask==1.1.1</span></pre><p id="6422" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated"><strong class="le ir"> app1/Dockerfile </strong> <br/>你可以为 app2 创建相同的。</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="b611" class="jy jz iq mm b gy mq mr l ms mt">FROM python:3<br/>COPY ./requirements.txt /requirements.txt<br/>WORKDIR /<br/>RUN pip install -r requirements.txt<br/>COPY . /<br/>ENTRYPOINT [ "python3" ]<br/>CMD [ "app1.py" ]</span></pre><p id="8086" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated">我们将使用 NGINX 作为负载平衡器，路由标准将由循环法<strong class="le ir">权重</strong>参数保证:</p><p id="316e" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated"><strong class="le ir"> nginx/nginx.conf </strong></p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="0510" class="jy jz iq mm b gy mq mr l ms mt">upstream loadbalancer {<br/>server 172.17.0.1:5001 weight=6;<br/>server 172.17.0.1:5002 weight=4;<br/>}<br/>server {<br/>location / {<br/>proxy_pass <a class="ae mv" href="http://loadbalancer;" rel="noopener ugc nofollow" target="_blank">http://loadbalancer;</a><br/>}}<br/></span></pre><p id="f0b6" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated">然后，我们将通过使用 Nginx 映像创建 Dockerfile 来对我们的负载平衡器进行 dockerize。它会在启动时将上述 conf 文件复制到容器内的相关路径中。</p><p id="7314" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated"><strong class="le ir"> nginx/Dockerfile </strong></p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="a16e" class="jy jz iq mm b gy mq mr l ms mt">FROM nginx<br/>RUN rm /etc/nginx/conf.d/default.conf<br/>COPY nginx.conf /etc/nginx/conf.d/default.conf</span></pre><p id="2ff9" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated">现在我们将创建 docker-compose 文件，该文件将加速我们的完整架构，以便我们可以从浏览器访问它。</p><p id="3973" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated"><strong class="le ir"> docker-compose.yml </strong></p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="e0cb" class="jy jz iq mm b gy mq mr l ms mt">version: '3'<br/>services:<br/>app1:<br/>build: ./app1<br/>ports:<br/>- "5001:5000"<br/>app2:<br/>build: ./app2<br/>ports:<br/>- "5002:5000"<br/>nginx:<br/>build: ./nginx<br/>ports:<br/>- "8080:80"<br/>depends_on:<br/>- app1<br/>- app2</span></pre><p id="4a3d" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated">关于 docker-compose.yml 的一些要点:</p><ul class=""><li id="e34a" class="mw mx iq le b lf lx lj ly kh my kl mz kp na lw nb nc nd ne bi translated">它将基于我们的 docker 文件为 app1、app2、Nginx 构建映像，然后根据这些映像构建容器。</li><li id="fb3b" class="mw mx iq le b lf nf lj ng kh nh kl ni kp nj lw nb nc nd ne bi translated">app1 和 app2 容器中打开的端口是 5000(flask 使用的默认端口)，这些端口将被映射到 5001 和 5002。<br/>负载平衡器会根据该端口将流量路由到适当的应用程序。</li><li id="7101" class="mw mx iq le b lf nf lj ng kh nh kl ni kp nj lw nb nc nd ne bi translated">负载平衡器(Nginx)会将其内部 80 端口暴露给 8080，这样我们就可以从<a class="ae mv" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>访问应用程序</li></ul><p id="51cd" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated">最后，我们将通过运行下面的命令来加速我们的架构，并在浏览器中享受结果:)</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="54ec" class="jy jz iq mm b gy mq mr l ms mt">docker-compose up</span></pre><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/266db2a2251ca9530cbd00955261c869.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*NSIVjwuXPqoyybaJYksadg.png"/></div></figure><p id="226a" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated">您还可以在下面的 GitLab repo 中找到完整的代码:</p><div class="nl nm gp gr nn no"><a href="https://gitlab.com/ouassini/load-balancing" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">Abdelilah OUASSINI /负载平衡</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">GitLab.com</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">gitlab.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc jw no"/></div></div></a></div><p id="0695" class="pw-post-body-paragraph lc ld iq le b lf lx lh li lj ly ll lm kh lz lo lp kl ma lr ls kp mb lu lv lw ij bi translated">一如既往，我希望你学到了新的东西。萨拉姆:)</p></div></div>    
</body>
</html>