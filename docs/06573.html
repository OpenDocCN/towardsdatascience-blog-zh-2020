<html>
<head>
<title>Linear Regression with Python and scikit-learn library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和scikit进行线性回归-学习库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/glr-with-python-and-scikit-learn-library-67b5b0d418ea?source=collection_archive---------45-----------------------#2020-05-24">https://towardsdatascience.com/glr-with-python-and-scikit-learn-library-67b5b0d418ea?source=collection_archive---------45-----------------------#2020-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="c512" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">机器学习</h2><div class=""/><div class=""><h2 id="6963" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">广义线性回归导论</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/87e6386ae5e40ffab0d1dfdde126407d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZXc4vX6Ra_sXZH21LYibg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">从<a class="ae le" href="https://unsplash.com/@fabioha" rel="noopener ugc nofollow" target="_blank">@法比奥哈</a>到<a class="ae le" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/</a></p></figure><p id="28bb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一般来说，机器学习、统计学和应用数学中最常用的工具之一是回归工具。我说的是回归，但是有许多回归模型，这里我将尝试介绍的是众所周知的广义线性回归。这个复杂词背后的思想非常简单:我们试图拟合的观察值应该是输入解释变量的线性组合。在数学上，观测向量被公式化</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/07c4f2fe2228bef7c811fee03ff77186.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*TB9w0X_IDbVylkzwKeqO4g.png"/></div></figure><p id="6a31" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">其中<em class="mc"> x </em> ₖ代表解释向量<em class="mc"> k </em>，而<em class="mc"> w </em> ₖ是每个解释变量的权重。此外，由于我们通常需要一个截距，按照惯例，我们设置<em class="mc"> x </em> ₀ <em class="mc"> =1 </em>，因此权重<em class="mc"> w </em> ₀代表截距。</p><h1 id="775f" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">线性回归</h1><p id="982a" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo mx lq lr ls my lu lv lw mz ly lz ma ij bi translated">作为第一个例子，让我们从一个简单的线性回归开始，它包括最小化误差平方和。误差被定义为预期真实值和通过我们的模型获得的预测值之间的差异</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi na"><img src="../Images/c3c14ff1eb17a3cfad431249726cc9b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46IQv7W09DJEPNkNxC-15g.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">线性模型的成本函数</p></figure><p id="ad40" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于所有m点<em class="mc"> (xᵢ，yᵢ) </em></p><p id="0d76" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了说明这个简单的例子，让我们使用令人敬畏的库scikit-learn，特别是包<code class="fe nb nc nd ne b">sklearn.linear_model</code></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/983ccf9d57e9f2ecf34bce589b2386e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*il_Z_bhZ-OKJOS6L.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">简单线性回归</p></figure><p id="7c5d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们在这里使用的模型非常简单，它只是一条线。该模型似乎很好，拟合系数为<em class="mc"> w₀ =-0.87998 </em>和<em class="mc"> w₁=4.54914 </em>，但误差不为零(示例中均方差= 15.57)。有时，减少残差的一种方法是用稍微复杂一点的模型来改变模型。在我们的例子中，我们简单地拟合了一个1次多项式。如果我们增加多项式次数呢？例如，假设我们将度数增加到12:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/32ef43fefd1629208e0adc3f6a950f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/0*4SmgRTt40afDDZ_q.jpg"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">多项式次数的影响</p></figure><p id="19b0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如我们所见，模型的多项式次数越多，残差就越小。然而，在这个例子中尤其明显的是，误差的减小不一定是更好模型的标志。事实上，假设我们使用一个高次多项式作为我们的模型，误差往往是零(实际上这是因为我们有一个多项式次数等于观察次数)。但是，如果我们增加一个额外的观察，我们的模型肯定会经历一个高残差。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6c6a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">结果是</p><p id="7037" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于 X=15 <strong class="lh ja">的残差<strong class="lh ja">为</strong>【57.50465854】<br/>对于</strong> X=15 <strong class="lh ja">的残差<strong class="lh ja">为</strong>【540.59208041】<br/>对于</strong> X=15 <strong class="lh ja">的残差<strong class="lh ja">为</strong>【23711.11027247】<br/></strong></p><p id="3120" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如我们在本例中看到的，在x = 15处添加一个观测值会导致多项式次数的误差增加。这种行为被称为过度拟合，即模型非常适合数据，但往往对新数据表现不佳。我们说它遭受巨大的变化。</p><p id="2dcf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了克服这个问题，我们需要选择正确的多项式次数。例如，我们可以将数据集分成两部分，一个训练集和一个测试集。然后，最佳模型将是在测试集上具有最小残差的模型。然而，有一个聪明的方法来限制过度拟合现象:正则化。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="8656" class="md me iq bd mf mg nq mi mj mk nr mm mn kf ns kg mp ki nt kj mr kl nu km mt mu bi translated">正规化</h1><p id="0788" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo mx lq lr ls my lu lv lw mz ly lz ma ij bi translated">正则化包括向模型添加惩罚，目标是防止过度拟合。它来源于这样的假设，当多项式的次数增加时(举我们的第一个例子)，每个多项式的权重也增加。因此，为了克服过度拟合，我们惩罚高权重的单体。最小化函数现在变成了</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nv"><img src="../Images/e1a94c1c43de613604aa8f107116c283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DcSFHTV7Ha6lyA_5NF761Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">正则化成本函数</p></figure><p id="488a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">其中|。|通常是L1或L2范数，而λ是一个超参数，它可以被调整以调节惩罚敏感性(0表示没有惩罚，即未规范化的模型)。两种广泛使用的正则化方法是L1和L2正则化，也称为<a class="ae le" href="http://en.wikipedia.org/wiki/Least_squares#Lasso_method" rel="noopener ugc nofollow" target="_blank">套索</a>和<a class="ae le" href="http://en.wikipedia.org/wiki/Tikhonov_regularization" rel="noopener ugc nofollow" target="_blank">岭</a>回归。</p><h1 id="66e2" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">套索</h1><p id="355d" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo mx lq lr ls my lu lv lw mz ly lz ma ij bi translated">引用scikit-learn库的内容</p><blockquote class="nw nx ny"><p id="fd80" class="lf lg mc lh b li lj ka lk ll lm kd ln nz lp lq lr oa lt lu lv ob lx ly lz ma ij bi translated">LASSO在某些情况下很有用，因为它倾向于使用较少参数值的解决方案，有效地减少了给定解决方案所依赖的变量的数量。因此，套索及其变体是压缩传感领域的基础。在某些条件下，它可以恢复非零权重的精确集合。</p></blockquote><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/00b9127cbcf3fb7a20f11fa1d6bb0d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/0*4QHAMtIFGyzPoYf8.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">套索正则化的影响</p></figure><p id="cf72" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们清楚地看到正规化的效果。当我们增加惩罚时，我们强烈限制每个系数的权重，直到只保留截距。但是如何选择合适的参数呢？在这里，我们再次需要查看在不是训练集的集合上计算的残差。这种方法被称为验证。原则是将数据集分成三部分，比如80%用于训练集，10%用于验证，10%用于测试。在训练集上训练模型，然后使用验证集来选择超参数。最后，使用测试集来估计模型的真实误差。然而，在小数据集上，这种方法不够有效，因为它限制了可用于训练的数据量。对于这样的小数据集，我们可以应用交叉验证的方法。为此，我们将数据集分成两部分，一部分用于训练，另一部分用于测试。然后，对除了一些k样本之外的所有训练集执行训练。所以我们假设训练集由N个样本组成。我们对N-k个样本执行N/k次回归，并计算k个剩余样本的验证误差。在所有这些回归之后，验证误差是所有验证误差的平均误差。</p><p id="0121" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在scikit-learn库中，有一个类实现了这种方法并找到了最佳的超参数:LassoCV。然后，我们重用前面省略了<code class="fe nb nc nd ne b">alpha</code>参数的代码示例，以强制使用<code class="fe nb nc nd ne b">LassoCV</code>模型:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/2f1ee2bbb0539440fc25cfcc5f6d6be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/0*GLgWE1a9fke1ucSL.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">套索正则化的最优解</p></figure><p id="dfd8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">根据拉索夫模型，最佳超参数alpha=4.16e⁻⁴.</p><h1 id="d82e" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">里脊回归</h1><p id="04fd" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo mx lq lr ls my lu lv lw mz ly lz ma ij bi translated">岭回归与LASSO非常相似，不同之处仅在于正则项中使用的范数的阶数。在LASSO中，我们使用一阶范数(L1)，在岭回归中，我们使用二阶范数(L2)。这种正则化技术的行为是模型的所有结果权重仍然是非空的，但是最终具有非常小的值，使得它们对预测值的影响非常低。相反，LASSO通过最终将权重设置为空来增加模型的稀疏性，这使得模型解释更容易。岭回归的主要优点是它与乘法因子无关，倾向于高度相关变量的权重相等，而LASSO会选择这个或那个。</p><p id="fae7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们示例的实现与前面的LASSO案例非常相似。我们要做的就是把<code class="fe nb nc nd ne b">Lasso</code>和<code class="fe nb nc nd ne b">LassoCV</code>换成<code class="fe nb nc nd ne b">Ridge</code>和<code class="fe nb nc nd ne b">RidgeCV</code>！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/de1c3d2384c220651098211007664f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/0*G1-7XArZ2BMX3lQi.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">山脊正则化的影响</p></figure><p id="6ba1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过交叉验证:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/5c8f3b31f77db06edc57331607e3c7ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*xABSUVlCdV9bDmtC.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">岭正则化最优解</p></figure><p id="6873" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如我们所见，最终的模型与套索正则化略有不同。如果我们现在看看权重系数:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/b77de622bdca72439e78c8ef251e0d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eIYb2UNMFtHHubkUeuqd-w.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">两种正则化的回归系数比较</p></figure><h1 id="084d" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">结论</h1><p id="9116" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo mx lq lr ls my lu lv lw mz ly lz ma ij bi translated">在本文中，我们看到了两种正则化技术，以及在尝试拟合模型时使用正则化的重要性。我们还看到，尽管这两种技术非常相似，但却给出了非常不同的结果。事实上，脊技术包括了所有的解释变量，而套索技术产生了一个稀疏的模型，通常更容易理解。然而，LASSO在高度相关变量的情况下表现不太好，因为它倾向于在结果中产生高度稀疏。这正是我们在示例中尝试用多项式拟合余弦时看到的情况。每个变量都是高度相关的，因此得到的模型有许多零值作为权重系数。除了脊和套索，弹性网格是另一种结合了L1和L2正则化的有用技术。它允许学习一个稀疏模型，同时它也保持山脊性质。</p><h1 id="12f7" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">结束注释</h1><p id="8ed4" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo mx lq lr ls my lu lv lw mz ly lz ma ij bi translated">我们简要地讨论了这个主题，但是和机器学习一样，我们需要几个数据集来训练模型、验证模型和测试模型。我们稍微讨论了一下，很快就看到了如何用交叉验证来处理小数据集。</p></div></div>    
</body>
</html>