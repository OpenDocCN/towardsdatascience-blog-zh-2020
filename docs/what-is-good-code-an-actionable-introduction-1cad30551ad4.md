# 什么是好代码？

> 原文：<https://towardsdatascience.com/what-is-good-code-an-actionable-introduction-1cad30551ad4?source=collection_archive---------23----------------------->

## 编码最佳实践

## 10 分钟可操作的介绍。

![](img/4319da30ba2b4f8c070397a7d94ae261.png)

优秀的代码转换器(图片由作者提供)

在接下来的部分，我将介绍手头的主题，让你了解这篇文章将会涵盖的内容，以及其中的每一个论点将会如何处理。希望这能帮助你决定是否值得花时间阅读这篇文章的其余部分。然而，如果你想快速找到文章的症结所在，可以跳过下面的部分。好东西在那里等着你！

你想知道成为一名伟大的程序员必须遵循的 5 个简单提示吗？或者，提升你的编码能力，并在科技巨头中获得梦想中的工作的秘方？

—如果是，**停止**阅读。

因为，今天我拒绝让你知道这些强大的行业秘密。我这样做的原因有三。

## **1。没有这样的秘密。**

如果有的话，我也退出俱乐部。唉！

## 2.写好代码的能力对别人的帮助比对你的帮助更大

如果你想学习写好代码，从而改善你的简历，或者能够完成你的下一个可交付成果，那么这是**而不是**需要学习的技能。写好代码是一种团队技能；这对你的同龄人有帮助，如果他们实践了，对你也有帮助。**简单地说，写好代码是礼貌的事情。**

它唯一能直接帮助你的时候，是当你碰巧回到你很久很久以前写的一段代码的时候！

## **3。好代码是一个以用例为中心的术语。**

根据守则的目的，我们衡量其好坏的尺度将会改变。虽然我将触及一些不同的用例，但作为这篇文章的一部分，我将主要探索它们，为我今天想要关注的主要用例添加一些上下文和一些对比。

> 一个庞大且足够复杂的代码库，这意味着由许多作者跨多年路线图逐步开发，其生产环境托管在弹性 web 服务中并依赖于弹性 web 服务，其最终客户是人。

随着我们进一步探索，我们为什么选择将自己限制在这些参数之内将变得不言而喻。但是现在，让我们介绍一个简单而著名的思想，我们将在此基础上完成这篇文章。

> “代码被阅读的次数远远多于它被编写的次数”

这是一个非常简单并且在某种程度上非常明显的观察结果，但却蕴含着深刻的见解。— **为人工阅读操作优化代码。**

当我们第一次学习编码时，我们编写 Hello World 程序，然后慢慢学习简单的数据结构和算法。然后我们被介绍给 Big-O(s ),并学习从时间和空间复杂性的角度来思考。在我们的整个学术生涯中，我们都带着这种如何处理代码的心智模型，然后尝试在我们的工作空间中使用它来开发软件产品。

如果我们的目标是编写编译器/解释器能够理解的代码，这是一种很好的方法。因为，在这种方法中，我们对全局状态的概念、到处使用 setters 以及编写任何晦涩复杂的逻辑(从人类的角度来看)变得很舒服，只要它生成解释器可以更快处理的字节代码。

现在，我们不应该忽视这种方法带来的好处。我们的程序工作起来，占用尽可能少的空间，运行尽可能快。并且，**如果代码一旦被编写，就意味着被固定在石头上**，这种方法将会是解决我们所有问题的灵丹妙药，我们将从此过上幸福的生活。但是真实世界的用例，我们正试图为其编写好的代码，要流畅得多，也要混乱得多。

在墨菲定律占主导地位的混乱的现实世界中，这种方法带来了明显的权衡。

## 没有人愿意接触的错误代码库。

我们都知道那些代码库，我们曾经在某个时间点工作过，并且会找一百个借口来避免再次工作。造成这种情况的原因有很多，但其中一些最常见的，也是让我不时产生夜惊的原因是。

## 一切都是相连的。

代码是有效的(好吧，7/10 次是有效的)，但是如果你在一个内部模块中改变一个私有方法来做一件事情，它会破坏一个完全不同的模块中的一些现有特性，做一些完全不同的事情。

## 每个人都有副业。

在整个代码库中，方法改变它们的输入参数，并且比蛇油有更多的副作用。这使得如果不阅读整个流程，甚至是最底层的细节，就不可能理解正在发生的事情。看着你，`System.out.println()`【1】【2】。

## 请把调试器递给我，好吗？

最近我在解决一个竞争性的编码问题。我最终得到了两个解决方案，一个(在某种程度上)优化了可读性，一个优化了编译器。

**以下是一般性问题陈述。**

通用问题陈述解决方案

**现在让我们实现一个编译器优化的。**

编译器优化解决方案

代码很小，并且非常高效。太好了。但是它是如何工作的呢？没那么简单，对吧？在您开始理解这段代码是如何工作的之前，您必须进行一次演练或启动调试器。

现在想象一下。

> 此代码为您客户的物流系统提供动力，但存在一个缺陷。你不修好它的每一分钟，成千上万的顾客都不知道他们是否还有足够的汽油来完成旅程。 ***在这样的代码中，你愿意成为负责尽快修复 bug 的人吗？***

现在再想象一下。

> 编写本代码时，天然气的价格很便宜。所以我们的顾客不在乎价格，只要他们能完成他们的旅程。最近，运营国与其石油和天然气贸易伙伴之间爆发了一场贸易战。突然之间，价格成了一个重要的变量。 ***这个逻辑应该放在哪里？***

现在你可能会说，*“哎，让当初写这个的人，照顾一下这个要求吧”*。那个人可能已经换了团队，换了公司，或者成为了一名口袋妖怪训练师。谁知道呢。

***代码库是整个团队/社区的共享继承。*** ***这个法典库应该是远古时期的。开发者应该是可替换的。如果我的缺席意味着我开发的特性成为孤儿，那么我的代码就是这种继承的负担。***

因此，虽然这段代码对于当前用例来说是一项资产*(小、轻、快)*，但是最轻微的震动都会将它变成负债*(难以理解、修复和扩展)*。

在我们混乱的现实世界中，记住墨菲定律，

*“任何可能出错的事情，都会出错”*【3】

**现在让我们转向更人性化的可读性优化解决方案。**

人类可读性优化的解决方案

好，让我们看看这里会发生什么。

*   对于每个站，从第一个开始，评估我们是否能从那里完成路线，过滤掉所有我们不能的站。
*   在过滤的电台中，找到具有最小索引的电台。
*   如果没有车站符合标准，我们会通知该路线无法完成。

我们甚至不需要知道**circularoutedetails 做什么或者**我们如何评估路线是否可以完成，就可以在高层次上理解我们正在做什么。****

现在，如果我作为一个读者想知道一些低层次的细节是如何工作的，我可以深入研究这些方法并弄清楚它。因此，尽管代码库更大，但作为读者，我可以简单地挑选我想知道的内容。第一步，我会在一本十页的字典中摸索，字典中的单词是随机排列的；第二步，我会按照严格的字母顺序，有条不紊地阅读第一千页。

做事情的能力是一种非常强大的能力，但遗憾的是，这种能力没有得到充分的重视。

在这个解决方案中，**概念和职责被分离到代码**的封装部分中。此外，**方法、类和字段的命名经过精心选择，以帮助轻松识别所述职责**。*(上面的代码可以进一步改进，我同意，但是你要明白)*。所以现在当一个 bug 爬进来时，我不需要摸索整个代码库，我可以找到最有可能产生问题的部分并修复它。

如果你想检查整个代码库，请看这里

[](https://github.com/pratickRoy/Competitive) [## 实践/竞争

### 一个解决竞争性编程问题的 Repo，既干净又优化。GitHub 是超过 50 个…

github.com](https://github.com/pratickRoy/Competitive) 

但是等等，我听到你问，

> “嗯，我明白你的意思了。但是第二种解决方案速度较慢，因此在日常工作中，您将向客户交付较慢的结果。还有，会产生更多的硬件成本。”

所有有效的点，我很高兴你问他们！
为了回答这个问题，我会将您重定向到我们的用例定义。所以让我重申一下。

> 一个庞大且足够复杂的代码库，这意味着由许多作者跨多年路线图逐步开发，其生产环境托管在弹性 web 服务中并依赖于弹性 web 服务，其最终客户是人。

所以现在以这个用例为背景，让我们来详细回答这个问题。

## 1.速度

> “但第二种解决方案速度较慢，因此，每天向客户交付结果的速度都较慢”

为了可测量的效率差异，让我们假设**第一个解取 O(n)** 而**第二个解取 O(n )** 。**加油站数量为 1000 个**，每一步的**操作需要 1 s** 。因此**第一个解决方案将花费 1 毫秒**，而**第二个将花费 1 秒**。毫无疑问，从电子学的角度来看，这是一个巨大的差异，但从人类感知的角度来看，这几乎是不可察觉的。一个人很难判断一个页面是在 1 毫秒还是 1 秒内加载的。我们用例的核心需求是什么？— **“并且其最终客户是人类。”**

但这种解释有点不真诚。这是因为我选择的价值观。如果有 10⁶加油站会怎么样？那么**第一个解决方案将占用 1s** 而**第二个将占用 10⁶s** 。10⁶s 肯定会引起用户的注意。在这里，第一个解决方案显然是更好的。*或者是？*

当设计一个真实世界的应用程序时，如果希望一次性处理 10⁶实体，您首先不会希望将它作为一个同步操作。10⁶实体，每个都可能有自己的数据库查找和服务间调用，是 10⁶潜在的故障点。我们需要确保节流&重试机制、状态管理和幂等保护措施到位。如果你的代码应该在一个单线程同步调用中处理一百万个条目，也许可以再试试这个设计。

我在这里想说的是，可伸缩性在很大程度上是一个高层次的架构问题。它可以通过多种方式解决，其中许多方式与您编写的代码无关。如果您不得不担心在代码方法级别满足您的规模需求，并且为此您不得不牺牲可读性，那么首先我们应该考虑重新检查架构一次。

然而，假设你正在建立一个高频交易平台，每一纳秒都很重要。在这里，选择第一种解决方案是有意义的。但如果最终客户是人，这里或那里的几秒钟对他们来说通常不是问题。然而，如果通过牺牲可读性**，你的团队花了几个月的时间来交付一个不破坏你的代码库**中所有其他东西的新特性，或者**花了几个小时来识别和修补一个严重的错误，这阻止了你的客户使用你的应用**，这**实际上影响了你的客户。**所以钥匙拿走了。

> 始终根据您的客户进行编码。

## 2.硬件成本

> 此外，这将导致更多的硬件成本。

没错。但是今天硬件很便宜。[4]

现在我不是提倡浪费。**就算便宜，还是要花钱的，还是要付出环境的代价。**

但是如果你牺牲可读性来节省硬件成本，你最终会让你的团队付出更多。**因为可读性低，需要花费更多的工时在 bug 和每个新功能上。从经济和环境角度来看，熟练工人的工时要昂贵得多。**(我在这里不对这种说法进行限定，因为我认为简单的谷歌搜索就足够了，但如果你不同意，请给我留言，我们可以进一步讨论)

所以关键外卖。

> 只要不影响理解，代码应该尽可能优化。

## 测量可读性？

嗯，好吧，我听到你问了，

> “有道理，但是可读性是一个主观的实体。我们如何衡量它？为了能够在实践中加强这一点，我需要一些客观的方法来衡量它，对吗？否则就没什么用了”

嗯，正如你提到的，这是一个主观的质量，所以虽然我们不能得到一个精确的测量，我们可以按照著名的 **WTFs 每分钟规则** [5]得到一个相对的测量，如果你想一想，这就是我们所需要的。

所以一个简单的方法是，

让你的同事阅读你的代码。**他们在阅读你的代码时吃惊的次数越少，可读性就越好。**

同样值得注意的是。我们提到的用例的参数是足够模糊的，如果你仔细想想，我们在日常生活中构建和使用的许多产品都属于这个描述，包括 Medium。
——我不会进一步解释，但先详细说明一下。这是值得的。:)

唷！那是一篇很长的文章。然而，我忽略了许多细微差别和问题。因此，如果你不同意我说的任何话，或者想进一步讨论以上任何问题，或者进一步讨论我在这里可能没有提到的任何细微差别，请留言。我非常乐意参与。辩论和讨论代码是生活中为数不多的可以而且应该过度享受的乐趣之一。

## 来源、脚注和进一步阅读链接

*   一个很好的关于副作用的介绍 wiki:
    【1】[副作用(计算机科学)](https://en.wikipedia.org/wiki/Side_effect_(computer_science))，Wikipedia
*   一个很有见地的问题，强调了代码中副作用的经常是无意的后果:
    【2】[system . out . println()在 Java 中有副作用吗？](https://stackoverflow.com/questions/34552710/does-system-out-println-have-a-side-effect-in-java) (2016)，堆栈溢出
*   很酷的一页，整理了大量的墨菲定律。看一看。这些定律有趣、令人沮丧、鼓舞人心、稀奇古怪，同时又有关联:
    【3】[墨菲定律|非常廉价的想法](https://www.angelo.edu/faculty/kboudrea/cheap/cheap3_murphy.htm)
*   一篇很好的介绍文章，介绍了问题的硬件和软件解决方案。有点过时，但让你思考下一个该问的问题:
    【4】j .阿特伍德，[硬件便宜，程序员贵](https://blog.codinghorror.com/hardware-is-cheap-programmers-are-expensive/) (2008)，编码恐怖
*   一篇详细介绍每分钟 WTF 规则的博客:
    [5] A. Eaton，[每分钟 WTF——代码质量的实际测量](http://reviewthecode.blogspot.com/2016/01/wtf-per-minute-actual-measurement-for.html#:~:text=WTF%20Per%20Minute%20-%20An%20Actual%20Measurement%20for%20Code%20Quality,-Cars%20have%20MPH&text=Developers%20have%20WTFPM%20(WTF%20per,more%20WTFPM%20they%20can%20attain.) (2016)，Blogspot
*   我对什么是好的编码的看法深受 Robert C. Martin 先生作品的影响。
    【5】[亚马逊链接为他的书清理代码。](https://www.amazon.in/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)

## **最后一次外卖**

在你走之前，这是最后一份外卖。如果你经常检查代码库是否满足上述用例，并且不想，也不得不向作者详细解释你期望在他们的代码中看到什么。简单地说，给他们发一张弗兰克·安德伍德这段有力而简洁(并被大量转述)的引文的截图。

![](img/f32561b9183ca68fc1cbdcd4a2690688.png)

最后一次外卖(图片由作者提供)

 [## 点击此处订阅:)

### 想在我写新东西时得到通知吗？每当我发布时收到电子邮件！

有两种作家，写得多的和写得少的。我是后者。我痴迷于创造价值，回避噪音。如果想看这样的内容，可以考虑订阅。](https://pratickroy.medium.com/subscribe)