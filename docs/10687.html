<html>
<head>
<title>Recursive Functions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的递归函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/recursive-function-in-python-36f8b833c847?source=collection_archive---------22-----------------------#2020-07-26">https://towardsdatascience.com/recursive-function-in-python-36f8b833c847?source=collection_archive---------22-----------------------#2020-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="04e8" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据科学</h2><div class=""/><div class=""><h2 id="1232" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">数据科学领域的例子</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/a60721dda152143e42c88c9a0c093b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uJOJz1qoOx7drig4"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine ivani</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="07b5" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">目录</h1><ul class=""><li id="ec53" class="ma mb it mc b md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">什么是递归？</li><li id="7ea3" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated">程序设计中的递归</li><li id="c8db" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated">来自数据科学世界的例子</li><li id="b613" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated">结论</li></ul><h1 id="1f2c" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">什么是递归？</h1><p id="26e1" class="pw-post-body-paragraph mx my it mc b md me kd mz mf mg kg na mh nb nc nd mj ne nf ng ml nh ni nj mn im bi translated">递归是一个在操作中引用自身的概念。这在所有艺术领域都可以找到:文学(mise en abyme)、绘画、摄影……<br/>一个物理世界的例子是将两个平行的镜子面对面放置。它们之间的任何对象都将被递归反射。<br/>我们每天在定义词的时候都会用到递归！事实上，我们用词来定义他人，而他人也被其他词所定义！</p><h1 id="af8d" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">程序设计中的递归</h1><p id="1a82" class="pw-post-body-paragraph mx my it mc b md me kd mz mf mg kg na mh nb nc nd mj ne nf ng ml nh ni nj mn im bi translated">在编程中，它是一个引用自身的函数。两个函数可以互相调用，这叫相互递归。让我们用一个数学界的例子:阶乘。自然数<code class="fe nk nl nm nn b">n</code>的阶乘是小于等于<code class="fe nk nl nm nn b">n</code>的严格正整数的乘积。记为<code class="fe nk nl nm nn b">n!</code>，计算如下:<code class="fe nk nl nm nn b">n! = (n-1)!*n</code>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="81f9" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated">在你的头脑中运行这个算法，你会发现它永远不会停止，它会无休止地运行。的确，如果我们用<code class="fe nk nl nm nn b">n = 3</code>执行函数，T5 会被<code class="fe nk nl nm nn b">n = 3</code>调用，然后<code class="fe nk nl nm nn b">n = 2</code>，然后<code class="fe nk nl nm nn b">n = 1</code>，然后<code class="fe nk nl nm nn b">n = 0</code>，然后<code class="fe nk nl nm nn b">n = -1</code>，等等。</p><blockquote class="nv"><p id="5ed6" class="nw nx it bd ny nz oa ob oc od oe mn dk translated">一个永不停歇的算法是个问题，可想而知！</p></blockquote><p id="a34f" class="pw-post-body-paragraph mx my it mc b md of kd mz mf og kg na mh oh nc nd mj oi nf ng ml oj ni nj mn im bi translated">因此，解决方案是指定<strong class="mc jd">一个停止条件</strong>，这将始终取决于我们的问题。在我们的例子中<code class="fe nk nl nm nn b">3! = 3*2*1</code>。您会注意到不同的因子(3、2 和 1)从不为负，甚至不等于 0。正是这个条件为我们提供了一个停止条件:“因子决不能小于或等于 0”。所以，我们添加一个条件语句:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="no np l"/></div></figure><blockquote class="nv"><p id="fa91" class="nw nx it bd ny nz ok ol om on oo mn dk translated">在函数内部调用函数被称为递归调用。</p><p id="0ff9" class="nw nx it bd ny nz oa ob oc od oe mn dk translated">递归调用必须在条件语句中。</p></blockquote><p id="5820" class="pw-post-body-paragraph mx my it mc b md of kd mz mf og kg na mh oh nc nd mj oi nf ng ml oj ni nj mn im bi translated"><strong class="mc jd">注:</strong>每一次递归都可以转化为迭代。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="c256" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">来自数据科学世界的例子</h1><h2 id="a6f6" class="op lj it bd lk oq or dn lo os ot dp ls mh ou ov lu mj ow ox lw ml oy oz ly iz bi translated">1.二叉树结构的表示:</h2><p id="7e8c" class="pw-post-body-paragraph mx my it mc b md me kd mz mf mg kg na mh nb nc nd mj ne nf ng ml nh ni nj mn im bi translated">二叉树是由称为节点的元素层次结构形成的数据结构。节点由两类信息表征:</p><ul class=""><li id="f8d5" class="ma mb it mc b md nq mf nr mh pa mj pb ml pc mn mo mp mq mr bi translated">节点特定信息</li><li id="bafd" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated">描述与其后代节点的链接的信息</li></ul><p id="f05b" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated">二叉树总是由一个节点指定:它的初始节点叫做根节点。<br/>每个节点最多有两个子节点:</p><ul class=""><li id="17f5" class="ma mb it mc b md nq mf nr mh pa mj pb ml pc mn mo mp mq mr bi translated">如果该节点正好有两个子节点，它们被称为 t <em class="pd">左子节点</em>和<em class="pd">右子节点</em>。</li><li id="ce72" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated">如果该节点只有一个子节点，这是左子节点<em class="pd">或右子节点<em class="pd">。</em></em></li><li id="3877" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated">如果节点没有子节点，它被称为<em class="pd">叶节点</em>。</li></ul><p id="63b0" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated">树枝是从树根到树叶的路径。</p><p id="74ee" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated">因此，二叉树是一个<strong class="mc jd">递归结构</strong>，因为左子树和右子树本身就是节点(依次代表树)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/11df6de79995d615bd24265d284c243e.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*Png1ee5UsFDlaRUhViUn4g.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">二叉树图。源作者</p></figure><p id="35c2" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated">这个图表示一个二叉树，它的节点 A 是根，B 是它的左孩子，C 是它的右孩子。节点 C 只有一个子节点 F(右子节点)。d、E 和 F 是叶节点。<br/>【A，B，D】，【A，B，E】，【A，C，F】是树的分支。</p></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><p id="7474" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated">让我们创建类节点:</p><p id="dee6" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated"><strong class="mc jd">属性:</strong></p><ul class=""><li id="904f" class="ma mb it mc b md nq mf nr mh pa mj pb ml pc mn mo mp mq mr bi translated"><strong class="mc jd"> <em class="pd">标签</em> </strong>:表示观察的字符串。</li><li id="35d3" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated"><strong class="mc jd"> <em class="pd">左</em> </strong>:表示左子的类的实例。</li><li id="2ecc" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated"><strong class="mc jd"> <em class="pd"> right </em> </strong>:代表右孩子的类的实例。</li></ul><p id="efe7" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated"><strong class="mc jd">方法:</strong></p><ul class=""><li id="e927" class="ma mb it mc b md nq mf nr mh pa mj pb ml pc mn mo mp mq mr bi translated"><strong class="mc jd"> <em class="pd"> __init__: </em> </strong>构造函数。</li><li id="a094" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated"><strong class="mc jd"> <em class="pd"> __str__: </em> </strong>根据以下示例返回表示树的字符串</li><li id="c8b7" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated"><strong class="mc jd"> <em class="pd">线性化:</em> </strong>递归方法返回一个树形分支列表。</li></ul><pre class="ks kt ku kv gt pm nn pn po aw pp bi"><span id="dafc" class="op lj it nn b gy pq pr l ps pt">NodeFigure = Nd = Node('A',Node('B', Node('D'), Node('E')), Node('C',None,Node('F')))</span><span id="93a6" class="op lj it nn b gy pu pr l ps pt"><strong class="nn jd">&gt;&gt;&gt; print(NodeFigure)</strong><br/>Node(A,Node(B,Node(D),Node(E)),Node(C,None,Node(F)))</span></pre><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="0699" class="op lj it bd lk oq or dn lo os ot dp ls mh ou ov lu mj ow ox lw ml oy oz ly iz bi translated">2.决策模型的表示</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="no np l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数据集表的切片</p></figure><p id="df93" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated">决策规则可以用二叉树来表示，称为<strong class="mc jd">二叉决策树</strong>。例如，对于下表中的数据集，可以构建下图所示的二元决策树。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/19b9875ef979592f2c50cf8c28c77707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o5NesubIf5DT5wi7jqd2UQ.png"/></div></div></figure><p id="97e0" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated">在这一部分中，我们将创建 DecisionNode 类，它从 Node 类继承并表示一个二叉决策树。</p><p id="baed" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated"><strong class="mc jd">属性:</strong></p><ul class=""><li id="e79a" class="ma mb it mc b md nq mf nr mh pa mj pb ml pc mn mo mp mq mr bi translated"><strong class="mc jd"> <em class="pd">标签</em> </strong>:表示观察的字符串，继承自 Node 类。</li><li id="ac43" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated"><strong class="mc jd"> <em class="pd"> distr </em> </strong>:代表每个决策概率的字典:<br/>——每个<strong class="mc jd">键</strong>代表一个可能的决策 0 或 1。<br/> -每个<strong class="mc jd">值</strong>都是一个代表决策概率的实数。</li><li id="eafc" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated"><strong class="mc jd"> <em class="pd"> threshold: </em> </strong>一个实数代表测试阈值，用来推导要跟随的分支。</li><li id="d1c8" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated"><strong class="mc jd"> <em class="pd"> left </em> </strong>:表示左侧子节点的类的实例，继承自 Node 类。</li><li id="e399" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated"><strong class="mc jd"> <em class="pd"> right </em> </strong>:代表右子的类的实例，继承自 Node 类。</li></ul><p id="3dfc" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated"><strong class="mc jd">方法:</strong></p><ul class=""><li id="6b28" class="ma mb it mc b md nq mf nr mh pa mj pb ml pc mn mo mp mq mr bi translated"><strong class="mc jd"> <em class="pd"> __init__: </em> </strong>构造函数(从节点继承)</li><li id="8311" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated"><strong class="mc jd"> <em class="pd"> __str__: </em> </strong>根据以下示例返回表示树的字符串</li></ul><pre class="ks kt ku kv gt pm nn pn po aw pp bi"><span id="0bbd" class="op lj it nn b gy pq pr l ps pt">#Create the instance<br/>left = DecisionNode('Decision', {0:0,1:1}, 0.5)<br/>right = DecisionNode('Age',{0:0.5, 1:0.5},62,<br/>                     DecisionNode('Decision', {0:0.2, 1:0.8},0.5),<br/>                     DecisionNode('Tachycardia',{0:0.4,1:0.6},0.5,<br/>                         DecisionNode('Decision',{0:0.1, 1:0.9},0.5),<br/>                         DecisionNode('Decision',{0:0.9, 1:0.1},0.5)) )<br/>DecisionNd = DecisionNode('Blood Pressure', {0:0.3,1:0.7},91, left, right)</span><span id="ccd9" class="op lj it nn b gy pu pr l ps pt"><strong class="nn jd">&gt;&gt;&gt; print(DecisionNd)</strong></span><span id="5ce7" class="op lj it nn b gy pu pr l ps pt">IF Blood Pressure &gt;= 91  THEN Decision = {0: 0, 1: 1}<br/>IF Blood Pressure &lt; 91 AND Age &gt;= 62  THEN Decision = {0: 0.2, 1: 0.8}<br/>IF Blood Pressure &lt; 91 AND Age &lt; 62 AND Tachycardia &gt;= 0.5  THEN Decision = {0: 0.1, 1: 0.9}<br/>IF Blood Pressure &lt; 91 AND Age &lt; 62 AND Tachycardia &lt; 0.5  THEN Decision = {0: 0.9, 1: 0.1}</span></pre><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><h1 id="b4bd" class="li lj it bd lk ll pw ln lo lp px lr ls ki py kj lu kl pz km lw ko qa kp ly lz bi translated">简而言之:如何编程一个递归函数？</h1><ol class=""><li id="f3f3" class="ma mb it mc b md me mf mg mh mi mj mk ml mm mn qb mp mq mr bi translated">将问题分解成一个或多个同类型的子问题。子问题通过递归调用解决。</li><li id="de37" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn qb mp mq mr bi translated">子问题应该比原问题小。</li><li id="e372" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn qb mp mq mr bi translated">最后，分解必须产生一个不分解成子问题的基本问题(<strong class="mc jd">这是停止条件</strong>)。</li></ol></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><h2 id="4a95" class="op lj it bd lk oq or dn lo os ot dp ls mh ou ov lu mj ow ox lw ml oy oz ly iz bi translated">资源:</h2><ul class=""><li id="9e27" class="ma mb it mc b md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><a class="ae lh" href="http://www.ipeis.rnu.tn/concours_nationaux/concours.htm" rel="noopener ugc nofollow" target="_blank">http://www.ipeis.rnu.tn/concours_nationaux/concours.htm</a></li><li id="fed8" class="ma mb it mc b md ms mf mt mh mu mj mv ml mw mn mo mp mq mr bi translated"><a class="ae lh" href="https://www.geeksforgeeks.org/recursive-functions/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/recursive-functions/</a></li></ul></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><p id="4899" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated"><strong class="mc jd">感谢阅读！😄</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/73fcb42edeb341185b03869b3b377154.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*YKbbxLAqcap2T27r"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">查看我的其他文章，并在<a class="ae lh" href="https://medium.com/@ahmedazizkhelifi" rel="noopener">媒体</a>上关注我</p></figure><p id="a9a5" class="pw-post-body-paragraph mx my it mc b md nq kd mz mf nr kg na mh ns nc nd mj nt nf ng ml nu ni nj mn im bi translated">哈利菲·艾哈迈德·阿齐兹</p></div></div>    
</body>
</html>