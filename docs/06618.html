<html>
<head>
<title>Is NumPy Faster Than Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NumPy比Python快吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/is-numpy-faster-than-python-e8a7363d8276?source=collection_archive---------17-----------------------#2020-05-25">https://towardsdatascience.com/is-numpy-faster-than-python-e8a7363d8276?source=collection_archive---------17-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="795a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Numpy的线性代数比常规Python快多少？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bd0ac34d2406abd10a992b8593b10c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UiC11__5EaepJPB0UWdxBg.png"/></div></div></figure><p id="9620" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated"><span class="l lr ls lt bm lu lv lw lx ly di"> A </span>前几天，我写了一篇文章，客观地比较了Julia和Python的现状，甚至测试了两种语言之间的一些基本迭代性能。虽然Python肯定落后于Julia，但令人印象深刻的是Python在Julia面前表现得如此之好，当处理较小的数据集时，Python通常仅落后于Julia。然而，当观察次数增加时，Python的速度缺点似乎成指数增长。您可以在此处找到该文章的链接:</p><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/should-you-jump-pythons-ship-and-move-to-julia-ccd32e7d25d9"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">该不该跳Python的船，搬去茱莉亚？</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">是应该为了朱丽亚的表现而抛弃Python，还是朱丽亚的速度只是精心炒作？</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq ks mc"/></div></div></a></div><p id="0bd9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">公开发表你的作品的一个好处是，它基本上可以被整个互联网的同行评议。虽然这可能会为一些相当粗鲁的人找你麻烦打开大门，但它也允许志同道合的科学家交流思想。这个故事留下了很大的反响，对我的测试进行了建设性的批评，因为我为元素级乘法和元素级指数编写了自己的函数。需要说明的是，我的目标是比较这两种语言的原始能力，并不是说用一种或另一种语言可以更快地编写这个算法，而是说明用Julia编写后端代码要容易得多，这与因为Python的缺点而改用C语言相反。</p><p id="6db3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，比起使用我自己的函数，大多数Python程序员更希望我不要重新发明轮子，而是把它做成方形，并且更希望我只使用NumPy。然而，为了准确测试Pythonic的性能，并与不使用C的Julian性能进行比较，我避免使用C。</p><p id="1de9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这个想法让我很好奇。在Github上看，NumPy大约有51%是c语言，所以很明显，在很多情况下，NumPy会击败我们在Python中可以进行的任何操作。目前悬而未决的是，我们可以从这样的事情中获得多大的性能提升。此外，NumPy中相对基本的线性代数函数，如numpy.multiply()，有可能是用Python编写的，甚至没有利用c。</p><h1 id="d34d" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">%timeit测试</h1><blockquote class="nj"><p id="aa15" class="nk nl it bd nm nn no np nq nr ns lp dk translated"><a class="ae nt" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/numpyvspythonspeedtest.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><p id="47d9" class="pw-post-body-paragraph ku kv it kw b kx nu ju kz la nv jx lc ld nw lf lg lh nx lj lk ll ny ln lo lp im bi translated">我想测试这一点的第一种方法是使用我在之前的另一篇文章中使用的相同方法。我将使用一个10，000，000的dim数据集，并尝试使用一个简单的线性回归模型进行预测，该模型使用了C中可能使用的NumPy函数和我自己的Pythonic函数。下面是使用我自己的函数编写的类:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="eaa8" class="oe ms it oa b gy of og l oh oi">def dot(x,y):<br/>    lst = []<br/>    for i,w in zip(x,y):<br/>        lst.append(i * w)<br/>    return(lst)<br/>def sq(x):<br/>    x = [c ** 2 for c in x]<br/>    return(x)<br/>class LinearRegression:<br/>    def __init__(self,x,y):<br/>        # a = ((∑y)(∑x^2)-(∑x)(∑xy)) / (n(∑x^2) - (∑x)^2)<br/>        # b = (x(∑xy) - (∑x)(∑y)) / n(∑x^2) - (∑x)^2<br/>        if len(x) != len(y):<br/>            pass<br/>        # Get our Summations:<br/>        Σx = sum(x)<br/>        Σy = sum(y)<br/>        # dot x and y<br/>        xy = dot(x,y)<br/>        # ∑dot x and y<br/>        Σxy = sum(xy)<br/>        # dotsquare x<br/>        x2 = sq(x)<br/>        # ∑ dotsquare x<br/>        Σx2 = sum(x2)<br/>        # n = sample size<br/>        n = len(x)<br/>        # Calculate a<br/>        self.a = (((Σy) * (Σx2)) - ((Σx * (Σxy)))) / ((n * (Σx2))-(Σx**2))<br/>        # Calculate b<br/>        self.b = ((n*(Σxy)) - (Σx * Σy)) / ((n * (Σx2)) - (Σx ** 2))<br/>        # The part that is super struct:<br/>    def predict(self,xt):<br/>        xt = [self.a + (self.b * i) for i in xt]<br/>        return(xt)</span></pre><p id="33ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是使用NumPy函数编写的同一个类:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="5477" class="oe ms it oa b gy of og l oh oi">import numpy as np<br/>class npLinearRegression:<br/>    def __init__(self,x,y):<br/>        # a = ((∑y)(∑x^2)-(∑x)(∑xy)) / (n(∑x^2) - (∑x)^2)<br/>        # b = (x(∑xy) - (∑x)(∑y)) / n(∑x^2) - (∑x)^2<br/>        if len(x) != len(y):<br/>            pass<br/>        # Get our Summations:<br/>        Σx = sum(x)<br/>        Σy = sum(y)<br/>        # dot x and y<br/>        xy = np.multiply(x,y)<br/>        # ∑dot x and y<br/>        Σxy = sum(xy)<br/>        # dotsquare x<br/>        x2 = np.square(x)<br/>        # ∑ dotsquare x<br/>        Σx2 = sum(x2)<br/>        # n = sample size<br/>        n = len(x)<br/>        # Calculate a<br/>        self.a = (((Σy) * (Σx2)) - ((Σx * (Σxy)))) / ((n * (Σx2))-(Σx**2))<br/>        # Calculate b<br/>        self.b = ((n*(Σxy)) - (Σx * Σy)) / ((n * (Σx2)) - (Σx ** 2))<br/>        # The part that is super struct:<br/>    def predict(self,xt):<br/>        xt = [self.a + (self.b * i) for i in xt]<br/>        return(xt)</span></pre><p id="f229" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用的两个Numpy函数是square()和multiply()。这些函数相对简单，正如我在函数示例中展示的那样，所以我真的很好奇是否有C语言可以加速它们。在我们开始速度测试之前，我们需要读入一些数据:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="094a" class="oe ms it oa b gy of og l oh oi">import pandas as pd<br/>df = pd.read_csv("speedtrain.csv")<br/>testdf = pd.read_csv("speedtest.csv")</span></pre><p id="aa42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们将以我们自制的函数为基线来计时:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/d81c0f3a64c00c8606bb81a25cd3eeb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*HxgX1MarldBEzagMfHH8rg.png"/></div></figure><p id="2e73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然8.22当然不坏，但它还可以更好。Julia在不到一秒钟的时间内完成了这个计算，所以看看C和Python的组合如何与Julia相抗衡将会非常有趣:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/687959e4a7be19200a936e679b403861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*Zav4QRstTlfqzHS1nJgmkg.png"/></div></figure><blockquote class="nj"><p id="de7d" class="nk nl it bd nm nn ol om on oo op lp dk translated">哇！</p></blockquote><p id="13bb" class="pw-post-body-paragraph ku kv it kw b kx nu ju kz la nv jx lc ld nw lf lg lh nx lj lk ll ny ln lo lp im bi translated">看起来我文章的评论有一点是对的；NumPy和C对于线性代数来说要快得多。我曾怀疑NumPy可能会为这个操作保留纯Python代码，但是很明显我错了。我认为提醒我们自己NumPy可能也有自己的类型和用C编写的迭代器也很重要。这当然非常酷，因为这意味着NumPy相对来说非常快。</p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><h1 id="d0fc" class="mr ms it bd mt mu ox mw mx my oy na nb jz oz ka nd kc pa kd nf kf pb kg nh ni bi translated">结论</h1><p id="5956" class="pw-post-body-paragraph ku kv it kw b kx pc ju kz la pd jx lc ld pe lf lg lh pf lj lk ll pg ln lo lp im bi translated">所以简短的回答是</p><blockquote class="nj"><p id="cab5" class="nk nl it bd nm nn no np nq nr ns lp dk translated">是的，</p></blockquote><p id="f79e" class="pw-post-body-paragraph ku kv it kw b kx nu ju kz la nv jx lc ld nw lf lg lh nx lj lk ll ny ln lo lp im bi translated">NumPy比Python快很多。虽然这是意料之中的，但是如果我说我期望通过使用NumPy而不是Pythonic函数来实现我的目标，那么我是在撒谎。我认为这也是对为了Python中的科学和数学而对NumPy包所做的惊人工作的一种敬意。目前，NumPy在Github上有超过23，000个提交，这是为社区做的大量免费、开源、无私的工作！</p><p id="99e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总的来说，我认为Python可以通过使用一个大的C库来加速是非常酷的。毕竟，Python主要是为最终用户与低层应用程序进行交互而创建的，就像他们在ABC中那样。我很高兴收到这个回复，并且能够进一步研究这个问题，了解更多关于使用NumPy带来的性能好处。非常感谢你们所有人的阅读，也感谢你们提供建设性的反馈，比如催生了这篇文章的回复。</p></div></div>    
</body>
</html>