<html>
<head>
<title>A Gentle Introduction to Regular Expressions with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 正则表达式的简明介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-python-4f3fce46dcb4?source=collection_archive---------40-----------------------#2020-09-01">https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-python-4f3fce46dcb4?source=collection_archive---------40-----------------------#2020-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c8bc" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">教程| Python</h2><div class=""/><div class=""><h2 id="66a1" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">正则表达式是数据科学家对付非结构化文本最强大的武器</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/5ec03bec24492d1ad7b1f82bd9fdc168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dk7Gkk2aKOi32zdD"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@marius?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marius Masalar </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3456" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们生活在一个以数据为中心的时代。数据已被描述为<a class="ae lh" href="https://www.wired.com/insights/2014/07/data-new-oil-digital-economy/" rel="noopener ugc nofollow" target="_blank">新油</a>。但是就像石油一样，原始数据并不总是有用的。一种在其原始形式下特别难以使用的数据形式是<a class="ae lh" href="https://www.datamation.com/big-data/structured-vs-unstructured-data.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">非结构化数据</strong> </a>。</p><p id="d943" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很多数据是非结构化数据。非结构化数据不太适合用于分析的格式，比如 Excel 电子表格或<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html#dataframe" rel="noopener ugc nofollow" target="_blank"> pandas DataFrame </a>。文本数据是一种常见的非结构化数据，这使得它很难处理。输入<a class="ae lh" href="https://www.w3schools.com/python/python_regex.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">正则表达式</strong> </a>，简称<strong class="lk jd"> regex </strong>。一开始它们可能看起来有点吓人，但是一旦你开始使用它们，你很快就会像这条蛇一样舒服了🐍！</p><blockquote class="me mf mg"><p id="3f6d" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">更适应 python？试试我的教程，用 R 代替 regex:</p></blockquote><div class="ml mm gp gr mn mo"><a href="https://medium.com/@atseewal/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd jd gy z fp mt fr fs mu fu fw jc bi translated">R 正则表达式的简明介绍</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">正则表达式是数据科学家对付非结构化文本最强大的武器。他们曾经是野餐…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">medium.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc lb mo"/></div></div></a></div><h1 id="b46f" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">正则表达式模块(re)</h1><p id="18fe" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">我们将使用正则表达式模块。要将其导入 python 项目，请使用以下命令:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="6027" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看到多简单了吗？<code class="fe oc od oe of b">re</code>模块内置在 python 中，不需要安装。让我们来看看本模块中提供的几个功能:</p><ol class=""><li id="b09c" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md ol om on oo bi translated"><code class="fe oc od oe of b">re.findall(pattern, string)</code>:该函数返回一个包含<code class="fe oc od oe of b">string</code>中<code class="fe oc od oe of b">pattern</code>所有实例的列表</li><li id="0184" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated"><code class="fe oc od oe of b">re.sub(pattern, repl, string)</code>:该函数返回<code class="fe oc od oe of b">string</code>，将<code class="fe oc od oe of b">string</code>中的<code class="fe oc od oe of b">pattern</code>实例替换为<code class="fe oc od oe of b">repl</code></li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/2dc986c02e1c57d729ac2f488c3a46df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lc8AzbhnNM2NTeC-"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">蒂姆·柯林斯在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d045" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可能已经使用过这些功能。他们有非常简单的应用程序，不需要添加正则表达式。回想一下社交距离之前的时代，想象一下在公园里的一次美好野餐。这里有一个例子，是每个人带去野餐的东西。我们可以用它来演示 regex 函数的基本用法:</p><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="a7a1" class="oz ne it of b gy pa pb l pc pd">basic_string = 'Drew has 3 watermelons, Alex has 4 hamburgers, Karina has 12 tamales, and Anna has 6 soft pretzels'</span></pre><p id="5c96" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我想从这个字符串中提取一个人名字的每个实例，我只需将名字和<code class="fe oc od oe of b">basic_string</code>传递给<code class="fe oc od oe of b">re.findall()</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">re.findall()的基本用法</p></figure><p id="7d07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">结果将是一个包含该模式所有实例的列表。使用这个例子，<code class="fe oc od oe of b">basic_find</code>将是一个带有一个条目的列表:</p><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="a50c" class="oz ne it of b gy pa pb l pc pd">['Drew']</span></pre><p id="0227" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们想象一下，亚历克斯把他的 4 个汉堡包忘在野餐的地方，被肖恩偷走了。<code class="fe oc od oe of b">re.sub()</code>可以用 Shawn 替换 Alex 的任何实例:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">re.sub()的基本用法</p></figure><p id="ebc7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">结果字符串将显示 Shawn 现在有 4 个汉堡包。多么幸运的家伙🍔。</p><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="2475" class="oz ne it of b gy pa pb l pc pd">Drew has 3 watermelons, Shawn has 4 hamburgers, Karina has 12 tamales, and Anna has 6 soft pretzels</span></pre><p id="c901" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，这些例子都很基本。他们有一个时间和地点，但是如果我们想知道野餐中总共有多少食物呢？有物品的都是些什么人？如果我们需要熊猫数据框架中的这些数据来进行进一步分析，该怎么办？这就是你开始看到 regex 的好处的地方。</p><h1 id="2417" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">正则表达式词汇</h1><p id="4067" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">驱动正则表达式的有几个概念:</p><ol class=""><li id="a375" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md ol om on oo bi translated">字符集</li><li id="3896" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated">元字符</li><li id="57c9" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated">量词</li><li id="1aad" class="og oh it lk b ll op lo oq lr or lv os lz ot md ol om on oo bi translated">捕获组</li></ol><p id="0a17" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这不是一个详尽的列表，但足以帮助我们立即行动。</p><h2 id="4426" class="oz ne it bd nf pe pf dn nj pg ph dp nn lr pi pj np lv pk pl nr lz pm pn nt iz bi translated">字符集</h2><p id="8195" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">字符集表示括号内的选项，正则表达式只匹配其中一个选项。我们可以对字符集做很多事情:</p><ul class=""><li id="fefe" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md po om on oo bi translated">匹配一组<strong class="lk jd">字符</strong>:我们可以通过将每个元音放在括号中找到字符串中的所有元音，例如<code class="fe oc od oe of b">[aeiou]</code></li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">用括号组查找所有元音</p></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="dacb" class="oz ne it of b gy pa pb l pc pd">['e', 'a', 'a', 'e', 'e', 'o', 'e', 'a', 'a', 'u', 'e', 'a', 'i', 'a', 'a', 'a', 'a', 'e', 'a', 'a', 'a', 'o', 'e', 'e']</span></pre><ul class=""><li id="11ab" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md po om on oo bi translated">匹配一个<strong class="lk jd">范围的字符</strong>:通过使用<strong class="lk jd">连字符</strong>、<code class="fe oc od oe of b">[A-F]</code>，我们可以找到从“A”到“F”的任何<strong class="lk jd">大写字母</strong>。字符集<strong class="lk jd">区分大小写</strong>，所以<code class="fe oc od oe of b">[A-F]</code>和<code class="fe oc od oe of b">[a-f]</code>不一样</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">查找所有带括号组的大写字母</p></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="b76f" class="oz ne it of b gy pa pb l pc pd">['D', 'A', 'K', 'A']</span></pre><ul class=""><li id="923f" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md po om on oo bi translated">匹配一个<strong class="lk jd">范围的数字</strong>:我们可以通过添加数字到我们的字符集来查找一个范围内的数字，<code class="fe oc od oe of b">[0-9]</code>查找任何数字。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">用括号组查找所有数字</p></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="2664" class="oz ne it of b gy pa pb l pc pd">['3', '4', '1', '2', '6']</span></pre><p id="903b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">字符集可以同时包含这一部分的所有内容，所以类似于<code class="fe oc od oe of b">[A-Ct-z7-9]</code>的内容仍然有效。它将匹配从大写字母“A”到大写字母“C”、小写字母“t”到小写字母“z”以及 7 到 9 的所有字符。</p><p id="437d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，我们还不能回答之前提出的关于括号组的任何问题。让我们为我们的正则表达式库添加更多的武器。</p><h2 id="1b7c" class="oz ne it bd nf pe pf dn nj pg ph dp nn lr pi pj np lv pk pl nr lz pm pn nt iz bi translated">元字符</h2><p id="dc9d" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">元字符代表一种类型的字符。它们通常以反斜杠<code class="fe oc od oe of b">\</code>开头。每一个都匹配一个字符。以下是一些最重要的例子:</p><ul class=""><li id="8732" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md po om on oo bi translated"><code class="fe oc od oe of b">\s</code>:这个元字符代表<strong class="lk jd">空格</strong>。这将匹配每个空格、制表符和换行符。您还可以分别为制表符和换行符指定<code class="fe oc od oe of b">\t</code>和<code class="fe oc od oe of b">\n</code>。附注:我们的示例字符串没有任何制表符，但是在寻找它们时要小心。许多<a class="ae lh" href="https://www.codecademy.com/articles/what-is-an-ide" rel="noopener ugc nofollow" target="_blank">集成开发环境</a>或 IDE 都有一个设置，当你输入时，它会用空格替换所有的制表符。在示例字符串中，<code class="fe oc od oe of b">\s</code>返回一个包含 17 个空格的字符串，这正好是示例字符串中的空格数！</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">动作中的元角色</p></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="4a2d" class="oz ne it of b gy pa pb l pc pd">[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']</span></pre><ul class=""><li id="3a6f" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md po om on oo bi translated"><code class="fe oc od oe of b">\w</code>:该元字符代表<strong class="lk jd">字母数字字符</strong>。这包括所有字母 a-z，大写和小写，以及数字 0-9。这相当于括号组<code class="fe oc od oe of b">[A-Za-z0-9]</code>，只是写起来更快。注意记住<code class="fe oc od oe of b">\w</code>元字符本身只捕获单个字符，而不是整个单词或数字。你会在例子中看到。别担心，我们很快就会知道如何处理。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">\w 活动中的元字符</p></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="97fb" class="oz ne it of b gy pa pb l pc pd">['D', 'r', 'e', 'w', 'h', 'a', 's', '3', 'w', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n', 's', 'A', 'l', 'e', 'x', 'h', 'a', 's', '4', 'h', 'a', 'm', 'b', 'u', 'r', 'g', 'e', 'r', 's', 'K', 'a', 'r', 'i', 'n', 'a', 'h', 'a', 's', '1', '2', 't', 'a', 'm', 'a', 'l', 'e', 's', 'a', 'n', 'd', 'A', 'n', 'n', 'a', 'h', 'a', 's', '6', 's', 'o', 'f', 't', 'p', 'r', 'e', 't', 'z', 'e', 'l', 's']</span></pre><ul class=""><li id="c972" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md po om on oo bi translated"><code class="fe oc od oe of b">\d</code>:该元字符代表<strong class="lk jd">数字</strong>。使用我们之前的野餐例子，看看它如何只找到字符串中的数字。你会注意到，像括号组一样，它选取 5 个数字，而不是我们期望的 4 个。这是因为它寻找的是每个单独的数字，而不是一组数字。接下来我们将看到如何用量词来解决这个问题。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">\d 活动中的元字符</p></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="fda3" class="oz ne it of b gy pa pb l pc pd">['3', '4', '1', '2', '6']</span></pre><h2 id="d0bd" class="oz ne it bd nf pe pf dn nj pg ph dp nn lr pi pj np lv pk pl nr lz pm pn nt iz bi translated">量词</h2><p id="fcb9" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">正如我们在上一节中看到的，单个元字符的功能有限。当涉及到单词或数字时，<strong class="lk jd">我们通常希望一次找到 1 个以上的字符</strong>。这就是量词的用武之地。它们允许你量化你期望的字符数量。他们总是在被量化的人物之后出现，有几种类型:</p><ul class=""><li id="5534" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md po om on oo bi translated"><code class="fe oc od oe of b">+</code>量化 1 个或多个匹配。让我们看一个新的例子来开发一些关于每个量词将返回什么的直觉:<code class="fe oc od oe of b">quant_example</code></li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">显示量词的示例字符串</p></figure><p id="0efc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们在<code class="fe oc od oe of b">quant_example</code>上使用<code class="fe oc od oe of b">+</code>量词时，它将返回 4 个匹配。提到 regex 寻找非重叠匹配是一个很好的理由。在这种情况下，它会查看每个 B 及其后面的字符。因为我们使用了<code class="fe oc od oe of b">+</code>量词，所以它继续匹配，直到到达一组 B 的末尾。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">实际中的+量词</p></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="ec64" class="oz ne it of b gy pa pb l pc pd">['B', 'BB', 'BBB', 'BBBB']</span></pre><ul class=""><li id="5198" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md po om on oo bi translated"><code class="fe oc od oe of b">{}</code>量化特定数量或范围的匹配。当像<code class="fe oc od oe of b">{2}</code>这样书写时，它将精确匹配前面的 2 个字符。我们会看到一些有趣的结果。它找到了 4 根火柴。这是因为它正在寻找每个不重叠的 2 B 组。第 1 组中有一个匹配，第 2 组中只有 1 个非重叠匹配，第 4 组中有 2 个非重叠匹配。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="78ed" class="oz ne it of b gy pa pb l pc pd">['BB', 'BB', 'BB', 'BB']</span></pre><p id="e6c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当写成类似<code class="fe oc od oe of b">{2,4}</code>的形式时，它将匹配出现 2 到 4 次的任意数量的 B。注意，在正则表达式中放一个空格是无效的。它将返回一个空列表。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="14c7" class="oz ne it of b gy pa pb l pc pd">['BB', 'BBB', 'BBBB']</span></pre><p id="e9c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们也可以写这个量词，像<code class="fe oc od oe of b">{2,}</code>一样省略上界。这将匹配 2 个或更多实例。对于<code class="fe oc od oe of b">quant_example</code>，它将返回与<code class="fe oc od oe of b">{2,4}</code>完全相同的结果。</p><ul class=""><li id="0e3c" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md po om on oo bi translated"><code class="fe oc od oe of b">*</code>量化零个或多个匹配项<strong class="lk jd">。这在我们寻找可能在字符串中也可能不在字符串中的东西时很有帮助。</strong></li></ul><p id="74ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe oc od oe of b">*</code>量词单独使用时会返回一些奇怪的匹配，所以我们可以省略一个用<code class="fe oc od oe of b">quant_example</code>的例子。我们将在下面的例子中看到，当某人在我们的野餐中带了一个有多个单词名称的食物时，它是如何应用的。没有它，我们就不会正确地捕捉到安娜带来了软椒盐卷饼！</p><p id="a79d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们结合目前所知的字符集、元字符和量词来回答一些关于我们的野餐字符串的问题。我们想知道字符串中的所有单词，以及字符串中的数字。</p><p id="e596" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于单词，我们可以使用一个全部大写和小写字母的字符集，给它添加一个<code class="fe oc od oe of b">+</code>量词。这将找到任何长度的字母字符组合在一起。换句话说，它会找到所有的单词。Regex 看起来越来越有用了。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="1bb8" class="oz ne it of b gy pa pb l pc pd">['Drew', 'has', 'watermelons', 'Alex', 'has', 'hamburgers', 'Karina', 'has', 'tamales', 'and', 'Anna', 'has', 'soft', 'pretzels']</span></pre><p id="8a87" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了找到每种食物的数量，我们可以使用<code class="fe oc od oe of b">\d</code>元字符和量词<code class="fe oc od oe of b">{1,2}</code>。这将查找长度为 1 或 2 个字符的数字组。这是一个更有用的输出，因为我们有同样数量的食物和人！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="e272" class="oz ne it of b gy pa pb l pc pd">['3', '4', '12', '6']</span></pre><p id="325c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了找到每种食物的数量和名称，我们可以将量词和元字符结合起来。我们知道每个数字后面都有一个食物项目，所以我们可以添加到前面的例子中。我们知道有一个空格和一个单词(<code class="fe oc od oe of b">\s\w+</code>)后面可以跟另一个单词，比如“软椒盐卷饼”是如何出现的。要指定第二个词可能不在那里，我们可以用量词<code class="fe oc od oe of b">*</code>与第二个词连用。就像这样，我们有一份清单，上面列有野餐中所有物品的数量和名称。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="906b" class="oz ne it of b gy pa pb l pc pd">['3 watermelons', '4 hamburgers', '12 tamales', '6 soft pretzels']</span></pre><h2 id="5342" class="oz ne it bd nf pe pf dn nj pg ph dp nn lr pi pj np lv pk pl nr lz pm pn nt iz bi translated">捕获组</h2><p id="632c" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">捕获组允许您查找整个短语，并且只返回其中的一部分。以我们的例子为例，我需要每个人的名字，他们带了什么，带了多少。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="e958" class="oz ne it of b gy pa pb l pc pd">['Drew has 3 watermelons',<br/> 'Alex has 4 hamburgers',<br/> 'Karina has 12 tamales',<br/> 'Anna has 6 soft pretzels']</span></pre><p id="9124" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在<code class="fe oc od oe of b">capture_group1</code>中使用的正则表达式正在寻找一个名称，它以一个大写字母开始，后面有任意数量的小写字母(<code class="fe oc od oe of b">[A-Z][a-z]+</code>)。然后在一个空格之后，它匹配模式空格，单词，空格<code class="fe oc od oe of b">\s\w+\s</code>。接下来，我们要寻找一个 1 到 2 位数的数字，后跟一个空格和一个单词(<code class="fe oc od oe of b">\d{1,2}\s\w+</code>)。您可以在输出中看到，我们得到了一个字符串，其中包含每个人的详细信息。</p><p id="8cbe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在这是从我们开始的地方前进了一大步，但是我们真的不在乎“有”这个词，我们希望能够从数量上制作一个熊猫的数据框架。让我们添加捕获组。通过使用捕获组，我们可以返回一个包含所需信息的元组。我们将创建包含每个名称、数量和项目的捕获组。捕获组只是用括号括起来的正则表达式的一部分。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="8602" class="oz ne it of b gy pa pb l pc pd">[('Drew', '3', 'watermelons'), ('Alex', '4', 'hamburgers'), ('Karina', '12', 'tamales'), ('Anna', '6', 'soft pretzels')]</span></pre><p id="ea0e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就这样，我们现在有了一个元组列表，其中包含了我们想要的确切信息！</p><h1 id="ddc5" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">将我们的文本组合成一个数据帧</h1><p id="9d32" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">在进行数据分析时，最有用的 python 数据结构之一是 pandas 数据框架。毫无疑问，如果你点击了这篇文章，你就已经知道了。数据框架支持计算列统计数据和绘制数据。因为我们有一个元组列表，其中包含了我们想要的数据帧中的所有信息，所以我们可以遍历这个列表，构建我们的数据帧。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><pre class="ks kt ku kv gt ov of ow ox aw oy bi"><span id="afdf" class="oz ne it of b gy pa pb l pc pd">| Name   | Quantity | Item          |<br/>| ------ | -------- | ------------- |<br/>| Drew   | 3        | watermelons   |<br/>| Alex   | 4        | hamburgers    |<br/>| Karina | 12       | tamales       |<br/>| Anna   | 6        | soft pretzels |</span></pre></div><div class="ab cl pp pq hx pr" role="separator"><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu"/></div><div class="im in io ip iq"><h1 id="d42f" class="nd ne it bd nf ng pw ni nj nk px nm nn ki py kj np kl pz km nr ko qa kp nt nu bi translated">结论和进一步学习</h1><p id="8a79" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">我们只讨论了 regex 如何帮助处理非结构化文本数据的一小部分。这是一个很好的入门基础，但是不久之后你将需要知道一些概念，比如如何找到除了一个字符之外的所有内容(否定)，或者找到紧接在其他内容之前或之后的内容(环视)。查看我关于这些概念的另一篇文章。</p><div class="ml mm gp gr mn mo"><a rel="noopener follow" target="_blank" href="/anchors-away-more-python-regular-expressions-you-wish-you-knew-8a7780ac54e9"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd jd gy z fp mt fr fs mu fu fw jc bi translated">起锚！更多你希望知道的 Python 正则表达式</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">使用 Python 中的高级正则表达式工具处理文本的秘密</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="qb l mz na nb mx nc lb mo"/></div></div></a></div><p id="9961" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里有更多的资源可以帮助您了解 regex 中的其他概念:</p><ul class=""><li id="b43f" class="og oh it lk b ll lm lo lp lr oi lv oj lz ok md po om on oo bi translated"><a class="ae lh" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">官方</a> <code class="fe oc od oe of b"><a class="ae lh" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">re</a></code> <a class="ae lh" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">文档</a>:虽然文档看起来令人生畏，但是学习如何阅读它只会在你编程的时候对你有所帮助</li><li id="7d47" class="og oh it lk b ll op lo oq lr or lv os lz ot md po om on oo bi translated"><a class="ae lh" href="https://www.w3schools.com/python/python_regex.asp" rel="noopener ugc nofollow" target="_blank"> w3schools 参考资料</a>:庞大的编码和脚本语言参考资料知识库，包括 python。他们的许多例子都可以通过点击“自己尝试”按钮直接在浏览器上运行</li><li id="f342" class="og oh it lk b ll op lo oq lr or lv os lz ot md po om on oo bi translated"><a class="ae lh" href="https://www.datacamp.com/join-me/ODczNDQ5" rel="noopener ugc nofollow" target="_blank"> Datacamp 课程</a>(付费链接):一个致力于数据科学、机器学习和数据可视化的在线学习社区。查看他们的课程“Python 中的正则表达式”网站上每门课程的第一章都是免费的！</li></ul><div class="ml mm gp gr mn mo"><a href="https://realdrewdata.medium.com/membership" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd jd gy z fp mt fr fs mu fu fw jc bi translated">通过我的推荐链接加入 Medium-Drew Seewald</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">realdrewdata.medium.com</p></div></div><div class="mx l"><div class="qc l mz na nb mx nc lb mo"/></div></div></a></div></div></div>    
</body>
</html>