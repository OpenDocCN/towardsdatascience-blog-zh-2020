<html>
<head>
<title>60 Questions to Test Your Knowledge of Python Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试您对Python列表的了解的60个问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/60-questions-to-test-your-knowledge-of-python-lists-cca0ebfa0582?source=collection_archive---------0-----------------------#2020-05-19">https://towardsdatascience.com/60-questions-to-test-your-knowledge-of-python-lists-cca0ebfa0582?source=collection_archive---------0-----------------------#2020-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6de9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过掌握列表基础知识粉碎算法问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/58264dcfbaec1e6df95b9075532eace2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNC_-XyZ3c3JoL7QalYtGw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@andrew?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">安德鲁·尼尔</a>从<a class="ae ky" href="https://www.pexels.com/photo/woman-in-gray-sweater-sitting-on-couch-using-macbook-4134786/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</p></figure><p id="e9f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近做了很多算法问题，发现我并没有像应该的那样理解列表</p><p id="7681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我为评估自己的知识而写的60个问题的汇编。</p><p id="1713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你会发现它对我和写作一样有用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7730" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题1–10:</h1><h2 id="f572" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">1.检查列表是否包含元素</h2><p id="0868" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">如果列表中有特定的元素，那么<code class="fe nl nm nn no b">in</code>操作符将返回True。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="3590" class="mu md it no b gy nt nu l nv nw">li = [1,2,3,'a','b','c']</span><span id="d73b" class="mu md it no b gy nx nu l nv nw">'a' in li <br/>#=&gt; True</span></pre><h2 id="6e9c" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">2.如何同时遍历2+个列表</h2><p id="c57c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">您可以使用<code class="fe nl nm nn no b">zip()</code>列表，然后遍历<code class="fe nl nm nn no b">zip</code>对象。<code class="fe nl nm nn no b">zip</code>对象是元组的迭代器。</p><p id="bf0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们同时迭代3个列表，并将值插入到一个字符串中。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="9c1f" class="mu md it no b gy nt nu l nv nw">name = ['Snowball', 'Chewy', 'Bubbles', 'Gruff']<br/>animal = ['Cat', 'Dog', 'Fish', 'Goat']<br/>age = [1, 2, 2, 6]</span><span id="7291" class="mu md it no b gy nx nu l nv nw">z = zip(name, animal, age)<br/>z #=&gt; &lt;zip at 0x111081e48&gt;</span><span id="fac8" class="mu md it no b gy nx nu l nv nw">for name,animal,age in z:<br/>    print("%s the %s is %s" % (name, animal, age))<br/>    <br/>#=&gt; Snowball the Cat is 1<br/>#=&gt; Chewy the Dog is 2<br/>#=&gt; Bubbles the Fish is 2<br/>#=&gt; Gruff the Goat is 6</span></pre><h2 id="79e1" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">3.什么时候你会使用列表而不是字典？</h2><p id="88a4" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">列表和字典通常有稍微不同的用例，但是有一些重叠。</p><p id="3d11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我得出的算法问题的一般规则是，如果你可以两者都用，那就用字典，因为查找会更快。</p><h2 id="2032" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated"><strong class="ak">列表</strong></h2><p id="4b05" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">如果你需要存储一些东西的顺序，使用一个<strong class="lb iu">列表</strong>。</p><p id="c22e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即:数据库记录的id，按照它们将被显示的顺序排列。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="4c36" class="mu md it no b gy nt nu l nv nw">ids = [23,1,7,9]</span></pre><p id="4721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从python 3.7开始，列表和字典都是有序的，列表允许重复值，而字典不允许重复键。</p><h2 id="2a6f" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated"><strong class="ak">字典</strong></h2><p id="8c31" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">如果你想计算某事的发生次数，就用字典。比如家里宠物的数量。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="bf44" class="mu md it no b gy nt nu l nv nw">pets = {'dogs':2,'cats':1,'fish':5}</span></pre><p id="1582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个键在字典中只能存在一次。注意，键也可以是其他不可变的数据结构，如元组。即:<code class="fe nl nm nn no b">{('a',1):1, ('b',2):1}</code>。</p><h2 id="3612" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">4.列表是可变的吗？</h2><p id="7f4d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">是的。请注意，在下面的代码中，与内存中相同标识符关联的值没有发生变化。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="73f7" class="mu md it no b gy nt nu l nv nw">x = [1]<br/>print(id(x),':',x) #=&gt; 4501046920 : [1]</span><span id="c2c0" class="mu md it no b gy nx nu l nv nw">x.append(5)<br/>x.extend([6,7])<br/>print(id(x),':',x) #=&gt; 4501046920 : [1, 5, 6, 7]</span></pre><h2 id="cca9" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">5.一个列表需要同质吗？</h2><p id="00fa" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">不可以。不同类型的对象可以混合在一个列表中。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="33b3" class="mu md it no b gy nt nu l nv nw">a = [1,'a',1.0,[]]<br/>a #=&gt; [1, 'a', 1.0, []]</span></pre><h2 id="5f5c" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">6.追加和扩展有什么区别？</h2><p id="a450" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">.append()</code>在列表末尾添加一个对象。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="83ef" class="mu md it no b gy nt nu l nv nw">a = [1,2,3]<br/>a.append(4)<br/>a #=&gt; [1, 2, 3, 4]</span></pre><p id="b8f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也意味着追加列表会将整个列表作为单个元素添加，而不是追加它的每个值。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="59b8" class="mu md it no b gy nt nu l nv nw">a.append([5,6])<br/>a #=&gt; [1, 2, 3, 4, [5, 6]]</span></pre><p id="b054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">.extend()</code>将第二个列表中的每个值作为自己的元素相加。所以用另一个列表扩展一个列表会合并它们的值。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="1901" class="mu md it no b gy nt nu l nv nw">b = [1,2,3]<br/>b.extend([5,6])<br/>b #=&gt; [1, 2, 3, 5, 6]</span></pre><h2 id="6723" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">7.python列表是存储值还是指针？</h2><p id="7fcd" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">Python列表本身并不存储值。它们存储指向存储在内存中其他地方的值的指针。这使得列表是可变的。</p><p id="abea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们初始化值<code class="fe nl nm nn no b">1</code>和<code class="fe nl nm nn no b">2</code>，然后创建一个包含值<code class="fe nl nm nn no b">1</code>和<code class="fe nl nm nn no b">2</code>的列表。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="176b" class="mu md it no b gy nt nu l nv nw">print( id(1) ) #=&gt; 4438537632<br/>print( id(2) ) #=&gt; 4438537664</span><span id="d4df" class="mu md it no b gy nx nu l nv nw">a = [1,2,3]<br/>print( id(a) ) #=&gt; 4579953480</span><span id="ee38" class="mu md it no b gy nx nu l nv nw">print( id(a[0]) ) #=&gt; 4438537632<br/>print( id(a[1]) ) #=&gt; 4438537664</span></pre><p id="8254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意链表是如何拥有自己的内存地址的。但是列表中的<code class="fe nl nm nn no b">1</code>和<code class="fe nl nm nn no b">2</code>与我们之前定义的<code class="fe nl nm nn no b">1</code>和<code class="fe nl nm nn no b">2</code>指向内存中相同的位置。</p><h2 id="10ba" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">8.“del”是做什么的？</h2><p id="0523" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">del</code>从给定索引的列表中删除一个项目。</p><p id="9adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们将删除索引1处的值。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="a5e1" class="mu md it no b gy nt nu l nv nw">a = ['w', 'x', 'y', 'z']<br/>a #=&gt; ['w', 'x', 'y', 'z']</span><span id="9dc2" class="mu md it no b gy nx nu l nv nw">del a[1]</span><span id="abe4" class="mu md it no b gy nx nu l nv nw">a #=&gt; ['w', 'y', 'z']</span></pre><p id="d833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe nl nm nn no b">del</code>没有返回被移除的元素。</p><h2 id="f2a7" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">9.“移除”和“弹出”有什么区别？</h2><p id="3a39" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">.remove()</code>删除匹配对象的第一个实例。下面我们去掉第一个<code class="fe nl nm nn no b">b</code>。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="060e" class="mu md it no b gy nt nu l nv nw">a = ['a', 'a', 'b', 'b', 'c', 'c']<br/>a.remove('b')<br/>a #=&gt; ['a', 'a', 'b', 'c', 'c']</span></pre><p id="6e50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">.pop()</code>根据索引删除对象。</p><p id="bb39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">pop</code>和<code class="fe nl nm nn no b">del</code>的区别在于<code class="fe nl nm nn no b">pop</code>返回弹出的元素。这允许使用类似堆栈的列表。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="58c9" class="mu md it no b gy nt nu l nv nw">a = ['a', 'a', 'b', 'b', 'c', 'c']<br/>a.pop(4) #=&gt; 'c'<br/>a #=&gt; ['a', 'a', 'b', 'b', 'c']</span></pre><p id="f93c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，如果没有指定索引，<code class="fe nl nm nn no b">pop</code>会删除列表中的最后一个元素。</p><h2 id="c264" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">10.从列表中删除重复项</h2><p id="2d3f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">如果你不关心维护一个列表的顺序，那么转换成一个集合再转换回一个列表就可以实现这个目的。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="b972" class="mu md it no b gy nt nu l nv nw">li = [3, 2, 2, 1, 1, 1]<br/>list(set(li)) #=&gt; [1, 2, 3]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/1d30c13f33d6ade258f1b287c382b4da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xyXpc3G7yGUa-A2POaj0Rw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@chevanon?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">切瓦农摄影</a>从<a class="ae ky" href="https://www.pexels.com/photo/art-blur-cappuccino-close-up-302899/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</p></figure><h1 id="ec7f" class="mc md it bd me mf nz mh mi mj oa ml mm jz ob ka mo kc oc kd mq kf od kg ms mt bi translated">问题11–20:</h1><h2 id="537a" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">11.查找第一个匹配元素的索引</h2><p id="9529" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">例如，您想在水果列表中找到第一个“苹果”。使用<code class="fe nl nm nn no b">.index()</code>方法。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="7ed5" class="mu md it no b gy nt nu l nv nw">fruit = ['pear', 'orange', 'apple', 'grapefruit', 'apple', 'pear']<br/>fruit.index('apple') #=&gt; 2<br/>fruit.index('pear') #=&gt; 0</span></pre><h2 id="cb64" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">12.从列表中删除所有元素</h2><p id="482d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们可以用<code class="fe nl nm nn no b">.clear()</code>从现有列表中清除元素，而不是创建一个新的空列表。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="01c7" class="mu md it no b gy nt nu l nv nw">fruit = ['pear', 'orange', 'apple']</span><span id="a047" class="mu md it no b gy nx nu l nv nw">print( fruit )     #=&gt; ['pear', 'orange', 'apple']<br/>print( id(fruit) ) #=&gt; 4581174216</span><span id="db9d" class="mu md it no b gy nx nu l nv nw">fruit.clear()</span><span id="8cc6" class="mu md it no b gy nx nu l nv nw">print( fruit )     #=&gt; []<br/>print( id(fruit) ) #=&gt; 4581174216</span></pre><p id="f7f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者用<code class="fe nl nm nn no b">del</code>。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="789c" class="mu md it no b gy nt nu l nv nw">fruit = ['pear', 'orange', 'apple']</span><span id="c224" class="mu md it no b gy nx nu l nv nw">print( fruit )     #=&gt; ['pear', 'orange', 'apple']<br/>print( id(fruit) ) #=&gt; 4581166792</span><span id="63e6" class="mu md it no b gy nx nu l nv nw">del fruit[:]</span><span id="5f52" class="mu md it no b gy nx nu l nv nw">print( fruit )     #=&gt; []<br/>print( id(fruit) ) #=&gt; 4581166792</span></pre><h2 id="9dad" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">13.遍历列表中的值及其索引</h2><p id="d9ed" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">将计数器添加到作为参数传递的列表中。</p><p id="e829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们遍历列表，将值和索引传递给字符串插值。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="d87c" class="mu md it no b gy nt nu l nv nw">grocery_list = ['flour','cheese','carrots']</span><span id="7ac2" class="mu md it no b gy nx nu l nv nw">for idx,val in enumerate(grocery_list):<br/>    print("%s: %s" % (idx, val))<br/>    <br/>#=&gt; 0: flour<br/>#=&gt; 1: cheese<br/>#=&gt; 2: carrots</span></pre><h2 id="f592" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">14.如何连接两个列表</h2><p id="ef53" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">+</code>操作符将连接两个列表。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="3c94" class="mu md it no b gy nt nu l nv nw">one = ['a', 'b', 'c']<br/>two = [1, 2, 3]</span><span id="8788" class="mu md it no b gy nx nu l nv nw">one + two #=&gt; ['a', 'b', 'c', 1, 2, 3]</span></pre><h2 id="2b31" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">15.如何用列表理解操作列表中的每个元素</h2><p id="a768" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">下面我们返回一个新的列表，每个元素加1。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="1ca2" class="mu md it no b gy nt nu l nv nw">li = [0,25,50,100]</span><span id="98c8" class="mu md it no b gy nx nu l nv nw">[i+1 for i in li] <br/>#=&gt; [1, 26, 51, 101]</span></pre><h2 id="3c41" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">16.统计列表中特定对象的出现次数</h2><p id="e82f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">count()</code>方法返回一个特定对象出现的次数。下面我们返回字符串的次数，<code class="fe nl nm nn no b">“fish”</code>存在于一个名为<code class="fe nl nm nn no b">pets</code>的列表中。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="393e" class="mu md it no b gy nt nu l nv nw">pets = ['dog','cat','fish','fish','cat']<br/>pets.count('fish')<br/>#=&gt; 2</span></pre><h2 id="eca8" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">17.如何浅层复制一个列表？</h2><p id="1b24" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">.copy()</code>可以用来浅层复制一个列表。</p><p id="fa51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们创建一个<code class="fe nl nm nn no b">round1</code>的浅层副本，给它分配一个新名字<code class="fe nl nm nn no b">round2</code>，然后移除字符串<code class="fe nl nm nn no b">sonny chiba</code>。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="e1c3" class="mu md it no b gy nt nu l nv nw">round1 = ['chuck norris', 'bruce lee', 'sonny chiba']</span><span id="33bc" class="mu md it no b gy nx nu l nv nw"><strong class="no iu">round2 = round1.copy()</strong><br/>round2.remove('sonny chiba')</span><span id="0e3f" class="mu md it no b gy nx nu l nv nw">print(round1) #=&gt; ['chuck norris', 'bruce lee', 'sonny chiba']<br/>print(round2) #=&gt; ['chuck norris', 'bruce lee']</span></pre><h2 id="63b4" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">18.为什么要创建一个列表的浅层副本？</h2><p id="b1f5" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">基于前面的例子，如果我们不创建浅层拷贝，修改<code class="fe nl nm nn no b">round2</code>将会修改<code class="fe nl nm nn no b">round1</code>。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="d32f" class="mu md it no b gy nt nu l nv nw">round1 = ['chuck norris', 'bruce lee', 'sonny chiba']</span><span id="2651" class="mu md it no b gy nx nu l nv nw"><strong class="no iu">round2 = round1</strong><br/>round2.remove('sonny chiba')</span><span id="2fde" class="mu md it no b gy nx nu l nv nw">print(round1) #=&gt; ['chuck norris', 'bruce lee']<br/>print(round2) #=&gt; ['chuck norris', 'bruce lee']</span></pre><p id="7ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有浅拷贝，<code class="fe nl nm nn no b">round1</code>和<code class="fe nl nm nn no b">round2</code>只是内存中指向同一个链表的名字。这就是为什么看起来改变一个的值会改变另一个的值。</p><h2 id="77e1" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">19.如何深度复制一个列表？</h2><p id="2b96" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">为此我们需要导入<code class="fe nl nm nn no b">copy</code>模块，然后调用<code class="fe nl nm nn no b">copy.deepcopy()</code>。</p><p id="5988" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们创建一个名为<code class="fe nl nm nn no b">round2</code>的列表的深层副本<code class="fe nl nm nn no b">round1</code>，更新<code class="fe nl nm nn no b">round2</code>中的值，然后打印两者。在这种情况下，<code class="fe nl nm nn no b">round1</code>不受影响。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="8ae2" class="mu md it no b gy nt nu l nv nw">round1 = [<br/>    ['Arnold', 'Sylvester', 'Jean Claude'],<br/>    ['Buttercup', 'Bubbles', 'Blossom']<br/>]</span><span id="69f6" class="mu md it no b gy nx nu l nv nw">import copy<br/><strong class="no iu">round2 = copy.deepcopy(round1)</strong></span><span id="9518" class="mu md it no b gy nx nu l nv nw">round2[0][0] = 'Jet Lee'</span><span id="fd6b" class="mu md it no b gy nx nu l nv nw">print(round1)<br/>#=&gt; [['Arnold', 'Sylvester', 'Jean Claude'], ['Buttercup', 'Bubbles', 'Blossom']]</span><span id="19b4" class="mu md it no b gy nx nu l nv nw">print(round2)<br/>#=&gt; [['Jet Lee', 'Sylvester', 'Jean Claude'], ['Buttercup', 'Bubbles', 'Blossom']]</span></pre><p id="658e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面我们可以看到，改变<code class="fe nl nm nn no b">round2</code>中的嵌套数组并没有更新<code class="fe nl nm nn no b">round1</code>。</p><h2 id="6de2" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">20.深抄和浅抄有什么区别？</h2><p id="44b9" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在前一个例子的基础上，创建一个浅层副本，然后修改它，会影响原始列表..</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="60ea" class="mu md it no b gy nt nu l nv nw">round1 = [<br/>    ['Arnold', 'Sylvester', 'Jean Claude'],<br/>    ['Buttercup', 'Bubbles', 'Blossom']<br/>]</span><span id="02c1" class="mu md it no b gy nx nu l nv nw">import copy<br/><strong class="no iu">round2 = round1.copy()</strong></span><span id="f48e" class="mu md it no b gy nx nu l nv nw">round2[0][0] = 'Jet Lee'</span><span id="81c0" class="mu md it no b gy nx nu l nv nw">print(round1)<br/>#=&gt; [['Jet Lee', 'Sylvester', 'Jean Claude'], ['Buttercup', 'Bubbles', 'Blossom']]</span><span id="093c" class="mu md it no b gy nx nu l nv nw">print(round2)<br/>#=&gt; [['Jet Lee', 'Sylvester', 'Jean Claude'], ['Buttercup', 'Bubbles', 'Blossom']]</span></pre><p id="dca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么会这样？</p><p id="1161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个浅层副本确实会在内存中创建一个新的对象，但是它会填充上一个列表中已有对象的引用。</p><p id="59b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建深层副本会创建原始对象的副本，并指向这些新版本。因此新列表完全不受旧列表更改的影响，反之亦然。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/96d08f73ae4399100882ff9453d443d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcUUJYQfRO1vyoOBahXFvQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@valeriya?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">瓦莱里娅·博尔特涅娃</a>从<a class="ae ky" href="https://www.pexels.com/photo/croissant-with-butter-1510684/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</p></figure><h1 id="bbb0" class="mc md it bd me mf nz mh mi mj oa ml mm jz ob ka mo kc oc kd mq kf od kg ms mt bi translated">问题21-30:</h1><h2 id="a3c4" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">21.列表和元组的区别是什么？</h2><p id="b206" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">元组在创建后无法更新。添加/移除/更新现有元组需要创建新元组。</p><p id="b27c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表创建后可以修改。</p><p id="7277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元组通常表示一个对象，如从数据库中加载的记录，其中元素具有不同的数据类型。</p><p id="e212" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表通常用于存储特定类型对象的有序序列(但不总是如此)。</p><p id="7cb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者都是序列，并且允许重复值。</p><h2 id="8aaf" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">22.返回列表的长度</h2><p id="a625" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">len()</code>可以返回一个列表的长度。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="e2cd" class="mu md it no b gy nt nu l nv nw">li = ['a', 'b', 'c', 'd', 'e']<br/>len(li)<br/>#=&gt; 5</span></pre><p id="a1f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是请注意，它对顶级对象进行计数，因此几个整数的嵌套列表将只被计为单个对象。下面，<code class="fe nl nm nn no b">li</code>的长度是2，不是5。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="caaf" class="mu md it no b gy nt nu l nv nw">li = [[1,2],[3,4,5]]<br/>len(li)<br/>#=&gt; 2</span></pre><h2 id="47b3" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">23.列表和集合的区别是什么？</h2><p id="de68" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">列表是有序的，而集合不是。这就是为什么使用set在一个列表中寻找唯一值，像<code class="fe nl nm nn no b">list( set([3, 3, 2, 1]) )</code>失去了顺序。</p><p id="04d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表通常用于跟踪顺序，而集合通常用于跟踪存在。</p><p id="f38e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表允许重复，但是根据定义，集合中的所有值都是唯一的。</p><h2 id="48b0" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">24.如何检查一个元素是否不在列表中？</h2><p id="533e" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">为此，我们使用了<code class="fe nl nm nn no b">in</code>操作符，但是在它前面加上了<code class="fe nl nm nn no b">not</code>。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="9f05" class="mu md it no b gy nt nu l nv nw">li = [1,2,3,4]<br/>5 not in li #=&gt; True<br/>4 not in li #=&gt; False</span></pre><h2 id="5fe9" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">25.用map函数将列表中的每个元素乘以5</h2><p id="02ff" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">.map()</code>允许迭代一个序列，并用另一个函数更新每个值。</p><p id="3e76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回一个地图对象，但是我已经用一个列表理解包装了它，所以我们可以看到更新的值。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="ef3f" class="mu md it no b gy nt nu l nv nw">def multiply_5(val):<br/>    return val * 5</span><span id="d57c" class="mu md it no b gy nx nu l nv nw">a = [10,20,30,40,50]</span><span id="7a08" class="mu md it no b gy nx nu l nv nw">[val for val in map(multiply_5, a)] <br/>#=&gt; [50, 100, 150, 200, 250]</span></pre><h2 id="4b89" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">26.用zip函数将两个列表合并成一个元组列表</h2><p id="a327" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">zip()</code>将多个序列组合成一个元组迭代器，其中相同序列索引处的值组合在同一个元组中。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="c4e4" class="mu md it no b gy nt nu l nv nw">alphabet = ['a', 'b', 'c']<br/>integers = [1, 2, 3]</span><span id="3a1a" class="mu md it no b gy nx nu l nv nw">list(zip(alphabet, integers))</span></pre><h2 id="8662" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">27.在现有列表中的特定索引处插入值</h2><p id="9047" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">insert()</code>方法接受一个要插入的对象和索引。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="4ded" class="mu md it no b gy nt nu l nv nw">li = ['a','b','c','d','e']<br/>li.insert(2, 'HERE')</span><span id="ab68" class="mu md it no b gy nx nu l nv nw">li #=&gt; ['a', 'b', 'HERE', 'c', 'd', 'e']</span></pre><p id="224c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，先前位于指定索引处的元素被向右移动，而不是被覆盖。</p><h2 id="9056" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">28.用reduce函数从第一个元素中减去列表中的值</h2><p id="d108" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">reduce()</code>需要从<code class="fe nl nm nn no b">functools</code>导入。</p><p id="5970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定一个函数，<code class="fe nl nm nn no b">reduce</code>遍历一个序列，并对每个元素调用该函数。当前一个元素调用函数时，前一个元素的输出作为参数传递。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="cf47" class="mu md it no b gy nt nu l nv nw">from functools import reduce</span><span id="14d7" class="mu md it no b gy nx nu l nv nw">def subtract(a,b):<br/>    return a - b</span><span id="a908" class="mu md it no b gy nx nu l nv nw">numbers = [100,10,5,1,2,7,5]</span><span id="935c" class="mu md it no b gy nx nu l nv nw">reduce(subtract, numbers) #=&gt; 70</span></pre><p id="b622" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面我们从100减去了10，5，1，2，7和5。</p><h2 id="121c" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">29.用filter函数从列表中删除负值</h2><p id="e46f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">给定一个函数，<code class="fe nl nm nn no b">filter()</code>将从序列中删除该函数不返回<code class="fe nl nm nn no b">True</code>的任何元素。</p><p id="9990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们去掉小于零的元素。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="bfa0" class="mu md it no b gy nt nu l nv nw">def remove_negatives(x):<br/>    return True if x &gt;= 0 else False<br/>    <br/>a = [-10, 27, 1000, -1, 0, -30]</span><span id="7a12" class="mu md it no b gy nx nu l nv nw">[x for x in filter(remove_negatives, a)] <br/>#=&gt; [27, 1000, 0]</span></pre><h2 id="929f" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">30.将列表转换成字典，其中列表元素是键</h2><p id="5b51" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">为此我们可以用字典理解。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="3f32" class="mu md it no b gy nt nu l nv nw">li = ['The', 'quick', 'brown', 'fox', 'was', 'quick']<br/>d = {k:1 for k in li}<br/>d #=&gt; {'The': 1, 'quick': 1, 'brown': 1, 'fox': 1, 'was': 1}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/2639b593844099566b683cfe0c5bc9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5o5xJXmfJ3PRJiBFwaFBLg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·梅纳江摄于<a class="ae ky" href="https://www.pexels.com/photo/shallow-focus-photography-of-cafe-late-982612/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a></p></figure><h1 id="af95" class="mc md it bd me mf nz mh mi mj oa ml mm jz ob ka mo kc oc kd mq kf od kg ms mt bi translated">问题31-40:</h1><h2 id="cd07" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">31.用lambda函数修改现有列表</h2><p id="b3f3" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">让我们将之前编写的<code class="fe nl nm nn no b">map</code>函数转换成带有<code class="fe nl nm nn no b">lambda</code>的一行程序。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="a1c3" class="mu md it no b gy nt nu l nv nw">a = [10,20,30,40,50]</span><span id="ef5d" class="mu md it no b gy nx nu l nv nw">list(map(lambda val:val*5, a))<br/>#=&gt; [50, 100, 150, 200, 250]</span></pre><p id="be4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="of">我可以把它作为一个map对象，直到我需要迭代它，但是我把它转换成一个列表来显示里面的元素。</em></p><h2 id="7339" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">32.移除列表中特定索引后的元素</h2><p id="60de" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">使用slice语法，我们可以返回一个新的列表，其中只包含特定索引之前的元素。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="fbff" class="mu md it no b gy nt nu l nv nw">li = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,10]</span><span id="eba4" class="mu md it no b gy nx nu l nv nw">li[:10]<br/>#=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></pre><h2 id="1186" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">33.移除列表中特定索引前的元素</h2><p id="2924" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">slice语法还可以返回一个新列表，其中包含指定索引之后的值。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="a31a" class="mu md it no b gy nt nu l nv nw">li = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,10]</span><span id="029a" class="mu md it no b gy nx nu l nv nw">li[15:]<br/>#=&gt; [16, 17, 18, 19, 10]</span></pre><h2 id="f2a3" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">34.移除列表中两个索引之间的元素</h2><p id="5321" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">或者在两个指数之间。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="b909" class="mu md it no b gy nt nu l nv nw">li = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,10]</span><span id="240c" class="mu md it no b gy nx nu l nv nw">li[12:17]<br/>#=&gt; [13, 14, 15, 16, 17]</span></pre><h2 id="d32b" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">35.返回列表中两个索引之间的第二个元素</h2><p id="37ff" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">或者在特定间隔的索引之前/之后/之间。</p><p id="8465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们使用slice语法返回索引10和16之间的每第二个值。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="57b4" class="mu md it no b gy nt nu l nv nw">li = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,10]</span><span id="d4c0" class="mu md it no b gy nx nu l nv nw">li[10:16:2]<br/>#=&gt; [11, 13, 15]</span></pre><h2 id="c615" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">36.按升序对整数列表进行排序</h2><p id="c63e" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">sort()</code>方法将一个列表改变为升序。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="d3ce" class="mu md it no b gy nt nu l nv nw">li = [10,1,9,2,8,3,7,4,6,5]</span><span id="3731" class="mu md it no b gy nx nu l nv nw">li.sort()<br/>li #=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></pre><h2 id="5cd1" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">37.按降序对整数列表进行排序</h2><p id="cb7a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">通过添加参数<code class="fe nl nm nn no b">reverse=True</code>，也可以用<code class="fe nl nm nn no b">sort()</code>进行降序排序。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="de86" class="mu md it no b gy nt nu l nv nw">li = [10,1,9,2,8,3,7,4,6,5]</span><span id="10a4" class="mu md it no b gy nx nu l nv nw">li.sort(reverse=True)<br/>li #=&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span></pre><h2 id="013e" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">38.用列表理解从列表中过滤出偶数值</h2><p id="a387" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">您可以在列表理解中添加条件逻辑，以按照给定的模式过滤出值。</p><p id="ef4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们过滤掉能被2整除的值。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="8fa4" class="mu md it no b gy nt nu l nv nw">li = [1,2,3,4,5,6,7,8,9,10]</span><span id="a3cb" class="mu md it no b gy nx nu l nv nw">[i for i in li if i % 2 != 0]<br/>#=&gt; [1, 3, 5, 7, 9]</span></pre><h2 id="b028" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">39.统计列表中每个值的出现次数</h2><p id="d04b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">一种选择是遍历一个列表并将计数添加到一个字典中。但是最简单的选择是从<code class="fe nl nm nn no b">collections</code>导入<code class="fe nl nm nn no b">Counter</code>类，并将列表传递给它。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="5a08" class="mu md it no b gy nt nu l nv nw">from collections import Counter</span><span id="1d10" class="mu md it no b gy nx nu l nv nw">li = ['blue', 'pink', 'green', 'green', 'yellow', 'pink', 'orange']</span><span id="96e5" class="mu md it no b gy nx nu l nv nw">Counter(li)<br/>#=&gt; Counter({'blue': 1, 'pink': 2, 'green': 2, 'yellow': 1, 'orange': 1})</span></pre><h2 id="6e61" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">40.获取列表中每个嵌套列表的第一个元素</h2><p id="cb6a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">列表理解非常适合迭代其他对象的列表，并从每个嵌套对象中获取一个元素。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="0c76" class="mu md it no b gy nt nu l nv nw">li = [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15]]</span><span id="d97b" class="mu md it no b gy nx nu l nv nw">[i[0] for i in li]<br/>#=&gt; [1, 4, 7, 10, 13]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/6e3a8abc67714bd3115b28e1c4196d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FRBA7upsp4m_1zhpR3kCVQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/macro-photography-of-pile-of-3-cookie-230325/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@fotios-photos?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Lisa Fotios </a>的照片</p></figure><h1 id="59b9" class="mc md it bd me mf nz mh mi mj oa ml mm jz ob ka mo kc oc kd mq kf od kg ms mt bi translated">问题41–50:</h1><h2 id="b200" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">41.对于一个列表，插入、查找、删除的时间复杂度是多少？</h2><p id="23a0" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><strong class="lb iu">插入的是O(n) </strong>。如果在开头插入一个元素，所有其他元素都必须右移。</p><p id="d8dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">通过索引查找是O(1) </strong>。但是find by value是O(n ),因为需要迭代元素直到找到值。</p><p id="931d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">删除是O(n) </strong>。如果一开始就删除了一个元素，那么所有其他元素都必须左移。</p><h2 id="a6ea" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">42.将列表中的元素组合成一个字符串。</h2><p id="435d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这可以通过<code class="fe nl nm nn no b">join()</code>功能完成。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="1168" class="mu md it no b gy nt nu l nv nw">li = ['The','quick','brown', 'fox', 'jumped', 'over', 'the', 'lazy', 'dog']<br/>' '.join(li)<br/>#=&gt; 'The quick brown fox jumped over the lazy dog'</span></pre><h2 id="489b" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">43.一个列表乘以一个整数会有什么影响？</h2><p id="d7cc" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">将一个列表乘以一个整数称为多重串联，其效果与将一个列表串联n次相同。</p><p id="2bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们将列表乘以5。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="b519" class="mu md it no b gy nt nu l nv nw">['a','b'] * 5<br/>#=&gt; ['a', 'b', 'a', 'b', 'a', 'b', 'a', 'b', 'a', 'b']</span></pre><p id="5ed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与相同。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="53b2" class="mu md it no b gy nt nu l nv nw">['a','b'] + ['a','b'] + ['a','b'] + ['a','b'] + ['a','b']<br/>#=&gt; ['a', 'b', 'a', 'b', 'a', 'b', 'a', 'b', 'a', 'b']</span></pre><h2 id="a15a" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">44.如果列表中的任何值可以被2整除，则使用“any”函数返回True</h2><p id="3faa" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">如果返回的列表中有任何值的计算结果为<code class="fe nl nm nn no b">True</code>，我们可以将<code class="fe nl nm nn no b">any()</code>与列表理解结合起来返回<code class="fe nl nm nn no b">True</code>。</p><p id="6a0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一个列表下面，理解返回<code class="fe nl nm nn no b">True</code>，因为列表中有一个<code class="fe nl nm nn no b">2</code>，它可以被<code class="fe nl nm nn no b">2</code>整除。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="652a" class="mu md it no b gy nt nu l nv nw">li1 = [1,2,3]<br/>li2 = [1,3]</span><span id="a40b" class="mu md it no b gy nx nu l nv nw">any(i % 2 == 0 for i in li1) #=&gt; True<br/>any(i % 2 == 0 for i in li2) #=&gt; False</span></pre><h2 id="2b15" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">45.如果列表中的所有值都是负数，则使用“all”函数返回True</h2><p id="db56" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">与<code class="fe nl nm nn no b">any()</code>函数类似，<code class="fe nl nm nn no b">all()</code>也可以与列表理解一起使用，仅当返回列表中的所有值都是<code class="fe nl nm nn no b">True</code>时才返回<code class="fe nl nm nn no b">True</code>。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="4169" class="mu md it no b gy nt nu l nv nw">li1 = [2,3,4]<br/>li2 = [2,4]</span><span id="e939" class="mu md it no b gy nx nu l nv nw">all(i % 2 == 0 for i in li1) #=&gt; False<br/>all(i % 2 == 0 for i in li2) #=&gt; True</span></pre><h2 id="a698" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">46.你能对一个包含“无”的列表进行排序吗？</h2><p id="c8b0" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">您不能对包含<code class="fe nl nm nn no b">None</code>的列表进行排序，因为比较运算符(由<code class="fe nl nm nn no b">sort()</code>使用)不能将整数与<code class="fe nl nm nn no b">None</code>进行比较。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="6351" class="mu md it no b gy nt nu l nv nw">li = [10,1,9,2,8,3,7,4,6,None]</span><span id="c62b" class="mu md it no b gy nx nu l nv nw">li.sort()<br/>li #=&gt; TypeError: '&lt;' not supported between instances of 'NoneType' and 'int'</span></pre><h2 id="86a8" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">47.列表构造函数将从现有列表中创建什么样的副本？</h2><p id="0634" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">list构造函数创建一个传入列表的浅表副本。也就是说，这比使用<code class="fe nl nm nn no b">.copy()</code>要简单得多。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="5918" class="mu md it no b gy nt nu l nv nw">li1 = ['a','b']<br/>li2 = list(li1)<br/>li2.append('c')</span><span id="678e" class="mu md it no b gy nx nu l nv nw">print(li1) #=&gt; ['a', 'b']<br/>print(li2) #=&gt; ['a', 'b', 'c']</span></pre><h2 id="4f96" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">48.颠倒列表的顺序</h2><p id="dfef" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">可以用<code class="fe nl nm nn no b">reverse()</code>方法将一个列表改变成相反的顺序。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="233d" class="mu md it no b gy nt nu l nv nw">li = [1,2,3,4,5,6,7,8,9,10]<br/>li.reverse()<br/>li #=&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span></pre><p id="10de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这将改变对象，而不是返回一个新的对象。</p><h2 id="29c0" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">49.反和反的区别是什么？</h2><p id="c359" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">reverse()</code>原地反转列表。<code class="fe nl nm nn no b">reversed()</code>以逆序返回列表的iterable。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="111b" class="mu md it no b gy nt nu l nv nw">li = [1,2,3,4,5,6,7,8,9,10]<br/>list(reversed(li))<br/>#=&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span></pre><h2 id="3f4f" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">50.sort和sorted有什么区别？</h2><p id="2b62" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">sort()</code>就地修改列表。<code class="fe nl nm nn no b">sorted()</code>返回一个逆序的新列表。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="7850" class="mu md it no b gy nt nu l nv nw">li = [10,1,9,2,8,3,7,4,6,5]<br/>li.sort()<br/>li #=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><span id="e3e6" class="mu md it no b gy nx nu l nv nw">li = [10,1,9,2,8,3,7,4,6,5]<br/>sorted(li) #=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/1ec595d5e89558a1c8fad1f9941f7411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihGVUG1BO9vQ3r5VWZXQYA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/coffee-latte-1477486/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae ky" href="https://www.pexels.com/@tl-portrait-614151?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> TL人像</a>照片</p></figure><h1 id="daec" class="mc md it bd me mf nz mh mi mj oa ml mm jz ob ka mo kc oc kd mq kf od kg ms mt bi translated">问题51–60:</h1><h2 id="6148" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">51.返回列表中的最小值</h2><p id="6b56" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">min()</code>函数返回列表中的最小值。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="aea6" class="mu md it no b gy nt nu l nv nw">li = [10,1,9,2,8,3,7,4,6,5]<br/>min(li)<br/>#=&gt; 1</span></pre><h2 id="86d5" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">52.返回列表中的最大值</h2><p id="6e32" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">max()</code>函数返回列表中的最大值。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="f59f" class="mu md it no b gy nt nu l nv nw">li = [10,1,9,2,8,3,7,4,6,5]<br/>max(li)<br/>#=&gt; 10</span></pre><h2 id="0abb" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">53.返回列表中数值的总和</h2><p id="1032" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nl nm nn no b">sum()</code>函数返回列表中所有值的总和。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="d77b" class="mu md it no b gy nt nu l nv nw">li = [10,1,9,2,8,3,7,4,6,5]<br/>sum(li)<br/>#=&gt; 55</span></pre><h2 id="e1c8" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">54.将列表用作堆栈</h2><p id="0ba5" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">你可以使用<code class="fe nl nm nn no b">append()</code>和<code class="fe nl nm nn no b">pop()</code>把一个列表当作一个堆栈。堆栈按照后进先出法运行。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="fd16" class="mu md it no b gy nt nu l nv nw">stack = []</span><span id="5a22" class="mu md it no b gy nx nu l nv nw">stack.append('Jess')<br/>stack.append('Todd')<br/>stack.append('Yuan')</span><span id="28c2" class="mu md it no b gy nx nu l nv nw">print(stack) #=&gt; ['Jess', 'Todd', 'Yuan']</span><span id="75d9" class="mu md it no b gy nx nu l nv nw">print(stack.pop()) #=&gt; Yuan</span><span id="306c" class="mu md it no b gy nx nu l nv nw">print(stack) #=&gt; ['Jess', 'Todd']</span></pre><p id="1081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">堆栈的一个好处是可以在O(1)时间内添加和删除元素，因为列表不需要迭代。</p><h2 id="4c12" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">55.找到两个列表的交集</h2><p id="8e45" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们可以通过使用带“与”符号的<code class="fe nl nm nn no b">set()</code>来做到这一点。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="f6d4" class="mu md it no b gy nt nu l nv nw">li1 = [1,2,3]<br/>li2 = [2,3,4]</span><span id="4a94" class="mu md it no b gy nx nu l nv nw">set(li1) &amp; set(li2)<br/>#=&gt; {2, 3}</span></pre><h2 id="eb27" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">56.找出一个集合和另一个集合的区别</h2><p id="5b6f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们不能减去列表，但我们可以减去集合。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="e127" class="mu md it no b gy nt nu l nv nw">li1 = [1,2,3]<br/>li2 = [2,3,4]</span><span id="e1bf" class="mu md it no b gy nx nu l nv nw">set(li1) - set(li2)<br/>#=&gt; {1}</span><span id="ef83" class="mu md it no b gy nx nu l nv nw">set(li2) - set(li1)<br/>#=&gt; {4}</span></pre><h2 id="ebcd" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">57.用列表理解展平列表列表</h2><p id="b786" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">与Ruby不同，Python3没有显式的flatten函数。但是我们可以使用列表理解来简化列表列表。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="8faa" class="mu md it no b gy nt nu l nv nw">li = [[1,2,3],[4,5,6]]</span><span id="15ff" class="mu md it no b gy nx nu l nv nw">[i for x in li for i in x]<br/>#=&gt; [1, 2, 3, 4, 5, 6]</span></pre><h2 id="4366" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">58.生成两个值之间所有整数的列表</h2><p id="ca45" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们可以创建一个介于两个值之间的范围，然后将其转换为一个列表。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="bae9" class="mu md it no b gy nt nu l nv nw">list(range(5,10))<br/>#=&gt; [5, 6, 7, 8, 9]</span></pre><h2 id="9208" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">59.将两个列表合并成一个字典</h2><p id="771a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">使用<code class="fe nl nm nn no b">zip()</code>和<code class="fe nl nm nn no b">list()</code>构造函数，我们可以将两个列表合并成一个字典，其中一个列表成为键，另一个列表成为值。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="192a" class="mu md it no b gy nt nu l nv nw">name = ['Snowball', 'Chewy', 'Bubbles', 'Gruff']<br/>animal = ['Cat', 'Dog', 'Fish', 'Goat']</span><span id="3637" class="mu md it no b gy nx nu l nv nw">dict(zip(name, animal))<br/>#=&gt; {'Snowball': 'Cat', 'Chewy': 'Dog', 'Bubbles': 'Fish', 'Gruff': 'Goat'}</span></pre><h2 id="3d7a" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">60.使用slice语法反转列表的顺序</h2><p id="0e8c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">虽然我们可以用<code class="fe nl nm nn no b">reverse()</code>和<code class="fe nl nm nn no b">reversed()</code>反转一个列表，但也可以用slice语法来完成。</p><p id="bc30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将通过从头到尾遍历列表返回一个新列表。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="3f57" class="mu md it no b gy nt nu l nv nw">li = ['a','b',3,4]<br/>li[::-1]<br/>#=&gt; [4, 3, 'b', 'a']</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5e6b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="0b1b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">做完这些后，我觉得更有准备去解决算法问题，而不用去猜测具体的列表方法。</p><p id="e877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">去除持续的谷歌搜索可以为更高层次的思考释放能量，比如让一个功能做它应该做的事情，以及降低功能的复杂性。</p><p id="637a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我希望您发现这也很有用。</p><p id="5940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能对我之前发表的关于<a class="ae ky" rel="noopener" target="_blank" href="/41-questions-to-test-your-knowledge-of-python-strings-9eb473aa8fe8">字符串问题</a>的文章感兴趣，或者对我已经开始发表的关于算法问题的<a class="ae ky" rel="noopener" target="_blank" href="/3-algorithm-interview-questions-for-data-science-and-software-engineering-in-python-29fc86a07a6f">每周系列文章感兴趣。</a></p></div></div>    
</body>
</html>