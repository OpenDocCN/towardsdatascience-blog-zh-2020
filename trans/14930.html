<html>
<head>
<title>Simple Morse Code Decoder in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的简单莫尔斯码解码器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/simple-morse-code-decoder-in-python-39f6db635af2?source=collection_archive---------8-----------------------#2020-10-14">https://towardsdatascience.com/simple-morse-code-decoder-in-python-39f6db635af2?source=collection_archive---------8-----------------------#2020-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/987fbe841f90ec4c96d67a6a75e95f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VvpVJUPjj8C-i7i1d8-tQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者Rhey t . Snodgrass&amp;Victor f . Camp，1922 — Image:Intcode.png和Image:国际莫尔斯code.png，公共领域，<a class="ae kf" href="https://commons.wikimedia.org/w/index.php?curid=3902977" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=3902977</a></p></figure><p id="cbf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">莫尔斯电码是一种用于电信的方法，其中每个字母、数字和标点符号由一系列点/破折号/空格表示。它是由塞缪尔·莫尔斯在20世纪30年代首先发明的，并且已经在海军工业中大量使用。本文将描述用Python构建一个简单的莫尔斯码解码器的过程。</p><h1 id="e63c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Python中的莫尔斯码表示</h1><p id="44fa" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如上图所示，每个字母和数字都由一系列点和破折号表示。我们可以在Python中这样表示它们，但是为了更清楚，让我们将它们翻译成‘0’和‘1’，其中<strong class="ki iu">‘0’表示点</strong>，而<strong class="ki iu">‘1’表示破折号</strong>。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="43e6" class="mq lf it mm b gy mr ms l mt mu">character = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9']</span><span id="0ff3" class="mq lf it mm b gy mv ms l mt mu">code = ['01','1000','1010','100','0','0010','110','0000','00','0111','101','0100','11','10','111','0110','1101','010','000','1','001','0001','011','1001','1011','1100','11111','01111','00111','00011','00001','00000','10000','11000','11100','11110']</span></pre><p id="e63a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于每个字符(即一个字母或数字)对应一系列0和1，我们将使用一个字典结构在Python中存储它们。你可以在这里参考我之前关于用Python <a class="ae kf" rel="noopener" target="_blank" href="/python-data-structures-conversions-ec9d56649e3b">构建字典数据结构的帖子。</a></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7fbd" class="mq lf it mm b gy mr ms l mt mu"># Define an empty dictionary 'morse_dict'<br/>morse_dict = {}</span><span id="336d" class="mq lf it mm b gy mv ms l mt mu"># Convert the 2 lists into a dictionary using a tuple<br/>zipped_char_code = zip(character, code)<br/>morse_dict = dict(zipped_char_code)</span><span id="3bf3" class="mq lf it mm b gy mv ms l mt mu"># Print the dictionary 'morse_dict' on the terminal line by line<br/>for key, value in morse_dict.items():<br/>    print(key, value)</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/6f4d8e1c37c94fca432c6f68ecb23d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:206/format:webp/1*SSf74sRbFH1POvyjlsY1JQ.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片-包含莫尔斯电码表示的字典的Python输出</p></figure><h1 id="7d3a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">建造莫尔斯电码解码器</h1><p id="7a16" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">莫尔斯解码器的构建方式是，我们将提示用户键入莫尔斯码表示(即0和1)，每个字母或数字由一个<strong class="ki iu"> * </strong>分隔。一旦用户按下“回车”，程序将解码莫尔斯电码并以字母数字的形式显示出来。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8643" class="mq lf it mm b gy mr ms l mt mu"># reverse the previous dict as it's easier to access the keys<br/>zipped_code_char = zip(code,character)<br/>rev_morse_dict = dict(list(zipped_code_char))<br/># initiating a while loop<br/>while True:<br/>    # empty list to store original message<br/>    ori_msg = [] <br/>    # empty list to store decoded message<br/>    dec_msg = []<br/>    <br/>    # prompt the user to input morse code<br/>    input_msg = input ("Please enter any Morse Code sequence for decoding. Leave blank to quit. ")<br/>    # append input_msg (string) to ori_msg (string)<br/>    ori_msg.append(input_msg)<br/>    # split each morse code by '*'<br/>    new_msg = input_msg.split("*")<br/>    <br/>    # printing out the original message<br/>    for line in ori_msg: # to print original message without the []<br/>        print("Original message: " + line + "\n")<br/>    <br/>    # loop through each morse code representation<br/>    for j in range (0,len(new_msg)):<br/>        # get the alphanumeric alphabet based on the dict keys and append to dec_msg<br/>        if new_msg[j] in rev_morse_dict.keys():<br/>            dec_msg.append(rev_morse_dict[new_msg[j]])<br/>    <br/>    # printing out the decoded message<br/>    print ("Decoded Message is: " + ''.join(dec_msg) + "\n")</span><span id="5090" class="mq lf it mm b gy mv ms l mt mu">    # end the infinite while loop<br/>    break</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/bfc1f3f7eaf5a2fac58d2cd62cc366db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vtObQmFpO6XVk68DXTBXmg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图片作者——莫尔斯电码解码器的Python输出</p></figure><p id="147e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如在程序输出中看到的，莫尔斯电码解码器能够将莫尔斯电码解码为<em class="my"> MYNAMEISKIERAN。</em></p><h1 id="4116" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">错误检查</h1><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/2043cb07375176094ca45f409bc02d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eiqn6tpOPuqz3x7p9hRcbg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图片由作者提供——带“abc”输入的莫尔斯电码解码器的Python输出</p></figure><p id="13f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，我们只实现了一个简单的莫尔斯电码解码器，它只能在用户只输入莫尔斯电码表示(即0和1)的情况下解码<strong class="ki iu">。如截图所示，如果用户输入'<em class="my"> abc '，</em>解码器将无法解码剩余的莫尔斯电码，也不会显示任何错误信息。让我们改进我们的解码器，进行以下简单的错误检查:</strong></p><ol class=""><li id="979c" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated">用户只能输入0、1和*</li><li id="70f5" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">用户只能输入预先定义的莫尔斯电码表示法(例如0000000不是有效的表示法)</li><li id="030a" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">程序可以继续解码莫尔斯电码，直到用户指定退出</li></ol><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5b37" class="mq lf it mm b gy mr ms l mt mu"># counter to do error check<br/>    i = 0<br/>    # proceed if user enters something<br/>    if (len(input_msg)!=0):<br/>        # while loop to check if only 0, 1 or * has been keyed in<br/>        while (i&lt;len(input_msg)):<br/>            if input_msg[i] == "0" or input_msg[i] == "1" or input_msg[i] == "*":<br/>                i+=1<br/>            else:<br/>                # if invalid chars found, print error message<br/>                print ("Error input, Morse Code sequence should only consists of 0 and 1, with a * between subsequence")<br/>               # break the error check once one error has been found<br/>                break</span></pre><p id="f691" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们添加上面的代码来纠正第一个无效字符的问题，如下面的屏幕截图所示，现在会向用户显示一条无效字符的错误消息。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/0295694ae57250d85d0d3a8deb98be8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KOkjC0v_aLsuP02p6tOBfQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片——带“abc”输入的新型莫尔斯电码解码器的Python输出</p></figure><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e335" class="mq lf it mm b gy mr ms l mt mu"># loop through each morse code representation<br/>            for j in range (0,len(new_msg)):<br/>                # get the alphanumeric alphabet based on the dict keys and append to dec_msg<br/>                if new_msg[j] in rev_morse_dict.keys():<br/>                    dec_msg.append(rev_morse_dict[new_msg[j]])<br/>                # if morse code representation not found in original list, append input to err_msg<br/>                else:<br/>                    err_msg.append(new_msg[j])<br/>            <br/>            # to print error message only when necessary<br/>            if len(err_msg) != 0:  <br/>                for line in err_msg: <br/>                    print(line + " has no known morse translation")</span></pre><p id="08d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们添加上面的代码来纠正在预定义列表中找不到的无效莫尔斯码表示的第二个问题。新程序现在将向用户显示一条错误消息，如下所示，同时对那些有效的消息进行解码。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/a0089a33ab19cf79092a97b6171022cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qx-cDB-UXwIDooI78OxvjA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图片由作者提供-新莫尔斯电码解码器的Python输出，带有无效的莫尔斯电码输入</p></figure><p id="cc4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，如前所述，我们将使我们的程序有能力继续解码莫尔斯电码表示，如果用户继续输入，只有当用户选择退出时才停止。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/686ddc20ee243633fb299204849076a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eAN9u-0-l5b_-CoFxkE0TA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片—新莫尔斯电码解码器的Python输出</p></figure><h1 id="a712" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">限制</h1><p id="852a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这个程序的第一个限制是，如果用户想键入句子，程序将无法识别。从程序的输出中可以看出，字母数字被解码，中间没有任何空格。当然，有一些方法可以改进这一点，比如指定用户键入“***”作为空格。</p><p id="3f88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个限制是，我们没有在这个莫尔斯电码解码器中加入标点符号，因为它对这个程序的目的来说并不重要。由于标点符号也是由点和破折号组成的，我们可以简单地扩展预定义的莫尔斯电码表示来包含标点符号。</p><h1 id="e494" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">摘要</h1><p id="2945" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">本文描述了构建一个莫尔斯码解码器的过程，该解码器能够接受用户输入，并以原始的字母数字形式输出。此外，我们在程序中实现了几个错误检查功能，以确保莫尔斯电码解码器按照预期的方式工作。希望你们喜欢这篇文章，并开始建立自己的莫尔斯码解码器的乐趣！干杯！</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><a href="https://www.buymeacoffee.com/tankahwang"><div class="gh gi nr"><img src="../Images/4bc5de35955c00939383a18fb66b41d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*9vg3-OY14aZN1UpKwIxxZg.png"/></div></a></figure></div></div>    
</body>
</html>