<html>
<head>
<title>An efficient language detection model using Naive Bayes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种高效的朴素贝叶斯语言检测模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-efficient-language-detection-model-using-naive-bayes-85d02b51cfbd?source=collection_archive---------24-----------------------#2020-10-08">https://towardsdatascience.com/an-efficient-language-detection-model-using-naive-bayes-85d02b51cfbd?source=collection_archive---------24-----------------------#2020-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="63ea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个简单的Python语言检测模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/433ec69940844a03c0b4e34c75fe97c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*WyCj0qeyLcvGySq4.jpg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">比利亚纳·约万诺维奇摄于<a class="ae ku" href="https://pixabay.com/it/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2724442" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a></p></figure><p id="26c0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">语言检测(或识别)是自然语言处理的一个迷人的分支。它的目标是创建一个模型，能够检测一个文本是用哪种语言写的。</p><p id="caa5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">数据科学家通常采用神经网络模型来实现这一目标。在本文中，我展示了如何使用朴素贝叶斯模型在Python中创建一个简单的语言检测模型。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="d71d" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">问题是</h1><p id="d971" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">我们要面对的问题是创建一个模型，一旦有了文本，它就能检测出它的语言。文本可以是一个句子、一个单词、一个更复杂的文本等等。例如，输出变量可以是语言代码(如英语的“en”)。</p><p id="756b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">一个好主意是建立一个模型来检测文本的语言，即使该文本包含该模型在训练阶段没有看到的单词。我们想要一个模型，它能够以一种使语言能够正确检测的方式来概括语言的底层结构。</p><p id="b1b6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们看看如何创建这样一个模型。</p><h1 id="41a7" class="ly lz it bd ma mb mv md me mf mw mh mi jz mx ka mk kc my kd mm kf mz kg mo mp bi translated">数据</h1><p id="57d9" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">我要训练这个模型检测三种语言:意大利语、英语和德语。对于意大利语，我将使用我的一个简短的恐怖故事的文本来训练模型，<em class="na"> L'isola del male </em>。对于英语，我将使用这个故事的英文翻译，<em class="na">邪恶之岛</em>。对于德语，我将使用的文本<em class="na">也就是查拉图斯特拉</em>在这里找到的弗里德里希·尼采:<a class="ae ku" href="http://www.nietzschesource.org/#eKGWB/Za-I" rel="noopener ugc nofollow" target="_blank">http://www.nietzschesource.org/#eKGWB/Za-I</a>。我将把这些文档分割成句子，最终的句子数据集将被分割成训练集和测试集。</p><h1 id="d158" class="ly lz it bd ma mb mv md me mf mw mh mi jz mx ka mk kc my kd mm kf mz kg mo mp bi translated">使用字符二元模型进行矢量化</h1><p id="6bb6" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">所以，我们在讨论一个三值类的分类问题，即:it，en，de。这是目标变量。</p><p id="ae0f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，我们来谈谈特点。我要使用的特性是char bigrams，它是一个句子中两个连续字符的集合。例如，考虑“行星”这个词。在这种情况下，字符二元组是“pl”，“la”，“an”，“ne”，“et”。</p><p id="9af4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为什么我们应该使用char二元模型？因为这样会降维。拉丁字母表由26个字母组成。加上这10个数字和一些其他特殊的字符或符号，我们得到大约50个不同的符号。我们可以拥有的字符二元模型的最大数量是50*50 = 2500。</p><p id="43cb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们使用经典的单词驱动的矢量化，我们将拥有更高的维度，因为每种语言可能有数十万个单词，我们可能需要将它们全部矢量化，创建一个包含数千个特征的向量，并遭受维度的<em class="na">诅咒</em>。使用char二元模型，我们最多可以得到2500个组件，它们可以在所有使用拉丁字母的语言中共享。这非常令人印象深刻，因为我们可以使用这个语料库作为使用这种字母表的每种语言的通用特征集。此外，我们没有绑定到预定义的单词语料库，因此我们的模型甚至可以处理从未被训练过的单词，只要它们是由原始训练语料库的字符二元组构成的。</p><p id="8bb7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我们的特殊例子中，三个文档的完整词汇由7062个不同的单词组成。如果我们使用chars char二元模型，我们得到842个特征。我们已经将问题的维度减少了近90%！</p><p id="d231" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">所以，这些就是特色。对于每个句子，我们计算字符二元模型，并计算特定二元模型在句子中出现的次数。这个数字将填充表示句子的相应向量分量。</p><h1 id="11fc" class="ly lz it bd ma mb mv md me mf mw mh mi jz mx ka mk kc my kd mm kf mz kg mo mp bi translated">模型</h1><p id="39d6" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">我要用的模型是多项式朴素贝叶斯。这是一个非常简单的模型，一般来说，当谈到自然语言处理时，朴素贝叶斯非常强大。它几乎没有超参数，所以我们可以专注于预处理阶段，这是最关键的。</p><p id="9025" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">根据scikit-learn文档，多项式朴素贝叶斯可以将计数向量作为输入特征，这正是我们需要的。</p><h1 id="e990" class="ly lz it bd ma mb mv md me mf mw mh mi jz mx ka mk kc my kd mm kf mz kg mo mp bi translated">代码</h1><p id="ea5e" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">让我们导入一些库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ad38" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将要使用的语料库由3个文本文件组成。我们必须清理文本，将其矢量化，然后我们可以训练模型。</p><h2 id="8d70" class="nd lz it bd ma ne nf dn me ng nh dp mi le ni nj mk li nk nl mm lm nm nn mo no bi translated">数据预处理和矢量化</h2><p id="916b" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">首先，我们必须清理我们的文本，以便把它分成单句。让我们编写一个函数，它获取一个文本文件，删除双空格、引号和无用的标点符号，返回一个句子列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5282" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">每个文档都存储在单独的txt文件中。我们可以加载三个文档的句子，创建一个包含所有句子的数组，另一个包含与每个句子相关的语言。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="1eb6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">完整的语料库规模为4195个句子。下面是一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/55f54537dd01cecc3bdaf1e908102a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*yHWEan0ul3vgPsDDx2VQDA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">语料库的一个例子。图片由作者提供。</p></figure><p id="cafe" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如你所见，每个句子都与其语言相关联。</p><p id="e2ce" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">语言在语料库中的分布相当均匀，所以不存在不平衡的类别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ddd33fc803444d48de03fe0744490f7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*oc2IsOzFbgsFlM4kfrLt3w.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">语料库中语言的分布。图片由作者提供。</p></figure><p id="e12b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，我们可以将数据集分为训练集和测试集，并开始处理模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ea94" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，我们必须调用sklearn的CountVectorizer对象，以便为每个char二元模型创建它在每个句子中出现的次数。然后，我们可以创建管道，将我们的数据矢量化，并将其提供给模型，这是一个多项式朴素贝叶斯。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="86a2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，我们可以拟合管道，并在测试集上计算预测:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="cca1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们终于可以看看混淆矩阵了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/b93e948acfb7b46fa09d146e3cc2b2ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*vx6hHj63LqWimtQafo3kug.png"/></div></figure><p id="daec" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">挺斜的。分类误差似乎很低。</p><p id="5163" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们看看分类报告:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/3485555b00a0da3bbc953cf979a124e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*NzCovanRNh4j6TOgTsoN4w.png"/></div></figure><p id="78d2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如你所见，我们达到了97%的整体准确率。如果我们考虑到我们只处理三个文档和一个少于5000条记录的数据集，这是非常令人印象深刻的。</p><h1 id="96b0" class="ly lz it bd ma mb mv md me mf mw mh mi jz mx ka mk kc my kd mm kf mz kg mo mp bi translated">让我们强调模型</h1><p id="bb73" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">现在，让我们强调一下我们的模型。</p><p id="7239" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是三种不同语言的一组句子。“评论”栏是我的一个评论，解释了这个句子的一些特征，包括它的真实语言。“检测到的语言”列是模型预测的语言的ISO代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f3ba" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如我们所看到的，即使对于混合语言的句子，该模型也相当不错。仍然存在一些错误(例如，“超参数”被错误地检测为意大利语)，但是结果看起来健壮且不错。</p><p id="2d62" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">甚至在意大利文和英文文本中都出现的单词“Harrier”也被正确地认为是一个英文单词。</p><h1 id="11a4" class="ly lz it bd ma mb mv md me mf mw mh mi jz mx ka mk kc my kd mm kf mz kg mo mp bi translated">一个简单的API</h1><p id="82f1" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">我已经将模型嵌入到pickle文件中，并使用Flask创建了一个简单的API，将其部署在Heroku上。这是一个用于测试目的的开发API。我善意地鼓励你尝试一下，并给我你的反馈。</p><p id="b927" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">终点是:<strong class="kx iu">https://gianlucamalato.herokuapp.com/text/language/detect/</strong></p><p id="1899" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请求必须是带有“text”键的JSON文档，其值是要处理的文本。该方法是POST。</p><p id="561e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">响应是一个JSON文档，包含“文本”字段中的原始文本和“语言”字段中检测到的语言代码。</p><p id="f69e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是一个如何调用我的API的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="931f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我创建了另一个GET方法来显示模型修改日期和支持的语言:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="520a" class="ly lz it bd ma mb mv md me mf mw mh mi jz mx ka mk kc my kd mm kf mz kg mo mp bi translated">结论</h1><p id="3b7c" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">在本文中，我展示了如何使用朴素贝叶斯创建一个简单的语言检测模型。像往常一样，模型的功能依赖于输入特性，使用char二元模型似乎是个好主意。</p><p id="c935" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你喜欢这个模型，请使用我的API强调它，并给我你的反馈。</p></div></div>    
</body>
</html>