<html>
<head>
<title>How to use Deep Learning for Time Series Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用深度学习进行时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-deep-learning-for-time-series-forecasting-3f8a399cf205?source=collection_archive---------6-----------------------#2020-09-21">https://towardsdatascience.com/how-to-use-deep-learning-for-time-series-forecasting-3f8a399cf205?source=collection_archive---------6-----------------------#2020-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0b4b129c6304f6238a6c223b3e2ff86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNToQNhlfb7i43kBoMHnUQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">资料来源:研究结果——由作者计算</p></figure><div class=""/><div class=""><h2 id="99d9" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">RNN家族的一个应用</h2></div><h2 id="a548" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">介绍</h2><p id="e73b" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated">很长一段时间，我听说时间序列的问题只能用统计方法来逼近(AR[1]，AM[2]，ARMA[3]，ARIMA[4])。这些技术通常由数学家使用，他们试图不断改进这些技术来约束平稳和非平稳的时间序列。</p><p id="dd25" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">几个月前，我的一个朋友(数学家、统计学教授、非平稳时间序列专家)邀请我去验证和改进重建恒星光变曲线的技术。事实上，开普勒卫星[11]像许多其他卫星一样，无法持续测量附近恒星的光通量强度。开普勒卫星在2009年至2016年期间致力于搜索太阳系以外的行星，称为太阳系外行星或系外行星。</p><p id="87e7" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">如你所知，我们将比我们的地球走得更远一点，深入到一次银河之旅中，机器学习将是我们的船只。如你所知，天体物理学一直是我的强烈爱好。</p><blockquote class="ms mt mu"><p id="5592" class="lt lu mr lv b lw mm kj ly lz mn km mb mv mo md me mw mp mg mh mx mq mj mk ml im bi translated">Github上有笔记本:<a class="ae my" href="https://github.com/Christophe-pere/Time_series_RNN" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></blockquote><h2 id="995f" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">RNN，LSTM，GRU，双向，CNN-x</h2><p id="1369" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated">那么我们将乘坐哪艘船来完成这项研究呢？我们将使用递归神经网络(RNN[5])，模型。我们将使用LSTM[6]，GRU[7]，堆叠LSTM，堆叠GRU，双向[8] LSTM，双向GRU，还有CNN-LSTM[9]。对于那些热衷于树家族的人，你可以在这里找到杰森·布朗利<a class="ae my" href="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" rel="noopener ugc nofollow" target="_blank">写的一篇关于XGBoost和时间序列的文章。github </a>上有一个关于时间序列的很好的知识库。</p><p id="d492" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">对于那些不熟悉RNN家族的人来说，把他们看作是具有记忆效应和遗忘能力的学习方法。双向术语来自体系结构，它是关于两个RNN，它们将在一个方向(从左到右)和另一个方向(从右到左)上“读取”数据，以便能够获得长期依赖关系的最佳表示。</p><h2 id="6e6a" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">数据</h2><p id="5f16" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated">正如前面介绍中所说，这些数据对应于几颗恒星的通量测量。事实上，在每一个时间增量(小时)，卫星都会测量来自附近恒星的通量。这种通量或强度，即光强度，随着时间的推移而变化。这有几个原因，卫星的适当运动、旋转、视角等。会有所不同。因此，测量到的光子数量会发生变化，恒星是一个熔化材料球(氢氦聚变)，它有自己的运动，因此光子的发射取决于它的运动。这对应于光强度的波动。</p><p id="fc08" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">但是，也可能有行星，系外行星，扰乱恒星，甚至在恒星和卫星的视线之间通过(凌日法[12])。这条通道遮蔽了恒星，卫星接收到的光子更少，因为它们被从它面前经过的行星阻挡了(一个具体的例子是由于月亮引起的日食)。</p><p id="4222" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">这组通量测量值称为光变曲线。光线曲线是什么样的？以下是一些例子:</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/87b9d33340bf1f91ba0103b691c5ca81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vmqB6hBITI_uNf0SqPg4pA.jpeg"/></div></div></figure><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/f4781f9b5b2b95e68a2cd8ec819f4c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvOp7kwkHLCn-uSAOkmghA.jpeg"/></div></div></figure><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/912b9e36ee0d886e726a6a113520b5fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSydz-0y6xNoi9KUMUqPwA.jpeg"/></div></div></figure><p id="963a" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">恒星与恒星之间的通量差别很大。有些非常吵，而另一些非常稳定。尽管如此，通量还是呈现出异常。在光变曲线中可以看到洞或缺少测量。目标是看看是否有可能在没有测量的情况下预测光曲线的行为。</p><h2 id="1431" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">数据整理</h2><p id="0d13" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated">为了能够使用模型中的数据，有必要进行数据简化。这里将介绍两种，<em class="mr">移动平均线</em>和<em class="mr">窗口法</em>。</p><p id="822b" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated"><strong class="lv jj"> <em class="mr">均线:</em> </strong></p><p id="9fc8" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">移动平均包括取X个连续的点并计算它们的平均值。这种方法允许减少可变性并消除噪声。这也减少了点数，是一种缩减采样方法。</p><p id="cd53" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">下面的函数允许我们通过给出一个用于计算点的平均值和标准偏差的数字来计算一系列点的移动平均值。</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c7d3" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">您可以看到该函数在输入中有3个参数。<strong class="lv jj"> <em class="mr">时间</em> </strong>和<strong class="lv jj"> <em class="mr">通量</em> </strong>是时间序列的<strong class="lv jj"> <em class="mr"> x </em> </strong>和<strong class="lv jj"> <em class="mr"> y </em> </strong>。<strong class="lv jj"> <em class="mr">滞后</em> </strong>是控制点数的参数，用于计算时间和通量的平均值以及通量的标准偏差。</p><p id="367c" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">现在，我们可以看看如何使用这个函数和转换得到的结果。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="025d" class="kx ky ji nh b gy nl nm l nn no"><strong class="nh jj"><em class="mr"># import the packages needed for the study</em></strong><br/>matplotlib inline<br/>import scipy<br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import sklearn<br/>import tensorflow as tf<br/><strong class="nh jj"><em class="mr"># let's see the progress bar</em></strong><br/>from tqdm import tqdm<br/>tqdm().pandas()</span></pre><p id="93a4" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">现在我们需要导入数据。文件<code class="fe np nq nr nh b">kep_lightcurves.csv</code>包含了13颗恒星的数据。每个星形有4列，原始通量(“…_orig”)、重定标通量是原始通量减去平均通量(“…_rscl”)、差值(“…_diff”)和残差(“…_res”)。所以，总共52列。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="706c" class="kx ky ji nh b gy nl nm l nn no"># reduce the number of points with the mean on 20 points<br/>x, y, y_err  = moving_mean(df.index,df["001724719_rscl"], 20)</span></pre><p id="3bb4" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">df.index对应于时间序列的时间<br/> df["001724719_rscl"]重新标度的恒星通量(" 001724719") <br/> lag=20是将计算平均值和标准差的点数</p><p id="4c67" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">前3条光线曲线的结果:</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/63ae5477139f2753118d39a85f230be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2WUUUb5bLxmTUbpY98TgA.png"/></div></div></figure><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0b4b129c6304f6238a6c223b3e2ff86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNToQNhlfb7i43kBoMHnUQ.png"/></div></div></figure><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bcb802abbb54fb79f78784b5fcd062bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DuKp8zgTxZOfPhQNVZMtKg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">前3颗恒星的光变曲线，移动平均值显示25，000到30，000个测量值之间的点</p></figure><p id="c21d" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated"><strong class="lv jj"> <em class="mr">窗口方法:</em> </strong></p><p id="5f66" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">第二种方法是窗口法，它是如何工作的？</p><p id="f2ae" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">你需要取一些点，在前面的例子中是20，计算平均值(与前面的方法没有区别)，这个点是新的时间序列的开始，它在位置20(移动19个点)。但是，不是移动到接下来的20个点，而是将窗口移动一个点，计算前20个点的平均值，并通过向前移动一步来一次又一次地移动。这不是一种下采样方法，而是一种清理方法，因为效果是平滑数据点。</p><p id="547b" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">让我们看看它的代码:</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="07a5" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">您可以像这样轻松地使用它:</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="38b3" class="kx ky ji nh b gy nl nm l nn no"># reduce the number of points with the mean on 20 points<br/>x, y, y_err  = mean_sliding_windows(df.index,df["001724719_rscl"], 40)</span></pre><p id="1b0d" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated"><code class="fe np nq nr nh b">df.index</code>对应于时间序列的时间<br/><code class="fe np nq nr nh b">df[“001724719_rscl”]</code>【001724719】<br/><code class="fe np nq nr nh b">lag=40</code>是将计算平均值和标准差的点的数量</p><p id="feb6" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">现在，看看结果:</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8cd0d2396ccf9761674cc81073bc87f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GdyFVrWzYFiX7CT7SSbMcg.png"/></div></div></figure><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e1ce5b1dd35526873de0629f08b6882a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PNwFWJb0_VX_mRlngl1XZw.png"/></div></div></figure><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3df22e4c7f0b6b5bd24f54173e4e8fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__UICVMgBhwE0VLM6kru1w.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用窗口方法显示25，000和30，000测量值之间的点的前3颗恒星的光变曲线</p></figure><p id="306c" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">嗯，还不错。将滞后设置为40允许在小孔中“预测”或扩展新的时间序列。但是，如果你仔细观察，你会发现在红线的起点和终点有一个分歧。可以改进该函数以避免这些伪像。</p><p id="27a7" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">在研究的其余部分，我们将使用移动平均法获得的时间序列。</p><p id="bf1b" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated"><strong class="lv jj"> <em class="mr">将x轴从数值改为日期:</em> </strong></p><p id="934d" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">如果需要，您可以更改日期轴。开普勒任务开始于2009年3月7日，结束于2017年。<a class="ae my" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> <em class="mr">熊猫</em> </a>有一个叫<code class="fe np nq nr nh b">pd.data_range()</code>的函数，这个函数允许你从一个不断递增的列表中创建日期。</p><p id="20fa" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated"><code class="fe np nq nr nh b">df.index = pd.date_range(‘2009–03–07’, periods=len(df.index), freq=’h’)</code></p><p id="3796" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">这一行代码将创建一个新的索引，频率为几个小时。如果你打印结果(如下),你会发现一个合适的实际时间表。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="af2c" class="kx ky ji nh b gy nl nm l nn no">$ df.index<br/>DatetimeIndex(['2009-03-07 00:00:00', '2009-03-07 01:00:00',<br/>               '2009-03-07 02:00:00', '2009-03-07 03:00:00',<br/>               '2009-03-07 04:00:00', '2009-03-07 05:00:00',<br/>               '2009-03-07 06:00:00', '2009-03-07 07:00:00',<br/>               '2009-03-07 08:00:00', '2009-03-07 09:00:00',<br/>               ...<br/>               '2017-04-29 17:00:00', '2017-04-29 18:00:00',<br/>               '2017-04-29 19:00:00', '2017-04-29 20:00:00',<br/>               '2017-04-29 21:00:00', '2017-04-29 22:00:00',<br/>               '2017-04-29 23:00:00', '2017-04-30 00:00:00',<br/>               '2017-04-30 01:00:00', '2017-04-30 02:00:00'],<br/>              dtype='datetime64[ns]', length=71427, freq='H')</span></pre><p id="3b4b" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">您现在已经有了原始时间序列的良好时间刻度。</p><p id="67cf" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated"><strong class="lv jj"> <em class="mr">生成数据集</em> </strong></p><p id="2421" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">因此，现在已经创建了数据归约函数，我们可以将它们合并到另一个函数中(如下所示)，该函数将考虑初始数据集和数据集中存在的恒星名称(这一部分可以在函数中完成)。</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6c15" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">要生成新的数据框，请执行以下操作:</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="faa7" class="kx ky ji nh b gy nl nm l nn no">stars = df.columns<br/>stars = list(set([i.split("_")[0] for i in stars]))<br/>print(f"The number of stars available is: {len(stars)}")<br/>&gt; The number of stars available is: 13</span></pre><p id="dac4" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">我们有4种数据类型的13颗星，对应于52列。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="2c8f" class="kx ky ji nh b gy nl nm l nn no">df_mean, df_slide = reduced_data(df,stars)</span></pre><p id="cf8b" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">很好，在这一点上，您有两个新的数据集，其中包含通过移动平均和窗口方法减少的数据。</p><h2 id="26b5" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">方法</h2><p id="f165" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated"><strong class="lv jj"> <em class="mr">准备数据:</em> </strong></p><p id="9f0d" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">为了使用机器学习算法来预测时间序列，必须相应地准备数据。数据不能仅仅设置在(x，y)数据点。数据必须采用序列[x1，x2，x3，…，xn]和预测值y的形式。</p><p id="65ca" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">下面的函数向您展示了如何设置数据集:</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4e1a" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">开始前有两件重要的事情。</p><p id="bd4f" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated"><em class="mr"> 1-数据需要重标度</em> <br/>深度学习算法在数据在[0，1]范围内预测时间序列时效果更好。简单来说，<code class="fe np nq nr nh b"><a class="ae my" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html" rel="noopener ugc nofollow" target="_blank">scikit-learn</a></code>提供了函数<code class="fe np nq nr nh b"><a class="ae my" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html" rel="noopener ugc nofollow" target="_blank">MinMaxScaler</a>()</code>。您可以配置<code class="fe np nq nr nh b">feature_range</code>参数，但默认情况下需要<code class="fe np nq nr nh b">(0, 1)</code>。并清除nan值的数据(如果你不删除nan值，你的损失函数将输出nan)。</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="091e" class="kx ky ji nh b gy nl nm l nn no"><strong class="nh jj"><em class="mr"># normalize the dataset </em></strong><br/>num = 2 <strong class="nh jj"><em class="mr"># choose the third star in the dataset</em></strong><br/>values = df_model[stars[num]+"_rscl_y"].values <strong class="nh jj"><em class="mr"># extract the list of values</em></strong><br/>scaler = MinMaxScaler(feature_range=(0, 1)) <strong class="nh jj"><em class="mr"># make an instance of MinMaxScaler</em></strong><br/>dataset = scaler.fit_transform(values[~np.isnan(values)].reshape(-1, 1)) <strong class="nh jj"><em class="mr"># the data will be clean of nan values, rescaled and reshape</em></strong></span></pre><p id="30a0" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated"><em class="mr"> 2-数据需要转换成x列表和y列表<br/></em><em class="mr"/>现在，我们将通过<code class="fe np nq nr nh b">create_values()</code>函数来为模型生成数据。但是，在此之前，我更喜欢通过以下方式保存原始数据:</p><p id="9238" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated"><code class="fe np nq nr nh b">df_model = df_mean.save()</code></p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="f7a0" class="kx ky ji nh b gy nl nm l nn no"><strong class="nh jj"><em class="mr"># split into train and test sets</em></strong><br/>train_size = int(len(dataset) * 0.8)   <strong class="nh jj"><em class="mr"># make 80% data train</em></strong><br/>train = dataset[:train_size] <strong class="nh jj"><em class="mr"># set the train data</em></strong><br/>test  = dataset[train_size:] <strong class="nh jj"><em class="mr"># set the test data </em></strong><br/><strong class="nh jj"><em class="mr"># reshape into X=t and Y=t+1<br/></em></strong>look_back = 20<br/>trainX, trainY = create_dataset(train, look_back)<br/>testX, testY = create_dataset(test, look_back)<br/><strong class="nh jj"><em class="mr"># reshape input to be [samples, time steps, features]</em></strong><br/>trainX = np.reshape(trainX, (trainX.shape[0], trainX.shape[1], 1))<br/>testX = np.reshape(testX, (testX.shape[0], testX.shape[1], 1))</span></pre><p id="f84a" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">看一看结果:</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="604a" class="kx ky ji nh b gy nl nm l nn no">trainX[0]<br/>&gt; array([[0.7414906],<br/>       [0.76628096],<br/>       [0.79901113],<br/>       [0.62779976],<br/>       [0.64012722],<br/>       [0.64934765],<br/>       [0.68549234],<br/>       [0.64054092],<br/>       [0.68075644],<br/>       [0.73782449],<br/>       [0.68319294],<br/>       [0.64330245],<br/>       [0.61339268],<br/>       [0.62758265],<br/>       [0.61779702],<br/>       [0.69994317],<br/>       [0.64737128],<br/>       [0.64122564],<br/>       [0.62016833],<br/>       [0.47867125]]) <strong class="nh jj"><em class="mr"># 20 values in the first value of x train data<br/></em></strong>trainY[0]<br/>&gt;<strong class="nh jj"><em class="mr"> </em></strong>array([0.46174275]) <strong class="nh jj"><em class="mr"># the corresponding y value</em></strong></span></pre><p id="5d3e" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated"><strong class="lv jj"> <em class="mr">指标</em> </strong></p><p id="1de9" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">我们用什么标准来预测时间序列？我们可以使用平均绝对误差和均方误差。它们由函数给出:</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4ee7" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">您需要首先导入函数:</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="5574" class="kx ky ji nh b gy nl nm l nn no">from sklearn.metrics import mean_absolute_error, mean_squared_error</span></pre><p id="9b72" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated"><strong class="lv jj"> <em class="mr"> RNNs: </em> </strong></p><p id="35cf" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">你可以用几行代码轻松实现带有Keras的RNN家族。在这里，您可以使用此功能来配置您的RNN。您需要首先从Keras导入不同的模型，例如:</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="c642" class="kx ky ji nh b gy nl nm l nn no"><strong class="nh jj"><em class="mr"># import some packages</em></strong><br/>import tensorflow as tf<br/>from keras.layers import SimpleRNN, LSTM, GRU, Bidirectional, Conv1D, MaxPooling1D, Dropout</span></pre><p id="87d7" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">现在，我们有从Keras进口的模型。下面的函数可以生成一个简单的模型(<code class="fe np nq nr nh b">SimpleRNN</code>、<code class="fe np nq nr nh b">LSTM</code>、<code class="fe np nq nr nh b">GRU</code>)。或者，两个模型(相同的)可以堆叠，或用于<code class="fe np nq nr nh b">Bidirectional</code>或两个双向模型的堆叠。还可以用<code class="fe np nq nr nh b">MaxPooling1D </code>和<code class="fe np nq nr nh b">dropout</code>加上CNN部分(<code class="fe np nq nr nh b">Conv1D</code>)。</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ef85" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">该函数计算训练部分和测试部分的度量，并在数据帧中返回结果。看你如何用五个例子。</p><p id="6f56" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">LSTM:</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="5687" class="kx ky ji nh b gy nl nm l nn no"><strong class="nh jj"><em class="mr"># train the model and compute the metrics</em></strong><br/>&gt; x_train_predict_lstm, y_train_lstm,x_test_predict_lstm, y_test_lstm, res= <strong class="nh jj">time_series_deep_learning</strong>(train_x, train_y, test_x, test_y, model_dl=<strong class="nh jj">LSTM </strong>,  unit=12, look_back=20)<br/><strong class="nh jj"><em class="mr"># plot the resuts of the prediction</em></strong><br/>&gt; plotting_predictions(dataset, look_back, x_train_predict_lstm,  x_test_predict_lstm)<br/><strong class="nh jj"><em class="mr"># save the metrics per model in the dataframe df_results</em></strong><br/>&gt; df_results = df_results.append(res)</span></pre><p id="3bcd" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">GRU:</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="c878" class="kx ky ji nh b gy nl nm l nn no"><strong class="nh jj"><em class="mr"># train the model and compute the metrics</em></strong><br/>&gt; x_train_predict_lstm, y_train_lstm,x_test_predict_lstm, y_test_lstm, res= <strong class="nh jj">time_series_deep_learning</strong>(train_x, train_y, test_x, test_y, model_dl=<strong class="nh jj">GRU</strong>,  unit=12, look_back=20)</span></pre><p id="3883" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">堆栈LSTM:</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="2461" class="kx ky ji nh b gy nl nm l nn no"><strong class="nh jj"><em class="mr"># train the model and compute the metrics</em></strong><br/>&gt; x_train_predict_lstm, y_train_lstm,x_test_predict_lstm, y_test_lstm, res= <strong class="nh jj">time_series_deep_learning</strong>(train_x, train_y, test_x, test_y, model_dl=<strong class="nh jj">LSTM </strong>,  unit=12, look_back=20, <strong class="nh jj">stacked=True</strong>)</span></pre><p id="0760" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">双向LSTM:</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="6250" class="kx ky ji nh b gy nl nm l nn no"><strong class="nh jj"><em class="mr"># train the model and compute the metrics</em></strong><br/>&gt; x_train_predict_lstm, y_train_lstm,x_test_predict_lstm, y_test_lstm, res= <strong class="nh jj">time_series_deep_learning</strong>(train_x, train_y, test_x, test_y, model_dl=<strong class="nh jj">LSTM </strong>,  unit=12, look_back=20, <strong class="nh jj">bidirection=True</strong>)</span></pre><p id="4e3a" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">美国有线电视新闻网LSTM报道:</p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="447d" class="kx ky ji nh b gy nl nm l nn no"><strong class="nh jj"><em class="mr"># train the model and compute the metrics</em></strong><br/>&gt; x_train_predict_lstm, y_train_lstm,x_test_predict_lstm, y_test_lstm, res= <strong class="nh jj">time_series_deep_learning</strong>(train_x, train_y, test_x, test_y, model_dl=<strong class="nh jj">LSTM </strong>,  unit=12, look_back=20, <strong class="nh jj">cnn=True</strong>)</span></pre><h2 id="0a60" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结果</h2><p id="bff8" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated">考虑到数据，这个结果相当不错。我们可以看到，深度学习RNN可以再现具有良好准确性的数据。下图显示了LSTM模型的预测结果。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/d4cd4e505d9134b1ab8356c21e3987f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dFLAin8fHnbENhG2hYXSw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">LSTM预言</p></figure><p id="9445" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated"><em class="mr">表1:不同RNN模型的结果，显示了MAE和MSE指标</em></p><pre class="na nb nc nd gt ng nh ni nj aw nk bi"><span id="349a" class="kx ky ji nh b gy nl nm l nn no">        Name    | MAE Train | MSE Train | MAE Test | MSE Test<br/>--------------------------------------------------------------------<br/>            GRU |   4.24    |   34.11   |   4.15   |   31.47 <br/>           LSTM |   4.26    |   34.54   |   4.16   |   31.64 <br/>      Stack_GRU |   4.19    |   33.89   |   4.17   |   32.01<br/>      SimpleRNN |   4.21    |   34.07   |   4.18   |   32.41<br/>           LSTM |   4.28    |   35.1    |   4.21   |   31.9<br/>         Bi_GRU |   4.21    |   34.34   |   4.22   |   32.54<br/>  Stack_Bi_LSTM |   4.45    |   36.83   |   4.24   |   32.22<br/>        Bi_LSTM |   4.31    |   35.37   |   4.27   |   32.4<br/>Stack_SimpleRNN |   4.4     |   35.62   |   4.27   |   33.94<br/>      SimpleRNN |   4.44    |   35.94   |   4.31   |   34.37 <br/>     Stack_LSTM |   4.51    |   36.78   |   4.4    |   34.28<br/> Stacked_Bi_GRU |   4.56    |   37.32   |   4.45   |   35.34<br/>       CNN_LSTM |   5.01    |   45.85   |   4.55   |   36.29<br/>        CNN_GRU |   5.05    |   46.25   |   4.66   |   37.17 <br/>  CNN_Stack_GRU |   5.07    |   45.92   |   4.7    |   38.64</span></pre><p id="2256" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">表1显示了RNN家族的训练集和测试集的平均绝对误差(MAE)和均方误差(MSE)。GRU在测试集上显示出最好的结果，MAE为4.15，MSE为31.47。</p><h2 id="9fa3" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">讨论</h2><p id="6192" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated">结果很好，重现了不同恒星的光变曲线(见笔记本)。然而，波动并没有完全再现，峰值没有相同的强度，通量略有偏移。可以通过注意机制(变形金刚[10])进行潜在的纠正。另一种方法是调整模型、层数(堆栈)、单元数(单元)、不同RNN算法的组合、新的损失函数或激活函数等。</p><h2 id="26b6" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结论</h2><p id="ee65" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated">本文展示了将所谓的人工智能方法与时间序列相结合的可能性。记忆算法的力量(RNN、LSTM、GRU)使得精确重现事件的零星波动成为可能。在我们的例子中，恒星通量表现出相当强烈和显著的波动，这些方法已经能够捕捉到。</p><p id="f36a" class="pw-post-body-paragraph lt lu ji lv b lw mm kj ly lz mn km mb lg mo md me lk mp mg mh lo mq mj mk ml im bi translated">这项研究表明，时间序列不再保留给统计方法，如ARIMA[4]模型。</p><h2 id="d9b7" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">参考</h2><p id="1a5a" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated">[1] <a class="ae my" href="https://en.wikipedia.org/wiki/Autoregressive_model" rel="noopener ugc nofollow" target="_blank">自回归模型，维基百科</a><br/>【2】<a class="ae my" href="https://en.wikipedia.org/wiki/Moving-average_model" rel="noopener ugc nofollow" target="_blank">移动平均模型，维基百科</a><br/>【3】彼得·惠特尔，1950。<em class="mr">时间序列分析中的假设检验。</em>论文<br/>【4】阿尔贝托·卢塞诺&amp;丹尼尔·培尼亚，2008。<em class="mr">自回归综合移动平均(ARIMA)建模</em>。威利在线图书馆。<a class="ae my" href="https://doi.org/10.1002/9780470061572.eqr276" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1002/9780470061572.eqr276</a><br/>【5】鲁梅尔哈特，戴维E. <em class="mr">等著</em>，1986年。<em class="mr">通过反向传播误差学习表征</em>。<em class="mr">性质</em>。323(6088):533–536。<a class="ae my" href="https://ui.adsabs.harvard.edu/abs/1986Natur.323..533R" rel="noopener ugc nofollow" target="_blank">自然杂志..533R </a>。<br/>[6]hoch Reiter，Sepp&amp;schmid Huber，于尔根，1997年。<em class="mr">长短期记忆</em>。<em class="mr">神经计算</em>。<strong class="lv jj">9</strong>(8):1735–1780。<a class="ae my" href="https://en.wikipedia.org/wiki/Doi_(identifier)" rel="noopener ugc nofollow" target="_blank">土井</a>:<a class="ae my" href="https://doi.org/10.1162%2Fneco.1997.9.8.1735" rel="noopener ugc nofollow" target="_blank">10.1162/neco . 1997 . 9 . 8 . 1735</a><br/>【7】Cho，KyungHyun <em class="mr">等人</em>，2014。<em class="mr">门控递归神经网络对序列建模的经验评估</em>。<a class="ae my" href="https://en.wikipedia.org/wiki/ArXiv_(identifier)" rel="noopener ugc nofollow" target="_blank">arXiv</a>:<a class="ae my" href="https://arxiv.org/abs/1412.3555" rel="noopener ugc nofollow" target="_blank">1412.3555</a><br/>【8】m .舒斯特&amp; K.K .帕利瓦尔，1997年。<em class="mr">双向递归神经</em>网络。IEEE信号处理汇刊，第45卷，第11期，第2673-2681页。DOI<strong class="lv jj">:</strong><a class="ae my" href="https://doi.org/10.1109/78.650093" rel="noopener ugc nofollow" target="_blank">10.1109/78.650093</a><br/>【9】塔拉·n·塞纳特<em class="mr">等人</em>，2014。<em class="mr">卷积、长短期记忆、全连接深度神经网络</em>。<a class="ae my" href="https://static.googleusercontent.com/media/research.google.com/fr//pubs/archive/43455.pdf" rel="noopener ugc nofollow" target="_blank">https://static . Google user content . com/media/research . Google . com/fr//pubs/archive/43455 . pdf</a><br/>【10】阿希什·瓦斯瓦尼<em class="mr">等人</em>，2017。你需要的只是关注。<a class="ae my" href="https://arxiv.org/abs/1706.03762" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1706.03762</a><br/>【11】<a class="ae my" href="https://www.nasa.gov/mission_pages/kepler/overview/index.html" rel="noopener ugc nofollow" target="_blank">开普勒任务，美国宇航局</a></p></div></div>    
</body>
</html>