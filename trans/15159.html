<html>
<head>
<title>The Art of Recursion; a connection to infinity.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归的艺术；与无限的联系。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-art-of-recursion-a-connection-to-infinity-622292be0089?source=collection_archive---------38-----------------------#2020-10-18">https://towardsdatascience.com/the-art-of-recursion-a-connection-to-infinity-622292be0089?source=collection_archive---------38-----------------------#2020-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9bcb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">艺术、数学和编程中的递归之美。</h2></div><p id="c484" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">不久前，我使用PIP将一些python包安装到一个新环境中。顾名思义，PIP是Python中安装和管理包的标准包。出于好奇，我决定谷歌一下PIP代表什么…PIP = PIP安装Python。这让我陷入了递归首字母缩略词的<em class="ln">螺旋</em>——首字母缩略词指的是它自己。虽然递归首字母缩略词的早期例子似乎来自计算机科学领域，但现在也有一些组织使用递归名称<em class="ln">(见:VISA和FARM)。</em></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/f4d10b15d257f1099da71e3f51b038fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*_BvRjwilTNIoi7kviB5lKA.jpeg"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">来源:阿尔夫·范·比姆/ CC0 ( <a class="ae ma" href="https://commons.wikimedia.org/wiki/File:Droste_Cacao_Alcalinise_blikje,_foto4.JPG" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</p></figure><p id="f2c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">递归也可以在视觉上出现，例如上面的Droste可可罐。递归的想法是非常神奇的，因为即使它超出了我们所看到的，甚至超出了我们所画出的，在理论上，递归实体是无限扩展的。这就像站在两面镜子中间，看着自己的同一个影像延伸到一个无尽的不存在的(至少对我们的肉眼来说)走廊。</p><blockquote class="mb"><p id="08cf" class="mc md it bd me mf mg mh mi mj mk ld dk translated">递归的威力显然在于用有限的语句定义无限的对象集的可能性。同样，一个有限的递归程序可以描述无限数量的计算，即使这个程序不包含显式的重复。</p><p id="5d97" class="mc md it bd me mf mg mh mi mj mk ld dk translated">— <a class="ae ma" href="https://en.wikipedia.org/wiki/Niklaus_Wirth" rel="noopener ugc nofollow" target="_blank">尼古拉斯·沃斯</a>，<em class="ml">算法+数据结构=程序</em>，1976<a class="ae ma" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)#cite_note-3" rel="noopener ugc nofollow" target="_blank">【3】</a></p></blockquote><h2 id="c4c7" class="mm mn it bd mo mp mq dn mr ms mt dp mu kr mv mw mx kv my mz na kz nb nc nd ne bi translated">数学和计算机科学中的递归</h2><p id="f31f" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">递归是数学和计算机科学中的一个重要分支。斯坦福哲学百科全书将递归函数定义为这样一种函数，它的“值是由应用于较小自变量的相同函数的应用来定义的”。递归的强大和美丽在于这个函数的强大。这个函数本身可能并不简单，但是一旦你破解了这个代码，它就是一个强大的函数。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="bc18" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">递归在行动中——递归在数学和计算机科学中的应用。</p><p id="f625" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> A .数学上:</strong>递归函数为数学归纳法提供了一个范围，一种<strong class="kk iu">数学上的工整证明技术</strong>。(递归函数的结果可以是<em class="ln">美学上令人愉悦的</em>，例如斐波那契螺旋。)<br/> <strong class="kk iu"> B .在计算机科学中:</strong>递归是一种强大的算法工具，用于<strong class="kk iu">解决否则必须迭代解决的问题</strong>，需要跟踪迭代的每个实例的状态。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/2209a2887c2b88c7ba201afa06d4501b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YfuYekzMIaMMewmLcDt61g.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">斐波纳契螺旋:不管你放大多少，你最终都会得到同样的图像。斐波那契螺旋中的比例被称为“黄金比例”。这个比例在自然和艺术中都能找到！来源:维基共享资源</p></figure><h1 id="0ad1" class="nw mn it bd mo nx ny nz mr oa ob oc mu jz od ka mx kc oe kd na kf of kg nd og bi translated">A.递归序列&amp;归纳法证明</h1><p id="1296" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">数学中的<em class="ln">序列</em>是指一系列数字A₁、A₂、A₃…An.<br/><em class="ln">递归序列</em>是列表中的每个条目由列表中先前的条目定义的序列。例如A₃ = 3A₂-2A₁.A₁和A₂需要先被分配一个号码。</p><p id="e66d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更一般地说，上面的例子将被定义为:<br/><strong class="kk iu"><em class="ln">x</em>n = 3<em class="ln">x</em>n-₁-2<em class="ln">x</em>n-₂对于所有n &gt; 2和<em class="ln"> X </em> ₁ =某数a，<em class="ln"> X </em> ₂ =某数B </strong>。<em class="ln">(序列中的前两个条目必须定义为递归公式依赖于这两个数字。)</em></p><p id="90f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">斐波那契数列</strong>是著名的递归数列，定义为:<br/> Fn = Fn-₁ + Fn-₂，对于所有n个&gt; 2。其中F₁ = 1，F₂ =1。</p><p id="e043" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">递归的威力就在这里:你会如何寻找A₃₀₀₀₀₀₀₀的值？你可以首先计算A₁到A₂₉₉₉₉₉₉₉.的价值<em class="ln">不理想</em>，除非你是超级计算机？即使是超级计算机，理论上也有极限。介绍递归序列的<strong class="kk iu">封闭形式</strong>。这是一种表示一个序列的一个条目的值的方式，不依赖于前面的值！</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/2a3a26220a8f2b2edd779a26749ae199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*mTGOw0icS9iK-9dUAFF1ag.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">斐波纳契数列的封闭形式。Fn由n定义，而不是序列的任何前面的值。</p></figure><p id="374c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">寻找递归关系的封闭形式是另一天的主题。应该注意的是<em class="ln">不是所有的递归序列都有一个封闭形式</em>(如果你设法找到一个，那会让你非常出名！！).所以让我们首先假设我们已经为封闭形式确定了一个<em class="ln">表达式</em>。</p><p id="c207" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要证明这个表达式确实适用于序列中的所有值<em class="ln">，并且将使用<strong class="kk iu">数学归纳法来证明。</strong>这个证明是优雅的，因为你<strong class="kk iu">只需要证明<em class="ln">对某些值k </em> </strong> <em class="ln">成立，而viola，你已经</em> <strong class="kk iu"> <em class="ln">证明了这对于序列中的所有值</em> </strong> <em class="ln">成立！</em></em></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oi"><img src="../Images/910ae3df2c43127bcce1119c5e166ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rlLSCz7ibHG-7SgSXlP-lQ.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">图片作者。来自LSE《抽象数学导论》2016的例子。</p></figure><p id="f009" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本上，逻辑流程是这样的— <br/> 1。首先假设该表达式适用于直到kᵗʰ条目的所有条目(k是任意数)<br/> 2。然后证明它对后面的条目成立；即(k+1)ᵗʰ条目<br/> 3。因为k是任意选择的，所以它可以是任何整数。在我们开始证明之前，我们还表明它适用于构建序列的前两个条目(n=1，n=2)。<strong class="kk iu">逻辑在整个序列中递归流动，因此通过数学归纳法，闭合形式对n的所有值(即序列中的所有条目)都成立。</strong></p><blockquote class="oj ok ol"><p id="3295" class="ki kj ln kk b kl km ju kn ko kp jx kq om ks kt ku on kw kx ky oo la lb lc ld im bi translated">用<a class="ae ma" href="https://en.wikipedia.org/wiki/Niklaus_Wirth" rel="noopener ugc nofollow" target="_blank">尼古拉斯·沃斯</a>的话说，我们已经“用有限的语句定义了无限的对象集合”。</p></blockquote><h1 id="0878" class="nw mn it bd mo nx ny nz mr oa ob oc mu jz od ka mx kc oe kd na kf of kg nd og bi translated">B.递归函数和分治算法</h1><p id="ea30" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">在一些编程问题中，我们知道我们想要达到的目标，但是<strong class="kk iu">可能不知道需要多少步骤，或者正确的路径</strong>。这是因为<em class="ln">环境会改变</em>并且健壮的算法应该不管环境如何都工作。这就是递归可以帮助我们解决这些大问题的地方。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi op"><img src="../Images/d0aaa4ef0970acbc86de586f1b9ab2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uc3Y_N3O2vVoenYsSL9CGA.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">来源:<a class="ae ma" href="https://introcs.cs.princeton.edu/java/23recursion/" rel="noopener ugc nofollow" target="_blank">https://introcs.cs.princeton.edu/java/23recursion/</a>(无意侵犯版权)</p></figure><p id="97ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编程中的递归与我们在自然界中看到的分支没有什么不同——每个分支都分支成更多的分支，向外延伸，最终覆盖一大片区域(例如，树、树根、灯光、河流三角洲)。在每一步，都必须根据一套固定的规则做出决定，这套规则适用于每一步。例如，在根中，新的分枝可能向土壤更肥沃的区域生长。这种情况循环发生，直到植物的根部伸展以给植物提供足够的养分，或者没有生长的空间。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oq"><img src="../Images/53c5aab14e0f0047590ba3cd0ff0e46e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wo72ObE3_AOB7tgvPIDAXw.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">来源:LSE算法与编程2019</p></figure><p id="260d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样的逻辑也适用于递归函数。破解的代码是这样的:<strong class="kk iu">‘每一步应用的规则集是什么；</strong>和<strong class="kk iu">我们何时停止拓展业务？</strong></p><p id="eeaa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这本身就不是一个小问题。然而，一旦你能想出那个问题的答案，大多数编程语言都允许<em class="ln">递归函数</em>，那是一个可以调用自身的<em class="ln">函数。</em>这有助于执行你所确定的规则来灵活地解决问题。(我在这里要提醒的是，递归可能并不总是解决编程问题的最佳方式，事实上可能更复杂，但那是另一个故事了。)</p><p id="c27f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们举个例子Python中的MergeSort算法。MergeSort是一种按升序对数字进行排序的算法。</p><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="45cb" class="mm mn it os b gy ow ox l oy oz">def MergeSort(A):                  # Create the MergeSort algorithm<br/>    if len(A) &lt;= 1:<br/>    return A</span><span id="c34a" class="mm mn it os b gy pa ox l oy oz">    m = len(A) // 2<br/>    left = MergeSort(A[:m])        # Sort the left half of the list<br/>    right = MergeSort(A[m:])       # Sort the right half of the list</span><span id="c2bd" class="mm mn it os b gy pa ox l oy oz">    return Merge(left , right)     # merges the left and right<br/>                                     elements which are both sorted</span></pre><p id="2beb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可能首先会让人难以理解，我将把算法的细节留到以后再说。<br/> <strong class="kk iu">但基本概念依旧— <br/> </strong> 1。规则是:在每一步，将列表分成两半，并对每一半进行排序。然后，使用合并规则合并每个排序后的一半。Merge本身是一个函数，定义为按照升序合并两个排序列表。<br/> 2。<strong class="kk iu">递归地将给定的列表分成两半，直到列表只包含一个元素。<br/> 3。然后<strong class="kk iu">递归组合</strong>排序后的一半，直到整个列表被排序。</strong></p><p id="b59c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们不需要定义<em class="ln">划分列表的次数，</em>也不需要定义<em class="ln">要采取的一组特定的固定步骤。</em>这使得算法适用于任意数字组合或任意长度的列表。</p><blockquote class="oj ok ol"><p id="3350" class="ki kj ln kk b kl km ju kn ko kp jx kq om ks kt ku on kw kx ky oo la lb lc ld im bi translated">再一次，用尼古拉斯·沃斯的话来说，“一个有限的递归程序可以描述无限次的计算，即使这个程序不包含显式的重复”。</p></blockquote></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="a425" class="nw mn it bd mo nx pb nz mr oa pc oc mu jz pd ka mx kc pe kd na kf pf kg nd og bi translated">太久没读了；</h1><p id="5803" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">递归可以在自然界中观察到，在河流三角洲中树木伸展树枝或溪流的方式。递归也存在于艺术中，既有显式的(例如在Droste tin设计中)，也有隐式的(例如艺术中的斐波那契螺旋和比率)。</p><p id="89a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在数学和计算机科学中，递归是一种强大的方式，通过定义一组有限的规则或提供有限的证明来达到无限。</p><p id="f8b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在数学中的递归序列中，递归允许我们<strong class="kk iu">证明该表达式对序列的无限项</strong>成立，通过证明它对某些项成立。</p><p id="1052" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在编程中，递归函数<strong class="kk iu">允许我们用一组有限的规则解决可能没有完全定义的问题</strong>。</p><p id="cb92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">递归帮助我们在有限的时间内达到无限。 </p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="245a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章献给我的初中老师，王老师，她教会了我们数学是美丽的。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="a47a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">斯坦福哲学百科全书:<a class="ae ma" href="https://plato.stanford.edu/entries/recursive-functions/" rel="noopener ugc nofollow" target="_blank">https://plato.stanford.edu/entries/recursive-functions/</a></p><p id="7247" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他资源:【https://www.youtube.com/watch?v=PXwStduNw14】<a class="ae ma" href="https://www.youtube.com/watch?v=PXwStduNw14" rel="noopener ugc nofollow" target="_blank"/>Eddie Woo关于<em class="ln">数学是一种意义</em>的精彩ted演讲。</p></div></div>    
</body>
</html>