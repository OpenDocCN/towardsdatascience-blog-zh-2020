<html>
<head>
<title>Advanced Tensorflow Data Input Pipelines: Handling Time Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级Tensorflow数据输入管道:处理时间序列</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/advanced-tensorflow-data-input-pipelines-handling-time-series-e990717d0089?source=collection_archive---------16-----------------------#2020-09-25">https://towardsdatascience.com/advanced-tensorflow-data-input-pipelines-handling-time-series-e990717d0089?source=collection_archive---------16-----------------------#2020-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="70ef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提取标签、多变量序列窗口、多个TF记录文件碎片和其他处理顺序数据的有用技巧</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c8483234dae322e545049bba143815a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OOPQQ15DVNGjdXwfrMmT9g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://pixabay.com/photos/grow-blossom-time-lapse-sequence-73353/" rel="noopener ugc nofollow" target="_blank">图片来自Pixabay的stux</a></p></figure><p id="827f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.tensorflow.org/guide/data" rel="noopener ugc nofollow" target="_blank"> tf.data.Dataset </a> API是一个非常高效的管道构建器。时序任务的正确实现可能有点棘手。在本文中，我们将深入探讨常见任务:</p><ul class=""><li id="1897" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">窗口标记数据</li><li id="b071" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通过前瞻设置未标记数据的窗口</li><li id="c279" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">分片TF记录文件提高效率和无数据丢失的技巧</li></ul><p id="e129" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧！</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="6d0e" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">窗口标记数据</h1><p id="0191" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">有了数据集api，这很容易做到。假设以下配置。输入特征为<code class="fe nk nl nm nn b">a</code>，标签为<code class="fe nk nl nm nn b">b</code>。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="9618" class="ns mo iq nn b gy nt nu l nv nw">a, b<br/>1, 0<br/>2, 0<br/>3, 1<br/>4, 0<br/>5, 0<br/>6, 1</span></pre><p id="836d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每一行都可以用一个张量形状的<code class="fe nk nl nm nn b">(2,)</code>来描述。所以我们的数据集大小为<code class="fe nk nl nm nn b">(6, 2)</code>。</p><p id="8e81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，用一个窗口大小的<code class="fe nk nl nm nn b">2</code>，产生训练数据。这看起来像是:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="3ec6" class="ns mo iq nn b gy nt nu l nv nw">1, 2 -&gt; 0 (label of row 2)<br/>2, 3 -&gt; 1 (label of row 3)<br/>4, 5 -&gt; 0 ...</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="68dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">.window()</code>函数实际上产生了一组数据集。这就是为什么我们需要做一个<code class="fe nk nl nm nn b">.flat_map(batch)</code>运算来得到一系列我们可以统一处理的张量。</p><h1 id="317c" class="mn mo iq bd mp mq nz ms mt mu oa mw mx jw ob jx mz jz oc ka nb kc od kd nd ne bi translated">通过前瞻设置未标记数据的窗口</h1><p id="c1ae" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">有时你只想预测一个序列的下一个滴答。这可以在没有标签的情况下完成。对于输入数据集:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="5765" class="ns mo iq nn b gy nt nu l nv nw">a<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6</span></pre><p id="6fbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">训练对将是(同样，窗口大小为<code class="fe nk nl nm nn b">2</code>):</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="5e47" class="ns mo iq nn b gy nt nu l nv nw">1, 2 -&gt; 3<br/>2, 3 -&gt; 4<br/>4, 5 -&gt; 6</span></pre><p id="ccd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们尝试采用前面的方法，使用大小为<code class="fe nk nl nm nn b">3</code>的窗口，保留最后一个元素作为标签。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><blockquote class="oe"><p id="a812" class="of og iq bd oh oi oj ok ol om on lr dk translated">数据丢失</p></blockquote><p id="8cbe" class="pw-post-body-paragraph kw kx iq ky b kz oo jr lb lc op ju le lf oq lh li lj or ll lm ln os lp lq lr ij bi translated">实现这一点的最佳方法是创建2个类似的数据集管道，窗口大小为<code class="fe nk nl nm nn b">2</code>，但其中一个管道滞后于前端。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="5f34" class="mn mo iq bd mp mq nz ms mt mu oa mw mx jw ob jx mz jz oc ka nb kc od kd nd ne bi translated">分片TF记录文件提高效率和无数据丢失的技巧</h1><p id="1ab4" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">大规模深度学习输入管道的典型方式是将输入数据分割成1-100兆字节范围内的文件，这些文件可以顺序和并行读取。这意味着，通过只使用旋转驱动器而不是固态硬盘来保持性能，存储服务器成本大幅降低。</p><p id="c62f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种做法的一个非常常见的例子是将TF记录存储在Hadoop文件系统或基于存储桶的公共云解决方案(如Google Cloud Storage)中。</p><p id="d08d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将X-Y对数据集(如图像)分割成多个文件是很简单的。对于手头的时间序列窗口任务，保持序列完整性和避免数据丢失变得很棘手。</p><p id="d3eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个简单的例子。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="9f94" class="ns mo iq nn b gy nt nu l nv nw">File 1<br/>----------<br/>a, b<br/>1, 1<br/>1, 2<br/>1, 3</span><span id="2417" class="ns mo iq nn b gy ot nu l nv nw">File 2<br/>----------<br/>a, b<br/>1, 4<br/>1, 5<br/>1, 6<br/>1, 7</span></pre><p id="8ea2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，你可以得到一个文件包，把它们加载起来，直接推给训练。但是你有很多问题。</p><p id="d2d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，为了获得最佳性能，2+个碎片之间的顺序是不确定的。这意味着您的数据将<strong class="ky ir">无序，</strong>类似于位置不变的并行算法，如map-reduce。</p><p id="18ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您最终将同时打开文件1的第1行和文件2的第2行，而另一个工人同时打开文件1的第2行和文件2的第1行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5daa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">故障部分现已修复。但是还有一个问题需要仔细检查。缺少<strong class="ky ir">跨文件数据</strong>。如果文件2是文件1的序列延续，您需要确保您的回顾窗口包括这两个文件之间的链接。否则，你会丢失数据点。</p><p id="1c9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着，当<code class="fe nk nl nm nn b">tf.data.Dataset</code>解析分片文件时，为您的模型生成的最终数据集需要包括(让我们为2个窗口演示这一点):</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="287c" class="ns mo iq nn b gy nt nu l nv nw">(a)1,2 and (a)1,3 -&gt; (b)1, 4<br/>(a)1,3 and (b)1,4 -&gt; (b)1, 5</span></pre><p id="2f1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，你可以删除这几个数据点。但是请记住，窗口越大，丢失的数据点就越多。根据数据的性质和大小，做出正确的决定。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="332d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您像我们在上面的<strong class="ky ir">窗口未标记数据中通过前瞻</strong>部分演示的那样强制执行纯顺序读取，您将不会从并行读取加速中受益。</p><p id="594c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单而有效的解决方案是制作多个数据集，然后按2的顺序将它们连接起来。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="e85a" class="mn mo iq bd mp mq nz ms mt mu oa mw mx jw ob jx mz jz oc ka nb kc od kd nd ne bi translated">结论</h1><p id="e646" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">您甚至可以使用这种优化的管道在一个或多个TPU上用大量的时间序列数据进行训练。</p><p id="0133" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过实现本文中提到的技术，您可以避免常见的缺陷，如数据丢失和顺序完整性，从而为顺序数据创建高性能的管道。</p><p id="4030" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你！你已经取得了时间序列<strong class="ky ir">卓越</strong>。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="5127" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢谢你一路看完！</p></div></div>    
</body>
</html>