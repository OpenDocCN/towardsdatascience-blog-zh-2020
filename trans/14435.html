<html>
<head>
<title>Real Time Machine Learning at Scale using SpaCy, Kafka &amp; Seldon Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SpaCy、Kafka和Seldon核心的大规模实时机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/real-time-stream-processing-for-machine-learning-at-scale-with-spacy-kafka-seldon-core-6360f2fedbe?source=collection_archive---------14-----------------------#2020-10-05">https://towardsdatascience.com/real-time-stream-processing-for-machine-learning-at-scale-with-spacy-kafka-seldon-core-6360f2fedbe?source=collection_archive---------14-----------------------#2020-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="98e6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这是一个实践教程，讲述了如何使用Reddit评论审核数据集训练机器学习模型，并使用Kafka和Seldon Core将其部署在可扩展的基础架构中</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/52aa6b7d61cbad94fc151e9bb4ead8fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LuX2T2W-BDiEq9yevrQMAQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Seldon Core进行流处理的模型部署(图片由作者提供)</p></figure><p id="b252" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本帖中，我们将介绍如何为自动文本预测用例训练和部署利用可扩展流处理架构的机器学习模型。我们将使用<a class="ae lr" href="https://github.com/scikit-learn/scikit-learn" rel="noopener ugc nofollow" target="_blank"> Sklearn </a>和<a class="ae lr" href="https://spacy.io/" rel="noopener ugc nofollow" target="_blank"> SpaCy </a>从Reddit内容审核数据集训练一个ML模型，我们将使用Seldon Core部署该模型，以实时处理来自Kafka实时流的文本数据。你还可以在这篇文章中找到视频形式的内容概述，在NLP Summit 2020上展示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">实时机器学习视频(NLP峰会2020)</p></figure><p id="3a5b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以在以下链接中找到本文的完整代码:</p><ul class=""><li id="76b7" class="lu lv iq kx b ky kz lb lc le lw li lx lm ly lq lz ma mb mc bi translated"><a class="ae lr" href="https://docs.seldon.io/projects/seldon-core/en/latest/examples/sklearn_spacy_text_classifier_example.html" rel="noopener ugc nofollow" target="_blank">谢顿模型集装箱化笔记本</a></li><li id="ceff" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><a class="ae lr" href="https://github.com/axsaucedo/reddit-classification-exploration/" rel="noopener ugc nofollow" target="_blank"> Reddit数据集探索性数据分析笔记本</a></li><li id="5158" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><a class="ae lr" href="https://github.com/SeldonIO/seldon-core/blob/master/examples/kafka/sklearn_spacy/README.ipynb" rel="noopener ugc nofollow" target="_blank">卡夫卡谢顿核心流处理部署笔记本</a></li></ul><h1 id="99e7" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">使用SpaCy &amp; Sklearn进行模型训练</h1><p id="68bc" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">对于这个用例，我们将使用<a class="ae lr" href="https://www.kaggle.com/areeves87/rscience-popular-comment-removal/kernels" rel="noopener ugc nofollow" target="_blank"> Reddit /r/science内容审核数据集</a>。这个数据集由超过200，000条reddit评论组成，主要根据评论是否被版主删除来标记。我们的任务是训练一个ML模型，它能够预测reddit版主已经删除的评论。</p><p id="7c5a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">SpaCy是用于生产文本处理用例的最受欢迎和最活跃的NLP库之一，它提供了“工业级”功能，包括标记化、NER、深度学习集成以及跨广泛语言模型的更多功能。同样，Sklearn是Python中最流行的机器学习工具包。我们将使用这两个框架进行探索性数据(和模型)分析，以及训练我们的机器学习模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/408e7b17242c6db6176a394dc533331a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJTx3Semz8_yMAGxiEMdCA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">探索性数据分析笔记本(图片由作者提供)</p></figure><p id="5e3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当涉及到构建机器学习模型时——特别是当它被部署到生产系统时——使用<a class="ae lr" href="https://ethical.institute/principles.html" rel="noopener ugc nofollow" target="_blank">原则和最佳实践</a>来确保其负责任的设计、开发和运营是很重要的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/0cbe7222aa8069d2fb77eda894816346.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/0*LhNvLCBGf6mnGlbb"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">算法对比图(图片由作者提供)</p></figure><p id="89f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您将能够在<a class="ae lr" href="https://github.com/axsaucedo/reddit-classification-exploration/blob/master/Data%20Preprocessing.ipynb" rel="noopener ugc nofollow" target="_blank">模型培训</a>笔记本中找到<a class="ae lr" href="https://github.com/axsaucedo/reddit-classification-exploration/blob/master/Exploratory%20Data%20Analysis.ipynb" rel="noopener ugc nofollow" target="_blank">探索性数据分析</a>的最佳实践和技术。这些包括特征工程、数据分布、数据不平衡、数据清理、算法性能比较、标记化方法、部分依赖图等。</p><p id="1f96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些技术使数据科学家和工程师能够为机器学习模型的培训、部署甚至生产监控确定特定领域的最佳实践。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/cd974d30ab0b7911860403b6a6c6f9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PJ1ysDXkEV2feruW_FOpbQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基本NLP管道(图片由作者提供)</p></figure><p id="e961" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本教程中，我们将使用<a class="ae lr" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Sklearn </a>和<a class="ae lr" href="https://spacy.io/" rel="noopener ugc nofollow" target="_blank"> SpaCy </a>构建机器学习管道。如上图所示，我们在管道中使用了以下组件:</p><ul class=""><li id="13df" class="lu lv iq kx b ky kz lb lc le lw li lx lm ly lq lz ma mb mc bi translated"><code class="fe ni nj nk nl b">CleanTextTransformer </code> —通过删除相关字符、符号和重复短语来清除输入文本</li><li id="6935" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><code class="fe ni nj nk nl b">SpacyTokenTransformer </code> —使用SpaCy将输入文本转换为标记，并删除相关标记，如停用词</li><li id="6fd9" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><code class="fe ni nj nk nl b">TfidfVectorizer </code> —将令牌转换为模型可以处理的向量</li><li id="5444" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><code class="fe ni nj nk nl b">LogisticRegression </code> —在我们当前数据集上训练的逻辑回归模型</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/5da90a9a02577a72d9239a95e91a6db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJ-tSEOKDGHv77ppzAGq6A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模型推理阶段(图片由作者提供)</p></figure><p id="0224" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了更直观地了解我们的模型将如何处理数据，上图显示了文本数据输入实例在每个阶段是如何转换的。更具体地说，如果我们接收到一个短语，它将通过每个管道组件发送，直到我们能够接收到一个预测。</p><p id="1ad8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们训练了我们的模型，我们将能够使用用于管道的相同代码，并且我们将导出使用<code class="fe ni nj nk nl b">pickle</code>训练的模型的工件，这样我们可以在部署模型时加载它们。</p><h1 id="9bcb" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">具有谢顿核心的集装箱化模型</h1><p id="6a97" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">Seldon Core可用于将我们的模型转换为可扩展的微服务，并使用Seldon cloud原生kubernetes操作员将其部署到Kubernetes。使用Seldon Core部署的模型支持REST和GRPC接口，但从1.3版本开始，它还支持原生kafka接口，我们将在本文中使用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/52aa6b7d61cbad94fc151e9bb4ead8fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LuX2T2W-BDiEq9yevrQMAQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">采用塞尔顿核心的模型部署(图片由作者提供)</p></figure><p id="d76f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Seldon提供了几种生产机器学习模型的方法。最常见的方法是使用现有的<a class="ae lr" href="https://docs.seldon.io/projects/seldon-core/en/latest/servers/overview.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">预打包模型服务器</strong> s </a>中的一个。然而，在这种情况下，我们将通过扩展默认的<a class="ae lr" href="https://docs.seldon.io/projects/seldon-core/en/latest/servers/sklearn.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> sklearn预打包服务器</strong> </a>来添加SpaCy及其各自的英语语言模型，从而构建我们自己的<a class="ae lr" href="https://docs.seldon.io/projects/seldon-core/en/latest/servers/custom.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">定制模型服务器</strong> </a>。</p><p id="65cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了用Seldon封装我们的模型，我们将使用<a class="ae lr" href="https://docs.seldon.io/projects/seldon-core/en/latest/python/python_wrapping_s2i.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Python语言包装器</strong> </a>遵循标准的Seldon核心工作流程。如下图所示，将模型装箱所需的标准步骤如下:</p><ul class=""><li id="724f" class="lu lv iq kx b ky kz lb lc le lw li lx lm ly lq lz ma mb mc bi translated">创建一个<strong class="kx ir"> Python包装类</strong>来公开模型逻辑</li><li id="837e" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated">通过<code class="fe ni nj nk nl b">requirements.txt</code>文件添加<strong class="kx ir"> Python依赖关系</strong></li><li id="5cef" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated">添加<strong class="kx ir">协议、日志级别等环境参数</strong></li><li id="c2b0" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated">可选地添加任何带有Dockerfile扩展名的<strong class="kx ir">进一步依赖关系</strong></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/70fc21e91643f8567930460470fd960a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0au-EFdV7QLGPO_d6NMi2Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">集装箱模型所需的标准步骤(图片由作者提供)</p></figure><p id="f863" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，我们只需要定义一个Python包装器，它由以下部分组成:</p><ul class=""><li id="681d" class="lu lv iq kx b ky kz lb lc le lw li lx lm ly lq lz ma mb mc bi translated">导入本文培训部分使用的ML管道的代码</li><li id="85e5" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated">一个加载模型工件的<code class="fe ni nj nk nl b">__init__</code>方法</li><li id="305f" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated">每次发送请求时被调用的<code class="fe ni nj nk nl b">predict</code>方法</li></ul><p id="371e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">包装器的代码可以在下图中找到，或者你可以找到完整的<a class="ae lr" href="https://docs.seldon.io/projects/seldon-core/en/latest/examples/sklearn_spacy_text_classifier_example.html" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>来训练、装箱和测试谢顿包装模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/8f34bde77eff3407d4a93cdc26d65356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EsNCyUYAsyme0Bb5W7xZZQ.png"/></div></div></figure><p id="19e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦有了包装器，我们就能够使用<code class="fe ni nj nk nl b">s2i</code> CLI简单地运行Seldon实用程序，即:</p><blockquote class="np nq nr"><p id="9538" class="kv kw ns kx b ky kz jr la lb lc ju ld nt lf lg lh nu lj lk ll nv ln lo lp lq ij bi translated"><code class="fe ni nj nk nl b">s2i build . seldonio/seldon-core-s2i-python3:1.3.0 nlp-model:0.1</code></p></blockquote><p id="3dec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经将我们的模型完全容器化为image <code class="fe ni nj nk nl b">nlp-model:0.1</code>,我们将能够在下一节中为流处理部署它。</p><h1 id="e681" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">Kafka流处理</h1><p id="0fba" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">谢顿模型支持REST、GRPC和Kafka协议——在本例中，我们将使用后者来支持流处理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/68748cddde640ba9fa1ef13b4bef1560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ethNkBOij8UCbtSC-GBYA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Kafka ML处理架构(图片由作者提供)</p></figure><p id="6e50" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以在示例中找到完整的<a class="ae lr" href="https://github.com/SeldonIO/seldon-core/blob/master/examples/kafka/sklearn_spacy/README.ipynb" rel="noopener ugc nofollow" target="_blank"> jupyter笔记本</a>，其中包括部署文件以及请求工作流。</p><p id="6a2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们有以下组件:</p><ul class=""><li id="523c" class="lu lv iq kx b ky kz lb lc le lw li lx lm ly lq lz ma mb mc bi translated"><strong class="kx ir"> Kubernetes集群</strong> —我们所有组件将部署到的Kubernetes集群</li><li id="7ce4" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><strong class="kx ir"> Reddit源</strong> —以Reddit评论流的形式产生输入数据的组件</li><li id="0580" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><strong class="kx ir"> Kafka队列</strong>—Kafka集群组件，将处理消费者和生产者提供的数据流</li><li id="d212" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><strong class="kx ir"> Seldon ML服务</strong> —我们使用Seldon部署的容器化reddit分类器模型</li><li id="e3d0" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><strong class="kx ir">卡夫卡</strong></li><li id="7bc7" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><strong class="kx ir">卡夫卡</strong> <code class="fe ni nj nk nl b"><strong class="kx ir">model_output</strong></code> <strong class="kx ir">主题</strong> —其他应用程序可以从中消费的输出主题</li><li id="453c" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><strong class="kx ir">其他应用程序</strong> —在我们的例子中，这是一个单一用户应用程序，但是这可以包括任何其他想要使用<code class="fe ni nj nk nl b">model_output</code>主题的应用程序</li></ul><p id="64c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了简单起见，我们将跳过设置kubernetes集群所需的步骤——包括设置Kafka代理和安装Seldon Core——但是您可以在笔记本示例中找到完整的说明。</p><p id="85c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以部署我们的模型了。为此，我们只需按照SeldonDeployment模式定义我们的部署配置文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/c65ce9bd4eb5c88785dd2ff8ff15cbee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0XD4oJXiZbL4_dmNhor6A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SeldonDeployment Kafka配置文件(图片由作者提供)</p></figure><p id="a1bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您在配置YAML中看到的，该结构包含以下要点:</p><ul class=""><li id="c0ea" class="lu lv iq kx b ky kz lb lc le lw li lx lm ly lq lz ma mb mc bi translated">型号名称<code class="fe ni nj nk nl b">name: reddit-kafka</code></li><li id="98f9" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><code class="fe ni nj nk nl b">graph.name: classifier</code>是我们将部署的型号</li><li id="1767" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><code class="fe ni nj nk nl b">serverType: kafka</code>使用kafka接口启用部署的微服务(与REST或GRPC协议相反)</li><li id="99c1" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><code class="fe ni nj nk nl b">KAFKA_BROKER</code>卡夫卡经纪人的服务器</li><li id="4a2f" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><code class="fe ni nj nk nl b">KAFKA_INPUT_TOPIC</code>输入消费主题的名称</li><li id="80df" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><code class="fe ni nj nk nl b">KAFKA_OUTPUT_TOPIC</code>要生成的输出主题的名称</li></ul><p id="bcc3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以使用kubectl命令创建模型:</p><blockquote class="np nq nr"><p id="29db" class="kv kw ns kx b ky kz jr la lb lc ju ld nt lf lg lh nu lj lk ll nv ln lo lp lq ij bi translated"><code class="fe ni nj nk nl b">kubectl apply -f sdep_reddit_kafka.yaml</code></p></blockquote><p id="834c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们的模型被创建，我们现在可以将数据发送到输入主题中。我们可以通过使用<code class="fe ni nj nk nl b">kafka-console-producer.sh</code>实用程序来实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/4ea56ced0a3a8820144e2816d3f32b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEbfCWDfdy4JB92SKR-Hgw.png"/></div></div></figure><p id="91d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似地，我们也可以监听模型产生的输出数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/f14ff2bdb53ea680fcca6cfe4ccbc615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jf-Nv6nMFXA1pMF513yVvA.png"/></div></div></figure><p id="bce0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，当我们将输入数据发送到输入主题时:</p><blockquote class="np nq nr"><p id="666a" class="kv kw ns kx b ky kz jr la lb lc ju ld nt lf lg lh nu lj lk ll nv ln lo lp lq ij bi translated"><code class="fe ni nj nk nl b">{”data”: {”ndarray”: [”This is an input”]}}</code></p></blockquote><p id="4e0e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们会在输出主题流中看到预测:</p><blockquote class="np nq nr"><p id="30a0" class="kv kw ns kx b ky kz jr la lb lc ju ld nt lf lg lh nu lj lk ll nv ln lo lp lq ij bi translated"><code class="fe ni nj nk nl b">{“data”:{“names”:[“t:0”,”t:1"],”ndarray”: [[0.6758450844706712, 0.32415491552932885]]},”meta”:{}}</code></p></blockquote><p id="b815" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样，我们现在有了一个部署在可扩展架构中的模型，用于实时机器学习处理——更具体地说，该架构允许每个相应组件的水平和垂直可扩展性。部署的模型可以扩展到可变数量的副本，以及基于Kubernetes HPA的自动扩展，后者可以根据资源使用情况进行水平扩展。类似地，Kafka还可以通过代理的数量进行水平扩展，从而实现低延迟的大吞吐量。这可以在下图中更直观地看到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/df7d0a2015cc216f1ee54f71521467a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EzO7Bh1V8hoFkeL-OEMzew.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">缩放副本和代理(图片由作者提供)</p></figure><h1 id="2cf4" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">下一步是什么？</h1><p id="e856" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">现在，您已经对核心架构组件有了直觉和理解，您现在能够深入研究实际的细节了。为此，您可以通过以下链接访问代码和资源:</p><ul class=""><li id="2801" class="lu lv iq kx b ky kz lb lc le lw li lx lm ly lq lz ma mb mc bi translated"><a class="ae lr" href="https://docs.seldon.io/projects/seldon-core/en/latest/examples/sklearn_spacy_text_classifier_example.html" rel="noopener ugc nofollow" target="_blank">谢顿模型集装箱化笔记本</a></li><li id="e07e" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><a class="ae lr" href="https://github.com/axsaucedo/reddit-classification-exploration/" rel="noopener ugc nofollow" target="_blank"> Reddit数据集探索性数据分析笔记本</a></li><li id="7d50" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><a class="ae lr" href="https://github.com/SeldonIO/seldon-core/blob/master/examples/kafka/sklearn_spacy/README.ipynb" rel="noopener ugc nofollow" target="_blank">卡夫卡谢顿核心流处理部署笔记本</a></li></ul><p id="6eb6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您有兴趣进一步了解机器学习模型的可扩展部署策略示例，您可以查看:</p><ul class=""><li id="1634" class="lu lv iq kx b ky kz lb lc le lw li lx lm ly lq lz ma mb mc bi translated"><a class="ae lr" href="https://docs.seldon.io/projects/seldon-core/en/latest/examples/argo_workflows_batch.html" rel="noopener ugc nofollow" target="_blank">利用Argo工作流程进行批处理</a></li><li id="5f45" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><a class="ae lr" href="https://docs.seldon.io/projects/seldon-core/en/latest/streaming/knative_eventing.html" rel="noopener ugc nofollow" target="_blank">无服务器事件与Knative </a></li><li id="1039" class="lu lv iq kx b ky md lb me le mf li mg lm mh lq lz ma mb mc bi translated"><a class="ae lr" href="https://docs.seldon.io/projects/seldon-core/en/latest/analytics/explainers.html" rel="noopener ugc nofollow" target="_blank"> AI用不在场证明解释模式</a></li></ul></div></div>    
</body>
</html>