<html>
<head>
<title>A quick tutorial to AWS Transcribe with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python进行AWS转录的快速教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-quick-tutorial-to-aws-transcribe-with-python-53bbf6605a55?source=collection_archive---------10-----------------------#2020-10-19">https://towardsdatascience.com/a-quick-tutorial-to-aws-transcribe-with-python-53bbf6605a55?source=collection_archive---------10-----------------------#2020-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="369c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过Google Colab和Google Drive使用AWS转录的转录服务简介</h2></div><p id="8b77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">去年夏天，我开发了一些涉及语音转文本机制的产品，我认为最好使用现有的API来实现这些目的。在这篇文章中，我想与那些想尝试这些美妙技术的人分享我使用这些API的一点点经验。希望你们觉得有帮助:)</p><p id="3b24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哦！而<strong class="kh ir">这里是我将涉及的快速内容:</strong> <br/> <strong class="kh ir"> -设置:通用包和初始化基本功能<br/> -单扬声器文件<br/> -多扬声器文件<br/> -通过Colab和Google Drive访问文件并上传到S3存储器<br/> -创建词汇表以增强转录准确性</strong></p><p id="969a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码链接:Google Colab ( <a class="ae lb" href="https://colab.research.google.com/drive/1oaS1dOj5kkzx9Q8YRZd54AGHzrQEqg_9" rel="noopener ugc nofollow" target="_blank">此处</a>)、Gist ( <a class="ae lb" href="https://gist.github.com/viethoangtranduong/28a365e6457f35e206779995f488318a" rel="noopener ugc nofollow" target="_blank">此处</a>)或Github( <a class="ae lb" href="https://github.com/viethoangtranduong/AWS-Transcribe-Tutorial/blob/master/AWS_Transcribe_Tutorial.ipynb" rel="noopener ugc nofollow" target="_blank">此处</a>)。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/4021e56f94b36411b5d15a4d00de7ac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uxw6mHIh32PvPycrlekW2g.jpeg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae lb" href="https://pixabay.com/illustrations/web-network-programming-3706562/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="f58c" class="lz ma iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated">为什么选择语音转文本？</h2><p id="27fd" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">语音转文本是一项很有前途的技术，不是作为一个产品本身，而是更多地基于它对许多其他产品的底层应用。由于我们的阅读速度比听力速度快得多，阅读转录比听类似内容的音频节省更多的时间。谷歌的新旗舰手机:Pixel 4，引入了执行实时转录的录音应用程序！有前途的产品可能是会议记录(Zoom已经提供了这个功能)、讲座(文本记录)等等。</p><p id="08f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多年来，语音转文本已经是一个相当成熟的领域。由于这种挑战更多的是横向的，而不是纵向的，因此拥有来自各种输入源的大量数据的公司会胜出。毫无疑问，像亚马逊、谷歌、IBM、微软这样的大公司是在他们的云上提供转录服务的领导者。</p><p id="f635" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每种产品都有其优点和缺点，可能会不同程度地满足您的需求。我强烈建议尝试所有这些服务，并选择最适合您所需用例的服务。在这篇文章中，我将重点放在Amazon Transcription服务上，因为它有丰富的输出:一个JSON文件，包含所有时间戳和其他信息，这非常有用！</p><p id="b845" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(对我(希望)下一篇帖子的小炒作:Google Cloud(执行单个说话者转录时):输出没有任何标点符号。我希望写一个RNN模型来添加标点符号，以丰富输出。但这是在未来。让我们暂时回到AWS！)</p><p id="0e2c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将通过使用谷歌Colab的步骤。完整代码的链接是<a class="ae lb" href="https://colab.research.google.com/drive/1oaS1dOj5kkzx9Q8YRZd54AGHzrQEqg_9" rel="noopener ugc nofollow" target="_blank">这里是</a>。我们开始吧！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="da07" class="lz ma iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated"><strong class="ak">设置:通用软件包和初始化基本功能。</strong></h2><pre class="ld le lf lg gt mx my mz na aw nb bi"><span id="3e99" class="lz ma iq my b gy nc nd l ne nf">!pip install boto3<br/>import pandas as pd<br/>import time<br/>import boto3</span></pre><p id="88be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Boto是用于Python的AWS软件开发工具包。更多关于Boto 3文档的信息可以在<a class="ae lb" href="https://boto3.amazonaws.com/v1/documentation/api/latest/index.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="23a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要AWS帐户的访问密钥。如果你还没有创建一个帐户，请这样做(它是免费创建的，如果你不使用太多，还有免费层)！<br/>当您拥有自己的帐户时，以下是获取个人访问密钥的方法(如果您已经有了访问密钥，请随意使用):</p><ul class=""><li id="2c5c" class="ng nh iq kh b ki kj kl km ko ni ks nj kw nk la nl nm nn no bi translated">步骤1:转到AWS管理控制台页面。</li><li id="f453" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">第二步:点击右上角的用户名，选择“我的安全凭证”</li><li id="f0bb" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">步骤3:选择“访问密钥(访问密钥ID和秘密访问密钥。”</li><li id="801d" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">第四步:创建新的密钥，并记住保存它！</li><li id="0254" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">步骤5:添加到我们的代码中:初始化转录作业。</li></ul><pre class="ld le lf lg gt mx my mz na aw nb bi"><span id="870e" class="lz ma iq my b gy nc nd l ne nf">transcribe = boto3.client('transcribe',<br/>aws_access_key_id = #insert your access key ID here,<br/>aws_secret_access_key = # insert your secret access key here<br/>region_name = # region: usually, I put "us-east-2"</span></pre><p id="5438" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们需要<strong class="kh ir">创建/连接我们的亚马逊S3存储。</strong> <br/> AWS转录将从您的S3存储中转录文件。这非常方便，因为你可以将文件存储到亚马逊S3，并直接从云中处理它们。点击阅读如何创建你的S3桶<a class="ae lb" href="https://docs.aws.amazon.com/AmazonS3/latest/gsg/CreatingABucket.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="40eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尝试上传一个随机的音频/视频文件到S3存储，让我们试试转录服务！这些是我们的价值观</p><ul class=""><li id="d74a" class="ng nh iq kh b ki kj kl km ko ni ks nj kw nk la nl nm nn no bi translated">job_uri: S3访问链接，通常为“S3://bucket _ name/”+audio _ file _ name(如“S3://viethoangtranduong/AWS . wav”)</li><li id="9cb6" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">job_name:对于每个转录调用，我们需要一个作业名。在这种情况下，我使用音频文件名本身。我们也可以使用散列函数来自动化系统。<br/> <strong class="kh ir">注意:如果已经存在同名作业，作业将会崩溃。避免这些问题的可能方法是</strong> : <br/> - <strong class="kh ir">一个哈希函数</strong>来编码音频文件名和作业的时间戳(这将避免重复，即使文件具有相同的名称)<br/> - <strong class="kh ir">一个密钥生成器数据库</strong>:如果我们使用base 62(因为我们想避免“/”和“+”)，那么我们可以有62⁶ = 56.8 B唯一代码(这应该足够了)。我们可以将未使用的密钥用于每项工作。<br/>我们可以有两个数据库来存储使用和未使用的密钥。每次使用一个未使用的键时，我们将它移动到另一个数据库。我们必须跟踪文件名和匹配的键，以便将来遍历。使用这种方法，我们可以进一步发展成转录文件的链接缩写。</li><li id="79a5" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">file_format:文件格式。AWS可以处理大多数文件，如. mp3、.wav，甚至像. mp4这样的视频</li></ul><p id="c7d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简单起见，我创建了一个函数调用check_job_name来处理重复的作业名。</p><pre class="ld le lf lg gt mx my mz na aw nb bi"><span id="c237" class="lz ma iq my b gy nc nd l ne nf">def check_job_name(job_name):<br/>  job_verification = True</span><span id="da19" class="lz ma iq my b gy nu nd l ne nf">  # all the transcriptions<br/>  existed_jobs = transcribe.list_transcription_jobs()</span><span id="b138" class="lz ma iq my b gy nu nd l ne nf">  for job in existed_jobs['TranscriptionJobSummaries']:<br/>    if job_name == job['TranscriptionJobName']:<br/>      job_verification = False<br/>      break</span><span id="cb0a" class="lz ma iq my b gy nu nd l ne nf">   if job_verification == False:<br/>    command = input(job_name + " has existed. \nDo you want to override the existed job (Y/N): ")    if command.lower() == "y" or command.lower() == "yes":                transcribe.delete_transcription_job(TranscriptionJobName=job_name)<br/>    elif command.lower() == "n" or command.lower() == "no":      job_name = input("Insert new job name? ")      check_job_name(job_name)<br/>    else:<br/>      print("Input can only be (Y/N)")<br/>      command = input(job_name + " has existed. \nDo you want to override the existed job (Y/N): ")<br/>  return job_name</span></pre><p id="459f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">对于单扬声器文件</strong></p><pre class="ld le lf lg gt mx my mz na aw nb bi"><span id="4e01" class="lz ma iq my b gy nc nd l ne nf">def amazon_transcribe(audio_file_name):<br/>  job_uri = # your S3 access link<br/>  # Usually, I put like this to automate the process with the file name<br/>  # "s3://bucket_name" + audio_file_name  </span><span id="c08a" class="lz ma iq my b gy nu nd l ne nf">  # Usually, file names have spaces and have the file extension like .mp3<br/>  # we take only a file name and delete all the space to name the job<br/>  job_name = (audio_file_name.split('.')[0]).replace(" ", "")  </span><span id="c46c" class="lz ma iq my b gy nu nd l ne nf">  # file format  <br/>  file_format = audio_file_name.split('.')[1]<br/>  <br/>  # check if name is taken or not<br/>  job_name = check_job_name(job_name)<br/>  transcribe.start_transcription_job(<br/>      TranscriptionJobName=job_name,<br/>      Media={'MediaFileUri': job_uri},<br/>      MediaFormat = file_format,<br/>      LanguageCode='en-US')<br/>  <br/>  while True:<br/>    result = transcribe.get_transcription_job(TranscriptionJobName=job_name)<br/>    if result['TranscriptionJob']['TranscriptionJobStatus'] in ['COMPLETED', 'FAILED']:<br/>        break<br/>    time.sleep(15)<br/>  if result['TranscriptionJob']['TranscriptionJobStatus'] == "COMPLETED":<br/>    data = pd.read_json(result['TranscriptionJob']['Transcript']['TranscriptFileUri'])<br/>  return data['results'][1][0]['transcript']</span></pre><p id="eeda" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为转录可能需要时间，所以我们创建了一个while循环来等待它完成(每15秒重新运行一次)。<br/>最后一个“if”语句从JSON文件中提取特定的脚本。我将在文章的最后讨论如何提取时间戳。</p><p id="cb0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">对于多扬声器文件</strong></p><p id="6095" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于AWS为多个扬声器转录，它可以检测的最大扬声器是10个。这次我将接受两个参数作为输入:audio_file_name和max_speakers。我强烈建议使用max_speakers值来提高AWS的准确性。但是，您也可以将其留空。</p><pre class="ld le lf lg gt mx my mz na aw nb bi"><span id="d8d1" class="lz ma iq my b gy nc nd l ne nf">def amazon_transcribe(audio_file_name, max_speakers = -1):<br/>  <br/>  if max_speakers &gt; 10:<br/>    raise ValueError("Maximum detected speakers is 10.")<br/>  <br/>  job_uri = "s3 bucket link" + audio_file_name<br/>  job_name = (audio_file_name.split('.')[0]).replace(" ", "")<br/>  <br/>  # check if name is taken or not<br/>  job_name = check_job_name(job_name)<br/>    if max_speakers != -1:<br/>      transcribe.start_transcription_job(<br/>        TranscriptionJobName=job_name,<br/>        Media={'MediaFileUri': job_uri},<br/>        MediaFormat=audio_file_name.split('.')[1],<br/>        LanguageCode='en-US',<br/>        Settings = {'ShowSpeakerLabels': True,<br/>                  'MaxSpeakerLabels': max_speakers})<br/>    else:<br/>      transcribe.start_transcription_job(<br/>        TranscriptionJobName=job_name,<br/>        Media={'MediaFileUri': job_uri},<br/>        MediaFormat=audio_file_name.split('.')[1],<br/>        LanguageCode='en-US',<br/>        Settings = {'ShowSpeakerLabels': True})</span><span id="921d" class="lz ma iq my b gy nu nd l ne nf">  while True:<br/>    result = transcribe.get_transcription_job(TranscriptionJobName=job_name)<br/>    if result['TranscriptionJob']['TranscriptionJobStatus'] in ['COMPLETED', 'FAILED']:<br/>      break<br/>    time.sleep(15)</span><span id="fb59" class="lz ma iq my b gy nu nd l ne nf">  if result['TranscriptionJob']['TranscriptionJobStatus'] == 'COMPLETED':<br/>    data = pd.read_json(result['TranscriptionJob']['Transcript']['TranscriptFileUri'])<br/>  return result</span></pre><p id="166a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次，输出不再是文本，而是一个文件结果(在Python中，它是一种字典数据类型)。</p><pre class="ld le lf lg gt mx my mz na aw nb bi"><span id="0d11" class="lz ma iq my b gy nc nd l ne nf">data = pd.read_json(result['TranscriptionJob']['Transcript']['TranscriptFileUri'])<br/>transcript = data['results'][2][0]['transcript']</span></pre><p id="8db0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码将为您提供原始的转录(没有扬声器标签):结果将类似于将这些文件输入到单扬声器模型中。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="af9e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">如何添加扬声器标签？</strong></p><p id="512a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将读取“TranscriptFileUri”中的JSON文件。<br/>由于我们正在使用Google Colab，我还将演示如何访问特定文件夹中的文件。假设我们已经把它放在一个文件夹中:Colab Notebooks/AWS transcript reader:下面是访问它的方法。</p><pre class="ld le lf lg gt mx my mz na aw nb bi"><span id="fa8e" class="lz ma iq my b gy nc nd l ne nf">from google.colab import drive<br/>import sys<br/>import os </span><span id="d67c" class="lz ma iq my b gy nu nd l ne nf">drive.mount('/content/drive/')<br/>sys.path.append("/content/drive/My Drive/Colab Notebooks/AWS Transcribe reader")<br/>os.chdir("/content/drive/My Drive/Colab Notebooks/AWS Transcribe reader")</span></pre><p id="4ee0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们需要处理来自AWS转录的JSON输出。下面的代码将提供一个带有[时间戳，演讲者标签，内容]的. txt文件。<br/>当<strong class="kh ir">输入“filename.json”文件</strong>时，期待完整抄本的“filename.txt”文件。</p><pre class="ld le lf lg gt mx my mz na aw nb bi"><span id="a45a" class="lz ma iq my b gy nc nd l ne nf">import json<br/>import datetime<br/>import time as ptime </span><span id="8a81" class="lz ma iq my b gy nu nd l ne nf">def read_output(filename):<br/>  # example filename: audio.json<br/>  <br/>  # take the input as the filename<br/>  <br/>  filename = (filename).split('.')[0]<br/>  <br/>  # Create an output txt file<br/>  print(filename+'.txt')<br/>  with open(filename+'.txt','w') as w:<br/>    with open(filename+'.json') as f:<br/>      data=json.loads(f.read())<br/>      labels = data['results']['speaker_labels']['segments']<br/>      speaker_start_times={}<br/>  <br/>      for label in labels:<br/>        for item in label['items']:<br/>          speaker_start_times[item['start_time']] = item['speaker_label']</span><span id="cc8b" class="lz ma iq my b gy nu nd l ne nf">      items = data['results']['items']<br/>      lines = []<br/>      line = ''<br/>      time = 0<br/>      speaker = 'null'<br/>      i = 0<br/>      <br/>      # loop through all elements<br/>      for item in items:<br/>        i = i+1<br/>        content = item['alternatives'][0]['content']</span><span id="8868" class="lz ma iq my b gy nu nd l ne nf">      # if it's starting time<br/>        if item.get('start_time'):<br/>          current_speaker = speaker_start_times[item['start_time']]</span><span id="ea14" class="lz ma iq my b gy nu nd l ne nf">      # in AWS output, there are types as punctuation<br/>        elif item['type'] == 'punctuation':<br/>          line = line + content<br/>  <br/>      # handle different speaker<br/>        if current_speaker != speaker:<br/>          if speaker:<br/>            lines.append({'speaker':speaker, 'line':line, 'time':time})<br/>          line = content<br/>          speaker = current_speaker<br/>          time = item['start_time']</span><span id="bb29" class="lz ma iq my b gy nu nd l ne nf">        elif item['type'] != 'punctuation':<br/>          line = line + ' ' + content<br/>      lines.append({'speaker': speaker, 'line': line,'time': time})       </span><span id="ae5c" class="lz ma iq my b gy nu nd l ne nf">      # sort the results by the time<br/>      sorted_lines = sorted(lines,key=lambda k: float(k['time']))<br/>      # write into the .txt file<br/>      for line_data in sorted_lines:<br/>        line = '[' + str(datetime.timedelta(seconds=int(round(float(line_data['time']))))) + '] ' + line_data.get('speaker') + ': ' + line_data.get('line')<br/>        w.write(line + '\n\n')</span></pre><p id="23e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在同一个文件夹中，会出现“filename.txt”文件，其中包含所有的抄本。</p><p id="979f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">奖励1:直接访问和上传文件到S3存储器</strong></p><p id="0e04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将文件上传到AWS S3存储肯定会使许多过程自动化。</p><pre class="ld le lf lg gt mx my mz na aw nb bi"><span id="0b88" class="lz ma iq my b gy nc nd l ne nf"># define AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, and bucket_name<br/># bucket_name: name of s3 storage folder<br/>s3 = boto3.client('s3', <br/>  aws_access_key_id = AWS_ACCESS_KEY_ID,<br/>  aws_secret_access_key = AWS_SECRET_ACCESS_KEY,<br/>  region_name = "us-east-2")</span><span id="feca" class="lz ma iq my b gy nu nd l ne nf">s3.upload_file(file_name, bucket_name, file_name)</span></pre><p id="b394" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">红利二:我们为什么不创建一个词汇表来增强准确性？</strong></p><p id="9d0a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过控制台管理将词汇表手动上传到AWS转录服务中。接受的文件有。csv或. txt. <br/>然而，如果我们想用Python来自动化这个过程，那就有点棘手了。<br/>下面是我发现的一种方法:AWS通过Python接受特定类型的输入，这是一个有4列的data frame:[' Phrases '，' IPA '，' SoundsLike '，' DisplayAs']转换成。txt文件。有关各列含义和自定义词汇的更多信息，请阅读此处的<a class="ae lb" href="https://docs.aws.amazon.com/transcribe/latest/dg/how-vocabulary.html" rel="noopener ugc nofollow" target="_blank"/>。</p><pre class="ld le lf lg gt mx my mz na aw nb bi"><span id="b776" class="lz ma iq my b gy nc nd l ne nf">def vocab_name(custom_name):<br/>  vocab = pd.DataFrame([['Los-Angeles', np.nan, np.nan, "Los Angeles"], ["F.B.I.", "ɛ f b i aɪ", np.nan, "FBI"], ["Etienne", np.nan, "eh-tee-en", np.nan]], columns=['Phrase', 'IPA', 'SoundsLike', 'DisplayAs'])</span><span id="646d" class="lz ma iq my b gy nu nd l ne nf">  vocab.to_csv(custom_name+'.csv', header=True, index=None, sep='\t')<br/>  import csv<br/>  import time<br/>  csv_file = 'custom_name+'.csv<br/>  txt_file = 'custom_name+'.txt</span><span id="6296" class="lz ma iq my b gy nu nd l ne nf">  with open(txt_file, "w") as my_output_file:<br/>    with open(csv_file, "r") as my_input_file:<br/>      my_output_file.write(" ".join(row)+'\n') for row in csv.reader(my_input_file)]<br/>    my_output_file.close()<br/>  ptime.sleep(30) # wait for the file to finish</span><span id="74c5" class="lz ma iq my b gy nu nd l ne nf">  bucket_name = #name of the S3 bucket<br/>  s3.upload_file(txt_file, bucket_name, txt_file)<br/>  ptime.sleep(60)</span><span id="ef55" class="lz ma iq my b gy nu nd l ne nf">  response = transcribe.create_vocabulary(<br/>    VocabularyName= custom_name,<br/>    LanguageCode='en-US',<br/>    VocabularyFileUri = "your s3 link" + txt_file)<br/>    # the link usually is bucketname.region.amazonaws.com</span><span id="bf7a" class="lz ma iq my b gy nu nd l ne nf"># after running vocab_name, we can check the status through this line</span><span id="1590" class="lz ma iq my b gy nu nd l ne nf"># if it's ready, the VocabularyState will be 'READY'<br/>transcribe.list_vocabularies()</span></pre><p id="cea4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上传和添加词汇表花费了相当多的时间。这可能不是最佳的方法，但它是有效的(在尝试字符串列表、列表列表中，但目前没有一个有效)。<br/> <strong class="kh ir">如果你找到了进一步自动化的方法，请评论！我很乐意讨论和了解更多。</strong></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="80ab" class="lz ma iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated"><strong class="ak">结论和…下一步是什么？</strong></h2><p id="587b" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">这里有一个关于AWS转录的快速教程。希望你觉得有用！此外，我希望听到你的想法，并进一步讨论它们。(我可能会写一些关于在Google Cloud little-punctuations抄本中添加标点符号的内容，所以我希望我不会偷懒)。</p><p id="057b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">链接到代码:Google Colab ( <a class="ae lb" href="https://colab.research.google.com/drive/1oaS1dOj5kkzx9Q8YRZd54AGHzrQEqg_9" rel="noopener ugc nofollow" target="_blank">这里</a>)，Gist ( <a class="ae lb" href="https://gist.github.com/viethoangtranduong/28a365e6457f35e206779995f488318a" rel="noopener ugc nofollow" target="_blank">这里</a>，或者Github( <a class="ae lb" href="https://github.com/viethoangtranduong/AWS-Transcribe-Tutorial/blob/master/AWS_Transcribe_Tutorial.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>)。<br/>欢迎通过<a class="ae lb" href="https://www.linkedin.com/in/viethoangtranduong/" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/viethoangtranduong/</a>联系我或在此发表评论，我会尽力尽快回复！</p><p id="1615" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">附:实时转录比转录一个类似的文件要好得多。</strong></p><p id="76d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">参考资料<br/> </strong> <a class="ae lb" href="https://medium.com/@labrlearning/a-five-minute-overview-of-aws-transcribe-514b6cfeeddd" rel="noopener">五分钟概述AWS转录</a> <br/> <a class="ae lb" href="https://github.com/kibaffo33/aws_transcribe_to_docx" rel="noopener ugc nofollow" target="_blank"> AWS转录为Docx。</a></p></div></div>    
</body>
</html>