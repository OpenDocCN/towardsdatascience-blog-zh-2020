<html>
<head>
<title>Fire: Simple CLIs done right</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">火:简单的气候做对了</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fire-simple-clis-done-right-dd1b89748f16?source=collection_archive---------46-----------------------#2020-09-29">https://towardsdatascience.com/fire-simple-clis-done-right-dd1b89748f16?source=collection_archive---------46-----------------------#2020-09-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c10e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建CLI有助于提高ML管道的可访问性和重用性，但是设置它们可能会很麻烦。进入火场。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5a35ef706befe3ff73b112569cc1a375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JfRJn73Qlgyr92uDe1zJww.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由来自Unsplash的Cullan Smith拍摄</p></figure><h1 id="5c26" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">什么是火？</h1><p id="7481" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">几个月前，我大发雷霆，我<a class="ae mj" href="https://mark.douthwaite.io/monster-jobs-with-tqdm/" rel="noopener ugc nofollow" target="_blank">表达了我对</a>创建进度条的一个叫做<code class="fe mk ml mm mn b">TQDM</code>的小软件包的赞赏。这篇文章也是同样的思路，但这次是关于<code class="fe mk ml mm mn b">Fire</code>:一个<a class="ae mj" href="https://github.com/google/python-fire" rel="noopener ugc nofollow" target="_blank">伟大的包</a>，它可以让命令行界面(CLI)在几秒钟内(字面上)建立并运行起来轻而易举。</p><p id="30a5" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">那么，为什么要写CLI呢？实际上，一个简单的CLI可以使配置脚本变得像更改几个命令行参数一样简单。假设你有一个设置在编排服务上的脚本(可能类似于Jenkins ),它定期重新训练你最新最棒的Tweet情感分类器。假设是一个<a class="ae mj" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn </a> <a class="ae mj" href="https://en.wikipedia.org/wiki/Random_forest#:~:text=Random%20forests%20or%20random%20decision,prediction%20(regression)%20of%20the%20individual" rel="noopener ugc nofollow" target="_blank">随机森林</a>。您可以像这样运行作业:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="6bca" class="mx kw iq mn b gy my mz l na nb">python tweet-classifier/train.py</span></pre><p id="4c43" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">您可以选择直接在代码中调整模型的参数。一个更好的方法是将模型封装在一个函数中，并将模型的参数绑定到一个函数签名(例如<code class="fe mk ml mm mn b">train(n_estimators: int = 100)</code>)上，而不是运行类似如下的代码:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="1c36" class="mx kw iq mn b gy my mz l na nb">python tweet-classifier/train.py --n_estimators 100</span></pre><p id="ce93" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">这将允许您通过CLI配置模型的超参数。</p><p id="f1c7" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">这个<em class="nc">防止你为了改变脚本的配置而需要改变代码</em>本身，这反过来可以帮助其他用户轻松地获取和运行你的代码。对于“生产”代码来说，这通常也是一个更好的想法，对源代码的更改应该被仔细跟踪，并传播到该代码的所有实例(您可能正在运行几十个不同的Tweet分类器，更改其中一个代码可能会以意想不到的方式改变它们)。几十个陈旧的Git分支对此也是一个糟糕的解决方案。对已部署代码的特别更改会造成混乱，最终会让您(或您的雇主)损失一大笔钱。CLIs可以成为你工具箱里的一个工具，帮助你避免这种命运。</p><p id="23f7" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">虽然使用Python的标准库来设置CLI是可能的(并且仍然非常简单),但是它很快就会变得冗长。下面是一个简单的例子，说明如何为一个脚本创建一个CLI来打印到<code class="fe mk ml mm mn b">n</code>的斐波那契数列:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="d619" class="mx kw iq mn b gy my mz l na nb"># fib.py<br/>import argparse</span><span id="80f7" class="mx kw iq mn b gy nd mz l na nb">def fibonacci(n, a=0, b=1):<br/>    """Print the Fibonacci series up to n."""<br/>    while a &lt;= n:<br/>        print(a)<br/>        a, b = b, a + b</span><span id="44d5" class="mx kw iq mn b gy nd mz l na nb">if __name__ == "__main__":<br/>    parser = argparse.ArgumentParser()<br/>    parser.add_argument("-n", type=int)<br/>    args = parser.parse_args()<br/>    fibonacci(args.n)</span></pre><p id="a49a" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">现在，要执行它，您可以运行:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="cba1" class="mx kw iq mn b gy my mz l na nb">python fib.py -n 13</span></pre><p id="2e6a" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">您应该看到Fibonacci序列打印到控制台。很简单。现在让我们假设你想设置你的初始条件<code class="fe mk ml mm mn b">a</code>和<code class="fe mk ml mm mn b">b</code>。您可以通过以下方式实现:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="8c22" class="mx kw iq mn b gy my mz l na nb">if __name__ == "__main__":<br/>    parser = argparse.ArgumentParser()<br/>    parser.add_argument("-n", type=int)<br/>    parser.add_argument("-a", type=int)<br/>    parser.add_argument("-b", type=int)<br/>    args = parser.parse_args()<br/>    fibonacci(args.n, a=args.a, b=args.b)</span></pre><p id="aadc" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">仍然很简单，但是你的代码很快变得有点臃肿。您可能会想象，随着函数签名中参数数量的增加(或添加新函数)，我们的<code class="fe mk ml mm mn b">ArgumentParser</code>块将会快速增长，跟踪所有这些函数及其参数可能会变得非常复杂，最终可能会构成几十行代码。此外，对于简单的脚本来说，这可能是一个足够大的障碍，添加CLI可能看起来有点痛苦——也许您可能<em class="nc">甚至</em>想直接在脚本中更改一些参数。</p><h1 id="6cfd" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">输入<code class="fe mk ml mm mn b">Fire</code></h1><p id="6786" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这就是<code class="fe mk ml mm mn b">Fire</code>的用武之地:它<em class="nc">自动</em>从函数/方法签名生成CLI。让我们看看最初的例子，但是这次使用<code class="fe mk ml mm mn b">Fire</code>:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="9a1a" class="mx kw iq mn b gy my mz l na nb"># fib.py<br/>import fire</span><span id="b3b9" class="mx kw iq mn b gy nd mz l na nb">def fibonacci(n, a=0, b=1):<br/>    """Print the Fibonacci series up to n."""<br/>    while a &lt;= n:<br/>        print(a)<br/>        a, b = b, a + b</span><span id="83c8" class="mx kw iq mn b gy nd mz l na nb">if __name__ == "__main__":<br/>    fire.Fire(fibonacci)</span></pre><p id="683b" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">首先，你可以用<code class="fe mk ml mm mn b">pip install fire</code>把<code class="fe mk ml mm mn b">Fire</code>安装成一个普通的Python包。在<code class="fe mk ml mm mn b">Fire</code>的项目报告上有更多的安装细节。您现在可以运行:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="2f32" class="mx kw iq mn b gy my mz l na nb">python fib.py -n 13</span></pre><p id="a530" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">您应该会看到相同的输出。您也可以运行:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="d82e" class="mx kw iq mn b gy my mz l na nb">python fib.py -n 13 -a 0 -b 1</span></pre><p id="9b23" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">如您所见，<code class="fe mk ml mm mn b">Fire</code>自动将函数签名中的<em class="nc">参数(即函数参数)映射到相应的CLI参数。只需一行代码，您就可以启动并运行CLI。但这只是一个简单的案例。让我们假设您想要为一个脚本创建一个具有许多不同功能的CLI(可能一个用于训练模型，一个用于运行推理等等。).下面是前面例子的修改版本，引入了一个新的函数和一个新的tuple对象<code class="fe mk ml mm mn b">struct</code>:</em></p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="eba8" class="mx kw iq mn b gy my mz l na nb"># cli.py<br/>import fire</span><span id="f063" class="mx kw iq mn b gy nd mz l na nb">def fibonacci(n, a=0, b=1):<br/>    """Print the Fibonacci series up to n."""<br/>    while a &lt;= n:<br/>        print(a)<br/>        a, b = b, a + b</span><span id="1299" class="mx kw iq mn b gy nd mz l na nb">def say_hello(name):<br/>    print(f"Hello, {name}!")</span><span id="b79c" class="mx kw iq mn b gy nd mz l na nb">struct = tuple(["a", "b"])</span><span id="c525" class="mx kw iq mn b gy nd mz l na nb">if __name__ == "__main__":<br/>    fire.Fire()</span></pre><p id="2c90" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">这做了一些非常有趣的事情。如果将<code class="fe mk ml mm mn b">Fire</code>函数调用的第一个参数留空，那么<code class="fe mk ml mm mn b">Fire</code>会检查当前模块中的Python对象，并通过CLI公开它们。例如，您可以运行:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="9bf3" class="mx kw iq mn b gy my mz l na nb">python cli.py fibonacci -n 13</span></pre><p id="9a3f" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">这将像以前一样运行<code class="fe mk ml mm mn b">fibonacci</code>功能。但是，您也可以运行:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="7ca7" class="mx kw iq mn b gy my mz l na nb">python cli.py say_hello Jane</span></pre><p id="9ffa" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">这将产生预期的输出<code class="fe mk ml mm mn b">Hello, Jane!</code>。也许最有趣的是，你也可以运行:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="1f8e" class="mx kw iq mn b gy my mz l na nb">python cli.py struct 0</span></pre><p id="696b" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">您应该会看到输出<code class="fe mk ml mm mn b">a</code>。同样，您可以运行:</p><pre class="kg kh ki kj gt mt mn mu mv aw mw bi"><span id="a93e" class="mx kw iq mn b gy my mz l na nb">python cli.py struct 1</span></pre><p id="0f9b" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">且看<code class="fe mk ml mm mn b">b</code>。在这种情况下，<code class="fe mk ml mm mn b">Fire</code>让您直接从CLI与本地Python对象直接交互。您也可以将这个想法扩展到您自己的定制数据结构中。</p><h1 id="35dc" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">结束语</h1><p id="301b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe mk ml mm mn b">Fire</code>是一个很棒的工具，可以在几秒钟内让干净、高质量的CLIs启动并运行，它非常简单，你几乎不需要学习任何新概念就可以在工作中使用它。将一个新模型管道快速包装在一个闪亮的新CLI中以备部署是理想的。还有一堆<a class="ae mj" href="https://github.com/google/python-fire/blob/master/docs/guide.md#grouping-commands" rel="noopener ugc nofollow" target="_blank">更高级的特性</a>你也可以用来构建更复杂的CLI。</p><p id="337b" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">然而，如果你正在构建一个全功能的CLI并想要细粒度的控制，你可能想看看古老而超级灵活的<code class="fe mk ml mm mn b"><a class="ae mj" href="https://github.com/pallets/click" rel="noopener ugc nofollow" target="_blank">click</a></code> <a class="ae mj" href="https://github.com/pallets/click" rel="noopener ugc nofollow" target="_blank">库</a>。这将为您提供尽可能多的控制(至少在Python中)。</p></div></div>    
</body>
</html>