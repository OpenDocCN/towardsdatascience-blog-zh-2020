<html>
<head>
<title>Decoding Scala without the Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无需代码即可解码Scala</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/decoding-scala-without-the-code-6db00f37c469?source=collection_archive---------47-----------------------#2020-11-09">https://towardsdatascience.com/decoding-scala-without-the-code-6db00f37c469?source=collection_archive---------47-----------------------#2020-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="76aa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入Scala的内部工作和内存管理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7148ec25028bda72614e24d9ccb1835b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_mrDN1IJycZS2kZnlJ1qmw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@nate_dumlao?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">内森·杜姆劳</a>在<a class="ae kv" href="https://unsplash.com/s/photos/coffee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6f51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在使用Spark时遇到了Scala，Spark本身就是用Scala编写的。我有着<code class="fe ls lt lu lv b">Python</code>的背景，对<code class="fe ls lt lu lv b">Java</code>一无所知，我发现<code class="fe ls lt lu lv b">Scala</code>在开始时有点令人困惑，但是随着时间的推移，我越来越喜欢它，现在，它是我大多数用例的首选语言。</p><p id="5e05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">凭借经验，我已经掌握了一些scala及其工作原理。请继续阅读，了解更多关于scala的信息，主要是非编码部分，代码是如何执行的。也许你会使用它很长一段时间，但有些东西仍然会让你感到惊讶。</p><p id="190b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我不会深入讨论如何在<code class="fe ls lt lu lv b">Scala</code>中编码，因为我相信学习一门语言没有比用它构建一些东西更好的方法，这可以在以后的时间里讨论。</p><h1 id="1bfb" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">Scala的酷在哪里？</h1><p id="592f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我对<code class="fe ls lt lu lv b">Scala</code>的第一印象是<code class="fe ls lt lu lv b">Java++</code>(好吧，这是相当蹩脚的)，但我认为<code class="fe ls lt lu lv b">Scala</code>是一个更好的<code class="fe ls lt lu lv b">Java</code>，具有几乎相似的结构和更少的<em class="mt">代码。</em></p><p id="3966" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Scala( <em class="mt">代表可扩展语言</em>)是运行在JVM上的面向对象&amp; <a class="ae kv" href="https://www.geeksforgeeks.org/functional-programming-paradigm/" rel="noopener ugc nofollow" target="_blank">函数式编程</a>语言的组合。截至2020年10月，Scala的最新版本是2.13.3</p><p id="ca0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在scala中一切都是对象</strong>，事实上，据说scala比Java更面向对象。让我们看看如何:</p><ul class=""><li id="9e38" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">像1，2这样的整数是<code class="fe ls lt lu lv b">Int</code>类的对象，而<code class="fe ls lt lu lv b">Int</code>类的方法可以在整数上调用，例如，你可以像这样在整数上调用一个方法:</li></ul><pre class="kg kh ki kj gt nd lv ne nf aw ng bi"><span id="e8bb" class="nh lx iq lv b gy ni nj l nk nl">print(-1.abs) # absolute value of -1<br/>1</span></pre><ul class=""><li id="a619" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">函数是Scala中<code class="fe ls lt lu lv b">Function</code>trait的对象。(<a class="ae kv" href="https://gleichmann.wordpress.com/2010/11/08/functional-scala-functions-as-objects-as-functions/#:~:text=Since%20Functions%20are%20Objects%20in,Function2%20as%20the%20underlying%20type." rel="noopener ugc nofollow" target="_blank">读作</a>)</li></ul><p id="69a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Scala允许惰性求值，</strong>可用于资源的优化使用。Scala的惰性求值允许表达式，代码直到第一次使用才被求值。Scala的这一特性是Spark工作的基本原则，即Spark是延迟评估的。</p><p id="2a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Scala自动做类型干涉，</strong>我们并不总是需要在声明的时候定义变量的类型。在大多数情况下，编译器可以在编译时检测到变量的类型。(<a class="ae kv" href="https://en.wikipedia.org/wiki/Type_inference#:~:text=Type%20inference%20is%20the%20ability,type%20annotations%20having%20been%20given." rel="noopener ugc nofollow" target="_blank">类型推理如何工作</a>)</p><p id="5847" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Scala看起来是解释型的，但实际上它是编译型的，所以速度更快，</strong>尽管乍看起来Scala似乎是一种解释型语言，至少对我来说是这样。因为我们有一个可用的scala shell，我们可以在其中执行测试代码，就像Python一样，我还假设scala是一种解释型语言。</p><p id="54df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">scala</code>命令启动一个交互式shell，在这里Scala表达式被交互式地解释。外壳是REPL，它在引擎盖下编译代码&amp;运行编译好的代码。</p><p id="be8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Scala与Java紧密集成，所以如果需要的话，你可以混合Java和Scala来编写代码。此外，几乎所有的Java库都可以导入Scala。</p><p id="525b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<strong class="ky ir"> Scala是用Scala </strong>写的，就是这么酷！(<a class="ae kv" href="https://stackoverflow.com/a/19580470" rel="noopener ugc nofollow" target="_blank">参考</a>)</p><h1 id="ec4e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">Scala代码是如何工作的？</h1><p id="488b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">Scala代码被编译成Java字节码，由Java虚拟机(JVM)执行，这实质上就是我们如何混合使用Java和Scala代码。</p><p id="03b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JVM是一种抽象的计算机器，它使计算机能够运行Java程序。由于scala代码被编译成Java字节码，所以它是通过JVM执行的。</p><p id="2138" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JVM基本上就是Java神了(<em class="mt">也</em> <em class="mt">对于我们scala peeps </em>)，越早学会越好。它负责所有的事情，从加载代码、验证代码、执行代码、内存管理、从操作系统分配资源，最后是运行时环境。</p><h1 id="6a44" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">Scala中的内存管理</h1><p id="c137" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">Scala运行在JVM上，所以它采用类似Java的内存管理。所有的执行都依赖于内存&amp;我们可以将内存管理定义为从操作系统分配资源，并释放不必要的内存以避免出现OOM错误。(将在后面讨论)</p><p id="92d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在更高的层次上，JVM内存由三部分组成:堆、栈和其他。让我们试着一个一个去理解每一个组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/186189fc463b9e93fd2345f1c2e9504d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*4SMWHlMmLbhRzCjymHnGFw.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JVM内存架构(图片由我在<a class="ae kv" href="http://draw.io/" rel="noopener ugc nofollow" target="_blank">http://draw.io/</a>上创建)</p></figure><h2 id="a655" class="nh lx iq bd ly nn no dn mc np nq dp mg lf nr ns mi lj nt nu mk ln nv nw mm nx bi translated">许多</h2><p id="de7c" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">堆存储实际的对象，并在JVM启动时创建。只有一个堆空间由所有JVM进程共享。另外，请注意垃圾收集器(或GC)只在堆内存上运行。</p><p id="9085" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">堆的大小可以是固定的，也可以是可变的，这取决于GC策略。用户可以使用–Xmx选项设置最大堆大小，默认为64 MB。</p><h2 id="f541" class="nh lx iq bd ly nn no dn mc np nq dp mg lf nr ns mi lj nt nu mk ln nv nw mm nx bi translated">堆</h2><p id="410a" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">堆栈区域是用线程创建的。它存储对堆内存中存储的对象的本地引用。</p><p id="ee24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于其LIFO结构，堆栈非常适合为方法清理空间，因此，我们不需要随机访问数据。</p><h2 id="af32" class="nh lx iq bd ly nn no dn mc np nq dp mg lf nr ns mi lj nt nu mk ln nv nw mm nx bi translated">其他的</h2><p id="662d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">这个部分存储特定于JVM的代码和数据。</p><h2 id="10fd" class="nh lx iq bd ly nn no dn mc np nq dp mg lf nr ns mi lj nt nu mk ln nv nw mm nx bi translated">垃圾收集器(<em class="ny">特别提及</em>):</h2><p id="97eb" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">随着时间的推移，未被引用的对象会导致堆内存增加，清理堆内存是内存管理的一个重要组成部分。但作为用户，我们不必担心自己清理这些未被引用的对象，即所谓的垃圾。GC或垃圾收集器为我们完成了这项工作。</p><p id="da10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">垃圾收集器是一个守护进程，它清理由未使用或未引用的对象占用的不必要的内存。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="aec1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然用户并不总是需要干预GC、JVM内存管理或scala的内部工作，因为大部分工作都是它自己完成的，但是了解内部工作可能会帮助我们更好地理解代码，并知道在哪里花费精力。另外，这很有趣！</p><p id="4029" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，这是JVM内存架构的高级概述，它在更深的层次上变得更加有趣，包括各个组件，如年轻一代、老一代、小型GC等。我可能会写一篇同样的后续文章，让我知道你的反馈。</p><p id="a57e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快乐编码，<br/>再见。</p></div></div>    
</body>
</html>