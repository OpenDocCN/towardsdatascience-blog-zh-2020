<html>
<head>
<title>A Machine Learning Approach To Credit Risk Assessment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">信用风险评估的机器学习方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-machine-learning-approach-to-credit-risk-assessment-ba8eda1cd11f?source=collection_archive---------5-----------------------#2020-11-02">https://towardsdatascience.com/a-machine-learning-approach-to-credit-risk-assessment-ba8eda1cd11f?source=collection_archive---------5-----------------------#2020-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="71a4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">分类任务</h2><div class=""/><div class=""><h2 id="c715" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated"><em class="kr">预测贷款违约及其概率</em></h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/43a819ff93826028650ab2b73b6d78ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-a-6RleVRKJfSRXJ0MzP8w.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">来源:unDraw.co<a class="ae li" href="https://undraw.co/" rel="noopener ugc nofollow" target="_blank"/></p></figure><h2 id="34d0" class="lj lk it bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md iz bi translated">1.介绍</h2><p id="f05b" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm ls mn mo mp lw mq mr ms ma mt mu mv mw im bi translated">信用违约风险被简单地称为由于借款人未能偿还贷款而给贷款人造成损失的可能性。信用分析师通常负责通过彻底分析借款人偿还贷款的能力来评估这种风险——但信用分析师的时代已经一去不复返了，现在是机器学习时代！由于其无与伦比的预测能力和速度，机器学习算法可以为信用风险评估领域提供很多东西。在这篇文章中，我们将利用机器学习的力量来预测借款人是否会拖欠贷款，并预测他们的违约概率。让我们开始吧。</p><h2 id="6b03" class="lj lk it bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md iz bi translated">2.资料组</h2><p id="4ab3" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm ls mn mo mp lw mq mr ms ma mt mu mv mw im bi translated">我们正在使用的数据集可以在<a class="ae li" href="https://www.kaggle.com/laotse/credit-risk-dataset" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上找到，它包含32，581名借款人的数据和与每个借款人相关的11个变量。让我们看看这些变量是什么:</p><ul class=""><li id="edc5" class="mx my it mg b mh mz mk na ls nb lw nc ma nd mw ne nf ng nh bi translated">年龄——数字变量；年龄(年)</li><li id="1294" class="mx my it mg b mh ni mk nj ls nk lw nl ma nm mw ne nf ng nh bi translated">收入——数字变量；美元年收入</li><li id="b496" class="mx my it mg b mh ni mk nj ls nk lw nl ma nm mw ne nf ng nh bi translated">家庭状况——分类变量；“租金”、“抵押贷款”或“自有”</li><li id="59db" class="mx my it mg b mh ni mk nj ls nk lw nl ma nm mw ne nf ng nh bi translated">就业时间——数值变量；就业年限(年)</li><li id="0c9e" class="mx my it mg b mh ni mk nj ls nk lw nl ma nm mw ne nf ng nh bi translated">贷款意向——分类变量；“教育”、“医疗”、“风险”、“家居装修”、“个人”或“债务合并”</li><li id="a41c" class="mx my it mg b mh ni mk nj ls nk lw nl ma nm mw ne nf ng nh bi translated">贷款金额——数字变量；贷款金额(美元)</li><li id="b45f" class="mx my it mg b mh ni mk nj ls nk lw nl ma nm mw ne nf ng nh bi translated">贷款等级——分类变量；“A”、“B”、“C”、“D”、“E”、“F”或“G”</li><li id="50f0" class="mx my it mg b mh ni mk nj ls nk lw nl ma nm mw ne nf ng nh bi translated">利率——数字变量；百分比利率</li><li id="6624" class="mx my it mg b mh ni mk nj ls nk lw nl ma nm mw ne nf ng nh bi translated">贷款收入比——数字变量；介于0和1之间</li><li id="3e1c" class="mx my it mg b mh ni mk nj ls nk lw nl ma nm mw ne nf ng nh bi translated">历史默认值—二元、分类变量；“Y”或“N”</li><li id="661c" class="mx my it mg b mh ni mk nj ls nk lw nl ma nm mw ne nf ng nh bi translated">贷款状态—二进制数字变量；0(无默认值)或1(默认值)→这将是我们的目标变量</li></ul><p id="f107" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">现在我们知道了我们在这里处理的是什么样的变量，让我们来看看事情的本质。</p><h2 id="83da" class="lj lk it bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md iz bi translated">3.数据探索和预处理</h2><p id="c961" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm ls mn mo mp lw mq mr ms ma mt mu mv mw im bi translated">首先，让我们继续检查数据集中缺失的值。</p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="78c3" class="lj lk it nr b gy nv nw l nx ny">#Checking for missing values<br/>data.isnull().sum()</span><span id="cb66" class="lj lk it nr b gy nz nw l nx ny">Age                       0 <br/>Income                    0 <br/>Home_Status               0 <br/>Employment_Length       895 <br/>Loan_Intent               0 <br/>loan_Grade                0 <br/>Loan_Amount               0 <br/>Interest_Rate          3116 <br/>Loan_Status               0 <br/>loan_percent_income       0 <br/>Historical_Default        0 <br/>dtype: int64</span></pre><p id="6b40" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">我们可以看到就业时间和利率都有缺失值。鉴于缺失值只占数据集的一小部分，我们将删除包含缺失值的行。</p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="231c" class="lj lk it nr b gy nv nw l nx ny">#Dropping missing values<br/>data = data.dropna(axis=0)</span></pre><p id="bd5d" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">接下来，我们将寻找数据集中的异常值，以便进行相应的补救。我们将使用describe()方法来完成这项工作，该方法用于计算描述性统计数据。它不仅有助于识别异常值，还能让我们更好地理解数据是如何分布的。我们还将使用散点图矩阵，这是一个散点图网格，用于可视化变量组合之间的二元关系，以直观地检测异常值。</p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="d6f3" class="lj lk it nr b gy nv nw l nx ny">data.describe()</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oa"><img src="../Images/6d184170cc3aeeb00399004f012032f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_rmjKX5-knDSYrMKspC8A.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片</p></figure><p id="7d89" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">我不知道你的情况，但我没遇到过那么多活到144岁或工作了123年的人。除此之外，来自变量<em class="ob">年龄</em>和<em class="ob">就业时间</em>的异常值可能会对<em class="ob"> </em>的模型产生负面影响，因此应该被移除。在此之前，我们将使用散点图矩阵寻找更多的异常值。</p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="fbde" class="lj lk it nr b gy nv nw l nx ny">#Scatterplot matrix<br/>fig = px.scatter_matrix(data, dimensions=<br/>["Age","Income","Employment_Length","Loan_Amount","Interest_Rate"],<br/>labels={col:col.replace('_', ' ') for col in data.columns},           height=900, color="Loan_Status", color_continuous_scale=px.colors.diverging.Tealrose)<br/>fig.show()</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oc"><img src="../Images/cf57e0573bea2209c569c0388488f382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aLDBHoWBye8I82bjhE5vw.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片</p></figure><p id="f7a5" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">现在很清楚的是<em class="ob">收入</em>也有一个需要剔除的异常值。我们现在将使用下面几行代码删除所有异常值。</p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="6f8b" class="lj lk it nr b gy nv nw l nx ny">#Removing outliers<br/>data = data[data["Age"]&lt;=100]<br/>data = data[data["Employment_Length"]&lt;=100]<br/>data = data[data["Income"]&lt;= 4000000]</span></pre><p id="ea5f" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">鉴于我们数据集的性质，我们预计我们正在处理一个不平衡的分类问题，这意味着我们的非违约案例比违约案例多得多。使用下面的代码，我们确认78.4%的数据集包含非默认案例的情况确实如此。</p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="4c22" class="lj lk it nr b gy nv nw l nx ny">#Percentage of non-default cases<br/>data_0 = data[data.Loan_Status == 0].Loan_Status.count() / data.Loan_Status.count()<br/>data_0</span></pre><p id="146b" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">考虑到这一点，我们现在将进一步探索<em class="ob">贷款状态</em>如何与数据集中的其他变量相关联。</p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="017c" class="lj lk it nr b gy nv nw l nx ny">#Box plot<br/>fig = px.box(data, x="loan_Grade", y="loan_percent_income", color="Loan_Status",<br/>color_discrete_sequence=px.colors.qualitative.Dark24,<br/>labels={col:col.replace('_', ' ') for col in data.columns},<br/>category_orders={"loan_Grade":["A","B","C","D","E","F","G"]})<br/>fig.update_layout(legend=dict(orientation="h", yanchor="bottom",<br/>y=1.02, xanchor="right", x=1))<br/>fig.show()</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oc"><img src="../Images/e1fac05696e76d2e7fa5aab7ad7570be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ttRnl8-opCGtbWiNrCs8pw.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片</p></figure><p id="089d" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">当我们看这个方框图时，两件事很快就凸显出来了。我们可以清楚地看到，那些没有违约的人在所有贷款等级中都有较低的贷款收入比均值；这并不奇怪。我们还可以看到，没有贷款等级为G的借款人能够偿还他们的贷款！</p><p id="2be5" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">使用平行类别图，我们可以了解数据集中不同类别变量之间的相互关系，并且我们可以根据<em class="ob">贷款状态绘制出这些关系。</em></p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="3257" class="lj lk it nr b gy nv nw l nx ny">#Parallel category diagram<br/>fig = px.parallel_categories(data, color_continuous_scale=px.colors.sequential.RdBu, color="Loan_Status",<br/>dimensions=['Home_Status', 'Loan_Intent', "loan_Grade", 'Historical_Default'], labels={col:col.replace('_', ' ') for col in data.columns})<br/>fig.show()</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi od"><img src="../Images/3c19e65d2269376dad1446d1685206be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gxLe5Ds4Fbi52y9YWxPAg.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片</p></figure><p id="c1aa" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">上图的主要要点:</p><ul class=""><li id="5fa3" class="mx my it mg b mh mz mk na ls nb lw nc ma nd mw ne nf ng nh bi translated">我们的数据集主要由以前从未拖欠过贷款的借款人组成；</li><li id="2f8c" class="mx my it mg b mh ni mk nj ls nk lw nl ma nm mw ne nf ng nh bi translated">贷款等级“A”和“B”是最常见的等级，而“F”和“G”是最不常见的等级；</li><li id="26c1" class="mx my it mg b mh ni mk nj ls nk lw nl ma nm mw ne nf ng nh bi translated">房屋租赁者比有抵押贷款的人更经常拖欠贷款，而房主拖欠的最少；</li><li id="be34" class="mx my it mg b mh ni mk nj ls nk lw nl ma nm mw ne nf ng nh bi translated">借款人用于房屋装修的贷款最少，用于教育的贷款最多。此外，用于支付医疗费用和债务整合的贷款违约更为常见。</li></ul><p id="9bb6" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">在我们开始模型训练之前，我们需要确保我们所有的变量都是数值型的，因为我们将要使用的一些模型不能对标签数据进行操作。我们可以简单地使用一键编码方法来做到这一点。</p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="073c" class="lj lk it nr b gy nv nw l nx ny">#One hot encoding of categorical variables<br/>df = pd.get_dummies(data=data,columns=['Home_Status','Loan_Intent','loan_Grade','Historical_Default'])</span></pre><p id="13fb" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">现在是时候将我们的数据集分割成一列并测试分割，我们将准备好开始构建一些模型。</p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="060d" class="lj lk it nr b gy nv nw l nx ny">#Train and test split<br/>Y = df['Loan_Status']<br/>X = df.drop('Loan_Status',axis=1)<br/>x_train, x_test, y_train, y_test = model_selection.train_test_split(X, Y, random_state=0, test_size=.20)</span></pre><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oe of l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated"><a class="ae li" href="https://giphy.com/gifs/gotham-fox-3o7abuqxszgO6pFb3i/links" rel="noopener ugc nofollow" target="_blank"> Giphy </a></p></figure><h2 id="de32" class="lj lk it bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md iz bi translated">4.模型训练和评估</h2><p id="2c30" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm ls mn mo mp lw mq mr ms ma mt mu mv mw im bi translated">在本节中，我们将训练和测试3个模型，即KNN、逻辑回归和XGBoost。我们还将评估他们在预测贷款违约及其概率方面的表现。</p><p id="1800" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">首先，我们将构建模型并查看一些评估指标，以评估模型预测类别标签的能力，即默认或无默认。</p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="d24f" class="lj lk it nr b gy nv nw l nx ny">def model_assess(model, name='Default'):<br/>model.fit(x_train, y_train)<br/>preds = model.predict(x_test)<br/>preds_proba = model.predict_proba(x_test)<br/>print('                   ', name, '\n',<br/>classification_report(y_test, model.predict(x_test)))</span><span id="3eae" class="lj lk it nr b gy nz nw l nx ny">#KNN<br/>knn = KNeighborsClassifier(n_neighbors=151)<br/>model_assess(knn, name='KNN')</span><span id="43a2" class="lj lk it nr b gy nz nw l nx ny">#Logistic Regression<br/>lg = LogisticRegression(random_state=0)<br/>model_assess(lg, 'Logistic Regression')</span><span id="d8bb" class="lj lk it nr b gy nz nw l nx ny">#XGB<br/>xgb = XGBClassifier(n_estimators=1000, learning_rate=0.05)model_assess(xgb, 'XGBoost')</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi og"><img src="../Images/6913c7574d58e20431fb7a6a4b7a0564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*zRCbQjVMUjEFuonoEXOe1Q.png"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片</p></figure><p id="e53c" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">我们之前已经认识到，我们正在处理一个不平衡的数据集，因此我们需要确保我们在我们的案例中使用了适当的评估指标。出于这个原因，我们将对常见的<strong class="mg jd">准确性</strong>指标持保留态度。为了说明为什么会出现这种情况，accuracy计算了真实预测值与输入样本总数的比率，这意味着我们的模型通过预测多数类可以获得相当高的准确性，但无法捕获少数类default，这可不是什么好事。这就是为什么我们将重点评估模型分类性能的评估指标是<strong class="mg jd">精度</strong>、<strong class="mg jd">召回</strong>和<strong class="mg jd"> F1 </strong> <strong class="mg jd">得分</strong>。</p><p id="09f8" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">首先，<strong class="mg jd"> Precision </strong>给出了分类器预测的真阳性与总阳性的比率，其中阳性表示我们上下文中的默认情况。考虑到它们是我们数据集中的少数类，我们可以看到我们的模型在正确预测这些次要实例方面做得很好。此外，<strong class="mg jd">回忆，</strong>也称为真阳性率，给出了真阳性的数量除以实际上属于阳性类的元素总数。在我们的例子中，回忆<strong class="mg jd"> </strong>是一个比精确度更重要的指标，因为我们更关心假阴性(我们的模型预测某人不会违约，但他们会违约)而不是假阳性(我们的模型预测某人会违约，但他们不会)。最后，<strong class="mg jd"> F1分数</strong>提供了一个衡量精确度和召回率的单一分数。现在我们知道了要寻找什么，我们可以清楚地看到XGboost在所有3个指标中表现最好。尽管它在精确度上比在召回上得分更高，但它仍然有0.81的不错的F1分数。</p><p id="c8c7" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">我们现在来看看<strong class="mg jd"> ROC </strong>其中<strong class="mg jd"> </strong>是一条概率曲线，x轴是假阳性率(FPR)，y轴是真阳性率(TPR，召回)。最佳模型应该最大化TPR为1，最小化FPR为0。也就是说，我们可以使用ROC曲线曲线下的面积<strong class="mg jd"> AUC </strong>来比较分类器，其中其值越高，该模型在预测0为0和1为1时就越好。</p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="d290" class="lj lk it nr b gy nv nw l nx ny">#ROC AUC<br/>fig = plt.figure(figsize=(14,10))<br/>plt.plot([0, 1], [0, 1],'r--')</span><span id="9189" class="lj lk it nr b gy nz nw l nx ny">#KNN<br/>preds_proba_knn = knn.predict_proba(x_test)<br/>probsknn = preds_proba_knn[:, 1]<br/>fpr, tpr, thresh = metrics.roc_curve(y_test, probsknn)<br/>aucknn = roc_auc_score(y_test, probsknn)<br/>plt.plot(fpr, tpr, label=f'KNN, AUC = {str(round(aucknn,3))}')</span><span id="a5e5" class="lj lk it nr b gy nz nw l nx ny">#Logistic Regression<br/>preds_proba_lg = lg.predict_proba(x_test)<br/>probslg = preds_proba_lg[:, 1]<br/>fpr, tpr, thresh = metrics.roc_curve(y_test, probslg)<br/>auclg = roc_auc_score(y_test, probslg)<br/>plt.plot(fpr, tpr, label=f'Logistic Regression, AUC = {str(round(auclg,3))}')</span><span id="9069" class="lj lk it nr b gy nz nw l nx ny">#XGBoost<br/>preds_proba_xgb = xgb.predict_proba(x_test)<br/>probsxgb = preds_proba_xgb[:, 1]<br/>fpr, tpr, thresh = metrics.roc_curve(y_test, probsxgb)<br/>aucxgb = roc_auc_score(y_test, probsxgb)<br/>plt.plot(fpr, tpr, label=f'XGBoost, AUC = {str(round(aucxgb,3))}')</span><span id="82c2" class="lj lk it nr b gy nz nw l nx ny">plt.ylabel("True Positive Rate")<br/>plt.xlabel("False Positive Rate")<br/>plt.title("ROC curve")<br/>plt.rcParams['axes.titlesize'] = 18<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oh"><img src="../Images/cac540586c6a470564291263ccab4497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsaKuaQCu_V-HOCT1JEQZQ.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片</p></figure><p id="00ff" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">我们可以再次看到，XGBoost性能最好，因为它具有最高的AUC，因此是区分默认和非默认类的最佳分类器。</p><p id="a73e" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">到目前为止，我们已经研究了每个模型预测类别标签的能力，现在我们将评估它们在预测样本属于正类别的概率(即违约概率)方面的性能。对于这项任务，我们将使用<strong class="mg jd">可靠性图</strong>和<strong class="mg jd"> Brier评分</strong>，其中前者创建实际概率与测试集预测概率的图表，后者计算预测概率与其各自正类值之间的均方误差。考虑到Brier得分是一个成本函数，Brier得分越低表示预测越准确。</p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="0750" class="lj lk it nr b gy nv nw l nx ny">#Reliability plot and Brier Score<br/>fig = plt.figure(figsize=(14,10))<br/>plt.plot([0, 1], [0, 1], color="black")</span><span id="5b13" class="lj lk it nr b gy nz nw l nx ny">#KNN<br/>knn_y, knn_x = calibration_curve(y_test, preds_proba_knn[:,1], n_bins=10, normalize=True)<br/>loss_knn = brier_score_loss(y_test, preds_proba_knn[:,1])<br/>plt.plot(knn_x, knn_y, marker='o', label=f'KNN, Brier score = {str(round(loss_knn,3))}')</span><span id="ca65" class="lj lk it nr b gy nz nw l nx ny">#Logistic Regression<br/>lg_y, lg_x = calibration_curve(y_test, preds_proba_lg[:,1], n_bins=10, normalize=True)<br/>loss_lg = brier_score_loss(y_test, preds_proba_lg[:,1])<br/>plt.plot(lg_x, lg_y, marker='o',label=f'Logistic Regression, Brier score = {str(round(loss_lg,3))}')</span><span id="26ec" class="lj lk it nr b gy nz nw l nx ny">#XGBoost<br/>preds_proba_xgb = xgb.predict_proba(x_test)<br/>xgb_y, xgb_x = calibration_curve(y_test, preds_proba_xgb[:,1], n_bins=10, normalize=True)<br/>loss_xgb = brier_score_loss(y_test, preds_proba_xgb[:,1])<br/>plt.plot(xgb_x, xgb_y, marker='o', label=f'XGBoost, Brier score = {str(round(loss_xgb,3))}')</span><span id="f59b" class="lj lk it nr b gy nz nw l nx ny">plt.ylabel("Actual probabilty")<br/>plt.xlabel("Predicted probability")<br/>plt.title("Reliability plot")<br/>plt.rcParams['axes.titlesize'] = 18<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oh"><img src="../Images/b74e49f7a307fddc3bc6e30ce56dee7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mPMu6HnsMdeYWi46KQuQUQ.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片</p></figure><p id="4283" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">我们可以从上面的Brier评分中看到，与其他型号相比，XGBoost再次表现最佳，这并不令人惊讶。从这个分数和图中，我们得出结论，我们的模型对于概率预测来说是校准良好的，这意味着预测的概率与每个类别的预期概率分布非常匹配，因此不需要进一步校准。</p><p id="6746" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">不用说，哪个模型被选为我们在预测类别标签和违约概率方面表现最好的模型。如果你不知何故跳过了前面所有的步骤，发现自己在这里，你应该回去读一下，顺便说一下，这是XGBoost。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oe of l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated"><a class="ae li" href="https://giphy.com/gifs/bestcoast-Vdoc3Q62X6aUro6Dv1/links" rel="noopener ugc nofollow" target="_blank">吉菲</a></p></figure><h2 id="3092" class="lj lk it bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md iz bi translated">5.特征重要性</h2><p id="19c4" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm ls mn mo mp lw mq mr ms ma mt mu mv mw im bi translated">最后但并非最不重要的一点，是时候确定哪些特征对预测我们的目标变量最有影响了。对于这个任务，我们将通过<strong class="mg jd">信息增益</strong>使用特性重要性，它测量每个特性对XGBoost中每棵树的贡献。</p><pre class="kt ku kv kw gt nq nr ns nt aw nu bi"><span id="e04d" class="lj lk it nr b gy nv nw l nx ny">#Feature importance plot<br/>fig, (ax1, ax2) = plt.subplots(figsize = (15, 17), ncols=1, nrows=2)<br/>plt.subplots_adjust(left=0.125, right=0.9, bottom=0.1, top = 0.9, wspace=0, hspace = 0.5)</span><span id="b869" class="lj lk it nr b gy nz nw l nx ny">plot_importance(xgb, importance_type='gain', ax = ax1)<br/>ax1.set_title('Feature Importance by Information Gain', fontsize = 18)<br/>ax1.set_xlabel('Gain')</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oi"><img src="../Images/759baaff47494e9602ab4678558d7d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HitSoAsR3YroE7QgslKnQ.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片</p></figure><p id="29b4" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">从上图中我们可以看出，作为住房状况的租金、贷款收入比和贷款等级C是预测贷款违约及其概率的三个最重要的特征。</p><p id="10bd" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">就这样。</p><h2 id="15f2" class="lj lk it bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md iz bi translated">6.结论</h2><p id="4413" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm ls mn mo mp lw mq mr ms ma mt mu mv mw im bi translated">总之，我们分析和预处理了我们的数据，训练和评估了3个模型，纳姆利KNN，逻辑回归和XGBoost，以了解它们预测贷款违约的能力和概率。我们使用Precision、Recall、F1和ROCAUC来评估模型在预测类别标签方面的性能。我们特别使用了这些指标，并放弃了准确性，因为我们正在处理一个不平衡的数据集。我们还使用可靠性图和Brier评分来评估我们的模型的校准。在确定XGBoost在所有指标上表现最佳之后，我们使用信息增益的特性重要性研究了哪些特性对我们的预测最重要。说完这些，我们就可以总结我们的演示了，机器学习是如何应用于信用风险评估领域的。</p><p id="bafa" class="pw-post-body-paragraph me mf it mg b mh mz kd mj mk na kg mm ls nn mo mp lw no mr ms ma np mu mv mw im bi translated">希望你觉得这篇文章很有见地！</p></div></div>    
</body>
</html>