<html>
<head>
<title>Understanding Python Multithreading and Multiprocessing via Simulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过模拟了解Python多线程和多重处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-python-multithreading-and-multiprocessing-via-simulation-3f600dbbfe31?source=collection_archive---------26-----------------------#2020-09-21">https://towardsdatascience.com/understanding-python-multithreading-and-multiprocessing-via-simulation-3f600dbbfe31?source=collection_archive---------26-----------------------#2020-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d303" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">边做边学:简单的模拟有助于更好地理解复杂的想法，如多线程和多重处理。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1f0a57bb818e8d5aa0d6a238b607827a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mukRmicBJZdRU4m3qf_dUw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@hue12_photography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> hue12摄影</a>拍摄</p></figure><p id="2192" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python是一种优秀的通用语言，在各个领域都有应用。然而，有时候你只是希望它能进一步加速。提高速度的一个方法是用多线程或多重处理来并行工作。</p><p id="fda0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有许多很好的资源可以解释这两者的概念。为了避免重复劳动，这里有一些我认为非常有用的方法。</p><ul class=""><li id="4ca7" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://stackoverflow.com/questions/18114285/what-are-the-differences-between-the-threading-and-multiprocessing-modules" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/18114285/线程与多处理模块的区别是什么</a></li><li id="696d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/contentsquare-engineering-blog/multithreading-vs-multiprocessing-in-python-ece023ad55a" rel="noopener">https://medium . com/content square-engineering-blog/multi threading-vs-multi processing-in-python-ECE 023 ad 55 a</a></li><li id="cbc0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://www.geeksforgeeks.org/difference-between-multithreading-vs-multiprocessing-in-python/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/difference-between-multi threading-vs-multi processing-in-python/</a></li><li id="156a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/concurrent.futures.html</a></li></ul><p id="75ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我想为那些想进一步探索概念并在自己的笔记本电脑上进行测试的人提供一个简单的模拟。所以我们开始吧！</p><h1 id="ab23" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">模拟设置</h1><p id="f980" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">概括地说，我通过以下步骤创建了一个模拟:</p><ul class=""><li id="dbcd" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">创建两个函数来模拟IO密集型和CPU密集型任务</li><li id="22bc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用“<a class="ae kv" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank"> concurrent.futures </a>”模块创建一个“中枢”函数，在不同的并行化设置下模拟执行一个任务100次</li><li id="2f86" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用Python的“timeit”函数执行“hub”函数5次，以获得给定并行化设置下的平均花费时间</li></ul><p id="2615" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是包含设置细节的代码块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="c13e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">性能比较</h1><p id="6438" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我在本地笔记本电脑上的测试结果在这里分享。请注意，在不同的硬件环境下，确切的模拟数字会有所不同，但原则应该始终适用。</p><p id="7de8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在下面的图表中显示了模拟结果:x轴是工作人员的数量(例如线程号或进程号)，y轴是完成计算所花费的时间。四种不同的颜色标记了不同的设置:CPU繁重任务的多处理(蓝色)，CPU繁重任务的多线程(红色)，IO繁重任务的多处理(黄色)，IO繁重任务的多线程(绿色)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/15df1549935c3f20d69ba6145ed6d7c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pvoS6dcH2MREnhJd8DoJYw.png"/></div></div></figure><p id="2ece" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从图表中可以很容易地看出一些发现:</p><ol class=""><li id="09fe" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ng ly lz ma bi translated">“多线程”和“多处理”在IO繁重任务中同样有效。随着工作人员的增加，总任务花费的时间从大约10秒(1个工作人员)减少到1.3秒(8个工作人员)，这意味着速度提高了大约8倍。</li><li id="0099" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ng ly lz ma bi translated"><strong class="ky ir">“多线程”在CPU繁重的任务上表现不佳。</strong>红色条形图显示，无论使用多少“线程”,总花费时间始终在10秒左右。</li><li id="75f4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ng ly lz ma bi translated"><strong class="ky ir">“多处理”在CPU繁重的任务上是有效的，然而，它在硬件限制下达到了一个平台。</strong>在我的例子中，当worker #大于等于5时，它的最大加速仍然是5X (~2秒)，小于他们的实际worker #(例如6、7、8)。这是因为我的笔记本电脑有6个内核，鉴于系统需要1个内核来维持其功能，其余5个内核可用于计算，因此最大速度提升是5X。</li></ol><p id="54a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看一下硬件概述，您会发现我的笔记本电脑的6核特性以及启用的“超线程技术”,因此线程数不限于处理器数6。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/7138b53641ce06ff4c3da07b8319e0b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*8FKesiOUntBtm8X3BibAHw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我的笔记本电脑硬件概述</p></figure><p id="cc79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你喜欢这篇短文，并自己练习。更重要的是，您现在应该对Python中多线程和多处理的区别有了更好的理解。</p><p id="f421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">边做边学既有趣又有效。尽情享受吧！</p><p id="f7b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi">— — — — — — — — — — — — — —</p><p id="e608" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这篇文章，通过点赞、分享和评论来帮助传播。潘目前是LinkedIn的数据科学经理。可以看之前的文章，关注他上<a class="ae kv" href="https://www.linkedin.com/in/panwu/" rel="noopener ugc nofollow" target="_blank"><em class="ni">LinkedIn</em></a><em class="ni">。</em></p></div></div>    
</body>
</html>