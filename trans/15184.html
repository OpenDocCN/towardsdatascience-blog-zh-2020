<html>
<head>
<title>NumPy Array Processing With Cython: 5000x Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">采用Cython的NumPy阵列处理:速度提高5000倍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/numpy-array-processing-with-cython-1250x-faster-a80f8b3caa52?source=collection_archive---------14-----------------------#2020-10-19">https://towardsdatascience.com/numpy-array-processing-with-cython-1250x-faster-a80f8b3caa52?source=collection_archive---------14-----------------------#2020-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程将向您展示如何使用Cython加速NumPy数组的处理。通过在Python中显式指定变量的数据类型，Cython可以在运行时大幅提高速度。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/41aee8574301795e125ba1eba0a9cb0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NloLW7p8EId-ZMpqYfqYSQ.jpeg"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">茱莉亚·乔皮恩:【https://unsplash.com/photos/IojCPQ2rWe8】T2</p></figure><p id="b518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程涵盖的部分如下:</p><ul class=""><li id="d186" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">遍历NumPy数组</li><li id="414f" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">NumPy数组的Cython类型</li><li id="8707" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">NumPy数组元素的数据类型</li><li id="780c" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">NumPy数组作为函数参数</li><li id="1ff3" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">对NumPy数组进行索引，而不是迭代</li><li id="ec05" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">禁用边界检查和负索引</li><li id="7402" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">摘要</li></ul><p id="98ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于Cython及其使用方法的介绍，请查看我在<a class="ae lb" href="https://blog.paperspace.com/boosting-python-scripts-cython/" rel="noopener ugc nofollow" target="_blank">上发表的关于使用Cython提升Python脚本的帖子</a>。要不，我们开始吧！</p><div class="lq lr gp gr ls lt"><a href="https://blog.paperspace.com/boosting-python-scripts-cython/" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd ir gy z fp ly fr fs lz fu fw ip bi translated">使用Cython | Paperspace博客提升Python脚本</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">Python可能是当今最流行的编程语言之一，但它肯定不是最高效的。在…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">blog.paperspace.com</p></div></div><div class="mc l"><div class="md l me mf mg mc mh kv lt"/></div></div></a></div><h1 id="cb1b" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">遍历NumPy数组</h1><p id="df23" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">我们将从与上一教程相同的代码开始，除了这里我们将遍历一个NumPy数组而不是一个列表。NumPy数组是使用arrange()函数在<em class="nl"> arr </em>变量中创建的，该函数从0开始以1为步长返回10亿个数字。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="685c" class="nr mj iq nn b gy ns nt l nu nv">import time<br/>import numpy</span><span id="5a50" class="nr mj iq nn b gy nw nt l nu nv">total = 0<br/>arr = numpy.arange(1000000000)</span><span id="2cf8" class="nr mj iq nn b gy nw nt l nu nv">t1 = time.time()<br/>for k in arr:<br/>    total = total + k<br/>t2 = time.time()</span><span id="ccba" class="nr mj iq nn b gy nw nt l nu nv">print("Total = ", total)<br/>t = t2 - t1<br/>print("%.20f" % t)</span></pre><p id="52ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在一台配备Core i7–6500 u CPU @ 2.5 GHz和16 GB DDR3 RAM的机器上运行这个程序。Python代码在458秒(7.63分钟)内完成。太长了。</p><p id="2f57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看在编辑了在<a class="ae lb" href="https://blog.paperspace.com/boosting-python-scripts-cython/" rel="noopener ugc nofollow" target="_blank">之前的教程</a>中创建的Cython脚本后，需要多长时间才能完成，如下所示。唯一的变化是在<em class="nl"> for </em>循环中包含了NumPy数组。请注意，在使用Cython脚本之前，您必须使用下面的命令来重新构建它。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="0b94" class="nr mj iq nn b gy ns nt l nu nv">python setup.py build_ext --inplace</span></pre><p id="3244" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当前形式的Cython脚本在128秒(2.13分钟)内完成。仍然很长，但这是一个开始。让我们看看如何让它更快。</p><h1 id="a05d" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">NumPy数组的Cython类型</h1><p id="8002" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">之前我们看到，在为所使用的变量显式定义C类型后，Cython代码运行得非常快。NumPy数组也是这种情况。如果我们保留NumPy数组的当前形式，Cython的工作方式与常规Python完全一样，为数组中的每个数字创建一个对象。为了让事情运行得更快，我们还需要为NumPy数组定义一个C数据类型，就像为任何其他变量一样。</p><p id="1a5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">NumPy数组的数据类型为<strong class="jp ir"> <em class="nl"> ndarray </em> </strong>，代表<strong class="jp ir"> n维数组</strong>。如果您使用关键字<em class="nl"> int </em>来创建整数类型的变量，那么您可以使用<em class="nl"> ndarray </em>来创建NumPy数组的变量。注意<em class="nl">n array</em>必须使用NumPy调用，因为<em class="nl">n array</em>在NumPy内部。因此，创建NumPy数组变量的语法是<em class="nl"> numpy.ndarray </em>。下面列出的代码创建了一个名为<em class="nl"> arr </em>的变量，数据类型为NumPy <em class="nl"> ndarray </em>。</p><p id="d3fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先要注意的是，NumPy是使用第二行中的常规关键字<em class="nl"> import </em>导入的。在第三行，您可能会注意到NumPy也是使用关键字<em class="nl"> cimport </em>导入的。</p><p id="5c09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们来看看Cython文件可以分为两类:</p><ol class=""><li id="3ab1" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk nx li lj lk bi translated">定义文件(。pxd)</li><li id="656f" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nx li lj lk bi translated">实现文件(。pyx)</li></ol><p id="f2c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义文件的扩展名为。pxd，用于保存C声明，例如要导入并在其他Cython文件中使用的数据类型。另一个文件是带有扩展名的实现文件。pyx，我们目前用它来编写Cython代码。在这个文件中，我们可以导入一个定义文件来使用其中声明的内容。</p><p id="3796" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码将被写入扩展名为. pyx的实现文件中。<em class="nl"> cimport numpy </em>语句在Cython中导入一个名为“numpy”的定义文件。这样做是因为cy thon“numpy”文件具有处理NumPy数组的数据类型。</p><p id="15c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码定义了前面讨论的变量，分别是<em class="nl"> maxval </em>、<em class="nl"> total </em>、<em class="nl"> k </em>、<em class="nl"> t1 </em>、<em class="nl"> t2 </em>和<em class="nl"> t </em>。有一个名为<em class="nl"> arr </em>的新变量<em class="nl"> </em>保存数组，数据类型<code class="fe ny nz oa nn b">numpy.ndarray</code>。之前使用了两个导入语句，即<code class="fe ny nz oa nn b">import numpy</code>和<code class="fe ny nz oa nn b">cimport numpy</code>。这里哪一个是相关的？这里我们将使用需要的<code class="fe ny nz oa nn b">cimport numpy</code>，而不是常规的<code class="fe ny nz oa nn b">import</code>。这让我们可以访问在Cython numpy定义文件中声明的<em class="nl"> numpy.ndarray </em>类型，因此我们可以将<em class="nl"> arr </em>变量的类型定义为numpy.ndarray。</p><p id="bfa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nl"> maxval </em>变量被设置为等于NumPy数组的长度。我们可以从创建一个长度为10，000的数组开始，并在以后增加这个数字，以比较Cython相对于Python的改进。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="5c7b" class="nr mj iq nn b gy ns nt l nu nv">import time<br/>import numpy<br/>cimport numpy</span><span id="3cdb" class="nr mj iq nn b gy nw nt l nu nv">cdef unsigned long long int maxval<br/>cdef unsigned long long int total<br/>cdef int k<br/>cdef double t1, t2, t<br/>cdef numpy.ndarray arr</span><span id="52b2" class="nr mj iq nn b gy nw nt l nu nv">maxval = 10000<br/>arr = numpy.arange(maxval)</span><span id="a149" class="nr mj iq nn b gy nw nt l nu nv">t1 = time.time()</span><span id="d676" class="nr mj iq nn b gy nw nt l nu nv">for k in arr:<br/>    total = total + k<br/>print "Total =", total</span><span id="78ba" class="nr mj iq nn b gy nw nt l nu nv">t2 = time.time()<br/>t = t2 - t1<br/>print("%.20f" % t)</span></pre><p id="6863" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在创建了一个类型为<code class="fe ny nz oa nn b">numpy.ndarray</code>的变量并定义了它的长度之后，接下来是使用<code class="fe ny nz oa nn b">numpy.arange()</code>函数创建数组。注意，这里我们使用的是Python NumPy，它是使用<code class="fe ny nz oa nn b">import numpy</code>语句导入的。</p><p id="64c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过运行上面的代码，Cython只用了0.001秒就完成了。对于Python，代码耗时0.003秒。在这种情况下，Cython比Python快近3倍。</p><p id="afaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当<code class="fe ny nz oa nn b">maxsize</code>变量设置为100万时，Cython代码运行0.096秒，而Python需要0.293秒(Cython也快了3倍)。当处理1亿个时，Cython需要10.220秒，而Python需要37.173秒。对于10亿，Cython需要120秒，而Python需要458秒。尽管如此，Cython可以做得更好。让我们看看怎么做。</p><h1 id="e0dc" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">NumPy数组元素的数据类型</h1><p id="93b7" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">第一个改进与数组的数据类型有关。NumPy数组<code class="fe ny nz oa nn b">arr</code>的数据类型根据下一行定义。注意，我们所做的只是定义数组的类型，但是我们可以给Cython更多的信息来简化事情。</p><p id="7a27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，没有任何东西可以警告您有一部分代码需要优化。一切都会起作用；你必须调查你的代码，找出可以优化的部分，以便运行得更快。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="9052" class="nr mj iq nn b gy ns nt l nu nv">cdef numpy.ndarray arr</span></pre><p id="01b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了定义数组的数据类型，我们还可以定义两条信息:</p><ol class=""><li id="1caf" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk nx li lj lk bi translated">数组元素的数据类型</li><li id="ed63" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nx li lj lk bi translated">维度数量</li></ol><p id="60a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数组元素的数据类型是<code class="fe ny nz oa nn b">int</code>，根据下面的代码行定义。使用<strong class="jp ir"> cimport </strong>导入的numpy有一个对应于NumPy中每种类型的类型，但在末尾有<strong class="jp ir"> _t </strong>。比如常规NumPy中的<strong class="jp ir"> int </strong>对应Cython中的<strong class="jp ir"> int_t </strong>。</p><p id="2912" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参数是<code class="fe ny nz oa nn b">ndim</code>，它指定了数组中的维数。这里设置为1。请注意，它的默认值也是1，因此可以从我们的示例中省略。如果使用了更多的维度，我们必须指定它。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="7fc5" class="nr mj iq nn b gy ns nt l nu nv">cdef numpy.ndarray[numpy.int_t, ndim=1] arr</span></pre><p id="5707" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，只有当NumPy数组是函数中的一个参数或者函数中的一个局部变量时——而不是在脚本体中——才允许这样定义NumPy数组的类型。我希望Cython尽快解决这个问题。我们现在需要编辑前面的代码，将其添加到下一节将要创建的函数中。现在，让我们在定义数组之后创建它。</p><p id="98c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们将变量<code class="fe ny nz oa nn b">arr</code>的类型定义为<code class="fe ny nz oa nn b">numpy.ndarray</code>，但是不要忘记这是容器的类型。该容器包含元素，如果没有指定其他内容，这些元素将被转换为对象。为了强制这些元素为整数，根据下一行将<code class="fe ny nz oa nn b">dtype</code>参数设置为<code class="fe ny nz oa nn b">numpy.int</code> <strong class="jp ir"> </strong>。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="1c96" class="nr mj iq nn b gy ns nt l nu nv">arr = numpy.arange(maxval, dtype=numpy.int)</span></pre><p id="ac49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里使用的numpy是使用<code class="fe ny nz oa nn b">cimport</code> <strong class="jp ir"> </strong>关键字导入的。一般来说，无论何时发现用于定义变量的关键字numpy，都要确保它是使用<code class="fe ny nz oa nn b">cimport</code>关键字从Cython导入的。</p><h1 id="101e" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">NumPy数组作为函数参数</h1><p id="b2dd" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">准备好数组后，下一步是创建一个函数，它接受下面列出的类型为<code class="fe ny nz oa nn b">numpy.ndarray</code>的变量。这个函数被命名为<code class="fe ny nz oa nn b">do_calc()</code>。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="e4c3" class="nr mj iq nn b gy ns nt l nu nv">import time<br/>import numpy<br/>cimport numpy</span><span id="ba00" class="nr mj iq nn b gy nw nt l nu nv">ctypedef numpy.int_t DTYPE_t<br/>def do_calc(numpy.ndarray[DTYPE_t, ndim=1] arr):<br/>    cdef int maxval<br/>    cdef unsigned long long int total<br/>    cdef int k<br/>    cdef double t1, t2, t<br/>    <br/>    t1 = time.time()</span><span id="c95e" class="nr mj iq nn b gy nw nt l nu nv">    for k in arr:<br/>        total = total + k<br/>    print "Total = ", total<br/>    <br/>    t2 = time.time()<br/>    t = t2 - t1<br/>    print("%.20f" % t)</span></pre><p id="0f59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建完Cython脚本后，接下来我们根据下面的代码调用函数<code class="fe ny nz oa nn b">do_calc()</code>。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="bc9f" class="nr mj iq nn b gy ns nt l nu nv">import test_cython<br/>import numpy<br/>arr = numpy.arange(1000000000, dtype=numpy.int)<br/>test_cython.do_calc(arr)</span></pre><p id="8168" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种情况下的计算时间从120秒减少到98秒。这使得Cython在对10亿个数字求和时比Python快5倍。正如你现在所期望的，对我来说这仍然不够快。我们将在下一节看到另一个加速计算的技巧。</p><h1 id="470d" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">NumPy数组上的索引与迭代</h1><p id="ccc7" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">Cython只是将计算时间减少了5倍，这并不鼓励我使用Cython。但这不是Cython的问题，而是使用的问题。问题在于循环是如何产生的。让我们仔细看看下面给出的循环。</p><p id="0191" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在之前的教程中，提到了非常重要的一点，那就是Python只是一个接口。界面只是让用户觉得事情更简单。请注意，简单的方法并不总是做某事的有效方法。</p><p id="d777" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Python有一种特殊的方法来迭代数组，这在下面的循环中实现。循环变量<em class="nl"> k </em>循环遍历<em class="nl"> arr </em> NumPy数组，从数组中一个元素一个元素地取出。变量<em class="nl"> k </em>被分配给这样的返回元素。以这种方式循环遍历数组是Python中引入的一种风格，但它不是C用于循环遍历数组的方式。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="1360" class="nr mj iq nn b gy ns nt l nu nv">for k in arr:<br/>    total = total + k</span></pre><p id="03c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于编程语言来说，循环遍历数组的通常方式是从0(有时从1)开始创建索引，直到到达数组中的最后一个索引。每个索引用于索引数组以返回相应的元素。这是循环遍历数组的正常方式。因为C不知道如何以Python风格遍历数组，所以上面的循环是以Python风格执行的，因此执行起来要花很多时间。</p><p id="b931" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了克服这个问题，我们需要创建一个普通样式的循环，使用索引<code class="fe ny nz oa nn b">for</code>访问数组元素。新的循环实现如下。</p><p id="818d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，有一个名为<em class="nl">arr _ shape</em><strong class="jp ir">T5】的新变量用于存储数组中元素的数量。在我们的示例中，只有一个维度，其长度通过使用索引0索引<em class="nl"> arr.shape </em>的结果来返回。</strong></p><p id="957f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后<em class="nl"> arr_shape </em>变量被提供给<code class="fe ny nz oa nn b">range()</code>函数，该函数返回访问数组元素的索引。在这种情况下，变量<em class="nl"> k </em>代表一个索引，而不是一个数组值。</p><p id="c4bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在循环内部，通过索引<em class="nl"> k </em>对变量<em class="nl"> arr </em>进行索引来返回元素。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="1e16" class="nr mj iq nn b gy ns nt l nu nv">cdef int arr_shape = arr.shape[0]<br/>for k in range(arr_shape):<br/>    total = total + arr[k]</span></pre><p id="cd2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们编辑Cython脚本来包含上面的循环。下面列出了新脚本。旧循环被注释掉了。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="a514" class="nr mj iq nn b gy ns nt l nu nv">import time<br/>import numpy<br/>cimport numpy</span><span id="ae03" class="nr mj iq nn b gy nw nt l nu nv">ctypedef numpy.int_t DTYPE_t</span><span id="c707" class="nr mj iq nn b gy nw nt l nu nv">def do_calc(numpy.ndarray[DTYPE_t, ndim=1] arr):<br/>    cdef int maxval<br/>    cdef unsigned long long int total<br/>    cdef int k<br/>    cdef double t1, t2, t<br/>    cdef int arr_shape = arr.shape[0]</span><span id="735c" class="nr mj iq nn b gy nw nt l nu nv">    t1=time.time()</span><span id="3d64" class="nr mj iq nn b gy nw nt l nu nv">#    for k in arr:<br/>#        total = total + k</span><span id="5962" class="nr mj iq nn b gy nw nt l nu nv">    for k in range(arr_shape):<br/>        total = total + arr[k]<br/>    print "Total =", total<br/>    <br/>    t2=time.time()<br/>    t = t2-t1<br/>    print("%.20f" % t)</span></pre><p id="8df4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过构建Cython脚本，在将循环改为使用索引后，对10亿个数字求和的计算时间现在大约只有一秒钟。所以，时间从120秒减少到仅仅1秒。这是我们对Cython的期望。</p><p id="a783" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，当我们使用Python风格遍历数组时，不会发生任何错误。没有迹象可以帮助我们找出代码没有优化的原因。因此，我们必须仔细寻找代码的每一部分，寻找优化的可能性。</p><p id="ecda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，普通Python执行上述代码需要500多秒，而Cython只需要1秒左右。因此，对于10亿个数的求和，Cython比Python快500倍。超级棒。记住，为了减少计算时间，我们牺牲了Python的简单性。在我看来，将时间减少500倍，值得使用Cython优化代码。</p><p id="a91e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码速度提高500倍固然很好，但还有一个改进，这将在下一节讨论。</p><h1 id="25d1" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">禁用边界检查和负索引</h1><p id="c8a9" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">如<a class="ae lb" href="https://cython.readthedocs.io/en/latest/src/tutorial/numpy.html" rel="noopener ugc nofollow" target="_blank"> Cython文档</a>中所述，导致代码变慢的因素有以下几个:</p><ol class=""><li id="a702" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk nx li lj lk bi translated">边界检查，以确保索引在数组的范围内。</li><li id="1c8e" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nx li lj lk bi translated">使用负索引访问数组元素。</li></ol><p id="9b1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当Cython执行代码时，这两个特性是活动的。可以使用负索引(如-1)来访问数组中的最后一个元素。Cython还确保没有索引超出范围，如果出现这种情况，代码不会崩溃。如果您不需要这些功能，您可以禁用它以节省更多时间。这是通过添加以下行来实现的。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="c802" class="nr mj iq nn b gy ns nt l nu nv">cimport cython<br/>@cython.boundscheck(False)<br/>@cython.wraparound(False)</span></pre><p id="700e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">禁用这些功能后的新代码如下:</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="184e" class="nr mj iq nn b gy ns nt l nu nv">import time<br/>import numpy<br/>cimport numpy<br/>cimport cython</span><span id="db17" class="nr mj iq nn b gy nw nt l nu nv">ctypedef numpy.int_t DTYPE_t</span><span id="148e" class="nr mj iq nn b gy nw nt l nu nv">@cython.boundscheck(False) # turn off bounds-checking for entire function<br/>@cython.wraparound(False)  # turn off negative index wrapping for entire function<br/>def do_calc(numpy.ndarray[DTYPE_t, ndim=1] arr):<br/>    cdef int maxval<br/>    cdef unsigned long long int total<br/>    cdef int k<br/>    cdef double t1, t2, t<br/>    cdef int arr_shape = arr.shape[0]</span><span id="68e0" class="nr mj iq nn b gy nw nt l nu nv">    t1=time.time()</span><span id="4b59" class="nr mj iq nn b gy nw nt l nu nv">#    for k in arr:<br/>#        total = total + k</span><span id="22b1" class="nr mj iq nn b gy nw nt l nu nv">    for k in range(arr_shape):<br/>        total = total + arr[k]<br/>    print "Total =", total</span><span id="6bb6" class="nr mj iq nn b gy nw nt l nu nv">    t2=time.time()<br/>    t = t2-t1<br/>    print("%.20f" % t)</span></pre><p id="dc57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建并运行Cython脚本后，对0到100000000的数字求和的时间大约为0.09秒。与Python脚本大约500秒的计算时间相比，Cython比Python快5000多倍。</p><p id="9ba4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一段代码中使用<code class="fe ny nz oa nn b">numpy.sum()</code>函数的情况下，时间大约为0.38秒。那就是Cython快了4倍。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="49db" class="nr mj iq nn b gy ns nt l nu nv">import numpy<br/>import time</span><span id="47ae" class="nr mj iq nn b gy nw nt l nu nv">arr = numpy.arange(100000000)</span><span id="df20" class="nr mj iq nn b gy nw nt l nu nv">t1 = time.time()<br/>result = numpy.sum(arr)<br/>t2 = time.time()<br/>t = t2 - t1<br/>print("%.20f" % t)</span></pre><h1 id="f13d" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">摘要</h1><p id="fb50" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">本教程使用Cython来提高NumPy数组处理的性能。我们通过四种不同的方式实现了这一目标:</p><h1 id="d1b1" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">1.定义NumPy数组数据类型</h1><p id="86c2" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">我们首先使用<code class="fe ny nz oa nn b">numpy.ndarray</code>指定NumPy数组的数据类型。我们看到这个类型在使用<code class="fe ny nz oa nn b">cimport</code>关键字导入的定义文件中是可用的。</p><h1 id="bb83" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">2.指定数组元素的数据类型+维数</h1><p id="cfe1" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">仅仅将<code class="fe ny nz oa nn b">numpy.ndarray</code>类型赋给一个变量是一个开始——但这还不够。仍然需要提供两条信息:数组元素的数据类型和数组的维数。两者都对处理时间有很大影响。</p><p id="fc4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有当NumPy数组被定义为函数参数或函数内部的局部变量时，这些细节才会被接受。因此，我们在这些点上添加了Cython代码。您还可以指定函数的返回数据类型。</p><h1 id="6c17" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">3.使用索引遍历NumPy数组</h1><p id="fe56" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">减少处理时间的第三种方法是避免Pythonic循环，在这种循环中，一个变量由数组中的值逐个赋值。相反，只需使用索引遍历数组。这导致时间的大量减少。</p><h1 id="2847" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">4.禁用不必要的功能</h1><p id="5d7f" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">最后，您可以通过禁用Cython中为每个函数默认完成的一些检查来减少一些额外的毫秒数。这些包括“边界检查”和“回绕”禁用这些功能取决于您的具体需求。例如，如果使用负索引，则需要启用回绕功能。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="d028" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">本文原载于</strong> <a class="ae lb" href="https://blog.paperspace.com/faster-numpy-array-processing-ndarray-cython" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Paperspace博客</strong> </a> <strong class="jp ir">。你可以在渐变</strong>  <strong class="jp ir">上免费运行我的教程的代码</strong> <a class="ae lb" href="https://gradient.paperspace.com" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">。</strong></a></p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="7e7a" class="mi mj iq bd mk ml oi mn mo mp oj mr ms mt ok mv mw mx ol mz na nb om nd ne nf bi translated">结论</h1><p id="257c" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">本教程讨论了使用Cython操作NumPy数组，其速度是Python单独处理的5000倍以上。减少计算时间的关键是指定变量的数据类型，并对数组进行索引而不是迭代。</p><p id="0695" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一篇教程中，我们将通过使用Cython来减少遗传算法的<a class="ae lb" href="https://github.com/ahmedfgad/GeneticAlgorithmPython" rel="noopener ugc nofollow" target="_blank"> Python实现的计算时间，从而总结和推进我们迄今为止的知识。</a></p></div></div>    
</body>
</html>