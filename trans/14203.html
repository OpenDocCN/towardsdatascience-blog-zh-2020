<html>
<head>
<title>PostgreSQL 13 Features Distilled</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL 13特性精华</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/postgresql-13-features-distilled-c0c0adcfa020?source=collection_archive---------39-----------------------#2020-09-30">https://towardsdatascience.com/postgresql-13-features-distilled-c0c0adcfa020?source=collection_archive---------39-----------------------#2020-09-30</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/8dc4c92bd0341ac6834beae79db80c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_Kgf81uLZGkHKcunxNHhA.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated"><a class="ae jh" href="https://unsplash.com/@bepnamanh?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">南安</a>在<a class="ae jh" href="https://unsplash.com/s/photos/elephant?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h2 id="0991" class="ji jj jk bd b dl jl jm jn jo jp jq dk jr translated" aria-label="kicker paragraph">数据工程</h2><div class=""/><div class=""><h2 id="fd87" class="pw-subtitle-paragraph kq jt jk bd b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dk translated">PostgreSQL最新版本中的索引优化、增量排序、并行清空和更多最新特性</h2></div><p id="c02b" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> J </span>就在几周前，<a class="ae jh" href="https://linktr.ee/kovid" rel="noopener ugc nofollow" target="_blank">我写了关于MySQL 8.0在Google Cloud </a>上正式发布，在所有主要云平台上完成它的旅程。MySQL 8.0已经问世一段时间了。开源数据库社区急切地等待PostgreSQL的主发布版本13。PostgreSQL是仅次于MySQL的第二大流行的开源数据库，由于其固有的可扩展特性，它在所有地区和行业都被越来越多的人采用。随着AWS红移走上PostgreSQL路线，PostGIS中的世界级地理空间支持和令人惊叹的核心功能集，PostgreSQL几乎不是一个可以忽略的数据库。</p><p id="e45a" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">一周前，9月24日，PostgreSQL 13发布了。这个新版本有很多特性，但我们只介绍了PostgreSQL官方版本中列出的一些主要特性。</p><h1 id="0550" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">平行分度真空</h1><p id="b23f" class="pw-post-body-paragraph li lj jk lk b ll nf ku ln lo ng kx lq lr nh lt lu lv ni lx ly lz nj mb mc md in bi translated">清空是一个缓慢而乏味的过程，但与其他数据库不同，PostgreSQL使用它来回收磁盘上任何未使用的空间。当vacuum在任何给定的表上运行时，在该表上创建的索引也会被清空。PostgreSQL 13引入了一个特性，可以并行清空一个表上的多个索引。</p><p id="224c" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">可以使用名为<code class="fe nk nl nm nn b"><strong class="lk ju">max_parallel_maintenance_workers</strong></code>的数据库变量设置并行化的程度。这应该设置为表拥有的索引数。</p><p id="3000" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这一点，再加上<a class="ae jh" href="https://www.percona.com/blog/2020/09/10/index-improvements-in-postgresql-13/" rel="noopener ugc nofollow" target="_blank">许多其他索引改进</a>，使得这个版本的PostgreSQL 13更有吸引力。<a class="ae jh" href="https://eng.uber.com/postgres-to-mysql-migration/" rel="noopener ugc nofollow" target="_blank">也许优步终究会考虑搬回PostgreSQL，开个玩笑</a>！</p><p id="cceb" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">注:请注意，autovacuum尚不支持此功能。这里列出了对autovacuum的一些其他改进。</p><h1 id="9073" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">为查询优化器和规划器提供更好的统计数据</h1><p id="3109" class="pw-post-body-paragraph li lj jk lk b ll nf ku ln lo ng kx lq lr nh lt lu lv ni lx ly lz nj mb mc md in bi translated">我们所知道的关于优化器的一件事是，如果他们有更新和更好的关于表、索引、分区等的统计数据，他们会优化、计划和重写更好的查询。几年前，<a class="ae jh" href="https://pganalyze.com/blog/postgres13-better-performance-monitoring-usability#extended-statistics-improvements-in-postgres-13" rel="noopener ugc nofollow" target="_blank">随着PostgreSQL 10的发布，它引入了用户定义的自定义统计数据的概念，名为扩展统计数据</a>。使用扩展的统计数据，用户可以创建自己的统计数据来定义高级关系和依赖关系，以捕获行为统计数据并将其提供给优化器。</p><p id="6118" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">在PostgreSQL 13中，我们看到了更多的改进。以前，规划器只能使用一组定制的统计数据来规划和优化查询。用户可以通过<code class="fe nk nl nm nn b">OR</code>、<code class="fe nk nl nm nn b">IN</code>或<code class="fe nk nl nm nn b">ANY</code>子句使用多个统计数据。</p><h1 id="905b" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">增量排序</h1><p id="7c1f" class="pw-post-body-paragraph li lj jk lk b ll nf ku ln lo ng kx lq lr nh lt lu lv ni lx ly lz nj mb mc md in bi translated">在这个主要版本之前，如果您在一个表中有一个针对<code class="fe nk nl nm nn b">(column_1, column_2)</code>的索引，它将自己具体化为一个B树，并且您发出一个使用<code class="fe nk nl nm nn b">(column_1, column_2, column_3)</code>排序的查询，PostgreSQL不会使用现有的索引，该索引已经对where子句中的前两列的数据进行了排序。</p><p id="8419" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">在这个新版本中，这个问题已经得到了解决。现在，PostgreSQL不会对已经为列<code class="fe nk nl nm nn b">column_1</code>和<code class="fe nk nl nm nn b">column_2</code>排序的数据重新排序。在亚历山大·库兹曼科夫<a class="ae jh" href="https://www.postgresql.eu/events/pgconfeu2018/sessions/session/2124/slides/122/Towards%20more%20efficient%20query%20plans%20(2).pdf" rel="noopener ugc nofollow" target="_blank">的演讲中了解更多。</a></p><h1 id="452f" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">使用重复数据删除的b树成本优化</h1><p id="40d9" class="pw-post-body-paragraph li lj jk lk b ll nf ku ln lo ng kx lq lr nh lt lu lv ni lx ly lz nj mb mc md in bi translated">考虑一个您想要索引的表列，但是它有许多重复的值。在该列上创建索引时，所有值都绘制在索引的B树结构上。很多重复出现在你的索引中。这导致索引很大，并且索引的处理时间也很长。</p><blockquote class="no np nq"><p id="1caa" class="li lj nr lk b ll lm ku ln lo lp kx lq ns ls lt lu nt lw lx ly nu ma mb mc md in bi translated"><strong class="lk ju"> <em class="jk">主键或唯一索引</em> </strong> <em class="jk">显然不会发生这种情况——请参考</em><a class="nv nw ep" href="https://medium.com/u/2790f889fe05?source=post_page-----c0c0adcfa020--------------------------------" rel="noopener" target="_blank"><em class="jk">Andrew Kozin</em></a><em class="jk">对这篇帖子的评论，了解为什么这句话不成立。</em></p></blockquote><p id="692d" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">非唯一列上的索引对于聚合查询非常重要。为了从这些查询和数据库中获得更好的性能，PostgreSQL 13引入了一个新的重复值删除过程。PostgreSQL现在只保存对列值的引用，而不是存储所有重复的值。</p><p id="05e5" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">重复数据删除过程显然节省了大量空间，因为这是一个常见问题。节省空间的同时，也节省了在更大的索引上花费的额外处理时间。在这里了解更多关于B树实现的信息</p><div class="it iu gq gs iv nx"><a href="https://www.postgresql.org/docs/13/btree-implementation.html#BTREE-DEDUPLICATION" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fp"><div class="nz ab oa cl cj ob"><h2 class="bd ju gz z fq oc fs ft od fv fx jt bi translated">PostgreSQL:文档:13: 63.4。履行</h2><div class="oe l"><h3 class="bd b gz z fq oc fs ft od fv fx dk translated">本节涵盖了可能对高级用户有用的B树索引实现细节。看…</h3></div><div class="of l"><p class="bd b dl z fq oc fs ft od fv fx dk translated">www.postgresql.org</p></div></div><div class="og l"><div class="oh l oi oj ok og ol jb nx"/></div></div></a></div><h1 id="487a" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">聚合的性能优化</h1><p id="e53f" class="pw-post-body-paragraph li lj jk lk b ll nf ku ln lo ng kx lq lr nh lt lu lv ni lx ly lz nj mb mc md in bi translated">PostgreSQL 10引入的另一个特性是散列聚合。Postgres在聚合时有两个选项——散列或组。如果哈希表可以放在内存中，则使用哈希聚合。<a class="ae jh" href="https://info.crunchydata.com/blog/why-postgresql-13-is-a-lucky-release" rel="noopener ugc nofollow" target="_blank">在PostgreSQL 13 </a>之前，如果哈希表不适合内存，PostgreSQL只会选择组聚合。但是现在，在这个版本中，如果哈希表不适合内存，它将溢出到磁盘。</p><p id="d901" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">对于那些已经在使用PostgreSQL的人来说，如果你打算<a class="ae jh" href="https://www.percona.com/blog/2020/07/28/migrating-to-postgresql-version-13-incompatibilities-you-should-be-aware-of/" rel="noopener ugc nofollow" target="_blank">迁移到PostgreSQL 13 </a>，这里有一篇关于Percona博客的好文章。</p></div></div>    
</body>
</html>