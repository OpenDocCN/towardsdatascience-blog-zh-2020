<html>
<head>
<title>You Don’t Have to Use Docker Anymore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不用再用Docker了</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/its-time-to-say-goodbye-to-docker-5cfec8eff833?source=collection_archive---------0-----------------------#2020-10-15">https://towardsdatascience.com/its-time-to-say-goodbye-to-docker-5cfec8eff833?source=collection_archive---------0-----------------------#2020-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c871" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/opinion" rel="noopener" target="_blank">意见</a></h2><div class=""/><div class=""><h2 id="9b4f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Docker不是唯一的集装箱工具，可能会有更好的替代工具…</h2></div><p id="0e64" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在古代的集装箱时代(真的更像4年前)<em class="ln">码头工人</em>是集装箱游戏中唯一的玩家。但现在情况不同了，Docker不是唯一的T4，而是另一个容器引擎。Docker允许我们构建、运行、拉取、推送或检查容器图像，但对于这些任务中的每一项，都有其他替代工具，它们可能比Docker做得更好。所以，让我们探索一下前景，并且(仅仅是<em class="ln">也许是</em>)卸载并完全忘记Docker</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/0053a9212f47b73bff7935dde3073e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eIlOiySoCmfbrk1dLOXSfw.jpeg"/></div></div><p class="ma mb gj gh gi mc md bd b be z dk translated">照片由<a class="ae me" href="https://unsplash.com/@917sunny?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">妮可陈</a>在<a class="ae me" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="3856" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">为什么不使用Docker呢？</h1><p id="0052" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">如果你已经是docker用户很长时间了，我认为你需要一些说服来考虑转换到不同的工具。所以，现在开始:</p><p id="51f4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先，Docker是一个单体工具。它是一个尝试做所有事情的工具，这通常不是最好的方法。大多数情况下，最好选择一个专门的工具，它只能做一件事，而且做得很好。</p><p id="8edd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果您害怕切换到不同的工具集，因为您必须学习使用不同的CLI、不同的API或不同的概念，那么这不是问题。选择本文中显示的任何工具都可以是完全无缝的，因为它们都(包括Docker)遵循OCI下的相同规范，这是<a class="ae me" href="https://opencontainers.org/" rel="noopener ugc nofollow" target="_blank">开放容器倡议</a>的缩写。该计划包含<a class="ae me" href="https://github.com/opencontainers/runtime-spec" rel="noopener ugc nofollow" target="_blank">容器运行时</a>、<a class="ae me" href="https://github.com/opencontainers/distribution-spec" rel="noopener ugc nofollow" target="_blank">容器分发</a>和<a class="ae me" href="https://github.com/opencontainers/image-spec" rel="noopener ugc nofollow" target="_blank">容器映像</a>的规范，涵盖了使用容器所需的所有特性。</p><p id="cc7e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有了OCI，您可以选择一套最适合您需求的工具，同时您还可以享受使用与Docker相同的API和CLI命令的乐趣。</p><p id="ece8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所以，如果你愿意尝试新的工具，那么让我们比较一下Docker和它的竞争对手的优缺点和特性，看看是否真的有必要考虑放弃Docker而使用一些新的闪亮的工具。</p><h1 id="c2bb" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">集装箱发动机</h1><p id="0cf6" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">当将Docker与其他工具进行比较时，我们需要按组件对其进行分解，首先我们应该谈论的是<em class="ln">容器引擎</em>。Container engine是一个工具，它提供了处理图像和容器的用户界面，这样您就不必去弄乱诸如<code class="fe nc nd ne nf b">SECCOMP</code>规则或SELinux策略之类的东西。它的工作也是从远程存储库中提取图像，并将它们扩展到您的磁盘上。它看似运行容器，但实际上它的工作是创建容器清单和带有图像层的目录。然后它将它们传递给<em class="ln">容器运行时</em>，比如<code class="fe nc nd ne nf b">runc</code>或<code class="fe nc nd ne nf b">crun</code>(我们稍后会谈到)。</p><p id="468f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有许多容器引擎可用，但Docker最突出的竞争对手是由红帽开发的。与Docker不同，Podman不需要守护进程来运行，也不需要root权限，这是Docker长期关注的问题。根据名称，Podman不仅可以运行容器，还可以运行<em class="ln">pod</em>。如果您不熟悉pod的概念，那么pod是Kubernetes的最小计算单元。它由一个或多个容器组成——主容器和所谓的<em class="ln">侧容器</em>——执行支持任务。这使得Podman用户以后更容易将他们的工作负载迁移到Kubernetes。因此，作为一个简单的演示，这就是如何在一个单元中运行两个容器:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="663c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，Podman提供了与Docker完全相同的CLI命令，因此您可以只做<code class="fe nc nd ne nf b">alias docker=podman</code>并假装什么都没有改变。</p><p id="602d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">除了Docker和Podman，还有其他的容器引擎，但是我认为它们都是没有前途的技术，或者不适合本地开发和使用。但是为了有一个完整的画面，让我们至少提一下那里有什么:</p><ul class=""><li id="1156" class="ni nj it kt b ku kv kx ky la nk le nl li nm lm nn no np nq bi translated"><a class="ae me" href="https://linuxcontainers.org/lxd/introduction/" rel="noopener ugc nofollow" target="_blank">LXD</a>——LXD是LXC (Linux容器)的容器管理器(守护程序)。这个工具提供了运行<em class="ln">系统</em>容器的能力，这些容器提供了更类似于虚拟机的容器环境。它位于非常狭窄的空间，没有很多用户，所以除非你有非常具体的用例，那么你可能最好使用Docker或Podman。</li><li id="db6b" class="ni nj it kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated">CRI-O  —当你在谷歌上搜索什么是CRI-O时，你可能会发现它被描述为容器引擎。不过，它确实是容器运行时。除了它实际上不是一台发动机之外，它也不适合<em class="ln"/>的“正常”使用。我的意思是，它是专门为用作Kubernetes运行时(CRI)而构建的，而不是供最终用户使用的。</li><li id="fc87" class="ni nj it kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated"><a class="ae me" href="https://coreos.com/rkt/" rel="noopener ugc nofollow" target="_blank"> rkt </a> — rkt ( <em class="ln">“火箭”</em>)是由<em class="ln"> CoreOS </em>研发的集装箱发动机。这里提到这个项目实际上只是为了完整性，因为项目结束了，它的开发也停止了——因此它不应该被使用。</li></ul><h1 id="41ce" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">建筑图像</h1><p id="75de" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">对于容器引擎，除了Docker，真的只有一种选择。当涉及到构建图像时，我们有更多的选择。</p><p id="f8c0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先，我来介绍一下<a class="ae me" href="https://buildah.io/" rel="noopener ugc nofollow" target="_blank"> Buildah </a>。Buildah是由Red Hat开发的另一个工具，它与Podman配合得非常好。如果您已经安装了Podman，您甚至可能已经注意到了<code class="fe nc nd ne nf b">podman build</code>子命令，它实际上只是Buildah的伪装，因为它的二进制文件包含在Podman中。</p><p id="317f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">至于它的功能，它遵循与Podman相同的路线——它是无后台和无根的，并生成OCI兼容的图像，因此它保证您的图像将与用Docker构建的图像以相同的方式运行。它还可以从<code class="fe nc nd ne nf b">Dockerfile</code>或者(更恰当的名称)<code class="fe nc nd ne nf b">Containerfile</code>构建图像，这是不同名称的同一事物。除此之外，Buildah还提供了对图像层的更好的控制，允许您将许多更改提交到单个层中。与Docker一个意想不到但(在我看来)很好的区别是，Buildah构建的图像是特定于用户的，因此您将只能列出您自己构建的图像。</p><p id="8ae7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，考虑到Buildah已经包含在Podman CLI中，您可能会问为什么还要使用单独的<code class="fe nc nd ne nf b">buildah</code> CLI？嗯，<code class="fe nc nd ne nf b">buildah</code> CLI是<code class="fe nc nd ne nf b">podman build</code>中包含的命令的超集，所以你可能不需要接触<code class="fe nc nd ne nf b">buildah</code> CLI，但是通过使用它，你可能还会发现一些额外的有用特性(关于<code class="fe nc nd ne nf b">podman build</code>和<code class="fe nc nd ne nf b">buildah</code>之间的具体区别，请参见下面的<a class="ae me" href="https://podman.io/blogs/2018/10/31/podman-buildah-relationship.html" rel="noopener ugc nofollow" target="_blank">文章</a>)。</p><p id="c105" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">说到这里，让我们来看一个小演示:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ee4b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从上面的脚本中可以看到，您可以简单地使用<code class="fe nc nd ne nf b">buildah bud</code>构建映像，其中<code class="fe nc nd ne nf b">bud</code>代表<em class="ln">使用Dockerfile </em>构建，但是您也可以使用更多的脚本化方法，使用Buildahs <code class="fe nc nd ne nf b">from</code>、<code class="fe nc nd ne nf b">run</code>和<code class="fe nc nd ne nf b">copy</code>，它们是Dockerfile中的命令(<code class="fe nc nd ne nf b">FROM image</code>、<code class="fe nc nd ne nf b">RUN ...</code>、<code class="fe nc nd ne nf b">COPY ...</code>)的等价命令。</p><p id="c3df" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">接下来是谷歌的<a class="ae me" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>。Kaniko也从Dockerfile构建容器映像，与Buildah类似，它也不需要守护进程。与Buildah的主要区别是Kaniko更关注Kubernetes中的建筑图像。</p><p id="0e30" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">Kaniko应该作为一个映像运行，使用<code class="fe nc nd ne nf b">gcr.io/kaniko-project/executor</code>，这对于Kubernetes来说是有意义的，但是对于本地构建来说不太方便，而且有点违背了初衷，因为您需要使用Docker来运行Kaniko image来构建您的映像。也就是说，如果您正在寻找在Kubernetes集群中构建映像的工具(例如在CI/CD管道中)，那么Kaniko可能是一个不错的选择，因为它是无后台的，而且(<a class="ae me" href="https://github.com/GoogleContainerTools/kaniko#security" rel="noopener ugc nofollow" target="_blank">也许</a>)更加安全。</p><p id="1531" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从我的个人经验来看，我使用Kaniko和Buildah在Kubernetes/OpenShift集群中构建图像，我认为两者都能很好地完成工作，但是在Kaniko中，当将图像推送到注册表时，我看到了一些随机构建崩溃和失败。</p><p id="3c72" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里的第三个竞争者是<a class="ae me" href="https://github.com/moby/buildkit" rel="noopener ugc nofollow" target="_blank"> buildkit </a>，也可以称为<em class="ln">下一代</em> <code class="fe nc nd ne nf b">docker build</code>。它是<em class="ln">莫比</em>项目的一部分(Docker也是如此),可以使用<code class="fe nc nd ne nf b">DOCKER_BUILDKIT=1 docker build ...</code>通过Docker作为实验特性来启用。好吧，但这到底能给你带来什么？它引入了许多改进和很酷的特性，包括并行构建步骤、跳过未使用的阶段、更好的增量构建和无根构建。然而另一方面，它仍然需要守护进程来运行(<code class="fe nc nd ne nf b">buildkitd</code>)。所以，如果你不想摆脱Docker，而是想要一些新的特性和不错的改进，那么使用buildkit可能是一个不错的选择。</p><p id="8f8e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">与上一节一样，这里我们也有一些<em class="ln">“荣誉奖”</em>，它们填补了一些非常具体的用例，但不是我的首选:</p><ul class=""><li id="086c" class="ni nj it kt b ku kv kx ky la nk le nl li nm lm nn no np nq bi translated"><a class="ae me" href="https://github.com/openshift/source-to-image" rel="noopener ugc nofollow" target="_blank"> Source-To-Image (S2I) </a>是一个不用Dockerfile直接从源代码构建图像的工具包。这个工具对于简单的、预期的场景和工作流工作得很好，但是如果你需要太多的定制或者如果你的项目没有预期的布局，它很快就会变得令人讨厌和笨拙。如果您对Docker还不是很有信心，或者如果您在OpenShift集群上构建您的映像，您可以考虑使用S2I，因为使用S2I构建是一个内置特性。</li><li id="487c" class="ni nj it kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated"><a class="ae me" href="https://github.com/GoogleContainerTools/jib" rel="noopener ugc nofollow" target="_blank"> Jib </a>是谷歌的另一个工具，专门用于构建Java映像。它包括<a class="ae me" href="https://github.com/GoogleContainerTools/jib/tree/master/jib-maven-plugin#quickstart" rel="noopener ugc nofollow" target="_blank"> Maven </a>和<a class="ae me" href="https://github.com/GoogleContainerTools/jib/tree/master/jib-gradle-plugin#quickstart" rel="noopener ugc nofollow" target="_blank"> Gradle </a>插件，可以让你轻松构建图像，而不需要弄乱docker文件。</li><li id="7990" class="ni nj it kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated">最后但同样重要的是<a class="ae me" href="https://github.com/bazelbuild/bazel" rel="noopener ugc nofollow" target="_blank"> Bazel </a>，这是谷歌的另一个工具。这不仅仅是为了构建容器映像，而是一个完整的构建系统。如果你<em class="ln">只是</em>想要建立一个形象，那么深入Bazel可能有点矫枉过正，但绝对是一个很好的学习经历，所以如果你准备好了，那么<a class="ae me" href="https://github.com/bazelbuild/rules_docker" rel="noopener ugc nofollow" target="_blank"> rules_docker </a>部分对你来说是一个很好的起点。</li></ul><h1 id="1adc" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">容器运行时</h1><p id="6ae1" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">最后一大难题是<em class="ln">容器运行时</em>，它负责运行容器。容器运行时是整个容器生命周期/堆栈的一部分，除非您对速度、安全性等有非常具体的要求，否则您很可能不会去弄乱它。所以，如果你已经厌倦了我，那么你可能想跳过这一节。另一方面，如果你只是想知道有哪些选择，那就这样:</p><p id="b187" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">runc是基于OCI容器运行时规范创建的最流行的容器运行时。它被Docker(通过<em class="ln"> containerd </em>)、Podman和CRI-O使用，所以除了LXD(使用LXC)之外，它几乎什么都用。我没有什么可以补充的了。它是(几乎)所有东西的默认设置，所以即使你在读完这篇文章后放弃了Docker，你也很可能仍然会使用runc。</p><p id="0476" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">runc的一个替代物被类似地(并且令人困惑地)命名为<a class="ae me" href="https://github.com/containers/crun" rel="noopener ugc nofollow" target="_blank"> crun </a>。这是Red Hat开发的工具，完全用C编写(runc用Go编写)。这使得它比runc更快，内存效率更高。考虑到它也是OCI兼容的运行时，如果你想自己检查的话，你应该可以很容易地切换到它。尽管它现在不是很受欢迎，但它将作为RHEL 8.3版本的替代OCI运行时出现在技术预览版中，并考虑到它是我们最终可能会看到的Podman或CRI-O的默认红帽产品</p><p id="c7d6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">说到CRI-O，我之前说过CRI-O不是真正的容器引擎，而是容器运行时。这是因为CRI-O不包括像推送图像这样的功能，而这正是你对容器引擎的期望。CRI-O作为一个运行时在内部使用runc来运行容器。这个运行时不是您应该尝试在您的机器上使用的运行时，因为它被构建为在Kubernetes节点上用作运行时，您可以看到它被描述为<em class="ln">“Kubernetes需要的所有运行时，仅此而已”</em>。因此，除非您正在设置Kubernetes集群(或者OpenShift集群——CRI-O已经是默认的),否则您可能不应该接触这个集群。</p><p id="3a84" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这部分的最后一个是<a class="ae me" href="https://containerd.io/" rel="noopener ugc nofollow" target="_blank"> containerd </a>，是CNCF的毕业设计。它是一个守护进程，充当各种容器运行时和操作系统的API门面。在后台，它依赖于runc，并且是Docker引擎的默认运行时。它也被Google Kubernetes引擎(GKE)和IBM Kubernetes服务(IKS)使用。它是Kubernetes容器运行时接口的一个实现(与CRI-O相同)，因此它是Kubernetes集群运行时的一个很好的候选。</p><h1 id="51f7" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">图像检查和分发</h1><p id="552c" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">集装箱堆栈的最后一部分是图像检查和分发。这有效地取代了<code class="fe nc nd ne nf b">docker inspect</code>，并且(可选地)增加了在远程注册中心之间复制/镜像映像的能力。</p><p id="0106" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我在这里提到的唯一可以完成这些任务的工具是Skopeo。它是由Red Hat制作的，是Buildah、Podman和CRI-O的配套工具。除了我们都从Docker了解的基本<code class="fe nc nd ne nf b">skopeo inspect</code>之外，Skopeo还能够使用<code class="fe nc nd ne nf b">skopeo copy</code>复制图像，这允许您在远程注册表之间镜像图像，而无需首先将它们拖到本地注册表。如果您使用本地注册表，此功能也可以作为拉/推。</p><p id="8531" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">作为一个小奖励，我还想提一下<a class="ae me" href="https://github.com/wagoodman/dive" rel="noopener ugc nofollow" target="_blank"> Dive </a>，这是一个检查、探索和分析图像的工具。它对用户更友好，提供更可读的输出，并且可以更深入地挖掘(或者我猜是<em class="ln">潜入</em>)你的图像，分析和衡量它的效率。它也适用于CI管道，可以衡量你的图像是否<em class="ln">【足够高效】</em>或者换句话说——是否浪费了太多空间。</p><h1 id="5b98" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">结论</h1><p id="ea11" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">本文并不是要说服您完全放弃Docker，而是向您展示构建、运行、管理和分发容器及其映像的整体情况和所有选项。包括Docker在内的每一种工具都有其优点和缺点，评估哪一套工具最适合您的工作流和用例非常重要，我希望这篇文章能帮助您。</p><h2 id="1277" class="nw mg it bd mh nx ny dn ml nz oa dp mp la ob oc mr le od oe mt li of og mv iz bi translated">资源</h2><ul class=""><li id="3f7f" class="ni nj it kt b ku mx kx my la oh le oi li oj lm nn no np nq bi translated">让我们尝试一下Kubernetes可用的每一个CRI运行时。不，真的！</li><li id="1cc5" class="ni nj it kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated"><a class="ae me" href="https://events19.linuxfoundation.org/wp-content/uploads/2017/11/How-Container-Runtime-Matters-in-Kubernetes_-OSS-Kunal-Kushwaha.pdf" rel="noopener ugc nofollow" target="_blank">在Kubernetes中，容器运行时有多重要？</a></li><li id="2ede" class="ni nj it kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated"><a class="ae me" href="https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction" rel="noopener ugc nofollow" target="_blank">集装箱术语实用介绍</a></li><li id="cd2e" class="ni nj it kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated"><a class="ae me" href="https://events19.linuxfoundation.org/wp-content/uploads/2017/11/Comparing-Next-Generation-Container-Image-Building-Tools-OSS-Akihiro-Suda.pdf" rel="noopener ugc nofollow" target="_blank">比较下一代容器映像构建工具</a></li><li id="af4a" class="ni nj it kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated"><a class="ae me" href="https://www.capitalone.com/tech/cloud/container-runtime/" rel="noopener ugc nofollow" target="_blank">全面的容器运行时比较</a></li><li id="bf32" class="ni nj it kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated"><a class="ae me" href="https://blog.alexellis.io/building-containers-without-docker/" rel="noopener ugc nofollow" target="_blank">建造没有码头工人的集装箱</a></li></ul></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="193f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">本文最初发布于</em><a class="ae me" href="https://martinheinz.dev/blog/35?utm_source=tds&amp;utm_medium=referral&amp;utm_campaign=blog_post_35" rel="noopener ugc nofollow" target="_blank"><em class="ln">martinheinz . dev</em></a></p><div class="or os gp gr ot ou"><a rel="noopener follow" target="_blank" href="/deploy-any-python-project-to-kubernetes-2c6ad4d41f14"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jd gy z fp oz fr fs pa fu fw jc bi translated">将任何Python项目部署到Kubernetes</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">是时候深入Kubernetes，使用这个成熟的项目模板将您的Python项目带到云中了！</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ly ou"/></div></div></a></div><div class="or os gp gr ot ou"><a rel="noopener follow" target="_blank" href="/analyzing-docker-image-security-ed5cf7e93751"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jd gy z fp oz fr fs pa fu fw jc bi translated">分析Docker图像安全性</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">码头集装箱远没有你想象的那么安全…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi ly ou"/></div></div></a></div><div class="or os gp gr ot ou"><a rel="noopener follow" target="_blank" href="/all-the-things-you-can-do-with-github-api-and-python-f01790fca131"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jd gy z fp oz fr fs pa fu fw jc bi translated">你可以用GitHub API和Python做的所有事情</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">GitHub REST API允许您管理问题、分支、回购、提交等等，所以让我们看看您如何使用…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pk l pf pg ph pd pi ly ou"/></div></div></a></div></div></div>    
</body>
</html>