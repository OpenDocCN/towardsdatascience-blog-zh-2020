<html>
<head>
<title>Implementing a Naive Bayes Classifier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现朴素贝叶斯分类器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-a-naive-bayes-classifier-f206805a95fd?source=collection_archive---------19-----------------------#2020-10-08">https://towardsdatascience.com/implementing-a-naive-bayes-classifier-f206805a95fd?source=collection_archive---------19-----------------------#2020-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1a40" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Python中使用真实世界的数据集</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f38edb1eeefde644cf4faab960b558ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSw-njRsFwVlqbTElIX8oQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·Ku在<a class="ae ky" href="https://unsplash.com/s/photos/machine-learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b2b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">在</span>的<a class="ae ky" rel="noopener" target="_blank" href="/basics-of-supervised-learning-classification-d26c00d80100">监督学习(分类)</a>的背景下，朴素贝叶斯或者更确切地说贝叶斯学习作为评估其他学习算法的黄金标准，同时作为一种强大的概率建模技术。</p><p id="518a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将讨论<a class="ae ky" rel="noopener" target="_blank" href="/understanding-naive-bayes-classifier-46385aca47ec">朴素贝叶斯分类器</a>的工作原理，通过将它应用于真实世界的数据集，用Python实现。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="1dc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> T </span>岗位更宽泛地分为以下几个部分:</p><ul class=""><li id="3a60" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mq mr ms mt bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/data-preprocessing-in-python-b52b652e37d5">数据预处理</a></li><li id="7bda" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">训练模型</li><li id="7792" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">预测结果</li><li id="8b7c" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">检查模型的性能</li></ul><p id="a4f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述部分可以进一步划分如下:</p><p id="1a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">→ <a class="ae ky" rel="noopener" target="_blank" href="/data-preprocessing-in-python-b52b652e37d5">数据预处理</a></p><ol class=""><li id="febe" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mz mr ms mt bi translated">导入库</li><li id="ba37" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mz mr ms mt bi translated">导入数据集</li><li id="6d05" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mz mr ms mt bi translated">将数据集分成训练集和测试集</li><li id="089d" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mz mr ms mt bi translated">特征缩放</li></ol><p id="9a73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">→训练模型</p><ol class=""><li id="897b" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mz mr ms mt bi translated">在训练集上训练朴素贝叶斯模型</li></ol><p id="9ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">→预测结果</p><ol class=""><li id="2561" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mz mr ms mt bi translated">预测测试集结果</li></ol><p id="de90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">→检查模型的性能</p><ol class=""><li id="9a28" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mz mr ms mt bi translated">制作混淆矩阵</li></ol><p id="a5ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">→可视化</p><ol class=""><li id="4b26" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mz mr ms mt bi translated">可视化混淆矩阵</li></ol></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="3cff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">在我们开始深入研究代码本身之前，我们需要谈谈数据集本身。对于这个实现，我们将使用<a class="ae ky" href="https://scikit-learn.org/stable/datasets/index.html#newsgroups-dataset" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">这20个新闻组的文本数据集</strong> </a> <strong class="lb iu">。</strong>这个数据集是公开的，目的是人们可以学习和磨练他们的<a class="ae ky" rel="noopener" target="_blank" href="/understanding-naive-bayes-classifier-46385aca47ec">机器学习</a>技能。</p><p id="bc7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用scikit-learn (sklearn)作为机器学习库和数据集本身的存储库。这就是<strong class="lb iu"> sklearn的</strong>网站告诉你的数据集。</p><blockquote class="na"><p id="9f8e" class="nb nc it bd nd ne nf ng nh ni nj lu dk translated">20个新闻组数据集包含大约18000个关于20个主题的新闻组帖子，分为两个子集:一个用于培训(或开发)，另一个用于测试(或性能评估)。训练集和测试集之间的划分基于在特定日期之前和之后发布的消息。</p></blockquote><h2 id="797c" class="nk nl it bd nm nn no dn np nq nr dp ns li nt nu nv lm nw nx ny lq nz oa ob oc bi translated">数据集特征:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/9a6a01f897a35a94b46a078adbe98e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*yXBRgeQpXnLVqlIjCtqyww.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://scikit-learn.org/stable/datasets/index.html#newsgroups-dataset" rel="noopener ugc nofollow" target="_blank">https://scikit-learn . org/stable/datasets/index . html # news groups-dataset</a></p></figure><blockquote class="oe of og"><p id="9b5f" class="kz la oh lb b lc ld ju le lf lg jx lh oi lj lk ll oj ln lo lp ok lr ls lt lu im bi translated">注意:由于原始数据是自然语言文本，我们不能直接处理它。在开始处理数据之前，我们需要将数据转换成数字。有多种方法可以做到这一点，即:</p><p id="cd7e" class="kz la oh lb b lc ld ju le lf lg jx lh oi lj lk ll oj ln lo lp ok lr ls lt lu im bi translated"><a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html#sklearn.feature_extraction.text.CountVectorizer" rel="noopener ugc nofollow" target="_blank">计数矢量器</a></p><p id="7f70" class="kz la oh lb b lc ld ju le lf lg jx lh oi lj lk ll oj ln lo lp ok lr ls lt lu im bi translated"><a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html#sklearn.feature_extraction.text.TfidfVectorizer" rel="noopener ugc nofollow" target="_blank">tfidf矢量器</a></p><p id="fd01" class="kz la oh lb b lc ld ju le lf lg jx lh oi lj lk ll oj ln lo lp ok lr ls lt lu im bi translated"><a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.HashingVectorizer.html#sklearn.feature_extraction.text.HashingVectorizer" rel="noopener ugc nofollow" target="_blank">哈希矢量器</a></p><p id="5062" class="kz la oh lb b lc ld ju le lf lg jx lh oi lj lk ll oj ln lo lp ok lr ls lt lu im bi translated">选择矢量器取决于解决方案的设计者和问题本身。出于本文的目的，我将使用CountVectorizer。我已经为所有矢量器提供了sklearn文档的链接。你当然可以在那里和网上详细看看。</p></blockquote></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="67aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">现在，我们已经谈了一点数据集，让我们从代码本身开始，一步一步来。</p><h2 id="b13e" class="nk nl it bd nm nn ol dn np nq om dp ns li on nu nv lm oo nx ny lq op oa ob oc bi translated">→ <a class="ae ky" rel="noopener" target="_blank" href="/data-preprocessing-in-python-b52b652e37d5">数据预处理</a></h2><ol class=""><li id="200c" class="ml mm it lb b lc oq lf or li os lm ot lq ou lu mz mr ms mt bi translated">导入库</li></ol><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="1c54" class="nk nl it ow b gy pa pb l pc pd">from sklearn.datasets import fetch_20newsgroups<br/>from sklearn.feature_extraction.text import CountVectorizer<br/>from sklearn.naive_bayes import GaussianNB<br/>from sklearn.metrics import confusion_matrix, plot_confusion_matrix<br/>import matplotlib.pyplot as plt</span></pre><p id="c53b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述库的使用/要求(按顺序解释)如下:</p><p id="6845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">a)从sklearn本身导入数据集</p><p id="3263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">b)导入计数矢量器以将原始自然语言文本转换成机器可理解的数字</p><p id="7124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">c)导入<a class="ae ky" rel="noopener" target="_blank" href="/understanding-naive-bayes-classifier-46385aca47ec">朴素贝叶斯分类器</a>，在这种情况下，我们使用<a class="ae ky" rel="noopener" target="_blank" href="/continuous-data-and-zero-frequency-problem-in-naive-bayes-classifier-7784f4066b51">高斯朴素贝叶斯</a></p><p id="ba9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">d)引入混淆矩阵方法来检查模型的性能并将其可视化。</p><p id="8f4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">e)用于混淆矩阵的可视化</p><p id="2b2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2 &amp; 3.导入数据集并将数据集分成训练集和测试集</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="88f7" class="nk nl it ow b gy pa pb l pc pd">data_train = fetch_20newsgroups(subset='train', categories=None,<br/>                                remove=('headers', 'footers',       <br/>                                'quotes'))</span><span id="1f79" class="nk nl it ow b gy pe pb l pc pd">data_test = fetch_20newsgroups(subset='test', categories=None,<br/>                               remove=('headers', 'footers', <br/>                               'quotes'))</span><span id="5460" class="nk nl it ow b gy pe pb l pc pd">X_train = data_train.data<br/>y_train = data_train.target</span><span id="156e" class="nk nl it ow b gy pe pb l pc pd">X_test = data_test.data<br/>y_test = data_test.target</span></pre><p id="cfdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe pf pg ph ow b">data_train</code>包含来自数据本身的训练集。<code class="fe pf pg ph ow b">fetch_20newsgroups</code>中传递的参数可以理解为:</p><p id="2e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">I)子集-定义训练或测试集</p><p id="bf82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ii)类别—数据集包含20个<a class="ae ky" rel="noopener" target="_blank" href="/journey-into-data-mining-3b5ccfa5343">类别或分类标签</a>。通过在参数中提供以下类别的列表，可以使用数据集的子集:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="5a15" class="nk nl it ow b gy pa pb l pc pd">from pprint import pprint<br/>pprint(list(newsgroups_train.target_names))</span></pre><p id="579c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是:</p><blockquote class="oe of og"><p id="373e" class="kz la oh lb b lc ld ju le lf lg jx lh oi lj lk ll oj ln lo lp ok lr ls lt lu im bi translated">['alt .无神论'，<br/> 'comp.graphics '，<br/> 'comp.os.ms-windows.misc '，<br/> 'comp.sys.ibm.pc.hardware '，<br/> 'comp.sys.mac.hardware '，<br/> 'comp.windows.x '，<br/> 'misc.forsale '，<br/> 'rec.autos '，<br/>' rec . motors '，<br/> 'rec.sport.baseball '，<br/> 'rec</p></blockquote><p id="adc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iii)移除—数据集中的文本包含页眉、页脚和引号，但我们希望对数据主体应用模型。</p><p id="9b27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过调用<code class="fe pf pg ph ow b">data_train</code>和<code class="fe pf pg ph ow b">data_test</code>上的<code class="fe pf pg ph ow b">.data</code>和<code class="fe pf pg ph ow b">.target</code>可以分离自变量和因变量，得到分叉的训练和测试数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/788a1f870c75e9da4e97f1c954a548bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qIaJ0dPb2FXsKIaGhY5NNA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类别/y_train</p></figure><p id="6b52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数组中的值表示上述类别列表的索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/f9d03202f654105492e2c3083aa681bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*63X87cuWWMXZyDCw7r7w1Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在应用CountVectorizer之前进行X_train</p></figure><p id="6b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.特征缩放</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="8908" class="nk nl it ow b gy pa pb l pc pd">vectorizer = CountVectorizer()<br/>X_train = vectorizer.fit_transform(X_train)<br/>X_test = vectorizer.transform(X_test)</span></pre><p id="c0c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建CountVectorizer类的对象，然后在<code class="fe pf pg ph ow b">X_train</code>和<code class="fe pf pg ph ow b">X_test</code>数据上拟合矢量器对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/63805574b94583af51b3af3cfd00ee64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXLldynULR5OsDtPXQZb7A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用计数矢量器后的X_train</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="dbbf" class="nk nl it bd nm nn ol dn np nq om dp ns li on nu nv lm oo nx ny lq op oa ob oc bi translated">→训练模型</h2><ol class=""><li id="f866" class="ml mm it lb b lc oq lf or li os lm ot lq ou lu mz mr ms mt bi translated">在训练集上训练朴素贝叶斯模型</li></ol><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="3177" class="nk nl it ow b gy pa pb l pc pd">classifier = GaussianNB()<br/>classifier.fit(X_train.toarray(), y_train)</span></pre><p id="0b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">制作GaussianNB类的对象，然后根据<code class="fe pf pg ph ow b">X_train</code>和<code class="fe pf pg ph ow b">y_train </code>数据拟合分类器对象。这里的<code class="fe pf pg ph ow b">.toarray()</code>与<code class="fe pf pg ph ow b">X_train</code>用于将稀疏矩阵转换为密集矩阵。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="b7ba" class="nk nl it bd nm nn ol dn np nq om dp ns li on nu nv lm oo nx ny lq op oa ob oc bi translated">→预测结果</h2><ol class=""><li id="9dae" class="ml mm it lb b lc oq lf or li os lm ot lq ou lu mz mr ms mt bi translated">预测测试集结果</li></ol><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="846f" class="nk nl it ow b gy pa pb l pc pd">y_pred = classifier.predict(X_test.toarray())</span></pre><p id="8b03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在分类器对象上调用<code class="fe pf pg ph ow b">.predict</code>方法，并传递<code class="fe pf pg ph ow b">X_test</code>来预测之前未见过的数据上的训练模型的结果。这里的<code class="fe pf pg ph ow b">.toarray()</code>与<code class="fe pf pg ph ow b">X_test</code>用于将稀疏矩阵转换为密集矩阵。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="9d63" class="nk nl it bd nm nn ol dn np nq om dp ns li on nu nv lm oo nx ny lq op oa ob oc bi translated">→检查模型的性能</h2><ol class=""><li id="ffa2" class="ml mm it lb b lc oq lf or li os lm ot lq ou lu mz mr ms mt bi translated">制作混淆矩阵</li></ol><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="ca09" class="nk nl it ow b gy pa pb l pc pd">cm = confusion_matrix(y_test, y_pred)<br/>print(cm)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/11f2c666a122dfd0fffe211a05f63705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*4RZH8JrEuqMOnzhAJui83Q.png"/></div></figure><h2 id="90d2" class="nk nl it bd nm nn ol dn np nq om dp ns li on nu nv lm oo nx ny lq op oa ob oc bi translated">→可视化</h2><ol class=""><li id="0cd4" class="ml mm it lb b lc oq lf or li os lm ot lq ou lu mz mr ms mt bi translated">可视化混淆矩阵</li></ol><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="950a" class="nk nl it ow b gy pa pb l pc pd">plot_confusion_matrix(classifier, X_test.toarray(), y_test, display_labels=['alt.atheism',<br/> 'comp.graphics',<br/> 'comp.os.ms-windows.misc',<br/> 'comp.sys.ibm.pc.hardware'], cmap=plt.cm.Blues)</span></pre><p id="49c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了形象化的目的，我把类别的数量限制在4个，这样它就能被正确地看到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/52bf1b61e1ef150f4b0c0518440e20f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*GbM5-m29pGaE4hDIoS6GsQ.png"/></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="697b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，机器学习模型的整个管道已经完成，我希望我能够分享一些知识。这是一个非常基本的机器学习管道，但当你想建立更好更复杂的机器学习模型时，它在建立基础方面相当重要。我希望在未来带来更多动态和复杂的模型，敬请期待。</p><p id="81f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个<a class="ae ky" href="https://github.com/tarunlnmiit/machine_learning/blob/master/naive_bayes-20newsgroup.ipynb" rel="noopener ugc nofollow" target="_blank">链接</a>到完整的jupyter笔记本。</p><div class="pn po gp gr pp pq"><a href="https://github.com/tarunlnmiit/machine_learning/blob/master/naive_bayes-20newsgroup.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd iu gy z fp pv fr fs pw fu fw is bi translated">tarunlnmiti/机器学习</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">permalink dissolve GitHub是超过5000万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">github.com</p></div></div><div class="pz l"><div class="qa l qb qc qd pz qe ks pq"/></div></div></a></div></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="6e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://colossal-hustler-1290.ck.page/c717067eb6" rel="noopener ugc nofollow" target="_blank">我正在免费赠送一本关于一致性的电子书。在这里获得你的免费电子书。</a></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="500f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p><p id="91b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢阅读这样的故事，并想支持我成为一名作家，可以考虑<a class="ae ky" href="https://tarun-gupta.medium.com/membership" rel="noopener">注册成为一名媒体成员</a>。每月5美元，你可以无限制地阅读媒体上的故事。如果你注册使用我的链接，我会赚一小笔佣金，不需要你额外付费。</p><div class="pn po gp gr pp pq"><a href="https://tarun-gupta.medium.com/membership" rel="noopener follow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd iu gy z fp pv fr fs pw fu fw is bi translated">加入我的推荐链接-塔伦古普塔</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">tarun-gupta.medium.com</p></div></div><div class="pz l"><div class="qf l qb qc qd pz qe ks pq"/></div></div></a></div></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="1ad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里阅读我的更多帖子:</p><div class="pn po gp gr pp pq"><a href="https://tarun-gupta.medium.com/thank-you-for-visiting-my-profile-9f708062c75e" rel="noopener follow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd iu gy z fp pv fr fs pw fu fw is bi translated">标记故事列表的快速链接—感谢您的访问</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">我也有一份以快节奏出版为目标的出版物。读书成为作家。</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">tarun-gupta.medium.com</p></div></div></div></a></div></div></div>    
</body>
</html>